[
    {
        "title": "Next Greater Numerically Balanced Number",
        "question_content": "An integer x is numerically balanced if for every digit d in the number x, there are exactly d occurrences of that digit in x.\nGiven an integer n, return the smallest numerically balanced number strictly greater than n.\n&nbsp;\nExample 1:\n\nInput: n = 1\nOutput: 22\nExplanation: \n22 is numerically balanced since:\n- The digit 2 occurs 2 times. \nIt is also the smallest numerically balanced number strictly greater than 1.\n\nExample 2:\n\nInput: n = 1000\nOutput: 1333\nExplanation: \n1333 is numerically balanced since:\n- The digit 1 occurs 1 time.\n- The digit 3 occurs 3 times. \nIt is also the smallest numerically balanced number strictly greater than 1000.\nNote that 1022 cannot be the answer because 0 appeared more than 0 times.\n\nExample 3:\n\nInput: n = 3000\nOutput: 3133\nExplanation: \n3133 is numerically balanced since:\n- The digit 1 occurs 1 time.\n- The digit 3 occurs 3 times.\nIt is also the smallest numerically balanced number strictly greater than 3000.\n\n&nbsp;\nConstraints:\n\n\t0 <= n <= 106",
        "solutions": [
            {
                "id": 1537485,
                "title": "fastest-code-so-far",
                "content": "```\\nclass Solution {\\npublic:\\n    int nextBeautifulNumber(int n) {\\n//        please run this on you local for preparation.\\n//        vector<int> all;\\n//        for (int i = 0; i <= 1224444; ++i) {\\n//            int v = i;\\n//            unordered_map<int, int> m;\\n//            while (v > 0) {\\n//                ++m[v % 10];\\n//                v /= 10;\\n//            }\\n//            for (auto& p : m) {\\n//                if (p.first != p.second) goto L;\\n//            }\\n//            all.push_back(i);\\n//        L:\\n//            ;\\n//        }\\n        static vector<int> all {\\n            0, 1, 22, 122, 212, 221, 333, 1333, 3133, 3313, 3331, 4444, 14444, \\n            22333, 23233, 23323, 23332, 32233, 32323, 32332, 33223, 33232, \\n            33322, 41444, 44144, 44414, 44441, 55555, 122333, 123233, 123323,\\n            123332, 132233, 132323, 132332, 133223, 133232, 133322, 155555, \\n            212333, 213233, 213323, 213332, 221333, 223133, 223313, 223331, \\n            224444, 231233, 231323, 231332, 232133, 232313, 232331, 233123, \\n            233132, 233213, 233231, 233312, 233321, 242444, 244244, 244424, \\n            244442, 312233, 312323, 312332, 313223, 313232, 313322, 321233,\\n            321323, 321332, 322133, 322313, 322331, 323123, 323132, 323213,\\n            323231, 323312, 323321, 331223, 331232, 331322, 332123, 332132, \\n            332213, 332231, 332312, 332321, 333122, 333212, 333221, 422444, \\n            424244, 424424, 424442, 442244, 442424, 442442, 444224, 444242,\\n            444422, 515555, 551555, 555155, 555515, 555551, 666666, 1224444,\\n        };\\n        return *upper_bound(all.begin(), all.end(), n);\\n    }\\n};\\n```\\n",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int nextBeautifulNumber(int n) {\\n//        please run this on you local for preparation.\\n//        vector<int> all;\\n//        for (int i = 0; i <= 1224444; ++i) {\\n//            int v = i;\\n//            unordered_map<int, int> m;\\n//            while (v > 0) {\\n//                ++m[v % 10];\\n//                v /= 10;\\n//            }\\n//            for (auto& p : m) {\\n//                if (p.first != p.second) goto L;\\n//            }\\n//            all.push_back(i);\\n//        L:\\n//            ;\\n//        }\\n        static vector<int> all {\\n            0, 1, 22, 122, 212, 221, 333, 1333, 3133, 3313, 3331, 4444, 14444, \\n            22333, 23233, 23323, 23332, 32233, 32323, 32332, 33223, 33232, \\n            33322, 41444, 44144, 44414, 44441, 55555, 122333, 123233, 123323,\\n            123332, 132233, 132323, 132332, 133223, 133232, 133322, 155555, \\n            212333, 213233, 213323, 213332, 221333, 223133, 223313, 223331, \\n            224444, 231233, 231323, 231332, 232133, 232313, 232331, 233123, \\n            233132, 233213, 233231, 233312, 233321, 242444, 244244, 244424, \\n            244442, 312233, 312323, 312332, 313223, 313232, 313322, 321233,\\n            321323, 321332, 322133, 322313, 322331, 323123, 323132, 323213,\\n            323231, 323312, 323321, 331223, 331232, 331322, 332123, 332132, \\n            332213, 332231, 332312, 332321, 333122, 333212, 333221, 422444, \\n            424244, 424424, 424442, 442244, 442424, 442442, 444224, 444242,\\n            444422, 515555, 551555, 555155, 555515, 555551, 666666, 1224444,\\n        };\\n        return *upper_bound(all.begin(), all.end(), n);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1537631,
                "title": "next-permutation-vs-dfs",
                "content": "I did not see a good solution, and I did not want to generate all options.\\n\\n> Update: I upsolved this problem using DFS, see the second approach below.\\n\\nNote that there are only 14 (including `1224444`) sorted beautiful numbers (e.g. `122333`), and we can permute them (`123233`, `123323`, etc.) to get all options.\\n\\n#### Approach 1: next_permutation\\n\\n**C++**\\n```cpp\\nint base[13] = {1, 22, 122, 333, 1333, 4444, 14444, 22333, 55555, 122333, 155555, 224444, 666666};\\nint nextBeautifulNumber(int n) {\\n    int res = 1224444;\\n    string s = to_string(n);\\n    for (int nn : base) {\\n        string ss = to_string(nn);\\n        if (ss.size() < s.size())\\n            continue;\\n        if (ss.size() > s.size())\\n            res = min(res, nn);\\n        else\\n            do {\\n                if (ss > s)\\n                    res = min(res, stoi(ss));\\n            } while(next_permutation(begin(ss), end(ss)));\\n    }\\n    return res;\\n}\\n```\\n\\n#### Approach 2: DFS\\nThis is a simplified implementation; we can also prune values that are going to be less than `n`. With pruning, it takes 0 ms to find balanced numbers for 64-bit integers.\\n\\n**C++**\\n```cpp\\nint cnt[10] = {0, 1, 2, 3, 4, 5, 6, 7, 8, 9};\\nlong long dfs(long long n, long long val, int sz) {\\n    if (sz == 0) {\\n        for (int i = 1; i <= 9; ++i)\\n            if (cnt[i] != i && cnt[i] != 0)\\n                return 0;\\n        return val > n ? val : 0;\\n    }\\n    long long res = 0;\\n    for (int i = 1; res == 0 && i <= 9; ++i)\\n        if (cnt[i] > 0 && cnt[i] <= sz) {\\n            --cnt[i];\\n            res = dfs(n, val * 10 + i, sz - 1);\\n            ++cnt[i];\\n        }\\n    return res;\\n}\\nint nextBeautifulNumber(int n) {\\n    int sz = to_string(n).size();\\n    return dfs(n, 0, sz) ?: dfs(0, 0, sz + 1);\\n}\\n```",
                "solutionTags": [],
                "code": "```cpp\\nint base[13] = {1, 22, 122, 333, 1333, 4444, 14444, 22333, 55555, 122333, 155555, 224444, 666666};\\nint nextBeautifulNumber(int n) {\\n    int res = 1224444;\\n    string s = to_string(n);\\n    for (int nn : base) {\\n        string ss = to_string(nn);\\n        if (ss.size() < s.size())\\n            continue;\\n        if (ss.size() > s.size())\\n            res = min(res, nn);\\n        else\\n            do {\\n                if (ss > s)\\n                    res = min(res, stoi(ss));\\n            } while(next_permutation(begin(ss), end(ss)));\\n    }\\n    return res;\\n}\\n```\n```cpp\\nint cnt[10] = {0, 1, 2, 3, 4, 5, 6, 7, 8, 9};\\nlong long dfs(long long n, long long val, int sz) {\\n    if (sz == 0) {\\n        for (int i = 1; i <= 9; ++i)\\n            if (cnt[i] != i && cnt[i] != 0)\\n                return 0;\\n        return val > n ? val : 0;\\n    }\\n    long long res = 0;\\n    for (int i = 1; res == 0 && i <= 9; ++i)\\n        if (cnt[i] > 0 && cnt[i] <= sz) {\\n            --cnt[i];\\n            res = dfs(n, val * 10 + i, sz - 1);\\n            ++cnt[i];\\n        }\\n    return res;\\n}\\nint nextBeautifulNumber(int n) {\\n    int sz = to_string(n).size();\\n    return dfs(n, 0, sz) ?: dfs(0, 0, sz + 1);\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1537599,
                "title": "c-python-generate-numeric-balanced-numbers-with-prune-beat-100-clean-concise",
                "content": "**Idea**\\n- The idea is that we generate all possible numeric balanced numbers with `numLen` start from `|n|`.\\n- While backtracking to generate we can prune some invalid combination, they are\\n\\t-` if counter[d] >= d: continue`   # Prune if number of occurrences of `d` is greater than `d`\\n\\t-` if counter[d] + (numLen - i) < d: continue`  # Prune if not enough number of occurrences of `d`\\n- Since `n <= 10^6`, in the worst case, there are up to 7 digits, each digits must be values from `[1..7]`, so it can run up to `7^7 = 823543`. \\n\\n**Python 3**\\n```python\\nclass Solution:\\n    def nextBeautifulNumber(self, n: int) -> int:\\n        def backtracking(i, numLen, curNum, counter):\\n            if i == numLen:\\n                isBalanceNumber = True\\n                for d, freq in counter.items():\\n                    if freq != 0 and d != freq:\\n                        isBalanceNumber = False\\n                if isBalanceNumber:\\n                    yield curNum\\n                return\\n\\n            for d in range(1, numLen+1):\\n                if counter[d] >= d: continue   # Prune if number of occurrences of `d` is greater than `d`\\n                if counter[d] + (numLen - i) < d: continue  # Prune if not enough number of occurrences of `d`\\n                counter[d] += 1\\n                yield from backtracking(i + 1, numLen, curNum * 10 + d, counter)\\n                counter[d] -= 1\\n\\n        for numLen in range(len(str(n)), len(str(n)) + 2):\\n            for num in backtracking(0, numLen, 0, Counter()):\\n                if num > n:\\n                    return num\\n```\\n\\n**C++**\\n```c++\\nclass Solution {\\npublic:\\n    int nextBeautifulNumber(int n) {\\n        if (n == 0) return 1;\\n        int minNumLen = log10(n) + 1;\\n        for (int numLen = minNumLen; numLen <= minNumLen + 1; ++numLen) {\\n            vector<int> all;\\n            unordered_map<int, int> counter;\\n            backtracking(0, numLen, 0, counter, all);\\n            for (int num : all)\\n                if (num > n) return num;\\n        }\\n        return -1;\\n    }\\n    void backtracking(int i, int numLen, int curNum, unordered_map<int, int>& counter, vector<int>& out) {\\n        if (i == numLen) {\\n            bool isBalanceNumber = true;\\n            for (auto& [d, freq] : counter)\\n                if (freq > 0 && d != freq)\\n                    isBalanceNumber = false;\\n            if (isBalanceNumber) \\n                out.push_back(curNum);\\n            return;\\n        }\\n        for (int d = 1; d <= numLen; ++d) {\\n            if (counter[d] >= d) continue; // Prune if number of occurrences of `d` is greater than `d`\\n            if (counter[d] + (numLen - i) < d) continue; // Prune if not enough number of occurrences of `d`\\n            counter[d] += 1;\\n            backtracking(i + 1, numLen, curNum * 10 + d, counter, out);\\n            counter[d] -= 1;\\n        }\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```python\\nclass Solution:\\n    def nextBeautifulNumber(self, n: int) -> int:\\n        def backtracking(i, numLen, curNum, counter):\\n            if i == numLen:\\n                isBalanceNumber = True\\n                for d, freq in counter.items():\\n                    if freq != 0 and d != freq:\\n                        isBalanceNumber = False\\n                if isBalanceNumber:\\n                    yield curNum\\n                return\\n\\n            for d in range(1, numLen+1):\\n                if counter[d] >= d: continue   # Prune if number of occurrences of `d` is greater than `d`\\n                if counter[d] + (numLen - i) < d: continue  # Prune if not enough number of occurrences of `d`\\n                counter[d] += 1\\n                yield from backtracking(i + 1, numLen, curNum * 10 + d, counter)\\n                counter[d] -= 1\\n\\n        for numLen in range(len(str(n)), len(str(n)) + 2):\\n            for num in backtracking(0, numLen, 0, Counter()):\\n                if num > n:\\n                    return num\\n```\n```c++\\nclass Solution {\\npublic:\\n    int nextBeautifulNumber(int n) {\\n        if (n == 0) return 1;\\n        int minNumLen = log10(n) + 1;\\n        for (int numLen = minNumLen; numLen <= minNumLen + 1; ++numLen) {\\n            vector<int> all;\\n            unordered_map<int, int> counter;\\n            backtracking(0, numLen, 0, counter, all);\\n            for (int num : all)\\n                if (num > n) return num;\\n        }\\n        return -1;\\n    }\\n    void backtracking(int i, int numLen, int curNum, unordered_map<int, int>& counter, vector<int>& out) {\\n        if (i == numLen) {\\n            bool isBalanceNumber = true;\\n            for (auto& [d, freq] : counter)\\n                if (freq > 0 && d != freq)\\n                    isBalanceNumber = false;\\n            if (isBalanceNumber) \\n                out.push_back(curNum);\\n            return;\\n        }\\n        for (int d = 1; d <= numLen; ++d) {\\n            if (counter[d] >= d) continue; // Prune if number of occurrences of `d` is greater than `d`\\n            if (counter[d] + (numLen - i) < d) continue; // Prune if not enough number of occurrences of `d`\\n            counter[d] += 1;\\n            backtracking(i + 1, numLen, curNum * 10 + d, counter, out);\\n            counter[d] -= 1;\\n        }\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1537728,
                "title": "222-lines-of-bliss-ugliest-number-beats-100",
                "content": "```\\nclass Solution:\\n    def nextBeautifulNumber(self, n: int) -> int:\\n        if n == 0:\\n            return 1\\n        elif 1 <= n < 22:\\n            return 22\\n        elif 22 <= n < 122:\\n            return 122\\n        elif 122 <= n < 212:\\n            return 212\\n        elif 212 <= n < 221:\\n            return 221\\n        elif 221 <= n < 333:\\n            return 333\\n        elif 333 <= n < 1333:\\n            return 1333\\n        elif 1333 <= n < 3133:\\n            return 3133\\n        elif 3133 <= n < 3313:\\n            return 3313\\n        elif 3313 <= n < 3331:\\n            return 3331\\n        elif 3331 <= n < 4444:\\n            return 4444\\n        elif 4444 <= n < 14444:\\n            return 14444\\n        elif 14444 <= n < 22333:\\n            return 22333\\n        elif 22333 <= n < 23233:\\n            return 23233\\n        elif 23233 <= n < 23323:\\n            return 23323\\n        elif 23323 <= n < 23332:\\n            return 23332\\n        elif 23332 <= n < 32233:\\n            return 32233\\n        elif 32233 <= n < 32323:\\n            return 32323\\n        elif 32323 <= n < 32332:\\n            return 32332\\n        elif 32332 <= n < 33223:\\n            return 33223\\n        elif 33223 <= n < 33232:\\n            return 33232\\n        elif 33232 <= n < 33322:\\n            return 33322\\n        elif 33322 <= n < 41444:\\n            return 41444\\n        elif 41444 <= n < 44144:\\n            return 44144\\n        elif 44144 <= n < 44414:\\n            return 44414\\n        elif 44414 <= n < 44441:\\n            return 44441\\n        elif 44414 <= n < 44441:\\n            return 44441\\n        elif 44441 <= n < 55555:\\n            return 55555\\n        elif 55555 <= n < 122333:\\n            return 122333\\n        elif 122333 <= n < 123233:\\n            return 123233\\n        elif 123233 <= n < 123323:\\n            return 123323\\n        elif 123323 <= n < 123332:\\n            return 123332\\n        elif 123332 <= n < 132233:\\n            return 132233\\n        elif 132233 <= n < 132323:\\n            return 132323\\n        elif 132233 <= n < 132332:\\n            return 132332\\n        elif 132332 <= n < 133223:\\n            return 133223\\n        elif 133223 <= n < 133232:\\n            return 133232\\n        elif 133232 <= n < 133322:\\n            return 133322\\n        elif 133322 <= n < 155555:\\n            return 155555\\n        elif 155555 <= n < 212333:\\n            return 212333\\n        elif 212333 <= n < 213233:\\n            return 213233\\n        elif 213233 <= n < 213323:\\n            return 213323\\n        elif 213323 <= n < 213332:\\n            return 213332\\n        elif 213332 <= n < 221333:\\n            return 221333\\n        elif 221333 <= n < 223133:\\n            return 223133\\n        elif 223133 <= n < 223313:\\n            return 223313\\n        elif 223313 <= n < 223331:\\n            return 223331\\n        elif 223331 <= n < 224444:\\n            return 224444\\n        elif 224444 <= n < 231233:\\n            return 231233\\n        elif 231233 <= n < 231323:\\n            return 231323\\n        elif 231323 <= n < 231332:\\n            return 231332\\n        elif 231332 <= n < 232133:\\n            return 232133\\n        elif 232133 <= n < 232313:\\n            return 232313\\n        elif 232313 <= n < 232331:\\n            return 232331\\n        elif 232331 <= n < 233123:\\n            return 233123\\n        elif 233123 <= n < 233132:\\n            return 233132\\n        elif 233132 <= n < 233213:\\n            return 233213\\n        elif 233213 <= n < 233231:\\n            return 233231\\n        elif 233231 <= n < 233312:\\n            return 233312\\n        elif 233312 <= n < 233321:\\n            return 233321\\n        elif 233321 <= n < 242444:\\n            return 242444\\n        elif 242444 <= n < 244244:\\n            return 244244\\n        elif 244244 <= n < 244424:\\n            return 244424\\n        elif 244244 <= n < 244442:\\n            return 244442\\n        elif 244442 <= n < 312233:\\n            return 312233\\n        elif 312233 <= n < 312323:\\n            return 312323\\n        elif 312323 <= n < 312332:\\n            return 312332\\n        elif 312332 <= n < 313223:\\n            return 313223\\n        elif 313223 <= n < 313232:\\n            return 313232\\n        elif 313232 <= n < 313322:\\n            return 313322\\n        elif 313322 <= n < 321233:\\n            return 321233\\n        elif 321233 <= n < 321323:\\n            return 321323\\n        elif 321323 <= n < 321332:\\n            return 321332\\n        elif 321332 <= n < 322133:\\n            return 322133\\n        elif 322133 <= n < 322313:\\n            return 322313\\n        elif 322313 <= n < 322331:\\n            return 322331\\n        elif 322331 <= n < 323123:\\n            return 323123\\n        elif 323123 <= n < 323132:\\n            return 323132\\n        elif 323132 <= n < 323213:\\n            return 323213\\n        elif 323213 <= n < 323231:\\n            return 323231\\n        elif 323231 <= n < 323312:\\n            return 323312\\n        elif 323312 <= n < 323321:\\n            return 323321\\n        elif 323321 <= n < 331223:\\n            return 331223\\n        elif 331223 <= n < 331232:\\n            return 331232\\n        elif 331232 <= n < 331322:\\n            return 331322\\n        elif 331322 <= n < 332123:\\n            return 332123\\n        elif 332123 <= n < 332132:\\n            return 332132\\n        elif 332132 <= n < 332213:\\n            return 332213\\n        elif 332213 <= n < 332231:\\n            return 332231\\n        elif 332231 <= n < 332312:\\n            return 332312\\n        elif 332312 <= n < 332321:\\n            return 332321\\n        elif 332321 <= n < 333122:\\n            return 333122\\n        elif 333122 <= n < 333212:\\n            return 333212\\n        elif 333212 <= n < 333221:\\n            return 333221\\n        elif 333221 <= n < 422444:\\n            return 422444\\n        elif 422444 <= n < 424244:\\n            return 424244\\n        elif 424244 <= n < 424424:\\n            return 424424\\n        elif 424424 <= n < 424442:\\n            return 424442\\n        elif 424442 <= n < 442244:\\n            return 442244\\n        elif 442244 <= n < 442424:\\n            return 442424\\n        elif 442424 <= n < 442442:\\n            return 442442\\n        elif 442442 <= n < 444224:\\n            return 444224\\n        elif 444224 <= n < 444242:\\n            return 444242\\n        elif 444242 <= n < 444422:\\n            return 444422\\n        elif 444422 <= n < 515555:\\n            return 515555\\n        elif 515555 <= n < 551555:\\n            return 551555\\n        elif 551555 <= n < 555155:\\n            return 555155\\n        elif 555155 <= n < 555515:\\n            return 555515\\n        elif 555515 <= n < 555551:\\n            return 555551\\n        elif 555551 <= n < 666666:\\n            return 666666\\n        elif 666666 <= n < 1224444:\\n            return 1224444\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def nextBeautifulNumber(self, n: int) -> int:\\n        if n == 0:\\n            return 1\\n        elif 1 <= n < 22:\\n            return 22\\n        elif 22 <= n < 122:\\n            return 122\\n        elif 122 <= n < 212:\\n            return 212\\n        elif 212 <= n < 221:\\n            return 221\\n        elif 221 <= n < 333:\\n            return 333\\n        elif 333 <= n < 1333:\\n            return 1333\\n        elif 1333 <= n < 3133:\\n            return 3133\\n        elif 3133 <= n < 3313:\\n            return 3313\\n        elif 3313 <= n < 3331:\\n            return 3331\\n        elif 3331 <= n < 4444:\\n            return 4444\\n        elif 4444 <= n < 14444:\\n            return 14444\\n        elif 14444 <= n < 22333:\\n            return 22333\\n        elif 22333 <= n < 23233:\\n            return 23233\\n        elif 23233 <= n < 23323:\\n            return 23323\\n        elif 23323 <= n < 23332:\\n            return 23332\\n        elif 23332 <= n < 32233:\\n            return 32233\\n        elif 32233 <= n < 32323:\\n            return 32323\\n        elif 32323 <= n < 32332:\\n            return 32332\\n        elif 32332 <= n < 33223:\\n            return 33223\\n        elif 33223 <= n < 33232:\\n            return 33232\\n        elif 33232 <= n < 33322:\\n            return 33322\\n        elif 33322 <= n < 41444:\\n            return 41444\\n        elif 41444 <= n < 44144:\\n            return 44144\\n        elif 44144 <= n < 44414:\\n            return 44414\\n        elif 44414 <= n < 44441:\\n            return 44441\\n        elif 44414 <= n < 44441:\\n            return 44441\\n        elif 44441 <= n < 55555:\\n            return 55555\\n        elif 55555 <= n < 122333:\\n            return 122333\\n        elif 122333 <= n < 123233:\\n            return 123233\\n        elif 123233 <= n < 123323:\\n            return 123323\\n        elif 123323 <= n < 123332:\\n            return 123332\\n        elif 123332 <= n < 132233:\\n            return 132233\\n        elif 132233 <= n < 132323:\\n            return 132323\\n        elif 132233 <= n < 132332:\\n            return 132332\\n        elif 132332 <= n < 133223:\\n            return 133223\\n        elif 133223 <= n < 133232:\\n            return 133232\\n        elif 133232 <= n < 133322:\\n            return 133322\\n        elif 133322 <= n < 155555:\\n            return 155555\\n        elif 155555 <= n < 212333:\\n            return 212333\\n        elif 212333 <= n < 213233:\\n            return 213233\\n        elif 213233 <= n < 213323:\\n            return 213323\\n        elif 213323 <= n < 213332:\\n            return 213332\\n        elif 213332 <= n < 221333:\\n            return 221333\\n        elif 221333 <= n < 223133:\\n            return 223133\\n        elif 223133 <= n < 223313:\\n            return 223313\\n        elif 223313 <= n < 223331:\\n            return 223331\\n        elif 223331 <= n < 224444:\\n            return 224444\\n        elif 224444 <= n < 231233:\\n            return 231233\\n        elif 231233 <= n < 231323:\\n            return 231323\\n        elif 231323 <= n < 231332:\\n            return 231332\\n        elif 231332 <= n < 232133:\\n            return 232133\\n        elif 232133 <= n < 232313:\\n            return 232313\\n        elif 232313 <= n < 232331:\\n            return 232331\\n        elif 232331 <= n < 233123:\\n            return 233123\\n        elif 233123 <= n < 233132:\\n            return 233132\\n        elif 233132 <= n < 233213:\\n            return 233213\\n        elif 233213 <= n < 233231:\\n            return 233231\\n        elif 233231 <= n < 233312:\\n            return 233312\\n        elif 233312 <= n < 233321:\\n            return 233321\\n        elif 233321 <= n < 242444:\\n            return 242444\\n        elif 242444 <= n < 244244:\\n            return 244244\\n        elif 244244 <= n < 244424:\\n            return 244424\\n        elif 244244 <= n < 244442:\\n            return 244442\\n        elif 244442 <= n < 312233:\\n            return 312233\\n        elif 312233 <= n < 312323:\\n            return 312323\\n        elif 312323 <= n < 312332:\\n            return 312332\\n        elif 312332 <= n < 313223:\\n            return 313223\\n        elif 313223 <= n < 313232:\\n            return 313232\\n        elif 313232 <= n < 313322:\\n            return 313322\\n        elif 313322 <= n < 321233:\\n            return 321233\\n        elif 321233 <= n < 321323:\\n            return 321323\\n        elif 321323 <= n < 321332:\\n            return 321332\\n        elif 321332 <= n < 322133:\\n            return 322133\\n        elif 322133 <= n < 322313:\\n            return 322313\\n        elif 322313 <= n < 322331:\\n            return 322331\\n        elif 322331 <= n < 323123:\\n            return 323123\\n        elif 323123 <= n < 323132:\\n            return 323132\\n        elif 323132 <= n < 323213:\\n            return 323213\\n        elif 323213 <= n < 323231:\\n            return 323231\\n        elif 323231 <= n < 323312:\\n            return 323312\\n        elif 323312 <= n < 323321:\\n            return 323321\\n        elif 323321 <= n < 331223:\\n            return 331223\\n        elif 331223 <= n < 331232:\\n            return 331232\\n        elif 331232 <= n < 331322:\\n            return 331322\\n        elif 331322 <= n < 332123:\\n            return 332123\\n        elif 332123 <= n < 332132:\\n            return 332132\\n        elif 332132 <= n < 332213:\\n            return 332213\\n        elif 332213 <= n < 332231:\\n            return 332231\\n        elif 332231 <= n < 332312:\\n            return 332312\\n        elif 332312 <= n < 332321:\\n            return 332321\\n        elif 332321 <= n < 333122:\\n            return 333122\\n        elif 333122 <= n < 333212:\\n            return 333212\\n        elif 333212 <= n < 333221:\\n            return 333221\\n        elif 333221 <= n < 422444:\\n            return 422444\\n        elif 422444 <= n < 424244:\\n            return 424244\\n        elif 424244 <= n < 424424:\\n            return 424424\\n        elif 424424 <= n < 424442:\\n            return 424442\\n        elif 424442 <= n < 442244:\\n            return 442244\\n        elif 442244 <= n < 442424:\\n            return 442424\\n        elif 442424 <= n < 442442:\\n            return 442442\\n        elif 442442 <= n < 444224:\\n            return 444224\\n        elif 444224 <= n < 444242:\\n            return 444242\\n        elif 444242 <= n < 444422:\\n            return 444422\\n        elif 444422 <= n < 515555:\\n            return 515555\\n        elif 515555 <= n < 551555:\\n            return 551555\\n        elif 551555 <= n < 555155:\\n            return 555155\\n        elif 555155 <= n < 555515:\\n            return 555515\\n        elif 555515 <= n < 555551:\\n            return 555551\\n        elif 555551 <= n < 666666:\\n            return 666666\\n        elif 666666 <= n < 1224444:\\n            return 1224444\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1537491,
                "title": "c-brute-force-and-why-it-can-pass",
                "content": "See my latest update in repo [LeetCode](https://github.com/lzl124631x/LeetCode)\\n\\n![image](https://assets.leetcode.com/users/images/295f9f07-ce53-447c-93ab-5bad59a8e8a2_1635389683.880866.png)\\n\\n\\n## Solution 1. Brute Force\\n\\nThe key is about estimating the time complexity.\\n\\nSince `n` is at most `1e6` and `log10(n)` is at most `6`, the result\\'s upper bound is `1224444`, the time complexity is at most `1e6 * 6 = 6e6` which is acceptable. This is also indicated by the hints of this problem.\\n\\nI thought about a more complex solution during the context but once I found a brute force solution can pass, I went ahead and implemented this. For the 2nd question, usually it doesn\\'t require you to implement a too complex solution. That said, learning how to solve it in an more elegant way is also important.\\n\\n```cpp\\n// OJ: https://leetcode.com/contest/weekly-contest-264/problems/next-greater-numerically-balanced-number/\\n// Author: github.com/lzl124631x\\n// Time: O(C * logC) where `C` is the maximum possible input number.\\n// Space: O(1)\\nclass Solution {\\n    bool balance(int n) {\\n        int cnt[10] = {};\\n        while (n) {\\n            if (n % 10 == 0) return false; // no 0 allowed\\n            cnt[n % 10]++;\\n            n /= 10;\\n        }\\n        for (int i = 1; i < 10; ++i) {\\n            if (cnt[i] && cnt[i] != i) return false;\\n        }\\n        return true;\\n    }\\npublic:\\n    int nextBeautifulNumber(int n) {\\n        while (true) {\\n            ++n;\\n            if (balance(n)) return n;\\n        }\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```cpp\\n// OJ: https://leetcode.com/contest/weekly-contest-264/problems/next-greater-numerically-balanced-number/\\n// Author: github.com/lzl124631x\\n// Time: O(C * logC) where `C` is the maximum possible input number.\\n// Space: O(1)\\nclass Solution {\\n    bool balance(int n) {\\n        int cnt[10] = {};\\n        while (n) {\\n            if (n % 10 == 0) return false; // no 0 allowed\\n            cnt[n % 10]++;\\n            n /= 10;\\n        }\\n        for (int i = 1; i < 10; ++i) {\\n            if (cnt[i] && cnt[i] != i) return false;\\n        }\\n        return true;\\n    }\\npublic:\\n    int nextBeautifulNumber(int n) {\\n        while (true) {\\n            ++n;\\n            if (balance(n)) return n;\\n        }\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1537686,
                "title": "optimal-c-solution-with-comments-accepted",
                "content": "```\\n//these are the only numbers of whose combination can be the required answer\\nstring arr[14] = {\"1\",\"22\",\"122\",\"333\",\"1333\",\"22333\",\"122333\",\"4444\",\"14444\",\"224444\",\"1224444\",\"55555\",\"155555\",\"666666\"};\\n    vector<string> perm;\\n\\t//function to find permuations of a given string \\n    void permute(string a, int l, int r)\\n    {\\n        // Base case\\n        if (l == r)\\n            perm.push_back(a);\\n        else\\n        {\\n            // Permutations made\\n            for (int i = l; i <= r; i++)\\n            {\\n\\n                // Swapping done\\n                swap(a[l], a[i]);\\n\\n                // Recursion called\\n                permute(a, l+1, r);\\n\\n                //backtrack\\n                swap(a[l], a[i]);\\n            }\\n        }\\n    }\\n\\t\\n\\tint nextBeautifulNumber(int n) {\\n\\t//sort the ans array based on word size and if word size equal\\n\\t//then lexicographically\\n        sort(arr,arr+14,[](string &a,string &b){\\n            if(a.size() != b.size()) return a.size() < b.size();\\n            return a < b;\\n            });\\n        // for(int i=0;i<14;i++) cout<<arr[i]<<\" \";\\n        // cout<<endl;\\n        string str = to_string(n);\\n        perm.clear();\\n        vector<string> brr;\\n        string res = \"-1\";\\n        string emer = \"-1\";\\n        for(auto &ch : arr)\\n        {\\n\\t\\t//if the curr words size in arr is equal to str then one of its permutation can be \\n\\t\\t// our ans so we store it in a vector\\n            if(ch.size() == str.size()) brr.push_back(ch);\\n\\t\\t\\t//if permuation of above any doesn\\'t give answer \\n\\t\\t\\t//then first string with length size+1 of str will be the ans\\n            else if(ch.size() == str.size()+1)\\n            {\\n                emer = ch;\\n                break;\\n            }\\n        }\\n        \\n        \\n        for(auto &ele : brr)\\n        {\\n            // cout<<ele<<\" \";\\n            perm.clear();\\n\\t\\t\\t//find permuations of current candidate\\n            permute(ele,0,ele.size()-1);\\n            string sr = str;\\n\\t\\t\\t//sort the permuations lexicographically\\n            sort(perm.begin(),perm.end(),[](string &a,string &b){\\n                return a<b;\\n            });\\n\\t\\t\\t//check if any of theswe permuations may be our requierd candidate\\n            for(auto &p : perm)\\n            {\\n                if(p>str)\\n                {\\n                    if(res == \"-1\") res = p;\\n                    else if(p < res) res = p;\\n                }\\n            }\\n        }\\n\\t\\t//if permuations of any of equal size candidates didn\\'t yield expected result then\\n\\t\\t//size+1 string in arr is our ans\\n        if(res != \"-1\") return stoi(res);\\n\\t\\t//else return the permuation which we found as answer\\n        return stoi(emer);\\n        \\n    }\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\n//these are the only numbers of whose combination can be the required answer\\nstring arr[14] = {\"1\",\"22\",\"122\",\"333\",\"1333\",\"22333\",\"122333\",\"4444\",\"14444\",\"224444\",\"1224444\",\"55555\",\"155555\",\"666666\"};\\n    vector<string> perm;\\n\\t//function to find permuations of a given string \\n    void permute(string a, int l, int r)\\n    {\\n        // Base case\\n        if (l == r)\\n            perm.push_back(a);\\n        else\\n        {\\n            // Permutations made\\n            for (int i = l; i <= r; i++)\\n            {\\n\\n                // Swapping done\\n                swap(a[l], a[i]);\\n\\n                // Recursion called\\n                permute(a, l+1, r);\\n\\n                //backtrack\\n                swap(a[l], a[i]);\\n            }\\n        }\\n    }\\n\\t\\n\\tint nextBeautifulNumber(int n) {\\n\\t//sort the ans array based on word size and if word size equal\\n\\t//then lexicographically\\n        sort(arr,arr+14,[](string &a,string &b){\\n            if(a.size() != b.size()) return a.size() < b.size();\\n            return a < b;\\n            });\\n        // for(int i=0;i<14;i++) cout<<arr[i]<<\" \";\\n        // cout<<endl;\\n        string str = to_string(n);\\n        perm.clear();\\n        vector<string> brr;\\n        string res = \"-1\";\\n        string emer = \"-1\";\\n        for(auto &ch : arr)\\n        {\\n\\t\\t//if the curr words size in arr is equal to str then one of its permutation can be \\n\\t\\t// our ans so we store it in a vector\\n            if(ch.size() == str.size()) brr.push_back(ch);\\n\\t\\t\\t//if permuation of above any doesn\\'t give answer \\n\\t\\t\\t//then first string with length size+1 of str will be the ans\\n            else if(ch.size() == str.size()+1)\\n            {\\n                emer = ch;\\n                break;\\n            }\\n        }\\n        \\n        \\n        for(auto &ele : brr)\\n        {\\n            // cout<<ele<<\" \";\\n            perm.clear();\\n\\t\\t\\t//find permuations of current candidate\\n            permute(ele,0,ele.size()-1);\\n            string sr = str;\\n\\t\\t\\t//sort the permuations lexicographically\\n            sort(perm.begin(),perm.end(),[](string &a,string &b){\\n                return a<b;\\n            });\\n\\t\\t\\t//check if any of theswe permuations may be our requierd candidate\\n            for(auto &p : perm)\\n            {\\n                if(p>str)\\n                {\\n                    if(res == \"-1\") res = p;\\n                    else if(p < res) res = p;\\n                }\\n            }\\n        }\\n\\t\\t//if permuations of any of equal size candidates didn\\'t yield expected result then\\n\\t\\t//size+1 string in arr is our ans\\n        if(res != \"-1\") return stoi(res);\\n\\t\\t//else return the permuation which we found as answer\\n        return stoi(emer);\\n        \\n    }\\n```",
                "codeTag": "C++"
            },
            {
                "id": 1537643,
                "title": "c-backtracking-4-steps-solution-stepwise-explanation",
                "content": "I knew simply incrementing n would work but I tried to do using permutation by backtracking\\nFirst of all, since n<=10^6, So there will be only 6 digits, and our result will be in at most 7 digits.\\n# Step 1:\\nSo make list of balanced numbers i.e\\n1  22  333  4444  55555  666666 \\nThis numbers are obvious to us, Isn\\'t it? Yes, it is.\\n# Step 2:\\nNow we can find more such numbers by combining two or more of them.\\nfor example : 1 and 22 combined  as 122\\nNow we have\\nlist of balanced numbers as:\\n\"1\",\"22\",\"122\",\"333\",\"1333\",\"4444\",\"14444\",\"22333\",\"55555\",\"122333\",\"155555\",\"224444\",\"666666\",\"1224444\"\\n\\n# Step 3:\\nCan we find more good balanced numbers?\\nYes, of course. Take one number from above and permute its digits , you get another number which is also balanced.\\n for exmaple:\\n lets take \\n 122333\\n Then if we permute its digits we may get: 212333 , 221333, 321233,...... and so on   ( Find it all by next_permutation or backtracking)\\n Do this for all numbers from the above balanced numbers.\\n You get like this ,\\n 1 22 122 212 221 333 1333 3133 3313 3331 4444 14444 22333 23233 23323 23332 32233 32323 32332 33223 33232 33322 41444 44144 44414 44441 55555 122333 123233 123323 123332 132233 132323 132332 133223 133232 133322 155555 212333 213233 213323 213332 221333 223133 223313 223331 224444 231233 231323 231332 232133 232313 232331 233123 233132 233213 233231 233312 233321 242444 244244 244424 244442 312233 312323 312332 313223 313232 313322 321233 321323 321332 322133 322313 322331 323123 323132 323213 323231 323312 323321 331223 331232 331322 332123 332132 332213 332231 332312 332321 333122 333212 333221 422444 424244 424424 424442 442244 442424 442442 444224 444242 444422 515555 551555 555155 555515 555551 666666 1224444 1242444 1244244 1244424 1244442 1422444 1424244 1424424 1424442 1442244 1442424 1442442 1444224 1444242 1444422 1666666 2124444 2142444 2144244 2144424 2144442 2214444 2241444 2244144 2244414 2244441 2255555 2412444 2414244 2414424 2414442 2421444 2424144 2424414 2424441 2441...\\n \\n#  Step 4:\\n Now you have list of balanced numbers. Sort it  and upper_bound is your answer.\\n```\\nclass Solution {\\npublic:\\n    vector<string> ans;\\n    void permute(string &s,vector<bool> &vis,string cur){\\n        if(cur.size()==s.size())\\n        {\\n            ans.push_back(cur);\\n            return;\\n        }\\n        for(int i=0;i<s.size();i++){\\n            if(vis[i]==false){\\n                vis[i]=true;\\n                permute(s,vis,cur+s[i]);\\n                vis[i]=false;\\n            }\\n        }\\n    }\\n    int nextBeautifulNumber(int n) {\\n      vector<string> nums{\"1\",\"22\",\"122\",\"333\",\"1333\",\"4444\",\"14444\",\"22333\",\"55555\",\"122333\",\"155555\",\"224444\",\"666666\",\"1224444\"};\\n      for(int i=0;i<nums.size();i++){\\n          int n=nums[i].size();\\n          vector<bool> vis(n);\\n          for(int j=0;j<n;j++){\\n             vis[j]=false;\\n          }\\n          permute(nums[i],vis,\"\");\\n      }  \\n      set<int> a;\\n      for(string x:ans)\\n      {\\n          if(x!=\"\"){\\n              int y=stoi(x);\\n              a.insert(y);\\n          }\\n      }\\n      auto it=upper_bound(a.begin(),a.end(),n);\\n      int res=*it;\\n      return res;\\n    }\\n};\\n",
                "solutionTags": [
                    "C",
                    "Backtracking"
                ],
                "code": "class Solution {\\npublic:\\n    vector<string> ans;\\n    void permute(string &s,vector<bool> &vis,string cur){\\n        if(cur.size()==s.size())\\n        {\\n            ans.push_back(cur);\\n            return;\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 1537608,
                "title": "python-permutation-binary-search",
                "content": "```\\nimport itertools\\n\\nclass Solution(object):\\n    def nextBeautifulNumber(self, n):\\n        \"\"\"\\n        :type n: int\\n        :rtype: int\\n        \"\"\"\\n        tmp = [1, 22, 122, 333, 1333, 4444, 44441, 55555, 22333, 122333, 155555, 224444, 666666]\\n        tmp = [str(t) for t in tmp]\\n        candidates = []\\n        for t in tmp:\\n        \\n            candidates += list( set(\"\".join(p) for p in itertools.permutations(list(t)) ) )\\n        \\n        candidates = [int(c) for c in candidates]\\n        candidates.append(1224444)\\n        candidates.sort()\\n        # print(candidates)\\n        ind = bisect.bisect_right(candidates, n)\\n        return candidates[ind]\\n        \\n\\n\\n\\n        \\n```",
                "solutionTags": [],
                "code": "```\\nimport itertools\\n\\nclass Solution(object):\\n    def nextBeautifulNumber(self, n):\\n        \"\"\"\\n        :type n: int\\n        :rtype: int\\n        \"\"\"\\n        tmp = [1, 22, 122, 333, 1333, 4444, 44441, 55555, 22333, 122333, 155555, 224444, 666666]\\n        tmp = [str(t) for t in tmp]\\n        candidates = []\\n        for t in tmp:\\n        \\n            candidates += list( set(\"\".join(p) for p in itertools.permutations(list(t)) ) )\\n        \\n        candidates = [int(c) for c in candidates]\\n        candidates.append(1224444)\\n        candidates.sort()\\n        # print(candidates)\\n        ind = bisect.bisect_right(candidates, n)\\n        return candidates[ind]\\n        \\n\\n\\n\\n        \\n```",
                "codeTag": "Java"
            },
            {
                "id": 1537666,
                "title": "c-solution-explained",
                "content": "Notice what numbers can be numerically balanced for each digit.\\n1 digit: 1\\n2 digits: 22\\n3 digits: 333 and all permutations of 122\\n4 digits: 4444 and all permutations of 1333\\n5 digits: 55555 and all permutations of 14444 and 22333\\n\\nNotice for every valid number, if we count each digit which shows up atleast one time then\\nnumber of digits = value of digit\\n\\nHere is solution:\\n```\\nclass Solution {\\npublic:\\n    bool valid(int n)\\n    {\\n        vector<int> map(10,0);\\n        while(n)\\n        {\\n            int rem = n%10;\\n            map[rem]++;\\n            n = n/10;\\n        }\\n        for(int i=0; i<10; i++)\\n            if(map[i] && map[i]!=i) return false;\\n        return true;\\n    }\\n    \\n    int nextBeautifulNumber(int n) {\\n     \\n        while(true) \\n        {\\n            ++n;\\n            if(valid(n))\\n                return n;\\n        }\\n        return 1;\\n    }\\n};",
                "solutionTags": [
                    "C"
                ],
                "code": "class Solution {\\npublic:\\n    bool valid(int n)\\n    {\\n        vector<int> map(10,0);\\n        while(n)\\n        {\\n            int rem = n%10;\\n            map[rem]++;\\n            n = n/10;\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 1537557,
                "title": "check-it-1-by-1",
                "content": "```\\nclass Solution {\\n    public int nextBeautifulNumber(int n) {\\n        for (int i = n + 1; i < Integer.MAX_VALUE; i++) {\\n            if (check(i)) {\\n                return i;\\n            }\\n        }\\n        return -1;\\n    }\\n    \\n    boolean check(int i) {\\n        Map<Integer, Integer> map = new HashMap<>();\\n        List<Integer> list = new ArrayList<>();\\n        while (i != 0) {\\n            int d = i % 10;\\n            list.add(d);\\n            i /= 10;\\n        }\\n        for (int num : list) {\\n            map.put(num, map.getOrDefault(num, 0) + 1);\\n        } \\n        for (int key : map.keySet()) {\\n            if (key != map.get(key)) {\\n                return false;\\n            }\\n        }\\n        return true;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int nextBeautifulNumber(int n) {\\n        for (int i = n + 1; i < Integer.MAX_VALUE; i++) {\\n            if (check(i)) {\\n                return i;\\n            }\\n        }\\n        return -1;\\n    }\\n    \\n    boolean check(int i) {\\n        Map<Integer, Integer> map = new HashMap<>();\\n        List<Integer> list = new ArrayList<>();\\n        while (i != 0) {\\n            int d = i % 10;\\n            list.add(d);\\n            i /= 10;\\n        }\\n        for (int num : list) {\\n            map.put(num, map.getOrDefault(num, 0) + 1);\\n        } \\n        for (int key : map.keySet()) {\\n            if (key != map.get(key)) {\\n                return false;\\n            }\\n        }\\n        return true;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1538628,
                "title": "easy-code-with-comments",
                "content": "**Please Upvote , it helps a lot**\\n\\n```\\nclass Solution {\\n    public int nextBeautifulNumber(int n) {\\n\\n        while(true){\\n            n++;\\n           int num = n; //test this number\\n           int [] freq = new int[10]; // 0 to 9\\n            \\n            while(num > 0){  //calculate freq of each digit in the num\\n                int rem = num % 10; //this is remainder\\n                num = num / 10;     //this is quotient\\n                freq[rem] = freq[rem] + 1; //increase its frequency\\n                if(freq[rem] > rem) break;\\n            }\\n            \\n            boolean ans = true;\\n            \\n            for(int i = 0;i<10;i++){ //check frequency of each digit\\n              if(freq[i] != i && freq[i] != 0){\\n                  ans = false;\\n                  break;\\n              }\\n            }\\n            \\n            if(ans == true){\\n                return n;\\n            }\\n        }\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int nextBeautifulNumber(int n) {\\n\\n        while(true){\\n            n++;\\n           int num = n; //test this number\\n           int [] freq = new int[10]; // 0 to 9\\n            \\n            while(num > 0){  //calculate freq of each digit in the num\\n                int rem = num % 10; //this is remainder\\n                num = num / 10;     //this is quotient\\n                freq[rem] = freq[rem] + 1; //increase its frequency\\n                if(freq[rem] > rem) break;\\n            }\\n            \\n            boolean ans = true;\\n            \\n            for(int i = 0;i<10;i++){ //check frequency of each digit\\n              if(freq[i] != i && freq[i] != 0){\\n                  ans = false;\\n                  break;\\n              }\\n            }\\n            \\n            if(ans == true){\\n                return n;\\n            }\\n        }\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1537587,
                "title": "java-exhaustive-list-of-beautiful-numbers",
                "content": "\\nBasically, list all the beautiful numbers in ascending order and you got it.\\nListing all permutations that contains two different digit is not hard. For example, the permutations for ```22333```are:\\n```\\n\\t\\t22333, 23233, 23323, 23332,\\n\\t\\t32233, 32323, 32332,\\n\\t\\t33223, 33232,\\n\\t\\t33322\\n``` \\nThe only challenging parts are the permutations of ```122333```. It would be easier if you first come up with all the permutations of ```22333```. Then you can think of that challenge as finding all the outputs of inserting `1` in different ways into each permutation of ```22333```.\\nYou can just list all the numbers in unsorted order then let the function sort the array.\\n```\\n    public int nextBeautifulNumber(int n) {\\n        int[] candidates = new int[] {1, 22, 122, 212, 221, 333, 1333, 3133, 3313, 3331, 4444, 14444, 22333, 23233, 23323, 23332, 32233, \\n\\t\\t\\t32323, 32332, 33223, 33232, 33322, 41444, 44144, 44414, 44441, 55555, 122333, 123233, 123323, 123332, 132233, 132323, 132332, \\n\\t\\t\\t133223, 133232, 133322, 155555, 212333, 213233, 213323, 213332, 221333, 223133, 223313, 223331, 224444, 231233, 231323, 231332, \\n\\t\\t\\t232133, 232313, 232331, 233123, 233132, 233213, 233231, 233312, 233321, 242444, 244244, 244424, 244442, 312233, 312323, 312332, \\n\\t\\t\\t313223, 313232, 313322, 321233, 321323, 321332, 322133, 322313, 322331, 323123, 323132, 323213, 323231, 323312, 323321, 331223, \\n\\t\\t\\t331232, 331322, 332123, 332132, 332213, 332231, 332312, 332321, 333122, 333212, 333221, 422444, 424244, 424424, 424442, 442244, \\n\\t\\t\\t442424, 442442, 444224, 444242, 444422, 515555, 551555, 555155, 555515, 555551, 666666};\\n        for (int candidate : candidates) if (n < candidate) return candidate;\\n        return 1224444;\\n    }\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```22333```\n```\\n\\t\\t22333, 23233, 23323, 23332,\\n\\t\\t32233, 32323, 32332,\\n\\t\\t33223, 33232,\\n\\t\\t33322\\n```\n```122333```\n```22333```\n```22333```\n```\\n    public int nextBeautifulNumber(int n) {\\n        int[] candidates = new int[] {1, 22, 122, 212, 221, 333, 1333, 3133, 3313, 3331, 4444, 14444, 22333, 23233, 23323, 23332, 32233, \\n\\t\\t\\t32323, 32332, 33223, 33232, 33322, 41444, 44144, 44414, 44441, 55555, 122333, 123233, 123323, 123332, 132233, 132323, 132332, \\n\\t\\t\\t133223, 133232, 133322, 155555, 212333, 213233, 213323, 213332, 221333, 223133, 223313, 223331, 224444, 231233, 231323, 231332, \\n\\t\\t\\t232133, 232313, 232331, 233123, 233132, 233213, 233231, 233312, 233321, 242444, 244244, 244424, 244442, 312233, 312323, 312332, \\n\\t\\t\\t313223, 313232, 313322, 321233, 321323, 321332, 322133, 322313, 322331, 323123, 323132, 323213, 323231, 323312, 323321, 331223, \\n\\t\\t\\t331232, 331322, 332123, 332132, 332213, 332231, 332312, 332321, 333122, 333212, 333221, 422444, 424244, 424424, 424442, 442244, \\n\\t\\t\\t442424, 442442, 444224, 444242, 444422, 515555, 551555, 555155, 555515, 555551, 666666};\\n        for (int candidate : candidates) if (n < candidate) return candidate;\\n        return 1224444;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1537523,
                "title": "java-o-7",
                "content": "There are only 110 balanced numbers between 0 and 1,000,000.   The 111th is 1,224,444, which is the next balanced number after 1,000,000.   Put 111 numbers into an array and just do binary search.   If number exists in the array we take the next one.\\n\\n```\\nclass Solution {\\n    public int nextBeautifulNumber(int n) {\\n        int[] beauts = {0, 1, 22, 122, 212, 221, 333, 1333, 3133, 3313, 3331, 4444, 14444, 22333, 23233, 23323, 23332, 32233, 32323, 32332, 33223, 33232, 33322, 41444, 44144, 44414, 44441, 55555, 122333, 123233, 123323, 123332, 132233, 132323, 132332, 133223, 133232, 133322, 155555, 212333, 213233, 213323, 213332, 221333, 223133, 223313, 223331, 224444, 231233, 231323, 231332, 232133, 232313, 232331, 233123, 233132, 233213, 233231, 233312, 233321, 242444, 244244, 244424, 244442, 312233, 312323, 312332, 313223, 313232, 313322, 321233, 321323, 321332, 322133, 322313, 322331, 323123, 323132, 323213, 323231, 323312, 323321, 331223, 331232, 331322, 332123, 332132, 332213, 332231, 332312, 332321, 333122, 333212, 333221, 422444, 424244, 424424, 424442, 442244, 442424, 442442, 444224, 444242, 444422, 515555, 551555, 555155, 555515, 555551, 666666, 1224444};\\n        int pos = Arrays.binarySearch(beauts, n);\\n        \\n        if(pos >= 0) {\\n            return beauts[pos+1];\\n        }\\n        \\n        return beauts[-pos-1];\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Counting"
                ],
                "code": "```\\nclass Solution {\\n    public int nextBeautifulNumber(int n) {\\n        int[] beauts = {0, 1, 22, 122, 212, 221, 333, 1333, 3133, 3313, 3331, 4444, 14444, 22333, 23233, 23323, 23332, 32233, 32323, 32332, 33223, 33232, 33322, 41444, 44144, 44414, 44441, 55555, 122333, 123233, 123323, 123332, 132233, 132323, 132332, 133223, 133232, 133322, 155555, 212333, 213233, 213323, 213332, 221333, 223133, 223313, 223331, 224444, 231233, 231323, 231332, 232133, 232313, 232331, 233123, 233132, 233213, 233231, 233312, 233321, 242444, 244244, 244424, 244442, 312233, 312323, 312332, 313223, 313232, 313322, 321233, 321323, 321332, 322133, 322313, 322331, 323123, 323132, 323213, 323231, 323312, 323321, 331223, 331232, 331322, 332123, 332132, 332213, 332231, 332312, 332321, 333122, 333212, 333221, 422444, 424244, 424424, 424442, 442244, 442424, 442442, 444224, 444242, 444422, 515555, 551555, 555155, 555515, 555551, 666666, 1224444};\\n        int pos = Arrays.binarySearch(beauts, n);\\n        \\n        if(pos >= 0) {\\n            return beauts[pos+1];\\n        }\\n        \\n        return beauts[-pos-1];\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1538324,
                "title": "c-beats-100-time-and-92-space",
                "content": "Maintained array of size 7 only because with given contraints, there is no minimum number possible with all 7\\'s that is greater than n.\\nThis way, we avoid checking unnecessary numbers in the start itself.\\n```\\nclass Solution {\\npublic:\\n    bool check(int n)\\n    {\\n        int nums[7]={0};\\n        while(n!=0)\\n        {\\n            if(n%10==0 || n%10>6) return false;\\n            nums[n%10]++;\\n            n=n/10;\\n        }\\n        for(int i=1;i<=6;i++)\\n        {\\n            if(nums[i]!=0 && nums[i]!=i) return false;\\n        }\\n        return true;\\n    }\\n    \\n    int nextBeautifulNumber(int n) {\\n    n++;\\n    while(1)\\n    {\\n        if(check(n)) return n;\\n        n++;\\n    }\\n    return 0;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool check(int n)\\n    {\\n        int nums[7]={0};\\n        while(n!=0)\\n        {\\n            if(n%10==0 || n%10>6) return false;\\n            nums[n%10]++;\\n            n=n/10;\\n        }\\n        for(int i=1;i<=6;i++)\\n        {\\n            if(nums[i]!=0 && nums[i]!=i) return false;\\n        }\\n        return true;\\n    }\\n    \\n    int nextBeautifulNumber(int n) {\\n    n++;\\n    while(1)\\n    {\\n        if(check(n)) return n;\\n        n++;\\n    }\\n    return 0;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1537516,
                "title": "java-solution-easy-to-understand-recursion",
                "content": "\\n\\nclass Solution {\\n\\n    int ans=Integer.MAX_VALUE;\\n    public int nextBeautifulNumber(int n) {\\n        int arr[]=new int[10];\\n        for(int i=1;i<=6;i++){\\n            arr[i]=i;\\n        }\\n        find(arr,0L,n);\\n        return ans;\\n\\t\\t\\n\\t\\t\\n    }\\n\\t\\n    void find(int arr[],long num,int n){\\n        \\n        if(num>n && check(arr)){\\n            if(ans>num)ans=(int)num;\\n            return;\\n        }\\n        if(num>100*n) return;\\n        \\n        for(int i=1;i<=6;i++){\\n            if(arr[i]!=0){\\n                arr[i]--;\\n                find(arr,num*10+i,n);\\n                arr[i]++;\\n            }\\n        }\\n    }\\n    boolean check(int arr[]){\\n        for(int i=1;i<=6;i++){\\n            if(arr[i]!=0 && arr[i]!=i) return false;\\n        }\\n        return true;\\n    }\\n}\\n\\nUpvote if you find this solution helpful thanks",
                "solutionTags": [
                    "Java"
                ],
                "code": "class Solution {\\n\\n    int ans=Integer.MAX_VALUE;\\n    public int nextBeautifulNumber(int n) {\\n        int arr[]=new int[10];\\n        for(int i=1;i<=6;i++){\\n            arr[i]=i;\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 3688107,
                "title": "easy-java-solution-3-ms-100-working",
                "content": "# Step By Step Explanation \\n\\n1. We need to find the smallest numerically balanced number strictly greater than the given number `n`.\\n2. To determine if a number is numerically balanced, we need to check if each digit in the number has exactly the same count as the value of that digit.\\n3. We can start by incrementing the given number `n` by 1 and check if it is numerically balanced.\\n4. If it is numerically balanced, we return that number as the result.\\n5. If it is not numerically balanced, we increment the number and repeat the check until we find a numerically balanced number.\\n6. To check if a number is numerically balanced, we can count the occurrence of each digit in the number and compare it with the digit value itself.\\n7. We can use an array or map to store the count of each digit, and if any count is different from the digit value, the number is not numerically balanced.\\n8. By following this approach, we can find the smallest numerically balanced number greater than the given number `n`.\\n\\n# Code\\n```\\nclass Solution {\\n    public int nextBeautifulNumber(int n) {\\n        int num = n + 1;\\n\\n        while (!isNumericallyBalanced(num)) {\\n            num++;\\n        }\\n\\n        return num;\\n    }\\n\\n    private boolean isNumericallyBalanced(int num) {\\n        int[] digitCount = new int[10];\\n\\n        while (num > 0) {\\n            int digit = num % 10;\\n            digitCount[digit]++;\\n            num /= 10;\\n        }\\n\\n        for (int i = 0; i < 10; i++) {\\n            if (digitCount[i] != 0 && digitCount[i] != i) {\\n                return false;\\n            }\\n        }\\n        return true;\\n    }\\n}\\n\\n\\n\\n```\\n\\n# Complexity\\n\\n* The time complexity of the solution is O(N), where N represents the difference between the numerically balanced number and `n`. \\n* The space complexity is O(1) since it requires a constant amount of space regardless of the input size.\\n\\n\\n![free Delivery.png](https://assets.leetcode.com/users/images/9662d212-c7de-4a4d-99b8-d30f041b8d91_1687853150.4191005.png)\\n\\n\\n",
                "solutionTags": [
                    "Java",
                    "Math",
                    "Backtracking",
                    "Enumeration"
                ],
                "code": "```\\nclass Solution {\\n    public int nextBeautifulNumber(int n) {\\n        int num = n + 1;\\n\\n        while (!isNumericallyBalanced(num)) {\\n            num++;\\n        }\\n\\n        return num;\\n    }\\n\\n    private boolean isNumericallyBalanced(int num) {\\n        int[] digitCount = new int[10];\\n\\n        while (num > 0) {\\n            int digit = num % 10;\\n            digitCount[digit]++;\\n            num /= 10;\\n        }\\n\\n        for (int i = 0; i < 10; i++) {\\n            if (digitCount[i] != 0 && digitCount[i] != i) {\\n                return false;\\n            }\\n        }\\n        return true;\\n    }\\n}\\n\\n\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2246137,
                "title": "very-easy-java-solution-speed-100-memory-98",
                "content": "\\nclass Solution {\\n    public int nextBeautifulNumber(int n) {\\n        int small[] = {1, 22, 122, 212, 221, 333,1333, 3133, 3313, 3331,4444};\\n\\t\\t\\n        int medium[] = {14444, 22333, 23233, 23323, 23332, 32233, 32323, 32332, 33223, 33232, 33322, 41444, 44144, 44414, 44441,55555};\\n\\t\\t\\n        int big[] = {122333, 123233, 123323, 123332, 132233, 132323, 132332, 133223, 133232, 133322, 155555, 212333, 213233, 213323, 213332, 221333, 223133, 223313, 223331, 224444, 231233, 231323, 231332, 232133, 232313, 232331, 233123, 233132, 233213, 233231, 233312, 233321, 242444, 244244, 244424, 244442, 312233, 312323, 312332, 313223, 313232, 313322, 321233, 321323, 321332, 322133, 322313, 322331, 323123, 323132, 323213, 323231, 323312, 323321, 331223, 331232, 331322, 332123, 332132, 332213, 332231, 332312, 332321, 333122, 333212, 333221, 422444, 424244, 424424, 424442, 442244, 442424, 442442, 444224, 444242, 444422, 515555, 551555, 555155, 555515, 555551, 666666,1224444};\\n        \\n\\n        if(n>=0 && n<=small[small.length-1]){\\n            for(int i=0; i<small.length;i++){\\n                if(n<small[i])return small[i];\\n            }\\n        }else if(n>=small[small.length-1] && n<=medium[medium.length-1]){\\n            for(int i=0; i<medium.length;i++){\\n                if(n<medium[i])return medium[i];\\n            }\\n        }else if(n>=medium[medium.length-1] && n<=big[big.length-1]){\\n            for(int i=0; i<big.length;i++){\\n                if(n<big[i])return big[i];\\n            }\\n        }\\n        return n;\\n    }\\n}",
                "solutionTags": [
                    "Java",
                    "Array"
                ],
                "code": "class Solution {\\n    public int nextBeautifulNumber(int n) {\\n        int small[] = {1, 22, 122, 212, 221, 333,1333, 3133, 3313, 3331,4444}",
                "codeTag": "Java"
            },
            {
                "id": 2053307,
                "title": "python-brute-force",
                "content": "\\n    def nextBeautifulNumber(self, n):\\n        for i in range(n+1, 1224445):\\n            dict1 = Counter(str(i))\\n            if all(dict1[i] == int(i) for i in str(i)):\\n                return i",
                "solutionTags": [],
                "code": "\\n    def nextBeautifulNumber(self, n):\\n        for i in range(n+1, 1224445):\\n            dict1 = Counter(str(i))\\n            if all(dict1[i] == int(i) for i in str(i)):\\n                return i",
                "codeTag": "Python3"
            },
            {
                "id": 1543672,
                "title": "simple-and-easy-c",
                "content": "```\\n bool isbal(int n){\\n        vector<int> v(10);\\n        \\n        \\n        while(n){\\n            v[n%10]++;\\n            n/=10;\\n        }\\n        \\n        \\n       for(int i=0;i<10;i++){\\n           if(v[i] and i!=v[i]) return false;\\n       }\\n        \\n        return true;\\n    }\\n    int nextBeautifulNumber(int n) {\\n        \\n        for(int i=n+1;i<1e8;i++){\\n            \\n            if(isbal(i)){\\n                return i;\\n            }\\n        }\\n        return 1;\\n    }\\n```",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\n bool isbal(int n){\\n        vector<int> v(10);\\n        \\n        \\n        while(n){\\n            v[n%10]++;\\n            n/=10;\\n        }\\n        \\n        \\n       for(int i=0;i<10;i++){\\n           if(v[i] and i!=v[i]) return false;\\n       }\\n        \\n        return true;\\n    }\\n    int nextBeautifulNumber(int n) {\\n        \\n        for(int i=n+1;i<1e8;i++){\\n            \\n            if(isbal(i)){\\n                return i;\\n            }\\n        }\\n        return 1;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1537823,
                "title": "easy-c-solution-36-ms-faster-than-100-solutions",
                "content": "class Solution {\\npublic:\\n    bool balanced(int n ){\\n        \\n        int a[10] = {0};\\n        while(n){\\n            int x = n%10;\\n            a[x]+=1;\\n            n = n/10;\\n            if(a[x] > x) return false;\\n        }\\n        for(int i =0;i<=9;i++){\\n            if(a[i]!=i && a[i]!=0){\\n                return false;\\n            }\\n        }\\n        return true;\\n        \\n    }\\n    int nextBeautifulNumber(int n) {\\n        n+=1;\\n         while(n<=INT_MAX){\\n            if(balanced(n)){\\n                return n;\\n            }\\n            n+=1;\\n        }\\n        return -1;\\n        \\n    }\\n};",
                "solutionTags": [],
                "code": "class Solution {\\npublic:\\n    bool balanced(int n ){\\n        \\n        int a[10] = {0}",
                "codeTag": "Java"
            },
            {
                "id": 1537537,
                "title": "python3-brute-force",
                "content": "\\n```\\nclass Solution:\\n    def nextBeautifulNumber(self, n: int) -> int:\\n        while True: \\n            n += 1\\n            nn = n \\n            freq = defaultdict(int)\\n            while nn: \\n                nn, d = divmod(nn, 10)\\n                freq[d] += 1\\n            if all(k == v for k, v in freq.items()): return n \\n```\\n\\nBacktracking\\n```\\nclass Solution:\\n    def nextBeautifulNumber(self, n: int) -> int:\\n        \\n        def fn(i, x):\\n            if i == k:\\n                if all(d == v for d, v in freq.items() if v): yield x\\n            else: \\n                for d in range(1, k+1):\\n                    if freq[d] < d <= freq[d] + k - i: \\n                        freq[d] += 1\\n                        yield from fn(i+1, 10*x+d)\\n                        freq[d] -= 1\\n\\n        for k in (len(str(n)), len(str(n))+1):\\n            freq = Counter()\\n            for val in fn(0, 0):\\n                if val > n: return val\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def nextBeautifulNumber(self, n: int) -> int:\\n        while True: \\n            n += 1\\n            nn = n \\n            freq = defaultdict(int)\\n            while nn: \\n                nn, d = divmod(nn, 10)\\n                freq[d] += 1\\n            if all(k == v for k, v in freq.items()): return n \\n```\n```\\nclass Solution:\\n    def nextBeautifulNumber(self, n: int) -> int:\\n        \\n        def fn(i, x):\\n            if i == k:\\n                if all(d == v for d, v in freq.items() if v): yield x\\n            else: \\n                for d in range(1, k+1):\\n                    if freq[d] < d <= freq[d] + k - i: \\n                        freq[d] += 1\\n                        yield from fn(i+1, 10*x+d)\\n                        freq[d] -= 1\\n\\n        for k in (len(str(n)), len(str(n))+1):\\n            freq = Counter()\\n            for val in fn(0, 0):\\n                if val > n: return val\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1590143,
                "title": "c-2-step-process-1-generate-base-balanced-numbers-2-generate-permutations",
                "content": "Breaking the problem into 2 steps leads to a simple solution which is also fast!\\n\\nStep 1: We perform DFS to generate base balanced numbers restricting its length as per our requirement. This helps in cases where constraints are other than what the current problem statement provides. Hence, it is more generic.\\n\\nWe perform a simple exclusion/inclusion dfs.\\n\\nStep 2: Once we have base beautiful numbers which are also sorted,  we can prune some of them out on the basis of length and also on the basis of whether we have found the final result. Rest of the explanation is in the commented code.\\n\\n```cpp\\nclass Solution {\\npublic:\\n    void generate_base(set<long> &base, long start, int next, int &length) {\\n        if (next == 10) {\\n            if (start > 0) {\\n                base.insert(start);\\n            }\\n            return;\\n        }\\n        \\n        // include new digits\\n        for (int index = next; index <= 9; index++) {\\n            int ctr = index;\\n            long val = start;\\n            \\n            if (to_string(val).size() + ctr > length) {\\n                continue;\\n            }\\n            \\n            while (ctr--) {\\n                val = val * 10 + index;\\n            }\\n            \\n            generate_base(base, val, index + 1, length);\\n        }\\n        // exclude and move to next\\n        generate_base(base, start, next + 1, length);\\n    }\\n    \\n    \\n    \\n    int nextBeautifulNumber(int n) {\\n        set<long> base;\\n        int length = 7;\\n        generate_base(base, 0, 1, length); // we generate all base integers that are less than or equal to 7 digits;\\n        \\n        string target = to_string(n);\\n        int res = INT_MAX;\\n        \\n        for (auto s: base) {\\n            string b = to_string(s);\\n            \\n            if (b.size() < target.size()) {\\n                continue;\\n            } // anything shorter than length of n can be pruned\\n            \\n            if (b.size() > target.size() && res != INT_MAX) {\\n                break;\\n            } // anything greater than length of n can be pruned if we already have a result found.\\n            \\n            do {\\n                if (n < stoi(b)) {\\n                    res = min(res, stoi(b));\\n                }\\n            } while (next_permutation(b.begin(), b.end()));\\n            // permute over variations of base\\n        }\\n        \\n        return res;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```cpp\\nclass Solution {\\npublic:\\n    void generate_base(set<long> &base, long start, int next, int &length) {\\n        if (next == 10) {\\n            if (start > 0) {\\n                base.insert(start);\\n            }\\n            return;\\n        }\\n        \\n        // include new digits\\n        for (int index = next; index <= 9; index++) {\\n            int ctr = index;\\n            long val = start;\\n            \\n            if (to_string(val).size() + ctr > length) {\\n                continue;\\n            }\\n            \\n            while (ctr--) {\\n                val = val * 10 + index;\\n            }\\n            \\n            generate_base(base, val, index + 1, length);\\n        }\\n        // exclude and move to next\\n        generate_base(base, start, next + 1, length);\\n    }\\n    \\n    \\n    \\n    int nextBeautifulNumber(int n) {\\n        set<long> base;\\n        int length = 7;\\n        generate_base(base, 0, 1, length); // we generate all base integers that are less than or equal to 7 digits;\\n        \\n        string target = to_string(n);\\n        int res = INT_MAX;\\n        \\n        for (auto s: base) {\\n            string b = to_string(s);\\n            \\n            if (b.size() < target.size()) {\\n                continue;\\n            } // anything shorter than length of n can be pruned\\n            \\n            if (b.size() > target.size() && res != INT_MAX) {\\n                break;\\n            } // anything greater than length of n can be pruned if we already have a result found.\\n            \\n            do {\\n                if (n < stoi(b)) {\\n                    res = min(res, stoi(b));\\n                }\\n            } while (next_permutation(b.begin(), b.end()));\\n            // permute over variations of base\\n        }\\n        \\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1543168,
                "title": "c-0ms-code-with-backtracking-and-next-permutation",
                "content": "Generating all combinations of beautiful integers using backtracking and then creating permutations of the same.\\n```\\nvector<int>v;      // beautiful vector\\nbool yes=false;    // to determine if beautiful vector is already created or not\\nvoid rec2(string s){    // to generate permutations of a particular string \\n    do{\\n        v.push_back(stoi(s));   \\n    }while(next_permutation(s.begin(),s.end()));\\n    return;\\n}\\n\\nvoid rec(int cnt,int i,string &s){  //to generate all possible combinations using backtracking\\n    if(cnt+i>7 || i>7)return;\\n \\n    for(int j=0;j<i;j++){\\n        s.push_back(\\'0\\'+i);         \\n    }\\n    rec2(s);\\n    rec(cnt+i,i+1,s);\\n    for(int j=0;j<i;j++){\\n        s.pop_back();               //backtracking\\n    }\\n    rec(cnt,i+1,s);\\n}\\nvoid mn(){                          ///main function for generating beautiful vector\\n    string s=\"\";\\n    rec(0,1,s);\\n    sort(v.begin(),v.end());\\n    yes=true;\\n}\\nclass Solution {\\npublic:\\n    \\n    int nextBeautifulNumber(int n) {\\n      if(!yes)mn();                             //creating beautiful vector if not created \\n      auto it=upper_bound(v.begin(),v.end(),n);\\n        return *it;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Backtracking"
                ],
                "code": "```\\nvector<int>v;      // beautiful vector\\nbool yes=false;    // to determine if beautiful vector is already created or not\\nvoid rec2(string s){    // to generate permutations of a particular string \\n    do{\\n        v.push_back(stoi(s));   \\n    }while(next_permutation(s.begin(),s.end()));\\n    return;\\n}\\n\\nvoid rec(int cnt,int i,string &s){  //to generate all possible combinations using backtracking\\n    if(cnt+i>7 || i>7)return;\\n \\n    for(int j=0;j<i;j++){\\n        s.push_back(\\'0\\'+i);         \\n    }\\n    rec2(s);\\n    rec(cnt+i,i+1,s);\\n    for(int j=0;j<i;j++){\\n        s.pop_back();               //backtracking\\n    }\\n    rec(cnt,i+1,s);\\n}\\nvoid mn(){                          ///main function for generating beautiful vector\\n    string s=\"\";\\n    rec(0,1,s);\\n    sort(v.begin(),v.end());\\n    yes=true;\\n}\\nclass Solution {\\npublic:\\n    \\n    int nextBeautifulNumber(int n) {\\n      if(!yes)mn();                             //creating beautiful vector if not created \\n      auto it=upper_bound(v.begin(),v.end(),n);\\n        return *it;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1539533,
                "title": "python-3-100-runtime-100-memory-not-an-interview-friendly-solution",
                "content": "```python\\narr = [\\n            0, 1, 22, 122, 212, 221, 333, 1333, 3133, 3313, 3331, 4444, 14444, \\n            22333, 23233, 23323, 23332, 32233, 32323, 32332, 33223, 33232, \\n            33322, 41444, 44144, 44414, 44441, 55555, 122333, 123233, 123323,\\n            123332, 132233, 132323, 132332, 133223, 133232, 133322, 155555, \\n            212333, 213233, 213323, 213332, 221333, 223133, 223313, 223331, \\n            224444, 231233, 231323, 231332, 232133, 232313, 232331, 233123, \\n            233132, 233213, 233231, 233312, 233321, 242444, 244244, 244424, \\n            244442, 312233, 312323, 312332, 313223, 313232, 313322, 321233,\\n            321323, 321332, 322133, 322313, 322331, 323123, 323132, 323213,\\n            323231, 323312, 323321, 331223, 331232, 331322, 332123, 332132, \\n            332213, 332231, 332312, 332321, 333122, 333212, 333221, 422444, \\n            424244, 424424, 424442, 442244, 442424, 442442, 444224, 444242,\\n            444422, 515555, 551555, 555155, 555515, 555551, 666666, 1224444,\\n        ]\\n        \\n        return arr[bisect_right(arr, n)]\\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```python\\narr = [\\n            0, 1, 22, 122, 212, 221, 333, 1333, 3133, 3313, 3331, 4444, 14444, \\n            22333, 23233, 23323, 23332, 32233, 32323, 32332, 33223, 33232, \\n            33322, 41444, 44144, 44414, 44441, 55555, 122333, 123233, 123323,\\n            123332, 132233, 132323, 132332, 133223, 133232, 133322, 155555, \\n            212333, 213233, 213323, 213332, 221333, 223133, 223313, 223331, \\n            224444, 231233, 231323, 231332, 232133, 232313, 232331, 233123, \\n            233132, 233213, 233231, 233312, 233321, 242444, 244244, 244424, \\n            244442, 312233, 312323, 312332, 313223, 313232, 313322, 321233,\\n            321323, 321332, 322133, 322313, 322331, 323123, 323132, 323213,\\n            323231, 323312, 323321, 331223, 331232, 331322, 332123, 332132, \\n            332213, 332231, 332312, 332321, 333122, 333212, 333221, 422444, \\n            424244, 424424, 424442, 442244, 442424, 442442, 444224, 444242,\\n            444422, 515555, 551555, 555155, 555515, 555551, 666666, 1224444,\\n        ]\\n        \\n        return arr[bisect_right(arr, n)]\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1538808,
                "title": "simple-python-solution",
                "content": "```\\nclass Solution:\\n    def nextBeautifulNumber(self, n: int) -> int:\\n        temp = [1, 22, 122, 333, 1333, 4444, 44441, 55555, 22333, 122333, 155555, 224444, 666666] ##only 6 digits number considered as 0<=n<= 10^6\\n        \\n        final_check = self.permum(temp)\\n        #print(final_check)\\n        for x in range(len(final_check)):\\n            if final_check[x] > n:\\n                return final_check[x]\\n            \\n    \\n        \\n        \\n    def permum(self, temp):\\n        temp = [str(t) for t in temp]\\n        final_check  = []\\n        for x in temp:\\n            final_check += list( set(\"\".join(p) for p in itertools.permutations(list(x))))\\n            \\n        final_check = [int(c) for c in final_check]\\n        final_check.append(1224444) ##appending the lowest seven digit number\\n        final_check.sort()\\n        return final_check\\n        \\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def nextBeautifulNumber(self, n: int) -> int:\\n        temp = [1, 22, 122, 333, 1333, 4444, 44441, 55555, 22333, 122333, 155555, 224444, 666666] ##only 6 digits number considered as 0<=n<= 10^6\\n        \\n        final_check = self.permum(temp)\\n        #print(final_check)\\n        for x in range(len(final_check)):\\n            if final_check[x] > n:\\n                return final_check[x]\\n            \\n    \\n        \\n        \\n    def permum(self, temp):\\n        temp = [str(t) for t in temp]\\n        final_check  = []\\n        for x in temp:\\n            final_check += list( set(\"\".join(p) for p in itertools.permutations(list(x))))\\n            \\n        final_check = [int(c) for c in final_check]\\n        final_check.append(1224444) ##appending the lowest seven digit number\\n        final_check.sort()\\n        return final_check\\n        \\n```",
                "codeTag": "Java"
            },
            {
                "id": 1538579,
                "title": "python-3-all-combinations-46ms",
                "content": "```\\nclass Solution:\\n    def nextBeautifulNumber(self, n: int) -> int:\\n        n_digits = len(str(n))\\n        \\n        next_max = {\\n            1: [1],\\n            2: [22],\\n            3: [122, 333],\\n            4: [1333, 4444],\\n            5: [14444, 22333, 55555],\\n            6: [122333, 224444, 666666, 155555],\\n            7: [1224444, 2255555, 3334444, 1666666, 7777777]\\n                }\\n        \\n        if n >= int(str(n_digits) * n_digits):\\n            n_digits += 1\\n            return min(next_max[n_digits])\\n        \\n        ans = float(\\'inf\\')\\n        for num in sorted(next_max[n_digits]):      \\n            cands = set(permutations(str(num)))\\n            cands = sorted(map(lambda x: int(\"\".join(x)), cands))\\n        \\n            loc = bisect.bisect(cands, n)\\n            if loc < len(cands):           \\n                ans = min(ans, cands[loc])\\n        \\n        return ans\\n",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "class Solution:\\n    def nextBeautifulNumber(self, n: int) -> int:\\n        n_digits = len(str(n))\\n        \\n        next_max = {\\n            1: [1],\\n            2: [22],\\n            3: [122, 333],\\n            4: [1333, 4444],\\n            5: [14444, 22333, 55555],\\n            6: [122333, 224444, 666666, 155555],\\n            7: [1224444, 2255555, 3334444, 1666666, 7777777]\\n                }",
                "codeTag": "Java"
            },
            {
                "id": 1537859,
                "title": "java-backtracking-runtime-10-ms-faster-than-83-33",
                "content": "```\\nclass Solution {\\n    int ans = 0;\\n    Map<Integer, Integer> map = new HashMap<>();\\n    public int nextBeautifulNumber(int n) {\\n        if (n == 0) return 1;\\n        if (n < 22) return 22;\\n        \\n        int digits = 0;\\n        int originalN = n;\\n        \\n        // count how many digits\\n        while (n != 0) {\\n            digits++;\\n            n /= 10;\\n        }\\n\\n        compute(digits, 0, new StringBuilder(), originalN);\\n        if (ans > n) {\\n            return ans;\\n        }\\n        \\n        // if the next balanced number has one more digit\\n        compute(digits + 1, 0, new StringBuilder(), originalN);\\n        return ans;\\n    }\\n    \\n    public void compute (int digit, int sum, StringBuilder sb, int n) {\\n        // We just need the first one since it\\'s inorder\\n        if (ans != 0) {\\n            return;\\n        }\\n        if (sb.length() == digit && sum == digit && Integer.valueOf(sb.toString()) > n) {\\n            ans = Integer.valueOf(sb.toString());\\n            return;\\n        }\\n        \\n        for (int i = 1; i <= digit; i++) {\\n            if (map.getOrDefault(i, 0) < i && sum <= digit) {\\n                sb.append(i);\\n                map.put(i, map.getOrDefault(i, 0) + 1);\\n                if (map.get(i) == 1) {\\n                    compute(digit, sum + i, sb, n);\\n                } else {\\n                    compute(digit, sum, sb, n);\\n                }\\n                sb.deleteCharAt(sb.length() - 1);\\n                map.put(i, map.get(i) - 1);\\n            }\\n        }\\n    }\\n    \\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    int ans = 0;\\n    Map<Integer, Integer> map = new HashMap<>();\\n    public int nextBeautifulNumber(int n) {\\n        if (n == 0) return 1;\\n        if (n < 22) return 22;\\n        \\n        int digits = 0;\\n        int originalN = n;\\n        \\n        // count how many digits\\n        while (n != 0) {\\n            digits++;\\n            n /= 10;\\n        }\\n\\n        compute(digits, 0, new StringBuilder(), originalN);\\n        if (ans > n) {\\n            return ans;\\n        }\\n        \\n        // if the next balanced number has one more digit\\n        compute(digits + 1, 0, new StringBuilder(), originalN);\\n        return ans;\\n    }\\n    \\n    public void compute (int digit, int sum, StringBuilder sb, int n) {\\n        // We just need the first one since it\\'s inorder\\n        if (ans != 0) {\\n            return;\\n        }\\n        if (sb.length() == digit && sum == digit && Integer.valueOf(sb.toString()) > n) {\\n            ans = Integer.valueOf(sb.toString());\\n            return;\\n        }\\n        \\n        for (int i = 1; i <= digit; i++) {\\n            if (map.getOrDefault(i, 0) < i && sum <= digit) {\\n                sb.append(i);\\n                map.put(i, map.getOrDefault(i, 0) + 1);\\n                if (map.get(i) == 1) {\\n                    compute(digit, sum + i, sb, n);\\n                } else {\\n                    compute(digit, sum, sb, n);\\n                }\\n                sb.deleteCharAt(sb.length() - 1);\\n                map.put(i, map.get(i) - 1);\\n            }\\n        }\\n    }\\n    \\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1537742,
                "title": "c-solution-explanation-permutation-binary-search",
                "content": "class Solution {\\npublic:\\n    int nextBeautifulNumber(int n) {\\n\\n// APPROACH:\\n// If we observe, we can figure out that there will only be few \\'Numerically Balanced Number\\' less than 10^6, which is our constraint. So, we will store all the numerically balanced numbers upto length 7 and their permutations in a vector in sorted manner and can then find our required answer using binary search.\\n        \\n \\n \\n        vector<string>a{\"1\",\"22\",\"122\",\"333\",\"1333\",\"4444\",\"14444\",\"22333\",\"55555\",\"155555\",\"224444\",\"666666\",\"223331\",\"7777777\",\"1666666\",\"2255555\",\"3334444\",\"4444221\"};   //Storing numerically balanced numbers as string but not their permutations.\\n\\t\\t set<string>st;\\n        \\n        // Finding Permutaions of each string and storing them in a set\\n        for(int i=0;i<a.size();i++)\\n        {\\n            string s=a[i];\\n            sort(s.begin(),s.end());\\n            do\\n            {\\n              st.insert(s);\\n            } while(next_permutation(s.begin(),s.end()));\\n        }\\n        \\n        vector<int>v;\\n        for(auto &x:st)\\n        {\\n            int i=stoi(x); //converting string to integer\\n            v.push_back(i);\\n        }\\n        sort(v.begin(),v.end());\\n        int idx=upper_bound(v.begin(),v.end(),n)-(v.begin());\\n        return v[idx];\\n    }\\n};",
                "solutionTags": [
                    "C",
                    "Binary Tree"
                ],
                "code": "class Solution {\\npublic:\\n    int nextBeautifulNumber(int n) {\\n\\n// APPROACH:\\n// If we observe, we can figure out that there will only be few \\'Numerically Balanced Number\\' less than 10^6, which is our constraint. So, we will store all the numerically balanced numbers upto length 7 and their permutations in a vector in sorted manner and can then find our required answer using binary search.\\n        \\n \\n \\n        vector<string>a{\"1\",\"22\",\"122\",\"333\",\"1333\",\"4444\",\"14444\",\"22333\",\"55555\",\"155555\",\"224444\",\"666666\",\"223331\",\"7777777\",\"1666666\",\"2255555\",\"3334444\",\"4444221\"}",
                "codeTag": "Java"
            },
            {
                "id": 1537565,
                "title": "simple-java-solution-interesting-one",
                "content": "**Precomputation**:\\nFor all digits from 1- 7 find all the beautiful numbers for example\\n1- 1\\n2- 22\\n3 - [122, 212, 221, 333]\\n4- [1333(All its permutations), 4444]\\n5- [14444 (all its permutations), 22333 (all its permutations), 55555]]\\n6- [122333 (all its permutations), 224444(all its permutations), 666666]\\n7 - ... You got the point.\\n\\n**Find the Answer**.\\nNow, find the number of digits in the given number n ,and go to the list pre-computed beautiful numbers for that digit and return the number greater than input. If not found in current set of digits return first number with number of digits just one more.\\n\\n\\nclass Solution {\\n    \\n    static void permute(String str, String ans, TreeSet<String> a)\\n    {\\n  \\n        if (str.length() == 0) {\\n            a.add(new String(ans));\\n            return;\\n        }\\n        for (int i = 0; i < str.length(); i++) {\\n  \\n            char ch = str.charAt(i);\\n  \\n        \\n            String ros = str.substring(0, i) + \\n                         str.substring(i + 1);\\n  \\n            // Recurvise call\\n            permute(ros, ans + ch, a);\\n        }\\n    }\\n    \\n    public int nextBeautifulNumber(int n) {\\n        Map<Integer, TreeSet<Integer>> map=new HashMap();\\n        for(int i=1;i<=7;i++)\\n            map.put(i, new TreeSet());\\n        \\n        if(n==0)\\n            return 1;\\n        \\n        map.get(1).add(1);\\n        map.get(2).add(22);\\n        \\n        map.get(3).add(122);\\n        map.get(3).add(212);\\n        map.get(3).add(221);\\n        map.get(3).add(333);\\n        \\n        String s= \"1333\";\\n        TreeSet<String> p=new TreeSet();\\n        permute(s, \"\", p);\\n        for(String x: p){\\n            map.get(4).add(Integer.parseInt(x));\\n        }\\n        map.get(4).add(4444);\\n        \\n        s=\"14444\";\\n        p=new TreeSet();\\n        permute(s, \"\", p);\\n        for(String x: p){\\n            map.get(5).add(Integer.parseInt(x));\\n        }\\n          s=\"22333\";\\n        p=new TreeSet();\\n        permute(s, \"\", p);\\n        for(String x: p){\\n            map.get(5).add(Integer.parseInt(x));\\n        }\\n        map.get(5).add(55555);\\n        \\n        s=\"122333\";\\n        p=new TreeSet();\\n        permute(s,\"\", p);\\n        for(String x: p){\\n            map.get(6).add(Integer.parseInt(x));\\n        }\\n        \\n         s=\"155555\";\\n        p=new TreeSet();\\n        permute(s, \"\", p);\\n        for(String x: p){\\n            map.get(6).add(Integer.parseInt(x));\\n        }\\n        \\n         s=\"224444\";\\n        p=new TreeSet();\\n        permute(s, \"\", p);\\n        for(String x: p){\\n            map.get(6).add(Integer.parseInt(x));\\n        }\\n        map.get(6).add(666666);\\n        \\n        map.get(7).add(1224444);\\n        int d=0, num=n;\\n        while(num>0){\\n            d++;\\n            num=num/10;\\n        }\\n        if(d==7)\\n            return 1224444;\\n        \\n        for(int x: map.get(d)){\\n            if(x>n)\\n                return x;\\n        }\\n        return map.get(d+1).first();\\n        \\n        \\n        \\n            \\n    }\\n}\\n\\ncheers!",
                "solutionTags": [
                    "Java"
                ],
                "code": "class Solution {\\n    \\n    static void permute(String str, String ans, TreeSet<String> a)\\n    {\\n  \\n        if (str.length() == 0) {\\n            a.add(new String(ans));\\n            return;\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 1537548,
                "title": "c-2048-next-greater-numerically-balanced-number",
                "content": "\\n```\\nclass Solution {\\npublic:\\n    int nextBeautifulNumber(int n) {\\n        for (bool flag = true; flag; ) {\\n            ++n; \\n            vector<int> freq(10); \\n            for (int x = n; x; x /= 10) ++freq[x%10]; \\n            flag = false; \\n            for (int i = 0; i < 10; ++i) \\n                if (freq[i] && i != freq[i]) flag = true; \\n        }\\n        return n; \\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int nextBeautifulNumber(int n) {\\n        for (bool flag = true; flag; ) {\\n            ++n; \\n            vector<int> freq(10); \\n            for (int x = n; x; x /= 10) ++freq[x%10]; \\n            flag = false; \\n            for (int i = 0; i < 10; ++i) \\n                if (freq[i] && i != freq[i]) flag = true; \\n        }\\n        return n; \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1537506,
                "title": "i-thought-this-would-tle",
                "content": "I submitted this solution out of desperation, to my surprise this passed the test case. \\n```\\nclass Solution:\\n    def nextBeautifulNumber(self, n: int) -> int:\\n        for i in range(n + 1, 10 ** 7):\\n            if self.balance(i):\\n                return i\\n    \\n    def balance(self, x):\\n        counter = Counter(str(x))\\n        for k,v in counter.items():\\n            if int(k) != v:\\n                return False\\n            \\n        return True\\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nclass Solution:\\n    def nextBeautifulNumber(self, n: int) -> int:\\n        for i in range(n + 1, 10 ** 7):\\n            if self.balance(i):\\n                return i\\n    \\n    def balance(self, x):\\n        counter = Counter(str(x))\\n        for k,v in counter.items():\\n            if int(k) != v:\\n                return False\\n            \\n        return True\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1537482,
                "title": "javascript",
                "content": "```\\nlet nextBeautifulNumber = n => {\\n    let ok = n => {\\n        let s = `${n}`;\\n        let m = new Map();\\n        for (let c of s)\\n            m.set(c, 1 + (m.get(c) || 0));\\n        return [...m].every(([x, cnt]) => x == cnt);\\n    };\\n    do {\\n        ++n;\\n    } while (!ok(n));\\n    return n;\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nlet nextBeautifulNumber = n => {\\n    let ok = n => {\\n        let s = `${n}`;\\n        let m = new Map();\\n        for (let c of s)\\n            m.set(c, 1 + (m.get(c) || 0));\\n        return [...m].every(([x, cnt]) => x == cnt);\\n    };\\n    do {\\n        ++n;\\n    } while (!ok(n));\\n    return n;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2703554,
                "title": "python-using-permutations-very-simple-solution-96-faster",
                "content": "\\n\\n# Code\\n```\\nclass Solution:\\n    def nextBeautifulNumber(self, n: int) -> int:\\n        from itertools import permutations\\n        mylist = [1, 22, 122, 333, 1333, 4444, 14444, 22333, 55555, 122333, 155555, 224444, 666666,1224444]\\n        res=[]\\n        def digit_combination(a,length):\\n            a = list(str(a))\\n            comb = permutations(a, length)\\n            for each in comb:\\n                s = [str(i) for i in each]\\n                result = int(\"\".join(s))\\n                res.append(result)\\n        for every in mylist:\\n            digit_combination(every,len(str(every)))\\n        res.sort()\\n        print(res)\\n        for idx in res:\\n            if(idx>n):\\n                return idx\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def nextBeautifulNumber(self, n: int) -> int:\\n        from itertools import permutations\\n        mylist = [1, 22, 122, 333, 1333, 4444, 14444, 22333, 55555, 122333, 155555, 224444, 666666,1224444]\\n        res=[]\\n        def digit_combination(a,length):\\n            a = list(str(a))\\n            comb = permutations(a, length)\\n            for each in comb:\\n                s = [str(i) for i in each]\\n                result = int(\"\".join(s))\\n                res.append(result)\\n        for every in mylist:\\n            digit_combination(every,len(str(every)))\\n        res.sort()\\n        print(res)\\n        for idx in res:\\n            if(idx>n):\\n                return idx\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2544173,
                "title": "fastest-code-c",
                "content": "```\\nclass Solution {\\npublic:\\n    int nextBeautifulNumber(int n) \\n    {\\n        vector<int> all = {1, 22, 122, 212, 221, 333, 1333, 3133, 3313, 3331, 4444, 14444, 22333, 23233, 23323, 23332, 32233, 32323, \\n\\t\\t32332, 33223, 33232, 33322, 41444, 44144, 44414, 44441, 55555, 122333, 123233, 123323, 123332, 132233, 132323, 132332, \\n\\t\\t133223, 133232, 133322, 155555, 212333, 213233, 213323, 213332, 221333, 223133, 223313, 223331, 224444, 231233, \\n\\t\\t231323, 231332, 232133, 232313, 232331, 233123, 233132, 233213, 233231, 233312, 233321, 242444, 244244, 244424, 244442, \\n\\t\\t312233, 312323, 312332, 313223, 313232, 313322, 321233, 321323, 321332, 322133, 322313, 322331, 323123, 323132, \\n\\t\\t323213, 323231, 323312, 323321, 331223, 331232, 331322, 332123, 332132, 332213, 332231, 332312, 332321, 333122, \\n\\t\\t333212, 333221, 422444, 424244, 424424, 424442, 442244, 442424, 442442, 444224, 444242, 444422, 515555, 551555, \\n\\t\\t555155, 555515, 555551, 666666, 1224444};\\n        \\n        return *upper_bound(all.begin(), all.end(), n);\\n        \\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int nextBeautifulNumber(int n) \\n    {\\n        vector<int> all = {1, 22, 122, 212, 221, 333, 1333, 3133, 3313, 3331, 4444, 14444, 22333, 23233, 23323, 23332, 32233, 32323, \\n\\t\\t32332, 33223, 33232, 33322, 41444, 44144, 44414, 44441, 55555, 122333, 123233, 123323, 123332, 132233, 132323, 132332, \\n\\t\\t133223, 133232, 133322, 155555, 212333, 213233, 213323, 213332, 221333, 223133, 223313, 223331, 224444, 231233, \\n\\t\\t231323, 231332, 232133, 232313, 232331, 233123, 233132, 233213, 233231, 233312, 233321, 242444, 244244, 244424, 244442, \\n\\t\\t312233, 312323, 312332, 313223, 313232, 313322, 321233, 321323, 321332, 322133, 322313, 322331, 323123, 323132, \\n\\t\\t323213, 323231, 323312, 323321, 331223, 331232, 331322, 332123, 332132, 332213, 332231, 332312, 332321, 333122, \\n\\t\\t333212, 333221, 422444, 424244, 424424, 424442, 442244, 442424, 442442, 444224, 444242, 444422, 515555, 551555, \\n\\t\\t555155, 555515, 555551, 666666, 1224444};\\n        \\n        return *upper_bound(all.begin(), all.end(), n);\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2408414,
                "title": "backtracking-c",
                "content": "Generate all the balanced numbers. Then sort them and then use binary search to find the stickly greater number.\\nD = largest digit count in the balanced number. I have added 3 to it just to stay safe.\\n```\\nclass Solution {\\n    vector<int> nums;\\npublic:\\n    int stoi(string &num) {\\n        int p = 1;\\n        int n = 0;\\n        for (int i = num.length()-1; i >= 0; i--) {\\n            n += (num[i]-\\'0\\')*p;\\n            p *= 10;\\n        }\\n        return n;\\n    }\\n    \\n    void generateNums(string &num, int idx, int st, int D) {\\n        if (idx == D) {\\n            do {\\n                nums.push_back(stoi(num));\\n            } while (next_permutation(num.begin(),num.end()));\\n            return;\\n        }\\n        if (idx > D) {\\n            return;\\n        }\\n        for (int i = st; i < 10; i++) {\\n            string temp = num;\\n            num += string(i,i+\\'0\\');\\n            generateNums(num,num.length(),i+1,D);\\n            num = temp;\\n        }\\n    }\\n    \\n    int nextBeautifulNumber(int n) {\\n        int D = log(1e6)/log(10) + 3;\\n        for (int i = 1; i <= D; i++) {\\n            string num;\\n            generateNums(num,0,1,i);\\n        }\\n        sort(nums.begin(),nums.end());\\n        auto it = upper_bound(nums.begin(),nums.end(),n);\\n        return *it;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    vector<int> nums;\\npublic:\\n    int stoi(string &num) {\\n        int p = 1;\\n        int n = 0;\\n        for (int i = num.length()-1; i >= 0; i--) {\\n            n += (num[i]-\\'0\\')*p;\\n            p *= 10;\\n        }\\n        return n;\\n    }\\n    \\n    void generateNums(string &num, int idx, int st, int D) {\\n        if (idx == D) {\\n            do {\\n                nums.push_back(stoi(num));\\n            } while (next_permutation(num.begin(),num.end()));\\n            return;\\n        }\\n        if (idx > D) {\\n            return;\\n        }\\n        for (int i = st; i < 10; i++) {\\n            string temp = num;\\n            num += string(i,i+\\'0\\');\\n            generateNums(num,num.length(),i+1,D);\\n            num = temp;\\n        }\\n    }\\n    \\n    int nextBeautifulNumber(int n) {\\n        int D = log(1e6)/log(10) + 3;\\n        for (int i = 1; i <= D; i++) {\\n            string num;\\n            generateNums(num,0,1,i);\\n        }\\n        sort(nums.begin(),nums.end());\\n        auto it = upper_bound(nums.begin(),nums.end(),n);\\n        return *it;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2209885,
                "title": "easy-to-understand-recursive-solution",
                "content": "inspired by @marmik_p\\n```\\nvector<int>v;      // beautiful vector\\nvoid permute(string s){    // to generate permutations of a particular string \\n    do{\\n        v.push_back(stoi(s));   \\n    }while(next_permutation(s.begin(),s.end()));\\n    return;\\n}\\n\\nvoid solve(int cnt,int i,string &s){  //to generate all possible combinations using backtracking\\n    \\n   // cout<<\"value is cnt, i is \"<<cnt<<\", \"<<i<<endl;\\n    \\n    if(cnt+i>7 || i>7){\\n        // cout<<\"returning \\\\n\";\\n        return;\\n     }\\n    for(int j=0;j<i;j++){\\n        s.push_back(\\'0\\'+i); \\n    }\\n    \\n    permute(s);\\n    \\n    // cout<<\"printing s before RC --> \";\\n    // for(int j=0;j<s.size();j++){\\n    //     cout<<s[j];\\n    // }\\n    // cout<<\"\\\\n\\\\n\";\\n   \\n    solve(cnt+i,i+1,s);\\n    \\n    for(int j=0;j<i;j++){\\n        s.pop_back();               //backtracking\\n    }\\n    // cout<<\"printing s after BT \\\\n\";\\n    // for(int j=0;j<s.size();j++){\\n    //     cout<<s[j];\\n    // }\\n    // cout<<\"\\\\n\";\\n    solve(cnt,i+1,s);\\n}\\n\\nclass Solution {\\npublic:\\n    \\n    int nextBeautifulNumber(int n) {\\n                                        \\n      string s=\"\";   //creating beautiful vector\\n      \\n      solve(0,1,s);\\n        \\n      sort(v.begin(),v.end());\\n        \\n        auto it = upper_bound(v.begin(),v.end(),n);\\n        return *it;\\n    }\\n};\\n```\\n",
                "solutionTags": [
                    "C",
                    "Backtracking"
                ],
                "code": "```\\nvector<int>v;      // beautiful vector\\nvoid permute(string s){    // to generate permutations of a particular string \\n    do{\\n        v.push_back(stoi(s));   \\n    }while(next_permutation(s.begin(),s.end()));\\n    return;\\n}\\n\\nvoid solve(int cnt,int i,string &s){  //to generate all possible combinations using backtracking\\n    \\n   // cout<<\"value is cnt, i is \"<<cnt<<\", \"<<i<<endl;\\n    \\n    if(cnt+i>7 || i>7){\\n        // cout<<\"returning \\\\n\";\\n        return;\\n     }\\n    for(int j=0;j<i;j++){\\n        s.push_back(\\'0\\'+i); \\n    }\\n    \\n    permute(s);\\n    \\n    // cout<<\"printing s before RC --> \";\\n    // for(int j=0;j<s.size();j++){\\n    //     cout<<s[j];\\n    // }\\n    // cout<<\"\\\\n\\\\n\";\\n   \\n    solve(cnt+i,i+1,s);\\n    \\n    for(int j=0;j<i;j++){\\n        s.pop_back();               //backtracking\\n    }\\n    // cout<<\"printing s after BT \\\\n\";\\n    // for(int j=0;j<s.size();j++){\\n    //     cout<<s[j];\\n    // }\\n    // cout<<\"\\\\n\";\\n    solve(cnt,i+1,s);\\n}\\n\\nclass Solution {\\npublic:\\n    \\n    int nextBeautifulNumber(int n) {\\n                                        \\n      string s=\"\";   //creating beautiful vector\\n      \\n      solve(0,1,s);\\n        \\n      sort(v.begin(),v.end());\\n        \\n        auto it = upper_bound(v.begin(),v.end(),n);\\n        return *it;\\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 1890981,
                "title": "python-find-all-permutations",
                "content": "```\\n    def nextBeautifulNumber(self, n: int) -> int:\\n        allNums = [[1], [22], [122, 333], [1333, 4444], [14444, 22333, 55555], [122333, 155555, 224444, 666666], [1224444]];\\n\\n        \\n        for lst in allNums:\\n            if len(str(lst[0])) < len(str(n)):\\n                continue\\n            \\n            allPermus = set()\\n            for item in lst:\\n                allPermus.update(itertools.permutations([i for i in str(item)]))\\n\\n            allPermus = [int(\\'\\'.join(i)) for i in allPermus]\\n            allPermus.sort()\\n            for permu in allPermus:\\n                if permu > n:\\n                    return permu\\n        return -1\\n",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\n    def nextBeautifulNumber(self, n: int) -> int:\\n        allNums = [[1], [22], [122, 333], [1333, 4444], [14444, 22333, 55555], [122333, 155555, 224444, 666666], [1224444]];\\n\\n        \\n        for lst in allNums:\\n            if len(str(lst[0])) < len(str(n)):\\n                continue\\n            \\n            allPermus = set()\\n            for item in lst:\\n                allPermus.update(itertools.permutations([i for i in str(item)]))\\n\\n            allPermus = [int(\\'\\'.join(i)) for i in allPermus]\\n            allPermus.sort()\\n            for permu in allPermus:\\n                if permu > n:\\n                    return permu\\n        return -1\\n",
                "codeTag": "Python3"
            },
            {
                "id": 1827813,
                "title": "simple-c-solution-using-hashmap-brute-force-easy-to-understand",
                "content": "\\tclass Solution {\\n\\tpublic:\\n    int nextBeautifulNumber(int n) {\\n        \\n        if(n>=666666){\\n            return 1224444;\\n        }\\n        \\n     \\n        \\n        unordered_map<int,int> mp;\\n        int flag;\\n        for(int i=n+1;i<=666666;i++){\\n            \\n            int m = i;\\n            \\n            while(m){\\n                int rem = m%10;\\n                mp[rem]++;\\n                m=m/10;\\n            }\\n            flag = 0;\\n            for(auto x : mp){\\n                if(x.first!=x.second){\\n                    flag=1;\\n                    mp.clear();\\n                    break;\\n                }\\n            }\\n            \\n            if(flag==0){\\n                return i;\\n            }\\n            \\n        }\\n        \\n        return -1;\\n        \\n    }\\n};",
                "solutionTags": [
                    "C"
                ],
                "code": "class Solution {\\n\\tpublic:\\n    int nextBeautifulNumber(int n) {\\n        \\n        if(n>=666666){\\n            return 1224444;\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 1606818,
                "title": "easy-to-understand-bruteforce-python-w-comments",
                "content": "So this is a classic way to solve some problems:\\nIf you know the solution is within a bound, you can write a check function\\nand then iterate across all the possible solutions. \\n(In some cases you can use binary search, but not this problem since the boolean True results are dispersed throughout the range)\\n\\n```\\nclass Solution(object):\\n    def nextBeautifulNumber(self, n):\\n        \"\"\"\\n        :type n: int\\n        :rtype: int\\n        \"\"\"\\n        #runtime: O(n) searches * O(len(n)) checks = O(n) * constant = O(n)\\n        \\n        # set-up bounds\\n        low = n + 1\\n        high = 1224444  # I came across this number from discussions\\n        digit_len = len(str(n))\\n        if digit_len < 6:\\n            high = 0\\n            power = 1\\n            for i in range(digit_len+1):\\n                high += power * (digit_len+1)\\n                power *= 10\\n                \\n        # Bruteforce from low to high\\n        for i in range(low, high + 1):\\n            if self.isBeautiful(i):\\n                return i\\n        return high\\n        \\n    # given n, check if it is beautiful, a lc easy-level problem\\n    def isBeautiful(self, n):\\n        if n == 0 :\\n            return False\\n        \\n        count_nums = {}\\n        while n:\\n            digit = n % 10\\n            if digit == 0:\\n                return False\\n            if digit in count_nums:\\n                count_nums[digit] += 1\\n                if count_nums[digit] > digit:\\n                    return False\\n            else:\\n                count_nums[digit] = 1\\n            n /= 10\\n        for key, count in count_nums.items():\\n            if key != count:\\n                return False\\n        return True\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution(object):\\n    def nextBeautifulNumber(self, n):\\n        \"\"\"\\n        :type n: int\\n        :rtype: int\\n        \"\"\"\\n        #runtime: O(n) searches * O(len(n)) checks = O(n) * constant = O(n)\\n        \\n        # set-up bounds\\n        low = n + 1\\n        high = 1224444  # I came across this number from discussions\\n        digit_len = len(str(n))\\n        if digit_len < 6:\\n            high = 0\\n            power = 1\\n            for i in range(digit_len+1):\\n                high += power * (digit_len+1)\\n                power *= 10\\n                \\n        # Bruteforce from low to high\\n        for i in range(low, high + 1):\\n            if self.isBeautiful(i):\\n                return i\\n        return high\\n        \\n    # given n, check if it is beautiful, a lc easy-level problem\\n    def isBeautiful(self, n):\\n        if n == 0 :\\n            return False\\n        \\n        count_nums = {}\\n        while n:\\n            digit = n % 10\\n            if digit == 0:\\n                return False\\n            if digit in count_nums:\\n                count_nums[digit] += 1\\n                if count_nums[digit] > digit:\\n                    return False\\n            else:\\n                count_nums[digit] = 1\\n            n /= 10\\n        for key, count in count_nums.items():\\n            if key != count:\\n                return False\\n        return True\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1552251,
                "title": "easy-c-solution-with-explanation",
                "content": "```\\nbool isBeautiful(int n)\\n    {\\n        int freq[10];\\n        for(int i=0;i<10;i++)   // Create a frequency array and initialise freq of digits from 1-9 as 0.\\n            freq[i]=0;\\n        while(n>0)             //Find frequency of each digit of the number greater than n.\\n        {\\n            int rem=n%10;\\n            if(rem==0)         //If we encounter any digit as \\'0\\' then return false because 0 will have frequency 0 i.e. should not be there.\\n                return false;\\n            freq[rem]++;       //Update frequency in freq array\\n            n=n/10;\\n        }\\n        for(int i=1;i<10;i++)\\n        {\\n            if(freq[i]!=0 && freq[i]!=i)   //Check if for each digit the digit=frequency of that digit like 1333 \\n                return false;\\n        }\\n        return true;\\n    }\\n    \\n    \\n\\tint nextBeautifulNumber(int n) \\n    { \\n        while(true)  //until the conditions meet  i.e. 10^6\\n        {\\n            if(isBeautiful(++n))  //check for each number greater than n\\n                return n;\\n        }\\n    }",
                "solutionTags": [],
                "code": "```\\nbool isBeautiful(int n)\\n    {\\n        int freq[10];\\n        for(int i=0;i<10;i++)   // Create a frequency array and initialise freq of digits from 1-9 as 0.\\n            freq[i]=0;\\n        while(n>0)             //Find frequency of each digit of the number greater than n.\\n        {\\n            int rem=n%10;\\n            if(rem==0)         //If we encounter any digit as \\'0\\' then return false because 0 will have frequency 0 i.e. should not be there.\\n                return false;\\n            freq[rem]++;       //Update frequency in freq array\\n            n=n/10;\\n        }\\n        for(int i=1;i<10;i++)\\n        {\\n            if(freq[i]!=0 && freq[i]!=i)   //Check if for each digit the digit=frequency of that digit like 1333 \\n                return false;\\n        }\\n        return true;\\n    }\\n    \\n    \\n\\tint nextBeautifulNumber(int n) \\n    { \\n        while(true)  //until the conditions meet  i.e. 10^6\\n        {\\n            if(isBeautiful(++n))  //check for each number greater than n\\n                return n;\\n        }\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 1543581,
                "title": "28-ms-python-solution",
                "content": "Instead of binary searching the whole array you can do it in buckets. Which I know is an overkill.\\n\\n```\\nclass Solution:\\n            \\n    def nextBeautifulNumber(self, n: int) -> int:                                \\n                \\n        look = {1: [1], 2: [22], 3: [122, 212, 221, 333], 4: [1333, 3133, 3313, 3331, 4444], 5: [14444, 22333, 23233, 23323, 23332, 32233, 32323, 32332, 33223, 33232, 33322, 41444, 44144, 44414, 44441, 55555], 6: [122333, 123233, 123323, 123332, 132233, 132323, 132332, 133223, 133232, 133322, 155555, 212333, 213233, 213323, 213332, 221333, 223133, 223313, 223331, 224444, 231233, 231323, 231332, 232133, 232313, 232331, 233123, 233132, 233213, 233231, 233312, 233321, 242444, 244244, 244424, 244442, 312233, 312323, 312332, 313223, 313232, 313322, 321233, 321323, 321332, 322133, 322313, 322331, 323123, 323132, 323213, 323231, 323312, 323321, 331223, 331232, 331322, 332123, 332132, 332213, 332231, 332312, 332321, 333122, 333212, 333221, 422444, 424244, 424424, 424442, 442244, 442424, 442442, 444224, 444242, 444422, 515555, 551555, 555155, 555515, 555551, 666666], 7: []}\\n                \\n        length = len(str(n))\\n        res = -1                \\n        arr = look[length]  \\n        \\n        l,r = 0,len(arr) - 1        \\n        while(l <= r):\\n            mid = (l + r) // 2\\n            if arr[mid] > n:\\n                res = arr[mid]\\n                r = mid - 1\\n            else:\\n                l = mid + 1\\n                            \\n        if res != -1:\\n            return res\\n        \\n        if n == 10 ** 6 or length + 1 == 7:\\n            return 1224444\\n        \\n        return look[length + 1][0]\\n    \\n\\n\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n            \\n    def nextBeautifulNumber(self, n: int) -> int:                                \\n                \\n        look = {1: [1], 2: [22], 3: [122, 212, 221, 333], 4: [1333, 3133, 3313, 3331, 4444], 5: [14444, 22333, 23233, 23323, 23332, 32233, 32323, 32332, 33223, 33232, 33322, 41444, 44144, 44414, 44441, 55555], 6: [122333, 123233, 123323, 123332, 132233, 132323, 132332, 133223, 133232, 133322, 155555, 212333, 213233, 213323, 213332, 221333, 223133, 223313, 223331, 224444, 231233, 231323, 231332, 232133, 232313, 232331, 233123, 233132, 233213, 233231, 233312, 233321, 242444, 244244, 244424, 244442, 312233, 312323, 312332, 313223, 313232, 313322, 321233, 321323, 321332, 322133, 322313, 322331, 323123, 323132, 323213, 323231, 323312, 323321, 331223, 331232, 331322, 332123, 332132, 332213, 332231, 332312, 332321, 333122, 333212, 333221, 422444, 424244, 424424, 424442, 442244, 442424, 442442, 444224, 444242, 444422, 515555, 551555, 555155, 555515, 555551, 666666], 7: []}\\n                \\n        length = len(str(n))\\n        res = -1                \\n        arr = look[length]  \\n        \\n        l,r = 0,len(arr) - 1        \\n        while(l <= r):\\n            mid = (l + r) // 2\\n            if arr[mid] > n:\\n                res = arr[mid]\\n                r = mid - 1\\n            else:\\n                l = mid + 1\\n                            \\n        if res != -1:\\n            return res\\n        \\n        if n == 10 ** 6 or length + 1 == 7:\\n            return 1224444\\n        \\n        return look[length + 1][0]\\n    \\n\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1542093,
                "title": "c-smartly-add-a-test-case-to-avoid-tle",
                "content": "```\\nclass Solution {\\n    \\n    bool isBalanced(int n)\\n    {\\n        map<int ,int > mp;\\n        \\n        while(n>0)\\n        {\\n            int x = n%10;\\n            mp[x]++;\\n            \\n            n/=10 ;\\n        }\\n        \\n        for(auto x: mp)\\n        {\\n            if(x.first!= x.second) return 0;\\n        }\\n        \\n         return 1;\\n    }\\n    \\npublic:\\n    int nextBeautifulNumber(int n) {\\n        \\n        if( 666666 <= n )\\n        {\\n            return 1224444 ;\\n        }\\n\\n        n++;\\n        \\n        while(true)\\n        {\\n            if(isBalanced(n)) break;\\n            \\n            n++;\\n        }\\n        \\n        return n;\\n    }\\n};",
                "solutionTags": [],
                "code": "class Solution {\\n    \\n    bool isBalanced(int n)\\n    {\\n        map<int ,int > mp;\\n        \\n        while(n>0)\\n        {\\n            int x = n%10;\\n            mp[x]++;\\n            \\n            n/=10 ;\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 1538747,
                "title": "java-next-greater-numerically-balanced-number-100-faster",
                "content": "```\\nclass Solution {\\n    private int lowerBound(int[] arr, int target) {\\n        int l = 0, r = 109;\\n        while (l < r) {\\n            int mid = (l + r) / 2;\\n            if (arr[mid]<= target)\\n                l = mid + 1;\\n            else\\n                r = mid;\\n        }\\n\\n        return arr[l] > target ? arr[l] : -1;\\n    }\\n    \\n    public int nextBeautifulNumber(int n) {\\n        int[] arr = new int[] {1, 22, 122, 212, 221, 333, 1333, 3133, 3313, 3331, 4444, 14444, 22333, 23233, 23323, 23332, 32233, 32323, 32332, 33223, 33232, 33322, 41444, 44144, 44414, 44441, 55555, 122333, 123233, 123323, 123332, 132233, 132323, 132332, 133223, 133232, 133322, 155555, 212333, 213233, 213323, 213332, 221333, 223133, 223313, 223331, 224444, 231233, 231323, 231332, 232133, 232313, 232331, 233123, 233132, 233213, 233231, 233312, 233321, 242444, 244244, 244424, 244442, 312233, 312323, 312332, 313223, 313232, 313322, 321233, 321323, 321332, 322133, 322313, 322331, 323123, 323132, 323213, 323231, 323312, 323321, 331223, 331232, 331322, 332123, 332132, 332213, 332231, 332312, 332321, 333122, 333212, 333221, 422444, 424244, 424424, 424442, 442244, 442424, 442442, 444224, 444242, 444422, 515555, 551555, 555155, 555515, 555551, 666666, 1224444};\\n        \\n        return lowerBound(arr, n);\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Binary Search Tree"
                ],
                "code": "```\\nclass Solution {\\n    private int lowerBound(int[] arr, int target) {\\n        int l = 0, r = 109;\\n        while (l < r) {\\n            int mid = (l + r) / 2;\\n            if (arr[mid]<= target)\\n                l = mid + 1;\\n            else\\n                r = mid;\\n        }\\n\\n        return arr[l] > target ? arr[l] : -1;\\n    }\\n    \\n    public int nextBeautifulNumber(int n) {\\n        int[] arr = new int[] {1, 22, 122, 212, 221, 333, 1333, 3133, 3313, 3331, 4444, 14444, 22333, 23233, 23323, 23332, 32233, 32323, 32332, 33223, 33232, 33322, 41444, 44144, 44414, 44441, 55555, 122333, 123233, 123323, 123332, 132233, 132323, 132332, 133223, 133232, 133322, 155555, 212333, 213233, 213323, 213332, 221333, 223133, 223313, 223331, 224444, 231233, 231323, 231332, 232133, 232313, 232331, 233123, 233132, 233213, 233231, 233312, 233321, 242444, 244244, 244424, 244442, 312233, 312323, 312332, 313223, 313232, 313322, 321233, 321323, 321332, 322133, 322313, 322331, 323123, 323132, 323213, 323231, 323312, 323321, 331223, 331232, 331322, 332123, 332132, 332213, 332231, 332312, 332321, 333122, 333212, 333221, 422444, 424244, 424424, 424442, 442244, 442424, 442442, 444224, 444242, 444422, 515555, 551555, 555155, 555515, 555551, 666666, 1224444};\\n        \\n        return lowerBound(arr, n);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1537984,
                "title": "java-c-straightforward-solution",
                "content": "\\n```\\nJAVA\\nclass Solution {\\n\\n    public boolean isBalanced(int n){\\n        int num = n;\\n        \\n        int[] arr = new int[10];\\n        while(num != 0){\\n            int rem = num%10;\\n            arr[rem]++;\\n            num /= 10;\\n        }\\n        \\n        for(int i = 0; i < 10; i++){\\n            if(arr[i] == 0) continue;\\n            if(arr[i] != i) return false;\\n        }\\n        return true;\\n    }\\n    \\n    public int nextBeautifulNumber(int n) {\\n        n = n+1;\\n        while(isBalanced(n) == false){\\n            n++;\\n        }\\n        return n;\\n    }\\n}\\n\\n\\nC++\\nclass Solution {\\npublic:\\n    \\n    bool isBalanced(int n){\\n        int num = n;\\n        \\n        int arr[10];\\n        for(int i = 0; i < 10; i++) arr[i] = 0;\\n        \\n        while(num != 0){\\n            int rem = num%10;\\n            arr[rem]++;\\n            num /= 10;\\n        }\\n        \\n        for(int i = 0; i < 10; i++){\\n            if(arr[i] == 0) continue;\\n            if(arr[i] != i) return false;\\n        }\\n        return true;\\n    }\\n    \\n    int nextBeautifulNumber(int n) {\\n        n = n+1;\\n        while(isBalanced(n) == false){\\n            n++;\\n        }\\n        return n;\\n    }\\n};\\n",
                "solutionTags": [],
                "code": "class Solution {\\n\\n    public boolean isBalanced(int n){\\n        int num = n;\\n        \\n        int[] arr = new int[10];\\n        while(num != 0){\\n            int rem = num%10;\\n            arr[rem]++;\\n            num /= 10;\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 1537735,
                "title": "python-check-possible-combinations-of-within-1-2-digit-length-with-explanation",
                "content": "Since we want the smallest balanced number that is greater than the input, we need the length of the output to be at least the same length in digit or 1 larger.\\nFor a number to be a balanced number, it only has a limited combination. With the input **n** restricted to be less than `10^6`, we can map out the possible combination with dictionary like this:\\n```\\nd ={\\n\\t1: [[1]],\\n\\t2: [[2]],\\n\\t3: [[1,2],[3]],\\n\\t4: [[1,3], [4]],\\n\\t5: [[1,4], [2,3],[5]],\\n\\t6: [[1,2,3], [1,5], [2,4],[6]],\\n\\t7: [[1,6],[1,2,4],[2,5],[3,4],[7]],\\n\\t8: [[1,7],[3,5],[1,3,4],[2,6],[8]]\\n}\\n```\\nWith a given n, we want to check its current digit length\\'s all combination, if there are valid answers, we will return the smallest one, if not, we will move to digit count + 1.\\nTo check each arrangement in each digit count, I first multiply the amount of each of the number in each combination by itself. This might sound a bit confusing but we can visualize it below with example of digit count 5:\\n```\\n5: [[1,4], [2,3],[5]]\\n[1,4,4,4], [2,2,3,3,3], [5,5,5,5,5]\\n```\\nWe will product list of second line from the first line when digit count 5 is called.\\nI used itertools to brute force and get all the different rearrangement for each of the combinations.\\nFor each combination, combine the list of integers to string and then check if the int() of said string is greater than n, if it is, store it in the result list.\\nAfter finishing checking a digit count and if result is found, return the minimum from the result list, else move to the next digit count.\\n\\n**Code**:\\n```\\nclass Solution:\\n    def nextBeautifulNumber(self, n: int) -> int:\\n        d ={\\n            1: [[1]],\\n            2: [[2]],\\n            3: [[1,2],[3]],\\n            4: [[1,3], [4]],\\n            5: [[1,4], [2,3],[5]],\\n            6: [[1,2,3], [1,5], [2,4],[6]],\\n            7: [[1,6],[1,2,4],[2,5],[3,4],[7]],\\n            8: [[1,7],[3,5],[1,3,4],[2,6],[8]]\\n        }\\n        l = len(str(n))\\n        found = False # Whether a balanced number greater than n has been found\\n        curr_comb = d[l] # Get the combination for current length \\n        res = [] # Store all the valid balanced numbers\\n        while not found: # While no answers have been found\\n            for comb in curr_comb:\\n                temp = [] \\n                for num in comb:\\n                    temp += [num]*num # To repeat\\n                all_arrang = set(itertools.permutations(temp)) # Get all arrangements\\n                for i in all_arrang:\\n                    s2=\\'\\'\\n                    # Combine the arrangement into string\\n                    for char in i:\\n                        s2 = s2+str(char)\\n                    # If the string is balanced and above n\\n                    if int(s2)> n:\\n                        found = True\\n                        res.append(int(s2))\\n            # If the result is not found, we need to go to a higher digit count\\n            if not found:\\n                l+=1\\n                curr_comb = d[l]\\n        return min(res)\\n```\\n\\n**Example:**\\n`n = 7000`\\n`digit count = 4`\\n`4: [[1,3], [4]]` Get 4 from dictionary\\n`[1,3,3,3],[4,4,4,4] `Possible combinations\\n`1333, 3133, 3313, 3331, 4444` are possible balanced number with 4 digit\\nSince none are larger than 7000, check `digit count = 5`\\n`[1, 4, 4, 4, 4], [2, 2, 3, 3, 3],[5, 5, 5, 5, 5]` Possible combinations for 5\\n`14444,44441,44144,44414,41444,32233,33232,23233,23323,32323,22333,33322,33223,23332,32332,55555`\\nWe will return the smallest one which will be 14444",
                "solutionTags": [],
                "code": "```\\nd ={\\n\\t1: [[1]],\\n\\t2: [[2]],\\n\\t3: [[1,2],[3]],\\n\\t4: [[1,3], [4]],\\n\\t5: [[1,4], [2,3],[5]],\\n\\t6: [[1,2,3], [1,5], [2,4],[6]],\\n\\t7: [[1,6],[1,2,4],[2,5],[3,4],[7]],\\n\\t8: [[1,7],[3,5],[1,3,4],[2,6],[8]]\\n}\\n```\n```\\n5: [[1,4], [2,3],[5]]\\n[1,4,4,4], [2,2,3,3,3], [5,5,5,5,5]\\n```\n```\\nclass Solution:\\n    def nextBeautifulNumber(self, n: int) -> int:\\n        d ={\\n            1: [[1]],\\n            2: [[2]],\\n            3: [[1,2],[3]],\\n            4: [[1,3], [4]],\\n            5: [[1,4], [2,3],[5]],\\n            6: [[1,2,3], [1,5], [2,4],[6]],\\n            7: [[1,6],[1,2,4],[2,5],[3,4],[7]],\\n            8: [[1,7],[3,5],[1,3,4],[2,6],[8]]\\n        }\\n        l = len(str(n))\\n        found = False # Whether a balanced number greater than n has been found\\n        curr_comb = d[l] # Get the combination for current length \\n        res = [] # Store all the valid balanced numbers\\n        while not found: # While no answers have been found\\n            for comb in curr_comb:\\n                temp = [] \\n                for num in comb:\\n                    temp += [num]*num # To repeat\\n                all_arrang = set(itertools.permutations(temp)) # Get all arrangements\\n                for i in all_arrang:\\n                    s2=\\'\\'\\n                    # Combine the arrangement into string\\n                    for char in i:\\n                        s2 = s2+str(char)\\n                    # If the string is balanced and above n\\n                    if int(s2)> n:\\n                        found = True\\n                        res.append(int(s2))\\n            # If the result is not found, we need to go to a higher digit count\\n            if not found:\\n                l+=1\\n                curr_comb = d[l]\\n        return min(res)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1537733,
                "title": "not-a-good-question-at-all-c",
                "content": "```\\n    bool isvalid(int i)\\n    {\\n        map<int,int> mp;\\n        while(i)\\n        {\\n            mp[i%10]++;\\n            i/=10;\\n        }\\n        // Checking if the all digits d has d occurence or not \\n        for(auto x: mp)\\n            if(x.first!=x.second)return false;\\n        \\n           return true;\\n    }\\n    \\n    int nextBeautifulNumber(int n) {\\n        // Hard Coding the large value\\n        if(n>=666666)return 1224444;\\n        \\n        // Brute force for small value\\n        for(int i=n+1;i<=666666;i++)\\n        {\\n            if(isvalid(i))\\n                return i;\\n        }\\n        return 0;\\n    }\\n```",
                "solutionTags": [],
                "code": "```\\n    bool isvalid(int i)\\n    {\\n        map<int,int> mp;\\n        while(i)\\n        {\\n            mp[i%10]++;\\n            i/=10;\\n        }\\n        // Checking if the all digits d has d occurence or not \\n        for(auto x: mp)\\n            if(x.first!=x.second)return false;\\n        \\n           return true;\\n    }\\n    \\n    int nextBeautifulNumber(int n) {\\n        // Hard Coding the large value\\n        if(n>=666666)return 1224444;\\n        \\n        // Brute force for small value\\n        for(int i=n+1;i<=666666;i++)\\n        {\\n            if(isvalid(i))\\n                return i;\\n        }\\n        return 0;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1537706,
                "title": "c-generate-all-valid-numbers-26ms",
                "content": "Brute force works pretty well in this contest.\\nBut I think the following will work better for an interview...\\n\\n```\\nclass Solution {\\npublic:\\n    int nextBeautifulNumber(int n) {\\n        int d = count_digits(n);\\n        \\n        vector<vector<vector<int>>> comb(d + 2);\\n        vector<int> cand;\\n        for (int i = 1; i <= d + 1; ++i) {\\n            // generate the following, this will generate some invalid ones such as (1, 1, 2) for 4-digits, which will be filtered out later\\n            // 1-digit: (1)\\n            // 2-digit: (2)\\n            // 3-digit: (3), (1, 2)\\n            // 4-digit: (4), (1, 3)\\n            // 5-digit: (5), (1, 4), (2, 3)\\n            // ...\\n            comb[i].push_back({i});\\n            for (int j = 1; j < i && j < i - j; ++j) {\\n                for (const auto &a: comb[j]) {\\n                    for (const auto &b: comb[i-j]) {\\n                        comb[i].push_back(a);\\n                        comb[i].back().insert(comb[i].back().end(), b.begin(), b.end());\\n                    }\\n                }\\n            }\\n\\t\\t\\t\\n\\t\\t\\t if (i < d) continue; // can not be greater than n\\n        \\n            for (auto &c: comb[i]) {\\n                vector<int> cnt(d + 2);\\n                int total = 0;\\n                for (int num: c) {\\n                    cnt[num] = num;\\n                    total += num;\\n                }\\n                // filter out invalid cases\\n                bool ok = true;\\n                for (int j = 1; j <= d + 1; ++j) {\\n                    if (cnt[j] > 0 && cnt[j] != j) {\\n                        ok = false;\\n                        break;\\n                    }\\n                }\\n                if (ok) dfs(cnt, 0, total, cand);\\n            }\\n        }\\n        sort(cand.begin(), cand.end());\\n        for (int v: cand) {\\n            if (v > n) return v;\\n        }\\n        return -1;\\n    }\\n    \\n    void dfs(vector<int> &cnt, int cur, int total, vector<int> &cand) {\\n        int n = cnt.size();\\n        if (total == 0) {\\n            cand.push_back(cur);\\n            return;\\n        }\\n        for (int i = 1; i < n; ++i) {\\n            if (cnt[i] > 0) {\\n                --cnt[i];\\n                dfs(cnt, cur * 10 + i, total - 1, cand);\\n                ++cnt[i];\\n            }\\n        }\\n    }\\n    \\n    int count_digits(int n) {\\n        int cnt = 0;\\n        while (n) {\\n            ++cnt;\\n            n /= 10;\\n        }\\n        return cnt;\\n    }\\n};",
                "solutionTags": [
                    "C",
                    "Depth-First Search"
                ],
                "code": "class Solution {\\npublic:\\n    int nextBeautifulNumber(int n) {\\n        int d = count_digits(n);\\n        \\n        vector<vector<vector<int>>> comb(d + 2);\\n        vector<int> cand;\\n        for (int i = 1; i <= d + 1; ++i) {\\n            // generate the following, this will generate some invalid ones such as (1, 1, 2) for 4-digits, which will be filtered out later\\n            // 1-digit: (1)\\n            // 2-digit: (2)\\n            // 3-digit: (3), (1, 2)\\n            // 4-digit: (4), (1, 3)\\n            // 5-digit: (5), (1, 4), (2, 3)\\n            // ...\\n            comb[i].push_back({i}",
                "codeTag": "Java"
            },
            {
                "id": 1537701,
                "title": "simple-javascript-solution-explained",
                "content": "```\\n/**\\n * @param {number} n\\n * @return {number}\\n */\\nvar nextBeautifulNumber = function(n) {\\n    //1224444 is next minimum balanced number after 10^6\\n    for(let i=n+1; i<=1224444;i++){//Sequency check each number from n+1 to 1224444\\n        if(isNumericallyBalanced(i)){\\n            return i;//Return the number if is a balanced number\\n        }\\n    }\\n    function isNumericallyBalanced(n){\\n        let map={},d,nStr=n.toString();\\n        while(n>0){//Create a map of digits with frequency\\n            d = n%10;\\n            if(d>nStr.length){//If we have found a digit greater than the lenght of the number like 227333, here when we see 7, we can return false\\n                return false;\\n            }\\n            if(map[d]===undefined){\\n                map[d]=1;\\n            }else{\\n                map[d]++;\\n                if(map[d]>d){//If a digit has frequency more than its value, for example 22333344, here when we see fourth 3 than we can return false\\n                    return false;\\n                }\\n            }\\n            n = Math.floor(n/10);\\n        }\\n        for(let key in map){//Check if frequency is equal to the digit\\n            if(map[key]!==parseInt(key)){\\n                return false;\\n            }\\n        }\\n        return true;\\n    }\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {number} n\\n * @return {number}\\n */\\nvar nextBeautifulNumber = function(n) {\\n    //1224444 is next minimum balanced number after 10^6\\n    for(let i=n+1; i<=1224444;i++){//Sequency check each number from n+1 to 1224444\\n        if(isNumericallyBalanced(i)){\\n            return i;//Return the number if is a balanced number\\n        }\\n    }\\n    function isNumericallyBalanced(n){\\n        let map={},d,nStr=n.toString();\\n        while(n>0){//Create a map of digits with frequency\\n            d = n%10;\\n            if(d>nStr.length){//If we have found a digit greater than the lenght of the number like 227333, here when we see 7, we can return false\\n                return false;\\n            }\\n            if(map[d]===undefined){\\n                map[d]=1;\\n            }else{\\n                map[d]++;\\n                if(map[d]>d){//If a digit has frequency more than its value, for example 22333344, here when we see fourth 3 than we can return false\\n                    return false;\\n                }\\n            }\\n            n = Math.floor(n/10);\\n        }\\n        for(let key in map){//Check if frequency is equal to the digit\\n            if(map[key]!==parseInt(key)){\\n                return false;\\n            }\\n        }\\n        return true;\\n    }\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1537700,
                "title": "worst-solution",
                "content": "Basic Intuision: Check if n is the beautiful number.\\nHow?\\nPut the number of occurence of each digit to arr[10];\\nIf arr[i] != i, then it is not beautiful number.\\n\\n```\\n   bool isbeautiful(int n){\\n        int arr[10] = {};\\n        while(n){\\n            arr[n%10]++;\\n            n /=10;\\n        }\\n        for(int i=0;i<10;++i){\\n            if(arr[i]>0 && arr[i]!=i)\\n                return false;\\n        }\\n        return true;\\n    }\\n    int nextBeautifulNumber(int n) {\\n        n++;\\n        while(true){\\n            if(isbeautiful(n))\\n                return n;\\n            n++;\\n        }\\n    }\\n```",
                "solutionTags": [],
                "code": "```\\n   bool isbeautiful(int n){\\n        int arr[10] = {};\\n        while(n){\\n            arr[n%10]++;\\n            n /=10;\\n        }\\n        for(int i=0;i<10;++i){\\n            if(arr[i]>0 && arr[i]!=i)\\n                return false;\\n        }\\n        return true;\\n    }\\n    int nextBeautifulNumber(int n) {\\n        n++;\\n        while(true){\\n            if(isbeautiful(n))\\n                return n;\\n            n++;\\n        }\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1537691,
                "title": "python-solution-that-beats-100-with-backtracking-to-enumerate-possible-beautiful-numbers",
                "content": "```python\\nclass Solution:\\n    def __init__(self):\\n        self.result = None\\n        self.n = 0\\n\\n    def getNextBeautifulNumbersFromSet(self, digit_set):\\n        digits = []\\n        for digit in digit_set:\\n            digits += [digit] * digit\\n        \\n        def backtrack(prefix, remaining_digits):\\n            num_remaining_digits = len(remaining_digits)\\n            if num_remaining_digits == 0:\\n                if prefix > self.n and (self.result is None or prefix < self.result):\\n                    self.result = prefix\\n                return\\n            \\n            for next_digit in set(remaining_digits):\\n                new_prefix = prefix + next_digit * 10 ** (num_remaining_digits - 1)\\n                if self.result is None or new_prefix < self.result:\\n                    remaining_digits.remove(next_digit)\\n                    backtrack(new_prefix, remaining_digits)\\n                    remaining_digits.append(next_digit)\\n        \\n        backtrack(0, digits)\\n            \\n    \\n    def getDigitSets(self, num_digits):\\n        valid_digit_sets = []\\n\\n        def backtrack(prior_digit_set, num_digits):\\n            if num_digits < 1:\\n                valid_digit_sets.append(set(prior_digit_set))\\n                return \\n            for next_digit in range(num_digits, 0, -1):\\n                if next_digit not in prior_digit_set:\\n                    prior_digit_set.add(next_digit)\\n                    backtrack(prior_digit_set, num_digits - next_digit)\\n                    prior_digit_set.remove(next_digit)\\n\\n        backtrack(set(), num_digits)\\n        return valid_digit_sets\\n    \\n    \\n    def getNextBeautifulNumbers(self, num_digits):\\n        valid_digit_sets = self.getDigitSets(num_digits)\\n        \\n        for digit_set in valid_digit_sets:\\n            self.getNextBeautifulNumbersFromSet(digit_set)\\n        \\n                \\n    def nextBeautifulNumber(self, n: int) -> int:        \\n        num_digits = 1\\n        k = n\\n        while k >= 10:\\n            num_digits += 1\\n            k = k // 10\\n        \\n        self.n = n\\n        \\n        self.getNextBeautifulNumbers(num_digits)\\n        \\n        if self.result is None:\\n            self.getNextBeautifulNumbers(num_digits + 1)            \\n        \\n        return self.result\\n\\n```\\n",
                "solutionTags": [
                    "Python",
                    "Backtracking"
                ],
                "code": "```python\\nclass Solution:\\n    def __init__(self):\\n        self.result = None\\n        self.n = 0\\n\\n    def getNextBeautifulNumbersFromSet(self, digit_set):\\n        digits = []\\n        for digit in digit_set:\\n            digits += [digit] * digit\\n        \\n        def backtrack(prefix, remaining_digits):\\n            num_remaining_digits = len(remaining_digits)\\n            if num_remaining_digits == 0:\\n                if prefix > self.n and (self.result is None or prefix < self.result):\\n                    self.result = prefix\\n                return\\n            \\n            for next_digit in set(remaining_digits):\\n                new_prefix = prefix + next_digit * 10 ** (num_remaining_digits - 1)\\n                if self.result is None or new_prefix < self.result:\\n                    remaining_digits.remove(next_digit)\\n                    backtrack(new_prefix, remaining_digits)\\n                    remaining_digits.append(next_digit)\\n        \\n        backtrack(0, digits)\\n            \\n    \\n    def getDigitSets(self, num_digits):\\n        valid_digit_sets = []\\n\\n        def backtrack(prior_digit_set, num_digits):\\n            if num_digits < 1:\\n                valid_digit_sets.append(set(prior_digit_set))\\n                return \\n            for next_digit in range(num_digits, 0, -1):\\n                if next_digit not in prior_digit_set:\\n                    prior_digit_set.add(next_digit)\\n                    backtrack(prior_digit_set, num_digits - next_digit)\\n                    prior_digit_set.remove(next_digit)\\n\\n        backtrack(set(), num_digits)\\n        return valid_digit_sets\\n    \\n    \\n    def getNextBeautifulNumbers(self, num_digits):\\n        valid_digit_sets = self.getDigitSets(num_digits)\\n        \\n        for digit_set in valid_digit_sets:\\n            self.getNextBeautifulNumbersFromSet(digit_set)\\n        \\n                \\n    def nextBeautifulNumber(self, n: int) -> int:        \\n        num_digits = 1\\n        k = n\\n        while k >= 10:\\n            num_digits += 1\\n            k = k // 10\\n        \\n        self.n = n\\n        \\n        self.getNextBeautifulNumbers(num_digits)\\n        \\n        if self.result is None:\\n            self.getNextBeautifulNumbers(num_digits + 1)            \\n        \\n        return self.result\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1537689,
                "title": "another-accepted-java-solution-though-does-not-lean-towards-time-efficiency",
                "content": "*The idea is to put all the digits of a number in a **hashmap** with digits as the key and the number of times it appeared in the number as the value.*\\n```\\nclass Solution {\\n    public int nextBeautifulNumber(int n) {\\n        if(n <= 0) return 1;\\n        int flag=0;\\n        n += 1;\\n        while(true) {\\n            String str = \"\"+n;\\n            Map<Integer, Integer> map = new HashMap<>();\\n\\n            for(int i=0; i<str.length(); i++) {\\n                int digit = (int)str.charAt(i)-\\'0\\';\\n                if(map.containsKey(digit)) map.put(digit, map.get(digit)+1);\\n                else map.put(digit, 1);\\n            }\\n            for(int i: map.keySet()) {\\n                if(map.get(i) != i) {\\n                    flag=0;\\n                    break;\\n                }\\n                else flag=1;\\n            }\\n            if(flag == 1) break;\\n            n++;\\n        }\\n        return n;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int nextBeautifulNumber(int n) {\\n        if(n <= 0) return 1;\\n        int flag=0;\\n        n += 1;\\n        while(true) {\\n            String str = \"\"+n;\\n            Map<Integer, Integer> map = new HashMap<>();\\n\\n            for(int i=0; i<str.length(); i++) {\\n                int digit = (int)str.charAt(i)-\\'0\\';\\n                if(map.containsKey(digit)) map.put(digit, map.get(digit)+1);\\n                else map.put(digit, 1);\\n            }\\n            for(int i: map.keySet()) {\\n                if(map.get(i) != i) {\\n                    flag=0;\\n                    break;\\n                }\\n                else flag=1;\\n            }\\n            if(flag == 1) break;\\n            n++;\\n        }\\n        return n;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1537619,
                "title": "java-short",
                "content": "```\\nclass Solution {\\n    public int nextBeautifulNumber(int n) {\\n        for(int i=n+1;;i++)\\n            if(isNumericallyBalanced(i)) return i;\\n    }\\n    private boolean isNumericallyBalanced(int n) {\\n        int[] count = new int[10];\\n        for(;n>0;n/=10)\\n            if(++count[n%10] > n%10) return false;\\n        for(int i=1;i<10;i++) \\n            if(count[i] != 0 && count[i] != i) return false;\\n        return true;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int nextBeautifulNumber(int n) {\\n        for(int i=n+1;;i++)\\n            if(isNumericallyBalanced(i)) return i;\\n    }\\n    private boolean isNumericallyBalanced(int n) {\\n        int[] count = new int[10];\\n        for(;n>0;n/=10)\\n            if(++count[n%10] > n%10) return false;\\n        for(int i=1;i<10;i++) \\n            if(count[i] != 0 && count[i] != i) return false;\\n        return true;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1537588,
                "title": "c-easy-simple-code-next-permutation",
                "content": "```\\nclass Solution {\\npublic:\\n    int go(int n){\\n       map<int, vector<string>> mp;\\n       mp[1].push_back(\"1\");\\n       mp[2].push_back(\"22\");\\n       mp[3].push_back(\"122\"); \\n       mp[3].push_back(\"333\"); \\n       mp[4].push_back(\"1333\"); \\n       mp[4].push_back(\"4444\"); \\n       mp[5].push_back(\"14444\");\\n       mp[5].push_back(\"22333\"); \\n       mp[5].push_back(\"55555\"); \\n       mp[6].push_back(\"122333\");   \\n       mp[6].push_back(\"155555\");\\n       mp[6].push_back(\"224444\");\\n       mp[6].push_back(\"666666\");   \\n       mp[7].push_back(\"1224444\");\\n        \\n       string ss = to_string(n);\\n       int nn = ss.size(); \\n       int nm;\\n       int ans = INT_MAX;\\n        \\n       for(string s : mp[nn]){\\n           do{\\n               nm = stoi(s);\\n               if(nm > n) {\\n                   ans = min(ans, nm);\\n               }\\n           } while(next_permutation(s.begin(), s.end()));\\n       }\\n       if(nn != 7){\\n            nm  = stoi(mp[nn + 1][0]);\\n            ans = min(ans, nm);\\n       }\\n       return ans; \\n    }\\n    int nextBeautifulNumber(int n) {\\n        return go(n);\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int go(int n){\\n       map<int, vector<string>> mp;\\n       mp[1].push_back(\"1\");\\n       mp[2].push_back(\"22\");\\n       mp[3].push_back(\"122\"); \\n       mp[3].push_back(\"333\"); \\n       mp[4].push_back(\"1333\"); \\n       mp[4].push_back(\"4444\"); \\n       mp[5].push_back(\"14444\");\\n       mp[5].push_back(\"22333\"); \\n       mp[5].push_back(\"55555\"); \\n       mp[6].push_back(\"122333\");   \\n       mp[6].push_back(\"155555\");\\n       mp[6].push_back(\"224444\");\\n       mp[6].push_back(\"666666\");   \\n       mp[7].push_back(\"1224444\");\\n        \\n       string ss = to_string(n);\\n       int nn = ss.size(); \\n       int nm;\\n       int ans = INT_MAX;\\n        \\n       for(string s : mp[nn]){\\n           do{\\n               nm = stoi(s);\\n               if(nm > n) {\\n                   ans = min(ans, nm);\\n               }\\n           } while(next_permutation(s.begin(), s.end()));\\n       }\\n       if(nn != 7){\\n            nm  = stoi(mp[nn + 1][0]);\\n            ans = min(ans, nm);\\n       }\\n       return ans; \\n    }\\n    int nextBeautifulNumber(int n) {\\n        return go(n);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1537569,
                "title": "c-solution-beat-100",
                "content": "```\\nint nextBeautifulNumber(int n) {\\n        if (n == 0)\\n            return 1;\\n        if (n < 22)\\n            return 22;\\n        string ori = std::to_string(n);\\n        int digits = ori.size();\\n        if (digits == 7)\\n            return 1224444;\\n        \\n        string min = \"\";\\n        for (int i = 0; i < digits; ++i) {\\n            min += (\\'0\\' + digits);\\n        }\\n        \\n        std::unordered_map<int, vector<string>> mp;\\n        mp[3].push_back(\"122\");\\n        mp[3].push_back(\"333\");\\n        \\n        mp[4].push_back(\"1333\");\\n        mp[4].push_back(\"4444\");\\n        \\n        mp[5].push_back(\"14444\");\\n        mp[5].push_back(\"22333\");\\n        mp[5].push_back(\"55555\");\\n        \\n        mp[6].push_back(\"122333\");\\n        mp[6].push_back(\"224444\");\\n        mp[6].push_back(\"155555\");\\n        mp[6].push_back(\"666666\");\\n        \\n        mp[7].push_back(\"1224444\");\\n        \\n        string res = \"\";\\n        if (min <= ori) {\\n            return std::stoi(mp[digits + 1].front());\\n        } else {\\n           for (string str : mp[digits]) {\\n               do {\\n                   if (str > ori) {\\n                      if (!res.empty() && str < res) {\\n                         res = str;\\n                      } else if (res.empty()){\\n                          res = str;\\n                      }\\n                   }\\n               } while (next_permutation(str.begin(), str.end()));\\n           }\\n        }\\n        \\n        return std::stoi(res);\\n    }",
                "solutionTags": [],
                "code": "```\\nint nextBeautifulNumber(int n) {\\n        if (n == 0)\\n            return 1;\\n        if (n < 22)\\n            return 22;\\n        string ori = std::to_string(n);\\n        int digits = ori.size();\\n        if (digits == 7)\\n            return 1224444;\\n        \\n        string min = \"\";\\n        for (int i = 0; i < digits; ++i) {\\n            min += (\\'0\\' + digits);\\n        }\\n        \\n        std::unordered_map<int, vector<string>> mp;\\n        mp[3].push_back(\"122\");\\n        mp[3].push_back(\"333\");\\n        \\n        mp[4].push_back(\"1333\");\\n        mp[4].push_back(\"4444\");\\n        \\n        mp[5].push_back(\"14444\");\\n        mp[5].push_back(\"22333\");\\n        mp[5].push_back(\"55555\");\\n        \\n        mp[6].push_back(\"122333\");\\n        mp[6].push_back(\"224444\");\\n        mp[6].push_back(\"155555\");\\n        mp[6].push_back(\"666666\");\\n        \\n        mp[7].push_back(\"1224444\");\\n        \\n        string res = \"\";\\n        if (min <= ori) {\\n            return std::stoi(mp[digits + 1].front());\\n        } else {\\n           for (string str : mp[digits]) {\\n               do {\\n                   if (str > ori) {\\n                      if (!res.empty() && str < res) {\\n                         res = str;\\n                      } else if (res.empty()){\\n                          res = str;\\n                      }\\n                   }\\n               } while (next_permutation(str.begin(), str.end()));\\n           }\\n        }\\n        \\n        return std::stoi(res);\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 1537567,
                "title": "python-3-bitmask-clean-explanation",
                "content": "### Explanation\\n- The brute-force solution is cool, this might give you a bit more insight on the actual important balanced numbers\\n- Use `itertools.product` to make a bitmask so that we can pick numbers from `base` to form a combination\\n- Permute each combination to get different valid balanced numbers, sort them and use for later\\n- Total scale is between `O(10^5)` and `O(10^6)`\\n### Implementation\\n```\\nclass Solution:\\n    def __init__(self):\\n        base = [\\'1\\', \\'22\\', \\'333\\', \\'4444\\', \\'55555\\', \\'666666\\']\\n        nums = set()\\n        for comb in itertools.product([0,1], repeat=6):              # 64 combinations\\n            cur = \\'\\'\\n            for i, val in enumerate(comb):\\n                cur += base[i] if val else \\'\\'\\n            if len(cur) > 7:                                         # max `n` is 10^6, which is 7 digits\\n                continue \\n            if cur:                                                  # permute all valid combinations\\n                nums |= set(itertools.permutations(cur, len(cur)))   # about 10^4\\n        nums = sorted([int(\\'\\'.join(num)) for num in nums|set(base)]) # convert tuple to integer and sort           \\n        self.nums = nums\\n    def nextBeautifulNumber(self, n: int) -> int:\\n        idx = bisect.bisect_right(self.nums, n)                      # binary search\\n        return self.nums[idx]                                        # return answer\\n```",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Bitmask"
                ],
                "code": "```\\nclass Solution:\\n    def __init__(self):\\n        base = [\\'1\\', \\'22\\', \\'333\\', \\'4444\\', \\'55555\\', \\'666666\\']\\n        nums = set()\\n        for comb in itertools.product([0,1], repeat=6):              # 64 combinations\\n            cur = \\'\\'\\n            for i, val in enumerate(comb):\\n                cur += base[i] if val else \\'\\'\\n            if len(cur) > 7:                                         # max `n` is 10^6, which is 7 digits\\n                continue \\n            if cur:                                                  # permute all valid combinations\\n                nums |= set(itertools.permutations(cur, len(cur)))   # about 10^4\\n        nums = sorted([int(\\'\\'.join(num)) for num in nums|set(base)]) # convert tuple to integer and sort           \\n        self.nums = nums\\n    def nextBeautifulNumber(self, n: int) -> int:\\n        idx = bisect.bisect_right(self.nums, n)                      # binary search\\n        return self.nums[idx]                                        # return answer\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1537521,
                "title": "sad-solution-enumerate",
                "content": "I enumerated all numbers.\\nHad 7 bugs. Turns out that I am not good at alg or math or even typing accurately.\\n```\\nclass Solution:\\n    def nextBeautifulNumber(self, n: int) -> int:\\n        l = [1, 22, 122, 212, 221, 333, \\n             1333, 3133, 3313, 3331, 4444, \\n             14444,\\n             22333,\\n             23233, 23323, 23332,\\n             32233, 32323, 32332, \\n             33223, 33232, 33322,\\n             41444, 44144, 44414, 44441, \\n             55555,\\n             122333, 123233, 123323, 123332,\\n             132233, 132323, 132332, 133223, 133232, 133322,\\n             155555,\\n             212333, 213233, 213323, 213332, \\n             221333, 223133, 223313, 223331,\\n             224444, \\n             231233, 231323, 231332, \\n             232133, 232313, 232331, \\n             233123, 233132, 233213, 233231, 233312, 233321,\\n             242444, 244244, 244424, 244442,\\n             312233, 312323, 312332, \\n             313223, 313232, 313322,\\n             321233, 321323, 321332,\\n             322133, 322313, 322331,\\n             323123, 323132, 323213, 323231, 323312, 323321,\\n             331223, 331232, 331322,\\n             332123, 332132, 332213, 332231, 332312, 332321,\\n             333122, 333212, 333221,\\n             422444, 424244, 424424, 424442,\\n             442244, 442424, 442442, \\n             444224, 444242, 444422,\\n             515555, 551555, 555155, 555515, 555551,\\n             666666,\\n             1224444,\\n            ]\\n        \\n        return l[bisect.bisect_right(l, n)]\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def nextBeautifulNumber(self, n: int) -> int:\\n        l = [1, 22, 122, 212, 221, 333, \\n             1333, 3133, 3313, 3331, 4444, \\n             14444,\\n             22333,\\n             23233, 23323, 23332,\\n             32233, 32323, 32332, \\n             33223, 33232, 33322,\\n             41444, 44144, 44414, 44441, \\n             55555,\\n             122333, 123233, 123323, 123332,\\n             132233, 132323, 132332, 133223, 133232, 133322,\\n             155555,\\n             212333, 213233, 213323, 213332, \\n             221333, 223133, 223313, 223331,\\n             224444, \\n             231233, 231323, 231332, \\n             232133, 232313, 232331, \\n             233123, 233132, 233213, 233231, 233312, 233321,\\n             242444, 244244, 244424, 244442,\\n             312233, 312323, 312332, \\n             313223, 313232, 313322,\\n             321233, 321323, 321332,\\n             322133, 322313, 322331,\\n             323123, 323132, 323213, 323231, 323312, 323321,\\n             331223, 331232, 331322,\\n             332123, 332132, 332213, 332231, 332312, 332321,\\n             333122, 333212, 333221,\\n             422444, 424244, 424424, 424442,\\n             442244, 442424, 442442, \\n             444224, 444242, 444422,\\n             515555, 551555, 555155, 555515, 555551,\\n             666666,\\n             1224444,\\n            ]\\n        \\n        return l[bisect.bisect_right(l, n)]\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1537512,
                "title": "python-all-permutations-sort-binary-search",
                "content": "Generate all permutations of valid numbers under 1M, plus one 7-digit number 1224444.\\nSort and binary search to find the insert index.\\n\\n```\\ndef nextBeautifulNumber(self, n: int) -> int:\\n\\tcandidates = [1,\\n\\t\\t\\t\\t  22,\\n\\t\\t\\t\\t  122, 333, \\n\\t\\t\\t\\t  1333, 4444, \\n\\t\\t\\t\\t  14444, 22333, 55555, \\n\\t\\t\\t\\t  155555, 122333, 224444, 666666,\\n\\t\\t\\t\\t  1224444    # 7-digit largest possible\\n\\t\\t\\t\\t  ]\\n\\n\\tdef get_permutations(s):\\n\\t\\tst = set()\\n\\t\\tfor perm in itertools.permutations(s):\\n\\t\\t\\tst.add(\\'\\'.join(perm))\\n\\t\\treturn [int(x) for x in st]\\n\\n\\t# all possible\\n\\tarr = [candidates[-1]]\\n\\tfor x in candidates[:-1]:\\n\\t\\tarr += get_permutations(str(x))\\n\\n\\tarr.sort()\\n\\treturn arr[bisect.bisect_right(arr, n)]\\n```",
                "solutionTags": [],
                "code": "```\\ndef nextBeautifulNumber(self, n: int) -> int:\\n\\tcandidates = [1,\\n\\t\\t\\t\\t  22,\\n\\t\\t\\t\\t  122, 333, \\n\\t\\t\\t\\t  1333, 4444, \\n\\t\\t\\t\\t  14444, 22333, 55555, \\n\\t\\t\\t\\t  155555, 122333, 224444, 666666,\\n\\t\\t\\t\\t  1224444    # 7-digit largest possible\\n\\t\\t\\t\\t  ]\\n\\n\\tdef get_permutations(s):\\n\\t\\tst = set()\\n\\t\\tfor perm in itertools.permutations(s):\\n\\t\\t\\tst.add(\\'\\'.join(perm))\\n\\t\\treturn [int(x) for x in st]\\n\\n\\t# all possible\\n\\tarr = [candidates[-1]]\\n\\tfor x in candidates[:-1]:\\n\\t\\tarr += get_permutations(str(x))\\n\\n\\tarr.sort()\\n\\treturn arr[bisect.bisect_right(arr, n)]\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 1537488,
                "title": "c-brute-force-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    int nextBeautifulNumber(int n) {\\n        int x = n + 1;\\n        while(true) {\\n            auto s = to_string(x);\\n            int cnt[10]; memset(cnt, 0, sizeof(cnt));\\n            for(auto c : s) {\\n                ++cnt[c - \\'0\\'];\\n            }\\n            bool f = true;\\n            for(int i = 0; i < 10; i++) {\\n                if(cnt[i] && cnt[i] != i) {\\n                    f = false; break;\\n                }\\n            }\\n            if(f) return x;\\n            x++;\\n        }\\n        return 0;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int nextBeautifulNumber(int n) {\\n        int x = n + 1;\\n        while(true) {\\n            auto s = to_string(x);\\n            int cnt[10]; memset(cnt, 0, sizeof(cnt));\\n            for(auto c : s) {\\n                ++cnt[c - \\'0\\'];\\n            }\\n            bool f = true;\\n            for(int i = 0; i < 10; i++) {\\n                if(cnt[i] && cnt[i] != i) {\\n                    f = false; break;\\n                }\\n            }\\n            if(f) return x;\\n            x++;\\n        }\\n        return 0;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3959473,
                "title": "python3-backtracking",
                "content": "# Intuition\\n- We will need to know all the numbers that we can use, So hence I have created a method getNums\\n- Get all the permutations with the values we can use and get the lowest among the values that is greater than n\\n\\n# Approach\\n- Intuition pretty much explains the approach\\n\\n# Complexity\\n- Time complexity:\\n- O(pos!) -  this is to generate all the possibilities with permutations\\n\\n- Space complexity:\\n- O(permutations)\\n\\n# Code\\n```\\nclass Solution:\\n    def nextBeautifulNumber(self, n: int) -> int:\\n        if n == 0:\\n            return 1\\n        def getNums(mask,places,vals):\\n            if places < 0:\\n                return \\n            elif places == 0:\\n                vals.add(mask)\\n            else:\\n                for i in range(1,places+1):\\n                    cmask = 1 << i\\n                    if not(cmask & mask):\\n                        getNums(mask ^ cmask,places-i,vals)\\n\\n        def solve(n):\\n            # calc the positions\\n            curr = 1\\n            pos = 0\\n            while curr <= n:\\n                pos+=1\\n                curr=curr*10\\n\\n            #getting the numbers that can be used\\n            vals=set()\\n            getNums(0,pos,vals)\\n            getNums(0,pos+1,vals)\\n            values = set()\\n            res = float(\\'inf\\')\\n            for num in vals:\\n                bin_val = bin(num).replace(\\'0b\\',\\'\\')[-1::-1]\\n                arr = []\\n                for i in range(len(bin_val)):\\n                    if bin_val[i]!=\\'0\\':\\n                        for j in range(i):\\n                            arr.append(i)\\n                for p in permutations(arr):\\n                    s = \\'\\'\\n                    for k in p:\\n                        s+=str(k)\\n                    if int(s) > n and int(s) < res:\\n                        res = int(s)\\n            return res\\n        return solve(n)\\n        # return 2\\n\\n            \\n```",
                "solutionTags": [
                    "Python3",
                    "Backtracking",
                    "Bitmask"
                ],
                "code": "```\\nclass Solution:\\n    def nextBeautifulNumber(self, n: int) -> int:\\n        if n == 0:\\n            return 1\\n        def getNums(mask,places,vals):\\n            if places < 0:\\n                return \\n            elif places == 0:\\n                vals.add(mask)\\n            else:\\n                for i in range(1,places+1):\\n                    cmask = 1 << i\\n                    if not(cmask & mask):\\n                        getNums(mask ^ cmask,places-i,vals)\\n\\n        def solve(n):\\n            # calc the positions\\n            curr = 1\\n            pos = 0\\n            while curr <= n:\\n                pos+=1\\n                curr=curr*10\\n\\n            #getting the numbers that can be used\\n            vals=set()\\n            getNums(0,pos,vals)\\n            getNums(0,pos+1,vals)\\n            values = set()\\n            res = float(\\'inf\\')\\n            for num in vals:\\n                bin_val = bin(num).replace(\\'0b\\',\\'\\')[-1::-1]\\n                arr = []\\n                for i in range(len(bin_val)):\\n                    if bin_val[i]!=\\'0\\':\\n                        for j in range(i):\\n                            arr.append(i)\\n                for p in permutations(arr):\\n                    s = \\'\\'\\n                    for k in p:\\n                        s+=str(k)\\n                    if int(s) > n and int(s) < res:\\n                        res = int(s)\\n            return res\\n        return solve(n)\\n        # return 2\\n\\n            \\n```",
                "codeTag": "Java"
            },
            {
                "id": 3898448,
                "title": "solution-using-dictionary",
                "content": "# Intuition\\nCreate function to check whether a number is balanced. and then iterate from n+1 to find the next balanced number.\\n\\n# Approach\\nisbalanced function checks whether the digit value is equal to the number of occurences using a dictionary and then returns True or False.\\n\\n# Complexity\\n- Time complexity:O(n)\\n\\n- Space complexity:O(n)\\n\\n# Code\\n```\\nclass Solution:\\n    def nextBeautifulNumber(self, n: int) -> int:\\n        def isbalanced(n):\\n            d={}\\n            while n>0:\\n                d[n%10]=d.get(n%10,0)+1\\n                n=n//10\\n            for i in d:\\n                if d[i]!=i:\\n                    return False\\n            return True\\n        i=n+1\\n        while not isbalanced(i):\\n            i+=1\\n        return i\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def nextBeautifulNumber(self, n: int) -> int:\\n        def isbalanced(n):\\n            d={}\\n            while n>0:\\n                d[n%10]=d.get(n%10,0)+1\\n                n=n//10\\n            for i in d:\\n                if d[i]!=i:\\n                    return False\\n            return True\\n        i=n+1\\n        while not isbalanced(i):\\n            i+=1\\n        return i\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3813278,
                "title": "easy-intuitive-c-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    void nextPermutation(string &nums) {\\n        if(nums.size()==1) return;\\n        int i=nums.size()-2;\\n        while(i>=0 && nums[i]>=nums[i+1]) i--;\\n        int j=nums.size()-1;\\n        if(i<0){\\n            sort(nums.begin(), nums.end());\\n            return;\\n        }\\n        while(j>=0 && nums[j]<=nums[i]) j--;\\n        swap(nums[i], nums[j]);\\n        reverse(nums.begin()+i+1, nums.end());\\n    }\\n    int nextBeautifulNumber(int n) {\\n        vector<vector<string>> v = {{\"1\"}, {\"22\"}, {\"122\", \"333\"}, {\"1333\", \"4444\"}, {\"14444\", \"22333\", \"55555\"},\\n        {\"122333\", \"155555\", \"224444\", \"666666\"},{\"1224444\", \"1666666\", \"2255555\", \"3334444\"}, {\"17777777\", \"22666666\", \"33355555\"},\\n        {\"188888888\", \"227777777\", \"333666666\", \"444455555\"}};\\n        string num = to_string(n);\\n        int d = num.size();\\n        int ans = stoi(v[d][0]);\\n        for(int i=0; i<v[d-1].size(); i++){\\n            string curr = v[d-1][i];\\n            while(true){\\n                int a = stoi(curr), b = stoi(num);\\n                if(a > b) ans = min(ans, a);\\n                nextPermutation(curr);\\n                if(curr==v[d-1][i]) break;\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    void nextPermutation(string &nums) {\\n        if(nums.size()==1) return;\\n        int i=nums.size()-2;\\n        while(i>=0 && nums[i]>=nums[i+1]) i--;\\n        int j=nums.size()-1;\\n        if(i<0){\\n            sort(nums.begin(), nums.end());\\n            return;\\n        }\\n        while(j>=0 && nums[j]<=nums[i]) j--;\\n        swap(nums[i], nums[j]);\\n        reverse(nums.begin()+i+1, nums.end());\\n    }\\n    int nextBeautifulNumber(int n) {\\n        vector<vector<string>> v = {{\"1\"}, {\"22\"}, {\"122\", \"333\"}, {\"1333\", \"4444\"}, {\"14444\", \"22333\", \"55555\"},\\n        {\"122333\", \"155555\", \"224444\", \"666666\"},{\"1224444\", \"1666666\", \"2255555\", \"3334444\"}, {\"17777777\", \"22666666\", \"33355555\"},\\n        {\"188888888\", \"227777777\", \"333666666\", \"444455555\"}};\\n        string num = to_string(n);\\n        int d = num.size();\\n        int ans = stoi(v[d][0]);\\n        for(int i=0; i<v[d-1].size(); i++){\\n            string curr = v[d-1][i];\\n            while(true){\\n                int a = stoi(curr), b = stoi(num);\\n                if(a > b) ans = min(ans, a);\\n                nextPermutation(curr);\\n                if(curr==v[d-1][i]) break;\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3804097,
                "title": "python-easy-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n\\n    def is_next_balance(self,n):\\n        val = str(n)\\n        counts = [val.count(i) for i in val]\\n        return all(count == int(d) for d,count in zip(val,counts))\\n        # val = str(n)\\n        # counts = []\\n        # for digit in val:\\n        #     counts.append(val.count(digit))\\n\\n        # temp = []\\n        # for digit,count in zip(val,counts ):\\n        #     if int(digit) == count:\\n        #         temp.append(True)\\n        #     else:\\n        #         temp.append(False)\\n\\n        # return all(temp)\\n\\n    def nextBeautifulNumber(self, n: int) -> int:\\n        n = n+1\\n        while True:\\n            if self.is_next_balance(n):\\n                return n\\n            n += 1\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n\\n    def is_next_balance(self,n):\\n        val = str(n)\\n        counts = [val.count(i) for i in val]\\n        return all(count == int(d) for d,count in zip(val,counts))\\n        # val = str(n)\\n        # counts = []\\n        # for digit in val:\\n        #     counts.append(val.count(digit))\\n\\n        # temp = []\\n        # for digit,count in zip(val,counts ):\\n        #     if int(digit) == count:\\n        #         temp.append(True)\\n        #     else:\\n        #         temp.append(False)\\n\\n        # return all(temp)\\n\\n    def nextBeautifulNumber(self, n: int) -> int:\\n        n = n+1\\n        while True:\\n            if self.is_next_balance(n):\\n                return n\\n            n += 1\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3770862,
                "title": "golang-permutation",
                "content": "# Code\\n```\\nfunc nextBeautifulNumber(n int) int {\\n  // With these combinations, we have to generate the smallest number with the\\n  // right digits.\\n  // For n, the next bigger balanced number will have the same number of digits or\\n  // just one more digit. For 1, 22. For 99, 122.\\n  if n == 0 {\\n    return 1\\n  }\\n  combinations := map[int][][]int{\\n    2: {{2, 2}},\\n    3: {{1, 2, 2}, {3, 3, 3}},\\n    4: {{1, 3, 3, 3}, {4, 4, 4, 4}},\\n    5: {{1, 4, 4, 4, 4}, {2, 2, 3, 3, 3}, {5, 5, 5, 5, 5}},\\n    6: {{1, 2, 2, 3, 3, 3}, {1, 5, 5, 5, 5, 5}, {2, 2, 4, 4, 4, 4}, {6, 6, 6, 6, 6, 6}},\\n    7: {{1, 2, 2, 4, 4, 4, 4}, {1, 6, 6, 6, 6, 6, 6}, {2, 2, 5, 5, 5, 5, 5},\\n        {3, 3, 3, 4, 4, 4, 4}, {7, 7, 7, 7, 7, 7, 7}},\\n  }\\n  // fmt.Println(combinations)\\n  var numDigits int\\n  for num := n; num > 0; num /= 10 {\\n    numDigits++\\n  }\\n  res := math.MaxInt32\\n  for _, comb := range combinations[numDigits] {\\n    backtrack(comb, 0, (1 << numDigits) - 1, n, &res)\\n  }\\n  if res == math.MaxInt32 && numDigits+1 <= 7 {\\n    for _, comb := range combinations[numDigits+1] {\\n      backtrack(comb, 0, (1 << (numDigits+1))-1, n, &res)\\n    }\\n  }\\n  return res\\n}\\n\\nfunc backtrack(comb []int, curr int, used int, num int, res *int) {\\n  if used == 0 {\\n    if curr > num {\\n      *res = min(*res, curr)\\n    }\\n  }\\n  for i := 0; i < len(comb); i++ {\\n    if used & (1 << i) != 0 {\\n      backtrack(comb, curr*10 + comb[i], used ^ (1 << i), num, res)\\n    }\\n  }\\n}  \\n\\nfunc min(a, b int) int {\\n  if a < b {\\n    return a\\n  }\\n  return b\\n}\\n```",
                "solutionTags": [
                    "Go",
                    "Backtracking"
                ],
                "code": "```\\nfunc nextBeautifulNumber(n int) int {\\n  // With these combinations, we have to generate the smallest number with the\\n  // right digits.\\n  // For n, the next bigger balanced number will have the same number of digits or\\n  // just one more digit. For 1, 22. For 99, 122.\\n  if n == 0 {\\n    return 1\\n  }\\n  combinations := map[int][][]int{\\n    2: {{2, 2}},\\n    3: {{1, 2, 2}, {3, 3, 3}},\\n    4: {{1, 3, 3, 3}, {4, 4, 4, 4}},\\n    5: {{1, 4, 4, 4, 4}, {2, 2, 3, 3, 3}, {5, 5, 5, 5, 5}},\\n    6: {{1, 2, 2, 3, 3, 3}, {1, 5, 5, 5, 5, 5}, {2, 2, 4, 4, 4, 4}, {6, 6, 6, 6, 6, 6}},\\n    7: {{1, 2, 2, 4, 4, 4, 4}, {1, 6, 6, 6, 6, 6, 6}, {2, 2, 5, 5, 5, 5, 5},\\n        {3, 3, 3, 4, 4, 4, 4}, {7, 7, 7, 7, 7, 7, 7}},\\n  }\\n  // fmt.Println(combinations)\\n  var numDigits int\\n  for num := n; num > 0; num /= 10 {\\n    numDigits++\\n  }\\n  res := math.MaxInt32\\n  for _, comb := range combinations[numDigits] {\\n    backtrack(comb, 0, (1 << numDigits) - 1, n, &res)\\n  }\\n  if res == math.MaxInt32 && numDigits+1 <= 7 {\\n    for _, comb := range combinations[numDigits+1] {\\n      backtrack(comb, 0, (1 << (numDigits+1))-1, n, &res)\\n    }\\n  }\\n  return res\\n}\\n\\nfunc backtrack(comb []int, curr int, used int, num int, res *int) {\\n  if used == 0 {\\n    if curr > num {\\n      *res = min(*res, curr)\\n    }\\n  }\\n  for i := 0; i < len(comb); i++ {\\n    if used & (1 << i) != 0 {\\n      backtrack(comb, curr*10 + comb[i], used ^ (1 << i), num, res)\\n    }\\n  }\\n}  \\n\\nfunc min(a, b int) int {\\n  if a < b {\\n    return a\\n  }\\n  return b\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3731349,
                "title": "python",
                "content": "Not an intuitive question\\n# Code\\n```\\nclass Solution:\\n    def nextBeautifulNumber(self, n: int) -> int:\\n        i = n+1\\n        while  True:\\n            if i % 10 == 0:\\n                i += 1\\n                continue\\n\\n            c = Counter(str(i))\\n            \\n            flag = False\\n            for k, v in c.items():\\n                if k != str(v):\\n                    flag = True\\n                    break\\n            if flag:\\n                i += 1\\n                continue\\n            else:\\n                return i\\n\\n            i += 1\\n            \\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def nextBeautifulNumber(self, n: int) -> int:\\n        i = n+1\\n        while  True:\\n            if i % 10 == 0:\\n                i += 1\\n                continue\\n\\n            c = Counter(str(i))\\n            \\n            flag = False\\n            for k, v in c.items():\\n                if k != str(v):\\n                    flag = True\\n                    break\\n            if flag:\\n                i += 1\\n                continue\\n            else:\\n                return i\\n\\n            i += 1\\n            \\n```",
                "codeTag": "Java"
            },
            {
                "id": 3709690,
                "title": "digit-dp-with-hashing-for-memoization",
                "content": "Works for `N` upto `10^45` (not possible to have valid number after 45 digits).\\n\\nHere are some large sample cases for example,\\n\\n> Input: 7139439876337848785064545556248947173076\\nOutput: 7139439876342244666667777788888889999999\\n\\n> Input: 3490604516062527549992140925717635204475\\nOutput: 3491223344466666677777778888888899999999\\n\\n> Input: 1859838154423133868948753919599391851535\\nOutput: 1859844445555666666777777788888899999999\\n\\n> Input: 6376577388423026207334083244308585806167\\nOutput: 6376577388522355566667777888888999999999\\n\\n> Input: 1330960657578122460105257866466146843217\\nOutput: 1332234444666666777777788888888999999999\\n\\n> Input: 3553865709742829205519906646039952764467\\nOutput: 3553865722355666667777778888888999999999\\n\\n> Input: 2483811564272139684107992053599876257243\\nOutput: 2483812334446666667777777888888999999999\\n\\n> Input: 8621673721335639672544858823299225417666\\nOutput: 8621673723344446666777778888888999999999\\n\\n> Input: 8705095074045994723645407683134169452176\\nOutput: 8712233344446666667777778888888999999999\\n\\n> Input: 5088803754921187328346206849718779701426\\nOutput: 5144445555666666777777788888888999999999\\n\\n```\\nM1 = 10 ** 9 + 7\\nM2 = 10 ** 9 + 33\\np1 = 10 ** 9 + 9\\np2 = 10 ** 9 + 87\\npw1 = [1] * 10\\npw2 = [1] * 10\\nfor i in range(1, 10):\\n    pw1[i] = p1 * pw1[i - 1]\\n    pw2[i] = p2 * pw2[i - 1]\\n    pw1[i] %= M1\\n    pw2[i] %= M2\\n\\nclass Solution:\\n    def find(self, num, i, n, ctr, fhash, shash, tight, curr):\\n        if i >= n:\\n            if tight or ctr[0] > 0:\\n                return float(\\'inf\\')\\n            for d in range(1, 10):\\n                if ctr[d] > 0 and ctr[d] != d:\\n                    return float(\\'inf\\')\\n            return curr\\n        key = (i, fhash, shash, tight)\\n        if key in self.cache:\\n            return self.cache[key]\\n        mindigit = 0\\n        if tight:\\n            mindigit = int(num[i])\\n        for d in range(mindigit, 10):\\n            if ctr[d] == d:\\n                continue\\n            ctr[d] += 1\\n            cres = self.find(num, i + 1, n, ctr, (fhash + d * pw1[d]) % M1, (shash + d * pw2[d]) % M2, tight and d == mindigit, 10 * curr + d)\\n            if cres < float(\\'inf\\'):\\n                self.cache[key] = cres\\n                return cres\\n            ctr[d] -= 1\\n        self.cache[key] = float(\\'inf\\')\\n        return float(\\'inf\\')\\n    \\n    def nextBeautifulNumber(self, n: int) -> int:\\n        self.cache = {}\\n        a = self.find(str(n), 0, len(str(n)), [0] * 10, 0, 0, True, 0)\\n        self.cache = {}\\n        b = self.find(str(10 ** len(str(n))), 0, len(str(10 ** len(str(n)))), [0] * 10, 0, 0, True, 0)\\n        return min(a, b)\\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nM1 = 10 ** 9 + 7\\nM2 = 10 ** 9 + 33\\np1 = 10 ** 9 + 9\\np2 = 10 ** 9 + 87\\npw1 = [1] * 10\\npw2 = [1] * 10\\nfor i in range(1, 10):\\n    pw1[i] = p1 * pw1[i - 1]\\n    pw2[i] = p2 * pw2[i - 1]\\n    pw1[i] %= M1\\n    pw2[i] %= M2\\n\\nclass Solution:\\n    def find(self, num, i, n, ctr, fhash, shash, tight, curr):\\n        if i >= n:\\n            if tight or ctr[0] > 0:\\n                return float(\\'inf\\')\\n            for d in range(1, 10):\\n                if ctr[d] > 0 and ctr[d] != d:\\n                    return float(\\'inf\\')\\n            return curr\\n        key = (i, fhash, shash, tight)\\n        if key in self.cache:\\n            return self.cache[key]\\n        mindigit = 0\\n        if tight:\\n            mindigit = int(num[i])\\n        for d in range(mindigit, 10):\\n            if ctr[d] == d:\\n                continue\\n            ctr[d] += 1\\n            cres = self.find(num, i + 1, n, ctr, (fhash + d * pw1[d]) % M1, (shash + d * pw2[d]) % M2, tight and d == mindigit, 10 * curr + d)\\n            if cres < float(\\'inf\\'):\\n                self.cache[key] = cres\\n                return cres\\n            ctr[d] -= 1\\n        self.cache[key] = float(\\'inf\\')\\n        return float(\\'inf\\')\\n    \\n    def nextBeautifulNumber(self, n: int) -> int:\\n        self.cache = {}\\n        a = self.find(str(n), 0, len(str(n)), [0] * 10, 0, 0, True, 0)\\n        self.cache = {}\\n        b = self.find(str(10 ** len(str(n))), 0, len(str(10 ** len(str(n)))), [0] * 10, 0, 0, True, 0)\\n        return min(a, b)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3700072,
                "title": "c-o-nlogn-iterative-approach",
                "content": "# Intuition\\nThe problem is solved using iterative approach by just iterating from n+1 till 100*n since the answer will lie under 1e6 digits. using a hash map to track the frequency of each digit in number, if there is any mismatch simple move to check next integer. \\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n    o(nlogn) \\n\\n- Space complexity:\\n    o(n)\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int nextBeautifulNumber(int n) \\n    {\\n        unordered_map<int,int> freq;\\n\\n        for(int i=n+1;i<100*n;i++)\\n        {\\n            bool flag = true;\\n            int num = i;\\n            while (num) \\n            {\\n                if (num % 10 == 0) \\n                {\\n                    flag = false;\\n                    break;\\n                } // no 0 allowed\\n                freq[num % 10]++;\\n                num/= 10;\\n            }\\n            if(flag)\\n            {\\n                for (int x = 1; x < 10; ++x) \\n                {\\n                    if (freq[x] && freq[x] != x) \\n                    {\\n                        flag = false;\\n                        break;\\n                    }\\n                }\\n            }\\n            if(flag)\\n            {\\n                return i;\\n            }\\n\\n            freq.clear();\\n        }\\n        return 1;    \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int nextBeautifulNumber(int n) \\n    {\\n        unordered_map<int,int> freq;\\n\\n        for(int i=n+1;i<100*n;i++)\\n        {\\n            bool flag = true;\\n            int num = i;\\n            while (num) \\n            {\\n                if (num % 10 == 0) \\n                {\\n                    flag = false;\\n                    break;\\n                } // no 0 allowed\\n                freq[num % 10]++;\\n                num/= 10;\\n            }\\n            if(flag)\\n            {\\n                for (int x = 1; x < 10; ++x) \\n                {\\n                    if (freq[x] && freq[x] != x) \\n                    {\\n                        flag = false;\\n                        break;\\n                    }\\n                }\\n            }\\n            if(flag)\\n            {\\n                return i;\\n            }\\n\\n            freq.clear();\\n        }\\n        return 1;    \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3660911,
                "title": "easy-to-understand-next-greater-numerically-balanced-number-simple-iterative-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def nextBeautifulNumber(self, a: int) -> int:\\n        def is_safe(s):\\n            for i in s:\\n                if s.count(i)!=int(i):\\n                    return False\\n            return True\\n        while True:\\n            a+=1\\n            s=str(a)\\n            if is_safe(s):\\n                break\\n        return(a)\\n```",
                "solutionTags": [
                    "Python3",
                    "Iterator"
                ],
                "code": "```\\nclass Solution:\\n    def nextBeautifulNumber(self, a: int) -> int:\\n        def is_safe(s):\\n            for i in s:\\n                if s.count(i)!=int(i):\\n                    return False\\n            return True\\n        while True:\\n            a+=1\\n            s=str(a)\\n            if is_safe(s):\\n                break\\n        return(a)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3570585,
                "title": "c-using-map-one-edge-case-handling",
                "content": "Since input n<=10^6, the next 7 digit number after beautiful number 666666 is 1224444. Which is also the output for all inputs above the beautiful number 666666.\\n\\n# Code\\n```\\nclass Solution {\\nprivate: \\n    bool isBeautiful(int n)\\n    {\\n        unordered_map<int,int> m1;\\n        while(n!=0)\\n        {\\n            int d=n%10;\\n            if(d==0){return false;}\\n            m1[d]++;\\n            n=n/10;\\n        }\\n        for(auto it:m1)\\n        {\\n            if(it.first!=it.second){return false;}\\n        }\\n     return true;\\n    }\\npublic:\\n    int nextBeautifulNumber(int n) {\\n    if(n==0){return 1;}\\n    if(n>=666666){return 1224444;}//since input n<=10^6, the next 7 digit number after beautiful number 666666 is 1224444. Which is also the output for all inputs above the beautiful number 666666. \\n    while(true)\\n    {\\n        if(isBeautiful(++n)){return n;}\\n    }\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\nprivate: \\n    bool isBeautiful(int n)\\n    {\\n        unordered_map<int,int> m1;\\n        while(n!=0)\\n        {\\n            int d=n%10;\\n            if(d==0){return false;}\\n            m1[d]++;\\n            n=n/10;\\n        }\\n        for(auto it:m1)\\n        {\\n            if(it.first!=it.second){return false;}\\n        }\\n     return true;\\n    }\\npublic:\\n    int nextBeautifulNumber(int n) {\\n    if(n==0){return 1;}\\n    if(n>=666666){return 1224444;}//since input n<=10^6, the next 7 digit number after beautiful number 666666 is 1224444. Which is also the output for all inputs above the beautiful number 666666. \\n    while(true)\\n    {\\n        if(isBeautiful(++n)){return n;}\\n    }\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3531547,
                "title": "i-know-i-m-not-the-first-with-this-one-but-why-is-this-legal",
                "content": "# Assist code\\n```\\ndef check_ok(num):\\n    digits = [int(x) for x in str(num)]\\n    for d in digits:\\n            count = 0\\n            for dd in digits:\\n                    if dd == d:\\n                            count += 1\\n            if count != d:\\n                    return False\\n    return True\\n\\nfor n in range(2_000_000):\\n    if check_ok(n):\\n        print(n, \",\", sep=\\'\\')\\n```\\n\\n# Code\\n```\\nimpl Solution {\\n    pub fn next_beautiful_number(n: i32) -> i32 {\\n        let numbers = [\\n            1,\\n            22,\\n            122,\\n            212,\\n            221,\\n            333,\\n            1333,\\n            3133,\\n            3313,\\n            3331,\\n            4444,\\n            14444,\\n            22333,\\n            23233,\\n            23323,\\n            23332,\\n            32233,\\n            32323,\\n            32332,\\n            33223,\\n            33232,\\n            33322,\\n            41444,\\n            44144,\\n            44414,\\n            44441,\\n            55555,\\n            122333,\\n            123233,\\n            123323,\\n            123332,\\n            132233,\\n            132323,\\n            132332,\\n            133223,\\n            133232,\\n            133322,\\n            155555,\\n            212333,\\n            213233,\\n            213323,\\n            213332,\\n            221333,\\n            223133,\\n            223313,\\n            223331,\\n            224444,\\n            231233,\\n            231323,\\n            231332,\\n            232133,\\n            232313,\\n            232331,\\n            233123,\\n            233132,\\n            233213,\\n            233231,\\n            233312,\\n            233321,\\n            242444,\\n            244244,\\n            244424,\\n            244442,\\n            312233,\\n            312323,\\n            312332,\\n            313223,\\n            313232,\\n            313322,\\n            321233,\\n            321323,\\n            321332,\\n            322133,\\n            322313,\\n            322331,\\n            323123,\\n            323132,\\n            323213,\\n            323231,\\n            323312,\\n            323321,\\n            331223,\\n            331232,\\n            331322,\\n            332123,\\n            332132,\\n            332213,\\n            332231,\\n            332312,\\n            332321,\\n            333122,\\n            333212,\\n            333221,\\n            422444,\\n            424244,\\n            424424,\\n            424442,\\n            442244,\\n            442424,\\n            442442,\\n            444224,\\n            444242,\\n            444422,\\n            515555,\\n            551555,\\n            555155,\\n            555515,\\n            555551,\\n            666666,\\n        ];\\n        for num in numbers {\\n            if num > n {\\n                return num;\\n            }\\n        }\\n        1224444\\n    }\\n}\\n```",
                "solutionTags": [
                    "Rust"
                ],
                "code": "```\\ndef check_ok(num):\\n    digits = [int(x) for x in str(num)]\\n    for d in digits:\\n            count = 0\\n            for dd in digits:\\n                    if dd == d:\\n                            count += 1\\n            if count != d:\\n                    return False\\n    return True\\n\\nfor n in range(2_000_000):\\n    if check_ok(n):\\n        print(n, \",\", sep=\\'\\')\\n```\n```\\nimpl Solution {\\n    pub fn next_beautiful_number(n: i32) -> i32 {\\n        let numbers = [\\n            1,\\n            22,\\n            122,\\n            212,\\n            221,\\n            333,\\n            1333,\\n            3133,\\n            3313,\\n            3331,\\n            4444,\\n            14444,\\n            22333,\\n            23233,\\n            23323,\\n            23332,\\n            32233,\\n            32323,\\n            32332,\\n            33223,\\n            33232,\\n            33322,\\n            41444,\\n            44144,\\n            44414,\\n            44441,\\n            55555,\\n            122333,\\n            123233,\\n            123323,\\n            123332,\\n            132233,\\n            132323,\\n            132332,\\n            133223,\\n            133232,\\n            133322,\\n            155555,\\n            212333,\\n            213233,\\n            213323,\\n            213332,\\n            221333,\\n            223133,\\n            223313,\\n            223331,\\n            224444,\\n            231233,\\n            231323,\\n            231332,\\n            232133,\\n            232313,\\n            232331,\\n            233123,\\n            233132,\\n            233213,\\n            233231,\\n            233312,\\n            233321,\\n            242444,\\n            244244,\\n            244424,\\n            244442,\\n            312233,\\n            312323,\\n            312332,\\n            313223,\\n            313232,\\n            313322,\\n            321233,\\n            321323,\\n            321332,\\n            322133,\\n            322313,\\n            322331,\\n            323123,\\n            323132,\\n            323213,\\n            323231,\\n            323312,\\n            323321,\\n            331223,\\n            331232,\\n            331322,\\n            332123,\\n            332132,\\n            332213,\\n            332231,\\n            332312,\\n            332321,\\n            333122,\\n            333212,\\n            333221,\\n            422444,\\n            424244,\\n            424424,\\n            424442,\\n            442244,\\n            442424,\\n            442442,\\n            444224,\\n            444242,\\n            444422,\\n            515555,\\n            551555,\\n            555155,\\n            555515,\\n            555551,\\n            666666,\\n        ];\\n        for num in numbers {\\n            if num > n {\\n                return num;\\n            }\\n        }\\n        1224444\\n    }\\n}\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 3481125,
                "title": "python3-brute-force",
                "content": "\\n\\n# Code\\n```\\nclass Solution:\\n    def nextBeautifulNumber(self, n: int) -> int:\\n        \\n        def isValid(x):\\n            count=Counter(str(x))\\n            for k,v in count.items():\\n                if int(k)!=v:\\n                    return False\\n            \\n            return True\\n\\n        \\n        start=n+1\\n        \\n        while True:\\n            if isValid(start):\\n                return start\\n            start+=1\\n        \\n        \\n        \\n```",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def nextBeautifulNumber(self, n: int) -> int:\\n        \\n        def isValid(x):\\n            count=Counter(str(x))\\n            for k,v in count.items():\\n                if int(k)!=v:\\n                    return False\\n            \\n            return True\\n\\n        \\n        start=n+1\\n        \\n        while True:\\n            if isValid(start):\\n                return start\\n            start+=1\\n        \\n        \\n        \\n```",
                "codeTag": "Java"
            },
            {
                "id": 3438603,
                "title": "simplest-java-code-using-hashmap-beginner-friendly-code",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int nextBeautifulNumber(int n) {\\n        int ans=n+1;\\n        while(true){\\n            if(helper(ans)){\\n                return ans;\\n            }else{\\n                ans++;\\n            }\\n        }\\n    }\\n    static boolean helper(int ans){\\n        HashMap<Integer,Integer> map=new HashMap<>();\\n        while(ans>0){\\n            int rem=ans%10;\\n            map.put(rem,map.getOrDefault(rem,0)+1);\\n            ans=ans/10;\\n        }\\n        for(int key:map.keySet()){\\n            if(map.get(key)!=key){\\n                return false;\\n            }\\n        }\\n        return true;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int nextBeautifulNumber(int n) {\\n        int ans=n+1;\\n        while(true){\\n            if(helper(ans)){\\n                return ans;\\n            }else{\\n                ans++;\\n            }\\n        }\\n    }\\n    static boolean helper(int ans){\\n        HashMap<Integer,Integer> map=new HashMap<>();\\n        while(ans>0){\\n            int rem=ans%10;\\n            map.put(rem,map.getOrDefault(rem,0)+1);\\n            ans=ans/10;\\n        }\\n        for(int key:map.keySet()){\\n            if(map.get(key)!=key){\\n                return false;\\n            }\\n        }\\n        return true;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3406525,
                "title": "c-enumeration",
                "content": "# Code\\n```\\nclass Solution {\\npublic:\\n    int nextBeautifulNumber(int n) {\\n        for(int i = n + 1;; i++) {\\n            int freq[10] = {0};\\n            for(int j = i; j > 0; j /= 10) {\\n                freq[j % 10]++;\\n            }\\n            bool flag = true;\\n            for(int j = 0; j < 10; j++) {\\n                if(freq[j] && freq[j] != j) {\\n                    flag = false;\\n                    break;\\n                }\\n            }\\n            if(flag) return i;\\n        }\\n        return -1;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Math",
                    "Enumeration"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int nextBeautifulNumber(int n) {\\n        for(int i = n + 1;; i++) {\\n            int freq[10] = {0};\\n            for(int j = i; j > 0; j /= 10) {\\n                freq[j % 10]++;\\n            }\\n            bool flag = true;\\n            for(int j = 0; j < 10; j++) {\\n                if(freq[j] && freq[j] != j) {\\n                    flag = false;\\n                    break;\\n                }\\n            }\\n            if(flag) return i;\\n        }\\n        return -1;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3390921,
                "title": "bs",
                "content": "```\\nint nextBeautifulNumber(int n) \\n{\\n    int t[]{1,22,122,212,221,333,1333,3133,3313,3331,4444,14444,22333,23233,23323,23332,32233,32323,32332,33223,33232,33322,41444,44144,44414,44441,55555,\\n            122333,123233,123323,123332,132233,132323,132332,133223,133232,133322,155555,212333,213233,213323,213332,221333,223133,223313,223331,224444,\\n            231233,231323,231332,232133,232313,232331,233123,233132,233213,233231,233312,233321,242444,244244,244424,244442,312233,312323,312332,313223,\\n            313232,313322,321233,321323,321332,322133,322313,322331,323123,323132,323213,323231,323312,323321,331223,331232,331322,332123,332132,332213,\\n            332231,332312,332321,333122,333212,333221,422444,424244,424424,424442,442244,442424,442442,444224,444242,444422,515555,551555,555155,555515,\\n            555551,666666,1224444};  \\n    return *upper_bound(begin(t), end(t), n);\\n}\\n```",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nint nextBeautifulNumber(int n) \\n{\\n    int t[]{1,22,122,212,221,333,1333,3133,3313,3331,4444,14444,22333,23233,23323,23332,32233,32323,32332,33223,33232,33322,41444,44144,44414,44441,55555,\\n            122333,123233,123323,123332,132233,132323,132332,133223,133232,133322,155555,212333,213233,213323,213332,221333,223133,223313,223331,224444,\\n            231233,231323,231332,232133,232313,232331,233123,233132,233213,233231,233312,233321,242444,244244,244424,244442,312233,312323,312332,313223,\\n            313232,313322,321233,321323,321332,322133,322313,322331,323123,323132,323213,323231,323312,323321,331223,331232,331322,332123,332132,332213,\\n            332231,332312,332321,333122,333212,333221,422444,424244,424424,424442,442244,442424,442442,444224,444242,444422,515555,551555,555155,555515,\\n            555551,666666,1224444};  \\n    return *upper_bound(begin(t), end(t), n);\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3390777,
                "title": "c-binary-search",
                "content": "```\\nclass Solution {\\npublic:    \\n    int nextBeautifulNumber(int n) {\\n       vector<int> v1 = {1,22,122,333,4444,3331,55555,14444,22333,666666,555551,333221,444422,7777777,6666661,4444333,2255555,4444122};\\n        set<int> st;\\n        for(auto &x : v1)\\n        {\\n            string s = to_string(x);\\n            sort(s.begin() , s.end());\\n            do{\\n                st.insert(stoi(s));\\n            }while(next_permutation(s.begin(), s.end()));\\n        }\\n        // for(auto &x : st)cout << x << \" \";\\n        vector<int> srch;\\n        for(auto &x : st)srch.push_back(x);\\n        int l=0, r=srch.size()-1, res;\\n        while(l <= r)\\n        {\\n            int mid = (l+r)/2;\\n            if(srch[mid] <= n)l=mid+1;\\n            else {res = srch[mid];r=mid-1;}\\n        }\\n        return res;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Binary Tree"
                ],
                "code": "```\\nclass Solution {\\npublic:    \\n    int nextBeautifulNumber(int n) {\\n       vector<int> v1 = {1,22,122,333,4444,3331,55555,14444,22333,666666,555551,333221,444422,7777777,6666661,4444333,2255555,4444122};\\n        set<int> st;\\n        for(auto &x : v1)\\n        {\\n            string s = to_string(x);\\n            sort(s.begin() , s.end());\\n            do{\\n                st.insert(stoi(s));\\n            }while(next_permutation(s.begin(), s.end()));\\n        }\\n        // for(auto &x : st)cout << x << \" \";\\n        vector<int> srch;\\n        for(auto &x : st)srch.push_back(x);\\n        int l=0, r=srch.size()-1, res;\\n        while(l <= r)\\n        {\\n            int mid = (l+r)/2;\\n            if(srch[mid] <= n)l=mid+1;\\n            else {res = srch[mid];r=mid-1;}\\n        }\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 3319778,
                "title": "c",
                "content": "```\\nbool isBalancedNum(int n){\\n    int* digit = calloc(10, sizeof(int)) ; \\n    while(n){\\n        int d = n % 10 ;\\n        n /= 10 ;\\n        digit[d]++ ;\\n        if(d == 0 || digit[d] > d)\\n            return false ;\\n    }\\n    \\n    for(int i = 1; i < 10; i++){\\n        if(digit[i] > 0 && digit[i] != i )\\n            return false ;\\n    }\\n    return true ;\\n}\\nint nextBeautifulNumber(int n){\\n    n += 1 ;\\n    while(1){\\n        if(isBalancedNum(n))\\n            return n ;\\n        n++ ;\\n    }\\n    return -1 ;\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nbool isBalancedNum(int n){\\n    int* digit = calloc(10, sizeof(int)) ; \\n    while(n){\\n        int d = n % 10 ;\\n        n /= 10 ;\\n        digit[d]++ ;\\n        if(d == 0 || digit[d] > d)\\n            return false ;\\n    }\\n    \\n    for(int i = 1; i < 10; i++){\\n        if(digit[i] > 0 && digit[i] != i )\\n            return false ;\\n    }\\n    return true ;\\n}\\nint nextBeautifulNumber(int n){\\n    n += 1 ;\\n    while(1){\\n        if(isBalancedNum(n))\\n            return n ;\\n        n++ ;\\n    }\\n    return -1 ;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3311607,
                "title": "java-brute-force",
                "content": "# Code\\n```\\nclass Solution {\\n    public int nextBeautifulNumber(int n) {\\n        ++n;\\n        for (; !isBalanced(n); ++n) {\\n            ;\\n        }\\n        return n;\\n    }\\n\\n    public boolean isBalanced(int n) {\\n        int[] digits = new int[]{0, 1, 2, 3, 4, 5, 6, 7, 8, 9};\\n        while (n > 0) {\\n            --digits[n % 10];\\n            n /= 10;\\n        }\\n        for (int i = 0; i <= 9; ++i) {\\n            if (digits[i] != i && digits[i] != 0) {\\n                return false;\\n            }\\n        }\\n        return true;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Greedy"
                ],
                "code": "```\\nclass Solution {\\n    public int nextBeautifulNumber(int n) {\\n        ++n;\\n        for (; !isBalanced(n); ++n) {\\n            ;\\n        }\\n        return n;\\n    }\\n\\n    public boolean isBalanced(int n) {\\n        int[] digits = new int[]{0, 1, 2, 3, 4, 5, 6, 7, 8, 9};\\n        while (n > 0) {\\n            --digits[n % 10];\\n            n /= 10;\\n        }\\n        for (int i = 0; i <= 9; ++i) {\\n            if (digits[i] != i && digits[i] != 0) {\\n                return false;\\n            }\\n        }\\n        return true;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3282561,
                "title": "python3-short-and-straight-forward-brute-force-solution",
                "content": "\\n\\n# Code\\n```\\nclass Solution:\\n    def nextBeautifulNumber(self, n: int) -> int:\\n        \\n        num=n+1\\n        \\n        while True:\\n            count=Counter(str(num))\\n            if all(int(key)==val for key,val in count.items()):\\n                return num\\n            num+=1\\n        \\n        \\n```",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def nextBeautifulNumber(self, n: int) -> int:\\n        \\n        num=n+1\\n        \\n        while True:\\n            count=Counter(str(num))\\n            if all(int(key)==val for key,val in count.items()):\\n                return num\\n            num+=1\\n        \\n        \\n```",
                "codeTag": "Java"
            },
            {
                "id": 3222746,
                "title": "beginner-friendly-using-next-permutations-dfs-and-set",
                "content": "\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int nextBeautifulNumber(int n) {\\n        vector<vector<int>>ans={{1},//1 digit valid combinations\\n                                {2,2},//2 digit valid combinations\\n                                {1,2,2},{3,3,3},//3 digit valid combinations\\n                                {1,3,3,3},{4,4,4,4},//4 digit \\n                                {1,4,4,4,4},{2,2,3,3,3},{5,5,5,5,5},//5 digits\\n                                {1,5,5,5,5,5},{6,6,6,6,6,6},{2,2,4,4,4,4},{1,2,2,3,3,3},//6 digits\\n                                {1,2,2,4,4,4,4},{1,6,6,6,6,6,6},{2,2,5,5,5,5,5},{3,3,3,4,4,4,4},{7,7,7,7,7,7,7}}//7 digits;\\n        int m=ans.size();\\n        set<int>s;\\n//nxt permutation will create will all the combinations possible with given array of integers like for 1,2,3 -> 1,3,2 -> 2,1,3 -> 2,3,1 -> 3,1,2 -> 3,2,1\\n        for(int i=0;i<m;i++)\\n        {\\n            do\\n            {\\n                int temp=0;\\n                //this look will create number from integer array\\n                for(int j=0;j<ans[i].size();j++)\\n                {\\n                    temp=temp*10+ans[i][j];\\n                }\\n                s.insert(temp);\\n            }while(next_permutation(ans[i].begin(),ans[i].end()));\\n        }\\n//upper_bound will return the very next number greater than n.\\n        return *s.upper_bound(n);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int nextBeautifulNumber(int n) {\\n        vector<vector<int>>ans={{1},//1 digit valid combinations\\n                                {2,2},//2 digit valid combinations\\n                                {1,2,2},{3,3,3},//3 digit valid combinations\\n                                {1,3,3,3},{4,4,4,4},//4 digit \\n                                {1,4,4,4,4},{2,2,3,3,3},{5,5,5,5,5},//5 digits\\n                                {1,5,5,5,5,5},{6,6,6,6,6,6},{2,2,4,4,4,4},{1,2,2,3,3,3},//6 digits\\n                                {1,2,2,4,4,4,4},{1,6,6,6,6,6,6},{2,2,5,5,5,5,5},{3,3,3,4,4,4,4},{7,7,7,7,7,7,7}}//7 digits;\\n        int m=ans.size();\\n        set<int>s;\\n//nxt permutation will create will all the combinations possible with given array of integers like for 1,2,3 -> 1,3,2 -> 2,1,3 -> 2,3,1 -> 3,1,2 -> 3,2,1\\n        for(int i=0;i<m;i++)\\n        {\\n            do\\n            {\\n                int temp=0;\\n                //this look will create number from integer array\\n                for(int j=0;j<ans[i].size();j++)\\n                {\\n                    temp=temp*10+ans[i][j];\\n                }\\n                s.insert(temp);\\n            }while(next_permutation(ans[i].begin(),ans[i].end()));\\n        }\\n//upper_bound will return the very next number greater than n.\\n        return *s.upper_bound(n);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3174872,
                "title": "easy-to-understand-dfs",
                "content": "```\\nclass Solution {\\npublic:\\n    bool isBeautiful(vector<int> &dp) {\\n        for (int i = 1; i < 10; i++) {\\n            if (dp[i]) {\\n                if (dp[i] != i)\\n                    return false;\\n            } \\n        }\\n        return true;\\n    }\\n    int helper(int n, int num, vector<int> &cnt, int sz) {\\n        if (sz == 0) {\\n            if ((num > n) && isBeautiful(cnt)) {\\n                return num;\\n            }\\n            return 0;\\n        }\\n        \\n        int res = 0;\\n        for (int i = 1; (i <= 9) && !res; i++) {\\n            if (cnt[i]  && cnt[i] <= sz) {\\n                cnt[i] -= 1;\\n                res = helper(n, num*10 + i, cnt, sz-1);\\n                cnt[i] += 1;\\n            }\\n        }\\n        return res;\\n    }\\n    int nextBeautifulNumber(int n) {\\n        vector<int> cnt(10);\\n        iota(begin(cnt),end(cnt),0);\\n        int sz = to_string(n).size();\\n        int res = helper(n,0,cnt,sz);\\n        if (res != 0)\\n            return res;\\n        return helper(n,0,cnt,sz+1);\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    bool isBeautiful(vector<int> &dp) {\\n        for (int i = 1; i < 10; i++) {\\n            if (dp[i]) {\\n                if (dp[i] != i)\\n                    return false;\\n            } \\n        }\\n        return true;\\n    }\\n    int helper(int n, int num, vector<int> &cnt, int sz) {\\n        if (sz == 0) {\\n            if ((num > n) && isBeautiful(cnt)) {\\n                return num;\\n            }\\n            return 0;\\n        }\\n        \\n        int res = 0;\\n        for (int i = 1; (i <= 9) && !res; i++) {\\n            if (cnt[i]  && cnt[i] <= sz) {\\n                cnt[i] -= 1;\\n                res = helper(n, num*10 + i, cnt, sz-1);\\n                cnt[i] += 1;\\n            }\\n        }\\n        return res;\\n    }\\n    int nextBeautifulNumber(int n) {\\n        vector<int> cnt(10);\\n        iota(begin(cnt),end(cnt),0);\\n        int sz = to_string(n).size();\\n        int res = helper(n,0,cnt,sz);\\n        if (res != 0)\\n            return res;\\n        return helper(n,0,cnt,sz+1);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3174566,
                "title": "simple-brute-force",
                "content": "```\\nclass Solution {\\npublic:\\n    bool isBeautiful(int n) {\\n        vector<int> dp(10,0);\\n        while(n) {\\n            dp[n%10]++;\\n            n = n/10;\\n        }\\n        bool found = false;\\n        for (int i = 1; i < 10; i++) {\\n            if (dp[i]) {\\n                if (dp[i] != i)\\n                    return false;\\n                found = true;\\n            } \\n        }\\n        return found && !dp[0];\\n    }\\n    int nextBeautifulNumber(int n) {\\n        for (int i = n+1; i <= 7777777; i++) {\\n            if (isBeautiful(i)) {\\n                return i;\\n            }\\n        }\\n        return n;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    bool isBeautiful(int n) {\\n        vector<int> dp(10,0);\\n        while(n) {\\n            dp[n%10]++;\\n            n = n/10;\\n        }\\n        bool found = false;\\n        for (int i = 1; i < 10; i++) {\\n            if (dp[i]) {\\n                if (dp[i] != i)\\n                    return false;\\n                found = true;\\n            } \\n        }\\n        return found && !dp[0];\\n    }\\n    int nextBeautifulNumber(int n) {\\n        for (int i = n+1; i <= 7777777; i++) {\\n            if (isBeautiful(i)) {\\n                return i;\\n            }\\n        }\\n        return n;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3137235,
                "title": "java-hashmap-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public boolean check( int n )\\n    {\\n        HashMap< Integer, Integer > hash = new HashMap<>();\\n        while( n > 0 )\\n        {\\n            int rem = n % 10;\\n            if ( rem == 0 )\\n                return false;\\n            n = n / 10;\\n            if ( hash.containsKey( rem ) )\\n            {\\n                hash.put( rem, hash.get(rem) + 1 );\\n            }\\n            else\\n            {\\n                hash.put( rem, 1 );\\n            }\\n        }\\n        int ans = 0;\\n        for ( Map.Entry< Integer, Integer > pair : hash.entrySet() )\\n        {\\n            if ( pair.getKey() == pair.getValue() )\\n            {\\n                ans++;\\n            }\\n        }\\n\\n        if ( ans == hash.size() )\\n        {\\n            return true;\\n        }\\n        return false;\\n    }\\n    public int nextBeautifulNumber(int n) {\\n        while ( true )\\n        {\\n            n++;\\n            if ( new Solution().check( n ) )\\n                return n;\\n        }\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public boolean check( int n )\\n    {\\n        HashMap< Integer, Integer > hash = new HashMap<>();\\n        while( n > 0 )\\n        {\\n            int rem = n % 10;\\n            if ( rem == 0 )\\n                return false;\\n            n = n / 10;\\n            if ( hash.containsKey( rem ) )\\n            {\\n                hash.put( rem, hash.get(rem) + 1 );\\n            }\\n            else\\n            {\\n                hash.put( rem, 1 );\\n            }\\n        }\\n        int ans = 0;\\n        for ( Map.Entry< Integer, Integer > pair : hash.entrySet() )\\n        {\\n            if ( pair.getKey() == pair.getValue() )\\n            {\\n                ans++;\\n            }\\n        }\\n\\n        if ( ans == hash.size() )\\n        {\\n            return true;\\n        }\\n        return false;\\n    }\\n    public int nextBeautifulNumber(int n) {\\n        while ( true )\\n        {\\n            n++;\\n            if ( new Solution().check( n ) )\\n                return n;\\n        }\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3062446,
                "title": "python-bruteforce-simplest",
                "content": "\\n# Code\\n```\\nclass Solution:\\n    def nextBeautifulNumber(self, n: int) -> int:\\n        while True: \\n            n += 1\\n            freq = Counter(str(n))\\n            if all(int(k) == v for k, v in freq.items()): return n \\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def nextBeautifulNumber(self, n: int) -> int:\\n        while True: \\n            n += 1\\n            freq = Counter(str(n))\\n            if all(int(k) == v for k, v in freq.items()): return n \\n```",
                "codeTag": "Java"
            },
            {
                "id": 3000662,
                "title": "javascript-2-solutions-backtracking-iterative",
                "content": "# Complexity\\n- Time complexity: $$O(n)$$\\n- Space complexity: $$O(digits)$$\\n\\n# Code\\n```\\nvar nextBeautifulNumber = function(n) {\\n    const count = Array.from({ length: 7 }, (_, i) => i);\\n    const digits = [1, 2, 3, 4, 5, 6];\\n    n = n + \"\";\\n\\n    const recursion = (n, num, size) => {\\n        if (size == 0) {\\n            if (num > n && count.every((value, i) => value == i || value == 0))\\n                return num;\\n            return 0;\\n        }\\n\\n        for (const digit of digits) {\\n            count[digit]--;\\n            const res = recursion(n, num * 10 + digit, size - 1);\\n            if (res > 0) return res;\\n            count[digit]++;\\n        }\\n\\n        return 0;\\n    };\\n\\n    return recursion(n, 0, n.length) || recursion(0, 0, n.length + 1)\\n};\\n```\\n# Complexity\\n- Time complexity: $$O(n)$$\\n- Space complexity: $$O(1)$$\\n```\\nvar nextBeautifulNumber = function(n) {\\n    for (let i = n + 1, j = i;; j = ++i) {\\n        const freq = Array(10).fill(0);\\n        while (j > 0) {\\n            freq[j % 10]++;\\n            j = (j - j % 10) / 10;\\n        }\\n\\n        if (freq.every((count, i) => count == 0 || count == i)) return i;\\n    }\\n};\\n```",
                "solutionTags": [
                    "JavaScript",
                    "Backtracking"
                ],
                "code": "```\\nvar nextBeautifulNumber = function(n) {\\n    const count = Array.from({ length: 7 }, (_, i) => i);\\n    const digits = [1, 2, 3, 4, 5, 6];\\n    n = n + \"\";\\n\\n    const recursion = (n, num, size) => {\\n        if (size == 0) {\\n            if (num > n && count.every((value, i) => value == i || value == 0))\\n                return num;\\n            return 0;\\n        }\\n\\n        for (const digit of digits) {\\n            count[digit]--;\\n            const res = recursion(n, num * 10 + digit, size - 1);\\n            if (res > 0) return res;\\n            count[digit]++;\\n        }\\n\\n        return 0;\\n    };\\n\\n    return recursion(n, 0, n.length) || recursion(0, 0, n.length + 1)\\n};\\n```\n```\\nvar nextBeautifulNumber = function(n) {\\n    for (let i = n + 1, j = i;; j = ++i) {\\n        const freq = Array(10).fill(0);\\n        while (j > 0) {\\n            freq[j % 10]++;\\n            j = (j - j % 10) / 10;\\n        }\\n\\n        if (freq.every((count, i) => count == 0 || count == i)) return i;\\n    }\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2858265,
                "title": "c-code-not-a-smart-and-mathy-idea-just-basic-search",
                "content": "Yes, anyone can do it, but the pure act of typing == satisfying (~_~) for me. \\n\\n```cpp\\nclass Solution {\\npublic:\\n    int sel[10];\\n    int res;\\n    int get_nlen(int n) {\\n        if (n == 0)\\n            return 1;\\n        int len = 0;\\n        while (n > 0) {\\n            len++; n /= 10;\\n        }\\n        return len;\\n    }\\n    vector<int> get_sel_d() {\\n        vector<int> d = {};\\n        for (int v = 1; v <= 9; v++) {\\n            for (int i = 0; i < sel[v]; i++) {\\n                d.push_back(v);\\n            }\\n        }\\n        return d;\\n    }\\n    int get_from_sel_d(vector<int>& d) {\\n        int res = 0;\\n        for (int v : d) {\\n            res = res * 10 + v;\\n        }\\n        return res; \\n    }\\n    void opt(int& nlen, int curlen, int& n) {\\n        if (curlen >= (nlen - 1)) {\\n            vector<int> d = get_sel_d();\\n            do {\\n                int tmp = get_from_sel_d(d);\\n                if (tmp > n && res > tmp)\\n                    res = tmp;\\n            } while(std::next_permutation(d.begin(), d.end()));\\n        }\\n        if (curlen < nlen) {\\n            for (int v = 1; v <= 9; v++) {\\n                if ((curlen + v) > nlen)\\n                    break;\\n                if (!sel[v]) {\\n                    sel[v] = v;\\n                    opt(nlen, (curlen + v), n);\\n                    sel[v] = false;\\n                }\\n            }\\n        }\\n    }\\n    int nextBeautifulNumber(int n) {\\n        memset(sel, 0, sizeof(sel));\\n        int nlen = get_nlen(n) + 1;\\n        res = 1e7;\\n        opt(nlen, 0, n);\\n        return res;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```cpp\\nclass Solution {\\npublic:\\n    int sel[10];\\n    int res;\\n    int get_nlen(int n) {\\n        if (n == 0)\\n            return 1;\\n        int len = 0;\\n        while (n > 0) {\\n            len++; n /= 10;\\n        }\\n        return len;\\n    }\\n    vector<int> get_sel_d() {\\n        vector<int> d = {};\\n        for (int v = 1; v <= 9; v++) {\\n            for (int i = 0; i < sel[v]; i++) {\\n                d.push_back(v);\\n            }\\n        }\\n        return d;\\n    }\\n    int get_from_sel_d(vector<int>& d) {\\n        int res = 0;\\n        for (int v : d) {\\n            res = res * 10 + v;\\n        }\\n        return res; \\n    }\\n    void opt(int& nlen, int curlen, int& n) {\\n        if (curlen >= (nlen - 1)) {\\n            vector<int> d = get_sel_d();\\n            do {\\n                int tmp = get_from_sel_d(d);\\n                if (tmp > n && res > tmp)\\n                    res = tmp;\\n            } while(std::next_permutation(d.begin(), d.end()));\\n        }\\n        if (curlen < nlen) {\\n            for (int v = 1; v <= 9; v++) {\\n                if ((curlen + v) > nlen)\\n                    break;\\n                if (!sel[v]) {\\n                    sel[v] = v;\\n                    opt(nlen, (curlen + v), n);\\n                    sel[v] = false;\\n                }\\n            }\\n        }\\n    }\\n    int nextBeautifulNumber(int n) {\\n        memset(sel, 0, sizeof(sel));\\n        int nlen = get_nlen(n) + 1;\\n        res = 1e7;\\n        opt(nlen, 0, n);\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2841279,
                "title": "python-solution-using-normal-for-loop",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n       \\n\\n# Code\\n```\\nclass Solution:\\n    def nextBeautifulNumber(self, n: int) -> int:\\n        if(n==0):return 1\\n        for x in range(n+1,1000000000):\\n            l=[]\\n            count=0\\n            for y in str(x):\\n                l.append(int(y))\\n            l1=set(l)\\n            for z in l1:\\n                a=l.count(z)\\n                if(a==z and x>9):\\n                    count+=1\\n            if(count==len(list(l1))):\\n                return x\\n            \\n  \\n\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def nextBeautifulNumber(self, n: int) -> int:\\n        if(n==0):return 1\\n        for x in range(n+1,1000000000):\\n            l=[]\\n            count=0\\n            for y in str(x):\\n                l.append(int(y))\\n            l1=set(l)\\n            for z in l1:\\n                a=l.count(z)\\n                if(a==z and x>9):\\n                    count+=1\\n            if(count==len(list(l1))):\\n                return x\\n            \\n  \\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2766178,
                "title": "brute-force",
                "content": "```\\nclass Solution {\\n    public int nextBeautifulNumber(int n) {\\n        while(true){\\n            if(helper(++n)) return n;\\n        }\\n        \\n    }\\n    boolean helper(int n){\\n        int[] freq=new int[10];\\n        while(n>0){\\n            int rem=n%10;\\n            if(rem==0) return false;\\n            freq[rem]++;\\n            n/=10;\\n        }\\n        for(int i=1;i<10;i++){\\n            if(freq[i]!=0 && freq[i]!=i) return false;\\n        }\\n        return true;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int nextBeautifulNumber(int n) {\\n        while(true){\\n            if(helper(++n)) return n;\\n        }\\n        \\n    }\\n    boolean helper(int n){\\n        int[] freq=new int[10];\\n        while(n>0){\\n            int rem=n%10;\\n            if(rem==0) return false;\\n            freq[rem]++;\\n            n/=10;\\n        }\\n        for(int i=1;i<10;i++){\\n            if(freq[i]!=0 && freq[i]!=i) return false;\\n        }\\n        return true;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2739688,
                "title": "java-solution-brute-force-w-r-t-constraints",
                "content": "```\\nclass Solution {\\n    public int nextBeautifulNumber(int n) {\\n        int candidate = n + 1;\\n        while (candidate <= 1_224_444) {\\n            if (this.isBalanced(candidate))\\n                return candidate;\\n            \\n            candidate++;\\n        }\\n        \\n        return -1;\\n    }\\n    \\n    private boolean isBalanced(int num) {\\n        int[] counter = new int[9];\\n        int m = num;\\n        while (m != 0) {\\n            int digit = m % 10;\\n            \\n            if (digit == 0)\\n                return false;\\n            \\n            counter[digit - 1]++;\\n            m /= 10;\\n        }\\n        \\n        for (int i = 0; i < 9; i++) {\\n            if (counter[i] != 0 && counter[i] != i + 1)\\n                return false;\\n        }\\n        \\n        return true;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int nextBeautifulNumber(int n) {\\n        int candidate = n + 1;\\n        while (candidate <= 1_224_444) {\\n            if (this.isBalanced(candidate))\\n                return candidate;\\n            \\n            candidate++;\\n        }\\n        \\n        return -1;\\n    }\\n    \\n    private boolean isBalanced(int num) {\\n        int[] counter = new int[9];\\n        int m = num;\\n        while (m != 0) {\\n            int digit = m % 10;\\n            \\n            if (digit == 0)\\n                return false;\\n            \\n            counter[digit - 1]++;\\n            m /= 10;\\n        }\\n        \\n        for (int i = 0; i < 9; i++) {\\n            if (counter[i] != 0 && counter[i] != i + 1)\\n                return false;\\n        }\\n        \\n        return true;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2690355,
                "title": "backtracking",
                "content": "```\\nclass Solution:\\n    def nextBeautifulNumber(self, n: int) -> int:\\n        \\n        \\n        l = len(str(n))\\n        arr = [i for i in range(1,l+2)]\\n        \\n        \\n        def dfs(final,path,index):\\n            if sum(path) == l or sum(path) == l+1:\\n                final.append(path)\\n            \\n            for i in range(index,len(arr)):\\n                dfs(final,path+[arr[i]],i+1)\\n        \\n        \\n        def recur(final,path,string):\\n            if string == \"\":\\n                if int(path) > n and int(path) < ans[0]:\\n                    ans[0] = int(path)\\n                return\\n            \\n            for i in range(len(string)):\\n                recur(final,path+string[i] , string[:i]+string[i+1:])\\n        \\n        final = []\\n        path = []\\n        dfs(final,path,0)\\n        print(final)\\n        \\n        ans = [float(\\'inf\\')]\\n        for string in [\"\".join(str(i)*i for i in A) for A in final]:\\n            \\n            recur(final,\"\",string)\\n            \\n        return ans[0]\\n        \\n```",
                "solutionTags": [
                    "Backtracking"
                ],
                "code": "```\\nclass Solution:\\n    def nextBeautifulNumber(self, n: int) -> int:\\n        \\n        \\n        l = len(str(n))\\n        arr = [i for i in range(1,l+2)]\\n        \\n        \\n        def dfs(final,path,index):\\n            if sum(path) == l or sum(path) == l+1:\\n                final.append(path)\\n            \\n            for i in range(index,len(arr)):\\n                dfs(final,path+[arr[i]],i+1)\\n        \\n        \\n        def recur(final,path,string):\\n            if string == \"\":\\n                if int(path) > n and int(path) < ans[0]:\\n                    ans[0] = int(path)\\n                return\\n            \\n            for i in range(len(string)):\\n                recur(final,path+string[i] , string[:i]+string[i+1:])\\n        \\n        final = []\\n        path = []\\n        dfs(final,path,0)\\n        print(final)\\n        \\n        ans = [float(\\'inf\\')]\\n        for string in [\"\".join(str(i)*i for i in A) for A in final]:\\n            \\n            recur(final,\"\",string)\\n            \\n        return ans[0]\\n        \\n```",
                "codeTag": "Java"
            },
            {
                "id": 2664001,
                "title": "rust-0ms-100-fastest-using-binary-search-on-pre-computed-numbers",
                "content": "There are 110 numbers between 0 and 1_000_000: \\nPrecompute the value of the numbers using brute-force; include them with the program, \\nthen use upper-bound binary search:\\n```\\nimpl Solution {\\n    pub fn next_beautiful_number(n: i32) -> i32 {\\n        let numbers = vec![\\n            0, 1, 22, 122, 212, 221, 333, 1333, 3133, 3313, 3331, 4444, 14444, 22333, 23233, 23323,\\n            23332, 32233, 32323, 32332, 33223, 33232, 33322, 41444, 44144, 44414, 44441, 55555,\\n            122333, 123233, 123323, 123332, 132233, 132323, 132332, 133223, 133232, 133322, 155555,\\n            212333, 213233, 213323, 213332, 221333, 223133, 223313, 223331, 224444, 231233, 231323,\\n            231332, 232133, 232313, 232331, 233123, 233132, 233213, 233231, 233312, 233321, 242444,\\n            244244, 244424, 244442, 312233, 312323, 312332, 313223, 313232, 313322, 321233, 321323,\\n            321332, 322133, 322313, 322331, 323123, 323132, 323213, 323231, 323312, 323321, 331223,\\n            331232, 331322, 332123, 332132, 332213, 332231, 332312, 332321, 333122, 333212, 333221,\\n            422444, 424244, 424424, 424442, 442244, 442424, 442442, 444224, 444242, 444422, 515555,\\n            551555, 555155, 555515, 555551, 666666, 1224444\\n        ];\\n\\n        let mut l = 0;\\n        let mut r = numbers.len();\\n        let mut found = i32::MAX;\\n\\n\\n        while l <= r {\\n            let m = (l+r)/2;\\n            let k = numbers[m];\\n            if k == n {\\n                return numbers[m+1];\\n            } else if k > n {\\n                found = k;\\n                r = m - 1;\\n            } else {\\n                l = m + 1;\\n            }\\n        }\\n        found\\n    }\\n}\\n```",
                "solutionTags": [
                    "Rust",
                    "Binary Tree"
                ],
                "code": "```\\nimpl Solution {\\n    pub fn next_beautiful_number(n: i32) -> i32 {\\n        let numbers = vec![\\n            0, 1, 22, 122, 212, 221, 333, 1333, 3133, 3313, 3331, 4444, 14444, 22333, 23233, 23323,\\n            23332, 32233, 32323, 32332, 33223, 33232, 33322, 41444, 44144, 44414, 44441, 55555,\\n            122333, 123233, 123323, 123332, 132233, 132323, 132332, 133223, 133232, 133322, 155555,\\n            212333, 213233, 213323, 213332, 221333, 223133, 223313, 223331, 224444, 231233, 231323,\\n            231332, 232133, 232313, 232331, 233123, 233132, 233213, 233231, 233312, 233321, 242444,\\n            244244, 244424, 244442, 312233, 312323, 312332, 313223, 313232, 313322, 321233, 321323,\\n            321332, 322133, 322313, 322331, 323123, 323132, 323213, 323231, 323312, 323321, 331223,\\n            331232, 331322, 332123, 332132, 332213, 332231, 332312, 332321, 333122, 333212, 333221,\\n            422444, 424244, 424424, 424442, 442244, 442424, 442442, 444224, 444242, 444422, 515555,\\n            551555, 555155, 555515, 555551, 666666, 1224444\\n        ];\\n\\n        let mut l = 0;\\n        let mut r = numbers.len();\\n        let mut found = i32::MAX;\\n\\n\\n        while l <= r {\\n            let m = (l+r)/2;\\n            let k = numbers[m];\\n            if k == n {\\n                return numbers[m+1];\\n            } else if k > n {\\n                found = k;\\n                r = m - 1;\\n            } else {\\n                l = m + 1;\\n            }\\n        }\\n        found\\n    }\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2656357,
                "title": "easy-c-brute-force",
                "content": "class Solution {\\npublic:\\n    \\n\\t\\n\\t\\n\\tbool notBalanced(int n){\\n        vector<int> a(10,0);\\n        \\n        while(n>0){\\n            a[n%10]++;\\n            n/=10;\\n        }\\n        \\n        if(a[0] != 0) return true;\\n        \\n        for(int i = 1; i <= 9; ++i){\\n          if(a[i] != i && a[i] != 0)return true;\\n        }\\n        \\n        return false;\\n    }\\n    \\n    int nextBeautifulNumber(int n) {\\n      n = n+1;\\n      while(notBalanced(n)){\\n          \\n          n = n+1; \\n      }\\n        \\n        return n;\\n    }\\n};",
                "solutionTags": [],
                "code": "class Solution {\\npublic:\\n    \\n\\t\\n\\t\\n\\tbool notBalanced(int n){\\n        vector<int> a(10,0);\\n        \\n        while(n>0){\\n            a[n%10]++;\\n            n/=10;\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 2650262,
                "title": "easy-c-backtracking-solution-beats-66-c-solution",
                "content": "class Solution {\\npublic:\\n    bool IsSafe(int index,int i,int (&countarr)[10],string &temp)\\n{\\n    if(countarr[i] < i && i <= temp.length() )\\n        return true;\\n    else\\n        return false;\\n}\\nbool IsAns(string &str,int (&countarr)[10],int &n,string &temp)\\n{\\n    for(int i = 1;i<=temp.length();i++)\\n    {\\n        if(countarr[i] != 0 && countarr[i] != i)\\n            return false;\\n    }\\n    int ans = stoi(str);\\n    if(ans >= n)\\n        return true;\\n     return false;\\n}\\nbool solve(int index,string &str,int &size,int (&countarr)[10],int &n,string &temp)\\n{\\n    if(index == size)\\n    {\\n        if(IsAns(str,countarr,n,temp))\\n        {\\n            return true;\\n        }\\n        return false;\\n    }\\n    for(int i = 1;i<=size;i++)\\n    {\\n        if(IsSafe(index,i,countarr,temp))\\n        {\\n            char toadd = i + \\'0\\';\\n            str.push_back(toadd);\\n            countarr[i]++;\\n            bool next_step_ans = solve(index+1,str,size,countarr,n,temp);\\n            if(next_step_ans)\\n            {\\n                return true;\\n            }\\n            else\\n            {\\n                countarr[i]--;\\n                str.pop_back();\\n            }\\n        }\\n    }\\n    return false;\\n}\\n    int nextBeautifulNumber(int n) {\\n        n++;\\n        string temp = to_string(n);\\n        int size = temp.length();\\n        int index = 0;\\n        int countarr[10] = {0};\\n        string str = \"\";\\n        bool ans;\\n        bool flag = false;\\n        int firstnumber = temp[0] - \\'0\\';\\n        if(firstnumber <= size)\\n        {\\n            ans = solve(index,str,size,countarr,n,temp);\\n            if(ans)\\n                flag = true;\\n        }\\n        if(flag == false)\\n        {\\n            n = pow(10,size);\\n            temp = to_string(n);\\n            size = temp.length();\\n            ans = solve(index,str,size,countarr,n,temp);\\n        }\\n        int output = stoi(str);\\n        return output;\\n        }\\n};",
                "solutionTags": [
                    "Backtracking",
                    "Recursion"
                ],
                "code": "class Solution {\\npublic:\\n    bool IsSafe(int index,int i,int (&countarr)[10],string &temp)\\n{\\n    if(countarr[i] < i && i <= temp.length() )\\n        return true;\\n    else\\n        return false;\\n}",
                "codeTag": "Java"
            },
            {
                "id": 2630064,
                "title": "fastest-python-solution-so-far",
                "content": "The code is quite self explanatory. \\nFirst, we create a *cache* of all beutiful numbers, `balancedNums` to reuse across all test cases.\\nThen, we find the number strictly larger than `n` using binary/bisection search.\\nPython\\'s built-in `bisect.bisect_right` function can do this task efficiently.\\n\\n```\\ndef sanitize(tuples):\\n    strings = map(lambda t: \\'\\'.join(t), tuples)\\n    numbers = map(int, strings)\\n    return sorted(set(numbers))\\n        \\nclass Solution:\\n    balancedNums = sanitize(\\n        [(\\'2\\', \\'2\\')]\\n        + list(permutations(\\'122\\', 3))\\n        + [tuple(\\'333\\')]\\n        + list(permutations(\\'1333\\', 4))\\n        + [tuple(\\'4444\\')]\\n        + list(permutations(\\'14444\\', 5)) + list(permutations(\\'22333\\', 5))\\n        + [tuple(\\'55555\\')]\\n        + list(permutations(\\'155555\\', 6)) \\n        + list(permutations(\\'224444\\', 6)) \\n        + list(permutations(\\'122333\\', 6))\\n        + [tuple(\\'666666\\')]\\n    )\\n    \\n    def nextBeautifulNumber(self, n: int) -> int:\\n        if n == 0:\\n            return 1\\n        \\n        idx = bisect.bisect_right(self.balancedNums, n)\\n        return self.balancedNums[idx]\\n```",
                "solutionTags": [
                    "Python",
                    "Binary Search",
                    "Binary Tree"
                ],
                "code": "```\\ndef sanitize(tuples):\\n    strings = map(lambda t: \\'\\'.join(t), tuples)\\n    numbers = map(int, strings)\\n    return sorted(set(numbers))\\n        \\nclass Solution:\\n    balancedNums = sanitize(\\n        [(\\'2\\', \\'2\\')]\\n        + list(permutations(\\'122\\', 3))\\n        + [tuple(\\'333\\')]\\n        + list(permutations(\\'1333\\', 4))\\n        + [tuple(\\'4444\\')]\\n        + list(permutations(\\'14444\\', 5)) + list(permutations(\\'22333\\', 5))\\n        + [tuple(\\'55555\\')]\\n        + list(permutations(\\'155555\\', 6)) \\n        + list(permutations(\\'224444\\', 6)) \\n        + list(permutations(\\'122333\\', 6))\\n        + [tuple(\\'666666\\')]\\n    )\\n    \\n    def nextBeautifulNumber(self, n: int) -> int:\\n        if n == 0:\\n            return 1\\n        \\n        idx = bisect.bisect_right(self.balancedNums, n)\\n        return self.balancedNums[idx]\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2622431,
                "title": "pysch-o-1-solution-permutation",
                "content": "I know brute would have worked as well but still I have come up with constant-time unusual aprroach.\\nIdea is to think of all `beautifullNumbers` of length 1 to 6. \\nFor length 1, number is `1`\\nfor length 2, number is `22`\\nfor length 3, number is Permutation of 122 ie `122,221 and 212` and `333`\\nfor length 4, numbers are Permutation of 1333 ie `1333,3133,3331 and 3313` and `4444`\\nsimilary I filled the vector beautifulNumbers and just looped through it.\\n\\nFor creating permutations of digits to get all numbers, I used this next-permutation.\\n\\n**Time**: `O(K log K) ` where K = length of vector = 277 ie **O(1)**\\n\\n```\\nint nextBeautifulNumber(int n) {\\n        vector <int> beautifullNumbers={1,22,122,212,221,333,1333,3133,3331,3313,4444,14444,41444,44144,44414,44441,22333,23233,23323,23332,32233,32323,32332,33223,33232,33322,55555,155555,515555,551555,555155,555515,555551,224444,242444,244244,244424,244442,422444,424244,424424,424442,442244,442424,442442,444224,444242,444422,122333,123233,123323,123332,132233,132323,132332,133223,133232,133322,212333,213233,213323,213332,221333,223133,223313,223331,231233,231323,231332,232133,232313,232331,233123,233132,233213,233231,233312,233321,312233,312323,312332,313223,313232,313322,321233,321323,321332,322133,322313,322331,323123,323132,323213,323231,323312,323321,331223,331232,331322,332123,332132,332213,332231,332312,332321,333122,333212,333221,666666,1666666,6166666,6616666,6661666,6666166,6666616,6666661,1224444,1242444,1244244,1244424,1244442,1422444,1424244,1424424,1424442,1442244,1442424,1442442,1444224,1444242,1444422,2124444,2142444,2144244,2144424,2144442,2214444,2241444,2244144,2244414,2244441,2412444,2414244,2414424,2414442,2421444,2424144,2424414,2424441,2441244,2441424,2441442,2442144,2442414,2442441,2444124,2444142,2444214,2444241,2444412,2444421,4122444,4124244,4124424,4124442,4142244,4142424,4142442,4144224,4144242,4144422,4212444,4214244,4214424,4214442,4221444,4224144,4224414,4224441,4241244,4241424,4241442,4242144,4242414,4242441,4244124,4244142,4244214,4244241,4244412,4244421,4412244,4412424,4412442,4414224,4414242,4414422,4421244,4421424,4421442,4422144,4422414,4422441,4424124,4424142,4424214,4424241,4424412,4424421,4441224,4441242,4441422,4442124,4442142,4442214,4442241,4442412,4442421,4444122,4444212,4444221,2255555,2525555,2552555,2555255,2555525,2555552,5225555,5252555,5255255,5255525,5255552,5522555,5525255,5525525,5525552,5552255,5552525,5552552,5555225,5555252,5555522,3334444,3343444,3344344,3344434,3344443,3433444,3434344,3434434,3434443,3443344,3443434,3443443,3444334,3444343,3444433,4333444,4334344,4334434,4334443,4343344,4343434,4343443,4344334,4344343,4344433,4433344,4433434,4433443,4434334,4434343,4434433,4443334,4443343,4443433,4444333};\\n    \\n        sort(beautifullNumbers.begin(),beautifullNumbers.end());\\n        int ans=0;\\n        for(int i=0;i<beautifullNumbers.size();i++){\\n            if(beautifullNumbers[i]>n){\\n                ans=beautifullNumbers[i];\\n                break;\\n            }\\n        }\\n        return ans;\\n    }\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nint nextBeautifulNumber(int n) {\\n        vector <int> beautifullNumbers={1,22,122,212,221,333,1333,3133,3331,3313,4444,14444,41444,44144,44414,44441,22333,23233,23323,23332,32233,32323,32332,33223,33232,33322,55555,155555,515555,551555,555155,555515,555551,224444,242444,244244,244424,244442,422444,424244,424424,424442,442244,442424,442442,444224,444242,444422,122333,123233,123323,123332,132233,132323,132332,133223,133232,133322,212333,213233,213323,213332,221333,223133,223313,223331,231233,231323,231332,232133,232313,232331,233123,233132,233213,233231,233312,233321,312233,312323,312332,313223,313232,313322,321233,321323,321332,322133,322313,322331,323123,323132,323213,323231,323312,323321,331223,331232,331322,332123,332132,332213,332231,332312,332321,333122,333212,333221,666666,1666666,6166666,6616666,6661666,6666166,6666616,6666661,1224444,1242444,1244244,1244424,1244442,1422444,1424244,1424424,1424442,1442244,1442424,1442442,1444224,1444242,1444422,2124444,2142444,2144244,2144424,2144442,2214444,2241444,2244144,2244414,2244441,2412444,2414244,2414424,2414442,2421444,2424144,2424414,2424441,2441244,2441424,2441442,2442144,2442414,2442441,2444124,2444142,2444214,2444241,2444412,2444421,4122444,4124244,4124424,4124442,4142244,4142424,4142442,4144224,4144242,4144422,4212444,4214244,4214424,4214442,4221444,4224144,4224414,4224441,4241244,4241424,4241442,4242144,4242414,4242441,4244124,4244142,4244214,4244241,4244412,4244421,4412244,4412424,4412442,4414224,4414242,4414422,4421244,4421424,4421442,4422144,4422414,4422441,4424124,4424142,4424214,4424241,4424412,4424421,4441224,4441242,4441422,4442124,4442142,4442214,4442241,4442412,4442421,4444122,4444212,4444221,2255555,2525555,2552555,2555255,2555525,2555552,5225555,5252555,5255255,5255525,5255552,5522555,5525255,5525525,5525552,5552255,5552525,5552552,5555225,5555252,5555522,3334444,3343444,3344344,3344434,3344443,3433444,3434344,3434434,3434443,3443344,3443434,3443443,3444334,3444343,3444433,4333444,4334344,4334434,4334443,4343344,4343434,4343443,4344334,4344343,4344433,4433344,4433434,4433443,4434334,4434343,4434433,4443334,4443343,4443433,4444333};\\n    \\n        sort(beautifullNumbers.begin(),beautifullNumbers.end());\\n        int ans=0;\\n        for(int i=0;i<beautifullNumbers.size();i++){\\n            if(beautifullNumbers[i]>n){\\n                ans=beautifullNumbers[i];\\n                break;\\n            }\\n        }\\n        return ans;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2593099,
                "title": "simple-java-solution-hashmap",
                "content": "class Solution {\\n    public int nextBeautifulNumber(int n) {\\n        int z=n,ans=0;\\n        if(n==0)\\n            return 1;\\n        if(n<22)\\n            return 22;\\n        int no=0;\\n        while(z!=0)\\n        {\\n            z=z/10;\\n            no++;\\n        }\\n        z=n;\\n        int t=0;\\n        while(z!=0)\\n        {\\n                t=t*10+no;\\n            z=z/10;\\n            \\n        }\\n        z=n;\\n        if(n>=t)\\n        {\\n            int l =1;\\n            while(z!=0)\\n            {\\n                l=l*10+no;\\n                z=z/10;\\n            }\\n             for( int i=n+1;i<=l;i++)\\n                {\\n                HashMap<Integer,Integer> hm = new HashMap<>();\\n                int s =i;\\n                while(s!=0)\\n                 {\\n                    hm.put(s%10,hm.getOrDefault(s%10,0)+1);\\n                    s=s/10;\\n                 }\\n                \\n                if(check(hm))\\n                {\\n                    ans = i;\\n                    break;\\n                }\\n                }\\n        }\\n        else{\\n            for( int i=n+1;i<=t;i++)\\n                {\\n                HashMap<Integer,Integer> hm = new HashMap<>();\\n                int s =i;\\n                while(s!=0)\\n                 {\\n                    hm.put(s%10,hm.getOrDefault(s%10,0)+1);\\n                    s=s/10;\\n                 }\\n                \\n                if(check(hm))\\n                {\\n                    ans = i;\\n                    break;\\n                }\\n                }\\n                \\n        return ans;\\n        \\n    }\\n     return ans;   \\n    }\\n    public boolean check(HashMap<Integer,Integer>hm)\\n    {\\n        for(int x: hm.keySet())\\n        {\\n            if(hm.get(x) !=x)\\n            {\\n                return false;\\n            }\\n        }\\n        return true;\\n    }\\n                }\\n\\t\\t***your vote is appreciated\\n",
                "solutionTags": [],
                "code": "class Solution {\\n    public int nextBeautifulNumber(int n) {\\n        int z=n,ans=0;\\n        if(n==0)\\n            return 1;\\n        if(n<22)\\n            return 22;\\n        int no=0;\\n        while(z!=0)\\n        {\\n            z=z/10;\\n            no++;\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 2578738,
                "title": "simple-python-backtracking-solution",
                "content": "```\\nclass Solution:\\n    def nextBeautifulNumber(self, n: int) -> int:\\n        count = [0, 1, 2, 3, 4, 5, 6, 7, 8, 9]\\n        def solve(count: List[int], size: int, val: int) -> List[int]:\\n            if not size:\\n                for digit, cnt in enumerate(count):\\n                    if cnt != digit and cnt != 0:\\n                        return 0\\n                yield val if val > n else 0\\n            for digit in range(10):\\n                if count[digit] > 0 and count[digit] <= size:\\n                    count[digit] -= 1\\n                    yield from solve(count, size - 1, val * 10 + digit)\\n                    count[digit] += 1\\n        \\n        for numLen in range(len(str(n)), len(str(n)) + 2):\\n            for num in solve(count, numLen, 0):\\n                if num:\\n                    return num\\n```",
                "solutionTags": [
                    "Python",
                    "Backtracking"
                ],
                "code": "```\\nclass Solution:\\n    def nextBeautifulNumber(self, n: int) -> int:\\n        count = [0, 1, 2, 3, 4, 5, 6, 7, 8, 9]\\n        def solve(count: List[int], size: int, val: int) -> List[int]:\\n            if not size:\\n                for digit, cnt in enumerate(count):\\n                    if cnt != digit and cnt != 0:\\n                        return 0\\n                yield val if val > n else 0\\n            for digit in range(10):\\n                if count[digit] > 0 and count[digit] <= size:\\n                    count[digit] -= 1\\n                    yield from solve(count, size - 1, val * 10 + digit)\\n                    count[digit] += 1\\n        \\n        for numLen in range(len(str(n)), len(str(n)) + 2):\\n            for num in solve(count, numLen, 0):\\n                if num:\\n                    return num\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2558154,
                "title": "what-is-wrong-here-giving-me-runtime-error",
                "content": "\\nclass Solution {\\npublic: \\n    int ans;\\n    int makenum(vector<int> &v)\\n    {\\n        int mn = 0, mul=1;\\n        int i = v.size();\\n        i--;\\n        for( ; i>=0; i--)\\n        {\\n            mn  += v[i]*mul;\\n            mul *= 10;\\n        }\\n        return mn;\\n    }\\n    bool fn (int i, int len, unordered_map<int, int> &mp, vector<int> &v, int N)\\n    {      \\n        if(i == len)\\n        {           \\n                for(auto x: mp)\\n                {\\n                    if(x.first != x.second)\\n                        return false;\\n                }                 \\n                int mn = makenum(v);\\n                if( mn > N )\\n                {\\n                    ans = mn ;\\n                    return true;\\n                }   \\n            return false;\\n        }      \\n        for(int j=1; j<=len; j++)\\n        {\\n            if(mp[j]+1 <= j)\\n            {\\n                 mp[j]++;\\n                 v.push_back(v[i]);\\n                 if( fn(i+1, len, mp, v, N) )\\n                     return true;\\n                 mp[j]--;\\n                 v.pop_back();\\n            }\\n        }\\n        return true;\\n    }    \\n    int nextBeautifulNumber(int n) {\\n        if(n<22) return 22;\\n        string tmp = to_string(n);\\n        int len = tmp.size(); \\n        vector<int> v;\\n        unordered_map<int, int> mp;\\n        if(fn(0, len , mp, v, n)) \\n            return ans;\\n        else if (fn(0, len + 1, mp, v, n)) \\n            return ans;\\n        return -1;\\n        \\n    }\\n};",
                "solutionTags": [],
                "code": "class Solution {\\npublic: \\n    int ans;\\n    int makenum(vector<int> &v)\\n    {\\n        int mn = 0, mul=1;\\n        int i = v.size();\\n        i--;\\n        for( ; i>=0; i--)\\n        {\\n            mn  += v[i]*mul;\\n            mul *= 10;\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 2549216,
                "title": "simple-c-brute-force-solution",
                "content": "```\\nclass Solution {\\nprivate:\\n    bool isNumericallyBalanced(int n){\\n        string num = to_string(n);\\n        int arr[10] = {};\\n        for(auto el: num){\\n            arr[el - \\'0\\']++;\\n        }\\n        for(int i = 0 ; i <= 9 ; i++){\\n            if(arr[i] != 0 && i != arr[i]) return false;\\n        }\\n        return true;\\n    }\\npublic:\\n    int nextBeautifulNumber(int n) {\\n        int candidate = n + 1;\\n        while(true){\\n            if(isNumericallyBalanced(candidate)){\\n                break;\\n            }\\n            candidate++;\\n        }\\n        return candidate;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Enumeration"
                ],
                "code": "```\\nclass Solution {\\nprivate:\\n    bool isNumericallyBalanced(int n){\\n        string num = to_string(n);\\n        int arr[10] = {};\\n        for(auto el: num){\\n            arr[el - \\'0\\']++;\\n        }\\n        for(int i = 0 ; i <= 9 ; i++){\\n            if(arr[i] != 0 && i != arr[i]) return false;\\n        }\\n        return true;\\n    }\\npublic:\\n    int nextBeautifulNumber(int n) {\\n        int candidate = n + 1;\\n        while(true){\\n            if(isNumericallyBalanced(candidate)){\\n                break;\\n            }\\n            candidate++;\\n        }\\n        return candidate;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2534532,
                "title": "java-solution-easy-hashmap",
                "content": "```\\nclass Solution {\\n    public int nextBeautifulNumber(int n) {\\n        n=n+1;\\n        while(true)\\n        {\\n            if(find(n)) return n;\\n            else\\n                n++;\\n        }\\n        \\n    }\\n    public boolean find(int n)\\n    {\\n        HashMap<Integer, Integer> hm = new HashMap<>();\\n        while(n!=0)\\n        {\\n            int x=n%10;\\n            if(hm.containsKey(x))\\n                hm.put(x,hm.get(x)+1);\\n            else\\n                hm.put(x,1);\\n            n=n/10;\\n        }\\n        for(Map.Entry<Integer,Integer> map : hm.entrySet()) \\n        {\\n            if(map.getKey()!=map.getValue()) return false;\\n        }\\n        return true;\\n}\\n}\\n",
                "solutionTags": [
                    "Java"
                ],
                "code": "class Solution {\\n    public int nextBeautifulNumber(int n) {\\n        n=n+1;\\n        while(true)\\n        {\\n            if(find(n)) return n;\\n            else\\n                n++;\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 2490369,
                "title": "python-3-backtrack",
                "content": "\\tclass Solution:            \\n\\t\\tdef nextBeautifulNumber(self, n: int) -> int:\\n\\t\\t\\tcnt=[0,1,2,3,4,5,6,7,8,9]\\n\\t\\t\\tdef solve(cnt,sz,val):\\n\\t\\t\\t\\tif sz==0:\\n\\t\\t\\t\\t\\tfor i,x in enumerate(cnt):\\n\\t\\t\\t\\t\\t\\tif x!=i and x!=0:\\n\\t\\t\\t\\t\\t\\t\\treturn 0\\n\\t\\t\\t\\t\\tyield val if val>n else 0\\n\\t\\t\\t\\tres=0\\n\\t\\t\\t\\tfor i in range(10):\\n\\t\\t\\t\\t\\tif cnt[i]>0 and cnt[i]<=sz:\\n\\t\\t\\t\\t\\t\\tcnt[i]-=1\\n\\t\\t\\t\\t\\t\\tyield from solve(cnt,sz-1,val*10+i)\\n\\t\\t\\t\\t\\t\\tcnt[i]+=1\\n\\t\\t\\tfor numLen in range(len(str(n)), len(str(n)) + 2):\\n\\t\\t\\t\\tfor num in solve(cnt,numLen,0):\\n\\t\\t\\t\\t\\tif num:\\n\\t\\t\\t\\t\\t\\treturn num",
                "solutionTags": [],
                "code": "\\tclass Solution:            \\n\\t\\tdef nextBeautifulNumber(self, n: int) -> int:\\n\\t\\t\\tcnt=[0,1,2,3,4,5,6,7,8,9]\\n\\t\\t\\tdef solve(cnt,sz,val):\\n\\t\\t\\t\\tif sz==0:\\n\\t\\t\\t\\t\\tfor i,x in enumerate(cnt):\\n\\t\\t\\t\\t\\t\\tif x!=i and x!=0:\\n\\t\\t\\t\\t\\t\\t\\treturn 0\\n\\t\\t\\t\\t\\tyield val if val>n else 0\\n\\t\\t\\t\\tres=0\\n\\t\\t\\t\\tfor i in range(10):\\n\\t\\t\\t\\t\\tif cnt[i]>0 and cnt[i]<=sz:\\n\\t\\t\\t\\t\\t\\tcnt[i]-=1\\n\\t\\t\\t\\t\\t\\tyield from solve(cnt,sz-1,val*10+i)\\n\\t\\t\\t\\t\\t\\tcnt[i]+=1\\n\\t\\t\\tfor numLen in range(len(str(n)), len(str(n)) + 2):\\n\\t\\t\\t\\tfor num in solve(cnt,numLen,0):\\n\\t\\t\\t\\t\\tif num:\\n\\t\\t\\t\\t\\t\\treturn num",
                "codeTag": "Java"
            },
            {
                "id": 2471714,
                "title": "easy-brute-force-using-counting",
                "content": "```\\nclass Solution {\\n    public int nextBeautifulNumber(int n) {\\n        n++;\\n        while(true){\\n            if(ok(n))\\n                return n;\\n            n++;\\n        }\\n    }\\n    \\n    private boolean ok(int n){\\n        int count[] = new int[10];\\n        \\n        int temp = n;\\n        \\n        while(n!=0){\\n            int lastDigit = n%10;\\n            \\n            count[lastDigit]++;\\n            \\n            n = n/10;\\n        }\\n        \\n        while(temp!=0){\\n            int lastDigit = temp%10;\\n            \\n            if(count[lastDigit]!=lastDigit)\\n                return false;\\n            \\n            temp/=10;\\n        }\\n        \\n        return true;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Counting"
                ],
                "code": "```\\nclass Solution {\\n    public int nextBeautifulNumber(int n) {\\n        n++;\\n        while(true){\\n            if(ok(n))\\n                return n;\\n            n++;\\n        }\\n    }\\n    \\n    private boolean ok(int n){\\n        int count[] = new int[10];\\n        \\n        int temp = n;\\n        \\n        while(n!=0){\\n            int lastDigit = n%10;\\n            \\n            count[lastDigit]++;\\n            \\n            n = n/10;\\n        }\\n        \\n        while(temp!=0){\\n            int lastDigit = temp%10;\\n            \\n            if(count[lastDigit]!=lastDigit)\\n                return false;\\n            \\n            temp/=10;\\n        }\\n        \\n        return true;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2427999,
                "title": "brute-force-hashmap",
                "content": "\\tclass Solution {\\n\\t\\tpublic int nextBeautifulNumber(int n) {\\n        \\n        for(int i=n+1;i<=9999999;i++){\\n            if(isBalanced(i)){\\n                return i;\\n            }\\n        }\\n        \\n        \\n        return -1;\\n        \\n    }\\n    \\n    public static boolean isBalanced(int i){\\n        HashMap<Integer,Integer> map = new HashMap<>();\\n        \\n        \\n        while(i>0){\\n            int n=i%10;\\n            i /=10;\\n            map.put(n,map.getOrDefault(n,0)+1);\\n        }\\n        \\n        for(int key:map.keySet()){\\n            if(key != map.get(key)){\\n                return false;\\n            }\\n        }\\n        \\n        return true;\\n    }\\n}",
                "solutionTags": [
                    "Java"
                ],
                "code": "class Solution {\\n\\t\\tpublic int nextBeautifulNumber(int n) {\\n        \\n        for(int i=n+1;i<=9999999;i++){\\n            if(isBalanced(i)){\\n                return i;\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 2284712,
                "title": "75-lines-of-code-using-next-permutation",
                "content": "```\\nint nextBeautifulNumber(int n) {\\n        string x=to_string(n);\\n        int len=x.length();\\n        if(len==1 and x!=\"0\")return 22;  \\n        if(len==1 and x==\"0\")return 1;\\n        if(len==2 and x<\"22\")return 22;\\n        if(len==2 and x>=\"22\")return 122;  //small cases done\\n        \\n        if(len<=3){\\n            vector<vector<char>>p={{\\'1\\',\\'2\\',\\'2\\'},{\\'3\\',\\'3\\',\\'3\\'}};\\n            vector<int>posans;\\n            for(int i=0;i<2;i++)\\n            {\\n                do {\\n                   string temp;\\n                    for(int j=0;j<3;j++){temp+=p[i][j];}\\n                    if(stoi(temp)>stoi(x))posans.push_back(stoi(temp)); //making all possible permutations and                                                                                                                 //storing only number greater than n \\n               } while (next_permutation(p[i].begin(),p[i].end()));\\n            }\\n             sort(posans.begin(),posans.end());\\n                if(!posans.empty())return posans[0];                 //sorting and returning smallest one of all possible                                                                                               // answers from vector.\\n        }\\n        \\n        if(len<=4){\\n            vector<int>posans;\\n            vector<vector<char>>p={{\\'1\\',\\'3\\',\\'3\\',\\'3\\'},{\\'4\\',\\'4\\',\\'4\\',\\'4\\'}};\\n            for(int i=0;i<2;i++)\\n            {\\n             string temp;\\n                do {\\n                   string temp;\\n                    for(int j=0;j<4;j++){temp+=p[i][j];}\\n                    if(stoi(temp)>stoi(x))posans.push_back(stoi(temp));\\n               } while (next_permutation(p[i].begin(),p[i].end()));\\n        \\n            }\\n            sort(posans.begin(),posans.end());\\n                if(!posans.empty())return posans[0];\\n        }\\n        \\n        if(len<=5){\\n            vector<int>posans;\\n            vector<vector<char>>p={{\\'1\\',\\'4\\',\\'4\\',\\'4\\',\\'4\\'},{\\'2\\',\\'2\\',\\'3\\',\\'3\\',\\'3\\'},{\\'5\\',\\'5\\',\\'5\\',\\'5\\',\\'5\\'}};\\n            for(int i=0;i<3;i++)\\n            {\\n             string temp;\\n                do {\\n                   string temp;\\n                    for(int j=0;j<5;j++){temp+=p[i][j];}\\n                    if(stoi(temp)>stoi(x))posans.push_back(stoi(temp));\\n               } while (next_permutation(p[i].begin(),p[i].end()));\\n        \\n            }\\n            sort(posans.begin(),posans.end());\\n                if(!posans.empty())return posans[0];\\n        }\\n        \\n        if(len<=6){\\n            vector<int>posans;\\n            vector<vector<char>>p={{\\'1\\',\\'2\\',\\'2\\',\\'3\\',\\'3\\',\\'3\\'},{\\'1\\',\\'5\\',\\'5\\',\\'5\\',\\'5\\',\\'5\\'},{\\'2\\',\\'2\\',\\'4\\',\\'4\\',\\'4\\',\\'4\\'},{\\'6\\',\\'6\\',\\'6\\',\\'6\\',\\'6\\',\\'6\\'}};\\n            for(int i=0;i<4;i++)\\n            {\\n                do {\\n                   string temp;\\n                    for(int j=0;j<6;j++){temp+=p[i][j];}\\n                    if(stoi(temp)>stoi(x))posans.push_back(stoi(temp));\\n               } while (next_permutation(p[i].begin(),p[i].end()));\\n        \\n            }\\n            if(!posans.empty())sort(posans.begin(),posans.end());\\n                if(!posans.empty())return posans[0];\\n        }\\n        \\n        return 1224444;     //returning smallest 7 digit balanced number if 6 digit are not possible(see) contraints\\n    }\\n\\t// Do upvote please.\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "String"
                ],
                "code": "```\\nint nextBeautifulNumber(int n) {\\n        string x=to_string(n);\\n        int len=x.length();\\n        if(len==1 and x!=\"0\")return 22;  \\n        if(len==1 and x==\"0\")return 1;\\n        if(len==2 and x<\"22\")return 22;\\n        if(len==2 and x>=\"22\")return 122;  //small cases done\\n        \\n        if(len<=3){\\n            vector<vector<char>>p={{\\'1\\',\\'2\\',\\'2\\'},{\\'3\\',\\'3\\',\\'3\\'}};\\n            vector<int>posans;\\n            for(int i=0;i<2;i++)\\n            {\\n                do {\\n                   string temp;\\n                    for(int j=0;j<3;j++){temp+=p[i][j];}\\n                    if(stoi(temp)>stoi(x))posans.push_back(stoi(temp)); //making all possible permutations and                                                                                                                 //storing only number greater than n \\n               } while (next_permutation(p[i].begin(),p[i].end()));\\n            }\\n             sort(posans.begin(),posans.end());\\n                if(!posans.empty())return posans[0];                 //sorting and returning smallest one of all possible                                                                                               // answers from vector.\\n        }\\n        \\n        if(len<=4){\\n            vector<int>posans;\\n            vector<vector<char>>p={{\\'1\\',\\'3\\',\\'3\\',\\'3\\'},{\\'4\\',\\'4\\',\\'4\\',\\'4\\'}};\\n            for(int i=0;i<2;i++)\\n            {\\n             string temp;\\n                do {\\n                   string temp;\\n                    for(int j=0;j<4;j++){temp+=p[i][j];}\\n                    if(stoi(temp)>stoi(x))posans.push_back(stoi(temp));\\n               } while (next_permutation(p[i].begin(),p[i].end()));\\n        \\n            }\\n            sort(posans.begin(),posans.end());\\n                if(!posans.empty())return posans[0];\\n        }\\n        \\n        if(len<=5){\\n            vector<int>posans;\\n            vector<vector<char>>p={{\\'1\\',\\'4\\',\\'4\\',\\'4\\',\\'4\\'},{\\'2\\',\\'2\\',\\'3\\',\\'3\\',\\'3\\'},{\\'5\\',\\'5\\',\\'5\\',\\'5\\',\\'5\\'}};\\n            for(int i=0;i<3;i++)\\n            {\\n             string temp;\\n                do {\\n                   string temp;\\n                    for(int j=0;j<5;j++){temp+=p[i][j];}\\n                    if(stoi(temp)>stoi(x))posans.push_back(stoi(temp));\\n               } while (next_permutation(p[i].begin(),p[i].end()));\\n        \\n            }\\n            sort(posans.begin(),posans.end());\\n                if(!posans.empty())return posans[0];\\n        }\\n        \\n        if(len<=6){\\n            vector<int>posans;\\n            vector<vector<char>>p={{\\'1\\',\\'2\\',\\'2\\',\\'3\\',\\'3\\',\\'3\\'},{\\'1\\',\\'5\\',\\'5\\',\\'5\\',\\'5\\',\\'5\\'},{\\'2\\',\\'2\\',\\'4\\',\\'4\\',\\'4\\',\\'4\\'},{\\'6\\',\\'6\\',\\'6\\',\\'6\\',\\'6\\',\\'6\\'}};\\n            for(int i=0;i<4;i++)\\n            {\\n                do {\\n                   string temp;\\n                    for(int j=0;j<6;j++){temp+=p[i][j];}\\n                    if(stoi(temp)>stoi(x))posans.push_back(stoi(temp));\\n               } while (next_permutation(p[i].begin(),p[i].end()));\\n        \\n            }\\n            if(!posans.empty())sort(posans.begin(),posans.end());\\n                if(!posans.empty())return posans[0];\\n        }\\n        \\n        return 1224444;     //returning smallest 7 digit balanced number if 6 digit are not possible(see) contraints\\n    }\\n\\t// Do upvote please.\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2278110,
                "title": "easy-explanation",
                "content": "class Solution {\\npublic:\\n    int nextBeautifulNumber(int n) {\\n        while(true){\\n            n++;\\n            vector<int> v(10,0);\\n            int r=n;      \\n            while(r){\\n                v[r%10]++;\\n                r=r/10;\\n                \\n            }\\n            bool f=true;\\n            for(int i=0;i<10;i++)\\n            {\\n                if(v[i]!=0 && i!=v[i])\\n                {\\n                    f=!f;\\n                    break;\\n                }\\n            }\\n            if(f) return n;\\n        }\\n    }\\n};",
                "solutionTags": [],
                "code": "class Solution {\\npublic:\\n    int nextBeautifulNumber(int n) {\\n        while(true){\\n            n++;\\n            vector<int> v(10,0);\\n            int r=n;      \\n            while(r){\\n                v[r%10]++;\\n                r=r/10;\\n                \\n            }",
                "codeTag": "Java"
            },
            {
                "id": 2268270,
                "title": "backtracking-with-no-hardcoded-answers-constants",
                "content": "This is the ugliest code I\\'ve ever written. \\nEssentially the idea is to track which numbers we\\'ve already used, if the number of digits needed to balance the number is more than the number of digits in the original number, then we can terminate the recursion.\\n\\n```\\nimport copy\\n\\ndef current_digit_greater(num: int, digits: list[int]):\\n    return not digits or num > digits[0]\\n\\ndef num_digits_greater(num: int, digits: list[int]):\\n    return len(digits) == 0 # check adding this number results in more digits\\n\\nclass Solution:\\n    def solve(\\n        self, \\n        digits: int, \\n        nums_freq: dict[int, int], \\n        num_to_balance: int,\\n        greater: bool,\\n        new_greater_func: Callable\\n    ) -> list[int]:\\n        \"\"\"\\n        Calculate the smallest possible balanced number, given that certain numbers\\n        (stored in nums_freq) have already been used a certain number of times\\n        digits: the target number that this number may need to be greater than\\n        greater: whether or not that number is already greater than the target\\n        nums_to_balance: how many more digits are required to balance the number\\n        new_greater_func, a function to check if adding a new digit would result in a greater number\\n        \"\"\"\\n        # Base cases are when the digits or 0, or the number needs to be balanced\\n        # If the number to balancer is more than the number of remaining digits\\n        # and we\\'re already greater, than we can fill out the rest of the number\\n            # if it\\'s not yet greater, we need to do the main loop to solve\\n        if num_to_balance >= len(digits) and greater:\\n            result = []\\n            sorted_digits = sorted(list(nums_freq.items()), key=lambda x: x[0])\\n            for digit, existing_freq in sorted_digits:\\n                freq_to_add = digit - existing_freq\\n                while freq_to_add > 0:\\n                    result.append(digit)\\n                    freq_to_add -= 1\\n            return result\\n        if len(digits) == 0 and greater:\\n            return []\\n            \\n        # Then loop through and try using the smallest possible number\\n        # Need to check all possiblities though, as e.g. 22 is better than 122\\n        # when solving for n = 1\\n        best_result = None\\n        for num in range(1, 10):\\n            # Recurse if this number can be used\\n            digit_count = nums_freq.get(num, 0)\\n            new_greater = greater or new_greater_func(num, digits)\\n            # new greater needs to be a callable, that updates when a smaller digit\\n            # is chosen, to len(digits) == 0 (enforcing an extra digit is added)\\n            if digit_count < num: # and (new_greater or num == digits[0]):\\n                new_to_balance = num_to_balance + (-1 if num in nums_freq else num-1)\\n                new_nums_freq = copy.copy(nums_freq)\\n                new_nums_freq[num] = digit_count + 1\\n                new_new_greater_func = new_greater_func if not digits or num >= digits[0] else num_digits_greater\\n                new_result = [num] + self.solve(digits[1:], new_nums_freq, new_to_balance, new_greater, new_new_greater_func)\\n                \\n                # If the result has fewer digits, replace an earlier result\\n                if best_result is None or len(new_result) < len(best_result):\\n                    best_result = new_result\\n                    \\n                    # If we get a number with num digits == len(digits) we can finish\\n                    if len(new_result) == len(digits):\\n                        return new_result\\n                    # Otherwise run until all combinations have been checked\\n        return best_result\\n    \\n    def nextBeautifulNumber(self, n: int) -> int:\\n        # Convert n to an array of digits\\n        digits = []\\n        while n != 0:\\n            digits.append(n % 10)\\n            n //= 10\\n        digits = list(reversed(digits))\\n        \\n        # Call the solve function\\n        result = self.solve(digits, {}, 0, False, current_digit_greater)\\n        #return self.solve(digits, {3: 1, 2: 1, 1:1}, 4, True)\\n    \\n        # Convert to number\\n        result_int = 0\\n        for digit in result:\\n            result_int *= 10\\n            result_int += digit\\n        return result_int\\n```",
                "solutionTags": [
                    "Python",
                    "Backtracking"
                ],
                "code": "```\\nimport copy\\n\\ndef current_digit_greater(num: int, digits: list[int]):\\n    return not digits or num > digits[0]\\n\\ndef num_digits_greater(num: int, digits: list[int]):\\n    return len(digits) == 0 # check adding this number results in more digits\\n\\nclass Solution:\\n    def solve(\\n        self, \\n        digits: int, \\n        nums_freq: dict[int, int], \\n        num_to_balance: int,\\n        greater: bool,\\n        new_greater_func: Callable\\n    ) -> list[int]:\\n        \"\"\"\\n        Calculate the smallest possible balanced number, given that certain numbers\\n        (stored in nums_freq) have already been used a certain number of times\\n        digits: the target number that this number may need to be greater than\\n        greater: whether or not that number is already greater than the target\\n        nums_to_balance: how many more digits are required to balance the number\\n        new_greater_func, a function to check if adding a new digit would result in a greater number\\n        \"\"\"\\n        # Base cases are when the digits or 0, or the number needs to be balanced\\n        # If the number to balancer is more than the number of remaining digits\\n        # and we\\'re already greater, than we can fill out the rest of the number\\n            # if it\\'s not yet greater, we need to do the main loop to solve\\n        if num_to_balance >= len(digits) and greater:\\n            result = []\\n            sorted_digits = sorted(list(nums_freq.items()), key=lambda x: x[0])\\n            for digit, existing_freq in sorted_digits:\\n                freq_to_add = digit - existing_freq\\n                while freq_to_add > 0:\\n                    result.append(digit)\\n                    freq_to_add -= 1\\n            return result\\n        if len(digits) == 0 and greater:\\n            return []\\n            \\n        # Then loop through and try using the smallest possible number\\n        # Need to check all possiblities though, as e.g. 22 is better than 122\\n        # when solving for n = 1\\n        best_result = None\\n        for num in range(1, 10):\\n            # Recurse if this number can be used\\n            digit_count = nums_freq.get(num, 0)\\n            new_greater = greater or new_greater_func(num, digits)\\n            # new greater needs to be a callable, that updates when a smaller digit\\n            # is chosen, to len(digits) == 0 (enforcing an extra digit is added)\\n            if digit_count < num: # and (new_greater or num == digits[0]):\\n                new_to_balance = num_to_balance + (-1 if num in nums_freq else num-1)\\n                new_nums_freq = copy.copy(nums_freq)\\n                new_nums_freq[num] = digit_count + 1\\n                new_new_greater_func = new_greater_func if not digits or num >= digits[0] else num_digits_greater\\n                new_result = [num] + self.solve(digits[1:], new_nums_freq, new_to_balance, new_greater, new_new_greater_func)\\n                \\n                # If the result has fewer digits, replace an earlier result\\n                if best_result is None or len(new_result) < len(best_result):\\n                    best_result = new_result\\n                    \\n                    # If we get a number with num digits == len(digits) we can finish\\n                    if len(new_result) == len(digits):\\n                        return new_result\\n                    # Otherwise run until all combinations have been checked\\n        return best_result\\n    \\n    def nextBeautifulNumber(self, n: int) -> int:\\n        # Convert n to an array of digits\\n        digits = []\\n        while n != 0:\\n            digits.append(n % 10)\\n            n //= 10\\n        digits = list(reversed(digits))\\n        \\n        # Call the solve function\\n        result = self.solve(digits, {}, 0, False, current_digit_greater)\\n        #return self.solve(digits, {3: 1, 2: 1, 1:1}, 4, True)\\n    \\n        # Convert to number\\n        result_int = 0\\n        for digit in result:\\n            result_int *= 10\\n            result_int += digit\\n        return result_int\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2169866,
                "title": "generate-all-balanced-number-c",
                "content": "```\\nclass Solution {\\n    \\n    vector<int>A;\\n    \\n    void init()\\n    {\\n        for( int b = 1 ; b < 1<<9 ; b++ )\\n        {\\n            string t ;\\n            for( int i = 0 ; i < 9 ; i++ )\\n            {\\n                if(b&(1<<i))\\n                {\\n                    int k = i+1;\\n                    while(k--)\\n                        t += to_string(i+1);\\n                }\\n            }\\n            \\n            if(t.size()>9)\\n                continue;\\n            \\n            sort(t.begin(),t.end());\\n            \\n            do{\\n                A.push_back(stoi(t));\\n            }while(next_permutation(t.begin(),t.end()) );\\n        }\\n    }\\n    \\npublic:\\n    int nextBeautifulNumber(int N ) {\\n        A.clear();\\n        init();\\n        sort(A.begin(),A.end());\\n         return *upper_bound(A.begin(),A.end(),N);\\n      \\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\n    \\n    vector<int>A;\\n    \\n    void init()\\n    {\\n        for( int b = 1 ; b < 1<<9 ; b++ )\\n        {\\n            string t ;\\n            for( int i = 0 ; i < 9 ; i++ )\\n            {\\n                if(b&(1<<i))\\n                {\\n                    int k = i+1;\\n                    while(k--)\\n                        t += to_string(i+1);\\n                }\\n            }\\n            \\n            if(t.size()>9)\\n                continue;\\n            \\n            sort(t.begin(),t.end());\\n            \\n            do{\\n                A.push_back(stoi(t));\\n            }while(next_permutation(t.begin(),t.end()) );\\n        }\\n    }\\n    \\npublic:\\n    int nextBeautifulNumber(int N ) {\\n        A.clear();\\n        init();\\n        sort(A.begin(),A.end());\\n         return *upper_bound(A.begin(),A.end(),N);\\n      \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2116214,
                "title": "c-permuntations",
                "content": "```\\nclass Solution {\\npublic:\\n    int nextBeautifulNumber(int n) {\\n        string allcombinations[] = {\"666666\", \"55555\", \"4444\", \"333\", \"22\", \"224444\",\\n                            \"22333\", \"1\", \"155555\", \"14444\", \"1333\", \"122\", \"122333\",\"1224444\"};\\n        int ans = 10000000;\\n        for(auto s : allcombinations)\\n        {\\n            sort(s.begin(), s.end());\\n            do {\\n                auto tmp = atoi(s.c_str());\\n                if (tmp > n)\\n                    ans = min(ans, tmp);\\n            } while (next_permutation(s.begin(),s.end()));\\n        }\\n        return ans;\\n    }\\n};\\n```\\n",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int nextBeautifulNumber(int n) {\\n        string allcombinations[] = {\"666666\", \"55555\", \"4444\", \"333\", \"22\", \"224444\",\\n                            \"22333\", \"1\", \"155555\", \"14444\", \"1333\", \"122\", \"122333\",\"1224444\"};\\n        int ans = 10000000;\\n        for(auto s : allcombinations)\\n        {\\n            sort(s.begin(), s.end());\\n            do {\\n                auto tmp = atoi(s.c_str());\\n                if (tmp > n)\\n                    ans = min(ans, tmp);\\n            } while (next_permutation(s.begin(),s.end()));\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2052823,
                "title": "golang-brute-force-50ms",
                "content": "```\\nfunc nextBeautifulNumber(n int) int {\\n\\tmss := (10000000)\\n\\tfor i := n + 1; i < mss; i++ {\\n\\t\\tif val(i) {\\n\\t\\t\\treturn i\\n\\t\\t}\\n\\t}\\n\\treturn 0\\n}\\n\\nfunc val(n int) bool {\\n\\tvar c [10]int\\n\\tfor n != 0 {\\n\\t\\tc[n%10]++\\n\\t\\tn = n / 10\\n\\t}\\n\\n\\tfor i := range c {\\n\\t\\tif c[i] != 0 && c[i] != i {\\n\\t\\t\\treturn false\\n\\t\\t}\\n\\t}\\n\\treturn true\\n}\\n\\n```",
                "solutionTags": [],
                "code": "```\\nfunc nextBeautifulNumber(n int) int {\\n\\tmss := (10000000)\\n\\tfor i := n + 1; i < mss; i++ {\\n\\t\\tif val(i) {\\n\\t\\t\\treturn i\\n\\t\\t}\\n\\t}\\n\\treturn 0\\n}\\n\\nfunc val(n int) bool {\\n\\tvar c [10]int\\n\\tfor n != 0 {\\n\\t\\tc[n%10]++\\n\\t\\tn = n / 10\\n\\t}\\n\\n\\tfor i := range c {\\n\\t\\tif c[i] != 0 && c[i] != i {\\n\\t\\t\\treturn false\\n\\t\\t}\\n\\t}\\n\\treturn true\\n}\\n\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2052334,
                "title": "java-brute-force-using-int-array",
                "content": "```\\nclass Solution {\\n      public int nextBeautifulNumber(int n) {\\n        for (int i = n+1; i <= Integer.MAX_VALUE; i++) {\\n           if(countDigits(i))\\n               return i;\\n        }\\n        return 0;\\n    }\\n\\n    private boolean countDigits(int n) {\\n        int countDigits[] = new int[10];\\n        while (n > 0) {\\n            int digit = n % 10;\\n            countDigits[digit]+=1;\\n            if (countDigits[digit] > digit) return false;\\n            n = n / 10;\\n        }\\n        for (int i = 0; i < countDigits.length; i++) {\\n            if (countDigits[i] != 0 && countDigits[i] != i)\\n                return false;\\n        }\\n        return true;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n      public int nextBeautifulNumber(int n) {\\n        for (int i = n+1; i <= Integer.MAX_VALUE; i++) {\\n           if(countDigits(i))\\n               return i;\\n        }\\n        return 0;\\n    }\\n\\n    private boolean countDigits(int n) {\\n        int countDigits[] = new int[10];\\n        while (n > 0) {\\n            int digit = n % 10;\\n            countDigits[digit]+=1;\\n            if (countDigits[digit] > digit) return false;\\n            n = n / 10;\\n        }\\n        for (int i = 0; i < countDigits.length; i++) {\\n            if (countDigits[i] != 0 && countDigits[i] != i)\\n                return false;\\n        }\\n        return true;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2014394,
                "title": "javascript-solution-backtracking",
                "content": "```\\nvar nextBeautifulNumber = function(n) {\\n    const numLen = n.toString().length;\\n    const MAX = Number.MAX_SAFE_INTEGER;\\n    const count = [];\\n    \\n    for (let i = 0; i <= 9; ++i) {\\n        count[i] = i;\\n    }\\n    \\n    let min = MAX;\\n    \\n    backtrack(numLen + 1, 0, count);\\n    \\n    return min;\\n    \\n    \\n    function backtrack(len, num, count) {\\n        if (num > n && isValid(count))  {\\n            min = Math.min(min, num) \\n            return;\\n        }\\n\\n        if (len === 0) return;\\n\\n        for (let dig = 1; dig <= 9; ++dig) {\\n            if (count[dig] > 0 && count[dig] <= len) {\\n                --count[dig];\\n\\n                const res = backtrack(len - 1, (num * 10) + dig, count);\\n\\n                ++count[dig];\\n            }\\n        }\\n\\n    }\\n    \\n    \\n    function isValid(count) {\\n        for (let i = 1; i <= 9; ++i) {\\n            if (count[i] != 0 && count[i] != i) return false;\\n        }\\n        \\n        return true;\\n    }\\n```",
                "solutionTags": [
                    "JavaScript",
                    "Backtracking"
                ],
                "code": "```\\nvar nextBeautifulNumber = function(n) {\\n    const numLen = n.toString().length;\\n    const MAX = Number.MAX_SAFE_INTEGER;\\n    const count = [];\\n    \\n    for (let i = 0; i <= 9; ++i) {\\n        count[i] = i;\\n    }\\n    \\n    let min = MAX;\\n    \\n    backtrack(numLen + 1, 0, count);\\n    \\n    return min;\\n    \\n    \\n    function backtrack(len, num, count) {\\n        if (num > n && isValid(count))  {\\n            min = Math.min(min, num) \\n            return;\\n        }\\n\\n        if (len === 0) return;\\n\\n        for (let dig = 1; dig <= 9; ++dig) {\\n            if (count[dig] > 0 && count[dig] <= len) {\\n                --count[dig];\\n\\n                const res = backtrack(len - 1, (num * 10) + dig, count);\\n\\n                ++count[dig];\\n            }\\n        }\\n\\n    }\\n    \\n    \\n    function isValid(count) {\\n        for (let i = 1; i <= 9; ++i) {\\n            if (count[i] != 0 && count[i] != i) return false;\\n        }\\n        \\n        return true;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1977808,
                "title": "java-combination-permuatation-2ms-96-100",
                "content": "We can try to generate all the possible numbers, but how would we go about doing it effeciently?\\nHere is how:\\n1. First we generate all the possible combination. That is, `{1, 2}` means we pick 1 and 2, and our goal is to make 122, 212, 211.\\n\\n2. Once we pick a combination, we permute the selected numbers.\\n\\n3. We don\\'t actually need the whole list, just return the smallest number found.\\n\\nThis question is basically testing if we know how to do combination and permutation. We can speed it up a bit by only doing permutation when the length chosen is the same length of n or length + 1.\\n\\nAlso, I think you can just bruteforce this too because `n` max is only 1e6. \\n\\n**Java (96% Speed at 2ms || 100% Space at 39 MB)**\\n```Java\\nclass Solution {\\n    public int nextBeautifulNumber(int n) {\\n        int[] arr = new int[]{0, 1, 2, 3, 4, 5, 6};\\n        boolean[] select = new boolean[7];\\n        int d = n == 0? 1 : (int)Math.log10(n) + 1;\\n        return solve(1, n, d, 0, select, arr);\\n    }\\n\\n    private int solve(int i, int n, int d, int sz, boolean[] select, int[] arr){ // Get all combinations\\n        if (sz > d + 1) // Way too large, no need to consider it\\n            return Integer.MAX_VALUE;\\n        if (i == select.length){\\n            return sz >= d? make(0, n, sz, select, arr) : Integer.MAX_VALUE;\\n        }\\n        int ans = solve(i + 1, n, d, sz, select, arr);\\n        select[i] = true;\\n        ans = Math.min(ans, solve(i + 1, n, d, sz + i, select, arr));\\n        select[i] = false;\\n        return ans;\\n    }\\n\\n    private int make(int cur, int n, int end, boolean[] select, int[] arr){ // Get all permutation.\\n        if (end == 0){\\n            return cur > n? cur : Integer.MAX_VALUE;\\n        }\\n\\n        int ans = Integer.MAX_VALUE;\\n        for (int j = 1; j < arr.length; j++){\\n            if (!select[j] || arr[j] == 0)\\n                continue;\\n            --arr[j];\\n            ans = Math.min(make(10 * cur + j, n, end - 1, select, arr), ans);\\n            ++arr[j];\\n        }\\n        return ans;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```Java\\nclass Solution {\\n    public int nextBeautifulNumber(int n) {\\n        int[] arr = new int[]{0, 1, 2, 3, 4, 5, 6};\\n        boolean[] select = new boolean[7];\\n        int d = n == 0? 1 : (int)Math.log10(n) + 1;\\n        return solve(1, n, d, 0, select, arr);\\n    }\\n\\n    private int solve(int i, int n, int d, int sz, boolean[] select, int[] arr){ // Get all combinations\\n        if (sz > d + 1) // Way too large, no need to consider it\\n            return Integer.MAX_VALUE;\\n        if (i == select.length){\\n            return sz >= d? make(0, n, sz, select, arr) : Integer.MAX_VALUE;\\n        }\\n        int ans = solve(i + 1, n, d, sz, select, arr);\\n        select[i] = true;\\n        ans = Math.min(ans, solve(i + 1, n, d, sz + i, select, arr));\\n        select[i] = false;\\n        return ans;\\n    }\\n\\n    private int make(int cur, int n, int end, boolean[] select, int[] arr){ // Get all permutation.\\n        if (end == 0){\\n            return cur > n? cur : Integer.MAX_VALUE;\\n        }\\n\\n        int ans = Integer.MAX_VALUE;\\n        for (int j = 1; j < arr.length; j++){\\n            if (!select[j] || arr[j] == 0)\\n                continue;\\n            --arr[j];\\n            ans = Math.min(make(10 * cur + j, n, end - 1, select, arr), ans);\\n            ++arr[j];\\n        }\\n        return ans;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1920818,
                "title": "worst-question-ever-i-solved-cpp-many-edge-cases-took-to-long-to-crack-the-edge-cases",
                "content": "```\\nclass Solution {\\npublic:\\n    set<int> SS;\\n    void help(string S,int I){\\n        if(I==(S.length()-1)){\\n            SS.insert(stoi(S));\\n            return ;\\n        }\\n        for(int i=I;i<S.length();i++){\\n            swap(S[i],S[I]);\\n            help(S,I+1);\\n            swap(S[i],S[I]);\\n        }\\n    }\\n    int nextBeautifulNumber(int n) {\\n        SS.insert(1);\\n        SS.insert(22);\\n        SS.insert(333);\\n        SS.insert(4444);\\n        SS.insert(55555);\\n        help(\"122\",0);\\n        help(\"1333\",0);\\n        help(\"14444\",0);\\n        help(\"22333\",0);\\n        help(\"155555\",0);\\n        help(\"122333\",0);\\n        help(\"224444\",0);\\n        SS.insert(666666);\\n        for(auto i:SS){\\n            if(n<i) return i;\\n        }\\n        return 1224444;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    set<int> SS;\\n    void help(string S,int I){\\n        if(I==(S.length()-1)){\\n            SS.insert(stoi(S));\\n            return ;\\n        }\\n        for(int i=I;i<S.length();i++){\\n            swap(S[i],S[I]);\\n            help(S,I+1);\\n            swap(S[i],S[I]);\\n        }\\n    }\\n    int nextBeautifulNumber(int n) {\\n        SS.insert(1);\\n        SS.insert(22);\\n        SS.insert(333);\\n        SS.insert(4444);\\n        SS.insert(55555);\\n        help(\"122\",0);\\n        help(\"1333\",0);\\n        help(\"14444\",0);\\n        help(\"22333\",0);\\n        help(\"155555\",0);\\n        help(\"122333\",0);\\n        help(\"224444\",0);\\n        SS.insert(666666);\\n        for(auto i:SS){\\n            if(n<i) return i;\\n        }\\n        return 1224444;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1806037,
                "title": "giving-tle-but-when-i-m-running-in-testcases-it-is-running-fine-can-anyone-optimise-is",
                "content": "class Solution {\\npublic:\\n    int nextBeautifulNumber(int n) {\\n        \\n        if(n==0)\\n            return 1;\\n        int i,l;\\n        int c=0,d=0,e=0;\\n        int x=n+1;\\n        while(c!=1)   \\n        {\\n            d=0,e=0;         \\n            string p=to_string(x);\\n            unordered_map<char,int>m1;\\n            for(i=0;i<p.size();i++)\\n            {\\n                m1[p[i]]++;\\n            }\\n            unordered_map<char,int>::iterator it;\\n            for(it=m1.begin();it!=m1.end();++it)\\n            {\\n                d++;\\n                if((it->first-48)==it->second)\\n                e++;\\n            }\\n            if(e==d)\\n            {\\n                c++;\\n                l=x;\\n                break;\\n            }\\n            m1.clear();          \\n            x++;\\n        }\\n        return l;\\n\\n    }\\n}; \\n",
                "solutionTags": [],
                "code": "class Solution {\\npublic:\\n    int nextBeautifulNumber(int n) {\\n        \\n        if(n==0)\\n            return 1;\\n        int i,l;\\n        int c=0,d=0,e=0;\\n        int x=n+1;\\n        while(c!=1)   \\n        {\\n            d=0,e=0;         \\n            string p=to_string(x);\\n            unordered_map<char,int>m1;\\n            for(i=0;i<p.size();i++)\\n            {\\n                m1[p[i]]++;\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 1783159,
                "title": "java-backtraking-o-9-di-d",
                "content": "Time complexity is O((9-di)^d)\\n1. where di = initial individula digit, for example 835, here possible value for first digit starts with 8 so only 8 and 9 are posible vlue for first digit, and so on.\\n2. d = maximum number of digit, for exaple 324 here d = 3, but for 999 actual d = 4 as we will check numbers that are more than 999.\\n3. each digit posible value is 9 - di\\n\\nSpace Complexity: O(d) where d = digits also map space but is will be constant as only 9 value will be store.\\n\\nPlease let me know what do you think.\\n\\n```\\n\\tprivate int number = 0;\\n    private boolean startFromZero = false;\\n    public int nextBeautifulNumber(int n) {\\n        if(n == 0){\\n            return 1;\\n        }\\n        if(n == 1000000){\\n            return 1224444;\\n        }\\n        List<Integer> list = new ArrayList<>();\\n        Map<Integer, Integer> map = new HashMap<>();\\n        n = n + 1;//Math.pow(10, getLengthOfN(n+1));\\n        backtrack(getLengthOfN(n), n, list, map, String.valueOf(n), 0);\\n        return number;\\n    }\\n    \\n    private void backtrack(int lengthOfDigit, int n, List<Integer> list, Map<Integer, Integer> map, String nStr, int start){\\n        \\n        if(lengthOfDigit == list.size()){\\n            startFromZero = true;\\n            int d = lengthOfDigit - 1;\\n            number = 0;\\n            for(int i: list){\\n                number += i * (Math.pow(10, d--));\\n                if(map.get(i) != i){\\n                    number = 0;\\n                    break;\\n                }\\n            }\\n            return;\\n        }\\n        \\n        if(start >= nStr.length()){\\n            return;\\n        }\\n\\n        for(int i = startFromZero ? 0 : (int) nStr.charAt(start) - \\'0\\'; i <= 9 ; i++){\\n            if(map.getOrDefault(i, 0) < i){\\n                list.add(i);\\n                map.put(i, map.getOrDefault(i, 0) + 1);\\n                backtrack(lengthOfDigit, n, list, map, nStr, start + 1);\\n                if(number != 0 || n > Math.pow(10, 6)){\\n                    break;\\n                }\\n                list.remove(list.size() - 1);\\n                map.put(i, map.get(i) - 1);    \\n\\n                if(start == 0 && i == 9){\\n                    n = (int)Math.pow(10, lengthOfDigit);\\n                    nStr = String.valueOf(n);\\n                    i = 0;\\n                    lengthOfDigit = nStr.length();\\n                }\\n                \\n            }else{\\n                startFromZero = true;\\n            }\\n            \\n            \\n        }\\n    }\\n    \\n    private int getLengthOfN(int n){\\n        int length = 0;\\n        while(n != 0){\\n            length++;\\n            n = n / 10;\\n        }\\n        return length;\\n    }\\n    \\n```",
                "solutionTags": [
                    "Java",
                    "Backtracking"
                ],
                "code": "```\\n\\tprivate int number = 0;\\n    private boolean startFromZero = false;\\n    public int nextBeautifulNumber(int n) {\\n        if(n == 0){\\n            return 1;\\n        }\\n        if(n == 1000000){\\n            return 1224444;\\n        }\\n        List<Integer> list = new ArrayList<>();\\n        Map<Integer, Integer> map = new HashMap<>();\\n        n = n + 1;//Math.pow(10, getLengthOfN(n+1));\\n        backtrack(getLengthOfN(n), n, list, map, String.valueOf(n), 0);\\n        return number;\\n    }\\n    \\n    private void backtrack(int lengthOfDigit, int n, List<Integer> list, Map<Integer, Integer> map, String nStr, int start){\\n        \\n        if(lengthOfDigit == list.size()){\\n            startFromZero = true;\\n            int d = lengthOfDigit - 1;\\n            number = 0;\\n            for(int i: list){\\n                number += i * (Math.pow(10, d--));\\n                if(map.get(i) != i){\\n                    number = 0;\\n                    break;\\n                }\\n            }\\n            return;\\n        }\\n        \\n        if(start >= nStr.length()){\\n            return;\\n        }\\n\\n        for(int i = startFromZero ? 0 : (int) nStr.charAt(start) - \\'0\\'; i <= 9 ; i++){\\n            if(map.getOrDefault(i, 0) < i){\\n                list.add(i);\\n                map.put(i, map.getOrDefault(i, 0) + 1);\\n                backtrack(lengthOfDigit, n, list, map, nStr, start + 1);\\n                if(number != 0 || n > Math.pow(10, 6)){\\n                    break;\\n                }\\n                list.remove(list.size() - 1);\\n                map.put(i, map.get(i) - 1);    \\n\\n                if(start == 0 && i == 9){\\n                    n = (int)Math.pow(10, lengthOfDigit);\\n                    nStr = String.valueOf(n);\\n                    i = 0;\\n                    lengthOfDigit = nStr.length();\\n                }\\n                \\n            }else{\\n                startFromZero = true;\\n            }\\n            \\n            \\n        }\\n    }\\n    \\n    private int getLengthOfN(int n){\\n        int length = 0;\\n        while(n != 0){\\n            length++;\\n            n = n / 10;\\n        }\\n        return length;\\n    }\\n    \\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1760433,
                "title": "golang-brute",
                "content": "```\\nfunc nextBeautifulNumber(n int) int {\\n    list := []int{0, 1, 2, 3, 4, 5, 6}\\n    var res []int\\n    for i := 0; i < len(list); i++ {\\n        a := 1\\n        if i == 0 {\\n            a = 0\\n        }\\n        for j := i + a; j < len(list); j++ {\\n            for k := j + 1; k < len(list); k++ {\\n                if i + j + k <= 6 {\\n                    dfs(i, i, j, j, k, k, 0, &res)\\n                }\\n            }\\n        }\\n    }\\n    sort.Ints(res)\\n\\tres = append(res, 1224444)\\n    return res[sort.Search(len(res), func(i int) bool {\\n        return res[i] > n\\n    })]\\n}\\n\\nfunc dfs(a int, x int, b int, y int, c int, z int, cur int, res *[]int) {\\n    if x == 0 && y == 0 && z == 0 {\\n        *res = append(*res, cur)\\n    }\\n    \\n    if x > 0 {\\n        dfs(a, x - 1, b, y, c, z, cur * 10 + a, res)\\n    }\\n    if y > 0 {\\n        dfs(a, x, b, y - 1, c, z, cur * 10 + b, res)\\n    }\\n    if z > 0 {\\n        dfs(a, x, b, y, c, z - 1, cur * 10 + c, res)\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nfunc nextBeautifulNumber(n int) int {\\n    list := []int{0, 1, 2, 3, 4, 5, 6}\\n    var res []int\\n    for i := 0; i < len(list); i++ {\\n        a := 1\\n        if i == 0 {\\n            a = 0\\n        }\\n        for j := i + a; j < len(list); j++ {\\n            for k := j + 1; k < len(list); k++ {\\n                if i + j + k <= 6 {\\n                    dfs(i, i, j, j, k, k, 0, &res)\\n                }\\n            }\\n        }\\n    }\\n    sort.Ints(res)\\n\\tres = append(res, 1224444)\\n    return res[sort.Search(len(res), func(i int) bool {\\n        return res[i] > n\\n    })]\\n}\\n\\nfunc dfs(a int, x int, b int, y int, c int, z int, cur int, res *[]int) {\\n    if x == 0 && y == 0 && z == 0 {\\n        *res = append(*res, cur)\\n    }\\n    \\n    if x > 0 {\\n        dfs(a, x - 1, b, y, c, z, cur * 10 + a, res)\\n    }\\n    if y > 0 {\\n        dfs(a, x, b, y - 1, c, z, cur * 10 + b, res)\\n    }\\n    if z > 0 {\\n        dfs(a, x, b, y, c, z - 1, cur * 10 + c, res)\\n    }\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1736391,
                "title": "python3-brute-force-solution",
                "content": "```\\nclass Solution:\\n    def nextBeautifulNumber(self, n: int) -> int:\\n        from collections import Counter\\n        \\n        for val in range(n+1,1224445):\\n            \\n            counter=Counter(str(val))\\n            if all(counter[ch]==int(ch) for ch in str(val)):\\n                return val\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def nextBeautifulNumber(self, n: int) -> int:\\n        from collections import Counter\\n        \\n        for val in range(n+1,1224445):\\n            \\n            counter=Counter(str(val))\\n            if all(counter[ch]==int(ch) for ch in str(val)):\\n                return val\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1708134,
                "title": "python-3-binary-search-with-pre-calculation",
                "content": "\\n```\\n    def nextBeautifulNumber(self, n: int) -> int:\\n        \\n        listN = [1, 22, 122, 212, 221, 333, 1333, 3133, 3313, 3331, 4444, 14444, 22333, 23233, 23323, 23332, 32233, 32323, 32332, 33223, 33232, 33322, 41444, 44144, 44414, 44441, 55555, 122333, 123233, 123323, 123332, 132233, 132323, 132332, 133223, 133232, 133322, 155555, 212333, 213233, 213323, 213332, 221333, 223133, 223313, 223331, 224444, 231233, 231323, 231332, 232133, 232313, 232331, 233123, 233132, 233213, 233231, 233312, 233321, 242444, 244244, 244424, 244442, 312233, 312323, 312332, 313223, 313232, 313322, 321233, 321323, 321332, 322133, 322313, 322331, 323123, 323132, 323213, 323231, 323312, 323321, 331223, 331232, 331322, 332123, 332132, 332213, 332231, 332312, 332321, 333122, 333212, 333221, 422444, 424244, 424424, 424442, 442244, 442424, 442442, 444224, 444242, 444422, 515555, 551555, 555155, 555515, 555551, 666666, 1224444]\\n        \\n        l,r = 0,len(listN)\\n        while l<r:\\n            ind = (l+r)//2\\n            if listN[ind]<=n:           l = ind+1\\n            else:                       r = ind\\n        return listN[l]\\n```",
                "solutionTags": [],
                "code": "```\\n    def nextBeautifulNumber(self, n: int) -> int:\\n        \\n        listN = [1, 22, 122, 212, 221, 333, 1333, 3133, 3313, 3331, 4444, 14444, 22333, 23233, 23323, 23332, 32233, 32323, 32332, 33223, 33232, 33322, 41444, 44144, 44414, 44441, 55555, 122333, 123233, 123323, 123332, 132233, 132323, 132332, 133223, 133232, 133322, 155555, 212333, 213233, 213323, 213332, 221333, 223133, 223313, 223331, 224444, 231233, 231323, 231332, 232133, 232313, 232331, 233123, 233132, 233213, 233231, 233312, 233321, 242444, 244244, 244424, 244442, 312233, 312323, 312332, 313223, 313232, 313322, 321233, 321323, 321332, 322133, 322313, 322331, 323123, 323132, 323213, 323231, 323312, 323321, 331223, 331232, 331322, 332123, 332132, 332213, 332231, 332312, 332321, 333122, 333212, 333221, 422444, 424244, 424424, 424442, 442244, 442424, 442442, 444224, 444242, 444422, 515555, 551555, 555155, 555515, 555551, 666666, 1224444]\\n        \\n        l,r = 0,len(listN)\\n        while l<r:\\n            ind = (l+r)//2\\n            if listN[ind]<=n:           l = ind+1\\n            else:                       r = ind\\n        return listN[l]\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 1672942,
                "title": "golang-simple-solution",
                "content": "```\\nfunc nextBeautifulNumber(n int) int {    \\n    i:= n+1\\n    for true{\\n        if isBeatiful(i){\\n            return i\\n        }\\n        i++\\n    }\\n    return -1\\n}\\n\\nfunc isBeatiful(a int) bool{\\n    arr:= make([]int, 10)\\n    for a >= 1{\\n        pop:= a % 10\\n        arr[pop]++\\n        a = a / 10\\n    }        \\n    if arr[0] != 0{\\n        return false\\n    }\\n    for i:= 0; i < 10; i++{\\n        if arr[i] != 0 && arr[i] != i{\\n            return false\\n        }\\n    }\\n    return true\\n}\\n```",
                "solutionTags": [
                    "Go"
                ],
                "code": "```\\nfunc nextBeautifulNumber(n int) int {    \\n    i:= n+1\\n    for true{\\n        if isBeatiful(i){\\n            return i\\n        }\\n        i++\\n    }\\n    return -1\\n}\\n\\nfunc isBeatiful(a int) bool{\\n    arr:= make([]int, 10)\\n    for a >= 1{\\n        pop:= a % 10\\n        arr[pop]++\\n        a = a / 10\\n    }        \\n    if arr[0] != 0{\\n        return false\\n    }\\n    for i:= 0; i < 10; i++{\\n        if arr[i] != 0 && arr[i] != i{\\n            return false\\n        }\\n    }\\n    return true\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1665062,
                "title": "c-bf-solution-100ms",
                "content": "After trying multiple more sophisticated approaches I figured out the best solution here is Brute Force\\n```\\npublic class Solution {\\n    public int NextBeautifulNumber(int n) {\\n        for(int i=n+1; i<10_000_000; i++)\\n            if(IsBeauty(i))\\n                return i;\\n        return -1;\\n    }\\n    \\n    private bool IsBeauty(int n)\\n    {\\n        var digits = new int[10];\\n        while(n > 0)\\n        {\\n            var mod = n % 10;\\n            if(mod == 0)\\n                return false;\\n            digits[mod]++;\\n            n /= 10;\\n        }\\n        \\n        for(int j=1; j<10; j++)\\n            if(digits[j] != 0 && digits[j] != j)\\n                return false;\\n\\n        return true;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\npublic class Solution {\\n    public int NextBeautifulNumber(int n) {\\n        for(int i=n+1; i<10_000_000; i++)\\n            if(IsBeauty(i))\\n                return i;\\n        return -1;\\n    }\\n    \\n    private bool IsBeauty(int n)\\n    {\\n        var digits = new int[10];\\n        while(n > 0)\\n        {\\n            var mod = n % 10;\\n            if(mod == 0)\\n                return false;\\n            digits[mod]++;\\n            n /= 10;\\n        }\\n        \\n        for(int j=1; j<10; j++)\\n            if(digits[j] != 0 && digits[j] != j)\\n                return false;\\n\\n        return true;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1643316,
                "title": "java-brute-force-approach-using-hashmap",
                "content": "```\\nclass Solution {\\n    public int nextBeautifulNumber(int n) {\\n        int ans=0;\\n        for(int i=n+1;i<=1224444;i++){\\n            if(isGood(i)){\\n                return i;\\n            }\\n        }\\n        return 0;\\n    }\\n    public static boolean isGood(int n){\\n        String s=Integer.toString(n);\\n        HashMap<Character,Integer> map=new HashMap<>();\\n        for(int i=0;i<s.length();i++){\\n            map.put(s.charAt(i),map.getOrDefault(s.charAt(i),0)+1);\\n        }\\n        for(char a:map.keySet()){\\n            int b=map.get(a);\\n            int c=Character.getNumericValue(a);\\n            if(b!=c){\\n                return false;\\n            }\\n        }\\n        return true;\\n    }\\n}",
                "solutionTags": [
                    "Java"
                ],
                "code": "class Solution {\\n    public int nextBeautifulNumber(int n) {\\n        int ans=0;\\n        for(int i=n+1;i<=1224444;i++){\\n            if(isGood(i)){\\n                return i;\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 1629352,
                "title": "java-pre-populated-list-of-balanced-numbers",
                "content": "```\\npublic class Solution {\\n    public int nextBeautifulNumber(int n) {\\n        Set<String> b = Set.of(\\n                \"1\",\\n                \"22\",\\n                \"122\",\\n                \"333\",\\n                \"1333\",\\n                \"4444\",\\n                \"14444\",\\n                \"22333\",\\n                \"55555\",\\n                \"122333\",\\n                \"155555\",\\n\\t\\t\\t\\t\"224444\",\\n                \"666666\",\\n                \"1224444\"\\n        );\\n\\n        for (int i = n + 1; i <= 1224444; i++) {\\n            char[] c = String.valueOf(i).toCharArray();\\n            Arrays.sort(c);\\n            if (b.contains(new String(c))) {\\n                return i;\\n            }\\n        }\\n        throw new IllegalArgumentException(\"not found balanced number\");\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\npublic class Solution {\\n    public int nextBeautifulNumber(int n) {\\n        Set<String> b = Set.of(\\n                \"1\",\\n                \"22\",\\n                \"122\",\\n                \"333\",\\n                \"1333\",\\n                \"4444\",\\n                \"14444\",\\n                \"22333\",\\n                \"55555\",\\n                \"122333\",\\n                \"155555\",\\n\\t\\t\\t\\t\"224444\",\\n                \"666666\",\\n                \"1224444\"\\n        );\\n\\n        for (int i = n + 1; i <= 1224444; i++) {\\n            char[] c = String.valueOf(i).toCharArray();\\n            Arrays.sort(c);\\n            if (b.contains(new String(c))) {\\n                return i;\\n            }\\n        }\\n        throw new IllegalArgumentException(\"not found balanced number\");\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1627454,
                "title": "python-calculate-all-beauty-numbers-of-any-length-99",
                "content": "```\\nimport itertools\\n\\nclass Solution:\\n    nums = []\\n    def nextBeautifulNumber(self, n: int) -> int:\\n        N = 6\\n        combinations = set()\\n        def calCombinations(cur: List[int]) -> None:\\n            numbers = []\\n            # Update with all combinations\\n            for num in cur:\\n                numbers.extend([str(num)]*num)\\n            if len(numbers) > N:\\n                return\\n            combinations.update(itertools.permutations(numbers))\\n            \\n        cur = []\\n        def findAllBeautifulNumber(i: int) -> None:\\n            if i == N:\\n                return\\n            # Select the current number.\\n            cur.append(i+1)\\n            calCombinations(cur)\\n            findAllBeautifulNumber(i+1)\\n            # Do not select the current number, nothing changed, no need to re-calculate\\n            cur.pop()\\n            findAllBeautifulNumber(i+1)\\n            \\n        if not Solution.nums:\\n            findAllBeautifulNumber(0)\\n            Solution.nums = [int(\\'\\'.join(comb)) for comb in combinations]\\n            Solution.nums.sort()\\n            Solution.nums.append(1224444)\\n        return Solution.nums[bisect.bisect_right(Solution.nums, n)]\\n```",
                "solutionTags": [],
                "code": "```\\nimport itertools\\n\\nclass Solution:\\n    nums = []\\n    def nextBeautifulNumber(self, n: int) -> int:\\n        N = 6\\n        combinations = set()\\n        def calCombinations(cur: List[int]) -> None:\\n            numbers = []\\n            # Update with all combinations\\n            for num in cur:\\n                numbers.extend([str(num)]*num)\\n            if len(numbers) > N:\\n                return\\n            combinations.update(itertools.permutations(numbers))\\n            \\n        cur = []\\n        def findAllBeautifulNumber(i: int) -> None:\\n            if i == N:\\n                return\\n            # Select the current number.\\n            cur.append(i+1)\\n            calCombinations(cur)\\n            findAllBeautifulNumber(i+1)\\n            # Do not select the current number, nothing changed, no need to re-calculate\\n            cur.pop()\\n            findAllBeautifulNumber(i+1)\\n            \\n        if not Solution.nums:\\n            findAllBeautifulNumber(0)\\n            Solution.nums = [int(\\'\\'.join(comb)) for comb in combinations]\\n            Solution.nums.sort()\\n            Solution.nums.append(1224444)\\n        return Solution.nums[bisect.bisect_right(Solution.nums, n)]\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1605021,
                "title": "why-it-is-showing-tle-please-anyone-could-help",
                "content": "```\\nclass Solution {\\n    public int nextBeautifulNumber(int n) {\\n        \\n        \\n        while(true)\\n        {\\n            n++;\\n            if(isBeautifulNumber(n))\\n            {\\n                return n;\\n            }\\n        }\\n        \\n        \\n    }\\n    \\n    \\n    \\n      public static boolean isBeautifulNumber(int n)\\n        {\\n            \\n            int[] freq=new int[10];\\n            \\n            while(n>0)\\n            {\\n            int lastDigit=n%10;\\n                \\n                \\n                if(lastDigit==0) return false;\\n                \\n                freq[lastDigit]++;\\n                n=n/10;\\n            }\\n            \\n            \\n            for(int i=1; i<=9; i++)\\n            {\\n                if(freq[i]!=i)\\n                    return false;\\n            }\\n            \\n            return true;\\n        }\\n        \\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int nextBeautifulNumber(int n) {\\n        \\n        \\n        while(true)\\n        {\\n            n++;\\n            if(isBeautifulNumber(n))\\n            {\\n                return n;\\n            }\\n        }\\n        \\n        \\n    }\\n    \\n    \\n    \\n      public static boolean isBeautifulNumber(int n)\\n        {\\n            \\n            int[] freq=new int[10];\\n            \\n            while(n>0)\\n            {\\n            int lastDigit=n%10;\\n                \\n                \\n                if(lastDigit==0) return false;\\n                \\n                freq[lastDigit]++;\\n                n=n/10;\\n            }\\n            \\n            \\n            for(int i=1; i<=9; i++)\\n            {\\n                if(freq[i]!=i)\\n                    return false;\\n            }\\n            \\n            return true;\\n        }\\n        \\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1588655,
                "title": "python-dp-recursion-no-pre-calc-100-programming-3",
                "content": "```\\nclass Solution(object):\\n    \\n    def __init__(self):\\n        # global variable ans\\n        self.ans = 999999999\\n    \\n    def permutations(self, curr, s, n):\\n        # if permutation is created\\n        if(len(s) == 0):\\n            curr_num = int(curr) # cast permutation (curr) into integer\\n            \\n            if(curr_num > n):\\n                self.ans = min(self.ans, curr_num) # choose minimum from possible permutations\\n        \\n        # permutation creation starts from here (before s is not empty)\\n        for i in range(len(s)):\\n            # put s[i] in curr and take s[i] out of s\\n            self.permutations(curr + s[i], s[:i] + s[i + 1:], n)\\n    \\n    def nextBeautifulNumber(self, n):\\n        \"\"\"\\n        :type n: int\\n        :rtype: int\\n        \"\"\"\\n        dp = [(0,)]\\n        l = len(str(n)) # length of n\\n        \\n        # generate possible digit combinations in tuples from 1 to l + 1\\n        for i in range(1, l + 2):\\n            for j in range(len(dp)):\\n                if i + sum(dp[j]) <= l + 1:\\n                    dp.append((i,) + dp[j])\\n        \\n        # choose combinations only for l and l + 1\\n        filtered_combinations = filter(lambda el: sum(el) == l or sum(el) == l + 1, dp)\\n                    \\n        for i in filtered_combinations:\\n            s = \"\"\\n            \\n            # generate initial permutation for current tuple (i) \\n            for j in (sorted(i)[1:]):\\n                for _ in range(j):\\n                    s+=str(j)\\n                    \\n            if sum(i) == l:\\n                self.permutations(\"\",s,n) # generate other possible permutations\\n            else:\\n                self.ans = min(self.ans, int(s)) # initial permutation for l + 1 is lowest so we don\\'t need to check other combinations\\n        \\n        return self.ans\\n```",
                "solutionTags": [
                    "Python",
                    "Dynamic Programming",
                    "Recursion"
                ],
                "code": "```\\nclass Solution(object):\\n    \\n    def __init__(self):\\n        # global variable ans\\n        self.ans = 999999999\\n    \\n    def permutations(self, curr, s, n):\\n        # if permutation is created\\n        if(len(s) == 0):\\n            curr_num = int(curr) # cast permutation (curr) into integer\\n            \\n            if(curr_num > n):\\n                self.ans = min(self.ans, curr_num) # choose minimum from possible permutations\\n        \\n        # permutation creation starts from here (before s is not empty)\\n        for i in range(len(s)):\\n            # put s[i] in curr and take s[i] out of s\\n            self.permutations(curr + s[i], s[:i] + s[i + 1:], n)\\n    \\n    def nextBeautifulNumber(self, n):\\n        \"\"\"\\n        :type n: int\\n        :rtype: int\\n        \"\"\"\\n        dp = [(0,)]\\n        l = len(str(n)) # length of n\\n        \\n        # generate possible digit combinations in tuples from 1 to l + 1\\n        for i in range(1, l + 2):\\n            for j in range(len(dp)):\\n                if i + sum(dp[j]) <= l + 1:\\n                    dp.append((i,) + dp[j])\\n        \\n        # choose combinations only for l and l + 1\\n        filtered_combinations = filter(lambda el: sum(el) == l or sum(el) == l + 1, dp)\\n                    \\n        for i in filtered_combinations:\\n            s = \"\"\\n            \\n            # generate initial permutation for current tuple (i) \\n            for j in (sorted(i)[1:]):\\n                for _ in range(j):\\n                    s+=str(j)\\n                    \\n            if sum(i) == l:\\n                self.permutations(\"\",s,n) # generate other possible permutations\\n            else:\\n                self.ans = min(self.ans, int(s)) # initial permutation for l + 1 is lowest so we don\\'t need to check other combinations\\n        \\n        return self.ans\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1588249,
                "title": "python-unique-perms-cached-99-time",
                "content": "![image](https://assets.leetcode.com/users/images/3f9e6918-b778-4319-a97a-f52e18fd240f_1637418483.7067416.png)\\n\\nSort of cheating:\\n\\n```\\nclass Solution:\\n    cache = []\\n    \\n    def nextBeautifulNumber(self, n: int) -> int:\\n        if not Solution.cache:\\n            st = set([1, 22, 333, 4444, 55555, 666666, 1224444])\\n            for x in list(permutations([\\'1\\', \\'2\\', \\'2\\'])):\\n                st.add(int(\"\".join(x)))\\n            for x in list(permutations([\\'1\\', \\'3\\', \\'3\\', \\'3\\'])):\\n                st.add(int(\"\".join(x)))\\n            for x in list(permutations([\\'2\\', \\'2\\', \\'3\\', \\'3\\', \\'3\\'])):\\n                st.add(int(\"\".join(x)))\\n            for x in list(permutations([\\'1\\', \\'4\\', \\'4\\', \\'4\\', \\'4\\'])):\\n                st.add(int(\"\".join(x)))\\n            for x in list(permutations([\\'1\\', \\'2\\', \\'2\\', \\'3\\', \\'3\\', \\'3\\'])):\\n                st.add(int(\"\".join(x)))\\n            for x in list(permutations([\\'2\\', \\'2\\', \\'4\\', \\'4\\', \\'4\\', \\'4\\'])):\\n                st.add(int(\"\".join(x)))\\n            for x in list(permutations([\\'1\\', \\'5\\', \\'5\\', \\'5\\', \\'5\\', \\'5\\'])):\\n                st.add(int(\"\".join(x)))\\n            Solution.cache = sorted(list(st))\\n\\n        return Solution.cache[bisect_right(Solution.cache, n)]\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    cache = []\\n    \\n    def nextBeautifulNumber(self, n: int) -> int:\\n        if not Solution.cache:\\n            st = set([1, 22, 333, 4444, 55555, 666666, 1224444])\\n            for x in list(permutations([\\'1\\', \\'2\\', \\'2\\'])):\\n                st.add(int(\"\".join(x)))\\n            for x in list(permutations([\\'1\\', \\'3\\', \\'3\\', \\'3\\'])):\\n                st.add(int(\"\".join(x)))\\n            for x in list(permutations([\\'2\\', \\'2\\', \\'3\\', \\'3\\', \\'3\\'])):\\n                st.add(int(\"\".join(x)))\\n            for x in list(permutations([\\'1\\', \\'4\\', \\'4\\', \\'4\\', \\'4\\'])):\\n                st.add(int(\"\".join(x)))\\n            for x in list(permutations([\\'1\\', \\'2\\', \\'2\\', \\'3\\', \\'3\\', \\'3\\'])):\\n                st.add(int(\"\".join(x)))\\n            for x in list(permutations([\\'2\\', \\'2\\', \\'4\\', \\'4\\', \\'4\\', \\'4\\'])):\\n                st.add(int(\"\".join(x)))\\n            for x in list(permutations([\\'1\\', \\'5\\', \\'5\\', \\'5\\', \\'5\\', \\'5\\'])):\\n                st.add(int(\"\".join(x)))\\n            Solution.cache = sorted(list(st))\\n\\n        return Solution.cache[bisect_right(Solution.cache, n)]\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1556037,
                "title": "c-28ms-precalc",
                "content": "This problem just begs to precalculate the sequence. I doubt it is the goal of the problem writer.\\n\\n```\\npublic class Solution {\\n    \\n    static int[] preCalcBalanced = new int[]{\\n        1, 22, 122, 212, 221, 333, 1333, 3133, 3313, 3331, 4444, 14444, 22333, 23233, 23323, 23332, 32233, 32323, 32332, 33223, 33232, 33322,\\n\\t\\t41444, 44144, 44414, 44441, 55555, 122333, 123233, 123323, 123332, 132233, 132323, 132332, 133223, 133232, 133322, 155555,\\n\\t\\t212333, 213233, 213323, 213332, 221333, 223133, 223313, 223331, 224444, 231233, 231323, 231332, 232133, 232313, 232331, 233123,\\n\\t\\t233132, 233213, 233231, 233312, 233321, 242444, 244244, 244424, 244442, 312233, 312323, 312332, 313223, 313232, 313322, 321233,\\n\\t\\t321323, 321332, 322133, 322313, 322331, 323123, 323132, 323213, 323231, 323312, 323321, 331223, 331232, 331322, 332123, 332132,\\n\\t\\t332213, 332231, 332312, 332321, 333122, 333212, 333221, 422444, 424244, 424424, 424442, 442244, 442424, 442442, 444224, 444242,\\n\\t\\t444422, 515555, 551555, 555155, 555515, 555551, 666666, 1224444 };\\n    \\n    public int NextBeautifulNumber(int n) {\\n        \\n        int index = Array.BinarySearch(preCalcBalanced, n+1);\\n        if( index < 0) index = ~index;\\n        return preCalcBalanced[index];\\n\\n    }\\n\\n}\\n```\\n\\n",
                "solutionTags": [],
                "code": "```\\npublic class Solution {\\n    \\n    static int[] preCalcBalanced = new int[]{\\n        1, 22, 122, 212, 221, 333, 1333, 3133, 3313, 3331, 4444, 14444, 22333, 23233, 23323, 23332, 32233, 32323, 32332, 33223, 33232, 33322,\\n\\t\\t41444, 44144, 44414, 44441, 55555, 122333, 123233, 123323, 123332, 132233, 132323, 132332, 133223, 133232, 133322, 155555,\\n\\t\\t212333, 213233, 213323, 213332, 221333, 223133, 223313, 223331, 224444, 231233, 231323, 231332, 232133, 232313, 232331, 233123,\\n\\t\\t233132, 233213, 233231, 233312, 233321, 242444, 244244, 244424, 244442, 312233, 312323, 312332, 313223, 313232, 313322, 321233,\\n\\t\\t321323, 321332, 322133, 322313, 322331, 323123, 323132, 323213, 323231, 323312, 323321, 331223, 331232, 331322, 332123, 332132,\\n\\t\\t332213, 332231, 332312, 332321, 333122, 333212, 333221, 422444, 424244, 424424, 424442, 442244, 442424, 442442, 444224, 444242,\\n\\t\\t444422, 515555, 551555, 555155, 555515, 555551, 666666, 1224444 };\\n    \\n    public int NextBeautifulNumber(int n) {\\n        \\n        int index = Array.BinarySearch(preCalcBalanced, n+1);\\n        if( index < 0) index = ~index;\\n        return preCalcBalanced[index];\\n\\n    }\\n\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1553094,
                "title": "a-crazy-answer-beats-both-100-just-pre-print-all-potential-answers",
                "content": "```scala\\n\\n  def nextBeautifulNumber(n: Int): Int = {\\n    val len = n.toString().length\\n\\n    val answer = Array(\\n      Array(0),\\n      Array(1),\\n      Array(22),\\n      Array(122, 212, 221, 333),\\n      Array(1333, 3133, 3313, 3331, 4444),\\n      Array(14444, 22333, 23233, 23323, 23332, 32233, 32323, 32332, 33223, 33232, 33322, 41444,\\n        44144, 44414, 44441, 55555),\\n      Array(122333, 123233, 123323, 123332, 132233, 132323, 132332, 133223, 133232, 133322, 155555,\\n        212333, 213233, 213323, 213332, 221333, 223133, 223313, 223331, 224444, 231233, 231323,\\n        231332, 232133, 232313, 232331, 233123, 233132, 233213, 233231, 233312, 233321, 242444,\\n        244244, 244424, 244442, 312233, 312323, 312332, 313223, 313232, 313322, 321233, 321323,\\n        321332, 322133, 322313, 322331, 323123, 323132, 323213, 323231, 323312, 323321, 331223,\\n        331232, 331322, 332123, 332132, 332213, 332231, 332312, 332321, 333122, 333212, 333221,\\n        422444, 424244, 424424, 424442, 442244, 442424, 442442, 444224, 444242, 444422, 515555,\\n        551555, 555155, 555515, 555551, 666666),\\n      Array(1224444, 1242444, 1244244, 1244424, 1244442, 1422444, 1424244, 1424424, 1424442,\\n        1442244, 1442424, 1442442, 1444224, 1444242, 1444422, 1666666, 2124444, 2142444, 2144244,\\n        2144424, 2144442, 2214444, 2241444, 2244144, 2244414, 2244441, 2255555, 2412444, 2414244,\\n        2414424, 2414442, 2421444, 2424144, 2424414, 2424441, 2441244, 2441424, 2441442, 2442144,\\n        2442414, 2442441, 2444124, 2444142, 2444214, 2444241, 2444412, 2444421, 2525555, 2552555,\\n        2555255, 2555525, 2555552, 3334444, 3343444, 3344344, 3344434, 3344443, 3433444, 3434344,\\n        3434434, 3434443, 3443344, 3443434, 3443443, 3444334, 3444343, 3444433, 4122444, 4124244,\\n        4124424, 4124442, 4142244, 4142424, 4142442, 4144224, 4144242, 4144422, 4212444, 4214244,\\n        4214424, 4214442, 4221444, 4224144, 4224414, 4224441, 4241244, 4241424, 4241442, 4242144,\\n        4242414, 4242441, 4244124, 4244142, 4244214, 4244241, 4244412, 4244421, 4333444, 4334344,\\n        4334434, 4334443, 4343344, 4343434, 4343443, 4344334, 4344343, 4344433, 4412244, 4412424,\\n        4412442, 4414224, 4414242, 4414422, 4421244, 4421424, 4421442, 4422144, 4422414, 4422441,\\n        4424124, 4424142, 4424214, 4424241, 4424412, 4424421, 4433344, 4433434, 4433443, 4434334,\\n        4434343, 4434433, 4441224, 4441242, 4441422, 4442124, 4442142, 4442214, 4442241, 4442412,\\n        4442421, 4443334, 4443343, 4443433, 4444122, 4444212, 4444221, 4444333, 5225555, 5252555,\\n        5255255, 5255525, 5255552, 5522555, 5525255, 5525525, 5525552, 5552255, 5552525, 5552552,\\n        5555225, 5555252, 5555522, 6166666, 6616666, 6661666, 6666166, 6666616, 6666661)\\n    )\\n\\n    answer(len).foreach(x => if (x > n) return x)\\n    Array(0, 1, 22, 122, 1333, 14444, 122333, 1224444)(len + 1)\\n  }\\n\\n```",
                "solutionTags": [],
                "code": "```scala\\n\\n  def nextBeautifulNumber(n: Int): Int = {\\n    val len = n.toString().length\\n\\n    val answer = Array(\\n      Array(0),\\n      Array(1),\\n      Array(22),\\n      Array(122, 212, 221, 333),\\n      Array(1333, 3133, 3313, 3331, 4444),\\n      Array(14444, 22333, 23233, 23323, 23332, 32233, 32323, 32332, 33223, 33232, 33322, 41444,\\n        44144, 44414, 44441, 55555),\\n      Array(122333, 123233, 123323, 123332, 132233, 132323, 132332, 133223, 133232, 133322, 155555,\\n        212333, 213233, 213323, 213332, 221333, 223133, 223313, 223331, 224444, 231233, 231323,\\n        231332, 232133, 232313, 232331, 233123, 233132, 233213, 233231, 233312, 233321, 242444,\\n        244244, 244424, 244442, 312233, 312323, 312332, 313223, 313232, 313322, 321233, 321323,\\n        321332, 322133, 322313, 322331, 323123, 323132, 323213, 323231, 323312, 323321, 331223,\\n        331232, 331322, 332123, 332132, 332213, 332231, 332312, 332321, 333122, 333212, 333221,\\n        422444, 424244, 424424, 424442, 442244, 442424, 442442, 444224, 444242, 444422, 515555,\\n        551555, 555155, 555515, 555551, 666666),\\n      Array(1224444, 1242444, 1244244, 1244424, 1244442, 1422444, 1424244, 1424424, 1424442,\\n        1442244, 1442424, 1442442, 1444224, 1444242, 1444422, 1666666, 2124444, 2142444, 2144244,\\n        2144424, 2144442, 2214444, 2241444, 2244144, 2244414, 2244441, 2255555, 2412444, 2414244,\\n        2414424, 2414442, 2421444, 2424144, 2424414, 2424441, 2441244, 2441424, 2441442, 2442144,\\n        2442414, 2442441, 2444124, 2444142, 2444214, 2444241, 2444412, 2444421, 2525555, 2552555,\\n        2555255, 2555525, 2555552, 3334444, 3343444, 3344344, 3344434, 3344443, 3433444, 3434344,\\n        3434434, 3434443, 3443344, 3443434, 3443443, 3444334, 3444343, 3444433, 4122444, 4124244,\\n        4124424, 4124442, 4142244, 4142424, 4142442, 4144224, 4144242, 4144422, 4212444, 4214244,\\n        4214424, 4214442, 4221444, 4224144, 4224414, 4224441, 4241244, 4241424, 4241442, 4242144,\\n        4242414, 4242441, 4244124, 4244142, 4244214, 4244241, 4244412, 4244421, 4333444, 4334344,\\n        4334434, 4334443, 4343344, 4343434, 4343443, 4344334, 4344343, 4344433, 4412244, 4412424,\\n        4412442, 4414224, 4414242, 4414422, 4421244, 4421424, 4421442, 4422144, 4422414, 4422441,\\n        4424124, 4424142, 4424214, 4424241, 4424412, 4424421, 4433344, 4433434, 4433443, 4434334,\\n        4434343, 4434433, 4441224, 4441242, 4441422, 4442124, 4442142, 4442214, 4442241, 4442412,\\n        4442421, 4443334, 4443343, 4443433, 4444122, 4444212, 4444221, 4444333, 5225555, 5252555,\\n        5255255, 5255525, 5255552, 5522555, 5525255, 5525525, 5525552, 5552255, 5552525, 5552552,\\n        5555225, 5555252, 5555522, 6166666, 6616666, 6661666, 6666166, 6666616, 6666661)\\n    )\\n\\n    answer(len).foreach(x => if (x > n) return x)\\n    Array(0, 1, 22, 122, 1333, 14444, 122333, 1224444)(len + 1)\\n  }\\n\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 1548393,
                "title": "python-using-backtracking-works-for-any-n-beats-98",
                "content": "A little bit long but faster than 98% of the submissions. \\nThe idea is to cut the backtracking tree as early as possible.\\n\\n```\\nclass Solution:\\n    def nextBeautifulNumber(self, n: int) -> int:\\n        number = [int(d) for d in str(n)]\\n        must = dict(zip(range(1,10),[-1]*10))\\n        res = self.temp(number, must, shouldBeGreater = True)      \\n        if res == -1:\\n            res = self.temp([0] + number, must, shouldBeGreater = False)\\n        if res!= -1:\\n            res = int(\"\".join([str(x) for x in res]))         \\n        return res\\t\\t\\n    def temp(self, number, must, shouldBeGreater):        \\n        # base \\n        if len(number) == 0:\\n            if shouldBeGreater or sum(x for x in must.values() if x>0) > 0:\\n                return -1\\n            else: \\n                return list()\\n                \\n        # check must\\n        if sum(x for x in must.values() if x>0) > len(number):\\n            return -1\\n        \\n        # try all the possible digits\\n        for digit in range(1,10):                       \\n            if shouldBeGreater and digit < number[0]:\\n                continue\\n            if must[digit] == 0:\\n                continue\\n                \\n            # digit is selected    \\n            savedCnt = must[digit]\\n            if must[digit] == -1:\\n                must[digit] = digit-1 \\n            else:\\n                must[digit] -= 1\\n                \\n            # call temp\\n            if digit == number[0]:\\n                res = self.temp(number[1:], must, shouldBeGreater)\\n            else:\\n                res = self.temp(number[1:], must, shouldBeGreater = False)\\n            \\n            # use res\\n            if res == -1:\\n                must[digit] = savedCnt\\n                continue\\n            else:\\n                must[digit] = savedCnt\\n                return [digit] + res\\n        return -1\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def nextBeautifulNumber(self, n: int) -> int:\\n        number = [int(d) for d in str(n)]\\n        must = dict(zip(range(1,10),[-1]*10))\\n        res = self.temp(number, must, shouldBeGreater = True)      \\n        if res == -1:\\n            res = self.temp([0] + number, must, shouldBeGreater = False)\\n        if res!= -1:\\n            res = int(\"\".join([str(x) for x in res]))         \\n        return res\\t\\t\\n    def temp(self, number, must, shouldBeGreater):        \\n        # base \\n        if len(number) == 0:\\n            if shouldBeGreater or sum(x for x in must.values() if x>0) > 0:\\n                return -1\\n            else: \\n                return list()\\n                \\n        # check must\\n        if sum(x for x in must.values() if x>0) > len(number):\\n            return -1\\n        \\n        # try all the possible digits\\n        for digit in range(1,10):                       \\n            if shouldBeGreater and digit < number[0]:\\n                continue\\n            if must[digit] == 0:\\n                continue\\n                \\n            # digit is selected    \\n            savedCnt = must[digit]\\n            if must[digit] == -1:\\n                must[digit] = digit-1 \\n            else:\\n                must[digit] -= 1\\n                \\n            # call temp\\n            if digit == number[0]:\\n                res = self.temp(number[1:], must, shouldBeGreater)\\n            else:\\n                res = self.temp(number[1:], must, shouldBeGreater = False)\\n            \\n            # use res\\n            if res == -1:\\n                must[digit] = savedCnt\\n                continue\\n            else:\\n                must[digit] = savedCnt\\n                return [digit] + res\\n        return -1\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1548038,
                "title": "python-simple-brute-force-solution",
                "content": "```python\\nclass Solution:\\n    def nextBeautifulNumber(self, n: int) -> int:\\n\\n        def count(n):\\n            cnt = [0]*10\\n            while n:\\n                cnt[n%10] += 1\\n                n //= 10\\n            return cnt\\n        \\n        def valid(cnt):\\n            for i, c in enumerate(cnt):\\n                if c > 0 and c != i:\\n                    return False\\n            return True\\n\\n        x = n+1\\n        while True:\\n            cnt = count(x)\\n            if valid(cnt):\\n                return x\\n            x += 1\\n        \\n```",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```python\\nclass Solution:\\n    def nextBeautifulNumber(self, n: int) -> int:\\n\\n        def count(n):\\n            cnt = [0]*10\\n            while n:\\n                cnt[n%10] += 1\\n                n //= 10\\n            return cnt\\n        \\n        def valid(cnt):\\n            for i, c in enumerate(cnt):\\n                if c > 0 and c != i:\\n                    return False\\n            return True\\n\\n        x = n+1\\n        while True:\\n            cnt = count(x)\\n            if valid(cnt):\\n                return x\\n            x += 1\\n        \\n```",
                "codeTag": "Java"
            },
            {
                "id": 1546546,
                "title": "find-all-possible-balanced-numbers-then-find-n-s-position",
                "content": "Too lazy to manually list all balanced numbers, so I wrote a function to help me finish this lol. Here is my rough code.\\n```\\ndef nextBeautifulNumber(self, n: int) -> int:\\n        all_number = set()\\n        all_poss = [\"1\", \"22\", \"122\", \"333\", \"1333\", \"4444\", \"14444\", \"22333\", \"55555\", \"155555\", \"122333\", \"224444\", \"666666\"]\\n        def find_all(num_dict, pre):\\n            if max(num_dict.values()) == 0: \\n                [all_number.add(p) for p in pre]\\n            for k, v in num_dict.items():\\n                if v > 0:\\n                    num_dict[k] -= 1\\n                    temp = set()\\n                    for p in pre:\\n                        temp.add(p + k)\\n                    find_all(num_dict, temp)\\n                    num_dict[k] += 1\\n        for poss in all_poss:\\n            find_all(collections.Counter(poss), [\"\"])\\n        all_number.add(\"1224444\") # this is the smallest 7-digit number\\n        all_number = sorted([int(i) for i in all_number])\\n\\n        left, right = 0, len(all_number) - 1\\n        while left < right:\\n            mid = left + (right - left) // 2\\n            if all_number[mid] <= n:\\n                left = mid + 1\\n            if all_number[mid] > n:\\n                right = mid\\n        return all_number[left]\\n```",
                "solutionTags": [],
                "code": "```\\ndef nextBeautifulNumber(self, n: int) -> int:\\n        all_number = set()\\n        all_poss = [\"1\", \"22\", \"122\", \"333\", \"1333\", \"4444\", \"14444\", \"22333\", \"55555\", \"155555\", \"122333\", \"224444\", \"666666\"]\\n        def find_all(num_dict, pre):\\n            if max(num_dict.values()) == 0: \\n                [all_number.add(p) for p in pre]\\n            for k, v in num_dict.items():\\n                if v > 0:\\n                    num_dict[k] -= 1\\n                    temp = set()\\n                    for p in pre:\\n                        temp.add(p + k)\\n                    find_all(num_dict, temp)\\n                    num_dict[k] += 1\\n        for poss in all_poss:\\n            find_all(collections.Counter(poss), [\"\"])\\n        all_number.add(\"1224444\") # this is the smallest 7-digit number\\n        all_number = sorted([int(i) for i in all_number])\\n\\n        left, right = 0, len(all_number) - 1\\n        while left < right:\\n            mid = left + (right - left) // 2\\n            if all_number[mid] <= n:\\n                left = mid + 1\\n            if all_number[mid] > n:\\n                right = mid\\n        return all_number[left]\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 1545696,
                "title": "python3-prune",
                "content": "```python\\nclass Solution:\\n    def nextBeautifulNumber(self, n: int) -> int:\\n        for x in range(n + 1, 1224444 + 1):\\n            if any(d in str(x) for d in \\'0789\\'): continue\\n            c = Counter(str(x))\\n            if all(c[x] == int(x) for x in c): return x\\n```",
                "solutionTags": [],
                "code": "```python\\nclass Solution:\\n    def nextBeautifulNumber(self, n: int) -> int:\\n        for x in range(n + 1, 1224444 + 1):\\n            if any(d in str(x) for d in \\'0789\\'): continue\\n            c = Counter(str(x))\\n            if all(c[x] == int(x) for x in c): return x\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1544899,
                "title": "c-easy-to-understand-with-proper-explanation",
                "content": "class Solution {\\npublic:\\n    \\n   /*\\n   \\nvector<string>result;\\nset<string>st;\\n\\nvoid func(string ans,int idx){\\n    \\n    if(ans.length()>6 || idx>7){\\n        return;\\n    }\\n    \\n    if(ans.length()<=6){\\n        \\n        if(st.find(ans)==st.end()){\\n            result.push_back(ans);\\n            st.insert(ans);\\n        }\\n        \\n    }\\n    \\n   \\n        int val=idx;\\n        \\n        string temp=\"\";\\n        \\n        while(val--){\\n            temp+=to_string(idx);\\n        }\\n        \\n    func(ans+temp,idx+1);\\n    \\n    func(ans,idx+1);\\n    \\n}\\n\\n\\n */\\n    \\n    \\n    int nextBeautifulNumber(int n) {\\n        \\n        // We can also create these numbers recursively as mentioned above.....\\n        \\n        vector<int>base={1,22,122,333,1333,4444,14444,22333,55555,122333,155555,224444,666666};\\n        \\n        // cout<<base.size()<<endl;\\n        \\n        int res=1224444;\\n        \\n        string s=to_string(n);\\n        \\n        for(int nn:base){\\n            \\n            string ss=to_string(nn);\\n            \\n            if(ss.length()<s.length()){\\n                continue;\\n            }\\n            \\n            else if(ss.length()>s.length()){\\n                int val=stoi(ss);\\n                res=min(res,val);\\n                break;\\n            }\\n            \\n            // If length of both the strings are equal.\\n            \\n            else{\\n                \\n                do{\\n                    \\n                    if(ss>s){\\n                        int val=stoi(ss);\\n                        res=min(res,val);\\n                        break;\\n                    }\\n                    \\n                }while(next_permutation(ss.begin(),ss.end()));\\n                \\n                \\n            }\\n            \\n            \\n        }\\n        \\n        // next_permutation stl Application for more clearity......\\n        \\n//         vector<int>nums={1,3,4,2};\\n//         int range=5;\\n        \\n//         do{\\n            \\n//             cout<<nums[0]<<\" \"<<nums[1]<<\" \"<<nums[2]<<\" \"<<nums[3]<<endl;\\n//             range--;\\n            \\n//         }while(range>0 && next_permutation(nums.begin(),nums.end()));\\n        \\n        \\n        \\n        return res;\\n        \\n    }\\n};",
                "solutionTags": [],
                "code": "class Solution {\\npublic:\\n    \\n   /*\\n   \\nvector<string>result;\\nset<string>st;\\n\\nvoid func(string ans,int idx){\\n    \\n    if(ans.length()>6 || idx>7){\\n        return;\\n    }",
                "codeTag": "Java"
            },
            {
                "id": 1543278,
                "title": "python3-combinations-permutation",
                "content": "Find the length of the given num. Generate combination of numbers that add to length of number\\n\\n5 -> (1, 4), (2, 3), (5, 0), generate the necessary number and its corresponding permutations.\\n\\n(1, 4, 4, 4, 4), (2, 2, 3, 3, 3) (2, 3, 2, 3, 3)......\\n\\n```\\nclass Solution:\\n    def nextBeautifulNumber(self, num: int) -> int:\\n        n = len(str(num))\\n\\n        def gen_nums(m):\\n            st = set()\\n            num_lst = list(range(1, m + 1))\\n            for c in range(len(num_lst) + 1):\\n                for combs in combinations(num_lst, c + 1):\\n                    if sum(combs) == m:\\n                        s = \"\".join(str(e) * e for e in combs)\\n                        for p in set(permutations(s)):\\n                            st.add(int(\"\".join(p)))\\n            return st\\n\\n        res = sorted((gen_nums(n) | gen_nums(n + 1)) - {num})\\n        return res[bisect_left(res, num)]\\n\\t\\t\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def nextBeautifulNumber(self, num: int) -> int:\\n        n = len(str(num))\\n\\n        def gen_nums(m):\\n            st = set()\\n            num_lst = list(range(1, m + 1))\\n            for c in range(len(num_lst) + 1):\\n                for combs in combinations(num_lst, c + 1):\\n                    if sum(combs) == m:\\n                        s = \"\".join(str(e) * e for e in combs)\\n                        for p in set(permutations(s)):\\n                            st.add(int(\"\".join(p)))\\n            return st\\n\\n        res = sorted((gen_nums(n) | gen_nums(n + 1)) - {num})\\n        return res[bisect_left(res, num)]\\n\\t\\t\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1543026,
                "title": "begin-from-all-possible-combinations-and-calculate-all-permutations",
                "content": "```\\nclass Solution {\\npublic:\\n    Solution() {\\n        primitives.emplace_back(\"1\");\\n        primitives.emplace_back(\"22\");\\n        primitives.emplace_back(\"122\");\\n        primitives.emplace_back(\"333\");\\n        primitives.emplace_back(\"1333\");\\n        primitives.emplace_back(\"4444\");\\n        primitives.emplace_back(\"14444\");\\n        primitives.emplace_back(\"22333\");\\n        primitives.emplace_back(\"55555\");\\n        primitives.emplace_back(\"122333\");\\n        primitives.emplace_back(\"155555\");\\n        primitives.emplace_back(\"224444\");\\n        primitives.emplace_back(\"666666\");\\n        primitives.emplace_back(\"1666666\");\\n        primitives.emplace_back(\"1224444\");\\n        primitives.emplace_back(\"2255555\");\\n        primitives.emplace_back(\"3334444\");\\n        primitives.emplace_back(\"7777777\");\\n    }\\n    int nextBeautifulNumber(int n) {\\n        vector<int> candidates;\\n        for (string& num : primitives) {\\n            do {\\n                candidates.emplace_back(getNum(num));\\n            } while (next_permutation(begin(num), end(num)));\\n        }\\n        sort(begin(candidates), end(candidates));\\n        return *upper_bound(begin(candidates), end(candidates), n);\\n    }\\nprivate:\\n    int getNum(string s) {\\n        int ans = 0;\\n        for (char c : s) {\\n            ans = ans * 10 + (c - \\'0\\');\\n        }\\n        return ans;\\n    }\\n    vector<string> primitives;\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    Solution() {\\n        primitives.emplace_back(\"1\");\\n        primitives.emplace_back(\"22\");\\n        primitives.emplace_back(\"122\");\\n        primitives.emplace_back(\"333\");\\n        primitives.emplace_back(\"1333\");\\n        primitives.emplace_back(\"4444\");\\n        primitives.emplace_back(\"14444\");\\n        primitives.emplace_back(\"22333\");\\n        primitives.emplace_back(\"55555\");\\n        primitives.emplace_back(\"122333\");\\n        primitives.emplace_back(\"155555\");\\n        primitives.emplace_back(\"224444\");\\n        primitives.emplace_back(\"666666\");\\n        primitives.emplace_back(\"1666666\");\\n        primitives.emplace_back(\"1224444\");\\n        primitives.emplace_back(\"2255555\");\\n        primitives.emplace_back(\"3334444\");\\n        primitives.emplace_back(\"7777777\");\\n    }\\n    int nextBeautifulNumber(int n) {\\n        vector<int> candidates;\\n        for (string& num : primitives) {\\n            do {\\n                candidates.emplace_back(getNum(num));\\n            } while (next_permutation(begin(num), end(num)));\\n        }\\n        sort(begin(candidates), end(candidates));\\n        return *upper_bound(begin(candidates), end(candidates), n);\\n    }\\nprivate:\\n    int getNum(string s) {\\n        int ans = 0;\\n        for (char c : s) {\\n            ans = ans * 10 + (c - \\'0\\');\\n        }\\n        return ans;\\n    }\\n    vector<string> primitives;\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1542697,
                "title": "2048-next-greater-numerically-balanced-number",
                "content": "---\\n\\nWeekly Contest 264\\n\\n- Q1 answer\\n  - https://leetcode.com/problems/number-of-valid-words-in-a-sentence/discuss/1542727/2047-number-of-valid-words-in-a-sentence\\n- Q2 answer\\n  - ( below answer )\\n    - One of the difficult programs, lot of edge cases.\\n      - Took 3 days to solve this simple looking question. All trials below.\\n\\n---\\n\\n- Day 4 answer:\\n  - The secret is in the question constrainsts `0 <= n <= 10^6`\\n    - The number is not that big so we can bruteforce run from 1 to a litte over 10 ^ 6  (`1,224,444`)\\n\\n---\\n\\nHope it is simple to understand.\\n\\n---\\n\\n```\\nvar nextBeautifulNumber = function (n) {\\n\\n    let ASC_PATTERNS = [\\n        \\'1\\', //\\n        \\'22\\',\\n        \\'333\\',\\n        \\'4444\\',\\n        \\'55555\\',\\n        \\'666666\\',                            //          needed ans for 666,665 is 666,666\\n        // \\'7777777\\',                        //      not needed ans for max n = 10^6 is 1,224,444\\n        // \\'88888888\\',\\n        // \\'999999999\\',\\n    ];\\n\\n    for (let i = n + 1; i <= 1224444; i++) {                            // need > n and 1,224,444 is smallest number that is greater than largest n (10^6)\\n        let i_str = \\'\\' + i;\\n        if (i_str.indexOf(\\'0\\') !== -1) continue;                        // i has zero, its not the answer, continue with next i\\n\\n        let i_str_ascending = i_str.split(\\'\\').sort().join(\\'\\') + \\'\\';     // i in ascending order to group digits - 212 becomes 122\\n\\n        for (let patt of ASC_PATTERNS) {\\n            i_str_ascending = i_str_ascending.replace(patt, \\'\\');        // delete all matching patterns\\n\\n            if (!i_str_ascending) return i;                             // is empty after removing patterns - found the answer\\n        }\\n    }\\n};\\n```\\n\\n---\\n\\nFail trials, if you are interested:\\n\\n---\\n\\n<details>\\n\\n<summary>Fail trial 1 / Day 1 - From contest</summary>\\n\\n```\\nvar nextBeautifulNumber = function (n) {\\n    n = BigInt(n);\\n\\n    let nLen = (\\'\\' + n).length;\\n\\n    let a = [\\n        \\'1\\', //\\n        \\'22\\',\\n        \\'333\\',\\n        \\'4444\\',\\n        \\'55555\\',\\n        \\'666666\\',\\n        \\'7777777\\',\\n        \\'88888888\\',\\n        \\'999999999\\',\\n    ];\\n    let nnn = a.length;\\n\\n    let final_need = [];\\n    let min_len_need = Infinity;\\n    for (let i = nnn - 1; i >= 0; i--) {\\n        let need = [];\\n\\n\\n        let l = a[i].length;\\n        if (l >= nLen) {\\n            if (l <= min_len_need && a[i] > n) {\\n                min_len_need = l;\\n                need = [a[i]];\\n                final_need = need;\\n                continue;\\n            }\\n        }\\n\\n        need = [a[i]];\\n\\n\\n        let l2 = 0;\\n        let need2 = [];\\n        for (let j = 0; j < i; j++) {\\n            l2 += a[j].length;\\n            need2.push(a[j]);\\n\\n            let lSummedUp = l + l2;\\n            if (lSummedUp >= nLen) {\\n                if (lSummedUp <= min_len_need) {\\n                    min_len_need = lSummedUp;\\n                    need = [...need, ...need2];\\n\\n                    {\\n                        let final_need2 = need.join(\\'\\');\\n\\n                        let final2_needBig = BigInt(final_need2);\\n                        if (final2_needBig > n) {\\n                            final_need = need;\\n                        }\\n                    }\\n                }\\n            }\\n            if (lSummedUp > min_len_need) {\\n                break;\\n            }\\n        }\\n    }\\n\\n\\n    final_need.sort();\\n    final_need = final_need.join(\\'\\');\\n\\n    let final_needBig = BigInt(final_need);\\n    if (final_needBig > n) {\\n        return Number(final_needBig);\\n    }\\n\\n    let aaaa = final_need.split(\\'\\');\\n    for (let i = 0; i < aaaa.length; i++) {\\n        for (let j = i; j + 1 < aaaa.length - i; j++) {\\n            [aaaa[j], aaaa[j + 1]] = [aaaa[j + 1], aaaa[j]];\\n\\n            {\\n                let final_need = aaaa.join(\\'\\');\\n\\n                let final_needBig = BigInt(final_need);\\n                if (final_needBig > n) {\\n                    return Number(final_needBig);\\n                }\\n            }\\n        }\\n    }\\n};\\n\\n```\\n\\n</details>\\n\\n---\\n\\n<details>\\n\\n<summary>Fail trial 2 / Day 2 </summary>\\n\\n```\\nvar nextBeautifulNumber = function (n) {\\n    n = BigInt(n);\\n\\n    let nLen = (\\'\\' + n).length;\\n\\n    let a = [\\n        \\'1\\', //\\n        \\'22\\',\\n        \\'333\\',\\n        \\'4444\\',\\n        \\'55555\\',\\n        \\'666666\\',\\n        \\'7777777\\',\\n        \\'88888888\\',\\n        \\'999999999\\',\\n    ];\\n    let nnn = a.length;\\n\\n    let smallest_final_needBig___final_final = Infinity;\\n\\n    let final_need = [];\\n    let min_len_need = Infinity;\\n    for (let i = nnn - 1; i >= 0; i--) {\\n        let need = [];\\n\\n\\n        let l = a[i].length;\\n        if (l >= nLen) {\\n            if (l <= min_len_need && a[i] > n) {\\n                min_len_need = l;\\n                need = [a[i]];\\n                final_need = need;\\n\\n                continue;\\n            }\\n        }\\n\\n        for (let k = 0; k < i; k++) {\\n            need = [a[i]];\\n\\n            let l2 = 0;\\n            let need2 = [];\\n            for (let j = k; j < i; j++) {\\n                l2 += a[j].length;\\n                need2.push(a[j]);\\n\\n                let lSummedUp = l + l2;\\n                if (lSummedUp >= nLen) {\\n                    if (lSummedUp <= min_len_need) {\\n                        min_len_need = lSummedUp;\\n                        need = [...need, ...need2];\\n\\n                        {\\n                            let final2_needBig = BigInt(need.join(\\'\\'));\\n                            if (final2_needBig > n && final2_needBig < smallest_final_needBig___final_final) {\\n                                final_need = need;\\n                                if (1) {\\n                                    smallest_final_needBig___final_final = final2_needBig;\\n                                }\\n                            }\\n                        }\\n                    }\\n                }\\n                if (lSummedUp > min_len_need) {\\n                    break;\\n                }\\n            }\\n        }\\n    }\\n\\n\\n    final_need.sort();\\n    final_need = final_need.join(\\'\\');\\n\\n    let final_needBig = BigInt(final_need);\\n    if (final_needBig > n) {\\n        return Number(final_needBig);\\n    }\\n\\n    let aaaa = final_need.split(\\'\\');\\n    for (let i = 0; i < aaaa.length; i++) {\\n        for (let j = i; j + 1 < aaaa.length - i; j++) {\\n            [aaaa[j], aaaa[j + 1]] = [aaaa[j + 1], aaaa[j]];\\n\\n            {\\n                let final_needBig = BigInt(aaaa.join(\\'\\'));\\n                if (final_needBig > n) {\\n                    return Number(final_needBig);\\n                }\\n            }\\n        }\\n    }\\n};\\n```\\n\\n</details>\\n\\n---\\n\\n<details>\\n\\n<summary>Fail trial 3 / Day 3 </summary>\\n\\n```\\nvar nextBeautifulNumber = function (n) {\\n\\n    let A = [\\n        \\'1\\', //\\n        \\'22\\',\\n        \\'333\\',\\n        \\'4444\\',\\n        \\'55555\\',\\n        \\'666666\\',\\n        \\'7777777\\',\\n        \\'88888888\\',\\n        \\'999999999\\',\\n    ];\\n\\n    let ans = [];\\n    const bt = (start, a) => {\\n        if (start >= A.length) {\\n            return;\\n        }\\n\\n        if (a.join(\\'\\').length >= (n + \\'\\').length) {\\n            ans.push(a.join(\\'\\'));\\n            return;\\n        }\\n\\n        bt(start + 1, [...a, A[start]]);\\n        bt(start + 1, [...a]);\\n    };\\n\\n    bt(0, []);\\n    ans.sort((a, b) => a.length - b.length || a.localeCompare(b));\\n\\n    let nnnnn = n + \\'\\';\\n\\n    for (let kk = 0; kk < ans.length; kk++) {\\n        let s = ans[kk];\\n        let a = s.split(\\'\\');\\n\\n        {\\n            let good = [];\\n\\n            for (let i = 0; i < a.length; i++) {\\n                let x = a.join(\\'\\');\\n                    \\' .. \\',\\n                    a.join(\\'\\'), //\\n                    x.length > nnnnn.length,\\n                    x.localeCompare(nnnnn) > 0\\n                );\\n\\n                if (x.length > nnnnn.length || x.localeCompare(nnnnn) > 0) {\\n                    if (kk + 1 < ans.length) {\\n                        let x2 = ans[kk + 1];\\n\\n                        if (x.length < x2.length || x.localeCompare(x2) < 0) {\\n                            good.push(x);\\n                        }\\n                    } else {\\n                        good.push(x);\\n                    }\\n                }\\n\\n                a = [...a.slice(1), a[0]];\\n            }\\n\\n            if (good.length) {\\n                let ans = good;\\n                ans.sort((a, b) => a.length - b.length || a.localeCompare(b));\\n                return +ans[0];\\n            }\\n        }\\n    }\\n\\n    return \\'\\';\\n};\\n```\\n\\n</details>\\n\\n---\\n\\n",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\nvar nextBeautifulNumber = function (n) {\\n\\n    let ASC_PATTERNS = [\\n        \\'1\\', //\\n        \\'22\\',\\n        \\'333\\',\\n        \\'4444\\',\\n        \\'55555\\',\\n        \\'666666\\',                            //          needed ans for 666,665 is 666,666\\n        // \\'7777777\\',                        //      not needed ans for max n = 10^6 is 1,224,444\\n        // \\'88888888\\',\\n        // \\'999999999\\',\\n    ];\\n\\n    for (let i = n + 1; i <= 1224444; i++) {                            // need > n and 1,224,444 is smallest number that is greater than largest n (10^6)\\n        let i_str = \\'\\' + i;\\n        if (i_str.indexOf(\\'0\\') !== -1) continue;                        // i has zero, its not the answer, continue with next i\\n\\n        let i_str_ascending = i_str.split(\\'\\').sort().join(\\'\\') + \\'\\';     // i in ascending order to group digits - 212 becomes 122\\n\\n        for (let patt of ASC_PATTERNS) {\\n            i_str_ascending = i_str_ascending.replace(patt, \\'\\');        // delete all matching patterns\\n\\n            if (!i_str_ascending) return i;                             // is empty after removing patterns - found the answer\\n        }\\n    }\\n};\\n```\n```\\nvar nextBeautifulNumber = function (n) {\\n    n = BigInt(n);\\n\\n    let nLen = (\\'\\' + n).length;\\n\\n    let a = [\\n        \\'1\\', //\\n        \\'22\\',\\n        \\'333\\',\\n        \\'4444\\',\\n        \\'55555\\',\\n        \\'666666\\',\\n        \\'7777777\\',\\n        \\'88888888\\',\\n        \\'999999999\\',\\n    ];\\n    let nnn = a.length;\\n\\n    let final_need = [];\\n    let min_len_need = Infinity;\\n    for (let i = nnn - 1; i >= 0; i--) {\\n        let need = [];\\n\\n\\n        let l = a[i].length;\\n        if (l >= nLen) {\\n            if (l <= min_len_need && a[i] > n) {\\n                min_len_need = l;\\n                need = [a[i]];\\n                final_need = need;\\n                continue;\\n            }\\n        }\\n\\n        need = [a[i]];\\n\\n\\n        let l2 = 0;\\n        let need2 = [];\\n        for (let j = 0; j < i; j++) {\\n            l2 += a[j].length;\\n            need2.push(a[j]);\\n\\n            let lSummedUp = l + l2;\\n            if (lSummedUp >= nLen) {\\n                if (lSummedUp <= min_len_need) {\\n                    min_len_need = lSummedUp;\\n                    need = [...need, ...need2];\\n\\n                    {\\n                        let final_need2 = need.join(\\'\\');\\n\\n                        let final2_needBig = BigInt(final_need2);\\n                        if (final2_needBig > n) {\\n                            final_need = need;\\n                        }\\n                    }\\n                }\\n            }\\n            if (lSummedUp > min_len_need) {\\n                break;\\n            }\\n        }\\n    }\\n\\n\\n    final_need.sort();\\n    final_need = final_need.join(\\'\\');\\n\\n    let final_needBig = BigInt(final_need);\\n    if (final_needBig > n) {\\n        return Number(final_needBig);\\n    }\\n\\n    let aaaa = final_need.split(\\'\\');\\n    for (let i = 0; i < aaaa.length; i++) {\\n        for (let j = i; j + 1 < aaaa.length - i; j++) {\\n            [aaaa[j], aaaa[j + 1]] = [aaaa[j + 1], aaaa[j]];\\n\\n            {\\n                let final_need = aaaa.join(\\'\\');\\n\\n                let final_needBig = BigInt(final_need);\\n                if (final_needBig > n) {\\n                    return Number(final_needBig);\\n                }\\n            }\\n        }\\n    }\\n};\\n\\n```\n```\\nvar nextBeautifulNumber = function (n) {\\n    n = BigInt(n);\\n\\n    let nLen = (\\'\\' + n).length;\\n\\n    let a = [\\n        \\'1\\', //\\n        \\'22\\',\\n        \\'333\\',\\n        \\'4444\\',\\n        \\'55555\\',\\n        \\'666666\\',\\n        \\'7777777\\',\\n        \\'88888888\\',\\n        \\'999999999\\',\\n    ];\\n    let nnn = a.length;\\n\\n    let smallest_final_needBig___final_final = Infinity;\\n\\n    let final_need = [];\\n    let min_len_need = Infinity;\\n    for (let i = nnn - 1; i >= 0; i--) {\\n        let need = [];\\n\\n\\n        let l = a[i].length;\\n        if (l >= nLen) {\\n            if (l <= min_len_need && a[i] > n) {\\n                min_len_need = l;\\n                need = [a[i]];\\n                final_need = need;\\n\\n                continue;\\n            }\\n        }\\n\\n        for (let k = 0; k < i; k++) {\\n            need = [a[i]];\\n\\n            let l2 = 0;\\n            let need2 = [];\\n            for (let j = k; j < i; j++) {\\n                l2 += a[j].length;\\n                need2.push(a[j]);\\n\\n                let lSummedUp = l + l2;\\n                if (lSummedUp >= nLen) {\\n                    if (lSummedUp <= min_len_need) {\\n                        min_len_need = lSummedUp;\\n                        need = [...need, ...need2];\\n\\n                        {\\n                            let final2_needBig = BigInt(need.join(\\'\\'));\\n                            if (final2_needBig > n && final2_needBig < smallest_final_needBig___final_final) {\\n                                final_need = need;\\n                                if (1) {\\n                                    smallest_final_needBig___final_final = final2_needBig;\\n                                }\\n                            }\\n                        }\\n                    }\\n                }\\n                if (lSummedUp > min_len_need) {\\n                    break;\\n                }\\n            }\\n        }\\n    }\\n\\n\\n    final_need.sort();\\n    final_need = final_need.join(\\'\\');\\n\\n    let final_needBig = BigInt(final_need);\\n    if (final_needBig > n) {\\n        return Number(final_needBig);\\n    }\\n\\n    let aaaa = final_need.split(\\'\\');\\n    for (let i = 0; i < aaaa.length; i++) {\\n        for (let j = i; j + 1 < aaaa.length - i; j++) {\\n            [aaaa[j], aaaa[j + 1]] = [aaaa[j + 1], aaaa[j]];\\n\\n            {\\n                let final_needBig = BigInt(aaaa.join(\\'\\'));\\n                if (final_needBig > n) {\\n                    return Number(final_needBig);\\n                }\\n            }\\n        }\\n    }\\n};\\n```\n```\\nvar nextBeautifulNumber = function (n) {\\n\\n    let A = [\\n        \\'1\\', //\\n        \\'22\\',\\n        \\'333\\',\\n        \\'4444\\',\\n        \\'55555\\',\\n        \\'666666\\',\\n        \\'7777777\\',\\n        \\'88888888\\',\\n        \\'999999999\\',\\n    ];\\n\\n    let ans = [];\\n    const bt = (start, a) => {\\n        if (start >= A.length) {\\n            return;\\n        }\\n\\n        if (a.join(\\'\\').length >= (n + \\'\\').length) {\\n            ans.push(a.join(\\'\\'));\\n            return;\\n        }\\n\\n        bt(start + 1, [...a, A[start]]);\\n        bt(start + 1, [...a]);\\n    };\\n\\n    bt(0, []);\\n    ans.sort((a, b) => a.length - b.length || a.localeCompare(b));\\n\\n    let nnnnn = n + \\'\\';\\n\\n    for (let kk = 0; kk < ans.length; kk++) {\\n        let s = ans[kk];\\n        let a = s.split(\\'\\');\\n\\n        {\\n            let good = [];\\n\\n            for (let i = 0; i < a.length; i++) {\\n                let x = a.join(\\'\\');\\n                    \\' .. \\',\\n                    a.join(\\'\\'), //\\n                    x.length > nnnnn.length,\\n                    x.localeCompare(nnnnn) > 0\\n                );\\n\\n                if (x.length > nnnnn.length || x.localeCompare(nnnnn) > 0) {\\n                    if (kk + 1 < ans.length) {\\n                        let x2 = ans[kk + 1];\\n\\n                        if (x.length < x2.length || x.localeCompare(x2) < 0) {\\n                            good.push(x);\\n                        }\\n                    } else {\\n                        good.push(x);\\n                    }\\n                }\\n\\n                a = [...a.slice(1), a[0]];\\n            }\\n\\n            if (good.length) {\\n                let ans = good;\\n                ans.sort((a, b) => a.length - b.length || a.localeCompare(b));\\n                return +ans[0];\\n            }\\n        }\\n    }\\n\\n    return \\'\\';\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1542230,
                "title": "java-permutation-solution",
                "content": "```\\nclass Solution {\\n    public int nextBeautifulNumber(int n) {\\n        List<Integer> result = getNumberArray();\\n        for(int k: result) {\\n            if(k > n) return k;\\n        }\\n        return -1;\\n    }\\n    \\n    \\n    public List<Integer> getNumberArray() {\\n        int[] nums1 = new int[]{1};\\n        int[] nums2 = new int[]{2,2};\\n        int[] nums3 = new int[]{1,2,2};\\n        int[] nums4 = new int[]{3,3,3};\\n        int[] nums5 = new int[]{1,3,3,3};\\n        int[] nums6 = new int[]{4,4,4,4};\\n        int[] nums7 = new int[]{1,4,4,4,4};\\n        int[] nums12 = new int[]{2,2,3,3,3};\\n        int[] nums8 = new int[]{1,2,2,3,3,3};\\n        int[] nums9 = new int[]{1,5,5,5,5,5};\\n        int[] nums10 = new int[]{2,2,4,4,4,4};\\n        int[] nums11 = new int[]{6,6,6,6,6,6};\\n        int[] nums13 = new int[]{5,5,5,5,5};\\n        int[] nums14 = new int[]{1,2,2,4,4,4,4};\\n        List<List<Integer>> list_1 = permuteUnique(nums1);\\n        List<List<Integer>> list_2 = permuteUnique(nums2);\\n        List<List<Integer>> list_3 = permuteUnique(nums3);\\n        List<List<Integer>> list_4 = permuteUnique(nums4);\\n        List<List<Integer>> list_5 = permuteUnique(nums5);\\n        List<List<Integer>> list_6 = permuteUnique(nums6);\\n        List<List<Integer>> list_7 = permuteUnique(nums7);\\n        List<List<Integer>> list_8 = permuteUnique(nums8);\\n        List<List<Integer>> list_9 = permuteUnique(nums9);\\n        List<List<Integer>> list_10 = permuteUnique(nums10);\\n        List<List<Integer>> list_11 = permuteUnique(nums11);\\n        List<List<Integer>> list_12 = permuteUnique(nums12);\\n        List<List<Integer>> list_13 = permuteUnique(nums13);\\n        List<List<Integer>> list_14 = permuteUnique(nums14);\\n        List<List<Integer>> combine = new ArrayList<List<Integer>>();\\n        combine.addAll(list_1);\\n        combine.addAll(list_2);\\n        combine.addAll(list_3);\\n        combine.addAll(list_4);\\n        combine.addAll(list_5);\\n        combine.addAll(list_6);\\n        combine.addAll(list_7);\\n        combine.addAll(list_8);\\n        combine.addAll(list_9);\\n        combine.addAll(list_10);\\n        combine.addAll(list_11);\\n        combine.addAll(list_12);\\n        combine.addAll(list_13);\\n        combine.addAll(list_14);\\n        List<Integer> result = new ArrayList<Integer>();\\n        for(List<Integer> list: combine) {\\n            int k = convert(list);\\n            result.add(k);\\n        }\\n        Collections.sort(result);\\n        return result;\\n    }\\n    \\n    \\n    public int convert(List<Integer> list) {\\n        int number = 0;\\n        for(int myint: list) {\\n            number *= 10;\\n            number += myint;\\n        }\\n        return number;\\n    }\\n    \\n    public List<List<Integer>> permuteUnique(int[] nums) {\\n        List<List<Integer>> res = new ArrayList<List<Integer>>();\\n        if(nums==null || nums.length==0) return res;\\n        boolean[] used = new boolean[nums.length];\\n        List<Integer> list = new ArrayList<Integer>();\\n        Arrays.sort(nums);\\n        dfs(nums, used, list, res);\\n        return res;\\n    }\\n\\n    public void dfs(int[] nums, boolean[] used, List<Integer> list, List<List<Integer>> res){\\n        if(list.size()==nums.length){\\n            res.add(new ArrayList<Integer>(list));\\n            return;\\n        }\\n        for(int i=0;i<nums.length;i++){\\n            if(used[i]) continue;\\n            if(i>0 &&nums[i-1]==nums[i] && !used[i-1]) continue;\\n            used[i]=true;\\n            list.add(nums[i]);\\n            dfs(nums,used,list,res);\\n            used[i]=false;\\n            list.remove(list.size()-1);\\n        }\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Backtracking",
                    "Depth-First Search"
                ],
                "code": "```\\nclass Solution {\\n    public int nextBeautifulNumber(int n) {\\n        List<Integer> result = getNumberArray();\\n        for(int k: result) {\\n            if(k > n) return k;\\n        }\\n        return -1;\\n    }\\n    \\n    \\n    public List<Integer> getNumberArray() {\\n        int[] nums1 = new int[]{1};\\n        int[] nums2 = new int[]{2,2};\\n        int[] nums3 = new int[]{1,2,2};\\n        int[] nums4 = new int[]{3,3,3};\\n        int[] nums5 = new int[]{1,3,3,3};\\n        int[] nums6 = new int[]{4,4,4,4};\\n        int[] nums7 = new int[]{1,4,4,4,4};\\n        int[] nums12 = new int[]{2,2,3,3,3};\\n        int[] nums8 = new int[]{1,2,2,3,3,3};\\n        int[] nums9 = new int[]{1,5,5,5,5,5};\\n        int[] nums10 = new int[]{2,2,4,4,4,4};\\n        int[] nums11 = new int[]{6,6,6,6,6,6};\\n        int[] nums13 = new int[]{5,5,5,5,5};\\n        int[] nums14 = new int[]{1,2,2,4,4,4,4};\\n        List<List<Integer>> list_1 = permuteUnique(nums1);\\n        List<List<Integer>> list_2 = permuteUnique(nums2);\\n        List<List<Integer>> list_3 = permuteUnique(nums3);\\n        List<List<Integer>> list_4 = permuteUnique(nums4);\\n        List<List<Integer>> list_5 = permuteUnique(nums5);\\n        List<List<Integer>> list_6 = permuteUnique(nums6);\\n        List<List<Integer>> list_7 = permuteUnique(nums7);\\n        List<List<Integer>> list_8 = permuteUnique(nums8);\\n        List<List<Integer>> list_9 = permuteUnique(nums9);\\n        List<List<Integer>> list_10 = permuteUnique(nums10);\\n        List<List<Integer>> list_11 = permuteUnique(nums11);\\n        List<List<Integer>> list_12 = permuteUnique(nums12);\\n        List<List<Integer>> list_13 = permuteUnique(nums13);\\n        List<List<Integer>> list_14 = permuteUnique(nums14);\\n        List<List<Integer>> combine = new ArrayList<List<Integer>>();\\n        combine.addAll(list_1);\\n        combine.addAll(list_2);\\n        combine.addAll(list_3);\\n        combine.addAll(list_4);\\n        combine.addAll(list_5);\\n        combine.addAll(list_6);\\n        combine.addAll(list_7);\\n        combine.addAll(list_8);\\n        combine.addAll(list_9);\\n        combine.addAll(list_10);\\n        combine.addAll(list_11);\\n        combine.addAll(list_12);\\n        combine.addAll(list_13);\\n        combine.addAll(list_14);\\n        List<Integer> result = new ArrayList<Integer>();\\n        for(List<Integer> list: combine) {\\n            int k = convert(list);\\n            result.add(k);\\n        }\\n        Collections.sort(result);\\n        return result;\\n    }\\n    \\n    \\n    public int convert(List<Integer> list) {\\n        int number = 0;\\n        for(int myint: list) {\\n            number *= 10;\\n            number += myint;\\n        }\\n        return number;\\n    }\\n    \\n    public List<List<Integer>> permuteUnique(int[] nums) {\\n        List<List<Integer>> res = new ArrayList<List<Integer>>();\\n        if(nums==null || nums.length==0) return res;\\n        boolean[] used = new boolean[nums.length];\\n        List<Integer> list = new ArrayList<Integer>();\\n        Arrays.sort(nums);\\n        dfs(nums, used, list, res);\\n        return res;\\n    }\\n\\n    public void dfs(int[] nums, boolean[] used, List<Integer> list, List<List<Integer>> res){\\n        if(list.size()==nums.length){\\n            res.add(new ArrayList<Integer>(list));\\n            return;\\n        }\\n        for(int i=0;i<nums.length;i++){\\n            if(used[i]) continue;\\n            if(i>0 &&nums[i-1]==nums[i] && !used[i-1]) continue;\\n            used[i]=true;\\n            list.add(nums[i]);\\n            dfs(nums,used,list,res);\\n            used[i]=false;\\n            list.remove(list.size()-1);\\n        }\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1541825,
                "title": "c-next-permutation-math",
                "content": "```\\nclass Solution {\\npublic:\\n    \\n     int give(string str){\\n        int ans = 0;\\n        for(auto it : str)\\n            ans = ans*10 + (it-\\'0\\');\\n        return ans;\\n    }\\n    \\n    static bool comp(string a,string b){\\n        if(a.length() < b.length())\\n            return 1;\\n        if(b.length() < a.length())\\n            return 0;\\n        return a<b;\\n    }\\n    \\n   \\n    int nextBeautifulNumber(int n) {\\n        \\n        if(n == 0)\\n            return 1;\\n        \\n        vector<string>options;\\n        options.push_back(\"1\");\\n        options.push_back(\"22\");\\n        options.push_back(\"333\");\\n        options.push_back(\"4444\");\\n        options.push_back(\"55555\");\\n        options.push_back(\"666666\");\\n        options.push_back(\"7777777\");\\n                \\n        vector<string>comb;\\n        for(int i=1;i<=127;++i){\\n            vector<int>bin(7,0);\\n            int temp = i , ind = 0;\\n            while(temp){\\n                bin[ind++] = temp%2;\\n                temp/=2;\\n            }\\n            string cat=\"\";\\n            for(int i=0;i<7;++i){\\n                if(bin[i])\\n                    cat += options[i];\\n            }\\n            if(cat.length() <= 7)\\n                comb.push_back(cat);\\n        }\\n        sort(comb.begin(),comb.end(),comp);\\n                \\n        int ans = INT_MAX;\\n        \\n        for(int i=0;i<=17;++i){\\n            string req = comb[i];\\n        do{\\n            int x = give(req);\\n            if(x > n and x < ans)\\n                ans = x;\\n        }while(next_permutation(req.begin(),req.end()));\\n        }\\n        return ans;\\n    }\\n};\\n\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    \\n     int give(string str){\\n        int ans = 0;\\n        for(auto it : str)\\n            ans = ans*10 + (it-\\'0\\');\\n        return ans;\\n    }\\n    \\n    static bool comp(string a,string b){\\n        if(a.length() < b.length())\\n            return 1;\\n        if(b.length() < a.length())\\n            return 0;\\n        return a<b;\\n    }\\n    \\n   \\n    int nextBeautifulNumber(int n) {\\n        \\n        if(n == 0)\\n            return 1;\\n        \\n        vector<string>options;\\n        options.push_back(\"1\");\\n        options.push_back(\"22\");\\n        options.push_back(\"333\");\\n        options.push_back(\"4444\");\\n        options.push_back(\"55555\");\\n        options.push_back(\"666666\");\\n        options.push_back(\"7777777\");\\n                \\n        vector<string>comb;\\n        for(int i=1;i<=127;++i){\\n            vector<int>bin(7,0);\\n            int temp = i , ind = 0;\\n            while(temp){\\n                bin[ind++] = temp%2;\\n                temp/=2;\\n            }\\n            string cat=\"\";\\n            for(int i=0;i<7;++i){\\n                if(bin[i])\\n                    cat += options[i];\\n            }\\n            if(cat.length() <= 7)\\n                comb.push_back(cat);\\n        }\\n        sort(comb.begin(),comb.end(),comp);\\n                \\n        int ans = INT_MAX;\\n        \\n        for(int i=0;i<=17;++i){\\n            string req = comb[i];\\n        do{\\n            int x = give(req);\\n            if(x > n and x < ans)\\n                ans = x;\\n        }while(next_permutation(req.begin(),req.end()));\\n        }\\n        return ans;\\n    }\\n};\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1541396,
                "title": "c-simple-for-loop-from-lowest-to-highest",
                "content": "```\\nclass Solution {\\npublic:\\n    bool isbal(int num){\\n        int *arr=new int[10];\\n        for(int i=0;i<=9;i++)\\n            arr[i]=0;\\n        while(num!=0){\\n            arr[num%10]++;\\n            num=num/10;\\n        }\\n        for(int i=0;i<=9;i++){\\n            if(arr[i]!=0 && i!=arr[i]) return false;\\n        }\\n        return true;\\n    }\\n    int nextBeautifulNumber(int n) {\\n        int low=n+1; int high=7777777;\\n        for(int i=low;i<=high;i++){\\n           if(isbal(i)) return i;\\n        }\\n        return -1;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    bool isbal(int num){\\n        int *arr=new int[10];\\n        for(int i=0;i<=9;i++)\\n            arr[i]=0;\\n        while(num!=0){\\n            arr[num%10]++;\\n            num=num/10;\\n        }\\n        for(int i=0;i<=9;i++){\\n            if(arr[i]!=0 && i!=arr[i]) return false;\\n        }\\n        return true;\\n    }\\n    int nextBeautifulNumber(int n) {\\n        int low=n+1; int high=7777777;\\n        for(int i=low;i<=high;i++){\\n           if(isbal(i)) return i;\\n        }\\n        return -1;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1540945,
                "title": "java-easy-dfs-solution-beats-97",
                "content": "```\\nclass Solution {\\n    public int nextBeautifulNumber(int n) {\\n        \\n\\t\\t// Store possibilies for each digit size\\n        Map<Integer, int[][]> m = new HashMap<>();\\n        m.put(3, new int[][]{{1,2}, {0,3}});\\n        m.put(4, new int[][]{{1,3}, {0,4}});\\n        m.put(5, new int[][]{{1,4}, {2,3}, {0,5}});\\n        m.put(6, new int[][]{{1,2,3}, {1,5}, {2,4}, {0,6}});\\n        m.put(7, new int[][]{{1, 2, 4}, {1,6}, {2, 5}, {3, 4}, {0,7}});\\n        \\n        int dig = (int)Math.log10(n) + 1;\\n        \\n\\t\\t// Base conditions\\n        if (n == 0) return 1;\\n        if (n < 22) {\\n            return 22;\\n        }\\n        if (n == 22) {\\n            n = (int) Math.pow(10, dig);\\n            dig++;\\n        } else {\\n            int temp = dig, res = 0;\\n            while (temp > 0) {\\n                res = (res * 10) + dig;\\n                temp--;\\n            }\\n            if (res <= n) {\\n                n = (int) Math.pow(10, dig);\\n                dig++;\\n            }\\n        }\\n        \\n        int res = Integer.MAX_VALUE;\\n\\t\\t\\n\\t\\t// Try all combinations of each digit\\n        for (int[] comb : m.get(dig)) {\\n            int temp = -1;\\n            if (comb.length == 2) {\\n                temp = min(n, 0, comb[0], comb[1], 0, comb[0], comb[1], 0);\\n            } else {\\n                temp = min(n, comb[0], comb[1], comb[2], comb[0], comb[1], comb[2], 0);         \\n            }\\n            if (temp != -1) {\\n                    res = Math.min(res, temp);\\n                }\\n        }\\n        return res;\\n    }\\n    \\n    public int min(int n, int a, int b, int c, int aval, int bval, int cval, int res) {\\n        if (aval == 0 && bval == 0 && cval == 0) {\\n            if (res > n) {\\n                return res;\\n            } else {\\n                return -1;\\n            }\\n        }\\n        int temp = -1;\\n        \\n        if (aval > 0) {\\n            temp = min(n, a, b, c, aval - 1, bval, cval, (res * 10) + a);\\n        }\\n        if (temp > n) return temp;\\n        \\n        if (bval > 0) {\\n            temp = min(n, a, b, c, aval, bval - 1, cval, (res * 10) + b);\\n        }\\n        \\n        if (temp > n) return temp;\\n        \\n        if (cval > 0) {\\n            temp = min(n, a, b, c, aval, bval, cval - 1, (res * 10) + c);\\n        }\\n        \\n        if (temp > n) return temp;\\n        return -1;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int nextBeautifulNumber(int n) {\\n        \\n\\t\\t// Store possibilies for each digit size\\n        Map<Integer, int[][]> m = new HashMap<>();\\n        m.put(3, new int[][]{{1,2}, {0,3}});\\n        m.put(4, new int[][]{{1,3}, {0,4}});\\n        m.put(5, new int[][]{{1,4}, {2,3}, {0,5}});\\n        m.put(6, new int[][]{{1,2,3}, {1,5}, {2,4}, {0,6}});\\n        m.put(7, new int[][]{{1, 2, 4}, {1,6}, {2, 5}, {3, 4}, {0,7}});\\n        \\n        int dig = (int)Math.log10(n) + 1;\\n        \\n\\t\\t// Base conditions\\n        if (n == 0) return 1;\\n        if (n < 22) {\\n            return 22;\\n        }\\n        if (n == 22) {\\n            n = (int) Math.pow(10, dig);\\n            dig++;\\n        } else {\\n            int temp = dig, res = 0;\\n            while (temp > 0) {\\n                res = (res * 10) + dig;\\n                temp--;\\n            }\\n            if (res <= n) {\\n                n = (int) Math.pow(10, dig);\\n                dig++;\\n            }\\n        }\\n        \\n        int res = Integer.MAX_VALUE;\\n\\t\\t\\n\\t\\t// Try all combinations of each digit\\n        for (int[] comb : m.get(dig)) {\\n            int temp = -1;\\n            if (comb.length == 2) {\\n                temp = min(n, 0, comb[0], comb[1], 0, comb[0], comb[1], 0);\\n            } else {\\n                temp = min(n, comb[0], comb[1], comb[2], comb[0], comb[1], comb[2], 0);         \\n            }\\n            if (temp != -1) {\\n                    res = Math.min(res, temp);\\n                }\\n        }\\n        return res;\\n    }\\n    \\n    public int min(int n, int a, int b, int c, int aval, int bval, int cval, int res) {\\n        if (aval == 0 && bval == 0 && cval == 0) {\\n            if (res > n) {\\n                return res;\\n            } else {\\n                return -1;\\n            }\\n        }\\n        int temp = -1;\\n        \\n        if (aval > 0) {\\n            temp = min(n, a, b, c, aval - 1, bval, cval, (res * 10) + a);\\n        }\\n        if (temp > n) return temp;\\n        \\n        if (bval > 0) {\\n            temp = min(n, a, b, c, aval, bval - 1, cval, (res * 10) + b);\\n        }\\n        \\n        if (temp > n) return temp;\\n        \\n        if (cval > 0) {\\n            temp = min(n, a, b, c, aval, bval, cval - 1, (res * 10) + c);\\n        }\\n        \\n        if (temp > n) return temp;\\n        return -1;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1540750,
                "title": "java-recursive-permutation-binary-search-with-explanation",
                "content": "Most of the answers list all possible numbers by manual and return it directly, that\\'s a good solution but I think it might not be a proper answer in an interview.\\n\\nActually this problem covers recursive, permutation and binary search.\\n\\nWe can analyze it in this way:\\n1. It\\'s obvious that balanced number can have different length. \\n  For length 1, only number 1 is balanced.\\n  For length 2, only number 22 is balanced. (If you want to put digit 1, there is one more space left and then you have no other choice. For any digit which is bigger than 2, the length is not long enough.)\\n  So we can have a rough list like below:\\n    1. Length 1 : 1\\n    1. Length 2: 22\\n    1. Length 3: 333, 221, ....(and other permutation composed by 2,2,1)...\\n    1. Length 4: 4444, 3331, ...(permutation composed by 3,3,3,1)...\\n    1. Length 5: 55555, 44441, ...(permuation composed by 4,4,4,4,1)..., 33322, ...(permutation composed by 3,3,3,2,2)...\\n2. If we can get the length of given number, and then we would know how long would the balanced number be.\\n  Say the given number is 123, its length is 3, and we know the biggest balanced number with length 3 is 333. It\\'s obvious from the list in step 1.\\n  If the given number is 380, its length is 3 while the length of the balanced number cannot be 333 since 333 < 380. And we know 333 is the biggest number for 3-digit-balanced-number, so we have to turn to find a balanced number with 4 digits. It means that we have to find the answer in the 4th line of list in step1.\\n3. Once we decide how long the balanced number be, say 4. we can generate all balanced number with length 4.\\n4. Find the smallest one which is bigger than given number, this is the anwer we\\'re looking for.\\n\\nNow we have rough steps:\\n1. Get the length of given number, say **numLen**\\n2. Figure out the length of balanced number, say **balancedNumLen**\\n3. Generate all balanced number with length **balancedNumLen**(https://leetcode.com/problems/permutations-ii/  permutation with duplicated numbers), and sort them\\n4. Find answer from sorted balanced number by binary search(https://leetcode.com/problems/find-smallest-letter-greater-than-target/ a similar problem)\\n\\nCode looks like:\\n\\n```\\nclass Solution {\\n    // 1 \\n    // 22\\n    // 333, 221\\n    // 4444, 3331\\n    // 55555, 44441, 33322\\n    // 666666, 555551, 333221, 444422\\n    // 7777777, 6666661, 4444333, 4444221, 5555522, 4444333\\n\\t// Above are the possible BASIC balanced numbers, we can generate permutation for them\\n\\t// Because 0 <= n <= 10^6, so we only have to consider number with length up to 7\\n\\t\\n\\t// Very basic 2 cases for balanced, they will be used to generate more balanced numbers\\n    Map<Integer, List<Integer>> map = new HashMap<>(Map.of(\\n        1, List.of(1),\\n        2, List.of(22)\\n    ));\\n    public int nextBeautifulNumber(int n) {\\n\\t\\t// Get the length of given number\\n        int numLen = getNumLen(n);\\n\\t\\t\\n\\t\\t// Get the max balanced number for given length\\n\\t\\t// For example, 333 is the max for length 3, 55555 is the max for length 5\\n        int maxWithLenN = getMaxWithLenN(numLen);\\n\\t\\t\\n\\t\\t// Get sorted permutation by given length\\n\\t\\t// Given number is 380, then we should find balanced number in 4-digit-balanced-number since 380 > 333(which is the max in 3-digit-balanced-number)\\n\\t\\t// Given number is 123, we can find balanced number in 3-digit-balanced-number\\n        List<Integer> sortedPermutation = getSortedPermutationForGivenLen(n < maxWithLenN ? numLen : numLen + 1);\\n\\t\\t\\n\\t\\t// Find smallest one in all bigger, obviously binary search can be applied\\n\\t\\t// Given number is 123, and all 3-digit-balanced-number are 122, 212, 221, 333\\n\\t\\t// 212 should be returned\\n        return findLeftEdgeInBigger(n, sortedPermutation);\\n    }\\n    private List<Integer> getSortedPermutationForGivenLen(int len) {\\n\\t\\t// Get all basic balanced numbers first\\n\\t\\t// They can be 333, 221 or 4444, 3331\\n        List<Integer> allBasicOptions = getAllBasicOptions(len);\\n\\t\\t\\n\\t\\t// Then use basic number to generate permutation\\n        List<Integer> sortedPermutation = new ArrayList<>();\\n        for(int basic : allBasicOptions) {\\n            sortedPermutation.addAll(getAllPermutation(basic));\\n        }\\n\\t\\t// And sort them, since we\\'ll use binary search to do the search\\n        Collections.sort(sortedPermutation);\\n        return sortedPermutation;\\n    }\\n    private List<Integer> getAllPermutation(int num) {\\n        String numStr = String.valueOf(num);\\n        char[] chars = numStr.toCharArray();\\n        Arrays.sort(chars);\\n\\t\\t// Prepare all things and call this recursive to generate permucation\\n        return getAllPermutation(chars, new boolean[chars.length], new StringBuilder(), new ArrayList<Integer>());\\n    }\\n    private List<Integer> getAllPermutation(char[] chars, boolean[] touched, StringBuilder cur, List<Integer> result) {\\n\\t\\t// this is a permutation problems which contains duplicated number\\n        if(cur.length() == chars.length) {\\n            result.add(Integer.parseInt((new StringBuilder(cur)).toString()));\\n        }\\n        else {\\n            for(int i = 0; i < chars.length; i++) {\\n                if(touched[i]) {\\n                    continue;\\n                }\\n                if(i > 0 && chars[i] == chars[i - 1] && !touched[i - 1]) {\\n                    continue;\\n                }\\n                cur.append(chars[i]);\\n                touched[i] = true;\\n                getAllPermutation(chars, touched, cur, result);\\n                touched[i] = false;\\n                cur.deleteCharAt(cur.length() - 1);\\n            }\\n        }\\n        return result;\\n    }\\n    private int findLeftEdgeInBigger(int n, List<Integer> options) {\\n\\t\\t// binary search to find smallest number greater than given number\\n        int left = 0, right = options.size() - 1;\\n        while(left <= right) {\\n            int mid = left + (right - left) / 2;\\n            int midVal = options.get(mid);\\n            if(midVal <= n) {\\n                left = mid + 1;\\n            }\\n            else if(midVal > n) {\\n                right = mid - 1;\\n            }            \\n        }\\n        return left == options.size() ? options.get(options.size() - 1) : options.get(left);\\n    }\\n    private List<Integer> getAllBasicOptions(int len) {\\n\\t\\t// use map to store all generated basice balanced number to avoid duplicated calculation\\n        if(map.containsKey(len)) {\\n            return map.get(len);\\n        }\\n        List<String> options = new ArrayList<>();\\n        options.add(getNCopiesStrOfGivenDigit(len));\\n        for(int digit = len - 1; digit >= (len + 1) / 2; digit--) {\\n            StringBuilder firstPiece = new StringBuilder();\\n            firstPiece.append(getNCopiesStrOfGivenDigit(digit));\\n            for(int secondPiece : getAllBasicOptions(len - digit)) {\\n                StringBuilder option = new StringBuilder(firstPiece);\\n                option.append(secondPiece);\\n                options.add(option.toString());\\n            }\\n        }\\n        map.put(len, options.stream()\\n                            .filter(option -> isValid(option))\\n                            .map(Integer::parseInt)\\n                            .collect(Collectors.toList()));\\n        return map.get(len);\\n    }\\n    private boolean isValid(String option) {\\n\\t\\t// check if the number is a valid balanced number\\n        int len = option.length();\\n        int[] appearance = new int[len + 1];\\n        for(int i = 0; i < len; i++) {\\n            char ch = option.charAt(i);\\n            int digit = Character.getNumericValue(ch);\\n            appearance[digit]++;\\n        }\\n        for(int i = 1; i < appearance.length; i++) {\\n            if(appearance[i] != 0 && appearance[i] != i) {\\n                return false;\\n            }\\n        }\\n        return true;\\n    }\\n    private int getMaxWithLenN(int len) {\\n\\t\\t// Given 4\\n\\t\\t// Then return int 4444\\n        return Integer.parseInt(getNCopiesStrOfGivenDigit(len));\\n    }\\n    private String getNCopiesStrOfGivenDigit(int digit) {\\n\\t\\t// repeat given digit by digit times\\n\\t\\t// say digit is 5, we\\'ll get a string \"55555\"\\n        return String.join(\"\", Collections.nCopies(digit, String.valueOf(digit)));\\n    }\\n    private int getNumLen(int n) {\\n\\t\\t// use log10 to decide the length of given number\\n        return n == 0 \\n            ? 1\\n            : new Double(Math.log10(n)).intValue() + 1;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    // 1 \\n    // 22\\n    // 333, 221\\n    // 4444, 3331\\n    // 55555, 44441, 33322\\n    // 666666, 555551, 333221, 444422\\n    // 7777777, 6666661, 4444333, 4444221, 5555522, 4444333\\n\\t// Above are the possible BASIC balanced numbers, we can generate permutation for them\\n\\t// Because 0 <= n <= 10^6, so we only have to consider number with length up to 7\\n\\t\\n\\t// Very basic 2 cases for balanced, they will be used to generate more balanced numbers\\n    Map<Integer, List<Integer>> map = new HashMap<>(Map.of(\\n        1, List.of(1),\\n        2, List.of(22)\\n    ));\\n    public int nextBeautifulNumber(int n) {\\n\\t\\t// Get the length of given number\\n        int numLen = getNumLen(n);\\n\\t\\t\\n\\t\\t// Get the max balanced number for given length\\n\\t\\t// For example, 333 is the max for length 3, 55555 is the max for length 5\\n        int maxWithLenN = getMaxWithLenN(numLen);\\n\\t\\t\\n\\t\\t// Get sorted permutation by given length\\n\\t\\t// Given number is 380, then we should find balanced number in 4-digit-balanced-number since 380 > 333(which is the max in 3-digit-balanced-number)\\n\\t\\t// Given number is 123, we can find balanced number in 3-digit-balanced-number\\n        List<Integer> sortedPermutation = getSortedPermutationForGivenLen(n < maxWithLenN ? numLen : numLen + 1);\\n\\t\\t\\n\\t\\t// Find smallest one in all bigger, obviously binary search can be applied\\n\\t\\t// Given number is 123, and all 3-digit-balanced-number are 122, 212, 221, 333\\n\\t\\t// 212 should be returned\\n        return findLeftEdgeInBigger(n, sortedPermutation);\\n    }\\n    private List<Integer> getSortedPermutationForGivenLen(int len) {\\n\\t\\t// Get all basic balanced numbers first\\n\\t\\t// They can be 333, 221 or 4444, 3331\\n        List<Integer> allBasicOptions = getAllBasicOptions(len);\\n\\t\\t\\n\\t\\t// Then use basic number to generate permutation\\n        List<Integer> sortedPermutation = new ArrayList<>();\\n        for(int basic : allBasicOptions) {\\n            sortedPermutation.addAll(getAllPermutation(basic));\\n        }\\n\\t\\t// And sort them, since we\\'ll use binary search to do the search\\n        Collections.sort(sortedPermutation);\\n        return sortedPermutation;\\n    }\\n    private List<Integer> getAllPermutation(int num) {\\n        String numStr = String.valueOf(num);\\n        char[] chars = numStr.toCharArray();\\n        Arrays.sort(chars);\\n\\t\\t// Prepare all things and call this recursive to generate permucation\\n        return getAllPermutation(chars, new boolean[chars.length], new StringBuilder(), new ArrayList<Integer>());\\n    }\\n    private List<Integer> getAllPermutation(char[] chars, boolean[] touched, StringBuilder cur, List<Integer> result) {\\n\\t\\t// this is a permutation problems which contains duplicated number\\n        if(cur.length() == chars.length) {\\n            result.add(Integer.parseInt((new StringBuilder(cur)).toString()));\\n        }\\n        else {\\n            for(int i = 0; i < chars.length; i++) {\\n                if(touched[i]) {\\n                    continue;\\n                }\\n                if(i > 0 && chars[i] == chars[i - 1] && !touched[i - 1]) {\\n                    continue;\\n                }\\n                cur.append(chars[i]);\\n                touched[i] = true;\\n                getAllPermutation(chars, touched, cur, result);\\n                touched[i] = false;\\n                cur.deleteCharAt(cur.length() - 1);\\n            }\\n        }\\n        return result;\\n    }\\n    private int findLeftEdgeInBigger(int n, List<Integer> options) {\\n\\t\\t// binary search to find smallest number greater than given number\\n        int left = 0, right = options.size() - 1;\\n        while(left <= right) {\\n            int mid = left + (right - left) / 2;\\n            int midVal = options.get(mid);\\n            if(midVal <= n) {\\n                left = mid + 1;\\n            }\\n            else if(midVal > n) {\\n                right = mid - 1;\\n            }            \\n        }\\n        return left == options.size() ? options.get(options.size() - 1) : options.get(left);\\n    }\\n    private List<Integer> getAllBasicOptions(int len) {\\n\\t\\t// use map to store all generated basice balanced number to avoid duplicated calculation\\n        if(map.containsKey(len)) {\\n            return map.get(len);\\n        }\\n        List<String> options = new ArrayList<>();\\n        options.add(getNCopiesStrOfGivenDigit(len));\\n        for(int digit = len - 1; digit >= (len + 1) / 2; digit--) {\\n            StringBuilder firstPiece = new StringBuilder();\\n            firstPiece.append(getNCopiesStrOfGivenDigit(digit));\\n            for(int secondPiece : getAllBasicOptions(len - digit)) {\\n                StringBuilder option = new StringBuilder(firstPiece);\\n                option.append(secondPiece);\\n                options.add(option.toString());\\n            }\\n        }\\n        map.put(len, options.stream()\\n                            .filter(option -> isValid(option))\\n                            .map(Integer::parseInt)\\n                            .collect(Collectors.toList()));\\n        return map.get(len);\\n    }\\n    private boolean isValid(String option) {\\n\\t\\t// check if the number is a valid balanced number\\n        int len = option.length();\\n        int[] appearance = new int[len + 1];\\n        for(int i = 0; i < len; i++) {\\n            char ch = option.charAt(i);\\n            int digit = Character.getNumericValue(ch);\\n            appearance[digit]++;\\n        }\\n        for(int i = 1; i < appearance.length; i++) {\\n            if(appearance[i] != 0 && appearance[i] != i) {\\n                return false;\\n            }\\n        }\\n        return true;\\n    }\\n    private int getMaxWithLenN(int len) {\\n\\t\\t// Given 4\\n\\t\\t// Then return int 4444\\n        return Integer.parseInt(getNCopiesStrOfGivenDigit(len));\\n    }\\n    private String getNCopiesStrOfGivenDigit(int digit) {\\n\\t\\t// repeat given digit by digit times\\n\\t\\t// say digit is 5, we\\'ll get a string \"55555\"\\n        return String.join(\"\", Collections.nCopies(digit, String.valueOf(digit)));\\n    }\\n    private int getNumLen(int n) {\\n\\t\\t// use log10 to decide the length of given number\\n        return n == 0 \\n            ? 1\\n            : new Double(Math.log10(n)).intValue() + 1;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1539959,
                "title": "c-100-100-with-hardcoded-list",
                "content": "```\\npublic int NextBeautifulNumber(int n) {\\n\\tvar list = CreatePredefinedList();\\n\\tvar index = GetIndex(n, list);\\n\\tvar rs = list[index];\\n\\treturn rs;\\n}\\nprivate int GetIndex(int n, List<int> list)\\n{\\n\\tvar index0 = 0;\\n\\tif (n < list[index0]) return index0;\\n\\tvar index1 = list.Count - 1;\\n\\twhile(index1 - index0 > 1)\\n\\t{\\n\\t\\tvar indexMid = (index0 + index1) / 2;\\n\\t\\tif (n < list[indexMid])\\n\\t\\t{\\n\\t\\t\\tindex1 = indexMid;\\n\\t\\t}\\n\\t\\telse\\n\\t\\t{\\n\\t\\t\\tindex0 = indexMid;\\n\\t\\t}\\n\\t}\\n\\treturn index1;\\n}\\nprivate List<int> CreatePredefinedList()\\n{\\n\\tvar rs = new List<int>();\\n\\trs.Add(1);\\n\\trs.Add(22);\\n\\trs.Add(122);\\n\\trs.Add(212);\\n\\trs.Add(221);\\n\\trs.Add(333);\\n\\trs.Add(1333);\\n\\trs.Add(3133);\\n\\trs.Add(3313);\\n\\trs.Add(3331);\\n\\trs.Add(4444);\\n\\trs.Add(14444);\\n\\trs.Add(22333);\\n\\trs.Add(23233);\\n\\trs.Add(23323);\\n\\trs.Add(23332);\\n\\trs.Add(32233);\\n\\trs.Add(32323);\\n\\trs.Add(32332);\\n\\trs.Add(33223);\\n\\trs.Add(33232);\\n\\trs.Add(33322);\\n\\trs.Add(41444);\\n\\trs.Add(44144);\\n\\trs.Add(44414);\\n\\trs.Add(44441);\\n\\trs.Add(55555);\\n\\trs.Add(155555);\\n\\trs.Add(122333);\\n\\trs.Add(123233);\\n\\trs.Add(123323);\\n\\trs.Add(123332);\\n\\trs.Add(132233);\\n\\trs.Add(132323);\\n\\trs.Add(132332);\\n\\trs.Add(133223);\\n\\trs.Add(133232);\\n\\trs.Add(133322);\\n\\n\\trs.Add(212333);\\n\\trs.Add(213233);\\n\\trs.Add(213323);\\n\\trs.Add(213332);\\n\\trs.Add(221333);\\n\\trs.Add(223133);\\n\\trs.Add(223313);\\n\\trs.Add(223331);\\n\\trs.Add(231233);\\n\\trs.Add(231323);\\n\\trs.Add(231332);\\n\\trs.Add(232133);\\n\\trs.Add(232313);\\n\\trs.Add(232331);\\n\\trs.Add(233123);\\n\\trs.Add(233132);\\n\\trs.Add(233213);\\n\\trs.Add(233231);\\n\\trs.Add(233312);\\n\\trs.Add(233321);\\n\\n\\trs.Add(312233);\\n\\trs.Add(312323);\\n\\trs.Add(312332);\\n\\trs.Add(313223);\\n\\trs.Add(313232);\\n\\trs.Add(313322);\\n\\n\\trs.Add(321233);\\n\\trs.Add(321323);\\n\\trs.Add(321332);\\n\\trs.Add(322133);\\n\\trs.Add(322313);\\n\\trs.Add(322331);\\n\\trs.Add(323123);\\n\\trs.Add(323132);\\n\\trs.Add(323213);\\n\\trs.Add(323231);\\n\\trs.Add(323312);\\n\\trs.Add(323321);\\n\\n\\trs.Add(331223);\\n\\trs.Add(331232);\\n\\trs.Add(331322);\\n\\trs.Add(332123);\\n\\trs.Add(332132);\\n\\trs.Add(332213);\\n\\trs.Add(332231);\\n\\trs.Add(332312);\\n\\trs.Add(332321);\\n\\trs.Add(333122);\\n\\trs.Add(333212);\\n\\trs.Add(333221);\\n\\n\\trs.Add(224444);\\n\\trs.Add(242444);\\n\\trs.Add(244244);\\n\\trs.Add(244424);\\n\\trs.Add(244442);\\n\\trs.Add(422444);\\n\\trs.Add(424244);\\n\\trs.Add(424424);\\n\\trs.Add(424442);\\n\\trs.Add(442244);\\n\\trs.Add(442424);\\n\\trs.Add(442442);\\n\\trs.Add(444224);\\n\\trs.Add(444242);\\n\\trs.Add(444422);\\n\\trs.Add(515555);\\n\\trs.Add(551555);\\n\\trs.Add(555155);\\n\\trs.Add(555515);\\n\\trs.Add(555551);\\n\\trs.Add(666666);\\n\\trs.Add(1224444);\\n\\trs.Sort();\\n\\treturn rs;\\n}\\n```",
                "solutionTags": [],
                "code": "```\\npublic int NextBeautifulNumber(int n) {\\n\\tvar list = CreatePredefinedList();\\n\\tvar index = GetIndex(n, list);\\n\\tvar rs = list[index];\\n\\treturn rs;\\n}\\nprivate int GetIndex(int n, List<int> list)\\n{\\n\\tvar index0 = 0;\\n\\tif (n < list[index0]) return index0;\\n\\tvar index1 = list.Count - 1;\\n\\twhile(index1 - index0 > 1)\\n\\t{\\n\\t\\tvar indexMid = (index0 + index1) / 2;\\n\\t\\tif (n < list[indexMid])\\n\\t\\t{\\n\\t\\t\\tindex1 = indexMid;\\n\\t\\t}\\n\\t\\telse\\n\\t\\t{\\n\\t\\t\\tindex0 = indexMid;\\n\\t\\t}\\n\\t}\\n\\treturn index1;\\n}\\nprivate List<int> CreatePredefinedList()\\n{\\n\\tvar rs = new List<int>();\\n\\trs.Add(1);\\n\\trs.Add(22);\\n\\trs.Add(122);\\n\\trs.Add(212);\\n\\trs.Add(221);\\n\\trs.Add(333);\\n\\trs.Add(1333);\\n\\trs.Add(3133);\\n\\trs.Add(3313);\\n\\trs.Add(3331);\\n\\trs.Add(4444);\\n\\trs.Add(14444);\\n\\trs.Add(22333);\\n\\trs.Add(23233);\\n\\trs.Add(23323);\\n\\trs.Add(23332);\\n\\trs.Add(32233);\\n\\trs.Add(32323);\\n\\trs.Add(32332);\\n\\trs.Add(33223);\\n\\trs.Add(33232);\\n\\trs.Add(33322);\\n\\trs.Add(41444);\\n\\trs.Add(44144);\\n\\trs.Add(44414);\\n\\trs.Add(44441);\\n\\trs.Add(55555);\\n\\trs.Add(155555);\\n\\trs.Add(122333);\\n\\trs.Add(123233);\\n\\trs.Add(123323);\\n\\trs.Add(123332);\\n\\trs.Add(132233);\\n\\trs.Add(132323);\\n\\trs.Add(132332);\\n\\trs.Add(133223);\\n\\trs.Add(133232);\\n\\trs.Add(133322);\\n\\n\\trs.Add(212333);\\n\\trs.Add(213233);\\n\\trs.Add(213323);\\n\\trs.Add(213332);\\n\\trs.Add(221333);\\n\\trs.Add(223133);\\n\\trs.Add(223313);\\n\\trs.Add(223331);\\n\\trs.Add(231233);\\n\\trs.Add(231323);\\n\\trs.Add(231332);\\n\\trs.Add(232133);\\n\\trs.Add(232313);\\n\\trs.Add(232331);\\n\\trs.Add(233123);\\n\\trs.Add(233132);\\n\\trs.Add(233213);\\n\\trs.Add(233231);\\n\\trs.Add(233312);\\n\\trs.Add(233321);\\n\\n\\trs.Add(312233);\\n\\trs.Add(312323);\\n\\trs.Add(312332);\\n\\trs.Add(313223);\\n\\trs.Add(313232);\\n\\trs.Add(313322);\\n\\n\\trs.Add(321233);\\n\\trs.Add(321323);\\n\\trs.Add(321332);\\n\\trs.Add(322133);\\n\\trs.Add(322313);\\n\\trs.Add(322331);\\n\\trs.Add(323123);\\n\\trs.Add(323132);\\n\\trs.Add(323213);\\n\\trs.Add(323231);\\n\\trs.Add(323312);\\n\\trs.Add(323321);\\n\\n\\trs.Add(331223);\\n\\trs.Add(331232);\\n\\trs.Add(331322);\\n\\trs.Add(332123);\\n\\trs.Add(332132);\\n\\trs.Add(332213);\\n\\trs.Add(332231);\\n\\trs.Add(332312);\\n\\trs.Add(332321);\\n\\trs.Add(333122);\\n\\trs.Add(333212);\\n\\trs.Add(333221);\\n\\n\\trs.Add(224444);\\n\\trs.Add(242444);\\n\\trs.Add(244244);\\n\\trs.Add(244424);\\n\\trs.Add(244442);\\n\\trs.Add(422444);\\n\\trs.Add(424244);\\n\\trs.Add(424424);\\n\\trs.Add(424442);\\n\\trs.Add(442244);\\n\\trs.Add(442424);\\n\\trs.Add(442442);\\n\\trs.Add(444224);\\n\\trs.Add(444242);\\n\\trs.Add(444422);\\n\\trs.Add(515555);\\n\\trs.Add(551555);\\n\\trs.Add(555155);\\n\\trs.Add(555515);\\n\\trs.Add(555551);\\n\\trs.Add(666666);\\n\\trs.Add(1224444);\\n\\trs.Sort();\\n\\treturn rs;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1539888,
                "title": "c-faster-method-easy-solution-beats-100",
                "content": "Only these cases are there that will be the answer.\\n\\n```\\nclass Solution {\\npublic:\\n    int nextBeautifulNumber(int n) {\\n        \\n        vector<string> v={\\n                \"1\",\"22\",\"122\",\"333\",\"1333\",\"4444\",\"14444\",\"22333\",\"55555\",\\n                \"155555\",\"224444\",\"122333\",\"666666\",\"1224444\"\\n        };\\n        \\n        vector<int> store;\\n        \\n        for(string i : v)\\n        {\\n            do{\\n                store.push_back(stoi(i));\\n            }while(next_permutation(i.begin(),i.end()));\\n        }\\n        sort(store.begin(),store.end());\\n        \\n        \\n        return *upper_bound(store.begin(),store.end(),n);\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int nextBeautifulNumber(int n) {\\n        \\n        vector<string> v={\\n                \"1\",\"22\",\"122\",\"333\",\"1333\",\"4444\",\"14444\",\"22333\",\"55555\",\\n                \"155555\",\"224444\",\"122333\",\"666666\",\"1224444\"\\n        };\\n        \\n        vector<int> store;\\n        \\n        for(string i : v)\\n        {\\n            do{\\n                store.push_back(stoi(i));\\n            }while(next_permutation(i.begin(),i.end()));\\n        }\\n        sort(store.begin(),store.end());\\n        \\n        \\n        return *upper_bound(store.begin(),store.end(),n);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1539655,
                "title": "c-brute-force-137-145-cases-passes",
                "content": "Keep increasing the number for next permutation and calculate whether that number is balanced or not .\\n```\\nbool isbalanced(int n)\\n    {\\n          string str= to_string(n);\\n        unordered_map<int,int>m;\\n        for(int i=0;i<str.size();i++)\\n        {\\n            m[str[i]-\\'0\\']++;\\n            \\n        }\\n        for(auto it=m.begin();it!=m.end();it++)\\n        {\\n            if(it->first!=it->second)\\n            {\\n                return false;\\n            }\\n        }\\n        return true;\\n    }\\n    int nextBeautifulNumber(int n) {\\n        int res;\\n        while(true)\\n        {\\n            n++;\\n            if(isbalanced(n))\\n            {  \\n                res=n;\\n                break;\\n            }\\n        }\\n        return res;\\n        \\n    }\\n```",
                "solutionTags": [],
                "code": "```\\nbool isbalanced(int n)\\n    {\\n          string str= to_string(n);\\n        unordered_map<int,int>m;\\n        for(int i=0;i<str.size();i++)\\n        {\\n            m[str[i]-\\'0\\']++;\\n            \\n        }\\n        for(auto it=m.begin();it!=m.end();it++)\\n        {\\n            if(it->first!=it->second)\\n            {\\n                return false;\\n            }\\n        }\\n        return true;\\n    }\\n    int nextBeautifulNumber(int n) {\\n        int res;\\n        while(true)\\n        {\\n            n++;\\n            if(isbalanced(n))\\n            {  \\n                res=n;\\n                break;\\n            }\\n        }\\n        return res;\\n        \\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1539340,
                "title": "c-easy-solution-100-beat-next-permutation",
                "content": "```\\nclass Solution {\\npublic:\\n    int nextBeautifulNumber(int n) {\\n        if(n==0)\\n        {\\n            return 1;\\n        }\\n        if(n==1000000)\\n        {\\n            return 1224444;\\n        }\\n        string g = to_string(n);\\n        int s = g.size();\\n        int r = s;\\n        string tt;\\n        while(s!=0)\\n        {\\n            tt.push_back(r+\\'0\\');\\n            s--;\\n        }\\n        int y = stoi(tt);\\n        if(y<=n)\\n        {\\n            \\n            if(g.size()==6)\\n            {\\n                return 1224444;\\n            }\\n            else if(g.size()==5)\\n            {\\n                return 122333;\\n            }\\n            else if(g.size()==4)\\n            {\\n                return 14444;\\n            }\\n            else if(g.size()==3)\\n            {\\n                return 1333;\\n            }\\n            else if(g.size()==2)\\n            {\\n                return 122;\\n            }\\n            else\\n            {\\n                return 22;\\n            }\\n        }\\n        int u = 0;\\n        int ans =INT_MAX;\\n        while(u<g.size()-u)\\n        {\\n            string o;\\n            int l = g.size()-u;\\n            int c = l;\\n            int x = u;\\n            while(x!=0)\\n            {\\n                o.push_back(u+\\'0\\');\\n                x--;\\n            }\\n            while(l!=0)\\n            {\\n                o.push_back(c+\\'0\\');\\n                l--;\\n            }\\n            if(stoi(o)>n)\\n            {\\n                ans = min(ans,stoi(o));\\n            }\\n            while(next_permutation(o.begin(),o.end()))\\n            {\\n                int vvv = stoi(o);\\n                if(vvv>n)\\n                {\\n                    ans = min(ans,vvv);\\n                }\\n            }\\n            u++;\\n        }\\n        if(g.size()==6)\\n        {\\n            string kk = \"122333\";\\n            if(stoi(kk)>n)\\n            {\\n                ans = min(ans,stoi(kk));\\n            }\\n            while(next_permutation(kk.begin(),kk.end()))\\n            {\\n                if(stoi(kk)>n)\\n                {\\n                    ans = min(ans,stoi(kk));\\n                }\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int nextBeautifulNumber(int n) {\\n        if(n==0)\\n        {\\n            return 1;\\n        }\\n        if(n==1000000)\\n        {\\n            return 1224444;\\n        }\\n        string g = to_string(n);\\n        int s = g.size();\\n        int r = s;\\n        string tt;\\n        while(s!=0)\\n        {\\n            tt.push_back(r+\\'0\\');\\n            s--;\\n        }\\n        int y = stoi(tt);\\n        if(y<=n)\\n        {\\n            \\n            if(g.size()==6)\\n            {\\n                return 1224444;\\n            }\\n            else if(g.size()==5)\\n            {\\n                return 122333;\\n            }\\n            else if(g.size()==4)\\n            {\\n                return 14444;\\n            }\\n            else if(g.size()==3)\\n            {\\n                return 1333;\\n            }\\n            else if(g.size()==2)\\n            {\\n                return 122;\\n            }\\n            else\\n            {\\n                return 22;\\n            }\\n        }\\n        int u = 0;\\n        int ans =INT_MAX;\\n        while(u<g.size()-u)\\n        {\\n            string o;\\n            int l = g.size()-u;\\n            int c = l;\\n            int x = u;\\n            while(x!=0)\\n            {\\n                o.push_back(u+\\'0\\');\\n                x--;\\n            }\\n            while(l!=0)\\n            {\\n                o.push_back(c+\\'0\\');\\n                l--;\\n            }\\n            if(stoi(o)>n)\\n            {\\n                ans = min(ans,stoi(o));\\n            }\\n            while(next_permutation(o.begin(),o.end()))\\n            {\\n                int vvv = stoi(o);\\n                if(vvv>n)\\n                {\\n                    ans = min(ans,vvv);\\n                }\\n            }\\n            u++;\\n        }\\n        if(g.size()==6)\\n        {\\n            string kk = \"122333\";\\n            if(stoi(kk)>n)\\n            {\\n                ans = min(ans,stoi(kk));\\n            }\\n            while(next_permutation(kk.begin(),kk.end()))\\n            {\\n                if(stoi(kk)>n)\\n                {\\n                    ans = min(ans,stoi(kk));\\n                }\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1539302,
                "title": "golang-0ms-brute-force",
                "content": "```go\\nfunc nextBeautifulNumber(n int) int {\\n\\tbeautifulNumbers := generator()\\n\\tfor _, bn := range beautifulNumbers {\\n\\t\\tif n < bn {\\n\\t\\t\\treturn bn\\n\\t\\t}\\n\\t}\\n\\treturn 0\\n}\\n\\nfunc generator() []int {\\n\\tnumbers := make([]int, 0)\\n\\t// 1 1\\n\\t// 2 2\\n\\t// 3 1+2, 3\\n\\t// 7 1+2+4\\n\\tnumbers = append(numbers, 1, 22, 122, 212, 221, 333, 1224444)\\n\\t// 4 1+3, 4\\n\\tnumbers = append(numbers, 1333, 3133, 3313, 3331, 4444)\\n\\t// 5 1+4, 2+3, 5\\n\\tnumbers = append(numbers, 14444, 41444, 44144, 44414, 44441, 55555)\\n\\tfor i := 0; i < 5; i++ {\\n\\t\\tfor j := 0; j < 5; j++ {\\n\\t\\t\\tif i == j {\\n\\t\\t\\t\\tcontinue\\n\\t\\t\\t}\\n\\t\\t\\tbase := 33333\\n\\t\\t\\tbase -= 1 * int(math.Pow10(i) + math.Pow10(j))\\n\\t\\t\\tnumbers = append(numbers, base)\\n\\t\\t}\\n\\t}\\n\\t// 6 1+5, 1+2+3, 2+4, 6\\n\\tnumbers = append(numbers, 155555, 515555, 551555, 555155, 555515, 555551, 666666)\\n\\tfor i := 0; i < 6; i++ {\\n\\t\\tfor j := 0; j < 6; j++ {\\n\\t\\t\\tfor k := 0; k < 6; k++ {\\n\\t\\t\\t\\tif i == j || i == k || j == k {\\n\\t\\t\\t\\t\\tcontinue\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\tbase := 333333\\n\\t\\t\\t\\tbase -= 1 * int(math.Pow10(i) + math.Pow10(j))\\n\\t\\t\\t\\tbase -= 2 * int(math.Pow10(k))\\n\\t\\t\\t\\tnumbers = append(numbers, base)\\n\\t\\t\\t}\\n\\t\\t}\\n\\t}\\n    for i := 0; i < 6; i++ {\\n\\t\\tfor j := 0; j < 6; j++ {\\n\\t\\t\\tif i == j {\\n\\t\\t\\t\\tcontinue\\n\\t\\t\\t}\\n\\t\\t\\tbase := 444444\\n\\t\\t\\tbase -= 2 * int(math.Pow10(i) + math.Pow10(j))\\n\\t\\t\\tnumbers = append(numbers, base)\\n\\t\\t}\\n\\t}\\n\\tsort.Ints(numbers)\\n\\treturn numbers\\n}\\n```",
                "solutionTags": [
                    "Go"
                ],
                "code": "```go\\nfunc nextBeautifulNumber(n int) int {\\n\\tbeautifulNumbers := generator()\\n\\tfor _, bn := range beautifulNumbers {\\n\\t\\tif n < bn {\\n\\t\\t\\treturn bn\\n\\t\\t}\\n\\t}\\n\\treturn 0\\n}\\n\\nfunc generator() []int {\\n\\tnumbers := make([]int, 0)\\n\\t// 1 1\\n\\t// 2 2\\n\\t// 3 1+2, 3\\n\\t// 7 1+2+4\\n\\tnumbers = append(numbers, 1, 22, 122, 212, 221, 333, 1224444)\\n\\t// 4 1+3, 4\\n\\tnumbers = append(numbers, 1333, 3133, 3313, 3331, 4444)\\n\\t// 5 1+4, 2+3, 5\\n\\tnumbers = append(numbers, 14444, 41444, 44144, 44414, 44441, 55555)\\n\\tfor i := 0; i < 5; i++ {\\n\\t\\tfor j := 0; j < 5; j++ {\\n\\t\\t\\tif i == j {\\n\\t\\t\\t\\tcontinue\\n\\t\\t\\t}\\n\\t\\t\\tbase := 33333\\n\\t\\t\\tbase -= 1 * int(math.Pow10(i) + math.Pow10(j))\\n\\t\\t\\tnumbers = append(numbers, base)\\n\\t\\t}\\n\\t}\\n\\t// 6 1+5, 1+2+3, 2+4, 6\\n\\tnumbers = append(numbers, 155555, 515555, 551555, 555155, 555515, 555551, 666666)\\n\\tfor i := 0; i < 6; i++ {\\n\\t\\tfor j := 0; j < 6; j++ {\\n\\t\\t\\tfor k := 0; k < 6; k++ {\\n\\t\\t\\t\\tif i == j || i == k || j == k {\\n\\t\\t\\t\\t\\tcontinue\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\tbase := 333333\\n\\t\\t\\t\\tbase -= 1 * int(math.Pow10(i) + math.Pow10(j))\\n\\t\\t\\t\\tbase -= 2 * int(math.Pow10(k))\\n\\t\\t\\t\\tnumbers = append(numbers, base)\\n\\t\\t\\t}\\n\\t\\t}\\n\\t}\\n    for i := 0; i < 6; i++ {\\n\\t\\tfor j := 0; j < 6; j++ {\\n\\t\\t\\tif i == j {\\n\\t\\t\\t\\tcontinue\\n\\t\\t\\t}\\n\\t\\t\\tbase := 444444\\n\\t\\t\\tbase -= 2 * int(math.Pow10(i) + math.Pow10(j))\\n\\t\\t\\tnumbers = append(numbers, base)\\n\\t\\t}\\n\\t}\\n\\tsort.Ints(numbers)\\n\\treturn numbers\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1539297,
                "title": "c-brute-force",
                "content": "```\\nclass Solution {\\npublic:\\n    int nextBeautifulNumber(int n) {\\n        for (int i = n + 1;; ++i) {\\n            if (balanced(i)) {\\n                return i;\\n            }\\n        }\\n        \\n        return -1;\\n    }\\n    \\n    bool balanced(int n) {\\n        int cnt[9] = {0};\\n        \\n        while (n > 0) {\\n            int r = n % 10;\\n            \\n            if (r == 0) {\\n                return false;\\n            }\\n            \\n            ++cnt[r - 1];\\n            n /= 10;\\n        }\\n        \\n        for (int i = 1; i <= 9; ++i) {\\n            if (cnt[i - 1] > 0 && cnt[i - 1] != i) {\\n                return false;\\n            }\\n        }\\n        \\n        return true;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int nextBeautifulNumber(int n) {\\n        for (int i = n + 1;; ++i) {\\n            if (balanced(i)) {\\n                return i;\\n            }\\n        }\\n        \\n        return -1;\\n    }\\n    \\n    bool balanced(int n) {\\n        int cnt[9] = {0};\\n        \\n        while (n > 0) {\\n            int r = n % 10;\\n            \\n            if (r == 0) {\\n                return false;\\n            }\\n            \\n            ++cnt[r - 1];\\n            n /= 10;\\n        }\\n        \\n        for (int i = 1; i <= 9; ++i) {\\n            if (cnt[i - 1] > 0 && cnt[i - 1] != i) {\\n                return false;\\n            }\\n        }\\n        \\n        return true;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1539091,
                "title": "a-python3-solution-easy-to-understand",
                "content": "To check all numbers which is greater than n, unitl the number meets the condition.\\n\\n\\t```\\n    def nextBeautifulNumber(self, n: int) -> int:\\n        isBalanced = False\\n        for i in range(n+1,10**7+1):\\n            string_i = str(i)\\n            d = Counter(string_i)    # store the frequency of each digit in current number\\n            isBalanced = True\\n            for key in d:\\n                if int(key) != d[key]:\\n                    isBalanced = False\\n                    break\\n            if isBalanced == True:\\n                return i\\n\\t```",
                "solutionTags": [],
                "code": "```\\n    def nextBeautifulNumber(self, n: int) -> int:\\n        isBalanced = False\\n        for i in range(n+1,10**7+1):\\n            string_i = str(i)\\n            d = Counter(string_i)    # store the frequency of each digit in current number\\n            isBalanced = True\\n            for key in d:\\n                if int(key) != d[key]:\\n                    isBalanced = False\\n                    break\\n            if isBalanced == True:\\n                return i\\n\\t```",
                "codeTag": "Python3"
            },
            {
                "id": 1539036,
                "title": "python3-bruteforce-solution",
                "content": "```\\nclass Solution:\\n    def nextBeautifulNumber(self, n: int) -> int:\\n        def valid(x):\\n            cnt = [0] * 10\\n            while x:\\n                cnt[x % 10] += 1\\n                x //= 10\\n            for i in range(10):\\n                if cnt[i] != i and cnt[i] != 0:\\n                    return False\\n            return True\\n        for i in range(n + 1, 10 ** 7):\\n            if valid(i):\\n                return i\\n        return -1\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def nextBeautifulNumber(self, n: int) -> int:\\n        def valid(x):\\n            cnt = [0] * 10\\n            while x:\\n                cnt[x % 10] += 1\\n                x //= 10\\n            for i in range(10):\\n                if cnt[i] != i and cnt[i] != 0:\\n                    return False\\n            return True\\n        for i in range(n + 1, 10 ** 7):\\n            if valid(i):\\n                return i\\n        return -1\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1538918,
                "title": "python-40ms-very-fast-but-somewhat-long-code",
                "content": "```\\nclass Solution:\\n    def nextBeautifulNumber(self, n: int) -> int:\\n        possible_nums = [1,2,3,4,5,6,7,8,9]\\n        val = list([int(x) for x in str(n)])\\n        possible_nums = [x for x in possible_nums if x <= len(val)+1] ## eliminate values more than one length ahead\\n        tot_nums = len(val)\\n        best_ans = [int((len(val)+1)*str(len(val)+1))] ### set default best answer \\n        \\n        ### calculate possible permutations at certain length\\n        possible_combos = []\\n        def calc_combos(num, so_far):\\n            if num == 0:\\n                possible_combos.append(list(so_far))\\n            else:\\n                so_far_set = set(so_far)\\n                for val in possible_nums:\\n                    if num-val >= 0 and val not in so_far_set:\\n                        calc_combos(num-val,so_far + [val]*val)\\n        \\n        ### we calculate for same length as n\\n        calc_combos(tot_nums,[])\\n        \\n        def same_length_compare(i,numbers,curr_val,already_ahead):\\n            if not numbers and curr_val > n:\\n                best_ans[0] = min(curr_val,best_ans[0])\\n            elif curr_val < best_ans[0]:\\n                if already_ahead:\\n                    numbers = sorted(numbers)\\n                    y = int(\"\".join([str(x) for x in numbers]))\\n                    best_ans[0] = min(best_ans[0],curr_val*10**(len(numbers))+y)\\n                else:\\n                    for x in set(numbers):\\n                        if x == val[i]:\\n                            y = numbers.pop(numbers.index(x))\\n                            same_length_compare(i+1,numbers,curr_val*10+y,already_ahead)\\n                            numbers.append(y)\\n                        elif x > val[i]:\\n                            y = numbers.pop(numbers.index(x))\\n                            same_length_compare(i+1,numbers,curr_val*10+y,True)\\n                            numbers.append(y)\\n                            \\n        for vals in possible_combos:\\n            same_length_compare(0,vals,0,False)\\n            \\n        if best_ans[0] < int((len(val)+1)*str(len(val)+1)): ## this means we found something\\n            return best_ans[0]\\n        else:\\n            ### now we do same routine with num+1\\n            possible_combos = []\\n            calc_combos(tot_nums+1,[])\\n            ## only need to sort on these because want the lowest number with one extra digit\\n            for vals in sorted(possible_combos):\\n                return int(\"\".join([str(x) for x in vals]))",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def nextBeautifulNumber(self, n: int) -> int:\\n        possible_nums = [1,2,3,4,5,6,7,8,9]\\n        val = list([int(x) for x in str(n)])\\n        possible_nums = [x for x in possible_nums if x <= len(val)+1] ## eliminate values more than one length ahead\\n        tot_nums = len(val)\\n        best_ans = [int((len(val)+1)*str(len(val)+1))] ### set default best answer \\n        \\n        ### calculate possible permutations at certain length\\n        possible_combos = []\\n        def calc_combos(num, so_far):\\n            if num == 0:\\n                possible_combos.append(list(so_far))\\n            else:\\n                so_far_set = set(so_far)\\n                for val in possible_nums:\\n                    if num-val >= 0 and val not in so_far_set:\\n                        calc_combos(num-val,so_far + [val]*val)\\n        \\n        ### we calculate for same length as n\\n        calc_combos(tot_nums,[])\\n        \\n        def same_length_compare(i,numbers,curr_val,already_ahead):\\n            if not numbers and curr_val > n:\\n                best_ans[0] = min(curr_val,best_ans[0])\\n            elif curr_val < best_ans[0]:\\n                if already_ahead:\\n                    numbers = sorted(numbers)\\n                    y = int(\"\".join([str(x) for x in numbers]))\\n                    best_ans[0] = min(best_ans[0],curr_val*10**(len(numbers))+y)\\n                else:\\n                    for x in set(numbers):\\n                        if x == val[i]:\\n                            y = numbers.pop(numbers.index(x))\\n                            same_length_compare(i+1,numbers,curr_val*10+y,already_ahead)\\n                            numbers.append(y)\\n                        elif x > val[i]:\\n                            y = numbers.pop(numbers.index(x))\\n                            same_length_compare(i+1,numbers,curr_val*10+y,True)\\n                            numbers.append(y)\\n                            \\n        for vals in possible_combos:\\n            same_length_compare(0,vals,0,False)\\n            \\n        if best_ans[0] < int((len(val)+1)*str(len(val)+1)): ## this means we found something\\n            return best_ans[0]\\n        else:\\n            ### now we do same routine with num+1\\n            possible_combos = []\\n            calc_combos(tot_nums+1,[])\\n            ## only need to sort on these because want the lowest number with one extra digit\\n            for vals in sorted(possible_combos):\\n                return int(\"\".join([str(x) for x in vals]))",
                "codeTag": "Java"
            },
            {
                "id": 1538903,
                "title": "python-3-brute-force",
                "content": "```\\nclass Solution:\\n    def nextBeautifulNumber(self, n: int) -> int:\\n        \\n        def extractAndVerify(i):\\n            d=collections.defaultdict(int)\\n            while i:\\n                dig=i%10\\n                i=i//10\\n                d[dig]+=1\\n            for dig,count in d.items():\\n                if d[dig]!=dig:\\n                    return False\\n            return True\\n        \\n        j=n+1\\n        while True:\\n            if extractAndVerify(j):\\n                return j\\n            j+=1\\n        return -1\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def nextBeautifulNumber(self, n: int) -> int:\\n        \\n        def extractAndVerify(i):\\n            d=collections.defaultdict(int)\\n            while i:\\n                dig=i%10\\n                i=i//10\\n                d[dig]+=1\\n            for dig,count in d.items():\\n                if d[dig]!=dig:\\n                    return False\\n            return True\\n        \\n        j=n+1\\n        while True:\\n            if extractAndVerify(j):\\n                return j\\n            j+=1\\n        return -1\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1538876,
                "title": "python-cheating",
                "content": "```python\\nclass Solution:    \\n    def nextBeautifulNumber(self, n: int) -> int:\\n        nums = [1, 22, 122, 212, 221, 333, 1333, 3133, 3313, 3331, 4444, 14444, 22333, 23233, 23323, 23332, 32233, 32323, 32332, 33223, 33232, 33322, 41444, 44144, 44414, 44441, 55555, 122333, 123233, 123323, 123332, 132233, 132323, 132332, 133223, 133232, 133322, 155555, 212333, 213233, 213323, 213332, 221333, 223133, 223313, 223331, 224444, 231233, 231323, 231332, 232133, 232313, 232331, 233123, 233132, 233213, 233231, 233312, 233321, 242444, 244244, 244424, 244442, 312233, 312323, 312332, 313223, 313232, 313322, 321233, 321323, 321332, 322133, 322313, 322331, 323123, 323132, 323213, 323231, 323312, 323321, 331223, 331232, 331322, 332123, 332132, 332213, 332231, 332312, 332321, 333122, 333212, 333221, 422444, 424244, 424424, 424442, 442244, 442424, 442442, 444224, 444242, 444422, 515555, 551555, 555155, 555515, 555551, 666666, 1224444]\\n        \\n        index = bisect_left(nums, n)        \\n        return nums[index] if nums[index] != n else nums[index + 1]\\n```",
                "solutionTags": [],
                "code": "```python\\nclass Solution:    \\n    def nextBeautifulNumber(self, n: int) -> int:\\n        nums = [1, 22, 122, 212, 221, 333, 1333, 3133, 3313, 3331, 4444, 14444, 22333, 23233, 23323, 23332, 32233, 32323, 32332, 33223, 33232, 33322, 41444, 44144, 44414, 44441, 55555, 122333, 123233, 123323, 123332, 132233, 132323, 132332, 133223, 133232, 133322, 155555, 212333, 213233, 213323, 213332, 221333, 223133, 223313, 223331, 224444, 231233, 231323, 231332, 232133, 232313, 232331, 233123, 233132, 233213, 233231, 233312, 233321, 242444, 244244, 244424, 244442, 312233, 312323, 312332, 313223, 313232, 313322, 321233, 321323, 321332, 322133, 322313, 322331, 323123, 323132, 323213, 323231, 323312, 323321, 331223, 331232, 331322, 332123, 332132, 332213, 332231, 332312, 332321, 333122, 333212, 333221, 422444, 424244, 424424, 424442, 442244, 442424, 442442, 444224, 444242, 444422, 515555, 551555, 555155, 555515, 555551, 666666, 1224444]\\n        \\n        index = bisect_left(nums, n)        \\n        return nums[index] if nums[index] != n else nums[index + 1]\\n```",
                "codeTag": "Java"
            }
        ],
        "discussions": [
            {
                "id": 1575901,
                "content": [
                    {
                        "username": "akshay3213",
                        "content": "I think this problem can be solved using **Digit DP**.\\n\\nJust giving a idea here.If someone has grip in Digit Dp then please consider this and approach this problem.\\n\\nIf you think this can\\'t be solved using Digit Dp , please enlighten me.\\n\\nThanks..\\n"
                    },
                    {
                        "username": "user5642Tf",
                        "content": "class Solution {\\n    public int nextBeautifulNumber(int n) {\\n\\n        int x = n+1;\\n        while(!isBalanced(x)){\\n            x++;\\n        }\\n\\n        return x;\\n\\n    }\\n\\n    public boolean isBalanced(int x){\\n        int temp = x;\\n        int[] size = new int[10];\\n        Arrays.fill(size, 0);\\n\\n        while(temp != 0){\\n            size[temp%10] += 1;\\n            if(size[temp%10] > temp%10){\\n                return false;\\n            }\\n            temp = temp/10;\\n        }\\n        for(int i=0; i<size.length; i++){\\n            if(size[i] !=0 && size[i] != i){\\n                return false;\\n            }\\n        }\\n        return true;\\n    }\\n\\n}"
                    }
                ]
            },
            {
                "id": 1796051,
                "content": [
                    {
                        "username": "akshay3213",
                        "content": "I think this problem can be solved using **Digit DP**.\\n\\nJust giving a idea here.If someone has grip in Digit Dp then please consider this and approach this problem.\\n\\nIf you think this can\\'t be solved using Digit Dp , please enlighten me.\\n\\nThanks..\\n"
                    },
                    {
                        "username": "user5642Tf",
                        "content": "class Solution {\\n    public int nextBeautifulNumber(int n) {\\n\\n        int x = n+1;\\n        while(!isBalanced(x)){\\n            x++;\\n        }\\n\\n        return x;\\n\\n    }\\n\\n    public boolean isBalanced(int x){\\n        int temp = x;\\n        int[] size = new int[10];\\n        Arrays.fill(size, 0);\\n\\n        while(temp != 0){\\n            size[temp%10] += 1;\\n            if(size[temp%10] > temp%10){\\n                return false;\\n            }\\n            temp = temp/10;\\n        }\\n        for(int i=0; i<size.length; i++){\\n            if(size[i] !=0 && size[i] != i){\\n                return false;\\n            }\\n        }\\n        return true;\\n    }\\n\\n}"
                    }
                ]
            }
        ]
    }
]