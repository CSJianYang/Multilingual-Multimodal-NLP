[
    {
        "title": "Number of Good Pairs",
        "question_content": "Given an array of integers nums, return the number of good pairs.\nA pair (i, j) is called good if nums[i] == nums[j] and i < j.\n&nbsp;\nExample 1:\n\nInput: nums = [1,2,3,1,1,3]\nOutput: 4\nExplanation: There are 4 good pairs (0,3), (0,4), (3,4), (2,5) 0-indexed.\n\nExample 2:\n\nInput: nums = [1,1,1,1]\nOutput: 6\nExplanation: Each pair in the array are good.\n\nExample 3:\n\nInput: nums = [1,2,3]\nOutput: 0\n\n&nbsp;\nConstraints:\n\n\t1 <= nums.length <= 100\n\t1 <= nums[i] <= 100",
        "solutions": [
            {
                "id": 731561,
                "title": "java-c-python-count",
                "content": "## **Explanation**\\n`count` the occurrence of the same elements.\\nFor each new element `a`,\\nthere will be more `count[a]` pairs,\\nwith `A[i] == A[j]` and `i < j`\\n<br>\\n\\n## **Complexity**\\nTime `O(N)`\\nSpace `O(N)`\\n<br>\\n\\n**Java:**\\n```java\\n    public int numIdenticalPairs(int[] A) {\\n        int res = 0, count[] = new int[101];\\n        for (int a: A) {\\n            res += count[a]++;\\n        }\\n        return res;\\n    }\\n```\\n\\n**C++:**\\n```cpp\\n    int numIdenticalPairs(vector<int>& A) {\\n        int res = 0;\\n        unordered_map<int, int> count;\\n        for (int a: A) {\\n            res += count[a]++;\\n        }\\n        return res;\\n    }\\n```\\n**C++**\\n1-line from @generationx2020\\n```cpp\\n    int numIdenticalPairs(vector<int>& A) {\\n        return accumulate(A.begin(), A.end(), 0, [count = unordered_map<int, int> {}] (auto a, auto b) mutable {\\n            return a + count[b]++;\\n        });\\n    }\\n```\\n**Python:**\\n```py\\n    def numIdenticalPairs(self, A):\\n        return sum(k * (k - 1) / 2 for k in collections.Counter(A).values())\\n```\\n",
                "solutionTags": [],
                "code": "```java\\n    public int numIdenticalPairs(int[] A) {\\n        int res = 0, count[] = new int[101];\\n        for (int a: A) {\\n            res += count[a]++;\\n        }\\n        return res;\\n    }\\n```\n```cpp\\n    int numIdenticalPairs(vector<int>& A) {\\n        int res = 0;\\n        unordered_map<int, int> count;\\n        for (int a: A) {\\n            res += count[a]++;\\n        }\\n        return res;\\n    }\\n```\n```cpp\\n    int numIdenticalPairs(vector<int>& A) {\\n        return accumulate(A.begin(), A.end(), 0, [count = unordered_map<int, int> {}] (auto a, auto b) mutable {\\n            return a + count[b]++;\\n        });\\n    }\\n```\n```py\\n    def numIdenticalPairs(self, A):\\n        return sum(k * (k - 1) / 2 for k in collections.Counter(A).values())\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 1457646,
                "title": "java-story-based-0ms-single-pass-easy-to-understand-simple-hashmap",
                "content": "\\n# HANDSHAKES IN GATHERING\\n\\n# **YOU ALL CAN BUY ME A ******BEER \\uD83C\\uDF7A****** AT \\uD83D\\uDC47**\\n\\n**https://www.buymeacoffee.com/deepakgupta**\\n\\nImagine this problem like, There is a gathering organized by some guy, the guest list is [1,2,3,1,1,3].\\nThe problem with the guest is they only handshake with like minded people. (Like minded here is basically the digit should be same , for example, 1 will handshake with 1 only, 2 will handshake with 2 only and so on)\\n\\n\\n\\n**So, finally we just need to count number of handshakes in the gathering. \\uD83D\\uDCAF \\uD83D\\uDCAF**\\n\\n(To distinguish , multiple 1\\'s and 3\\'s , a,b,c,d... letters are used)\\n\\n**\\uD83D\\uDD25 the day of arrival \\uD83D\\uDD25** \\n\\none by one guests are arriving at the gathering\\n\\n\\u2705 first guest: 1\\n\\n\\u2705 second guest: 2\\n(at this moment, in gathering hall we have **1** (2 is about to enter) , since they are not like minded they wont shake hands)\\n\\n\\u2705 third guest:3\\n(at this moment, in gathering hall we have **1 ,2** (3 is about to enter), since they are not like minded they wont shake hands)\\n\\n\\u2705 fourth guest : 1\\n(at this moment, fourth guest will see in gathering hall , there is **one like minded guy** ie(1) , so he will handshake with him)\\ntherefore totalHandShake = 1\\n\\n\\u2705 fifth guest : 1\\n(at this moment, fifth guest will see in gathering hall, there are **two like minded guys** ie(1,1) , so he will handshake with them)\\ntherefore totalHandShake = 1(last handshake between 1a-1b ) + 2(current handshake between 1a-1c, 1b-1c) = 3\\n\\n\\u2705 sixth guest : 3\\n(at this moment, sixth guest will see in gathering hall, there is **one like minded guy** ie(3) , so he will handshake with him)\\ntherefore totalHandShake = 3(last handshake) + 1(3a-3b) = 4 \\n\\n\\nHere, in code we can imagine\\n\\n**given array as guest list.\\nHashmap as gathering hall\\nans as totalHandshakes.**\\n\\n# IF YOU GUYS ENJOYED THIS, PLEASE UPVOTE AND COMMENT, THIS GIVES ME HUGE MOTIVATION.\\n# **YOU ALL CAN BUY ME A BEER \\uD83C\\uDF7A AT \\uD83D\\uDC47**\\n\\n**https://www.buymeacoffee.com/deepakgupta**\\n\\n\\n\\n```\\nclass Solution {\\n    public int numIdenticalPairs(int[] guestList) {\\n        HashMap<Integer, Integer> hm = new HashMap<>();\\n        \\n        int ans = 0;\\n        \\n        for(int friend:guestList)\\n        {\\n            int friendCount = hm.getOrDefault(friend,0);\\n            ans+=friendCount;\\n            hm.put(friend,friendCount+1);\\n        }\\n        \\n        \\n        return ans;\\n    }\\n}\\n```\\n\\n**SPACE : O(N)\\nTIME   :  O(N)**\\n\\n\\n\\n\\n",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int numIdenticalPairs(int[] guestList) {\\n        HashMap<Integer, Integer> hm = new HashMap<>();\\n        \\n        int ans = 0;\\n        \\n        for(int friend:guestList)\\n        {\\n            int friendCount = hm.getOrDefault(friend,0);\\n            ans+=friendCount;\\n            hm.put(friend,friendCount+1);\\n        }\\n        \\n        \\n        return ans;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 736565,
                "title": "python-simple-o-n-solution",
                "content": "**Solution Idea**\\nThe idea is storing the number of repeated elements in a dictionary/hash table and using mathmatics to calculate the number of combinations.\\n\\n**Fundamental Math Concept (Combinations)**\\nThe \"# of pairs\" can be calculated by summing each value from range 0 to n-1, where n is the \"# of times repeated\". So the \"# of pairs\" for the 5 repeated values, would be 0+1+2+3+4 = 10.\\n\\nAnother way to think about it is:\\n\\nNotice in the table below how the number of pairs increments by adding the previous \"# of times repeated\" to the previous \"# of pairs.\"\\n\\nFor example: to get the \"# of pairs\" for 3 repeated values, you would add the previous \"# of times repeated\" (which is 2) with the previous \"# of pairs\" (which is 1). Therefore, the \"# of pairs for 3 repeated values is 2+1=3. In this method, you don\\'t peform the same computations multiple times.\\n\\nExample Table of # of repeated items with their corresponding # of pairs\\n<table>\\n\\t<tr>\\n    <th># of times repeated</th>\\n    <th># of pairs</th>\\n  </tr>\\n  <tr>\\n    <td>2</td>\\n    <td>1</td>\\n  </tr>\\n  <tr>\\n    <td>3</td>\\n    <td>3</td>\\n  </tr>\\n  <tr>\\n    <td>4</td>\\n    <td>6</td>\\n  </tr>\\n  <tr>\\n    <td>5</td>\\n    <td>10</td>\\n  </tr>\\n  <tr>\\n    <td>6</td>\\n    <td>15</td>\\n  </tr>\\n</table>\\n\\n**My Code Solution**\\n1. Dictionary/Hash Table to store the number of times an element is repeated\\n2. Record total number of pairs (num)\\n3. Iterate through the nums list\\n4. Check to see if each element has already been seen, if not add it to the Hash Table\\n5. If it has been seen, but only once, just add 1 to \"num\"\\n6. If it has been seen, multiple times. Add the number of repeated times to \"num\"\\n7. Increment the number of reapeated times by 1.\\n7. Move onto next element\\n\\n```\\nclass Solution:\\n    \\n    # search for duplicate numbers\\n    def numIdenticalPairs(self, nums: List[int]) -> int:\\n        \\n        # number of good pairs\\n        repeat = {}\\n        num = 0\\n        \\n        # for every element in nums\\n        for v in nums:\\n            \\n            # number of repeated digits\\n            if v in repeat:\\n                \\n                # count number of pairs based on duplicate values\\n                if repeat[v] == 1:\\n                    num += 1\\n                else:\\n                    num += repeat[v]\\n                \\n                # increment the number of counts\\n                repeat[v] += 1\\n            # number has not been seen before\\n            else:\\n                repeat[v] = 1\\n        # return\\n        return num\\n```",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Hash Table",
                    "Math"
                ],
                "code": "```\\nclass Solution:\\n    \\n    # search for duplicate numbers\\n    def numIdenticalPairs(self, nums: List[int]) -> int:\\n        \\n        # number of good pairs\\n        repeat = {}\\n        num = 0\\n        \\n        # for every element in nums\\n        for v in nums:\\n            \\n            # number of repeated digits\\n            if v in repeat:\\n                \\n                # count number of pairs based on duplicate values\\n                if repeat[v] == 1:\\n                    num += 1\\n                else:\\n                    num += repeat[v]\\n                \\n                # increment the number of counts\\n                repeat[v] += 1\\n            # number has not been seen before\\n            else:\\n                repeat[v] = 1\\n        # return\\n        return num\\n```",
                "codeTag": "Java"
            },
            {
                "id": 733540,
                "title": "java-100-faster-100-space-easy-solution",
                "content": "Method - 1: We can use two for loops and check is <b> nums[i] = nums[j] </b> and i < j and simply increase count by one every time. I think it will give error of time limit exceeded.\\n\\nMethod - 2 : First we can count the frequency of each numbers using array. If a number appears n times, then n * (n \\u2013 1) / 2 pairs can be made with this number.\\n\\n```\\nclass Solution {\\n    public int numIdenticalPairs(int[] nums) {\\n        \\n        int ans = 0;\\n        int[] count = new int[101];\\n        \\n        for(int n: nums)\\n            count[n]++;\\n        \\n        for(int n: count)\\n            ans += (n * (n - 1))/2;\\n        \\n        return ans;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int numIdenticalPairs(int[] nums) {\\n        \\n        int ans = 0;\\n        int[] count = new int[101];\\n        \\n        for(int n: nums)\\n            count[n]++;\\n        \\n        for(int n: count)\\n            ans += (n * (n - 1))/2;\\n        \\n        return ans;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 749025,
                "title": "python-o-n-simple-dictionary-solution",
                "content": "```\\nclass Solution:\\n    def numIdenticalPairs(self, nums: List[int]) -> int:\\n        hashMap = {}\\n        res = 0\\n        for number in nums:            \\n            if number in hashMap:\\n                res += hashMap[number]\\n                hashMap[number] += 1\\n            else:\\n                hashMap[number] = 1\\n        return res\\n```\\n\\n- If the value already exists in the hashMap that means the number of new pairs is equal to the frequency since the current value can be paired with each prior occurrence . \\n",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def numIdenticalPairs(self, nums: List[int]) -> int:\\n        hashMap = {}\\n        res = 0\\n        for number in nums:            \\n            if number in hashMap:\\n                res += hashMap[number]\\n                hashMap[number] += 1\\n            else:\\n                hashMap[number] = 1\\n        return res\\n```",
                "codeTag": "Java"
            },
            {
                "id": 731571,
                "title": "java-hashmap-o-n",
                "content": "for each i, finds all j where, j < i &&  nums[j] == nums[i];\\n```\\n    public int numIdenticalPairs(int[] nums) {\\n        int res = 0;\\n        Map<Integer, Integer> map = new HashMap<>();\\n        for (int n : nums) {\\n            map.put(n, map.getOrDefault(n, 0) + 1);\\n            res += map.get(n) - 1;  // addtional pair can be formed btw n and all previous v == n;\\n        }\\n        return res;\\n    }\\n```",
                "solutionTags": [],
                "code": "```\\n    public int numIdenticalPairs(int[] nums) {\\n        int res = 0;\\n        Map<Integer, Integer> map = new HashMap<>();\\n        for (int n : nums) {\\n            map.put(n, map.getOrDefault(n, 0) + 1);\\n            res += map.get(n) - 1;  // addtional pair can be formed btw n and all previous v == n;\\n        }\\n        return res;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 731624,
                "title": "c-java-o-n",
                "content": "We can just count each value. Then, `n` elements with the same value can form `n * (n - 1) / 2` pairs.\\n\\n> Why? The first element forms `n - 1` pairs, the second - `n - 2` pairs and so on. So the sum of the [1, n - 1] progression is `n * (n - 1) / 2`.\\n\\n**C++**\\n```cpp\\nint numIdenticalPairs(vector<int>& nums) {\\n    int cnt[101] = {};\\n    for (auto n: nums)\\n        ++cnt[n];\\n    return accumulate(begin(cnt), end(cnt), 0, [](int s, int i)\\n        { return s + i * (i - 1) / 2; });\\n}\\n```\\n**Java**\\n```java\\npublic int numIdenticalPairs(int[] nums) {\\n    int cnt[] = new int[101], res = 0;\\n    for (var n: nums)\\n        ++cnt[n];\\n    for (int i = 0; i <= 100; ++i)\\n        res += cnt[i] * (cnt[i] - 1) / 2;\\n    return res;     \\n}\\n```\\n\\nWe can also simplify the logic a bit by combining the counting and progression.\\n\\n**C++**\\n```cpp\\nint numIdenticalPairs(vector<int>& nums) {\\n    int cnt[101] = {}, res = 0;\\n    for (auto n: nums)\\n        res += cnt[n]++;\\n    return res;\\n}\\n```\\n\\n**Java**\\n```java\\npublic int numIdenticalPairs(int[] nums) {\\n    int cnt[] = new int[101], res = 0;\\n    for (var n: nums)\\n        res += cnt[n]++;\\n    return res;\\n}\\n```",
                "solutionTags": [],
                "code": "```cpp\\nint numIdenticalPairs(vector<int>& nums) {\\n    int cnt[101] = {};\\n    for (auto n: nums)\\n        ++cnt[n];\\n    return accumulate(begin(cnt), end(cnt), 0, [](int s, int i)\\n        { return s + i * (i - 1) / 2; });\\n}\\n```\n```java\\npublic int numIdenticalPairs(int[] nums) {\\n    int cnt[] = new int[101], res = 0;\\n    for (var n: nums)\\n        ++cnt[n];\\n    for (int i = 0; i <= 100; ++i)\\n        res += cnt[i] * (cnt[i] - 1) / 2;\\n    return res;     \\n}\\n```\n```cpp\\nint numIdenticalPairs(vector<int>& nums) {\\n    int cnt[101] = {}, res = 0;\\n    for (auto n: nums)\\n        res += cnt[n]++;\\n    return res;\\n}\\n```\n```java\\npublic int numIdenticalPairs(int[] nums) {\\n    int cnt[] = new int[101], res = 0;\\n    for (var n: nums)\\n        res += cnt[n]++;\\n    return res;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 911686,
                "title": "clean-javascript-solution",
                "content": "```\\n// time O(N^2) space O(1)\\n var numIdenticalPairs = function(nums) {\\n     let count = 0\\n    \\n     for(let i=0; i<nums.length; i++) {\\n         for(let j=i+1; j<nums.length; j++) {\\n             if(nums[i] === nums[j]) {\\n                 count++\\n             }\\n         }\\n     }\\n    \\n     return count\\n };\\n```\\n\\n```\\n// time O(N) space O(N)\\nvar numIdenticalPairs = function(nums) {\\n    const map = {}\\n    let count = 0\\n    \\n    for (const number of nums) {\\n        if (map[number]) {\\n            count += map[number];\\n            map[number] += 1;\\n        } else {\\n            map[number] = 1;\\n        }\\n    }\\n    return count\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n// time O(N^2) space O(1)\\n var numIdenticalPairs = function(nums) {\\n     let count = 0\\n    \\n     for(let i=0; i<nums.length; i++) {\\n         for(let j=i+1; j<nums.length; j++) {\\n             if(nums[i] === nums[j]) {\\n                 count++\\n             }\\n         }\\n     }\\n    \\n     return count\\n };\\n```\n```\\n// time O(N) space O(N)\\nvar numIdenticalPairs = function(nums) {\\n    const map = {}\\n    let count = 0\\n    \\n    for (const number of nums) {\\n        if (map[number]) {\\n            count += map[number];\\n            map[number] += 1;\\n        } else {\\n            map[number] = 1;\\n        }\\n    }\\n    return count\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1202414,
                "title": "weeb-explains-python-beats-97-65",
                "content": "![image](https://assets.leetcode.com/users/images/6a27264b-cfe3-42e3-92e0-bfcee79d7d1e_1620717462.3697262.png)\\nfirst try btw and its already 97%\\n\\nOkay, my code looks weird at first glance but its actually pretty easy, just plug in the formula for quadratic sequence\\n\\t\\n\\tclass Solution:\\n\\t\\tdef numIdenticalPairs(self, nums: List[int]) -> int:\\n\\t\\t\\tnums, memo = sorted(nums), {} # sort to get the total number of digits that have duplicates\\n\\t\\t\\tfor i in range(len(nums)-1): # lets say nums = [1,1,1,1,2,2,2,3] the total digits with duplicates is 7\\n\\t\\t\\t\\tif nums[i] == nums[i+1]: # because nums has 4 ones and 3 twos so it adds up to 7\\n\\t\\t\\t\\t\\tif nums[i] not in memo: # 3 is not counted because there are no duplicates of it\\n\\t\\t\\t\\t\\t\\tmemo[nums[i]] = 1\\n\\t\\t\\t\\t\\tmemo[nums[i]] = memo[nums[i]] + 1 \\n\\t\\t\\t# nums = [1,1,1,1,2,2,2,3]\\n\\t\\t\\t# so now memo = {1 : 4, 2: 3} which means we have 4 ones and 3 twos\\n\\t\\t\\tanswer = 0\\n\\t\\t\\tfor n in memo.values(): # this is the hard part, please refer to my beautiful drawing to understand this\\n\\t\\t\\t\\tanswer += (n**2 - n)//2 # after looking at the drawing, we repeat with each n value in memo\\n\\n\\t\\t\\treturn answer\\n\\n![image](https://assets.leetcode.com/users/images/62dfbc6c-2157-4b97-bebb-aa4cc1978ac6_1620719423.0946832.png)\\n![image](https://assets.leetcode.com/users/images/d3bba77d-366c-4380-a2e6-8e6844184e97_1620719531.481281.png)\\n\\nDamn, this took some time to do, please give me an upvote if u find it helpful\\n\\nAnways, i want to recommend an anime called **Karakai Jouzu no Takagi-san(Teasing Master Takagi-san)**\\n\\n# Episodes: 24 + 1 OVA\\n# Genres: Romantic comedy, Slice of life\\n\\nI love this anime, its wholesome so go check it out!\\n",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "class Solution:\\n\\t\\tdef numIdenticalPairs(self, nums: List[int]) -> int:\\n\\t\\t\\tnums, memo = sorted(nums), {}",
                "codeTag": "Java"
            },
            {
                "id": 939461,
                "title": "java-1-pass-one-pass-solution-intuitive-explanation",
                "content": "**1512. Number of Good Pairs**\\n```\\nclass Solution {\\n    public int numIdenticalPairs(int[] nums) {\\n        HashMap<Integer,Integer> map = new HashMap<Integer,Integer>();\\n        int answer = 0;\\n        for(int i: nums){\\n            if(map.containsKey(i)){ // if number has occurred before\\n                int temp = map.get(i);\\n                answer += temp; // add number of occurrences to the answer\\n                map.put(i,temp+1); // increment number of occurrences\\n            } else {\\n                map.put(i,1); // if it is the first time, add it to the map\\n            }\\n        }\\n        return answer;\\n    }\\n}\\n```\\n**PROBLEM OVERVIEW**\\nThe basic premise of the prolem is to find of many times nums[i] == nums[j], where j > i\\nWe are esentially tasked with finding the number of repeats after first occurence of each number.\\n\\n**ASSESSING SOLUTIONS**\\nA hashmap is great for this solution as we can looop through the array of numbers and have 1 of 2 states:\\n\\n*  if it exists, then add the number of currently stores and subsequently increment it\\n* otherwise, set that value as 1 (it exists)\\n\\nThe code is O(n), as it iterates through the entire array\\n\\n**EXPLANATIONS**\\nHere\\'s a way to visualize it. If I have [1,1], then there is only **1** \"good pair,\" which is the first and second 1. **(0+1 = 1)**\\nIf I have [1,1,1] then there are **3** \"good pairs\" ([first,second], [second,third,], [first,third]). **The first 1 has 0 pairs, the second 1 has 1 pair, and the third 1 has 2 pairs. (0+1+2 = 3)!**\\nLikeswise for [1,1,1,1] there are **6** \"good pairs\" **(0+1+2+3 = 6)**\\n\\nFrom this, we can conclude the pattern is **for every subsequent repeat of a number, the number of combinations increases by the current number of appearances of that number.**\\n\\nIn the code, we demonstrate this by incrementing the value in the map by one everytime, signaling the next occurence to add to \"answers\" one more combination than before.",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int numIdenticalPairs(int[] nums) {\\n        HashMap<Integer,Integer> map = new HashMap<Integer,Integer>();\\n        int answer = 0;\\n        for(int i: nums){\\n            if(map.containsKey(i)){ // if number has occurred before\\n                int temp = map.get(i);\\n                answer += temp; // add number of occurrences to the answer\\n                map.put(i,temp+1); // increment number of occurrences\\n            } else {\\n                map.put(i,1); // if it is the first time, add it to the map\\n            }\\n        }\\n        return answer;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 731808,
                "title": "simplest-c-explanation-o-n2-and-o-n",
                "content": "\\n**O(n2)** [100% less memory usage] [75% less time usage]\\n```\\nint numIdenticalPairs(vector<int>& nums) {\\n\\tint counter = 0;\\n\\tfor(int i=0;i<nums.size()-1;++i)\\n\\t  for(int j=i+1;j<nums.size();++j)\\n\\t\\tif(nums[i]==nums[j]) counter++;\\n\\treturn counter;\\n}\\n```\\n\\n\\n**O(n)** [100% less memory usage] [100% less time usage]\\n```\\nint numIdenticalPairs(vector<int>& nums) {\\n\\tint count[101] = {};\\n\\tfor (auto n: nums)\\n\\t\\t++count[n];\\n\\treturn accumulate(begin(count), end(count), 0, [](int s, int i)\\n\\t\\t{ return s + i * (i - 1) / 2; });\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nint numIdenticalPairs(vector<int>& nums) {\\n\\tint counter = 0;\\n\\tfor(int i=0;i<nums.size()-1;++i)\\n\\t  for(int j=i+1;j<nums.size();++j)\\n\\t\\tif(nums[i]==nums[j]) counter++;\\n\\treturn counter;\\n}\\n```\n```\\nint numIdenticalPairs(vector<int>& nums) {\\n\\tint count[101] = {};\\n\\tfor (auto n: nums)\\n\\t\\t++count[n];\\n\\treturn accumulate(begin(count), end(count), 0, [](int s, int i)\\n\\t\\t{ return s + i * (i - 1) / 2; });\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 822102,
                "title": "python-99-27-o-n-easy-to-understand-its-math",
                "content": "Because pairs are only created if **nums[i] == nums[j]** and i < j, we can infer a arithmethic sequence from this condition. \\n\\nA hint was also given from the examples:\\n[1,1,1,1] have 6 combination\\nThe first 1 have 3 pairs\\nThe second 1 have 2 pairs\\nThe third 1 have 1 pairs\\nHence for 4 of 1\\'s, we can have 3 + 2 + 1 combination\\n\\nThen we just have to store every value count and then count arithmetic sequence sum from 1 to n, given n is the number of appearance for each number.\\n\\nPlease star it if you like my solution and explanation :), any advice or correction would be appreciated.\\n\\nThanks !\\n\\n```\\ndef numIdenticalPairs(self, nums: List[int]) -> int:\\n        pairs = 0\\n        d = {}\\n        for i in nums:\\n            if i in d:\\n                d[i] += 1\\n            else:\\n                d[i] = 1\\n        for num in d:\\n            val = d[num]\\n            for i in range(val):\\n                pairs += i\\n        return pairs\\n\\t```",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Math"
                ],
                "code": "```\\ndef numIdenticalPairs(self, nums: List[int]) -> int:\\n        pairs = 0\\n        d = {}\\n        for i in nums:\\n            if i in d:\\n                d[i] += 1\\n            else:\\n                d[i] = 1\\n        for num in d:\\n            val = d[num]\\n            for i in range(val):\\n                pairs += i\\n        return pairs\\n\\t```",
                "codeTag": "Python3"
            },
            {
                "id": 737778,
                "title": "c-speed-mem-o-n-o-n-w-o-map-video",
                "content": "Since the given nums.length() <= 100, space complexity is O(n).\\nhttps://www.youtube.com/watch?v=FlFxSnK2SmY\\n```\\nclass Solution {\\npublic:\\n    int numIdenticalPairs(vector<int>& nums) {\\n        \\n        int mem[101] ={0};\\n        int sum=0;\\n        \\n        for(int i=0; i < nums.size(); i++){\\n            sum += mem[nums[i]];\\n            ++mem[nums[i]];\\n        }\\n        \\n        return sum;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int numIdenticalPairs(vector<int>& nums) {\\n        \\n        int mem[101] ={0};\\n        int sum=0;\\n        \\n        for(int i=0; i < nums.size(); i++){\\n            sum += mem[nums[i]];\\n            ++mem[nums[i]];\\n        }\\n        \\n        return sum;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 966159,
                "title": "c-single-pass-solution-explained-100-time-96-space",
                "content": "This is a nice one that can be solved trivially, but it has some more challenge if you plan on tackling it in a more optimised way. My core intuition was that for each number `n` we basically need to apply the Gaussian formula to its frequency `f`, `-1` (since numbers can\\'t form couples with themselves in this problem).\\n\\nSo, if we encounter `9` once, we have `0` pairs; twice, we have `1` pair; thrice, we have `1 + 2 == 3` pairs; four times, we have `1 + 2 + 3 == 6` pairs and so on.\\n\\nWith that in mind, we have 2 ways to skin this cat \\uD83D\\uDC08 : the first one is to add for each number the cumulative frequency of its occurrence so far.\\n\\nTo do so, we declare 2 support variables;\\n* `res` to store our ongoing total;\\n* `seen` to collect the frequency of each element (and we know that all the values will go in the `1 - 100` range, so we can just use an array with `101` elements to avoid converting them into a `0`-indexed operation).\\n\\nFor each number `n`, we will:\\n* increase `res` by its previous comulative frequency so far `seen[n]`;\\n* increase said frequency by `1` with `seen[n]++`.\\n\\nOnce done, we can return `res`.\\n\\nThe code:\\n\\n```cpp\\nclass Solution {\\npublic:\\n    int numIdenticalPairs(vector<int>& nums) {\\n        // support variables\\n        int res = 0, seen[101] = {};\\n        for (auto n: nums) {\\n            // for each occurrence, we had the previously found matches to res...\\n            res += seen[n];\\n            // ...and then we update seen \\n            seen[n]++;\\n        }\\n        return res;\\n    }\\n};\\n```\\n\\nAlternative version, which would be more perfoming with significantly longer inputs where an optimised multiplicative algorithm trumps manual sums, would do partially the same, first populating `seen` with all the relative frequencies (provided at least one element was found) and then applying the gaussian formula to them.\\n\\nInterestingly enough, this approach proved to be consistently slower and a bit more demanding in terms of memory (I guess due to how multiplications are usually computed):\\n\\n```cpp\\nclass Solution {\\npublic:\\n    int numIdenticalPairs(vector<int>& nums) {\\n        // support variables\\n        int res = 0, seen[101] = {};\\n        // populating seen with all the frequencies\\n        for (int n: nums) seen[n]++;\\n        // updating res based on the found frequencies\\n        for (int f: seen) if (f) res += f * (f - 1) / 2;\\n        return res;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Array",
                    "Counting"
                ],
                "code": "```cpp\\nclass Solution {\\npublic:\\n    int numIdenticalPairs(vector<int>& nums) {\\n        // support variables\\n        int res = 0, seen[101] = {};\\n        for (auto n: nums) {\\n            // for each occurrence, we had the previously found matches to res...\\n            res += seen[n];\\n            // ...and then we update seen \\n            seen[n]++;\\n        }\\n        return res;\\n    }\\n};\\n```\n```cpp\\nclass Solution {\\npublic:\\n    int numIdenticalPairs(vector<int>& nums) {\\n        // support variables\\n        int res = 0, seen[101] = {};\\n        // populating seen with all the frequencies\\n        for (int n: nums) seen[n]++;\\n        // updating res based on the found frequencies\\n        for (int f: seen) if (f) res += f * (f - 1) / 2;\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1080300,
                "title": "hash-table-explained-line-by-line-faster",
                "content": "Before solving the question we will keep two thing in mind.\\n1.The use of Vectors\\n2.The use of Hashing.\\n\\nHere, this question can be solved by a direct formula which we will use to find the number of good pairs.\\nThe formula is (n*(n-1))/2.\\n\\n*First we find the count of number occurences of a number. \\n*Then store the number count in the dictionary .\\n[1,2,3,1,1,3]\\n\\nkey - value pair\\n1     :         3\\n2     :         1\\n3     :         2\\n\\n*Then we consider n = value in the hash table\\n*using loop calculate the good pairs.\\n```\\n//Program to find the number of good pairs\\n//Good pairs are those in which nums[i] == nums[j] and i<j\\nclass Solution {\\npublic:\\n    int numIdenticalPairs(vector<int>& nums) \\n    {\\n   \\n        unordered_map<int,int> umap; //Initializing a Hash Table\\n         \\n        for(int i=0;i<nums.size();i++) //Iterating through the vector\\n        {\\n            ++umap[nums[i]];  //Counting the occurences of a number and storing it in value.\\n            \\n        }\\n        int good_pairs = 0;\\n        for(auto i:umap) //Using the formula \\n        {\\n            int n = i.second; //i.second implies -- value of hash table\\n            good_pairs += ((n)*(n-1))/2;\\n            \\n        }\\n        return good_pairs;\\n        \\n        \\n    }\\n};\\n    \\n```\\n\\n",
                "solutionTags": [
                    "C++",
                    "C",
                    "Hash Table"
                ],
                "code": "```\\n//Program to find the number of good pairs\\n//Good pairs are those in which nums[i] == nums[j] and i<j\\nclass Solution {\\npublic:\\n    int numIdenticalPairs(vector<int>& nums) \\n    {\\n   \\n        unordered_map<int,int> umap; //Initializing a Hash Table\\n         \\n        for(int i=0;i<nums.size();i++) //Iterating through the vector\\n        {\\n            ++umap[nums[i]];  //Counting the occurences of a number and storing it in value.\\n            \\n        }\\n        int good_pairs = 0;\\n        for(auto i:umap) //Using the formula \\n        {\\n            int n = i.second; //i.second implies -- value of hash table\\n            good_pairs += ((n)*(n-1))/2;\\n            \\n        }\\n        return good_pairs;\\n        \\n        \\n    }\\n};\\n    \\n```",
                "codeTag": "Java"
            },
            {
                "id": 975212,
                "title": "one-pass-o-n-time-using-hashmap",
                "content": "This is a basic concept of **combinations**:\\n```\\nn_C_r = n! / r! * (n-r)!\\n\\nwhere:\\nn_C_r\\t= \\tnumber of combinations\\nn\\t= \\ttotal number of objects in the set\\nr\\t= \\tnumber of choosing objects from the set\\n```\\nHere:\\n* The **set** would be with respect to a unique number at a time. (combinations for each distinct number)\\n* **n** is the number of occurences and **r = 2**, since we are choosing pairs. So replacing these values will lead to the formula: **n * (n-1)/2**\\n**Note**: Even with numbers with frequency 1 in total, the respective pairs will amount to 0 based on above formula. (Hence, 0 pairs)\\n\\n\\n# TL;DR\\n**Approach taken with an example:**\\n\\n- For a number with number of occurences count **n**, the number of good pairs would be: **n * (n-1)/2**\\n- We will consider the data structure **HashMap** that will store **key** as the number and number of occurrences as **value**.\\n\\nSo let\\'s say for array **[1,2,3,1,1,3,5,6,5]**, the Hashmap will have the following entries:\\n```\\n{\\n\\t1 : 3,\\n\\t2 : 1,\\n\\t3 : 2,\\n\\t5 : 2,\\n\\t6 : 1\\n}\\n```\\nThe required count would be: **(3 * 2/2) + (1 * 0/2) + (2 * 1/2) + (2 * 1/2) + (1 * 0/2) = 5**\\n, which is true since the good pairs are: **(0, 3), (0, 4), (3, 4), (2, 5), (6, 8)**\\n\\n**Short & Sweet:**\\n```\\nclass Solution {\\n    public int numIdenticalPairs(int[] nums) {\\n        Map<Integer, Integer> countMap = new HashMap<>();\\n        int count = 0;\\n        \\n        for(Integer num : nums)\\n            countMap.put(num, countMap.getOrDefault(num, 0) + 1);\\n        \\n        for(Integer currCount : countMap.values())\\n            count += currCount * (currCount-1)/2;\\n        \\n        return count;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nn_C_r = n! / r! * (n-r)!\\n\\nwhere:\\nn_C_r\\t= \\tnumber of combinations\\nn\\t= \\ttotal number of objects in the set\\nr\\t= \\tnumber of choosing objects from the set\\n```\n```\\n{\\n\\t1 : 3,\\n\\t2 : 1,\\n\\t3 : 2,\\n\\t5 : 2,\\n\\t6 : 1\\n}\\n```\n```\\nclass Solution {\\n    public int numIdenticalPairs(int[] nums) {\\n        Map<Integer, Integer> countMap = new HashMap<>();\\n        int count = 0;\\n        \\n        for(Integer num : nums)\\n            countMap.put(num, countMap.getOrDefault(num, 0) + 1);\\n        \\n        for(Integer currCount : countMap.values())\\n            count += currCount * (currCount-1)/2;\\n        \\n        return count;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 732910,
                "title": "my-favorite-story-in-maths-the-prince-of-mathematicians",
                "content": "https://nrich.maths.org/2478 & https://nrich.maths.org/2478\\n\\nCarl Friedrich Gauss (1777-1855) is recognised as being one of the greatest mathematicians of all time.\\n\\nThe most well-known story is a tale from when Gauss was still at primary school. One day Gauss\\' teacher asked his class to add together all the numbers from 1 to 100, assuming that this task would occupy them for quite a while. He was shocked when young Gauss, after a few seconds thought, wrote down the answer 5050. The teacher couldn\\'t understand how his pupil had calculated the sum so quickly in his head, but the eight year old Gauss pointed out that the problem was actually quite simple.\\n![image](https://assets.leetcode.com/users/images/0bdd5099-5631-40e9-b3a6-ad5b11ba2eeb_1594576169.009218.png)\\n\\nHe had added the numbers in pairs \\n1. the first and the last (1+100=101)\\n2. the second and the second to last  (2+99=101) \\n3. and so on...\\n\\nso the total would be 50 lots of 101, which is 5050.\\n\\n```python\\nclass Solution:\\n    def numIdenticalPairs(self, arr: List[int]) -> int:\\n        \\n\\t\\t#  Gauss\\'s insight as a child  ->  n(n + 1)/2\\n        def sumASeriesOfConsecutiveNumbers(n):\\n            return n*(n + 1)//2\\n        \\n        res = 0\\n        c = collections.Counter(arr)\\n        for v in c.values():\\n            res += sumASeriesOfConsecutiveNumbers(v-1)\\n        return res\\n```",
                "solutionTags": [],
                "code": "```python\\nclass Solution:\\n    def numIdenticalPairs(self, arr: List[int]) -> int:\\n        \\n\\t\\t#  Gauss\\'s insight as a child  ->  n(n + 1)/2\\n        def sumASeriesOfConsecutiveNumbers(n):\\n            return n*(n + 1)//2\\n        \\n        res = 0\\n        c = collections.Counter(arr)\\n        for v in c.values():\\n            res += sumASeriesOfConsecutiveNumbers(v-1)\\n        return res\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3341032,
                "title": "good-pairs-java-simple-solution",
                "content": "```\\nclass Solution {\\n    public int numIdenticalPairs(int[] nums) {\\n     int counter = 0;\\n\\n     for(int i = 0; i < nums.length; i++){\\n         for(int j = i+1; j < nums.length; j++){\\n             if(nums[i] == nums[j]){\\n                 counter++;\\n                }\\n            }\\n        }\\n        return counter;   \\n    }\\n}\\n```\\nplease upvote me, to nourish the child of curiosity within me!",
                "solutionTags": [
                    "Java",
                    "Array"
                ],
                "code": "```\\nclass Solution {\\n    public int numIdenticalPairs(int[] nums) {\\n     int counter = 0;\\n\\n     for(int i = 0; i < nums.length; i++){\\n         for(int j = i+1; j < nums.length; j++){\\n             if(nums[i] == nums[j]){\\n                 counter++;\\n                }\\n            }\\n        }\\n        return counter;   \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 941264,
                "title": "simple-c-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    int numIdenticalPairs(vector<int>& nums) {\\n    unordered_map<int,int> map;\\n    int res=0;\\n    for(int i:nums)\\n        res+=map[i]++;\\n    return res;\\n    }\\n};\\n```\\n\\n**Explanation:**\\n\\n[1,2,3,1,1,3]\\nconsider the above example\\n\\nres=0\\n\\n* iteration 1: map[1]=0 so res=0+0 =0 and map[1]=0+1 =1\\n* iteration 2: map[2]=0 so res=0+0 =0 and map[2]=0+1 =1\\n* iteration 3: map[3]=0 so res=0+0 =0 and map[3]=0+1 =1\\n* iteration 4: map[1]=1 so res=0+1 =1 and map[1]=1+1 =2\\n* iteration 5: map[1]=2 so res=2+1 =3 and map[1]=2+1 =3\\n* iteration 6: map[3]=1 so res=3+1 =4 and map[3]=1+1 =2\\n\\nfinally **res=4** is returned",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int numIdenticalPairs(vector<int>& nums) {\\n    unordered_map<int,int> map;\\n    int res=0;\\n    for(int i:nums)\\n        res+=map[i]++;\\n    return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1023592,
                "title": "golang-o-n-solution",
                "content": "```\\nfunc numIdenticalPairs(nums []int) int {\\n    cnt := make(map[int]int)\\n    var pairs int\\n    \\n    for _, num := range nums {\\n\\t\\tpairs += cnt[num]     //if num not in hash map \"cnt\", map returns default value of int (ie 0)\\n        cnt[num]++\\n    } \\n    return pairs\\n}\\n```",
                "solutionTags": [
                    "Go"
                ],
                "code": "```\\nfunc numIdenticalPairs(nums []int) int {\\n    cnt := make(map[int]int)\\n    var pairs int\\n    \\n    for _, num := range nums {\\n\\t\\tpairs += cnt[num]     //if num not in hash map \"cnt\", map returns default value of int (ie 0)\\n        cnt[num]++\\n    } \\n    return pairs\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 742796,
                "title": "2-lines-in-javascript-using-counter-for-o-n-brute-o-n-2",
                "content": "Short and sweet:\\n```\\nfunction numIdenticalPairs(nums) { // O(n)\\n  const map = nums.reduce((m, n, i) => m.set(n, (m.get(n)||0) + 1), new Map());\\n  return [...map.values()].reduce((num, n) => num + n * (n - 1) / 2, 0);\\n};\\n```\\n\\nFirst line, count how many times each number appears.\\n2nd line, use the `n(n-1)/2`  to get how many combinations are possible.\\n\\nThis is the intuition for the formula, if you have only one number is zero, if you have a pair is two and so on.\\n\\n1: 0\\n2: 1\\n3: 2 + 1 = 3\\n4: 3 + 2 + 1 = 6\\n5: 4 + 3 + 2 + 1 = 10\\n\\nSo of the formula to getting all natural number added up is: `n(n-1)/2`.\\n\\nAlso, you can use the brute force for O(n^2):\\n\\n```js\\nfunction numIdenticalPairs(nums) { // O(n^2)\\n\\tlet sum = 0;\\n\\tfor (let i = 0; i < nums.length; i++) {\\n\\t\\tfor (let j = i + 1; j < nums.length; j++) {\\n\\t\\t\\tif (nums[i] === nums[j]) sum++;\\n\\t\\t}\\n\\t}\\n\\treturn sum;\\n}\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\nfunction numIdenticalPairs(nums) { // O(n)\\n  const map = nums.reduce((m, n, i) => m.set(n, (m.get(n)||0) + 1), new Map());\\n  return [...map.values()].reduce((num, n) => num + n * (n - 1) / 2, 0);\\n};\\n```\n```js\\nfunction numIdenticalPairs(nums) { // O(n^2)\\n\\tlet sum = 0;\\n\\tfor (let i = 0; i < nums.length; i++) {\\n\\t\\tfor (let j = i + 1; j < nums.length; j++) {\\n\\t\\t\\tif (nums[i] === nums[j]) sum++;\\n\\t\\t}\\n\\t}\\n\\treturn sum;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 738609,
                "title": "javascript-3-solutions",
                "content": "**Brute force solution:**\\nO(N^2) time + O(1) space\\nlogic:\\n- nested loop i (start from beginning) & j (start from end)\\n- if `nums[i] === nums[j]`, increment count\\n```\\nvar numIdenticalPairs = function(nums) {\\n    let count = 0; \\n    for (let i = 0; i < nums.length; i++) {\\n        for (let j = nums.length - 1; j > i; j--) {\\n            if (nums[i] === nums[j]) count++;\\n        }\\n    }\\n    \\n    return count;\\n};\\n```\\n_____\\n**Optimized Time**\\nO(N) time + O(N) space\\nlogic: \\n- Use an object to store numbers (can also use array since this problem have constraint of `1 <= nums[i] <= 100`\\n- when new number is added to object, set 1 as value\\n- if current number already exist in object, add 1 to current value + add the value to `count`\\n```\\nvar numIdenticalPairs = function(nums) {\\n    const map = {};\\n    let count = 0;\\n    nums.forEach(num => {\\n        if (map[num]) {\\n            count += map[num];\\n            map[num]++;\\n        } else {\\n            map[num] = 1;\\n        }\\n    })\\n    return count;\\n};\\n```\\n____ \\n**Optimized Space**\\nO(NlogN) time + O(1) space\\nlogic: \\n- use sorting to sort nums (sorting takes NlogN time)\\n- have `curCount = 1`  and update it as we see same neighboring numbers in the array\\n- add `curCount` to `totalCount`\\n- reset `curCount` to 1 when neighboring numbers are not the same\\n\\n```\\nvar numIdenticalPairs = function(nums) {\\n    nums.sort();\\n    let totalCount = 0; \\n    let curCount = 1;\\n    for (let i = 1; i < nums.length; i++) {\\n        if (nums[i] === nums[i-1]) {\\n            totalCount += curCount;\\n            curCount++;\\n        } else {\\n            curCount = 1;\\n        }\\n    }\\n    \\n    return totalCount;\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\nvar numIdenticalPairs = function(nums) {\\n    let count = 0; \\n    for (let i = 0; i < nums.length; i++) {\\n        for (let j = nums.length - 1; j > i; j--) {\\n            if (nums[i] === nums[j]) count++;\\n        }\\n    }\\n    \\n    return count;\\n};\\n```\n```\\nvar numIdenticalPairs = function(nums) {\\n    const map = {};\\n    let count = 0;\\n    nums.forEach(num => {\\n        if (map[num]) {\\n            count += map[num];\\n            map[num]++;\\n        } else {\\n            map[num] = 1;\\n        }\\n    })\\n    return count;\\n};\\n```\n```\\nvar numIdenticalPairs = function(nums) {\\n    nums.sort();\\n    let totalCount = 0; \\n    let curCount = 1;\\n    for (let i = 1; i < nums.length; i++) {\\n        if (nums[i] === nums[i-1]) {\\n            totalCount += curCount;\\n            curCount++;\\n        } else {\\n            curCount = 1;\\n        }\\n    }\\n    \\n    return totalCount;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 941242,
                "title": "python-simple-solutions",
                "content": "#### Solution 1: Using count\\n\\n```\\nclass Solution:\\n    def numIdenticalPairs(self, nums: List[int]) -> int:\\n        c=0\\n        for i in range(len(nums)):\\n            c+=nums[:i].count(nums[i])\\n        return c\\n```\\n\\n#### Solution 2: Using dictionary\\n```\\nclass Solution:\\n    def numIdenticalPairs(self, nums: List[int]) -> int:\\n        d={};c=0\\n        for i in nums:\\n            if i in d:\\n                c+=d[i]\\n                d[i]+=1\\n            else:\\n                d[i]=1\\n        return c\\n```",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def numIdenticalPairs(self, nums: List[int]) -> int:\\n        c=0\\n        for i in range(len(nums)):\\n            c+=nums[:i].count(nums[i])\\n        return c\\n```\n```\\nclass Solution:\\n    def numIdenticalPairs(self, nums: List[int]) -> int:\\n        d={};c=0\\n        for i in nums:\\n            if i in d:\\n                c+=d[i]\\n                d[i]+=1\\n            else:\\n                d[i]=1\\n        return c\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1154018,
                "title": "swift-number-of-good-pairs",
                "content": "```swift\\nclass Solution {\\n    func numIdenticalPairs(_ nums: [Int]) -> Int {\\n        var res = 0, map = [Int:Int]()\\n        nums.forEach {\\n            res += map[$0] ?? 0\\n            map[$0,default: 0] += 1\\n        }\\n        return res\\n    }\\n}\\n```\\n```swift\\nimport XCTest\\n\\n// Executed 3 tests, with 0 failures (0 unexpected) in 0.031 (0.033) seconds\\n\\nclass Tests: XCTestCase {\\n    private let s = Solution()\\n    func test0() {\\n        XCTAssertEqual(s.numIdenticalPairs([1,2,3,1,1,3]), 4)\\n    }\\n    func test1() {\\n        XCTAssertEqual(s.numIdenticalPairs([1,1,1,1]), 6)\\n    }\\n    func test2() {\\n        XCTAssertEqual(s.numIdenticalPairs([1,2,3]), 0)\\n    }\\n}\\n\\nTests.defaultTestSuite.run()\\n```\\n",
                "solutionTags": [
                    "Swift"
                ],
                "code": "```swift\\nclass Solution {\\n    func numIdenticalPairs(_ nums: [Int]) -> Int {\\n        var res = 0, map = [Int:Int]()\\n        nums.forEach {\\n            res += map[$0] ?? 0\\n            map[$0,default: 0] += 1\\n        }\\n        return res\\n    }\\n}\\n```\n```swift\\nimport XCTest\\n\\n// Executed 3 tests, with 0 failures (0 unexpected) in 0.031 (0.033) seconds\\n\\nclass Tests: XCTestCase {\\n    private let s = Solution()\\n    func test0() {\\n        XCTAssertEqual(s.numIdenticalPairs([1,2,3,1,1,3]), 4)\\n    }\\n    func test1() {\\n        XCTAssertEqual(s.numIdenticalPairs([1,1,1,1]), 6)\\n    }\\n    func test2() {\\n        XCTAssertEqual(s.numIdenticalPairs([1,2,3]), 0)\\n    }\\n}\\n\\nTests.defaultTestSuite.run()\\n```",
                "codeTag": "Java"
            },
            {
                "id": 733661,
                "title": "basic-java-solution",
                "content": "```\\nclass Solution {\\n    public int numIdenticalPairs(int[] nums) {\\n        int i=0,j=0,c=0;\\n        \\n        for(i=0;i<nums.length;i++)\\n        {\\n            for(j=i+1;j<nums.length;j++)\\n            {\\n                if(nums[i]==nums[j])\\n                    c++;;\\n            }\\n        }\\n        return c;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int numIdenticalPairs(int[] nums) {\\n        int i=0,j=0,c=0;\\n        \\n        for(i=0;i<nums.length;i++)\\n        {\\n            for(j=i+1;j<nums.length;j++)\\n            {\\n                if(nums[i]==nums[j])\\n                    c++;;\\n            }\\n        }\\n        return c;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3417146,
                "title": "simple-c-code-beats-100-time",
                "content": "\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nTake two iterators, traverse one iterator from other till the end of the vector and check if both have same value or not.\\n# Complexity\\n- Time complexity: O(n^2)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int numIdenticalPairs(vector<int>& nums) {\\n        std::vector<int>::iterator itr1,itr2;\\n        int count=0;\\n        for(itr1=nums.begin();itr1!=nums.end();itr1++)\\n        {\\n            for(itr2=itr1+1;itr2!=nums.end();itr2++)\\n            {\\n                if(*itr1==*itr2)\\n                {\\n                    count++;\\n                }\\n            }\\n        }\\n        return count;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int numIdenticalPairs(vector<int>& nums) {\\n        std::vector<int>::iterator itr1,itr2;\\n        int count=0;\\n        for(itr1=nums.begin();itr1!=nums.end();itr1++)\\n        {\\n            for(itr2=itr1+1;itr2!=nums.end();itr2++)\\n            {\\n                if(*itr1==*itr2)\\n                {\\n                    count++;\\n                }\\n            }\\n        }\\n        return count;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1564800,
                "title": "python-o-n-simple-solution",
                "content": "**Python :**\\n\\n```\\ndef numIdenticalPairs(self, nums: List[int]) -> int:\\n\\tcountPairs = 0\\n\\tcounter = {}\\n\\n\\tfor n in nums:\\n\\t\\tif n in counter:\\n\\t\\t\\tcountPairs += counter[n]\\n\\t\\t\\tcounter[n] += 1\\n\\n\\t\\telse:\\n\\t\\t\\tcounter[n] = 1\\n\\n\\treturn countPairs\\n```\\n\\n**Like it ? please upvote !**",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\ndef numIdenticalPairs(self, nums: List[int]) -> int:\\n\\tcountPairs = 0\\n\\tcounter = {}\\n\\n\\tfor n in nums:\\n\\t\\tif n in counter:\\n\\t\\t\\tcountPairs += counter[n]\\n\\t\\t\\tcounter[n] += 1\\n\\n\\t\\telse:\\n\\t\\t\\tcounter[n] = 1\\n\\n\\treturn countPairs\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 1122623,
                "title": "clear-explanation-using-combinations-for-pairs",
                "content": "We are asked to return the total number of pairs in a list of numbers  (`pair (i,j)` is called good if `nums[i] == nums[j]` and `i < j`).\\n\\nFirst, let\\'s consider a list of just one number, e.g. `nums = [1]`.  Here, this number cannot be paired with any others (other than itself), so the result is zero.\\n\\nNext, let\\'s consider a list of all idential numbers, e.g. `nums = [1, 1, 1, 1]`.  What we are really being asked is how many combinations of two can be made from such a list.  Using zero based indexing, we have the following six pairs of such combinations:\\n```\\n(0, 1), (0, 2), (0, 3)  # The first number at index 0 can be paired with the others at index locations 1, 2 and 3.\\n        (1, 2), (1, 3)  # The second at index 1 can be paired with its matching pair at index locations 2 and 3.\\n\\t\\t        (2, 3)  # The third at index 2 can form a unique pair with the number at index location 3.\\n```\\n\\nMore generally, the combination formula is `n! / [k! * (n - k)!]`.  In this problem, `n` represents the count of a given number and `k=2` because we are looking at unique pairs.  So the general formula becomes `n! / [2 * (n - 2)!]`.  Noting that  `n! / (n - 2)!` is simply `n * (n - 1)` after cancelling the factorial terms, the total number of unique pairs of the same number can be calculated as `n * (n - 1) / 2`.\\n\\nNow let\\'s say we are given the following ten mixed numbers:\\n`nums = [1, 2, 3, 1, 3, 2, 2, 4, 2, 3]`\\n\\nThe first thing we want to do is count the number of occurrences of each number, so `number: count of number`\\n```\\n1: 2\\n2: 4\\n3: 3\\n4: 1\\n```\\n\\nNote that when `n = 1`, then  `n * (n - 1) / 2` is simply zero and can hence be ignored (one item cannot be paired with any matching item).\\n\\nSo, the result is as follows given the above set of ten numbers with their respective counts:\\n```\\n1: 2 -> 2 * (2 - 1) / 2 = 1\\n2: 4 -> 4 * (4 - 1) / 2 = 6\\n3: 3 -> 3 * (3 - 1) / 2 = 3\\n4: 1 -> 1 * (1 - 1) / 2 = 0\\n```\\nThe answer in this example is thus `1 + 6 + 3 = 10`.\\n\\n<strong>Python Implementations</strong>\\n\\nNote that all of this can be solved simply in python using `Counter` and using a generator expression to sum the calculations for each counted value. Note that `n * (n - 1)` always results in an even number because it is the product of an odd number and an even number.  We can therefore use floor division on the summed result because this summed result will be even. All intermediate results are guaranteed to be integers as is the final result.  Note that summing everything and then dividing by two just once is slightly more efficient that summing all intermediate `n * (n - 1) / 2` calculations.\\n\\n```\\nfrom collections import Counter\\n\\nclass Solution:\\n    def numIdenticalPairs(self, nums: List[int]) -> int:\\n        return sum(num * (num - 1) for num in Counter(nums).values()) // 2\\n```\\n\\nAn alternative solution that just uses one pass (`O(n)` time complexity) to calculated the total pairs:\\n\\n```\\nclass Solution:\\n    def numIdenticalPairs(self, nums: List[int]) -> int:\\n        pairs = 0\\n        counts = {}\\n        for num in nums:\\n            prior_num_count = counts.get(num, 0)\\n            pairs += prior_num_count\\n            counts[num] = prior_num_count + 1\\n        return pairs\\n```\\n\\nBy observing the cumulative count, one notes that it is equal to the sum of the prior counts plus one minus the current total count (i.e. the prior count). The solution immediately above uses this obvservation, increasing the pairs count by one less than the number of occurrences observed for each number.  This solution has the same `O(n)` space complexity as the prior solution, as they both require the use of a dictionary/hashmap to keep track of the counts for each number observed.\\n\\n```\\ncount: sum of prior counts + (count - 1)\\n1: 0\\n2: 1 (0 + 1)\\n3: 3 (1 + 2)\\n4: 6 (3 + 3)\\n5: 10 (6 + 4)\\n```",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\n(0, 1), (0, 2), (0, 3)  # The first number at index 0 can be paired with the others at index locations 1, 2 and 3.\\n        (1, 2), (1, 3)  # The second at index 1 can be paired with its matching pair at index locations 2 and 3.\\n\\t\\t        (2, 3)  # The third at index 2 can form a unique pair with the number at index location 3.\\n```\n```\\n1: 2\\n2: 4\\n3: 3\\n4: 1\\n```\n```\\n1: 2 -> 2 * (2 - 1) / 2 = 1\\n2: 4 -> 4 * (4 - 1) / 2 = 6\\n3: 3 -> 3 * (3 - 1) / 2 = 3\\n4: 1 -> 1 * (1 - 1) / 2 = 0\\n```\n```\\nfrom collections import Counter\\n\\nclass Solution:\\n    def numIdenticalPairs(self, nums: List[int]) -> int:\\n        return sum(num * (num - 1) for num in Counter(nums).values()) // 2\\n```\n```\\nclass Solution:\\n    def numIdenticalPairs(self, nums: List[int]) -> int:\\n        pairs = 0\\n        counts = {}\\n        for num in nums:\\n            prior_num_count = counts.get(num, 0)\\n            pairs += prior_num_count\\n            counts[num] = prior_num_count + 1\\n        return pairs\\n```\n```\\ncount: sum of prior counts + (count - 1)\\n1: 0\\n2: 1 (0 + 1)\\n3: 3 (1 + 2)\\n4: 6 (3 + 3)\\n5: 10 (6 + 4)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1195779,
                "title": "java-hashmap-100-faster",
                "content": "**1.** we make a HashMap<Integer, Integer> , which we will use to store freq of each num (How many times every num has appeared in array) \\n\\n**2.** we traverse through nums array and for each num :\\n* we check if ( it is already present in our HashMap or not ):\\n*  * A) num is not already present in HashMap : *Then it has only one occurrence and it can not make pair with itself. We simply put it in HashMap with its frequecy as 1.*\\n B) num is already present in HashMap : Then it means there are (one or) more than one occurrences of it previously and now it can make pairs.  ( but how many pairs?  ) \\n To know how many pairs? we need to know how many times it has previously appeared in the array ( that\\'s why we used HashMap instead of Hashset to store the current frequency of num. )\\n we get the frequency ( k ) of num from HashMap ( which is also equal to the number of  pairs it can make ). add then add freq ( k) to count [ count += k; ]. Then increment the freq of that num by one and put new freq in hashMap [ hs.put(n, k + 1); ]\\n \\n** 3.**  we count all such pairs in \\'count\\' variable. which is our final answer.\\n\\n# CODE:\\n\\n```\\nimport java.util.HashMap;\\n\\nclass Solution {\\n    public int numIdenticalPairs(int[] nums) {\\n        HashMap<Integer, Integer> hs = new HashMap<>();\\n        int count = 0;\\n        for (int n : nums) {\\n            if (hs.containsKey(n)) {\\n                int k = hs.get(n);\\n                count += k;\\n                hs.put(n, k + 1);\\n            } else {\\n                hs.put(n, 1);\\n            }\\n        }\\n        return count;\\n\\n    }\\n}\\n```\\n\\n# **EXAMPLE DRY RUN:**\\nwe have have array as { 3,3,3,3 } then we start traversing....\\n\\n**index 0 :** value = 3.... and frequency(3) = 0.... and good pairs = 0; \\n===> update frequency(3) = 1 and still good pairs = 0 bcz only one occurrence of 3 till now.\\n\\n**index 1:** value = 3.... and frequency(3) = 1.... and good pairs = 0;\\n===>access previous frequency(3) = 1 and update good pairs = 0+1 (bcz the \\'3\\' at \\'index 1\\' can make *one* new pair with \\'3\\' at \\'index 0\\')\\n===> update frequency(3) = 2\\n\\n**index 2:** value = 3.... and frequency(3) = 2.... and good pairs = 1; \\n===>access previous frequency(3) = 2 and update good pairs = 0+1+2 (bcz the \\'3\\' at \\'index 2\\' can make* two* new pairs with \\'3\\' at \\'index 1\\' & with \\'3\\' at \\'index 0\\' )\\n===> update frequency(3) = 3.\\n\\n**index 3:** value = 3.... and frequency(3) = 3.... and good pairs = 3;\\n===>access previous frequency(3) = 3 and update good pairs = 0+1+2+3 (bcz the \\'3\\' at \\'index 3\\' can make* three *new pairs with \\'3\\' at \\'index 2\\' & with \\'3\\' at \\'index 1\\' & & with \\'3\\' at \\'index 0\\')\\n===> update frequency(3) = 4.\\n\\n*good pairs* = 0+1+2+3 = 6",
                "solutionTags": [
                    "Java",
                    "Hash Table"
                ],
                "code": "```\\nimport java.util.HashMap;\\n\\nclass Solution {\\n    public int numIdenticalPairs(int[] nums) {\\n        HashMap<Integer, Integer> hs = new HashMap<>();\\n        int count = 0;\\n        for (int n : nums) {\\n            if (hs.containsKey(n)) {\\n                int k = hs.get(n);\\n                count += k;\\n                hs.put(n, k + 1);\\n            } else {\\n                hs.put(n, 1);\\n            }\\n        }\\n        return count;\\n\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2066453,
                "title": "c-java-c-python-easy-to-understand-clean-code-with-comment",
                "content": "This code implements an optimized solution to solve the \"Number of Good Pairs\" problem. The problem requires counting the number of good pairs in an array of integers.\\n\\nTo solve the problem, the code follows these steps:\\n\\n- **Initialization**: An array called \"count\" is created with a size of 101. This array will be used to store the counts of each number. Since the problem specifies that the integers in the array are in the range 1 to 100, using an array of size 101 ensures coverage for all possible values. Additionally, a variable named \"goodPairs\" is initialized to keep track of the count of good pairs found so far. This variable will be returned as the final result.\\n\\n- **Iteration**: The code iterates through the \"nums\" array using a foreach loop. For each number, denoted as \"num,\" the following steps are performed:\\n\\n  a. Incrementing goodPairs: The code increases \"goodPairs\" by the current count of \"num\" in the \"count\" array. This step takes into account the number of existing pairs that \"num\" can form with previous occurrences of the same number. For example, if there are \"x\" occurrences of \"num\" before the current iteration, it means that there are \"x\" pairs that \"num\" can form with those previous occurrences. Therefore, \"goodPairs\" is increased by \"x\".\\n\\n  b. Updating count: The code increments the count of \"num\" in the \"count\" array by 1 to account for the current occurrence of \"num.\" This ensures that all occurrences of each number are correctly counted.\\n\\n- **Return**: Finally, the code returns the value of \"goodPairs,\" which represents the total number of good pairs found in the \"nums\" array.\\n\\nIn summary, the code efficiently solves the problem by using an optimized approach with a time complexity of O(n), where \"n\" is the length of the \"nums\" array. The space complexity is constant, O(1), as it uses a fixed-size array (\"count\") to store the counts, which does not depend on the input size.\\n```C++ []\\nclass Solution {\\npublic:\\n    int numIdenticalPairs(vector<int>& nums) {\\n        vector<int> count(101, 0);\\n        int goodPairs = 0;        \\n        for (int num : nums) {\\n            goodPairs += count[num]; // Increase goodPairs by the current count\\n            count[num]++; // Increment the count of the number\\n        }        \\n        return goodPairs;\\n    }\\n};\\n```\\n```Java []\\nclass Solution {\\n    public int numIdenticalPairs(int[] nums) {\\n        int[] count = new int[101];\\n        int goodPairs = 0;        \\n        for (int num : nums) {\\n            goodPairs += count[num]; // Increase goodPairs by the current count\\n            count[num]++; // Increment the count of the number\\n        }        \\n        return goodPairs;\\n    }\\n}\\n```\\n```csharp []\\npublic class Solution {\\n    public int NumIdenticalPairs(int[] nums) {\\n        int[] count = new int[101];\\n        int goodPairs = 0;        \\n        foreach (int num in nums) {\\n            goodPairs += count[num]; // Increase goodPairs by the current count\\n            count[num]++; // Increment the count of the number\\n        }        \\n        return goodPairs;\\n    }\\n}\\n```\\n```Python []\\nclass Solution(object):\\n    def numIdenticalPairs(self, nums):\\n        count = [0] * 101\\n        goodPairs = 0\\n        for num in nums:\\n            goodPairs += count[num]  # Increase goodPairs by the current count\\n            count[num] += 1  # Increment the count of the number\\n        return goodPairs\\n```\\n\\n",
                "solutionTags": [
                    "C++",
                    "Array",
                    "Hash Table",
                    "Math",
                    "Counting"
                ],
                "code": "```C++ []\\nclass Solution {\\npublic:\\n    int numIdenticalPairs(vector<int>& nums) {\\n        vector<int> count(101, 0);\\n        int goodPairs = 0;        \\n        for (int num : nums) {\\n            goodPairs += count[num]; // Increase goodPairs by the current count\\n            count[num]++; // Increment the count of the number\\n        }        \\n        return goodPairs;\\n    }\\n};\\n```\n```Java []\\nclass Solution {\\n    public int numIdenticalPairs(int[] nums) {\\n        int[] count = new int[101];\\n        int goodPairs = 0;        \\n        for (int num : nums) {\\n            goodPairs += count[num]; // Increase goodPairs by the current count\\n            count[num]++; // Increment the count of the number\\n        }        \\n        return goodPairs;\\n    }\\n}\\n```\n```csharp []\\npublic class Solution {\\n    public int NumIdenticalPairs(int[] nums) {\\n        int[] count = new int[101];\\n        int goodPairs = 0;        \\n        foreach (int num in nums) {\\n            goodPairs += count[num]; // Increase goodPairs by the current count\\n            count[num]++; // Increment the count of the number\\n        }        \\n        return goodPairs;\\n    }\\n}\\n```\n```Python []\\nclass Solution(object):\\n    def numIdenticalPairs(self, nums):\\n        count = [0] * 101\\n        goodPairs = 0\\n        for num in nums:\\n            goodPairs += count[num]  # Increase goodPairs by the current count\\n            count[num] += 1  # Increment the count of the number\\n        return goodPairs\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1745047,
                "title": "c-o-n-easy-solution-using-unordered-map",
                "content": "We store the count of each number in unordered map, if the count of a number is greater than 1 then we increase the variable res  and store the number of possible combinations which satisfy the given condition given in the question (nums[i] == nums[j] and i<j)\\n```\\nclass Solution {\\npublic:\\n    \\n    int numIdenticalPairs(vector<int>& nums) {\\n        int res=0;\\n        unordered_map<int, int> mp;\\n        for(int i=0; i<nums.size(); i++){\\n            mp[nums[i]]++;\\n        }\\n        for(auto x:mp){\\n            if(x.second > 1){\\n                res += (x.second * (x.second - 1))/2; \\n            }\\n        }\\n        return res;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Hash Table"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    \\n    int numIdenticalPairs(vector<int>& nums) {\\n        int res=0;\\n        unordered_map<int, int> mp;\\n        for(int i=0; i<nums.size(); i++){\\n            mp[nums[i]]++;\\n        }\\n        for(auto x:mp){\\n            if(x.second > 1){\\n                res += (x.second * (x.second - 1))/2; \\n            }\\n        }\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 731660,
                "title": "optimal-and-suboptimal-completely-explained-with-2-solutions",
                "content": "\\nThis is the bruteforce approach.\\n\\nTime:O(n^2)\\nSpace:O(1)\\n```python\\nclass Solution:\\n    def numIdenticalPairs(self, nums: List[int]) -> int:\\n        n = len(nums)\\n        res = 0 \\n        for i in range(n):\\n            for j in range(i+1,n):\\n                if nums[i] == nums[j]:\\n                    res+=1\\n        return res\\n```\\n\\nThis is the optimal solution which stores the {number,[list of indices of occurence of number]} as an event.\\nThen find the number of number of pairs from each event.\\nTime:O(n) | Space:O(n)\\n\\n```python\\nclass Solution:\\n    def numIdenticalPairs(self, nums: List[int]) -> int:\\n        n = len(nums)\\n        events = collections.defaultdict(list)\\n        for idx,num in enumerate(nums):\\n            events[num].append(idx)\\n        count = lambda x:x*(x-1)//2 if x>1 else 0\\n        res = 0 \\n        for event in events:\\n            indices = events[event]\\n            length = len(indices)\\n            ans = count(length)\\n            res+=ans\\n        return res\\n```\\n\\nThis is very critical in the interview setting.Dont get satisfied after proposing the first solution.I mean anyone could do the first\\nsolution and its pretty naive.Discuss all possible approaches with their Time and space complexities.If you observe,its a tradeoff with memory\\nand optimising time in the second solution. In eitherway,both solution are good and we need to choose according to the situation based on time,memory constraints.\\n\\nThanks for your time :)",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```python\\nclass Solution:\\n    def numIdenticalPairs(self, nums: List[int]) -> int:\\n        n = len(nums)\\n        res = 0 \\n        for i in range(n):\\n            for j in range(i+1,n):\\n                if nums[i] == nums[j]:\\n                    res+=1\\n        return res\\n```\n```python\\nclass Solution:\\n    def numIdenticalPairs(self, nums: List[int]) -> int:\\n        n = len(nums)\\n        events = collections.defaultdict(list)\\n        for idx,num in enumerate(nums):\\n            events[num].append(idx)\\n        count = lambda x:x*(x-1)//2 if x>1 else 0\\n        res = 0 \\n        for event in events:\\n            indices = events[event]\\n            length = len(indices)\\n            ans = count(length)\\n            res+=ans\\n        return res\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2675214,
                "title": "java-o-n-1-line-logic-easy",
                "content": "```\\nclass Solution {\\n    public int numIdenticalPairs(int[] nums) {\\n        int ans = 0;\\n        int[] temp = new int[101];\\n        \\n        for (int i = 0; i < nums.length; i++) {\\n            ans += temp[nums[i]]++;\\n        }\\n        return ans;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Array"
                ],
                "code": "```\\nclass Solution {\\n    public int numIdenticalPairs(int[] nums) {\\n        int ans = 0;\\n        int[] temp = new int[101];\\n        \\n        for (int i = 0; i < nums.length; i++) {\\n            ans += temp[nums[i]]++;\\n        }\\n        return ans;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1601830,
                "title": "simple-o-n-java-solution-hashmap",
                "content": "**Upvote if you LIKE**\\uD83D\\uDE42 \\nclass Solution {\\n\\n    public int numIdenticalPairs(int[] nums) {\\n        HashMap<Integer,Integer> hm = new HashMap<>();\\n        int count = 0;\\n        for(int i=0;i<nums.length;i++){\\n            if(hm.containsKey(nums[i])){\\n                count += hm.get(nums[i]);\\n                hm.put(nums[i],hm.get(nums[i])+1);\\n            }\\n            else\\n                hm.put(nums[i],1);\\n        }\\n        return count;\\n    }\\n}",
                "solutionTags": [
                    "Java"
                ],
                "code": "class Solution {\\n\\n    public int numIdenticalPairs(int[] nums) {\\n        HashMap<Integer,Integer> hm = new HashMap<>();\\n        int count = 0;\\n        for(int i=0;i<nums.length;i++){\\n            if(hm.containsKey(nums[i])){\\n                count += hm.get(nums[i]);\\n                hm.put(nums[i],hm.get(nums[i])+1);\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 851005,
                "title": "c-0-ms-faster-than-100-00-o-n-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    int numIdenticalPairs(vector<int>& nums) {\\n        \\n        //Using map to store frequencies of each element\\n        map<int,int> count;\\n        \\n        int noOfPairs = 0;\\n        \\n        for(int i=0;i<nums.size();i++){\\n            count[nums[i]]+=1;\\n        }\\n        \\n        //if there are say n 1\\'s then idea is that there will\\n        //will be exactly 1+2+....+(n-1) no. of pairs which is\\n        //(n)*(n-1)/2\\n        \\n        for(auto ele: count){\\n            noOfPairs+=(ele.second)*(ele.second - 1)/2; \\n        }\\n        \\n        return noOfPairs;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int numIdenticalPairs(vector<int>& nums) {\\n        \\n        //Using map to store frequencies of each element\\n        map<int,int> count;\\n        \\n        int noOfPairs = 0;\\n        \\n        for(int i=0;i<nums.size();i++){\\n            count[nums[i]]+=1;\\n        }\\n        \\n        //if there are say n 1\\'s then idea is that there will\\n        //will be exactly 1+2+....+(n-1) no. of pairs which is\\n        //(n)*(n-1)/2\\n        \\n        for(auto ele: count){\\n            noOfPairs+=(ele.second)*(ele.second - 1)/2; \\n        }\\n        \\n        return noOfPairs;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 731682,
                "title": "c-simple-o-n-2-solution",
                "content": "```csharp\\npublic int NumIdenticalPairs(int[] nums) \\n{\\n\\tint count = 0;\\n\\n\\tfor(int i = 0; i < nums.Length; i++)\\n\\t{\\n\\t\\tfor(int j = i + 1; j < nums.Length; j++)\\n\\t\\t{\\n\\t\\t\\tif(nums[i] == nums[j])\\n\\t\\t\\t{\\n\\t\\t\\t\\tcount++;\\n\\t\\t\\t}\\n\\t\\t}\\n\\t}\\n\\n\\treturn count;\\n}\\n```",
                "solutionTags": [],
                "code": "```csharp\\npublic int NumIdenticalPairs(int[] nums) \\n{\\n\\tint count = 0;\\n\\n\\tfor(int i = 0; i < nums.Length; i++)\\n\\t{\\n\\t\\tfor(int j = i + 1; j < nums.Length; j++)\\n\\t\\t{\\n\\t\\t\\tif(nums[i] == nums[j])\\n\\t\\t\\t{\\n\\t\\t\\t\\tcount++;\\n\\t\\t\\t}\\n\\t\\t}\\n\\t}\\n\\n\\treturn count;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3109723,
                "title": "simple-solution-number-of-good-pairs",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def numIdenticalPairs(self, nums: List[int]) -> int:\\n        count=0\\n        for i in range(len(nums)):\\n            for j in range(len(nums)):\\n                if nums[i]==nums[j] and i<j:\\n                    count+=1\\n        return count\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def numIdenticalPairs(self, nums: List[int]) -> int:\\n        count=0\\n        for i in range(len(nums)):\\n            for j in range(len(nums)):\\n                if nums[i]==nums[j] and i<j:\\n                    count+=1\\n        return count\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2873992,
                "title": "javascript-solution-faster-than-97-43-of-other-submissions-map-array-reduce",
                "content": "**Feel free to ask Q\\'s...**\\n*#happytohelpu*\\n\\n***Do upvote if you find this solution useful. Happy Coding!***\\n\\nRuntime: 58 ms\\nMemory Usage: 41.7 MB\\n\\n```\\n\\n/**\\n * @param {number[]} nums\\n * @param {Map} map\\n * @return {number}\\n */\\nconst numIdenticalPairs = (nums, map = new Map(), res = 0) => {\\n    for (let i = 0; i < nums.length; i++) {\\n        let temp = map.get(nums[i]);\\n        if (temp) res += temp;\\n        /** Everytime same value is found in other index it can be paired with \\n         * existing one so adding previous value to result \\n         */\\n        map.set(nums[i], temp ? temp + 1 : 1);\\n    }\\n    return res;\\n};\\n```\\n\\n\\nSolution 2 with Map and Array reduce method a slight variation\\n\\n```\\nconst numIdenticalPairs = (nums, map = new Map()) => nums.reduce((prev, cur) => {\\n    if (map.get(cur)) {\\n        prev += map.get(cur);\\n        map.set(cur, map.get(cur) + 1);\\n    } else {\\n        map.set(cur, 1)\\n    }\\n    return prev;\\n}, 0);\\n```\\n",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n\\n/**\\n * @param {number[]} nums\\n * @param {Map} map\\n * @return {number}\\n */\\nconst numIdenticalPairs = (nums, map = new Map(), res = 0) => {\\n    for (let i = 0; i < nums.length; i++) {\\n        let temp = map.get(nums[i]);\\n        if (temp) res += temp;\\n        /** Everytime same value is found in other index it can be paired with \\n         * existing one so adding previous value to result \\n         */\\n        map.set(nums[i], temp ? temp + 1 : 1);\\n    }\\n    return res;\\n};\\n```\n```\\nconst numIdenticalPairs = (nums, map = new Map()) => nums.reduce((prev, cur) => {\\n    if (map.get(cur)) {\\n        prev += map.get(cur);\\n        map.set(cur, map.get(cur) + 1);\\n    } else {\\n        map.set(cur, 1)\\n    }\\n    return prev;\\n}, 0);\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2651454,
                "title": "c-hashmap-solution-explained",
                "content": "**Hello Everyone!**\\nI hope you find this solution helpful, feel free to comment suggestions and critiques!\\n\\n```\\nclass Solution {\\npublic:\\n    int numIdenticalPairs(vector<int>& nums) {\\n        unordered_map<int, int>mp;\\n        int ans = 0;\\n        for (int i = 0; i < nums.size(); ++i){\\n            //Go through the vector given and increment the map by 1\\n\\t\\t\\t// everytime the same number appears. This is counting the \\n\\t\\t\\t// frequency of that number\\n\\t\\t\\t++mp[nums[i]];\\n\\t\\t\\t\\n\\t\\t\\t//If the number shows up more than once, then it has atleast one pair\\n            if (mp[nums[i]] > 1)\\n            {\\n\\t\\t\\t\\t//add to the answer the frequency - 1\\n\\t\\t\\t\\t// (appearing two times means there is one pair, three times is two pairs, etc etc\\n                ans += mp[nums[i]] - 1;       \\n            }\\n        }\\n\\t\\t//return the answer\\n        return ans;\\n    }\\n};\\n```\\nPlease leave an upvote if you found this solution helpful!",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int numIdenticalPairs(vector<int>& nums) {\\n        unordered_map<int, int>mp;\\n        int ans = 0;\\n        for (int i = 0; i < nums.size(); ++i){\\n            //Go through the vector given and increment the map by 1\\n\\t\\t\\t// everytime the same number appears. This is counting the \\n\\t\\t\\t// frequency of that number\\n\\t\\t\\t++mp[nums[i]];\\n\\t\\t\\t\\n\\t\\t\\t//If the number shows up more than once, then it has atleast one pair\\n            if (mp[nums[i]] > 1)\\n            {\\n\\t\\t\\t\\t//add to the answer the frequency - 1\\n\\t\\t\\t\\t// (appearing two times means there is one pair, three times is two pairs, etc etc\\n                ans += mp[nums[i]] - 1;       \\n            }\\n        }\\n\\t\\t//return the answer\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1101026,
                "title": "python-1-liner-without-using-counter",
                "content": "```\\ndef numIdenticalPairs(self, nums: List[int]) -> int:\\n        return (sum(i==j for j in nums for i in nums)-len(nums))//2\\n```",
                "solutionTags": [],
                "code": "```\\ndef numIdenticalPairs(self, nums: List[int]) -> int:\\n        return (sum(i==j for j in nums for i in nums)-len(nums))//2\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 990196,
                "title": "python-3-faster-than-99-48",
                "content": "The solution to this problem uses a small math formula and a hash table. The following is the approach I used,\\n\\n1. Build a dictionary to store the array items as keys and the value is a list of indices where this element appears. Ex: nums = [1,2,1,1]. d = { 1: [0,2,3], 2: [1]}. As I am iterating through the array linearly, this automatically guarantees i < j.\\n2. In this dicitionary check for the presence of lists whose length is greater than 1, which means the element repeats. In those cases, it is the number of pairs we can form with the elements of that list incrementally. Say the lenght of a list is n, this is equivalent to summing up the numbers upto n-1. \\n3. Using Gauss\\'s trick, sum of numbers upto n, is n(n+1) / 2. Modifying it slightly for n-1, it is (n-1)n / 2. Add this for each list whose length is greater than 1 to the answer variable. Ex: consider the dictionary d = { 1: [0,2,3], 2: [1]}, for this list 1 has 3 elements, so we add (3-1) * 3 / 2 = 3 to the answer.\\n\\nFollowing code implements it.\\n\\n```\\nclass Solution:\\n    def numIdenticalPairs(self, nums: List[int]) -> int:\\n        ans = 0\\n        d = defaultdict(list)\\n        for i in range(len(nums)):\\n            d[nums[i]].append(i)\\n        # print(d)\\n        for k,v in d.items():\\n            n = len(v)\\n            # print(n)\\n            if n > 1:\\n                ans += ((n-1) * n) // 2\\n        return ans\\n```\\n\\nWhile this is faster than 99.48% python 3 solutions, it doesn\\'t perform that well on space.  Any suggestions are appreciated.",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def numIdenticalPairs(self, nums: List[int]) -> int:\\n        ans = 0\\n        d = defaultdict(list)\\n        for i in range(len(nums)):\\n            d[nums[i]].append(i)\\n        # print(d)\\n        for k,v in d.items():\\n            n = len(v)\\n            # print(n)\\n            if n > 1:\\n                ans += ((n-1) * n) // 2\\n        return ans\\n```",
                "codeTag": "Java"
            },
            {
                "id": 893146,
                "title": "python-98-with-o-n",
                "content": "Solution1: Brute force\\nTC= O(n*2)\\nSC O(n)\\n```\\nclass Solution(object):\\n    def numIdenticalPairs(self, nums):\\n        \"\"\"\\n        :type nums: List[int]\\n        :rtype: int\\n        \"\"\"\\n        count =0\\n        for i in range(len(nums)):\\n            for j in range(len(nums)):\\n                 if nums[i]==nums[j] and i<j:\\n                     count +=1\\n        return count\\n```\\n\\nSolution2 : Optimize in O(n)\\n\\nTC O(n)\\nSC O(1)\\n```\\nclass Solution(object):\\n    def numIdenticalPairs(self, nums):\\n        \"\"\"\\n        :type nums: List[int]\\n        :rtype: int\\n        \"\"\"\\n        \\n        dic = {}\\n        count =0\\n        \\n        for num in nums:\\n            if num in dic:\\n                count +=dic[num]\\n                dic[num] +=1\\n            else:\\n                dic[num] =1\\n        return count\\n        \\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nclass Solution(object):\\n    def numIdenticalPairs(self, nums):\\n        \"\"\"\\n        :type nums: List[int]\\n        :rtype: int\\n        \"\"\"\\n        count =0\\n        for i in range(len(nums)):\\n            for j in range(len(nums)):\\n                 if nums[i]==nums[j] and i<j:\\n                     count +=1\\n        return count\\n```\n```\\nclass Solution(object):\\n    def numIdenticalPairs(self, nums):\\n        \"\"\"\\n        :type nums: List[int]\\n        :rtype: int\\n        \"\"\"\\n        \\n        dic = {}\\n        count =0\\n        \\n        for num in nums:\\n            if num in dic:\\n                count +=dic[num]\\n                dic[num] +=1\\n            else:\\n                dic[num] =1\\n        return count\\n        \\n```",
                "codeTag": "Java"
            },
            {
                "id": 879663,
                "title": "c-100-faster",
                "content": "```\\nclass Solution {\\npublic:\\n    int numIdenticalPairs(vector<int>& nums) {\\n        unordered_map<int,int> map;\\n        int ans=0;\\n        for(auto n:nums){\\n            map[n]++;\\n            ans+=(map[n]-1);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int numIdenticalPairs(vector<int>& nums) {\\n        unordered_map<int,int> map;\\n        int ans=0;\\n        for(auto n:nums){\\n            map[n]++;\\n            ans+=(map[n]-1);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3185645,
                "title": "easy-java-hashmap-explained",
                "content": "\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nThis Java code defines a method named **numIdenticalPairs** that takes an array of integers nums and returns the number of good pairs of indices **(i, j)** such that **nums[i] == nums[j]** and **i < j**. A good pair is a pair of indices that satisfies the condition.\\n\\nThe code first creates a hash map to store the count of occurrences of each number in the input array. It then iterates over the map and computes the count of good pairs for each number using the formula **m*(m-1)/2**, where m is the count of occurrences of the number. The total count of good pairs is accumulated in the count variable and returned.\\n\\nThe time complexity of the code is **O(n)**, where n is the length of the input array, because it uses a hash map to count the occurrences of each number, which takes **O(n)** time, and then iterates over the map, which takes **O(m)** time where m is the number of distinct numbers in the array (which is usually much smaller than n).\\n\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int numIdenticalPairs(int[] nums) {\\n        HashMap<Integer,Integer> map = new HashMap<>();\\n        int count = 0;\\n        int n = nums.length;\\n        for(int i=0; i<n; i++){\\n            if(map.containsKey(nums[i]))\\n                map.put(nums[i],map.get(nums[i])+1);\\n            else\\n                map.put(nums[i],1);\\n        }\\n        for(Map.Entry<Integer,Integer> e: map.entrySet()){\\n            if(e.getValue()>0){\\n                int m = e.getValue();\\n                count+=(m*(m-1))/2;\\n            }\\n        }\\n        return count;\\n    }\\n}\\n```\\n## If you find this helpful then pls upvote me..........",
                "solutionTags": [
                    "Java",
                    "Array",
                    "Hash Table",
                    "Math",
                    "Counting"
                ],
                "code": "```\\nclass Solution {\\n    public int numIdenticalPairs(int[] nums) {\\n        HashMap<Integer,Integer> map = new HashMap<>();\\n        int count = 0;\\n        int n = nums.length;\\n        for(int i=0; i<n; i++){\\n            if(map.containsKey(nums[i]))\\n                map.put(nums[i],map.get(nums[i])+1);\\n            else\\n                map.put(nums[i],1);\\n        }\\n        for(Map.Entry<Integer,Integer> e: map.entrySet()){\\n            if(e.getValue()>0){\\n                int m = e.getValue();\\n                count+=(m*(m-1))/2;\\n            }\\n        }\\n        return count;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2746064,
                "title": "java-simple-explanation-o-n-time-0-ms-faster-than-100",
                "content": "We declared an empty array of size 101 since 101 is the max number given in constraints.\\nThe temp array looks like [0, 0, 0, 0, 0, ... , 0] now.\\n\\nWe are now looping in the given nums array and going to each element and adding it\\'s temp count.\\n\\nLet\\'s understand this by an example.\\nGiven `nums = [1,2,3,1,1,3]`\\nwhen i=0, we will check nums[i] which is num[0] = 1.\\nThen we will go to temp[nums[i]] which is temp[1] = 0 for now. So we will add it to count 0 + 0 = 0.\\nThen we will perform temp[1]++ which means we will make the temp array look like [0,1,0,0,0...0]\\n\\nNow, we will have i =1:\\nnums[1]=2\\ntemp[2]++\\ncount = 0 + 0\\nNow the temp array will look like [0, 1, 1, 0, 0, ... , 0]\\n\\ni = 2\\nnums[2] = 3\\ntemp[3]++\\ncount = 0 + 0\\nNow the temp array will look like [0, 1, 1, 1, 0, 0, ... , 0]\\n\\nNow for i = 3\\nnums[3] = 1\\ntemp[1]++\\ncount = 0 + 1\\nNow the temp array will look like [0, 2, 1, 1, 0, 0, ... , 0]\\n\\nNow for i = 4\\nnums[4] = 1\\ntemp[1]++\\ncount = 1 + 2\\nNow the temp array will look like [0, 3, 1, 1, 0, 0, ... , 0]\\n\\nFor i = 5\\nnums[5] = 3\\ntemp[3]++\\ncount = 3 + 1\\nNow the temp array will look like [0, 3, 1, 2, 0, ... , 0]\\n\\nWe will return count which is 4\\n```\\nclass Solution {\\n    public int numIdenticalPairs(int[] nums) {\\n        int[] temp = new int[101];\\n        \\n        int count = 0;\\n        \\n        for (int i = 0; i < nums.length; i++) {\\n            count += temp[nums[i]]++;\\n        }\\n        \\n        return count;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int numIdenticalPairs(int[] nums) {\\n        int[] temp = new int[101];\\n        \\n        int count = 0;\\n        \\n        for (int i = 0; i < nums.length; i++) {\\n            count += temp[nums[i]]++;\\n        }\\n        \\n        return count;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2544514,
                "title": "easy-java-solution-simple-beginner-friendly",
                "content": "**If you really found my solution helpful please upvote it, as it motivates me to post such kind of codes and help the coding community, if you have some queries or some improvements please feel free to comment and share your views.**\\n```\\nclass Solution {\\n    public int numIdenticalPairs(int[] nums) {\\n        int count = 0;\\n        for(int i = 0 ; i < nums.length; i ++){\\n            for(int j = i + 1; j < nums.length; j ++){\\n                if(nums[i] == nums[j]){\\n                    count++;\\n                }\\n            }\\n        }\\n        return count;\\n    }\\n}\\n```\\n**Happy Coding**",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int numIdenticalPairs(int[] nums) {\\n        int count = 0;\\n        for(int i = 0 ; i < nums.length; i ++){\\n            for(int j = i + 1; j < nums.length; j ++){\\n                if(nums[i] == nums[j]){\\n                    count++;\\n                }\\n            }\\n        }\\n        return count;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1383728,
                "title": "python3-hash-table-o-n-93-3-faster-98-04-memory-efficient",
                "content": "\\n```\\ndef numIdenticalPairs(self, nums: List[int]) -> int:\\n        d={}\\n        c=0\\n        for i in range(len(nums)):\\n            if nums[i] in d:\\n                d[nums[i]]+=1\\n                c+=d[nums[i]]\\n            else:\\n                d[nums[i]]=0\\n        return c\\n```\\nPlease Upvote\\nHappy Coding!!",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\ndef numIdenticalPairs(self, nums: List[int]) -> int:\\n        d={}\\n        c=0\\n        for i in range(len(nums)):\\n            if nums[i] in d:\\n                d[nums[i]]+=1\\n                c+=d[nums[i]]\\n            else:\\n                d[nums[i]]=0\\n        return c\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 1066531,
                "title": "kotlin-1-line",
                "content": "```\\nfun numIdenticalPairs(a: IntArray) = a.mapIndexed { i, n -> a.slice(i + 1..a.lastIndex).count { it == n } }.sum()\\n```\\n**Approach 2:**\\n```\\nfun numIdenticalPairs(a: IntArray): Int {\\n    var c = 0\\n    a.forEachIndexed { i, n -> for (j in i + 1 until a.size) if (n == a[j]) c++ }\\n    return c\\n}\\n```\\n**Approach 3:**\\n```\\nfun numIdenticalPairs(nums: IntArray): Int {\\n    val map = mutableMapOf<Int, Int>()\\n    var count = 0\\n    nums.forEach {\\n        if (map.containsKey(it)) count += map[it]!!\\n        map[it] = map.getOrDefault(it, 0) + 1\\n    }     \\n    return count\\n}\\n```",
                "solutionTags": [
                    "Kotlin"
                ],
                "code": "```\\nfun numIdenticalPairs(a: IntArray) = a.mapIndexed { i, n -> a.slice(i + 1..a.lastIndex).count { it == n } }.sum()\\n```\n```\\nfun numIdenticalPairs(a: IntArray): Int {\\n    var c = 0\\n    a.forEachIndexed { i, n -> for (j in i + 1 until a.size) if (n == a[j]) c++ }\\n    return c\\n}\\n```\n```\\nfun numIdenticalPairs(nums: IntArray): Int {\\n    val map = mutableMapOf<Int, Int>()\\n    var count = 0\\n    nums.forEach {\\n        if (map.containsKey(it)) count += map[it]!!\\n        map[it] = map.getOrDefault(it, 0) + 1\\n    }     \\n    return count\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1031419,
                "title": "javascript-solution-93-speed-using-map-and-counter",
                "content": "```/**\\n * @param {number[]} nums\\n * @return {number}\\n */\\nvar numIdenticalPairs = function(nums) {\\n    const map = new Map();\\n    let pairs = 0;\\n\\n    for (let i = 0; i < nums.length; i++) {\\n        if (map.has(nums[i])) {\\n            pairs += map.get(nums[i]);\\n            map.set(nums[i], map.get(nums[i]) + 1);\\n        } else {\\n            map.set(nums[i], 1);\\n        }\\n    }\\n    return pairs;\\n};\\n\\nWe can also use for...of instead of traditional for loop",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```/**\\n * @param {number[]} nums\\n * @return {number}\\n */\\nvar numIdenticalPairs = function(nums) {\\n    const map = new Map();\\n    let pairs = 0;\\n\\n    for (let i = 0; i < nums.length; i++) {\\n        if (map.has(nums[i])) {\\n            pairs += map.get(nums[i]);\\n            map.set(nums[i], map.get(nums[i]) + 1);\\n        } else {\\n            map.set(nums[i], 1);\\n        }\\n    }\\n    return pairs;\\n};\\n\\nWe can also use for...of instead of traditional for loop",
                "codeTag": "Unknown"
            },
            {
                "id": 935442,
                "title": "simple-javascript-solution",
                "content": "```\\nvar numIdenticalPairs = function(nums) {\\n      let obj = {};\\n      let counter = 0;\\n\\n      for (val of nums) {\\n        if (obj[val]) {\\n          counter += obj[val];\\n          obj[val]++;\\n        } else {\\n          obj[val] = 1;\\n        }\\n      }\\n      console.log(obj);\\n      return counter;\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\nvar numIdenticalPairs = function(nums) {\\n      let obj = {};\\n      let counter = 0;\\n\\n      for (val of nums) {\\n        if (obj[val]) {\\n          counter += obj[val];\\n          obj[val]++;\\n        } else {\\n          obj[val] = 1;\\n        }\\n      }\\n      console.log(obj);\\n      return counter;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 837450,
                "title": "python3-solution-with-a-single-pass-and-no-if-else-statements",
                "content": "This solution makes use of a single pass and no if-else statements.\\n\\n[@navinmittal29](https://leetcode.com/navinmittal29) Thanks for your suggestion on how to avoid using the if-else statements in my previous solution.\\n\\n\\n```\\nclass Solution:\\n    def numIdenticalPairs(self, nums: List[int]) -> int:\\n        my_count = 0\\n        my_dict = {}\\n        \\n        for n in nums:\\n            # Check to see if number has already been encountered\\n            # and increase count by the number of previous instances\\n            my_count += my_dict.get(n, 0) \\n\\n            # Increase the count of previous observation\\n            # Or store newly encountered number along with its count\\n            my_dict[n] = my_dict.get(n, 0) + 1\\n                \\n        return my_count\\n```",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def numIdenticalPairs(self, nums: List[int]) -> int:\\n        my_count = 0\\n        my_dict = {}\\n        \\n        for n in nums:\\n            # Check to see if number has already been encountered\\n            # and increase count by the number of previous instances\\n            my_count += my_dict.get(n, 0) \\n\\n            # Increase the count of previous observation\\n            # Or store newly encountered number along with its count\\n            my_dict[n] = my_dict.get(n, 0) + 1\\n                \\n        return my_count\\n```",
                "codeTag": "Java"
            },
            {
                "id": 731739,
                "title": "java-python-3-4-1-liners-o-n-counting-codes-w-brief-explanation-and-analysis",
                "content": "For any given `i` items, we have `C(i, 2) = (i - 1) * i / 2` combination options if choosing pairs from the `i` elements.\\n```java\\n    public int numIdenticalPairs(int[] nums) {\\n        int[] cnt = new int[101];\\n        for (int n : nums)\\n            ++cnt[n];\\n        return Arrays.stream(cnt).map(i -> (i - 1) * i / 2).sum();\\n    }\\n```\\n```python\\n    def numIdenticalPairs(self, nums: List[int]) -> int:\\n        return sum(v * (v - 1) // 2 for v in Counter(nums).values())\\n```\\n**Analysis:**\\n\\nTime: `O(n)`, space: `O(R)`, where `R = cnt.length`, the range of the `nums`.",
                "solutionTags": [],
                "code": "```java\\n    public int numIdenticalPairs(int[] nums) {\\n        int[] cnt = new int[101];\\n        for (int n : nums)\\n            ++cnt[n];\\n        return Arrays.stream(cnt).map(i -> (i - 1) * i / 2).sum();\\n    }\\n```\n```python\\n    def numIdenticalPairs(self, nums: List[int]) -> int:\\n        return sum(v * (v - 1) // 2 for v in Counter(nums).values())\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 3837000,
                "title": "c-3-line-solution",
                "content": "# Code\\n```\\nclass Solution {\\npublic:\\n    int numIdenticalPairs(vector<int>& nums) {\\n        int ans = 0, freq[101] = {0};\\n        for(auto i : nums) ans += freq[i], freq[i] += 1;\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int numIdenticalPairs(vector<int>& nums) {\\n        int ans = 0, freq[101] = {0};\\n        for(auto i : nums) ans += freq[i], freq[i] += 1;\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3460814,
                "title": "java-o-n-log-n-hashmap-used-for-beginners-explained",
                "content": "# Approach\\n- Create a hashmap\\n- O(n log n) nested loop setup for finding out pairs\\n- If a key == nums[i] does not exist upon finding a pair, push a pair (nums[i] , 1)\\n- If key exist, increment the value corresponding to the key in the hashmap.\\n- for all the key values in the map, return the sum of all the values  \\n\\n# Complexity\\n- Time complexity: O(n log n)\\n\\n- Space complexity: O(n)\\n\\n# Code\\n```\\nclass Solution {\\n    public int numIdenticalPairs(int[] nums) {\\n        HashMap<Integer, Integer> map = new HashMap<>();\\n        for(int i = 0;i<nums.length;i++){\\n            for(int j = i+1;j<nums.length;j++){\\n                if(nums[i] == nums[j]){\\n                    if(map.containsKey(nums[i]) == true){\\n                        int value = map.get(nums[i]);\\n                        value++;\\n                        map.put(nums[i],value);\\n                    }else{\\n                        map.put(nums[i],1);\\n                    }\\n                }\\n            }\\n        }\\n        int sum = 0;\\n        for(int val: map.keySet()){\\n            sum += map.get(val);\\n        }\\n        return sum;\\n    }\\n}\\n```\\n\\n![images.jpeg](https://assets.leetcode.com/users/images/50a24157-7d7e-43a9-8524-2a6d895ec72e_1682603816.5533574.jpeg)\\n",
                "solutionTags": [
                    "Java",
                    "Hash Table"
                ],
                "code": "```\\nclass Solution {\\n    public int numIdenticalPairs(int[] nums) {\\n        HashMap<Integer, Integer> map = new HashMap<>();\\n        for(int i = 0;i<nums.length;i++){\\n            for(int j = i+1;j<nums.length;j++){\\n                if(nums[i] == nums[j]){\\n                    if(map.containsKey(nums[i]) == true){\\n                        int value = map.get(nums[i]);\\n                        value++;\\n                        map.put(nums[i],value);\\n                    }else{\\n                        map.put(nums[i],1);\\n                    }\\n                }\\n            }\\n        }\\n        int sum = 0;\\n        for(int val: map.keySet()){\\n            sum += map.get(val);\\n        }\\n        return sum;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3379741,
                "title": "find-the-number-of-identical-pairs-in-an-array-of-integers",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nThe problem is asking to find the number of identical pairs in an array of integers. We can keep track of the frequency of each integer using a hash map, where the keys are the integers and the values are the frequency of occurrence. Then, for each key in the map, we can calculate the number of pairs that can be formed using the formula n * (n-1) / 2, where n is the frequency of the integer. We can then sum up the number of pairs for each integer to get the total number of identical pairs in the array.\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nThe approach used in this solution is to first create a hash map, where we iterate through the input array and keep track of the frequency of each integer. Then, we iterate through the keys in the map and calculate the number of identical pairs that can be formed using the formula mentioned above. Finally, we sum up the number of pairs for each integer to get the total number of identical pairs in the array.\\n# Complexity\\n<!-- - Time complexity: -->\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n<!-- - Space complexity: -->\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nThe time complexity of this solution is O(n), where n is the length of the input array. This is because we iterate through the array once to create the hash map, and then iterate through the keys in the map, which has a maximum length of the number of unique integers in the array. The space complexity is also O(n), since we are using a hash map to store the frequency of each integer in the array.\\n# Code\\n```\\n/**\\n * @param {number[]} nums\\n * @return {number}\\n */\\nvar numIdenticalPairs = function (nums) {\\n  let m = {};\\n\\n  nums.forEach((element) => {\\n    if (m[element] == undefined) m[element] = 1;\\n    else m[element]++;\\n  });\\n\\n  let res = 0;\\n\\n  for (const key in m) {\\n    if (Object.hasOwnProperty.call(m, key)) {\\n      const element = m[key];\\n      if (element > 1) res += element * (element / 2 - 0.5);\\n    }\\n  }\\n\\n  return res;\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {number[]} nums\\n * @return {number}\\n */\\nvar numIdenticalPairs = function (nums) {\\n  let m = {};\\n\\n  nums.forEach((element) => {\\n    if (m[element] == undefined) m[element] = 1;\\n    else m[element]++;\\n  });\\n\\n  let res = 0;\\n\\n  for (const key in m) {\\n    if (Object.hasOwnProperty.call(m, key)) {\\n      const element = m[key];\\n      if (element > 1) res += element * (element / 2 - 0.5);\\n    }\\n  }\\n\\n  return res;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2977892,
                "title": "beats-100-java-solution",
                "content": "\\n\\n# Complexity\\n- Time complexity:\\nO(N)\\n\\n- Space complexity:\\nO(N)\\n\\n# Code\\n```\\nclass Solution {\\n    public int numIdenticalPairs(int[] nums) {\\n\\n    HashMap<Integer,Integer>mp=new HashMap<>();\\n\\n    int count=0;\\n\\n    for(int i=0;i<nums.length;i++){\\n\\n    if(!mp.containsKey(nums[i])){\\n        mp.put(nums[i],1);\\n    }\\n    else{\\n        count+=mp.get(nums[i]);\\n        mp.put(nums[i],mp.get(nums[i])+1);\\n    }\\n\\n    }\\n\\n    return count;\\n\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int numIdenticalPairs(int[] nums) {\\n\\n    HashMap<Integer,Integer>mp=new HashMap<>();\\n\\n    int count=0;\\n\\n    for(int i=0;i<nums.length;i++){\\n\\n    if(!mp.containsKey(nums[i])){\\n        mp.put(nums[i],1);\\n    }\\n    else{\\n        count+=mp.get(nums[i]);\\n        mp.put(nums[i],mp.get(nums[i])+1);\\n    }\\n\\n    }\\n\\n    return count;\\n\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2968656,
                "title": "using-basic-combination-with-bucket-array",
                "content": "# Intuition\\n(Read the note below)\\nSince we have to count the number of pairs using `nCr` which is `n!/(n-r)! * r!`\\nTaking `r = 2`, since we are to count the number of pairs\\n\\n`nC2 = n!/(n-2)! * (2)!`\\n\\n# Approach\\nNow next step was to minimize the value of `nC2` else taking the worst case scenario 100 (max value of nums[i]) it\\'ll lead to overflow since 100! is a very big number. \\n\\nTherefore `nC2 = n! / (n-2)! * 2!`\\n`nC2 = n(n-1)(n-2)! / (n-2)! * 2!`\\n`nC2 = n(n-1) / 2`  _cancelling (n-2)! out_\\n\\n# Complexity\\n- Time complexity: __O(2n)__\\n\\n- Space complexity: __O(101)__\\n\\n# Note\\nbuc_arr[] is used to store the frequency of each element present in the nums vector.\\n\\nThe size is taken as 101 as the maximum value of nums[i] is 100 \\nTherefore that means `buc_arr[nums[i]]` cannot exceed a value of `buc_arr[100]` therefore size taken as `101` i.e. to accomodate all values from 0 to 100 \\n\\n# Code\\n```cpp\\nclass Solution {\\npublic:\\n    int numIdenticalPairs(vector<int>& nums) {\\n        // nC2 = n! / (n-2)! x 2!\\n        // nC2 = n(n-1)(n-2)! / (n-2)! x 2!\\n        // nC2 = n(n-1) / 2\\n\\n        vector<int> buc_arr(101);\\n        for(int x: nums)\\n            buc_arr[x]++;\\n        \\n        int sum = 0;\\n        for(int x: buc_arr) {\\n            sum += x*(x-1)/2;\\n        }\\n\\n        return sum;\\n\\n    }\\n};\\n```\\n\\n",
                "solutionTags": [
                    "C++",
                    "Math"
                ],
                "code": "```cpp\\nclass Solution {\\npublic:\\n    int numIdenticalPairs(vector<int>& nums) {\\n        // nC2 = n! / (n-2)! x 2!\\n        // nC2 = n(n-1)(n-2)! / (n-2)! x 2!\\n        // nC2 = n(n-1) / 2\\n\\n        vector<int> buc_arr(101);\\n        for(int x: nums)\\n            buc_arr[x]++;\\n        \\n        int sum = 0;\\n        for(int x: buc_arr) {\\n            sum += x*(x-1)/2;\\n        }\\n\\n        return sum;\\n\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2771165,
                "title": "c-map-math-o-n",
                "content": "***Explanation***\\ncount the occurrence of the same elements.\\nFor each new element a,\\nthere will be more count[a] pairs.\\nwith *A[i] == A[j]* and *i < j*\\n\\n***Explaining the logic:***\\n1) We can store the ints like a key in map, and the indexes save in the vector of ints like a  value in a map. \\nFor example 1, it will be like that:\\n[![image](https://assets.leetcode.com/users/images/72269524-2e0d-4d35-9887-e52b219a6485_1667408712.184323.png)\\n](http://)[](http://)\\n2) It is a fact that, to find the sum of numbers from 1 to n, the formula will be:\\n![image](https://assets.leetcode.com/users/images/8e4d0c3b-e70a-48e1-9377-3f314e0135e2_1667408825.1531677.png)\\n**((n)*(n+1))/2**\\n3) Then we can iterate trough the map and take the size of vectors and apply that formula to the sizes of vectors in map:\\n ``\\n int sum = ((i.second.size()-1)*(i.second.size()))/2;\\n ``\\n 4) and make `ans+=sum`\\n\\n***C++ code with comments:***\\n```\\n int numIdenticalPairs(vector<int>& nums) {\\n        map<int,vector<int>> mp; // creating a map with key - int, and value - vector\\n        for(int i = 0 ; i < nums.size();i++){\\n            // For example: key is 1, and we saving the indexes of this number. Example 1:\\n            // [1]:0,3,4\\n            // [2]:1\\n            // and etc...\\n            mp[nums[i]].push_back(i); \\n        }\\n        //declaring the variable to save the numbers of good pairs\\n        int ans = 0;\\n        \\n        for(auto i : mp){\\n            //using the formula to find the sum of numbers\\n            // ((n)*(n+1))/2\\n            // n - the size of the vector\\n            int sum = ((i.second.size()-1)*(i.second.size()))/2;\\n            // saving it to the ans\\n            ans+=sum;\\n        }\\n        //returning ans\\n        return ans;\\n    }\\n```\\n***C++ code without comments:***\\n```\\nint numIdenticalPairs(vector<int> &nums)\\n{\\n    map<int, vector<int>> mp;\\n    for (int i = 0; i < nums.size(); i++)\\n    {\\n        mp[nums[i]].push_back(i);\\n    }\\n    int ans = 0;\\n    for (auto i : mp)\\n    {\\n        int sum = ((i.second.size() - 1) * (i.second.size())) / 2;\\n\\n        ans += sum;\\n    }\\n    return ans;\\n}\\n```\\n\\n***Complexity***\\nTime O(N)\\nSpace O(N)\\n",
                "solutionTags": [
                    "C",
                    "Math"
                ],
                "code": "```\\n int numIdenticalPairs(vector<int>& nums) {\\n        map<int,vector<int>> mp; // creating a map with key - int, and value - vector\\n        for(int i = 0 ; i < nums.size();i++){\\n            // For example: key is 1, and we saving the indexes of this number. Example 1:\\n            // [1]:0,3,4\\n            // [2]:1\\n            // and etc...\\n            mp[nums[i]].push_back(i); \\n        }\\n        //declaring the variable to save the numbers of good pairs\\n        int ans = 0;\\n        \\n        for(auto i : mp){\\n            //using the formula to find the sum of numbers\\n            // ((n)*(n+1))/2\\n            // n - the size of the vector\\n            int sum = ((i.second.size()-1)*(i.second.size()))/2;\\n            // saving it to the ans\\n            ans+=sum;\\n        }\\n        //returning ans\\n        return ans;\\n    }\\n```\n```\\nint numIdenticalPairs(vector<int> &nums)\\n{\\n    map<int, vector<int>> mp;\\n    for (int i = 0; i < nums.size(); i++)\\n    {\\n        mp[nums[i]].push_back(i);\\n    }\\n    int ans = 0;\\n    for (auto i : mp)\\n    {\\n        int sum = ((i.second.size() - 1) * (i.second.size())) / 2;\\n\\n        ans += sum;\\n    }\\n    return ans;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2671622,
                "title": "c-explained-easy-using-permutation",
                "content": "```\\nThe approach is very simple. Count number of duplicates for each element in a given array and calculate nC2 which is used to select two elements at a time.\\n\\nNote: nC2=n*(n-1)/2\\n```\\n```\\nclass Solution {\\npublic:\\n    int numIdenticalPairs(vector<int>& nums) {\\n        map<int,int> m;\\n        for(int i=0;i<nums.size();i++) m[nums[i]]++;\\n        int c=0;\\n        for(auto i:m)\\n        {\\n            int n=i.second;\\n            c+=n*(n-1)/2;\\n        }\\n        return c;\\n    }\\n};\\n```\\n```\\nFeel free to comment if any doubt...\\n```",
                "solutionTags": [
                    "C",
                    "Probability and Statistics"
                ],
                "code": "```\\nThe approach is very simple. Count number of duplicates for each element in a given array and calculate nC2 which is used to select two elements at a time.\\n\\nNote: nC2=n*(n-1)/2\\n```\n```\\nclass Solution {\\npublic:\\n    int numIdenticalPairs(vector<int>& nums) {\\n        map<int,int> m;\\n        for(int i=0;i<nums.size();i++) m[nums[i]]++;\\n        int c=0;\\n        for(auto i:m)\\n        {\\n            int n=i.second;\\n            c+=n*(n-1)/2;\\n        }\\n        return c;\\n    }\\n};\\n```\n```\\nFeel free to comment if any doubt...\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2514502,
                "title": "java-solution-using-hashmap",
                "content": "Time Complexity : O(N)\\n\\n```\\n\\nclass Solution {\\n    public int numIdenticalPairs(int[] nums) {\\n        int count = 0;\\n        HashMap<Integer, Integer> map = new HashMap<>();\\n        for(int i=0; i<nums.length; i++){\\n            if(map.containsKey(nums[i])){\\n                count += map.get(nums[i]);\\n                map.put(nums[i], map.get(nums[i])+1);\\n            }\\n            else{\\n                map.put(nums[i], 1);\\n            }\\n        }\\n        return count;\\n    }\\n}",
                "solutionTags": [
                    "Java"
                ],
                "code": "class Solution {\\n    public int numIdenticalPairs(int[] nums) {\\n        int count = 0;\\n        HashMap<Integer, Integer> map = new HashMap<>();\\n        for(int i=0; i<nums.length; i++){\\n            if(map.containsKey(nums[i])){\\n                count += map.get(nums[i]);\\n                map.put(nums[i], map.get(nums[i])+1);\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 2449707,
                "title": "c-o-n-best-explanation-easy-understanding",
                "content": "### ***Use new version of leetcode to see latex expressions properly***\\n***\\n```\\n// Time Complexity = O(n)\\n// Space Complexity = O(n)\\n// Runtime : 0ms, faster than 100.00%\\n// Memory Usage : 7.2 MB, less than 60.74%\\n```\\n\\n```\\n    int numIdenticalPairs(vector<int>& nums) {\\n        \\n        unordered_map<int,int> hashmap;\\n        int goodPairs = 0;\\n        \\n        for(int i=0; i<nums.size(); i++)\\n            hashtable[nums[i]] += 1;\\n        \\n        for(auto element : hashtable)\\n            goodPairs += element.second * (element.second - 1) / 2;\\n        \\n        return goodPairs;\\n    }\\n```\\n\\nFirst, we find the count of numbers in the array with **hashmap**.\\n\\nLet our array be [1,2,3,1,1,3,1,1,3]\\nWe can specify good pairs as the count of same numbers after them.\\nThere are 5 1s in an array, where the positions of the numbers don\\'t matter to us because all we\\'re looking at are the numbers that come after them that are the same as themselves. Returning to our example, after the first 1 will come 4 more 1s. The second future is 3 after 1, the third future is 2 after 1, and so on until 1.\\n\\nNow let **a** be the count of 1 in the array. After the first 1 will come a-1 more 1s. The second future is a-2 after 1, the third future is a-3 after 1, and so on until 1.\\n\\nNow let\\'s change our arr a little bit and let our new array be [1,2,3,1,1,3,1,1,3,1,1,3,1,1,1,1,3, \\u2026 , 1,1]\\nLet **a** be the count of 1s here too\\n\\n\\n\\n| Arr | Count of 1s after ***bold-italic*** value (**a** is count of all 1s) |\\n|:-:| :-:|\\n| [***1***,2,3,1,1,3,1,1,3,1,1,3,1,1,1,1,3, \\u2026 , 1,1]| a-1 |\\n| [1,2,3,***1***,1,3,1,1,3,1,1,3,1,1,1,1,3, \\u2026 , 1,1]| a-2 |\\n| [1,2,3,1,***1***,3,1,1,3,1,1,3,1,1,1,1,3, \\u2026 , 1,1]| a-3 |\\n| ... | |\\n| [1,2,3,1,1,3,1,1,3,1,1,3,1,1,1,1,3, \\u2026 , ***1***,1]| 1 |\\n\\n****\\nIf check the second column you can see numbers goes to 1 from a-1 so we can specify as\\nTotal number of good pairs = $$[(a-1) + (a-2)+(a-3)+...+1]$$\\n\\n\\nIf we use consecutive numbers formula on *Total number of good pairs*\\n\\n$$\\\\Large\\\\frac {n(firstNumber + lastNumber)}{2}$$  $$\\\\leftarrow$$ this is the **consecutive formula**\\n\\nin our problem,\\n*n* = **a-1**, because when size **a** we start from **a-1** \\nfor example 1s count are 5, its sum of good pairs 4+3+2+1. That\\u2019s why size is 5-1 = 4, so **a-1**.\\n\\n*first number* = **a - 1**,\\n*last number* = **1**,\\n\\nIf we substitute the variables\\n$$\\\\Large\\\\frac {(a-1) * (a-1 + 1)}{2} = \\\\Large\\\\frac{(a-1) * a}{2}$$\\n\\nWith $\\\\large\\\\frac{(a-1) * a}{2}$, we calculate the number of good pairs for each different number and return the sum.\\n\\n**If we use the counts of the numbers we keep in the hashmap in this formula and sum the results, we will find the good pairs in the array.**\\n\\n\\n```\\nbool shouldYouUpvote() { return (I helped == true) ? upvote : nothing; }\\n```\\n\\n\\n\\n\\n\\n",
                "solutionTags": [
                    "C++",
                    "Hash Table",
                    "Math"
                ],
                "code": "```\\n// Time Complexity = O(n)\\n// Space Complexity = O(n)\\n// Runtime : 0ms, faster than 100.00%\\n// Memory Usage : 7.2 MB, less than 60.74%\\n```\n```\\n    int numIdenticalPairs(vector<int>& nums) {\\n        \\n        unordered_map<int,int> hashmap;\\n        int goodPairs = 0;\\n        \\n        for(int i=0; i<nums.size(); i++)\\n            hashtable[nums[i]] += 1;\\n        \\n        for(auto element : hashtable)\\n            goodPairs += element.second * (element.second - 1) / 2;\\n        \\n        return goodPairs;\\n    }\\n```\n```\\nbool shouldYouUpvote() { return (I helped == true) ? upvote : nothing; }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2094229,
                "title": "python-oneliner-solution",
                "content": "Here is my python one-liner:\\n\\n```python\\n        return sum(c * (c - 1) // 2 for c in Counter(nums).values())\\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```python\\n        return sum(c * (c - 1) // 2 for c in Counter(nums).values())\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1151026,
                "title": "good-100-faster-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    int numIdenticalPairs(vector<int>& nums) {\\n        int n = nums.size();\\n        map<int,int> smap;\\n        int count =0;\\n        for(int  i =0;i<n;i++)\\n        {\\n            count+=smap[nums[i]];\\n            smap[nums[i]]++;\\n        }\\n        return count;\\n        \\n    }\\n}\\n```",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int numIdenticalPairs(vector<int>& nums) {\\n        int n = nums.size();\\n        map<int,int> smap;\\n        int count =0;\\n        for(int  i =0;i<n;i++)\\n        {\\n            count+=smap[nums[i]];\\n            smap[nums[i]]++;\\n        }\\n        return count;\\n        \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 987128,
                "title": "java-easiest-100-faster",
                "content": "```\\nclass Solution {\\n    public int numIdenticalPairs(int[] nums) {\\n\\tint answer = 0;\\n\\tint[] freq = new int[102];\\n        \\n\\tfor (int i : nums) {\\n\\t\\tif (freq[i] == 0) freq[i]++;\\n\\t\\telse{\\n\\t\\t\\tanswer += freq[i];\\n\\t\\t\\tfreq[i]++;\\n\\t\\t}\\n\\t}\\n\\treturn answer;\\n}\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int numIdenticalPairs(int[] nums) {\\n\\tint answer = 0;\\n\\tint[] freq = new int[102];\\n        \\n\\tfor (int i : nums) {\\n\\t\\tif (freq[i] == 0) freq[i]++;\\n\\t\\telse{\\n\\t\\t\\tanswer += freq[i];\\n\\t\\t\\tfreq[i]++;\\n\\t\\t}\\n\\t}\\n\\treturn answer;\\n}\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 981334,
                "title": "java-0-ms-runtime-beats-100",
                "content": "**Method 1**: T: O(n\\xB2), S: O(1)\\n```\\npublic int numIdenticalPairs(int[] nums) {\\n\\tint count = 0;\\n\\tfor (int i = 0; i < nums.length; i++)\\n\\t\\tfor (int j = i + 1; j < nums.length; j++)\\n\\t\\t\\tif (nums[i] == nums[j])\\n\\t\\t\\t\\tcount++;\\n\\treturn count;\\n}\\n```\\n\\n**Method 2**: T: O(n), S: O(n)\\n```\\npublic int numIdenticalPairs(int[] nums) {\\n\\tint count = 0;\\n\\tMap<Integer, Integer> frequencyByNum = new HashMap<>();\\n\\tfor (int num : nums) {\\n\\t\\tInteger frequency = frequencyByNum.get(num);\\n\\t\\tif (frequency == null) {\\n\\t\\t\\tfrequencyByNum.put(num, 1);\\n\\t\\t} else {\\n\\t\\t\\tcount += frequency;\\n\\t\\t\\tfrequencyByNum.put(num, frequency + 1);\\n\\t\\t}\\n\\t}\\n\\treturn count;\\n}\\n```\\n\\n**Method 2 but simpler**: T: O(n), S: O(n)\\n```\\npublic int numIdenticalPairs(int[] nums) {\\n\\tint count = 0;\\n\\tMap<Integer, Integer> frequencyByNum = new HashMap<>();\\n\\tfor (int num : nums) {\\n\\t\\tif (frequencyByNum.containsKey(num))\\n\\t\\t\\tcount += frequencyByNum.get(num);\\n\\t\\tfrequencyByNum.compute(num, (k, v) -> v == null ? 1 : v + 1);\\n\\t}\\n\\treturn count;\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\npublic int numIdenticalPairs(int[] nums) {\\n\\tint count = 0;\\n\\tfor (int i = 0; i < nums.length; i++)\\n\\t\\tfor (int j = i + 1; j < nums.length; j++)\\n\\t\\t\\tif (nums[i] == nums[j])\\n\\t\\t\\t\\tcount++;\\n\\treturn count;\\n}\\n```\n```\\npublic int numIdenticalPairs(int[] nums) {\\n\\tint count = 0;\\n\\tMap<Integer, Integer> frequencyByNum = new HashMap<>();\\n\\tfor (int num : nums) {\\n\\t\\tInteger frequency = frequencyByNum.get(num);\\n\\t\\tif (frequency == null) {\\n\\t\\t\\tfrequencyByNum.put(num, 1);\\n\\t\\t} else {\\n\\t\\t\\tcount += frequency;\\n\\t\\t\\tfrequencyByNum.put(num, frequency + 1);\\n\\t\\t}\\n\\t}\\n\\treturn count;\\n}\\n```\n```\\npublic int numIdenticalPairs(int[] nums) {\\n\\tint count = 0;\\n\\tMap<Integer, Integer> frequencyByNum = new HashMap<>();\\n\\tfor (int num : nums) {\\n\\t\\tif (frequencyByNum.containsKey(num))\\n\\t\\t\\tcount += frequencyByNum.get(num);\\n\\t\\tfrequencyByNum.compute(num, (k, v) -> v == null ? 1 : v + 1);\\n\\t}\\n\\treturn count;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 745974,
                "title": "simplest-solution-with-python-3",
                "content": "```\\n    def numIdenticalPairs(self, nums: List[int]) -> int:\\n        set_nums=set(nums)\\n        good=0\\n        for x in set_nums:\\n            n=nums.count(x)\\n            good+=(n*(n-1))/2 \\n\\t\\t\\t#finding number of occurences of element and using nC2 to find good pairs \\n        return int(good)\\n```",
                "solutionTags": [],
                "code": "```\\n    def numIdenticalPairs(self, nums: List[int]) -> int:\\n        set_nums=set(nums)\\n        good=0\\n        for x in set_nums:\\n            n=nums.count(x)\\n            good+=(n*(n-1))/2 \\n\\t\\t\\t#finding number of occurences of element and using nC2 to find good pairs \\n        return int(good)\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 732229,
                "title": "python-faster-than-100-of-submission",
                "content": "```\\n        freq={}\\n        output=0\\n        for num in nums:\\n            if not num in freq:\\n                freq[num]=0\\n            freq[num]+=1\\n        \\n        for num in freq:\\n            n=freq[num]\\n            output+=(n*(n-1)//2)\\n            \\n        return output\\n```\\n\\n",
                "solutionTags": [],
                "code": "```\\n        freq={}\\n        output=0\\n        for num in nums:\\n            if not num in freq:\\n                freq[num]=0\\n            freq[num]+=1\\n        \\n        for num in freq:\\n            n=freq[num]\\n            output+=(n*(n-1)//2)\\n            \\n        return output\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3784488,
                "title": "easiest-c-solution-o-n-time-complexity-beats-100",
                "content": "\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int numIdenticalPairs(vector<int>& nums) {\\n        unordered_map<int, int> m;\\n        int ans = 0;\\n        for(auto num : nums){\\n            ans += m[num];\\n            m[num]++;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Hash Table"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int numIdenticalPairs(vector<int>& nums) {\\n        unordered_map<int, int> m;\\n        int ans = 0;\\n        for(auto num : nums){\\n            ans += m[num];\\n            m[num]++;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3090562,
                "title": "easy-to-understand-c-code-rt-0-ms-memory-7-2-mb",
                "content": "\\n\\n# Complexity\\n- Runtime: 0 ms\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Memory: 7.2 Mb\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int numIdenticalPairs(vector<int>& nums) {\\n        int c=0;\\n        for(int i=0;i<nums.size();i++){\\n            for(int j=i+1;j<nums.size();j++){\\n                if(nums[i]==nums[j]){\\n                    c++;\\n                }\\n            }\\n        }return c;\\n    }\\n};\\n```\\nIf you like the code approach, make sure to upvote \\u270C\\uFE0F. \\nGooD Day",
                "solutionTags": [
                    "C++",
                    "Array"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int numIdenticalPairs(vector<int>& nums) {\\n        int c=0;\\n        for(int i=0;i<nums.size();i++){\\n            for(int j=i+1;j<nums.size();j++){\\n                if(nums[i]==nums[j]){\\n                    c++;\\n                }\\n            }\\n        }return c;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3055896,
                "title": "easy-python-solution-more-than-80-beats",
                "content": "simply use nested for loop.\\n```\\nfor i in range(0,len(nums)):\\n    for j in range(i+1,len(nums)):\\n```\\nThe outer loop will run from index 0 upto 2nd last index, because in the inner loop we are comparing the items with rest of the list.\\n\\nThe outer loop starts from i+1 and stop as 2nd last index.\\nThat way we can compare every element with rest of the list, if num[i] equals to num[j] then count it.\\n\\n# Code\\n```\\nclass Solution(object):\\n    def numIdenticalPairs(self, nums):\\n        \"\"\"\\n        :type nums: List[int]\\n        :rtype: int\\n        \"\"\"\\n        count =0\\n        for i in range(0,len(nums)):\\n            for j in range(i+1,len(nums)):\\n                if nums[i] == nums[j]:\\n                    count += 1\\n        return count\\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nfor i in range(0,len(nums)):\\n    for j in range(i+1,len(nums)):\\n```\n```\\nclass Solution(object):\\n    def numIdenticalPairs(self, nums):\\n        \"\"\"\\n        :type nums: List[int]\\n        :rtype: int\\n        \"\"\"\\n        count =0\\n        for i in range(0,len(nums)):\\n            for j in range(i+1,len(nums)):\\n                if nums[i] == nums[j]:\\n                    count += 1\\n        return count\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2902383,
                "title": "single-loop-o-n-speed-hash-table-fast",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\nThe good pair quantites are same as how many identical number already accululated each time when you encounter the same number. For example, if number 1 appears 4 times already, then the next time you encounter number 1, that will contribute 4 quantites to the good pair. So we only need to record how many times the number appears and save it in a bucket for that number. That is the hash table. \\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\nTaking advantage of only 100 distinct possible numbers, our hash function can directly map the key to the index of hashmap array\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\nSince we only for loop once, it is O(n)\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\nWe need full size hashmap, O(n) space complexity\\n\\n# Code\\n```\\nint numIdenticalPairs(int* nums, int numsSize){\\n    int hashmap[101] = {0};\\n    for(int i = 0; i < numsSize; i++){\\n        hashmap[0]+= hashmap[nums[i]]++;\\n    }\\n    return hashmap[0];\\n\\n}\\n```",
                "solutionTags": [
                    "C",
                    "Hash Table",
                    "Hash Function"
                ],
                "code": "```\\nint numIdenticalPairs(int* nums, int numsSize){\\n    int hashmap[101] = {0};\\n    for(int i = 0; i < numsSize; i++){\\n        hashmap[0]+= hashmap[nums[i]]++;\\n    }\\n    return hashmap[0];\\n\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2432446,
                "title": "java-using-hashmaps",
                "content": "```class Solution {\\n    public int numIdenticalPairs(int[] nums) {\\n        HashMap <Integer, Integer> map = new HashMap<>();\\n        HashMap <Integer, Integer> goodPairs = new HashMap<>();\\n        \\n        for(int i = 0; i < nums.length; i++) {\\n            int curr = nums[i];\\n            if(!map.containsKey(curr)) {\\n                map.put(curr, 1);\\n            } else {\\n                int occurences = map.get(curr);\\n                occurences = occurences + 1;\\n                map.replace(curr, occurences);\\n                if(!goodPairs.containsKey(curr)) {\\n                    goodPairs.put(curr, 1);\\n                } else {\\n                    int goodP = goodPairs.get(curr);\\n                    int pairs = occurences + (goodP -1);\\n                    goodPairs.replace(curr, pairs);\\n                }\\n                \\n            }\\n        }\\n        \\n        Set <Integer> set = new HashSet<>();\\n        set = goodPairs.keySet();\\n        int sum = 0;\\n        \\n        for(int i: set) {\\n            int value = goodPairs.get(i);\\n            sum = sum + value;\\n        }\\n        \\n        return sum;\\n        \\n        \\n        \\n    }\\n}\\n\\n\\n    //math examples\\n//     when occurences = 2 \\n//    + (goodpair-1)\\n//     good pair = 1\\n    \\n//     occurence = 3\\n//     + (goodpair-1)\\n//     good pair = 3\\n    \\n//     occurence = 4\\n//     + (goodpair - 1)\\n//     good pairs = 6\\n    \\n//     occurence = 5\\n//     + (goodpair-1)\\n    \\n",
                "solutionTags": [],
                "code": "class Solution {\\n    public int numIdenticalPairs(int[] nums) {\\n        HashMap <Integer, Integer> map = new HashMap<>();\\n        HashMap <Integer, Integer> goodPairs = new HashMap<>();\\n        \\n        for(int i = 0; i < nums.length; i++) {\\n            int curr = nums[i];\\n            if(!map.containsKey(curr)) {\\n                map.put(curr, 1);\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 1976561,
                "title": "python-3-99-fast-3-solutions-each-better-than-the-other",
                "content": "**Suggestions to make it better are always welcomed.**\\n\\nWe can use that brute force which can get us the solution in O(n^2) time.\\nBut that would be a naive solution. \\nEvery following solution is built upon previous solution and give us 99% best result after submission when you submit solution 3.\\n\\n**Solution 1:**\\n```\\nclass Solution:\\n    def numIdenticalPairs(self, nums: List[int]) -> int:\\n        mapping = collections.defaultdict(list)\\n        count = 0\\n        \\n        for i, num in enumerate(nums):\\n            mapping[num].append(i)\\n            \\n        for indexes in mapping.values():\\n            for i in range(len(indexes)-1):\\n                for j in range(i+1, len(indexes)):\\n                    count += 1\\n                    \\n        return count\\n```\\n        \\n**Solution 2**\\n```\\nclass Solution:\\n    def numIdenticalPairs(self, nums: List[int]) -> int:\\n        mapping = collections.defaultdict(list)\\n        count = 0\\n        \\n        for i, num in enumerate(nums):\\n            mapping[num].append(i)                \\n            \\n        for indexes in mapping.values():\\n            size = len(indexes)\\n            count += (size * (size-1))//2\\n            \\n        return count\\n```\\n\\n**Solution 3**\\n```\\nclass Solution:\\n    def numIdenticalPairs(self, nums: List[int]) -> int:\\n        mapping = collections.Counter(nums)\\n        count = 0\\n                \\n        for value in mapping.values():\\n            count += (value * (value-1))//2\\n            \\n        return count\\n```\\n\\n**I hope that you\\'ve found this useful.\\nIn that case, please upvote. It only motivates me to write more such posts\\uD83D\\uDE03**",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def numIdenticalPairs(self, nums: List[int]) -> int:\\n        mapping = collections.defaultdict(list)\\n        count = 0\\n        \\n        for i, num in enumerate(nums):\\n            mapping[num].append(i)\\n            \\n        for indexes in mapping.values():\\n            for i in range(len(indexes)-1):\\n                for j in range(i+1, len(indexes)):\\n                    count += 1\\n                    \\n        return count\\n```\n```\\nclass Solution:\\n    def numIdenticalPairs(self, nums: List[int]) -> int:\\n        mapping = collections.defaultdict(list)\\n        count = 0\\n        \\n        for i, num in enumerate(nums):\\n            mapping[num].append(i)                \\n            \\n        for indexes in mapping.values():\\n            size = len(indexes)\\n            count += (size * (size-1))//2\\n            \\n        return count\\n```\n```\\nclass Solution:\\n    def numIdenticalPairs(self, nums: List[int]) -> int:\\n        mapping = collections.Counter(nums)\\n        count = 0\\n                \\n        for value in mapping.values():\\n            count += (value * (value-1))//2\\n            \\n        return count\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1554480,
                "title": "c-faster-than-100",
                "content": "```\\nclass Solution {\\npublic:\\n    int numIdenticalPairs(vector<int>& nums) {\\n        int count = 0;\\n        for(int index = 0;index<nums.size();index++)\\n        {\\n            for(int jindex=index+1;jindex<nums.size();jindex++)\\n            {\\n                if(nums[index]==nums[jindex])\\n                    count++;\\n            }\\n        }\\n        return count;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int numIdenticalPairs(vector<int>& nums) {\\n        int count = 0;\\n        for(int index = 0;index<nums.size();index++)\\n        {\\n            for(int jindex=index+1;jindex<nums.size();jindex++)\\n            {\\n                if(nums[index]==nums[jindex])\\n                    count++;\\n            }\\n        }\\n        return count;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1520782,
                "title": "java-simple-o-n-time-complexity-easy-to-understand",
                "content": "\\n```\\npublic int numIdenticalPairs(int[] nums) {\\n        \\n        Map<Integer, Integer> map = new HashMap<>(); // to count number of occurences of number\\n        int ans = 0; // result\\n        \\n        for (int i : nums) {\\n            int count = map.getOrDefault(i, 0); // if number doesn\\'t exist in array then simply return 0, else return number of time it occurred\\n\\t\\t\\t/**\\n\\t\\t\\tE.g we have nums = [1,2,3,1,1,3]\\n\\t\\t\\ttill [1,2,3] we have 0 ans, map->[{1,1}, {2,1}, {3,1}]\\n\\t\\t\\t1. now  we have first duplicate number come i.e. 1\\n\\t\\t\\tans updated to 1 and map updated to 2\\n\\t\\t\\tmap->[{1,2}, {2,1}, {3,1}], ans->1\\n\\t\\t\\t2. and now again 1 (index 4)\\n\\t\\t\\tans updated to 3 and map updated to 3\\n\\t\\t\\tmap->[{1,3}, {2,1}, {3,1}], ans->3\\n\\t\\t\\t3. now come 3 which is second occurence for number 3\\n\\t\\t\\tans updated to 4 (because for key 3 we have value 1 in map)\\n\\t\\t\\tmap->[{1,3}, {2,1}, {3,2}], ans->4\\n\\t\\t\\t4. And answer is 4 {as all indexes travelled}\\n\\t\\t\\n\\t\\t\\t*/\\n            ans += count; // add it to result\\n            map.put(i, count + 1);//update the frequency/count of number in map\\n        }\\n        return ans;\\n    }\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\npublic int numIdenticalPairs(int[] nums) {\\n        \\n        Map<Integer, Integer> map = new HashMap<>(); // to count number of occurences of number\\n        int ans = 0; // result\\n        \\n        for (int i : nums) {\\n            int count = map.getOrDefault(i, 0); // if number doesn\\'t exist in array then simply return 0, else return number of time it occurred\\n\\t\\t\\t/**\\n\\t\\t\\tE.g we have nums = [1,2,3,1,1,3]\\n\\t\\t\\ttill [1,2,3] we have 0 ans, map->[{1,1}, {2,1}, {3,1}]\\n\\t\\t\\t1. now  we have first duplicate number come i.e. 1\\n\\t\\t\\tans updated to 1 and map updated to 2\\n\\t\\t\\tmap->[{1,2}, {2,1}, {3,1}], ans->1\\n\\t\\t\\t2. and now again 1 (index 4)\\n\\t\\t\\tans updated to 3 and map updated to 3\\n\\t\\t\\tmap->[{1,3}, {2,1}, {3,1}], ans->3\\n\\t\\t\\t3. now come 3 which is second occurence for number 3\\n\\t\\t\\tans updated to 4 (because for key 3 we have value 1 in map)\\n\\t\\t\\tmap->[{1,3}, {2,1}, {3,2}], ans->4\\n\\t\\t\\t4. And answer is 4 {as all indexes travelled}\\n\\t\\t\\n\\t\\t\\t*/\\n            ans += count; // add it to result\\n            map.put(i, count + 1);//update the frequency/count of number in map\\n        }\\n        return ans;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1404812,
                "title": "java-fasted-method-100-working-o-n",
                "content": "class Solution {\\n    public int numIdenticalPairs(int[] nums) {\\n        \\n        int n = nums.length;\\n            \\n        int goodPairs=0;\\n      \\n        int[] map = new int[101];\\n        \\n        \\n        for(int i=0;i<n;i++){\\n            map[nums[i]]++;\\n        }\\n        \\n     \\n        for(int i=0;i<=100;i++){\\n            if(map[i] > 1){\\n                goodPairs += (map[i] * (map[i]-1)) / 2; \\n            }\\n        }\\n        return goodPairs;\\n    }\\n}",
                "solutionTags": [],
                "code": "class Solution {\\n    public int numIdenticalPairs(int[] nums) {\\n        \\n        int n = nums.length;\\n            \\n        int goodPairs=0;\\n      \\n        int[] map = new int[101];\\n        \\n        \\n        for(int i=0;i<n;i++){\\n            map[nums[i]]++;\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 1353137,
                "title": "c-hashmap-solution-0-n",
                "content": "\\'\\'\\'\\n  class Solution {\\npublic:\\n    int numIdenticalPairs(vector<int>& nums) {\\n        \\n        \\n        ios_base::sync_with_stdio(false);\\n        cin.tie(NULL);\\n        \\nunordered_map<int,int>dp;\\n        \\n        \\n        int good_pairs,x;good_pairs=0;x=0;\\n        \\n        for(int i=0;i<nums.size();i++)\\n        {\\n             dp[nums[i]]++;  //storing the count of each num;  \\n        }\\n        \\n        for(auto i=dp.begin();i!=dp.end();i++)    \\n      {\\n          if(i->second>1)\\n          {\\n        x=(i->second*(i->second-1))>>1;\\n              good_pairs=good_pairs+x;\\n              \\n          }\\n      }\\n        return good_pairs;\\n    \\n                                       \\n    }\\n};\\n\\n\\'\\'\\'",
                "solutionTags": [],
                "code": "class Solution {\\npublic:\\n    int numIdenticalPairs(vector<int>& nums) {\\n        \\n        \\n        ios_base::sync_with_stdio(false);\\n        cin.tie(NULL);\\n        \\nunordered_map<int,int>dp;\\n        \\n        \\n        int good_pairs,x;good_pairs=0;x=0;\\n        \\n        for(int i=0;i<nums.size();i++)\\n        {\\n             dp[nums[i]]++;  //storing the count of each num;  \\n        }",
                "codeTag": "Java"
            },
            {
                "id": 1281128,
                "title": "c-simple-you-ll-love-it-guaranteed",
                "content": "If you have Learned something new please give it upvote;\\notherwise thank you for having a look \\uD83D\\uDE4F\\uD83C\\uDFFB\\n\\nstoring values to set to avoid repeatation.\\n\\n```\\nint numIdenticalPairs(vector<int>& nums) {\\n\\tset<int>set1; int pairs = 0;\\n\\tfor(int i=0; i<nums.size(); i++){\\n\\t\\tif(set1.find(nums[i]) == set1.end()){\\n\\t\\t\\tint cnt = count(begin(nums), end(nums), nums[i]);\\n\\t\\t\\tpairs += cnt * (cnt-1)/2;\\n\\t\\t\\tset1.insert(nums[i]);\\n\\t\\t}\\n\\t}\\n\\treturn pairs;\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nint numIdenticalPairs(vector<int>& nums) {\\n\\tset<int>set1; int pairs = 0;\\n\\tfor(int i=0; i<nums.size(); i++){\\n\\t\\tif(set1.find(nums[i]) == set1.end()){\\n\\t\\t\\tint cnt = count(begin(nums), end(nums), nums[i]);\\n\\t\\t\\tpairs += cnt * (cnt-1)/2;\\n\\t\\t\\tset1.insert(nums[i]);\\n\\t\\t}\\n\\t}\\n\\treturn pairs;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1209470,
                "title": "java-100-solution-with-hashmap",
                "content": "\\nclass Solution {\\n    public int numIdenticalPairs(int[] nums) {\\n       \\n        Map<Integer,Integer> map=new HashMap<>();\\n        \\n        for(int i=0;i<nums.length;i++)\\n        {\\n            map.put( nums[i], map.getOrDefault(nums[i],0) + 1);\\n        }\\n        \\n        int sum=0;\\n        \\n        for(Integer i: map.keySet())\\n        {\\n            int count=map.get(i);\\n            if(count>1)\\n                sum=sum+(count*(count-1))/2;    //for n items, n*(n-1)/2 pairs exist\\n        }\\n        \\n        return sum;\\n    }\\n}",
                "solutionTags": [],
                "code": "class Solution {\\n    public int numIdenticalPairs(int[] nums) {\\n       \\n        Map<Integer,Integer> map=new HashMap<>();\\n        \\n        for(int i=0;i<nums.length;i++)\\n        {\\n            map.put( nums[i], map.getOrDefault(nums[i],0) + 1);\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 933762,
                "title": "o-n-javascript-solution",
                "content": "```\\nconst numIdenticalPairs = (nums) => {\\n    \\n    let map = {};\\n    let counter = 0;\\n    \\n    for(val of nums) {\\n        !map[val] ? map[val] = 1 : counter += map[val]++ \\n    }\\n    \\n    return counter;\\n    \\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\nconst numIdenticalPairs = (nums) => {\\n    \\n    let map = {};\\n    let counter = 0;\\n    \\n    for(val of nums) {\\n        !map[val] ? map[val] = 1 : counter += map[val]++ \\n    }\\n    \\n    return counter;\\n    \\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 910704,
                "title": "simple-java-solution-with-explaination-0ms-o-n-time-constant-space-100-faster-single-loop",
                "content": "1.take output array of size 101 (since this is the max possible numbers) and count variable to store the total number of pairs.\\n2.start counting frequency of each element. before incrementing frequency just add the current frequency to the count. (why? because we need to add pair i.e. one less than the frequency).\\n3. once loop finishes count will hold the answer.\\n```\\nclass Solution {\\n    public int numIdenticalPairs(int[] nums) {\\n        int[]  op = new int[101];\\n        int c=0;\\n        for(int i:nums) {\\n            c+=op[i]++;\\n        }\\n        return c;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int numIdenticalPairs(int[] nums) {\\n        int[]  op = new int[101];\\n        int c=0;\\n        for(int i:nums) {\\n            c+=op[i]++;\\n        }\\n        return c;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 819035,
                "title": "python-3-98-52-faster-3-techniques-but-only-1-optimal-solution",
                "content": "**Suggestions to make it better are always welcomed.**\\n\\nThere are 3 ways of doing this:\\n1. Use 2 for loops. For every ith element, compare with the remaining i+1 to n elements. If match is found, increase the count. This is T=O(n2) and S=O(1)\\n\\n2. Sort the list before processing it. This way all the matching numbers will be near each other. Now searching for the pair can be done using binary search. Assuming sorting is O(n log n) and binary search for every ith element is also O(n log n), overall T = O(n log n) and S = O(1)\\n\\n3. Using dictionary. Record every elements that we encounter. If the element already exists, then increment it\\'s count. We sum the elements that match and return the result. Here T=O(n) at the expense of space, S=O(n)\\n\\n**Implementation of solution 3:**\\n```\\ndef numIdenticalPairs(self, nums: List[int]) -> int:\\n\\tmapping = collections.defaultdict(int)\\n\\ttotal = 0\\n\\tfor i in range(len(nums)):\\n\\t\\ttotal += mapping[nums[i]]\\n\\t\\tmapping[nums[i]] += 1\\n\\treturn total\\n```\\n\\n**If this solution helped, please upvote it for others to take advantage of it and learn their techniques**",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\ndef numIdenticalPairs(self, nums: List[int]) -> int:\\n\\tmapping = collections.defaultdict(int)\\n\\ttotal = 0\\n\\tfor i in range(len(nums)):\\n\\t\\ttotal += mapping[nums[i]]\\n\\t\\tmapping[nums[i]] += 1\\n\\treturn total\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 803606,
                "title": "a-simple-c-solution-faster-than-100",
                "content": "```\\nclass Solution {\\npublic:\\n    int numIdenticalPairs(vector<int>& nums) {\\n        map<int , int> m; int sum=0;\\n        for(auto i : nums) m[i]++;\\n        for(auto i : m) {\\n        int num = i.second; \\n        if(num>1) sum += (num*(num-1))/2;  \\n        }\\n        return sum;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int numIdenticalPairs(vector<int>& nums) {\\n        map<int , int> m; int sum=0;\\n        for(auto i : nums) m[i]++;\\n        for(auto i : m) {\\n        int num = i.second; \\n        if(num>1) sum += (num*(num-1))/2;  \\n        }\\n        return sum;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 787607,
                "title": "python-sol-by-iteration",
                "content": "Python sol by iteration\\n\\n---\\n\\n**Implementation**:\\n\\n```\\nclass Solution:\\n    def numIdenticalPairs(self, nums: List[int]) -> int:\\n        \\n        size = len(nums)\\n        \\n        good_pair_count = 0\\n        \\n        for i in range(size - 1):\\n            \\n            for j in range(i+1, size):\\n                \\n                if nums[i] == nums[j]:\\n                    good_pair_count += 1\\n                    \\n        \\n        return good_pair_count\\n```",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Iterator"
                ],
                "code": "```\\nclass Solution:\\n    def numIdenticalPairs(self, nums: List[int]) -> int:\\n        \\n        size = len(nums)\\n        \\n        good_pair_count = 0\\n        \\n        for i in range(size - 1):\\n            \\n            for j in range(i+1, size):\\n                \\n                if nums[i] == nums[j]:\\n                    good_pair_count += 1\\n                    \\n        \\n        return good_pair_count\\n```",
                "codeTag": "Java"
            },
            {
                "id": 783552,
                "title": "three-java-solutions-including-optimal-0ms-and-100-faster",
                "content": "**Approach 1.** \\nNaive brute force solution. O(N^2) time and O(1) space. Max(N) == 100;\\n```\\nclass Solution {\\n    public int numIdenticalPairs(int[] nums) {\\n        int  ret = 0;\\n        for (int i = 0; i < nums.length; i++) {\\n            for (int j = i + 1; j < nums.length; j++){\\n                if (nums[i]==nums[j]) ret++;\\n            }\\n        }\\n        return ret;\\n    }\\n}\\n\\n``` \\n**APPROACH 2**. \\nCombinatorics. O(N) time (max(N) == 100) and O(N) space complexity. \\nThis approach is based on the number ways to sample r elements (== 2 in our case) from n elements.\\n**C = n!/(r! * (n-r)!)**\\n\\nTime complexity : O(N) space, space is O(1) since the number n is limited to 100;\\nFactorial calculation is DP based. And we need to use BigInteger to avoid overflows\\n\\n```\\nstatic HashMap<Integer, BigInteger> facts = new HashMap<>();\\n\\n    static {\\n        facts.put(1, BigInteger.ONE);\\n        facts.put(0, BigInteger.ONE);\\n        for (int i = 2; i <= 100; i++) {\\n            fact(i);\\n        }\\n    }\\n        \\n     public static int numIdenticalPairs(int[] nums) {\\n        HashMap<Integer, Integer> counts = new HashMap<>();\\n\\n        for (int i = nums.length - 1; i >= 0; i--) {\\n            counts.put(nums[i], counts.getOrDefault(nums[i], 0) + 1);\\n        }\\n\\n        int ret = 0;\\n\\n        for (int key : counts.values()) {\\n            int numOfComb = key == 1 ? 0 : calcNumbOfComb(key);\\n            if (numOfComb > 0) ret += numOfComb;\\n        }\\n\\n        return ret;\\n    }\\n\\n    private static int calcNumbOfComb(int i) {\\n\\n        BigInteger nF = fact(i);\\n        BigInteger nrFact = fact(i - 2);\\n        return (nF.divide(BigInteger.TWO.multiply(nrFact))).intValue();\\n    }\\n\\n    private static BigInteger fact(int i) {\\n        if (facts.get(i) == null) {\\n            if (facts.get(i - 1) == null)\\n                facts.put(i - 1, fact(i - 2).multiply(BigInteger.valueOf(i - 1)));\\n            facts.put(i, BigInteger.valueOf(i).multiply(facts.get(i - 1)));\\n        }\\n\\n        return facts.get(i);\\n    }\\n```\\n**APPROACH 2 Optimized**. \\nWe can simplify by canceling (n - 2)! in **C = n!/(r! * (n-r)!)**.\\n**C = n!/(r! * (n-r)!) = n * (n-1) * (n-2)!/(2! * (n-2)!) = n * (n-1)/2**. This means that it is not necessary to caculate factorials which simplifies the solution. \\n\\nHere is an example of experimental way to get the same formula\\n\\n\\t// Sample input: [1,1,1,1]. Start looking from the end of the array.\\n    // Number of ones: 1 -> 0 (+0) possible pairs -> 1 * 0/2\\n    // Number of ones: 2 -> 1 (+1) possible pair -> 2 * 1/2\\n    // Number of ones: 3 -> 3 (+2) possible pairs -> 3 * 2/2\\n    // Number of ones: 4 -> 6 (+3) possible pairs -> 4 * 3/2\\n    // Number of ones: 5 -> 10 (+4) possible pairs -> 5 * 4/2\\n\\t// Number of ones: n ->  x (+ n-1) possible pair -> x = n * (n - 1)/2\\n\\n**Here is the final solution**\\n```\\nimport java.math.BigInteger;\\nimport java.util.ArrayList;\\nimport java.util.HashMap;\\n\\nclass Solution {\\n    \\npublic static int numIdenticalPairs(int[] nums) {\\n        // Count frequncies \\n        HashMap<Integer, Integer> counts = new HashMap<>();\\n        \\n        // Maximum 100 iterations\\n        for (int i = nums.length - 1; i >= 0; i--) {\\n            counts.put(nums[i], counts.getOrDefault(nums[i], 0) + 1);\\n        }\\n\\n        int ret = 0;\\n        \\n        // Maximum 100 iterations\\n        for (int key : counts.values()) {\\n            ret += key * (key - 1)/2;\\n        }\\n\\n        return ret;\\n    }\\n}",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int numIdenticalPairs(int[] nums) {\\n        int  ret = 0;\\n        for (int i = 0; i < nums.length; i++) {\\n            for (int j = i + 1; j < nums.length; j++){\\n                if (nums[i]==nums[j]) ret++;\\n            }\\n        }\\n        return ret;\\n    }\\n}\\n\\n```\n```\\nstatic HashMap<Integer, BigInteger> facts = new HashMap<>();\\n\\n    static {\\n        facts.put(1, BigInteger.ONE);\\n        facts.put(0, BigInteger.ONE);\\n        for (int i = 2; i <= 100; i++) {\\n            fact(i);\\n        }\\n    }\\n        \\n     public static int numIdenticalPairs(int[] nums) {\\n        HashMap<Integer, Integer> counts = new HashMap<>();\\n\\n        for (int i = nums.length - 1; i >= 0; i--) {\\n            counts.put(nums[i], counts.getOrDefault(nums[i], 0) + 1);\\n        }\\n\\n        int ret = 0;\\n\\n        for (int key : counts.values()) {\\n            int numOfComb = key == 1 ? 0 : calcNumbOfComb(key);\\n            if (numOfComb > 0) ret += numOfComb;\\n        }\\n\\n        return ret;\\n    }\\n\\n    private static int calcNumbOfComb(int i) {\\n\\n        BigInteger nF = fact(i);\\n        BigInteger nrFact = fact(i - 2);\\n        return (nF.divide(BigInteger.TWO.multiply(nrFact))).intValue();\\n    }\\n\\n    private static BigInteger fact(int i) {\\n        if (facts.get(i) == null) {\\n            if (facts.get(i - 1) == null)\\n                facts.put(i - 1, fact(i - 2).multiply(BigInteger.valueOf(i - 1)));\\n            facts.put(i, BigInteger.valueOf(i).multiply(facts.get(i - 1)));\\n        }\\n\\n        return facts.get(i);\\n    }\\n```",
                "codeTag": "Java"
            },
            {
                "id": 749449,
                "title": "c-dictionary-o-n-solution",
                "content": "**Solution:** \\n\\nUpdated solution with Kiebus\\'s advice.\\n\\nThe idea is count the occurrence of the same elements. nums[i] will contribute dic[nums[i]] pairs to the result. Time complexity and space complexity are both O(n).\\n\\n```\\npublic class Solution {\\n    public int NumIdenticalPairs(int[] nums) {\\n        \\n        if(nums == null || nums.Length < 1)\\n            return 0;\\n        \\n        int cnt = 0;\\n        Dictionary<int,int> dic = new Dictionary<int,int>();\\n        for(int i = 0; i < nums.Length; i++)\\n        {\\n            if(!dic.ContainsKey(nums[i]))\\n                dic.Add(nums[i], 1);\\n            else\\n            {               \\n                cnt += dic[nums[i]];\\n                dic[nums[i]]++;\\n            }\\n        }\\n        \\n        return cnt;\\n    }\\n}\\n```\\n\\n\\noriginal implmentation\\n```\\npublic class Solution {\\n    public int NumIdenticalPairs(int[] nums) {\\n        \\n        if(nums == null || nums.Length < 1)\\n            return 0;\\n        \\n        int cnt = 0;\\n        Dictionary<int,List<int>> dic = new Dictionary<int,List<int>>();\\n        for(int i = 0; i < nums.Length; i++)\\n        {\\n            if(!dic.ContainsKey(nums[i]))\\n                dic.Add(nums[i], new List<int>(){nums[i]});\\n            else\\n            {\\n                cnt += dic[nums[i]].Count;\\n                dic[nums[i]].Add(i);\\n            }\\n        }\\n        \\n        return cnt;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\npublic class Solution {\\n    public int NumIdenticalPairs(int[] nums) {\\n        \\n        if(nums == null || nums.Length < 1)\\n            return 0;\\n        \\n        int cnt = 0;\\n        Dictionary<int,int> dic = new Dictionary<int,int>();\\n        for(int i = 0; i < nums.Length; i++)\\n        {\\n            if(!dic.ContainsKey(nums[i]))\\n                dic.Add(nums[i], 1);\\n            else\\n            {               \\n                cnt += dic[nums[i]];\\n                dic[nums[i]]++;\\n            }\\n        }\\n        \\n        return cnt;\\n    }\\n}\\n```\n```\\npublic class Solution {\\n    public int NumIdenticalPairs(int[] nums) {\\n        \\n        if(nums == null || nums.Length < 1)\\n            return 0;\\n        \\n        int cnt = 0;\\n        Dictionary<int,List<int>> dic = new Dictionary<int,List<int>>();\\n        for(int i = 0; i < nums.Length; i++)\\n        {\\n            if(!dic.ContainsKey(nums[i]))\\n                dic.Add(nums[i], new List<int>(){nums[i]});\\n            else\\n            {\\n                cnt += dic[nums[i]].Count;\\n                dic[nums[i]].Add(i);\\n            }\\n        }\\n        \\n        return cnt;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 736026,
                "title": "c",
                "content": "```\\nint numIdenticalPairs(int* nums, int numsSize){\\n    int s = 0, a[101] = { 0 };\\n    for (int i = 0; i < numsSize; i++) s += a[nums[i]]++;\\n    return s;\\n}\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nint numIdenticalPairs(int* nums, int numsSize){\\n    int s = 0, a[101] = { 0 };\\n    for (int i = 0; i < numsSize; i++) s += a[nums[i]]++;\\n    return s;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 734440,
                "title": "c-solution-hashmap-using-map-o-n-simplest-solution-easy-to-understand",
                "content": "This question uses basic math.\\nAlthough shown in HINT the formula is n(n-1)/2, where n is number of time any number occur.\\nWe don\\'t care about the number but only the number of time any number.\\nAlthough every solution shows in 0ms.\\nBut the solution easy to understand is here.\\n```\\nclass Solution {\\npublic:\\n    int numIdenticalPairs(vector<int>& nums) {\\n        unordered_map<int,int> mp;\\n        for(int i=0;i<nums.size();++i){\\n            auto  itr=mp.find(nums[i]);\\n            if(itr==mp.end())\\n                mp.insert(make_pair(nums[i],1));\\n            else\\n                itr->second++;\\n        }\\n        int sum=0;\\n        for(auto it=mp.begin();it!=mp.end();++it){\\n            int z=it->second;\\n            sum+=z*(z-1)/2;\\n        }\\n        return sum;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Hash Table"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int numIdenticalPairs(vector<int>& nums) {\\n        unordered_map<int,int> mp;\\n        for(int i=0;i<nums.size();++i){\\n            auto  itr=mp.find(nums[i]);\\n            if(itr==mp.end())\\n                mp.insert(make_pair(nums[i],1));\\n            else\\n                itr->second++;\\n        }\\n        int sum=0;\\n        for(auto it=mp.begin();it!=mp.end();++it){\\n            int z=it->second;\\n            sum+=z*(z-1)/2;\\n        }\\n        return sum;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 732615,
                "title": "python-3-solution-with-defaultdict",
                "content": "```\\nclass Solution:\\n    def numIdenticalPairs(self, nums) -> int:\\n        \"\"\"\\n        Given an array of numbers, this program determines the\\n        number of good pairs [nums[j], nums[k]]. In a good pair,\\n        j < k and nums[j] = nums[k].\\n        \\n        If there are 2 or more ocurrences of a value within nums, then\\n        there is at least 1 good pair for that value. If there are n\\n        occurrences of a value, the number of good pairs is:\\n        \\n                            n!\\n                      ----------------  or  n * (n - 1) / 2\\n                        (n - 2)! * 2!\\n\\n        :param nums: array of integers\\n        :type nums: list[int]\\n        :return: number of good pairs\\n        :rtype: int\\n        \"\"\"\\n        counts = defaultdict(int)\\n        for num in nums:\\n            counts[num] += 1\\n        good_pairs = 0\\n        for count in counts.values():\\n            if count > 1:\\n                good_pairs += count * (count - 1) // 2\\n        return good_pairs\\n\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def numIdenticalPairs(self, nums) -> int:\\n        \"\"\"\\n        Given an array of numbers, this program determines the\\n        number of good pairs [nums[j], nums[k]]. In a good pair,\\n        j < k and nums[j] = nums[k].\\n        \\n        If there are 2 or more ocurrences of a value within nums, then\\n        there is at least 1 good pair for that value. If there are n\\n        occurrences of a value, the number of good pairs is:\\n        \\n                            n!\\n                      ----------------  or  n * (n - 1) / 2\\n                        (n - 2)! * 2!\\n\\n        :param nums: array of integers\\n        :type nums: list[int]\\n        :return: number of good pairs\\n        :rtype: int\\n        \"\"\"\\n        counts = defaultdict(int)\\n        for num in nums:\\n            counts[num] += 1\\n        good_pairs = 0\\n        for count in counts.values():\\n            if count > 1:\\n                good_pairs += count * (count - 1) // 2\\n        return good_pairs\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 731702,
                "title": "javascript",
                "content": "```\\n/**\\n * @param {number[]} nums\\n * @return {number}\\n */\\nvar numIdenticalPairs = function(nums) {\\n    let count = 0\\n    for(let i=0;i<nums.length;i++){\\n        for(let j=i+1;j<nums.length;j++){\\n            if(nums[i] == nums[j]) count++\\n        }\\n    }\\n    return count\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {number[]} nums\\n * @return {number}\\n */\\nvar numIdenticalPairs = function(nums) {\\n    let count = 0\\n    for(let i=0;i<nums.length;i++){\\n        for(let j=i+1;j<nums.length;j++){\\n            if(nums[i] == nums[j]) count++\\n        }\\n    }\\n    return count\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 731616,
                "title": "clean-python-3-counter-and-math-o-n",
                "content": "Time: `O(N)`\\nSpace: `O(N)`\\n```\\nimport collections\\nimport math\\nclass Solution:\\n    def numIdenticalPairs(self, nums: List[int]) -> int:\\n        counter = collections.Counter(nums)\\n        return sum(math.comb(count, 2) for count in counter.values() if count > 1)\\n```",
                "solutionTags": [],
                "code": "```\\nimport collections\\nimport math\\nclass Solution:\\n    def numIdenticalPairs(self, nums: List[int]) -> int:\\n        counter = collections.Counter(nums)\\n        return sum(math.comb(count, 2) for count in counter.values() if count > 1)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3974306,
                "title": "optimized-with-frequency-array",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nFrequency Array\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nO(N)\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int numIdenticalPairs(int[] nums) {\\n        int mx=Arrays.stream(nums).max().getAsInt();\\n        int[] freqArray=new int[mx+1];\\n        for(int i:nums){\\n            freqArray[i]++;\\n        }\\n        int ans=0;\\n        for(int i:freqArray){\\n            ans += (i*(i-1))/2;\\n        }return ans;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int numIdenticalPairs(int[] nums) {\\n        int mx=Arrays.stream(nums).max().getAsInt();\\n        int[] freqArray=new int[mx+1];\\n        for(int i:nums){\\n            freqArray[i]++;\\n        }\\n        int ans=0;\\n        for(int i:freqArray){\\n            ans += (i*(i-1))/2;\\n        }return ans;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3899512,
                "title": "simple-solution-with-dictionary-time-complexity-o-n",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nFirstly, done with brute force where I achieved the task but time complexity is higher i.e. O(n^2), then come up with this dictionary approach.\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:O(n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def numIdenticalPairs(self, nums: List[int]) -> int:\\n        result={}\\n        res=0\\n\\n        for num in nums:\\n            if num in result:\\n                res+=result[num]\\n                result[num]+=1\\n            else:\\n                result[num]=1\\n        \\n        return res\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def numIdenticalPairs(self, nums: List[int]) -> int:\\n        result={}\\n        res=0\\n\\n        for num in nums:\\n            if num in result:\\n                res+=result[num]\\n                result[num]+=1\\n            else:\\n                result[num]=1\\n        \\n        return res\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3526881,
                "title": "c-java-simple-solution-single-iteration-o-n",
                "content": "\\n# Approach\\nWe will use a HashMap to store the numbers and frequency of those numbers.\\nIn single iteration, we will check if the number exists in map we will increase the count by frequency of the number, and increase the frequncy by 1.\\nIf the number does not exist we will add the number to the map with frequency 1.\\n$$ map <int,\\\\hspace{0.1cm}int> \\\\hspace{0.2cm} $$ key = nums[i], value = frequency\\n$$ count \\\\hspace{0.1cm} += map[nums[i]] \\\\hspace{0.2cm} $$\\n*Let 1 exists 3 times then, [1, 1, 1] --> {0, 1}, {1, 2}, {0, 2}*\\n\\n# Dry run\\n$$nums:$$ [ 1, 2, 3, 1, 1, 3 ] $$ \\\\hspace{0.2cm} n:$$ 6\\n\\n$$ i = 0, $$ map = { } $$ \\\\hspace{0.2cm} count = 0 $$\\n$$ i = 1, $$ map = { {1, 1} } $$ \\\\hspace{0.2cm} count = 0 $$\\n$$ i = 2, $$ map = { {1, 1}, {2, 1} } $$ \\\\hspace{0.2cm} count = 0 $$\\n$$ i = 3, $$ map = { {1, 2}, {2, 1}, {3, 1} } $$ \\\\hspace{0.2cm} count = 1 $$\\n$$ i = 4, $$ map = { {1, 3}, {2, 1}, {3, 1} } $$ \\\\hspace{0.2cm} count = 3 $$\\n$$ i = 5, $$ map = { {1, 3}, {2, 1}, {3, 2} } $$ \\\\hspace{0.2cm} count = 4 $$\\n\\n$$ number \\\\hspace{0.1cm} of \\\\hspace{0.1cm} magic \\\\hspace{0.1cm} pairs: $$ 4\\n\\n*Note:* First update the number then change the frequency.\\n\\n# Complexity\\n- Time complexity: **O(n)** $$ To \\\\hspace{0.2cm} traverse \\\\hspace{0.2cm} once \\\\hspace{0.2cm} through \\\\hspace{0.2cm} the \\\\hspace{0.2cm} given \\\\hspace{0.2cm} array.$$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: **O(n)** $$ To \\\\hspace{0.2cm} store \\\\hspace{0.2cm} the \\\\hspace{0.2cm} array \\\\hspace{0.2cm} in  \\\\hspace{0.2cm} a \\\\hspace{0.2cm} hashmap. $$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n\\n# Code\\n```C++ []\\nclass Solution {\\npublic:\\n    int numIdenticalPairs(vector<int>& nums) {\\n        map<int, int> m;\\n        int count = 0;\\n        for (int i = 0; i < nums.size(); ++i) {\\n            if (m.count(nums[i]) > 0) {\\n                count += m[nums[i]];\\n                m[nums[i]] = m[nums[i]] + 1;\\n            } else {\\n                m[nums[i]] = 1;\\n            }\\n        }\\n        return count;\\n    }\\n};\\n```\\n```Java []\\nclass Solution {\\n    public int numIdenticalPairs(int[] nums) {\\n        HashMap<Integer, Integer> map = new HashMap<>();\\n        int count = 0;\\n        for (int i = 0; i < nums.length; ++i) {\\n            if (map.containsKey(nums[i])) {\\n                count += map.get(nums[i]);\\n                map.put(nums[i], map.get(nums[i]) + 1);\\n            } else {\\n                map.put(nums[i], 1);\\n            }\\n        }\\n        return count;\\n    }\\n}\\n```\\n",
                "solutionTags": [
                    "C++",
                    "Java",
                    "Array",
                    "Hash Table",
                    "Counting"
                ],
                "code": "```C++ []\\nclass Solution {\\npublic:\\n    int numIdenticalPairs(vector<int>& nums) {\\n        map<int, int> m;\\n        int count = 0;\\n        for (int i = 0; i < nums.size(); ++i) {\\n            if (m.count(nums[i]) > 0) {\\n                count += m[nums[i]];\\n                m[nums[i]] = m[nums[i]] + 1;\\n            } else {\\n                m[nums[i]] = 1;\\n            }\\n        }\\n        return count;\\n    }\\n};\\n```\n```Java []\\nclass Solution {\\n    public int numIdenticalPairs(int[] nums) {\\n        HashMap<Integer, Integer> map = new HashMap<>();\\n        int count = 0;\\n        for (int i = 0; i < nums.length; ++i) {\\n            if (map.containsKey(nums[i])) {\\n                count += map.get(nums[i]);\\n                map.put(nums[i], map.get(nums[i]) + 1);\\n            } else {\\n                map.put(nums[i], 1);\\n            }\\n        }\\n        return count;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3497764,
                "title": "c-simple-solution-beats-100",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\npublic class Solution {\\n    public int NumIdenticalPairs(int[] nums) {\\n        Dictionary<int, int> id = new();\\n        int ans = 0;\\n        for (int i = 0; i < nums.Length; i++)\\n        {\\n            int c= id.GetValueOrDefault(nums[i],0);\\n            ans += c;\\n            id[nums[i]] = c + 1;\\n        }\\n        return ans;\\n    }\\n}\\n```",
                "solutionTags": [
                    "C#"
                ],
                "code": "```\\npublic class Solution {\\n    public int NumIdenticalPairs(int[] nums) {\\n        Dictionary<int, int> id = new();\\n        int ans = 0;\\n        for (int i = 0; i < nums.Length; i++)\\n        {\\n            int c= id.GetValueOrDefault(nums[i],0);\\n            ans += c;\\n            id[nums[i]] = c + 1;\\n        }\\n        return ans;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3466162,
                "title": "three-c-easy-solutions-with-time-and-space-complexity",
                "content": "\\n**Solution: 1**\\n\\n\\nSimple just compare the ```ith``` and ```jth``` index.\\n```\\n\\nclass Solution {\\npublic:\\n    int numIdenticalPairs(vector<int>& nums) {\\n        int count = 0;\\n        for(int i = 0;i<nums.size();i++){\\n            for(int j=i+1;j<nums.size();j++){\\n                if(nums[i] == nums[j]){\\n                    count++;\\n                }\\n            }\\n        }\\n        return count;\\n    }\\n};\\n\\n/*\\n    Analysis:\\n    Time Complexity : O(N^2)\\n    Space Complexity : O(N)\\n*/\\n\\n```\\n\\n**Solution:2**\\n\\n\\n```\\nclass Solution {\\npublic:\\n    int numIdenticalPairs(vector<int>& nums) {\\n        sort(nums.begin(),nums.end());\\n        int count = 0;\\n        int i = 0;\\n        for(int j=1;j<nums.size();j++){\\n            if(nums[i] == nums[j]){\\n                count+=j-i;\\n            }\\n            else\\n            {\\n                i=j;\\n            }\\n        }\\n        return count;\\n    }\\n};\\n\\n/*\\n    Analysis:\\n    Time Complexity : O(nlogn)\\n    Space Complexity : O(1)\\n*/\\n\\n\\n```\\n\\n\\n**Solution: 3**\\n\\n```\\nclass Solution {\\npublic:\\n    int numIdenticalPairs(vector<int>& nums) {\\n        sort(nums.begin(),nums.end());\\n        int count = 0;\\n        int i = 0;\\n        for(int j=1;j<nums.size();j++){\\n            if(nums[i] == nums[j]){\\n                count+=j-i;\\n            }\\n            else\\n            {\\n                i=j;\\n            }\\n        }\\n        return count;\\n    }\\n};\\n\\n/*\\n    Analysis:\\n    Time Complexity : O(nlogn)\\n    Space Complexity : O(1)\\n*/    \\n\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```ith```\n```jth```\n```\\n\\nclass Solution {\\npublic:\\n    int numIdenticalPairs(vector<int>& nums) {\\n        int count = 0;\\n        for(int i = 0;i<nums.size();i++){\\n            for(int j=i+1;j<nums.size();j++){\\n                if(nums[i] == nums[j]){\\n                    count++;\\n                }\\n            }\\n        }\\n        return count;\\n    }\\n};\\n\\n/*\\n    Analysis:\\n    Time Complexity : O(N^2)\\n    Space Complexity : O(N)\\n*/\\n\\n```\n```\\nclass Solution {\\npublic:\\n    int numIdenticalPairs(vector<int>& nums) {\\n        sort(nums.begin(),nums.end());\\n        int count = 0;\\n        int i = 0;\\n        for(int j=1;j<nums.size();j++){\\n            if(nums[i] == nums[j]){\\n                count+=j-i;\\n            }\\n            else\\n            {\\n                i=j;\\n            }\\n        }\\n        return count;\\n    }\\n};\\n\\n/*\\n    Analysis:\\n    Time Complexity : O(nlogn)\\n    Space Complexity : O(1)\\n*/\\n\\n\\n```\n```\\nclass Solution {\\npublic:\\n    int numIdenticalPairs(vector<int>& nums) {\\n        sort(nums.begin(),nums.end());\\n        int count = 0;\\n        int i = 0;\\n        for(int j=1;j<nums.size();j++){\\n            if(nums[i] == nums[j]){\\n                count+=j-i;\\n            }\\n            else\\n            {\\n                i=j;\\n            }\\n        }\\n        return count;\\n    }\\n};\\n\\n/*\\n    Analysis:\\n    Time Complexity : O(nlogn)\\n    Space Complexity : O(1)\\n*/    \\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3289788,
                "title": "c-easy-solution",
                "content": "\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int numIdenticalPairs(vector<int>& nums) {\\n        int count=0;\\n        for(int i=0;i<nums.size()-1;i++){\\n            for(int j=i+1;j<nums.size();j++){\\n                if(nums[i]==nums[j])count++;\\n            }\\n        }\\n        return count;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int numIdenticalPairs(vector<int>& nums) {\\n        int count=0;\\n        for(int i=0;i<nums.size()-1;i++){\\n            for(int j=i+1;j<nums.size();j++){\\n                if(nums[i]==nums[j])count++;\\n            }\\n        }\\n        return count;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3280312,
                "title": "c-easy-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Complexity\\n- Time complexity: 82 ms.Beats 76.37% of other solutions.\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:38.2 MB.Beats 15.19% of other solutions.\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\npublic class Solution {\\n    public int NumIdenticalPairs(int[] nums) {\\n        int count=0;\\n        for(int i=0;i<nums.Length-1;i++){\\n            for(int j=i+1;j<nums.Length;j++)\\n            if(nums[i]==nums[j])count++;\\n        }\\n        return count;\\n    }\\n}\\n```",
                "solutionTags": [
                    "C#",
                    "Array"
                ],
                "code": "```\\npublic class Solution {\\n    public int NumIdenticalPairs(int[] nums) {\\n        int count=0;\\n        for(int i=0;i<nums.Length-1;i++){\\n            for(int j=i+1;j<nums.Length;j++)\\n            if(nums[i]==nums[j])count++;\\n        }\\n        return count;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3168634,
                "title": "python-2-ways",
                "content": "# O(n) time, O(n) space\\nFirst solution is a **hash table**-based approach to count the number of good pairs. Here I use a dictionary `repeats` where the keys are the unique integers in `nums` and the values are the number of times that integer appears in `nums`. Then iterate through `nums` and increments the count of pairs by the number of times the current integer has already appeared in `nums`.\\n```\\nclass Solution:\\n    def numIdenticalPairs(self, nums: List[int]) -> int:\\n        repeats: dict[int, int] = {}\\n        pairs = 0\\n        for num in nums:\\n            if num in repeats:\\n                pairs += repeats[num]\\n                repeats[num] += 1\\n            else:\\n                repeats[num] = 1\\n        return pairs\\n\\n```\\n# O(n^2) time, O(1) space\\nSecond solution is a nested loop approach to count the number of good pairs in the given array of integers `nums`. Here I use an outer loop to iterate through `nums`, and an inner loop to compare the current integer to each subsequent integer in `nums`. If the current integer and the next integer are equal, increments the count of pairs.\\n```\\nclass Solution:\\n    def numIdenticalPairs(self, nums: List[int]) -> int:\\n        pairs = 0\\n        for i, left in enumerate(nums):\\n            j = i + 1\\n            while j < len(nums):\\n                right = nums[j]\\n                if left == right:\\n                    pairs += 1\\n                j += 1\\n        return pairs\\n```\\n...but runtime and memory consumption in submissions are almost equal",
                "solutionTags": [
                    "Python3",
                    "Hash Table"
                ],
                "code": "```\\nclass Solution:\\n    def numIdenticalPairs(self, nums: List[int]) -> int:\\n        repeats: dict[int, int] = {}\\n        pairs = 0\\n        for num in nums:\\n            if num in repeats:\\n                pairs += repeats[num]\\n                repeats[num] += 1\\n            else:\\n                repeats[num] = 1\\n        return pairs\\n\\n```\n```\\nclass Solution:\\n    def numIdenticalPairs(self, nums: List[int]) -> int:\\n        pairs = 0\\n        for i, left in enumerate(nums):\\n            j = i + 1\\n            while j < len(nums):\\n                right = nums[j]\\n                if left == right:\\n                    pairs += 1\\n                j += 1\\n        return pairs\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3063412,
                "title": "java-hashmap-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nMy first thought is to use two for loops but then I decided to reduce the time complexity.\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nI have used a hashmap which stores the elements count and for the elements having count more than 1,I will apply the formula n*(n-1)/2 as among them we need to choose the pairs and finally add the value to the variable pairs\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n    O(n)\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n    O(n)\\n\\n# Code\\n```\\nclass Solution {\\n    public int numIdenticalPairs(int[] nums) {\\n        int pairs=0;\\n        HashMap<Integer,Integer> hm=new HashMap<>();\\n        for(int i=0;i<nums.length;i++){\\n            if(!hm.containsKey(nums[i]))\\n                hm.put(nums[i],1);\\n            else{\\n                int val=hm.get(nums[i]);\\n                val++;\\n                hm.put(nums[i],val);\\n            }\\n        }\\n        for(Map.Entry<Integer,Integer> entry : hm.entrySet()) {\\n            int val=entry.getValue();\\n            if(val>1){\\n                pairs+=val*(val-1)/2;\\n            }\\n        }\\n        return pairs;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int numIdenticalPairs(int[] nums) {\\n        int pairs=0;\\n        HashMap<Integer,Integer> hm=new HashMap<>();\\n        for(int i=0;i<nums.length;i++){\\n            if(!hm.containsKey(nums[i]))\\n                hm.put(nums[i],1);\\n            else{\\n                int val=hm.get(nums[i]);\\n                val++;\\n                hm.put(nums[i],val);\\n            }\\n        }\\n        for(Map.Entry<Integer,Integer> entry : hm.entrySet()) {\\n            int val=entry.getValue();\\n            if(val>1){\\n                pairs+=val*(val-1)/2;\\n            }\\n        }\\n        return pairs;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2979550,
                "title": "c-hashmap-explained-solution",
                "content": "\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int numIdenticalPairs(vector<int>& nums) {\\n        unordered_map<int,int> hashmap;\\n        int count=0;\\n        for (int i=0;i<nums.size();i++){\\n    //we will increase the frequency if we encounter the same number again\\n            hashmap[nums[i]]++;\\n//we will add counts of pairs by freq-1 for ex if freq 2 pair will be 1 ,if freq is 3 pair will be 2 etc etc.\\n            if (hashmap[nums[i]]>1){\\n                count+=hashmap[nums[i]]-1;\\n            }\\n       \\n        }\\n//return the ans\\n        return count;\\n    }\\n};\\n    \\n```",
                "solutionTags": [
                    "C++",
                    "Array",
                    "Hash Table",
                    "Math"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int numIdenticalPairs(vector<int>& nums) {\\n        unordered_map<int,int> hashmap;\\n        int count=0;\\n        for (int i=0;i<nums.size();i++){\\n    //we will increase the frequency if we encounter the same number again\\n            hashmap[nums[i]]++;\\n//we will add counts of pairs by freq-1 for ex if freq 2 pair will be 1 ,if freq is 3 pair will be 2 etc etc.\\n            if (hashmap[nums[i]]>1){\\n                count+=hashmap[nums[i]]-1;\\n            }\\n       \\n        }\\n//return the ans\\n        return count;\\n    }\\n};\\n    \\n```",
                "codeTag": "Java"
            },
            {
                "id": 2972803,
                "title": "c-solution-2ms-simpleapproach",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int numIdenticalPairs(vector<int>& nums) {\\n        int count=0;\\n        for(int i=0;i<nums.size();i++)\\n        {\\n            for(int j=i+1;j<nums.size();j++)\\n            {\\n                if(nums[i]==nums[j])\\n                {\\n                    count++;\\n                }\\n            }\\n        }\\n        return count;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int numIdenticalPairs(vector<int>& nums) {\\n        int count=0;\\n        for(int i=0;i<nums.size();i++)\\n        {\\n            for(int j=i+1;j<nums.size();j++)\\n            {\\n                if(nums[i]==nums[j])\\n                {\\n                    count++;\\n                }\\n            }\\n        }\\n        return count;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2937996,
                "title": "using-java-simple-code",
                "content": "# Intuition\\nwithout any advance method \\n\\n# Approach\\nmatching approach\\n# Complexity\\n- Time complexity:\\no(n^2)\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n   public int numIdenticalPairs(int[] nums) {\\n        int c=0;\\n        for (int i = 0; i < nums.length; i++) {\\n            for (int j = i+1; j < nums.length; j++) {\\n                if(nums[i]==nums[j]){\\n                    c++;\\n                }\\n            }\\n        }\\n        return c;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n   public int numIdenticalPairs(int[] nums) {\\n        int c=0;\\n        for (int i = 0; i < nums.length; i++) {\\n            for (int j = i+1; j < nums.length; j++) {\\n                if(nums[i]==nums[j]){\\n                    c++;\\n                }\\n            }\\n        }\\n        return c;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2853022,
                "title": "0ms-solution",
                "content": "```\\nfunc numIdenticalPairs(nums []int) int {\\n\\tvar res int\\n\\thashMap := make(map[int]int)\\n\\tfor _, val := range nums {\\n\\t\\thashMap[val]++\\n\\t}\\n\\tfor _, element := range hashMap {\\n\\t\\tfor i := element - 1; i > 0; i-- {\\n\\t\\t\\tres = res + i\\n\\t\\t}\\n\\t}\\n\\treturn res\\n}\\n```",
                "solutionTags": [
                    "Go"
                ],
                "code": "```\\nfunc numIdenticalPairs(nums []int) int {\\n\\tvar res int\\n\\thashMap := make(map[int]int)\\n\\tfor _, val := range nums {\\n\\t\\thashMap[val]++\\n\\t}\\n\\tfor _, element := range hashMap {\\n\\t\\tfor i := element - 1; i > 0; i-- {\\n\\t\\t\\tres = res + i\\n\\t\\t}\\n\\t}\\n\\treturn res\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2830033,
                "title": "c-nested-loop",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nThe input size is small enough we can just do nested loops.\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nWell, nested loops.\\n\\n# Complexity\\n- Time complexity: $$O(n^2)$$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: $$O(1)$$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int numIdenticalPairs(vector<int>& nums) {\\n        int good_pairs = 0;\\n        for (int i = 0; i < nums.size(); ++i)\\n            for (int j = i + 1; j < nums.size(); ++j)\\n                good_pairs += nums[i] == nums[j];\\n        \\n        return good_pairs;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int numIdenticalPairs(vector<int>& nums) {\\n        int good_pairs = 0;\\n        for (int i = 0; i < nums.size(); ++i)\\n            for (int j = i + 1; j < nums.size(); ++j)\\n                good_pairs += nums[i] == nums[j];\\n        \\n        return good_pairs;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2788796,
                "title": "o-n-java",
                "content": "```\\nclass Solution {\\n    public int numIdenticalPairs(int[] nums) {\\n        Map<Integer,Integer> m=new HashMap<>();\\n        for(int i:nums)m.put(i,m.getOrDefault(i,0)+1);\\n        \\n        int c=0;\\n        \\n        for(int i:m.keySet()){\\n            int n=m.get(i);\\n            int val=n-1;\\n            if(n>1)c+=(val*(val+1))/2;\\n        }\\n        return c;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int numIdenticalPairs(int[] nums) {\\n        Map<Integer,Integer> m=new HashMap<>();\\n        for(int i:nums)m.put(i,m.getOrDefault(i,0)+1);\\n        \\n        int c=0;\\n        \\n        for(int i:m.keySet()){\\n            int n=m.get(i);\\n            int val=n-1;\\n            if(n>1)c+=(val*(val+1))/2;\\n        }\\n        return c;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2785405,
                "title": "java",
                "content": "```\\nclass Solution {\\n    public int numIdenticalPairs(int[] nums) {\\n        int count=0;\\n        for(int i=0;i<nums.length;i++){\\n            for(int j=i+1;j<nums.length;j++)\\n                if(nums[i]==nums[j])\\n                    count++;\\n        }\\n        return count;\\n    }\\n\\t}\\n\\t```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int numIdenticalPairs(int[] nums) {\\n        int count=0;\\n        for(int i=0;i<nums.length;i++){\\n            for(int j=i+1;j<nums.length;j++)\\n                if(nums[i]==nums[j])\\n                    count++;\\n        }\\n        return count;\\n    }\\n\\t}\\n\\t```",
                "codeTag": "Java"
            },
            {
                "id": 2784238,
                "title": "easy-c-o-n-soln-faang-interview-optimized-code",
                "content": "# **Plz Upvote if it helps \\uD83D\\uDE4F**\\n\\n# \\uD83D\\uDC49 Approach-1  (O(n^2) using Bruteforce)\\n> Time Complexity: O(n^2) \\nSpace Complexity: O(1)\\n![Screenshot (3405).png](https://assets.leetcode.com/users/images/dd357b66-2fcc-49a1-8b50-6abf5d4ac4e4_1667720335.9933274.png)\\n\\n\\n# \\uD83D\\uDC49 Approach-2  (O(nlogn) using sort())\\n\\n> Time Complexity: O(nlogn) \\nSpace Complexity: O(1)\\n```\\nclass Solution {\\npublic:\\n    int numIdenticalPairs(vector<int>& nums) {\\n        sort(nums.begin() , nums.end());\\n        int count = 1 , p = 0;\\n        for(int i = 0 ; i < nums.size()-1 ; i++){\\n            if(nums[i] == nums[i+1])\\n                count++;\\n            else{\\n                p = p + count*(count-1)/2;\\n                count = 1;\\n            }      \\n        }\\n        p = p + count*(count-1)/2;\\n        return p;\\n    }\\n};\\n```\\n\\n# \\uD83D\\uDC49 Approach-3  (Most Optimal \\uD83D\\uDD25 O(n) using Unordered map )\\n\\n1) Create an unordered map and store no. of time all elements occur in nums.\\n2) If count>1, use the combination formula NC2, which gives n*(n-1)/2;\\n\\n\\n\\n\\n<!-- Describe your approach to solving the problem. -->\\n\\n\\n\\n> Time Complexity: O(n) \\uD83D\\uDCAF\\uD83D\\uDCA8\\nSpace Complexity: O(n)\\n```\\nclass Solution {\\npublic:\\n    int numIdenticalPairs(vector<int>& nums) {\\n       unordered_map <int,int> mp;\\n       int res=0;\\n       for(int i = 0 ; i < nums.size() ; i++){\\n           mp[nums[i]]++;\\n       }\\n       for(auto it : mp){\\n           if(it.second>1)\\n               res+=it.second*(it.second-1)/2;\\n       }\\n       return res;\\n    }\\n};\\n```\\n\\n#### ***For \\'n\\' numbers you can have nC2 pairs, which is equal to (n*(n-1))/2.**\\n\\n**I hope it cleared your doubt, if not you can check this out (https://stackoverflow.com/questions/18859430/how-do-i-get-the-total-number-of-unique-pairs-of-a-set-in-the-database)**",
                "solutionTags": [
                    "C++",
                    "Array",
                    "Hash Table",
                    "Math",
                    "Counting"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int numIdenticalPairs(vector<int>& nums) {\\n        sort(nums.begin() , nums.end());\\n        int count = 1 , p = 0;\\n        for(int i = 0 ; i < nums.size()-1 ; i++){\\n            if(nums[i] == nums[i+1])\\n                count++;\\n            else{\\n                p = p + count*(count-1)/2;\\n                count = 1;\\n            }      \\n        }\\n        p = p + count*(count-1)/2;\\n        return p;\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    int numIdenticalPairs(vector<int>& nums) {\\n       unordered_map <int,int> mp;\\n       int res=0;\\n       for(int i = 0 ; i < nums.size() ; i++){\\n           mp[nums[i]]++;\\n       }\\n       for(auto it : mp){\\n           if(it.second>1)\\n               res+=it.second*(it.second-1)/2;\\n       }\\n       return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2766771,
                "title": "java-easy-solution",
                "content": "Time Complexity: O(N^2)\\nSpace Complexity: O(1)\\n```\\nclass Solution {\\n    public int numIdenticalPairs(int[] nums) {\\n        int pairs = 0;\\n        int length = nums.length;\\n        for (int i = 0; i < length; i++) {\\n            for (int j = i + 1; j < length; j++) {\\n                if (nums[i] == nums[j])\\n                    pairs++;\\n            }\\n        }\\n        return pairs;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int numIdenticalPairs(int[] nums) {\\n        int pairs = 0;\\n        int length = nums.length;\\n        for (int i = 0; i < length; i++) {\\n            for (int j = i + 1; j < length; j++) {\\n                if (nums[i] == nums[j])\\n                    pairs++;\\n            }\\n        }\\n        return pairs;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2726864,
                "title": "0ms-100-fastest-cpp-solution-using-hash-map",
                "content": "\\n# # Abb is ke liye ek upvote tho bantha hai yaar..\\n\\n\\n\\tclass Solution {\\n\\t\\tpublic:\\n\\t\\t\\tint numIdenticalPairs(vector<int>& nums) {\\n\\t\\t\\tint total = 0;\\n\\t\\t\\tunordered_map <int,int> mp;\\n\\t\\t\\tfor(int i=0;  i<nums.size();  i++)\\n\\t\\t\\t{\\n\\t\\t\\t\\ttotal  +=  mp[nums[i]];\\n\\t\\t\\t\\tmp[nums[i]]++;\\n\\t\\t\\t}\\n\\t\\t\\treturn total;\\n\\t\\t}\\n\\t};\\n\\n\\n\\n\\n",
                "solutionTags": [
                    "C++",
                    "Hash Table"
                ],
                "code": "class Solution {\\n\\t\\tpublic:\\n\\t\\t\\tint numIdenticalPairs(vector<int>& nums) {\\n\\t\\t\\tint total = 0;\\n\\t\\t\\tunordered_map <int,int> mp;\\n\\t\\t\\tfor(int i=0;  i<nums.size();  i++)\\n\\t\\t\\t{\\n\\t\\t\\t\\ttotal  +=  mp[nums[i]];\\n\\t\\t\\t\\tmp[nums[i]]++;\\n\\t\\t\\t}",
                "codeTag": "Java"
            },
            {
                "id": 2672879,
                "title": "c-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    int numIdenticalPairs(vector<int>& nums) {\\n        int sum = 0;\\n        map<int,int>mp;//To keep track of how many times elements of nums occur\\n        for(int i = 0;i < nums.size();i++)\\n        {\\n            sum += mp[nums[i]]++;//if we get an element, check in map how many times it has occured before and add in sum\\n        }\\n        return sum;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int numIdenticalPairs(vector<int>& nums) {\\n        int sum = 0;\\n        map<int,int>mp;//To keep track of how many times elements of nums occur\\n        for(int i = 0;i < nums.size();i++)\\n        {\\n            sum += mp[nums[i]]++;//if we get an element, check in map how many times it has occured before and add in sum\\n        }\\n        return sum;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2672346,
                "title": "100-faster-with-easy-understand",
                "content": "class Solution {\\npublic:\\n    int numIdenticalPairs(vector<int>& nums) {\\n        int count =0;\\n        for(int i=0;i<nums.size();i++){\\n            for(int j=i+1;j<nums.size();j++){\\n                if(nums[i]==nums[j]){\\n                    count++;\\n                }\\n            }\\n        }\\n        return count;\\n    }\\n};",
                "solutionTags": [
                    "C"
                ],
                "code": "class Solution {\\npublic:\\n    int numIdenticalPairs(vector<int>& nums) {\\n        int count =0;\\n        for(int i=0;i<nums.size();i++){\\n            for(int j=i+1;j<nums.size();j++){\\n                if(nums[i]==nums[j]){\\n                    count++;\\n                }",
                "codeTag": "Java"
            },
            {
                "id": 2552019,
                "title": "java-hashmap-mathematics-combinations-nc2",
                "content": "```\\nclass Solution {\\n    public int numIdenticalPairs(int[] arr) {\\n        int n = arr.length;\\n        HashMap<Integer, Integer> hm = new HashMap<>();\\n        for(int i=0;i<n;i++){\\n            hm.put(arr[i], hm.getOrDefault(arr[i], 0)+1);\\n        }\\n        int ans = 0;\\n        for(Map.Entry<Integer, Integer> m: hm.entrySet()){\\n            int i = m.getValue();\\n            int res = (i*(i-1))/2;\\n            ans += res;\\n        }\\n        return ans;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Hash Table",
                    "Math"
                ],
                "code": "```\\nclass Solution {\\n    public int numIdenticalPairs(int[] arr) {\\n        int n = arr.length;\\n        HashMap<Integer, Integer> hm = new HashMap<>();\\n        for(int i=0;i<n;i++){\\n            hm.put(arr[i], hm.getOrDefault(arr[i], 0)+1);\\n        }\\n        int ans = 0;\\n        for(Map.Entry<Integer, Integer> m: hm.entrySet()){\\n            int i = m.getValue();\\n            int res = (i*(i-1))/2;\\n            ans += res;\\n        }\\n        return ans;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2473799,
                "title": "java-solution-95-faster",
                "content": "```\\nclass Solution {\\n    public int numIdenticalPairs(int[] nums) {\\n       int i=0;\\n            int j=i+1;\\n            int count=0;\\n            while (i<nums.length-1){\\n                if (nums[i]==nums[j])\\n                    count++;\\n                j++;\\n                if (j==nums.length) {\\n                    i++;\\n                    j=i+1;\\n                }\\n            }\\n            return count; \\n    }\\n}\\n```\\nPlease Give a upvote if you find this helpful",
                "solutionTags": [
                    "Java",
                    "Array"
                ],
                "code": "```\\nclass Solution {\\n    public int numIdenticalPairs(int[] nums) {\\n       int i=0;\\n            int j=i+1;\\n            int count=0;\\n            while (i<nums.length-1){\\n                if (nums[i]==nums[j])\\n                    count++;\\n                j++;\\n                if (j==nums.length) {\\n                    i++;\\n                    j=i+1;\\n                }\\n            }\\n            return count; \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2400203,
                "title": "python-o-2-solution",
                "content": "```\\nclass SolutionTwo:\\n    def numIdenticalPairs(self, nums: List[int]) -> int:\\n\\n        goodPairs = 0;\\n        for i in range(0, len(nums)):\\n            for j in range(i + 1, len(nums)):\\n                if (nums[i] == nums[j]):\\n                    goodPairs += 1;\\n\\n        return goodPairs;\\n```",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nclass SolutionTwo:\\n    def numIdenticalPairs(self, nums: List[int]) -> int:\\n\\n        goodPairs = 0;\\n        for i in range(0, len(nums)):\\n            for j in range(i + 1, len(nums)):\\n                if (nums[i] == nums[j]):\\n                    goodPairs += 1;\\n\\n        return goodPairs;\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2295967,
                "title": "solution-in-o-n-time-python",
                "content": "If we consider the following example: [1, 2, 3, 1, 1, 2, 1]\\nWe have 6 (1, 1) pairs and 1 (2, 2), total is 7.\\n\\nIn the array, 1 appears 4 times and that gives us 6 pairs, 2 appears twice and that gives 1 pair.\\nWe can try to figure out a relation between frequence of appearance of a number and the numbers of good pairs that genarates.\\n\\nIf we take number 1, based on the following figure, we have 3 + 2 +1 = 6 good pairs.\\nIf we generalize that, if **k is the frequency** of a number in the array, the number of pairs generated by k would be the sum **(k-1) + (k-2) + ... + 1** and that is the sum of the first (k-1) numbers, which is equal to: **(k-1)k/2**.\\n\\n![image](https://assets.leetcode.com/users/images/de7704ef-6180-4263-b806-47245d4efcea_1658072374.5028248.png)\\n\\n\\nSo, first, we need to keep track of the appearance of a number in the array. We can achieve that by using a hashmap/dictionary.\\n```python\\nfor num in nums:\\n\\tif num in freq:\\n\\t\\tfreq[num] += 1\\n\\telse:\\n\\t\\tfreq[num] = 1\\n```\\n\\nSecond, we iterate through the frequencies, and sum up the number of pairs each frequency generates.\\n```python\\nfor num in freq:\\n\\tcount += (freq[num]*(freq[num]-1)//2)\\n```\\n\\nA solution to this problem would then be:\\n\\n```python\\nclass Solution:\\n    def numIdenticalPairs(self, nums: List[int]) -> int:\\n        count = 0\\n        freq = {}\\n        for num in nums:\\n            if num in freq:\\n                freq[num] += 1\\n            else:\\n                freq[num] = 1\\n        for num in freq:\\n            count += (freq[num]*(freq[num]-1)//2)\\n        return count \\n```\\n\\n**Time Complexity**: O(N), N being the number of elements in the array. First we iterate though the array to calculate the frequencies. That is done in O(N) time. Then we iterate through the dictionary once to calculate the number of good pairs, that is in worst-case (all numbers are different) done in O(N) time. So, total is O(2N) ~ O(N).\\n**Space Complexity**: O(N), we use a dictionaty to keep track of the frequencies, which in worst-case (all numbers are different) consumes N extra space.\\n",
                "solutionTags": [
                    "Python"
                ],
                "code": "```python\\nfor num in nums:\\n\\tif num in freq:\\n\\t\\tfreq[num] += 1\\n\\telse:\\n\\t\\tfreq[num] = 1\\n```\n```python\\nfor num in freq:\\n\\tcount += (freq[num]*(freq[num]-1)//2)\\n```\n```python\\nclass Solution:\\n    def numIdenticalPairs(self, nums: List[int]) -> int:\\n        count = 0\\n        freq = {}\\n        for num in nums:\\n            if num in freq:\\n                freq[num] += 1\\n            else:\\n                freq[num] = 1\\n        for num in freq:\\n            count += (freq[num]*(freq[num]-1)//2)\\n        return count \\n```",
                "codeTag": "Java"
            },
            {
                "id": 2250415,
                "title": "python3-o-n-o-n-runtime-47ms-60-77-memory-13-8mb-95-62",
                "content": "```\\nclass Solution:\\n#     O(n) || O(n)\\n# Runtime: 47ms 60.77% Memory: 13.8mb 95.62%\\n    def numIdenticalPairs(self, nums: List[int]) -> int:\\n        if not nums:\\n            return 0\\n\\t\\t\\t\\n        freqOfNumber = Counter(nums)\\n\\t\\t\\n        return sum([key * (key - 1) // 2 for key in freqOfNumber.values()])\\n```",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Math"
                ],
                "code": "```\\nclass Solution:\\n#     O(n) || O(n)\\n# Runtime: 47ms 60.77% Memory: 13.8mb 95.62%\\n    def numIdenticalPairs(self, nums: List[int]) -> int:\\n        if not nums:\\n            return 0\\n\\t\\t\\t\\n        freqOfNumber = Counter(nums)\\n\\t\\t\\n        return sum([key * (key - 1) // 2 for key in freqOfNumber.values()])\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2189733,
                "title": "python-using-hashmap",
                "content": "```\\nclass Solution:\\n    def numIdenticalPairs(self, nums: List[int]) -> int:\\n        dic = {}\\n        ans = 0\\n        n = len(nums)\\n        for i in range(n):\\n            if nums[i] in dic:\\n                ans += dic[nums[i]]\\n                dic[nums[i]] += 1\\n            else:\\n                dic[nums[i]] = 1 \\n        return ans\\n```\\nTime : O(N)\\nSpace : O(N)\\nPlease **UPVOTE**.",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nclass Solution:\\n    def numIdenticalPairs(self, nums: List[int]) -> int:\\n        dic = {}\\n        ans = 0\\n        n = len(nums)\\n        for i in range(n):\\n            if nums[i] in dic:\\n                ans += dic[nums[i]]\\n                dic[nums[i]] += 1\\n            else:\\n                dic[nums[i]] = 1 \\n        return ans\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1967855,
                "title": "java-0ms-counting-explanation-simple",
                "content": "The trick to solving this problem is to realize that for any given number, the number of \"good pairs\" that can be made with this number is the number of times we have seen this number previously in the array.\\n\\nWith the above logic, we just need to **iterate** over the input and **count** the number of times we have seen a given number so far, then add that to the total result before incrementing the count for the current number.\\n\\nSomething very important to mention, is that we can only get away with using an array of size 101 because the problem constraints state that no number in the input will be greater than 100. If this constaint didn\\'t exist, we could use something like a **HashMap** to keep track of the counts.\\n\\nUsing a **HashMap** instead of the array is perfectly acceptable and does yield the same runtime, but in practice will be much slower because of **overhead** from the **HashMap**. To recap, the use of a **HashMap** would not change the runtime complexity but it does make the practical performance worse.\\n\\n**Runtime Complexity - O(N)**\\n**Memory Complexity - O(1)**\\nwhere N is the size of the input array.\\n```\\n    public int numIdenticalPairs(int[] nums) {\\n        int[] counts = new int[101];\\n        \\n        int toReturn = 0;\\n        for(int num : nums) {\\n            toReturn += counts[num];\\n            counts[num]++;\\n        }\\n        \\n        return toReturn;\\n    }\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\n    public int numIdenticalPairs(int[] nums) {\\n        int[] counts = new int[101];\\n        \\n        int toReturn = 0;\\n        for(int num : nums) {\\n            toReturn += counts[num];\\n            counts[num]++;\\n        }\\n        \\n        return toReturn;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1730842,
                "title": "python-beginner-65-fast-using-hashmap-and-explanation",
                "content": "1. getting the count of all the numbers in a hashmap.\\n2. the number can only make a pair when it has frequency in the map more than once so we traverse the array checking frequence in the map we made\\n3. if the frequency is more than one we add to the result no of pairs it can make (number of pairs it can make is 1 less then the current frequency).\\n4. after we add to the result we subtract from the frequency of the count and continue in the loop.\\n\\n```\\ndef numIdenticalPairs(self, nums: List[int]) -> int:\\n        count = Counter(nums)\\n        \\n        #for n in nums:\\n        #    count[n] += 1\\n            \\n        res = 0\\n        \\n        for i in nums:\\n            if count[i] > 1:\\n                res += count[i] - 1\\n                count[i] -= 1\\n        return res\\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\ndef numIdenticalPairs(self, nums: List[int]) -> int:\\n        count = Counter(nums)\\n        \\n        #for n in nums:\\n        #    count[n] += 1\\n            \\n        res = 0\\n        \\n        for i in nums:\\n            if count[i] > 1:\\n                res += count[i] - 1\\n                count[i] -= 1\\n        return res\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 1701546,
                "title": "100-faster-solution-using-unordered-map-self-explainable",
                "content": "Guys do upvote if you like it, Please.\\nI have used a unordered map to count the occurence of elements in the array .\\nAfter counting ,if count>=2 we need to add their possible no.of pairs to sum(result)\\n```\\nclass Solution {\\npublic:\\n    int numIdenticalPairs(vector<int>& nums) {\\n        unordered_map<int,int> map;\\n        for(int i=0;i<nums.size();i++)\\n            map[nums[i]]++;\\n        \\n        int sum=0;\\n        for(auto it=map.begin();it!=map.end();it++)\\n        { \\n            int count=0;\\n            if(it->second>1)\\n            {\\n                for(int i=1;i<it->second;i++)\\n                    count+=i;\\n                \\n                sum+=count;\\n            }\\n            \\n        }\\n        return sum;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int numIdenticalPairs(vector<int>& nums) {\\n        unordered_map<int,int> map;\\n        for(int i=0;i<nums.size();i++)\\n            map[nums[i]]++;\\n        \\n        int sum=0;\\n        for(auto it=map.begin();it!=map.end();it++)\\n        { \\n            int count=0;\\n            if(it->second>1)\\n            {\\n                for(int i=1;i<it->second;i++)\\n                    count+=i;\\n                \\n                sum+=count;\\n            }\\n            \\n        }\\n        return sum;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1623759,
                "title": "python-99-7-faster-optimal-hashmap-solution",
                "content": "For the O(n) TC, O(n) SC solution, I used a dictionary to map the number to the number of times a value appears, starting from the last value.\\nI started from the last value because then the next time we see that number, we can count it as a good pair, since the index of the new number will be smaller than the index of the number we have in the dictionary. \\nIf the number is in the dictionary, we can increment our # of good pairs by adding the # of times we\\'ve seen the value.\\nFor example, if we have [1,1,1,1], we add 1 for the i = 2, 2 for i = 1, and 3 for the i = 0. We increment the counter in the dictionary after we\\'ve updated the count so we don\\'t include i = i as a good pair. This is effectively the same as ```n * (n - 1) / 2```, which is the sum from 1 to n-1.\\n\\n```\\n        count, nums_dict = 0, {}\\n        \\n        for i in range(-1, -(len(nums) + 1), -1):\\n            if nums[i] not in nums_dict:\\n                nums_dict[nums[i]] = 1\\n            else:\\n                count += nums_dict[nums[i]]\\n                nums_dict[nums[i]] += 1\\n        print(nums_dict)\\n        return count\\n```",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```n * (n - 1) / 2```\n```\\n        count, nums_dict = 0, {}\\n        \\n        for i in range(-1, -(len(nums) + 1), -1):\\n            if nums[i] not in nums_dict:\\n                nums_dict[nums[i]] = 1\\n            else:\\n                count += nums_dict[nums[i]]\\n                nums_dict[nums[i]] += 1\\n        print(nums_dict)\\n        return count\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 1554481,
                "title": "easy-to-understand-with-and-without-maps",
                "content": "```\\nclass Solution {\\npublic:\\n    int numIdenticalPairs(vector<int>& nums) {\\n        int count = 0;\\n        for(int index = 0 ; index < nums.size() ; index++)\\n        {\\n            for(int jindex = index + 1 ; jindex < nums.size() ; jindex++)\\n                if(nums[index] == nums[jindex])\\n                  count++;\\n        }\\n        return count;\\n    }\\n};\\n```\\n```\\nclass Solution {\\npublic:\\n    int numIdenticalPairs(vector<int>& nums) {\\n        unordered_map<int,int> map;\\n       \\n        int res = 0;\\n        \\n        for(auto n : nums)\\n        {\\n            res += map[n]++;\\n        }\\n        return res;\\n    }\\n};\\n\\n```\\n```\\nclass Solution {\\npublic:\\n    int numIdenticalPairs(vector<int>& nums) {\\n        unordered_map<int,int> map;\\n        \\n        int count = 0;\\n        for(int index = 0 ; index < nums.size() ; index++)\\n        {\\n            map[nums[index]]++;\\n        }\\n        \\n        for(int index = 0 ; index < nums.size() ; index++)\\n        {\\n            int n = map[nums[index]];\\n            map[nums[index]] = 0;\\n            count += (n * (n - 1))/2;\\n        }\\n        return count;\\n    }\\n};\\n\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int numIdenticalPairs(vector<int>& nums) {\\n        int count = 0;\\n        for(int index = 0 ; index < nums.size() ; index++)\\n        {\\n            for(int jindex = index + 1 ; jindex < nums.size() ; jindex++)\\n                if(nums[index] == nums[jindex])\\n                  count++;\\n        }\\n        return count;\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    int numIdenticalPairs(vector<int>& nums) {\\n        unordered_map<int,int> map;\\n       \\n        int res = 0;\\n        \\n        for(auto n : nums)\\n        {\\n            res += map[n]++;\\n        }\\n        return res;\\n    }\\n};\\n\\n```\n```\\nclass Solution {\\npublic:\\n    int numIdenticalPairs(vector<int>& nums) {\\n        unordered_map<int,int> map;\\n        \\n        int count = 0;\\n        for(int index = 0 ; index < nums.size() ; index++)\\n        {\\n            map[nums[index]]++;\\n        }\\n        \\n        for(int index = 0 ; index < nums.size() ; index++)\\n        {\\n            int n = map[nums[index]];\\n            map[nums[index]] = 0;\\n            count += (n * (n - 1))/2;\\n        }\\n        return count;\\n    }\\n};\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1495575,
                "title": "super-fast-100",
                "content": "int result =0;\\n        Map<Integer, Integer> map = new HashMap<>();\\n        for (int i = 0; i < nums.length; i++) {\\n            if (map.containsKey(nums[i])) {\\n                result+=map.get(nums[i]);\\n                map.put(nums[i], map.get(nums[i]) + 1);\\n            } else {\\n                map.put(nums[i], 1);\\n            }\\n        }\\n       return result;\\n    }",
                "solutionTags": [
                    "Java"
                ],
                "code": "int result =0;\\n        Map<Integer, Integer> map = new HashMap<>();\\n        for (int i = 0; i < nums.length; i++) {\\n            if (map.containsKey(nums[i])) {\\n                result+=map.get(nums[i]);\\n                map.put(nums[i], map.get(nums[i]) + 1);\\n            } else {\\n                map.put(nums[i], 1);\\n            }\\n        }\\n       return result;\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 1479230,
                "title": "python3-solution-using-dictionary",
                "content": "```\\nclass Solution:\\n    def numIdenticalPairs(self, nums: List[int]) -> int:\\n        mydict = {}\\n        for i in nums:\\n            if i not in mydict:\\n                mydict[i] = 1\\n            else:\\n                mydict[i] += 1\\n        \\n        count = 0\\n        for i in mydict:\\n            count += (mydict[i]*(mydict[i]-1))/2\\n        return int(count)",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "class Solution:\\n    def numIdenticalPairs(self, nums: List[int]) -> int:\\n        mydict = {}",
                "codeTag": "Java"
            },
            {
                "id": 1469620,
                "title": "0-ms-faster-java-hashmap-with-inline-comments",
                "content": "```\\nclass Solution {\\n    public int numIdenticalPairs(int[] nums) {\\n        //declare and initialize a count variable that keeps track of pairs\\n\\t\\tint count = 0;\\n\\t\\t// declare a HashMap that stores <K,V> in form of <nums[i], frequency of nums[i]>\\n\\t\\tMap<Integer, Integer> map = new HashMap<Integer, Integer>();\\n\\t\\t\\n\\t\\t//loop once through the array to store <K,V> in map\\n\\t\\tfor(int i = 0 ; i < nums.length; i++) {\\n\\t\\t\\t//check if map contains nums[i]\\n\\t\\t\\tif(map.containsKey(nums[i])) {\\n                // increase the count as nums[i] is repeated\\n\\t\\t\\t\\tcount += map.get(nums[i]);\\n\\t\\t\\t\\t//if nums[i] exists; add it to the map and increase it\\'s frequency.\\n\\t\\t\\t\\tmap.put(nums[i], map.get(nums[i]) + 1);\\n\\t\\t\\t\\t\\t\\t\\n\\t\\t\\t} else {\\n                //add it to map and initialize count to 1 (first occurence of nums[i])\\n\\t\\t\\t\\tmap.put(nums[i], 1);\\n\\t\\t\\t}\\t\\t\\n\\t\\t}\\n\\t\\treturn count;\\n    }\\n}\\n```\\ninputs appreciated.",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int numIdenticalPairs(int[] nums) {\\n        //declare and initialize a count variable that keeps track of pairs\\n\\t\\tint count = 0;\\n\\t\\t// declare a HashMap that stores <K,V> in form of <nums[i], frequency of nums[i]>\\n\\t\\tMap<Integer, Integer> map = new HashMap<Integer, Integer>();\\n\\t\\t\\n\\t\\t//loop once through the array to store <K,V> in map\\n\\t\\tfor(int i = 0 ; i < nums.length; i++) {\\n\\t\\t\\t//check if map contains nums[i]\\n\\t\\t\\tif(map.containsKey(nums[i])) {\\n                // increase the count as nums[i] is repeated\\n\\t\\t\\t\\tcount += map.get(nums[i]);\\n\\t\\t\\t\\t//if nums[i] exists; add it to the map and increase it\\'s frequency.\\n\\t\\t\\t\\tmap.put(nums[i], map.get(nums[i]) + 1);\\n\\t\\t\\t\\t\\t\\t\\n\\t\\t\\t} else {\\n                //add it to map and initialize count to 1 (first occurence of nums[i])\\n\\t\\t\\t\\tmap.put(nums[i], 1);\\n\\t\\t\\t}\\t\\t\\n\\t\\t}\\n\\t\\treturn count;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1191619,
                "title": "go",
                "content": "```\\nfunc numIdenticalPairs(nums []int) int {\\n    c:=0\\n    m := make(map[int]int)\\n    for i:=0;i<len(nums);i++{\\n            if _, ok := m[nums[i]]; ok {\\n                c+=m[nums[i]]\\n            } \\n            m[nums[i]]++\\n    }\\n    return c\\n}",
                "solutionTags": [],
                "code": "```\\nfunc numIdenticalPairs(nums []int) int {\\n    c:=0\\n    m := make(map[int]int)\\n    for i:=0;i<len(nums);i++{\\n            if _, ok := m[nums[i]]; ok {\\n                c+=m[nums[i]]\\n            } \\n            m[nums[i]]++\\n    }\\n    return c\\n}",
                "codeTag": "Unknown"
            },
            {
                "id": 1148606,
                "title": "rust-one-line-solution",
                "content": "```\\nimpl Solution {\\n    pub fn num_identical_pairs(nums: Vec<i32>) -> i32 {\\n        nums.iter()\\n            .fold([0i32; 101], |mut acc, &x| {\\n                acc[x as usize] += 1;\\n                acc\\n            })\\n            .iter()\\n            .filter(|&&x| x > 1)\\n            .map(|&x| x * (x - 1) / 2)\\n            .sum()\\n    }\\n}\\n```",
                "solutionTags": [
                    "Rust"
                ],
                "code": "```\\nimpl Solution {\\n    pub fn num_identical_pairs(nums: Vec<i32>) -> i32 {\\n        nums.iter()\\n            .fold([0i32; 101], |mut acc, &x| {\\n                acc[x as usize] += 1;\\n                acc\\n            })\\n            .iter()\\n            .filter(|&&x| x > 1)\\n            .map(|&x| x * (x - 1) / 2)\\n            .sum()\\n    }\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1147877,
                "title": "brute-force-solution",
                "content": "```\\nclass Solution:\\n    def numIdenticalPairs(self, nums: List[int]) -> int:\\n        count = 0\\n        for i in range(len(nums) - 1):\\n            for j in range(i + 1 , len(nums)):\\n                if(nums[i] == nums[j]): count += 1\\n        \\n        return count\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def numIdenticalPairs(self, nums: List[int]) -> int:\\n        count = 0\\n        for i in range(len(nums) - 1):\\n            for j in range(i + 1 , len(nums)):\\n                if(nums[i] == nums[j]): count += 1\\n        \\n        return count\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1123625,
                "title": "64-ms-faster-than-99-80-of-javascript",
                "content": "Runtime: 64 ms, faster than 99.80% of JavaScript online submissions for Number of Good Pairs.\\nMemory Usage: 38.3 MB, less than 86.10% of JavaScript online submissions for Number of Good Pairs.\\n\\n```\\nvar numIdenticalPairs = function(nums) {\\n  let result = 0\\n  nums.forEach((number, index) => {\\n    index = nums.indexOf(number, index + 1)\\n    while(index > 0) {\\n      result++\\n      index = nums.indexOf(number, index + 1)\\n    }\\n  })\\n  return result\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\nvar numIdenticalPairs = function(nums) {\\n  let result = 0\\n  nums.forEach((number, index) => {\\n    index = nums.indexOf(number, index + 1)\\n    while(index > 0) {\\n      result++\\n      index = nums.indexOf(number, index + 1)\\n    }\\n  })\\n  return result\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1070483,
                "title": "java-o-n",
                "content": "```\\nimport java.util.HashMap; \\n\\nclass Solution {\\n    public int numIdenticalPairs(int[] nums) {\\n        HashMap<Integer, Integer> h = new HashMap<>();\\n        for (int num:nums){\\n            h.put(num, h.getOrDefault(num, 0) + 1);\\n        }\\n        int sum = 0;\\n        \\n        for(int n: h.values()){\\n            sum += ((n*(n-1))/2);\\n        }\\n        return sum;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nimport java.util.HashMap; \\n\\nclass Solution {\\n    public int numIdenticalPairs(int[] nums) {\\n        HashMap<Integer, Integer> h = new HashMap<>();\\n        for (int num:nums){\\n            h.put(num, h.getOrDefault(num, 0) + 1);\\n        }\\n        int sum = 0;\\n        \\n        for(int n: h.values()){\\n            sum += ((n*(n-1))/2);\\n        }\\n        return sum;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1012671,
                "title": "java-0-ms-using-hashmap",
                "content": "```\\n\\npublic static  int numIdenticalPairs(int [] nums){\\n\\tMap<Integer,Integer> numbersMap = new HashMap<>();\\n\\tint counter = 0;\\n\\t\\n\\tfor(int keys : nums){\\n\\t\\tnumbersMap.put(keys,numbersMap.getOrDefault(keys,0)+1);\\n\\t}\\n\\t\\n\\tfor(int keys : numbersMap.keySet()){\\n\\t\\tint values = numbersMap.get(keys);\\n\\n\\t\\tif(values > 1){\\n\\t\\t\\tcounter += values * (values - 1) / 2;\\n\\t\\t}\\n\\t}\\n\\t\\n\\treturn counter;\\n}\\n\\n\\n\\n\\n```",
                "solutionTags": [],
                "code": "```\\n\\npublic static  int numIdenticalPairs(int [] nums){\\n\\tMap<Integer,Integer> numbersMap = new HashMap<>();\\n\\tint counter = 0;\\n\\t\\n\\tfor(int keys : nums){\\n\\t\\tnumbersMap.put(keys,numbersMap.getOrDefault(keys,0)+1);\\n\\t}\\n\\t\\n\\tfor(int keys : numbersMap.keySet()){\\n\\t\\tint values = numbersMap.get(keys);\\n\\n\\t\\tif(values > 1){\\n\\t\\t\\tcounter += values * (values - 1) / 2;\\n\\t\\t}\\n\\t}\\n\\t\\n\\treturn counter;\\n}\\n\\n\\n\\n\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 989147,
                "title": "python-3",
                "content": "Runtime: 32 ms\\nMemory Usage: 14.2 MB\\n\\n```\\nclass Solution:\\n    def numIdenticalPairs(self, nums: List[int]) -> int:\\n        good_pairs = 0\\n\\t\\t\\n\\t\\t#continue this while loop till the list is empty \\n        while nums != []:\\n\\t\\t\\n\\t\\t#for loop: from 2nd element onwards\\n            for i in range(1, len(nums)):\\n\\t\\t\\t\\n\\t\\t\\t#if first element is equal to the 2nd element\\n                if nums[0] == nums[i]:\\n\\t\\t\\t\\t\\n\\t\\t\\t\\t#add to good_pairs\\n                    good_pairs+=1\\n\\t\\t\\t\\t\\t\\n\\t\\t\\t#after going checking element 1&2, 1&3, til 1&n, remove the first element \\n\\t\\t\\t#this is to prevent counting the same pair twice\\n            nums.remove(nums[0])\\n\\t\\t\\t\\n\\t\\t#while loop continues till we remove all elements\\n\\t\\t\\n        return good_pairs\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def numIdenticalPairs(self, nums: List[int]) -> int:\\n        good_pairs = 0\\n\\t\\t\\n\\t\\t#continue this while loop till the list is empty \\n        while nums != []:\\n\\t\\t\\n\\t\\t#for loop: from 2nd element onwards\\n            for i in range(1, len(nums)):\\n\\t\\t\\t\\n\\t\\t\\t#if first element is equal to the 2nd element\\n                if nums[0] == nums[i]:\\n\\t\\t\\t\\t\\n\\t\\t\\t\\t#add to good_pairs\\n                    good_pairs+=1\\n\\t\\t\\t\\t\\t\\n\\t\\t\\t#after going checking element 1&2, 1&3, til 1&n, remove the first element \\n\\t\\t\\t#this is to prevent counting the same pair twice\\n            nums.remove(nums[0])\\n\\t\\t\\t\\n\\t\\t#while loop continues till we remove all elements\\n\\t\\t\\n        return good_pairs\\n```",
                "codeTag": "Java"
            },
            {
                "id": 955727,
                "title": "python-simple-o-n-dict-solution",
                "content": "\\t\\tans = 0\\n        d = {}\\n        for num in nums:\\n            if num in d:\\n                ans += d[num]\\n            d[num] = d.get(num,0) + 1\\n\\n        return ans",
                "solutionTags": [],
                "code": "\\t\\tans = 0\\n        d = {}\\n        for num in nums:\\n            if num in d:\\n                ans += d[num]\\n            d[num] = d.get(num,0) + 1\\n\\n        return ans",
                "codeTag": "Unknown"
            },
            {
                "id": 885329,
                "title": "java-solution-hashmap-o-n",
                "content": "Open to optimisations, feel the additional map.get can be removed.\\n\\n```\\nclass Solution {\\n    public int numIdenticalPairs(int[] nums) {\\n        //we need nested loop to compare OR\\n        //use dictionary to store unique values then see if they come up again, increment, add to final count\\n        \\n        HashMap<Integer, Integer> numSet = new HashMap();\\n        int count = 0;\\n        for(int i = 0; i < nums.length; i++){\\n            if(!numSet.containsKey(nums[i])) numSet.put(nums[i], 1); //marks each unique value\\n            else if(numSet.containsKey(nums[i])){\\n                count += numSet.get(nums[i]); //adds amount of each value\\n                numSet.put(nums[i], numSet.get(nums[i]) + 1);\\n            }\\n        }\\n        return count;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int numIdenticalPairs(int[] nums) {\\n        //we need nested loop to compare OR\\n        //use dictionary to store unique values then see if they come up again, increment, add to final count\\n        \\n        HashMap<Integer, Integer> numSet = new HashMap();\\n        int count = 0;\\n        for(int i = 0; i < nums.length; i++){\\n            if(!numSet.containsKey(nums[i])) numSet.put(nums[i], 1); //marks each unique value\\n            else if(numSet.containsKey(nums[i])){\\n                count += numSet.get(nums[i]); //adds amount of each value\\n                numSet.put(nums[i], numSet.get(nums[i]) + 1);\\n            }\\n        }\\n        return count;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 834972,
                "title": "java-solution-think-bigger",
                "content": "```\\nimport java.math.BigInteger;\\nclass Solution {\\n    public int numIdenticalPairs(int[] nums) {\\n        Map<Integer, Integer> map = new HashMap<>();\\n        int res = 0;\\n        for(int i : nums) {\\n            map.put(i, map.getOrDefault(i,0) + 1);\\n        }\\n           // System.out.print(i + \"\\\\t\" + map.get(i) + \"\\\\n\");\\n        \\n        for(int i: map.keySet()) {\\n            if(map.get(i) > 1) {\\n                int c = map.get(i);\\n                int r = 2;\\n                // int ncr = nCr(c, r);\\n                int ncr = (factorial(c).divide((factorial(c-r).multiply(BigInteger.TWO)))).intValue();\\n                res += ncr;\\n                // System.out.print(i + \"\\\\t\" + map.get(i) + \"\\\\t\" + ncr + \"\\\\n\");\\n            }\\n        }\\n        \\n        return res;\\n    }\\n    /*\\n     * Java method to calculate factorial of a large number\\n     * @return BigInteger factorial of given number\\n     */\\n    public BigInteger factorial(int number) {\\n        BigInteger factorial = BigInteger.ONE;\\n\\n        for (int i = number; i > 0; i--) {\\n            factorial = factorial.multiply(BigInteger.valueOf(i));\\n        }\\n\\n        return factorial;\\n    }\\n}",
                "solutionTags": [],
                "code": "class Solution {\\n    public int numIdenticalPairs(int[] nums) {\\n        Map<Integer, Integer> map = new HashMap<>();\\n        int res = 0;\\n        for(int i : nums) {\\n            map.put(i, map.getOrDefault(i,0) + 1);\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 783177,
                "title": "java-0-n-solution-with-0-1-space-with-explanation",
                "content": "```\\nclass Solution {\\n    \\n    //make an integer array of size 101\\n    //iterate over the input array and increment the frequency at the index corresponding to the number in the array.\\n    //Use the formuale freqCount - 1 * freqCount / 2;\\n    //Logic Behind:\\n    //No. of fours = 4, No. of pairs = 6\\n    // No. of ones = 3, No. of pairs = 3\\n    // No. of two\\'s = 2, No, of pairs = 1\\n\\n    // If you try to note this down on a paper and try to work out how the number of pairs are being calculated:\\n    // As an example, Lets use No. of fours = 4:\\n    // there are four fours in our list, ignore the other numbers for now.:\\n    // 4 4 4 4\\n    // how many pairs can we make out of this ?\\n    // You can straight away use combinatorics.\\n\\n    // OR\\n\\n    // If you try to work this out and tell how we came to 6 pairs,\\n    // You can see that first 4 can be paired to the 3 fours in front of it.\\n    // The second four can be paired with the 2 fours in front of it (it has already been paired with the first one)\\n    // The third four can be paired with the last four.\\n    \\n    // If you count= 3 + 2 + 1\\n\\n    // you will immediately make the connection to the summation formulae (n(n+1))/2, but n here is 1 less than the             actual number.\\n\\n    \\n    //keep adding the results of factorial to the result i.e sum\\n    \\n    \\n    //TimeComplexity = O(n);\\n    //SpaceComplexity = O(1);\\n  \\n    public int numIdenticalPairs(int[] nums) {\\n        int goodPairs = 0;\\n        int[] freqCount = new int[101];\\n        \\n        for(int i=0; i<nums.length; i++){\\n            freqCount[nums[i]]++;\\n        }\\n                \\n        int r = 2;\\n        \\n        for(int i=0; i<101; i++){\\n            \\n            if(freqCount[i] > 1){\\n                goodPairs += (freqCount[i] - 1) * (freqCount[i]) / 2;\\n            }\\n            \\n        }\\n        \\n        return goodPairs;\\n        \\n    }\\n    \\n}",
                "solutionTags": [
                    "Java"
                ],
                "code": "class Solution {\\n    \\n    //make an integer array of size 101\\n    //iterate over the input array and increment the frequency at the index corresponding to the number in the array.\\n    //Use the formuale freqCount - 1 * freqCount / 2;\\n    //Logic Behind:\\n    //No. of fours = 4, No. of pairs = 6\\n    // No. of ones = 3, No. of pairs = 3\\n    // No. of two\\'s = 2, No, of pairs = 1\\n\\n    // If you try to note this down on a paper and try to work out how the number of pairs are being calculated:\\n    // As an example, Lets use No. of fours = 4:\\n    // there are four fours in our list, ignore the other numbers for now.:\\n    // 4 4 4 4\\n    // how many pairs can we make out of this ?\\n    // You can straight away use combinatorics.\\n\\n    // OR\\n\\n    // If you try to work this out and tell how we came to 6 pairs,\\n    // You can see that first 4 can be paired to the 3 fours in front of it.\\n    // The second four can be paired with the 2 fours in front of it (it has already been paired with the first one)\\n    // The third four can be paired with the last four.\\n    \\n    // If you count= 3 + 2 + 1\\n\\n    // you will immediately make the connection to the summation formulae (n(n+1))/2, but n here is 1 less than the             actual number.\\n\\n    \\n    //keep adding the results of factorial to the result i.e sum\\n    \\n    \\n    //TimeComplexity = O(n);\\n    //SpaceComplexity = O(1);\\n  \\n    public int numIdenticalPairs(int[] nums) {\\n        int goodPairs = 0;\\n        int[] freqCount = new int[101];\\n        \\n        for(int i=0; i<nums.length; i++){\\n            freqCount[nums[i]]++;\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 776829,
                "title": "java-o-n-solution",
                "content": "The most naive solution is two scan to get the answer. After reviewing other solutions, I get the optimize one.\\n```\\nclass Solution {\\n    public int numIdenticalPairs(int[] nums) {\\n        int count = 0;\\n        for(int i = 0; i < nums.length; i++){\\n            int pivot = nums[i];\\n            for(int j = i+1; j < nums.length; j++){\\n                if(nums[j] == pivot){\\n                    count++;\\n                }\\n            }\\n        }\\n        return count;\\n    }\\n}\\n```\\nThe idea of optimze solution is to use hashmap to record the occurrence of each elment of array. We initialize the hashmap with key of array element, value of 1. Each time a same element found, we update the value by add 1. We incrementally update the count to record the occurrence of element so far.\\n```\\nclass Solution {\\n    public int numIdenticalPairs(int[] nums) {\\n        int count = 0;\\n        HashMap<Integer, Integer> map = new HashMap<>();\\n        for(int i : nums){\\n            if(map.containsKey(i)){\\n                count += map.get(i);\\n                map.put(i, map.get(i) + 1);\\n                \\n            }else{\\n                \\n                map.put(i, 1);\\n            }\\n        }\\n        \\n        return count;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int numIdenticalPairs(int[] nums) {\\n        int count = 0;\\n        for(int i = 0; i < nums.length; i++){\\n            int pivot = nums[i];\\n            for(int j = i+1; j < nums.length; j++){\\n                if(nums[j] == pivot){\\n                    count++;\\n                }\\n            }\\n        }\\n        return count;\\n    }\\n}\\n```\n```\\nclass Solution {\\n    public int numIdenticalPairs(int[] nums) {\\n        int count = 0;\\n        HashMap<Integer, Integer> map = new HashMap<>();\\n        for(int i : nums){\\n            if(map.containsKey(i)){\\n                count += map.get(i);\\n                map.put(i, map.get(i) + 1);\\n                \\n            }else{\\n                \\n                map.put(i, 1);\\n            }\\n        }\\n        \\n        return count;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 759183,
                "title": "javascript-map",
                "content": "```\\n\\nvar numIdenticalPairs = function(nums) {\\n    let map = new Map(); //store n,freq\\n    for(let n of nums){\\n        map.set(n, (map.get(n) || 0) + 1);\\n    }\\n    let res = 0;\\n    for(const [k,v] of map){\\n        res += parseInt((map.get(k) * (map.get(k) -1)) / 2);\\n    }\\n    return res;\\n};\\n\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n\\nvar numIdenticalPairs = function(nums) {\\n    let map = new Map(); //store n,freq\\n    for(let n of nums){\\n        map.set(n, (map.get(n) || 0) + 1);\\n    }\\n    let res = 0;\\n    for(const [k,v] of map){\\n        res += parseInt((map.get(k) * (map.get(k) -1)) / 2);\\n    }\\n    return res;\\n};\\n\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 732511,
                "title": "java-solution-using-hashmap",
                "content": "Here we have used a hashmap to store the number of times one particular element is found in the array.\\nWe store the number of times an elemnts appears in the array. \\nExolaining it with an example:-\\n\\n[1,2,3,1,1,3]\\n\\nStarting with first iteration we will add 1 in hashmap with coressponding value of occurrence i.e 1. \\nSame will happen for 2,3.\\nNow when we will reach 4th iteration 1 has to be updated so we get the value from hashmap and add in the variable sum defining that we have found the first pair(here value of sum is 1 now). Here after adding the value in sum we update the hashmap and put the value against 1 as 2, indicating that if 1 appears again in the array it can form pair with 2 ones. which happens for the case of 5th iteration where we find 1 again and add 2 in sum.(Now the value of sum is 3). In the last iteration we find 3 in hashmap for which 1 is stored which is added in the sum.\\nHence at last we get 4 as value which is the answer.\\n\\n\\n\\'\\'\\'\\n\\nclass Solution {\\n    public int numIdenticalPairs(int[] nums) {\\n        \\n        HashMap<Integer,Integer> map = new HashMap<>();\\n        \\n        \\n        int sum = 0;\\n        for(int i=0;i<nums.length;i++){\\n            \\n            if(map.containsKey(nums[i])){               //Here we keep on updating the value in hashmap and keep on adding the value in sum\\n                \\n                \\n                \\n                int temp = map.get(nums[i]);\\n                sum+=temp;\\n                temp++;\\n                map.replace(nums[i],temp);\\n                \\n                \\n            }else{\\n                \\n                \\n                map.put(nums[i],1);  //for the first time value of hashmap for an element is always 1.\\n                \\n            }\\n            \\n        }\\n        \\n        return sum;\\n        \\n    }\\n}\\n\\n\\'\\'\\'",
                "solutionTags": [],
                "code": "class Solution {\\n    public int numIdenticalPairs(int[] nums) {\\n        \\n        HashMap<Integer,Integer> map = new HashMap<>();\\n        \\n        \\n        int sum = 0;\\n        for(int i=0;i<nums.length;i++){\\n            \\n            if(map.containsKey(nums[i])){               //Here we keep on updating the value in hashmap and keep on adding the value in sum\\n                \\n                \\n                \\n                int temp = map.get(nums[i]);\\n                sum+=temp;\\n                temp++;\\n                map.replace(nums[i],temp);\\n                \\n                \\n            }",
                "codeTag": "Java"
            },
            {
                "id": 731850,
                "title": "javascript-few-solutions-o-n",
                "content": "Using Object:\\n```\\nvar numIdenticalPairs = function(nums) {\\n  let obj = {};\\n  let p = 0;\\n  for (let n of nums) {\\n    if (obj[n]) {\\n      p += obj[n];\\n      obj[n] = obj[n] + 1;\\n    } else obj[n] = 1;\\n  }\\n  return p;\\n};\\n```\\nOne-liner:\\n```\\nlet numIdenticalPairs = A => A.map((_, i) => i + 1 == A.length ? 0 : A.slice(i).map((_, j) => Number(A[i] == A[i + j + 1])).reduce((a, b) => a + b)).reduce((a, b) => a + b);\\n```\\n2-liner:\\n```\\nvar numIdenticalPairs = function(nums, count = 0) {\\n  for (let i = 0; i < nums.length - 1; i += 1) for (let j = i + 1; j < nums.length; j += 1) count += nums[i] === nums[j];\\n  return count;\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\nvar numIdenticalPairs = function(nums) {\\n  let obj = {};\\n  let p = 0;\\n  for (let n of nums) {\\n    if (obj[n]) {\\n      p += obj[n];\\n      obj[n] = obj[n] + 1;\\n    } else obj[n] = 1;\\n  }\\n  return p;\\n};\\n```\n```\\nlet numIdenticalPairs = A => A.map((_, i) => i + 1 == A.length ? 0 : A.slice(i).map((_, j) => Number(A[i] == A[i + j + 1])).reduce((a, b) => a + b)).reduce((a, b) => a + b);\\n```\n```\\nvar numIdenticalPairs = function(nums, count = 0) {\\n  for (let i = 0; i < nums.length - 1; i += 1) for (let j = i + 1; j < nums.length; j += 1) count += nums[i] === nums[j];\\n  return count;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 731674,
                "title": "c-simple-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    int numIdenticalPairs(vector<int>& nums) {\\n        long long ans = 0;\\n        unordered_map<int,int>m;\\n        for(int x:nums) m[x]++;  // count occurance\\n        for(auto p: m){\\n            if(p.second > 1) ans += (p.second * (p.second-1) )/2;  \\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int numIdenticalPairs(vector<int>& nums) {\\n        long long ans = 0;\\n        unordered_map<int,int>m;\\n        for(int x:nums) m[x]++;  // count occurance\\n        for(auto p: m){\\n            if(p.second > 1) ans += (p.second * (p.second-1) )/2;  \\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 731559,
                "title": "c-o-n-2-o-n",
                "content": "//TC-O(N^2) , SC-O(1)\\n```\\nclass Solution {\\npublic:\\n    int numIdenticalPairs(vector<int>& nums) {\\n        int cnt = 0;\\n        for(int i=0; i<nums.size(); ++i)//take each number\\n        {\\n            for(int j=i+1; j<nums.size(); ++j)//check in next numbers\\n            {\\n                if(nums[i]==nums[j])//if they are same increment the counter for good pair\\n                    cnt++;\\n            }\\n        }\\n        return cnt;\\n    }\\n};\\n```\\n\\n//TC-O(N) & SC-O(N)\\n```\\n\\n\\nclass Solution {\\npublic:\\n    int numIdenticalPairs(vector<int>& nums) {\\n        unordered_map<int,int> hash;\\n        int cnt = 0;\\n        for(auto n:nums)//take each number\\n        {//for 1 occurence add 0, for second occ add 1, for third occ add 2, (1 +2= 3), for 4th occ, add 3.(1+2+3=6)\\n            \\n           cnt += hash[n]++;\\n        }\\n        return cnt;\\n    }\\n};\\n\\n//2- 1\\n//3- 3\\n//4- 6\\n//5- 10\\n//6- 15\\n//7- 21\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int numIdenticalPairs(vector<int>& nums) {\\n        int cnt = 0;\\n        for(int i=0; i<nums.size(); ++i)//take each number\\n        {\\n            for(int j=i+1; j<nums.size(); ++j)//check in next numbers\\n            {\\n                if(nums[i]==nums[j])//if they are same increment the counter for good pair\\n                    cnt++;\\n            }\\n        }\\n        return cnt;\\n    }\\n};\\n```\n```\\n\\n\\nclass Solution {\\npublic:\\n    int numIdenticalPairs(vector<int>& nums) {\\n        unordered_map<int,int> hash;\\n        int cnt = 0;\\n        for(auto n:nums)//take each number\\n        {//for 1 occurence add 0, for second occ add 1, for third occ add 2, (1 +2= 3), for 4th occ, add 3.(1+2+3=6)\\n            \\n           cnt += hash[n]++;\\n        }\\n        return cnt;\\n    }\\n};\\n\\n//2- 1\\n//3- 3\\n//4- 6\\n//5- 10\\n//6- 15\\n//7- 21\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4072440,
                "title": "easy-without-brute-force-js",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n    O(n)\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * @param {number[]} nums\\n * @return {number}\\n */\\nvar numIdenticalPairs = function(nums) {\\n    let holder = new Map();\\n    for(let i=0; i<nums.length; i++) {\\n        if(holder.has(nums[i])) {\\n            holder.set(nums[i], holder.get(nums[i])+1);\\n        }\\n        else {\\n            holder.set(nums[i], 1);\\n        }\\n    }\\n\\n    let count=0;\\n    holder.forEach (function(value, key) {\\n        let val = value-1;\\n        count = count + ((1 + val)/2 * val);\\n\\n    })\\n    return count;\\n\\n};\\n\\n```",
                "solutionTags": [
                    "C++",
                    "Java",
                    "Python",
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {number[]} nums\\n * @return {number}\\n */\\nvar numIdenticalPairs = function(nums) {\\n    let holder = new Map();\\n    for(let i=0; i<nums.length; i++) {\\n        if(holder.has(nums[i])) {\\n            holder.set(nums[i], holder.get(nums[i])+1);\\n        }\\n        else {\\n            holder.set(nums[i], 1);\\n        }\\n    }\\n\\n    let count=0;\\n    holder.forEach (function(value, key) {\\n        let val = value-1;\\n        count = count + ((1 + val)/2 * val);\\n\\n    })\\n    return count;\\n\\n};\\n\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 4037632,
                "title": "solution-of-number-of-good-pairs-problem",
                "content": "# Approach\\n- Solved using nCr formula.\\n- nCr is the number of ways of selecting some objects out of given objects where the order of the objects does not matter. It is expressed as nCr = n!/(r! * (n-r)!)\\n- You can use math.factorial(n) istead of function \"factorial\" to solve the problem\\n- n is the number of repeating digits\\n- r is the number of things to be chosen out of n things (r is equal to 2 in our case).\\n\\n\\n# Code with factorial()\\n```\\ndef factorial(n):\\n    if n==1 or n==0:\\n        return 1\\n    return n*factorial(n-1)\\n\\nclass Solution:\\n    def numIdenticalPairs(self, nums: List[int]) -> int:\\n        visited = set()\\n        count = 0\\n        for i in range(0, len(nums)):\\n            if nums[i] not in visited and nums.count(nums[i]) > 1:\\n                n_factorial = factorial(nums.count(nums[i]))\\n                r_factorial = factorial(nums.count(nums[i]) - 2)\\n                count += n_factorial/(r_factorial * 2)\\n            visited.add(nums[i])\\n        return int(count)   \\n```\\n# Code with math.factorial()\\n```\\nimport math\\n\\nclass Solution:\\n    def numIdenticalPairs(self, nums: List[int]) -> int:\\n        visited = set()\\n        count = 0\\n        for i in range(0, len(nums)):\\n            if nums[i] not in visited and nums.count(nums[i]) > 1:\\n                n_factorial = math.factorial(nums.count(nums[i]))\\n                r_factorial = math.factorial(nums.count(nums[i])-2)\\n                count += n_factorial/(r_factorial*2)\\n            visited.add(nums[i])\\n        return int(count)          \\n        \\n```",
                "solutionTags": [
                    "Python3",
                    "Array",
                    "Hash Table",
                    "Math"
                ],
                "code": "```\\ndef factorial(n):\\n    if n==1 or n==0:\\n        return 1\\n    return n*factorial(n-1)\\n\\nclass Solution:\\n    def numIdenticalPairs(self, nums: List[int]) -> int:\\n        visited = set()\\n        count = 0\\n        for i in range(0, len(nums)):\\n            if nums[i] not in visited and nums.count(nums[i]) > 1:\\n                n_factorial = factorial(nums.count(nums[i]))\\n                r_factorial = factorial(nums.count(nums[i]) - 2)\\n                count += n_factorial/(r_factorial * 2)\\n            visited.add(nums[i])\\n        return int(count)   \\n```\n```\\nimport math\\n\\nclass Solution:\\n    def numIdenticalPairs(self, nums: List[int]) -> int:\\n        visited = set()\\n        count = 0\\n        for i in range(0, len(nums)):\\n            if nums[i] not in visited and nums.count(nums[i]) > 1:\\n                n_factorial = math.factorial(nums.count(nums[i]))\\n                r_factorial = math.factorial(nums.count(nums[i])-2)\\n                count += n_factorial/(r_factorial*2)\\n            visited.add(nums[i])\\n        return int(count)          \\n        \\n```",
                "codeTag": "Java"
            },
            {
                "id": 4001148,
                "title": "easy-java-solution-with-simple-concept-for-beginners",
                "content": "# Intuition\\nAs the problem statement was to find the number of pairs so we can use the general array concept to get the pair \\n\\n# Approach\\nFirst initialize the counter and assign for loop and nested for loop \\nand increament the iteration part and check the condition that if itearated value of i and j is equal means return counter iteration.\\n\\n# Complexity\\n- Time complexity:\\n- O(n)\\n\\n- Space complexity:\\n-O(n)\\n\\n# Code\\n```\\nclass Solution {\\n    public int numIdenticalPairs(int[] nums) {\\n        int len =nums.length;\\n        int counter=0;\\n        for (int i =0;i<len;i++){\\n            for (int j=i+1;j<len;j++){\\n                if(nums[i]==nums[j]){\\n                    counter++; \\n                }           \\n            }\\n            \\n        }\\n        return counter;\\n        \\n    }\\n}\\n\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int numIdenticalPairs(int[] nums) {\\n        int len =nums.length;\\n        int counter=0;\\n        for (int i =0;i<len;i++){\\n            for (int j=i+1;j<len;j++){\\n                if(nums[i]==nums[j]){\\n                    counter++; \\n                }           \\n            }\\n            \\n        }\\n        return counter;\\n        \\n    }\\n}\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3690308,
                "title": "easy-javascript-solution-using-creating-map-98",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nfunction numIdenticalPairs(nums: number[]): number {\\n   let goodPair = 0 \\n   let map = {}\\n   for(let num of nums) {\\n     if(map[num]) {\\n       goodPair += map[num]\\n       map[num]++\\n     } else {\\n       map[num] = 1\\n     }\\n   }\\n  return goodPair\\n};\\n```",
                "solutionTags": [
                    "JavaScript",
                    "TypeScript"
                ],
                "code": "```\\nfunction numIdenticalPairs(nums: number[]): number {\\n   let goodPair = 0 \\n   let map = {}\\n   for(let num of nums) {\\n     if(map[num]) {\\n       goodPair += map[num]\\n       map[num]++\\n     } else {\\n       map[num] = 1\\n     }\\n   }\\n  return goodPair\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3596640,
                "title": "easy-c-solution",
                "content": "class Solution {\\npublic:\\n\\n    int numIdenticalPairs(vector<int>& nums) {\\n\\t\\n        int ans = 0 ; \\n        for(int i=0 ; i<nums.size() ;i++){\\n            for(int j=i+1; j<nums.size();j++){\\n                if(nums[i]==nums[j]){\\n                    ans++;\\n                }\\n            }\\n        }return ans; \\n    }\\n};",
                "solutionTags": [
                    "C",
                    "Array"
                ],
                "code": "class Solution {\\npublic:\\n\\n    int numIdenticalPairs(vector<int>& nums) {\\n\\t\\n        int ans = 0 ; \\n        for(int i=0 ; i<nums.size() ;i++){\\n            for(int j=i+1; j<nums.size();j++){\\n                if(nums[i]==nums[j]){\\n                    ans++;\\n                }",
                "codeTag": "Java"
            },
            {
                "id": 3535804,
                "title": "without-hashing-nested-loop-for-beginner",
                "content": "\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int numIdenticalPairs(vector<int>& nums) {\\n        int count=0;\\n        for(int i=0;i<nums.size();i++){\\n            for(int j=i+1;j<nums.size();j++){\\n                if(nums[i]==nums[j])\\n                {\\n                    count++;\\n                }\\n            }\\n        }\\n        return count;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int numIdenticalPairs(vector<int>& nums) {\\n        int count=0;\\n        for(int i=0;i<nums.size();i++){\\n            for(int j=i+1;j<nums.size();j++){\\n                if(nums[i]==nums[j])\\n                {\\n                    count++;\\n                }\\n            }\\n        }\\n        return count;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3508765,
                "title": "simplest-efficient-c-code-time-o-n-2-space-o-1",
                "content": "# Intuition\\nThe problem is asking to find the number of indices (i,j) such that i < j and nums[i] == nums[j]. One way to approach this problem is to iterate through the array and compare each element with all the elements that come after it. If we find any element that is equal to the current element, we increase a counter. At the end, the counter will hold the number of identical pairs.\\n\\n# Approach\\nThe given code is implementing the above approach. It is using two nested loops to iterate through the array and compare each element with all the elements that come after it. If the elements are equal, it increases the counter. At the end, it returns the counter.\\n\\n# Complexity\\n- Time complexity : $O(n^2)$, where n is the size of the array. This is because we are using two nested loops to iterate through the array.\\n\\n- Space complexity : $O(1)$. The algorithm uses a constant amount of extra space regardless of the size of the input.\\n\\n# Code\\n```\\nint numIdenticalPairs(int* nums, int n)\\n{\\n    int count=0;\\n    for(int i=0;i<n;i++)\\n    {\\n        for(int j=i+1;j<n;j++)\\n        {\\n            if(nums[i]==nums[j])\\n            count++;\\n        }\\n    }\\n    return count;\\n}\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nint numIdenticalPairs(int* nums, int n)\\n{\\n    int count=0;\\n    for(int i=0;i<n;i++)\\n    {\\n        for(int j=i+1;j<n;j++)\\n        {\\n            if(nums[i]==nums[j])\\n            count++;\\n        }\\n    }\\n    return count;\\n}\\n```",
                "codeTag": "Unknown"
            }
        ],
        "discussions": [
            {
                "id": 1570274,
                "content": [
                    {
                        "username": "user5615M",
                        "content": "I wanna explain this solution for peaple who like detailed mathematical explanations\\n\\nthe solution starts with iterating through all  the list and count the number of occurrences of each number and store it in a dictionary. so far so good!  \\nNext we want to iterate through each dictionary key and calculate the number of pairs.\\nCalculating the number of pairs is all about calculating the combinations of numbers\\n**nCr**  where **n** s the number of occurrences and **r**  is the number of elements we want in one group. Combinations are calculated as follows **nCr = n! / r! * (n-r)!** but remember that we want to count the number of pairs so **r=2** in our case. \\nLet\\'s calculate this \\n**nC2 = n! / 2! * (n-2)** =  **n * (n-1) * (n-2) * (n-3) *....1 /  2 * (n-2) * (n-3) * (n-4)*.....1**\\nso as you notice, there\\'re duplicate terms in the numerator and denomenator. we are gonna eliminate the terms starting from (n-2) to the end from both the numerator and denomenator. so we end up with **n * (n-1) / 2** This is exactly like summing from 1 to n-1. \\nso the final formula is used to calculate the number of pairs in each key of the dictionary \\nif n = 4 number of pairs is 4 * 3 / 2 = 6 pairs which gets the correct solution.\\n"
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "https://leetcode.com/problems/number-of-good-pairs/solutions/2784238/easy-c-o-n-soln-faang-interview-optimized-code/"
                    },
                    {
                        "username": "jjhardey24",
                        "content": "I\\'m not sure if I understand this quesion as it is unclear to me. What exactlty are i and j in the good pairs. Could someone expand further or give more test cases? I would greatly appreciate it."
                    },
                    {
                        "username": "ointissar",
                        "content": "i and j are indexes of good pairs in the given array\\nLet\\'s take an example:\\ngiven array                     [1, 3, 2, 1]\\nindexes                            0 1  2  3\\ngood pairs i and j            i           j\\n\\nSo i and j making the good pair (i, j) => (0, 3), because i < j  => 0 < 3 and array[i] = array[j]\\n\\nHope it\\'s clear enough :) "
                    },
                    {
                        "username": "Lucky_Dev",
                        "content": "indexes "
                    },
                    {
                        "username": "NagarapuNagaVenkataSivaSaiRagh",
                        "content": "i and j are index numbers, if nums[i]==nums[j]  then (i,j) is agood pair.... where(i<j)\\n\\nI hope you understood it\\n"
                    },
                    {
                        "username": "LOGANBLUE",
                        "content": "i and j are the indexes for equal entries like if 3 is present at 0,2,5 indexes so you have to make pair of the indexes like 0,2 & 0,5 & 2,5 so answer is 3(no of pairs of indexes)"
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "https://leetcode.com/problems/number-of-good-pairs/solutions/2784238/easy-c-o-n-soln-faang-interview-optimized-code/"
                    },
                    {
                        "username": "ft3793",
                        "content": "i should be in the last of the list and i in the starter of the list\\n"
                    },
                    {
                        "username": "Jsn667",
                        "content": "![image](https://assets.leetcode.com/users/images/e302aec0-570a-463e-8f68-3d87f4b3b4db_1608955337.8360794.png)\\n"
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "https://leetcode.com/problems/number-of-good-pairs/solutions/2784238/easy-c-o-n-soln-faang-interview-optimized-code/"
                    },
                    {
                        "username": "FireFrost",
                        "content": "check every pair with nested loop \\ntime - O(n^2)\\nspace - O(1)\\n\\nfrequency table and sum of n integers formula\\ntime - O(n)\\nspace - O(n)"
                    },
                    {
                        "username": "Nikhil_G002109",
                        "content": "How does the idea of using sum of \\'n\\' integers would come up in my mind??"
                    },
                    {
                        "username": "anshulupadhyay03",
                        "content": "why is my code failing for input : nums =\\n[6,5,1,5,7,7,9,1,5,7,1,6,10,9,7,4,1,8,7,1,1,8,6,4,7,4,10,5,3,9,10,1,9,5,5,4,1,7,4,2,9,2,6,6,4,2,10,3,5,3,6,4,7,4,6,4,4,6,3,4,10,1,10,6,10,4,9,6,6,4,8,6,9,5,4]\\n I am using the method of counting the numbers frequency and then using formula nCr to calculate pairs."
                    },
                    {
                        "username": "fuongdtran",
                        "content": "[@ry-reek](/ry-reek) it\\'s not the reason. Remember C is combinations, not permutations, meaning that (i,j) and (j,i) are accounted as one possibility. In other words, it does not matter if i < j or i > j"
                    },
                    {
                        "username": "fuongdtran",
                        "content": "The approach is right. The problem is that int/long variable does not big enough to hold a factorial calculation. since we know the r = 2, we can simplify the formula"
                    },
                    {
                        "username": "ry-reek",
                        "content": "okay, so one thing that I figured out is that calculating the nCr does not take the i < j into consideration so that\\'s why it\\'s the wrong approach."
                    },
                    {
                        "username": "ry-reek",
                        "content": "I am doing the same thing and my code fails for this exact test case."
                    },
                    {
                        "username": "kya_",
                        "content": "Did you ever figure out why this fails. I did the sam approach \\n"
                    },
                    {
                        "username": "tejaanuchuri",
                        "content": "![image](https://assets.leetcode.com/users/images/bc83ea82-042d-4c66-81c4-1632b63f9d3c_1651656723.4516509.png)\\n\\nHere we finding each number frequency and then based on frequency we get number of pairs;\\n\\nfor example a item has frequency k then (k*(k-1))/2 pairs are generated."
                    },
                    {
                        "username": "Anubhav_Saha",
                        "content": "Hi, can you explain the logic behind the formula k*(k-1)/2 for calculating pair\\n"
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "https://leetcode.com/problems/number-of-good-pairs/solutions/2784238/easy-c-o-n-soln-faang-interview-optimized-code/"
                    },
                    {
                        "username": "laosunhust",
                        "content": "`return int(sum([v(v-1)/2 for , v in Counter(nums).items()]))`"
                    },
                    {
                        "username": "luciferstern",
                        "content": "what if we want sum of all good pairs present in every subarray of a\\n"
                    },
                    {
                        "username": "L33TC0D3R4L1F3",
                        "content": "Wizard math?"
                    },
                    {
                        "username": "jaszy_the_better_twin",
                        "content": "slay"
                    },
                    {
                        "username": "percylam-pt",
                        "content": "**var numIdenticalPairs = function(nums) {\\n&ensp; &ensp; let output = 0;\\n&ensp; &ensp; while (nums.length!=0){\\n&ensp; &ensp; &ensp; &ensp; let target = nums.shift();\\n&ensp; &ensp; &ensp; &ensp; nums.forEach(e=>{e==target?output+=1:output+=0})\\n&ensp; &ensp; };\\n&ensp; &ensp; return output\\n};**"
                    }
                ]
            },
            {
                "id": 1574043,
                "content": [
                    {
                        "username": "user5615M",
                        "content": "I wanna explain this solution for peaple who like detailed mathematical explanations\\n\\nthe solution starts with iterating through all  the list and count the number of occurrences of each number and store it in a dictionary. so far so good!  \\nNext we want to iterate through each dictionary key and calculate the number of pairs.\\nCalculating the number of pairs is all about calculating the combinations of numbers\\n**nCr**  where **n** s the number of occurrences and **r**  is the number of elements we want in one group. Combinations are calculated as follows **nCr = n! / r! * (n-r)!** but remember that we want to count the number of pairs so **r=2** in our case. \\nLet\\'s calculate this \\n**nC2 = n! / 2! * (n-2)** =  **n * (n-1) * (n-2) * (n-3) *....1 /  2 * (n-2) * (n-3) * (n-4)*.....1**\\nso as you notice, there\\'re duplicate terms in the numerator and denomenator. we are gonna eliminate the terms starting from (n-2) to the end from both the numerator and denomenator. so we end up with **n * (n-1) / 2** This is exactly like summing from 1 to n-1. \\nso the final formula is used to calculate the number of pairs in each key of the dictionary \\nif n = 4 number of pairs is 4 * 3 / 2 = 6 pairs which gets the correct solution.\\n"
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "https://leetcode.com/problems/number-of-good-pairs/solutions/2784238/easy-c-o-n-soln-faang-interview-optimized-code/"
                    },
                    {
                        "username": "jjhardey24",
                        "content": "I\\'m not sure if I understand this quesion as it is unclear to me. What exactlty are i and j in the good pairs. Could someone expand further or give more test cases? I would greatly appreciate it."
                    },
                    {
                        "username": "ointissar",
                        "content": "i and j are indexes of good pairs in the given array\\nLet\\'s take an example:\\ngiven array                     [1, 3, 2, 1]\\nindexes                            0 1  2  3\\ngood pairs i and j            i           j\\n\\nSo i and j making the good pair (i, j) => (0, 3), because i < j  => 0 < 3 and array[i] = array[j]\\n\\nHope it\\'s clear enough :) "
                    },
                    {
                        "username": "Lucky_Dev",
                        "content": "indexes "
                    },
                    {
                        "username": "NagarapuNagaVenkataSivaSaiRagh",
                        "content": "i and j are index numbers, if nums[i]==nums[j]  then (i,j) is agood pair.... where(i<j)\\n\\nI hope you understood it\\n"
                    },
                    {
                        "username": "LOGANBLUE",
                        "content": "i and j are the indexes for equal entries like if 3 is present at 0,2,5 indexes so you have to make pair of the indexes like 0,2 & 0,5 & 2,5 so answer is 3(no of pairs of indexes)"
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "https://leetcode.com/problems/number-of-good-pairs/solutions/2784238/easy-c-o-n-soln-faang-interview-optimized-code/"
                    },
                    {
                        "username": "ft3793",
                        "content": "i should be in the last of the list and i in the starter of the list\\n"
                    },
                    {
                        "username": "Jsn667",
                        "content": "![image](https://assets.leetcode.com/users/images/e302aec0-570a-463e-8f68-3d87f4b3b4db_1608955337.8360794.png)\\n"
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "https://leetcode.com/problems/number-of-good-pairs/solutions/2784238/easy-c-o-n-soln-faang-interview-optimized-code/"
                    },
                    {
                        "username": "FireFrost",
                        "content": "check every pair with nested loop \\ntime - O(n^2)\\nspace - O(1)\\n\\nfrequency table and sum of n integers formula\\ntime - O(n)\\nspace - O(n)"
                    },
                    {
                        "username": "Nikhil_G002109",
                        "content": "How does the idea of using sum of \\'n\\' integers would come up in my mind??"
                    },
                    {
                        "username": "anshulupadhyay03",
                        "content": "why is my code failing for input : nums =\\n[6,5,1,5,7,7,9,1,5,7,1,6,10,9,7,4,1,8,7,1,1,8,6,4,7,4,10,5,3,9,10,1,9,5,5,4,1,7,4,2,9,2,6,6,4,2,10,3,5,3,6,4,7,4,6,4,4,6,3,4,10,1,10,6,10,4,9,6,6,4,8,6,9,5,4]\\n I am using the method of counting the numbers frequency and then using formula nCr to calculate pairs."
                    },
                    {
                        "username": "fuongdtran",
                        "content": "[@ry-reek](/ry-reek) it\\'s not the reason. Remember C is combinations, not permutations, meaning that (i,j) and (j,i) are accounted as one possibility. In other words, it does not matter if i < j or i > j"
                    },
                    {
                        "username": "fuongdtran",
                        "content": "The approach is right. The problem is that int/long variable does not big enough to hold a factorial calculation. since we know the r = 2, we can simplify the formula"
                    },
                    {
                        "username": "ry-reek",
                        "content": "okay, so one thing that I figured out is that calculating the nCr does not take the i < j into consideration so that\\'s why it\\'s the wrong approach."
                    },
                    {
                        "username": "ry-reek",
                        "content": "I am doing the same thing and my code fails for this exact test case."
                    },
                    {
                        "username": "kya_",
                        "content": "Did you ever figure out why this fails. I did the sam approach \\n"
                    },
                    {
                        "username": "tejaanuchuri",
                        "content": "![image](https://assets.leetcode.com/users/images/bc83ea82-042d-4c66-81c4-1632b63f9d3c_1651656723.4516509.png)\\n\\nHere we finding each number frequency and then based on frequency we get number of pairs;\\n\\nfor example a item has frequency k then (k*(k-1))/2 pairs are generated."
                    },
                    {
                        "username": "Anubhav_Saha",
                        "content": "Hi, can you explain the logic behind the formula k*(k-1)/2 for calculating pair\\n"
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "https://leetcode.com/problems/number-of-good-pairs/solutions/2784238/easy-c-o-n-soln-faang-interview-optimized-code/"
                    },
                    {
                        "username": "laosunhust",
                        "content": "`return int(sum([v(v-1)/2 for , v in Counter(nums).items()]))`"
                    },
                    {
                        "username": "luciferstern",
                        "content": "what if we want sum of all good pairs present in every subarray of a\\n"
                    },
                    {
                        "username": "L33TC0D3R4L1F3",
                        "content": "Wizard math?"
                    },
                    {
                        "username": "jaszy_the_better_twin",
                        "content": "slay"
                    },
                    {
                        "username": "percylam-pt",
                        "content": "**var numIdenticalPairs = function(nums) {\\n&ensp; &ensp; let output = 0;\\n&ensp; &ensp; while (nums.length!=0){\\n&ensp; &ensp; &ensp; &ensp; let target = nums.shift();\\n&ensp; &ensp; &ensp; &ensp; nums.forEach(e=>{e==target?output+=1:output+=0})\\n&ensp; &ensp; };\\n&ensp; &ensp; return output\\n};**"
                    }
                ]
            },
            {
                "id": 1566648,
                "content": [
                    {
                        "username": "user5615M",
                        "content": "I wanna explain this solution for peaple who like detailed mathematical explanations\\n\\nthe solution starts with iterating through all  the list and count the number of occurrences of each number and store it in a dictionary. so far so good!  \\nNext we want to iterate through each dictionary key and calculate the number of pairs.\\nCalculating the number of pairs is all about calculating the combinations of numbers\\n**nCr**  where **n** s the number of occurrences and **r**  is the number of elements we want in one group. Combinations are calculated as follows **nCr = n! / r! * (n-r)!** but remember that we want to count the number of pairs so **r=2** in our case. \\nLet\\'s calculate this \\n**nC2 = n! / 2! * (n-2)** =  **n * (n-1) * (n-2) * (n-3) *....1 /  2 * (n-2) * (n-3) * (n-4)*.....1**\\nso as you notice, there\\'re duplicate terms in the numerator and denomenator. we are gonna eliminate the terms starting from (n-2) to the end from both the numerator and denomenator. so we end up with **n * (n-1) / 2** This is exactly like summing from 1 to n-1. \\nso the final formula is used to calculate the number of pairs in each key of the dictionary \\nif n = 4 number of pairs is 4 * 3 / 2 = 6 pairs which gets the correct solution.\\n"
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "https://leetcode.com/problems/number-of-good-pairs/solutions/2784238/easy-c-o-n-soln-faang-interview-optimized-code/"
                    },
                    {
                        "username": "jjhardey24",
                        "content": "I\\'m not sure if I understand this quesion as it is unclear to me. What exactlty are i and j in the good pairs. Could someone expand further or give more test cases? I would greatly appreciate it."
                    },
                    {
                        "username": "ointissar",
                        "content": "i and j are indexes of good pairs in the given array\\nLet\\'s take an example:\\ngiven array                     [1, 3, 2, 1]\\nindexes                            0 1  2  3\\ngood pairs i and j            i           j\\n\\nSo i and j making the good pair (i, j) => (0, 3), because i < j  => 0 < 3 and array[i] = array[j]\\n\\nHope it\\'s clear enough :) "
                    },
                    {
                        "username": "Lucky_Dev",
                        "content": "indexes "
                    },
                    {
                        "username": "NagarapuNagaVenkataSivaSaiRagh",
                        "content": "i and j are index numbers, if nums[i]==nums[j]  then (i,j) is agood pair.... where(i<j)\\n\\nI hope you understood it\\n"
                    },
                    {
                        "username": "LOGANBLUE",
                        "content": "i and j are the indexes for equal entries like if 3 is present at 0,2,5 indexes so you have to make pair of the indexes like 0,2 & 0,5 & 2,5 so answer is 3(no of pairs of indexes)"
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "https://leetcode.com/problems/number-of-good-pairs/solutions/2784238/easy-c-o-n-soln-faang-interview-optimized-code/"
                    },
                    {
                        "username": "ft3793",
                        "content": "i should be in the last of the list and i in the starter of the list\\n"
                    },
                    {
                        "username": "Jsn667",
                        "content": "![image](https://assets.leetcode.com/users/images/e302aec0-570a-463e-8f68-3d87f4b3b4db_1608955337.8360794.png)\\n"
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "https://leetcode.com/problems/number-of-good-pairs/solutions/2784238/easy-c-o-n-soln-faang-interview-optimized-code/"
                    },
                    {
                        "username": "FireFrost",
                        "content": "check every pair with nested loop \\ntime - O(n^2)\\nspace - O(1)\\n\\nfrequency table and sum of n integers formula\\ntime - O(n)\\nspace - O(n)"
                    },
                    {
                        "username": "Nikhil_G002109",
                        "content": "How does the idea of using sum of \\'n\\' integers would come up in my mind??"
                    },
                    {
                        "username": "anshulupadhyay03",
                        "content": "why is my code failing for input : nums =\\n[6,5,1,5,7,7,9,1,5,7,1,6,10,9,7,4,1,8,7,1,1,8,6,4,7,4,10,5,3,9,10,1,9,5,5,4,1,7,4,2,9,2,6,6,4,2,10,3,5,3,6,4,7,4,6,4,4,6,3,4,10,1,10,6,10,4,9,6,6,4,8,6,9,5,4]\\n I am using the method of counting the numbers frequency and then using formula nCr to calculate pairs."
                    },
                    {
                        "username": "fuongdtran",
                        "content": "[@ry-reek](/ry-reek) it\\'s not the reason. Remember C is combinations, not permutations, meaning that (i,j) and (j,i) are accounted as one possibility. In other words, it does not matter if i < j or i > j"
                    },
                    {
                        "username": "fuongdtran",
                        "content": "The approach is right. The problem is that int/long variable does not big enough to hold a factorial calculation. since we know the r = 2, we can simplify the formula"
                    },
                    {
                        "username": "ry-reek",
                        "content": "okay, so one thing that I figured out is that calculating the nCr does not take the i < j into consideration so that\\'s why it\\'s the wrong approach."
                    },
                    {
                        "username": "ry-reek",
                        "content": "I am doing the same thing and my code fails for this exact test case."
                    },
                    {
                        "username": "kya_",
                        "content": "Did you ever figure out why this fails. I did the sam approach \\n"
                    },
                    {
                        "username": "tejaanuchuri",
                        "content": "![image](https://assets.leetcode.com/users/images/bc83ea82-042d-4c66-81c4-1632b63f9d3c_1651656723.4516509.png)\\n\\nHere we finding each number frequency and then based on frequency we get number of pairs;\\n\\nfor example a item has frequency k then (k*(k-1))/2 pairs are generated."
                    },
                    {
                        "username": "Anubhav_Saha",
                        "content": "Hi, can you explain the logic behind the formula k*(k-1)/2 for calculating pair\\n"
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "https://leetcode.com/problems/number-of-good-pairs/solutions/2784238/easy-c-o-n-soln-faang-interview-optimized-code/"
                    },
                    {
                        "username": "laosunhust",
                        "content": "`return int(sum([v(v-1)/2 for , v in Counter(nums).items()]))`"
                    },
                    {
                        "username": "luciferstern",
                        "content": "what if we want sum of all good pairs present in every subarray of a\\n"
                    },
                    {
                        "username": "L33TC0D3R4L1F3",
                        "content": "Wizard math?"
                    },
                    {
                        "username": "jaszy_the_better_twin",
                        "content": "slay"
                    },
                    {
                        "username": "percylam-pt",
                        "content": "**var numIdenticalPairs = function(nums) {\\n&ensp; &ensp; let output = 0;\\n&ensp; &ensp; while (nums.length!=0){\\n&ensp; &ensp; &ensp; &ensp; let target = nums.shift();\\n&ensp; &ensp; &ensp; &ensp; nums.forEach(e=>{e==target?output+=1:output+=0})\\n&ensp; &ensp; };\\n&ensp; &ensp; return output\\n};**"
                    }
                ]
            },
            {
                "id": 1574190,
                "content": [
                    {
                        "username": "user5615M",
                        "content": "I wanna explain this solution for peaple who like detailed mathematical explanations\\n\\nthe solution starts with iterating through all  the list and count the number of occurrences of each number and store it in a dictionary. so far so good!  \\nNext we want to iterate through each dictionary key and calculate the number of pairs.\\nCalculating the number of pairs is all about calculating the combinations of numbers\\n**nCr**  where **n** s the number of occurrences and **r**  is the number of elements we want in one group. Combinations are calculated as follows **nCr = n! / r! * (n-r)!** but remember that we want to count the number of pairs so **r=2** in our case. \\nLet\\'s calculate this \\n**nC2 = n! / 2! * (n-2)** =  **n * (n-1) * (n-2) * (n-3) *....1 /  2 * (n-2) * (n-3) * (n-4)*.....1**\\nso as you notice, there\\'re duplicate terms in the numerator and denomenator. we are gonna eliminate the terms starting from (n-2) to the end from both the numerator and denomenator. so we end up with **n * (n-1) / 2** This is exactly like summing from 1 to n-1. \\nso the final formula is used to calculate the number of pairs in each key of the dictionary \\nif n = 4 number of pairs is 4 * 3 / 2 = 6 pairs which gets the correct solution.\\n"
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "https://leetcode.com/problems/number-of-good-pairs/solutions/2784238/easy-c-o-n-soln-faang-interview-optimized-code/"
                    },
                    {
                        "username": "jjhardey24",
                        "content": "I\\'m not sure if I understand this quesion as it is unclear to me. What exactlty are i and j in the good pairs. Could someone expand further or give more test cases? I would greatly appreciate it."
                    },
                    {
                        "username": "ointissar",
                        "content": "i and j are indexes of good pairs in the given array\\nLet\\'s take an example:\\ngiven array                     [1, 3, 2, 1]\\nindexes                            0 1  2  3\\ngood pairs i and j            i           j\\n\\nSo i and j making the good pair (i, j) => (0, 3), because i < j  => 0 < 3 and array[i] = array[j]\\n\\nHope it\\'s clear enough :) "
                    },
                    {
                        "username": "Lucky_Dev",
                        "content": "indexes "
                    },
                    {
                        "username": "NagarapuNagaVenkataSivaSaiRagh",
                        "content": "i and j are index numbers, if nums[i]==nums[j]  then (i,j) is agood pair.... where(i<j)\\n\\nI hope you understood it\\n"
                    },
                    {
                        "username": "LOGANBLUE",
                        "content": "i and j are the indexes for equal entries like if 3 is present at 0,2,5 indexes so you have to make pair of the indexes like 0,2 & 0,5 & 2,5 so answer is 3(no of pairs of indexes)"
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "https://leetcode.com/problems/number-of-good-pairs/solutions/2784238/easy-c-o-n-soln-faang-interview-optimized-code/"
                    },
                    {
                        "username": "ft3793",
                        "content": "i should be in the last of the list and i in the starter of the list\\n"
                    },
                    {
                        "username": "Jsn667",
                        "content": "![image](https://assets.leetcode.com/users/images/e302aec0-570a-463e-8f68-3d87f4b3b4db_1608955337.8360794.png)\\n"
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "https://leetcode.com/problems/number-of-good-pairs/solutions/2784238/easy-c-o-n-soln-faang-interview-optimized-code/"
                    },
                    {
                        "username": "FireFrost",
                        "content": "check every pair with nested loop \\ntime - O(n^2)\\nspace - O(1)\\n\\nfrequency table and sum of n integers formula\\ntime - O(n)\\nspace - O(n)"
                    },
                    {
                        "username": "Nikhil_G002109",
                        "content": "How does the idea of using sum of \\'n\\' integers would come up in my mind??"
                    },
                    {
                        "username": "anshulupadhyay03",
                        "content": "why is my code failing for input : nums =\\n[6,5,1,5,7,7,9,1,5,7,1,6,10,9,7,4,1,8,7,1,1,8,6,4,7,4,10,5,3,9,10,1,9,5,5,4,1,7,4,2,9,2,6,6,4,2,10,3,5,3,6,4,7,4,6,4,4,6,3,4,10,1,10,6,10,4,9,6,6,4,8,6,9,5,4]\\n I am using the method of counting the numbers frequency and then using formula nCr to calculate pairs."
                    },
                    {
                        "username": "fuongdtran",
                        "content": "[@ry-reek](/ry-reek) it\\'s not the reason. Remember C is combinations, not permutations, meaning that (i,j) and (j,i) are accounted as one possibility. In other words, it does not matter if i < j or i > j"
                    },
                    {
                        "username": "fuongdtran",
                        "content": "The approach is right. The problem is that int/long variable does not big enough to hold a factorial calculation. since we know the r = 2, we can simplify the formula"
                    },
                    {
                        "username": "ry-reek",
                        "content": "okay, so one thing that I figured out is that calculating the nCr does not take the i < j into consideration so that\\'s why it\\'s the wrong approach."
                    },
                    {
                        "username": "ry-reek",
                        "content": "I am doing the same thing and my code fails for this exact test case."
                    },
                    {
                        "username": "kya_",
                        "content": "Did you ever figure out why this fails. I did the sam approach \\n"
                    },
                    {
                        "username": "tejaanuchuri",
                        "content": "![image](https://assets.leetcode.com/users/images/bc83ea82-042d-4c66-81c4-1632b63f9d3c_1651656723.4516509.png)\\n\\nHere we finding each number frequency and then based on frequency we get number of pairs;\\n\\nfor example a item has frequency k then (k*(k-1))/2 pairs are generated."
                    },
                    {
                        "username": "Anubhav_Saha",
                        "content": "Hi, can you explain the logic behind the formula k*(k-1)/2 for calculating pair\\n"
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "https://leetcode.com/problems/number-of-good-pairs/solutions/2784238/easy-c-o-n-soln-faang-interview-optimized-code/"
                    },
                    {
                        "username": "laosunhust",
                        "content": "`return int(sum([v(v-1)/2 for , v in Counter(nums).items()]))`"
                    },
                    {
                        "username": "luciferstern",
                        "content": "what if we want sum of all good pairs present in every subarray of a\\n"
                    },
                    {
                        "username": "L33TC0D3R4L1F3",
                        "content": "Wizard math?"
                    },
                    {
                        "username": "jaszy_the_better_twin",
                        "content": "slay"
                    },
                    {
                        "username": "percylam-pt",
                        "content": "**var numIdenticalPairs = function(nums) {\\n&ensp; &ensp; let output = 0;\\n&ensp; &ensp; while (nums.length!=0){\\n&ensp; &ensp; &ensp; &ensp; let target = nums.shift();\\n&ensp; &ensp; &ensp; &ensp; nums.forEach(e=>{e==target?output+=1:output+=0})\\n&ensp; &ensp; };\\n&ensp; &ensp; return output\\n};**"
                    }
                ]
            },
            {
                "id": 1725781,
                "content": [
                    {
                        "username": "user5615M",
                        "content": "I wanna explain this solution for peaple who like detailed mathematical explanations\\n\\nthe solution starts with iterating through all  the list and count the number of occurrences of each number and store it in a dictionary. so far so good!  \\nNext we want to iterate through each dictionary key and calculate the number of pairs.\\nCalculating the number of pairs is all about calculating the combinations of numbers\\n**nCr**  where **n** s the number of occurrences and **r**  is the number of elements we want in one group. Combinations are calculated as follows **nCr = n! / r! * (n-r)!** but remember that we want to count the number of pairs so **r=2** in our case. \\nLet\\'s calculate this \\n**nC2 = n! / 2! * (n-2)** =  **n * (n-1) * (n-2) * (n-3) *....1 /  2 * (n-2) * (n-3) * (n-4)*.....1**\\nso as you notice, there\\'re duplicate terms in the numerator and denomenator. we are gonna eliminate the terms starting from (n-2) to the end from both the numerator and denomenator. so we end up with **n * (n-1) / 2** This is exactly like summing from 1 to n-1. \\nso the final formula is used to calculate the number of pairs in each key of the dictionary \\nif n = 4 number of pairs is 4 * 3 / 2 = 6 pairs which gets the correct solution.\\n"
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "https://leetcode.com/problems/number-of-good-pairs/solutions/2784238/easy-c-o-n-soln-faang-interview-optimized-code/"
                    },
                    {
                        "username": "jjhardey24",
                        "content": "I\\'m not sure if I understand this quesion as it is unclear to me. What exactlty are i and j in the good pairs. Could someone expand further or give more test cases? I would greatly appreciate it."
                    },
                    {
                        "username": "ointissar",
                        "content": "i and j are indexes of good pairs in the given array\\nLet\\'s take an example:\\ngiven array                     [1, 3, 2, 1]\\nindexes                            0 1  2  3\\ngood pairs i and j            i           j\\n\\nSo i and j making the good pair (i, j) => (0, 3), because i < j  => 0 < 3 and array[i] = array[j]\\n\\nHope it\\'s clear enough :) "
                    },
                    {
                        "username": "Lucky_Dev",
                        "content": "indexes "
                    },
                    {
                        "username": "NagarapuNagaVenkataSivaSaiRagh",
                        "content": "i and j are index numbers, if nums[i]==nums[j]  then (i,j) is agood pair.... where(i<j)\\n\\nI hope you understood it\\n"
                    },
                    {
                        "username": "LOGANBLUE",
                        "content": "i and j are the indexes for equal entries like if 3 is present at 0,2,5 indexes so you have to make pair of the indexes like 0,2 & 0,5 & 2,5 so answer is 3(no of pairs of indexes)"
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "https://leetcode.com/problems/number-of-good-pairs/solutions/2784238/easy-c-o-n-soln-faang-interview-optimized-code/"
                    },
                    {
                        "username": "ft3793",
                        "content": "i should be in the last of the list and i in the starter of the list\\n"
                    },
                    {
                        "username": "Jsn667",
                        "content": "![image](https://assets.leetcode.com/users/images/e302aec0-570a-463e-8f68-3d87f4b3b4db_1608955337.8360794.png)\\n"
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "https://leetcode.com/problems/number-of-good-pairs/solutions/2784238/easy-c-o-n-soln-faang-interview-optimized-code/"
                    },
                    {
                        "username": "FireFrost",
                        "content": "check every pair with nested loop \\ntime - O(n^2)\\nspace - O(1)\\n\\nfrequency table and sum of n integers formula\\ntime - O(n)\\nspace - O(n)"
                    },
                    {
                        "username": "Nikhil_G002109",
                        "content": "How does the idea of using sum of \\'n\\' integers would come up in my mind??"
                    },
                    {
                        "username": "anshulupadhyay03",
                        "content": "why is my code failing for input : nums =\\n[6,5,1,5,7,7,9,1,5,7,1,6,10,9,7,4,1,8,7,1,1,8,6,4,7,4,10,5,3,9,10,1,9,5,5,4,1,7,4,2,9,2,6,6,4,2,10,3,5,3,6,4,7,4,6,4,4,6,3,4,10,1,10,6,10,4,9,6,6,4,8,6,9,5,4]\\n I am using the method of counting the numbers frequency and then using formula nCr to calculate pairs."
                    },
                    {
                        "username": "fuongdtran",
                        "content": "[@ry-reek](/ry-reek) it\\'s not the reason. Remember C is combinations, not permutations, meaning that (i,j) and (j,i) are accounted as one possibility. In other words, it does not matter if i < j or i > j"
                    },
                    {
                        "username": "fuongdtran",
                        "content": "The approach is right. The problem is that int/long variable does not big enough to hold a factorial calculation. since we know the r = 2, we can simplify the formula"
                    },
                    {
                        "username": "ry-reek",
                        "content": "okay, so one thing that I figured out is that calculating the nCr does not take the i < j into consideration so that\\'s why it\\'s the wrong approach."
                    },
                    {
                        "username": "ry-reek",
                        "content": "I am doing the same thing and my code fails for this exact test case."
                    },
                    {
                        "username": "kya_",
                        "content": "Did you ever figure out why this fails. I did the sam approach \\n"
                    },
                    {
                        "username": "tejaanuchuri",
                        "content": "![image](https://assets.leetcode.com/users/images/bc83ea82-042d-4c66-81c4-1632b63f9d3c_1651656723.4516509.png)\\n\\nHere we finding each number frequency and then based on frequency we get number of pairs;\\n\\nfor example a item has frequency k then (k*(k-1))/2 pairs are generated."
                    },
                    {
                        "username": "Anubhav_Saha",
                        "content": "Hi, can you explain the logic behind the formula k*(k-1)/2 for calculating pair\\n"
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "https://leetcode.com/problems/number-of-good-pairs/solutions/2784238/easy-c-o-n-soln-faang-interview-optimized-code/"
                    },
                    {
                        "username": "laosunhust",
                        "content": "`return int(sum([v(v-1)/2 for , v in Counter(nums).items()]))`"
                    },
                    {
                        "username": "luciferstern",
                        "content": "what if we want sum of all good pairs present in every subarray of a\\n"
                    },
                    {
                        "username": "L33TC0D3R4L1F3",
                        "content": "Wizard math?"
                    },
                    {
                        "username": "jaszy_the_better_twin",
                        "content": "slay"
                    },
                    {
                        "username": "percylam-pt",
                        "content": "**var numIdenticalPairs = function(nums) {\\n&ensp; &ensp; let output = 0;\\n&ensp; &ensp; while (nums.length!=0){\\n&ensp; &ensp; &ensp; &ensp; let target = nums.shift();\\n&ensp; &ensp; &ensp; &ensp; nums.forEach(e=>{e==target?output+=1:output+=0})\\n&ensp; &ensp; };\\n&ensp; &ensp; return output\\n};**"
                    }
                ]
            },
            {
                "id": 1576708,
                "content": [
                    {
                        "username": "user5615M",
                        "content": "I wanna explain this solution for peaple who like detailed mathematical explanations\\n\\nthe solution starts with iterating through all  the list and count the number of occurrences of each number and store it in a dictionary. so far so good!  \\nNext we want to iterate through each dictionary key and calculate the number of pairs.\\nCalculating the number of pairs is all about calculating the combinations of numbers\\n**nCr**  where **n** s the number of occurrences and **r**  is the number of elements we want in one group. Combinations are calculated as follows **nCr = n! / r! * (n-r)!** but remember that we want to count the number of pairs so **r=2** in our case. \\nLet\\'s calculate this \\n**nC2 = n! / 2! * (n-2)** =  **n * (n-1) * (n-2) * (n-3) *....1 /  2 * (n-2) * (n-3) * (n-4)*.....1**\\nso as you notice, there\\'re duplicate terms in the numerator and denomenator. we are gonna eliminate the terms starting from (n-2) to the end from both the numerator and denomenator. so we end up with **n * (n-1) / 2** This is exactly like summing from 1 to n-1. \\nso the final formula is used to calculate the number of pairs in each key of the dictionary \\nif n = 4 number of pairs is 4 * 3 / 2 = 6 pairs which gets the correct solution.\\n"
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "https://leetcode.com/problems/number-of-good-pairs/solutions/2784238/easy-c-o-n-soln-faang-interview-optimized-code/"
                    },
                    {
                        "username": "jjhardey24",
                        "content": "I\\'m not sure if I understand this quesion as it is unclear to me. What exactlty are i and j in the good pairs. Could someone expand further or give more test cases? I would greatly appreciate it."
                    },
                    {
                        "username": "ointissar",
                        "content": "i and j are indexes of good pairs in the given array\\nLet\\'s take an example:\\ngiven array                     [1, 3, 2, 1]\\nindexes                            0 1  2  3\\ngood pairs i and j            i           j\\n\\nSo i and j making the good pair (i, j) => (0, 3), because i < j  => 0 < 3 and array[i] = array[j]\\n\\nHope it\\'s clear enough :) "
                    },
                    {
                        "username": "Lucky_Dev",
                        "content": "indexes "
                    },
                    {
                        "username": "NagarapuNagaVenkataSivaSaiRagh",
                        "content": "i and j are index numbers, if nums[i]==nums[j]  then (i,j) is agood pair.... where(i<j)\\n\\nI hope you understood it\\n"
                    },
                    {
                        "username": "LOGANBLUE",
                        "content": "i and j are the indexes for equal entries like if 3 is present at 0,2,5 indexes so you have to make pair of the indexes like 0,2 & 0,5 & 2,5 so answer is 3(no of pairs of indexes)"
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "https://leetcode.com/problems/number-of-good-pairs/solutions/2784238/easy-c-o-n-soln-faang-interview-optimized-code/"
                    },
                    {
                        "username": "ft3793",
                        "content": "i should be in the last of the list and i in the starter of the list\\n"
                    },
                    {
                        "username": "Jsn667",
                        "content": "![image](https://assets.leetcode.com/users/images/e302aec0-570a-463e-8f68-3d87f4b3b4db_1608955337.8360794.png)\\n"
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "https://leetcode.com/problems/number-of-good-pairs/solutions/2784238/easy-c-o-n-soln-faang-interview-optimized-code/"
                    },
                    {
                        "username": "FireFrost",
                        "content": "check every pair with nested loop \\ntime - O(n^2)\\nspace - O(1)\\n\\nfrequency table and sum of n integers formula\\ntime - O(n)\\nspace - O(n)"
                    },
                    {
                        "username": "Nikhil_G002109",
                        "content": "How does the idea of using sum of \\'n\\' integers would come up in my mind??"
                    },
                    {
                        "username": "anshulupadhyay03",
                        "content": "why is my code failing for input : nums =\\n[6,5,1,5,7,7,9,1,5,7,1,6,10,9,7,4,1,8,7,1,1,8,6,4,7,4,10,5,3,9,10,1,9,5,5,4,1,7,4,2,9,2,6,6,4,2,10,3,5,3,6,4,7,4,6,4,4,6,3,4,10,1,10,6,10,4,9,6,6,4,8,6,9,5,4]\\n I am using the method of counting the numbers frequency and then using formula nCr to calculate pairs."
                    },
                    {
                        "username": "fuongdtran",
                        "content": "[@ry-reek](/ry-reek) it\\'s not the reason. Remember C is combinations, not permutations, meaning that (i,j) and (j,i) are accounted as one possibility. In other words, it does not matter if i < j or i > j"
                    },
                    {
                        "username": "fuongdtran",
                        "content": "The approach is right. The problem is that int/long variable does not big enough to hold a factorial calculation. since we know the r = 2, we can simplify the formula"
                    },
                    {
                        "username": "ry-reek",
                        "content": "okay, so one thing that I figured out is that calculating the nCr does not take the i < j into consideration so that\\'s why it\\'s the wrong approach."
                    },
                    {
                        "username": "ry-reek",
                        "content": "I am doing the same thing and my code fails for this exact test case."
                    },
                    {
                        "username": "kya_",
                        "content": "Did you ever figure out why this fails. I did the sam approach \\n"
                    },
                    {
                        "username": "tejaanuchuri",
                        "content": "![image](https://assets.leetcode.com/users/images/bc83ea82-042d-4c66-81c4-1632b63f9d3c_1651656723.4516509.png)\\n\\nHere we finding each number frequency and then based on frequency we get number of pairs;\\n\\nfor example a item has frequency k then (k*(k-1))/2 pairs are generated."
                    },
                    {
                        "username": "Anubhav_Saha",
                        "content": "Hi, can you explain the logic behind the formula k*(k-1)/2 for calculating pair\\n"
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "https://leetcode.com/problems/number-of-good-pairs/solutions/2784238/easy-c-o-n-soln-faang-interview-optimized-code/"
                    },
                    {
                        "username": "laosunhust",
                        "content": "`return int(sum([v(v-1)/2 for , v in Counter(nums).items()]))`"
                    },
                    {
                        "username": "luciferstern",
                        "content": "what if we want sum of all good pairs present in every subarray of a\\n"
                    },
                    {
                        "username": "L33TC0D3R4L1F3",
                        "content": "Wizard math?"
                    },
                    {
                        "username": "jaszy_the_better_twin",
                        "content": "slay"
                    },
                    {
                        "username": "percylam-pt",
                        "content": "**var numIdenticalPairs = function(nums) {\\n&ensp; &ensp; let output = 0;\\n&ensp; &ensp; while (nums.length!=0){\\n&ensp; &ensp; &ensp; &ensp; let target = nums.shift();\\n&ensp; &ensp; &ensp; &ensp; nums.forEach(e=>{e==target?output+=1:output+=0})\\n&ensp; &ensp; };\\n&ensp; &ensp; return output\\n};**"
                    }
                ]
            },
            {
                "id": 1575197,
                "content": [
                    {
                        "username": "user5615M",
                        "content": "I wanna explain this solution for peaple who like detailed mathematical explanations\\n\\nthe solution starts with iterating through all  the list and count the number of occurrences of each number and store it in a dictionary. so far so good!  \\nNext we want to iterate through each dictionary key and calculate the number of pairs.\\nCalculating the number of pairs is all about calculating the combinations of numbers\\n**nCr**  where **n** s the number of occurrences and **r**  is the number of elements we want in one group. Combinations are calculated as follows **nCr = n! / r! * (n-r)!** but remember that we want to count the number of pairs so **r=2** in our case. \\nLet\\'s calculate this \\n**nC2 = n! / 2! * (n-2)** =  **n * (n-1) * (n-2) * (n-3) *....1 /  2 * (n-2) * (n-3) * (n-4)*.....1**\\nso as you notice, there\\'re duplicate terms in the numerator and denomenator. we are gonna eliminate the terms starting from (n-2) to the end from both the numerator and denomenator. so we end up with **n * (n-1) / 2** This is exactly like summing from 1 to n-1. \\nso the final formula is used to calculate the number of pairs in each key of the dictionary \\nif n = 4 number of pairs is 4 * 3 / 2 = 6 pairs which gets the correct solution.\\n"
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "https://leetcode.com/problems/number-of-good-pairs/solutions/2784238/easy-c-o-n-soln-faang-interview-optimized-code/"
                    },
                    {
                        "username": "jjhardey24",
                        "content": "I\\'m not sure if I understand this quesion as it is unclear to me. What exactlty are i and j in the good pairs. Could someone expand further or give more test cases? I would greatly appreciate it."
                    },
                    {
                        "username": "ointissar",
                        "content": "i and j are indexes of good pairs in the given array\\nLet\\'s take an example:\\ngiven array                     [1, 3, 2, 1]\\nindexes                            0 1  2  3\\ngood pairs i and j            i           j\\n\\nSo i and j making the good pair (i, j) => (0, 3), because i < j  => 0 < 3 and array[i] = array[j]\\n\\nHope it\\'s clear enough :) "
                    },
                    {
                        "username": "Lucky_Dev",
                        "content": "indexes "
                    },
                    {
                        "username": "NagarapuNagaVenkataSivaSaiRagh",
                        "content": "i and j are index numbers, if nums[i]==nums[j]  then (i,j) is agood pair.... where(i<j)\\n\\nI hope you understood it\\n"
                    },
                    {
                        "username": "LOGANBLUE",
                        "content": "i and j are the indexes for equal entries like if 3 is present at 0,2,5 indexes so you have to make pair of the indexes like 0,2 & 0,5 & 2,5 so answer is 3(no of pairs of indexes)"
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "https://leetcode.com/problems/number-of-good-pairs/solutions/2784238/easy-c-o-n-soln-faang-interview-optimized-code/"
                    },
                    {
                        "username": "ft3793",
                        "content": "i should be in the last of the list and i in the starter of the list\\n"
                    },
                    {
                        "username": "Jsn667",
                        "content": "![image](https://assets.leetcode.com/users/images/e302aec0-570a-463e-8f68-3d87f4b3b4db_1608955337.8360794.png)\\n"
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "https://leetcode.com/problems/number-of-good-pairs/solutions/2784238/easy-c-o-n-soln-faang-interview-optimized-code/"
                    },
                    {
                        "username": "FireFrost",
                        "content": "check every pair with nested loop \\ntime - O(n^2)\\nspace - O(1)\\n\\nfrequency table and sum of n integers formula\\ntime - O(n)\\nspace - O(n)"
                    },
                    {
                        "username": "Nikhil_G002109",
                        "content": "How does the idea of using sum of \\'n\\' integers would come up in my mind??"
                    },
                    {
                        "username": "anshulupadhyay03",
                        "content": "why is my code failing for input : nums =\\n[6,5,1,5,7,7,9,1,5,7,1,6,10,9,7,4,1,8,7,1,1,8,6,4,7,4,10,5,3,9,10,1,9,5,5,4,1,7,4,2,9,2,6,6,4,2,10,3,5,3,6,4,7,4,6,4,4,6,3,4,10,1,10,6,10,4,9,6,6,4,8,6,9,5,4]\\n I am using the method of counting the numbers frequency and then using formula nCr to calculate pairs."
                    },
                    {
                        "username": "fuongdtran",
                        "content": "[@ry-reek](/ry-reek) it\\'s not the reason. Remember C is combinations, not permutations, meaning that (i,j) and (j,i) are accounted as one possibility. In other words, it does not matter if i < j or i > j"
                    },
                    {
                        "username": "fuongdtran",
                        "content": "The approach is right. The problem is that int/long variable does not big enough to hold a factorial calculation. since we know the r = 2, we can simplify the formula"
                    },
                    {
                        "username": "ry-reek",
                        "content": "okay, so one thing that I figured out is that calculating the nCr does not take the i < j into consideration so that\\'s why it\\'s the wrong approach."
                    },
                    {
                        "username": "ry-reek",
                        "content": "I am doing the same thing and my code fails for this exact test case."
                    },
                    {
                        "username": "kya_",
                        "content": "Did you ever figure out why this fails. I did the sam approach \\n"
                    },
                    {
                        "username": "tejaanuchuri",
                        "content": "![image](https://assets.leetcode.com/users/images/bc83ea82-042d-4c66-81c4-1632b63f9d3c_1651656723.4516509.png)\\n\\nHere we finding each number frequency and then based on frequency we get number of pairs;\\n\\nfor example a item has frequency k then (k*(k-1))/2 pairs are generated."
                    },
                    {
                        "username": "Anubhav_Saha",
                        "content": "Hi, can you explain the logic behind the formula k*(k-1)/2 for calculating pair\\n"
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "https://leetcode.com/problems/number-of-good-pairs/solutions/2784238/easy-c-o-n-soln-faang-interview-optimized-code/"
                    },
                    {
                        "username": "laosunhust",
                        "content": "`return int(sum([v(v-1)/2 for , v in Counter(nums).items()]))`"
                    },
                    {
                        "username": "luciferstern",
                        "content": "what if we want sum of all good pairs present in every subarray of a\\n"
                    },
                    {
                        "username": "L33TC0D3R4L1F3",
                        "content": "Wizard math?"
                    },
                    {
                        "username": "jaszy_the_better_twin",
                        "content": "slay"
                    },
                    {
                        "username": "percylam-pt",
                        "content": "**var numIdenticalPairs = function(nums) {\\n&ensp; &ensp; let output = 0;\\n&ensp; &ensp; while (nums.length!=0){\\n&ensp; &ensp; &ensp; &ensp; let target = nums.shift();\\n&ensp; &ensp; &ensp; &ensp; nums.forEach(e=>{e==target?output+=1:output+=0})\\n&ensp; &ensp; };\\n&ensp; &ensp; return output\\n};**"
                    }
                ]
            },
            {
                "id": 1575646,
                "content": [
                    {
                        "username": "user5615M",
                        "content": "I wanna explain this solution for peaple who like detailed mathematical explanations\\n\\nthe solution starts with iterating through all  the list and count the number of occurrences of each number and store it in a dictionary. so far so good!  \\nNext we want to iterate through each dictionary key and calculate the number of pairs.\\nCalculating the number of pairs is all about calculating the combinations of numbers\\n**nCr**  where **n** s the number of occurrences and **r**  is the number of elements we want in one group. Combinations are calculated as follows **nCr = n! / r! * (n-r)!** but remember that we want to count the number of pairs so **r=2** in our case. \\nLet\\'s calculate this \\n**nC2 = n! / 2! * (n-2)** =  **n * (n-1) * (n-2) * (n-3) *....1 /  2 * (n-2) * (n-3) * (n-4)*.....1**\\nso as you notice, there\\'re duplicate terms in the numerator and denomenator. we are gonna eliminate the terms starting from (n-2) to the end from both the numerator and denomenator. so we end up with **n * (n-1) / 2** This is exactly like summing from 1 to n-1. \\nso the final formula is used to calculate the number of pairs in each key of the dictionary \\nif n = 4 number of pairs is 4 * 3 / 2 = 6 pairs which gets the correct solution.\\n"
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "https://leetcode.com/problems/number-of-good-pairs/solutions/2784238/easy-c-o-n-soln-faang-interview-optimized-code/"
                    },
                    {
                        "username": "jjhardey24",
                        "content": "I\\'m not sure if I understand this quesion as it is unclear to me. What exactlty are i and j in the good pairs. Could someone expand further or give more test cases? I would greatly appreciate it."
                    },
                    {
                        "username": "ointissar",
                        "content": "i and j are indexes of good pairs in the given array\\nLet\\'s take an example:\\ngiven array                     [1, 3, 2, 1]\\nindexes                            0 1  2  3\\ngood pairs i and j            i           j\\n\\nSo i and j making the good pair (i, j) => (0, 3), because i < j  => 0 < 3 and array[i] = array[j]\\n\\nHope it\\'s clear enough :) "
                    },
                    {
                        "username": "Lucky_Dev",
                        "content": "indexes "
                    },
                    {
                        "username": "NagarapuNagaVenkataSivaSaiRagh",
                        "content": "i and j are index numbers, if nums[i]==nums[j]  then (i,j) is agood pair.... where(i<j)\\n\\nI hope you understood it\\n"
                    },
                    {
                        "username": "LOGANBLUE",
                        "content": "i and j are the indexes for equal entries like if 3 is present at 0,2,5 indexes so you have to make pair of the indexes like 0,2 & 0,5 & 2,5 so answer is 3(no of pairs of indexes)"
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "https://leetcode.com/problems/number-of-good-pairs/solutions/2784238/easy-c-o-n-soln-faang-interview-optimized-code/"
                    },
                    {
                        "username": "ft3793",
                        "content": "i should be in the last of the list and i in the starter of the list\\n"
                    },
                    {
                        "username": "Jsn667",
                        "content": "![image](https://assets.leetcode.com/users/images/e302aec0-570a-463e-8f68-3d87f4b3b4db_1608955337.8360794.png)\\n"
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "https://leetcode.com/problems/number-of-good-pairs/solutions/2784238/easy-c-o-n-soln-faang-interview-optimized-code/"
                    },
                    {
                        "username": "FireFrost",
                        "content": "check every pair with nested loop \\ntime - O(n^2)\\nspace - O(1)\\n\\nfrequency table and sum of n integers formula\\ntime - O(n)\\nspace - O(n)"
                    },
                    {
                        "username": "Nikhil_G002109",
                        "content": "How does the idea of using sum of \\'n\\' integers would come up in my mind??"
                    },
                    {
                        "username": "anshulupadhyay03",
                        "content": "why is my code failing for input : nums =\\n[6,5,1,5,7,7,9,1,5,7,1,6,10,9,7,4,1,8,7,1,1,8,6,4,7,4,10,5,3,9,10,1,9,5,5,4,1,7,4,2,9,2,6,6,4,2,10,3,5,3,6,4,7,4,6,4,4,6,3,4,10,1,10,6,10,4,9,6,6,4,8,6,9,5,4]\\n I am using the method of counting the numbers frequency and then using formula nCr to calculate pairs."
                    },
                    {
                        "username": "fuongdtran",
                        "content": "[@ry-reek](/ry-reek) it\\'s not the reason. Remember C is combinations, not permutations, meaning that (i,j) and (j,i) are accounted as one possibility. In other words, it does not matter if i < j or i > j"
                    },
                    {
                        "username": "fuongdtran",
                        "content": "The approach is right. The problem is that int/long variable does not big enough to hold a factorial calculation. since we know the r = 2, we can simplify the formula"
                    },
                    {
                        "username": "ry-reek",
                        "content": "okay, so one thing that I figured out is that calculating the nCr does not take the i < j into consideration so that\\'s why it\\'s the wrong approach."
                    },
                    {
                        "username": "ry-reek",
                        "content": "I am doing the same thing and my code fails for this exact test case."
                    },
                    {
                        "username": "kya_",
                        "content": "Did you ever figure out why this fails. I did the sam approach \\n"
                    },
                    {
                        "username": "tejaanuchuri",
                        "content": "![image](https://assets.leetcode.com/users/images/bc83ea82-042d-4c66-81c4-1632b63f9d3c_1651656723.4516509.png)\\n\\nHere we finding each number frequency and then based on frequency we get number of pairs;\\n\\nfor example a item has frequency k then (k*(k-1))/2 pairs are generated."
                    },
                    {
                        "username": "Anubhav_Saha",
                        "content": "Hi, can you explain the logic behind the formula k*(k-1)/2 for calculating pair\\n"
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "https://leetcode.com/problems/number-of-good-pairs/solutions/2784238/easy-c-o-n-soln-faang-interview-optimized-code/"
                    },
                    {
                        "username": "laosunhust",
                        "content": "`return int(sum([v(v-1)/2 for , v in Counter(nums).items()]))`"
                    },
                    {
                        "username": "luciferstern",
                        "content": "what if we want sum of all good pairs present in every subarray of a\\n"
                    },
                    {
                        "username": "L33TC0D3R4L1F3",
                        "content": "Wizard math?"
                    },
                    {
                        "username": "jaszy_the_better_twin",
                        "content": "slay"
                    },
                    {
                        "username": "percylam-pt",
                        "content": "**var numIdenticalPairs = function(nums) {\\n&ensp; &ensp; let output = 0;\\n&ensp; &ensp; while (nums.length!=0){\\n&ensp; &ensp; &ensp; &ensp; let target = nums.shift();\\n&ensp; &ensp; &ensp; &ensp; nums.forEach(e=>{e==target?output+=1:output+=0})\\n&ensp; &ensp; };\\n&ensp; &ensp; return output\\n};**"
                    }
                ]
            },
            {
                "id": 1574126,
                "content": [
                    {
                        "username": "user5615M",
                        "content": "I wanna explain this solution for peaple who like detailed mathematical explanations\\n\\nthe solution starts with iterating through all  the list and count the number of occurrences of each number and store it in a dictionary. so far so good!  \\nNext we want to iterate through each dictionary key and calculate the number of pairs.\\nCalculating the number of pairs is all about calculating the combinations of numbers\\n**nCr**  where **n** s the number of occurrences and **r**  is the number of elements we want in one group. Combinations are calculated as follows **nCr = n! / r! * (n-r)!** but remember that we want to count the number of pairs so **r=2** in our case. \\nLet\\'s calculate this \\n**nC2 = n! / 2! * (n-2)** =  **n * (n-1) * (n-2) * (n-3) *....1 /  2 * (n-2) * (n-3) * (n-4)*.....1**\\nso as you notice, there\\'re duplicate terms in the numerator and denomenator. we are gonna eliminate the terms starting from (n-2) to the end from both the numerator and denomenator. so we end up with **n * (n-1) / 2** This is exactly like summing from 1 to n-1. \\nso the final formula is used to calculate the number of pairs in each key of the dictionary \\nif n = 4 number of pairs is 4 * 3 / 2 = 6 pairs which gets the correct solution.\\n"
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "https://leetcode.com/problems/number-of-good-pairs/solutions/2784238/easy-c-o-n-soln-faang-interview-optimized-code/"
                    },
                    {
                        "username": "jjhardey24",
                        "content": "I\\'m not sure if I understand this quesion as it is unclear to me. What exactlty are i and j in the good pairs. Could someone expand further or give more test cases? I would greatly appreciate it."
                    },
                    {
                        "username": "ointissar",
                        "content": "i and j are indexes of good pairs in the given array\\nLet\\'s take an example:\\ngiven array                     [1, 3, 2, 1]\\nindexes                            0 1  2  3\\ngood pairs i and j            i           j\\n\\nSo i and j making the good pair (i, j) => (0, 3), because i < j  => 0 < 3 and array[i] = array[j]\\n\\nHope it\\'s clear enough :) "
                    },
                    {
                        "username": "Lucky_Dev",
                        "content": "indexes "
                    },
                    {
                        "username": "NagarapuNagaVenkataSivaSaiRagh",
                        "content": "i and j are index numbers, if nums[i]==nums[j]  then (i,j) is agood pair.... where(i<j)\\n\\nI hope you understood it\\n"
                    },
                    {
                        "username": "LOGANBLUE",
                        "content": "i and j are the indexes for equal entries like if 3 is present at 0,2,5 indexes so you have to make pair of the indexes like 0,2 & 0,5 & 2,5 so answer is 3(no of pairs of indexes)"
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "https://leetcode.com/problems/number-of-good-pairs/solutions/2784238/easy-c-o-n-soln-faang-interview-optimized-code/"
                    },
                    {
                        "username": "ft3793",
                        "content": "i should be in the last of the list and i in the starter of the list\\n"
                    },
                    {
                        "username": "Jsn667",
                        "content": "![image](https://assets.leetcode.com/users/images/e302aec0-570a-463e-8f68-3d87f4b3b4db_1608955337.8360794.png)\\n"
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "https://leetcode.com/problems/number-of-good-pairs/solutions/2784238/easy-c-o-n-soln-faang-interview-optimized-code/"
                    },
                    {
                        "username": "FireFrost",
                        "content": "check every pair with nested loop \\ntime - O(n^2)\\nspace - O(1)\\n\\nfrequency table and sum of n integers formula\\ntime - O(n)\\nspace - O(n)"
                    },
                    {
                        "username": "Nikhil_G002109",
                        "content": "How does the idea of using sum of \\'n\\' integers would come up in my mind??"
                    },
                    {
                        "username": "anshulupadhyay03",
                        "content": "why is my code failing for input : nums =\\n[6,5,1,5,7,7,9,1,5,7,1,6,10,9,7,4,1,8,7,1,1,8,6,4,7,4,10,5,3,9,10,1,9,5,5,4,1,7,4,2,9,2,6,6,4,2,10,3,5,3,6,4,7,4,6,4,4,6,3,4,10,1,10,6,10,4,9,6,6,4,8,6,9,5,4]\\n I am using the method of counting the numbers frequency and then using formula nCr to calculate pairs."
                    },
                    {
                        "username": "fuongdtran",
                        "content": "[@ry-reek](/ry-reek) it\\'s not the reason. Remember C is combinations, not permutations, meaning that (i,j) and (j,i) are accounted as one possibility. In other words, it does not matter if i < j or i > j"
                    },
                    {
                        "username": "fuongdtran",
                        "content": "The approach is right. The problem is that int/long variable does not big enough to hold a factorial calculation. since we know the r = 2, we can simplify the formula"
                    },
                    {
                        "username": "ry-reek",
                        "content": "okay, so one thing that I figured out is that calculating the nCr does not take the i < j into consideration so that\\'s why it\\'s the wrong approach."
                    },
                    {
                        "username": "ry-reek",
                        "content": "I am doing the same thing and my code fails for this exact test case."
                    },
                    {
                        "username": "kya_",
                        "content": "Did you ever figure out why this fails. I did the sam approach \\n"
                    },
                    {
                        "username": "tejaanuchuri",
                        "content": "![image](https://assets.leetcode.com/users/images/bc83ea82-042d-4c66-81c4-1632b63f9d3c_1651656723.4516509.png)\\n\\nHere we finding each number frequency and then based on frequency we get number of pairs;\\n\\nfor example a item has frequency k then (k*(k-1))/2 pairs are generated."
                    },
                    {
                        "username": "Anubhav_Saha",
                        "content": "Hi, can you explain the logic behind the formula k*(k-1)/2 for calculating pair\\n"
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "https://leetcode.com/problems/number-of-good-pairs/solutions/2784238/easy-c-o-n-soln-faang-interview-optimized-code/"
                    },
                    {
                        "username": "laosunhust",
                        "content": "`return int(sum([v(v-1)/2 for , v in Counter(nums).items()]))`"
                    },
                    {
                        "username": "luciferstern",
                        "content": "what if we want sum of all good pairs present in every subarray of a\\n"
                    },
                    {
                        "username": "L33TC0D3R4L1F3",
                        "content": "Wizard math?"
                    },
                    {
                        "username": "jaszy_the_better_twin",
                        "content": "slay"
                    },
                    {
                        "username": "percylam-pt",
                        "content": "**var numIdenticalPairs = function(nums) {\\n&ensp; &ensp; let output = 0;\\n&ensp; &ensp; while (nums.length!=0){\\n&ensp; &ensp; &ensp; &ensp; let target = nums.shift();\\n&ensp; &ensp; &ensp; &ensp; nums.forEach(e=>{e==target?output+=1:output+=0})\\n&ensp; &ensp; };\\n&ensp; &ensp; return output\\n};**"
                    }
                ]
            },
            {
                "id": 1575984,
                "content": [
                    {
                        "username": "user5615M",
                        "content": "I wanna explain this solution for peaple who like detailed mathematical explanations\\n\\nthe solution starts with iterating through all  the list and count the number of occurrences of each number and store it in a dictionary. so far so good!  \\nNext we want to iterate through each dictionary key and calculate the number of pairs.\\nCalculating the number of pairs is all about calculating the combinations of numbers\\n**nCr**  where **n** s the number of occurrences and **r**  is the number of elements we want in one group. Combinations are calculated as follows **nCr = n! / r! * (n-r)!** but remember that we want to count the number of pairs so **r=2** in our case. \\nLet\\'s calculate this \\n**nC2 = n! / 2! * (n-2)** =  **n * (n-1) * (n-2) * (n-3) *....1 /  2 * (n-2) * (n-3) * (n-4)*.....1**\\nso as you notice, there\\'re duplicate terms in the numerator and denomenator. we are gonna eliminate the terms starting from (n-2) to the end from both the numerator and denomenator. so we end up with **n * (n-1) / 2** This is exactly like summing from 1 to n-1. \\nso the final formula is used to calculate the number of pairs in each key of the dictionary \\nif n = 4 number of pairs is 4 * 3 / 2 = 6 pairs which gets the correct solution.\\n"
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "https://leetcode.com/problems/number-of-good-pairs/solutions/2784238/easy-c-o-n-soln-faang-interview-optimized-code/"
                    },
                    {
                        "username": "jjhardey24",
                        "content": "I\\'m not sure if I understand this quesion as it is unclear to me. What exactlty are i and j in the good pairs. Could someone expand further or give more test cases? I would greatly appreciate it."
                    },
                    {
                        "username": "ointissar",
                        "content": "i and j are indexes of good pairs in the given array\\nLet\\'s take an example:\\ngiven array                     [1, 3, 2, 1]\\nindexes                            0 1  2  3\\ngood pairs i and j            i           j\\n\\nSo i and j making the good pair (i, j) => (0, 3), because i < j  => 0 < 3 and array[i] = array[j]\\n\\nHope it\\'s clear enough :) "
                    },
                    {
                        "username": "Lucky_Dev",
                        "content": "indexes "
                    },
                    {
                        "username": "NagarapuNagaVenkataSivaSaiRagh",
                        "content": "i and j are index numbers, if nums[i]==nums[j]  then (i,j) is agood pair.... where(i<j)\\n\\nI hope you understood it\\n"
                    },
                    {
                        "username": "LOGANBLUE",
                        "content": "i and j are the indexes for equal entries like if 3 is present at 0,2,5 indexes so you have to make pair of the indexes like 0,2 & 0,5 & 2,5 so answer is 3(no of pairs of indexes)"
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "https://leetcode.com/problems/number-of-good-pairs/solutions/2784238/easy-c-o-n-soln-faang-interview-optimized-code/"
                    },
                    {
                        "username": "ft3793",
                        "content": "i should be in the last of the list and i in the starter of the list\\n"
                    },
                    {
                        "username": "Jsn667",
                        "content": "![image](https://assets.leetcode.com/users/images/e302aec0-570a-463e-8f68-3d87f4b3b4db_1608955337.8360794.png)\\n"
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "https://leetcode.com/problems/number-of-good-pairs/solutions/2784238/easy-c-o-n-soln-faang-interview-optimized-code/"
                    },
                    {
                        "username": "FireFrost",
                        "content": "check every pair with nested loop \\ntime - O(n^2)\\nspace - O(1)\\n\\nfrequency table and sum of n integers formula\\ntime - O(n)\\nspace - O(n)"
                    },
                    {
                        "username": "Nikhil_G002109",
                        "content": "How does the idea of using sum of \\'n\\' integers would come up in my mind??"
                    },
                    {
                        "username": "anshulupadhyay03",
                        "content": "why is my code failing for input : nums =\\n[6,5,1,5,7,7,9,1,5,7,1,6,10,9,7,4,1,8,7,1,1,8,6,4,7,4,10,5,3,9,10,1,9,5,5,4,1,7,4,2,9,2,6,6,4,2,10,3,5,3,6,4,7,4,6,4,4,6,3,4,10,1,10,6,10,4,9,6,6,4,8,6,9,5,4]\\n I am using the method of counting the numbers frequency and then using formula nCr to calculate pairs."
                    },
                    {
                        "username": "fuongdtran",
                        "content": "[@ry-reek](/ry-reek) it\\'s not the reason. Remember C is combinations, not permutations, meaning that (i,j) and (j,i) are accounted as one possibility. In other words, it does not matter if i < j or i > j"
                    },
                    {
                        "username": "fuongdtran",
                        "content": "The approach is right. The problem is that int/long variable does not big enough to hold a factorial calculation. since we know the r = 2, we can simplify the formula"
                    },
                    {
                        "username": "ry-reek",
                        "content": "okay, so one thing that I figured out is that calculating the nCr does not take the i < j into consideration so that\\'s why it\\'s the wrong approach."
                    },
                    {
                        "username": "ry-reek",
                        "content": "I am doing the same thing and my code fails for this exact test case."
                    },
                    {
                        "username": "kya_",
                        "content": "Did you ever figure out why this fails. I did the sam approach \\n"
                    },
                    {
                        "username": "tejaanuchuri",
                        "content": "![image](https://assets.leetcode.com/users/images/bc83ea82-042d-4c66-81c4-1632b63f9d3c_1651656723.4516509.png)\\n\\nHere we finding each number frequency and then based on frequency we get number of pairs;\\n\\nfor example a item has frequency k then (k*(k-1))/2 pairs are generated."
                    },
                    {
                        "username": "Anubhav_Saha",
                        "content": "Hi, can you explain the logic behind the formula k*(k-1)/2 for calculating pair\\n"
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "https://leetcode.com/problems/number-of-good-pairs/solutions/2784238/easy-c-o-n-soln-faang-interview-optimized-code/"
                    },
                    {
                        "username": "laosunhust",
                        "content": "`return int(sum([v(v-1)/2 for , v in Counter(nums).items()]))`"
                    },
                    {
                        "username": "luciferstern",
                        "content": "what if we want sum of all good pairs present in every subarray of a\\n"
                    },
                    {
                        "username": "L33TC0D3R4L1F3",
                        "content": "Wizard math?"
                    },
                    {
                        "username": "jaszy_the_better_twin",
                        "content": "slay"
                    },
                    {
                        "username": "percylam-pt",
                        "content": "**var numIdenticalPairs = function(nums) {\\n&ensp; &ensp; let output = 0;\\n&ensp; &ensp; while (nums.length!=0){\\n&ensp; &ensp; &ensp; &ensp; let target = nums.shift();\\n&ensp; &ensp; &ensp; &ensp; nums.forEach(e=>{e==target?output+=1:output+=0})\\n&ensp; &ensp; };\\n&ensp; &ensp; return output\\n};**"
                    }
                ]
            },
            {
                "id": 1570274,
                "content": [
                    {
                        "username": "user5615M",
                        "content": "I wanna explain this solution for peaple who like detailed mathematical explanations\\n\\nthe solution starts with iterating through all  the list and count the number of occurrences of each number and store it in a dictionary. so far so good!  \\nNext we want to iterate through each dictionary key and calculate the number of pairs.\\nCalculating the number of pairs is all about calculating the combinations of numbers\\n**nCr**  where **n** s the number of occurrences and **r**  is the number of elements we want in one group. Combinations are calculated as follows **nCr = n! / r! * (n-r)!** but remember that we want to count the number of pairs so **r=2** in our case. \\nLet\\'s calculate this \\n**nC2 = n! / 2! * (n-2)** =  **n * (n-1) * (n-2) * (n-3) *....1 /  2 * (n-2) * (n-3) * (n-4)*.....1**\\nso as you notice, there\\'re duplicate terms in the numerator and denomenator. we are gonna eliminate the terms starting from (n-2) to the end from both the numerator and denomenator. so we end up with **n * (n-1) / 2** This is exactly like summing from 1 to n-1. \\nso the final formula is used to calculate the number of pairs in each key of the dictionary \\nif n = 4 number of pairs is 4 * 3 / 2 = 6 pairs which gets the correct solution.\\n"
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "https://leetcode.com/problems/number-of-good-pairs/solutions/2784238/easy-c-o-n-soln-faang-interview-optimized-code/"
                    },
                    {
                        "username": "jjhardey24",
                        "content": "I\\'m not sure if I understand this quesion as it is unclear to me. What exactlty are i and j in the good pairs. Could someone expand further or give more test cases? I would greatly appreciate it."
                    },
                    {
                        "username": "ointissar",
                        "content": "i and j are indexes of good pairs in the given array\\nLet\\'s take an example:\\ngiven array                     [1, 3, 2, 1]\\nindexes                            0 1  2  3\\ngood pairs i and j            i           j\\n\\nSo i and j making the good pair (i, j) => (0, 3), because i < j  => 0 < 3 and array[i] = array[j]\\n\\nHope it\\'s clear enough :) "
                    },
                    {
                        "username": "Lucky_Dev",
                        "content": "indexes "
                    },
                    {
                        "username": "NagarapuNagaVenkataSivaSaiRagh",
                        "content": "i and j are index numbers, if nums[i]==nums[j]  then (i,j) is agood pair.... where(i<j)\\n\\nI hope you understood it\\n"
                    },
                    {
                        "username": "LOGANBLUE",
                        "content": "i and j are the indexes for equal entries like if 3 is present at 0,2,5 indexes so you have to make pair of the indexes like 0,2 & 0,5 & 2,5 so answer is 3(no of pairs of indexes)"
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "https://leetcode.com/problems/number-of-good-pairs/solutions/2784238/easy-c-o-n-soln-faang-interview-optimized-code/"
                    },
                    {
                        "username": "ft3793",
                        "content": "i should be in the last of the list and i in the starter of the list\\n"
                    },
                    {
                        "username": "Jsn667",
                        "content": "![image](https://assets.leetcode.com/users/images/e302aec0-570a-463e-8f68-3d87f4b3b4db_1608955337.8360794.png)\\n"
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "https://leetcode.com/problems/number-of-good-pairs/solutions/2784238/easy-c-o-n-soln-faang-interview-optimized-code/"
                    },
                    {
                        "username": "FireFrost",
                        "content": "check every pair with nested loop \\ntime - O(n^2)\\nspace - O(1)\\n\\nfrequency table and sum of n integers formula\\ntime - O(n)\\nspace - O(n)"
                    },
                    {
                        "username": "Nikhil_G002109",
                        "content": "How does the idea of using sum of \\'n\\' integers would come up in my mind??"
                    },
                    {
                        "username": "anshulupadhyay03",
                        "content": "why is my code failing for input : nums =\\n[6,5,1,5,7,7,9,1,5,7,1,6,10,9,7,4,1,8,7,1,1,8,6,4,7,4,10,5,3,9,10,1,9,5,5,4,1,7,4,2,9,2,6,6,4,2,10,3,5,3,6,4,7,4,6,4,4,6,3,4,10,1,10,6,10,4,9,6,6,4,8,6,9,5,4]\\n I am using the method of counting the numbers frequency and then using formula nCr to calculate pairs."
                    },
                    {
                        "username": "fuongdtran",
                        "content": "[@ry-reek](/ry-reek) it\\'s not the reason. Remember C is combinations, not permutations, meaning that (i,j) and (j,i) are accounted as one possibility. In other words, it does not matter if i < j or i > j"
                    },
                    {
                        "username": "fuongdtran",
                        "content": "The approach is right. The problem is that int/long variable does not big enough to hold a factorial calculation. since we know the r = 2, we can simplify the formula"
                    },
                    {
                        "username": "ry-reek",
                        "content": "okay, so one thing that I figured out is that calculating the nCr does not take the i < j into consideration so that\\'s why it\\'s the wrong approach."
                    },
                    {
                        "username": "ry-reek",
                        "content": "I am doing the same thing and my code fails for this exact test case."
                    },
                    {
                        "username": "kya_",
                        "content": "Did you ever figure out why this fails. I did the sam approach \\n"
                    },
                    {
                        "username": "tejaanuchuri",
                        "content": "![image](https://assets.leetcode.com/users/images/bc83ea82-042d-4c66-81c4-1632b63f9d3c_1651656723.4516509.png)\\n\\nHere we finding each number frequency and then based on frequency we get number of pairs;\\n\\nfor example a item has frequency k then (k*(k-1))/2 pairs are generated."
                    },
                    {
                        "username": "Anubhav_Saha",
                        "content": "Hi, can you explain the logic behind the formula k*(k-1)/2 for calculating pair\\n"
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "https://leetcode.com/problems/number-of-good-pairs/solutions/2784238/easy-c-o-n-soln-faang-interview-optimized-code/"
                    },
                    {
                        "username": "laosunhust",
                        "content": "`return int(sum([v(v-1)/2 for , v in Counter(nums).items()]))`"
                    },
                    {
                        "username": "luciferstern",
                        "content": "what if we want sum of all good pairs present in every subarray of a\\n"
                    },
                    {
                        "username": "L33TC0D3R4L1F3",
                        "content": "Wizard math?"
                    },
                    {
                        "username": "jaszy_the_better_twin",
                        "content": "slay"
                    },
                    {
                        "username": "percylam-pt",
                        "content": "**var numIdenticalPairs = function(nums) {\\n&ensp; &ensp; let output = 0;\\n&ensp; &ensp; while (nums.length!=0){\\n&ensp; &ensp; &ensp; &ensp; let target = nums.shift();\\n&ensp; &ensp; &ensp; &ensp; nums.forEach(e=>{e==target?output+=1:output+=0})\\n&ensp; &ensp; };\\n&ensp; &ensp; return output\\n};**"
                    }
                ]
            },
            {
                "id": 1574043,
                "content": [
                    {
                        "username": "user5615M",
                        "content": "I wanna explain this solution for peaple who like detailed mathematical explanations\\n\\nthe solution starts with iterating through all  the list and count the number of occurrences of each number and store it in a dictionary. so far so good!  \\nNext we want to iterate through each dictionary key and calculate the number of pairs.\\nCalculating the number of pairs is all about calculating the combinations of numbers\\n**nCr**  where **n** s the number of occurrences and **r**  is the number of elements we want in one group. Combinations are calculated as follows **nCr = n! / r! * (n-r)!** but remember that we want to count the number of pairs so **r=2** in our case. \\nLet\\'s calculate this \\n**nC2 = n! / 2! * (n-2)** =  **n * (n-1) * (n-2) * (n-3) *....1 /  2 * (n-2) * (n-3) * (n-4)*.....1**\\nso as you notice, there\\'re duplicate terms in the numerator and denomenator. we are gonna eliminate the terms starting from (n-2) to the end from both the numerator and denomenator. so we end up with **n * (n-1) / 2** This is exactly like summing from 1 to n-1. \\nso the final formula is used to calculate the number of pairs in each key of the dictionary \\nif n = 4 number of pairs is 4 * 3 / 2 = 6 pairs which gets the correct solution.\\n"
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "https://leetcode.com/problems/number-of-good-pairs/solutions/2784238/easy-c-o-n-soln-faang-interview-optimized-code/"
                    },
                    {
                        "username": "jjhardey24",
                        "content": "I\\'m not sure if I understand this quesion as it is unclear to me. What exactlty are i and j in the good pairs. Could someone expand further or give more test cases? I would greatly appreciate it."
                    },
                    {
                        "username": "ointissar",
                        "content": "i and j are indexes of good pairs in the given array\\nLet\\'s take an example:\\ngiven array                     [1, 3, 2, 1]\\nindexes                            0 1  2  3\\ngood pairs i and j            i           j\\n\\nSo i and j making the good pair (i, j) => (0, 3), because i < j  => 0 < 3 and array[i] = array[j]\\n\\nHope it\\'s clear enough :) "
                    },
                    {
                        "username": "Lucky_Dev",
                        "content": "indexes "
                    },
                    {
                        "username": "NagarapuNagaVenkataSivaSaiRagh",
                        "content": "i and j are index numbers, if nums[i]==nums[j]  then (i,j) is agood pair.... where(i<j)\\n\\nI hope you understood it\\n"
                    },
                    {
                        "username": "LOGANBLUE",
                        "content": "i and j are the indexes for equal entries like if 3 is present at 0,2,5 indexes so you have to make pair of the indexes like 0,2 & 0,5 & 2,5 so answer is 3(no of pairs of indexes)"
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "https://leetcode.com/problems/number-of-good-pairs/solutions/2784238/easy-c-o-n-soln-faang-interview-optimized-code/"
                    },
                    {
                        "username": "ft3793",
                        "content": "i should be in the last of the list and i in the starter of the list\\n"
                    },
                    {
                        "username": "Jsn667",
                        "content": "![image](https://assets.leetcode.com/users/images/e302aec0-570a-463e-8f68-3d87f4b3b4db_1608955337.8360794.png)\\n"
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "https://leetcode.com/problems/number-of-good-pairs/solutions/2784238/easy-c-o-n-soln-faang-interview-optimized-code/"
                    },
                    {
                        "username": "FireFrost",
                        "content": "check every pair with nested loop \\ntime - O(n^2)\\nspace - O(1)\\n\\nfrequency table and sum of n integers formula\\ntime - O(n)\\nspace - O(n)"
                    },
                    {
                        "username": "Nikhil_G002109",
                        "content": "How does the idea of using sum of \\'n\\' integers would come up in my mind??"
                    },
                    {
                        "username": "anshulupadhyay03",
                        "content": "why is my code failing for input : nums =\\n[6,5,1,5,7,7,9,1,5,7,1,6,10,9,7,4,1,8,7,1,1,8,6,4,7,4,10,5,3,9,10,1,9,5,5,4,1,7,4,2,9,2,6,6,4,2,10,3,5,3,6,4,7,4,6,4,4,6,3,4,10,1,10,6,10,4,9,6,6,4,8,6,9,5,4]\\n I am using the method of counting the numbers frequency and then using formula nCr to calculate pairs."
                    },
                    {
                        "username": "fuongdtran",
                        "content": "[@ry-reek](/ry-reek) it\\'s not the reason. Remember C is combinations, not permutations, meaning that (i,j) and (j,i) are accounted as one possibility. In other words, it does not matter if i < j or i > j"
                    },
                    {
                        "username": "fuongdtran",
                        "content": "The approach is right. The problem is that int/long variable does not big enough to hold a factorial calculation. since we know the r = 2, we can simplify the formula"
                    },
                    {
                        "username": "ry-reek",
                        "content": "okay, so one thing that I figured out is that calculating the nCr does not take the i < j into consideration so that\\'s why it\\'s the wrong approach."
                    },
                    {
                        "username": "ry-reek",
                        "content": "I am doing the same thing and my code fails for this exact test case."
                    },
                    {
                        "username": "kya_",
                        "content": "Did you ever figure out why this fails. I did the sam approach \\n"
                    },
                    {
                        "username": "tejaanuchuri",
                        "content": "![image](https://assets.leetcode.com/users/images/bc83ea82-042d-4c66-81c4-1632b63f9d3c_1651656723.4516509.png)\\n\\nHere we finding each number frequency and then based on frequency we get number of pairs;\\n\\nfor example a item has frequency k then (k*(k-1))/2 pairs are generated."
                    },
                    {
                        "username": "Anubhav_Saha",
                        "content": "Hi, can you explain the logic behind the formula k*(k-1)/2 for calculating pair\\n"
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "https://leetcode.com/problems/number-of-good-pairs/solutions/2784238/easy-c-o-n-soln-faang-interview-optimized-code/"
                    },
                    {
                        "username": "laosunhust",
                        "content": "`return int(sum([v(v-1)/2 for , v in Counter(nums).items()]))`"
                    },
                    {
                        "username": "luciferstern",
                        "content": "what if we want sum of all good pairs present in every subarray of a\\n"
                    },
                    {
                        "username": "L33TC0D3R4L1F3",
                        "content": "Wizard math?"
                    },
                    {
                        "username": "jaszy_the_better_twin",
                        "content": "slay"
                    },
                    {
                        "username": "percylam-pt",
                        "content": "**var numIdenticalPairs = function(nums) {\\n&ensp; &ensp; let output = 0;\\n&ensp; &ensp; while (nums.length!=0){\\n&ensp; &ensp; &ensp; &ensp; let target = nums.shift();\\n&ensp; &ensp; &ensp; &ensp; nums.forEach(e=>{e==target?output+=1:output+=0})\\n&ensp; &ensp; };\\n&ensp; &ensp; return output\\n};**"
                    }
                ]
            },
            {
                "id": 1566648,
                "content": [
                    {
                        "username": "user5615M",
                        "content": "I wanna explain this solution for peaple who like detailed mathematical explanations\\n\\nthe solution starts with iterating through all  the list and count the number of occurrences of each number and store it in a dictionary. so far so good!  \\nNext we want to iterate through each dictionary key and calculate the number of pairs.\\nCalculating the number of pairs is all about calculating the combinations of numbers\\n**nCr**  where **n** s the number of occurrences and **r**  is the number of elements we want in one group. Combinations are calculated as follows **nCr = n! / r! * (n-r)!** but remember that we want to count the number of pairs so **r=2** in our case. \\nLet\\'s calculate this \\n**nC2 = n! / 2! * (n-2)** =  **n * (n-1) * (n-2) * (n-3) *....1 /  2 * (n-2) * (n-3) * (n-4)*.....1**\\nso as you notice, there\\'re duplicate terms in the numerator and denomenator. we are gonna eliminate the terms starting from (n-2) to the end from both the numerator and denomenator. so we end up with **n * (n-1) / 2** This is exactly like summing from 1 to n-1. \\nso the final formula is used to calculate the number of pairs in each key of the dictionary \\nif n = 4 number of pairs is 4 * 3 / 2 = 6 pairs which gets the correct solution.\\n"
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "https://leetcode.com/problems/number-of-good-pairs/solutions/2784238/easy-c-o-n-soln-faang-interview-optimized-code/"
                    },
                    {
                        "username": "jjhardey24",
                        "content": "I\\'m not sure if I understand this quesion as it is unclear to me. What exactlty are i and j in the good pairs. Could someone expand further or give more test cases? I would greatly appreciate it."
                    },
                    {
                        "username": "ointissar",
                        "content": "i and j are indexes of good pairs in the given array\\nLet\\'s take an example:\\ngiven array                     [1, 3, 2, 1]\\nindexes                            0 1  2  3\\ngood pairs i and j            i           j\\n\\nSo i and j making the good pair (i, j) => (0, 3), because i < j  => 0 < 3 and array[i] = array[j]\\n\\nHope it\\'s clear enough :) "
                    },
                    {
                        "username": "Lucky_Dev",
                        "content": "indexes "
                    },
                    {
                        "username": "NagarapuNagaVenkataSivaSaiRagh",
                        "content": "i and j are index numbers, if nums[i]==nums[j]  then (i,j) is agood pair.... where(i<j)\\n\\nI hope you understood it\\n"
                    },
                    {
                        "username": "LOGANBLUE",
                        "content": "i and j are the indexes for equal entries like if 3 is present at 0,2,5 indexes so you have to make pair of the indexes like 0,2 & 0,5 & 2,5 so answer is 3(no of pairs of indexes)"
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "https://leetcode.com/problems/number-of-good-pairs/solutions/2784238/easy-c-o-n-soln-faang-interview-optimized-code/"
                    },
                    {
                        "username": "ft3793",
                        "content": "i should be in the last of the list and i in the starter of the list\\n"
                    },
                    {
                        "username": "Jsn667",
                        "content": "![image](https://assets.leetcode.com/users/images/e302aec0-570a-463e-8f68-3d87f4b3b4db_1608955337.8360794.png)\\n"
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "https://leetcode.com/problems/number-of-good-pairs/solutions/2784238/easy-c-o-n-soln-faang-interview-optimized-code/"
                    },
                    {
                        "username": "FireFrost",
                        "content": "check every pair with nested loop \\ntime - O(n^2)\\nspace - O(1)\\n\\nfrequency table and sum of n integers formula\\ntime - O(n)\\nspace - O(n)"
                    },
                    {
                        "username": "Nikhil_G002109",
                        "content": "How does the idea of using sum of \\'n\\' integers would come up in my mind??"
                    },
                    {
                        "username": "anshulupadhyay03",
                        "content": "why is my code failing for input : nums =\\n[6,5,1,5,7,7,9,1,5,7,1,6,10,9,7,4,1,8,7,1,1,8,6,4,7,4,10,5,3,9,10,1,9,5,5,4,1,7,4,2,9,2,6,6,4,2,10,3,5,3,6,4,7,4,6,4,4,6,3,4,10,1,10,6,10,4,9,6,6,4,8,6,9,5,4]\\n I am using the method of counting the numbers frequency and then using formula nCr to calculate pairs."
                    },
                    {
                        "username": "fuongdtran",
                        "content": "[@ry-reek](/ry-reek) it\\'s not the reason. Remember C is combinations, not permutations, meaning that (i,j) and (j,i) are accounted as one possibility. In other words, it does not matter if i < j or i > j"
                    },
                    {
                        "username": "fuongdtran",
                        "content": "The approach is right. The problem is that int/long variable does not big enough to hold a factorial calculation. since we know the r = 2, we can simplify the formula"
                    },
                    {
                        "username": "ry-reek",
                        "content": "okay, so one thing that I figured out is that calculating the nCr does not take the i < j into consideration so that\\'s why it\\'s the wrong approach."
                    },
                    {
                        "username": "ry-reek",
                        "content": "I am doing the same thing and my code fails for this exact test case."
                    },
                    {
                        "username": "kya_",
                        "content": "Did you ever figure out why this fails. I did the sam approach \\n"
                    },
                    {
                        "username": "tejaanuchuri",
                        "content": "![image](https://assets.leetcode.com/users/images/bc83ea82-042d-4c66-81c4-1632b63f9d3c_1651656723.4516509.png)\\n\\nHere we finding each number frequency and then based on frequency we get number of pairs;\\n\\nfor example a item has frequency k then (k*(k-1))/2 pairs are generated."
                    },
                    {
                        "username": "Anubhav_Saha",
                        "content": "Hi, can you explain the logic behind the formula k*(k-1)/2 for calculating pair\\n"
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "https://leetcode.com/problems/number-of-good-pairs/solutions/2784238/easy-c-o-n-soln-faang-interview-optimized-code/"
                    },
                    {
                        "username": "laosunhust",
                        "content": "`return int(sum([v(v-1)/2 for , v in Counter(nums).items()]))`"
                    },
                    {
                        "username": "luciferstern",
                        "content": "what if we want sum of all good pairs present in every subarray of a\\n"
                    },
                    {
                        "username": "L33TC0D3R4L1F3",
                        "content": "Wizard math?"
                    },
                    {
                        "username": "jaszy_the_better_twin",
                        "content": "slay"
                    },
                    {
                        "username": "percylam-pt",
                        "content": "**var numIdenticalPairs = function(nums) {\\n&ensp; &ensp; let output = 0;\\n&ensp; &ensp; while (nums.length!=0){\\n&ensp; &ensp; &ensp; &ensp; let target = nums.shift();\\n&ensp; &ensp; &ensp; &ensp; nums.forEach(e=>{e==target?output+=1:output+=0})\\n&ensp; &ensp; };\\n&ensp; &ensp; return output\\n};**"
                    }
                ]
            },
            {
                "id": 1574190,
                "content": [
                    {
                        "username": "user5615M",
                        "content": "I wanna explain this solution for peaple who like detailed mathematical explanations\\n\\nthe solution starts with iterating through all  the list and count the number of occurrences of each number and store it in a dictionary. so far so good!  \\nNext we want to iterate through each dictionary key and calculate the number of pairs.\\nCalculating the number of pairs is all about calculating the combinations of numbers\\n**nCr**  where **n** s the number of occurrences and **r**  is the number of elements we want in one group. Combinations are calculated as follows **nCr = n! / r! * (n-r)!** but remember that we want to count the number of pairs so **r=2** in our case. \\nLet\\'s calculate this \\n**nC2 = n! / 2! * (n-2)** =  **n * (n-1) * (n-2) * (n-3) *....1 /  2 * (n-2) * (n-3) * (n-4)*.....1**\\nso as you notice, there\\'re duplicate terms in the numerator and denomenator. we are gonna eliminate the terms starting from (n-2) to the end from both the numerator and denomenator. so we end up with **n * (n-1) / 2** This is exactly like summing from 1 to n-1. \\nso the final formula is used to calculate the number of pairs in each key of the dictionary \\nif n = 4 number of pairs is 4 * 3 / 2 = 6 pairs which gets the correct solution.\\n"
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "https://leetcode.com/problems/number-of-good-pairs/solutions/2784238/easy-c-o-n-soln-faang-interview-optimized-code/"
                    },
                    {
                        "username": "jjhardey24",
                        "content": "I\\'m not sure if I understand this quesion as it is unclear to me. What exactlty are i and j in the good pairs. Could someone expand further or give more test cases? I would greatly appreciate it."
                    },
                    {
                        "username": "ointissar",
                        "content": "i and j are indexes of good pairs in the given array\\nLet\\'s take an example:\\ngiven array                     [1, 3, 2, 1]\\nindexes                            0 1  2  3\\ngood pairs i and j            i           j\\n\\nSo i and j making the good pair (i, j) => (0, 3), because i < j  => 0 < 3 and array[i] = array[j]\\n\\nHope it\\'s clear enough :) "
                    },
                    {
                        "username": "Lucky_Dev",
                        "content": "indexes "
                    },
                    {
                        "username": "NagarapuNagaVenkataSivaSaiRagh",
                        "content": "i and j are index numbers, if nums[i]==nums[j]  then (i,j) is agood pair.... where(i<j)\\n\\nI hope you understood it\\n"
                    },
                    {
                        "username": "LOGANBLUE",
                        "content": "i and j are the indexes for equal entries like if 3 is present at 0,2,5 indexes so you have to make pair of the indexes like 0,2 & 0,5 & 2,5 so answer is 3(no of pairs of indexes)"
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "https://leetcode.com/problems/number-of-good-pairs/solutions/2784238/easy-c-o-n-soln-faang-interview-optimized-code/"
                    },
                    {
                        "username": "ft3793",
                        "content": "i should be in the last of the list and i in the starter of the list\\n"
                    },
                    {
                        "username": "Jsn667",
                        "content": "![image](https://assets.leetcode.com/users/images/e302aec0-570a-463e-8f68-3d87f4b3b4db_1608955337.8360794.png)\\n"
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "https://leetcode.com/problems/number-of-good-pairs/solutions/2784238/easy-c-o-n-soln-faang-interview-optimized-code/"
                    },
                    {
                        "username": "FireFrost",
                        "content": "check every pair with nested loop \\ntime - O(n^2)\\nspace - O(1)\\n\\nfrequency table and sum of n integers formula\\ntime - O(n)\\nspace - O(n)"
                    },
                    {
                        "username": "Nikhil_G002109",
                        "content": "How does the idea of using sum of \\'n\\' integers would come up in my mind??"
                    },
                    {
                        "username": "anshulupadhyay03",
                        "content": "why is my code failing for input : nums =\\n[6,5,1,5,7,7,9,1,5,7,1,6,10,9,7,4,1,8,7,1,1,8,6,4,7,4,10,5,3,9,10,1,9,5,5,4,1,7,4,2,9,2,6,6,4,2,10,3,5,3,6,4,7,4,6,4,4,6,3,4,10,1,10,6,10,4,9,6,6,4,8,6,9,5,4]\\n I am using the method of counting the numbers frequency and then using formula nCr to calculate pairs."
                    },
                    {
                        "username": "fuongdtran",
                        "content": "[@ry-reek](/ry-reek) it\\'s not the reason. Remember C is combinations, not permutations, meaning that (i,j) and (j,i) are accounted as one possibility. In other words, it does not matter if i < j or i > j"
                    },
                    {
                        "username": "fuongdtran",
                        "content": "The approach is right. The problem is that int/long variable does not big enough to hold a factorial calculation. since we know the r = 2, we can simplify the formula"
                    },
                    {
                        "username": "ry-reek",
                        "content": "okay, so one thing that I figured out is that calculating the nCr does not take the i < j into consideration so that\\'s why it\\'s the wrong approach."
                    },
                    {
                        "username": "ry-reek",
                        "content": "I am doing the same thing and my code fails for this exact test case."
                    },
                    {
                        "username": "kya_",
                        "content": "Did you ever figure out why this fails. I did the sam approach \\n"
                    },
                    {
                        "username": "tejaanuchuri",
                        "content": "![image](https://assets.leetcode.com/users/images/bc83ea82-042d-4c66-81c4-1632b63f9d3c_1651656723.4516509.png)\\n\\nHere we finding each number frequency and then based on frequency we get number of pairs;\\n\\nfor example a item has frequency k then (k*(k-1))/2 pairs are generated."
                    },
                    {
                        "username": "Anubhav_Saha",
                        "content": "Hi, can you explain the logic behind the formula k*(k-1)/2 for calculating pair\\n"
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "https://leetcode.com/problems/number-of-good-pairs/solutions/2784238/easy-c-o-n-soln-faang-interview-optimized-code/"
                    },
                    {
                        "username": "laosunhust",
                        "content": "`return int(sum([v(v-1)/2 for , v in Counter(nums).items()]))`"
                    },
                    {
                        "username": "luciferstern",
                        "content": "what if we want sum of all good pairs present in every subarray of a\\n"
                    },
                    {
                        "username": "L33TC0D3R4L1F3",
                        "content": "Wizard math?"
                    },
                    {
                        "username": "jaszy_the_better_twin",
                        "content": "slay"
                    },
                    {
                        "username": "percylam-pt",
                        "content": "**var numIdenticalPairs = function(nums) {\\n&ensp; &ensp; let output = 0;\\n&ensp; &ensp; while (nums.length!=0){\\n&ensp; &ensp; &ensp; &ensp; let target = nums.shift();\\n&ensp; &ensp; &ensp; &ensp; nums.forEach(e=>{e==target?output+=1:output+=0})\\n&ensp; &ensp; };\\n&ensp; &ensp; return output\\n};**"
                    }
                ]
            },
            {
                "id": 1725781,
                "content": [
                    {
                        "username": "user5615M",
                        "content": "I wanna explain this solution for peaple who like detailed mathematical explanations\\n\\nthe solution starts with iterating through all  the list and count the number of occurrences of each number and store it in a dictionary. so far so good!  \\nNext we want to iterate through each dictionary key and calculate the number of pairs.\\nCalculating the number of pairs is all about calculating the combinations of numbers\\n**nCr**  where **n** s the number of occurrences and **r**  is the number of elements we want in one group. Combinations are calculated as follows **nCr = n! / r! * (n-r)!** but remember that we want to count the number of pairs so **r=2** in our case. \\nLet\\'s calculate this \\n**nC2 = n! / 2! * (n-2)** =  **n * (n-1) * (n-2) * (n-3) *....1 /  2 * (n-2) * (n-3) * (n-4)*.....1**\\nso as you notice, there\\'re duplicate terms in the numerator and denomenator. we are gonna eliminate the terms starting from (n-2) to the end from both the numerator and denomenator. so we end up with **n * (n-1) / 2** This is exactly like summing from 1 to n-1. \\nso the final formula is used to calculate the number of pairs in each key of the dictionary \\nif n = 4 number of pairs is 4 * 3 / 2 = 6 pairs which gets the correct solution.\\n"
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "https://leetcode.com/problems/number-of-good-pairs/solutions/2784238/easy-c-o-n-soln-faang-interview-optimized-code/"
                    },
                    {
                        "username": "jjhardey24",
                        "content": "I\\'m not sure if I understand this quesion as it is unclear to me. What exactlty are i and j in the good pairs. Could someone expand further or give more test cases? I would greatly appreciate it."
                    },
                    {
                        "username": "ointissar",
                        "content": "i and j are indexes of good pairs in the given array\\nLet\\'s take an example:\\ngiven array                     [1, 3, 2, 1]\\nindexes                            0 1  2  3\\ngood pairs i and j            i           j\\n\\nSo i and j making the good pair (i, j) => (0, 3), because i < j  => 0 < 3 and array[i] = array[j]\\n\\nHope it\\'s clear enough :) "
                    },
                    {
                        "username": "Lucky_Dev",
                        "content": "indexes "
                    },
                    {
                        "username": "NagarapuNagaVenkataSivaSaiRagh",
                        "content": "i and j are index numbers, if nums[i]==nums[j]  then (i,j) is agood pair.... where(i<j)\\n\\nI hope you understood it\\n"
                    },
                    {
                        "username": "LOGANBLUE",
                        "content": "i and j are the indexes for equal entries like if 3 is present at 0,2,5 indexes so you have to make pair of the indexes like 0,2 & 0,5 & 2,5 so answer is 3(no of pairs of indexes)"
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "https://leetcode.com/problems/number-of-good-pairs/solutions/2784238/easy-c-o-n-soln-faang-interview-optimized-code/"
                    },
                    {
                        "username": "ft3793",
                        "content": "i should be in the last of the list and i in the starter of the list\\n"
                    },
                    {
                        "username": "Jsn667",
                        "content": "![image](https://assets.leetcode.com/users/images/e302aec0-570a-463e-8f68-3d87f4b3b4db_1608955337.8360794.png)\\n"
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "https://leetcode.com/problems/number-of-good-pairs/solutions/2784238/easy-c-o-n-soln-faang-interview-optimized-code/"
                    },
                    {
                        "username": "FireFrost",
                        "content": "check every pair with nested loop \\ntime - O(n^2)\\nspace - O(1)\\n\\nfrequency table and sum of n integers formula\\ntime - O(n)\\nspace - O(n)"
                    },
                    {
                        "username": "Nikhil_G002109",
                        "content": "How does the idea of using sum of \\'n\\' integers would come up in my mind??"
                    },
                    {
                        "username": "anshulupadhyay03",
                        "content": "why is my code failing for input : nums =\\n[6,5,1,5,7,7,9,1,5,7,1,6,10,9,7,4,1,8,7,1,1,8,6,4,7,4,10,5,3,9,10,1,9,5,5,4,1,7,4,2,9,2,6,6,4,2,10,3,5,3,6,4,7,4,6,4,4,6,3,4,10,1,10,6,10,4,9,6,6,4,8,6,9,5,4]\\n I am using the method of counting the numbers frequency and then using formula nCr to calculate pairs."
                    },
                    {
                        "username": "fuongdtran",
                        "content": "[@ry-reek](/ry-reek) it\\'s not the reason. Remember C is combinations, not permutations, meaning that (i,j) and (j,i) are accounted as one possibility. In other words, it does not matter if i < j or i > j"
                    },
                    {
                        "username": "fuongdtran",
                        "content": "The approach is right. The problem is that int/long variable does not big enough to hold a factorial calculation. since we know the r = 2, we can simplify the formula"
                    },
                    {
                        "username": "ry-reek",
                        "content": "okay, so one thing that I figured out is that calculating the nCr does not take the i < j into consideration so that\\'s why it\\'s the wrong approach."
                    },
                    {
                        "username": "ry-reek",
                        "content": "I am doing the same thing and my code fails for this exact test case."
                    },
                    {
                        "username": "kya_",
                        "content": "Did you ever figure out why this fails. I did the sam approach \\n"
                    },
                    {
                        "username": "tejaanuchuri",
                        "content": "![image](https://assets.leetcode.com/users/images/bc83ea82-042d-4c66-81c4-1632b63f9d3c_1651656723.4516509.png)\\n\\nHere we finding each number frequency and then based on frequency we get number of pairs;\\n\\nfor example a item has frequency k then (k*(k-1))/2 pairs are generated."
                    },
                    {
                        "username": "Anubhav_Saha",
                        "content": "Hi, can you explain the logic behind the formula k*(k-1)/2 for calculating pair\\n"
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "https://leetcode.com/problems/number-of-good-pairs/solutions/2784238/easy-c-o-n-soln-faang-interview-optimized-code/"
                    },
                    {
                        "username": "laosunhust",
                        "content": "`return int(sum([v(v-1)/2 for , v in Counter(nums).items()]))`"
                    },
                    {
                        "username": "luciferstern",
                        "content": "what if we want sum of all good pairs present in every subarray of a\\n"
                    },
                    {
                        "username": "L33TC0D3R4L1F3",
                        "content": "Wizard math?"
                    },
                    {
                        "username": "jaszy_the_better_twin",
                        "content": "slay"
                    },
                    {
                        "username": "percylam-pt",
                        "content": "**var numIdenticalPairs = function(nums) {\\n&ensp; &ensp; let output = 0;\\n&ensp; &ensp; while (nums.length!=0){\\n&ensp; &ensp; &ensp; &ensp; let target = nums.shift();\\n&ensp; &ensp; &ensp; &ensp; nums.forEach(e=>{e==target?output+=1:output+=0})\\n&ensp; &ensp; };\\n&ensp; &ensp; return output\\n};**"
                    }
                ]
            },
            {
                "id": 1576708,
                "content": [
                    {
                        "username": "user5615M",
                        "content": "I wanna explain this solution for peaple who like detailed mathematical explanations\\n\\nthe solution starts with iterating through all  the list and count the number of occurrences of each number and store it in a dictionary. so far so good!  \\nNext we want to iterate through each dictionary key and calculate the number of pairs.\\nCalculating the number of pairs is all about calculating the combinations of numbers\\n**nCr**  where **n** s the number of occurrences and **r**  is the number of elements we want in one group. Combinations are calculated as follows **nCr = n! / r! * (n-r)!** but remember that we want to count the number of pairs so **r=2** in our case. \\nLet\\'s calculate this \\n**nC2 = n! / 2! * (n-2)** =  **n * (n-1) * (n-2) * (n-3) *....1 /  2 * (n-2) * (n-3) * (n-4)*.....1**\\nso as you notice, there\\'re duplicate terms in the numerator and denomenator. we are gonna eliminate the terms starting from (n-2) to the end from both the numerator and denomenator. so we end up with **n * (n-1) / 2** This is exactly like summing from 1 to n-1. \\nso the final formula is used to calculate the number of pairs in each key of the dictionary \\nif n = 4 number of pairs is 4 * 3 / 2 = 6 pairs which gets the correct solution.\\n"
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "https://leetcode.com/problems/number-of-good-pairs/solutions/2784238/easy-c-o-n-soln-faang-interview-optimized-code/"
                    },
                    {
                        "username": "jjhardey24",
                        "content": "I\\'m not sure if I understand this quesion as it is unclear to me. What exactlty are i and j in the good pairs. Could someone expand further or give more test cases? I would greatly appreciate it."
                    },
                    {
                        "username": "ointissar",
                        "content": "i and j are indexes of good pairs in the given array\\nLet\\'s take an example:\\ngiven array                     [1, 3, 2, 1]\\nindexes                            0 1  2  3\\ngood pairs i and j            i           j\\n\\nSo i and j making the good pair (i, j) => (0, 3), because i < j  => 0 < 3 and array[i] = array[j]\\n\\nHope it\\'s clear enough :) "
                    },
                    {
                        "username": "Lucky_Dev",
                        "content": "indexes "
                    },
                    {
                        "username": "NagarapuNagaVenkataSivaSaiRagh",
                        "content": "i and j are index numbers, if nums[i]==nums[j]  then (i,j) is agood pair.... where(i<j)\\n\\nI hope you understood it\\n"
                    },
                    {
                        "username": "LOGANBLUE",
                        "content": "i and j are the indexes for equal entries like if 3 is present at 0,2,5 indexes so you have to make pair of the indexes like 0,2 & 0,5 & 2,5 so answer is 3(no of pairs of indexes)"
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "https://leetcode.com/problems/number-of-good-pairs/solutions/2784238/easy-c-o-n-soln-faang-interview-optimized-code/"
                    },
                    {
                        "username": "ft3793",
                        "content": "i should be in the last of the list and i in the starter of the list\\n"
                    },
                    {
                        "username": "Jsn667",
                        "content": "![image](https://assets.leetcode.com/users/images/e302aec0-570a-463e-8f68-3d87f4b3b4db_1608955337.8360794.png)\\n"
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "https://leetcode.com/problems/number-of-good-pairs/solutions/2784238/easy-c-o-n-soln-faang-interview-optimized-code/"
                    },
                    {
                        "username": "FireFrost",
                        "content": "check every pair with nested loop \\ntime - O(n^2)\\nspace - O(1)\\n\\nfrequency table and sum of n integers formula\\ntime - O(n)\\nspace - O(n)"
                    },
                    {
                        "username": "Nikhil_G002109",
                        "content": "How does the idea of using sum of \\'n\\' integers would come up in my mind??"
                    },
                    {
                        "username": "anshulupadhyay03",
                        "content": "why is my code failing for input : nums =\\n[6,5,1,5,7,7,9,1,5,7,1,6,10,9,7,4,1,8,7,1,1,8,6,4,7,4,10,5,3,9,10,1,9,5,5,4,1,7,4,2,9,2,6,6,4,2,10,3,5,3,6,4,7,4,6,4,4,6,3,4,10,1,10,6,10,4,9,6,6,4,8,6,9,5,4]\\n I am using the method of counting the numbers frequency and then using formula nCr to calculate pairs."
                    },
                    {
                        "username": "fuongdtran",
                        "content": "[@ry-reek](/ry-reek) it\\'s not the reason. Remember C is combinations, not permutations, meaning that (i,j) and (j,i) are accounted as one possibility. In other words, it does not matter if i < j or i > j"
                    },
                    {
                        "username": "fuongdtran",
                        "content": "The approach is right. The problem is that int/long variable does not big enough to hold a factorial calculation. since we know the r = 2, we can simplify the formula"
                    },
                    {
                        "username": "ry-reek",
                        "content": "okay, so one thing that I figured out is that calculating the nCr does not take the i < j into consideration so that\\'s why it\\'s the wrong approach."
                    },
                    {
                        "username": "ry-reek",
                        "content": "I am doing the same thing and my code fails for this exact test case."
                    },
                    {
                        "username": "kya_",
                        "content": "Did you ever figure out why this fails. I did the sam approach \\n"
                    },
                    {
                        "username": "tejaanuchuri",
                        "content": "![image](https://assets.leetcode.com/users/images/bc83ea82-042d-4c66-81c4-1632b63f9d3c_1651656723.4516509.png)\\n\\nHere we finding each number frequency and then based on frequency we get number of pairs;\\n\\nfor example a item has frequency k then (k*(k-1))/2 pairs are generated."
                    },
                    {
                        "username": "Anubhav_Saha",
                        "content": "Hi, can you explain the logic behind the formula k*(k-1)/2 for calculating pair\\n"
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "https://leetcode.com/problems/number-of-good-pairs/solutions/2784238/easy-c-o-n-soln-faang-interview-optimized-code/"
                    },
                    {
                        "username": "laosunhust",
                        "content": "`return int(sum([v(v-1)/2 for , v in Counter(nums).items()]))`"
                    },
                    {
                        "username": "luciferstern",
                        "content": "what if we want sum of all good pairs present in every subarray of a\\n"
                    },
                    {
                        "username": "L33TC0D3R4L1F3",
                        "content": "Wizard math?"
                    },
                    {
                        "username": "jaszy_the_better_twin",
                        "content": "slay"
                    },
                    {
                        "username": "percylam-pt",
                        "content": "**var numIdenticalPairs = function(nums) {\\n&ensp; &ensp; let output = 0;\\n&ensp; &ensp; while (nums.length!=0){\\n&ensp; &ensp; &ensp; &ensp; let target = nums.shift();\\n&ensp; &ensp; &ensp; &ensp; nums.forEach(e=>{e==target?output+=1:output+=0})\\n&ensp; &ensp; };\\n&ensp; &ensp; return output\\n};**"
                    }
                ]
            },
            {
                "id": 1575197,
                "content": [
                    {
                        "username": "user5615M",
                        "content": "I wanna explain this solution for peaple who like detailed mathematical explanations\\n\\nthe solution starts with iterating through all  the list and count the number of occurrences of each number and store it in a dictionary. so far so good!  \\nNext we want to iterate through each dictionary key and calculate the number of pairs.\\nCalculating the number of pairs is all about calculating the combinations of numbers\\n**nCr**  where **n** s the number of occurrences and **r**  is the number of elements we want in one group. Combinations are calculated as follows **nCr = n! / r! * (n-r)!** but remember that we want to count the number of pairs so **r=2** in our case. \\nLet\\'s calculate this \\n**nC2 = n! / 2! * (n-2)** =  **n * (n-1) * (n-2) * (n-3) *....1 /  2 * (n-2) * (n-3) * (n-4)*.....1**\\nso as you notice, there\\'re duplicate terms in the numerator and denomenator. we are gonna eliminate the terms starting from (n-2) to the end from both the numerator and denomenator. so we end up with **n * (n-1) / 2** This is exactly like summing from 1 to n-1. \\nso the final formula is used to calculate the number of pairs in each key of the dictionary \\nif n = 4 number of pairs is 4 * 3 / 2 = 6 pairs which gets the correct solution.\\n"
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "https://leetcode.com/problems/number-of-good-pairs/solutions/2784238/easy-c-o-n-soln-faang-interview-optimized-code/"
                    },
                    {
                        "username": "jjhardey24",
                        "content": "I\\'m not sure if I understand this quesion as it is unclear to me. What exactlty are i and j in the good pairs. Could someone expand further or give more test cases? I would greatly appreciate it."
                    },
                    {
                        "username": "ointissar",
                        "content": "i and j are indexes of good pairs in the given array\\nLet\\'s take an example:\\ngiven array                     [1, 3, 2, 1]\\nindexes                            0 1  2  3\\ngood pairs i and j            i           j\\n\\nSo i and j making the good pair (i, j) => (0, 3), because i < j  => 0 < 3 and array[i] = array[j]\\n\\nHope it\\'s clear enough :) "
                    },
                    {
                        "username": "Lucky_Dev",
                        "content": "indexes "
                    },
                    {
                        "username": "NagarapuNagaVenkataSivaSaiRagh",
                        "content": "i and j are index numbers, if nums[i]==nums[j]  then (i,j) is agood pair.... where(i<j)\\n\\nI hope you understood it\\n"
                    },
                    {
                        "username": "LOGANBLUE",
                        "content": "i and j are the indexes for equal entries like if 3 is present at 0,2,5 indexes so you have to make pair of the indexes like 0,2 & 0,5 & 2,5 so answer is 3(no of pairs of indexes)"
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "https://leetcode.com/problems/number-of-good-pairs/solutions/2784238/easy-c-o-n-soln-faang-interview-optimized-code/"
                    },
                    {
                        "username": "ft3793",
                        "content": "i should be in the last of the list and i in the starter of the list\\n"
                    },
                    {
                        "username": "Jsn667",
                        "content": "![image](https://assets.leetcode.com/users/images/e302aec0-570a-463e-8f68-3d87f4b3b4db_1608955337.8360794.png)\\n"
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "https://leetcode.com/problems/number-of-good-pairs/solutions/2784238/easy-c-o-n-soln-faang-interview-optimized-code/"
                    },
                    {
                        "username": "FireFrost",
                        "content": "check every pair with nested loop \\ntime - O(n^2)\\nspace - O(1)\\n\\nfrequency table and sum of n integers formula\\ntime - O(n)\\nspace - O(n)"
                    },
                    {
                        "username": "Nikhil_G002109",
                        "content": "How does the idea of using sum of \\'n\\' integers would come up in my mind??"
                    },
                    {
                        "username": "anshulupadhyay03",
                        "content": "why is my code failing for input : nums =\\n[6,5,1,5,7,7,9,1,5,7,1,6,10,9,7,4,1,8,7,1,1,8,6,4,7,4,10,5,3,9,10,1,9,5,5,4,1,7,4,2,9,2,6,6,4,2,10,3,5,3,6,4,7,4,6,4,4,6,3,4,10,1,10,6,10,4,9,6,6,4,8,6,9,5,4]\\n I am using the method of counting the numbers frequency and then using formula nCr to calculate pairs."
                    },
                    {
                        "username": "fuongdtran",
                        "content": "[@ry-reek](/ry-reek) it\\'s not the reason. Remember C is combinations, not permutations, meaning that (i,j) and (j,i) are accounted as one possibility. In other words, it does not matter if i < j or i > j"
                    },
                    {
                        "username": "fuongdtran",
                        "content": "The approach is right. The problem is that int/long variable does not big enough to hold a factorial calculation. since we know the r = 2, we can simplify the formula"
                    },
                    {
                        "username": "ry-reek",
                        "content": "okay, so one thing that I figured out is that calculating the nCr does not take the i < j into consideration so that\\'s why it\\'s the wrong approach."
                    },
                    {
                        "username": "ry-reek",
                        "content": "I am doing the same thing and my code fails for this exact test case."
                    },
                    {
                        "username": "kya_",
                        "content": "Did you ever figure out why this fails. I did the sam approach \\n"
                    },
                    {
                        "username": "tejaanuchuri",
                        "content": "![image](https://assets.leetcode.com/users/images/bc83ea82-042d-4c66-81c4-1632b63f9d3c_1651656723.4516509.png)\\n\\nHere we finding each number frequency and then based on frequency we get number of pairs;\\n\\nfor example a item has frequency k then (k*(k-1))/2 pairs are generated."
                    },
                    {
                        "username": "Anubhav_Saha",
                        "content": "Hi, can you explain the logic behind the formula k*(k-1)/2 for calculating pair\\n"
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "https://leetcode.com/problems/number-of-good-pairs/solutions/2784238/easy-c-o-n-soln-faang-interview-optimized-code/"
                    },
                    {
                        "username": "laosunhust",
                        "content": "`return int(sum([v(v-1)/2 for , v in Counter(nums).items()]))`"
                    },
                    {
                        "username": "luciferstern",
                        "content": "what if we want sum of all good pairs present in every subarray of a\\n"
                    },
                    {
                        "username": "L33TC0D3R4L1F3",
                        "content": "Wizard math?"
                    },
                    {
                        "username": "jaszy_the_better_twin",
                        "content": "slay"
                    },
                    {
                        "username": "percylam-pt",
                        "content": "**var numIdenticalPairs = function(nums) {\\n&ensp; &ensp; let output = 0;\\n&ensp; &ensp; while (nums.length!=0){\\n&ensp; &ensp; &ensp; &ensp; let target = nums.shift();\\n&ensp; &ensp; &ensp; &ensp; nums.forEach(e=>{e==target?output+=1:output+=0})\\n&ensp; &ensp; };\\n&ensp; &ensp; return output\\n};**"
                    }
                ]
            },
            {
                "id": 1575646,
                "content": [
                    {
                        "username": "user5615M",
                        "content": "I wanna explain this solution for peaple who like detailed mathematical explanations\\n\\nthe solution starts with iterating through all  the list and count the number of occurrences of each number and store it in a dictionary. so far so good!  \\nNext we want to iterate through each dictionary key and calculate the number of pairs.\\nCalculating the number of pairs is all about calculating the combinations of numbers\\n**nCr**  where **n** s the number of occurrences and **r**  is the number of elements we want in one group. Combinations are calculated as follows **nCr = n! / r! * (n-r)!** but remember that we want to count the number of pairs so **r=2** in our case. \\nLet\\'s calculate this \\n**nC2 = n! / 2! * (n-2)** =  **n * (n-1) * (n-2) * (n-3) *....1 /  2 * (n-2) * (n-3) * (n-4)*.....1**\\nso as you notice, there\\'re duplicate terms in the numerator and denomenator. we are gonna eliminate the terms starting from (n-2) to the end from both the numerator and denomenator. so we end up with **n * (n-1) / 2** This is exactly like summing from 1 to n-1. \\nso the final formula is used to calculate the number of pairs in each key of the dictionary \\nif n = 4 number of pairs is 4 * 3 / 2 = 6 pairs which gets the correct solution.\\n"
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "https://leetcode.com/problems/number-of-good-pairs/solutions/2784238/easy-c-o-n-soln-faang-interview-optimized-code/"
                    },
                    {
                        "username": "jjhardey24",
                        "content": "I\\'m not sure if I understand this quesion as it is unclear to me. What exactlty are i and j in the good pairs. Could someone expand further or give more test cases? I would greatly appreciate it."
                    },
                    {
                        "username": "ointissar",
                        "content": "i and j are indexes of good pairs in the given array\\nLet\\'s take an example:\\ngiven array                     [1, 3, 2, 1]\\nindexes                            0 1  2  3\\ngood pairs i and j            i           j\\n\\nSo i and j making the good pair (i, j) => (0, 3), because i < j  => 0 < 3 and array[i] = array[j]\\n\\nHope it\\'s clear enough :) "
                    },
                    {
                        "username": "Lucky_Dev",
                        "content": "indexes "
                    },
                    {
                        "username": "NagarapuNagaVenkataSivaSaiRagh",
                        "content": "i and j are index numbers, if nums[i]==nums[j]  then (i,j) is agood pair.... where(i<j)\\n\\nI hope you understood it\\n"
                    },
                    {
                        "username": "LOGANBLUE",
                        "content": "i and j are the indexes for equal entries like if 3 is present at 0,2,5 indexes so you have to make pair of the indexes like 0,2 & 0,5 & 2,5 so answer is 3(no of pairs of indexes)"
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "https://leetcode.com/problems/number-of-good-pairs/solutions/2784238/easy-c-o-n-soln-faang-interview-optimized-code/"
                    },
                    {
                        "username": "ft3793",
                        "content": "i should be in the last of the list and i in the starter of the list\\n"
                    },
                    {
                        "username": "Jsn667",
                        "content": "![image](https://assets.leetcode.com/users/images/e302aec0-570a-463e-8f68-3d87f4b3b4db_1608955337.8360794.png)\\n"
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "https://leetcode.com/problems/number-of-good-pairs/solutions/2784238/easy-c-o-n-soln-faang-interview-optimized-code/"
                    },
                    {
                        "username": "FireFrost",
                        "content": "check every pair with nested loop \\ntime - O(n^2)\\nspace - O(1)\\n\\nfrequency table and sum of n integers formula\\ntime - O(n)\\nspace - O(n)"
                    },
                    {
                        "username": "Nikhil_G002109",
                        "content": "How does the idea of using sum of \\'n\\' integers would come up in my mind??"
                    },
                    {
                        "username": "anshulupadhyay03",
                        "content": "why is my code failing for input : nums =\\n[6,5,1,5,7,7,9,1,5,7,1,6,10,9,7,4,1,8,7,1,1,8,6,4,7,4,10,5,3,9,10,1,9,5,5,4,1,7,4,2,9,2,6,6,4,2,10,3,5,3,6,4,7,4,6,4,4,6,3,4,10,1,10,6,10,4,9,6,6,4,8,6,9,5,4]\\n I am using the method of counting the numbers frequency and then using formula nCr to calculate pairs."
                    },
                    {
                        "username": "fuongdtran",
                        "content": "[@ry-reek](/ry-reek) it\\'s not the reason. Remember C is combinations, not permutations, meaning that (i,j) and (j,i) are accounted as one possibility. In other words, it does not matter if i < j or i > j"
                    },
                    {
                        "username": "fuongdtran",
                        "content": "The approach is right. The problem is that int/long variable does not big enough to hold a factorial calculation. since we know the r = 2, we can simplify the formula"
                    },
                    {
                        "username": "ry-reek",
                        "content": "okay, so one thing that I figured out is that calculating the nCr does not take the i < j into consideration so that\\'s why it\\'s the wrong approach."
                    },
                    {
                        "username": "ry-reek",
                        "content": "I am doing the same thing and my code fails for this exact test case."
                    },
                    {
                        "username": "kya_",
                        "content": "Did you ever figure out why this fails. I did the sam approach \\n"
                    },
                    {
                        "username": "tejaanuchuri",
                        "content": "![image](https://assets.leetcode.com/users/images/bc83ea82-042d-4c66-81c4-1632b63f9d3c_1651656723.4516509.png)\\n\\nHere we finding each number frequency and then based on frequency we get number of pairs;\\n\\nfor example a item has frequency k then (k*(k-1))/2 pairs are generated."
                    },
                    {
                        "username": "Anubhav_Saha",
                        "content": "Hi, can you explain the logic behind the formula k*(k-1)/2 for calculating pair\\n"
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "https://leetcode.com/problems/number-of-good-pairs/solutions/2784238/easy-c-o-n-soln-faang-interview-optimized-code/"
                    },
                    {
                        "username": "laosunhust",
                        "content": "`return int(sum([v(v-1)/2 for , v in Counter(nums).items()]))`"
                    },
                    {
                        "username": "luciferstern",
                        "content": "what if we want sum of all good pairs present in every subarray of a\\n"
                    },
                    {
                        "username": "L33TC0D3R4L1F3",
                        "content": "Wizard math?"
                    },
                    {
                        "username": "jaszy_the_better_twin",
                        "content": "slay"
                    },
                    {
                        "username": "percylam-pt",
                        "content": "**var numIdenticalPairs = function(nums) {\\n&ensp; &ensp; let output = 0;\\n&ensp; &ensp; while (nums.length!=0){\\n&ensp; &ensp; &ensp; &ensp; let target = nums.shift();\\n&ensp; &ensp; &ensp; &ensp; nums.forEach(e=>{e==target?output+=1:output+=0})\\n&ensp; &ensp; };\\n&ensp; &ensp; return output\\n};**"
                    }
                ]
            },
            {
                "id": 1574126,
                "content": [
                    {
                        "username": "user5615M",
                        "content": "I wanna explain this solution for peaple who like detailed mathematical explanations\\n\\nthe solution starts with iterating through all  the list and count the number of occurrences of each number and store it in a dictionary. so far so good!  \\nNext we want to iterate through each dictionary key and calculate the number of pairs.\\nCalculating the number of pairs is all about calculating the combinations of numbers\\n**nCr**  where **n** s the number of occurrences and **r**  is the number of elements we want in one group. Combinations are calculated as follows **nCr = n! / r! * (n-r)!** but remember that we want to count the number of pairs so **r=2** in our case. \\nLet\\'s calculate this \\n**nC2 = n! / 2! * (n-2)** =  **n * (n-1) * (n-2) * (n-3) *....1 /  2 * (n-2) * (n-3) * (n-4)*.....1**\\nso as you notice, there\\'re duplicate terms in the numerator and denomenator. we are gonna eliminate the terms starting from (n-2) to the end from both the numerator and denomenator. so we end up with **n * (n-1) / 2** This is exactly like summing from 1 to n-1. \\nso the final formula is used to calculate the number of pairs in each key of the dictionary \\nif n = 4 number of pairs is 4 * 3 / 2 = 6 pairs which gets the correct solution.\\n"
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "https://leetcode.com/problems/number-of-good-pairs/solutions/2784238/easy-c-o-n-soln-faang-interview-optimized-code/"
                    },
                    {
                        "username": "jjhardey24",
                        "content": "I\\'m not sure if I understand this quesion as it is unclear to me. What exactlty are i and j in the good pairs. Could someone expand further or give more test cases? I would greatly appreciate it."
                    },
                    {
                        "username": "ointissar",
                        "content": "i and j are indexes of good pairs in the given array\\nLet\\'s take an example:\\ngiven array                     [1, 3, 2, 1]\\nindexes                            0 1  2  3\\ngood pairs i and j            i           j\\n\\nSo i and j making the good pair (i, j) => (0, 3), because i < j  => 0 < 3 and array[i] = array[j]\\n\\nHope it\\'s clear enough :) "
                    },
                    {
                        "username": "Lucky_Dev",
                        "content": "indexes "
                    },
                    {
                        "username": "NagarapuNagaVenkataSivaSaiRagh",
                        "content": "i and j are index numbers, if nums[i]==nums[j]  then (i,j) is agood pair.... where(i<j)\\n\\nI hope you understood it\\n"
                    },
                    {
                        "username": "LOGANBLUE",
                        "content": "i and j are the indexes for equal entries like if 3 is present at 0,2,5 indexes so you have to make pair of the indexes like 0,2 & 0,5 & 2,5 so answer is 3(no of pairs of indexes)"
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "https://leetcode.com/problems/number-of-good-pairs/solutions/2784238/easy-c-o-n-soln-faang-interview-optimized-code/"
                    },
                    {
                        "username": "ft3793",
                        "content": "i should be in the last of the list and i in the starter of the list\\n"
                    },
                    {
                        "username": "Jsn667",
                        "content": "![image](https://assets.leetcode.com/users/images/e302aec0-570a-463e-8f68-3d87f4b3b4db_1608955337.8360794.png)\\n"
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "https://leetcode.com/problems/number-of-good-pairs/solutions/2784238/easy-c-o-n-soln-faang-interview-optimized-code/"
                    },
                    {
                        "username": "FireFrost",
                        "content": "check every pair with nested loop \\ntime - O(n^2)\\nspace - O(1)\\n\\nfrequency table and sum of n integers formula\\ntime - O(n)\\nspace - O(n)"
                    },
                    {
                        "username": "Nikhil_G002109",
                        "content": "How does the idea of using sum of \\'n\\' integers would come up in my mind??"
                    },
                    {
                        "username": "anshulupadhyay03",
                        "content": "why is my code failing for input : nums =\\n[6,5,1,5,7,7,9,1,5,7,1,6,10,9,7,4,1,8,7,1,1,8,6,4,7,4,10,5,3,9,10,1,9,5,5,4,1,7,4,2,9,2,6,6,4,2,10,3,5,3,6,4,7,4,6,4,4,6,3,4,10,1,10,6,10,4,9,6,6,4,8,6,9,5,4]\\n I am using the method of counting the numbers frequency and then using formula nCr to calculate pairs."
                    },
                    {
                        "username": "fuongdtran",
                        "content": "[@ry-reek](/ry-reek) it\\'s not the reason. Remember C is combinations, not permutations, meaning that (i,j) and (j,i) are accounted as one possibility. In other words, it does not matter if i < j or i > j"
                    },
                    {
                        "username": "fuongdtran",
                        "content": "The approach is right. The problem is that int/long variable does not big enough to hold a factorial calculation. since we know the r = 2, we can simplify the formula"
                    },
                    {
                        "username": "ry-reek",
                        "content": "okay, so one thing that I figured out is that calculating the nCr does not take the i < j into consideration so that\\'s why it\\'s the wrong approach."
                    },
                    {
                        "username": "ry-reek",
                        "content": "I am doing the same thing and my code fails for this exact test case."
                    },
                    {
                        "username": "kya_",
                        "content": "Did you ever figure out why this fails. I did the sam approach \\n"
                    },
                    {
                        "username": "tejaanuchuri",
                        "content": "![image](https://assets.leetcode.com/users/images/bc83ea82-042d-4c66-81c4-1632b63f9d3c_1651656723.4516509.png)\\n\\nHere we finding each number frequency and then based on frequency we get number of pairs;\\n\\nfor example a item has frequency k then (k*(k-1))/2 pairs are generated."
                    },
                    {
                        "username": "Anubhav_Saha",
                        "content": "Hi, can you explain the logic behind the formula k*(k-1)/2 for calculating pair\\n"
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "https://leetcode.com/problems/number-of-good-pairs/solutions/2784238/easy-c-o-n-soln-faang-interview-optimized-code/"
                    },
                    {
                        "username": "laosunhust",
                        "content": "`return int(sum([v(v-1)/2 for , v in Counter(nums).items()]))`"
                    },
                    {
                        "username": "luciferstern",
                        "content": "what if we want sum of all good pairs present in every subarray of a\\n"
                    },
                    {
                        "username": "L33TC0D3R4L1F3",
                        "content": "Wizard math?"
                    },
                    {
                        "username": "jaszy_the_better_twin",
                        "content": "slay"
                    },
                    {
                        "username": "percylam-pt",
                        "content": "**var numIdenticalPairs = function(nums) {\\n&ensp; &ensp; let output = 0;\\n&ensp; &ensp; while (nums.length!=0){\\n&ensp; &ensp; &ensp; &ensp; let target = nums.shift();\\n&ensp; &ensp; &ensp; &ensp; nums.forEach(e=>{e==target?output+=1:output+=0})\\n&ensp; &ensp; };\\n&ensp; &ensp; return output\\n};**"
                    }
                ]
            },
            {
                "id": 1575984,
                "content": [
                    {
                        "username": "user5615M",
                        "content": "I wanna explain this solution for peaple who like detailed mathematical explanations\\n\\nthe solution starts with iterating through all  the list and count the number of occurrences of each number and store it in a dictionary. so far so good!  \\nNext we want to iterate through each dictionary key and calculate the number of pairs.\\nCalculating the number of pairs is all about calculating the combinations of numbers\\n**nCr**  where **n** s the number of occurrences and **r**  is the number of elements we want in one group. Combinations are calculated as follows **nCr = n! / r! * (n-r)!** but remember that we want to count the number of pairs so **r=2** in our case. \\nLet\\'s calculate this \\n**nC2 = n! / 2! * (n-2)** =  **n * (n-1) * (n-2) * (n-3) *....1 /  2 * (n-2) * (n-3) * (n-4)*.....1**\\nso as you notice, there\\'re duplicate terms in the numerator and denomenator. we are gonna eliminate the terms starting from (n-2) to the end from both the numerator and denomenator. so we end up with **n * (n-1) / 2** This is exactly like summing from 1 to n-1. \\nso the final formula is used to calculate the number of pairs in each key of the dictionary \\nif n = 4 number of pairs is 4 * 3 / 2 = 6 pairs which gets the correct solution.\\n"
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "https://leetcode.com/problems/number-of-good-pairs/solutions/2784238/easy-c-o-n-soln-faang-interview-optimized-code/"
                    },
                    {
                        "username": "jjhardey24",
                        "content": "I\\'m not sure if I understand this quesion as it is unclear to me. What exactlty are i and j in the good pairs. Could someone expand further or give more test cases? I would greatly appreciate it."
                    },
                    {
                        "username": "ointissar",
                        "content": "i and j are indexes of good pairs in the given array\\nLet\\'s take an example:\\ngiven array                     [1, 3, 2, 1]\\nindexes                            0 1  2  3\\ngood pairs i and j            i           j\\n\\nSo i and j making the good pair (i, j) => (0, 3), because i < j  => 0 < 3 and array[i] = array[j]\\n\\nHope it\\'s clear enough :) "
                    },
                    {
                        "username": "Lucky_Dev",
                        "content": "indexes "
                    },
                    {
                        "username": "NagarapuNagaVenkataSivaSaiRagh",
                        "content": "i and j are index numbers, if nums[i]==nums[j]  then (i,j) is agood pair.... where(i<j)\\n\\nI hope you understood it\\n"
                    },
                    {
                        "username": "LOGANBLUE",
                        "content": "i and j are the indexes for equal entries like if 3 is present at 0,2,5 indexes so you have to make pair of the indexes like 0,2 & 0,5 & 2,5 so answer is 3(no of pairs of indexes)"
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "https://leetcode.com/problems/number-of-good-pairs/solutions/2784238/easy-c-o-n-soln-faang-interview-optimized-code/"
                    },
                    {
                        "username": "ft3793",
                        "content": "i should be in the last of the list and i in the starter of the list\\n"
                    },
                    {
                        "username": "Jsn667",
                        "content": "![image](https://assets.leetcode.com/users/images/e302aec0-570a-463e-8f68-3d87f4b3b4db_1608955337.8360794.png)\\n"
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "https://leetcode.com/problems/number-of-good-pairs/solutions/2784238/easy-c-o-n-soln-faang-interview-optimized-code/"
                    },
                    {
                        "username": "FireFrost",
                        "content": "check every pair with nested loop \\ntime - O(n^2)\\nspace - O(1)\\n\\nfrequency table and sum of n integers formula\\ntime - O(n)\\nspace - O(n)"
                    },
                    {
                        "username": "Nikhil_G002109",
                        "content": "How does the idea of using sum of \\'n\\' integers would come up in my mind??"
                    },
                    {
                        "username": "anshulupadhyay03",
                        "content": "why is my code failing for input : nums =\\n[6,5,1,5,7,7,9,1,5,7,1,6,10,9,7,4,1,8,7,1,1,8,6,4,7,4,10,5,3,9,10,1,9,5,5,4,1,7,4,2,9,2,6,6,4,2,10,3,5,3,6,4,7,4,6,4,4,6,3,4,10,1,10,6,10,4,9,6,6,4,8,6,9,5,4]\\n I am using the method of counting the numbers frequency and then using formula nCr to calculate pairs."
                    },
                    {
                        "username": "fuongdtran",
                        "content": "[@ry-reek](/ry-reek) it\\'s not the reason. Remember C is combinations, not permutations, meaning that (i,j) and (j,i) are accounted as one possibility. In other words, it does not matter if i < j or i > j"
                    },
                    {
                        "username": "fuongdtran",
                        "content": "The approach is right. The problem is that int/long variable does not big enough to hold a factorial calculation. since we know the r = 2, we can simplify the formula"
                    },
                    {
                        "username": "ry-reek",
                        "content": "okay, so one thing that I figured out is that calculating the nCr does not take the i < j into consideration so that\\'s why it\\'s the wrong approach."
                    },
                    {
                        "username": "ry-reek",
                        "content": "I am doing the same thing and my code fails for this exact test case."
                    },
                    {
                        "username": "kya_",
                        "content": "Did you ever figure out why this fails. I did the sam approach \\n"
                    },
                    {
                        "username": "tejaanuchuri",
                        "content": "![image](https://assets.leetcode.com/users/images/bc83ea82-042d-4c66-81c4-1632b63f9d3c_1651656723.4516509.png)\\n\\nHere we finding each number frequency and then based on frequency we get number of pairs;\\n\\nfor example a item has frequency k then (k*(k-1))/2 pairs are generated."
                    },
                    {
                        "username": "Anubhav_Saha",
                        "content": "Hi, can you explain the logic behind the formula k*(k-1)/2 for calculating pair\\n"
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "https://leetcode.com/problems/number-of-good-pairs/solutions/2784238/easy-c-o-n-soln-faang-interview-optimized-code/"
                    },
                    {
                        "username": "laosunhust",
                        "content": "`return int(sum([v(v-1)/2 for , v in Counter(nums).items()]))`"
                    },
                    {
                        "username": "luciferstern",
                        "content": "what if we want sum of all good pairs present in every subarray of a\\n"
                    },
                    {
                        "username": "L33TC0D3R4L1F3",
                        "content": "Wizard math?"
                    },
                    {
                        "username": "jaszy_the_better_twin",
                        "content": "slay"
                    },
                    {
                        "username": "percylam-pt",
                        "content": "**var numIdenticalPairs = function(nums) {\\n&ensp; &ensp; let output = 0;\\n&ensp; &ensp; while (nums.length!=0){\\n&ensp; &ensp; &ensp; &ensp; let target = nums.shift();\\n&ensp; &ensp; &ensp; &ensp; nums.forEach(e=>{e==target?output+=1:output+=0})\\n&ensp; &ensp; };\\n&ensp; &ensp; return output\\n};**"
                    }
                ]
            },
            {
                "id": 2065324,
                "content": [
                    {
                        "username": "pratikyadav8319",
                        "content": "ans is hidden in the que. just take 2 for loop first i for first element iteration and for 2nd element take j ; initialize j = 0+i in for loop so that j is always +1 from i and the apply condition according to the program / question (given)  and count the pairs you can create a ans = 0 int and count in it "
                    },
                    {
                        "username": "manish_j21",
                        "content": "to solve this problem first we will get the frequency of each element of array and then we will see how many combinations can be formed by them(nC2)here the value of nC2 will we n*(n-1)/2 and all the elements frequency combinations"
                    },
                    {
                        "username": "devesh_kumar_kushwaha",
                        "content": "\\uD83D\\uDFE2 no of pairs which can be possible from n equal elements equal to (n*(n-1))/2"
                    },
                    {
                        "username": "a_andreasian",
                        "content": "I don\\'t know how others solved, but in terms of time consumption and complexity - it should not be easy. Yes, there are no tricky test cases, or I just built an ultimate algorithm, \\nhowever, this is not easy. "
                    },
                    {
                        "username": "krushil1776",
                        "content": "  int count =0;\\n         for(int i=0;i<nums.length;i++){\\n             for(int j=i+1;j<nums.length;j++){\\n                 if(nums[i]=nums[j]){\\n                     count++;\\n\\n                 }\\n             }\\n         }\\nreturn count;   **************************simple java "
                    },
                    {
                        "username": "rishavpramanik17",
                        "content": "Simple C++ Solution :\\nint numIdenticalPairs(vector<int>& nums) {\\n        int count=0;\\n        int a=nums.size();\\n        for(int i=0;i<a;i++)\\n            for(int j=i+1;j<a;j++)\\n            {\\n                if(nums[i]==nums[j])\\n                count++;\\n            }\\n        return count;    \\n    }"
                    },
                    {
                        "username": "Razzzzzzzzz",
                        "content": "`class Solution:`\\n    `def numIdenticalPairs(self, nums: List[int]) -> int:`\\n        `list_num  = []`\\n        `for i in range(len(nums)):`\\n            `for j in range(i+1,len(nums)):`\\n                `if nums[i] == nums[j]:`\\n                    `list_num.append(1)`\\n        `return len(list_num)`"
                    },
                    {
                        "username": "priyasha_ivy",
                        "content": "I have used the sorting to sort the array following pointing the i at zero innitially and incrementing the j the difference between j and i till the array numbers are same if they are different then the i will increase. suppose in first case it [1,2,3,1,1,3] so after sorting its [1,1,1,2,3,3] so while the i = 0; j will move forward with count adding 1 each time once j reaches the 3rd index the else condition will change i = 2  and so on till j is less than the size of array. `your inline code...your inline code...` [leetcode](https://leetcode.com)"
                    },
                    {
                        "username": "CudCude",
                        "content": "Approach of linear space and time\\n\\nThink you are at an index i. How many good pairs you can make using nums[i]?\\nIn terms of left or right side............\\n\\n\\n\\nIf not able to figure out, read this.....\\n\\nIf I talk about from left to right in nums, then we will find that the number of good pairs will be the number of same elements as nums[i] on the right side of ith index. \\n\\nBecause nums[i] will make as many pairs as there are number of same elements on the right side.\\n\\nNow just sum up for every index from left to right and you got the answer.\\n\\nNote: same approach can be applied from right to left.\\n\\n\\nSorry for bad english. \\nThanks........"
                    },
                    {
                        "username": "Abhay_45",
                        "content": "class Solution {\\npublic:\\n    int numIdenticalPairs(vector<int>& nums) {\\n        \\n        int cnt=0;\\n        for (int i=0;i<nums.size();i++){\\n            for(int j=i+1;j<nums.size();j++){\\n                if(nums[i]==nums[j])\\n                cnt++;\\n            }\\n\\n        }\\n        return cnt;\\n    }\\n};"
                    }
                ]
            },
            {
                "id": 2050477,
                "content": [
                    {
                        "username": "pratikyadav8319",
                        "content": "ans is hidden in the que. just take 2 for loop first i for first element iteration and for 2nd element take j ; initialize j = 0+i in for loop so that j is always +1 from i and the apply condition according to the program / question (given)  and count the pairs you can create a ans = 0 int and count in it "
                    },
                    {
                        "username": "manish_j21",
                        "content": "to solve this problem first we will get the frequency of each element of array and then we will see how many combinations can be formed by them(nC2)here the value of nC2 will we n*(n-1)/2 and all the elements frequency combinations"
                    },
                    {
                        "username": "devesh_kumar_kushwaha",
                        "content": "\\uD83D\\uDFE2 no of pairs which can be possible from n equal elements equal to (n*(n-1))/2"
                    },
                    {
                        "username": "a_andreasian",
                        "content": "I don\\'t know how others solved, but in terms of time consumption and complexity - it should not be easy. Yes, there are no tricky test cases, or I just built an ultimate algorithm, \\nhowever, this is not easy. "
                    },
                    {
                        "username": "krushil1776",
                        "content": "  int count =0;\\n         for(int i=0;i<nums.length;i++){\\n             for(int j=i+1;j<nums.length;j++){\\n                 if(nums[i]=nums[j]){\\n                     count++;\\n\\n                 }\\n             }\\n         }\\nreturn count;   **************************simple java "
                    },
                    {
                        "username": "rishavpramanik17",
                        "content": "Simple C++ Solution :\\nint numIdenticalPairs(vector<int>& nums) {\\n        int count=0;\\n        int a=nums.size();\\n        for(int i=0;i<a;i++)\\n            for(int j=i+1;j<a;j++)\\n            {\\n                if(nums[i]==nums[j])\\n                count++;\\n            }\\n        return count;    \\n    }"
                    },
                    {
                        "username": "Razzzzzzzzz",
                        "content": "`class Solution:`\\n    `def numIdenticalPairs(self, nums: List[int]) -> int:`\\n        `list_num  = []`\\n        `for i in range(len(nums)):`\\n            `for j in range(i+1,len(nums)):`\\n                `if nums[i] == nums[j]:`\\n                    `list_num.append(1)`\\n        `return len(list_num)`"
                    },
                    {
                        "username": "priyasha_ivy",
                        "content": "I have used the sorting to sort the array following pointing the i at zero innitially and incrementing the j the difference between j and i till the array numbers are same if they are different then the i will increase. suppose in first case it [1,2,3,1,1,3] so after sorting its [1,1,1,2,3,3] so while the i = 0; j will move forward with count adding 1 each time once j reaches the 3rd index the else condition will change i = 2  and so on till j is less than the size of array. `your inline code...your inline code...` [leetcode](https://leetcode.com)"
                    },
                    {
                        "username": "CudCude",
                        "content": "Approach of linear space and time\\n\\nThink you are at an index i. How many good pairs you can make using nums[i]?\\nIn terms of left or right side............\\n\\n\\n\\nIf not able to figure out, read this.....\\n\\nIf I talk about from left to right in nums, then we will find that the number of good pairs will be the number of same elements as nums[i] on the right side of ith index. \\n\\nBecause nums[i] will make as many pairs as there are number of same elements on the right side.\\n\\nNow just sum up for every index from left to right and you got the answer.\\n\\nNote: same approach can be applied from right to left.\\n\\n\\nSorry for bad english. \\nThanks........"
                    },
                    {
                        "username": "Abhay_45",
                        "content": "class Solution {\\npublic:\\n    int numIdenticalPairs(vector<int>& nums) {\\n        \\n        int cnt=0;\\n        for (int i=0;i<nums.size();i++){\\n            for(int j=i+1;j<nums.size();j++){\\n                if(nums[i]==nums[j])\\n                cnt++;\\n            }\\n\\n        }\\n        return cnt;\\n    }\\n};"
                    }
                ]
            },
            {
                "id": 2018803,
                "content": [
                    {
                        "username": "pratikyadav8319",
                        "content": "ans is hidden in the que. just take 2 for loop first i for first element iteration and for 2nd element take j ; initialize j = 0+i in for loop so that j is always +1 from i and the apply condition according to the program / question (given)  and count the pairs you can create a ans = 0 int and count in it "
                    },
                    {
                        "username": "manish_j21",
                        "content": "to solve this problem first we will get the frequency of each element of array and then we will see how many combinations can be formed by them(nC2)here the value of nC2 will we n*(n-1)/2 and all the elements frequency combinations"
                    },
                    {
                        "username": "devesh_kumar_kushwaha",
                        "content": "\\uD83D\\uDFE2 no of pairs which can be possible from n equal elements equal to (n*(n-1))/2"
                    },
                    {
                        "username": "a_andreasian",
                        "content": "I don\\'t know how others solved, but in terms of time consumption and complexity - it should not be easy. Yes, there are no tricky test cases, or I just built an ultimate algorithm, \\nhowever, this is not easy. "
                    },
                    {
                        "username": "krushil1776",
                        "content": "  int count =0;\\n         for(int i=0;i<nums.length;i++){\\n             for(int j=i+1;j<nums.length;j++){\\n                 if(nums[i]=nums[j]){\\n                     count++;\\n\\n                 }\\n             }\\n         }\\nreturn count;   **************************simple java "
                    },
                    {
                        "username": "rishavpramanik17",
                        "content": "Simple C++ Solution :\\nint numIdenticalPairs(vector<int>& nums) {\\n        int count=0;\\n        int a=nums.size();\\n        for(int i=0;i<a;i++)\\n            for(int j=i+1;j<a;j++)\\n            {\\n                if(nums[i]==nums[j])\\n                count++;\\n            }\\n        return count;    \\n    }"
                    },
                    {
                        "username": "Razzzzzzzzz",
                        "content": "`class Solution:`\\n    `def numIdenticalPairs(self, nums: List[int]) -> int:`\\n        `list_num  = []`\\n        `for i in range(len(nums)):`\\n            `for j in range(i+1,len(nums)):`\\n                `if nums[i] == nums[j]:`\\n                    `list_num.append(1)`\\n        `return len(list_num)`"
                    },
                    {
                        "username": "priyasha_ivy",
                        "content": "I have used the sorting to sort the array following pointing the i at zero innitially and incrementing the j the difference between j and i till the array numbers are same if they are different then the i will increase. suppose in first case it [1,2,3,1,1,3] so after sorting its [1,1,1,2,3,3] so while the i = 0; j will move forward with count adding 1 each time once j reaches the 3rd index the else condition will change i = 2  and so on till j is less than the size of array. `your inline code...your inline code...` [leetcode](https://leetcode.com)"
                    },
                    {
                        "username": "CudCude",
                        "content": "Approach of linear space and time\\n\\nThink you are at an index i. How many good pairs you can make using nums[i]?\\nIn terms of left or right side............\\n\\n\\n\\nIf not able to figure out, read this.....\\n\\nIf I talk about from left to right in nums, then we will find that the number of good pairs will be the number of same elements as nums[i] on the right side of ith index. \\n\\nBecause nums[i] will make as many pairs as there are number of same elements on the right side.\\n\\nNow just sum up for every index from left to right and you got the answer.\\n\\nNote: same approach can be applied from right to left.\\n\\n\\nSorry for bad english. \\nThanks........"
                    },
                    {
                        "username": "Abhay_45",
                        "content": "class Solution {\\npublic:\\n    int numIdenticalPairs(vector<int>& nums) {\\n        \\n        int cnt=0;\\n        for (int i=0;i<nums.size();i++){\\n            for(int j=i+1;j<nums.size();j++){\\n                if(nums[i]==nums[j])\\n                cnt++;\\n            }\\n\\n        }\\n        return cnt;\\n    }\\n};"
                    }
                ]
            },
            {
                "id": 1988708,
                "content": [
                    {
                        "username": "pratikyadav8319",
                        "content": "ans is hidden in the que. just take 2 for loop first i for first element iteration and for 2nd element take j ; initialize j = 0+i in for loop so that j is always +1 from i and the apply condition according to the program / question (given)  and count the pairs you can create a ans = 0 int and count in it "
                    },
                    {
                        "username": "manish_j21",
                        "content": "to solve this problem first we will get the frequency of each element of array and then we will see how many combinations can be formed by them(nC2)here the value of nC2 will we n*(n-1)/2 and all the elements frequency combinations"
                    },
                    {
                        "username": "devesh_kumar_kushwaha",
                        "content": "\\uD83D\\uDFE2 no of pairs which can be possible from n equal elements equal to (n*(n-1))/2"
                    },
                    {
                        "username": "a_andreasian",
                        "content": "I don\\'t know how others solved, but in terms of time consumption and complexity - it should not be easy. Yes, there are no tricky test cases, or I just built an ultimate algorithm, \\nhowever, this is not easy. "
                    },
                    {
                        "username": "krushil1776",
                        "content": "  int count =0;\\n         for(int i=0;i<nums.length;i++){\\n             for(int j=i+1;j<nums.length;j++){\\n                 if(nums[i]=nums[j]){\\n                     count++;\\n\\n                 }\\n             }\\n         }\\nreturn count;   **************************simple java "
                    },
                    {
                        "username": "rishavpramanik17",
                        "content": "Simple C++ Solution :\\nint numIdenticalPairs(vector<int>& nums) {\\n        int count=0;\\n        int a=nums.size();\\n        for(int i=0;i<a;i++)\\n            for(int j=i+1;j<a;j++)\\n            {\\n                if(nums[i]==nums[j])\\n                count++;\\n            }\\n        return count;    \\n    }"
                    },
                    {
                        "username": "Razzzzzzzzz",
                        "content": "`class Solution:`\\n    `def numIdenticalPairs(self, nums: List[int]) -> int:`\\n        `list_num  = []`\\n        `for i in range(len(nums)):`\\n            `for j in range(i+1,len(nums)):`\\n                `if nums[i] == nums[j]:`\\n                    `list_num.append(1)`\\n        `return len(list_num)`"
                    },
                    {
                        "username": "priyasha_ivy",
                        "content": "I have used the sorting to sort the array following pointing the i at zero innitially and incrementing the j the difference between j and i till the array numbers are same if they are different then the i will increase. suppose in first case it [1,2,3,1,1,3] so after sorting its [1,1,1,2,3,3] so while the i = 0; j will move forward with count adding 1 each time once j reaches the 3rd index the else condition will change i = 2  and so on till j is less than the size of array. `your inline code...your inline code...` [leetcode](https://leetcode.com)"
                    },
                    {
                        "username": "CudCude",
                        "content": "Approach of linear space and time\\n\\nThink you are at an index i. How many good pairs you can make using nums[i]?\\nIn terms of left or right side............\\n\\n\\n\\nIf not able to figure out, read this.....\\n\\nIf I talk about from left to right in nums, then we will find that the number of good pairs will be the number of same elements as nums[i] on the right side of ith index. \\n\\nBecause nums[i] will make as many pairs as there are number of same elements on the right side.\\n\\nNow just sum up for every index from left to right and you got the answer.\\n\\nNote: same approach can be applied from right to left.\\n\\n\\nSorry for bad english. \\nThanks........"
                    },
                    {
                        "username": "Abhay_45",
                        "content": "class Solution {\\npublic:\\n    int numIdenticalPairs(vector<int>& nums) {\\n        \\n        int cnt=0;\\n        for (int i=0;i<nums.size();i++){\\n            for(int j=i+1;j<nums.size();j++){\\n                if(nums[i]==nums[j])\\n                cnt++;\\n            }\\n\\n        }\\n        return cnt;\\n    }\\n};"
                    }
                ]
            },
            {
                "id": 1873411,
                "content": [
                    {
                        "username": "pratikyadav8319",
                        "content": "ans is hidden in the que. just take 2 for loop first i for first element iteration and for 2nd element take j ; initialize j = 0+i in for loop so that j is always +1 from i and the apply condition according to the program / question (given)  and count the pairs you can create a ans = 0 int and count in it "
                    },
                    {
                        "username": "manish_j21",
                        "content": "to solve this problem first we will get the frequency of each element of array and then we will see how many combinations can be formed by them(nC2)here the value of nC2 will we n*(n-1)/2 and all the elements frequency combinations"
                    },
                    {
                        "username": "devesh_kumar_kushwaha",
                        "content": "\\uD83D\\uDFE2 no of pairs which can be possible from n equal elements equal to (n*(n-1))/2"
                    },
                    {
                        "username": "a_andreasian",
                        "content": "I don\\'t know how others solved, but in terms of time consumption and complexity - it should not be easy. Yes, there are no tricky test cases, or I just built an ultimate algorithm, \\nhowever, this is not easy. "
                    },
                    {
                        "username": "krushil1776",
                        "content": "  int count =0;\\n         for(int i=0;i<nums.length;i++){\\n             for(int j=i+1;j<nums.length;j++){\\n                 if(nums[i]=nums[j]){\\n                     count++;\\n\\n                 }\\n             }\\n         }\\nreturn count;   **************************simple java "
                    },
                    {
                        "username": "rishavpramanik17",
                        "content": "Simple C++ Solution :\\nint numIdenticalPairs(vector<int>& nums) {\\n        int count=0;\\n        int a=nums.size();\\n        for(int i=0;i<a;i++)\\n            for(int j=i+1;j<a;j++)\\n            {\\n                if(nums[i]==nums[j])\\n                count++;\\n            }\\n        return count;    \\n    }"
                    },
                    {
                        "username": "Razzzzzzzzz",
                        "content": "`class Solution:`\\n    `def numIdenticalPairs(self, nums: List[int]) -> int:`\\n        `list_num  = []`\\n        `for i in range(len(nums)):`\\n            `for j in range(i+1,len(nums)):`\\n                `if nums[i] == nums[j]:`\\n                    `list_num.append(1)`\\n        `return len(list_num)`"
                    },
                    {
                        "username": "priyasha_ivy",
                        "content": "I have used the sorting to sort the array following pointing the i at zero innitially and incrementing the j the difference between j and i till the array numbers are same if they are different then the i will increase. suppose in first case it [1,2,3,1,1,3] so after sorting its [1,1,1,2,3,3] so while the i = 0; j will move forward with count adding 1 each time once j reaches the 3rd index the else condition will change i = 2  and so on till j is less than the size of array. `your inline code...your inline code...` [leetcode](https://leetcode.com)"
                    },
                    {
                        "username": "CudCude",
                        "content": "Approach of linear space and time\\n\\nThink you are at an index i. How many good pairs you can make using nums[i]?\\nIn terms of left or right side............\\n\\n\\n\\nIf not able to figure out, read this.....\\n\\nIf I talk about from left to right in nums, then we will find that the number of good pairs will be the number of same elements as nums[i] on the right side of ith index. \\n\\nBecause nums[i] will make as many pairs as there are number of same elements on the right side.\\n\\nNow just sum up for every index from left to right and you got the answer.\\n\\nNote: same approach can be applied from right to left.\\n\\n\\nSorry for bad english. \\nThanks........"
                    },
                    {
                        "username": "Abhay_45",
                        "content": "class Solution {\\npublic:\\n    int numIdenticalPairs(vector<int>& nums) {\\n        \\n        int cnt=0;\\n        for (int i=0;i<nums.size();i++){\\n            for(int j=i+1;j<nums.size();j++){\\n                if(nums[i]==nums[j])\\n                cnt++;\\n            }\\n\\n        }\\n        return cnt;\\n    }\\n};"
                    }
                ]
            },
            {
                "id": 1849584,
                "content": [
                    {
                        "username": "pratikyadav8319",
                        "content": "ans is hidden in the que. just take 2 for loop first i for first element iteration and for 2nd element take j ; initialize j = 0+i in for loop so that j is always +1 from i and the apply condition according to the program / question (given)  and count the pairs you can create a ans = 0 int and count in it "
                    },
                    {
                        "username": "manish_j21",
                        "content": "to solve this problem first we will get the frequency of each element of array and then we will see how many combinations can be formed by them(nC2)here the value of nC2 will we n*(n-1)/2 and all the elements frequency combinations"
                    },
                    {
                        "username": "devesh_kumar_kushwaha",
                        "content": "\\uD83D\\uDFE2 no of pairs which can be possible from n equal elements equal to (n*(n-1))/2"
                    },
                    {
                        "username": "a_andreasian",
                        "content": "I don\\'t know how others solved, but in terms of time consumption and complexity - it should not be easy. Yes, there are no tricky test cases, or I just built an ultimate algorithm, \\nhowever, this is not easy. "
                    },
                    {
                        "username": "krushil1776",
                        "content": "  int count =0;\\n         for(int i=0;i<nums.length;i++){\\n             for(int j=i+1;j<nums.length;j++){\\n                 if(nums[i]=nums[j]){\\n                     count++;\\n\\n                 }\\n             }\\n         }\\nreturn count;   **************************simple java "
                    },
                    {
                        "username": "rishavpramanik17",
                        "content": "Simple C++ Solution :\\nint numIdenticalPairs(vector<int>& nums) {\\n        int count=0;\\n        int a=nums.size();\\n        for(int i=0;i<a;i++)\\n            for(int j=i+1;j<a;j++)\\n            {\\n                if(nums[i]==nums[j])\\n                count++;\\n            }\\n        return count;    \\n    }"
                    },
                    {
                        "username": "Razzzzzzzzz",
                        "content": "`class Solution:`\\n    `def numIdenticalPairs(self, nums: List[int]) -> int:`\\n        `list_num  = []`\\n        `for i in range(len(nums)):`\\n            `for j in range(i+1,len(nums)):`\\n                `if nums[i] == nums[j]:`\\n                    `list_num.append(1)`\\n        `return len(list_num)`"
                    },
                    {
                        "username": "priyasha_ivy",
                        "content": "I have used the sorting to sort the array following pointing the i at zero innitially and incrementing the j the difference between j and i till the array numbers are same if they are different then the i will increase. suppose in first case it [1,2,3,1,1,3] so after sorting its [1,1,1,2,3,3] so while the i = 0; j will move forward with count adding 1 each time once j reaches the 3rd index the else condition will change i = 2  and so on till j is less than the size of array. `your inline code...your inline code...` [leetcode](https://leetcode.com)"
                    },
                    {
                        "username": "CudCude",
                        "content": "Approach of linear space and time\\n\\nThink you are at an index i. How many good pairs you can make using nums[i]?\\nIn terms of left or right side............\\n\\n\\n\\nIf not able to figure out, read this.....\\n\\nIf I talk about from left to right in nums, then we will find that the number of good pairs will be the number of same elements as nums[i] on the right side of ith index. \\n\\nBecause nums[i] will make as many pairs as there are number of same elements on the right side.\\n\\nNow just sum up for every index from left to right and you got the answer.\\n\\nNote: same approach can be applied from right to left.\\n\\n\\nSorry for bad english. \\nThanks........"
                    },
                    {
                        "username": "Abhay_45",
                        "content": "class Solution {\\npublic:\\n    int numIdenticalPairs(vector<int>& nums) {\\n        \\n        int cnt=0;\\n        for (int i=0;i<nums.size();i++){\\n            for(int j=i+1;j<nums.size();j++){\\n                if(nums[i]==nums[j])\\n                cnt++;\\n            }\\n\\n        }\\n        return cnt;\\n    }\\n};"
                    }
                ]
            },
            {
                "id": 1842293,
                "content": [
                    {
                        "username": "pratikyadav8319",
                        "content": "ans is hidden in the que. just take 2 for loop first i for first element iteration and for 2nd element take j ; initialize j = 0+i in for loop so that j is always +1 from i and the apply condition according to the program / question (given)  and count the pairs you can create a ans = 0 int and count in it "
                    },
                    {
                        "username": "manish_j21",
                        "content": "to solve this problem first we will get the frequency of each element of array and then we will see how many combinations can be formed by them(nC2)here the value of nC2 will we n*(n-1)/2 and all the elements frequency combinations"
                    },
                    {
                        "username": "devesh_kumar_kushwaha",
                        "content": "\\uD83D\\uDFE2 no of pairs which can be possible from n equal elements equal to (n*(n-1))/2"
                    },
                    {
                        "username": "a_andreasian",
                        "content": "I don\\'t know how others solved, but in terms of time consumption and complexity - it should not be easy. Yes, there are no tricky test cases, or I just built an ultimate algorithm, \\nhowever, this is not easy. "
                    },
                    {
                        "username": "krushil1776",
                        "content": "  int count =0;\\n         for(int i=0;i<nums.length;i++){\\n             for(int j=i+1;j<nums.length;j++){\\n                 if(nums[i]=nums[j]){\\n                     count++;\\n\\n                 }\\n             }\\n         }\\nreturn count;   **************************simple java "
                    },
                    {
                        "username": "rishavpramanik17",
                        "content": "Simple C++ Solution :\\nint numIdenticalPairs(vector<int>& nums) {\\n        int count=0;\\n        int a=nums.size();\\n        for(int i=0;i<a;i++)\\n            for(int j=i+1;j<a;j++)\\n            {\\n                if(nums[i]==nums[j])\\n                count++;\\n            }\\n        return count;    \\n    }"
                    },
                    {
                        "username": "Razzzzzzzzz",
                        "content": "`class Solution:`\\n    `def numIdenticalPairs(self, nums: List[int]) -> int:`\\n        `list_num  = []`\\n        `for i in range(len(nums)):`\\n            `for j in range(i+1,len(nums)):`\\n                `if nums[i] == nums[j]:`\\n                    `list_num.append(1)`\\n        `return len(list_num)`"
                    },
                    {
                        "username": "priyasha_ivy",
                        "content": "I have used the sorting to sort the array following pointing the i at zero innitially and incrementing the j the difference between j and i till the array numbers are same if they are different then the i will increase. suppose in first case it [1,2,3,1,1,3] so after sorting its [1,1,1,2,3,3] so while the i = 0; j will move forward with count adding 1 each time once j reaches the 3rd index the else condition will change i = 2  and so on till j is less than the size of array. `your inline code...your inline code...` [leetcode](https://leetcode.com)"
                    },
                    {
                        "username": "CudCude",
                        "content": "Approach of linear space and time\\n\\nThink you are at an index i. How many good pairs you can make using nums[i]?\\nIn terms of left or right side............\\n\\n\\n\\nIf not able to figure out, read this.....\\n\\nIf I talk about from left to right in nums, then we will find that the number of good pairs will be the number of same elements as nums[i] on the right side of ith index. \\n\\nBecause nums[i] will make as many pairs as there are number of same elements on the right side.\\n\\nNow just sum up for every index from left to right and you got the answer.\\n\\nNote: same approach can be applied from right to left.\\n\\n\\nSorry for bad english. \\nThanks........"
                    },
                    {
                        "username": "Abhay_45",
                        "content": "class Solution {\\npublic:\\n    int numIdenticalPairs(vector<int>& nums) {\\n        \\n        int cnt=0;\\n        for (int i=0;i<nums.size();i++){\\n            for(int j=i+1;j<nums.size();j++){\\n                if(nums[i]==nums[j])\\n                cnt++;\\n            }\\n\\n        }\\n        return cnt;\\n    }\\n};"
                    }
                ]
            },
            {
                "id": 1831229,
                "content": [
                    {
                        "username": "pratikyadav8319",
                        "content": "ans is hidden in the que. just take 2 for loop first i for first element iteration and for 2nd element take j ; initialize j = 0+i in for loop so that j is always +1 from i and the apply condition according to the program / question (given)  and count the pairs you can create a ans = 0 int and count in it "
                    },
                    {
                        "username": "manish_j21",
                        "content": "to solve this problem first we will get the frequency of each element of array and then we will see how many combinations can be formed by them(nC2)here the value of nC2 will we n*(n-1)/2 and all the elements frequency combinations"
                    },
                    {
                        "username": "devesh_kumar_kushwaha",
                        "content": "\\uD83D\\uDFE2 no of pairs which can be possible from n equal elements equal to (n*(n-1))/2"
                    },
                    {
                        "username": "a_andreasian",
                        "content": "I don\\'t know how others solved, but in terms of time consumption and complexity - it should not be easy. Yes, there are no tricky test cases, or I just built an ultimate algorithm, \\nhowever, this is not easy. "
                    },
                    {
                        "username": "krushil1776",
                        "content": "  int count =0;\\n         for(int i=0;i<nums.length;i++){\\n             for(int j=i+1;j<nums.length;j++){\\n                 if(nums[i]=nums[j]){\\n                     count++;\\n\\n                 }\\n             }\\n         }\\nreturn count;   **************************simple java "
                    },
                    {
                        "username": "rishavpramanik17",
                        "content": "Simple C++ Solution :\\nint numIdenticalPairs(vector<int>& nums) {\\n        int count=0;\\n        int a=nums.size();\\n        for(int i=0;i<a;i++)\\n            for(int j=i+1;j<a;j++)\\n            {\\n                if(nums[i]==nums[j])\\n                count++;\\n            }\\n        return count;    \\n    }"
                    },
                    {
                        "username": "Razzzzzzzzz",
                        "content": "`class Solution:`\\n    `def numIdenticalPairs(self, nums: List[int]) -> int:`\\n        `list_num  = []`\\n        `for i in range(len(nums)):`\\n            `for j in range(i+1,len(nums)):`\\n                `if nums[i] == nums[j]:`\\n                    `list_num.append(1)`\\n        `return len(list_num)`"
                    },
                    {
                        "username": "priyasha_ivy",
                        "content": "I have used the sorting to sort the array following pointing the i at zero innitially and incrementing the j the difference between j and i till the array numbers are same if they are different then the i will increase. suppose in first case it [1,2,3,1,1,3] so after sorting its [1,1,1,2,3,3] so while the i = 0; j will move forward with count adding 1 each time once j reaches the 3rd index the else condition will change i = 2  and so on till j is less than the size of array. `your inline code...your inline code...` [leetcode](https://leetcode.com)"
                    },
                    {
                        "username": "CudCude",
                        "content": "Approach of linear space and time\\n\\nThink you are at an index i. How many good pairs you can make using nums[i]?\\nIn terms of left or right side............\\n\\n\\n\\nIf not able to figure out, read this.....\\n\\nIf I talk about from left to right in nums, then we will find that the number of good pairs will be the number of same elements as nums[i] on the right side of ith index. \\n\\nBecause nums[i] will make as many pairs as there are number of same elements on the right side.\\n\\nNow just sum up for every index from left to right and you got the answer.\\n\\nNote: same approach can be applied from right to left.\\n\\n\\nSorry for bad english. \\nThanks........"
                    },
                    {
                        "username": "Abhay_45",
                        "content": "class Solution {\\npublic:\\n    int numIdenticalPairs(vector<int>& nums) {\\n        \\n        int cnt=0;\\n        for (int i=0;i<nums.size();i++){\\n            for(int j=i+1;j<nums.size();j++){\\n                if(nums[i]==nums[j])\\n                cnt++;\\n            }\\n\\n        }\\n        return cnt;\\n    }\\n};"
                    }
                ]
            },
            {
                "id": 1824255,
                "content": [
                    {
                        "username": "pratikyadav8319",
                        "content": "ans is hidden in the que. just take 2 for loop first i for first element iteration and for 2nd element take j ; initialize j = 0+i in for loop so that j is always +1 from i and the apply condition according to the program / question (given)  and count the pairs you can create a ans = 0 int and count in it "
                    },
                    {
                        "username": "manish_j21",
                        "content": "to solve this problem first we will get the frequency of each element of array and then we will see how many combinations can be formed by them(nC2)here the value of nC2 will we n*(n-1)/2 and all the elements frequency combinations"
                    },
                    {
                        "username": "devesh_kumar_kushwaha",
                        "content": "\\uD83D\\uDFE2 no of pairs which can be possible from n equal elements equal to (n*(n-1))/2"
                    },
                    {
                        "username": "a_andreasian",
                        "content": "I don\\'t know how others solved, but in terms of time consumption and complexity - it should not be easy. Yes, there are no tricky test cases, or I just built an ultimate algorithm, \\nhowever, this is not easy. "
                    },
                    {
                        "username": "krushil1776",
                        "content": "  int count =0;\\n         for(int i=0;i<nums.length;i++){\\n             for(int j=i+1;j<nums.length;j++){\\n                 if(nums[i]=nums[j]){\\n                     count++;\\n\\n                 }\\n             }\\n         }\\nreturn count;   **************************simple java "
                    },
                    {
                        "username": "rishavpramanik17",
                        "content": "Simple C++ Solution :\\nint numIdenticalPairs(vector<int>& nums) {\\n        int count=0;\\n        int a=nums.size();\\n        for(int i=0;i<a;i++)\\n            for(int j=i+1;j<a;j++)\\n            {\\n                if(nums[i]==nums[j])\\n                count++;\\n            }\\n        return count;    \\n    }"
                    },
                    {
                        "username": "Razzzzzzzzz",
                        "content": "`class Solution:`\\n    `def numIdenticalPairs(self, nums: List[int]) -> int:`\\n        `list_num  = []`\\n        `for i in range(len(nums)):`\\n            `for j in range(i+1,len(nums)):`\\n                `if nums[i] == nums[j]:`\\n                    `list_num.append(1)`\\n        `return len(list_num)`"
                    },
                    {
                        "username": "priyasha_ivy",
                        "content": "I have used the sorting to sort the array following pointing the i at zero innitially and incrementing the j the difference between j and i till the array numbers are same if they are different then the i will increase. suppose in first case it [1,2,3,1,1,3] so after sorting its [1,1,1,2,3,3] so while the i = 0; j will move forward with count adding 1 each time once j reaches the 3rd index the else condition will change i = 2  and so on till j is less than the size of array. `your inline code...your inline code...` [leetcode](https://leetcode.com)"
                    },
                    {
                        "username": "CudCude",
                        "content": "Approach of linear space and time\\n\\nThink you are at an index i. How many good pairs you can make using nums[i]?\\nIn terms of left or right side............\\n\\n\\n\\nIf not able to figure out, read this.....\\n\\nIf I talk about from left to right in nums, then we will find that the number of good pairs will be the number of same elements as nums[i] on the right side of ith index. \\n\\nBecause nums[i] will make as many pairs as there are number of same elements on the right side.\\n\\nNow just sum up for every index from left to right and you got the answer.\\n\\nNote: same approach can be applied from right to left.\\n\\n\\nSorry for bad english. \\nThanks........"
                    },
                    {
                        "username": "Abhay_45",
                        "content": "class Solution {\\npublic:\\n    int numIdenticalPairs(vector<int>& nums) {\\n        \\n        int cnt=0;\\n        for (int i=0;i<nums.size();i++){\\n            for(int j=i+1;j<nums.size();j++){\\n                if(nums[i]==nums[j])\\n                cnt++;\\n            }\\n\\n        }\\n        return cnt;\\n    }\\n};"
                    }
                ]
            },
            {
                "id": 1820535,
                "content": [
                    {
                        "username": "pratikyadav8319",
                        "content": "ans is hidden in the que. just take 2 for loop first i for first element iteration and for 2nd element take j ; initialize j = 0+i in for loop so that j is always +1 from i and the apply condition according to the program / question (given)  and count the pairs you can create a ans = 0 int and count in it "
                    },
                    {
                        "username": "manish_j21",
                        "content": "to solve this problem first we will get the frequency of each element of array and then we will see how many combinations can be formed by them(nC2)here the value of nC2 will we n*(n-1)/2 and all the elements frequency combinations"
                    },
                    {
                        "username": "devesh_kumar_kushwaha",
                        "content": "\\uD83D\\uDFE2 no of pairs which can be possible from n equal elements equal to (n*(n-1))/2"
                    },
                    {
                        "username": "a_andreasian",
                        "content": "I don\\'t know how others solved, but in terms of time consumption and complexity - it should not be easy. Yes, there are no tricky test cases, or I just built an ultimate algorithm, \\nhowever, this is not easy. "
                    },
                    {
                        "username": "krushil1776",
                        "content": "  int count =0;\\n         for(int i=0;i<nums.length;i++){\\n             for(int j=i+1;j<nums.length;j++){\\n                 if(nums[i]=nums[j]){\\n                     count++;\\n\\n                 }\\n             }\\n         }\\nreturn count;   **************************simple java "
                    },
                    {
                        "username": "rishavpramanik17",
                        "content": "Simple C++ Solution :\\nint numIdenticalPairs(vector<int>& nums) {\\n        int count=0;\\n        int a=nums.size();\\n        for(int i=0;i<a;i++)\\n            for(int j=i+1;j<a;j++)\\n            {\\n                if(nums[i]==nums[j])\\n                count++;\\n            }\\n        return count;    \\n    }"
                    },
                    {
                        "username": "Razzzzzzzzz",
                        "content": "`class Solution:`\\n    `def numIdenticalPairs(self, nums: List[int]) -> int:`\\n        `list_num  = []`\\n        `for i in range(len(nums)):`\\n            `for j in range(i+1,len(nums)):`\\n                `if nums[i] == nums[j]:`\\n                    `list_num.append(1)`\\n        `return len(list_num)`"
                    },
                    {
                        "username": "priyasha_ivy",
                        "content": "I have used the sorting to sort the array following pointing the i at zero innitially and incrementing the j the difference between j and i till the array numbers are same if they are different then the i will increase. suppose in first case it [1,2,3,1,1,3] so after sorting its [1,1,1,2,3,3] so while the i = 0; j will move forward with count adding 1 each time once j reaches the 3rd index the else condition will change i = 2  and so on till j is less than the size of array. `your inline code...your inline code...` [leetcode](https://leetcode.com)"
                    },
                    {
                        "username": "CudCude",
                        "content": "Approach of linear space and time\\n\\nThink you are at an index i. How many good pairs you can make using nums[i]?\\nIn terms of left or right side............\\n\\n\\n\\nIf not able to figure out, read this.....\\n\\nIf I talk about from left to right in nums, then we will find that the number of good pairs will be the number of same elements as nums[i] on the right side of ith index. \\n\\nBecause nums[i] will make as many pairs as there are number of same elements on the right side.\\n\\nNow just sum up for every index from left to right and you got the answer.\\n\\nNote: same approach can be applied from right to left.\\n\\n\\nSorry for bad english. \\nThanks........"
                    },
                    {
                        "username": "Abhay_45",
                        "content": "class Solution {\\npublic:\\n    int numIdenticalPairs(vector<int>& nums) {\\n        \\n        int cnt=0;\\n        for (int i=0;i<nums.size();i++){\\n            for(int j=i+1;j<nums.size();j++){\\n                if(nums[i]==nums[j])\\n                cnt++;\\n            }\\n\\n        }\\n        return cnt;\\n    }\\n};"
                    }
                ]
            },
            {
                "id": 1801889,
                "content": [
                    {
                        "username": "imranansari9835",
                        "content": "Java:\\nclass Solution {\\n    public int numIdenticalPairs(int[] nums) {\\n        int x = 0;\\n        for (int i =0;i< nums.length;i++){\\n            for (int j = i; j < nums.length; j++) {\\n                if(nums[i] == nums[j] && i < j){\\n                    x++;\\n                }\\n            }\\n        }\\n        return x;\\n\\n    }\\n}\\n"
                    },
                    {
                        "username": "Kalpit_Rathi",
                        "content": "100% faster solution in java || very easy\\n\\nclass Solution {\\n    public int numIdenticalPairs(int[] nums) {\\n        int[] ans = new int[101];\\n        int count = 0;\\n\\n        for (int i = 0; i < nums.length; i++)\\n        {   \\n            count += ans[nums[i]];\\n            ans[nums[i]]++;\\n        }\\n\\n        return count;\\n    }\\n}"
                    },
                    {
                        "username": "Yash_0000",
                        "content": "use two pointer.\\n"
                    },
                    {
                        "username": "Yash_0000",
                        "content": "class Solution {\\n    public int numIdenticalPairs(int[] nums) {\\n        int count = 0;\\n        for(int i=0;i<nums.length;i++)\\n        {\\n            for(int j=i+1;j<nums.length;j++)\\n            {\\n                if(nums[i] == nums[j])\\n                count++;\\n            }\\n        } \\n        return count;\\n    }\\n}"
                    },
                    {
                        "username": "FaraiMajor",
                        "content": "the question is so vague. i dont understand what the question even mean. what is (i,j). their explanation is mediocre at best"
                    },
                    {
                        "username": "deleted_user",
                        "content": "Python Solution\\n\\nclass Solution:\\n    def numIdenticalPairs(self, nums: List[int]) -> int:\\n        count = 0\\n        for i in range(len(nums)-1):\\n            for j in range(i+1,len(nums)):\\n                if nums[i] == nums[j]:\\n                    count += 1\\n        return count"
                    },
                    {
                        "username": "ayushshuklas",
                        "content": "c++ O(n) using unordered_map \\n \\n`class Solution {\\npublic:\\n    int numIdenticalPairs(vector<int>& nums) {\\n        // sort(nums.bengin(),nums.end());\\n\\n        unordered_map<int,int> m;\\n\\n        for(auto it : nums)\\n        {\\n            m[it]++;\\n        }\\nint p = 0;\\n        for(auto it : m)\\n        {\\n            if(it.second > 1)\\n            {\\n                int n = it.second;\\n                p = p +  (n*(n-1))/2;\\n            }\\n        }\\n        return p;\\n    }\\n};`"
                    },
                    {
                        "username": "TheViking7",
                        "content": "calculating the frequency of  a number determines the no of pairs. "
                    },
                    {
                        "username": "deepdubey1995",
                        "content": "What is wrong in this code\\nclass Solution {\\n    public int numIdenticalPairs(int[] nums) {\\n        int count=0;\\n        int i=0;\\n        int j=nums.length-1;\\n        while(i<j){\\n            if(nums[i]==nums[j]){\\n                count++;\\n                j--;\\n            }\\n            else if(i>=j){\\n                i++;\\n                j=nums.length-1;\\n            }\\n            else\\n                j--;\\n        }\\n        return count;\\n    }      \\n}"
                    },
                    {
                        "username": "Bayervilligar",
                        "content": "  for(int i=0;i<nums.size();i++)\\n        {\\n            \\n                for(int j=0;j<nums.size();j++)\\n                {\\n                    if(nums[i]==nums[j] && i<j)\\n                     {\\n                        count++;\\n                     }\\n                }\\n                    \\n        }\\n\\nSEE THE ABOVE CODE I AM NOT POSTING THE COMPLETE SOLUTION THOUGH I THINK THIS APPROACH IS AN EASY ONE...JUST INTRODUCE A COUNT VARIABLE WHICH WILL KEEP THE COUNT OF GOOD PAIRS AND JUST USE THESE 2 NESTED LOOPS FOR TRAVERSING AND COMPARING EACH ELEMENT...\\nTHANKYOU...I HOPE IT HELPS"
                    }
                ]
            },
            {
                "id": 1783702,
                "content": [
                    {
                        "username": "imranansari9835",
                        "content": "Java:\\nclass Solution {\\n    public int numIdenticalPairs(int[] nums) {\\n        int x = 0;\\n        for (int i =0;i< nums.length;i++){\\n            for (int j = i; j < nums.length; j++) {\\n                if(nums[i] == nums[j] && i < j){\\n                    x++;\\n                }\\n            }\\n        }\\n        return x;\\n\\n    }\\n}\\n"
                    },
                    {
                        "username": "Kalpit_Rathi",
                        "content": "100% faster solution in java || very easy\\n\\nclass Solution {\\n    public int numIdenticalPairs(int[] nums) {\\n        int[] ans = new int[101];\\n        int count = 0;\\n\\n        for (int i = 0; i < nums.length; i++)\\n        {   \\n            count += ans[nums[i]];\\n            ans[nums[i]]++;\\n        }\\n\\n        return count;\\n    }\\n}"
                    },
                    {
                        "username": "Yash_0000",
                        "content": "use two pointer.\\n"
                    },
                    {
                        "username": "Yash_0000",
                        "content": "class Solution {\\n    public int numIdenticalPairs(int[] nums) {\\n        int count = 0;\\n        for(int i=0;i<nums.length;i++)\\n        {\\n            for(int j=i+1;j<nums.length;j++)\\n            {\\n                if(nums[i] == nums[j])\\n                count++;\\n            }\\n        } \\n        return count;\\n    }\\n}"
                    },
                    {
                        "username": "FaraiMajor",
                        "content": "the question is so vague. i dont understand what the question even mean. what is (i,j). their explanation is mediocre at best"
                    },
                    {
                        "username": "deleted_user",
                        "content": "Python Solution\\n\\nclass Solution:\\n    def numIdenticalPairs(self, nums: List[int]) -> int:\\n        count = 0\\n        for i in range(len(nums)-1):\\n            for j in range(i+1,len(nums)):\\n                if nums[i] == nums[j]:\\n                    count += 1\\n        return count"
                    },
                    {
                        "username": "ayushshuklas",
                        "content": "c++ O(n) using unordered_map \\n \\n`class Solution {\\npublic:\\n    int numIdenticalPairs(vector<int>& nums) {\\n        // sort(nums.bengin(),nums.end());\\n\\n        unordered_map<int,int> m;\\n\\n        for(auto it : nums)\\n        {\\n            m[it]++;\\n        }\\nint p = 0;\\n        for(auto it : m)\\n        {\\n            if(it.second > 1)\\n            {\\n                int n = it.second;\\n                p = p +  (n*(n-1))/2;\\n            }\\n        }\\n        return p;\\n    }\\n};`"
                    },
                    {
                        "username": "TheViking7",
                        "content": "calculating the frequency of  a number determines the no of pairs. "
                    },
                    {
                        "username": "deepdubey1995",
                        "content": "What is wrong in this code\\nclass Solution {\\n    public int numIdenticalPairs(int[] nums) {\\n        int count=0;\\n        int i=0;\\n        int j=nums.length-1;\\n        while(i<j){\\n            if(nums[i]==nums[j]){\\n                count++;\\n                j--;\\n            }\\n            else if(i>=j){\\n                i++;\\n                j=nums.length-1;\\n            }\\n            else\\n                j--;\\n        }\\n        return count;\\n    }      \\n}"
                    },
                    {
                        "username": "Bayervilligar",
                        "content": "  for(int i=0;i<nums.size();i++)\\n        {\\n            \\n                for(int j=0;j<nums.size();j++)\\n                {\\n                    if(nums[i]==nums[j] && i<j)\\n                     {\\n                        count++;\\n                     }\\n                }\\n                    \\n        }\\n\\nSEE THE ABOVE CODE I AM NOT POSTING THE COMPLETE SOLUTION THOUGH I THINK THIS APPROACH IS AN EASY ONE...JUST INTRODUCE A COUNT VARIABLE WHICH WILL KEEP THE COUNT OF GOOD PAIRS AND JUST USE THESE 2 NESTED LOOPS FOR TRAVERSING AND COMPARING EACH ELEMENT...\\nTHANKYOU...I HOPE IT HELPS"
                    }
                ]
            },
            {
                "id": 1778125,
                "content": [
                    {
                        "username": "imranansari9835",
                        "content": "Java:\\nclass Solution {\\n    public int numIdenticalPairs(int[] nums) {\\n        int x = 0;\\n        for (int i =0;i< nums.length;i++){\\n            for (int j = i; j < nums.length; j++) {\\n                if(nums[i] == nums[j] && i < j){\\n                    x++;\\n                }\\n            }\\n        }\\n        return x;\\n\\n    }\\n}\\n"
                    },
                    {
                        "username": "Kalpit_Rathi",
                        "content": "100% faster solution in java || very easy\\n\\nclass Solution {\\n    public int numIdenticalPairs(int[] nums) {\\n        int[] ans = new int[101];\\n        int count = 0;\\n\\n        for (int i = 0; i < nums.length; i++)\\n        {   \\n            count += ans[nums[i]];\\n            ans[nums[i]]++;\\n        }\\n\\n        return count;\\n    }\\n}"
                    },
                    {
                        "username": "Yash_0000",
                        "content": "use two pointer.\\n"
                    },
                    {
                        "username": "Yash_0000",
                        "content": "class Solution {\\n    public int numIdenticalPairs(int[] nums) {\\n        int count = 0;\\n        for(int i=0;i<nums.length;i++)\\n        {\\n            for(int j=i+1;j<nums.length;j++)\\n            {\\n                if(nums[i] == nums[j])\\n                count++;\\n            }\\n        } \\n        return count;\\n    }\\n}"
                    },
                    {
                        "username": "FaraiMajor",
                        "content": "the question is so vague. i dont understand what the question even mean. what is (i,j). their explanation is mediocre at best"
                    },
                    {
                        "username": "deleted_user",
                        "content": "Python Solution\\n\\nclass Solution:\\n    def numIdenticalPairs(self, nums: List[int]) -> int:\\n        count = 0\\n        for i in range(len(nums)-1):\\n            for j in range(i+1,len(nums)):\\n                if nums[i] == nums[j]:\\n                    count += 1\\n        return count"
                    },
                    {
                        "username": "ayushshuklas",
                        "content": "c++ O(n) using unordered_map \\n \\n`class Solution {\\npublic:\\n    int numIdenticalPairs(vector<int>& nums) {\\n        // sort(nums.bengin(),nums.end());\\n\\n        unordered_map<int,int> m;\\n\\n        for(auto it : nums)\\n        {\\n            m[it]++;\\n        }\\nint p = 0;\\n        for(auto it : m)\\n        {\\n            if(it.second > 1)\\n            {\\n                int n = it.second;\\n                p = p +  (n*(n-1))/2;\\n            }\\n        }\\n        return p;\\n    }\\n};`"
                    },
                    {
                        "username": "TheViking7",
                        "content": "calculating the frequency of  a number determines the no of pairs. "
                    },
                    {
                        "username": "deepdubey1995",
                        "content": "What is wrong in this code\\nclass Solution {\\n    public int numIdenticalPairs(int[] nums) {\\n        int count=0;\\n        int i=0;\\n        int j=nums.length-1;\\n        while(i<j){\\n            if(nums[i]==nums[j]){\\n                count++;\\n                j--;\\n            }\\n            else if(i>=j){\\n                i++;\\n                j=nums.length-1;\\n            }\\n            else\\n                j--;\\n        }\\n        return count;\\n    }      \\n}"
                    },
                    {
                        "username": "Bayervilligar",
                        "content": "  for(int i=0;i<nums.size();i++)\\n        {\\n            \\n                for(int j=0;j<nums.size();j++)\\n                {\\n                    if(nums[i]==nums[j] && i<j)\\n                     {\\n                        count++;\\n                     }\\n                }\\n                    \\n        }\\n\\nSEE THE ABOVE CODE I AM NOT POSTING THE COMPLETE SOLUTION THOUGH I THINK THIS APPROACH IS AN EASY ONE...JUST INTRODUCE A COUNT VARIABLE WHICH WILL KEEP THE COUNT OF GOOD PAIRS AND JUST USE THESE 2 NESTED LOOPS FOR TRAVERSING AND COMPARING EACH ELEMENT...\\nTHANKYOU...I HOPE IT HELPS"
                    }
                ]
            },
            {
                "id": 1778122,
                "content": [
                    {
                        "username": "imranansari9835",
                        "content": "Java:\\nclass Solution {\\n    public int numIdenticalPairs(int[] nums) {\\n        int x = 0;\\n        for (int i =0;i< nums.length;i++){\\n            for (int j = i; j < nums.length; j++) {\\n                if(nums[i] == nums[j] && i < j){\\n                    x++;\\n                }\\n            }\\n        }\\n        return x;\\n\\n    }\\n}\\n"
                    },
                    {
                        "username": "Kalpit_Rathi",
                        "content": "100% faster solution in java || very easy\\n\\nclass Solution {\\n    public int numIdenticalPairs(int[] nums) {\\n        int[] ans = new int[101];\\n        int count = 0;\\n\\n        for (int i = 0; i < nums.length; i++)\\n        {   \\n            count += ans[nums[i]];\\n            ans[nums[i]]++;\\n        }\\n\\n        return count;\\n    }\\n}"
                    },
                    {
                        "username": "Yash_0000",
                        "content": "use two pointer.\\n"
                    },
                    {
                        "username": "Yash_0000",
                        "content": "class Solution {\\n    public int numIdenticalPairs(int[] nums) {\\n        int count = 0;\\n        for(int i=0;i<nums.length;i++)\\n        {\\n            for(int j=i+1;j<nums.length;j++)\\n            {\\n                if(nums[i] == nums[j])\\n                count++;\\n            }\\n        } \\n        return count;\\n    }\\n}"
                    },
                    {
                        "username": "FaraiMajor",
                        "content": "the question is so vague. i dont understand what the question even mean. what is (i,j). their explanation is mediocre at best"
                    },
                    {
                        "username": "deleted_user",
                        "content": "Python Solution\\n\\nclass Solution:\\n    def numIdenticalPairs(self, nums: List[int]) -> int:\\n        count = 0\\n        for i in range(len(nums)-1):\\n            for j in range(i+1,len(nums)):\\n                if nums[i] == nums[j]:\\n                    count += 1\\n        return count"
                    },
                    {
                        "username": "ayushshuklas",
                        "content": "c++ O(n) using unordered_map \\n \\n`class Solution {\\npublic:\\n    int numIdenticalPairs(vector<int>& nums) {\\n        // sort(nums.bengin(),nums.end());\\n\\n        unordered_map<int,int> m;\\n\\n        for(auto it : nums)\\n        {\\n            m[it]++;\\n        }\\nint p = 0;\\n        for(auto it : m)\\n        {\\n            if(it.second > 1)\\n            {\\n                int n = it.second;\\n                p = p +  (n*(n-1))/2;\\n            }\\n        }\\n        return p;\\n    }\\n};`"
                    },
                    {
                        "username": "TheViking7",
                        "content": "calculating the frequency of  a number determines the no of pairs. "
                    },
                    {
                        "username": "deepdubey1995",
                        "content": "What is wrong in this code\\nclass Solution {\\n    public int numIdenticalPairs(int[] nums) {\\n        int count=0;\\n        int i=0;\\n        int j=nums.length-1;\\n        while(i<j){\\n            if(nums[i]==nums[j]){\\n                count++;\\n                j--;\\n            }\\n            else if(i>=j){\\n                i++;\\n                j=nums.length-1;\\n            }\\n            else\\n                j--;\\n        }\\n        return count;\\n    }      \\n}"
                    },
                    {
                        "username": "Bayervilligar",
                        "content": "  for(int i=0;i<nums.size();i++)\\n        {\\n            \\n                for(int j=0;j<nums.size();j++)\\n                {\\n                    if(nums[i]==nums[j] && i<j)\\n                     {\\n                        count++;\\n                     }\\n                }\\n                    \\n        }\\n\\nSEE THE ABOVE CODE I AM NOT POSTING THE COMPLETE SOLUTION THOUGH I THINK THIS APPROACH IS AN EASY ONE...JUST INTRODUCE A COUNT VARIABLE WHICH WILL KEEP THE COUNT OF GOOD PAIRS AND JUST USE THESE 2 NESTED LOOPS FOR TRAVERSING AND COMPARING EACH ELEMENT...\\nTHANKYOU...I HOPE IT HELPS"
                    }
                ]
            },
            {
                "id": 1752985,
                "content": [
                    {
                        "username": "imranansari9835",
                        "content": "Java:\\nclass Solution {\\n    public int numIdenticalPairs(int[] nums) {\\n        int x = 0;\\n        for (int i =0;i< nums.length;i++){\\n            for (int j = i; j < nums.length; j++) {\\n                if(nums[i] == nums[j] && i < j){\\n                    x++;\\n                }\\n            }\\n        }\\n        return x;\\n\\n    }\\n}\\n"
                    },
                    {
                        "username": "Kalpit_Rathi",
                        "content": "100% faster solution in java || very easy\\n\\nclass Solution {\\n    public int numIdenticalPairs(int[] nums) {\\n        int[] ans = new int[101];\\n        int count = 0;\\n\\n        for (int i = 0; i < nums.length; i++)\\n        {   \\n            count += ans[nums[i]];\\n            ans[nums[i]]++;\\n        }\\n\\n        return count;\\n    }\\n}"
                    },
                    {
                        "username": "Yash_0000",
                        "content": "use two pointer.\\n"
                    },
                    {
                        "username": "Yash_0000",
                        "content": "class Solution {\\n    public int numIdenticalPairs(int[] nums) {\\n        int count = 0;\\n        for(int i=0;i<nums.length;i++)\\n        {\\n            for(int j=i+1;j<nums.length;j++)\\n            {\\n                if(nums[i] == nums[j])\\n                count++;\\n            }\\n        } \\n        return count;\\n    }\\n}"
                    },
                    {
                        "username": "FaraiMajor",
                        "content": "the question is so vague. i dont understand what the question even mean. what is (i,j). their explanation is mediocre at best"
                    },
                    {
                        "username": "deleted_user",
                        "content": "Python Solution\\n\\nclass Solution:\\n    def numIdenticalPairs(self, nums: List[int]) -> int:\\n        count = 0\\n        for i in range(len(nums)-1):\\n            for j in range(i+1,len(nums)):\\n                if nums[i] == nums[j]:\\n                    count += 1\\n        return count"
                    },
                    {
                        "username": "ayushshuklas",
                        "content": "c++ O(n) using unordered_map \\n \\n`class Solution {\\npublic:\\n    int numIdenticalPairs(vector<int>& nums) {\\n        // sort(nums.bengin(),nums.end());\\n\\n        unordered_map<int,int> m;\\n\\n        for(auto it : nums)\\n        {\\n            m[it]++;\\n        }\\nint p = 0;\\n        for(auto it : m)\\n        {\\n            if(it.second > 1)\\n            {\\n                int n = it.second;\\n                p = p +  (n*(n-1))/2;\\n            }\\n        }\\n        return p;\\n    }\\n};`"
                    },
                    {
                        "username": "TheViking7",
                        "content": "calculating the frequency of  a number determines the no of pairs. "
                    },
                    {
                        "username": "deepdubey1995",
                        "content": "What is wrong in this code\\nclass Solution {\\n    public int numIdenticalPairs(int[] nums) {\\n        int count=0;\\n        int i=0;\\n        int j=nums.length-1;\\n        while(i<j){\\n            if(nums[i]==nums[j]){\\n                count++;\\n                j--;\\n            }\\n            else if(i>=j){\\n                i++;\\n                j=nums.length-1;\\n            }\\n            else\\n                j--;\\n        }\\n        return count;\\n    }      \\n}"
                    },
                    {
                        "username": "Bayervilligar",
                        "content": "  for(int i=0;i<nums.size();i++)\\n        {\\n            \\n                for(int j=0;j<nums.size();j++)\\n                {\\n                    if(nums[i]==nums[j] && i<j)\\n                     {\\n                        count++;\\n                     }\\n                }\\n                    \\n        }\\n\\nSEE THE ABOVE CODE I AM NOT POSTING THE COMPLETE SOLUTION THOUGH I THINK THIS APPROACH IS AN EASY ONE...JUST INTRODUCE A COUNT VARIABLE WHICH WILL KEEP THE COUNT OF GOOD PAIRS AND JUST USE THESE 2 NESTED LOOPS FOR TRAVERSING AND COMPARING EACH ELEMENT...\\nTHANKYOU...I HOPE IT HELPS"
                    }
                ]
            },
            {
                "id": 1748692,
                "content": [
                    {
                        "username": "imranansari9835",
                        "content": "Java:\\nclass Solution {\\n    public int numIdenticalPairs(int[] nums) {\\n        int x = 0;\\n        for (int i =0;i< nums.length;i++){\\n            for (int j = i; j < nums.length; j++) {\\n                if(nums[i] == nums[j] && i < j){\\n                    x++;\\n                }\\n            }\\n        }\\n        return x;\\n\\n    }\\n}\\n"
                    },
                    {
                        "username": "Kalpit_Rathi",
                        "content": "100% faster solution in java || very easy\\n\\nclass Solution {\\n    public int numIdenticalPairs(int[] nums) {\\n        int[] ans = new int[101];\\n        int count = 0;\\n\\n        for (int i = 0; i < nums.length; i++)\\n        {   \\n            count += ans[nums[i]];\\n            ans[nums[i]]++;\\n        }\\n\\n        return count;\\n    }\\n}"
                    },
                    {
                        "username": "Yash_0000",
                        "content": "use two pointer.\\n"
                    },
                    {
                        "username": "Yash_0000",
                        "content": "class Solution {\\n    public int numIdenticalPairs(int[] nums) {\\n        int count = 0;\\n        for(int i=0;i<nums.length;i++)\\n        {\\n            for(int j=i+1;j<nums.length;j++)\\n            {\\n                if(nums[i] == nums[j])\\n                count++;\\n            }\\n        } \\n        return count;\\n    }\\n}"
                    },
                    {
                        "username": "FaraiMajor",
                        "content": "the question is so vague. i dont understand what the question even mean. what is (i,j). their explanation is mediocre at best"
                    },
                    {
                        "username": "deleted_user",
                        "content": "Python Solution\\n\\nclass Solution:\\n    def numIdenticalPairs(self, nums: List[int]) -> int:\\n        count = 0\\n        for i in range(len(nums)-1):\\n            for j in range(i+1,len(nums)):\\n                if nums[i] == nums[j]:\\n                    count += 1\\n        return count"
                    },
                    {
                        "username": "ayushshuklas",
                        "content": "c++ O(n) using unordered_map \\n \\n`class Solution {\\npublic:\\n    int numIdenticalPairs(vector<int>& nums) {\\n        // sort(nums.bengin(),nums.end());\\n\\n        unordered_map<int,int> m;\\n\\n        for(auto it : nums)\\n        {\\n            m[it]++;\\n        }\\nint p = 0;\\n        for(auto it : m)\\n        {\\n            if(it.second > 1)\\n            {\\n                int n = it.second;\\n                p = p +  (n*(n-1))/2;\\n            }\\n        }\\n        return p;\\n    }\\n};`"
                    },
                    {
                        "username": "TheViking7",
                        "content": "calculating the frequency of  a number determines the no of pairs. "
                    },
                    {
                        "username": "deepdubey1995",
                        "content": "What is wrong in this code\\nclass Solution {\\n    public int numIdenticalPairs(int[] nums) {\\n        int count=0;\\n        int i=0;\\n        int j=nums.length-1;\\n        while(i<j){\\n            if(nums[i]==nums[j]){\\n                count++;\\n                j--;\\n            }\\n            else if(i>=j){\\n                i++;\\n                j=nums.length-1;\\n            }\\n            else\\n                j--;\\n        }\\n        return count;\\n    }      \\n}"
                    },
                    {
                        "username": "Bayervilligar",
                        "content": "  for(int i=0;i<nums.size();i++)\\n        {\\n            \\n                for(int j=0;j<nums.size();j++)\\n                {\\n                    if(nums[i]==nums[j] && i<j)\\n                     {\\n                        count++;\\n                     }\\n                }\\n                    \\n        }\\n\\nSEE THE ABOVE CODE I AM NOT POSTING THE COMPLETE SOLUTION THOUGH I THINK THIS APPROACH IS AN EASY ONE...JUST INTRODUCE A COUNT VARIABLE WHICH WILL KEEP THE COUNT OF GOOD PAIRS AND JUST USE THESE 2 NESTED LOOPS FOR TRAVERSING AND COMPARING EACH ELEMENT...\\nTHANKYOU...I HOPE IT HELPS"
                    }
                ]
            },
            {
                "id": 1744198,
                "content": [
                    {
                        "username": "imranansari9835",
                        "content": "Java:\\nclass Solution {\\n    public int numIdenticalPairs(int[] nums) {\\n        int x = 0;\\n        for (int i =0;i< nums.length;i++){\\n            for (int j = i; j < nums.length; j++) {\\n                if(nums[i] == nums[j] && i < j){\\n                    x++;\\n                }\\n            }\\n        }\\n        return x;\\n\\n    }\\n}\\n"
                    },
                    {
                        "username": "Kalpit_Rathi",
                        "content": "100% faster solution in java || very easy\\n\\nclass Solution {\\n    public int numIdenticalPairs(int[] nums) {\\n        int[] ans = new int[101];\\n        int count = 0;\\n\\n        for (int i = 0; i < nums.length; i++)\\n        {   \\n            count += ans[nums[i]];\\n            ans[nums[i]]++;\\n        }\\n\\n        return count;\\n    }\\n}"
                    },
                    {
                        "username": "Yash_0000",
                        "content": "use two pointer.\\n"
                    },
                    {
                        "username": "Yash_0000",
                        "content": "class Solution {\\n    public int numIdenticalPairs(int[] nums) {\\n        int count = 0;\\n        for(int i=0;i<nums.length;i++)\\n        {\\n            for(int j=i+1;j<nums.length;j++)\\n            {\\n                if(nums[i] == nums[j])\\n                count++;\\n            }\\n        } \\n        return count;\\n    }\\n}"
                    },
                    {
                        "username": "FaraiMajor",
                        "content": "the question is so vague. i dont understand what the question even mean. what is (i,j). their explanation is mediocre at best"
                    },
                    {
                        "username": "deleted_user",
                        "content": "Python Solution\\n\\nclass Solution:\\n    def numIdenticalPairs(self, nums: List[int]) -> int:\\n        count = 0\\n        for i in range(len(nums)-1):\\n            for j in range(i+1,len(nums)):\\n                if nums[i] == nums[j]:\\n                    count += 1\\n        return count"
                    },
                    {
                        "username": "ayushshuklas",
                        "content": "c++ O(n) using unordered_map \\n \\n`class Solution {\\npublic:\\n    int numIdenticalPairs(vector<int>& nums) {\\n        // sort(nums.bengin(),nums.end());\\n\\n        unordered_map<int,int> m;\\n\\n        for(auto it : nums)\\n        {\\n            m[it]++;\\n        }\\nint p = 0;\\n        for(auto it : m)\\n        {\\n            if(it.second > 1)\\n            {\\n                int n = it.second;\\n                p = p +  (n*(n-1))/2;\\n            }\\n        }\\n        return p;\\n    }\\n};`"
                    },
                    {
                        "username": "TheViking7",
                        "content": "calculating the frequency of  a number determines the no of pairs. "
                    },
                    {
                        "username": "deepdubey1995",
                        "content": "What is wrong in this code\\nclass Solution {\\n    public int numIdenticalPairs(int[] nums) {\\n        int count=0;\\n        int i=0;\\n        int j=nums.length-1;\\n        while(i<j){\\n            if(nums[i]==nums[j]){\\n                count++;\\n                j--;\\n            }\\n            else if(i>=j){\\n                i++;\\n                j=nums.length-1;\\n            }\\n            else\\n                j--;\\n        }\\n        return count;\\n    }      \\n}"
                    },
                    {
                        "username": "Bayervilligar",
                        "content": "  for(int i=0;i<nums.size();i++)\\n        {\\n            \\n                for(int j=0;j<nums.size();j++)\\n                {\\n                    if(nums[i]==nums[j] && i<j)\\n                     {\\n                        count++;\\n                     }\\n                }\\n                    \\n        }\\n\\nSEE THE ABOVE CODE I AM NOT POSTING THE COMPLETE SOLUTION THOUGH I THINK THIS APPROACH IS AN EASY ONE...JUST INTRODUCE A COUNT VARIABLE WHICH WILL KEEP THE COUNT OF GOOD PAIRS AND JUST USE THESE 2 NESTED LOOPS FOR TRAVERSING AND COMPARING EACH ELEMENT...\\nTHANKYOU...I HOPE IT HELPS"
                    }
                ]
            },
            {
                "id": 1742060,
                "content": [
                    {
                        "username": "imranansari9835",
                        "content": "Java:\\nclass Solution {\\n    public int numIdenticalPairs(int[] nums) {\\n        int x = 0;\\n        for (int i =0;i< nums.length;i++){\\n            for (int j = i; j < nums.length; j++) {\\n                if(nums[i] == nums[j] && i < j){\\n                    x++;\\n                }\\n            }\\n        }\\n        return x;\\n\\n    }\\n}\\n"
                    },
                    {
                        "username": "Kalpit_Rathi",
                        "content": "100% faster solution in java || very easy\\n\\nclass Solution {\\n    public int numIdenticalPairs(int[] nums) {\\n        int[] ans = new int[101];\\n        int count = 0;\\n\\n        for (int i = 0; i < nums.length; i++)\\n        {   \\n            count += ans[nums[i]];\\n            ans[nums[i]]++;\\n        }\\n\\n        return count;\\n    }\\n}"
                    },
                    {
                        "username": "Yash_0000",
                        "content": "use two pointer.\\n"
                    },
                    {
                        "username": "Yash_0000",
                        "content": "class Solution {\\n    public int numIdenticalPairs(int[] nums) {\\n        int count = 0;\\n        for(int i=0;i<nums.length;i++)\\n        {\\n            for(int j=i+1;j<nums.length;j++)\\n            {\\n                if(nums[i] == nums[j])\\n                count++;\\n            }\\n        } \\n        return count;\\n    }\\n}"
                    },
                    {
                        "username": "FaraiMajor",
                        "content": "the question is so vague. i dont understand what the question even mean. what is (i,j). their explanation is mediocre at best"
                    },
                    {
                        "username": "deleted_user",
                        "content": "Python Solution\\n\\nclass Solution:\\n    def numIdenticalPairs(self, nums: List[int]) -> int:\\n        count = 0\\n        for i in range(len(nums)-1):\\n            for j in range(i+1,len(nums)):\\n                if nums[i] == nums[j]:\\n                    count += 1\\n        return count"
                    },
                    {
                        "username": "ayushshuklas",
                        "content": "c++ O(n) using unordered_map \\n \\n`class Solution {\\npublic:\\n    int numIdenticalPairs(vector<int>& nums) {\\n        // sort(nums.bengin(),nums.end());\\n\\n        unordered_map<int,int> m;\\n\\n        for(auto it : nums)\\n        {\\n            m[it]++;\\n        }\\nint p = 0;\\n        for(auto it : m)\\n        {\\n            if(it.second > 1)\\n            {\\n                int n = it.second;\\n                p = p +  (n*(n-1))/2;\\n            }\\n        }\\n        return p;\\n    }\\n};`"
                    },
                    {
                        "username": "TheViking7",
                        "content": "calculating the frequency of  a number determines the no of pairs. "
                    },
                    {
                        "username": "deepdubey1995",
                        "content": "What is wrong in this code\\nclass Solution {\\n    public int numIdenticalPairs(int[] nums) {\\n        int count=0;\\n        int i=0;\\n        int j=nums.length-1;\\n        while(i<j){\\n            if(nums[i]==nums[j]){\\n                count++;\\n                j--;\\n            }\\n            else if(i>=j){\\n                i++;\\n                j=nums.length-1;\\n            }\\n            else\\n                j--;\\n        }\\n        return count;\\n    }      \\n}"
                    },
                    {
                        "username": "Bayervilligar",
                        "content": "  for(int i=0;i<nums.size();i++)\\n        {\\n            \\n                for(int j=0;j<nums.size();j++)\\n                {\\n                    if(nums[i]==nums[j] && i<j)\\n                     {\\n                        count++;\\n                     }\\n                }\\n                    \\n        }\\n\\nSEE THE ABOVE CODE I AM NOT POSTING THE COMPLETE SOLUTION THOUGH I THINK THIS APPROACH IS AN EASY ONE...JUST INTRODUCE A COUNT VARIABLE WHICH WILL KEEP THE COUNT OF GOOD PAIRS AND JUST USE THESE 2 NESTED LOOPS FOR TRAVERSING AND COMPARING EACH ELEMENT...\\nTHANKYOU...I HOPE IT HELPS"
                    }
                ]
            },
            {
                "id": 1740071,
                "content": [
                    {
                        "username": "imranansari9835",
                        "content": "Java:\\nclass Solution {\\n    public int numIdenticalPairs(int[] nums) {\\n        int x = 0;\\n        for (int i =0;i< nums.length;i++){\\n            for (int j = i; j < nums.length; j++) {\\n                if(nums[i] == nums[j] && i < j){\\n                    x++;\\n                }\\n            }\\n        }\\n        return x;\\n\\n    }\\n}\\n"
                    },
                    {
                        "username": "Kalpit_Rathi",
                        "content": "100% faster solution in java || very easy\\n\\nclass Solution {\\n    public int numIdenticalPairs(int[] nums) {\\n        int[] ans = new int[101];\\n        int count = 0;\\n\\n        for (int i = 0; i < nums.length; i++)\\n        {   \\n            count += ans[nums[i]];\\n            ans[nums[i]]++;\\n        }\\n\\n        return count;\\n    }\\n}"
                    },
                    {
                        "username": "Yash_0000",
                        "content": "use two pointer.\\n"
                    },
                    {
                        "username": "Yash_0000",
                        "content": "class Solution {\\n    public int numIdenticalPairs(int[] nums) {\\n        int count = 0;\\n        for(int i=0;i<nums.length;i++)\\n        {\\n            for(int j=i+1;j<nums.length;j++)\\n            {\\n                if(nums[i] == nums[j])\\n                count++;\\n            }\\n        } \\n        return count;\\n    }\\n}"
                    },
                    {
                        "username": "FaraiMajor",
                        "content": "the question is so vague. i dont understand what the question even mean. what is (i,j). their explanation is mediocre at best"
                    },
                    {
                        "username": "deleted_user",
                        "content": "Python Solution\\n\\nclass Solution:\\n    def numIdenticalPairs(self, nums: List[int]) -> int:\\n        count = 0\\n        for i in range(len(nums)-1):\\n            for j in range(i+1,len(nums)):\\n                if nums[i] == nums[j]:\\n                    count += 1\\n        return count"
                    },
                    {
                        "username": "ayushshuklas",
                        "content": "c++ O(n) using unordered_map \\n \\n`class Solution {\\npublic:\\n    int numIdenticalPairs(vector<int>& nums) {\\n        // sort(nums.bengin(),nums.end());\\n\\n        unordered_map<int,int> m;\\n\\n        for(auto it : nums)\\n        {\\n            m[it]++;\\n        }\\nint p = 0;\\n        for(auto it : m)\\n        {\\n            if(it.second > 1)\\n            {\\n                int n = it.second;\\n                p = p +  (n*(n-1))/2;\\n            }\\n        }\\n        return p;\\n    }\\n};`"
                    },
                    {
                        "username": "TheViking7",
                        "content": "calculating the frequency of  a number determines the no of pairs. "
                    },
                    {
                        "username": "deepdubey1995",
                        "content": "What is wrong in this code\\nclass Solution {\\n    public int numIdenticalPairs(int[] nums) {\\n        int count=0;\\n        int i=0;\\n        int j=nums.length-1;\\n        while(i<j){\\n            if(nums[i]==nums[j]){\\n                count++;\\n                j--;\\n            }\\n            else if(i>=j){\\n                i++;\\n                j=nums.length-1;\\n            }\\n            else\\n                j--;\\n        }\\n        return count;\\n    }      \\n}"
                    },
                    {
                        "username": "Bayervilligar",
                        "content": "  for(int i=0;i<nums.size();i++)\\n        {\\n            \\n                for(int j=0;j<nums.size();j++)\\n                {\\n                    if(nums[i]==nums[j] && i<j)\\n                     {\\n                        count++;\\n                     }\\n                }\\n                    \\n        }\\n\\nSEE THE ABOVE CODE I AM NOT POSTING THE COMPLETE SOLUTION THOUGH I THINK THIS APPROACH IS AN EASY ONE...JUST INTRODUCE A COUNT VARIABLE WHICH WILL KEEP THE COUNT OF GOOD PAIRS AND JUST USE THESE 2 NESTED LOOPS FOR TRAVERSING AND COMPARING EACH ELEMENT...\\nTHANKYOU...I HOPE IT HELPS"
                    }
                ]
            },
            {
                "id": 1734618,
                "content": [
                    {
                        "username": "imranansari9835",
                        "content": "Java:\\nclass Solution {\\n    public int numIdenticalPairs(int[] nums) {\\n        int x = 0;\\n        for (int i =0;i< nums.length;i++){\\n            for (int j = i; j < nums.length; j++) {\\n                if(nums[i] == nums[j] && i < j){\\n                    x++;\\n                }\\n            }\\n        }\\n        return x;\\n\\n    }\\n}\\n"
                    },
                    {
                        "username": "Kalpit_Rathi",
                        "content": "100% faster solution in java || very easy\\n\\nclass Solution {\\n    public int numIdenticalPairs(int[] nums) {\\n        int[] ans = new int[101];\\n        int count = 0;\\n\\n        for (int i = 0; i < nums.length; i++)\\n        {   \\n            count += ans[nums[i]];\\n            ans[nums[i]]++;\\n        }\\n\\n        return count;\\n    }\\n}"
                    },
                    {
                        "username": "Yash_0000",
                        "content": "use two pointer.\\n"
                    },
                    {
                        "username": "Yash_0000",
                        "content": "class Solution {\\n    public int numIdenticalPairs(int[] nums) {\\n        int count = 0;\\n        for(int i=0;i<nums.length;i++)\\n        {\\n            for(int j=i+1;j<nums.length;j++)\\n            {\\n                if(nums[i] == nums[j])\\n                count++;\\n            }\\n        } \\n        return count;\\n    }\\n}"
                    },
                    {
                        "username": "FaraiMajor",
                        "content": "the question is so vague. i dont understand what the question even mean. what is (i,j). their explanation is mediocre at best"
                    },
                    {
                        "username": "deleted_user",
                        "content": "Python Solution\\n\\nclass Solution:\\n    def numIdenticalPairs(self, nums: List[int]) -> int:\\n        count = 0\\n        for i in range(len(nums)-1):\\n            for j in range(i+1,len(nums)):\\n                if nums[i] == nums[j]:\\n                    count += 1\\n        return count"
                    },
                    {
                        "username": "ayushshuklas",
                        "content": "c++ O(n) using unordered_map \\n \\n`class Solution {\\npublic:\\n    int numIdenticalPairs(vector<int>& nums) {\\n        // sort(nums.bengin(),nums.end());\\n\\n        unordered_map<int,int> m;\\n\\n        for(auto it : nums)\\n        {\\n            m[it]++;\\n        }\\nint p = 0;\\n        for(auto it : m)\\n        {\\n            if(it.second > 1)\\n            {\\n                int n = it.second;\\n                p = p +  (n*(n-1))/2;\\n            }\\n        }\\n        return p;\\n    }\\n};`"
                    },
                    {
                        "username": "TheViking7",
                        "content": "calculating the frequency of  a number determines the no of pairs. "
                    },
                    {
                        "username": "deepdubey1995",
                        "content": "What is wrong in this code\\nclass Solution {\\n    public int numIdenticalPairs(int[] nums) {\\n        int count=0;\\n        int i=0;\\n        int j=nums.length-1;\\n        while(i<j){\\n            if(nums[i]==nums[j]){\\n                count++;\\n                j--;\\n            }\\n            else if(i>=j){\\n                i++;\\n                j=nums.length-1;\\n            }\\n            else\\n                j--;\\n        }\\n        return count;\\n    }      \\n}"
                    },
                    {
                        "username": "Bayervilligar",
                        "content": "  for(int i=0;i<nums.size();i++)\\n        {\\n            \\n                for(int j=0;j<nums.size();j++)\\n                {\\n                    if(nums[i]==nums[j] && i<j)\\n                     {\\n                        count++;\\n                     }\\n                }\\n                    \\n        }\\n\\nSEE THE ABOVE CODE I AM NOT POSTING THE COMPLETE SOLUTION THOUGH I THINK THIS APPROACH IS AN EASY ONE...JUST INTRODUCE A COUNT VARIABLE WHICH WILL KEEP THE COUNT OF GOOD PAIRS AND JUST USE THESE 2 NESTED LOOPS FOR TRAVERSING AND COMPARING EACH ELEMENT...\\nTHANKYOU...I HOPE IT HELPS"
                    }
                ]
            }
        ]
    }
]