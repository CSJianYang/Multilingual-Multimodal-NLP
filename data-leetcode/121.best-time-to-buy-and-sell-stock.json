[
    {
        "title": "Best Time to Buy and Sell Stock",
        "question_content": "You are given an array prices where prices[i] is the price of a given stock on the ith day.\nYou want to maximize your profit by choosing a single day to buy one stock and choosing a different day in the future to sell that stock.\nReturn the maximum profit you can achieve from this transaction. If you cannot achieve any profit, return 0.\n&nbsp;\nExample 1:\n\nInput: prices = [7,1,5,3,6,4]\nOutput: 5\nExplanation: Buy on day 2 (price = 1) and sell on day 5 (price = 6), profit = 6-1 = 5.\nNote that buying on day 2 and selling on day 1 is not allowed because you must buy before you sell.\n\nExample 2:\n\nInput: prices = [7,6,4,3,1]\nOutput: 0\nExplanation: In this case, no transactions are done and the max profit = 0.\n\n&nbsp;\nConstraints:\n\n\t1 <= prices.length <= 105\n\t0 <= prices[i] <= 104",
        "solutions": [
            {
                "id": 1735550,
                "title": "python-javascript-easy-solution-with-very-clear-explanation",
                "content": "**The question is saying us to find the best day to buy and sell stock, so we will get maiximum profit.**\\n\\n**Some body might think that we can find min and max number from the array so that we can get the max profit. But here is one catch\\nFor Example:\\nprices=[3,4,1,6]\\nmin=1\\nmax=6\\nprofit=max-min=5 which is correct\\nin this Example:\\n```\\nprices = [7,6,4,3,1]\\n```\\nmin = 1 price at day 6\\nmax = 7 price at day 1\\nmax_profit = 7-1 = 6 u can think like this but you can\\'t buy the stock at day 6 and sell it at day 1.**\\n\\n---\\n\\n**So what is the best way to find the max profit lets see \\uD83D\\uDE03\\n<ins>Explanation:</ins>\\nlet use initialize Left and Right pointer to first and second position of array\\nHere Left is to buy stock and Right is to sell stock**\\n\\n\\n`   Then we initialize our max_profit as 0.    `\\n\\n#### Now we will start our while loop and we will run till our \\n\\n**Right pointer less then length of array \\n<ins>For Example: </ins>\\nprices=[7,1,5,3,6,4]\\nNote:\\nprices[left] --> buy stock\\nprices[right] --> sell stock\\nnow we will check price at right and left pointer**\\n\\n\\n**step 1:** <br>\\nprice[left]=7 price[right]=1 profit=-6\\nhere price[left] is greater than price[right] so we will move left pointer to the right position and increment our right pointer by 1. We always want our left point to be minimum\\n\\n**step 2:** <br>\\nprice[left]=1 price[right]=5 profit=4\\nhere price[left] is less than price[right] which means we will get profit so we will update our max_profit and move our right pointer alone\\n\\n**step 3:** <br>\\nprice[left]=1 price[right]=3 profit=2\\nhere price[left] is less than price[right] which means we will get profit so we will check our max_profit previously it\\n\\nwas 4 now our current profit is 2 so we will check which is maximum and update our max_profit and move our right pointer alone\\n\\n**step 4:** <br>\\nprice[left]=1 price[right]=6 profit=5\\nhere price[left] is less than price[right] which means we will get profit so we will check our max_profit previously it was 4 now our current profit is 5 so we will check which is maximum and update our max_profit and move our right pointer alone\\n\\n**step 5:** <br>\\nprice[left]=1 price[right]=4 profit=3\\nsame logic as above\\n\\n\\n```\\nBig O :\\nn--> length of array\\nTime Complexity: O(n)\\nSpace Complexity: O(1)\\n```\\n\\n**My Hand Writting will not be good ,please adjust it \\uD83D\\uDE05**\\n\\n![image](https://assets.leetcode.com/users/images/c0c86dc7-f7fa-4be7-85f9-61e629aa67ae_1643686591.6894035.jpeg)\\n\\n\\n## lets go to the solution:\\n\\npython:\\n```python []\\nclass Solution:\\n    def maxProfit(self,prices):\\n        left = 0 #Buy\\n        right = 1 #Sell\\n        max_profit = 0\\n        while right < len(prices):\\n            currentProfit = prices[right] - prices[left] #our current Profit\\n            if prices[left] < prices[right]:\\n                max_profit =max(currentProfit,max_profit)\\n            else:\\n                left = right\\n            right += 1\\n        return max_profit\\n```\\n\\njavascript:\\n```javascript []\\nconst maxProfit = (prices) => {\\n  let left = 0; // Buy\\n  let right = 1; // sell\\n  let max_profit = 0;\\n  while (right < prices.length) {\\n    if (prices[left] < prices[right]) {\\n      let profit = prices[right] - prices[left]; // our current profit\\n\\n      max_profit = Math.max(max_profit, profit);\\n    } else {\\n      left = right;\\n    }\\n    right++;\\n  }\\n  return max_profit;\\n};\\n```\\n`UPVOTE if you like \\uD83D\\uDE03 , If you have any question, feel free to ask.`\\n",
                "solutionTags": [
                    "Python",
                    "JavaScript",
                    "Two Pointers"
                ],
                "code": "```\\nprices = [7,6,4,3,1]\\n```\n```\\nBig O :\\nn--> length of array\\nTime Complexity: O(n)\\nSpace Complexity: O(1)\\n```\n```python []\\nclass Solution:\\n    def maxProfit(self,prices):\\n        left = 0 #Buy\\n        right = 1 #Sell\\n        max_profit = 0\\n        while right < len(prices):\\n            currentProfit = prices[right] - prices[left] #our current Profit\\n            if prices[left] < prices[right]:\\n                max_profit =max(currentProfit,max_profit)\\n            else:\\n                left = right\\n            right += 1\\n        return max_profit\\n```\n```javascript []\\nconst maxProfit = (prices) => {\\n  let left = 0; // Buy\\n  let right = 1; // sell\\n  let max_profit = 0;\\n  while (right < prices.length) {\\n    if (prices[left] < prices[right]) {\\n      let profit = prices[right] - prices[left]; // our current profit\\n\\n      max_profit = Math.max(max_profit, profit);\\n    } else {\\n      left = right;\\n    }\\n    right++;\\n  }\\n  return max_profit;\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1735493,
                "title": "java-c-best-ever-explanation-could-possible",
                "content": "Let\\'s understand this problem by an **imagination**. **Imagine** you have given a **time machine**, you can go to **past** to **buy** the **stock** of your choice when the price is very least. And again using that **time machine** you went into **future** to **sell** the **stock**.\\n\\n![image](https://assets.leetcode.com/users/images/21002ba2-d686-4465-8486-38e3ccd4a063_1643683166.0503008.png)\\n\\nBy doing that you have achieve **maximum profit**. From `buying at very least price and selling at very higher price`. **And you have become rich now!**\\n\\n![image](https://assets.leetcode.com/users/images/2950d9ce-0000-49dd-8270-cdfbf8a7a6af_1643683545.5999126.png)\\n\\nNow let\\'s just understand it with our given example,\\n**Input**: prices = [7,1,5,3,6,4]\\n**Output**: 5\\n\\n![image](https://assets.leetcode.com/users/images/ca7614a0-a717-48c1-a4ba-7fba42046941_1643684561.8969386.png)\\n\\n`Remember one rule :- You can only buy one time & sell one time`\\n\\n* So, if **buy at 7** & **sell at any time in the future**, we\\'ll face loss. Because **buying price** is way **higher** then **selling price** available we have\\n* Now, I have seen a dip & I **buy at 1** & **sell at 5** my **overall profit** will be **5 - 1 = 4**\\n\\n* But what if, I had **buy at 1** & **sell at 6** my profit will be **6 - 1 = 5**. Which is **greater then my overall profit**. So, i will **update** my **overall profit** with new value.\\n* Now we have done as further we don\\'t have any higher point to sell. We will **return our answer.**\\n\\n**I hope now question, approach is absolute clear.**\\n\\n*code each line explained :* `Similar for C++, Java`\\n\\n```\\n{\\n        int lsf = Integer.MAX_VALUE; // least so far\\n        int op = 0; // overall profit\\n        int pist = 0; // profit if sold today\\n        \\n        for(int i = 0; i < prices.length; i++){\\n            if(prices[i] < lsf){ // if we found new buy value which is more smaller then previous one\\n                lsf = prices[i]; // update our least so far\\n            }\\n            pist = prices[i] - lsf; // calculating profit if sold today by, Buy - sell\\n            if(op < pist){ // if pist is more then our previous overall profit\\n                op = pist; // update overall profit\\n            }\\n        }\\n        return op; // return op \\n```\\n\\n**Java**\\n```\\nclass Solution {\\n    public int maxProfit(int[] prices) {\\n        int lsf = Integer.MAX_VALUE;\\n        int op = 0;\\n        int pist = 0;\\n        \\n        for(int i = 0; i < prices.length; i++){\\n            if(prices[i] < lsf){\\n                lsf = prices[i];\\n            }\\n            pist = prices[i] - lsf;\\n            if(op < pist){\\n                op = pist;\\n            }\\n        }\\n        return op;\\n    }\\n}\\n```\\n**C++**\\n```\\nclass Solution {\\npublic:\\n    int maxProfit(vector<int>& prices) {\\n        int lsf = INT_MAX;\\n        int op = 0;\\n        int pist = 0;\\n        \\n        for(int i = 0; i < prices.size(); i++){\\n            if(prices[i] < lsf){\\n                lsf = prices[i];\\n            }\\n            pist = prices[i] - lsf;\\n            if(op < pist){\\n                op = pist;\\n            }\\n        }\\n        return op;\\n    }\\n};\\n```",
                "solutionTags": [
                    "Java",
                    "C"
                ],
                "code": "```\\n{\\n        int lsf = Integer.MAX_VALUE; // least so far\\n        int op = 0; // overall profit\\n        int pist = 0; // profit if sold today\\n        \\n        for(int i = 0; i < prices.length; i++){\\n            if(prices[i] < lsf){ // if we found new buy value which is more smaller then previous one\\n                lsf = prices[i]; // update our least so far\\n            }\\n            pist = prices[i] - lsf; // calculating profit if sold today by, Buy - sell\\n            if(op < pist){ // if pist is more then our previous overall profit\\n                op = pist; // update overall profit\\n            }\\n        }\\n        return op; // return op \\n```\n```\\nclass Solution {\\n    public int maxProfit(int[] prices) {\\n        int lsf = Integer.MAX_VALUE;\\n        int op = 0;\\n        int pist = 0;\\n        \\n        for(int i = 0; i < prices.length; i++){\\n            if(prices[i] < lsf){\\n                lsf = prices[i];\\n            }\\n            pist = prices[i] - lsf;\\n            if(op < pist){\\n                op = pist;\\n            }\\n        }\\n        return op;\\n    }\\n}\\n```\n```\\nclass Solution {\\npublic:\\n    int maxProfit(vector<int>& prices) {\\n        int lsf = INT_MAX;\\n        int op = 0;\\n        int pist = 0;\\n        \\n        for(int i = 0; i < prices.size(); i++){\\n            if(prices[i] < lsf){\\n                lsf = prices[i];\\n            }\\n            pist = prices[i] - lsf;\\n            if(op < pist){\\n                op = pist;\\n            }\\n        }\\n        return op;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 39038,
                "title": "kadane-s-algorithm-since-no-one-has-mentioned-about-this-so-far-in-case-if-interviewer-twists-the-input",
                "content": "The logic to solve this problem is same as \"max subarray problem\" using `Kadane's Algorithm`. Since no body has mentioned this so far, I thought it's a good thing for everybody to know. \\n\\nAll the straight forward solution should work, but if the interviewer twists the question slightly by giving the ***difference array of prices***, Ex: for `{1, 7, 4, 11}`, if he gives `{0, 6, -3, 7}`, you might end up being confused. \\n\\nHere, the logic is to calculate the difference (`maxCur += prices[i] - prices[i-1]`) of the original array, and find a contiguous subarray giving maximum profit. If the difference falls below 0, reset it to zero.\\n\\n\\n        public int maxProfit(int[] prices) {\\n            int maxCur = 0, maxSoFar = 0;\\n            for(int i = 1; i < prices.length; i++) {\\n                maxCur = Math.max(0, maxCur += prices[i] - prices[i-1]);\\n                maxSoFar = Math.max(maxCur, maxSoFar);\\n            }\\n            return maxSoFar;\\n        }\\n\\n*`maxCur = current maximum value`\\n\\n*`maxSoFar = maximum value found so far`",
                "solutionTags": [
                    "Dynamic Programming"
                ],
                "code": "The logic to solve this problem is same as \"max subarray problem\" using `Kadane's Algorithm`. Since no body has mentioned this so far, I thought it's a good thing for everybody to know. \\n\\nAll the straight forward solution should work, but if the interviewer twists the question slightly by giving the ***difference array of prices***, Ex: for `{1, 7, 4, 11}`, if he gives `{0, 6, -3, 7}`, you might end up being confused. \\n\\nHere, the logic is to calculate the difference (`maxCur += prices[i] - prices[i-1]`) of the original array, and find a contiguous subarray giving maximum profit. If the difference falls below 0, reset it to zero.\\n\\n\\n        public int maxProfit(int[] prices) {\\n            int maxCur = 0, maxSoFar = 0;\\n            for(int i = 1; i < prices.length; i++) {\\n                maxCur = Math.max(0, maxCur += prices[i] - prices[i-1]);\\n                maxSoFar = Math.max(maxCur, maxSoFar);\\n            }\\n            return maxSoFar;\\n        }\\n\\n*`maxCur = current maximum value`\\n\\n*`maxSoFar = maximum value found so far`",
                "codeTag": "Unknown"
            },
            {
                "id": 39039,
                "title": "sharing-my-simple-and-clear-c-solution",
                "content": "    int maxProfit(vector<int> &prices) {\\n        int maxPro = 0;\\n        int minPrice = INT_MAX;\\n        for(int i = 0; i < prices.size(); i++){\\n            minPrice = min(minPrice, prices[i]);\\n            maxPro = max(maxPro, prices[i] - minPrice);\\n        }\\n        return maxPro;\\n    }\\n\\nminPrice is the minimum price from day 0 to day i. And maxPro is the maximum profit we can get from day 0 to day i. \\n\\nHow to get maxPro? Just get the larger one between current maxPro and prices[i] - minPrice.",
                "solutionTags": [
                    "C++",
                    "Greedy"
                ],
                "code": "    int maxProfit(vector<int> &prices) {\\n        int maxPro = 0;\\n        int minPrice = INT_MAX;\\n        for(int i = 0; i < prices.size(); i++){\\n            minPrice = min(minPrice, prices[i]);\\n            maxPro = max(maxPro, prices[i] - minPrice);\\n        }\\n        return maxPro;\\n    }\\n\\nminPrice is the minimum price from day 0 to day i. And maxPro is the maximum profit we can get from day 0 to day i. \\n\\nHow to get maxPro? Just get the larger one between current maxPro and prices[i] - minPrice.",
                "codeTag": "Unknown"
            },
            {
                "id": 39049,
                "title": "easy-o-n-python-solution",
                "content": "    def maxProfit(prices):\\n        max_profit, min_price = 0, float('inf')\\n        for price in prices:\\n            min_price = min(min_price, price)\\n            profit = price - min_price\\n            max_profit = max(max_profit, profit)\\n        return max_profit",
                "solutionTags": [
                    "Python"
                ],
                "code": "    def maxProfit(prices):\\n        max_profit, min_price = 0, float('inf')\\n        for price in prices:\\n            min_price = min(min_price, price)\\n            profit = price - min_price\\n            max_profit = max(max_profit, profit)\\n        return max_profit",
                "codeTag": "Python3"
            },
            {
                "id": 3169837,
                "title": "best-c-3-solution-dp-space-optimization-brute-force-optimize",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nWe can solve this problem using Three approach.\\n\\n1. Solved using Array(Two Nested Loop). Brute Force Approach.\\n2. Solved using Dynamic Programming Approach (tabulation).\\n3. Solved using Dynamic Programming Approach(Space optimization).\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nWe can easily understand the All the approaches by seeing the code which is easy to understand with comments.\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nTime complexity is given in code comment.\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nSpace complexity is given in code comment.\\n\\n# Code\\n\\n```\\n/*\\n\\n    Time Complexity : O(N^2), Where N is the size of the Array(prices). As we check for possible pair, and the\\n    total number of pairs are : N*(N\\u20131)/2.\\n\\n    Space complexity : O(1), Constant space.\\n\\n    Using Array(Two Nested Loop). Brute Force Approach.\\n\\n    Note : This will give TLE.\\n\\n*/\\n\\n\\n/***************************************** Approach 1 Code *****************************************/\\n\\nclass Solution {\\npublic:\\n    int maxProfit(vector<int>& prices) {\\n        int n = prices.size(), maxProfit = 0;\\n        for(int i=0; i<n-1; i++){\\n            for(int j=i+1; j<n; j++){\\n                if(prices[j] - prices[i] > maxProfit){\\n                    maxProfit = prices[j] - prices[i];\\n                }\\n            }\\n        }\\n        return maxProfit;\\n    }\\n};\\n\\n\\n\\n\\n\\n\\n/*\\n\\n    Time Complexity : O(N), As we iterate the array(prices) two times. Where N = size of the array.\\n\\n    Space complexity : O(N), Array(maxPrices) space.\\n\\n    Solved using Dynamic Programming Approach(tabulation).\\n\\n*/\\n\\n\\n/***************************************** Approach 2 Code *****************************************/\\n\\nclass Solution {\\npublic:\\n    int maxProfit(vector<int>& prices) {\\n        int n = prices.size();\\n        vector<int> maxPrices(n, 0);\\n        maxPrices[n-1] = prices[n-1];\\n        for(int i=n-2; i>=0; i--){\\n            maxPrices[i] = max(maxPrices[i+1], prices[i]); \\n        }\\n        int maxProfit = 0;\\n        for(int i=0; i<n; i++){\\n            maxProfit = max(maxProfit, maxPrices[i] - prices[i]); \\n        }\\n        return maxProfit;\\n    }\\n};\\n\\n\\n\\n\\n\\n\\n/*\\n\\n    Time Complexity : O(N), As we iterate the array(prices) two times. Where N = size of the array.\\n\\n    Space Complexity : O(1), Constant space.\\n\\n    Solved using Dynamic Programming Approach(Space optimisation).\\n\\n*/\\n\\n\\n/***************************************** Approach 3 Code *****************************************/\\n\\nclass Solution {\\npublic:\\n    int maxProfit(vector<int>& prices) {\\n        int n = prices.size();\\n        int buyAtPrice = INT_MAX;\\n        int maxProfit = 0;\\n        for(int i=0; i<n; i++){\\n            buyAtPrice = min(buyAtPrice, prices[i]);\\n            maxProfit = max(maxProfit, prices[i] - buyAtPrice); \\n        }\\n        return maxProfit;\\n    }\\n};\\n\\n\\n```\\n*IF YOU LIKE THE SOLUTION THEN PLEASE UPVOTE MY SOLUTION BECAUSE IT GIVES ME MOTIVATION TO REGULARLY POST THE SOLUTION.*\\n\\n![WhatsApp Image 2023-02-10 at 19.01.02.jpeg](https://assets.leetcode.com/users/images/0a95fea4-64f4-4502-82aa-41db6d77c05c_1676054939.8270252.jpeg)\\n\\n\\n\\n\\n",
                "solutionTags": [
                    "C++",
                    "Array",
                    "Dynamic Programming"
                ],
                "code": "```\\n/*\\n\\n    Time Complexity : O(N^2), Where N is the size of the Array(prices). As we check for possible pair, and the\\n    total number of pairs are : N*(N\\u20131)/2.\\n\\n    Space complexity : O(1), Constant space.\\n\\n    Using Array(Two Nested Loop). Brute Force Approach.\\n\\n    Note : This will give TLE.\\n\\n*/\\n\\n\\n/***************************************** Approach 1 Code *****************************************/\\n\\nclass Solution {\\npublic:\\n    int maxProfit(vector<int>& prices) {\\n        int n = prices.size(), maxProfit = 0;\\n        for(int i=0; i<n-1; i++){\\n            for(int j=i+1; j<n; j++){\\n                if(prices[j] - prices[i] > maxProfit){\\n                    maxProfit = prices[j] - prices[i];\\n                }\\n            }\\n        }\\n        return maxProfit;\\n    }\\n};\\n\\n\\n\\n\\n\\n\\n/*\\n\\n    Time Complexity : O(N), As we iterate the array(prices) two times. Where N = size of the array.\\n\\n    Space complexity : O(N), Array(maxPrices) space.\\n\\n    Solved using Dynamic Programming Approach(tabulation).\\n\\n*/\\n\\n\\n/***************************************** Approach 2 Code *****************************************/\\n\\nclass Solution {\\npublic:\\n    int maxProfit(vector<int>& prices) {\\n        int n = prices.size();\\n        vector<int> maxPrices(n, 0);\\n        maxPrices[n-1] = prices[n-1];\\n        for(int i=n-2; i>=0; i--){\\n            maxPrices[i] = max(maxPrices[i+1], prices[i]); \\n        }\\n        int maxProfit = 0;\\n        for(int i=0; i<n; i++){\\n            maxProfit = max(maxProfit, maxPrices[i] - prices[i]); \\n        }\\n        return maxProfit;\\n    }\\n};\\n\\n\\n\\n\\n\\n\\n/*\\n\\n    Time Complexity : O(N), As we iterate the array(prices) two times. Where N = size of the array.\\n\\n    Space Complexity : O(1), Constant space.\\n\\n    Solved using Dynamic Programming Approach(Space optimisation).\\n\\n*/\\n\\n\\n/***************************************** Approach 3 Code *****************************************/\\n\\nclass Solution {\\npublic:\\n    int maxProfit(vector<int>& prices) {\\n        int n = prices.size();\\n        int buyAtPrice = INT_MAX;\\n        int maxProfit = 0;\\n        for(int i=0; i<n; i++){\\n            buyAtPrice = min(buyAtPrice, prices[i]);\\n            maxProfit = max(maxProfit, prices[i] - buyAtPrice); \\n        }\\n        return maxProfit;\\n    }\\n};\\n\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 884314,
                "title": "python-3-very-simple-solution-explanation-added",
                "content": "**Suggestions to make it better are always welcomed.**\\n\\nWe might think about using sliding window technique, but obviously we don\\'t need subarray here. We just need one value from the given input list. So, this technique is not useful.\\n\\n**Solution:**\\nWe always need to know what is the maxProfit we can make if we sell the stock on i-th day. So, keep track of maxProfit.\\nThere might be a scenario where if stock bought on i-th day is minimum and we sell it on (i + k)th day. So, keep track of minPurchase as well.\\n\\n```\\ndef maxProfit(self, prices: List[int]) -> int:\\n\\tif not prices:\\n\\t\\treturn 0\\n\\n\\tmaxProfit = 0\\n\\tminPurchase = prices[0]\\n\\tfor i in range(1, len(prices)):\\t\\t\\n\\t\\tmaxProfit = max(maxProfit, prices[i] - minPurchase)\\n\\t\\tminPurchase = min(minPurchase, prices[i])\\n\\treturn maxProfit\\n```\\n\\n**I hope that you\\'ve found this useful.\\nIn that case, please upvote. It only motivates me to write more such posts\\uD83D\\uDE03**",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\ndef maxProfit(self, prices: List[int]) -> int:\\n\\tif not prices:\\n\\t\\treturn 0\\n\\n\\tmaxProfit = 0\\n\\tminPurchase = prices[0]\\n\\tfor i in range(1, len(prices)):\\t\\t\\n\\t\\tmaxProfit = max(maxProfit, prices[i] - minPurchase)\\n\\t\\tminPurchase = min(minPurchase, prices[i])\\n\\treturn maxProfit\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 900050,
                "title": "fully-explained-all-buy-and-sell-problems-c-recursive-memoization-minor-difference",
                "content": "**To solve this problem just start from basic similar problem. After solving these peoblems we wil reach at final this problem.**\\n\\n``` I have discussed all the problems by recursive and memoization approach , so that everyone can figure out minor differences between the questions :)```\\n\\n---------------------------------------------------------------------------------------------------------------\\n---------------------------------------------------------------------------------------------------------------\\n**Recursive Solution and memoize solutions:**\\n\\n1. https://leetcode.com/problems/best-time-to-buy-and-sell-stock/\\n\\n   **You can do at most one transaction**\\n\\n\\n```\\nclass Solution {\\npublic:\\n    int find(vector<int> &prices, int i,int k,bool buy,vector<vector<int>> &v)\\n    {\\n        //if we have no stock or we have no chance of transaction(k=0)\\n        if(i>=prices.size()||k<=0) return 0;\\n        if(v[i][buy]!=-1) return v[i][buy];\\n        \\n        if(buy)  //if we are buying then next time we will sell else next time we will buy\\n        {        //-prices[i], because bought stock of prices[i], expend money\\n            \\n           return v[i][buy]=max(-prices[i]+find(prices,i+1,k,!buy,v),find(prices,i+1,k,buy,v)); \\n        }\\n        else    //it\\'s time to sell , now decrease k, we have done 1 transaction\\n        {       //+prices[i], because we now gain (i.e) sell our stock at rate of prices[i]\\n           return v[i][buy]=max( prices[i]+find(prices,i+1,k-1,!buy,v),find(prices,i+1,k,buy,v)); \\n        }\\n    }\\n    int maxProfit(vector<int>& prices) {\\n        \\n        int n=prices.size(); \\n        vector<vector<int>> v(n,vector<int> (2,-1));\\n        //passing here buy=1 because we will first buy then sell\\n        //we can do atmost k=1 transaction\\n        return find(prices,0,1,1,v);\\n    }\\n};\\n```\\n\\n---------------------------------------------------------------------------------------------------------------\\n---------------------------------------------------------------------------------------------------------------\\n2. https://leetcode.com/problems/best-time-to-buy-and-sell-stock-ii/\\n\\n    **You can do as many transactions as you like**\\n\\n```\\nclass Solution {\\npublic:\\nint find(int ind,vector<int> &v,bool buy,vector<vector<int>> &memo)\\n{    \\n    if(ind>=v.size()) return 0;\\n    if(memo[ind][buy]!=-1) return memo[ind][buy];\\n    \\n    if(buy) //if we are buying then next time we will sell else next time we will buy\\n    {      //-prices[i], because bought stock of prices[i], expend money, !buy because next time sell\\n        \\n       return memo[ind][buy]=max(-v[ind]+find(ind+1,v,!buy,memo),find(ind+1,v,buy,memo));  \\n    }\\n    else   //it\\'s time to sell \\n    {      //+prices[i], because we now gain (i.e) sell our stock at rate of prices[i]\\n        \\n       return memo[ind][buy]=max(v[ind]+find(ind+1,v,!buy,memo),find(ind+1,v,buy,memo));  \\n    }\\n     \\n}\\n    int maxProfit(vector<int>& prices) {\\n        \\n        int n=prices.size();\\n        if(n<2) return 0;\\n        vector<vector<int>> v(n+1,vector<int>(2,-1));\\n        //passing here buy=1 because we will first buy then sell \\n        return find(0,prices,1,v); \\n    }\\n};\\n```\\n \\n---------------------------------------------------------------------------------------------------------------\\n---------------------------------------------------------------------------------------------------------------\\n 3.  https://leetcode.com/problems/best-time-to-buy-and-sell-stock-iii/\\n\\n      **You may complete at most two transactions.**\\n\\n```\\nclass Solution {\\npublic:\\n    int find(vector<int> &prices,int ind,bool buy,int c,vector<vector<vector<int>>> &memo)\\n    {   \\n        //if buy =1 means we have to buy now\\n        //else we have to sell now\\n        if(ind>=prices.size()||c>=2) return 0; //counter\\n        if(memo[ind][buy][c]!=-1) return memo[ind][buy][c];\\n        if(buy) //now we can either buy prices[i] or we can skip it and try next to buy\\n        {\\n            return memo[ind][buy][c]=max(-prices[ind]+find(prices,ind+1,!buy,c,memo),find(prices,ind+1,buy,c,memo));\\n        }\\n        else  //now we can either sell prices[i] or we can skip it and try next to sell\\n        {\\n            return memo[ind][buy][c]=max(prices[ind]+find(prices,ind+1,!buy,c+1,memo),find(prices,ind+1,buy,c,memo));\\n        }\\n        \\n    }\\n    int maxProfit(vector<int>& prices) {\\n        //here we can do maximum two transaction\\n        //Use 3-D vector because here three states i,k,buy/sell\\n        vector<vector<vector<int>>> memo(prices.size(),vector<vector<int>>(2,vector<int>(2,-1)));\\n          \\n       return find(prices,0,1,0,memo); \\n    }\\n};\\n \\n```\\n\\n---------------------------------------------------------------------------------------------------------------\\n---------------------------------------------------------------------------------------------------------------\\n4. https://leetcode.com/problems/best-time-to-buy-and-sell-stock-iv/\\n\\n     **You may complete at most k transactions.**\\n\\n```\\nclass Solution {\\npublic:\\n    int find(vector<int> &prices,int ind,bool buy,int c,int k,vector<vector<vector<int>>> &memo)\\n    {   //if buy =1 means we have to buy now\\n        //else we have to sell now\\n        if(ind>=prices.size()||c>=k) return 0; //counter\\n        \\n        else if(memo[ind][buy][c]!=-1) return memo[ind][buy][c];\\n         \\n        if(buy) //now we can either buy prices[i] or we can skip it and try next to buy\\n        {\\n        return memo[ind][buy][c]=max(-prices[ind]+find(prices,ind+1,!buy,c,k,memo),find(prices,ind+1,buy,c,k,memo));\\n        }\\n        else  //now we can either sell prices[i] or we can skip it and try next to sell\\n        {\\n        return memo[ind][buy][c]=max(prices[ind]+find(prices,ind+1,!buy,c+1,k,memo),find(prices,ind+1,buy,c,k,memo));\\n        }\\n        \\n    }\\n    int maxProfit(int k, vector<int>& prices) {\\n        \\n        //edge case we are not able to pick 2k points from n points, which means \\n        //we will not reach the limit no matter how we try. \\n        //if the price of day i arise, buy the stock in i-1th day and sell it at ith day.\\n        if (2 * k > prices.size()) {\\n            int res = 0;\\n            for (int i = 1; i < prices.size(); i++) {\\n                res += max(0, prices[i] - prices[i - 1]);\\n            }\\n            return res;\\n        }\\n        \\n         //here we can do maximum k transaction\\n        vector<vector<vector<int>>> memo(prices.size()+1,vector<vector<int>>(2,vector<int>(k+1,-1)));\\n        return find(prices,0,1,0,k,memo); \\n    }\\n};\\n```\\n\\n---------------------------------------------------------------------------------------------------------------\\n---------------------------------------------------------------------------------------------------------------\\n\\n**Hit \\uD83D\\uDC4D if you like it :)**",
                "solutionTags": [
                    "C++",
                    "C",
                    "Dynamic Programming",
                    "Recursion",
                    "Memoization"
                ],
                "code": "``` I have discussed all the problems by recursive and memoization approach , so that everyone can figure out minor differences between the questions :)```\n```\\nclass Solution {\\npublic:\\n    int find(vector<int> &prices, int i,int k,bool buy,vector<vector<int>> &v)\\n    {\\n        //if we have no stock or we have no chance of transaction(k=0)\\n        if(i>=prices.size()||k<=0) return 0;\\n        if(v[i][buy]!=-1) return v[i][buy];\\n        \\n        if(buy)  //if we are buying then next time we will sell else next time we will buy\\n        {        //-prices[i], because bought stock of prices[i], expend money\\n            \\n           return v[i][buy]=max(-prices[i]+find(prices,i+1,k,!buy,v),find(prices,i+1,k,buy,v)); \\n        }\\n        else    //it\\'s time to sell , now decrease k, we have done 1 transaction\\n        {       //+prices[i], because we now gain (i.e) sell our stock at rate of prices[i]\\n           return v[i][buy]=max( prices[i]+find(prices,i+1,k-1,!buy,v),find(prices,i+1,k,buy,v)); \\n        }\\n    }\\n    int maxProfit(vector<int>& prices) {\\n        \\n        int n=prices.size(); \\n        vector<vector<int>> v(n,vector<int> (2,-1));\\n        //passing here buy=1 because we will first buy then sell\\n        //we can do atmost k=1 transaction\\n        return find(prices,0,1,1,v);\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\nint find(int ind,vector<int> &v,bool buy,vector<vector<int>> &memo)\\n{    \\n    if(ind>=v.size()) return 0;\\n    if(memo[ind][buy]!=-1) return memo[ind][buy];\\n    \\n    if(buy) //if we are buying then next time we will sell else next time we will buy\\n    {      //-prices[i], because bought stock of prices[i], expend money, !buy because next time sell\\n        \\n       return memo[ind][buy]=max(-v[ind]+find(ind+1,v,!buy,memo),find(ind+1,v,buy,memo));  \\n    }\\n    else   //it\\'s time to sell \\n    {      //+prices[i], because we now gain (i.e) sell our stock at rate of prices[i]\\n        \\n       return memo[ind][buy]=max(v[ind]+find(ind+1,v,!buy,memo),find(ind+1,v,buy,memo));  \\n    }\\n     \\n}\\n    int maxProfit(vector<int>& prices) {\\n        \\n        int n=prices.size();\\n        if(n<2) return 0;\\n        vector<vector<int>> v(n+1,vector<int>(2,-1));\\n        //passing here buy=1 because we will first buy then sell \\n        return find(0,prices,1,v); \\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    int find(vector<int> &prices,int ind,bool buy,int c,vector<vector<vector<int>>> &memo)\\n    {   \\n        //if buy =1 means we have to buy now\\n        //else we have to sell now\\n        if(ind>=prices.size()||c>=2) return 0; //counter\\n        if(memo[ind][buy][c]!=-1) return memo[ind][buy][c];\\n        if(buy) //now we can either buy prices[i] or we can skip it and try next to buy\\n        {\\n            return memo[ind][buy][c]=max(-prices[ind]+find(prices,ind+1,!buy,c,memo),find(prices,ind+1,buy,c,memo));\\n        }\\n        else  //now we can either sell prices[i] or we can skip it and try next to sell\\n        {\\n            return memo[ind][buy][c]=max(prices[ind]+find(prices,ind+1,!buy,c+1,memo),find(prices,ind+1,buy,c,memo));\\n        }\\n        \\n    }\\n    int maxProfit(vector<int>& prices) {\\n        //here we can do maximum two transaction\\n        //Use 3-D vector because here three states i,k,buy/sell\\n        vector<vector<vector<int>>> memo(prices.size(),vector<vector<int>>(2,vector<int>(2,-1)));\\n          \\n       return find(prices,0,1,0,memo); \\n    }\\n};\\n \\n```\n```\\nclass Solution {\\npublic:\\n    int find(vector<int> &prices,int ind,bool buy,int c,int k,vector<vector<vector<int>>> &memo)\\n    {   //if buy =1 means we have to buy now\\n        //else we have to sell now\\n        if(ind>=prices.size()||c>=k) return 0; //counter\\n        \\n        else if(memo[ind][buy][c]!=-1) return memo[ind][buy][c];\\n         \\n        if(buy) //now we can either buy prices[i] or we can skip it and try next to buy\\n        {\\n        return memo[ind][buy][c]=max(-prices[ind]+find(prices,ind+1,!buy,c,k,memo),find(prices,ind+1,buy,c,k,memo));\\n        }\\n        else  //now we can either sell prices[i] or we can skip it and try next to sell\\n        {\\n        return memo[ind][buy][c]=max(prices[ind]+find(prices,ind+1,!buy,c+1,k,memo),find(prices,ind+1,buy,c,k,memo));\\n        }\\n        \\n    }\\n    int maxProfit(int k, vector<int>& prices) {\\n        \\n        //edge case we are not able to pick 2k points from n points, which means \\n        //we will not reach the limit no matter how we try. \\n        //if the price of day i arise, buy the stock in i-1th day and sell it at ith day.\\n        if (2 * k > prices.size()) {\\n            int res = 0;\\n            for (int i = 1; i < prices.size(); i++) {\\n                res += max(0, prices[i] - prices[i - 1]);\\n            }\\n            return res;\\n        }\\n        \\n         //here we can do maximum k transaction\\n        vector<vector<vector<int>>> memo(prices.size()+1,vector<vector<int>>(2,vector<int>(k+1,-1)));\\n        return find(prices,0,1,0,k,memo); \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 39062,
                "title": "my-jave-accepted-solution-with-o-n-time-and-o-1-space",
                "content": "The idea is to find so far min price.\\n\\n     public int maxProfit(int[] prices) {\\n    \\t\\t if (prices.length == 0) {\\n    \\t\\t\\t return 0 ;\\n    \\t\\t }\\t\\t\\n    \\t\\t int max = 0 ;\\n    \\t\\t int sofarMin = prices[0] ;\\n    \\t     for (int i = 0 ; i < prices.length ; ++i) {\\n    \\t    \\t if (prices[i] > sofarMin) {\\n    \\t    \\t\\t max = Math.max(max, prices[i] - sofarMin) ;\\n    \\t    \\t } else{\\n    \\t    \\t\\tsofarMin = prices[i];  \\n    \\t    \\t }\\n    \\t     }\\t     \\n    \\t    return  max ;\\n    \\t }",
                "solutionTags": [],
                "code": "The idea is to find so far min price.\\n\\n     public int maxProfit(int[] prices) {\\n    \\t\\t if (prices.length == 0) {\\n    \\t\\t\\t return 0 ;\\n    \\t\\t }\\t\\t\\n    \\t\\t int max = 0 ;\\n    \\t\\t int sofarMin = prices[0] ;\\n    \\t     for (int i = 0 ; i < prices.length ; ++i) {\\n    \\t    \\t if (prices[i] > sofarMin) {\\n    \\t    \\t\\t max = Math.max(max, prices[i] - sofarMin) ;\\n    \\t    \\t } else{\\n    \\t    \\t\\tsofarMin = prices[i];  \\n    \\t    \\t }\\n    \\t     }\\t     \\n    \\t    return  max ;\\n    \\t }",
                "codeTag": "Unknown"
            },
            {
                "id": 263197,
                "title": "python-2-solutions-min-so-far-kadane-s-algorithm-with-picture-o-1-in-space",
                "content": "**\\u2714\\uFE0F Solution 1: MinSoFar**\\n```python\\nclass Solution:\\n    def maxProfit(self, prices: List[int]) -> int:\\n        n = len(prices)\\n        ans = 0\\n        minSoFar = prices[0]\\n        for i in range(1, n):\\n            ans = max(ans, prices[i] - minSoFar)\\n            minSoFar = min(minSoFar, prices[i])\\n        return ans\\n```\\nComplexity:\\n- Time: `O(N)`, where `N <= 10^5` is length of `prices` array.\\n- Space: `O(1)`\\n\\n---\\n**\\u2714\\uFE0F Solution 2: Kadane\\'s Algorithm**\\n- Same with problem **[53. Maximum Subarray](https://leetcode.com/problems/maximum-subarray/)**.\\n\\n![image](https://assets.leetcode.com/users/images/fc0e41c4-bb24-4d62-9891-0d88f62d49b3_1632370664.418544.png)\\n\\n\\n```python\\nclass Solution:\\n    def maxProfit(self, prices: List[int]) -> int:\\n        n = len(prices)\\n        ans = 0\\n        curSum = 0\\n        for i in range(n-1):\\n            curSum += prices[i+1] - prices[i]\\n            if curSum < 0:\\n                curSum = 0\\n            ans = max(ans, curSum)\\n        return ans\\n```\\nComplexity:\\n- Time: `O(N)`, where `N <= 10^5` is length of `prices` array.\\n- Space: `O(1)`\\n\\nIf you think this **post is useful**, I\\'m happy if you **give a vote**. Any **questions or discussions are welcome!** Thank a lot.",
                "solutionTags": [],
                "code": "```python\\nclass Solution:\\n    def maxProfit(self, prices: List[int]) -> int:\\n        n = len(prices)\\n        ans = 0\\n        minSoFar = prices[0]\\n        for i in range(1, n):\\n            ans = max(ans, prices[i] - minSoFar)\\n            minSoFar = min(minSoFar, prices[i])\\n        return ans\\n```\n```python\\nclass Solution:\\n    def maxProfit(self, prices: List[int]) -> int:\\n        n = len(prices)\\n        ans = 0\\n        curSum = 0\\n        for i in range(n-1):\\n            curSum += prices[i+1] - prices[i]\\n            if curSum < 0:\\n                curSum = 0\\n            ans = max(ans, curSum)\\n        return ans\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3914105,
                "title": "most-optimized-solution-easy-to-understand-c-java-python",
                "content": "# Approach\\nTo solve this problem, I employed a straightforward approach that iterates through the array of stock prices. At each step, I kept track of the minimum stock price seen so far (`min_price`) and calculated the potential profit that could be obtained by selling at the current price (`prices[i] - min_price`). I updated the `maxprof` (maximum profit) variable with the maximum of its current value and the calculated profit. Additionally, I updated the `min_price` to be the minimum of the current stock price and the previously seen minimum.\\n\\n# Complexity\\n- Time complexity: $$O(n)$$\\nThe algorithm iterates through the array of stock prices once, performing constant-time operations at each step. Therefore, the time complexity is linear in the size of the input array.\\n\\n- Space complexity: $$O(1)$$\\nThe algorithm uses a constant amount of extra space to store variables like `min_price` and `maxprof`. The space complexity remains constant regardless of the size of the input array.\\n\\n\\n# Code\\n``` cpp []\\nclass Solution {\\npublic:\\n    int maxProfit(vector<int>& prices) {\\n        int min_price = prices[0];\\n        int maxprof = 0;\\n\\n        for(int i=1;i<prices.size();i++){\\n            maxprof = max(maxprof,prices[i]-min_price);\\n            min_price = min(prices[i],min_price);\\n        }\\n\\n        return maxprof;\\n    }\\n};\\n```\\n\\n``` java []\\nclass Solution {\\n    public int maxProfit(int[] prices) {\\n        int min_price = prices[0];\\n        int maxprof = 0;\\n\\n        for(int i=0;i<prices.length;i++){\\n            maxprof = Math.max(maxprof,prices[i]-min_price);\\n            min_price = Math.min(prices[i],min_price);\\n        }\\n\\n        return maxprof;\\n    }\\n}\\n```\\n\\n``` python3 []\\nclass Solution:\\n    def maxProfit(self, prices: List[int]) -> int:\\n        min_price = prices[0]\\n        max_profit = 0\\n        \\n        for price in prices[1:]:\\n            max_profit = max(max_profit, price - min_price)\\n            min_price = min(min_price, price)\\n            \\n        return max_profit\\n```\\n\\nHope you liked the Solution,\\nIf you have any questions or suggestions, feel free to share \\u2013 happy coding!\\n\\n---\\n\\n\\n![pleaseupvote.jpg](https://assets.leetcode.com/users/images/a79b8806-f22f-40aa-91d5-be9118ab659f_1692112738.478644.jpeg)\\n",
                "solutionTags": [
                    "C++",
                    "Java",
                    "Python",
                    "Python3",
                    "Array",
                    "Dynamic Programming"
                ],
                "code": "``` cpp []\\nclass Solution {\\npublic:\\n    int maxProfit(vector<int>& prices) {\\n        int min_price = prices[0];\\n        int maxprof = 0;\\n\\n        for(int i=1;i<prices.size();i++){\\n            maxprof = max(maxprof,prices[i]-min_price);\\n            min_price = min(prices[i],min_price);\\n        }\\n\\n        return maxprof;\\n    }\\n};\\n```\n``` java []\\nclass Solution {\\n    public int maxProfit(int[] prices) {\\n        int min_price = prices[0];\\n        int maxprof = 0;\\n\\n        for(int i=0;i<prices.length;i++){\\n            maxprof = Math.max(maxprof,prices[i]-min_price);\\n            min_price = Math.min(prices[i],min_price);\\n        }\\n\\n        return maxprof;\\n    }\\n}\\n```\n``` python3 []\\nclass Solution:\\n    def maxProfit(self, prices: List[int]) -> int:\\n        min_price = prices[0]\\n        max_profit = 0\\n        \\n        for price in prices[1:]:\\n            max_profit = max(max_profit, price - min_price)\\n            min_price = min(min_price, price)\\n            \\n        return max_profit\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2433981,
                "title": "easy-100-kadane-s-algorithm-java-c-python-js-python3-min-so-far",
                "content": "Given an array prices where prices[i] is the price of a given stock on the ith day.\\nmaximize our profit by choosing a single day to buy one stock and choosing a different day in the future to sell that stock.\\nReturn the maximum profit achieve from this transaction. If you cannot achieve any profit, return 0\\n\\n**Example:**\\nInput: prices = [7,1,5,3,6,4]\\nOutput: 5\\n**Explanation:** Buy on day 2 (price = 1) and sell on day 5 (price = 6), profit = 6-1 = 5.\\n**Note that, buying on day 2 and selling on day 1 is not allowed because we must buy before sell.**\\n# **Java Solution:**\\nRuntime: 1 ms, faster than 98.59% of Java online submissions for Best Time to Buy and Sell Stock.\\n```\\nclass Solution {\\n    public int maxProfit(int[] prices) {\\n        // Base case...\\n        // If the array is empty or its length <= 1, return 0...\\n        if(prices == null || prices.length <= 1) return 0;\\n        // Initialize the minimum price to buy...\\n        int minBuy = prices[0];\\n        // Initialize the maximum profit...\\n        int profit = 0;\\n        // Traverse all elements through a for loop...\\n        for(int i = 1; i < prices.length; i++) {\\n            // Get the minimum price to buy...\\n            minBuy = Math.min(minBuy, prices[i]);\\n            // Get maximum profit...\\n            profit = Math.max(profit, prices[i] - minBuy);\\n        }\\n        return profit;      //return the maximum profit...\\n    }\\n}\\n```\\n\\n# **C++ Solution:**\\n```\\nclass Solution {\\npublic:\\n    int maxProfit(vector<int>& prices) {\\n        if(prices.size() == 0) return 0;\\n        int profit = 0;\\n        int low = prices[0], high = prices[0];\\n        for(int i = 0; i < prices.size(); i++){\\n            if(prices[i] < low){\\n                profit = max(profit, high - low);\\n                low = prices[i];\\n                high = prices[i];\\n            }else{\\n                high = max(high, prices[i]);\\n            }\\n        }\\n        profit = max(profit, high - low);\\n        return profit;\\n    }\\n};\\n```\\n\\n# **Python Solution:**\\n```\\nclass Solution(object):\\n    def maxProfit(self, prices):\\n        if len(prices) == 0: return 0\\n        else:\\n            profit = 0\\n            minBuy = prices[0]\\n            for i in range(len(prices)):\\n                profit = max(prices[i] - minBuy, profit)\\n                minBuy = min(minBuy, prices[i])\\n            return profit\\n```\\n            \\n# **JavaScript Solution:**\\n```\\nvar maxProfit = function(prices) {\\n    if(prices == null || prices.length <= 1) return 0;\\n    let minBuy = prices[0];\\n    let profit = 0;\\n    for(let i = 1; i < prices.length; i++) {\\n        minBuy = Math.min(minBuy, prices[i]);\\n        profit = Math.max(profit, prices[i] - minBuy);\\n    }\\n    return profit;\\n};\\n```\\n\\n# **Python3 Solution:**\\n```\\nclass Solution:\\n    def maxProfit(self, prices: List[int]) -> int:\\n        if len(prices) == 0: return 0\\n        else:\\n            profit = 0\\n            minBuy = prices[0]\\n            for i in range(len(prices)):\\n                profit = max(prices[i] - minBuy, profit)\\n                minBuy = min(minBuy, prices[i])\\n            return profit\\n```\\n**I am working hard for you guys...\\nPlease upvote if you found any help with this code...**",
                "solutionTags": [
                    "Java",
                    "Python",
                    "Python3",
                    "C",
                    "JavaScript"
                ],
                "code": "```\\nclass Solution {\\n    public int maxProfit(int[] prices) {\\n        // Base case...\\n        // If the array is empty or its length <= 1, return 0...\\n        if(prices == null || prices.length <= 1) return 0;\\n        // Initialize the minimum price to buy...\\n        int minBuy = prices[0];\\n        // Initialize the maximum profit...\\n        int profit = 0;\\n        // Traverse all elements through a for loop...\\n        for(int i = 1; i < prices.length; i++) {\\n            // Get the minimum price to buy...\\n            minBuy = Math.min(minBuy, prices[i]);\\n            // Get maximum profit...\\n            profit = Math.max(profit, prices[i] - minBuy);\\n        }\\n        return profit;      //return the maximum profit...\\n    }\\n}\\n```\n```\\nclass Solution {\\npublic:\\n    int maxProfit(vector<int>& prices) {\\n        if(prices.size() == 0) return 0;\\n        int profit = 0;\\n        int low = prices[0], high = prices[0];\\n        for(int i = 0; i < prices.size(); i++){\\n            if(prices[i] < low){\\n                profit = max(profit, high - low);\\n                low = prices[i];\\n                high = prices[i];\\n            }else{\\n                high = max(high, prices[i]);\\n            }\\n        }\\n        profit = max(profit, high - low);\\n        return profit;\\n    }\\n};\\n```\n```\\nclass Solution(object):\\n    def maxProfit(self, prices):\\n        if len(prices) == 0: return 0\\n        else:\\n            profit = 0\\n            minBuy = prices[0]\\n            for i in range(len(prices)):\\n                profit = max(prices[i] - minBuy, profit)\\n                minBuy = min(minBuy, prices[i])\\n            return profit\\n```\n```\\nvar maxProfit = function(prices) {\\n    if(prices == null || prices.length <= 1) return 0;\\n    let minBuy = prices[0];\\n    let profit = 0;\\n    for(let i = 1; i < prices.length; i++) {\\n        minBuy = Math.min(minBuy, prices[i]);\\n        profit = Math.max(profit, prices[i] - minBuy);\\n    }\\n    return profit;\\n};\\n```\n```\\nclass Solution:\\n    def maxProfit(self, prices: List[int]) -> int:\\n        if len(prices) == 0: return 0\\n        else:\\n            profit = 0\\n            minBuy = prices[0]\\n            for i in range(len(prices)):\\n                profit = max(prices[i] - minBuy, profit)\\n                minBuy = min(minBuy, prices[i])\\n            return profit\\n```",
                "codeTag": "Java"
            },
            {
                "id": 273395,
                "title": "python-greedy",
                "content": "The heuristic is that as long as current price is higher than previous lowest price, max profit could be updated. So I use ```buy``` to track previous lowest price (indicating we can buy in that time) and ```ans``` to track max profit we have achieved so far.\\n```\\ndef maxProfit(prices):\\n\\tbuy, ans = float(\\'inf\\'), 0\\n\\tfor p in prices:\\n\\t\\tbuy, ans = min(buy, p), max(ans, p-buy)\\n\\treturn ans\\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```buy```\n```ans```\n```\\ndef maxProfit(prices):\\n\\tbuy, ans = float(\\'inf\\'), 0\\n\\tfor p in prices:\\n\\t\\tbuy, ans = min(buy, p), max(ans, p-buy)\\n\\treturn ans\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 1545423,
                "title": "python-easy-to-understand-solution-with-explanation-tracking-and-dynamic-programming",
                "content": "### Idea 1: Array \\n* The trick : track the minimum price and the maximum possible profit\\n\\t* \\tKeep track of the buy price --> keep comparing the current price with prvious buy price and track of the minimum price while iterating through the list\\n\\t* \\tHowever, if the current price is greater than the previous buy price \\n\\t\\t* \\tnow check if you sell it now would you get a better profit than the previous one \\n\\t\\t\\t* \\tKeep track of the maximum profit\\n```\\n\\nclass Solution(object):\\n    def maxProfit(self, prices):\\n        \\n        buy_price = prices[0] # at the begining the minimum price is the first price\\n        profit = 0 # at the begining the minimum  profit is zero\\n        \\n        for i in range(1,len(prices)):\\n            #if the current price is less than the previous buy price ; update the buy_price\\n            if prices[i] < buy_price:\\n                buy_price = prices[i]\\n            else: # if not check if you sell with the current price would you get better profit than the previous one\\n                profit = max(profit, prices[i]-buy_price) # compare the previous profit with the current profit\\n                \\n        return profit\\n\\t\\t\\n\\t\\t#Runtime: 916 ms\\n\\t\\t#Memory Usage: 23 MB\\n```\\n        \\n### * Idea 2 : Dynamic programming\\n* Track the minimum_price and the maximum profit together using a dp table\\n\\t* Thus each dp table cell will hold two items --> dp = [[min_price, max_profit], [min_price, max_profit], ........[min_price, max_profit]]\\n        \\n```\\nclass Solution(object):\\n    def maxProfit(self, prices):\\n        n = len(prices)\\n        dp = [0]*n # initializing the dp table\\n        dp[0] = [prices[0],0] # filling the the first dp table --> low_price = prices[0] max_profit=0\\n        min_price = max_profit = 0\\n        # Note that ---> indixing the dp table --> dp[i-1][0] stores minimum price and dp[i-1][1] stores maximum profit\\n        for i in range(1,n):\\n            min_price = min(dp[i-1][0], prices[i]) # min(previous_min_price, cur_min_price)\\n            max_profit = max(dp[i-1][1], prices[i]-dp[i-1][0]) # max(previoius_max_profit, current_profit)\\n            dp[i] =[min_price,max_profit]\\n                \\n        return dp[n-1][1]\\n\\t\\t#Runtime: 1220 ms, \\n\\t\\t#Memory Usage: 32.4 MB,\\n```\\n### \\n### ******* If you found this helpful , upvote and comment as sign of appreciation **********",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Dynamic Programming"
                ],
                "code": "```\\n\\nclass Solution(object):\\n    def maxProfit(self, prices):\\n        \\n        buy_price = prices[0] # at the begining the minimum price is the first price\\n        profit = 0 # at the begining the minimum  profit is zero\\n        \\n        for i in range(1,len(prices)):\\n            #if the current price is less than the previous buy price ; update the buy_price\\n            if prices[i] < buy_price:\\n                buy_price = prices[i]\\n            else: # if not check if you sell with the current price would you get better profit than the previous one\\n                profit = max(profit, prices[i]-buy_price) # compare the previous profit with the current profit\\n                \\n        return profit\\n\\t\\t\\n\\t\\t#Runtime: 916 ms\\n\\t\\t#Memory Usage: 23 MB\\n```\n```\\nclass Solution(object):\\n    def maxProfit(self, prices):\\n        n = len(prices)\\n        dp = [0]*n # initializing the dp table\\n        dp[0] = [prices[0],0] # filling the the first dp table --> low_price = prices[0] max_profit=0\\n        min_price = max_profit = 0\\n        # Note that ---> indixing the dp table --> dp[i-1][0] stores minimum price and dp[i-1][1] stores maximum profit\\n        for i in range(1,n):\\n            min_price = min(dp[i-1][0], prices[i]) # min(previous_min_price, cur_min_price)\\n            max_profit = max(dp[i-1][1], prices[i]-dp[i-1][0]) # max(previoius_max_profit, current_profit)\\n            dp[i] =[min_price,max_profit]\\n                \\n        return dp[n-1][1]\\n\\t\\t#Runtime: 1220 ms, \\n\\t\\t#Memory Usage: 32.4 MB,\\n```",
                "codeTag": "Java"
            },
            {
                "id": 39267,
                "title": "javascript-solution-if-anyone-is-interested",
                "content": "    var maxProfit = function(prices) {\\n        var min = Number.MAX_SAFE_INTEGER; \\n        var max = 0;\\n        for (var i = 0; i < prices.length; i++) {\\n            min = Math.min(min, prices[i]);\\n            max = Math.max(max, prices[i] - min);\\n        }\\n        return max;\\n    };",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "    var maxProfit = function(prices) {\\n        var min = Number.MAX_SAFE_INTEGER; \\n        var max = 0;\\n        for (var i = 0; i < prices.length; i++) {\\n            min = Math.min(min, prices[i]);\\n            max = Math.max(max, prices[i] - min);\\n        }\\n        return max;\\n    };",
                "codeTag": "Unknown"
            },
            {
                "id": 3226882,
                "title": "day-56-o-n-time-and-o-1-space-easiest-beginner-friendly-sol",
                "content": "# Intuition of this Problem:\\nThe intuition behind the code is to keep track of the minimum stock value seen so far while traversing the array from left to right. At each step, if the current stock value is greater than the minimum value seen so far, we calculate the profit that can be earned by selling the stock at the current value and buying at the minimum value seen so far, and update the maximum profit seen so far accordingly.\\n\\nBy keeping track of the minimum stock value and the maximum profit seen so far, we can solve the problem in a single pass over the array, without needing to consider all possible pairs of buy-sell transactions. This makes the code efficient and easy to implement.\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n**NOTE - PLEASE READ APPROACH FIRST THEN SEE THE CODE. YOU WILL DEFINITELY UNDERSTAND THE CODE LINE BY LINE AFTER SEEING THE APPROACH.**\\n\\n# Approach for this Problem:\\n1. Initialize a variable n to the size of the input vector prices.\\n2. Initialize variables maximumProfit and minStockVal to 0 and INT_MAX respectively.\\n3. Initialize a loop variable i to 0.\\n4. While i is less than n, do the following:\\n    - a. Set minStockVal to the minimum value between minStockVal and the value of prices at index i.\\n    - b. If minStockVal is less than or equal to the value of prices at index i, set maximumProfit to the maximum value between maximumProfit and the difference between prices at index i and minStockVal.\\n    - c. Increment i by 1.\\n1. Return maximumProfit.\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Humble Request:\\n- If my solution is helpful to you then please **UPVOTE** my solution, your **UPVOTE** motivates me to post such kind of solution.\\n- Please let me know in comments if there is need to do any improvement in my approach, code....anything.\\n- **Let\\'s connect on** https://www.linkedin.com/in/abhinash-singh-1b851b188\\n\\n![57jfh9.jpg](https://assets.leetcode.com/users/images/c2826b72-fb1c-464c-9f95-d9e578abcaf3_1674104075.4732099.jpeg)\\n\\n# Code:\\n```C++ []\\nclass Solution {\\npublic:\\n    int maxProfit(vector<int>& prices) {\\n        int n = prices.size();\\n        int maximumProfit = 0, minStockVal = INT_MAX;\\n        int i = 0;\\n        while (i < n) {\\n            minStockVal = min(minStockVal, prices[i]);\\n            // whenever the price of current stock is greater then then the stock value which we bought then only we will sell the stock \\n            if (prices[i] >= minStockVal)\\n                maximumProfit = max(maximumProfit, prices[i] - minStockVal);\\n            i++;\\n        }\\n        return maximumProfit;\\n    }\\n};\\n```\\n```Java []\\nclass Solution {\\n    public int maxProfit(int[] prices) {\\n        int n = prices.length;\\n        int maximumProfit = 0, minStockVal = Integer.MAX_VALUE;\\n        int i = 0;\\n        while (i < n) {\\n            minStockVal = Math.min(minStockVal, prices[i]);\\n            // whenever the price of current stock is greater then then the stock value which we bought then only we will sell the stock \\n            if (prices[i] >= minStockVal)\\n                maximumProfit = Math.max(maximumProfit, prices[i] - minStockVal);\\n            i++;\\n        }\\n        return maximumProfit;\\n    }\\n}\\n\\n```\\n```Python []\\nclass Solution:\\n    def maxProfit(self, prices: List[int]) -> int:\\n        n = len(prices)\\n        maximumProfit, minStockVal = 0, float(\\'inf\\')\\n        i = 0\\n        while i < n:\\n            minStockVal = min(minStockVal, prices[i])\\n            if prices[i] >= minStockVal:\\n                maximumProfit = max(maximumProfit, prices[i] - minStockVal)\\n            i += 1\\n        return maximumProfit\\n\\n```\\n\\n# Time Complexity and Space Complexity:\\n- Time complexity: **O(n)**, where n is the size of the input vector prices.\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: **O(1)**, as we are only using constant extra space for variables.\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->",
                "solutionTags": [
                    "C++",
                    "Java",
                    "Python3",
                    "Array"
                ],
                "code": "```C++ []\\nclass Solution {\\npublic:\\n    int maxProfit(vector<int>& prices) {\\n        int n = prices.size();\\n        int maximumProfit = 0, minStockVal = INT_MAX;\\n        int i = 0;\\n        while (i < n) {\\n            minStockVal = min(minStockVal, prices[i]);\\n            // whenever the price of current stock is greater then then the stock value which we bought then only we will sell the stock \\n            if (prices[i] >= minStockVal)\\n                maximumProfit = max(maximumProfit, prices[i] - minStockVal);\\n            i++;\\n        }\\n        return maximumProfit;\\n    }\\n};\\n```\n```Java []\\nclass Solution {\\n    public int maxProfit(int[] prices) {\\n        int n = prices.length;\\n        int maximumProfit = 0, minStockVal = Integer.MAX_VALUE;\\n        int i = 0;\\n        while (i < n) {\\n            minStockVal = Math.min(minStockVal, prices[i]);\\n            // whenever the price of current stock is greater then then the stock value which we bought then only we will sell the stock \\n            if (prices[i] >= minStockVal)\\n                maximumProfit = Math.max(maximumProfit, prices[i] - minStockVal);\\n            i++;\\n        }\\n        return maximumProfit;\\n    }\\n}\\n\\n```\n```Python []\\nclass Solution:\\n    def maxProfit(self, prices: List[int]) -> int:\\n        n = len(prices)\\n        maximumProfit, minStockVal = 0, float(\\'inf\\')\\n        i = 0\\n        while i < n:\\n            minStockVal = min(minStockVal, prices[i])\\n            if prices[i] >= minStockVal:\\n                maximumProfit = max(maximumProfit, prices[i] - minStockVal)\\n            i += 1\\n        return maximumProfit\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1280980,
                "title": "c-kadens-algo",
                "content": "**TIme complexity:O(n)\\nspace complexity:(1)**\\n```\\nclass Solution {\\npublic:\\n    int maxProfit(vector<int>& prices) {\\n        int profit=0;\\n        int minelem=prices[0];\\n        for(int i=1;i<prices.size();i++){\\n           minelem=min(prices[i],minelem);\\n            profit=max(profit,(prices[i]-minelem));\\n        }\\n        return profit;\\n    }\\n};\\n```\\nif you like the solution ,upvote it.",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int maxProfit(vector<int>& prices) {\\n        int profit=0;\\n        int minelem=prices[0];\\n        for(int i=1;i<prices.size();i++){\\n           minelem=min(prices[i],minelem);\\n            profit=max(profit,(prices[i]-minelem));\\n        }\\n        return profit;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 185218,
                "title": "javascript",
                "content": "```\nvar maxProfit = function(prices) {\n    let result = 0;\n    let min = prices[0];\n    for(let i = 1; i < prices.length; i++) {\n        min = Math.min(prices[i], min);\n        result = Math.max(result, prices[i] - min);\n    }\n    return result;\n};\n\n```",
                "solutionTags": [],
                "code": "```\nvar maxProfit = function(prices) {\n    let result = 0;\n    let min = prices[0];\n    for(let i = 1; i < prices.length; i++) {\n        min = Math.min(prices[i], min);\n        result = Math.max(result, prices[i] - min);\n    }\n    return result;\n};\n\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 39075,
                "title": "a-o-1-n-solution",
                "content": "1.for prices[0] .... prices[n], prices[n+1].....\\nif (prices[n] < prices[0]) then, the max profit is in prices[0]...prices[n], or begin from prices[n+1],\\notherwise, suppose prices[n+1] > prices[0], and max profit is happened between prices[n+1] , and \\nprices[n+k](k>1), then if we buy at day 0, and sell at day n+k, we get a bigger profit.\\n\\nBase on logic above, we can have a O(1*n) solution:\\n\\n    public class Solution {\\n        public int maxProfit(int[] prices) {\\n            \\n            if (prices.length == 0)\\n            {\\n                return 0;\\n            }\\n            \\n            int max = 0, min = prices[0];\\n            int profit = 0;\\n            \\n            for (int i = 1; i < prices.length; i++)\\n            {\\n                if (prices[i] < min)\\n                {\\n                    \\n                    min = prices[i];\\n                }\\n                else\\n                {\\n                    if (prices[i] - min > profit)\\n                    {\\n                        profit = prices[i] - min;\\n                    }\\n                    \\n                }\\n            }\\n         \\n       \\n         \\n         return profit;\\n         \\n        }\\n    }",
                "solutionTags": [],
                "code": "class Solution {\\n        public int maxProfit(int[] prices) {\\n            \\n            if (prices.length == 0)\\n            {\\n                return 0;\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 1505850,
                "title": "java-fastest-greedy-solution-100",
                "content": "````\\nclass Solution {\\n    public int maxProfit(int[] prices) {\\n        \\n        int max=0,min=prices[0];\\n        for(int i=1;i<prices.length;i++)   {\\n\\t\\t\\n            if(min<prices[i])\\n                max=Math.max(prices[i]-min,max);\\n            else\\n                min=prices[i];\\n        }\\n        return max;\\n    }\\n}\\n````\\n\\nIf it helped you then I will be happy if give a **upvote**!",
                "solutionTags": [
                    "Java",
                    "Greedy"
                ],
                "code": "````\\nclass Solution {\\n    public int maxProfit(int[] prices) {\\n        \\n        int max=0,min=prices[0];\\n        for(int i=1;i<prices.length;i++)   {\\n\\t\\t\\n            if(min<prices[i])\\n                max=Math.max(prices[i]-min,max);\\n            else\\n                min=prices[i];\\n        }\\n        return max;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 39230,
                "title": "5-line-cpp-solution",
                "content": "\\n    int maxProfit(vector<int>& prices) {\\n        int maxPro = 0, minPrice = INT_MAX;\\n        for(int i = 0; i < prices.size(); i++) {\\n            minPrice = min(minPrice, prices[i]);\\n            maxPro = max(prices[i] - minPrice, maxPro);\\n        }\\n        return maxPro;\\n    }",
                "solutionTags": [],
                "code": "\\n    int maxProfit(vector<int>& prices) {\\n        int maxPro = 0, minPrice = INT_MAX;\\n        for(int i = 0; i < prices.size(); i++) {\\n            minPrice = min(minPrice, prices[i]);\\n            maxPro = max(prices[i] - minPrice, maxPro);\\n        }\\n        return maxPro;\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 3227453,
                "title": "fast-java-solution",
                "content": "# JAVA Code\\n``` JAVA []\\nclass Solution {\\n    public int maxProfit(int[] prices) {\\n        int lsf = Integer.MAX_VALUE;\\n        int op = 0;\\n        int pist = 0;\\n        \\n        for(int i = 0; i < prices.length; i++){\\n            if(prices[i] < lsf){\\n                lsf = prices[i];\\n            }\\n            pist = prices[i] - lsf;\\n            if(op < pist){\\n                op = pist;\\n            }\\n        }\\n        return op;\\n    }\\n}\\n```\\n\\n![kitty.jpeg](https://assets.leetcode.com/users/images/6233d50d-1433-4516-8d8e-90fb8e13d32f_1677303191.974716.jpeg)\\n",
                "solutionTags": [
                    "Java"
                ],
                "code": "``` JAVA []\\nclass Solution {\\n    public int maxProfit(int[] prices) {\\n        int lsf = Integer.MAX_VALUE;\\n        int op = 0;\\n        int pist = 0;\\n        \\n        for(int i = 0; i < prices.length; i++){\\n            if(prices[i] < lsf){\\n                lsf = prices[i];\\n            }\\n            pist = prices[i] - lsf;\\n            if(op < pist){\\n                op = pist;\\n            }\\n        }\\n        return op;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2040282,
                "title": "o-n-time-beats-99-97-memory-speed-0ms-may-2022",
                "content": "**As a professional with a passion for problem-solving and collaboration, I am always looking to expand my network of like-minded individuals on LinkedIn. By connecting with me, we can work together to tackle complex challenges, share ideas, and grow both professionally and personally.**\\n\\n**Whether you\\'re an expert in your field or just starting out, I welcome connections from all backgrounds and experiences. By building a diverse and collaborative network, we can leverage our unique perspectives and skill sets to push the boundaries of what\\'s possible.**\\n\\n**So, if you\\'re interested in connecting and exploring the potential for future collaborations, please don\\'t hesitate to reach out. Let\\'s start a conversation and see where it takes us!**\\n\\n---\\n\\nhttps://www.linkedin.com/in/cucerdariancatalin/\\nhttps://www.linkedin.com/in/cucerdariancatalin/\\nhttps://www.linkedin.com/in/cucerdariancatalin/\\n\\n---\\n\\n```\\n```\\n\\n(Note: This is part of a series of Leetcode solution explanations. If you like this solution or find it useful, ***please upvote*** this post.)\\n***Take care brother, peace, love!***\\n\\n```\\n```\\n\\n```\\n```\\n\\n```\\n```\\n\\nThe best result for the code below is ***0ms / 38.2MB*** (beats 92.04% / 24.00%).\\n* ***Java***\\n```\\nclass Solution {\\n    public int maxProfit(int[] prices) {\\n        \\n        int max=0,min=prices[0];\\n        for(int i=1;i<prices.length;i++)   {\\n\\t\\t\\n            if(min<prices[i])\\n                max=Math.max(prices[i]-min,max);\\n            else\\n                min=prices[i];\\n        }\\n        return max;\\n    }\\n}\\n```\\n\\n```\\n```\\n\\n```\\n```\\n\\nThe best result for the code below is ***0ms / 7.0MB*** (beats 100.00% / 100.00%).\\n* ***C++***\\n```\\nint maxProfit(vector<int>& prices) {\\n        int n= prices.size();\\n        int maxprofit = 0;\\n        int minvalue = INT_MAX;\\n        for(int i =0;i<n;i++){\\n            minvalue = min(prices[i],minvalue);\\n            maxprofit= max(maxprofit,prices[i] - minvalue);\\n        }\\n        return maxprofit;\\n    }\\n```\\n\\n```\\n```\\n\\n```\\n```\\n\\n\\nThe best result for the code below is ***26ms / 12.2MB*** (beats 95.42% / 82.32%).\\n* ***Python***\\n```\\nclass Solution:\\n    def maxProfit(self,prices):\\n        left = 0 #Buy\\n        right = 1 #Sell\\n        max_profit = 0\\n        while right < len(prices):\\n            currentProfit = prices[right] - prices[left] #our current Profit\\n            if prices[left] < prices[right]:\\n                max_profit =max(currentProfit,max_profit)\\n            else:\\n                left = right\\n            right += 1\\n        return max_profit\\n```\\n\\n```\\n```\\n\\n```\\n```\\n\\nThe best result for the code below is ***51ms / 34.2MB*** (beats 100.00% / 84.12%).\\n* ***JavaScript***\\n```\\nconst maxProfit = (prices) => {\\n  let left = 0; // Buy\\n  let right = 1; // sell\\n  let max_profit = 0;\\n  while (right < prices.length) {\\n    if (prices[left] < prices[right]) {\\n      let profit = prices[right] - prices[left]; // our current profit\\n\\n      max_profit = Math.max(max_profit, profit);\\n    } else {\\n      left = right;\\n    }\\n    right++;\\n  }\\n  return max_profit;\\n};\\n```\\n\\n```\\n```\\n\\n```\\n```\\n\\nThe best result for the code below is ***68ms / 44.2MB*** (beats 100.00% / 45.25%).\\n* ***Kotlin***\\n```\\nfun maxProfit(prices: IntArray): Int {\\n   prices.foldIndexed<Int>(prices[0]) { i, min, n ->\\n\\t\\tprices[i] = n - min\\n\\t\\tif (n < min) n else min\\n   }\\n   return prices.max() ?: 0\\n} \\n```\\n\\n```\\n```\\n\\n```\\n```\\n\\nThe best result for the code below is ***12ms / 32.2MB*** (beats 95% / 84%).\\n* ***Swift***\\n```\\nfunc maxProfit(_ prices: [Int]) -> Int {\\n    guard prices.count > 1 else { return 0 }\\n    var best = 0, current = 0\\n    for index in 1..<prices.endIndex {\\n        current = max(0, current + prices[index] - prices[index-1])\\n        best = max(best, current)\\n    }\\n    return best\\n}\\n```\\n\\n```\\n```\\n\\n```\\n```\\n\\n***\"Open your eyes. Expect us.\" - \\uD835\\uDCD0\\uD835\\uDCF7\\uD835\\uDCF8\\uD835\\uDCF7\\uD835\\uDD02\\uD835\\uDCF6\\uD835\\uDCF8\\uD835\\uDCFE\\uD835\\uDCFC***",
                "solutionTags": [
                    "C++",
                    "Java",
                    "Python",
                    "Python3",
                    "C",
                    "JavaScript",
                    "Swift",
                    "Kotlin"
                ],
                "code": "```\\n```\n```\\n```\n```\\n```\n```\\n```\n```\\nclass Solution {\\n    public int maxProfit(int[] prices) {\\n        \\n        int max=0,min=prices[0];\\n        for(int i=1;i<prices.length;i++)   {\\n\\t\\t\\n            if(min<prices[i])\\n                max=Math.max(prices[i]-min,max);\\n            else\\n                min=prices[i];\\n        }\\n        return max;\\n    }\\n}\\n```\n```\\n```\n```\\n```\n```\\nint maxProfit(vector<int>& prices) {\\n        int n= prices.size();\\n        int maxprofit = 0;\\n        int minvalue = INT_MAX;\\n        for(int i =0;i<n;i++){\\n            minvalue = min(prices[i],minvalue);\\n            maxprofit= max(maxprofit,prices[i] - minvalue);\\n        }\\n        return maxprofit;\\n    }\\n```\n```\\n```\n```\\n```\n```\\nclass Solution:\\n    def maxProfit(self,prices):\\n        left = 0 #Buy\\n        right = 1 #Sell\\n        max_profit = 0\\n        while right < len(prices):\\n            currentProfit = prices[right] - prices[left] #our current Profit\\n            if prices[left] < prices[right]:\\n                max_profit =max(currentProfit,max_profit)\\n            else:\\n                left = right\\n            right += 1\\n        return max_profit\\n```\n```\\n```\n```\\n```\n```\\nconst maxProfit = (prices) => {\\n  let left = 0; // Buy\\n  let right = 1; // sell\\n  let max_profit = 0;\\n  while (right < prices.length) {\\n    if (prices[left] < prices[right]) {\\n      let profit = prices[right] - prices[left]; // our current profit\\n\\n      max_profit = Math.max(max_profit, profit);\\n    } else {\\n      left = right;\\n    }\\n    right++;\\n  }\\n  return max_profit;\\n};\\n```\n```\\n```\n```\\n```\n```\\nfun maxProfit(prices: IntArray): Int {\\n   prices.foldIndexed<Int>(prices[0]) { i, min, n ->\\n\\t\\tprices[i] = n - min\\n\\t\\tif (n < min) n else min\\n   }\\n   return prices.max() ?: 0\\n} \\n```\n```\\n```\n```\\n```\n```\\nfunc maxProfit(_ prices: [Int]) -> Int {\\n    guard prices.count > 1 else { return 0 }\\n    var best = 0, current = 0\\n    for index in 1..<prices.endIndex {\\n        current = max(0, current + prices[index] - prices[index-1])\\n        best = max(best, current)\\n    }\\n    return best\\n}\\n```\n```\\n```\n```\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3227007,
                "title": "simplest-solution-beginner-friendly-dp-c-python-java",
                "content": "# Consider\\uD83D\\uDC4D\\n```\\n                    Please Upvote If You Find It Helpful\\n```\\n# Intuition\\nIn this question we have to find the **Maximum Profit**.\\nSo, we find the **stock with Minimum value** and then **check for maximum profit**.\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n    Example : prices = [7,1,5,3,6,4]\\n    Initially `minValue` = INT_MAX, `profit` = 0\\n    At index `0` \\n        `minValue` = min(minValue, 7)\\n        profit = max(profit, 7 - minValue)\\n        so, `profit` = 0\\n    At index `1` \\n        minValue = min(minValue, 1)\\n        profit = max(profit, 1 - 1)\\n        so, `profit` = 0\\n    At index `2` \\n        minValue = min(minValue, 5)\\n        profit = max(profit, 5 - 1)\\n        so, `profit` = 4\\n    At index `3` \\n        minValue = min(minValue, 3)\\n        profit = max(profit, 3 - 1)\\n        so, `profit` = 4\\n    At index `4` \\n        minValue = min(minValue, 6)\\n        profit = max(profit, 6 - 1)\\n        so, `profit` = 5\\n    At index `5` \\n        minValue = min(minValue, 4)\\n        profit = max(profit, 4 - 1)\\n        so, `profit` = 5\\n    So answer is `5`\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity: O(n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```C++ []\\nclass Solution {\\npublic:\\n    int maxProfit(vector<int>& prices) {\\n        int minValue = INT_MAX;\\n        int profit = 0;\\n        for(int i=0;i<prices.size();i++){\\n            minValue = min(minValue, prices[i]);\\n            profit = max(profit, prices[i]-minValue);\\n        }\\n        return profit;\\n    }\\n};\\n```\\n```python []\\nclass Solution:\\n    def maxProfit(self, prices: List[int]) -> int:\\n        minValue = 1e9\\n        profit = 0\\n\\n        for i in range(len(prices)):\\n            minValue = min(minValue, prices[i])\\n            profit = max(profit, prices[i]-minValue)\\n        \\n        return profit\\n```\\n```Java []\\nclass Solution {\\n    public int maxProfit(int[] prices) {\\n        int minValue = Integer.MAX_VALUE;\\n        int profit = 0;\\n        for (int i = 0; i < prices.length; i++) {\\n            minValue = Math.min(minValue, prices[i]);\\n            profit = Math.max(profit, prices[i] - minValue);\\n        }\\n        return profit;\\n    }\\n}\\n\\n```\\n\\n```\\n                            Give a \\uD83D\\uDC4D. It motivates me alot\\n```\\nLet\\'s Connect On [Linkedin](https://www.linkedin.com/in/naman-agarwal-0551aa1aa/)",
                "solutionTags": [
                    "C++",
                    "Java",
                    "Python",
                    "Python3",
                    "Dynamic Programming"
                ],
                "code": "```\\n                    Please Upvote If You Find It Helpful\\n```\n```C++ []\\nclass Solution {\\npublic:\\n    int maxProfit(vector<int>& prices) {\\n        int minValue = INT_MAX;\\n        int profit = 0;\\n        for(int i=0;i<prices.size();i++){\\n            minValue = min(minValue, prices[i]);\\n            profit = max(profit, prices[i]-minValue);\\n        }\\n        return profit;\\n    }\\n};\\n```\n```python []\\nclass Solution:\\n    def maxProfit(self, prices: List[int]) -> int:\\n        minValue = 1e9\\n        profit = 0\\n\\n        for i in range(len(prices)):\\n            minValue = min(minValue, prices[i])\\n            profit = max(profit, prices[i]-minValue)\\n        \\n        return profit\\n```\n```Java []\\nclass Solution {\\n    public int maxProfit(int[] prices) {\\n        int minValue = Integer.MAX_VALUE;\\n        int profit = 0;\\n        for (int i = 0; i < prices.length; i++) {\\n            minValue = Math.min(minValue, prices[i]);\\n            profit = Math.max(profit, prices[i] - minValue);\\n        }\\n        return profit;\\n    }\\n}\\n\\n```\n```\\n                            Give a \\uD83D\\uDC4D. It motivates me alot\\n```",
                "codeTag": "Java"
            },
            {
                "id": 851941,
                "title": "python-o-n-dynamic-programming-solution-explained",
                "content": "Classical dynamic programming problem. Let `dp[i]` be a maximum profit we can have if we sell stock at `i`-th moment of time. Then we can get, that `dp[i+1] = max(dp[i] + q, q)`, where `q = nums[i+1] - nums[i]`, we have two choices, either we just buy and immeditely sell and get `q` gain, or we use `dp[i] + q` to merge two transactions. \\n\\nNote now, that we do not really need to keep all `dp` array, but we can keep only last state.\\n\\n**Complexity**: time complexity is `O(n)`, space complexity is `O(1)`.\\n\\n```\\nclass Solution:\\n    def maxProfit(self, nums):\\n        ans, dp = 0, 0\\n        for i in range(0, len(nums)-1):\\n            q = nums[i+1] - nums[i]\\n            dp = max(dp + q, q)\\n            ans = max(ans, dp)\\n        return ans\\n```\\n\\n**PS** Look also my solutions to similar problems: \\nBest Time to Buy and Sell Stock III\\nhttps://leetcode.com/problems/best-time-to-buy-and-sell-stock-iii/discuss/794633/Python-O(n)-solution-with-optimization-explained\\nBest Time to Buy and Sell Stock with Cooldown\\nhttps://leetcode.com/problems/best-time-to-buy-and-sell-stock-with-cooldown/discuss/761720/Python-dp-O(n)-solution-using-differences-explained\\n\\nIf you have any questions, feel free to ask. If you like solution and explanations, please **Upvote!**",
                "solutionTags": [
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution:\\n    def maxProfit(self, nums):\\n        ans, dp = 0, 0\\n        for i in range(0, len(nums)-1):\\n            q = nums[i+1] - nums[i]\\n            dp = max(dp + q, q)\\n            ans = max(ans, dp)\\n        return ans\\n```",
                "codeTag": "Java"
            },
            {
                "id": 172820,
                "title": "explanation-for-algorithm-why-this-is-dp",
                "content": "There are several solutions that invoke some recursive formula resembling\\n```\\nProfit_if_sold[i] = max(0, Profit_if_sold[i-1] + Diff_from_last[i])\\n```\\nwithout motivating how this formula is obtained. This post provides the explanation for **how** one arrives at this recursive formula.\\n\\n1. To arrive at this formula, you must first identify the optimal strategy. Realize that at time ```i```, you have three possible actions: buy, hold, or sell. The optimal actions to take are:\\n\\ta. **Buy the stock** if it is the minimum price-to-date, i.e. ```P_i < P_j``` for all ```j < i```\\n\\tb. **Hold / sell the stock** if it is not at the minimum price to-date, i.e. ```P_j < P_i``` for some ```j < i```\\n\\n2. To implement the strategy, it is informative to look at a concrete example:\\n```\\nPrices =         [7, 1, 5, 3, 6, 4, 0, 7] \\nMin_to_date =    [7, 1, 1, 1, 1, 1, 0, 0] \\nProfit_if_sold = [0, 0, 4, 2, 5, 3, 0, 7]\\nDiff_from_last = [0,-6, 4,-2, 3,-2,-4, 7]\\n```\\n* ```Prices``` are the stock prices\\n* ```Min_to_date``` is the minimum price to date\\n* ```Profit_if_sold``` is the profit if a stock was sold at step ```i```; note that it is ```0``` if is the min-to-date, as that would be the time to buy according to the strategy\\n* ```Diff_from_last[i] = P[i] - P[i-1]```\\n\\nIt is clear that the solution to the problem statement is ```max(Profit_if_sold)```. So how do you calculate ```Profit_if_sold```? You calculate it using the recursive formula\\n```\\nProfit_if_sold[i] = max(0, Profit_if_sold[i-1] + Diff_from_last[i]) \\n```\\nThis is the recursive formula used in several solutions. As this a recursive formula, one can consider this problem a DP problem",
                "solutionTags": [],
                "code": "```\\nProfit_if_sold[i] = max(0, Profit_if_sold[i-1] + Diff_from_last[i])\\n```\n```i```\n```P_i < P_j```\n```j < i```\n```P_j < P_i```\n```j < i```\n```\\nPrices =         [7, 1, 5, 3, 6, 4, 0, 7] \\nMin_to_date =    [7, 1, 1, 1, 1, 1, 0, 0] \\nProfit_if_sold = [0, 0, 4, 2, 5, 3, 0, 7]\\nDiff_from_last = [0,-6, 4,-2, 3,-2,-4, 7]\\n```\n```Prices```\n```Min_to_date```\n```Profit_if_sold```\n```i```\n```0```\n```Diff_from_last[i] = P[i] - P[i-1]```\n```max(Profit_if_sold)```\n```Profit_if_sold```\n```\\nProfit_if_sold[i] = max(0, Profit_if_sold[i-1] + Diff_from_last[i]) \\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 711530,
                "title": "python-beginner-simple-solution",
                "content": "If the code helped, would appreciate an upvote.\\n\\'\\'\\'\\nclass Solution:\\n    \\n\\tdef maxProfit(self, prices: List[int]) -> int:\\n\\t\\t\\n\\t\\tif not prices:\\n            return 0\\n\\n        profit = 0\\n\\n        buy_stock = prices[0]\\n\\n        for i in range(len(prices)):\\n\\n            # update the buy_stock if there\\'s\\n            # any smaller value is present in the list\\n            if buy_stock > prices[i]:\\n                buy_stock = prices[i]\\n\\n            # Now we\\'ve buy_stock.\\n            # Calculate the max of price diff and profit made till now\\n            profit = max((prices[i] - buy_stock, profit))\\n\\n        return profit",
                "solutionTags": [
                    "Python3"
                ],
                "code": "If the code helped, would appreciate an upvote.\\n\\'\\'\\'\\nclass Solution:\\n    \\n\\tdef maxProfit(self, prices: List[int]) -> int:\\n\\t\\t\\n\\t\\tif not prices:\\n            return 0\\n\\n        profit = 0\\n\\n        buy_stock = prices[0]\\n\\n        for i in range(len(prices)):\\n\\n            # update the buy_stock if there\\'s\\n            # any smaller value is present in the list\\n            if buy_stock > prices[i]:\\n                buy_stock = prices[i]\\n\\n            # Now we\\'ve buy_stock.\\n            # Calculate the max of price diff and profit made till now\\n            profit = max((prices[i] - buy_stock, profit))\\n\\n        return profit",
                "codeTag": "Java"
            },
            {
                "id": 39171,
                "title": "java-6-lines-4-lines-2-lines-solutions",
                "content": "I only count the new lines of code that I've written, i.e. everything except for the method definition and the method closing bracket.\\n\\nProper Java - 6 lines:\\n\\n    public int maxProfit(int[] prices) {\\n         int min = Integer.MAX_VALUE, max = 0;\\n         for (int i = 0; i < prices.length; i++) {\\n             min = Math.min(min, prices[i]);\\n             max = Math.max(max, prices[i] - min);\\n         }\\n         return max;\\n     }  \\n\\nProper Java with shortcuts - 4 lines:\\n  \\n    public int maxProfit(int[] prices) {\\n        int min = Integer.MAX_VALUE, max = 0;\\n        for (int i = 0; i < prices.length; i++)\\n            max = Math.max(max, prices[i] - (min = Math.min(min, prices[i])));\\n        return max;\\n    }\\n\\nJava 8 streams - 2 lines:\\n\\n    int min = Integer.MAX_VALUE;\\n    public int maxProfit(int[] prices) {\\n        return Arrays.stream(prices).map(i -> i - (min = Math.min(min, i))).max().orElse(0);\\n    }",
                "solutionTags": [],
                "code": "I only count the new lines of code that I've written, i.e. everything except for the method definition and the method closing bracket.\\n\\nProper Java - 6 lines:\\n\\n    public int maxProfit(int[] prices) {\\n         int min = Integer.MAX_VALUE, max = 0;\\n         for (int i = 0; i < prices.length; i++) {\\n             min = Math.min(min, prices[i]);\\n             max = Math.max(max, prices[i] - min);\\n         }\\n         return max;\\n     }  \\n\\nProper Java with shortcuts - 4 lines:\\n  \\n    public int maxProfit(int[] prices) {\\n        int min = Integer.MAX_VALUE, max = 0;\\n        for (int i = 0; i < prices.length; i++)\\n            max = Math.max(max, prices[i] - (min = Math.min(min, prices[i])));\\n        return max;\\n    }\\n\\nJava 8 streams - 2 lines:\\n\\n    int min = Integer.MAX_VALUE;\\n    public int maxProfit(int[] prices) {\\n        return Arrays.stream(prices).map(i -> i - (min = Math.min(min, i))).max().orElse(0);\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 39234,
                "title": "clean-java-solution-with-o-n-time-and-o-1-space",
                "content": "First attempt - simple brute force solution (just coded up problem definition):\\n\\n    // O(n^2) time, O(1) space\\n    public int maxProfit(int[] prices) {\\n        int profit = 0;\\n        for (int i = 0; i < prices.length; i++) {\\n            for (int j = i; j >= 0; j--) {\\n                profit = Math.max(profit, prices[i]-prices[j]);\\n            }\\n        }\\n        return profit;\\n    }\\n\\nSecond attempt - tried to solve iterating over array two times:\\n\\nfirst pass - from left to right and saving current minimum in additional array \\n\\nsecond pass - from right to left finding maximum of current profit and previous maximum profit\\n\\n    // O(n) time, O(n) space\\n    public int maxProfit(int[] prices) {\\n        int[] minPrices = new int[prices.length];\\n        int currentMinPrice = prices.length > 0 ? prices[0] : 0;\\n        for (int i = 0; i < prices.length; i++) {\\n            currentMinPrice = Math.min(currentMinPrice, prices[i]);\\n            minPrices[i] = currentMinPrice;\\n        }\\n        \\n        int currentMaxPrice = prices.length > 0 ? prices[prices.length - 1] : 0;\\n        int profit = currentMaxPrice - currentMinPrice;\\n        for (int i = prices.length - 1; i >= 0 ; i--) {\\n            currentMaxPrice = Math.max(currentMaxPrice, prices[i]);\\n            profit = Math.max(profit, currentMaxPrice - minPrices[i]);\\n        }\\n        return profit;\\n    }\\n\\nThird attempt - finally figured out, that keeping current minimum in separate array is really not required:\\n      \\n    // O(n) time, O(1) space\\n    public int maxProfit(int[] prices) {\\n        int currentMinPrice = prices.length > 0 ? prices[0] : 0;\\n        int profit = 0;\\n        for (int i = 0; i < prices.length; i++) {\\n            currentMinPrice = Math.min(currentMinPrice, prices[i]);\\n            profit = Math.max(profit, prices[i] - currentMinPrice); \\n        }\\n        return profit;\\n    }",
                "solutionTags": [
                    "Java",
                    "Array"
                ],
                "code": "First attempt - simple brute force solution (just coded up problem definition):\\n\\n    // O(n^2) time, O(1) space\\n    public int maxProfit(int[] prices) {\\n        int profit = 0;\\n        for (int i = 0; i < prices.length; i++) {\\n            for (int j = i; j >= 0; j--) {\\n                profit = Math.max(profit, prices[i]-prices[j]);\\n            }\\n        }\\n        return profit;\\n    }\\n\\nSecond attempt - tried to solve iterating over array two times:\\n\\nfirst pass - from left to right and saving current minimum in additional array \\n\\nsecond pass - from right to left finding maximum of current profit and previous maximum profit\\n\\n    // O(n) time, O(n) space\\n    public int maxProfit(int[] prices) {\\n        int[] minPrices = new int[prices.length];\\n        int currentMinPrice = prices.length > 0 ? prices[0] : 0;\\n        for (int i = 0; i < prices.length; i++) {\\n            currentMinPrice = Math.min(currentMinPrice, prices[i]);\\n            minPrices[i] = currentMinPrice;\\n        }\\n        \\n        int currentMaxPrice = prices.length > 0 ? prices[prices.length - 1] : 0;\\n        int profit = currentMaxPrice - currentMinPrice;\\n        for (int i = prices.length - 1; i >= 0 ; i--) {\\n            currentMaxPrice = Math.max(currentMaxPrice, prices[i]);\\n            profit = Math.max(profit, currentMaxPrice - minPrices[i]);\\n        }\\n        return profit;\\n    }\\n\\nThird attempt - finally figured out, that keeping current minimum in separate array is really not required:\\n      \\n    // O(n) time, O(1) space\\n    public int maxProfit(int[] prices) {\\n        int currentMinPrice = prices.length > 0 ? prices[0] : 0;\\n        int profit = 0;\\n        for (int i = 0; i < prices.length; i++) {\\n            currentMinPrice = Math.min(currentMinPrice, prices[i]);\\n            profit = Math.max(profit, prices[i] - currentMinPrice); \\n        }\\n        return profit;\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 1735436,
                "title": "c-solutions-using-kadane-s-algorithm",
                "content": "smjh\\n```\\nint maxProfit(vector<int>& prices) {\\n        int n= prices.size();\\n        int maxprofit = 0;\\n        int minvalue = INT_MAX;\\n        for(int i =0;i<n;i++){\\n            minvalue = min(prices[i],minvalue);\\n            maxprofit= max(maxprofit,prices[i] - minvalue);\\n        }\\n        return maxprofit;\\n    }\\n```\\nDo upvote if you find it helpful",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nint maxProfit(vector<int>& prices) {\\n        int n= prices.size();\\n        int maxprofit = 0;\\n        int minvalue = INT_MAX;\\n        for(int i =0;i<n;i++){\\n            minvalue = min(prices[i],minvalue);\\n            maxprofit= max(maxprofit,prices[i] - minvalue);\\n        }\\n        return maxprofit;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1144842,
                "title": "several-solutions-in-python",
                "content": "We only want to buy once, sell once.\\n\\n**Brute force** - compare each element, find max diff\\n```\\n    def maxProfit(self, p):\\n        n = len(p)\\n        max_so_far = 0\\n        \\n        for i in range(n):\\n            for j in range(i+1,n):\\n                max_so_far = max(max_so_far, p[j] - p[i])\\n                \\n        return max_so_far           \\n```\\nTime: `O(n^2)`\\nSpace: `O(1)`\\n\\n**Kadane\\'s algorithm** \\nIf the \"profit so far\" `cur` becomes negative, start from 0.\\nOtherwise add it to current diff `p[i] - p[i-1]` and update `max_so_far` (max profit so far).\\n```\\n    def maxProfit(self, p):\\n        n = len(p)\\n        max_so_far, cur = 0, 0\\n        \\n        for i in range(1,n):\\n            cur = max(cur + p[i] - p[i-1], 0)\\n            max_so_far = max(cur, max_so_far)\\n        return max_so_far           \\n```\\nTime: `O(n)`\\nSpace: `O(1)`\\n\\n**Comparing with min**\\nKeep the `min_so_far` (min element so far) value along with `max_so_far` (max profit so far).\\nFind the diff of `p[i]` with `min_so_far` at each step and update `max_so_far` if it exceeds it.\\n```\\n    def maxProfit(self, p):\\n        n = len(p)\\n        min_so_far, max_so_far = math.inf, 0\\n        \\n        for i in range(n):\\n            cur = p[i] - min_so_far\\n            max_so_far = max(cur, max_so_far)\\n            min_so_far = min(min_so_far, p[i])\\n        return max_so_far\\n```\\nTime: `O(n)`\\nSpace: `O(1)`\\n\\n**Slightly more Pythonic or one-liner solution**\\n```\\ndef maxProfit(self, p):\\n        res, min_so_far = 0, math.inf\\n        \\n        for p1 in p:\\n            res, min_so_far = max(res, p1 - min_so_far), min(min_so_far, p1)\\n        \\n        return res\\n```\\nTime: `O(n)`\\nSpace: `O(1)`",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Dynamic Programming"
                ],
                "code": "```\\n    def maxProfit(self, p):\\n        n = len(p)\\n        max_so_far = 0\\n        \\n        for i in range(n):\\n            for j in range(i+1,n):\\n                max_so_far = max(max_so_far, p[j] - p[i])\\n                \\n        return max_so_far           \\n```\n```\\n    def maxProfit(self, p):\\n        n = len(p)\\n        max_so_far, cur = 0, 0\\n        \\n        for i in range(1,n):\\n            cur = max(cur + p[i] - p[i-1], 0)\\n            max_so_far = max(cur, max_so_far)\\n        return max_so_far           \\n```\n```\\n    def maxProfit(self, p):\\n        n = len(p)\\n        min_so_far, max_so_far = math.inf, 0\\n        \\n        for i in range(n):\\n            cur = p[i] - min_so_far\\n            max_so_far = max(cur, max_so_far)\\n            min_so_far = min(min_so_far, p[i])\\n        return max_so_far\\n```\n```\\ndef maxProfit(self, p):\\n        res, min_so_far = 0, math.inf\\n        \\n        for p1 in p:\\n            res, min_so_far = max(res, p1 - min_so_far), min(min_so_far, p1)\\n        \\n        return res\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 1659852,
                "title": "easy-c-solution-in-few-line-of-code",
                "content": "> **If you\\u2019re interested in coding you can join my Discord Server, link in the comment section. Also if you find any mistake please let me know. Thank you!\\u2764\\uFE0F**\\n> \\n\\n---\\n\\n## Explanation:\\n\\n### Solution 01\\n\\n- The idea is quite simple, we\\u2019ve to find the max profit by selling the stocks.\\n- We took 2 int variables: **mn** *(to store the minimum till a particular date)* **& ans.**\\n- Run a for loop and in every time check for the minimum value till that iteration and store it in mn ~**min(mn, prices[i])**.\\n- Also, find the ans with **max(ans, prices[i]-mn)**.\\n- **Time complexity:** O(n).\\n\\n---\\n\\n## Solution:\\n\\n```cpp\\n//Solution 01:\\nclass Solution {\\npublic:\\n    int maxProfit(vector<int>& prices) {\\n        int n= prices.size();\\n        int mn= INT_MAX;\\n        int ans=0;\\n        \\n        for(int i=0; i<n; i++){\\n            mn = min(mn, prices[i]);\\n            ans = max(ans, prices[i]-mn);\\n        }\\n        \\n        return ans;\\n    }\\n};\\n```\\n\\n---\\n\\n> **Please upvote this solution**\\n>",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```cpp\\n//Solution 01:\\nclass Solution {\\npublic:\\n    int maxProfit(vector<int>& prices) {\\n        int n= prices.size();\\n        int mn= INT_MAX;\\n        int ans=0;\\n        \\n        for(int i=0; i<n; i++){\\n            mn = min(mn, prices[i]);\\n            ans = max(ans, prices[i]-mn);\\n        }\\n        \\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1057073,
                "title": "simple-o-n-java-solution",
                "content": "```\\n     public int maxProfit(int[] prices) {\\n        int minPrice = prices[0];\\n        int maxProfit = 0;\\n        for(int price:prices){\\n            minPrice = Math.min(minPrice,price);\\n            maxProfit = Math.max(maxProfit,price-minPrice);\\n        }\\n        return maxProfit;\\n    }\\n```",
                "solutionTags": [],
                "code": "```\\n     public int maxProfit(int[] prices) {\\n        int minPrice = prices[0];\\n        int maxProfit = 0;\\n        for(int price:prices){\\n            minPrice = Math.min(minPrice,price);\\n            maxProfit = Math.max(maxProfit,price-minPrice);\\n        }\\n        return maxProfit;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 39281,
                "title": "java-simple-solution",
                "content": "  public int maxProfit(int[] prices) {\\n    \\n        int le = prices.length, maxD = 0, min = Integer.MAX_VALUE;\\n    \\n        for (int i = 0; i < le; i++){ \\n            min = Math.min(min, prices[i]);\\n            maxD = Math.max(maxD, prices[i] - min);\\n        }\\n\\n        return maxD;       \\n}",
                "solutionTags": [],
                "code": "  public int maxProfit(int[] prices) {\\n    \\n        int le = prices.length, maxD = 0, min = Integer.MAX_VALUE;\\n    \\n        for (int i = 0; i < le; i++){ \\n            min = Math.min(min, prices[i]);\\n            maxD = Math.max(maxD, prices[i] - min);\\n        }\\n\\n        return maxD;       \\n}",
                "codeTag": "Unknown"
            },
            {
                "id": 1932147,
                "title": "100-fastest-swift-solution-time-o-n-space-o-1",
                "content": "```\\nclass Solution {\\n    // - Complexity:\\n    //   - time: O(n), where n is the number of prices.\\n    //   - space: O(1), only constant space is used.\\n    \\n    func maxProfit(_ prices: [Int]) -> Int {\\n        var minPrice = Int.max\\n        var ans = 0\\n        \\n        for price in prices {\\n            minPrice = min(minPrice, price)\\n            ans = max(ans, price - minPrice)\\n        }\\n        \\n        return ans        \\n    }\\n\\n}\\n```\\n\\nLet me know in comments if you have any doubts. I will be happy to answer.\\n\\nPlease upvote if you found the solution useful.",
                "solutionTags": [
                    "Swift"
                ],
                "code": "```\\nclass Solution {\\n    // - Complexity:\\n    //   - time: O(n), where n is the number of prices.\\n    //   - space: O(1), only constant space is used.\\n    \\n    func maxProfit(_ prices: [Int]) -> Int {\\n        var minPrice = Int.max\\n        var ans = 0\\n        \\n        for price in prices {\\n            minPrice = min(minPrice, price)\\n            ans = max(ans, price - minPrice)\\n        }\\n        \\n        return ans        \\n    }\\n\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1161290,
                "title": "simple-o-n-python-solution",
                "content": "920ms, faster than 96.58%\\n```\\nclass Solution:\\n    def maxProfit(self, prices: List[int]) -> int:\\n        max_profit = 0\\n        best_price_to_buy = prices[0]\\n        for price in prices:\\n            if price < best_price_to_buy:\\n                best_price_to_buy = price\\n            elif price > best_price_to_buy:\\n                profit = price - best_price_to_buy\\n                if profit > max_profit:\\n                    max_profit = profit\\n        return max_profit\\n```",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def maxProfit(self, prices: List[int]) -> int:\\n        max_profit = 0\\n        best_price_to_buy = prices[0]\\n        for price in prices:\\n            if price < best_price_to_buy:\\n                best_price_to_buy = price\\n            elif price > best_price_to_buy:\\n                profit = price - best_price_to_buy\\n                if profit > max_profit:\\n                    max_profit = profit\\n        return max_profit\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2822579,
                "title": "easy-c-o-n-soln-faang-interview-optimized-code",
                "content": "\\n# Complexity\\n- Time complexity: O(n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code \\uD83D\\uDCA1\\n```\\nclass Solution {\\npublic:\\n    int maxProfit(vector<int>& prices) {\\n        int low = prices[0], curr_profit = 0, ovr_profit = 0;\\n        for(int  i = 1; i < prices.size(); i++){\\n            if(prices[i]<low){\\n                low = prices[i];\\n            }\\n            curr_profit = prices[i]-low;\\n            if(curr_profit > ovr_profit)\\n                ovr_profit = curr_profit;\\n        }\\n        return ovr_profit;\\n    }\\n};\\n```\\n\\n# **Please Upvote if it helps \\uD83D\\uDE4F**",
                "solutionTags": [
                    "C++",
                    "Java",
                    "Python3",
                    "Array",
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int maxProfit(vector<int>& prices) {\\n        int low = prices[0], curr_profit = 0, ovr_profit = 0;\\n        for(int  i = 1; i < prices.size(); i++){\\n            if(prices[i]<low){\\n                low = prices[i];\\n            }\\n            curr_profit = prices[i]-low;\\n            if(curr_profit > ovr_profit)\\n                ovr_profit = curr_profit;\\n        }\\n        return ovr_profit;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1735444,
                "title": "5-lines-sol-c-easy-to-undersatand",
                "content": "```\\n\\n```class Solution {\\npublic:\\n    int maxProfit(vector<int>& prices) {\\n        int maxpro = 0;\\n        int minprice = INT_MAX;\\n        for(int i=0;i<prices.size();i++){\\n            minprice=min(prices[i],minprice);\\n            maxpro=max(maxpro,prices[i]-minprice);\\n        }\\n        return maxpro;\\n    }\\n};\\n\\nTC : O(n)\\nSC : O(1)\\n\\nfeel free to ask your doubts :)\\nand ps upvote if it was helpful :)",
                "solutionTags": [
                    "C",
                    "Dynamic Programming"
                ],
                "code": "```\\n\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2048073,
                "title": "go-clean-solution-beats-100-runtime",
                "content": "```\\nfunc maxProfit(prices []int) int {\\n    var profit = 0\\n    var minPrice = prices[0]\\n    \\n    for i := 1; i < len(prices); i++ {\\n        // If we find any price which is lower than the current minPrice\\n        // update the minPrice\\n        if prices[i] < minPrice {\\n            minPrice = prices[i]\\n        } else if (prices[i] - minPrice) > profit {\\n            // If diff of current stock with minPrice is greater\\n            // update the profit\\n            profit = prices[i] - minPrice\\n        }\\n    }\\n    \\n    return profit\\n}\\n```",
                "solutionTags": [
                    "Go"
                ],
                "code": "```\\nfunc maxProfit(prices []int) int {\\n    var profit = 0\\n    var minPrice = prices[0]\\n    \\n    for i := 1; i < len(prices); i++ {\\n        // If we find any price which is lower than the current minPrice\\n        // update the minPrice\\n        if prices[i] < minPrice {\\n            minPrice = prices[i]\\n        } else if (prices[i] - minPrice) > profit {\\n            // If diff of current stock with minPrice is greater\\n            // update the profit\\n            profit = prices[i] - minPrice\\n        }\\n    }\\n    \\n    return profit\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1312541,
                "title": "easy-o-n-tc-o-1-sc-solution-in-c",
                "content": "```\\nclass Solution \\n{\\npublic:\\n    int maxProfit(vector<int>& prices) \\n    {\\n        int buy=prices[0],ans=0;\\n        for(int i=1;i<prices.size();i++)\\n        {\\n            ans=max(ans,prices[i]-buy);\\n            buy=min(buy,prices[i]);\\n        }\\n        return ans;\\n    }\\n};\\n```\\n***Please upvote if you have got any help from my code.Thank you.***",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution \\n{\\npublic:\\n    int maxProfit(vector<int>& prices) \\n    {\\n        int buy=prices[0],ans=0;\\n        for(int i=1;i<prices.size();i++)\\n        {\\n            ans=max(ans,prices[i]-buy);\\n            buy=min(buy,prices[i]);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 461359,
                "title": "javascript-o-n",
                "content": "```\\n/**\\n * @param {number[]} prices\\n * @return {number}\\n */\\nvar maxProfit = function(prices) {\\n    let min = prices[0], max = 0;\\n    \\n    for(let i = 1; i < prices.length; i++){\\n        if(prices[i] - min > max){\\n            max = prices[i] - min;\\n        }\\n        \\n        if(prices[i] < min) min = prices[i]\\n    }\\n    \\n    return max;\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {number[]} prices\\n * @return {number}\\n */\\nvar maxProfit = function(prices) {\\n    let min = prices[0], max = 0;\\n    \\n    for(let i = 1; i < prices.length; i++){\\n        if(prices[i] - min > max){\\n            max = prices[i] - min;\\n        }\\n        \\n        if(prices[i] < min) min = prices[i]\\n    }\\n    \\n    return max;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 211020,
                "title": "c-0ms",
                "content": "```\\n    int i =0;\\n    int min = prices[i];\\n    int profit =0;\\n    \\n    for(i=1;i<pricesSize;i++){\\n        if(prices[i]>min){\\n            \\n            profit = (prices[i]-min>=profit)?(prices[i]-min):profit;\\n        }\\n        else\\n            min = prices[i];\\n    \\n    }\\n    \\n    \\n    return profit;\\n\\n```",
                "solutionTags": [],
                "code": "```\\n    int i =0;\\n    int min = prices[i];\\n    int profit =0;\\n    \\n    for(i=1;i<pricesSize;i++){\\n        if(prices[i]>min){\\n            \\n            profit = (prices[i]-min>=profit)?(prices[i]-min):profit;\\n        }\\n        else\\n            min = prices[i];\\n    \\n    }\\n    \\n    \\n    return profit;\\n\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 39328,
                "title": "c-simple-solution",
                "content": "    int maxProfit(vector<int>& prices) {\\n        int ret = 0, max = 0;\\n        for(int i = 1; i < prices.size(); i++)\\n        {\\n            ret += prices[i] - prices[i-1];\\n            if(ret < 0) ret = 0;\\n            if(ret > max) max = ret;\\n         }\\n         return max;\\n    }",
                "solutionTags": [
                    "C++"
                ],
                "code": "    int maxProfit(vector<int>& prices) {\\n        int ret = 0, max = 0;\\n        for(int i = 1; i < prices.size(); i++)\\n        {\\n            ret += prices[i] - prices[i-1];\\n            if(ret < 0) ret = 0;\\n            if(ret > max) max = ret;\\n         }\\n         return max;\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 2791216,
                "title": "c-solutions",
                "content": "```\\nclass Solution {\\npublic:\\n    int maxProfit(vector<int>& prices) {\\n        int profit=0;\\n        int minelem=prices[0];\\n        for(int i=1;i<prices.size();i++){\\n           minelem=min(prices[i],minelem);\\n            profit=max(profit,(prices[i]-minelem));\\n        }\\n        return profit;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int maxProfit(vector<int>& prices) {\\n        int profit=0;\\n        int minelem=prices[0];\\n        for(int i=1;i<prices.size();i++){\\n           minelem=min(prices[i],minelem);\\n            profit=max(profit,(prices[i]-minelem));\\n        }\\n        return profit;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 802390,
                "title": "python-go-js-c-o-n-by-dp-w-visualization",
                "content": "Python O(n) by DP + State machine\\n\\n---\\n\\n**State machine diagram**:\\n\\n![image](https://assets.leetcode.com/users/images/1128f24f-0acb-48cd-9de3-13c49ccde4a9_1597935823.84157.png)\\n\\n---\\n\\n**Implementation** by bottom-up DP with state machine:\\n<iframe src=\"https://leetcode.com/playground/MSLnVn8i/shared\" frameBorder=\"0\" width=\"800\" height=\"600\"></iframe>\\n\\n---\\n\\n**Implementation** by Top-down DP + recursion\\n<iframe src=\"https://leetcode.com/playground/RZLuFL45/shared\" frameBorder=\"0\" width=\"800\" height=\"600\"></iframe>\\n\\n---\\n\\nShare another viewpoint dp solution\\n<iframe src=\"https://leetcode.com/playground/TBNQ8rNj/shared\" frameBorder=\"0\" width=\"800\" height=\"600\"></iframe>\\n\\n\\n---\\n\\nCorresponding equvilent top-down DP + recusrion\\n<iframe src=\"https://leetcode.com/playground/k5WUoupZ/shared\" frameBorder=\"0\" width=\"800\" height=\"600\"></iframe>\\n\\n\\n---\\n\\nRelated leetcode challenge:\\n\\n[Leetcode #121 Best Time to Buy and Sell Stock](https://leetcode.com/problems/best-time-to-buy-and-sell-stock)\\n\\n[Leetcode #122 Best Time to Buy and Sell Stock II](https://leetcode.com/problems/best-time-to-buy-and-sell-stock-ii)\\n\\n[Leetcode #123 Best Time to Buy and Sell Stock III ](https://leetcode.com/problems/best-time-to-buy-and-sell-stock-iii)\\n\\n[Leetcode #188 Best Time to Buy and Sell Stock IV  ](https://leetcode.com/problems/best-time-to-buy-and-sell-stock-iv)\\n\\n[Leetcode #309 Best Time to Buy and Sell Stock with Cooldown](https://leetcode.com/problems/best-time-to-buy-and-sell-stock-with-cooldown)\\n\\n[Leetcode #714 Best Time to Buy and Sell Stock with Transaction Fee  ](https://leetcode.com/problems/best-time-to-buy-and-sell-stock-with-transaction-fee) \\n\\n---",
                "solutionTags": [
                    "Python",
                    "C",
                    "JavaScript",
                    "Go",
                    "Dynamic Programming"
                ],
                "code": "Python O(n) by DP + State machine\\n\\n---\\n\\n**State machine diagram**:\\n\\n![image](https://assets.leetcode.com/users/images/1128f24f-0acb-48cd-9de3-13c49ccde4a9_1597935823.84157.png)\\n\\n---\\n\\n**Implementation** by bottom-up DP with state machine:\\n<iframe src=\"https://leetcode.com/playground/MSLnVn8i/shared\" frameBorder=\"0\" width=\"800\" height=\"600\"></iframe>\\n\\n---\\n\\n**Implementation** by Top-down DP + recursion\\n<iframe src=\"https://leetcode.com/playground/RZLuFL45/shared\" frameBorder=\"0\" width=\"800\" height=\"600\"></iframe>\\n\\n---\\n\\nShare another viewpoint dp solution\\n<iframe src=\"https://leetcode.com/playground/TBNQ8rNj/shared\" frameBorder=\"0\" width=\"800\" height=\"600\"></iframe>\\n\\n\\n---\\n\\nCorresponding equvilent top-down DP + recusrion\\n<iframe src=\"https://leetcode.com/playground/k5WUoupZ/shared\" frameBorder=\"0\" width=\"800\" height=\"600\"></iframe>\\n\\n\\n---\\n\\nRelated leetcode challenge:\\n\\n[Leetcode #121 Best Time to Buy and Sell Stock](https://leetcode.com/problems/best-time-to-buy-and-sell-stock)\\n\\n[Leetcode #122 Best Time to Buy and Sell Stock II](https://leetcode.com/problems/best-time-to-buy-and-sell-stock-ii)\\n\\n[Leetcode #123 Best Time to Buy and Sell Stock III ](https://leetcode.com/problems/best-time-to-buy-and-sell-stock-iii)\\n\\n[Leetcode #188 Best Time to Buy and Sell Stock IV  ](https://leetcode.com/problems/best-time-to-buy-and-sell-stock-iv)\\n\\n[Leetcode #309 Best Time to Buy and Sell Stock with Cooldown](https://leetcode.com/problems/best-time-to-buy-and-sell-stock-with-cooldown)\\n\\n[Leetcode #714 Best Time to Buy and Sell Stock with Transaction Fee  ](https://leetcode.com/problems/best-time-to-buy-and-sell-stock-with-transaction-fee) \\n\\n---",
                "codeTag": "Unknown"
            },
            {
                "id": 853090,
                "title": "javascript-clean-one-pass-solution",
                "content": "```javascript\\nvar maxProfit = function(prices) {\\n    let maxProf = 0, curr = prices[0];\\n    \\n    for(let x of prices) {\\n        if(curr < x) maxProf = Math.max(maxProf, x - curr);\\n        else curr = x;\\n    }\\n    return maxProf;\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```javascript\\nvar maxProfit = function(prices) {\\n    let maxProf = 0, curr = prices[0];\\n    \\n    for(let x of prices) {\\n        if(curr < x) maxProf = Math.max(maxProf, x - curr);\\n        else curr = x;\\n    }\\n    return maxProf;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 132879,
                "title": "exhaustive-search-dp-with-explanation-java-python",
                "content": "> **Exhaustive Search**\\nThe problem is to get the maximum (prices[j] - prices[i]) for 0 <= i < j <= price.length,\\nAny price maycanbe the candidate prices[j].\\nTo get the maximum (prices[j] - prices[i]), prices[i] should be the minimum value to the left of prices[j].\\n```\\n    public int maxProfit(int[] prices) {\\n        int minPriceSoFar = Integer.MAX_VALUE, maxProfitSoFar = 0;\\n        \\n        for (int i = 0; i < prices.length; i++) {\\n            if (minPriceSoFar > prices[i]) {\\n                minPriceSoFar = prices[i];\\n            } else {\\n                maxProfitSoFar = Math.max(maxProfitSoFar, prices[i] - minPriceSoFar);\\n            }\\n        }\\n        \\n        return maxProfitSoFar;\\n    }\\n```\\n\\n> **Dynamic Programming**\\nThe maximum profit is actually the maximum consecutively increasing difference.\\nThe maximum consecutively increasing difference can end at any element in nums.\\nThe maximum consecutively increasing difference ending at position i + 1 is\\neither includes maximum consecutively increasing difference ending at position i or it doesn\\'t.\\nThat can be solved in the way similar to [53. Maximum Subarray](https://leetcode.com/problems/maximum-subarray/discuss/132821/DP-Thinking-Process-with-Java-Code).\\n****\\n```\\n    public int maxProfit(int[] prices) {\\n        int n = prices.length, maxProfitSoFar = 0;\\n        // maxIncDiffSum[i] max sum of increasing difference ending at prices[i].\\n        int[] maxIncDiffSum = new int[n];\\n        \\n        for (int i = 1; i < n; i++) {\\n            maxIncDiffSum[i] = Math.max(0, maxIncDiffSum[i - 1] + prices[i] - prices[i - 1]);\\n            maxProfitSoFar = Math.max(maxProfitSoFar, maxIncDiffSum[i]);\\n        }\\n        \\n        return maxProfitSoFar;\\n    }\\n```\\n```\\n    def maxProfit(self, prices):\\n        if len(prices) <= 1:\\n            return 0\\n        \\n        lenPrices = len(prices)\\n        state = [0] * lenPrices\\n        for i in range(1, lenPrices):\\n            state[i] = max(state[i - 1] + prices[i] - prices[i - 1], 0)   \\n            \\n        return max(state)\\n```\\n**(\\u4EBA \\u2022\\u0348\\u1D17\\u2022\\u0348)** Thanks for voting!",
                "solutionTags": [],
                "code": "```\\n    public int maxProfit(int[] prices) {\\n        int minPriceSoFar = Integer.MAX_VALUE, maxProfitSoFar = 0;\\n        \\n        for (int i = 0; i < prices.length; i++) {\\n            if (minPriceSoFar > prices[i]) {\\n                minPriceSoFar = prices[i];\\n            } else {\\n                maxProfitSoFar = Math.max(maxProfitSoFar, prices[i] - minPriceSoFar);\\n            }\\n        }\\n        \\n        return maxProfitSoFar;\\n    }\\n```\n```\\n    public int maxProfit(int[] prices) {\\n        int n = prices.length, maxProfitSoFar = 0;\\n        // maxIncDiffSum[i] max sum of increasing difference ending at prices[i].\\n        int[] maxIncDiffSum = new int[n];\\n        \\n        for (int i = 1; i < n; i++) {\\n            maxIncDiffSum[i] = Math.max(0, maxIncDiffSum[i - 1] + prices[i] - prices[i - 1]);\\n            maxProfitSoFar = Math.max(maxProfitSoFar, maxIncDiffSum[i]);\\n        }\\n        \\n        return maxProfitSoFar;\\n    }\\n```\n```\\n    def maxProfit(self, prices):\\n        if len(prices) <= 1:\\n            return 0\\n        \\n        lenPrices = len(prices)\\n        state = [0] * lenPrices\\n        for i in range(1, lenPrices):\\n            state[i] = max(state[i - 1] + prices[i] - prices[i - 1], 0)   \\n            \\n        return max(state)\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 3418898,
                "title": "c-easy-dp-very-short-code",
                "content": "# Code\\n```\\nclass Solution {\\npublic:\\n    int maxProfit(vector<int>& p) {\\n        int mn=p[0];\\n        int ans=0;\\n        for(int i=1;i<p.size();i++){\\n          ans=max(ans,p[i]-mn);\\n          mn=min(mn,p[i]);\\n        }\\n        return ans;\\n    }\\n};\\n```\\n![upvote (2).jpg](https://assets.leetcode.com/users/images/e73ffd6a-40e6-4d94-948a-a970bd55b51a_1681547184.833364.jpeg)\\n",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int maxProfit(vector<int>& p) {\\n        int mn=p[0];\\n        int ans=0;\\n        for(int i=1;i<p.size();i++){\\n          ans=max(ans,p[i]-mn);\\n          mn=min(mn,p[i]);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1317146,
                "title": "c",
                "content": "```CSHARP\\npublic int MaxProfit(int[] prices)\\n{\\n\\tif (prices.Length == 0) return 0;\\n\\n\\tint min = int.MaxValue;\\n\\tint max = int.MinValue;\\n\\n\\tfor(int i = 0; i < prices.Length; i++)\\n\\t{\\n\\t\\tmin = Math.Min(min, prices[i]);\\n\\t\\tmax = Math.Max(max, prices[i] - min);\\n\\t}\\n\\n\\treturn max;\\n}\\n```",
                "solutionTags": [],
                "code": "```CSHARP\\npublic int MaxProfit(int[] prices)\\n{\\n\\tif (prices.Length == 0) return 0;\\n\\n\\tint min = int.MaxValue;\\n\\tint max = int.MinValue;\\n\\n\\tfor(int i = 0; i < prices.Length; i++)\\n\\t{\\n\\t\\tmin = Math.Min(min, prices[i]);\\n\\t\\tmax = Math.Max(max, prices[i] - min);\\n\\t}\\n\\n\\treturn max;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2178695,
                "title": "c-solution-simple-optimized-solution-tc-o-n",
                "content": "**Explanation: Optimized Solution || T.C -> O(n)**\\n\\n* Take `maxProf` to store maximum profit.\\n* Take `minPrice` to store the minimal price to the left and initialize it with `INT_MAX` or `1e9`.\\n* Now linearly traverse from left to right and update the `minPrice` at every stage and after that try to sell it where profit will be price at that instance minus minimal price.\\n* Then we compare the current profit with the maximum profit and update the `maxProf`.\\n* After the traversal is over, we return the `maxProf`.\\n\\n```\\nclass Solution {\\npublic:\\n    int maxProfit(vector<int>& prices) {\\n        int maxProf = 0;\\n        int minPrice = INT_MAX;\\n        \\n        for(int i = 0; i<prices.size(); i++)\\n        {\\n            minPrice = min(minPrice,prices[i]);\\n            maxProf = max(maxProf, prices[i] - minPrice);\\n        }\\n        \\n        return maxProf;\\n    }\\n};\\n```\\n\\n**Please upvote if you find the solution useful, means a lot.**\\n\\n\\n\\n",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int maxProfit(vector<int>& prices) {\\n        int maxProf = 0;\\n        int minPrice = INT_MAX;\\n        \\n        for(int i = 0; i<prices.size(); i++)\\n        {\\n            minPrice = min(minPrice,prices[i]);\\n            maxProf = max(maxProf, prices[i] - minPrice);\\n        }\\n        \\n        return maxProf;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1987099,
                "title": "javascript-solution-with-explanation-and-comments",
                "content": "This problem can be solved using a sliding window/two-pointer technique. The reason that works is that we\\'ve got an array-based problem statement, and we want to calculate information about certain sub-sections of the array. A fast way to do this, in linear time, is to use two pointers that move through the set of data.\\n\\nWe\\'ll track a few things:\\n\\n1. We\\'ll track a maximum profit. That will start at 0, so we can have a good default value in case there are no profits available (in the case that the stock price only goes down)\\n1. We\\'ll track a left pointer. The left pointer will start at the beginning of the array.\\n1. We\\'ll track a right pointer. The right pointer will start at the beginning of the array + 1 - just after the left pointer.\\n\\nAt each step, we\\'ll subtract the value at the left pointer position from the right pointer position. If that value is greater than the current max, we\\'ll track it as the new max. In the case where the value is greater than the current max, we\\'ll increment the right pointer by one to see if there\\'s a better profit available. The left pointer will stay in the same place.\\n\\nIf the value isn\\'t greater than the max, but is positive, we\\'ll still move the right pointer, just to see if there are better days in the future to sell.\\n\\nIf, when we subtract the left pointer from the right pointer, there\\'s a negative value, it means that the value at the left can\\'t be the minimum price at all. In fact, it means that the value at the right pointer is our new lowest. So we update the left pointer to the right pointer position, and increment the right pointer again.\\n\\nWe\\'ll repeat this until the right pointer has exceeded the length of the array, at which point, we return the max.\\n\\nHere\\'s how to write that in JavaScript:\\n\\n```js\\n/**\\n * @param {number[]} prices\\n * @return {number}\\n */\\nvar maxProfit = function(prices) {\\n    // Set up variables to track the max profit we\\'ve seen (init at 0),\\n    // the left pointer (init at day 0)\\n    // and the right pointer (init at day 1, since we can\\'t buy/sell on the same day)\\n    let max = 0\\n    let left = 0\\n    let right = 1\\n    \\n    // Keep incrementing the right pointer until we hit the end of the prices array.\\n    while (right < prices.length) {\\n\\n        // The profit on any given day is the difference between the sell date (represented by right pointer)\\n        // and buy date (represented by the left pointer)\\n        const profit = prices[right] - prices[left]\\n        \\n        // If we can get a profit higher than we\\'ve seen before, set it as our maximum,\\n        // and we\\'ll keep going.\\n        if (profit > max) {\\n            max = profit\\n        }\\n        \\n        // If today would be a loss, it means two things: \\n        // 1. We don\\'t have a new maximum.\\n        // 2. We just found a day on which we could buy at a lower price than before, so we should buy now.\\n        // \\n        // The implication of point two is that we move our left pointer (again, as a sliding window) to be the current day,\\n        // as represented by the right pointer.\\n        if (profit < 0) {\\n            left = right\\n        }\\n        \\n        // Increment the right pointer to keep searching.\\n        right += 1\\n    }\\n    \\n    // This will return 0 if we had no possible profit, since we initialized at 0,\\n    // or the maximum profit possible.\\n    return max\\n};\\n```\\n",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```js\\n/**\\n * @param {number[]} prices\\n * @return {number}\\n */\\nvar maxProfit = function(prices) {\\n    // Set up variables to track the max profit we\\'ve seen (init at 0),\\n    // the left pointer (init at day 0)\\n    // and the right pointer (init at day 1, since we can\\'t buy/sell on the same day)\\n    let max = 0\\n    let left = 0\\n    let right = 1\\n    \\n    // Keep incrementing the right pointer until we hit the end of the prices array.\\n    while (right < prices.length) {\\n\\n        // The profit on any given day is the difference between the sell date (represented by right pointer)\\n        // and buy date (represented by the left pointer)\\n        const profit = prices[right] - prices[left]\\n        \\n        // If we can get a profit higher than we\\'ve seen before, set it as our maximum,\\n        // and we\\'ll keep going.\\n        if (profit > max) {\\n            max = profit\\n        }\\n        \\n        // If today would be a loss, it means two things: \\n        // 1. We don\\'t have a new maximum.\\n        // 2. We just found a day on which we could buy at a lower price than before, so we should buy now.\\n        // \\n        // The implication of point two is that we move our left pointer (again, as a sliding window) to be the current day,\\n        // as represented by the right pointer.\\n        if (profit < 0) {\\n            left = right\\n        }\\n        \\n        // Increment the right pointer to keep searching.\\n        right += 1\\n    }\\n    \\n    // This will return 0 if we had no possible profit, since we initialized at 0,\\n    // or the maximum profit possible.\\n    return max\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1735384,
                "title": "python-o-n-solution-for-2-1-22-daily",
                "content": "```\\nclass Solution:\\n    def maxProfit(self, prices: List[int]) -> int:\\n        lowest_price, best_profit = float(\"inf\"), 0\\n        for price in prices:\\n            profit = price - lowest_price\\n            best_profit = max(profit, best_profit)\\n            lowest_price = min(price, lowest_price)\\n        return best_profit\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def maxProfit(self, prices: List[int]) -> int:\\n        lowest_price, best_profit = float(\"inf\"), 0\\n        for price in prices:\\n            profit = price - lowest_price\\n            best_profit = max(profit, best_profit)\\n            lowest_price = min(price, lowest_price)\\n        return best_profit\\n```",
                "codeTag": "Java"
            },
            {
                "id": 712254,
                "title": "2-approaches-dp-recursion-time-o-n-space-o-1",
                "content": "```\\n// Time - O(n) Space - O(1)\\nclass Solution {\\n    public int maxProfit(int[] prices) {\\n        if(prices == null || prices.length == 0) return 0;\\n        return getMaxProfit(prices, 0, Integer.MAX_VALUE, 0);\\n    }\\n    \\n    public int getMaxProfit(int[] prices, int index, int minStockPrice, int maxDiff) {\\n        if(prices.length == index) {\\n            return maxDiff;\\n        }\\n         int earn =  prices[index] - minStockPrice;\\n         maxDiff = Math.max(earn, maxDiff);\\n         minStockPrice = Math.min(minStockPrice, prices[index]);\\n        return getMaxProfit(prices, ++index, minStockPrice, maxDiff);\\n    }\\n}\\n\\n// Time - O(n) Space - O(1)\\nclass Solution {\\n    public int maxProfit(int[] prices) {\\n        if(prices == null || prices.length == 0) return 0;\\n        return getMaxProfit(prices);\\n    }\\n    \\n    public int getMaxProfit(int[] prices) {\\n        int minStockPrice = Integer.MAX_VALUE, maxDiff = 0;\\n        for(int i = 0; i < prices.length; i++) {\\n            int earn =  prices[i] - minStockPrice;\\n            maxDiff = Math.max(earn, maxDiff);\\n            minStockPrice = Math.min(minStockPrice, prices[i]);\\n        }\\n        return maxDiff;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Dynamic Programming",
                    "Recursion"
                ],
                "code": "```\\n// Time - O(n) Space - O(1)\\nclass Solution {\\n    public int maxProfit(int[] prices) {\\n        if(prices == null || prices.length == 0) return 0;\\n        return getMaxProfit(prices, 0, Integer.MAX_VALUE, 0);\\n    }\\n    \\n    public int getMaxProfit(int[] prices, int index, int minStockPrice, int maxDiff) {\\n        if(prices.length == index) {\\n            return maxDiff;\\n        }\\n         int earn =  prices[index] - minStockPrice;\\n         maxDiff = Math.max(earn, maxDiff);\\n         minStockPrice = Math.min(minStockPrice, prices[index]);\\n        return getMaxProfit(prices, ++index, minStockPrice, maxDiff);\\n    }\\n}\\n\\n// Time - O(n) Space - O(1)\\nclass Solution {\\n    public int maxProfit(int[] prices) {\\n        if(prices == null || prices.length == 0) return 0;\\n        return getMaxProfit(prices);\\n    }\\n    \\n    public int getMaxProfit(int[] prices) {\\n        int minStockPrice = Integer.MAX_VALUE, maxDiff = 0;\\n        for(int i = 0; i < prices.length; i++) {\\n            int earn =  prices[i] - minStockPrice;\\n            maxDiff = Math.max(earn, maxDiff);\\n            minStockPrice = Math.min(minStockPrice, prices[i]);\\n        }\\n        return maxDiff;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 400573,
                "title": "python3-beats-93-61-with-comments",
                "content": "```python\\nclass Solution:\\n    def maxProfit(self, prices: List[int]) -> int:\\n        # Max profit and price to buy\\n        max_profit = 0\\n        high_buy = 0\\n        \\n        # Reverse the array of prices\\n        prices = prices[::-1]\\n        \\n        # Check each price to sell at compared to the highest buy price ahead of it\\n        for price in prices:\\n            # Update highest buy price in front of price\\n            if price > high_buy:\\n                high_buy = price\\n            # Check if this sale make higher profit than sales later in original array\\n            if high_buy - price > max_profit:\\n                max_profit = high_buy - price\\n                \\n        # Return the highest profit achieved\\n        return max_profit\\n```\\n",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Dynamic Programming"
                ],
                "code": "```python\\nclass Solution:\\n    def maxProfit(self, prices: List[int]) -> int:\\n        # Max profit and price to buy\\n        max_profit = 0\\n        high_buy = 0\\n        \\n        # Reverse the array of prices\\n        prices = prices[::-1]\\n        \\n        # Check each price to sell at compared to the highest buy price ahead of it\\n        for price in prices:\\n            # Update highest buy price in front of price\\n            if price > high_buy:\\n                high_buy = price\\n            # Check if this sale make higher profit than sales later in original array\\n            if high_buy - price > max_profit:\\n                max_profit = high_buy - price\\n                \\n        # Return the highest profit achieved\\n        return max_profit\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3676718,
                "title": "java-code-to-find-best-time-to-buy-and-sell-stocks",
                "content": "# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n$$O(n)$$\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n$$O(1)$$\\n\\n# Code\\n```\\nclass Solution {\\n    public int maxProfit(int[] prices) {\\n        int left = 0, right = 1,max = 0;\\n        while(right < prices.length){\\n            if(prices[left] > prices[right]){\\n                left = right;\\n            }else if(prices[left] < prices[right]){\\n                max = Math.max(max,(prices[right] - prices[left]));\\n            }\\n            right++;\\n        }\\n        return max;\\n    }\\n}\\n```\\n\\n## **If you find this helpful, please upvote \\uD83D\\uDE0A**",
                "solutionTags": [
                    "Java",
                    "Two Pointers"
                ],
                "code": "```\\nclass Solution {\\n    public int maxProfit(int[] prices) {\\n        int left = 0, right = 1,max = 0;\\n        while(right < prices.length){\\n            if(prices[left] > prices[right]){\\n                left = right;\\n            }else if(prices[left] < prices[right]){\\n                max = Math.max(max,(prices[right] - prices[left]));\\n            }\\n            right++;\\n        }\\n        return max;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3520779,
                "title": "c-java-python-javascript-simple-code-easy-to-understand",
                "content": "# Intuition:\\nThe intuition behind this solution is to find the maximum profit by keeping track of the minimum price encountered so far. By iterating over the prices, we update the minimum price if we find a smaller price. Then, we calculate the profit by subtracting the minimum price from the current price, and update the maximum profit if it is larger.\\n\\n# Approach:\\n1. Initialize the variables `profit` and `minPrice` to 0 and INT_MAX respectively.\\n2. Iterate over the `prices` vector using a for loop, with index `i` ranging from 0 to `prices.size() - 1`.\\n3. Inside the loop, update the `minPrice` by taking the minimum of the current `minPrice` and the price at index `i`.\\n4. Calculate the profit by subtracting the `minPrice` from the price at index `i`.\\n5. Update the `profit` by taking the maximum of the current `profit` and the calculated profit.\\n6. After the loop ends, return the `profit`.\\n\\n# Complexity:\\n- The time complexity of this solution is O(n), where n is the size of the `prices` vector, as we iterate over the vector once.\\n- The space complexity is O(1) as we only use a constant amount of additional space to store the variables `profit` and `minPrice`.\\n\\n---\\n# C++\\n```\\nclass Solution {\\npublic:\\n    int maxProfit(vector<int>& prices) {\\n        int profit=0;\\n        int minPrice=INT_MAX;\\n        for(int i=0;i<prices.size();i++){\\n            minPrice = min(minPrice,prices[i]);\\n            profit = max(profit,prices[i]-minPrice);\\n        }\\n        return profit;\\n    }\\n};\\n```\\n\\n---\\n# Java\\n```\\nclass Solution {\\n    public int maxProfit(int[] prices) {\\n        int profit = 0;\\n        int minPrice = Integer.MAX_VALUE;\\n        for (int i = 0; i < prices.length; i++) {\\n            minPrice = Math.min(minPrice, prices[i]);\\n            profit = Math.max(profit, prices[i] - minPrice);\\n        }\\n        return profit;\\n    }\\n}\\n\\n```\\n---\\n# Python\\n```\\nclass Solution(object):\\n    def maxProfit(self, prices):\\n        profit = 0\\n        minPrice = float(\"inf\")\\n        for price in prices:\\n            minPrice = min(minPrice, price)\\n            profit = max(profit, price - minPrice)\\n        return profit\\n\\n```\\n---\\n# JavaScript\\n```\\nvar maxProfit = function(prices) {\\n    let profit = 0;\\n    let minPrice = Number.MAX_VALUE;\\n    for (let i = 0; i < prices.length; i++) {\\n        minPrice = Math.min(minPrice, prices[i]);\\n        profit = Math.max(profit, prices[i] - minPrice);\\n    }\\n    return profit;  \\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Java",
                    "Python",
                    "JavaScript",
                    "Array"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int maxProfit(vector<int>& prices) {\\n        int profit=0;\\n        int minPrice=INT_MAX;\\n        for(int i=0;i<prices.size();i++){\\n            minPrice = min(minPrice,prices[i]);\\n            profit = max(profit,prices[i]-minPrice);\\n        }\\n        return profit;\\n    }\\n};\\n```\n```\\nclass Solution {\\n    public int maxProfit(int[] prices) {\\n        int profit = 0;\\n        int minPrice = Integer.MAX_VALUE;\\n        for (int i = 0; i < prices.length; i++) {\\n            minPrice = Math.min(minPrice, prices[i]);\\n            profit = Math.max(profit, prices[i] - minPrice);\\n        }\\n        return profit;\\n    }\\n}\\n\\n```\n```\\nclass Solution(object):\\n    def maxProfit(self, prices):\\n        profit = 0\\n        minPrice = float(\"inf\")\\n        for price in prices:\\n            minPrice = min(minPrice, price)\\n            profit = max(profit, price - minPrice)\\n        return profit\\n\\n```\n```\\nvar maxProfit = function(prices) {\\n    let profit = 0;\\n    let minPrice = Number.MAX_VALUE;\\n    for (let i = 0; i < prices.length; i++) {\\n        minPrice = Math.min(minPrice, prices[i]);\\n        profit = Math.max(profit, prices[i] - minPrice);\\n    }\\n    return profit;  \\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1422184,
                "title": "javascript-best-time-to-buy-and-sell-stock-written-explanation-code",
                "content": "# Table of Contents:\\n* High level overview of the problem\\n* Translate words to solution\\n* Code demo\\n\\n## **High level overview of the problem:**\\n\\n*You are given an array prices where prices[i] is the price of a given stock on the ith day.*\\n\\n*You want to maximize your profit by choosing a single day to buy one stock and choosing a different day in the future to sell that stock.*\\n\\n*Return the maximum profit you can achieve from this transaction. If you cannot achieve any profit, return 0.*\\n\\nWhen it comes to buying stocks in real life, you want to buy low and sell high. The concept is applied in this problem. We need to keep track of two prices in order to get a positive profit.\\n\\n**There are 2 ways to solve this problem:**\\n1. Brute Force\\n2. Greedy Algorithm\\n\\n## **Translate words to solution:**\\n\\n**Solution #1 Brute Force:**\\n\\nIf we iterate over the array with one for loop (buy price), we need an additional for loop (sell price) to scan the elements to the right of it. The reason we need a second for loop is because we need the buy price from the first for loop so that we can subtract the sell price in the second for loop. If we can loop over the elements with two for loops then we can generate the combinations to achieve a maximum profit. \\n\\nTime Complexity: O(n^2)\\nSpace Complexity: O(1)\\n\\n**Solution #2 Greedy Algorithm:**\\n\\nThe idea of the greedy algorithm is keep track of the locally optimal solution that will eventually build up to an optimal global solution. \\n\\nIn order for us to get a locally optimal solution we need to keep track of the minimum buy price, the maximum sell price, and the current profit. The formula for getting the current profit is equal to buy price subtracted by the sell price.\\n\\nOn every iteration, we simultaneously check if the current profit is greater than the global profit, if it is then we update the global profit to equal our current profit. \\n\\nTime Complexity: O(n)\\nSpace Complexity: O(1)\\n## **Code demo:**\\n\\n**Solution #1 Brute Force:**\\n\\n```\\nfunction maxProfit(prices) {\\n  let globalProfit = 0;\\n\\t// the reason prices.length - 1 is because we are using the second for loop to scan every element to the right of i\\n  for (let i = 0; i < prices.length - 1; i++) {\\n\\t  // the reason j is i + 1 is because we are scanning all the combinations of the first for loop\\n    for (let j = i + 1; j < prices.length; j++) {\\n      const currentProfit = prices[j] - prices[i]\\n\\n      if (currentProfit > globalProfit) {\\n        globalProfit = currentProfit\\n      }\\n    }\\n  }\\n\\n  return globalProfit;\\n}\\n\\n```\\n\\n**Solution #2 Greedy Algorithm:**\\n\\n```\\nfunction maxProfit(prices) {\\n  let globalProfit = 0;\\n  // minBuyPrice is set to Infinity because we can guarantee the first element will be set to the buy price \\n  let minBuyPrice = Infinity;\\n\\n  for (let i = 0; i < prices.length; i++) {\\n    if (minBuyPrice > prices[i]) {\\n      minBuyPrice = prices[i];\\n    }\\n\\n    const currentProfit = prices[i] - minBuyPrice;\\n\\n    if (currentProfit > globalProfit) {\\n      globalProfit = currentProfit;\\n    }\\n  }\\n\\n  return globalProfit;\\n}\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\nfunction maxProfit(prices) {\\n  let globalProfit = 0;\\n\\t// the reason prices.length - 1 is because we are using the second for loop to scan every element to the right of i\\n  for (let i = 0; i < prices.length - 1; i++) {\\n\\t  // the reason j is i + 1 is because we are scanning all the combinations of the first for loop\\n    for (let j = i + 1; j < prices.length; j++) {\\n      const currentProfit = prices[j] - prices[i]\\n\\n      if (currentProfit > globalProfit) {\\n        globalProfit = currentProfit\\n      }\\n    }\\n  }\\n\\n  return globalProfit;\\n}\\n\\n```\n```\\nfunction maxProfit(prices) {\\n  let globalProfit = 0;\\n  // minBuyPrice is set to Infinity because we can guarantee the first element will be set to the buy price \\n  let minBuyPrice = Infinity;\\n\\n  for (let i = 0; i < prices.length; i++) {\\n    if (minBuyPrice > prices[i]) {\\n      minBuyPrice = prices[i];\\n    }\\n\\n    const currentProfit = prices[i] - minBuyPrice;\\n\\n    if (currentProfit > globalProfit) {\\n      globalProfit = currentProfit;\\n    }\\n  }\\n\\n  return globalProfit;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 979892,
                "title": "java-all-approach-recursive-dp-kadane-s-algorithm",
                "content": "**Algorithm**\\n* This is one of the popular interview question and I would like to expalin in a way that I understood\\n\\n**Recursive Approach**\\n* The base case is that if the index passed to the recursive function has reached the `prices` array length, if so `return 0`\\n* compute the minimum of the current item, `prices[index]` so that when we backtrack after the recursive call we can compute `maxProfit` by comparing with the current element difference with the `prices[index]`\\n* recursively call the function by incrementing the `index`, the value that will be returned from recursive call is the `maxProfit`\\n* after coming from the recursive call, we cmpute the maxProfit with the current element `prices[index] - min` element found before recursing.\\n\\n```\\nclass Solution {\\n     protected int dfs(int[] prices, int index, int min){\\n         if (index == prices.length)\\n             return 0;\\n        \\n         int minimumEndingHere = Math.min(min, prices[index]);\\n         int maxProfit = dfs(prices, index + 1, minimumEndingHere);\\n         maxProfit = Math.max(maxProfit, prices[index] - min);\\n         return maxProfit;\\n     }\\n     public int maxProfit(int[] prices) {\\n         return dfs(prices, 0, Integer.MAX_VALUE);\\n   }\\n}\\n```\\n\\n**O(N) - Bottom Up Approach**\\n* start with having the dp array of the length of the `prices` array\\n* At each index store the max of the difference with the `prices[i]` with `min` that was computed earlier\\n* update the `min` everytime comparing with the current price\\n\\n```\\nclass Solution {\\npublic int maxProfit(int[] prices) {\\n        if (prices.length == 0)\\n            return 0;\\n        int[] dp = new int[prices.length];\\n        int min = prices[0];\\n    \\n        for (int i=1;i<prices.length;i++){\\n            dp[i] = Math.max(dp[i-1], prices[i] - min);\\n            min = Math.min(min, prices[i]);\\n        }\\n        \\n        return dp[prices.length-1];\\n    }\\n}\\n```\\n\\n**O(N) - Kadane\\'s Algorithm**\\n* assign `maxEndingHere` and `minEndingHere` with the first element in the prices array\\n* Loop through the length of the `prices` array\\n* If at any time you see `prices[i] < max`, then assign the `maxEndingHere` to the `prices[i]`, this is because we have to have the max computed after we buy the share for minimum prices. So we need to compute everytime\\n* Get the `maxEndingHere` and `minEndingHere` as the max and min compared with the `prices[i]`\\n* Compute `maxProfit` as the max between computed `maxEndingHere` and the difference of `maxEndingHere` and `minEndingHere`\\n* return the `maxProfit`\\n```\\nclass Solution {\\npublic int maxProfit(int[] prices) {\\n\\nif (prices == null || prices.length == 0)\\n     return 0;\\n        int maxProfit = 0;\\n         int maxEndingHere = prices[0];\\n         int minEndingHere = prices[0];\\n        \\n         for (int i=1;i<prices.length;i++){\\n             if (prices[i] < maxEndingHere){\\n                 maxEndingHere = prices[i];\\n             }\\n            maxEndingHere = Math.max(maxEndingHere, prices[i]);\\n            minEndingHere = Math.min(minEndingHere, prices[i]);\\n            maxProfit = Math.max(maxProfit, Math.abs(maxEndingHere-minEndingHere));\\n         }\\n         return maxProfit;\\n\\t}\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Dynamic Programming",
                    "Recursion"
                ],
                "code": "```\\nclass Solution {\\n     protected int dfs(int[] prices, int index, int min){\\n         if (index == prices.length)\\n             return 0;\\n        \\n         int minimumEndingHere = Math.min(min, prices[index]);\\n         int maxProfit = dfs(prices, index + 1, minimumEndingHere);\\n         maxProfit = Math.max(maxProfit, prices[index] - min);\\n         return maxProfit;\\n     }\\n     public int maxProfit(int[] prices) {\\n         return dfs(prices, 0, Integer.MAX_VALUE);\\n   }\\n}\\n```\n```\\nclass Solution {\\npublic int maxProfit(int[] prices) {\\n        if (prices.length == 0)\\n            return 0;\\n        int[] dp = new int[prices.length];\\n        int min = prices[0];\\n    \\n        for (int i=1;i<prices.length;i++){\\n            dp[i] = Math.max(dp[i-1], prices[i] - min);\\n            min = Math.min(min, prices[i]);\\n        }\\n        \\n        return dp[prices.length-1];\\n    }\\n}\\n```\n```\\nclass Solution {\\npublic int maxProfit(int[] prices) {\\n\\nif (prices == null || prices.length == 0)\\n     return 0;\\n        int maxProfit = 0;\\n         int maxEndingHere = prices[0];\\n         int minEndingHere = prices[0];\\n        \\n         for (int i=1;i<prices.length;i++){\\n             if (prices[i] < maxEndingHere){\\n                 maxEndingHere = prices[i];\\n             }\\n            maxEndingHere = Math.max(maxEndingHere, prices[i]);\\n            minEndingHere = Math.min(minEndingHere, prices[i]);\\n            maxProfit = Math.max(maxProfit, Math.abs(maxEndingHere-minEndingHere));\\n         }\\n         return maxProfit;\\n\\t}\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 118512,
                "title": "multiple-c-solutions-with-explaination",
                "content": "**1) Using 2 variables high and low**\\nThis is a sort of DP solution where we store the profits at each day\\n\\n```\\nclass Solution {\\npublic:\\n    int maxProfit(vector<int>& prices) {\\n        int high=0,low=0;\\n        int n = prices.size();\\n        \\n        //Edge Case\\n        if(n<2) return 0;\\n        \\n        //Store Profits at each day\\n        vector<int> profit(n,0);\\n        \\n        high = prices[0];\\n        low = prices[0];\\n        \\n        //For each day\\n        for(int i=1;i<n;i++) {\\n            \\n            //If current day price is grater then Great! Your profit is increasing\\n            if(prices[i]>high) {\\n                high = prices[i];\\n                profit[i] = high-low;\\n            }\\n            \\n            //If you see a new low- you should reset low as this current price and high as 0\\n            //As there can be a bigger margin profit ahead\\n            if(prices[i]<=low) {\\n                profit[i] = high-low;\\n                low = prices[i];\\n                high = 0; //Reset\\n            }\\n            \\n            //For cases where the value is between low and high\\n                profit[i] =high-low;\\n        }\\n        \\n        return *max_element(profit.begin(),profit.end());\\n    }\\n};\\n```\\n\\n\\n\\n**2) Using Max Difference (Unknown Author)**\\nThis also uses 2 variables.\\n```\\nclass Solution {\\npublic:\\n    int maxProfit(vector<int>& prices) {\\n        \\n        int min=INT_MAX,maxdiff=0;\\n        for(int i=0;i<prices.size();i++)\\n        {\\n            if(prices[i]<min)\\n                min=prices[i];\\n            else\\n                if(prices[i]-min > maxdiff)\\n                    maxdiff = prices[i]-min;\\n        }\\n        \\n        \\n        return maxdiff;\\n    }\\n};\\n```\\n\\n\\n**3) Kadane\\'s Algorithm**\\n\\nCheck this [solution](https://leetcode.com/problems/best-time-to-buy-and-sell-stock/discuss/39038/Kadane\\'s-Algorithm-Since-no-one-has-mentioned-about-this-so-far-:)\\n\\n\\n**4) Justification for it to be a DP solution**\\nCheck this [post](https://leetcode.com/problems/best-time-to-buy-and-sell-stock/discuss/39112/Why-is-this-problem-tagged-with-\"Dynamic-programming\"/36893)\\n",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int maxProfit(vector<int>& prices) {\\n        int high=0,low=0;\\n        int n = prices.size();\\n        \\n        //Edge Case\\n        if(n<2) return 0;\\n        \\n        //Store Profits at each day\\n        vector<int> profit(n,0);\\n        \\n        high = prices[0];\\n        low = prices[0];\\n        \\n        //For each day\\n        for(int i=1;i<n;i++) {\\n            \\n            //If current day price is grater then Great! Your profit is increasing\\n            if(prices[i]>high) {\\n                high = prices[i];\\n                profit[i] = high-low;\\n            }\\n            \\n            //If you see a new low- you should reset low as this current price and high as 0\\n            //As there can be a bigger margin profit ahead\\n            if(prices[i]<=low) {\\n                profit[i] = high-low;\\n                low = prices[i];\\n                high = 0; //Reset\\n            }\\n            \\n            //For cases where the value is between low and high\\n                profit[i] =high-low;\\n        }\\n        \\n        return *max_element(profit.begin(),profit.end());\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    int maxProfit(vector<int>& prices) {\\n        \\n        int min=INT_MAX,maxdiff=0;\\n        for(int i=0;i<prices.size();i++)\\n        {\\n            if(prices[i]<min)\\n                min=prices[i];\\n            else\\n                if(prices[i]-min > maxdiff)\\n                    maxdiff = prices[i]-min;\\n        }\\n        \\n        \\n        return maxdiff;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 39315,
                "title": "python-different-solutions-dp",
                "content": "       \\n    # DP\\n    def maxProfit1(self, prices):\\n        if not prices:\\n            return 0\\n        loc = glo = 0\\n        for i in xrange(1, len(prices)):\\n            loc = max(loc+prices[i]-prices[i-1], 0)\\n            glo = max(glo, loc)\\n        return glo\\n        \\n    def maxProfit2(self, prices):\\n        if not prices:\\n            return 0\\n        minPri, maxPro = prices[0], 0\\n        for i in xrange(1, len(prices)):\\n            minPri = min(minPri, prices[i])\\n            maxPro = max(maxPro, prices[i]-minPri)\\n        return maxPro\\n        \\n    # Reuse maximum subarray method\\n    def maxProfit(self, prices):\\n        if not prices or len(prices) == 1:\\n            return 0\\n        dp = [0] * len(prices)\\n        for i in xrange(1, len(prices)):\\n            dp[i] = prices[i]-prices[i-1]\\n        glo = loc = dp[0]\\n        for i in xrange(1, len(dp)):\\n            loc = max(loc+dp[i], dp[i])\\n            glo = max(glo, loc)\\n        return glo",
                "solutionTags": [
                    "Python",
                    "Dynamic Programming"
                ],
                "code": "       \\n    # DP\\n    def maxProfit1(self, prices):\\n        if not prices:\\n            return 0\\n        loc = glo = 0\\n        for i in xrange(1, len(prices)):\\n            loc = max(loc+prices[i]-prices[i-1], 0)\\n            glo = max(glo, loc)\\n        return glo\\n        \\n    def maxProfit2(self, prices):\\n        if not prices:\\n            return 0\\n        minPri, maxPro = prices[0], 0\\n        for i in xrange(1, len(prices)):\\n            minPri = min(minPri, prices[i])\\n            maxPro = max(maxPro, prices[i]-minPri)\\n        return maxPro\\n        \\n    # Reuse maximum subarray method\\n    def maxProfit(self, prices):\\n        if not prices or len(prices) == 1:\\n            return 0\\n        dp = [0] * len(prices)\\n        for i in xrange(1, len(prices)):\\n            dp[i] = prices[i]-prices[i-1]\\n        glo = loc = dp[0]\\n        for i in xrange(1, len(dp)):\\n            loc = max(loc+dp[i], dp[i])\\n            glo = max(glo, loc)\\n        return glo",
                "codeTag": "Python3"
            },
            {
                "id": 2549176,
                "title": "2-pointer-big-o-n-easy-solution",
                "content": "```python\\nclass Solution:\\n    def maxProfit(self, prices: List[int]) -> int:\\n        max_profit, l = 0, 0\\n\\n        for r in range(1, len(prices)):\\n            \\n            net = prices[r]-prices[l]\\n            is_profit = net > 0\\n            \\n            if is_profit:\\n                max_profit = max(max_profit, net)\\n            else:\\n                l = r\\n\\n        return max_profit\\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```python\\nclass Solution:\\n    def maxProfit(self, prices: List[int]) -> int:\\n        max_profit, l = 0, 0\\n\\n        for r in range(1, len(prices)):\\n            \\n            net = prices[r]-prices[l]\\n            is_profit = net > 0\\n            \\n            if is_profit:\\n                max_profit = max(max_profit, net)\\n            else:\\n                l = r\\n\\n        return max_profit\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3506973,
                "title": "c-java-python3-javascript-solution-o-n",
                "content": "**Here to see the full explanation :\\u2B50[Zyrastory - #121 Best Time to Buy and Sell Stock](https://zyrastory.com/en/coding-en/leetcode-en/leetcode-121-best-time-to-buy-and-sell-stock-solution-and-explanation-en/)\\u2B50**\\n\\n\\n---\\n\\n# Example :\\n# C#\\n\\u274Cfirst try  - **Time Complexity : O(n^2)**\\n```\\npublic class Solution {\\n    public int MaxProfit(int[] prices) {\\n        \\n        int max = 0;\\n         for(int i = 0;i<prices.Length-1;i++)\\n         {\\n             for(int j = i+1;j<prices.Length;j++)\\n             {\\n                 int res = prices[j]-prices[i];\\n                 if(res>max)\\n                 {\\n                     max = res;\\n                 }\\n             }\\n         }\\n        return max;\\n    }\\n}\\n```\\n\\nSolution - **Time Complexity : O(n)**\\n```\\npublic class Solution {\\n    public int MaxProfit(int[] prices) {\\n        int max = 0;\\n        int min = prices[0];\\n        \\n        for(int i=1;i<prices.Length;i++){\\n            if(prices[i] < min){\\n                min = prices[i];\\n            }\\n            \\n            else if((prices[i] - min) > max )\\n            {\\n                max = prices[i] - min;\\n            }\\n        }\\n        return max;\\n    }\\n}\\n```\\n\\n---\\n\\n# Java\\n```\\nclass Solution {\\n    public int maxProfit(int[] prices) {\\n        int max = 0;\\n        int min = prices[0];\\n        \\n        for(int i=1;i<prices.length;i++){\\n            if(prices[i] < min){\\n                min = prices[i];\\n            }\\n            \\n            else if((prices[i] - min) > max )\\n            {\\n                max = prices[i] - min;\\n            }\\n        }\\n        return max;\\n    }\\n}\\n```\\n\\n---\\n# Python3\\n```\\nclass Solution:\\n    def maxProfit(self, prices: List[int]) -> int:\\n        max = 0;\\n        min = prices[0];\\n        \\n        for i in range(1,len(prices)):\\n            if prices[i] < min :\\n                min = prices[i]\\n            \\n            elif((prices[i] - min) > max):\\n                max = prices[i] - min\\n        \\n        return max;\\n```\\n\\n---\\n\\n# JavaScript\\n```\\n/**\\n * @param {number[]} prices\\n * @return {number}\\n */\\nvar maxProfit = function(prices) {\\n    var max = 0;\\n    var min = prices[0];\\n\\n    for(var i=1;i<prices.length;i++){\\n        if(prices[i] < min){\\n            min = prices[i];\\n        }\\n\\n        else if((prices[i] - min) > max )\\n        {\\n            max = prices[i] - min;\\n        }\\n    }\\n    return max;\\n};\\n```\\n\\n\\n**If you got any problem about the explanation or you need other programming language solution, please feel free to let me know (leave comment or messenger me).**\\n\\nThanks!\\n\\n**\\uD83E\\uDDE1See next question - [Zyrastory - #122 Best Time to Buy and Sell Stock II](https://zyrastory.com/en/coding-en/leetcode-en/leetcode-122-best-time-to-buy-and-sell-stock-ii-solution-and-explanation-en/)**",
                "solutionTags": [
                    "Java",
                    "Python3",
                    "C#",
                    "JavaScript"
                ],
                "code": "```\\npublic class Solution {\\n    public int MaxProfit(int[] prices) {\\n        \\n        int max = 0;\\n         for(int i = 0;i<prices.Length-1;i++)\\n         {\\n             for(int j = i+1;j<prices.Length;j++)\\n             {\\n                 int res = prices[j]-prices[i];\\n                 if(res>max)\\n                 {\\n                     max = res;\\n                 }\\n             }\\n         }\\n        return max;\\n    }\\n}\\n```\n```\\npublic class Solution {\\n    public int MaxProfit(int[] prices) {\\n        int max = 0;\\n        int min = prices[0];\\n        \\n        for(int i=1;i<prices.Length;i++){\\n            if(prices[i] < min){\\n                min = prices[i];\\n            }\\n            \\n            else if((prices[i] - min) > max )\\n            {\\n                max = prices[i] - min;\\n            }\\n        }\\n        return max;\\n    }\\n}\\n```\n```\\nclass Solution {\\n    public int maxProfit(int[] prices) {\\n        int max = 0;\\n        int min = prices[0];\\n        \\n        for(int i=1;i<prices.length;i++){\\n            if(prices[i] < min){\\n                min = prices[i];\\n            }\\n            \\n            else if((prices[i] - min) > max )\\n            {\\n                max = prices[i] - min;\\n            }\\n        }\\n        return max;\\n    }\\n}\\n```\n```\\nclass Solution:\\n    def maxProfit(self, prices: List[int]) -> int:\\n        max = 0;\\n        min = prices[0];\\n        \\n        for i in range(1,len(prices)):\\n            if prices[i] < min :\\n                min = prices[i]\\n            \\n            elif((prices[i] - min) > max):\\n                max = prices[i] - min\\n        \\n        return max;\\n```\n```\\n/**\\n * @param {number[]} prices\\n * @return {number}\\n */\\nvar maxProfit = function(prices) {\\n    var max = 0;\\n    var min = prices[0];\\n\\n    for(var i=1;i<prices.length;i++){\\n        if(prices[i] < min){\\n            min = prices[i];\\n        }\\n\\n        else if((prices[i] - min) > max )\\n        {\\n            max = prices[i] - min;\\n        }\\n    }\\n    return max;\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3493104,
                "title": "c-one-pass-approach-with-explanation",
                "content": "# Intuition: \\nTo maximize the profit, we iterate through the array while keeping track of the minimum price encountered so far. We calculate the potential profit by selling at each price if we had bought at the minimum price. We update the maximum profit whenever a higher profit is obtained.\\n\\n# Approach:\\n- Initialize `minPrice` as the maximum possible value and `maxProfit` as 0.\\n- Iterate through the `prices` array.\\n- For each price, check if it is lower than the current `minPrice`. If so, update `minPrice`.\\n- Calculate the profit by subtracting `minPrice` from the current price.\\n- If the profit is higher than the current `maxProfit`, update `maxProfit`.\\n- Return the final `maxProfit` value.\\n\\n# Complexity:\\n- Time complexity: O(n), where n is the length of the `prices` array. We iterate through the array once.\\n- Space complexity: O(1). We use a constant amount of extra space to store variables.\\n\\n\\n# Code\\n```\\npublic class Solution {\\n    public int MaxProfit(int[] prices) {\\n        int minPrice = int.MaxValue;\\n        int maxProfit = 0;\\n        \\n        for (int i = 0; i < prices.Length; i++) {\\n            if (prices[i] < minPrice) {\\n                minPrice = prices[i];\\n            }\\n            \\n            int profit = prices[i] - minPrice;\\n            if (profit > maxProfit) {\\n                maxProfit = profit;\\n            }\\n        }\\n        \\n        return maxProfit;\\n    }\\n}\\n\\n```",
                "solutionTags": [
                    "C#"
                ],
                "code": "```\\npublic class Solution {\\n    public int MaxProfit(int[] prices) {\\n        int minPrice = int.MaxValue;\\n        int maxProfit = 0;\\n        \\n        for (int i = 0; i < prices.Length; i++) {\\n            if (prices[i] < minPrice) {\\n                minPrice = prices[i];\\n            }\\n            \\n            int profit = prices[i] - minPrice;\\n            if (profit > maxProfit) {\\n                maxProfit = profit;\\n            }\\n        }\\n        \\n        return maxProfit;\\n    }\\n}\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2572962,
                "title": "typescript-solution",
                "content": "```\\nfunction maxProfit(prices: number[]): number {\\n  let min = prices[0]\\n  let max = 0\\n  \\n  for (let i = 1; i < prices.length; i++) {\\n    min = Math.min(min, prices[i])\\n    max = Math.max(max, prices[i] - min)\\n  }\\n  \\n  return max\\n}\\n```",
                "solutionTags": [
                    "JavaScript",
                    "TypeScript",
                    "Dynamic Programming"
                ],
                "code": "```\\nfunction maxProfit(prices: number[]): number {\\n  let min = prices[0]\\n  let max = 0\\n  \\n  for (let i = 1; i < prices.length; i++) {\\n    min = Math.min(min, prices[i])\\n    max = Math.max(max, prices[i] - min)\\n  }\\n  \\n  return max\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1735433,
                "title": "rust-12-ms-2-9mb-oneliner",
                "content": "Runtime: 12 ms, faster than 93.02% of Rust online submissions for Best Time to Buy and Sell Stock.\\nMemory Usage: 2.9 MB, less than 50.39% of Rust online submissions for Best Time to Buy and Sell Stock.\\n```\\nimpl Solution {\\n    //  Profit = max price - min cost\\n    pub fn max_profit(prices: Vec<i32>) -> i32 {\\n        prices\\n        .iter()\\n        .fold((0, i32::MAX), |(mut max_profit, mut cost), price| {\\n            cost = i32::min(*price, cost);\\n            max_profit = i32::max(max_profit, price-cost);\\n            (max_profit, cost)\\n        }).0\\n    }\\n}\\n\\n\\n\\n```",
                "solutionTags": [
                    "Rust"
                ],
                "code": "```\\nimpl Solution {\\n    //  Profit = max price - min cost\\n    pub fn max_profit(prices: Vec<i32>) -> i32 {\\n        prices\\n        .iter()\\n        .fold((0, i32::MAX), |(mut max_profit, mut cost), price| {\\n            cost = i32::min(*price, cost);\\n            max_profit = i32::max(max_profit, price-cost);\\n            (max_profit, cost)\\n        }).0\\n    }\\n}\\n\\n\\n\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1709087,
                "title": "java-simple-solution-time-o-n-space-o-1",
                "content": "Kindly upvote if it helps you!\\n```\\npublic int maxProfit(int[] prices) {\\n        int maxProfit = 0;\\n\\t\\t//we buy the stock on the \\'left\\' day & plan on selling on the \\'right\\' day\\n        int left = 0, right = 1;\\n        while(right < prices.length){\\n\\t\\t\\t//We want a profitable deal. Hence if the cost at day we buy the stock is less than the price on\\n\\t\\t\\t//the day we sell the stock, calculating currentProfit.\\n\\t\\t\\t//If currentProfit is greater that maxProfit, updating maxProfit\\n            if(prices[left]<prices[right]){\\n                int currentProfit = prices[right]-prices[left];\\n                maxProfit = Math.max(maxProfit, currentProfit);\\n            }else{\\n\\t\\t\\t\\t//if we found a day having even less price , we will buy the stock at that day. \\n                left = right;\\n            }\\n            right++;\\n        }\\n        return maxProfit;\\n    }",
                "solutionTags": [
                    "Two Pointers"
                ],
                "code": "Kindly upvote if it helps you!\\n```\\npublic int maxProfit(int[] prices) {\\n        int maxProfit = 0;\\n\\t\\t//we buy the stock on the \\'left\\' day & plan on selling on the \\'right\\' day\\n        int left = 0, right = 1;\\n        while(right < prices.length){\\n\\t\\t\\t//We want a profitable deal. Hence if the cost at day we buy the stock is less than the price on\\n\\t\\t\\t//the day we sell the stock, calculating currentProfit.\\n\\t\\t\\t//If currentProfit is greater that maxProfit, updating maxProfit\\n            if(prices[left]<prices[right]){\\n                int currentProfit = prices[right]-prices[left];\\n                maxProfit = Math.max(maxProfit, currentProfit);\\n            }else{\\n\\t\\t\\t\\t//if we found a day having even less price , we will buy the stock at that day. \\n                left = right;\\n            }\\n            right++;\\n        }\\n        return maxProfit;\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 1528220,
                "title": "o-n-detailed-explanation-case-dissected",
                "content": "# 5, 2, 6, 1, 4\\n**Let us solve the problem for the above data**\\nDays are numbered, from 0 to 4 (i = i to 4)\\n\\nPrimary idea: Buying at the lowest price and selling it at the maximum will bring us profit! We always look for maximum profit if we cannot sell it at lowest or buy it at its highest.\\n\\n**Day 0: [5]** \\n*We have one option. Let us suppose we buy the stock at day 0. **minbytsofar=5.**\\nLet us suppose we sold it at Day 0 itself. Thus, we sold it at 5.\\nRemember profit= sell cost- buy cost. What will be the profit in this case? **profit=5-5=0***\\n\\n**Day 1: [5 , 2]**\\n*On day 1 we see that if we bought it now, instead of buying it when the cost was 5, we will be at an advantage. Because, our primary idea was to buy at the lowest. Thus, **minbuysofar**= **minimum(5,2)= 2**\\nSelling it at day 1 will give us a **profit=2-2=0***\\n\\n**Day 2: [5, 2, 6]**\\n*If we bought it on day 2, we wont be making an intellingent choice, because we always buy stock at its minimum. We let the minbuysofar remain as it was. Mathematically, **minbuysofar=minimum(6,2)=2***\\n*Selling it now would give us a profit of (selling at day 2- buying at day 1)= **profit=6-2=4***\\n*setting a global maxima for profit, maxprofit=4*\\n\\n**Day 3: [5, 2, 6, 1]**\\n*The price is 1 now. Will we buy now? Hell yeah!! Its lower than 2 **minbuysofar=minimum(2,1)***\\n***profit=selling it on day 3- buying it on day 3=1-1=0***\\n*Global maxima for profit? Maximum(0,4)=4. 4 was still our maximum profit made*\\n\\n**Day 4: [5, 2, 6, 1, 4]**\\n***minbuysofar= minimum(1,4)*** *We won\\'t buy anymore*\\n*Maximum profit made is still 4. Because Max(4,3)=4*\\n\\n**Answer = 4. OUR BEST PROFIT!!**\\n\\n\\n```\\nclass Solution {\\n    public int maxProfit(int[] prices) {\\n        if (prices.length == 1)\\n            return 0;\\n        \\n        //              DYNAMIC PROGRAMMING APPROACH  \\n        \\n        //we are going to run a loop and find selling on which day is going to give us profit, corresponding to each buying day\\n        //to optimize this we further find the best buying day before calculating the profit\\n        \\n        int minbuysofar = prices [0];\\n        int maxprofit = 0;\\n        int profit = 0;\\n        \\n        for (int i=0; i<prices.length; i++)\\n        {\\n            minbuysofar = Math.min(minbuysofar, prices[i]);\\n            //we buy at the price of minbuysofar\\n            \\n            \\n            profit = prices[i]- minbuysofar; \\n            /* this translates to:\\n        minbuysofar = selling on i\\'th day- buying when price is minbuysofar*/\\n            \\n            \\n            //Now we need to see where the profit was maximum\\n            maxprofit = Math.max(maxprofit, profit);\\n        }\\n        \\n        return maxprofit;\\n}\\n}\\n```\\n\\n***upvote if you find this helpful :p***",
                "solutionTags": [
                    "Java",
                    "C",
                    "Array",
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution {\\n    public int maxProfit(int[] prices) {\\n        if (prices.length == 1)\\n            return 0;\\n        \\n        //              DYNAMIC PROGRAMMING APPROACH  \\n        \\n        //we are going to run a loop and find selling on which day is going to give us profit, corresponding to each buying day\\n        //to optimize this we further find the best buying day before calculating the profit\\n        \\n        int minbuysofar = prices [0];\\n        int maxprofit = 0;\\n        int profit = 0;\\n        \\n        for (int i=0; i<prices.length; i++)\\n        {\\n            minbuysofar = Math.min(minbuysofar, prices[i]);\\n            //we buy at the price of minbuysofar\\n            \\n            \\n            profit = prices[i]- minbuysofar; \\n            /* this translates to:\\n        minbuysofar = selling on i\\'th day- buying when price is minbuysofar*/\\n            \\n            \\n            //Now we need to see where the profit was maximum\\n            maxprofit = Math.max(maxprofit, profit);\\n        }\\n        \\n        return maxprofit;\\n}\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 534953,
                "title": "explain-like-i-m-5-o-n-java-solution-solved-with-only-basic-intuition",
                "content": "Too often the solution is overcomplicated with terms like\\n- DP\\n- Kadane Algorithm\\n\\nYou can solve this problem with only simple logical reasoning to come up with the optimal solution.\\n\\nOur input: [7,1,5,3,6,4]\\n\\nWe know:\\n-  You can potentially sell stock on any day\\n-  When we sell stock on a certain day, we want to have bought stock when it was at it\\'s lowest prior to that day\\n\\nWe can simulate selling selling the stock every day and see which day would yield the max profit.\\n\\nWe do this by going through the array day by day while:\\n- Keeping track of lowest value\\n- Simulating the maximum profit if we were to sold that day\\n\\n```\\nclass Solution {\\n    public int maxProfit(int[] prices) {\\n        int lowestUntilThisPoint = Integer.MAX_VALUE;\\n        int maxProfit = -1;\\n        \\n        for (int price: prices) {\\n            if (price < lowestUntilThisPoint) {\\n                lowestUntilThisPoint = price;\\n            }\\n            int profit = price - lowestUntilThisPoint;\\n            if (profit > maxProfit) \\n                maxProfit = profit;\\n        }\\n        return Math.max(maxProfit, 0);\\n    }\\n}\\n```\\n",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int maxProfit(int[] prices) {\\n        int lowestUntilThisPoint = Integer.MAX_VALUE;\\n        int maxProfit = -1;\\n        \\n        for (int price: prices) {\\n            if (price < lowestUntilThisPoint) {\\n                lowestUntilThisPoint = price;\\n            }\\n            int profit = price - lowestUntilThisPoint;\\n            if (profit > maxProfit) \\n                maxProfit = profit;\\n        }\\n        return Math.max(maxProfit, 0);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 39206,
                "title": "o-n-solution-without-using-dp-using-divide-and-conquer-technique",
                "content": "I know the problem tag says it is a DP problem but this can also be solved using divide and conquer approach. The Idea is to divide the array in two halves and call it recursively. recursive method will return 3 values maxProfit, minPrice and maxPrice. For each iteration max profit will be max of maxProfit of each halves compared with the difference of max of right half and min of left half. Following is the code\\n\\n    public int maxProfit(int[] prices) {\\n            return prices.length > 0 ? helper(prices,0,prices.length -1)[0] : 0;\\n        }\\n        /**\\n         * index 0 is max profit, index 1 is max price in the range and index 2 is min price in the range.\\n         */\\n        private int[] helper(int[] prices, int i, int j){\\n            int[] result = {0,prices[i],prices[j]}; // base case \\n            if(i == j) return result;\\n            int m = i + (j - i) / 2 ;\\n            int[] left = helper(prices,i,m); // left half\\n            int[] right = helper(prices,m+1,j); // right half\\n            result[0] = Math.max(left[0],Math.max(right[0],right[1] - left[2]));\\n            result[1] = Math.max(left[1],right[1]);\\n            result[2] = Math.min(left[2],right[2]);\\n            return result;\\n        }",
                "solutionTags": [
                    "Java",
                    "Divide and Conquer"
                ],
                "code": "I know the problem tag says it is a DP problem but this can also be solved using divide and conquer approach. The Idea is to divide the array in two halves and call it recursively. recursive method will return 3 values maxProfit, minPrice and maxPrice. For each iteration max profit will be max of maxProfit of each halves compared with the difference of max of right half and min of left half. Following is the code\\n\\n    public int maxProfit(int[] prices) {\\n            return prices.length > 0 ? helper(prices,0,prices.length -1)[0] : 0;\\n        }\\n        /**\\n         * index 0 is max profit, index 1 is max price in the range and index 2 is min price in the range.\\n         */\\n        private int[] helper(int[] prices, int i, int j){\\n            int[] result = {0,prices[i],prices[j]}; // base case \\n            if(i == j) return result;\\n            int m = i + (j - i) / 2 ;\\n            int[] left = helper(prices,i,m); // left half\\n            int[] right = helper(prices,m+1,j); // right half\\n            result[0] = Math.max(left[0],Math.max(right[0],right[1] - left[2]));\\n            result[1] = Math.max(left[1],right[1]);\\n            result[2] = Math.min(left[2],right[2]);\\n            return result;\\n        }",
                "codeTag": "Unknown"
            },
            {
                "id": 39192,
                "title": "simple-python-code",
                "content": "    class Solution(object):\\n        def maxProfit(self, prices):\\n            \"\"\"\\n            :type prices: List[int]\\n            :rtype: int\\n            \"\"\"\\n            n=len(prices)\\n            if n<=1:\\n                return 0\\n            max_profit=0\\n            low_price=prices[0]\\n            for i in range(1,n):\\n                low_price=min(low_price,prices[i])\\n                max_profit=max(max_profit, prices[i]-low_price)\\n            return max_profit",
                "solutionTags": [],
                "code": "    class Solution(object):\\n        def maxProfit(self, prices):\\n            \"\"\"\\n            :type prices: List[int]\\n            :rtype: int\\n            \"\"\"\\n            n=len(prices)\\n            if n<=1:\\n                return 0\\n            max_profit=0\\n            low_price=prices[0]\\n            for i in range(1,n):\\n                low_price=min(low_price,prices[i])\\n                max_profit=max(max_profit, prices[i]-low_price)\\n            return max_profit",
                "codeTag": "Java"
            },
            {
                "id": 39244,
                "title": "concise-solution-o-n",
                "content": "1 to record the changes from yesterday \\n2 find the max sum of consecutive subarray(if sum<0 sum==0)\\n\\n\\n    class Solution {\\n    public:\\n        int maxProfit(vector<int> &prices) {\\n            \\n            int max=0;\\n            int current=0;\\n            for(int i=1;i<prices.size();i++){\\n                current+=prices[i]-prices[i-1];\\n                if(current<0) current=0;\\n                else if(current>max) max=current;\\n            }\\n        return max;\\n    }  \\n    };",
                "solutionTags": [],
                "code": "class Solution {\\n    public:\\n        int maxProfit(vector<int> &prices) {\\n            \\n            int max=0;\\n            int current=0;\\n            for(int i=1;i<prices.size();i++){\\n                current+=prices[i]-prices[i-1];\\n                if(current<0) current=0;\\n                else if(current>max) max=current;\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 4041235,
                "title": "java-dynamic-programming-o-n",
                "content": "# Intuition\\nThe problem involves finding the maximum profit that can be obtained by buying and selling a stock. The intuition is to use **dynamic** **programming** to keep track of the minimum buying price and the maximum profit that can be obtained at each step.\\n\\n# Approach\\n- Check if the length of the `prices` array is less than or equal to 1. If so, return 0 because there are not enough days to make a profit.\\n- Initialize an integer array `dp` of the same length as `prices` to store the maximum profit that can be obtained at each day. Set `dp[0]` to 0 because no profit can be made on the first day.\\n- Initialize an integer variable `minPrice` to store the minimum buying price. Set `minPrice` to the price on the first day, `prices[0]`.\\n- Use a loop to iterate through the `prices` array starting from the second day (index 1).\\n- For each day `i`, calculate the maximum profit that can be obtained either by not selling on this day (i.e., `dp[i-1]`) or by selling on this day (i.e., `prices[i] - minPrice`). Take the maximum of these two values and update `dp[i]` accordingly.\\n- Update `minPrice` by taking the minimum of its current value and the price on the current day `prices[i]`. This step ensures that `minPrice` always represents the minimum buying price seen so far.\\n- After the loop, the maximum profit is stored in `dp[n-1]`, where `n` is the length of the `prices` array.\\n- Return `dp[n-1]` as the maximum profit that can be obtained.\\n\\n# Complexity\\n- Time complexity: O(n)\\n  The algorithm iterates through the `prices` array once, performing constant-time operations at each step, resulting in a linear time complexity of O(n), where n is the length of the `prices` array.\\n\\n- Space complexity: O(n)\\n  The algorithm uses an additional integer array `dp` of the same length as the `prices` array, resulting in a space complexity of O(n).\\n  \\n# Code\\n```java\\nclass Solution {\\n    public int maxProfit(int[] prices) {\\n        if (prices.length <= 1) {\\n            return 0;\\n        }\\n\\n        int n = prices.length;\\n        int[] dp = new int[n]; \\n        dp[0] = 0;\\n        int minPrice = prices[0];\\n\\n        for (int i = 1; i < n; i++) {\\n            dp[i] = Math.max(dp[i - 1], prices[i] - minPrice);\\n            minPrice = Math.min(minPrice, prices[i]);\\n        }\\n\\n        return dp[n - 1];\\n    }\\n}\\n",
                "solutionTags": [
                    "Java"
                ],
                "code": "class Solution {\\n    public int maxProfit(int[] prices) {\\n        if (prices.length <= 1) {\\n            return 0;\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 3226931,
                "title": "python-3-5-lines-w-explanation-and-example-t-m-98-83",
                "content": "Here\\'s the plan:\\n\\nWe iterate through`prices`, keeping track of\\n1. `mn`, the minimum`price` were we to buy that day,and \\n2. `mx`, the potential maximum profit, were we to sell that day.\\n\\nWe return the profit`mx`after completing the iteration\\n\\n```\\nclass Solution:\\n    def maxProfit(self, prices: list[int]) -> int:\\n                                            # Example: prices = [7,1,5,3,6,4]\\n                                            #\\n        mn, mx = prices[0], 0               #   p   mn   mx  \\n                                            #  \\u2013\\u2013\\u2013  \\u2013\\u2013\\u2013  \\u2013\\u2013\\u2013\\n        for p in prices:                    #        7    0    <--   initial values\\n                                            #   1    1    0    <--   1 - 1 = 0, so mx = 0 still\\n            if   p < mn     : mn = p        #   5    1    4    <--   5 - 1 = 4, so mx = 4 now\\n            elif p > mx + mn: mx = p - mn   #   3    1    4    <--   3 - 1 = 2, so mx = 4 still\\n                                            #   6    1    4    <--   6 - 1 = 5, so mx = 5 now\\n        return mx                           #   4    1    5    <--   4 - 1 = 3, so mx = 5 still\\n                                            #\\n                                            #                         return 5\\n\\n```\\n[https://leetcode.com/problems/best-time-to-buy-and-sell-stock/submissions/904408311/](http://)\\n\\nI could be wrong, but I think that time complexity is *O*(*N*) and space complexity is *O*(1).",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def maxProfit(self, prices: list[int]) -> int:\\n                                            # Example: prices = [7,1,5,3,6,4]\\n                                            #\\n        mn, mx = prices[0], 0               #   p   mn   mx  \\n                                            #  \\u2013\\u2013\\u2013  \\u2013\\u2013\\u2013  \\u2013\\u2013\\u2013\\n        for p in prices:                    #        7    0    <--   initial values\\n                                            #   1    1    0    <--   1 - 1 = 0, so mx = 0 still\\n            if   p < mn     : mn = p        #   5    1    4    <--   5 - 1 = 4, so mx = 4 now\\n            elif p > mx + mn: mx = p - mn   #   3    1    4    <--   3 - 1 = 2, so mx = 4 still\\n                                            #   6    1    4    <--   6 - 1 = 5, so mx = 5 now\\n        return mx                           #   4    1    5    <--   4 - 1 = 3, so mx = 5 still\\n                                            #\\n                                            #                         return 5\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3108528,
                "title": "c-simple-o-n-one-pass",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nSimply track mininum upto each element take the differnee and comapre it it is greater than previous then update .\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nJust traverse the whole array and track minimum so far and take take its diffrence with each element and keep updating the max diff.At lst return the maximum diffrence.\\n# Complexity\\n- Time complexity:$$O(N)$$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:$$O(1)$$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int maxProfit(vector<int>& arr) {\\n        int ans=0;\\n        int n=arr.size();\\n        int mini=INT_MAX,maxi=0;\\n         for(int i=0;i<n;i++){\\n             ans=max(ans,arr[i]-mini);\\n             mini=min(arr[i],mini);\\n           //  maxi=max(arr[i+1],maxi);\\n         }\\n         return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Array"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int maxProfit(vector<int>& arr) {\\n        int ans=0;\\n        int n=arr.size();\\n        int mini=INT_MAX,maxi=0;\\n         for(int i=0;i<n;i++){\\n             ans=max(ans,arr[i]-mini);\\n             mini=min(arr[i],mini);\\n           //  maxi=max(arr[i+1],maxi);\\n         }\\n         return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2795048,
                "title": "java-runtime-1ms-faster-than-100-o-n-time-o-1-space",
                "content": "```\\nclass Solution {\\n    public int maxProfit(int[] prices) {\\n        int minBuy = prices[0], maxProfit = 0;\\n        for (int current : prices) {\\n            minBuy = Math.min(minBuy, current);\\n            maxProfit = Math.max(maxProfit, current - minBuy);\\n        }\\n        return maxProfit;\\n    }\\n}\\n```\\n\\n![image](https://assets.leetcode.com/users/images/302b12c8-9225-4955-8376-ddc8de15ccd5_1667962964.2372463.png)\\n",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int maxProfit(int[] prices) {\\n        int minBuy = prices[0], maxProfit = 0;\\n        for (int current : prices) {\\n            minBuy = Math.min(minBuy, current);\\n            maxProfit = Math.max(maxProfit, current - minBuy);\\n        }\\n        return maxProfit;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2643827,
                "title": "comprehensive-python-solution-thought-process-examples",
                "content": "**Approach**\\nYour first thought when approaching this problem is probably that we should buy on the cheapest day and then sell on the most expensive day. This works for cases such as ```[1,4,3,2,5]```  where the highest priced day is after the lowest priced day (in this case you can buy on day ```0``` and sell on day ```4``` to make a profit of ```4```. However, in a case such as example 1, ```[7,1,5,3,6,4]```, this method would assert that we can get a profit of ```6``` by selling at the highest price, ```7```, and buying at the lowest price, ```1```. Unfortuantely, this is not possible since we need to buy before we sell! So, how can we go from here? Well, let\\'s think about this major restriction \\u2013 we need to sell *after* we buy. This means that we can figure out the maximum profit to make by going to each day and seeing what would happen if we buy on that day and sell later!\\n\\n**Method 1: Brute-force; Time: O(N^2), Space: O(1) \\u2014> TLE**\\n```\\ndef maxProfit(self, prices: List[int]) -> int:\\n        profit = 0 #best profit possible\\n        for i in range(len(prices)-1):\\n            buy = prices[i] #assume we buy today\\n            sell = max(prices[i+1:]) #we sell on the future day with the highest price\\n            if sell-buy > profit: #if this combination improves our profit\\n                profit = sell-buy #update the profit\\n        return profit\\n```\\nIn this method we iterate through all the days and then figure out the highest profit we can make by buying on day ```i``` and selling on the day with the maximum price that occurs after this day (day ```i+1``` or later). Each time we check to see if this improved our profit. This method has a time complexity of ```O(N^2)``` since for every day ```i```, we need to look at ```N-i-1``` days afterwards to find the best day to sell. Unfortunately this results in a time limit exception since some of the leetcode test cases are super lengthy, so we will need to find a better solution.\\n\\n**How to improve - what to do when stuck**\\nFirst, let\\'s identify what step in our process is slowing down the code. It isn\\'t figuring out which day to buy, since we just assume we buy on day ```i```, but finding the day we sell on. Since the day we sell on is in the future, we need to look at every day even though we sometimes already looked at them in the last iteration of our ```for``` loop. So, let\\'s brainstorm how we can improve this method. Rather than assuming we buy on day ```i```, let\\'s assume we actually sell on day ```i```. Since we have already looked at the ```i-1``` days before this day, we can keep track of the cheapest day to buy on which was before day ```i```. This will greatly improve the speed of our code since we don\\'t need to look at a ton of days each time!\\n\\n**Method 2: One-pass; Time: O(N), Space: O(1)**\\n```\\ndef maxProfit(self, prices: List[int]) -> int:\\n        profit = 0 #our answer\\n        buy = prices[0] #the day we buy on\\n        for i in range(1,len(prices)):\\n            sell = prices[i] #assume we sell today\\n            profit = max(profit,sell-buy) #update the maximum profit if we were to sell today\\n            buy = min(buy,prices[i]) #update the cheapest price we could buy\\n        return profit\\n```\\nAs mentioned before, in this method we keep track of the cheapest day to buy, then see what would happen if we sold our stock on day ```i```. First we see if the profit we make from selling today is better than the profit we previously could make. Then make sure that this value, ```buy``` is as small as possible by checking to see if the current price is cheaper. To help illustrate how this works, I will walk through both examples provided with the question.\\n\\n**Example 1:**\\n```\\nprices = [7,1,5,3,6,4]\\n\\ni = 1, previous max profit = 0, buy = 7, sell = 1\\ni = 2, previous max profit = 0, buy = 1, sell = 5\\ni = 3, previous max profit = 4, buy = 1, sell = 3\\ni = 4, previous max profit = 4, buy = 1, sell = 6\\ni = 5, previous max profit = 5, buy = 1, sell = 4\\n```\\n\\n**Example 2:**\\n```\\nprices = [7,1,5,3,6,4]\\n\\ni = 1, previous max profit = 0, buy = 7, sell = 6\\ni = 2, previous max profit = 0, buy = 6, sell = 4\\ni = 3, previous max profit = 0, buy = 4, sell = 3\\ni = 4, previous max profit = 0, buy = 3, sell = 1\\n```\\n\\nI hope that walking through these examples has helped you understand what\\'s going on! If you still have any questions, please comment and I will try to help!\\n\\n**Thanks for Reading!**\\nIf this post has been helpful, please consider upvoting! Also, if I made any mistakes or there are other optimizations, methods I didn\\'t consider, etc. please let me know!\\n\\n\\n",
                "solutionTags": [
                    "Python"
                ],
                "code": "```[1,4,3,2,5]```\n```0```\n```4```\n```4```\n```[7,1,5,3,6,4]```\n```6```\n```7```\n```1```\n```\\ndef maxProfit(self, prices: List[int]) -> int:\\n        profit = 0 #best profit possible\\n        for i in range(len(prices)-1):\\n            buy = prices[i] #assume we buy today\\n            sell = max(prices[i+1:]) #we sell on the future day with the highest price\\n            if sell-buy > profit: #if this combination improves our profit\\n                profit = sell-buy #update the profit\\n        return profit\\n```\n```i```\n```i+1```\n```O(N^2)```\n```i```\n```N-i-1```\n```i```\n```for```\n```i```\n```i```\n```i-1```\n```i```\n```\\ndef maxProfit(self, prices: List[int]) -> int:\\n        profit = 0 #our answer\\n        buy = prices[0] #the day we buy on\\n        for i in range(1,len(prices)):\\n            sell = prices[i] #assume we sell today\\n            profit = max(profit,sell-buy) #update the maximum profit if we were to sell today\\n            buy = min(buy,prices[i]) #update the cheapest price we could buy\\n        return profit\\n```\n```i```\n```buy```\n```\\nprices = [7,1,5,3,6,4]\\n\\ni = 1, previous max profit = 0, buy = 7, sell = 1\\ni = 2, previous max profit = 0, buy = 1, sell = 5\\ni = 3, previous max profit = 4, buy = 1, sell = 3\\ni = 4, previous max profit = 4, buy = 1, sell = 6\\ni = 5, previous max profit = 5, buy = 1, sell = 4\\n```\n```\\nprices = [7,1,5,3,6,4]\\n\\ni = 1, previous max profit = 0, buy = 7, sell = 6\\ni = 2, previous max profit = 0, buy = 6, sell = 4\\ni = 3, previous max profit = 0, buy = 4, sell = 3\\ni = 4, previous max profit = 0, buy = 3, sell = 1\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 2573375,
                "title": "simple-javascript-solution",
                "content": "### Solution\\n```js\\n/**\\n * @param {number[]} prices\\n * @return {number}\\n */\\nvar maxProfit = function(prices) {\\n    // set to first element in array by default\\n    let minprice = prices[0];\\n    let profit = 0;\\n    for (let i = 0; i < prices.length; i++) {\\n        if (prices[i] < minprice) {\\n            minprice = prices[i];\\n        } else if (prices[i] - minprice > profit) {\\n            profit = prices[i] - minprice;\\n        }\\n    }\\n     return profit\\n};\\n```\\n\\n### LeetCode Output\\nRuntime: **89 ms**, faster than **93.23%** of JavaScript online submissions for Valid Parentheses.\\nMemory Usage: **52 MB**, less than **24.52%** of JavaScript online submissions for Valid Parentheses.\\n\\n[Link to Submission](https://leetcode.com/submissions/detail/799297619/)",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```js\\n/**\\n * @param {number[]} prices\\n * @return {number}\\n */\\nvar maxProfit = function(prices) {\\n    // set to first element in array by default\\n    let minprice = prices[0];\\n    let profit = 0;\\n    for (let i = 0; i < prices.length; i++) {\\n        if (prices[i] < minprice) {\\n            minprice = prices[i];\\n        } else if (prices[i] - minprice > profit) {\\n            profit = prices[i] - minprice;\\n        }\\n    }\\n     return profit\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2376959,
                "title": "python-o-n-solution",
                "content": "```\\nclass Solution:\\n    def maxProfit(self, prices: List[int]) -> int:\\n        max_profit = 0\\n        min_price = 999999\\n        for price in prices:\\n            if price < min_price:\\n                min_price = price\\n            if price - min_price > max_profit:\\n                max_profit = price - min_price\\n        return max_profit\\n```\\n\\n\\tIf you liked it, hit the upvote button! ;)",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nclass Solution:\\n    def maxProfit(self, prices: List[int]) -> int:\\n        max_profit = 0\\n        min_price = 999999\\n        for price in prices:\\n            if price < min_price:\\n                min_price = price\\n            if price - min_price > max_profit:\\n                max_profit = price - min_price\\n        return max_profit\\n```",
                "codeTag": "Java"
            },
            {
                "id": 719577,
                "title": "javascript-easy-approach",
                "content": "```\\nvar maxProfit = function (prices) {\\n    let minBuyPrice = prices[0];\\n    let maxProfit = 0;\\n    for (let price of prices) {\\n        if (price < minBuyPrice) {\\n            minBuyPrice = price\\n        } else if (price-minBuyPrice > maxProfit){\\n            maxProfit = price-minBuyPrice\\n        }\\n    }\\n    return maxProfit\\n}",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\nvar maxProfit = function (prices) {\\n    let minBuyPrice = prices[0];\\n    let maxProfit = 0;\\n    for (let price of prices) {\\n        if (price < minBuyPrice) {\\n            minBuyPrice = price\\n        } else if (price-minBuyPrice > maxProfit){\\n            maxProfit = price-minBuyPrice\\n        }\\n    }\\n    return maxProfit\\n}",
                "codeTag": "Unknown"
            },
            {
                "id": 494015,
                "title": "accepted-c-solution-easy-to-understand",
                "content": "For C# programmers the optimal solution code from Solution tab\\n# Approach\\nTrack minimum price and check for maximum profit\\n\\nTime Complexity: O(n)\\nSpace complexity: O(1)\\n\\n```\\npublic class Solution {\\n    public int MaxProfit(int[] prices)\\n    {\\n        int minprice = int.MaxValue;\\n        int maxprofit = 0;\\n        \\n        for (int i = 0; i < prices.Length; i++)\\n        {\\n            if (prices[i] < minprice)\\n            {\\n                minprice = prices[i];\\n            }\\n            else if (prices[i] - minprice > maxprofit)\\n            {\\n                maxprofit = prices[i] - minprice;\\n            }\\n        }\\n        \\n        return maxprofit;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\npublic class Solution {\\n    public int MaxProfit(int[] prices)\\n    {\\n        int minprice = int.MaxValue;\\n        int maxprofit = 0;\\n        \\n        for (int i = 0; i < prices.Length; i++)\\n        {\\n            if (prices[i] < minprice)\\n            {\\n                minprice = prices[i];\\n            }\\n            else if (prices[i] - minprice > maxprofit)\\n            {\\n                maxprofit = prices[i] - minprice;\\n            }\\n        }\\n        \\n        return maxprofit;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3872093,
                "title": "beats-94-43-in-runtime-63-in-memory-only-6-lines",
                "content": "![image.png](https://assets.leetcode.com/users/images/298dc630-31a5-4e65-b0eb-cf5bfdb3bc3e_1691325811.8985078.png)\\n\\n\\n\\nPlease UPVOTE \\n\\n\\n\\n# Code\\n```\\nclass Solution(object):\\n    def maxProfit(self, prices):\\n        l,r=0,1;maxP=0 \\n        while r<len(prices):\\n            if prices[l]<prices[r]:profit=prices[r]-prices[l];maxP=max(maxP, profit)                \\n            else:l=r \\n            r+=1\\n        return maxP\\n\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution(object):\\n    def maxProfit(self, prices):\\n        l,r=0,1;maxP=0 \\n        while r<len(prices):\\n            if prices[l]<prices[r]:profit=prices[r]-prices[l];maxP=max(maxP, profit)                \\n            else:l=r \\n            r+=1\\n        return maxP\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3758901,
                "title": "c-python-greedy-explain-w-pyplot",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nThe given code is a solution to the problem of finding the maximum profit that can be obtained from buying and selling stocks. The class Solution contains a single member function maxProfit that takes a vector of integers prices as input and returns an integer value representing the maximum profit.\\n\\n<!-- Describe your approach to solving the problem. -->\\n # Explain with Matplotlib.pyplot\\n[Please turn on English subtitles]\\n[https://youtu.be/--vVXnaKPqI](https://youtu.be/--vVXnaKPqI)\\n# Approach\\nThe following loop iterates through the prices vector starting from index 1 (since we already initialized buy with the price at index 0):\\n\\nbuy = min(buy, prices[i]);: \\nThis line compares the current price (prices[i]) with the current minimum price (buy). It updates buy if the current price is smaller, ensuring that buy always represents the minimum price seen so far.\\n\\nsell = max(sell, prices[i] - buy);: \\nThis line calculates the profit that can be obtained by selling at the current price (prices[i]) after buying at the minimum price (buy). It compares this profit with the current maximum profit (sell) and updates sell if the calculated profit is larger. This way, sell always represents the maximum profit seen so far.\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n$$O(n)$$\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n$$O(1)$$\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int maxProfit(vector<int>& prices) {\\n        int&& s=prices.size();\\n        if (s <= 1) return 0;\\n        int buy = prices[0], sell=0;\\n        for (int i = 1; i < s; i++) {\\n            buy = min(buy, prices[i]);\\n            sell = max(sell, prices[i] - buy);\\n //           cout<<buy<<\"|\"<<sell<<endl;          \\n        }\\n        return sell;\\n    }\\n};  \\n  \\n```\\n# Python Code\\n\\n```\\nclass Solution:\\n    def maxProfit(self, prices: List[int]) -> int:\\n        #List & Loop \\n        profit=0\\n        buy=prices[0]\\n        for x in prices[1:]:\\n            buy=min(buy, x)\\n            profit=max(profit, x-buy)\\n        return profit\\n```",
                "solutionTags": [
                    "C++",
                    "Python3"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int maxProfit(vector<int>& prices) {\\n        int&& s=prices.size();\\n        if (s <= 1) return 0;\\n        int buy = prices[0], sell=0;\\n        for (int i = 1; i < s; i++) {\\n            buy = min(buy, prices[i]);\\n            sell = max(sell, prices[i] - buy);\\n //           cout<<buy<<\"|\"<<sell<<endl;          \\n        }\\n        return sell;\\n    }\\n};  \\n  \\n```\n```\\nclass Solution:\\n    def maxProfit(self, prices: List[int]) -> int:\\n        #List & Loop \\n        profit=0\\n        buy=prices[0]\\n        for x in prices[1:]:\\n            buy=min(buy, x)\\n            profit=max(profit, x-buy)\\n        return profit\\n```",
                "codeTag": "C++"
            },
            {
                "id": 3227970,
                "title": "stocks-buy-and-sell-dp-easy-understanding",
                "content": "Hi,\\n\\nThere are lot of solutions already available, but reason behind writing this solution is this question is tagged as \\'Easy\\' but most of the solutions are not looking easy it looks like \\'Medium\\'. So thought to write a easy solution which is easy for everyone.\\n\\nI picked up DP approach, because its easy to relate to.\\n\\n**Intution:**\\nInorder to get maximum profit we will see what is the minimum rate before today that we can buy. \\n\\n**Steps:**\\n1. Define a DP array of size equal to array length\\n2. Iterate through the given array and see the minimum prices till that array store it in the DP array -> dp[i] = Math.min(dp[i-1], prices[i]);\\n3. Find which day has maximum difference compared to the DP array\\n4. Return the result\\n\\nKindly upvote and spread joy..\\n\\n```\\n\\tpublic int maxProfit(int[] prices) {\\n\\t\\tint res=0;\\n\\t\\tint[] dp = new int[prices.length];\\n\\t\\tdp[0]=prices[0];\\n\\t\\tfor(int i=1; i<prices.length; i++){\\n\\t\\t\\tdp[i] = Math.min(dp[i-1], prices[i]);\\n\\t\\t}\\n\\t\\tfor(int i=0; i<prices.length; i++){\\n\\t\\t\\tres = Math.max(res, prices[i]-dp[i]);\\n\\t\\t}\\n\\t\\treturn res;\\n\\t}",
                "solutionTags": [
                    "Java",
                    "Dynamic Programming"
                ],
                "code": "Hi,\\n\\nThere are lot of solutions already available, but reason behind writing this solution is this question is tagged as \\'Easy\\' but most of the solutions are not looking easy it looks like \\'Medium\\'. So thought to write a easy solution which is easy for everyone.\\n\\nI picked up DP approach, because its easy to relate to.\\n\\n**Intution:**\\nInorder to get maximum profit we will see what is the minimum rate before today that we can buy. \\n\\n**Steps:**\\n1. Define a DP array of size equal to array length\\n2. Iterate through the given array and see the minimum prices till that array store it in the DP array -> dp[i] = Math.min(dp[i-1], prices[i]);\\n3. Find which day has maximum difference compared to the DP array\\n4. Return the result\\n\\nKindly upvote and spread joy..\\n\\n```\\n\\tpublic int maxProfit(int[] prices) {\\n\\t\\tint res=0;\\n\\t\\tint[] dp = new int[prices.length];\\n\\t\\tdp[0]=prices[0];\\n\\t\\tfor(int i=1; i<prices.length; i++){\\n\\t\\t\\tdp[i] = Math.min(dp[i-1], prices[i]);\\n\\t\\t}\\n\\t\\tfor(int i=0; i<prices.length; i++){\\n\\t\\t\\tres = Math.max(res, prices[i]-dp[i]);\\n\\t\\t}\\n\\t\\treturn res;\\n\\t}",
                "codeTag": "Unknown"
            },
            {
                "id": 2945822,
                "title": "simplest-c-solution",
                "content": "# Approach\\nSimply tack the min price of the stock and the profit. \\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity: O(n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\npublic class Solution {\\n    public int MaxProfit(int[] prices) {\\n        var min = prices[0];\\n        var profit = 0;\\n        foreach (var today in prices) {\\n            profit = Math.Max(profit, today-min);\\n            min = Math.Min(min, today);\\n        }\\n        return profit;\\n    }\\n}\\n```",
                "solutionTags": [
                    "C#"
                ],
                "code": "```\\npublic class Solution {\\n    public int MaxProfit(int[] prices) {\\n        var min = prices[0];\\n        var profit = 0;\\n        foreach (var today in prices) {\\n            profit = Math.Max(profit, today-min);\\n            min = Math.Min(min, today);\\n        }\\n        return profit;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2739938,
                "title": "python-c-java-rust-simple-min-max-operations-with-detailed-comments",
                "content": "**\\u2705 IF YOU LIKE THIS SOLUTION, PLEASE UPVOTE.**\\n****\\nThis solution employs simple min and max operations. Time complexity is linear: **O(N)**. Space complexity is constant: **O(1)**. \\n| **Language** | [**Python**](https://leetcode.com/submissions/detail/829388260/) | [**C++**](https://leetcode.com/submissions/detail/829376733/) | [**Java**](https://leetcode.com/submissions/detail/829383379/) | [**Rust**](https://leetcode.com/submissions/detail/829390159/) | \\n|---|---|---|---|---|\\n| **Runtime** | **1084 ms (93.30%)** | **93 ms (99.88%)** | **1 ms (100.00%)** | **4 ms (99.72%)** |\\n| **Memory** | **25.0 MB  (85.47%)** | **93.5 MB (8.10%)** | **58.8 MB  (94.22%)** | **3.0 MB  (66.34%)** |\\n\\n<iframe src=\"https://leetcode.com/playground/7ktsghLD/shared\" frameBorder=\"0\" width=\"800\" height=\"400\"></iframe>",
                "solutionTags": [
                    "Java",
                    "Python",
                    "C",
                    "Rust"
                ],
                "code": "**\\u2705 IF YOU LIKE THIS SOLUTION, PLEASE UPVOTE.**\\n****\\nThis solution employs simple min and max operations. Time complexity is linear: **O(N)**. Space complexity is constant: **O(1)**. \\n| **Language** | [**Python**](https://leetcode.com/submissions/detail/829388260/) | [**C++**](https://leetcode.com/submissions/detail/829376733/) | [**Java**](https://leetcode.com/submissions/detail/829383379/) | [**Rust**](https://leetcode.com/submissions/detail/829390159/) | \\n|---|---|---|---|---|\\n| **Runtime** | **1084 ms (93.30%)** | **93 ms (99.88%)** | **1 ms (100.00%)** | **4 ms (99.72%)** |\\n| **Memory** | **25.0 MB  (85.47%)** | **93.5 MB (8.10%)** | **58.8 MB  (94.22%)** | **3.0 MB  (66.34%)** |\\n\\n<iframe src=\"https://leetcode.com/playground/7ktsghLD/shared\" frameBorder=\"0\" width=\"800\" height=\"400\"></iframe>",
                "codeTag": "Unknown"
            },
            {
                "id": 2266768,
                "title": "c-easy-and-clean-code",
                "content": "**APPROACH**\\n```\\nclass Solution {\\npublic:\\n    int maxProfit(vector<int>& prices) {\\n        int p = 0;\\n        int m = INT_MAX;\\n        for(int i = 0; i < prices.size(); i++){\\n            m = min(m, prices[i]);\\n            p = max(p, prices[i] - m);\\n        }\\n        return p;\\n    }\\n};\\n```\\nUpvote if you find it useful. \\uD83D\\uDE4C",
                "solutionTags": [
                    "C",
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int maxProfit(vector<int>& prices) {\\n        int p = 0;\\n        int m = INT_MAX;\\n        for(int i = 0; i < prices.size(); i++){\\n            m = min(m, prices[i]);\\n            p = max(p, prices[i] - m);\\n        }\\n        return p;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1942808,
                "title": "python-faster-than-99-explanation-added",
                "content": "So we need to find difference between max and min value in array.\\nBut, cause of time (it\\'s market, man!), max value should be later (with higher array index).\\nFinally, algo is find min value and max difference with next values.\\n\\nReadable things like\\n```\\nprofit = max(profit, new_profit)\\n```\\nworks a bit slower than\\n```\\nif profit > new_profit:\\n\\tprofit = new_profit\\n```\\ncause of a lot additional assignments in most cases.\\n\\n```\\nclass Solution:\\n    def maxProfit(self, prices: List[int]) -> int:\\n        min_price = prices[0]\\n        profit = 0\\n        for price in prices:\\n            if price < min_price:\\n                min_price = price\\n            elif price - min_price > profit:\\n                profit = price - min_price\\n        return profit\\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nprofit = max(profit, new_profit)\\n```\n```\\nif profit > new_profit:\\n\\tprofit = new_profit\\n```\n```\\nclass Solution:\\n    def maxProfit(self, prices: List[int]) -> int:\\n        min_price = prices[0]\\n        profit = 0\\n        for price in prices:\\n            if price < min_price:\\n                min_price = price\\n            elif price - min_price > profit:\\n                profit = price - min_price\\n        return profit\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1929705,
                "title": "java-2ms-sliding-window-explanation-simple-o-n",
                "content": "The key to solving this problem is realizing that once a local minima is found, it is never more profitable going forward to buy on a day that costs more money. This is because we only have one day to choose to buy and one day to choose to sell.\\n\\nIf you are having trouble understanding why this solution works, then I would recommend simulating on paper what the code would do for two or more test cases.\\n\\n**Runtime Complexity - O(N)**\\n**Memory Complexity - O(1)**\\nwhere N is the size of the input array \"prices\".\\n```\\n    public int maxProfit(int[] prices) {\\n        int maxProfit = 0;\\n        \\n        int minSeenSoFar = prices[0];\\n        for(int day = 1; day < prices.length; day++) {\\n            int priceToday = prices[day];\\n            \\n            if(priceToday < minSeenSoFar) {\\n                minSeenSoFar = priceToday;\\n                continue;\\n            }\\n            \\n            maxProfit = Math.max(maxProfit, priceToday - minSeenSoFar);\\n        }\\n        \\n        return maxProfit;\\n    }\\n```",
                "solutionTags": [
                    "Java",
                    "Sliding Window"
                ],
                "code": "```\\n    public int maxProfit(int[] prices) {\\n        int maxProfit = 0;\\n        \\n        int minSeenSoFar = prices[0];\\n        for(int day = 1; day < prices.length; day++) {\\n            int priceToday = prices[day];\\n            \\n            if(priceToday < minSeenSoFar) {\\n                minSeenSoFar = priceToday;\\n                continue;\\n            }\\n            \\n            maxProfit = Math.max(maxProfit, priceToday - minSeenSoFar);\\n        }\\n        \\n        return maxProfit;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1871901,
                "title": "c-easy-solution-explained",
                "content": "Approach is maintaining the smallest price and use this formula \\n`profit = current_day_price - minimum_price`\\nexample : \\n```\\n\\t\\t\\t\\t\\t\\tday     =  1 ,2 ,3 ,4 ,5 ,6\\n\\t\\t\\t\\t\\t\\tprice   =  7 ,1 ,5 ,3 ,6 ,4\\n\\t\\t\\n\\t\\tprice = 7\\n\\t\\tprofit = current_day_price - minPrice\\n\\t\\tprofit = 7- 7 = 0\\n\\t\\t\\n\\t\\tprice = 1\\n\\t\\tprofit = current_day_price - minPrice\\n\\t\\tprofit = 1 - 1 = 0\\n\\t\\t\\n\\t\\tprice = 5\\n\\t\\tprofit = current_day_price - minPrice\\n\\t\\tprofit = 5 - 1 = 4   (since minimum price is still 1)\\n\\t\\t\\n\\t\\tprice = 3\\n\\t\\tprofit = current_day_price - minPrice\\n\\t\\tprofit = 3 - 1 = 2\\n\\t\\t\\n\\t\\tprice = 6\\n\\t\\tprofit = current_day_price - minPrice\\n\\t\\tprofit = 6 - 1 = 5\\n\\t\\t\\n\\t\\tprice = 4\\n\\t\\tprofit = current_day_price - minPrice\\n\\t\\tprofit = 4 - 1 = 3\\n\\t\\t\\n\\tand now you know maximum profit is  5  ( on 6th day )\\n\\tthis is taking O(n) Time\\n```\\n\\nNow try to code down this approach and if you cant do it do not lose hope come back and look to the solution and try again.\\n\\nIf you have any issue or if you found any error in my method do mention it in comments.\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t\\tThank you\\n\\t\\t\\t\\t\\t\\t\\n\\t\\t\\t\\t\\t\\t\\n```\\nclass Solution {\\npublic:\\n    int maxProfit(vector<int>& prices) \\n    {\\n        int minPrices = INT_MAX, maxProfit = 0, profit;\\n        \\n        for(int i = 0;i < prices.size();i++)\\n        {\\n            minPrices = min(minPrices,prices[i]);\\n            profit = prices[i] - minPrices ;\\n            \\n            if(profit > maxProfit){ maxProfit = profit;}\\n        }\\n        return maxProfit;\\n    }\\n};\\n```\\n\\n\\n* ***Try to understand the code rather than coping.***\\n* ***If you liked my work than upvote my solution.***\\n\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t AND\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t \\n\\t\\t\\t\\t\\t\\t\\t\\t**** Happy Coding ****\\n\\t\\t\\t\\t\\t\\t**** Keep Solving, Keep Upgrading **** \\n",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\n\\t\\t\\t\\t\\t\\tday     =  1 ,2 ,3 ,4 ,5 ,6\\n\\t\\t\\t\\t\\t\\tprice   =  7 ,1 ,5 ,3 ,6 ,4\\n\\t\\t\\n\\t\\tprice = 7\\n\\t\\tprofit = current_day_price - minPrice\\n\\t\\tprofit = 7- 7 = 0\\n\\t\\t\\n\\t\\tprice = 1\\n\\t\\tprofit = current_day_price - minPrice\\n\\t\\tprofit = 1 - 1 = 0\\n\\t\\t\\n\\t\\tprice = 5\\n\\t\\tprofit = current_day_price - minPrice\\n\\t\\tprofit = 5 - 1 = 4   (since minimum price is still 1)\\n\\t\\t\\n\\t\\tprice = 3\\n\\t\\tprofit = current_day_price - minPrice\\n\\t\\tprofit = 3 - 1 = 2\\n\\t\\t\\n\\t\\tprice = 6\\n\\t\\tprofit = current_day_price - minPrice\\n\\t\\tprofit = 6 - 1 = 5\\n\\t\\t\\n\\t\\tprice = 4\\n\\t\\tprofit = current_day_price - minPrice\\n\\t\\tprofit = 4 - 1 = 3\\n\\t\\t\\n\\tand now you know maximum profit is  5  ( on 6th day )\\n\\tthis is taking O(n) Time\\n```\n```\\nclass Solution {\\npublic:\\n    int maxProfit(vector<int>& prices) \\n    {\\n        int minPrices = INT_MAX, maxProfit = 0, profit;\\n        \\n        for(int i = 0;i < prices.size();i++)\\n        {\\n            minPrices = min(minPrices,prices[i]);\\n            profit = prices[i] - minPrices ;\\n            \\n            if(profit > maxProfit){ maxProfit = profit;}\\n        }\\n        return maxProfit;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1738780,
                "title": "java-leetcode-daily-challenege-1st-feb-faster-than-100",
                "content": "```\\n//PLEASE UPVOTE IF IT HELPS YOU\\n\\nclass Solution {\\n    public int maxProfit(int[] prices) {\\n        int sp=0;\\n        int profit=0;\\n        for(int i=prices.length-1;i>=0;i--){\\n            sp=Math.max(sp,prices[i]);\\n            profit=Math.max(profit,sp-prices[i]);\\n        }\\n        return profit;\\n    }\\n}\\n\\n\\n//TC:O(n)   n:size of array prices\\n /*\\n APPROACH: profit=sp-cp\\n Traverse from the last index of array prices which is aur cp and find maximum sp and projfit for each iteration\\n */\\n \\n ```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\n//PLEASE UPVOTE IF IT HELPS YOU\\n\\nclass Solution {\\n    public int maxProfit(int[] prices) {\\n        int sp=0;\\n        int profit=0;\\n        for(int i=prices.length-1;i>=0;i--){\\n            sp=Math.max(sp,prices[i]);\\n            profit=Math.max(profit,sp-prices[i]);\\n        }\\n        return profit;\\n    }\\n}\\n\\n\\n//TC:O(n)   n:size of array prices\\n /*\\n APPROACH: profit=sp-cp\\n Traverse from the last index of array prices which is aur cp and find maximum sp and projfit for each iteration\\n */\\n \\n ```",
                "codeTag": "Java"
            },
            {
                "id": 1735439,
                "title": "python-2-approaches-complexity",
                "content": "\\t# Time: O(n)\\n\\t# Space: O(1)\\n\\tclass Solution:\\n\\t\\tdef maxProfit(self, prices: List[int]) -> int:\\n\\t\\t\\tmiN = (1 << 31)\\n\\t\\t\\tmaX = 0\\n\\t\\t\\tfor i in range(1, len(prices)):\\n\\t\\t\\t\\tif prices[i] > prices[i-1]:\\n\\t\\t\\t\\t\\tmiN = min(miN, prices[i-1])\\n\\t\\t\\t\\t\\tmaX = max(maX, prices[i]-miN)\\n\\t\\t\\treturn maX\\n\\n\\t# Kadane\\'s Algo \\n\\tclass Solution:\\n\\t\\tdef maxProfit(self, prices: List[int]) -> int:\\n\\t\\t\\tans = 0\\n\\t\\t\\tcurSum = 0\\n\\t\\t\\tfor i in range(len(prices)-1):\\n\\t\\t\\t\\tcurSum += prices[i+1]-prices[i]\\n\\t\\t\\t\\tif curSum < 0:\\n\\t\\t\\t\\t\\tcurSum = 0\\n\\t\\t\\t\\tans = max(ans, curSum)\\n\\t\\t\\treturn ans\\nIf you have any questions, please ask me, and if you like this approach, please **vote it up**!",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "\\t# Time: O(n)\\n\\t# Space: O(1)\\n\\tclass Solution:\\n\\t\\tdef maxProfit(self, prices: List[int]) -> int:\\n\\t\\t\\tmiN = (1 << 31)\\n\\t\\t\\tmaX = 0\\n\\t\\t\\tfor i in range(1, len(prices)):\\n\\t\\t\\t\\tif prices[i] > prices[i-1]:\\n\\t\\t\\t\\t\\tmiN = min(miN, prices[i-1])\\n\\t\\t\\t\\t\\tmaX = max(maX, prices[i]-miN)\\n\\t\\t\\treturn maX\\n\\n\\t# Kadane\\'s Algo \\n\\tclass Solution:\\n\\t\\tdef maxProfit(self, prices: List[int]) -> int:\\n\\t\\t\\tans = 0\\n\\t\\t\\tcurSum = 0\\n\\t\\t\\tfor i in range(len(prices)-1):\\n\\t\\t\\t\\tcurSum += prices[i+1]-prices[i]\\n\\t\\t\\t\\tif curSum < 0:\\n\\t\\t\\t\\t\\tcurSum = 0\\n\\t\\t\\t\\tans = max(ans, curSum)\\n\\t\\t\\treturn ans\\nIf you have any questions, please ask me, and if you like this approach, please **vote it up**!",
                "codeTag": "Java"
            },
            {
                "id": 1735352,
                "title": "java-greedy-explained",
                "content": "**Idea:**\\n* Maximum profit is made when \\n\\t* stocks are bought at price[i] and sold at price[j], where i < j, and \\n\\t* profit = price[j] - price[i] is max across all profits\\n* So scan from left to right, recording any profit and also the cheapest price seen yet\\n* If you come across a profit, check if its more than last profit, if yes, then this is the new max profit\\n* If you come across a cheaper price than the last cheapest seen, then this is the new cheapest price\\n>**T/S:** O(n)/O(1), where n = size(nums)\\n```\\npublic int maxProfit(int[] prices) {\\n\\tvar maxProfit = 0;\\n\\n\\tfor (int i = 1, cheapest = prices[0]; i < prices.length; i++) {\\n\\t\\tif (prices[i] >= cheapest)\\n\\t\\t\\tmaxProfit = Math.max(maxProfit, prices[i] - cheapest);\\n\\t\\tcheapest = Math.min(cheapest, prices[i]);\\n\\t}\\n\\treturn maxProfit;\\n}\\n```\\n***Please upvote if this helps***",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\npublic int maxProfit(int[] prices) {\\n\\tvar maxProfit = 0;\\n\\n\\tfor (int i = 1, cheapest = prices[0]; i < prices.length; i++) {\\n\\t\\tif (prices[i] >= cheapest)\\n\\t\\t\\tmaxProfit = Math.max(maxProfit, prices[i] - cheapest);\\n\\t\\tcheapest = Math.min(cheapest, prices[i]);\\n\\t}\\n\\treturn maxProfit;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1675152,
                "title": "easiest-and-optimized-o-n-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    int maxProfit(vector<int>& profit) {\\n        int ans = profit[0];\\n        int mxpro = -1;\\n        for(int i = 0 ; i < profit.size() ; i++){\\n            ans = min(ans,profit[i]);\\n            mxpro = max(mxpro , profit[i] - ans);\\n        }\\n        return mxpro;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int maxProfit(vector<int>& profit) {\\n        int ans = profit[0];\\n        int mxpro = -1;\\n        for(int i = 0 ; i < profit.size() ; i++){\\n            ans = min(ans,profit[i]);\\n            mxpro = max(mxpro , profit[i] - ans);\\n        }\\n        return mxpro;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1286991,
                "title": "java-solution-multiple-approach",
                "content": "\\nBrute Force Approach - this code will exceed the time limit but \\nthat does not mean your logic is wrong\\nbe easy on yourself, #KeepCoding\\n\\n```\\npublic class Main {\\n    public static void main(String args[]) {\\n       int[] arr={7,1,5,3,6,4};\\n        int profit=0;\\n        int  max_profit=0;\\n        for(int i=0; i<arr.length; i++){\\n            for(int j=i+1; j<arr.length; j++){\\n            profit=arr[j]-arr[i];\\n            if(profit>max_profit) max_profit=profit;\\n            }\\n\\n        }\\n        System.out.println(max_profit);\\n    }\\n}\\n```\\n\\n\\n//Method -2\\n```\\nclass Solution {\\n   public int maxProfit(int[] prices) {\\n        int max = 0, min = Integer.MAX_VALUE;\\n        for (int i = 0; i < prices.length; i++) {\\n            if (prices[i] < min) min = prices[i];\\n            else if (prices[i] > min) max = Math.max(prices[i] - min, max);\\n        }\\n        return max;\\n    }\\n}\\n```\\n\\n//Method -3\\n```\\nclass Solution {\\n    public int maxProfit(int[] prices) {\\n        int profit=0, max_profit=0, min_price=prices[0];\\n        for(int i=1;i<prices.length; i++){\\n            profit=prices[i]-min_price;\\n            min_price=Math.min(min_price,prices[i]);\\n            max_profit=Math.max(max_profit,profit);\\n        }\\n        return max_profit;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\npublic class Main {\\n    public static void main(String args[]) {\\n       int[] arr={7,1,5,3,6,4};\\n        int profit=0;\\n        int  max_profit=0;\\n        for(int i=0; i<arr.length; i++){\\n            for(int j=i+1; j<arr.length; j++){\\n            profit=arr[j]-arr[i];\\n            if(profit>max_profit) max_profit=profit;\\n            }\\n\\n        }\\n        System.out.println(max_profit);\\n    }\\n}\\n```\n```\\nclass Solution {\\n   public int maxProfit(int[] prices) {\\n        int max = 0, min = Integer.MAX_VALUE;\\n        for (int i = 0; i < prices.length; i++) {\\n            if (prices[i] < min) min = prices[i];\\n            else if (prices[i] > min) max = Math.max(prices[i] - min, max);\\n        }\\n        return max;\\n    }\\n}\\n```\n```\\nclass Solution {\\n    public int maxProfit(int[] prices) {\\n        int profit=0, max_profit=0, min_price=prices[0];\\n        for(int i=1;i<prices.length; i++){\\n            profit=prices[i]-min_price;\\n            min_price=Math.min(min_price,prices[i]);\\n            max_profit=Math.max(max_profit,profit);\\n        }\\n        return max_profit;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 853112,
                "title": "dynamic-programming-explanation",
                "content": "We can view the official solution as a form of optimized dynamic programming solution.\\n\\nWith a naive dynamic programming solution, we can keep track of the lowest price encountered thus far using the folllowing relation:\\n\\n* memo[i+1] is the lowest price up to prices[0..i]\\n\\nThe code becomes:\\n\\n```java\\nclass Solution {\\n    public int maxProfit(int[] prices) {\\n        int n = prices.length;\\n        if (n <= 1) {\\n            return 0;\\n        }\\n        \\n        int ans = 0;\\n        int[] memo = new int[n+1];\\n        memo[1] = prices[0];\\n        \\n        for (int i = 1; i < n; i++) {\\n            memo[i+1] = Math.min(memo[i], prices[i]);\\n            ans = Math.max(ans, prices[i] - memo[i]);\\n        }\\n        \\n        return ans;\\n    }\\n}\\n```\\n\\nIt requires `~O(N)` space.\\n\\nNoticing that we only ever need to keep track of the maximum solution of a subproblem, we can avoid allocating an array.\\n\\n```java\\nclass Solution {\\n    public int maxProfit(int[] prices) {\\n        int n = prices.length;\\n        if (n <= 1) {\\n            return 0;\\n        }\\n        \\n        int ans = 0;\\n        int lo = prices[0];\\n        \\n        for (int i = 1; i < n; i++) {\\n            ans = Math.max(ans, prices[i] - lo);\\n            lo = Math.min(lo, prices[i]);\\n        }\\n        \\n        return ans;\\n    }\\n}\\n```\\n\\nNow it requires `~O(1)` space.",
                "solutionTags": [],
                "code": "```java\\nclass Solution {\\n    public int maxProfit(int[] prices) {\\n        int n = prices.length;\\n        if (n <= 1) {\\n            return 0;\\n        }\\n        \\n        int ans = 0;\\n        int[] memo = new int[n+1];\\n        memo[1] = prices[0];\\n        \\n        for (int i = 1; i < n; i++) {\\n            memo[i+1] = Math.min(memo[i], prices[i]);\\n            ans = Math.max(ans, prices[i] - memo[i]);\\n        }\\n        \\n        return ans;\\n    }\\n}\\n```\n```java\\nclass Solution {\\n    public int maxProfit(int[] prices) {\\n        int n = prices.length;\\n        if (n <= 1) {\\n            return 0;\\n        }\\n        \\n        int ans = 0;\\n        int lo = prices[0];\\n        \\n        for (int i = 1; i < n; i++) {\\n            ans = Math.max(ans, prices[i] - lo);\\n            lo = Math.min(lo, prices[i]);\\n        }\\n        \\n        return ans;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 283486,
                "title": "100-simple-golang-solution",
                "content": "```\\nfunc maxProfit(prices []int) int {\\n    if len(prices) <= 1 {\\n\\t\\treturn 0\\n\\t} \\n    \\n    min, maxSale := prices[0], 0\\n\\n\\tfor _,price := range prices {\\n\\t\\tif price < min {\\n\\t\\t\\tmin = price\\n        } else if (price-min) > maxSale{\\n\\t\\t\\tmaxSale = price-min\\n\\t\\t}\\n\\t}\\n\\t\\n\\treturn  maxSale\\n}",
                "solutionTags": [
                    "Go"
                ],
                "code": "```\\nfunc maxProfit(prices []int) int {\\n    if len(prices) <= 1 {\\n\\t\\treturn 0\\n\\t} \\n    \\n    min, maxSale := prices[0], 0\\n\\n\\tfor _,price := range prices {\\n\\t\\tif price < min {\\n\\t\\t\\tmin = price\\n        } else if (price-min) > maxSale{\\n\\t\\t\\tmaxSale = price-min\\n\\t\\t}\\n\\t}\\n\\t\\n\\treturn  maxSale\\n}",
                "codeTag": "Unknown"
            },
            {
                "id": 39283,
                "title": "java-all-3-solutions-bruteforce-timeout-dp-3ms-divide-conquer-4ms",
                "content": "    public class Solution {\\n        \\n        public int maxProfitBruteForce(int[] prices) {\\n            int max = 0;\\n            for(int i=0; i<prices.length; i++)\\n                for(int j=i+1; j<prices.length; j++)\\n                    max = prices[j]-prices[i] > max ? prices[j]-prices[i] : max;\\n            return max;\\n        }\\n        \\n        public int maxProfitRec(int[] prices, int i, int j) {\\n            if(i==j)\\n                return 0;\\n            int mid = (i+j) / 2;\\n            int leftProfit = maxProfitRec(prices, i, mid);\\n            int rightProfit = maxProfitRec(prices, mid+1, j);\\n            int subMax = Math.max(leftProfit,rightProfit);\\n            \\n            int leftMin = prices[i];\\n            for(int k=i+1; k<=mid; k++)\\n                leftMin = prices[k] < leftMin ? prices[k] : leftMin;\\n            \\n            int rightMax = prices[mid+1];\\n            for(int k=mid+2; k<=j; k++)\\n                rightMax = prices[k] > rightMax ? prices[k] : rightMax;\\n            \\n            int crossMax = Math.max(0,rightMax-leftMin);\\n            \\n            return Math.max(subMax,crossMax);\\n        }\\n        \\n        public int maxProfitDp(int[] prices) {\\n            int buy = prices[0];\\n            int max = 0;\\n            for(int i=1; i<prices.length; i++) {\\n                max = prices[i]-buy > max ? prices[i]-buy : max;\\n                if(prices[i]<buy)\\n                    buy = prices[i];\\n            }\\n            return max;\\n        }\\n        \\n        public int maxProfit(int[] prices) {\\n            if(prices.length==0)\\n                return 0;\\n            // return maxProfitBruteForce(prices);\\n            // return maxProfitRec(prices,0,prices.length-1);\\n            return maxProfitDp(prices);   \\n        }\\n        \\n    }",
                "solutionTags": [],
                "code": "class Solution {\\n        \\n        public int maxProfitBruteForce(int[] prices) {\\n            int max = 0;\\n            for(int i=0; i<prices.length; i++)\\n                for(int j=i+1; j<prices.length; j++)\\n                    max = prices[j]-prices[i] > max ? prices[j]-prices[i] : max;\\n            return max;\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 39294,
                "title": "c-o-n-solution-kind-of-greedy",
                "content": "    int maxProfit(vector<int>& prices) {\\n        int size=prices.size();\\n        int profit=0;\\n        int max=0;\\n        for(int i=1;i<size;++i){\\n            profit+=(prices[i]-prices[i-1]);\\n            if(profit>max)\\n               max=profit;\\n            if(profit<0)\\n               profit=0;\\n        }\\n        return max;\\n    }",
                "solutionTags": [],
                "code": "    int maxProfit(vector<int>& prices) {\\n        int size=prices.size();\\n        int profit=0;\\n        int max=0;\\n        for(int i=1;i<size;++i){\\n            profit+=(prices[i]-prices[i-1]);\\n            if(profit>max)\\n               max=profit;\\n            if(profit<0)\\n               profit=0;\\n        }\\n        return max;\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 39351,
                "title": "easy-solution-in-c-o-n-time-complexity-and-o-1-space-complexity",
                "content": "    int maxProfit(int price[], int n)\\n    {\\n        int ret = 0, past = 0;\\n        for(int i = 1; i < n; i++)\\n        {\\n    \\t    ret += price[i] - price[i-1];\\n    \\t    if(ret < 0) ret = 0;\\n    \\t    if(ret > past) past = ret;\\n        }\\n        return past;\\n    }",
                "solutionTags": [],
                "code": "    int maxProfit(int price[], int n)\\n    {\\n        int ret = 0, past = 0;\\n        for(int i = 1; i < n; i++)\\n        {\\n    \\t    ret += price[i] - price[i-1];\\n    \\t    if(ret < 0) ret = 0;\\n    \\t    if(ret > past) past = ret;\\n        }\\n        return past;\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 39367,
                "title": "short-python-solution-o-n-runtime-o-1-space",
                "content": "The question is simple. You want to find the difference of the maximum and the minimum. The only trick is that the bigger number should come after the smaller number.\\n\\nSo, here is how I tackled it. Instead of going forward, I scanned through the list of prices backward to store the current maximum number. Update the biggest difference along the way.\\n\\n\\n    class Solution:\\n        # @param prices, a list of integer\\n        # @return an integer\\n        def maxProfit(self, prices):\\n            length = len(prices)\\n            if length==0:\\n                return 0\\n            temp = prices[length-1]\\n            res = 0\\n            for i in range(length-1,-1,-1):\\n                temp = max(temp,prices[i])\\n                if temp - prices[i] > res:\\n                    res = temp - prices[i]\\n            return res",
                "solutionTags": [
                    "Python"
                ],
                "code": "The question is simple. You want to find the difference of the maximum and the minimum. The only trick is that the bigger number should come after the smaller number.\\n\\nSo, here is how I tackled it. Instead of going forward, I scanned through the list of prices backward to store the current maximum number. Update the biggest difference along the way.\\n\\n\\n    class Solution:\\n        # @param prices, a list of integer\\n        # @return an integer\\n        def maxProfit(self, prices):\\n            length = len(prices)\\n            if length==0:\\n                return 0\\n            temp = prices[length-1]\\n            res = 0\\n            for i in range(length-1,-1,-1):\\n                temp = max(temp,prices[i])\\n                if temp - prices[i] > res:\\n                    res = temp - prices[i]\\n            return res",
                "codeTag": "Java"
            },
            {
                "id": 4062083,
                "title": "video-visualization-and-intuitive-proof-of-o-n-solution",
                "content": "https://youtube.com/watch?v=ioFPBdChabY\\n\\nA brute force approach would calculate every possible buy-sell combination and would run in O(n^2), but we can reduce this to O(n) by avoiding unncessary computations.  The strategy below iterates once for every sell date, and handles two cases:\\n1. If buy price < sell price, calculate the profit and compare it to the max profit so far.  If it is greater than the max profit, replace it.  Also, there is no need to go back and calculate profits using this <i>sell</i> date as a buy date, since we can always achieve a higher profit from using the original buy date (which is at a lower price).\\n2. If sell price <= buy date, simply update the buy date to be the current sell date, since we have found a lower price to buy from.\\n\\nAt the end, return `profit`, which will contain the maximum profit achievable.\\n\\n# Code\\n```\\nclass Solution(object):\\n    def maxProfit(self, prices):\\n        profit = 0\\n        buy = prices[0]\\n        for sell in prices[1:]:\\n            if sell > buy:\\n                profit = max(profit, sell - buy)\\n            else:\\n                buy = sell\\n        \\n        return profit\\n```",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Array",
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution(object):\\n    def maxProfit(self, prices):\\n        profit = 0\\n        buy = prices[0]\\n        for sell in prices[1:]:\\n            if sell > buy:\\n                profit = max(profit, sell - buy)\\n            else:\\n                buy = sell\\n        \\n        return profit\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3697960,
                "title": "java-striver-easy-approach",
                "content": "##### Optimal Approach \\nTime Complexity : O(N)\\nSpace Complexity: O(1)\\n```\\nclass Solution {\\n\\n    public int maxProfit(int[] prices) {\\n        int maxProfit = 0;\\n        int minPrice = prices[0];\\n\\n        for (int i = 0; i < prices.length; i++) {\\n            minPrice = Math.min(prices[i], minPrice);\\n            int profit = prices[i] - minPrice;\\n            maxProfit = Math.max(maxProfit, profit);\\n        }\\n        return maxProfit;\\n    }\\n}\\n\\n```\\n![image](https://assets.leetcode.com/users/images/4adf4688-89b6-40bf-9298-fe5bcd52ba3d_1688563501.1123872.jpeg)\\n",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n\\n    public int maxProfit(int[] prices) {\\n        int maxProfit = 0;\\n        int minPrice = prices[0];\\n\\n        for (int i = 0; i < prices.length; i++) {\\n            minPrice = Math.min(prices[i], minPrice);\\n            int profit = prices[i] - minPrice;\\n            maxProfit = Math.max(maxProfit, profit);\\n        }\\n        return maxProfit;\\n    }\\n}\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3333942,
                "title": "javascript-99-99-beats",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<O(n)>\\n\\n- Space complexity:\\n<O(1)>\\n\\n# Code\\n```\\n/**\\n * @param {number[]} prices\\n * @return {number}\\n */\\nvar maxProfit = function(prices) {\\n    let maxProfit = 0;\\n    let minPrice = prices[0];\\n    for (let i = 1; i < prices.length; i++) {\\n        const currentPrice = prices[i];\\n        const currentProfit = currentPrice - minPrice;\\n        if (currentProfit > maxProfit) {\\n            maxProfit = currentProfit;\\n        }\\n        if (currentPrice < minPrice) {\\n            minPrice = currentPrice;\\n        }\\n    }\\n    return maxProfit;\\n};\\n\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {number[]} prices\\n * @return {number}\\n */\\nvar maxProfit = function(prices) {\\n    let maxProfit = 0;\\n    let minPrice = prices[0];\\n    for (let i = 1; i < prices.length; i++) {\\n        const currentPrice = prices[i];\\n        const currentProfit = currentPrice - minPrice;\\n        if (currentProfit > maxProfit) {\\n            maxProfit = currentProfit;\\n        }\\n        if (currentPrice < minPrice) {\\n            minPrice = currentPrice;\\n        }\\n    }\\n    return maxProfit;\\n};\\n\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3272237,
                "title": "fast-5-lines-code-in-java-c",
                "content": "\\n# Algorithm\\n- keep min. value as first element of array\\n- Just travesrse left to right of array\\n  - Change value of min. only when you get a number smaller than it\\n  - Change value of profit only when you get a number greater than it\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n<!-- # Approach -->\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity: $$O(n)$$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n<!-- - Space complexity: -->\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```C []\\nint maxProfit(int* prices, int pricesSize){\\n    int profit = 0, min = prices[0], temp;\\n    for(int i=1; i<pricesSize; i++){\\n        if(prices[i]<min) min = prices[i];\\n        temp = prices[i] - min;\\n        if(temp > profit) profit = temp;\\n    }\\n    return profit;\\n}\\n```\\n```JAVA []\\nclass Solution {\\npublic int maxProfit(int[] prices) {\\n    int profit = 0, min = prices[0], temp;\\n    for(int i=1; i<prices.length; i++){\\n        if(prices[i]<min) min = prices[i];\\n        temp = prices[i] - min;\\n        if(temp > profit) profit = temp;\\n    }\\n    return profit;\\n}\\n}\\n```\\n>>> ## Upvote\\uD83D\\uDC4D if you find helpful\\n",
                "solutionTags": [
                    "Java",
                    "C",
                    "Array",
                    "Dynamic Programming"
                ],
                "code": "```C []\\nint maxProfit(int* prices, int pricesSize){\\n    int profit = 0, min = prices[0], temp;\\n    for(int i=1; i<pricesSize; i++){\\n        if(prices[i]<min) min = prices[i];\\n        temp = prices[i] - min;\\n        if(temp > profit) profit = temp;\\n    }\\n    return profit;\\n}\\n```\n```JAVA []\\nclass Solution {\\npublic int maxProfit(int[] prices) {\\n    int profit = 0, min = prices[0], temp;\\n    for(int i=1; i<prices.length; i++){\\n        if(prices[i]<min) min = prices[i];\\n        temp = prices[i] - min;\\n        if(temp > profit) profit = temp;\\n    }\\n    return profit;\\n}\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3236117,
                "title": "easy-to-understand-solution-two-pointer-method",
                "content": "# Intuition\\nTo use **2-pointer** method to solve the stock buy sell problem.\\n\\n# Approach\\nwe take two variables **l** and **r** that we given the 0th and 1st index.\\nwe traverse the while loop till the array length.\\nwhen we get the price of **right index greater than the left index** we find out the profit.\\nthen we check if the profit it greater than maxp then we switch them by using **Math.max** fucntion.\\n\\nif the right index value is not greater than the left index value than we appoint left as right, (l = r).\\n\\nthen we increment the value of right pointer(r++) and the while loop goes on till the end.\\n\\nat the end of while loop we can get the value of maximum profit.\\n# Solution\\n\\n```\\nclass Solution {\\n    public int maxProfit(int[] prices) {\\n\\t\\tint l = 0 , r = 1;\\n        int maxp = 0;\\n        int profit = 0;\\n        while (r < prices.length){\\n            if(prices[l] < prices[r]){\\n                profit = prices[r] - prices[l];\\n                maxp = Math.max(maxp,profit);\\n            }\\n            else{\\n                l = r;\\n            }\\n            r++;\\n        }\\n        return maxp;\\n    }\\n}\\n```\\n\\n# Time and Space Complexity\\n\\n**Time Complexity** : O(n)\\nAs we are moving in a linear motion in the array.\\n\\n**Space Complexity** : O(1)\\nAs we didn\\'t use any extra memory such as an extra array , so the space complexity is O(1)\\n",
                "solutionTags": [
                    "Java",
                    "Two Pointers"
                ],
                "code": "```\\nclass Solution {\\n    public int maxProfit(int[] prices) {\\n\\t\\tint l = 0 , r = 1;\\n        int maxp = 0;\\n        int profit = 0;\\n        while (r < prices.length){\\n            if(prices[l] < prices[r]){\\n                profit = prices[r] - prices[l];\\n                maxp = Math.max(maxp,profit);\\n            }\\n            else{\\n                l = r;\\n            }\\n            r++;\\n        }\\n        return maxp;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2772159,
                "title": "c-solutions",
                "content": "```\\nclass Solution {\\npublic:\\n    int maxProfit(vector<int>& prices) {\\n        int profit=0;\\n        int minelem=prices[0];\\n        for(int i=1;i<prices.size();i++){\\n           minelem=min(prices[i],minelem);\\n            profit=max(profit,(prices[i]-minelem));\\n        }\\n        return profit;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int maxProfit(vector<int>& prices) {\\n        int profit=0;\\n        int minelem=prices[0];\\n        for(int i=1;i<prices.size();i++){\\n           minelem=min(prices[i],minelem);\\n            profit=max(profit,(prices[i]-minelem));\\n        }\\n        return profit;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2296118,
                "title": "java-easy-solution-100-fast-explanation",
                "content": "```\\n*) The Idea of solution is very simple.\\n*) Just know the minimum element on left side w.r.to current array[i].\\n*) And then update the profit at current array[i](i.e by array[i] - minimum if and only if it is greater than profit).\\n*) Return profit.\\n\\nclass Solution {\\n    public int maxProfit(int[] prices) {\\n        int min = Integer.MAX_VALUE;\\n        int profit = 0;\\n        for(int i=0; i < prices.length; i++){\\n            min = Math.min(min, prices[i]);\\n            profit = Math.max(prices[i] - min, profit);\\n        }\\n        return profit;\\n    }\\n}\\n\\nPlease do upvote, If you find it useful .  :-)\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\n*) The Idea of solution is very simple.\\n*) Just know the minimum element on left side w.r.to current array[i].\\n*) And then update the profit at current array[i](i.e by array[i] - minimum if and only if it is greater than profit).\\n*) Return profit.\\n\\nclass Solution {\\n    public int maxProfit(int[] prices) {\\n        int min = Integer.MAX_VALUE;\\n        int profit = 0;\\n        for(int i=0; i < prices.length; i++){\\n            min = Math.min(min, prices[i]);\\n            profit = Math.max(prices[i] - min, profit);\\n        }\\n        return profit;\\n    }\\n}\\n\\nPlease do upvote, If you find it useful .  :-)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2178784,
                "title": "c-solution-simple-brute-force-solution-tc-o-n-2",
                "content": "```\\n// Brute Force Solution\\n\\nclass Solution {\\npublic:\\n    int maxProfit(vector<int>& prices) {\\n        int profit = 0;\\n\\n        for(int i=0;i<prices.size();i++){\\n            for(int j=i+1;j<prices.size();j++){\\n                if(prices[j] > prices[i] && prices[j]-prices[i] > profit){\\n                    profit = (prices[j]-prices[i]);\\n                }\\n            }\\n        }\\n        return profit;\\n    }\\n};\\n```\\n\\n**Please upvote if you find the solution useful, means a lot.**\\n",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\n// Brute Force Solution\\n\\nclass Solution {\\npublic:\\n    int maxProfit(vector<int>& prices) {\\n        int profit = 0;\\n\\n        for(int i=0;i<prices.size();i++){\\n            for(int j=i+1;j<prices.size();j++){\\n                if(prices[j] > prices[i] && prices[j]-prices[i] > profit){\\n                    profit = (prices[j]-prices[i]);\\n                }\\n            }\\n        }\\n        return profit;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1995994,
                "title": "python-solution-95-easy",
                "content": "```\\nclass Solution:\\n    def maxProfit(self, prices: List[int]) -> int:\\n        import math\\n        min_price = math.inf\\n        max_profit = 0\\n        for index in range(len(prices)):\\n            if prices[index] < min_price:\\n                min_price = prices[index]\\n            elif prices[index] - min_price > max_profit:\\n                max_profit = prices[index] - min_price\\n        return max_profit\\n",
                "solutionTags": [
                    "Python",
                    "Array",
                    "Two Pointers"
                ],
                "code": "```\\nclass Solution:\\n    def maxProfit(self, prices: List[int]) -> int:\\n        import math\\n        min_price = math.inf\\n        max_profit = 0\\n        for index in range(len(prices)):\\n            if prices[index] < min_price:\\n                min_price = prices[index]\\n            elif prices[index] - min_price > max_profit:\\n                max_profit = prices[index] - min_price\\n        return max_profit\\n",
                "codeTag": "Java"
            },
            {
                "id": 1517927,
                "title": "1-line-javascript-solution",
                "content": "```\\nfunction maxProfit(prices) { \\n    let max = 0, min = Infinity;\\n    prices.forEach(price => price < min ? min = price : max = Math.max(max, price - min));\\n    return max;\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\nfunction maxProfit(prices) { \\n    let max = 0, min = Infinity;\\n    prices.forEach(price => price < min ? min = price : max = Math.max(max, price - min));\\n    return max;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1153262,
                "title": "o-n-time-complexity-o-1-space-complexity-easy-approach",
                "content": "```\\nclass Solution {\\npublic:\\n    int maxProfit(vector<int>& prices) {\\n        int n = prices.size();\\n        int profit = 0, mini = INT_MAX;\\n        for(int i = 0; i < n; i++)\\n        {\\n            mini = min(mini, prices[i]);\\n            if(mini < prices[i])\\n                profit = max(profit, (prices[i] - mini));\\n        }\\n        return profit;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int maxProfit(vector<int>& prices) {\\n        int n = prices.size();\\n        int profit = 0, mini = INT_MAX;\\n        for(int i = 0; i < n; i++)\\n        {\\n            mini = min(mini, prices[i]);\\n            if(mini < prices[i])\\n                profit = max(profit, (prices[i] - mini));\\n        }\\n        return profit;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 414863,
                "title": "javascript-solution",
                "content": "```\\n/**\\n * @param {number[]} prices\\n * @return {number}\\n */\\nvar maxProfit = function(prices) {\\n    let max = 0;\\n    let min = Infinity;\\n    for(let i = 0; i < prices.length; i++) {\\n        min = Math.min(min, prices[i]);\\n        max = Math.max(max, prices[i] - min);\\n    }    \\n    \\n    return max;\\n};",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {number[]} prices\\n * @return {number}\\n */\\nvar maxProfit = function(prices) {\\n    let max = 0;\\n    let min = Infinity;\\n    for(let i = 0; i < prices.length; i++) {\\n        min = Math.min(min, prices[i]);\\n        max = Math.max(max, prices[i] - min);\\n    }    \\n    \\n    return max;\\n};",
                "codeTag": "Unknown"
            },
            {
                "id": 286814,
                "title": "c-dp",
                "content": "```\\npublic class Solution {\\n    public int MaxProfit(int[] prices) {\\n        var n = prices.Length;\\n        if (n == 0) return 0;\\n        var globalMaxProfit = 0;\\n        var globalMin = prices[0];\\n        for (int i = 1; i < n; i++) {\\n            var curPrice = prices[i];\\n            var localMaxProfit = Math.Max(0, curPrice - globalMin);\\n            globalMaxProfit = Math.Max(localMaxProfit, globalMaxProfit);\\n            globalMin = Math.Min(globalMin, curPrice);\\n        }\\n\\n        return globalMaxProfit;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\npublic class Solution {\\n    public int MaxProfit(int[] prices) {\\n        var n = prices.Length;\\n        if (n == 0) return 0;\\n        var globalMaxProfit = 0;\\n        var globalMin = prices[0];\\n        for (int i = 1; i < n; i++) {\\n            var curPrice = prices[i];\\n            var localMaxProfit = Math.Max(0, curPrice - globalMin);\\n            globalMaxProfit = Math.Max(localMaxProfit, globalMaxProfit);\\n            globalMin = Math.Min(globalMin, curPrice);\\n        }\\n\\n        return globalMaxProfit;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 154770,
                "title": "go-dp-bottom-up-single-loop-beats-100-with-explanation",
                "content": "Key observation: prices[2] - prices[0] = prices[2] - prices[1] + prices[1] - prices[0]\\n```\\nfunc maxProfit(prices []int) int {\\n    tmp := 0\\n    max := 0\\n    for i := 1; i < len(prices); i++ {\\n        tmp += prices[i] - prices[i-1]\\n        if tmp < 0 {\\n            tmp = 0\\n        }\\n        if tmp > max {\\n            max = tmp\\n        }\\n    }\\n    return max\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nfunc maxProfit(prices []int) int {\\n    tmp := 0\\n    max := 0\\n    for i := 1; i < len(prices); i++ {\\n        tmp += prices[i] - prices[i-1]\\n        if tmp < 0 {\\n            tmp = 0\\n        }\\n        if tmp > max {\\n            max = tmp\\n        }\\n    }\\n    return max\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 39064,
                "title": "dynamic-programming-explanation",
                "content": "```\\nclass Solution {\\n    //Dynamic programming. Using OPT[i] refers to the max profit we can get from first i days.\\n    /*OPT[i] = OPT[i-1] do nothing in day i or buy ticket in day i.\\n      OPT[i] = price[i] - smallest_value_from_first_i-1_days.\\n    */\\n    public int maxProfit(int[] prices) {\\n        //one exception: no day\\n        if(prices.length == 0)  return 0;\\n        int[] OPT = new int[prices.length];\\n        int smallest = prices[0];\\n        for(int i = 1; i < prices.length; i++){\\n            OPT[i] = Math.max(OPT[i-1], prices[i]-smallest);\\n            smallest = Math.min(smallest, prices[i]);\\n        }\\n        return OPT[OPT.length-1];\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    //Dynamic programming. Using OPT[i] refers to the max profit we can get from first i days.\\n    /*OPT[i] = OPT[i-1] do nothing in day i or buy ticket in day i.\\n      OPT[i] = price[i] - smallest_value_from_first_i-1_days.\\n    */\\n    public int maxProfit(int[] prices) {\\n        //one exception: no day\\n        if(prices.length == 0)  return 0;\\n        int[] OPT = new int[prices.length];\\n        int smallest = prices[0];\\n        for(int i = 1; i < prices.length; i++){\\n            OPT[i] = Math.max(OPT[i-1], prices[i]-smallest);\\n            smallest = Math.min(smallest, prices[i]);\\n        }\\n        return OPT[OPT.length-1];\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 39250,
                "title": "clearly-simple-java-solution",
                "content": "public class Solution {\\n    public int maxProfit(int[] prices) {\\n        \\n        if(prices==null || prices.length==0)\\n            return 0;\\n        \\n        int buyPrice = prices[0];\\n        int max = 0;\\n        \\n        int len = prices.length;\\n        for(int i=0;i<len;i++){\\n            \\n            if(prices[i]<buyPrice)\\n                buyPrice = prices[i];\\n            else{\\n                int newProfit = prices[i]-buyPrice ;\\n                max = ( newProfit>max ? newProfit : max);\\n            }\\n        }\\n        \\n        return max;\\n    }\\n}",
                "solutionTags": [],
                "code": "class Solution {\\n    public int maxProfit(int[] prices) {\\n        \\n        if(prices==null || prices.length==0)\\n            return 0;\\n        \\n        int buyPrice = prices[0];\\n        int max = 0;\\n        \\n        int len = prices.length;\\n        for(int i=0;i<len;i++){\\n            \\n            if(prices[i]<buyPrice)\\n                buyPrice = prices[i];\\n            else{\\n                int newProfit = prices[i]-buyPrice ;\\n                max = ( newProfit>max ? newProfit : max);\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 39153,
                "title": "simplest-dp-solution-in-java",
                "content": "public class Solution {\\n\\n    public int maxProfit(int[] prices) {\\n\\n        int min = Integer.MAX_VALUE;\\n        int max = 0;\\n\\n        for(int p:prices) {\\n            min = Math.min(min, p);\\n            max = Math.max(p-min, max);\\n        }\\n\\n        return max;\\n    }\\n}",
                "solutionTags": [
                    "Java",
                    "Dynamic Programming"
                ],
                "code": "class Solution {\\n\\n    public int maxProfit(int[] prices) {\\n\\n        int min = Integer.MAX_VALUE;\\n        int max = 0;\\n\\n        for(int p:prices) {\\n            min = Math.min(min, p);\\n            max = Math.max(p-min, max);\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 3818335,
                "title": "explained-c-easy-and-clean-code-dp",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n- We\\'ll chose minimum element from array for buying\\n- And max element from array after the minimum element\\n- and calculate the maximum possible profit\\n- Res will be the answer\\n\\n# Complexity\\n- Time complexity: O(n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int maxProfit(vector<int>& prices) {\\n        int result=0, minVal = INT_MAX;\\n        int soldToday = -1;\\n        for(int price: prices){\\n            minVal = min(price, minVal);\\n            soldToday = price-minVal;\\n            result = max(result, soldToday);\\n        }     \\n        return result;\\n    }\\n\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Array",
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int maxProfit(vector<int>& prices) {\\n        int result=0, minVal = INT_MAX;\\n        int soldToday = -1;\\n        for(int price: prices){\\n            minVal = min(price, minVal);\\n            soldToday = price-minVal;\\n            result = max(result, soldToday);\\n        }     \\n        return result;\\n    }\\n\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3538972,
                "title": "c-easy-solution-additional-variables-simple-conditions",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity: O(n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: const;\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int maxProfit(vector<int>& prices) {\\n        if (prices.size() == 0) return 0;\\n        int max, min, i, temp_min, temp_max;\\n        for (i = 0, min = max = temp_max = temp_min = prices[0]; i < prices.size(); i++) {\\n            if (temp_min > prices[i]) temp_min = temp_max = prices[i];\\n            if (temp_max <= prices[i] && prices[i] >  temp_min) temp_max = prices[i];\\n            if (temp_max - temp_min > max - min) {\\n                max = temp_max;\\n                min = temp_min;\\n            }\\n        }\\n        return max - min;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int maxProfit(vector<int>& prices) {\\n        if (prices.size() == 0) return 0;\\n        int max, min, i, temp_min, temp_max;\\n        for (i = 0, min = max = temp_max = temp_min = prices[0]; i < prices.size(); i++) {\\n            if (temp_min > prices[i]) temp_min = temp_max = prices[i];\\n            if (temp_max <= prices[i] && prices[i] >  temp_min) temp_max = prices[i];\\n            if (temp_max - temp_min > max - min) {\\n                max = temp_max;\\n                min = temp_min;\\n            }\\n        }\\n        return max - min;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3411647,
                "title": "easiest-apporach-to-understand-c",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nIt is  a common algorithm for solving the problem of finding the maximum profit that can be made from buying and selling a stock represented by a vector of prices.\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nThe function initializes a variable i to 0, representing the current index in the vector. It then **initializes a variable min** to the first element in the vector, representing the minimum price seen so far. It also initializes a variable profit to 0, representing the maximum profit seen so far.\\n\\nThe function then enters a loop that iterates through the remaining elements in the vector. For each element, the function **checks if it is greater than the current minimum price (min)**. If it is, **then the function calculates the profit that could be made by selling at this price and updates the profit variable if the calculated profit is greater than the current maximum**. If the element is less than the current minimum, then the function **updates the min variable** to this element, representing a new minimum price seen so far.\\n\\nAfter iterating through all the elements, the function returns the maximum profit seen during the iteration.\\n\\n# Complexity\\n- Time complexity: O(n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int maxProfit(vector<int>& prices) {\\n        int min = prices[0];\\n        int profit = 0;\\n        for(int i=1;i<prices.size();i++){\\n\\n        //checks and upadtes the profit if price less than min\\n\\n            if(prices[i]>min){\\n               profit = max(profit,prices[i]-min);\\n            }\\n            else if (prices[i]<min){\\n                min = prices[i];\\n            }\\n        }\\n        return profit;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int maxProfit(vector<int>& prices) {\\n        int min = prices[0];\\n        int profit = 0;\\n        for(int i=1;i<prices.size();i++){\\n\\n        //checks and upadtes the profit if price less than min\\n\\n            if(prices[i]>min){\\n               profit = max(profit,prices[i]-min);\\n            }\\n            else if (prices[i]<min){\\n                min = prices[i];\\n            }\\n        }\\n        return profit;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3228818,
                "title": "superb-logic-question-three-approaches",
                "content": "# Easy approach\\n```\\nclass Solution:\\n    def maxProfit(self, prices: List[int]) -> int:\\n        ans,buy=0,prices[0]\\n        for cost in prices[1:]:\\n            if cost<buy:\\n                buy=cost\\n            ans=max(ans,cost-buy)\\n        return ans\\n```\\n# Simple Approches:\\n```\\nclass Solution:\\n    def maxProfit(self, arr: List[int]) -> int:\\n        buy=arr[0]\\n        sell=0\\n        n=len(arr)\\n        profit=0\\n        for i in range(1,n):\\n            if arr[i]<buy:\\n                buy=arr[i]\\n            if arr[i]>buy:\\n                sell=arr[i]\\n                profit=max(profit,sell-buy)\\n        return profit\\n```\\n# Two Pointers Approches\\n```\\nclass Solution:\\n    def maxProfit(self,prices):\\n        left,right,maxprofit=0,1,0\\n        while right<len(prices):\\n            if prices[left]<prices[right]:\\n                currentprofit=prices[right]-prices[left]\\n                maxprofit=max(currentprofit,maxprofit)\\n            else:\\n                left=right\\n            right+=1\\n        return maxprofit\\n    \\n```\\n# please upvote me it would encourage me alot\\n",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution:\\n    def maxProfit(self, prices: List[int]) -> int:\\n        ans,buy=0,prices[0]\\n        for cost in prices[1:]:\\n            if cost<buy:\\n                buy=cost\\n            ans=max(ans,cost-buy)\\n        return ans\\n```\n```\\nclass Solution:\\n    def maxProfit(self, arr: List[int]) -> int:\\n        buy=arr[0]\\n        sell=0\\n        n=len(arr)\\n        profit=0\\n        for i in range(1,n):\\n            if arr[i]<buy:\\n                buy=arr[i]\\n            if arr[i]>buy:\\n                sell=arr[i]\\n                profit=max(profit,sell-buy)\\n        return profit\\n```\n```\\nclass Solution:\\n    def maxProfit(self,prices):\\n        left,right,maxprofit=0,1,0\\n        while right<len(prices):\\n            if prices[left]<prices[right]:\\n                currentprofit=prices[right]-prices[left]\\n                maxprofit=max(currentprofit,maxprofit)\\n            else:\\n                left=right\\n            right+=1\\n        return maxprofit\\n    \\n```",
                "codeTag": "Java"
            },
            {
                "id": 3195802,
                "title": "beats-93-69-with-step-by-step-explanation",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\nThe basic idea is to loop through each price in the list and keep track of the minimum price seen so far and the maximum profit that can be made by selling the stock at that price. If the current price is less than the minimum price so far, update the minimum price. If the difference between the current price and the minimum price is greater than the maximum profit so far, update the maximum profit. Finally, return the maximum profit.\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def maxProfit(self, prices: List[int]) -> int:\\n        min_price = float(\\'inf\\') # initialize minimum price to positive infinity\\n        max_profit = 0 # initialize maximum profit to zero\\n        \\n        for price in prices: # loop through each price in the list\\n            if price < min_price: # if price is less than minimum price so far\\n                min_price = price # update minimum price\\n            elif price - min_price > max_profit: # if selling price - buying price is greater than max profit so far\\n                max_profit = price - min_price # update max profit\\n        \\n        return max_profit # return the maximum profit\\n\\n```",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Array",
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution:\\n    def maxProfit(self, prices: List[int]) -> int:\\n        min_price = float(\\'inf\\') # initialize minimum price to positive infinity\\n        max_profit = 0 # initialize maximum profit to zero\\n        \\n        for price in prices: # loop through each price in the list\\n            if price < min_price: # if price is less than minimum price so far\\n                min_price = price # update minimum price\\n            elif price - min_price > max_profit: # if selling price - buying price is greater than max profit so far\\n                max_profit = price - min_price # update max profit\\n        \\n        return max_profit # return the maximum profit\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3188772,
                "title": "python3-easy-explanation-91-fast",
                "content": "![Capture.PNG](https://assets.leetcode.com/users/images/447d8e46-9cae-4879-bc1a-bc5a90db7f65_1676458994.5410964.png)\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n- buy when lowest price found.\\n- if next is not lower price try to sell but here we\\'ew keeping track of last lowest so everytime high price comes we will compare it to lowest.\\n- if next low value comes sell it and keep track of old max profit.\\n- do till all daysa are covered.\\n- return found profit.\\n\\n# Complexity\\n- Time complexity: O(N)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def maxProfit(self, prices: List[int]) -> int:\\n        profit = 0\\n        low = float(\"inf\")\\n        for i in prices:\\n            if low > i:\\n                low = i\\n            elif i - low > profit:\\n                profit = i - low\\n        return profit\\n```\\n# Please like and comment below :-)",
                "solutionTags": [
                    "Python3",
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution:\\n    def maxProfit(self, prices: List[int]) -> int:\\n        profit = 0\\n        low = float(\"inf\")\\n        for i in prices:\\n            if low > i:\\n                low = i\\n            elif i - low > profit:\\n                profit = i - low\\n        return profit\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3088782,
                "title": "c-easy-to-understand",
                "content": "```\\nclass Solution {\\npublic:\\n    int maxProfit(vector<int>& prices) {\\n        int n = prices.size();\\n        int curr_sell=prices[0];\\n        int profit=0;\\n        for(int i=1;i<n;i++){\\n            profit = max(profit,prices[i]-curr_sell);\\n            curr_sell = min(curr_sell,prices[i]);\\n        }\\n        return profit;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int maxProfit(vector<int>& prices) {\\n        int n = prices.size();\\n        int curr_sell=prices[0];\\n        int profit=0;\\n        for(int i=1;i<n;i++){\\n            profit = max(profit,prices[i]-curr_sell);\\n            curr_sell = min(curr_sell,prices[i]);\\n        }\\n        return profit;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2718970,
                "title": "python-c-java-faster-than-100-short-simple-solution-beginnerlevel",
                "content": "***Please upvote to motivate me in my quest of documenting all leetcode solutions. HAPPY CODING:)\\nAny suggestions and improvements are always welcome*.**\\n___________________\\n_________________\\n***Q121. Best Time to Buy and Sell Stock***\\n____________________________________________________________________________________________________________________\\n____________________________________________________________________________________________________________________\\n\\u2705 **Python  Code** :\\n```\\nclass Solution:\\n    def maxProfit(self, prices: List[int]) -> int:\\n        l, r = 0, 1\\n        maxp = 0\\n        while r < len(prices):\\n            if prices[l] < prices[r]:\\n                profit = prices[r] - prices[l]\\n                maxp = max(maxp, profit)\\n            else:\\n                l = r\\n            r += 1\\n        return maxp\\n```\\n____________________________________________________________________________________________________________________\\n____________________________________________________________________________________________________________________\\n\\n\\u2705 **Java Code** :\\n```\\nclass Solution {\\n    public int maxProfit(int[] prices) {\\n        if(prices.length==0)\\n            return 0;\\n    int n = prices.size();\\n        int profit = 0, pointer = prices[0];\\n        \\n        for(int i = 1; i < n; i++) {\\n            if(prices[i] < pointer) pointer = prices[i];\\n            \\n            else profit = max(profit, prices[i] - pointer);\\n        }\\n        \\n        return profit;\\n}\\n}\\n```\\n\\n____________________________________________________________________________________________________________________\\n____________________________________________________________________________________________________________________\\n\\u2705 **C++  Code** :\\n```\\nclass Solution {\\npublic:\\n    int maxProfit(vector<int>& prices) {\\n        int n = prices.size();\\n        int profit = 0, pointer = prices[0];\\n        \\n        for(int i = 1; i < n; i++) {\\n            if(prices[i] < pointer) pointer = prices[i];\\n            \\n            else profit = max(profit, prices[i] - pointer);\\n        }\\n        \\n        return profit;\\n    }\\n};\\n```\\n____________________________________________________________________________________________________________________\\n____________________________________________________________________________________________________________________\\nIf you like the solution, please upvote \\uD83D\\uDD3C\\nFor any questions, or discussions, comment below. \\uD83D\\uDC47\\uFE0F\\n",
                "solutionTags": [
                    "Java",
                    "Python",
                    "C"
                ],
                "code": "```\\nclass Solution:\\n    def maxProfit(self, prices: List[int]) -> int:\\n        l, r = 0, 1\\n        maxp = 0\\n        while r < len(prices):\\n            if prices[l] < prices[r]:\\n                profit = prices[r] - prices[l]\\n                maxp = max(maxp, profit)\\n            else:\\n                l = r\\n            r += 1\\n        return maxp\\n```\n```\\nclass Solution {\\n    public int maxProfit(int[] prices) {\\n        if(prices.length==0)\\n            return 0;\\n    int n = prices.size();\\n        int profit = 0, pointer = prices[0];\\n        \\n        for(int i = 1; i < n; i++) {\\n            if(prices[i] < pointer) pointer = prices[i];\\n            \\n            else profit = max(profit, prices[i] - pointer);\\n        }\\n        \\n        return profit;\\n}\\n}\\n```\n```\\nclass Solution {\\npublic:\\n    int maxProfit(vector<int>& prices) {\\n        int n = prices.size();\\n        int profit = 0, pointer = prices[0];\\n        \\n        for(int i = 1; i < n; i++) {\\n            if(prices[i] < pointer) pointer = prices[i];\\n            \\n            else profit = max(profit, prices[i] - pointer);\\n        }\\n        \\n        return profit;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2715902,
                "title": "121-best-time-to-buy-and-sell-stock-js",
                "content": "```\\nRuntime: 92 ms, faster than 91.28% of JavaScript online submissions for Best Time to Buy and Sell Stock.\\nMemory Usage: 51.7 MB, less than 66.52% of JavaScript online submissions for Best Time to Buy and Sell Stock.\\n\\n// We need to have two vars profit and difference.\\n// By Looping through the loop starting from the\\n// 1th element in prices array we substract the 0th element from the 1th\\n// element and save the difference in the difference var, after this we get the biggest \\n// number between profit and difference, to get the day with highest profit.\\n\\nconst maxProfit = (prices) => {\\n    let profit = 0;\\n    let left = 0;\\n    for(let right = 1 ; right< prices.length ; right++){\\n        if(prices[left]<prices[right]){\\n            let difference = prices[right] - prices[left];\\n            profit = Math.max(profit, difference);\\n        }\\n        else{\\n            left = right;\\n        }\\n    }\\n    return profit ?? 0;\\n};\\n",
                "solutionTags": [
                    "Array"
                ],
                "code": "```\\nRuntime: 92 ms, faster than 91.28% of JavaScript online submissions for Best Time to Buy and Sell Stock.\\nMemory Usage: 51.7 MB, less than 66.52% of JavaScript online submissions for Best Time to Buy and Sell Stock.\\n\\n// We need to have two vars profit and difference.\\n// By Looping through the loop starting from the\\n// 1th element in prices array we substract the 0th element from the 1th\\n// element and save the difference in the difference var, after this we get the biggest \\n// number between profit and difference, to get the day with highest profit.\\n\\nconst maxProfit = (prices) => {\\n    let profit = 0;\\n    let left = 0;\\n    for(let right = 1 ; right< prices.length ; right++){\\n        if(prices[left]<prices[right]){\\n            let difference = prices[right] - prices[left];\\n            profit = Math.max(profit, difference);\\n        }\\n        else{\\n            left = right;\\n        }\\n    }\\n    return profit ?? 0;\\n};\\n",
                "codeTag": "Unknown"
            },
            {
                "id": 2675038,
                "title": "c-easy-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    int maxProfit(vector<int>& prices) {\\n            int profit = 0;\\n            int min_pr = INT_MAX;\\n            for(int i = 0 ;i<prices.size(); i++){\\n                    int cost = prices[i] - min_pr;\\n                    min_pr = min(min_pr,prices[i]);\\n                    profit = max(profit ,cost);\\n            }\\n            return profit;\\n        \\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Array",
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int maxProfit(vector<int>& prices) {\\n            int profit = 0;\\n            int min_pr = INT_MAX;\\n            for(int i = 0 ;i<prices.size(); i++){\\n                    int cost = prices[i] - min_pr;\\n                    min_pr = min(min_pr,prices[i]);\\n                    profit = max(profit ,cost);\\n            }\\n            return profit;\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2518795,
                "title": "c-o-n-easy-to-understand",
                "content": "```\\nclass Solution {\\npublic:\\n    int maxProfit(vector<int>& prices) {\\n        int mini = prices[0];\\n    int maxProfit  = 0;\\n    int n = prices.size();\\n    for(int i=0;i<n;i++){\\n        int cost =  prices[i] - mini;\\n        maxProfit = max(maxProfit, cost);\\n        mini = min(mini,prices[i]);\\n    }\\n    return maxProfit;\\n    }\\n};\\n```\\n**Don\\'t forget to Upvote the post, if it\\'s been any help to you**",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int maxProfit(vector<int>& prices) {\\n        int mini = prices[0];\\n    int maxProfit  = 0;\\n    int n = prices.size();\\n    for(int i=0;i<n;i++){\\n        int cost =  prices[i] - mini;\\n        maxProfit = max(maxProfit, cost);\\n        mini = min(mini,prices[i]);\\n    }\\n    return maxProfit;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2198965,
                "title": "java-solution-easy-to-understand-upvote-as-well",
                "content": "***<----Click there to give thumbs up ;)***\\n```\\nclass Solution {\\n    public int maxProfit(int[] prices) {\\n        int length = prices.length;\\n        int minValue = prices[0];\\n        int maxProfit = 0;\\n        \\n        for(int i = 1; i < length; i++){\\n            maxProfit = Math.max(prices[i]-minValue,maxProfit); // Every time check the profit, i.e, current price - previous minimum price\\n            minValue = Math.min(minValue, prices[i]); // If current value is less than the existing minimum value, that means new minimum value will be current value\\n        }\\n        \\n        return maxProfit;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int maxProfit(int[] prices) {\\n        int length = prices.length;\\n        int minValue = prices[0];\\n        int maxProfit = 0;\\n        \\n        for(int i = 1; i < length; i++){\\n            maxProfit = Math.max(prices[i]-minValue,maxProfit); // Every time check the profit, i.e, current price - previous minimum price\\n            minValue = Math.min(minValue, prices[i]); // If current value is less than the existing minimum value, that means new minimum value will be current value\\n        }\\n        \\n        return maxProfit;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1785769,
                "title": "java-clean-code-with-explanation-o-1-space-o-n-time",
                "content": "```\\nclass Solution {\\n    public int maxProfit(int[] prices) {\\n        //keep a minprice variable which denotes the min price uptill that particular day \\n        //profit on that day = cost of the stock on that day - minprice\\n        //if the price of stock on that day < minprice then update minprice\\n        //keep a maxprofit variable and keep updating it as you traverse along the array\\n        \\n        int minprice = prices[0], maxprofit = 0;\\n        for(int day=1; day<prices.length; day++){\\n            int present_day_profit = prices[day] - minprice;\\n            \\n            if(present_day_profit>maxprofit) maxprofit = present_day_profit;\\n            \\n            if(prices[day]<minprice){\\n                minprice = prices[day];\\n            }\\n            \\n        }\\n        return maxprofit;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution {\\n    public int maxProfit(int[] prices) {\\n        //keep a minprice variable which denotes the min price uptill that particular day \\n        //profit on that day = cost of the stock on that day - minprice\\n        //if the price of stock on that day < minprice then update minprice\\n        //keep a maxprofit variable and keep updating it as you traverse along the array\\n        \\n        int minprice = prices[0], maxprofit = 0;\\n        for(int day=1; day<prices.length; day++){\\n            int present_day_profit = prices[day] - minprice;\\n            \\n            if(present_day_profit>maxprofit) maxprofit = present_day_profit;\\n            \\n            if(prices[day]<minprice){\\n                minprice = prices[day];\\n            }\\n            \\n        }\\n        return maxprofit;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1735814,
                "title": "python-3-o-n-simple-solution-explained",
                "content": "```\\nclass Solution:\\n    def maxProfit(self, prices: List[int]) -> int:\\n        # tracking the minimum while traverse\\n        # and maximizing the variable\\n        current_min, max_so_far = float(\\'inf\\'), 0\\n        for price in prices:\\n            current_min = min(current_min,  price)\\n            max_so_far = max(max_so_far, price-current_min)\\n        return max_so_far\\n```\\n\\nSimilar problems can be solved using Kadane\\'s Algorithm (DP)",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def maxProfit(self, prices: List[int]) -> int:\\n        # tracking the minimum while traverse\\n        # and maximizing the variable\\n        current_min, max_so_far = float(\\'inf\\'), 0\\n        for price in prices:\\n            current_min = min(current_min,  price)\\n            max_so_far = max(max_so_far, price-current_min)\\n        return max_so_far\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1694218,
                "title": "easiest-and-compact-approach-o-n-c",
                "content": "```\\n  int maxProfit(vector<int>& prices)\\n    {\\n        int n = prices.size();\\n        \\n        int minVal = prices[0];\\n        int ans = 0;\\n        \\n        for(int i=1;i<n;i++)\\n        {\\n            ans = max(ans,prices[i]-minVal);\\n            \\n            minVal = min(minVal,prices[i]);\\n        }\\n        return ans;\\n        \\n    }\\n```",
                "solutionTags": [],
                "code": "```\\n  int maxProfit(vector<int>& prices)\\n    {\\n        int n = prices.size();\\n        \\n        int minVal = prices[0];\\n        int ans = 0;\\n        \\n        for(int i=1;i<n;i++)\\n        {\\n            ans = max(ans,prices[i]-minVal);\\n            \\n            minVal = min(minVal,prices[i]);\\n        }\\n        return ans;\\n        \\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1514338,
                "title": "simple-and-clear-java-solution-o-n-time-and-o-1-space-best-time-to-buy-and-sell-stock",
                "content": "We just need to find maximum profit, for which we will buy the stock when it is minimum and sell it when it is maximum also we will not sell it on the same day we buy it.\\n```\\npublic int maxProfit(int[] prices) {\\n        int buy = prices[0];\\n        int profit = 0;\\n        for (int i = 1; i < prices.length; i++) {\\n            if (buy > prices[i]) {\\n                buy = prices[i]; // buy when price is minimum\\n            } else if (prices[i] - buy > profit) { \\n                profit = prices[i] - buy; // sell only when we have max profit\\n            }\\n        }\\n        return profit;\\n    }\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\npublic int maxProfit(int[] prices) {\\n        int buy = prices[0];\\n        int profit = 0;\\n        for (int i = 1; i < prices.length; i++) {\\n            if (buy > prices[i]) {\\n                buy = prices[i]; // buy when price is minimum\\n            } else if (prices[i] - buy > profit) { \\n                profit = prices[i] - buy; // sell only when we have max profit\\n            }\\n        }\\n        return profit;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1431436,
                "title": "javascript-js",
                "content": "```\\n/**\\n * @param {number[]} prices\\n * @return {number}\\n */\\nvar maxProfit = function (prices) {\\n  let result = 0;\\n  let lowestPrice = prices[0];\\n\\n  for (let i = 0; i < prices.length; i++) {\\n    lowestPrice = Math.min(prices[i], lowestPrice);\\n    result = Math.max(result, prices[i] - lowestPrice);\\n  }\\n\\n  return result;\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {number[]} prices\\n * @return {number}\\n */\\nvar maxProfit = function (prices) {\\n  let result = 0;\\n  let lowestPrice = prices[0];\\n\\n  for (let i = 0; i < prices.length; i++) {\\n    lowestPrice = Math.min(prices[i], lowestPrice);\\n    result = Math.max(result, prices[i] - lowestPrice);\\n  }\\n\\n  return result;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1370459,
                "title": "accepted-solution-for-swift",
                "content": "<blockquote>\\n<b>Disclaimer:</b> By using any content from this post or thread, you release the author(s) from all liability and warranties of any kind. You can are to use the content as you see fit. Any suggestions for improvement are welcome and greatly appreciated! Happy coding!\\n</blockquote>\\n\\n```swift\\nclass Solution {\\n    func maxProfit(_ p: [Int]) -> Int {\\n        guard !p.isEmpty else { return 0 }\\n        var bday = 0, prof = 0\\n        for i in p.indices.dropFirst() {\\n            bday = max(0, bday + p[i] - p[i-1])\\n            prof = max(prof, bday)\\n        }\\n        return prof\\n    }\\n}\\n```\\n\\n---\\n\\n<p>\\n<details>\\n<summary>\\n<img src=\"https://git.io/JDblm\" height=\"24\">\\n<b>TEST CASES</b>\\n</summary>\\n\\n<p><pre>\\n<b>Result:</b> Executed 2 tests, with 0 failures (0 unexpected) in 0.004 (0.006) seconds\\n</pre></p>\\n\\n```swift\\nimport XCTest\\n\\nclass Tests: XCTestCase {\\n    \\n    private let solution = Solution()\\n    \\n    // Buy on day 2 (price = 1) and sell on day 5 (price = 6), profit = 6-1 = 5.\\n    // Note that buying on day 2 and selling on day 1 is not allowed because you must buy before you sell.\\n    func test0() {\\n        let value = solution.maxProfit([7,1,5,3,6,4])\\n        XCTAssertEqual(value, 5)\\n    }\\n    \\n    // In this case, no transactions are done and the max profit = 0.\\n    func test1() {\\n        let value = solution.maxProfit([7,6,4,3,1])\\n        XCTAssertEqual(value, 0)\\n    }\\n}\\n\\nTests.defaultTestSuite.run()\\n```\\n\\n</details>\\n</p>",
                "solutionTags": [
                    "Swift"
                ],
                "code": "```swift\\nclass Solution {\\n    func maxProfit(_ p: [Int]) -> Int {\\n        guard !p.isEmpty else { return 0 }\\n        var bday = 0, prof = 0\\n        for i in p.indices.dropFirst() {\\n            bday = max(0, bday + p[i] - p[i-1])\\n            prof = max(prof, bday)\\n        }\\n        return prof\\n    }\\n}\\n```\n```swift\\nimport XCTest\\n\\nclass Tests: XCTestCase {\\n    \\n    private let solution = Solution()\\n    \\n    // Buy on day 2 (price = 1) and sell on day 5 (price = 6), profit = 6-1 = 5.\\n    // Note that buying on day 2 and selling on day 1 is not allowed because you must buy before you sell.\\n    func test0() {\\n        let value = solution.maxProfit([7,1,5,3,6,4])\\n        XCTAssertEqual(value, 5)\\n    }\\n    \\n    // In this case, no transactions are done and the max profit = 0.\\n    func test1() {\\n        let value = solution.maxProfit([7,6,4,3,1])\\n        XCTAssertEqual(value, 0)\\n    }\\n}\\n\\nTests.defaultTestSuite.run()\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1330044,
                "title": "c-brute-force-efficient-solution-time-o-n-auxiliary-space-o-1",
                "content": "**Brute Force Solution**\\n\\n```\\nclass Solution {\\npublic:\\n    int maxProfit(vector<int>& prices) { \\n    // Brute Force Solution Time O(N^2) & Auxiliary Space O(1)\\n    int len=prices.size(),profit=0;\\n        for(int i=0;i<len;i++){\\n            for(int j=i+1;j<len;j++){\\n                if(prices[j]>prices[i]){\\n                    int pro=prices[j]-prices[i];\\n                    profit=max(profit,pro);\\n                }\\n            }\\n        }\\n    return profit; \\n  }\\n};\\n```\\n\\n**Efficient Solution**\\n\\n```\\nclass Solution {\\npublic:\\n    int maxProfit(vector<int>& prices) {\\n    // Efficient Solution Time O(N) & Auxiliary Space O(1)\\n    int min_val=INT_MAX,profit=0,len=prices.size();\\n    for(int i=0;i<len;i++){\\n          min_val=min(min_val,prices[i]);\\n          profit=max(profit,prices[i]-min_val);\\n        }\\n    return profit;\\n    }\\n};\\n```\\n**All suggestions are welcome. Please upvote if you like it. Thank you for reading the post.**",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int maxProfit(vector<int>& prices) { \\n    // Brute Force Solution Time O(N^2) & Auxiliary Space O(1)\\n    int len=prices.size(),profit=0;\\n        for(int i=0;i<len;i++){\\n            for(int j=i+1;j<len;j++){\\n                if(prices[j]>prices[i]){\\n                    int pro=prices[j]-prices[i];\\n                    profit=max(profit,pro);\\n                }\\n            }\\n        }\\n    return profit; \\n  }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    int maxProfit(vector<int>& prices) {\\n    // Efficient Solution Time O(N) & Auxiliary Space O(1)\\n    int min_val=INT_MAX,profit=0,len=prices.size();\\n    for(int i=0;i<len;i++){\\n          min_val=min(min_val,prices[i]);\\n          profit=max(profit,prices[i]-min_val);\\n        }\\n    return profit;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1067884,
                "title": "python-dp-solution-with-comments",
                "content": "```\\nclass Solution:\\n    def maxProfit(self, prices: List[int]) -> int:\\n        if len(prices) == 0:\\n            return 0\\n\\t\\t# dp is an array of tuples where the first element in the tuple\\n\\t\\t# represents the cheapest stock I could have bought on the i\\'th day and the second\\n\\t\\t# element represents the max profit I could make on the i\\'th day\\n        dp = [(0, 0)]*len(prices)\\n        dp[0] = (prices[0], 0)\\n        for i in range(1, len(prices)):\\n            dp[i] = (min(dp[i - 1][0], prices[i]), max(prices[i] - dp[i - 1][0], dp[i - 1][1]))\\n        return dp[len(prices) - 1][1]\\n```",
                "solutionTags": [
                    "Python",
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution:\\n    def maxProfit(self, prices: List[int]) -> int:\\n        if len(prices) == 0:\\n            return 0\\n\\t\\t# dp is an array of tuples where the first element in the tuple\\n\\t\\t# represents the cheapest stock I could have bought on the i\\'th day and the second\\n\\t\\t# element represents the max profit I could make on the i\\'th day\\n        dp = [(0, 0)]*len(prices)\\n        dp[0] = (prices[0], 0)\\n        for i in range(1, len(prices)):\\n            dp[i] = (min(dp[i - 1][0], prices[i]), max(prices[i] - dp[i - 1][0], dp[i - 1][1]))\\n        return dp[len(prices) - 1][1]\\n```",
                "codeTag": "Java"
            },
            {
                "id": 981294,
                "title": "python3-two-pointer",
                "content": "```\\n# Two point\\nclass Solution:\\n    def maxProfit(self, prices: List[int]) -> int:\\n        l, r = 0, 1\\n        maxProfit = 0\\n        \\n        while(r < len(prices)):\\n            if prices[l] <= prices[r]:\\n                maxProfit = max(maxProfit, prices[r] - prices[l])\\n                r += 1\\n            else:\\n                l = r\\n                r += 1\\n        \\n        return maxProfit\\n```",
                "solutionTags": [
                    "Python3",
                    "Two Pointers"
                ],
                "code": "```\\n# Two point\\nclass Solution:\\n    def maxProfit(self, prices: List[int]) -> int:\\n        l, r = 0, 1\\n        maxProfit = 0\\n        \\n        while(r < len(prices)):\\n            if prices[l] <= prices[r]:\\n                maxProfit = max(maxProfit, prices[r] - prices[l])\\n                r += 1\\n            else:\\n                l = r\\n                r += 1\\n        \\n        return maxProfit\\n```",
                "codeTag": "Java"
            },
            {
                "id": 908061,
                "title": "state-machine-beats-100",
                "content": "\\nIf we are in S1, it means we bought a stock at current time or we bought it in past.\\nIf we are in S2, it means we sold a stock at current time or we sold it in past.\\n\\nAt beginning, only way to be in S1 is to buy stock at that time.\\nAt beginning, there is no way to be in S2, so it is undefined (`INT_MIN`).\\n\\n![image](https://assets.leetcode.com/users/images/2292f521-67ae-4f0d-bb59-db6389690725_1603536167.8704946.png)\\n\\n**C++**\\n```\\nclass Solution {\\npublic:\\n    int maxProfit(vector<int>& prices) {\\n        if(prices.size() < 2) {\\n            return 0;\\n        }\\n        int n = prices.size();\\n        vector<vector<int>> dp(2, vector<int> (n));\\n        dp[0][0] = -prices[0], dp[1][0] = INT_MIN;\\n        for(int i = 1; i < n; ++i) {\\n            dp[0][i] = max(dp[0][i - 1], -prices[i]);\\n            dp[1][i] = max(dp[1][i - 1], dp[0][i - 1] + prices[i]);\\n        }\\n        return max(0, dp[1][n - 1]);\\n    }\\n};\\n```\\n\\nO(1) space can be achieved by utilizing the fact that only the previous state is required to construct current state.\\n\\nInspired by this [post](https://leetcode.com/problems/best-time-to-buy-and-sell-stock-with-cooldown/discuss/75928/Share-my-DP-solution-(By-State-Machine-Thinking))",
                "solutionTags": [
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int maxProfit(vector<int>& prices) {\\n        if(prices.size() < 2) {\\n            return 0;\\n        }\\n        int n = prices.size();\\n        vector<vector<int>> dp(2, vector<int> (n));\\n        dp[0][0] = -prices[0], dp[1][0] = INT_MIN;\\n        for(int i = 1; i < n; ++i) {\\n            dp[0][i] = max(dp[0][i - 1], -prices[i]);\\n            dp[1][i] = max(dp[1][i - 1], dp[0][i - 1] + prices[i]);\\n        }\\n        return max(0, dp[1][n - 1]);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 852196,
                "title": "o-n-solution-dynamic-programming-c-optimal-solution-detailed-explanation",
                "content": "\\nYoutube link : https://youtu.be/0-6V7nDG8TY\\nFollow for further updates.\\n\\n**CODE :**\\n```\\nclass Solution {\\npublic:\\n    int maxProfit(vector<int>& prices) {\\n        \\n        int profit=0;\\n        int minvalue=INT_MAX;\\n        \\n        for(int i=0;i<prices.size();i++)\\n        {\\n            minvalue=min(minvalue,prices[i]);\\n            profit=max(profit,prices[i]-minvalue);\\n        }\\n        \\n        return profit;\\n        \\n    }\\n};\\n\\n\\n// FORMULA FOR CALCULATING PROFIT\\n\\n\\n// profit=(price of stock on ith day)-(min value of stock till ith day)\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int maxProfit(vector<int>& prices) {\\n        \\n        int profit=0;\\n        int minvalue=INT_MAX;\\n        \\n        for(int i=0;i<prices.size();i++)\\n        {\\n            minvalue=min(minvalue,prices[i]);\\n            profit=max(profit,prices[i]-minvalue);\\n        }\\n        \\n        return profit;\\n        \\n    }\\n};\\n\\n\\n// FORMULA FOR CALCULATING PROFIT\\n\\n\\n// profit=(price of stock on ith day)-(min value of stock till ith day)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 813030,
                "title": "php-faster-than-100",
                "content": "Faster than 100%\\n function maxProfit($prices) {\\n \\n        $min = $prices[0]; $max = 0;\\n    \\n         for($i = 1; $i < count($prices); $i++){\\n           if($prices[$i] - $min > $max) $max = $prices[$i] - $min;\\n           if($prices[$i] < $min) $min = $prices[$i];\\n        }\\n    \\n        return $max;\\n}\\n\\n**+-----------------------+------------------------+----------------------+**\\n\\nFaster than 68%\\n\\nfunction maxProfit($prices) {   \\n      \\n        $min = $prices[0]; $max = 0;\\n    \\n        for($i = 1; $i < count($prices); $i++){\\n          $max = max($prices[$i] - $min, $max);\\n          $min = min($prices[$i], $min);\\n        }\\n    \\n        return $max;\\n      \\n}",
                "solutionTags": [
                    "PHP"
                ],
                "code": "Faster than 100%\\n function maxProfit($prices) {\\n \\n        $min = $prices[0]; $max = 0;\\n    \\n         for($i = 1; $i < count($prices); $i++){\\n           if($prices[$i] - $min > $max) $max = $prices[$i] - $min;\\n           if($prices[$i] < $min) $min = $prices[$i];\\n        }\\n    \\n        return $max;\\n}\\n\\n**+-----------------------+------------------------+----------------------+**\\n\\nFaster than 68%\\n\\nfunction maxProfit($prices) {   \\n      \\n        $min = $prices[0]; $max = 0;\\n    \\n        for($i = 1; $i < count($prices); $i++){\\n          $max = max($prices[$i] - $min, $max);\\n          $min = min($prices[$i], $min);\\n        }\\n    \\n        return $max;\\n      \\n}",
                "codeTag": "Unknown"
            },
            {
                "id": 711172,
                "title": "easy-o-n-js-solution",
                "content": "```\\nvar maxProfit = function(prices) {\\n    let maxProfit = 0;\\n    let buyingPrice = prices[0];\\n    for (let i = 1; i < prices.length; i++) {\\n        if (prices[i] > buyingPrice) {\\n            let tempProfit = prices[i] - buyingPrice;\\n            maxProfit = Math.max(maxProfit, tempProfit);\\n        }\\n        if (prices[i] < buyingPrice) {\\n            buyingPrice = prices[i];\\n        }\\n    }\\n    return maxProfit;\\n    // Time Complexity: O(n)\\n    // Space Complexity: O(1)\\n};\\n\\n/*\\nTest Cases:\\n[3,7,0,1,2,2,3] => 4\\n[] => 0\\n[1] => 0 since we can\\'t perform selling\\n[2, 1] => 0\\n\\nIdea:\\n1. Create two variables, one of which will track the maximum possible profit so far and the other of which will track my buying price.\\nI initialise maximum profit to zero because we start with no profit, and I initialise my buying price to the first element of the array \\nsince this is the first possible price I can buy a stock at.\\n2. Loop over every number in the array from the second element.\\nEvery time I can make a profit (so when the current price is higher than the price I bought), I will compare the maximum profit so far\\nand the profit I can make through this transaction and update my tracking variable if I can make a higher profit through this transaction.\\nAlso, every time I encounter a price lower that the price I bought, update my buying price to this lower price because I want to maximise my profit.\\n3. Return the maximum profit.\\n\\nTime Complexity: O(n)\\nSpace Complexity: O(1)\\n*/\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\nvar maxProfit = function(prices) {\\n    let maxProfit = 0;\\n    let buyingPrice = prices[0];\\n    for (let i = 1; i < prices.length; i++) {\\n        if (prices[i] > buyingPrice) {\\n            let tempProfit = prices[i] - buyingPrice;\\n            maxProfit = Math.max(maxProfit, tempProfit);\\n        }\\n        if (prices[i] < buyingPrice) {\\n            buyingPrice = prices[i];\\n        }\\n    }\\n    return maxProfit;\\n    // Time Complexity: O(n)\\n    // Space Complexity: O(1)\\n};\\n\\n/*\\nTest Cases:\\n[3,7,0,1,2,2,3] => 4\\n[] => 0\\n[1] => 0 since we can\\'t perform selling\\n[2, 1] => 0\\n\\nIdea:\\n1. Create two variables, one of which will track the maximum possible profit so far and the other of which will track my buying price.\\nI initialise maximum profit to zero because we start with no profit, and I initialise my buying price to the first element of the array \\nsince this is the first possible price I can buy a stock at.\\n2. Loop over every number in the array from the second element.\\nEvery time I can make a profit (so when the current price is higher than the price I bought), I will compare the maximum profit so far\\nand the profit I can make through this transaction and update my tracking variable if I can make a higher profit through this transaction.\\nAlso, every time I encounter a price lower that the price I bought, update my buying price to this lower price because I want to maximise my profit.\\n3. Return the maximum profit.\\n\\nTime Complexity: O(n)\\nSpace Complexity: O(1)\\n*/\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 676371,
                "title": "java-with-picture",
                "content": "\\n\\n![](https://yyc-images.oss-cn-beijing.aliyuncs.com/leetcode_121_using_dp.png)  \\n\\n\\n``` java\\nclass Solution {\\n    public int maxProfit(int[] prices) {\\n        int max = 0;\\n        int len = prices.length;\\n        for (int i = 0; i < len; i++){\\n            for (int j = i + 1; j < len; j++){\\n                max = Math.max(max, prices[j] - prices[i]);\\n            }\\n        }\\n        return max;\\n    }\\n}\\n```\\n\\nTime complexity is O(N^2)  \\n\\n\\nLet\\'s optimize it to O(N).\\n\\n\\n``` java\\nclass Solution {\\n    public int maxProfit(int[] prices) {\\n        int len = prices.length;\\n        if (len == 0) return 0;\\n        int preMin = prices[0];\\n        int maxPro = 0;\\n\\n        for (int i = 1; i < len; i++){\\n            int cur = prices[i];\\n            maxPro = Math.max(maxPro, cur - preMin);\\n            preMin = Math.min(preMin, cur);\\n        }\\n        return maxPro;\\n    }\\n}\\n```\\n\\n`Enjoy it ! `",
                "solutionTags": [],
                "code": "``` java\\nclass Solution {\\n    public int maxProfit(int[] prices) {\\n        int max = 0;\\n        int len = prices.length;\\n        for (int i = 0; i < len; i++){\\n            for (int j = i + 1; j < len; j++){\\n                max = Math.max(max, prices[j] - prices[i]);\\n            }\\n        }\\n        return max;\\n    }\\n}\\n```\n``` java\\nclass Solution {\\n    public int maxProfit(int[] prices) {\\n        int len = prices.length;\\n        if (len == 0) return 0;\\n        int preMin = prices[0];\\n        int maxPro = 0;\\n\\n        for (int i = 1; i < len; i++){\\n            int cur = prices[i];\\n            maxPro = Math.max(maxPro, cur - preMin);\\n            preMin = Math.min(preMin, cur);\\n        }\\n        return maxPro;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 613191,
                "title": "8-line-java-solution-o-n-o-1-intuitive-solution",
                "content": "I found that using terms like \"buy\" and \"profit\" made this problem easier to understand/ code. \\n\\n**The question to avoid is:** If a buy a stock today, what\\'s the best price I can sell at? You go through every price and check your profit margins. This leads to O(n^2). \\n**A better question is:** What is the best stock to buy **today**, what\\'s the best price I can sell at? Because you continually adjust your buy time, you can go through the array once. \\n\\nGetting the perfect solution is all about perspective. \\n1. Go through the entire array. \\n2. If the current price of a stock is less than our previous purchase, we buy the stock \\n3. Otherwise, we sell the stock at the current price\\n4. We take note if there was a larger profit. \\n```\\npublic int maxProfit(int[] prices) {\\n        int profit = 0, \\n        buy = Integer.MAX_VALUE; \\n        for (int i = 0; i < prices.length; i ++){\\n            if (prices[i] < buy)\\n                buy = prices[i]; \\n\\t\\t\\telse\\n\\t\\t\\t\\tprofit = Math.max(profit, prices[i] - buy); \\n        }\\n        return profit; \\n    }\\n```\\nWe do not need the else, but for clarity, I included it. On either day we either buy or sell. (But If we buy/sell on the same day, we make 0 profit anyways). \\n",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\npublic int maxProfit(int[] prices) {\\n        int profit = 0, \\n        buy = Integer.MAX_VALUE; \\n        for (int i = 0; i < prices.length; i ++){\\n            if (prices[i] < buy)\\n                buy = prices[i]; \\n\\t\\t\\telse\\n\\t\\t\\t\\tprofit = Math.max(profit, prices[i] - buy); \\n        }\\n        return profit; \\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 591350,
                "title": "6-approaches-with-step-by-step-optimization-time-and-space-analysis",
                "content": "# APP1: find all buy&sell days combination and keep updating best benefit\\n# Time: O(n^2) Space: O(1). Runtime: TLE\\n    def maxProfit(self, prices: List[int]) -> int:\\n        if not prices:\\n            return 0\\n        n = len(prices)\\n        max_profit = -sys.maxsize\\n        for i in range(n - 1):\\n            # you\\'re allowed to buy&sell on the same day \\n            for j in range(i, n):\\n                max_profit = max(max_profit, prices[j] - prices[i])\\n        return max_profit\\n\\n# APP2: for each buy date, Pre-calculate the largest sell date. \\n# Time: O(n), Space: O(n), Runtime: 40%, memory: 5%\\n    def maxProfit(self, prices: List[int]) -> int:\\n        if not prices:\\n            return 0\\n        n = len(prices)\\n        suffix = [0] * n\\n        largest, ans = prices[n - 1], -sys.maxsize\\n        for i in range(n - 1, -1, -1):\\n            largest = max(largest, prices[i])\\n            suffix[i] = largest\\n        for i in range(n):\\n            ans = max(ans, suffix[i] - prices[i])\\n        return ans \\n                \\n# APP3: for each sell day, Pre-calculate the lowest buy date before. \\n# Time: O(n), Space: O(n), Runtime: 63% memory: 5%\\n    def maxProfit(self, prices: List[int]) -> int:\\n        if not prices:\\n            return 0\\n        n = len(prices)\\n        prefix = [0] * n \\n        lowest, ans = prices[0], -sys.maxsize\\n        for i in range(n):\\n            lowest = min(lowest, prices[i])\\n            prefix[i] = lowest\\n        for i in range(n):\\n            ans = max(ans, prices[i] - prefix[i])\\n        return ans\\n        \\n# APP4-Draft: DP: f[i][j]: max profit buy at i and sell at j using two dimension array \\n# Here we can calculate f[i][j] directly using prices[j] = prices[i], which means we don\\'t need two dimension \\n# f[i][j] = max(f[i][j - 1] + price[j] - price[j - 1], price[j] - price[i] if i == j - 1)\\n\\n# APP4-final: DP optimize APP4-draft using one dimension array, f[j]: max profit sell at j day.\\n# Two conditions: Fist, buy day is before j - 1, Second, buy day is on j - 1 \\n# f[j] = max(f[j - 1] + price[j] - price[j - 1], price[j] - price[j - 1])\\n# Time: O(n) Space: O(n) Runtime: 63% memory: 5%\\n    def maxProfit(self, prices: List[int]) -> int:\\n        if not prices:\\n            return 0\\n        n, ans = len(prices), -sys.maxsize\\n        f = [0] * n\\n        for j in range(1, n):\\n            f[j] = max(f[j - 1] + prices[j] - prices[j - 1], prices[j] - prices[j - 1])                        \\n            ans = max(ans, f[j])\\n        # consider same day buy&sell \\n        if ans < 0:\\n            return 0\\n        return ans \\n\\n# APP5 optimize APP2, we only need a variable instead of an array to know the lowest buy date for each sell day.\\n# Time: O(n) space: O(1) Runtime: 84% memory: 5%\\n    def maxProfit(self, prices: List[int]) -> int:\\n        if not prices:\\n            return 0\\n        n = len(prices)\\n        lowest = sys.maxsize\\n        max_profit = -sys.maxsize\\n        for i in range(n):\\n            lowest = min(lowest, prices[i])\\n            max_profit = max(max_profit, prices[i] - lowest)\\n        if max_profit < 0:\\n            return 0\\n        return max_profit\\n    \\n# APP6: for each sell day, i only care the price smaller than its previously, so it\\'s a increasing monotonic stack\\n# Time: O(n), space: O(n) Runtime: 63% memory: 5%\\n    def maxProfit(self, prices: List[int]) -> int:\\n        if not prices:\\n            return 0\\n        stack = []\\n        ans = -sys.maxsize\\n        # add last value to pop all the remaining ones in stack at last\\n        new_prices = prices + [-sys.maxsize]\\n        n = len(new_prices)\\n        for i in range(n):\\n            while stack and new_prices[i] < stack[-1]:\\n                ans = max(ans, stack[-1] - stack[0])\\n                stack.pop()\\n            stack.append(new_prices[i])\\n        return ans",
                "solutionTags": [],
                "code": "# APP1: find all buy&sell days combination and keep updating best benefit\\n# Time: O(n^2) Space: O(1). Runtime: TLE\\n    def maxProfit(self, prices: List[int]) -> int:\\n        if not prices:\\n            return 0\\n        n = len(prices)\\n        max_profit = -sys.maxsize\\n        for i in range(n - 1):\\n            # you\\'re allowed to buy&sell on the same day \\n            for j in range(i, n):\\n                max_profit = max(max_profit, prices[j] - prices[i])\\n        return max_profit\\n\\n# APP2: for each buy date, Pre-calculate the largest sell date. \\n# Time: O(n), Space: O(n), Runtime: 40%, memory: 5%\\n    def maxProfit(self, prices: List[int]) -> int:\\n        if not prices:\\n            return 0\\n        n = len(prices)\\n        suffix = [0] * n\\n        largest, ans = prices[n - 1], -sys.maxsize\\n        for i in range(n - 1, -1, -1):\\n            largest = max(largest, prices[i])\\n            suffix[i] = largest\\n        for i in range(n):\\n            ans = max(ans, suffix[i] - prices[i])\\n        return ans \\n                \\n# APP3: for each sell day, Pre-calculate the lowest buy date before. \\n# Time: O(n), Space: O(n), Runtime: 63% memory: 5%\\n    def maxProfit(self, prices: List[int]) -> int:\\n        if not prices:\\n            return 0\\n        n = len(prices)\\n        prefix = [0] * n \\n        lowest, ans = prices[0], -sys.maxsize\\n        for i in range(n):\\n            lowest = min(lowest, prices[i])\\n            prefix[i] = lowest\\n        for i in range(n):\\n            ans = max(ans, prices[i] - prefix[i])\\n        return ans\\n        \\n# APP4-Draft: DP: f[i][j]: max profit buy at i and sell at j using two dimension array \\n# Here we can calculate f[i][j] directly using prices[j] = prices[i], which means we don\\'t need two dimension \\n# f[i][j] = max(f[i][j - 1] + price[j] - price[j - 1], price[j] - price[i] if i == j - 1)\\n\\n# APP4-final: DP optimize APP4-draft using one dimension array, f[j]: max profit sell at j day.\\n# Two conditions: Fist, buy day is before j - 1, Second, buy day is on j - 1 \\n# f[j] = max(f[j - 1] + price[j] - price[j - 1], price[j] - price[j - 1])\\n# Time: O(n) Space: O(n) Runtime: 63% memory: 5%\\n    def maxProfit(self, prices: List[int]) -> int:\\n        if not prices:\\n            return 0\\n        n, ans = len(prices), -sys.maxsize\\n        f = [0] * n\\n        for j in range(1, n):\\n            f[j] = max(f[j - 1] + prices[j] - prices[j - 1], prices[j] - prices[j - 1])                        \\n            ans = max(ans, f[j])\\n        # consider same day buy&sell \\n        if ans < 0:\\n            return 0\\n        return ans \\n\\n# APP5 optimize APP2, we only need a variable instead of an array to know the lowest buy date for each sell day.\\n# Time: O(n) space: O(1) Runtime: 84% memory: 5%\\n    def maxProfit(self, prices: List[int]) -> int:\\n        if not prices:\\n            return 0\\n        n = len(prices)\\n        lowest = sys.maxsize\\n        max_profit = -sys.maxsize\\n        for i in range(n):\\n            lowest = min(lowest, prices[i])\\n            max_profit = max(max_profit, prices[i] - lowest)\\n        if max_profit < 0:\\n            return 0\\n        return max_profit\\n    \\n# APP6: for each sell day, i only care the price smaller than its previously, so it\\'s a increasing monotonic stack\\n# Time: O(n), space: O(n) Runtime: 63% memory: 5%\\n    def maxProfit(self, prices: List[int]) -> int:\\n        if not prices:\\n            return 0\\n        stack = []\\n        ans = -sys.maxsize\\n        # add last value to pop all the remaining ones in stack at last\\n        new_prices = prices + [-sys.maxsize]\\n        n = len(new_prices)\\n        for i in range(n):\\n            while stack and new_prices[i] < stack[-1]:\\n                ans = max(ans, stack[-1] - stack[0])\\n                stack.pop()\\n            stack.append(new_prices[i])\\n        return ans",
                "codeTag": "Python3"
            },
            {
                "id": 539219,
                "title": "c-0ms-dp-solution-w-explanation",
                "content": "This problem is not one where DP immediately comes to mind, but it is good training to think \"DP\". For this problem, DP does not immediately come to mind because it is not directly related to the answer. Instead, the answer is calculated as a side-effect of running the DP program. The DP part involves calculating the minimum number before current. This is used to get the maximum profit at that number. \\n\\nThus, the algorithm would be like this:\\n1. For each index `i`, Use DP to get minimum number from `prices[0 ... i-1]`. Subtract `prices[i]` with `min(prices[0 ... j-1])` to get maximum revenue selling at `i`. \\n2. Record maximum revenue, and return that.\\n\\nRecording `min` seems like an obvious problem, but *you have to think in DP*. Forget everything else. To think in DP, first find the optimal subproblems:\\n\\n1. `min(prices[0 ... i]) = min(min(prices[0 ... i-1]), prices[i])`\\n\\nThis is the optimal subproblem structure. This can then be immediately used to construct DP array, with `dp[i] = min(dp[i-1], prices[i])` as the update function. This forms the first solution.\\n\\nBecause the DP update function only depends on the previous state (`dp[i-1]`), we can do space optimization and reduce space from `O(n)` to `O(1)`. This forms the second solution.\\n\\nThis may seem complicated, but for harder problems this way of thinking will make generating solutions *very fast*. The only *thinking* required is to identify the subproblems, and use the relationship between subproblems to generate the update function. Once that is done, everything else is systematic. This may not be the most optimized solution, but you at least have a solution, and you can then take your time to try to come up with a better one. \\n\\n```\\n#define vi vector<int>\\n\\nclass Solution {\\npublic:\\n    int maxProfit(vector<int>& prices) {\\n        int size = prices.size(), res = 0;\\n        if(!size) return 0;\\n        vi dp(size, 0);\\n        dp[0] = prices[0];\\n        for(int i = 1; i < size; ++i) {\\n            res = max(res, prices[i]-dp[i-1]);\\n            dp[i] = min(dp[i-1], prices[i]);\\n        }\\n        return res;\\n    }\\n};\\n\\nauto gucciGang = []() {std::ios::sync_with_stdio(false);cin.tie(nullptr);cout.tie(nullptr);return 0;}();\\n```\\n\\nSpace optimized solution `O(n)` time `O(1)` space.\\n\\n```\\n#define vi vector<int>\\n\\nclass Solution {\\npublic:\\n    int maxProfit(vector<int>& prices) {\\n        int size = prices.size(), res = 0;\\n        if(!size) return 0;\\n        vi dp(2, 0);\\n        dp[0] = prices[0];\\n        for(int i = 1; i < size; ++i) {\\n            res = max(res, prices[i]-dp[0]);\\n            dp[1] = min(dp[0], prices[i]);\\n            swap(dp[0], dp[1]);\\n        }\\n        return res;\\n    }\\n};\\n\\nauto gucciGang = []() {std::ios::sync_with_stdio(false);cin.tie(nullptr);cout.tie(nullptr);return 0;}();\\n```",
                "solutionTags": [],
                "code": "```\\n#define vi vector<int>\\n\\nclass Solution {\\npublic:\\n    int maxProfit(vector<int>& prices) {\\n        int size = prices.size(), res = 0;\\n        if(!size) return 0;\\n        vi dp(size, 0);\\n        dp[0] = prices[0];\\n        for(int i = 1; i < size; ++i) {\\n            res = max(res, prices[i]-dp[i-1]);\\n            dp[i] = min(dp[i-1], prices[i]);\\n        }\\n        return res;\\n    }\\n};\\n\\nauto gucciGang = []() {std::ios::sync_with_stdio(false);cin.tie(nullptr);cout.tie(nullptr);return 0;}();\\n```\n```\\n#define vi vector<int>\\n\\nclass Solution {\\npublic:\\n    int maxProfit(vector<int>& prices) {\\n        int size = prices.size(), res = 0;\\n        if(!size) return 0;\\n        vi dp(2, 0);\\n        dp[0] = prices[0];\\n        for(int i = 1; i < size; ++i) {\\n            res = max(res, prices[i]-dp[0]);\\n            dp[1] = min(dp[0], prices[i]);\\n            swap(dp[0], dp[1]);\\n        }\\n        return res;\\n    }\\n};\\n\\nauto gucciGang = []() {std::ios::sync_with_stdio(false);cin.tie(nullptr);cout.tie(nullptr);return 0;}();\\n```",
                "codeTag": "C++"
            },
            {
                "id": 473883,
                "title": "python-concise-o-n-time-and-constant-space-solution",
                "content": "The idea is to record the minimum price so far as we loop through the price array, then \\'p - minP\\' is the maximum profit we can get if we sell the stock on current day, finally we get the overall maximum profit by comparing all the possible maximum profits.\\n\\nNote: it is OK to calculate minimum price before getting the maximum profit on each day. Because if today\\'s price is not the minimum so far, it does not affect the minimum price, and if today\\'s price is the minimum, it means all previous days\\' prices will be higher or equal to today\\'s price, then the maximum profit we can get today will be 0 anyways.\\n\\n```\\nclass Solution:\\n    def maxProfit(self, prices: List[int]) -> int:\\n        res, minP = 0, float(\\'inf\\')\\n        for p in prices:\\n            minP = min(p, minP)\\n            res = max(res, p - minP)\\n        return res\\n```",
                "solutionTags": [
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution:\\n    def maxProfit(self, prices: List[int]) -> int:\\n        res, minP = 0, float(\\'inf\\')\\n        for p in prices:\\n            minP = min(p, minP)\\n            res = max(res, p - minP)\\n        return res\\n```",
                "codeTag": "Java"
            },
            {
                "id": 405069,
                "title": "python-solution-easy-to-understand-and-o-n",
                "content": "1. Using element comparison\\n```\\nclass Solution(object):\\n    def maxProfit(self, prices):\\n\\n        low = float(\\'inf\\') # set initial low price to be infinite \\n        profit = 0 # set profit to be 0 \\n        for price in prices:\\n            if price < low:  # detect current price are lower than low\\n                low = price \\n            else:  # detect current price are higher\\n                profit = max(price-low, profit) # compare the current difference and previous max profit\\n        return profit\\n```\\n\\n2. Dynamic programming\\n```\\nclass Solution(object):\\n    def maxProfit(self, prices):\\n    \\n        fb, fs = float(\\'inf\\'), 0\\n        for price in prices:\\n            fb = min(fb, price) # keep minimal\\n            fs = max(fs, price-fb) # compute max difference\\n        return fs\\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nclass Solution(object):\\n    def maxProfit(self, prices):\\n\\n        low = float(\\'inf\\') # set initial low price to be infinite \\n        profit = 0 # set profit to be 0 \\n        for price in prices:\\n            if price < low:  # detect current price are lower than low\\n                low = price \\n            else:  # detect current price are higher\\n                profit = max(price-low, profit) # compare the current difference and previous max profit\\n        return profit\\n```\n```\\nclass Solution(object):\\n    def maxProfit(self, prices):\\n    \\n        fb, fs = float(\\'inf\\'), 0\\n        for price in prices:\\n            fb = min(fb, price) # keep minimal\\n            fs = max(fs, price-fb) # compute max difference\\n        return fs\\n```",
                "codeTag": "Java"
            },
            {
                "id": 341798,
                "title": "solution-in-python-3",
                "content": "```\\nclass Solution:\\n    def maxProfit(self, prices: List[int]) -> int:\\n    \\tm, mp = float(\\'inf\\'), 0\\n    \\tfor p in prices:\\n    \\t\\tif p < m: m = p\\n    \\t\\tif p - m > mp: mp = p - m\\n    \\treturn mp\\n\\t\\t\\n\\t\\t\\n- Python 3\\n- Junaid Mansuri",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def maxProfit(self, prices: List[int]) -> int:\\n    \\tm, mp = float(\\'inf\\'), 0\\n    \\tfor p in prices:\\n    \\t\\tif p < m: m = p\\n    \\t\\tif p - m > mp: mp = p - m\\n    \\treturn mp\\n\\t\\t\\n\\t\\t\\n- Python 3\\n- Junaid Mansuri",
                "codeTag": "Java"
            },
            {
                "id": 322506,
                "title": "best-python-solution-crack-the-dynamic-programming-explained",
                "content": "# Explaination\\nFirst setup a memo\\nThe value in memo is the max profit we are going to get when we only look at 0~i\\nFor every i, we either sell or not sell\\n* If we sell, the max profit is price now - lowest price before (prices[i]-min_price).\\n* If we not sell, the max profit we get now is the same as yesterday.\\nEvery i between these two we pick the max.\\nSo we iterate from 0 to the end.\\n\\n# Code\\n```\\nclass Solution(object):\\n    def maxProfit(self, prices):\\n        if prices is None or len(prices)==0: return 0\\n        \\n        memo = [0]*len(prices)\\n        min_price = float(\\'inf\\')\\n        \\n        for i in xrange(len(prices)):\\n            min_price = min(min_price, prices[i])\\n            if i==0: continue\\n            memo[i] = max(prices[i]-min_price, memo[i-1])\\n        return memo[-1]\\n```\\n\\n# More Resource\\nI really take time tried to make the best solution or explaination. \\nBecause I wanted to help others like me. \\nIf you like my answer, a star on [GitHub](https://github.com/wuduhren/leetcode-python) means a lot to me. \\nhttps://github.com/wuduhren/leetcode-python\\n\\n# Dynamic programming\\nThis is a dynamic programming question.\\nMost dynamic programming can solve it by the simliar approach.\\nIf you are not familiar with it take a look at  \\n* [House robber problem](https://leetcode.com/problems/min-cost-climbing-stairs) with @heroes3001 \\'s [explaination](https://leetcode.com/problems/house-robber/discuss/156523/From-good-to-great.-How-to-approach-most-of-DP-problems.). \\n* [Climbing stairs problem](https://leetcode.com/problems/climbing-stairs/) with my [explaination](https://leetcode.com/problems/min-cost-climbing-stairs/discuss/322531/).\\n* [Stock problem](https://leetcode.com/problems/best-time-to-buy-and-sell-stock/) with my [explaination](https://leetcode.com/problems/best-time-to-buy-and-sell-stock/discuss/322506).\\n* [0/1 Knapsack problem](https://www.youtube.com/watch?v=8LusJS5-AGo).",
                "solutionTags": [],
                "code": "```\\nclass Solution(object):\\n    def maxProfit(self, prices):\\n        if prices is None or len(prices)==0: return 0\\n        \\n        memo = [0]*len(prices)\\n        min_price = float(\\'inf\\')\\n        \\n        for i in xrange(len(prices)):\\n            min_price = min(min_price, prices[i])\\n            if i==0: continue\\n            memo[i] = max(prices[i]-min_price, memo[i-1])\\n        return memo[-1]\\n```",
                "codeTag": "Java"
            }
        ],
        "discussions": [
            {
                "id": 1757990,
                "content": [
                    {
                        "username": "Serosidium",
                        "content": "I couldn\\'t find any good explanations here and only code, so I will do my best to explain how I solved it without providing code. I am sure there are other possible solutions, but this is how it worked for me.\\n\\nThe brute force method of a double for loop is not necessary here, and this problem is marked with dynamic programming because it requires the [Sliding Window technique](https://algorithm-visualizer.org/dynamic-programming/sliding-window).\\n\\nBased on the fact that we have to sell after we buy and we are trying to maximize profit, we can iterate through the prices and only need to consider two things:\\n1.) **Is this price cheaper than any other price I\\'ve seen before?** \\n2.) If I subtract current price by the cheapest price I\\'ve found, **does this yield a greater profit than what I\\'ve seen so far?**\\n\\n*A fun thing to note is if #1 is true, then #2 cannot be true as well so there isn\\'t a need to check*\\n\\nLet\\'s consider an example of [4,1,5,2,7]\\n- 4 is the cheapest price we see to start, and we can\\'t sell on the first day so maxProfit is 0\\n- 1 is now the cheapest price we\\'ve seen. Selling now would lose us money, so we can\\'t update maxProfit\\n- 5 is not cheaper than 1, but if we sell now we get a maxProfit of 4! Better save that for later\\n- 2 is not cheaper than 1 and if we sell, we only get a profit of 1, no need to do anything here\\n- 7 is not cheaper than 1, but if we sell here, we\\'ll increase maxProfit to 6, making this the best profit to return.\\n\\nHope this helps someone else!\\n"
                    },
                    {
                        "username": "Manidgyf_6",
                        "content": "Thank you bro"
                    },
                    {
                        "username": "lorentzimys",
                        "content": "Awesome solution, thanks!"
                    },
                    {
                        "username": "Khoa268",
                        "content": "thanks for sharing!"
                    },
                    {
                        "username": "omeh-a",
                        "content": "This is not a DP solution as described, it is greedy"
                    },
                    {
                        "username": "ankitk742",
                        "content": "Thanks bro for your help without code really appreciate "
                    },
                    {
                        "username": "245120733119",
                        "content": "Brilliant!! Thanks for sharing!!"
                    },
                    {
                        "username": "Aniket_sggs",
                        "content": "Initially, this seemed to be DP problem. but after reading this description it is clear that this is basic problem with greedy solution."
                    },
                    {
                        "username": "duffinson97",
                        "content": "Thank you for not posting code, I don\\'t understand the sliding window technique or how this applies to that. I google it and the image link to this problem doesn\\'t make a lot of sense to me. But this solution works thanks"
                    },
                    {
                        "username": "typranjal1",
                        "content": "Thank you!."
                    },
                    {
                        "username": "jakho100",
                        "content": "was stuck on it for hours, thanks for the simple explanation! "
                    },
                    {
                        "username": "zafeer_rangoonwala",
                        "content": "I was originally not able to solve it but after reading your thought process it was a cake walk! \\n\\nThanks! "
                    },
                    {
                        "username": "mohammed1212345",
                        "content": "thank for helping out"
                    },
                    {
                        "username": "dungtuanuet",
                        "content": "Exellent explaination!"
                    },
                    {
                        "username": "kcleland18",
                        "content": "This was a great explanation!! Thanks!"
                    },
                    {
                        "username": "as358",
                        "content": "Best Explanation ever !!!"
                    },
                    {
                        "username": "user6798sW",
                        "content": "AWESOME BREAKDOWN! Ty"
                    },
                    {
                        "username": "jaydeep-pro",
                        "content": "[@evoniuk](/evoniuk) exactly! "
                    },
                    {
                        "username": "akshaydusad",
                        "content": "okay this is genius and surprisingly easier to follow!"
                    },
                    {
                        "username": "evoniuk",
                        "content": "Thank you! This is a solution that\\'s so simple and obvious once you see it you kick yourself for not thinking of it yourself!"
                    },
                    {
                        "username": "ivantchev",
                        "content": "How would the original wording of the problem have to be modified so that the double loop solution _has_ to be used?"
                    },
                    {
                        "username": "ivantchev",
                        "content": "Very helpful, thank you! To add: the reason why using your point 1.) works as a valid check is because given the problem constraints, it will always yield a higher profit down the line regardless of future values.\\n\\nAnd point  2.) shows we don\\'t need a second loop.\\n\\nI wonder, can any concrete aspect of the problem  be used as a clue so that we can reach Serosidium\\'s solution  independently. "
                    },
                    {
                        "username": "VishnuKesav",
                        "content": "[@sharpsailor](/sharpsailor) our target is to get highest possible profit.\\nYou are focusing on buying for the lowest price alone. No matter how low the price is, buying on a last day will yield 0 profit.\\n"
                    },
                    {
                        "username": "kaushar",
                        "content": "[@tengxianrui](/tengxianrui) Thanks  !"
                    },
                    {
                        "username": "neelimag459",
                        "content": "Thank you so much for such good explanation. Happy coding."
                    },
                    {
                        "username": "Nbs-26",
                        "content": "Thank u brother. Your explanation is very clear and well defined."
                    },
                    {
                        "username": "Dabchinsky",
                        "content": "[@sharpsailor](/sharpsailor) if we buy on 2 and sell on 4, our profit would be 4 - 2 = 2. "
                    },
                    {
                        "username": "sharpsailor",
                        "content": "check for {2,4,1} ideally it should give 0 but leetcode gives 2..Help me figure out where am I getting it wrong\\n"
                    },
                    {
                        "username": "jackbb147",
                        "content": "that\\'s actually very smart... thanks"
                    },
                    {
                        "username": "chiahao1",
                        "content": "Thank you! Your technique worked for me."
                    },
                    {
                        "username": "Marre-86",
                        "content": "Man, you made my day! I spent two hours and wrote almost 100 hundred lines code that probably was soving it but had \"time limit exceeded\" with huge input. And after your explanation I rewrite it in freaking 7 lines and it made it right off the bat!"
                    },
                    {
                        "username": "m1ma087",
                        "content": "Best tip! Thanks!"
                    },
                    {
                        "username": "sasaalina1985",
                        "content": "was reading this and solved the problem first try! Very good explanation!!!"
                    },
                    {
                        "username": "Yash_6207",
                        "content": "This is what we call as Greedy ! Good Explanation\\n"
                    },
                    {
                        "username": "iosifpetrupuha",
                        "content": "[@fjod](/fjod) but it\\'s buy day that should be before then sellday"
                    },
                    {
                        "username": "iosifpetrupuha",
                        "content": "[@iosifpetrupuha](/iosifpetrupuha) daaamn there is no indentation in this comment section"
                    },
                    {
                        "username": "iosifpetrupuha",
                        "content": "so I didn\\'t know this was called sliding window or sumthin, but I am second year at CS university, i have some grasp of this kind of logic and I solved it this way:\\nclass Solution:\\n    def maxProfit(self, prices: List[int]) -> int:\\n        #you obviously must buy before you sell(can\\'t go back in time)\\n        GreatestProfit=0\\n        priceToBeat=prices[0]\\n        for i in range(len(prices)-1):#we can iterate through the whole list, otherwise we get out of bounds, so we iterate from the first to the penultimate (so the last comparation we do is between the penultimate and the last element) \\n            if prices[i]<prices[i+1]:#sure profit, possible greatest profit\\n                if prices[i]<=priceToBeat:\\n                    priceToBeat=prices[i]\\n                if GreatestProfit<=prices[i+1]-priceToBeat: #if the GreatestProfit we calculate is greater than the one we have already, we update the Greatest Profit, otherwise we do nothing\\n                    GreatestProfit=prices[i+1]-priceToBeat\\n        return GreatestProfit\\nis this a proper way to solve this kind of problems? (in terms of efficiency I think we\\'re in O(n) so it should be pretty good"
                    },
                    {
                        "username": "Rohit_8412",
                        "content": "Thanks, I was about to see the solution after 10 min I didn\\'t get an approach into my mind.\\nThen I saw your discussion and I solved the question myself \\uD83D\\uDE0E"
                    },
                    {
                        "username": "fjod",
                        "content": "your explanation does not include rule of sellDay must be after buyDay"
                    },
                    {
                        "username": "Hanagaki_Takimichy",
                        "content": "thanks for great explaination without any spoilers.\\ni will try my best for the code, thanks a lot ;)"
                    },
                    {
                        "username": "csrnontol",
                        "content": "Sounds good, but I think your tip fails for [2,9,3,4,5,1,7] (how you\\'d choose 2, 9) and [2,9,3,4,5,1,7,10] (how you\\'d choose 1, 10)."
                    },
                    {
                        "username": "rockmanex",
                        "content": "best explanations so far. Thankyou it\\'s help a lot"
                    },
                    {
                        "username": "ak67",
                        "content": "I think this problem should be catogarise as medium level problem\\n"
                    },
                    {
                        "username": "Sultan_Ul_Arfin",
                        "content": "[@chazwinter](/chazwinter) what is sliding window? I never heard it ..will you explain that please<3\\n "
                    },
                    {
                        "username": "chazwinter",
                        "content": "It doesn\\'t require DP though. You only think it\\'s harder than it is because you\\'re overthinking it. You can use sliding window and just keep track of the lowest price as you go."
                    },
                    {
                        "username": "rwatso",
                        "content": "[@lucky_nik77](/lucky_nik77) Because by its very nature DP is not a beginner / easy level topic."
                    },
                    {
                        "username": "Vectorido",
                        "content": "[@lucky_nik77](/lucky_nik77) This is not hard for simple lists. But all people here usually stuck at TimeLimit error. So algorithm should be another, at least medium level of complexity."
                    },
                    {
                        "username": "lucky_nik77",
                        "content": "But why? It is hard to think about a DP problem that would be easier than this."
                    },
                    {
                        "username": "tiwarimrutunjay",
                        "content": "agreed"
                    },
                    {
                        "username": "codernoob",
                        "content": "how to resolve the time exceeded issue? Mine fails at 203rd test case with a large array"
                    },
                    {
                        "username": "user4279js",
                        "content": "[@rajamandalofficial56](/rajamandalofficial56) I\\'m not a javascript expert, but probably doing prices.slice(index) is looping 0 -index eachtime ... so you have O(N\\n^2) soltuion overall"
                    },
                    {
                        "username": "Behnoosh",
                        "content": "[@htooak2014](/htooak2014) To me it was occurring when my code had an O(n^2) complexity. Resolving that (to O(n)) solved this problem. I start from the end of the array prices and dynamically find the max value from the end of the array until the current step backwards. This way, at the end of the for loop, we can find the max profit with only one single pass over all entries of the array."
                    },
                    {
                        "username": "eyastaifour",
                        "content": "[@htooak2014](/htooak2014) I am hitting a limit error as well and I believe that it is because I keep on querying max() of the window, but when I think of it the max is either on the first index of the window (as I descend), or somewhere else, in which case, it should be cached as it doesnt change... at least, that\\'s what i am thinking\\n"
                    },
                    {
                        "username": "PercyJia95",
                        "content": "[@rajamandalofficial56](/rajamandalofficial56) You need to reconsider your variable naming. They carry very few meanings."
                    },
                    {
                        "username": "knotri",
                        "content": "[@rajamandalofficial56](/rajamandalofficial56) since u iterate over N elements with prices.map, and for each elements u call Math.max(...prices.slice) u need approx additional 1/2N to find maximum. So O(n) = n^2"
                    },
                    {
                        "username": "rajamandalofficial56",
                        "content": " let max = 0;\\n\\n    prices.map((el,index) => {\\n      let tem =  Math.max(...prices.slice(index))\\n      if(el< tem){\\n         if(max< tem-el){\\n             max = tem-el\\n         }\\n      }\\n    })\\n    return max\\n\\nError : Time Limit Exceeded\\n\\nO(n) complexity\\nwhat\\'s wrong this approach? "
                    },
                    {
                        "username": "htooak2014",
                        "content": "me too. time limit error occurs. why? leetcode compiler error?"
                    },
                    {
                        "username": "drmolenhouse",
                        "content": "Same issue, using the LeetCode Official solution lmao. What am I paying $35/month for?"
                    },
                    {
                        "username": "user4387LF",
                        "content": "Because you may be using a brute force approach with two loops checking every combination which takes O(n2) time; Cause it exceeds time limit. Optimize your code. Think to solve it in one pass with one loop in linear time."
                    },
                    {
                        "username": "Sahil481",
                        "content": "Your code is not well optimised. It is not ran within the given time limit."
                    },
                    {
                        "username": "pstrait",
                        "content": "Are you doing it with more than one loop? If so, there\\'s a better solution that has O(n) time complexity"
                    },
                    {
                        "username": "leet_code_master",
                        "content": "prices = [2, 4, 1]\\n\\nOutput: 0\\nExpected: 2\\n\\nYou buy on day three but cannot sell because it is the last day. Should that not be zero?"
                    },
                    {
                        "username": "langhudson870",
                        "content": "You should buy on day 1 and sell on day 2"
                    },
                    {
                        "username": "almaas21",
                        "content": "[@user4391xh](/user4391xh) \\nthe output required is max profit through traversing  in the list, it could be adjacent too like in [2,4,1] max_profit here is 2 not 0"
                    },
                    {
                        "username": "ashish_bhosale848",
                        "content": "Yes , I am facing the same issue at case 154"
                    },
                    {
                        "username": "user4391xh",
                        "content": "According to the example 2 \\n(Input: prices = [7,6,4,3,1]\\nOutput: 0\\nExplanation: In this case, no transactions are done and the max profit = 0.)\\nin the task description, 0 should be returned so looks like tests expect incorrect value here.."
                    },
                    {
                        "username": "kaushit",
                        "content": "[@mp9508](/mp9508) I also done the same thing but if that solution is wrong then what approach should we think."
                    },
                    {
                        "username": "shubhamDhapola",
                        "content": "you buy on the first day and sell on the second"
                    },
                    {
                        "username": "sazuki",
                        "content": "[@mp9508](/mp9508) This happend to me too, because ahahah well, the first value that is taken is the min() so basically 1, but this is the last one because that will end in a 0 output. "
                    },
                    {
                        "username": "HarshitBansal122",
                        "content": "buy on first day and sell on second day makes profit 2 "
                    },
                    {
                        "username": "Dan_A_S",
                        "content": "[@mkv1892](/mkv1892) I don\\'t agree with that (except if the explanation of the problem is not correct). What I understood from the explanation is, you buy when the price is cheapest and sell on a later date when you can maximize profit (meaning the highest prize on a later date from the date of purchase). Going by that, you buy at 1 so the output should be zero and not the expected 2."
                    },
                    {
                        "username": "mkv1892",
                        "content": "No, Here you buy at day 1, Where the buy price is 2 and sell at day 2, Where the sell price is 4."
                    },
                    {
                        "username": "Byas_Yadav",
                        "content": "[@mp9508](/mp9508) you buy on day 1 and sell it on day 2 i.e. profit =sell-buy --> 4-2=2"
                    },
                    {
                        "username": "mp9508",
                        "content": "[@leet_code_master](/leet_code_master) happened the same to me . the approach i took is:\\nfind the minimum element and then maxi=mini then use a loop from the next index of the lowest mini element and then find maxi, then return the output.\\nhope this helps\\n"
                    },
                    {
                        "username": "VaishaliChauhan",
                        "content": "We need to maximize profit, you can buy at 2 and sell on 4, giving a profit of 2"
                    },
                    {
                        "username": "IbrahimJunior",
                        "content": "you have to maintain your profit in a variable and only change the variable if the new profit is greater than the previous one, so for this scenario, 2 is the former profit, 0 is the new one, it is not greater than 2 so you don\\'t change your profit."
                    },
                    {
                        "username": "Hanagaki_Takimichy",
                        "content": "buy = 2 and sell = 4 profit = 2\\ni am facing the same problem bro............."
                    },
                    {
                        "username": "MatsRivel",
                        "content": "[@leet_code_master](/leet_code_master) What I did was look at what the largest value after i is for each i, and what the smallest value is before each i. Then, for each i, i subtract smallest from largest. This is your optimal profit for buying before i and selling after i. Now you just find the largest number out of these, and you\\'re done."
                    },
                    {
                        "username": "leet_code_master",
                        "content": "[@MeriemA](/MeriemA) I see. Thank you :) How do you recommend I go about this? Because now the new code I make messes up the second test case."
                    },
                    {
                        "username": "MeriemA",
                        "content": "Actually,  the idea here is how you can make the maximum of profits. You don\\'t have to buy the stock when it\\'s at its lowest price.\\nHere you can buy the first day and sell the second day and still make a profit which is 2.\\n"
                    },
                    {
                        "username": "EXLsunshine",
                        "content": "Why is this problem tagged with \"Dynamic programming\"?"
                    },
                    {
                        "username": "princebillygk2",
                        "content": "[@aryan14decsingh](/aryan14decsingh) The problem can be solved in Dynamic way but the more efficient way is array traversal approach."
                    },
                    {
                        "username": "Mrinal2100",
                        "content": "It should be tagged as two pointer problem"
                    },
                    {
                        "username": "aryan14decsingh",
                        "content": "Because it is Dynamic  ( debatable ) \\nquestion apart , did you get any job by now ? you posted this on 2015 , if you are still alive let me know if you got any jobs and some tips aswell"
                    },
                    {
                        "username": "djslim",
                        "content": "[@sourov1407](/sourov1407)  tbh it\\'s classic greedy problem, interestingly in leetcode 75 they marked it as greedy"
                    },
                    {
                        "username": "sahle123",
                        "content": "[@AdityaBhate](/AdityaBhate) He/she was asking a question, not for a solution."
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# \\uD83D\\uDEA9Easy C++ O(N) Soln. [ FAANG\\uD83D\\uDE31 Interview Optimized code ]\\n\\nhttps://leetcode.com/problems/best-time-to-buy-and-sell-stock/solutions/2822579/easy-c-o-n-soln-faang-interview-optimized-code/\\n\\n"
                    },
                    {
                        "username": "sourov1407",
                        "content": "Because we can use kadene\\'s algorithm here and as it is widely regarded as dp algorithm so yeah this problem is tagged with dynamic programming"
                    },
                    {
                        "username": "casper07",
                        "content": "I am So dumb...."
                    },
                    {
                        "username": "ydumar",
                        "content": "same bruh"
                    },
                    {
                        "username": "savagesam343",
                        "content": "me too bro, me too..."
                    },
                    {
                        "username": "night07",
                        "content": "me too jit"
                    },
                    {
                        "username": "AlgoEngine",
                        "content": "Video visualizing an intuitive proof of the O(n) solution:\nhttps://youtube.com/watch?v=ioFPBdChabY"
                    },
                    {
                        "username": "astek14",
                        "content": "Thanks it\\'s awesome"
                    },
                    {
                        "username": "shilbabun491",
                        "content": "how to resolve the time exceeded issue? Mine fails at 200th test case with a large array"
                    },
                    {
                        "username": "akelux",
                        "content": "How to get max profit 4 from input [3,2,6,5,0,3]?"
                    },
                    {
                        "username": "jenil59",
                        "content": "buy at 2 and sell at 6"
                    },
                    {
                        "username": "Trinto_610",
                        "content": "damn bro 2013"
                    },
                    {
                        "username": "prasumitmishra",
                        "content": "3 (buy),  2 (buy) , 6 (sell), 5 (hold), 0 (hold), 3 (hold)\\n-3 -2 + (2*6)\\n= -5 + 12 = 7"
                    },
                    {
                        "username": "KayvanShah1",
                        "content": "by selling on 6 and buying on 0\\nwhich means short selling"
                    },
                    {
                        "username": "bhanureddy7",
                        "content": "2,6"
                    },
                    {
                        "username": "Hanagaki_Takimichy",
                        "content": "buy = 2 and sell = 6"
                    },
                    {
                        "username": "hungkiet244203",
                        "content": "[@jannatbushra524](/jannatbushra524) yeah but the profit it provides isnt\\n"
                    },
                    {
                        "username": "MatsRivel",
                        "content": "[@jannatbushra524](/jannatbushra524) Buy at 0, then you have to sell after zero, so the best sell price is 3. 3-0 = 3, 6-2=4"
                    },
                    {
                        "username": "ajjha7203",
                        "content": "6-2 = 4"
                    },
                    {
                        "username": "damajsam93",
                        "content": "6-2 ==> 4 "
                    },
                    {
                        "username": "Jagdeep4485",
                        "content": "6-2= 4"
                    },
                    {
                        "username": "jannatbushra524",
                        "content": "[@rajanhossainkhan](/rajanhossainkhan) isn\\'t \\'0\\' a buy_price ??...and its smallest too."
                    },
                    {
                        "username": "rajanhossainkhan",
                        "content": "Here are the steps - \\n\\n1. First buy out price is 3 and profit is set to 0. \\n2. Now loop through array from index 1, since index 0 (which is 3) is taken as minimum buy out price for now. \\n3. Now if price is 2, then set this as new buy out price, since its smaller. So our current buy out price is 2. \\n4. Now next price is 6. This is bigger, so sell with current buy out price 2. \\n5. Calculate max profit  = max(profit, ( current_price - buy_price) \\n6. In this case, max(0, 6-2) = 4\\n\\nHope this helps. "
                    },
                    {
                        "username": "Amit_Joe",
                        "content": "2 -6\\n"
                    },
                    {
                        "username": "hemantgautam505",
                        "content": "output is 4\\n"
                    },
                    {
                        "username": "Shashi3k",
                        "content": "2-6\\n"
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for February, Day 1.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  **📌 Do you want to learn the problem thoroughly?**\n  Read [**⭐  LeetCode Official Solution⭐**](https://leetcode.com/problems/best-time-to-buy-and-sell-stock/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 2 approaches in the official solution</summary>\n\n  \n**Approach 1:** Brute Force\n\n  \n**Approach 2:** One Pass\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# \\uD83D\\uDEA9Easy C++ O(N) Soln. [ FAANG\\uD83D\\uDE31 Interview Optimized code ]\\n\\nhttps://leetcode.com/problems/best-time-to-buy-and-sell-stock/solutions/2822579/easy-c-o-n-soln-faang-interview-optimized-code/\\n"
                    }
                ]
            },
            {
                "id": 1575902,
                "content": [
                    {
                        "username": "Serosidium",
                        "content": "I couldn\\'t find any good explanations here and only code, so I will do my best to explain how I solved it without providing code. I am sure there are other possible solutions, but this is how it worked for me.\\n\\nThe brute force method of a double for loop is not necessary here, and this problem is marked with dynamic programming because it requires the [Sliding Window technique](https://algorithm-visualizer.org/dynamic-programming/sliding-window).\\n\\nBased on the fact that we have to sell after we buy and we are trying to maximize profit, we can iterate through the prices and only need to consider two things:\\n1.) **Is this price cheaper than any other price I\\'ve seen before?** \\n2.) If I subtract current price by the cheapest price I\\'ve found, **does this yield a greater profit than what I\\'ve seen so far?**\\n\\n*A fun thing to note is if #1 is true, then #2 cannot be true as well so there isn\\'t a need to check*\\n\\nLet\\'s consider an example of [4,1,5,2,7]\\n- 4 is the cheapest price we see to start, and we can\\'t sell on the first day so maxProfit is 0\\n- 1 is now the cheapest price we\\'ve seen. Selling now would lose us money, so we can\\'t update maxProfit\\n- 5 is not cheaper than 1, but if we sell now we get a maxProfit of 4! Better save that for later\\n- 2 is not cheaper than 1 and if we sell, we only get a profit of 1, no need to do anything here\\n- 7 is not cheaper than 1, but if we sell here, we\\'ll increase maxProfit to 6, making this the best profit to return.\\n\\nHope this helps someone else!\\n"
                    },
                    {
                        "username": "Manidgyf_6",
                        "content": "Thank you bro"
                    },
                    {
                        "username": "lorentzimys",
                        "content": "Awesome solution, thanks!"
                    },
                    {
                        "username": "Khoa268",
                        "content": "thanks for sharing!"
                    },
                    {
                        "username": "omeh-a",
                        "content": "This is not a DP solution as described, it is greedy"
                    },
                    {
                        "username": "ankitk742",
                        "content": "Thanks bro for your help without code really appreciate "
                    },
                    {
                        "username": "245120733119",
                        "content": "Brilliant!! Thanks for sharing!!"
                    },
                    {
                        "username": "Aniket_sggs",
                        "content": "Initially, this seemed to be DP problem. but after reading this description it is clear that this is basic problem with greedy solution."
                    },
                    {
                        "username": "duffinson97",
                        "content": "Thank you for not posting code, I don\\'t understand the sliding window technique or how this applies to that. I google it and the image link to this problem doesn\\'t make a lot of sense to me. But this solution works thanks"
                    },
                    {
                        "username": "typranjal1",
                        "content": "Thank you!."
                    },
                    {
                        "username": "jakho100",
                        "content": "was stuck on it for hours, thanks for the simple explanation! "
                    },
                    {
                        "username": "zafeer_rangoonwala",
                        "content": "I was originally not able to solve it but after reading your thought process it was a cake walk! \\n\\nThanks! "
                    },
                    {
                        "username": "mohammed1212345",
                        "content": "thank for helping out"
                    },
                    {
                        "username": "dungtuanuet",
                        "content": "Exellent explaination!"
                    },
                    {
                        "username": "kcleland18",
                        "content": "This was a great explanation!! Thanks!"
                    },
                    {
                        "username": "as358",
                        "content": "Best Explanation ever !!!"
                    },
                    {
                        "username": "user6798sW",
                        "content": "AWESOME BREAKDOWN! Ty"
                    },
                    {
                        "username": "jaydeep-pro",
                        "content": "[@evoniuk](/evoniuk) exactly! "
                    },
                    {
                        "username": "akshaydusad",
                        "content": "okay this is genius and surprisingly easier to follow!"
                    },
                    {
                        "username": "evoniuk",
                        "content": "Thank you! This is a solution that\\'s so simple and obvious once you see it you kick yourself for not thinking of it yourself!"
                    },
                    {
                        "username": "ivantchev",
                        "content": "How would the original wording of the problem have to be modified so that the double loop solution _has_ to be used?"
                    },
                    {
                        "username": "ivantchev",
                        "content": "Very helpful, thank you! To add: the reason why using your point 1.) works as a valid check is because given the problem constraints, it will always yield a higher profit down the line regardless of future values.\\n\\nAnd point  2.) shows we don\\'t need a second loop.\\n\\nI wonder, can any concrete aspect of the problem  be used as a clue so that we can reach Serosidium\\'s solution  independently. "
                    },
                    {
                        "username": "VishnuKesav",
                        "content": "[@sharpsailor](/sharpsailor) our target is to get highest possible profit.\\nYou are focusing on buying for the lowest price alone. No matter how low the price is, buying on a last day will yield 0 profit.\\n"
                    },
                    {
                        "username": "kaushar",
                        "content": "[@tengxianrui](/tengxianrui) Thanks  !"
                    },
                    {
                        "username": "neelimag459",
                        "content": "Thank you so much for such good explanation. Happy coding."
                    },
                    {
                        "username": "Nbs-26",
                        "content": "Thank u brother. Your explanation is very clear and well defined."
                    },
                    {
                        "username": "Dabchinsky",
                        "content": "[@sharpsailor](/sharpsailor) if we buy on 2 and sell on 4, our profit would be 4 - 2 = 2. "
                    },
                    {
                        "username": "sharpsailor",
                        "content": "check for {2,4,1} ideally it should give 0 but leetcode gives 2..Help me figure out where am I getting it wrong\\n"
                    },
                    {
                        "username": "jackbb147",
                        "content": "that\\'s actually very smart... thanks"
                    },
                    {
                        "username": "chiahao1",
                        "content": "Thank you! Your technique worked for me."
                    },
                    {
                        "username": "Marre-86",
                        "content": "Man, you made my day! I spent two hours and wrote almost 100 hundred lines code that probably was soving it but had \"time limit exceeded\" with huge input. And after your explanation I rewrite it in freaking 7 lines and it made it right off the bat!"
                    },
                    {
                        "username": "m1ma087",
                        "content": "Best tip! Thanks!"
                    },
                    {
                        "username": "sasaalina1985",
                        "content": "was reading this and solved the problem first try! Very good explanation!!!"
                    },
                    {
                        "username": "Yash_6207",
                        "content": "This is what we call as Greedy ! Good Explanation\\n"
                    },
                    {
                        "username": "iosifpetrupuha",
                        "content": "[@fjod](/fjod) but it\\'s buy day that should be before then sellday"
                    },
                    {
                        "username": "iosifpetrupuha",
                        "content": "[@iosifpetrupuha](/iosifpetrupuha) daaamn there is no indentation in this comment section"
                    },
                    {
                        "username": "iosifpetrupuha",
                        "content": "so I didn\\'t know this was called sliding window or sumthin, but I am second year at CS university, i have some grasp of this kind of logic and I solved it this way:\\nclass Solution:\\n    def maxProfit(self, prices: List[int]) -> int:\\n        #you obviously must buy before you sell(can\\'t go back in time)\\n        GreatestProfit=0\\n        priceToBeat=prices[0]\\n        for i in range(len(prices)-1):#we can iterate through the whole list, otherwise we get out of bounds, so we iterate from the first to the penultimate (so the last comparation we do is between the penultimate and the last element) \\n            if prices[i]<prices[i+1]:#sure profit, possible greatest profit\\n                if prices[i]<=priceToBeat:\\n                    priceToBeat=prices[i]\\n                if GreatestProfit<=prices[i+1]-priceToBeat: #if the GreatestProfit we calculate is greater than the one we have already, we update the Greatest Profit, otherwise we do nothing\\n                    GreatestProfit=prices[i+1]-priceToBeat\\n        return GreatestProfit\\nis this a proper way to solve this kind of problems? (in terms of efficiency I think we\\'re in O(n) so it should be pretty good"
                    },
                    {
                        "username": "Rohit_8412",
                        "content": "Thanks, I was about to see the solution after 10 min I didn\\'t get an approach into my mind.\\nThen I saw your discussion and I solved the question myself \\uD83D\\uDE0E"
                    },
                    {
                        "username": "fjod",
                        "content": "your explanation does not include rule of sellDay must be after buyDay"
                    },
                    {
                        "username": "Hanagaki_Takimichy",
                        "content": "thanks for great explaination without any spoilers.\\ni will try my best for the code, thanks a lot ;)"
                    },
                    {
                        "username": "csrnontol",
                        "content": "Sounds good, but I think your tip fails for [2,9,3,4,5,1,7] (how you\\'d choose 2, 9) and [2,9,3,4,5,1,7,10] (how you\\'d choose 1, 10)."
                    },
                    {
                        "username": "rockmanex",
                        "content": "best explanations so far. Thankyou it\\'s help a lot"
                    },
                    {
                        "username": "ak67",
                        "content": "I think this problem should be catogarise as medium level problem\\n"
                    },
                    {
                        "username": "Sultan_Ul_Arfin",
                        "content": "[@chazwinter](/chazwinter) what is sliding window? I never heard it ..will you explain that please<3\\n "
                    },
                    {
                        "username": "chazwinter",
                        "content": "It doesn\\'t require DP though. You only think it\\'s harder than it is because you\\'re overthinking it. You can use sliding window and just keep track of the lowest price as you go."
                    },
                    {
                        "username": "rwatso",
                        "content": "[@lucky_nik77](/lucky_nik77) Because by its very nature DP is not a beginner / easy level topic."
                    },
                    {
                        "username": "Vectorido",
                        "content": "[@lucky_nik77](/lucky_nik77) This is not hard for simple lists. But all people here usually stuck at TimeLimit error. So algorithm should be another, at least medium level of complexity."
                    },
                    {
                        "username": "lucky_nik77",
                        "content": "But why? It is hard to think about a DP problem that would be easier than this."
                    },
                    {
                        "username": "tiwarimrutunjay",
                        "content": "agreed"
                    },
                    {
                        "username": "codernoob",
                        "content": "how to resolve the time exceeded issue? Mine fails at 203rd test case with a large array"
                    },
                    {
                        "username": "user4279js",
                        "content": "[@rajamandalofficial56](/rajamandalofficial56) I\\'m not a javascript expert, but probably doing prices.slice(index) is looping 0 -index eachtime ... so you have O(N\\n^2) soltuion overall"
                    },
                    {
                        "username": "Behnoosh",
                        "content": "[@htooak2014](/htooak2014) To me it was occurring when my code had an O(n^2) complexity. Resolving that (to O(n)) solved this problem. I start from the end of the array prices and dynamically find the max value from the end of the array until the current step backwards. This way, at the end of the for loop, we can find the max profit with only one single pass over all entries of the array."
                    },
                    {
                        "username": "eyastaifour",
                        "content": "[@htooak2014](/htooak2014) I am hitting a limit error as well and I believe that it is because I keep on querying max() of the window, but when I think of it the max is either on the first index of the window (as I descend), or somewhere else, in which case, it should be cached as it doesnt change... at least, that\\'s what i am thinking\\n"
                    },
                    {
                        "username": "PercyJia95",
                        "content": "[@rajamandalofficial56](/rajamandalofficial56) You need to reconsider your variable naming. They carry very few meanings."
                    },
                    {
                        "username": "knotri",
                        "content": "[@rajamandalofficial56](/rajamandalofficial56) since u iterate over N elements with prices.map, and for each elements u call Math.max(...prices.slice) u need approx additional 1/2N to find maximum. So O(n) = n^2"
                    },
                    {
                        "username": "rajamandalofficial56",
                        "content": " let max = 0;\\n\\n    prices.map((el,index) => {\\n      let tem =  Math.max(...prices.slice(index))\\n      if(el< tem){\\n         if(max< tem-el){\\n             max = tem-el\\n         }\\n      }\\n    })\\n    return max\\n\\nError : Time Limit Exceeded\\n\\nO(n) complexity\\nwhat\\'s wrong this approach? "
                    },
                    {
                        "username": "htooak2014",
                        "content": "me too. time limit error occurs. why? leetcode compiler error?"
                    },
                    {
                        "username": "drmolenhouse",
                        "content": "Same issue, using the LeetCode Official solution lmao. What am I paying $35/month for?"
                    },
                    {
                        "username": "user4387LF",
                        "content": "Because you may be using a brute force approach with two loops checking every combination which takes O(n2) time; Cause it exceeds time limit. Optimize your code. Think to solve it in one pass with one loop in linear time."
                    },
                    {
                        "username": "Sahil481",
                        "content": "Your code is not well optimised. It is not ran within the given time limit."
                    },
                    {
                        "username": "pstrait",
                        "content": "Are you doing it with more than one loop? If so, there\\'s a better solution that has O(n) time complexity"
                    },
                    {
                        "username": "leet_code_master",
                        "content": "prices = [2, 4, 1]\\n\\nOutput: 0\\nExpected: 2\\n\\nYou buy on day three but cannot sell because it is the last day. Should that not be zero?"
                    },
                    {
                        "username": "langhudson870",
                        "content": "You should buy on day 1 and sell on day 2"
                    },
                    {
                        "username": "almaas21",
                        "content": "[@user4391xh](/user4391xh) \\nthe output required is max profit through traversing  in the list, it could be adjacent too like in [2,4,1] max_profit here is 2 not 0"
                    },
                    {
                        "username": "ashish_bhosale848",
                        "content": "Yes , I am facing the same issue at case 154"
                    },
                    {
                        "username": "user4391xh",
                        "content": "According to the example 2 \\n(Input: prices = [7,6,4,3,1]\\nOutput: 0\\nExplanation: In this case, no transactions are done and the max profit = 0.)\\nin the task description, 0 should be returned so looks like tests expect incorrect value here.."
                    },
                    {
                        "username": "kaushit",
                        "content": "[@mp9508](/mp9508) I also done the same thing but if that solution is wrong then what approach should we think."
                    },
                    {
                        "username": "shubhamDhapola",
                        "content": "you buy on the first day and sell on the second"
                    },
                    {
                        "username": "sazuki",
                        "content": "[@mp9508](/mp9508) This happend to me too, because ahahah well, the first value that is taken is the min() so basically 1, but this is the last one because that will end in a 0 output. "
                    },
                    {
                        "username": "HarshitBansal122",
                        "content": "buy on first day and sell on second day makes profit 2 "
                    },
                    {
                        "username": "Dan_A_S",
                        "content": "[@mkv1892](/mkv1892) I don\\'t agree with that (except if the explanation of the problem is not correct). What I understood from the explanation is, you buy when the price is cheapest and sell on a later date when you can maximize profit (meaning the highest prize on a later date from the date of purchase). Going by that, you buy at 1 so the output should be zero and not the expected 2."
                    },
                    {
                        "username": "mkv1892",
                        "content": "No, Here you buy at day 1, Where the buy price is 2 and sell at day 2, Where the sell price is 4."
                    },
                    {
                        "username": "Byas_Yadav",
                        "content": "[@mp9508](/mp9508) you buy on day 1 and sell it on day 2 i.e. profit =sell-buy --> 4-2=2"
                    },
                    {
                        "username": "mp9508",
                        "content": "[@leet_code_master](/leet_code_master) happened the same to me . the approach i took is:\\nfind the minimum element and then maxi=mini then use a loop from the next index of the lowest mini element and then find maxi, then return the output.\\nhope this helps\\n"
                    },
                    {
                        "username": "VaishaliChauhan",
                        "content": "We need to maximize profit, you can buy at 2 and sell on 4, giving a profit of 2"
                    },
                    {
                        "username": "IbrahimJunior",
                        "content": "you have to maintain your profit in a variable and only change the variable if the new profit is greater than the previous one, so for this scenario, 2 is the former profit, 0 is the new one, it is not greater than 2 so you don\\'t change your profit."
                    },
                    {
                        "username": "Hanagaki_Takimichy",
                        "content": "buy = 2 and sell = 4 profit = 2\\ni am facing the same problem bro............."
                    },
                    {
                        "username": "MatsRivel",
                        "content": "[@leet_code_master](/leet_code_master) What I did was look at what the largest value after i is for each i, and what the smallest value is before each i. Then, for each i, i subtract smallest from largest. This is your optimal profit for buying before i and selling after i. Now you just find the largest number out of these, and you\\'re done."
                    },
                    {
                        "username": "leet_code_master",
                        "content": "[@MeriemA](/MeriemA) I see. Thank you :) How do you recommend I go about this? Because now the new code I make messes up the second test case."
                    },
                    {
                        "username": "MeriemA",
                        "content": "Actually,  the idea here is how you can make the maximum of profits. You don\\'t have to buy the stock when it\\'s at its lowest price.\\nHere you can buy the first day and sell the second day and still make a profit which is 2.\\n"
                    },
                    {
                        "username": "EXLsunshine",
                        "content": "Why is this problem tagged with \"Dynamic programming\"?"
                    },
                    {
                        "username": "princebillygk2",
                        "content": "[@aryan14decsingh](/aryan14decsingh) The problem can be solved in Dynamic way but the more efficient way is array traversal approach."
                    },
                    {
                        "username": "Mrinal2100",
                        "content": "It should be tagged as two pointer problem"
                    },
                    {
                        "username": "aryan14decsingh",
                        "content": "Because it is Dynamic  ( debatable ) \\nquestion apart , did you get any job by now ? you posted this on 2015 , if you are still alive let me know if you got any jobs and some tips aswell"
                    },
                    {
                        "username": "djslim",
                        "content": "[@sourov1407](/sourov1407)  tbh it\\'s classic greedy problem, interestingly in leetcode 75 they marked it as greedy"
                    },
                    {
                        "username": "sahle123",
                        "content": "[@AdityaBhate](/AdityaBhate) He/she was asking a question, not for a solution."
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# \\uD83D\\uDEA9Easy C++ O(N) Soln. [ FAANG\\uD83D\\uDE31 Interview Optimized code ]\\n\\nhttps://leetcode.com/problems/best-time-to-buy-and-sell-stock/solutions/2822579/easy-c-o-n-soln-faang-interview-optimized-code/\\n\\n"
                    },
                    {
                        "username": "sourov1407",
                        "content": "Because we can use kadene\\'s algorithm here and as it is widely regarded as dp algorithm so yeah this problem is tagged with dynamic programming"
                    },
                    {
                        "username": "casper07",
                        "content": "I am So dumb...."
                    },
                    {
                        "username": "ydumar",
                        "content": "same bruh"
                    },
                    {
                        "username": "savagesam343",
                        "content": "me too bro, me too..."
                    },
                    {
                        "username": "night07",
                        "content": "me too jit"
                    },
                    {
                        "username": "AlgoEngine",
                        "content": "Video visualizing an intuitive proof of the O(n) solution:\nhttps://youtube.com/watch?v=ioFPBdChabY"
                    },
                    {
                        "username": "astek14",
                        "content": "Thanks it\\'s awesome"
                    },
                    {
                        "username": "shilbabun491",
                        "content": "how to resolve the time exceeded issue? Mine fails at 200th test case with a large array"
                    },
                    {
                        "username": "akelux",
                        "content": "How to get max profit 4 from input [3,2,6,5,0,3]?"
                    },
                    {
                        "username": "jenil59",
                        "content": "buy at 2 and sell at 6"
                    },
                    {
                        "username": "Trinto_610",
                        "content": "damn bro 2013"
                    },
                    {
                        "username": "prasumitmishra",
                        "content": "3 (buy),  2 (buy) , 6 (sell), 5 (hold), 0 (hold), 3 (hold)\\n-3 -2 + (2*6)\\n= -5 + 12 = 7"
                    },
                    {
                        "username": "KayvanShah1",
                        "content": "by selling on 6 and buying on 0\\nwhich means short selling"
                    },
                    {
                        "username": "bhanureddy7",
                        "content": "2,6"
                    },
                    {
                        "username": "Hanagaki_Takimichy",
                        "content": "buy = 2 and sell = 6"
                    },
                    {
                        "username": "hungkiet244203",
                        "content": "[@jannatbushra524](/jannatbushra524) yeah but the profit it provides isnt\\n"
                    },
                    {
                        "username": "MatsRivel",
                        "content": "[@jannatbushra524](/jannatbushra524) Buy at 0, then you have to sell after zero, so the best sell price is 3. 3-0 = 3, 6-2=4"
                    },
                    {
                        "username": "ajjha7203",
                        "content": "6-2 = 4"
                    },
                    {
                        "username": "damajsam93",
                        "content": "6-2 ==> 4 "
                    },
                    {
                        "username": "Jagdeep4485",
                        "content": "6-2= 4"
                    },
                    {
                        "username": "jannatbushra524",
                        "content": "[@rajanhossainkhan](/rajanhossainkhan) isn\\'t \\'0\\' a buy_price ??...and its smallest too."
                    },
                    {
                        "username": "rajanhossainkhan",
                        "content": "Here are the steps - \\n\\n1. First buy out price is 3 and profit is set to 0. \\n2. Now loop through array from index 1, since index 0 (which is 3) is taken as minimum buy out price for now. \\n3. Now if price is 2, then set this as new buy out price, since its smaller. So our current buy out price is 2. \\n4. Now next price is 6. This is bigger, so sell with current buy out price 2. \\n5. Calculate max profit  = max(profit, ( current_price - buy_price) \\n6. In this case, max(0, 6-2) = 4\\n\\nHope this helps. "
                    },
                    {
                        "username": "Amit_Joe",
                        "content": "2 -6\\n"
                    },
                    {
                        "username": "hemantgautam505",
                        "content": "output is 4\\n"
                    },
                    {
                        "username": "Shashi3k",
                        "content": "2-6\\n"
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for February, Day 1.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  **📌 Do you want to learn the problem thoroughly?**\n  Read [**⭐  LeetCode Official Solution⭐**](https://leetcode.com/problems/best-time-to-buy-and-sell-stock/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 2 approaches in the official solution</summary>\n\n  \n**Approach 1:** Brute Force\n\n  \n**Approach 2:** One Pass\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# \\uD83D\\uDEA9Easy C++ O(N) Soln. [ FAANG\\uD83D\\uDE31 Interview Optimized code ]\\n\\nhttps://leetcode.com/problems/best-time-to-buy-and-sell-stock/solutions/2822579/easy-c-o-n-soln-faang-interview-optimized-code/\\n"
                    }
                ]
            },
            {
                "id": 1677787,
                "content": [
                    {
                        "username": "Serosidium",
                        "content": "I couldn\\'t find any good explanations here and only code, so I will do my best to explain how I solved it without providing code. I am sure there are other possible solutions, but this is how it worked for me.\\n\\nThe brute force method of a double for loop is not necessary here, and this problem is marked with dynamic programming because it requires the [Sliding Window technique](https://algorithm-visualizer.org/dynamic-programming/sliding-window).\\n\\nBased on the fact that we have to sell after we buy and we are trying to maximize profit, we can iterate through the prices and only need to consider two things:\\n1.) **Is this price cheaper than any other price I\\'ve seen before?** \\n2.) If I subtract current price by the cheapest price I\\'ve found, **does this yield a greater profit than what I\\'ve seen so far?**\\n\\n*A fun thing to note is if #1 is true, then #2 cannot be true as well so there isn\\'t a need to check*\\n\\nLet\\'s consider an example of [4,1,5,2,7]\\n- 4 is the cheapest price we see to start, and we can\\'t sell on the first day so maxProfit is 0\\n- 1 is now the cheapest price we\\'ve seen. Selling now would lose us money, so we can\\'t update maxProfit\\n- 5 is not cheaper than 1, but if we sell now we get a maxProfit of 4! Better save that for later\\n- 2 is not cheaper than 1 and if we sell, we only get a profit of 1, no need to do anything here\\n- 7 is not cheaper than 1, but if we sell here, we\\'ll increase maxProfit to 6, making this the best profit to return.\\n\\nHope this helps someone else!\\n"
                    },
                    {
                        "username": "Manidgyf_6",
                        "content": "Thank you bro"
                    },
                    {
                        "username": "lorentzimys",
                        "content": "Awesome solution, thanks!"
                    },
                    {
                        "username": "Khoa268",
                        "content": "thanks for sharing!"
                    },
                    {
                        "username": "omeh-a",
                        "content": "This is not a DP solution as described, it is greedy"
                    },
                    {
                        "username": "ankitk742",
                        "content": "Thanks bro for your help without code really appreciate "
                    },
                    {
                        "username": "245120733119",
                        "content": "Brilliant!! Thanks for sharing!!"
                    },
                    {
                        "username": "Aniket_sggs",
                        "content": "Initially, this seemed to be DP problem. but after reading this description it is clear that this is basic problem with greedy solution."
                    },
                    {
                        "username": "duffinson97",
                        "content": "Thank you for not posting code, I don\\'t understand the sliding window technique or how this applies to that. I google it and the image link to this problem doesn\\'t make a lot of sense to me. But this solution works thanks"
                    },
                    {
                        "username": "typranjal1",
                        "content": "Thank you!."
                    },
                    {
                        "username": "jakho100",
                        "content": "was stuck on it for hours, thanks for the simple explanation! "
                    },
                    {
                        "username": "zafeer_rangoonwala",
                        "content": "I was originally not able to solve it but after reading your thought process it was a cake walk! \\n\\nThanks! "
                    },
                    {
                        "username": "mohammed1212345",
                        "content": "thank for helping out"
                    },
                    {
                        "username": "dungtuanuet",
                        "content": "Exellent explaination!"
                    },
                    {
                        "username": "kcleland18",
                        "content": "This was a great explanation!! Thanks!"
                    },
                    {
                        "username": "as358",
                        "content": "Best Explanation ever !!!"
                    },
                    {
                        "username": "user6798sW",
                        "content": "AWESOME BREAKDOWN! Ty"
                    },
                    {
                        "username": "jaydeep-pro",
                        "content": "[@evoniuk](/evoniuk) exactly! "
                    },
                    {
                        "username": "akshaydusad",
                        "content": "okay this is genius and surprisingly easier to follow!"
                    },
                    {
                        "username": "evoniuk",
                        "content": "Thank you! This is a solution that\\'s so simple and obvious once you see it you kick yourself for not thinking of it yourself!"
                    },
                    {
                        "username": "ivantchev",
                        "content": "How would the original wording of the problem have to be modified so that the double loop solution _has_ to be used?"
                    },
                    {
                        "username": "ivantchev",
                        "content": "Very helpful, thank you! To add: the reason why using your point 1.) works as a valid check is because given the problem constraints, it will always yield a higher profit down the line regardless of future values.\\n\\nAnd point  2.) shows we don\\'t need a second loop.\\n\\nI wonder, can any concrete aspect of the problem  be used as a clue so that we can reach Serosidium\\'s solution  independently. "
                    },
                    {
                        "username": "VishnuKesav",
                        "content": "[@sharpsailor](/sharpsailor) our target is to get highest possible profit.\\nYou are focusing on buying for the lowest price alone. No matter how low the price is, buying on a last day will yield 0 profit.\\n"
                    },
                    {
                        "username": "kaushar",
                        "content": "[@tengxianrui](/tengxianrui) Thanks  !"
                    },
                    {
                        "username": "neelimag459",
                        "content": "Thank you so much for such good explanation. Happy coding."
                    },
                    {
                        "username": "Nbs-26",
                        "content": "Thank u brother. Your explanation is very clear and well defined."
                    },
                    {
                        "username": "Dabchinsky",
                        "content": "[@sharpsailor](/sharpsailor) if we buy on 2 and sell on 4, our profit would be 4 - 2 = 2. "
                    },
                    {
                        "username": "sharpsailor",
                        "content": "check for {2,4,1} ideally it should give 0 but leetcode gives 2..Help me figure out where am I getting it wrong\\n"
                    },
                    {
                        "username": "jackbb147",
                        "content": "that\\'s actually very smart... thanks"
                    },
                    {
                        "username": "chiahao1",
                        "content": "Thank you! Your technique worked for me."
                    },
                    {
                        "username": "Marre-86",
                        "content": "Man, you made my day! I spent two hours and wrote almost 100 hundred lines code that probably was soving it but had \"time limit exceeded\" with huge input. And after your explanation I rewrite it in freaking 7 lines and it made it right off the bat!"
                    },
                    {
                        "username": "m1ma087",
                        "content": "Best tip! Thanks!"
                    },
                    {
                        "username": "sasaalina1985",
                        "content": "was reading this and solved the problem first try! Very good explanation!!!"
                    },
                    {
                        "username": "Yash_6207",
                        "content": "This is what we call as Greedy ! Good Explanation\\n"
                    },
                    {
                        "username": "iosifpetrupuha",
                        "content": "[@fjod](/fjod) but it\\'s buy day that should be before then sellday"
                    },
                    {
                        "username": "iosifpetrupuha",
                        "content": "[@iosifpetrupuha](/iosifpetrupuha) daaamn there is no indentation in this comment section"
                    },
                    {
                        "username": "iosifpetrupuha",
                        "content": "so I didn\\'t know this was called sliding window or sumthin, but I am second year at CS university, i have some grasp of this kind of logic and I solved it this way:\\nclass Solution:\\n    def maxProfit(self, prices: List[int]) -> int:\\n        #you obviously must buy before you sell(can\\'t go back in time)\\n        GreatestProfit=0\\n        priceToBeat=prices[0]\\n        for i in range(len(prices)-1):#we can iterate through the whole list, otherwise we get out of bounds, so we iterate from the first to the penultimate (so the last comparation we do is between the penultimate and the last element) \\n            if prices[i]<prices[i+1]:#sure profit, possible greatest profit\\n                if prices[i]<=priceToBeat:\\n                    priceToBeat=prices[i]\\n                if GreatestProfit<=prices[i+1]-priceToBeat: #if the GreatestProfit we calculate is greater than the one we have already, we update the Greatest Profit, otherwise we do nothing\\n                    GreatestProfit=prices[i+1]-priceToBeat\\n        return GreatestProfit\\nis this a proper way to solve this kind of problems? (in terms of efficiency I think we\\'re in O(n) so it should be pretty good"
                    },
                    {
                        "username": "Rohit_8412",
                        "content": "Thanks, I was about to see the solution after 10 min I didn\\'t get an approach into my mind.\\nThen I saw your discussion and I solved the question myself \\uD83D\\uDE0E"
                    },
                    {
                        "username": "fjod",
                        "content": "your explanation does not include rule of sellDay must be after buyDay"
                    },
                    {
                        "username": "Hanagaki_Takimichy",
                        "content": "thanks for great explaination without any spoilers.\\ni will try my best for the code, thanks a lot ;)"
                    },
                    {
                        "username": "csrnontol",
                        "content": "Sounds good, but I think your tip fails for [2,9,3,4,5,1,7] (how you\\'d choose 2, 9) and [2,9,3,4,5,1,7,10] (how you\\'d choose 1, 10)."
                    },
                    {
                        "username": "rockmanex",
                        "content": "best explanations so far. Thankyou it\\'s help a lot"
                    },
                    {
                        "username": "ak67",
                        "content": "I think this problem should be catogarise as medium level problem\\n"
                    },
                    {
                        "username": "Sultan_Ul_Arfin",
                        "content": "[@chazwinter](/chazwinter) what is sliding window? I never heard it ..will you explain that please<3\\n "
                    },
                    {
                        "username": "chazwinter",
                        "content": "It doesn\\'t require DP though. You only think it\\'s harder than it is because you\\'re overthinking it. You can use sliding window and just keep track of the lowest price as you go."
                    },
                    {
                        "username": "rwatso",
                        "content": "[@lucky_nik77](/lucky_nik77) Because by its very nature DP is not a beginner / easy level topic."
                    },
                    {
                        "username": "Vectorido",
                        "content": "[@lucky_nik77](/lucky_nik77) This is not hard for simple lists. But all people here usually stuck at TimeLimit error. So algorithm should be another, at least medium level of complexity."
                    },
                    {
                        "username": "lucky_nik77",
                        "content": "But why? It is hard to think about a DP problem that would be easier than this."
                    },
                    {
                        "username": "tiwarimrutunjay",
                        "content": "agreed"
                    },
                    {
                        "username": "codernoob",
                        "content": "how to resolve the time exceeded issue? Mine fails at 203rd test case with a large array"
                    },
                    {
                        "username": "user4279js",
                        "content": "[@rajamandalofficial56](/rajamandalofficial56) I\\'m not a javascript expert, but probably doing prices.slice(index) is looping 0 -index eachtime ... so you have O(N\\n^2) soltuion overall"
                    },
                    {
                        "username": "Behnoosh",
                        "content": "[@htooak2014](/htooak2014) To me it was occurring when my code had an O(n^2) complexity. Resolving that (to O(n)) solved this problem. I start from the end of the array prices and dynamically find the max value from the end of the array until the current step backwards. This way, at the end of the for loop, we can find the max profit with only one single pass over all entries of the array."
                    },
                    {
                        "username": "eyastaifour",
                        "content": "[@htooak2014](/htooak2014) I am hitting a limit error as well and I believe that it is because I keep on querying max() of the window, but when I think of it the max is either on the first index of the window (as I descend), or somewhere else, in which case, it should be cached as it doesnt change... at least, that\\'s what i am thinking\\n"
                    },
                    {
                        "username": "PercyJia95",
                        "content": "[@rajamandalofficial56](/rajamandalofficial56) You need to reconsider your variable naming. They carry very few meanings."
                    },
                    {
                        "username": "knotri",
                        "content": "[@rajamandalofficial56](/rajamandalofficial56) since u iterate over N elements with prices.map, and for each elements u call Math.max(...prices.slice) u need approx additional 1/2N to find maximum. So O(n) = n^2"
                    },
                    {
                        "username": "rajamandalofficial56",
                        "content": " let max = 0;\\n\\n    prices.map((el,index) => {\\n      let tem =  Math.max(...prices.slice(index))\\n      if(el< tem){\\n         if(max< tem-el){\\n             max = tem-el\\n         }\\n      }\\n    })\\n    return max\\n\\nError : Time Limit Exceeded\\n\\nO(n) complexity\\nwhat\\'s wrong this approach? "
                    },
                    {
                        "username": "htooak2014",
                        "content": "me too. time limit error occurs. why? leetcode compiler error?"
                    },
                    {
                        "username": "drmolenhouse",
                        "content": "Same issue, using the LeetCode Official solution lmao. What am I paying $35/month for?"
                    },
                    {
                        "username": "user4387LF",
                        "content": "Because you may be using a brute force approach with two loops checking every combination which takes O(n2) time; Cause it exceeds time limit. Optimize your code. Think to solve it in one pass with one loop in linear time."
                    },
                    {
                        "username": "Sahil481",
                        "content": "Your code is not well optimised. It is not ran within the given time limit."
                    },
                    {
                        "username": "pstrait",
                        "content": "Are you doing it with more than one loop? If so, there\\'s a better solution that has O(n) time complexity"
                    },
                    {
                        "username": "leet_code_master",
                        "content": "prices = [2, 4, 1]\\n\\nOutput: 0\\nExpected: 2\\n\\nYou buy on day three but cannot sell because it is the last day. Should that not be zero?"
                    },
                    {
                        "username": "langhudson870",
                        "content": "You should buy on day 1 and sell on day 2"
                    },
                    {
                        "username": "almaas21",
                        "content": "[@user4391xh](/user4391xh) \\nthe output required is max profit through traversing  in the list, it could be adjacent too like in [2,4,1] max_profit here is 2 not 0"
                    },
                    {
                        "username": "ashish_bhosale848",
                        "content": "Yes , I am facing the same issue at case 154"
                    },
                    {
                        "username": "user4391xh",
                        "content": "According to the example 2 \\n(Input: prices = [7,6,4,3,1]\\nOutput: 0\\nExplanation: In this case, no transactions are done and the max profit = 0.)\\nin the task description, 0 should be returned so looks like tests expect incorrect value here.."
                    },
                    {
                        "username": "kaushit",
                        "content": "[@mp9508](/mp9508) I also done the same thing but if that solution is wrong then what approach should we think."
                    },
                    {
                        "username": "shubhamDhapola",
                        "content": "you buy on the first day and sell on the second"
                    },
                    {
                        "username": "sazuki",
                        "content": "[@mp9508](/mp9508) This happend to me too, because ahahah well, the first value that is taken is the min() so basically 1, but this is the last one because that will end in a 0 output. "
                    },
                    {
                        "username": "HarshitBansal122",
                        "content": "buy on first day and sell on second day makes profit 2 "
                    },
                    {
                        "username": "Dan_A_S",
                        "content": "[@mkv1892](/mkv1892) I don\\'t agree with that (except if the explanation of the problem is not correct). What I understood from the explanation is, you buy when the price is cheapest and sell on a later date when you can maximize profit (meaning the highest prize on a later date from the date of purchase). Going by that, you buy at 1 so the output should be zero and not the expected 2."
                    },
                    {
                        "username": "mkv1892",
                        "content": "No, Here you buy at day 1, Where the buy price is 2 and sell at day 2, Where the sell price is 4."
                    },
                    {
                        "username": "Byas_Yadav",
                        "content": "[@mp9508](/mp9508) you buy on day 1 and sell it on day 2 i.e. profit =sell-buy --> 4-2=2"
                    },
                    {
                        "username": "mp9508",
                        "content": "[@leet_code_master](/leet_code_master) happened the same to me . the approach i took is:\\nfind the minimum element and then maxi=mini then use a loop from the next index of the lowest mini element and then find maxi, then return the output.\\nhope this helps\\n"
                    },
                    {
                        "username": "VaishaliChauhan",
                        "content": "We need to maximize profit, you can buy at 2 and sell on 4, giving a profit of 2"
                    },
                    {
                        "username": "IbrahimJunior",
                        "content": "you have to maintain your profit in a variable and only change the variable if the new profit is greater than the previous one, so for this scenario, 2 is the former profit, 0 is the new one, it is not greater than 2 so you don\\'t change your profit."
                    },
                    {
                        "username": "Hanagaki_Takimichy",
                        "content": "buy = 2 and sell = 4 profit = 2\\ni am facing the same problem bro............."
                    },
                    {
                        "username": "MatsRivel",
                        "content": "[@leet_code_master](/leet_code_master) What I did was look at what the largest value after i is for each i, and what the smallest value is before each i. Then, for each i, i subtract smallest from largest. This is your optimal profit for buying before i and selling after i. Now you just find the largest number out of these, and you\\'re done."
                    },
                    {
                        "username": "leet_code_master",
                        "content": "[@MeriemA](/MeriemA) I see. Thank you :) How do you recommend I go about this? Because now the new code I make messes up the second test case."
                    },
                    {
                        "username": "MeriemA",
                        "content": "Actually,  the idea here is how you can make the maximum of profits. You don\\'t have to buy the stock when it\\'s at its lowest price.\\nHere you can buy the first day and sell the second day and still make a profit which is 2.\\n"
                    },
                    {
                        "username": "EXLsunshine",
                        "content": "Why is this problem tagged with \"Dynamic programming\"?"
                    },
                    {
                        "username": "princebillygk2",
                        "content": "[@aryan14decsingh](/aryan14decsingh) The problem can be solved in Dynamic way but the more efficient way is array traversal approach."
                    },
                    {
                        "username": "Mrinal2100",
                        "content": "It should be tagged as two pointer problem"
                    },
                    {
                        "username": "aryan14decsingh",
                        "content": "Because it is Dynamic  ( debatable ) \\nquestion apart , did you get any job by now ? you posted this on 2015 , if you are still alive let me know if you got any jobs and some tips aswell"
                    },
                    {
                        "username": "djslim",
                        "content": "[@sourov1407](/sourov1407)  tbh it\\'s classic greedy problem, interestingly in leetcode 75 they marked it as greedy"
                    },
                    {
                        "username": "sahle123",
                        "content": "[@AdityaBhate](/AdityaBhate) He/she was asking a question, not for a solution."
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# \\uD83D\\uDEA9Easy C++ O(N) Soln. [ FAANG\\uD83D\\uDE31 Interview Optimized code ]\\n\\nhttps://leetcode.com/problems/best-time-to-buy-and-sell-stock/solutions/2822579/easy-c-o-n-soln-faang-interview-optimized-code/\\n\\n"
                    },
                    {
                        "username": "sourov1407",
                        "content": "Because we can use kadene\\'s algorithm here and as it is widely regarded as dp algorithm so yeah this problem is tagged with dynamic programming"
                    },
                    {
                        "username": "casper07",
                        "content": "I am So dumb...."
                    },
                    {
                        "username": "ydumar",
                        "content": "same bruh"
                    },
                    {
                        "username": "savagesam343",
                        "content": "me too bro, me too..."
                    },
                    {
                        "username": "night07",
                        "content": "me too jit"
                    },
                    {
                        "username": "AlgoEngine",
                        "content": "Video visualizing an intuitive proof of the O(n) solution:\nhttps://youtube.com/watch?v=ioFPBdChabY"
                    },
                    {
                        "username": "astek14",
                        "content": "Thanks it\\'s awesome"
                    },
                    {
                        "username": "shilbabun491",
                        "content": "how to resolve the time exceeded issue? Mine fails at 200th test case with a large array"
                    },
                    {
                        "username": "akelux",
                        "content": "How to get max profit 4 from input [3,2,6,5,0,3]?"
                    },
                    {
                        "username": "jenil59",
                        "content": "buy at 2 and sell at 6"
                    },
                    {
                        "username": "Trinto_610",
                        "content": "damn bro 2013"
                    },
                    {
                        "username": "prasumitmishra",
                        "content": "3 (buy),  2 (buy) , 6 (sell), 5 (hold), 0 (hold), 3 (hold)\\n-3 -2 + (2*6)\\n= -5 + 12 = 7"
                    },
                    {
                        "username": "KayvanShah1",
                        "content": "by selling on 6 and buying on 0\\nwhich means short selling"
                    },
                    {
                        "username": "bhanureddy7",
                        "content": "2,6"
                    },
                    {
                        "username": "Hanagaki_Takimichy",
                        "content": "buy = 2 and sell = 6"
                    },
                    {
                        "username": "hungkiet244203",
                        "content": "[@jannatbushra524](/jannatbushra524) yeah but the profit it provides isnt\\n"
                    },
                    {
                        "username": "MatsRivel",
                        "content": "[@jannatbushra524](/jannatbushra524) Buy at 0, then you have to sell after zero, so the best sell price is 3. 3-0 = 3, 6-2=4"
                    },
                    {
                        "username": "ajjha7203",
                        "content": "6-2 = 4"
                    },
                    {
                        "username": "damajsam93",
                        "content": "6-2 ==> 4 "
                    },
                    {
                        "username": "Jagdeep4485",
                        "content": "6-2= 4"
                    },
                    {
                        "username": "jannatbushra524",
                        "content": "[@rajanhossainkhan](/rajanhossainkhan) isn\\'t \\'0\\' a buy_price ??...and its smallest too."
                    },
                    {
                        "username": "rajanhossainkhan",
                        "content": "Here are the steps - \\n\\n1. First buy out price is 3 and profit is set to 0. \\n2. Now loop through array from index 1, since index 0 (which is 3) is taken as minimum buy out price for now. \\n3. Now if price is 2, then set this as new buy out price, since its smaller. So our current buy out price is 2. \\n4. Now next price is 6. This is bigger, so sell with current buy out price 2. \\n5. Calculate max profit  = max(profit, ( current_price - buy_price) \\n6. In this case, max(0, 6-2) = 4\\n\\nHope this helps. "
                    },
                    {
                        "username": "Amit_Joe",
                        "content": "2 -6\\n"
                    },
                    {
                        "username": "hemantgautam505",
                        "content": "output is 4\\n"
                    },
                    {
                        "username": "Shashi3k",
                        "content": "2-6\\n"
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for February, Day 1.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  **📌 Do you want to learn the problem thoroughly?**\n  Read [**⭐  LeetCode Official Solution⭐**](https://leetcode.com/problems/best-time-to-buy-and-sell-stock/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 2 approaches in the official solution</summary>\n\n  \n**Approach 1:** Brute Force\n\n  \n**Approach 2:** One Pass\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# \\uD83D\\uDEA9Easy C++ O(N) Soln. [ FAANG\\uD83D\\uDE31 Interview Optimized code ]\\n\\nhttps://leetcode.com/problems/best-time-to-buy-and-sell-stock/solutions/2822579/easy-c-o-n-soln-faang-interview-optimized-code/\\n"
                    }
                ]
            },
            {
                "id": 1665530,
                "content": [
                    {
                        "username": "Serosidium",
                        "content": "I couldn\\'t find any good explanations here and only code, so I will do my best to explain how I solved it without providing code. I am sure there are other possible solutions, but this is how it worked for me.\\n\\nThe brute force method of a double for loop is not necessary here, and this problem is marked with dynamic programming because it requires the [Sliding Window technique](https://algorithm-visualizer.org/dynamic-programming/sliding-window).\\n\\nBased on the fact that we have to sell after we buy and we are trying to maximize profit, we can iterate through the prices and only need to consider two things:\\n1.) **Is this price cheaper than any other price I\\'ve seen before?** \\n2.) If I subtract current price by the cheapest price I\\'ve found, **does this yield a greater profit than what I\\'ve seen so far?**\\n\\n*A fun thing to note is if #1 is true, then #2 cannot be true as well so there isn\\'t a need to check*\\n\\nLet\\'s consider an example of [4,1,5,2,7]\\n- 4 is the cheapest price we see to start, and we can\\'t sell on the first day so maxProfit is 0\\n- 1 is now the cheapest price we\\'ve seen. Selling now would lose us money, so we can\\'t update maxProfit\\n- 5 is not cheaper than 1, but if we sell now we get a maxProfit of 4! Better save that for later\\n- 2 is not cheaper than 1 and if we sell, we only get a profit of 1, no need to do anything here\\n- 7 is not cheaper than 1, but if we sell here, we\\'ll increase maxProfit to 6, making this the best profit to return.\\n\\nHope this helps someone else!\\n"
                    },
                    {
                        "username": "Manidgyf_6",
                        "content": "Thank you bro"
                    },
                    {
                        "username": "lorentzimys",
                        "content": "Awesome solution, thanks!"
                    },
                    {
                        "username": "Khoa268",
                        "content": "thanks for sharing!"
                    },
                    {
                        "username": "omeh-a",
                        "content": "This is not a DP solution as described, it is greedy"
                    },
                    {
                        "username": "ankitk742",
                        "content": "Thanks bro for your help without code really appreciate "
                    },
                    {
                        "username": "245120733119",
                        "content": "Brilliant!! Thanks for sharing!!"
                    },
                    {
                        "username": "Aniket_sggs",
                        "content": "Initially, this seemed to be DP problem. but after reading this description it is clear that this is basic problem with greedy solution."
                    },
                    {
                        "username": "duffinson97",
                        "content": "Thank you for not posting code, I don\\'t understand the sliding window technique or how this applies to that. I google it and the image link to this problem doesn\\'t make a lot of sense to me. But this solution works thanks"
                    },
                    {
                        "username": "typranjal1",
                        "content": "Thank you!."
                    },
                    {
                        "username": "jakho100",
                        "content": "was stuck on it for hours, thanks for the simple explanation! "
                    },
                    {
                        "username": "zafeer_rangoonwala",
                        "content": "I was originally not able to solve it but after reading your thought process it was a cake walk! \\n\\nThanks! "
                    },
                    {
                        "username": "mohammed1212345",
                        "content": "thank for helping out"
                    },
                    {
                        "username": "dungtuanuet",
                        "content": "Exellent explaination!"
                    },
                    {
                        "username": "kcleland18",
                        "content": "This was a great explanation!! Thanks!"
                    },
                    {
                        "username": "as358",
                        "content": "Best Explanation ever !!!"
                    },
                    {
                        "username": "user6798sW",
                        "content": "AWESOME BREAKDOWN! Ty"
                    },
                    {
                        "username": "jaydeep-pro",
                        "content": "[@evoniuk](/evoniuk) exactly! "
                    },
                    {
                        "username": "akshaydusad",
                        "content": "okay this is genius and surprisingly easier to follow!"
                    },
                    {
                        "username": "evoniuk",
                        "content": "Thank you! This is a solution that\\'s so simple and obvious once you see it you kick yourself for not thinking of it yourself!"
                    },
                    {
                        "username": "ivantchev",
                        "content": "How would the original wording of the problem have to be modified so that the double loop solution _has_ to be used?"
                    },
                    {
                        "username": "ivantchev",
                        "content": "Very helpful, thank you! To add: the reason why using your point 1.) works as a valid check is because given the problem constraints, it will always yield a higher profit down the line regardless of future values.\\n\\nAnd point  2.) shows we don\\'t need a second loop.\\n\\nI wonder, can any concrete aspect of the problem  be used as a clue so that we can reach Serosidium\\'s solution  independently. "
                    },
                    {
                        "username": "VishnuKesav",
                        "content": "[@sharpsailor](/sharpsailor) our target is to get highest possible profit.\\nYou are focusing on buying for the lowest price alone. No matter how low the price is, buying on a last day will yield 0 profit.\\n"
                    },
                    {
                        "username": "kaushar",
                        "content": "[@tengxianrui](/tengxianrui) Thanks  !"
                    },
                    {
                        "username": "neelimag459",
                        "content": "Thank you so much for such good explanation. Happy coding."
                    },
                    {
                        "username": "Nbs-26",
                        "content": "Thank u brother. Your explanation is very clear and well defined."
                    },
                    {
                        "username": "Dabchinsky",
                        "content": "[@sharpsailor](/sharpsailor) if we buy on 2 and sell on 4, our profit would be 4 - 2 = 2. "
                    },
                    {
                        "username": "sharpsailor",
                        "content": "check for {2,4,1} ideally it should give 0 but leetcode gives 2..Help me figure out where am I getting it wrong\\n"
                    },
                    {
                        "username": "jackbb147",
                        "content": "that\\'s actually very smart... thanks"
                    },
                    {
                        "username": "chiahao1",
                        "content": "Thank you! Your technique worked for me."
                    },
                    {
                        "username": "Marre-86",
                        "content": "Man, you made my day! I spent two hours and wrote almost 100 hundred lines code that probably was soving it but had \"time limit exceeded\" with huge input. And after your explanation I rewrite it in freaking 7 lines and it made it right off the bat!"
                    },
                    {
                        "username": "m1ma087",
                        "content": "Best tip! Thanks!"
                    },
                    {
                        "username": "sasaalina1985",
                        "content": "was reading this and solved the problem first try! Very good explanation!!!"
                    },
                    {
                        "username": "Yash_6207",
                        "content": "This is what we call as Greedy ! Good Explanation\\n"
                    },
                    {
                        "username": "iosifpetrupuha",
                        "content": "[@fjod](/fjod) but it\\'s buy day that should be before then sellday"
                    },
                    {
                        "username": "iosifpetrupuha",
                        "content": "[@iosifpetrupuha](/iosifpetrupuha) daaamn there is no indentation in this comment section"
                    },
                    {
                        "username": "iosifpetrupuha",
                        "content": "so I didn\\'t know this was called sliding window or sumthin, but I am second year at CS university, i have some grasp of this kind of logic and I solved it this way:\\nclass Solution:\\n    def maxProfit(self, prices: List[int]) -> int:\\n        #you obviously must buy before you sell(can\\'t go back in time)\\n        GreatestProfit=0\\n        priceToBeat=prices[0]\\n        for i in range(len(prices)-1):#we can iterate through the whole list, otherwise we get out of bounds, so we iterate from the first to the penultimate (so the last comparation we do is between the penultimate and the last element) \\n            if prices[i]<prices[i+1]:#sure profit, possible greatest profit\\n                if prices[i]<=priceToBeat:\\n                    priceToBeat=prices[i]\\n                if GreatestProfit<=prices[i+1]-priceToBeat: #if the GreatestProfit we calculate is greater than the one we have already, we update the Greatest Profit, otherwise we do nothing\\n                    GreatestProfit=prices[i+1]-priceToBeat\\n        return GreatestProfit\\nis this a proper way to solve this kind of problems? (in terms of efficiency I think we\\'re in O(n) so it should be pretty good"
                    },
                    {
                        "username": "Rohit_8412",
                        "content": "Thanks, I was about to see the solution after 10 min I didn\\'t get an approach into my mind.\\nThen I saw your discussion and I solved the question myself \\uD83D\\uDE0E"
                    },
                    {
                        "username": "fjod",
                        "content": "your explanation does not include rule of sellDay must be after buyDay"
                    },
                    {
                        "username": "Hanagaki_Takimichy",
                        "content": "thanks for great explaination without any spoilers.\\ni will try my best for the code, thanks a lot ;)"
                    },
                    {
                        "username": "csrnontol",
                        "content": "Sounds good, but I think your tip fails for [2,9,3,4,5,1,7] (how you\\'d choose 2, 9) and [2,9,3,4,5,1,7,10] (how you\\'d choose 1, 10)."
                    },
                    {
                        "username": "rockmanex",
                        "content": "best explanations so far. Thankyou it\\'s help a lot"
                    },
                    {
                        "username": "ak67",
                        "content": "I think this problem should be catogarise as medium level problem\\n"
                    },
                    {
                        "username": "Sultan_Ul_Arfin",
                        "content": "[@chazwinter](/chazwinter) what is sliding window? I never heard it ..will you explain that please<3\\n "
                    },
                    {
                        "username": "chazwinter",
                        "content": "It doesn\\'t require DP though. You only think it\\'s harder than it is because you\\'re overthinking it. You can use sliding window and just keep track of the lowest price as you go."
                    },
                    {
                        "username": "rwatso",
                        "content": "[@lucky_nik77](/lucky_nik77) Because by its very nature DP is not a beginner / easy level topic."
                    },
                    {
                        "username": "Vectorido",
                        "content": "[@lucky_nik77](/lucky_nik77) This is not hard for simple lists. But all people here usually stuck at TimeLimit error. So algorithm should be another, at least medium level of complexity."
                    },
                    {
                        "username": "lucky_nik77",
                        "content": "But why? It is hard to think about a DP problem that would be easier than this."
                    },
                    {
                        "username": "tiwarimrutunjay",
                        "content": "agreed"
                    },
                    {
                        "username": "codernoob",
                        "content": "how to resolve the time exceeded issue? Mine fails at 203rd test case with a large array"
                    },
                    {
                        "username": "user4279js",
                        "content": "[@rajamandalofficial56](/rajamandalofficial56) I\\'m not a javascript expert, but probably doing prices.slice(index) is looping 0 -index eachtime ... so you have O(N\\n^2) soltuion overall"
                    },
                    {
                        "username": "Behnoosh",
                        "content": "[@htooak2014](/htooak2014) To me it was occurring when my code had an O(n^2) complexity. Resolving that (to O(n)) solved this problem. I start from the end of the array prices and dynamically find the max value from the end of the array until the current step backwards. This way, at the end of the for loop, we can find the max profit with only one single pass over all entries of the array."
                    },
                    {
                        "username": "eyastaifour",
                        "content": "[@htooak2014](/htooak2014) I am hitting a limit error as well and I believe that it is because I keep on querying max() of the window, but when I think of it the max is either on the first index of the window (as I descend), or somewhere else, in which case, it should be cached as it doesnt change... at least, that\\'s what i am thinking\\n"
                    },
                    {
                        "username": "PercyJia95",
                        "content": "[@rajamandalofficial56](/rajamandalofficial56) You need to reconsider your variable naming. They carry very few meanings."
                    },
                    {
                        "username": "knotri",
                        "content": "[@rajamandalofficial56](/rajamandalofficial56) since u iterate over N elements with prices.map, and for each elements u call Math.max(...prices.slice) u need approx additional 1/2N to find maximum. So O(n) = n^2"
                    },
                    {
                        "username": "rajamandalofficial56",
                        "content": " let max = 0;\\n\\n    prices.map((el,index) => {\\n      let tem =  Math.max(...prices.slice(index))\\n      if(el< tem){\\n         if(max< tem-el){\\n             max = tem-el\\n         }\\n      }\\n    })\\n    return max\\n\\nError : Time Limit Exceeded\\n\\nO(n) complexity\\nwhat\\'s wrong this approach? "
                    },
                    {
                        "username": "htooak2014",
                        "content": "me too. time limit error occurs. why? leetcode compiler error?"
                    },
                    {
                        "username": "drmolenhouse",
                        "content": "Same issue, using the LeetCode Official solution lmao. What am I paying $35/month for?"
                    },
                    {
                        "username": "user4387LF",
                        "content": "Because you may be using a brute force approach with two loops checking every combination which takes O(n2) time; Cause it exceeds time limit. Optimize your code. Think to solve it in one pass with one loop in linear time."
                    },
                    {
                        "username": "Sahil481",
                        "content": "Your code is not well optimised. It is not ran within the given time limit."
                    },
                    {
                        "username": "pstrait",
                        "content": "Are you doing it with more than one loop? If so, there\\'s a better solution that has O(n) time complexity"
                    },
                    {
                        "username": "leet_code_master",
                        "content": "prices = [2, 4, 1]\\n\\nOutput: 0\\nExpected: 2\\n\\nYou buy on day three but cannot sell because it is the last day. Should that not be zero?"
                    },
                    {
                        "username": "langhudson870",
                        "content": "You should buy on day 1 and sell on day 2"
                    },
                    {
                        "username": "almaas21",
                        "content": "[@user4391xh](/user4391xh) \\nthe output required is max profit through traversing  in the list, it could be adjacent too like in [2,4,1] max_profit here is 2 not 0"
                    },
                    {
                        "username": "ashish_bhosale848",
                        "content": "Yes , I am facing the same issue at case 154"
                    },
                    {
                        "username": "user4391xh",
                        "content": "According to the example 2 \\n(Input: prices = [7,6,4,3,1]\\nOutput: 0\\nExplanation: In this case, no transactions are done and the max profit = 0.)\\nin the task description, 0 should be returned so looks like tests expect incorrect value here.."
                    },
                    {
                        "username": "kaushit",
                        "content": "[@mp9508](/mp9508) I also done the same thing but if that solution is wrong then what approach should we think."
                    },
                    {
                        "username": "shubhamDhapola",
                        "content": "you buy on the first day and sell on the second"
                    },
                    {
                        "username": "sazuki",
                        "content": "[@mp9508](/mp9508) This happend to me too, because ahahah well, the first value that is taken is the min() so basically 1, but this is the last one because that will end in a 0 output. "
                    },
                    {
                        "username": "HarshitBansal122",
                        "content": "buy on first day and sell on second day makes profit 2 "
                    },
                    {
                        "username": "Dan_A_S",
                        "content": "[@mkv1892](/mkv1892) I don\\'t agree with that (except if the explanation of the problem is not correct). What I understood from the explanation is, you buy when the price is cheapest and sell on a later date when you can maximize profit (meaning the highest prize on a later date from the date of purchase). Going by that, you buy at 1 so the output should be zero and not the expected 2."
                    },
                    {
                        "username": "mkv1892",
                        "content": "No, Here you buy at day 1, Where the buy price is 2 and sell at day 2, Where the sell price is 4."
                    },
                    {
                        "username": "Byas_Yadav",
                        "content": "[@mp9508](/mp9508) you buy on day 1 and sell it on day 2 i.e. profit =sell-buy --> 4-2=2"
                    },
                    {
                        "username": "mp9508",
                        "content": "[@leet_code_master](/leet_code_master) happened the same to me . the approach i took is:\\nfind the minimum element and then maxi=mini then use a loop from the next index of the lowest mini element and then find maxi, then return the output.\\nhope this helps\\n"
                    },
                    {
                        "username": "VaishaliChauhan",
                        "content": "We need to maximize profit, you can buy at 2 and sell on 4, giving a profit of 2"
                    },
                    {
                        "username": "IbrahimJunior",
                        "content": "you have to maintain your profit in a variable and only change the variable if the new profit is greater than the previous one, so for this scenario, 2 is the former profit, 0 is the new one, it is not greater than 2 so you don\\'t change your profit."
                    },
                    {
                        "username": "Hanagaki_Takimichy",
                        "content": "buy = 2 and sell = 4 profit = 2\\ni am facing the same problem bro............."
                    },
                    {
                        "username": "MatsRivel",
                        "content": "[@leet_code_master](/leet_code_master) What I did was look at what the largest value after i is for each i, and what the smallest value is before each i. Then, for each i, i subtract smallest from largest. This is your optimal profit for buying before i and selling after i. Now you just find the largest number out of these, and you\\'re done."
                    },
                    {
                        "username": "leet_code_master",
                        "content": "[@MeriemA](/MeriemA) I see. Thank you :) How do you recommend I go about this? Because now the new code I make messes up the second test case."
                    },
                    {
                        "username": "MeriemA",
                        "content": "Actually,  the idea here is how you can make the maximum of profits. You don\\'t have to buy the stock when it\\'s at its lowest price.\\nHere you can buy the first day and sell the second day and still make a profit which is 2.\\n"
                    },
                    {
                        "username": "EXLsunshine",
                        "content": "Why is this problem tagged with \"Dynamic programming\"?"
                    },
                    {
                        "username": "princebillygk2",
                        "content": "[@aryan14decsingh](/aryan14decsingh) The problem can be solved in Dynamic way but the more efficient way is array traversal approach."
                    },
                    {
                        "username": "Mrinal2100",
                        "content": "It should be tagged as two pointer problem"
                    },
                    {
                        "username": "aryan14decsingh",
                        "content": "Because it is Dynamic  ( debatable ) \\nquestion apart , did you get any job by now ? you posted this on 2015 , if you are still alive let me know if you got any jobs and some tips aswell"
                    },
                    {
                        "username": "djslim",
                        "content": "[@sourov1407](/sourov1407)  tbh it\\'s classic greedy problem, interestingly in leetcode 75 they marked it as greedy"
                    },
                    {
                        "username": "sahle123",
                        "content": "[@AdityaBhate](/AdityaBhate) He/she was asking a question, not for a solution."
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# \\uD83D\\uDEA9Easy C++ O(N) Soln. [ FAANG\\uD83D\\uDE31 Interview Optimized code ]\\n\\nhttps://leetcode.com/problems/best-time-to-buy-and-sell-stock/solutions/2822579/easy-c-o-n-soln-faang-interview-optimized-code/\\n\\n"
                    },
                    {
                        "username": "sourov1407",
                        "content": "Because we can use kadene\\'s algorithm here and as it is widely regarded as dp algorithm so yeah this problem is tagged with dynamic programming"
                    },
                    {
                        "username": "casper07",
                        "content": "I am So dumb...."
                    },
                    {
                        "username": "ydumar",
                        "content": "same bruh"
                    },
                    {
                        "username": "savagesam343",
                        "content": "me too bro, me too..."
                    },
                    {
                        "username": "night07",
                        "content": "me too jit"
                    },
                    {
                        "username": "AlgoEngine",
                        "content": "Video visualizing an intuitive proof of the O(n) solution:\nhttps://youtube.com/watch?v=ioFPBdChabY"
                    },
                    {
                        "username": "astek14",
                        "content": "Thanks it\\'s awesome"
                    },
                    {
                        "username": "shilbabun491",
                        "content": "how to resolve the time exceeded issue? Mine fails at 200th test case with a large array"
                    },
                    {
                        "username": "akelux",
                        "content": "How to get max profit 4 from input [3,2,6,5,0,3]?"
                    },
                    {
                        "username": "jenil59",
                        "content": "buy at 2 and sell at 6"
                    },
                    {
                        "username": "Trinto_610",
                        "content": "damn bro 2013"
                    },
                    {
                        "username": "prasumitmishra",
                        "content": "3 (buy),  2 (buy) , 6 (sell), 5 (hold), 0 (hold), 3 (hold)\\n-3 -2 + (2*6)\\n= -5 + 12 = 7"
                    },
                    {
                        "username": "KayvanShah1",
                        "content": "by selling on 6 and buying on 0\\nwhich means short selling"
                    },
                    {
                        "username": "bhanureddy7",
                        "content": "2,6"
                    },
                    {
                        "username": "Hanagaki_Takimichy",
                        "content": "buy = 2 and sell = 6"
                    },
                    {
                        "username": "hungkiet244203",
                        "content": "[@jannatbushra524](/jannatbushra524) yeah but the profit it provides isnt\\n"
                    },
                    {
                        "username": "MatsRivel",
                        "content": "[@jannatbushra524](/jannatbushra524) Buy at 0, then you have to sell after zero, so the best sell price is 3. 3-0 = 3, 6-2=4"
                    },
                    {
                        "username": "ajjha7203",
                        "content": "6-2 = 4"
                    },
                    {
                        "username": "damajsam93",
                        "content": "6-2 ==> 4 "
                    },
                    {
                        "username": "Jagdeep4485",
                        "content": "6-2= 4"
                    },
                    {
                        "username": "jannatbushra524",
                        "content": "[@rajanhossainkhan](/rajanhossainkhan) isn\\'t \\'0\\' a buy_price ??...and its smallest too."
                    },
                    {
                        "username": "rajanhossainkhan",
                        "content": "Here are the steps - \\n\\n1. First buy out price is 3 and profit is set to 0. \\n2. Now loop through array from index 1, since index 0 (which is 3) is taken as minimum buy out price for now. \\n3. Now if price is 2, then set this as new buy out price, since its smaller. So our current buy out price is 2. \\n4. Now next price is 6. This is bigger, so sell with current buy out price 2. \\n5. Calculate max profit  = max(profit, ( current_price - buy_price) \\n6. In this case, max(0, 6-2) = 4\\n\\nHope this helps. "
                    },
                    {
                        "username": "Amit_Joe",
                        "content": "2 -6\\n"
                    },
                    {
                        "username": "hemantgautam505",
                        "content": "output is 4\\n"
                    },
                    {
                        "username": "Shashi3k",
                        "content": "2-6\\n"
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for February, Day 1.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  **📌 Do you want to learn the problem thoroughly?**\n  Read [**⭐  LeetCode Official Solution⭐**](https://leetcode.com/problems/best-time-to-buy-and-sell-stock/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 2 approaches in the official solution</summary>\n\n  \n**Approach 1:** Brute Force\n\n  \n**Approach 2:** One Pass\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# \\uD83D\\uDEA9Easy C++ O(N) Soln. [ FAANG\\uD83D\\uDE31 Interview Optimized code ]\\n\\nhttps://leetcode.com/problems/best-time-to-buy-and-sell-stock/solutions/2822579/easy-c-o-n-soln-faang-interview-optimized-code/\\n"
                    }
                ]
            },
            {
                "id": 1564785,
                "content": [
                    {
                        "username": "Serosidium",
                        "content": "I couldn\\'t find any good explanations here and only code, so I will do my best to explain how I solved it without providing code. I am sure there are other possible solutions, but this is how it worked for me.\\n\\nThe brute force method of a double for loop is not necessary here, and this problem is marked with dynamic programming because it requires the [Sliding Window technique](https://algorithm-visualizer.org/dynamic-programming/sliding-window).\\n\\nBased on the fact that we have to sell after we buy and we are trying to maximize profit, we can iterate through the prices and only need to consider two things:\\n1.) **Is this price cheaper than any other price I\\'ve seen before?** \\n2.) If I subtract current price by the cheapest price I\\'ve found, **does this yield a greater profit than what I\\'ve seen so far?**\\n\\n*A fun thing to note is if #1 is true, then #2 cannot be true as well so there isn\\'t a need to check*\\n\\nLet\\'s consider an example of [4,1,5,2,7]\\n- 4 is the cheapest price we see to start, and we can\\'t sell on the first day so maxProfit is 0\\n- 1 is now the cheapest price we\\'ve seen. Selling now would lose us money, so we can\\'t update maxProfit\\n- 5 is not cheaper than 1, but if we sell now we get a maxProfit of 4! Better save that for later\\n- 2 is not cheaper than 1 and if we sell, we only get a profit of 1, no need to do anything here\\n- 7 is not cheaper than 1, but if we sell here, we\\'ll increase maxProfit to 6, making this the best profit to return.\\n\\nHope this helps someone else!\\n"
                    },
                    {
                        "username": "Manidgyf_6",
                        "content": "Thank you bro"
                    },
                    {
                        "username": "lorentzimys",
                        "content": "Awesome solution, thanks!"
                    },
                    {
                        "username": "Khoa268",
                        "content": "thanks for sharing!"
                    },
                    {
                        "username": "omeh-a",
                        "content": "This is not a DP solution as described, it is greedy"
                    },
                    {
                        "username": "ankitk742",
                        "content": "Thanks bro for your help without code really appreciate "
                    },
                    {
                        "username": "245120733119",
                        "content": "Brilliant!! Thanks for sharing!!"
                    },
                    {
                        "username": "Aniket_sggs",
                        "content": "Initially, this seemed to be DP problem. but after reading this description it is clear that this is basic problem with greedy solution."
                    },
                    {
                        "username": "duffinson97",
                        "content": "Thank you for not posting code, I don\\'t understand the sliding window technique or how this applies to that. I google it and the image link to this problem doesn\\'t make a lot of sense to me. But this solution works thanks"
                    },
                    {
                        "username": "typranjal1",
                        "content": "Thank you!."
                    },
                    {
                        "username": "jakho100",
                        "content": "was stuck on it for hours, thanks for the simple explanation! "
                    },
                    {
                        "username": "zafeer_rangoonwala",
                        "content": "I was originally not able to solve it but after reading your thought process it was a cake walk! \\n\\nThanks! "
                    },
                    {
                        "username": "mohammed1212345",
                        "content": "thank for helping out"
                    },
                    {
                        "username": "dungtuanuet",
                        "content": "Exellent explaination!"
                    },
                    {
                        "username": "kcleland18",
                        "content": "This was a great explanation!! Thanks!"
                    },
                    {
                        "username": "as358",
                        "content": "Best Explanation ever !!!"
                    },
                    {
                        "username": "user6798sW",
                        "content": "AWESOME BREAKDOWN! Ty"
                    },
                    {
                        "username": "jaydeep-pro",
                        "content": "[@evoniuk](/evoniuk) exactly! "
                    },
                    {
                        "username": "akshaydusad",
                        "content": "okay this is genius and surprisingly easier to follow!"
                    },
                    {
                        "username": "evoniuk",
                        "content": "Thank you! This is a solution that\\'s so simple and obvious once you see it you kick yourself for not thinking of it yourself!"
                    },
                    {
                        "username": "ivantchev",
                        "content": "How would the original wording of the problem have to be modified so that the double loop solution _has_ to be used?"
                    },
                    {
                        "username": "ivantchev",
                        "content": "Very helpful, thank you! To add: the reason why using your point 1.) works as a valid check is because given the problem constraints, it will always yield a higher profit down the line regardless of future values.\\n\\nAnd point  2.) shows we don\\'t need a second loop.\\n\\nI wonder, can any concrete aspect of the problem  be used as a clue so that we can reach Serosidium\\'s solution  independently. "
                    },
                    {
                        "username": "VishnuKesav",
                        "content": "[@sharpsailor](/sharpsailor) our target is to get highest possible profit.\\nYou are focusing on buying for the lowest price alone. No matter how low the price is, buying on a last day will yield 0 profit.\\n"
                    },
                    {
                        "username": "kaushar",
                        "content": "[@tengxianrui](/tengxianrui) Thanks  !"
                    },
                    {
                        "username": "neelimag459",
                        "content": "Thank you so much for such good explanation. Happy coding."
                    },
                    {
                        "username": "Nbs-26",
                        "content": "Thank u brother. Your explanation is very clear and well defined."
                    },
                    {
                        "username": "Dabchinsky",
                        "content": "[@sharpsailor](/sharpsailor) if we buy on 2 and sell on 4, our profit would be 4 - 2 = 2. "
                    },
                    {
                        "username": "sharpsailor",
                        "content": "check for {2,4,1} ideally it should give 0 but leetcode gives 2..Help me figure out where am I getting it wrong\\n"
                    },
                    {
                        "username": "jackbb147",
                        "content": "that\\'s actually very smart... thanks"
                    },
                    {
                        "username": "chiahao1",
                        "content": "Thank you! Your technique worked for me."
                    },
                    {
                        "username": "Marre-86",
                        "content": "Man, you made my day! I spent two hours and wrote almost 100 hundred lines code that probably was soving it but had \"time limit exceeded\" with huge input. And after your explanation I rewrite it in freaking 7 lines and it made it right off the bat!"
                    },
                    {
                        "username": "m1ma087",
                        "content": "Best tip! Thanks!"
                    },
                    {
                        "username": "sasaalina1985",
                        "content": "was reading this and solved the problem first try! Very good explanation!!!"
                    },
                    {
                        "username": "Yash_6207",
                        "content": "This is what we call as Greedy ! Good Explanation\\n"
                    },
                    {
                        "username": "iosifpetrupuha",
                        "content": "[@fjod](/fjod) but it\\'s buy day that should be before then sellday"
                    },
                    {
                        "username": "iosifpetrupuha",
                        "content": "[@iosifpetrupuha](/iosifpetrupuha) daaamn there is no indentation in this comment section"
                    },
                    {
                        "username": "iosifpetrupuha",
                        "content": "so I didn\\'t know this was called sliding window or sumthin, but I am second year at CS university, i have some grasp of this kind of logic and I solved it this way:\\nclass Solution:\\n    def maxProfit(self, prices: List[int]) -> int:\\n        #you obviously must buy before you sell(can\\'t go back in time)\\n        GreatestProfit=0\\n        priceToBeat=prices[0]\\n        for i in range(len(prices)-1):#we can iterate through the whole list, otherwise we get out of bounds, so we iterate from the first to the penultimate (so the last comparation we do is between the penultimate and the last element) \\n            if prices[i]<prices[i+1]:#sure profit, possible greatest profit\\n                if prices[i]<=priceToBeat:\\n                    priceToBeat=prices[i]\\n                if GreatestProfit<=prices[i+1]-priceToBeat: #if the GreatestProfit we calculate is greater than the one we have already, we update the Greatest Profit, otherwise we do nothing\\n                    GreatestProfit=prices[i+1]-priceToBeat\\n        return GreatestProfit\\nis this a proper way to solve this kind of problems? (in terms of efficiency I think we\\'re in O(n) so it should be pretty good"
                    },
                    {
                        "username": "Rohit_8412",
                        "content": "Thanks, I was about to see the solution after 10 min I didn\\'t get an approach into my mind.\\nThen I saw your discussion and I solved the question myself \\uD83D\\uDE0E"
                    },
                    {
                        "username": "fjod",
                        "content": "your explanation does not include rule of sellDay must be after buyDay"
                    },
                    {
                        "username": "Hanagaki_Takimichy",
                        "content": "thanks for great explaination without any spoilers.\\ni will try my best for the code, thanks a lot ;)"
                    },
                    {
                        "username": "csrnontol",
                        "content": "Sounds good, but I think your tip fails for [2,9,3,4,5,1,7] (how you\\'d choose 2, 9) and [2,9,3,4,5,1,7,10] (how you\\'d choose 1, 10)."
                    },
                    {
                        "username": "rockmanex",
                        "content": "best explanations so far. Thankyou it\\'s help a lot"
                    },
                    {
                        "username": "ak67",
                        "content": "I think this problem should be catogarise as medium level problem\\n"
                    },
                    {
                        "username": "Sultan_Ul_Arfin",
                        "content": "[@chazwinter](/chazwinter) what is sliding window? I never heard it ..will you explain that please<3\\n "
                    },
                    {
                        "username": "chazwinter",
                        "content": "It doesn\\'t require DP though. You only think it\\'s harder than it is because you\\'re overthinking it. You can use sliding window and just keep track of the lowest price as you go."
                    },
                    {
                        "username": "rwatso",
                        "content": "[@lucky_nik77](/lucky_nik77) Because by its very nature DP is not a beginner / easy level topic."
                    },
                    {
                        "username": "Vectorido",
                        "content": "[@lucky_nik77](/lucky_nik77) This is not hard for simple lists. But all people here usually stuck at TimeLimit error. So algorithm should be another, at least medium level of complexity."
                    },
                    {
                        "username": "lucky_nik77",
                        "content": "But why? It is hard to think about a DP problem that would be easier than this."
                    },
                    {
                        "username": "tiwarimrutunjay",
                        "content": "agreed"
                    },
                    {
                        "username": "codernoob",
                        "content": "how to resolve the time exceeded issue? Mine fails at 203rd test case with a large array"
                    },
                    {
                        "username": "user4279js",
                        "content": "[@rajamandalofficial56](/rajamandalofficial56) I\\'m not a javascript expert, but probably doing prices.slice(index) is looping 0 -index eachtime ... so you have O(N\\n^2) soltuion overall"
                    },
                    {
                        "username": "Behnoosh",
                        "content": "[@htooak2014](/htooak2014) To me it was occurring when my code had an O(n^2) complexity. Resolving that (to O(n)) solved this problem. I start from the end of the array prices and dynamically find the max value from the end of the array until the current step backwards. This way, at the end of the for loop, we can find the max profit with only one single pass over all entries of the array."
                    },
                    {
                        "username": "eyastaifour",
                        "content": "[@htooak2014](/htooak2014) I am hitting a limit error as well and I believe that it is because I keep on querying max() of the window, but when I think of it the max is either on the first index of the window (as I descend), or somewhere else, in which case, it should be cached as it doesnt change... at least, that\\'s what i am thinking\\n"
                    },
                    {
                        "username": "PercyJia95",
                        "content": "[@rajamandalofficial56](/rajamandalofficial56) You need to reconsider your variable naming. They carry very few meanings."
                    },
                    {
                        "username": "knotri",
                        "content": "[@rajamandalofficial56](/rajamandalofficial56) since u iterate over N elements with prices.map, and for each elements u call Math.max(...prices.slice) u need approx additional 1/2N to find maximum. So O(n) = n^2"
                    },
                    {
                        "username": "rajamandalofficial56",
                        "content": " let max = 0;\\n\\n    prices.map((el,index) => {\\n      let tem =  Math.max(...prices.slice(index))\\n      if(el< tem){\\n         if(max< tem-el){\\n             max = tem-el\\n         }\\n      }\\n    })\\n    return max\\n\\nError : Time Limit Exceeded\\n\\nO(n) complexity\\nwhat\\'s wrong this approach? "
                    },
                    {
                        "username": "htooak2014",
                        "content": "me too. time limit error occurs. why? leetcode compiler error?"
                    },
                    {
                        "username": "drmolenhouse",
                        "content": "Same issue, using the LeetCode Official solution lmao. What am I paying $35/month for?"
                    },
                    {
                        "username": "user4387LF",
                        "content": "Because you may be using a brute force approach with two loops checking every combination which takes O(n2) time; Cause it exceeds time limit. Optimize your code. Think to solve it in one pass with one loop in linear time."
                    },
                    {
                        "username": "Sahil481",
                        "content": "Your code is not well optimised. It is not ran within the given time limit."
                    },
                    {
                        "username": "pstrait",
                        "content": "Are you doing it with more than one loop? If so, there\\'s a better solution that has O(n) time complexity"
                    },
                    {
                        "username": "leet_code_master",
                        "content": "prices = [2, 4, 1]\\n\\nOutput: 0\\nExpected: 2\\n\\nYou buy on day three but cannot sell because it is the last day. Should that not be zero?"
                    },
                    {
                        "username": "langhudson870",
                        "content": "You should buy on day 1 and sell on day 2"
                    },
                    {
                        "username": "almaas21",
                        "content": "[@user4391xh](/user4391xh) \\nthe output required is max profit through traversing  in the list, it could be adjacent too like in [2,4,1] max_profit here is 2 not 0"
                    },
                    {
                        "username": "ashish_bhosale848",
                        "content": "Yes , I am facing the same issue at case 154"
                    },
                    {
                        "username": "user4391xh",
                        "content": "According to the example 2 \\n(Input: prices = [7,6,4,3,1]\\nOutput: 0\\nExplanation: In this case, no transactions are done and the max profit = 0.)\\nin the task description, 0 should be returned so looks like tests expect incorrect value here.."
                    },
                    {
                        "username": "kaushit",
                        "content": "[@mp9508](/mp9508) I also done the same thing but if that solution is wrong then what approach should we think."
                    },
                    {
                        "username": "shubhamDhapola",
                        "content": "you buy on the first day and sell on the second"
                    },
                    {
                        "username": "sazuki",
                        "content": "[@mp9508](/mp9508) This happend to me too, because ahahah well, the first value that is taken is the min() so basically 1, but this is the last one because that will end in a 0 output. "
                    },
                    {
                        "username": "HarshitBansal122",
                        "content": "buy on first day and sell on second day makes profit 2 "
                    },
                    {
                        "username": "Dan_A_S",
                        "content": "[@mkv1892](/mkv1892) I don\\'t agree with that (except if the explanation of the problem is not correct). What I understood from the explanation is, you buy when the price is cheapest and sell on a later date when you can maximize profit (meaning the highest prize on a later date from the date of purchase). Going by that, you buy at 1 so the output should be zero and not the expected 2."
                    },
                    {
                        "username": "mkv1892",
                        "content": "No, Here you buy at day 1, Where the buy price is 2 and sell at day 2, Where the sell price is 4."
                    },
                    {
                        "username": "Byas_Yadav",
                        "content": "[@mp9508](/mp9508) you buy on day 1 and sell it on day 2 i.e. profit =sell-buy --> 4-2=2"
                    },
                    {
                        "username": "mp9508",
                        "content": "[@leet_code_master](/leet_code_master) happened the same to me . the approach i took is:\\nfind the minimum element and then maxi=mini then use a loop from the next index of the lowest mini element and then find maxi, then return the output.\\nhope this helps\\n"
                    },
                    {
                        "username": "VaishaliChauhan",
                        "content": "We need to maximize profit, you can buy at 2 and sell on 4, giving a profit of 2"
                    },
                    {
                        "username": "IbrahimJunior",
                        "content": "you have to maintain your profit in a variable and only change the variable if the new profit is greater than the previous one, so for this scenario, 2 is the former profit, 0 is the new one, it is not greater than 2 so you don\\'t change your profit."
                    },
                    {
                        "username": "Hanagaki_Takimichy",
                        "content": "buy = 2 and sell = 4 profit = 2\\ni am facing the same problem bro............."
                    },
                    {
                        "username": "MatsRivel",
                        "content": "[@leet_code_master](/leet_code_master) What I did was look at what the largest value after i is for each i, and what the smallest value is before each i. Then, for each i, i subtract smallest from largest. This is your optimal profit for buying before i and selling after i. Now you just find the largest number out of these, and you\\'re done."
                    },
                    {
                        "username": "leet_code_master",
                        "content": "[@MeriemA](/MeriemA) I see. Thank you :) How do you recommend I go about this? Because now the new code I make messes up the second test case."
                    },
                    {
                        "username": "MeriemA",
                        "content": "Actually,  the idea here is how you can make the maximum of profits. You don\\'t have to buy the stock when it\\'s at its lowest price.\\nHere you can buy the first day and sell the second day and still make a profit which is 2.\\n"
                    },
                    {
                        "username": "EXLsunshine",
                        "content": "Why is this problem tagged with \"Dynamic programming\"?"
                    },
                    {
                        "username": "princebillygk2",
                        "content": "[@aryan14decsingh](/aryan14decsingh) The problem can be solved in Dynamic way but the more efficient way is array traversal approach."
                    },
                    {
                        "username": "Mrinal2100",
                        "content": "It should be tagged as two pointer problem"
                    },
                    {
                        "username": "aryan14decsingh",
                        "content": "Because it is Dynamic  ( debatable ) \\nquestion apart , did you get any job by now ? you posted this on 2015 , if you are still alive let me know if you got any jobs and some tips aswell"
                    },
                    {
                        "username": "djslim",
                        "content": "[@sourov1407](/sourov1407)  tbh it\\'s classic greedy problem, interestingly in leetcode 75 they marked it as greedy"
                    },
                    {
                        "username": "sahle123",
                        "content": "[@AdityaBhate](/AdityaBhate) He/she was asking a question, not for a solution."
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# \\uD83D\\uDEA9Easy C++ O(N) Soln. [ FAANG\\uD83D\\uDE31 Interview Optimized code ]\\n\\nhttps://leetcode.com/problems/best-time-to-buy-and-sell-stock/solutions/2822579/easy-c-o-n-soln-faang-interview-optimized-code/\\n\\n"
                    },
                    {
                        "username": "sourov1407",
                        "content": "Because we can use kadene\\'s algorithm here and as it is widely regarded as dp algorithm so yeah this problem is tagged with dynamic programming"
                    },
                    {
                        "username": "casper07",
                        "content": "I am So dumb...."
                    },
                    {
                        "username": "ydumar",
                        "content": "same bruh"
                    },
                    {
                        "username": "savagesam343",
                        "content": "me too bro, me too..."
                    },
                    {
                        "username": "night07",
                        "content": "me too jit"
                    },
                    {
                        "username": "AlgoEngine",
                        "content": "Video visualizing an intuitive proof of the O(n) solution:\nhttps://youtube.com/watch?v=ioFPBdChabY"
                    },
                    {
                        "username": "astek14",
                        "content": "Thanks it\\'s awesome"
                    },
                    {
                        "username": "shilbabun491",
                        "content": "how to resolve the time exceeded issue? Mine fails at 200th test case with a large array"
                    },
                    {
                        "username": "akelux",
                        "content": "How to get max profit 4 from input [3,2,6,5,0,3]?"
                    },
                    {
                        "username": "jenil59",
                        "content": "buy at 2 and sell at 6"
                    },
                    {
                        "username": "Trinto_610",
                        "content": "damn bro 2013"
                    },
                    {
                        "username": "prasumitmishra",
                        "content": "3 (buy),  2 (buy) , 6 (sell), 5 (hold), 0 (hold), 3 (hold)\\n-3 -2 + (2*6)\\n= -5 + 12 = 7"
                    },
                    {
                        "username": "KayvanShah1",
                        "content": "by selling on 6 and buying on 0\\nwhich means short selling"
                    },
                    {
                        "username": "bhanureddy7",
                        "content": "2,6"
                    },
                    {
                        "username": "Hanagaki_Takimichy",
                        "content": "buy = 2 and sell = 6"
                    },
                    {
                        "username": "hungkiet244203",
                        "content": "[@jannatbushra524](/jannatbushra524) yeah but the profit it provides isnt\\n"
                    },
                    {
                        "username": "MatsRivel",
                        "content": "[@jannatbushra524](/jannatbushra524) Buy at 0, then you have to sell after zero, so the best sell price is 3. 3-0 = 3, 6-2=4"
                    },
                    {
                        "username": "ajjha7203",
                        "content": "6-2 = 4"
                    },
                    {
                        "username": "damajsam93",
                        "content": "6-2 ==> 4 "
                    },
                    {
                        "username": "Jagdeep4485",
                        "content": "6-2= 4"
                    },
                    {
                        "username": "jannatbushra524",
                        "content": "[@rajanhossainkhan](/rajanhossainkhan) isn\\'t \\'0\\' a buy_price ??...and its smallest too."
                    },
                    {
                        "username": "rajanhossainkhan",
                        "content": "Here are the steps - \\n\\n1. First buy out price is 3 and profit is set to 0. \\n2. Now loop through array from index 1, since index 0 (which is 3) is taken as minimum buy out price for now. \\n3. Now if price is 2, then set this as new buy out price, since its smaller. So our current buy out price is 2. \\n4. Now next price is 6. This is bigger, so sell with current buy out price 2. \\n5. Calculate max profit  = max(profit, ( current_price - buy_price) \\n6. In this case, max(0, 6-2) = 4\\n\\nHope this helps. "
                    },
                    {
                        "username": "Amit_Joe",
                        "content": "2 -6\\n"
                    },
                    {
                        "username": "hemantgautam505",
                        "content": "output is 4\\n"
                    },
                    {
                        "username": "Shashi3k",
                        "content": "2-6\\n"
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for February, Day 1.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  **📌 Do you want to learn the problem thoroughly?**\n  Read [**⭐  LeetCode Official Solution⭐**](https://leetcode.com/problems/best-time-to-buy-and-sell-stock/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 2 approaches in the official solution</summary>\n\n  \n**Approach 1:** Brute Force\n\n  \n**Approach 2:** One Pass\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# \\uD83D\\uDEA9Easy C++ O(N) Soln. [ FAANG\\uD83D\\uDE31 Interview Optimized code ]\\n\\nhttps://leetcode.com/problems/best-time-to-buy-and-sell-stock/solutions/2822579/easy-c-o-n-soln-faang-interview-optimized-code/\\n"
                    }
                ]
            },
            {
                "id": 1785221,
                "content": [
                    {
                        "username": "Serosidium",
                        "content": "I couldn\\'t find any good explanations here and only code, so I will do my best to explain how I solved it without providing code. I am sure there are other possible solutions, but this is how it worked for me.\\n\\nThe brute force method of a double for loop is not necessary here, and this problem is marked with dynamic programming because it requires the [Sliding Window technique](https://algorithm-visualizer.org/dynamic-programming/sliding-window).\\n\\nBased on the fact that we have to sell after we buy and we are trying to maximize profit, we can iterate through the prices and only need to consider two things:\\n1.) **Is this price cheaper than any other price I\\'ve seen before?** \\n2.) If I subtract current price by the cheapest price I\\'ve found, **does this yield a greater profit than what I\\'ve seen so far?**\\n\\n*A fun thing to note is if #1 is true, then #2 cannot be true as well so there isn\\'t a need to check*\\n\\nLet\\'s consider an example of [4,1,5,2,7]\\n- 4 is the cheapest price we see to start, and we can\\'t sell on the first day so maxProfit is 0\\n- 1 is now the cheapest price we\\'ve seen. Selling now would lose us money, so we can\\'t update maxProfit\\n- 5 is not cheaper than 1, but if we sell now we get a maxProfit of 4! Better save that for later\\n- 2 is not cheaper than 1 and if we sell, we only get a profit of 1, no need to do anything here\\n- 7 is not cheaper than 1, but if we sell here, we\\'ll increase maxProfit to 6, making this the best profit to return.\\n\\nHope this helps someone else!\\n"
                    },
                    {
                        "username": "Manidgyf_6",
                        "content": "Thank you bro"
                    },
                    {
                        "username": "lorentzimys",
                        "content": "Awesome solution, thanks!"
                    },
                    {
                        "username": "Khoa268",
                        "content": "thanks for sharing!"
                    },
                    {
                        "username": "omeh-a",
                        "content": "This is not a DP solution as described, it is greedy"
                    },
                    {
                        "username": "ankitk742",
                        "content": "Thanks bro for your help without code really appreciate "
                    },
                    {
                        "username": "245120733119",
                        "content": "Brilliant!! Thanks for sharing!!"
                    },
                    {
                        "username": "Aniket_sggs",
                        "content": "Initially, this seemed to be DP problem. but after reading this description it is clear that this is basic problem with greedy solution."
                    },
                    {
                        "username": "duffinson97",
                        "content": "Thank you for not posting code, I don\\'t understand the sliding window technique or how this applies to that. I google it and the image link to this problem doesn\\'t make a lot of sense to me. But this solution works thanks"
                    },
                    {
                        "username": "typranjal1",
                        "content": "Thank you!."
                    },
                    {
                        "username": "jakho100",
                        "content": "was stuck on it for hours, thanks for the simple explanation! "
                    },
                    {
                        "username": "zafeer_rangoonwala",
                        "content": "I was originally not able to solve it but after reading your thought process it was a cake walk! \\n\\nThanks! "
                    },
                    {
                        "username": "mohammed1212345",
                        "content": "thank for helping out"
                    },
                    {
                        "username": "dungtuanuet",
                        "content": "Exellent explaination!"
                    },
                    {
                        "username": "kcleland18",
                        "content": "This was a great explanation!! Thanks!"
                    },
                    {
                        "username": "as358",
                        "content": "Best Explanation ever !!!"
                    },
                    {
                        "username": "user6798sW",
                        "content": "AWESOME BREAKDOWN! Ty"
                    },
                    {
                        "username": "jaydeep-pro",
                        "content": "[@evoniuk](/evoniuk) exactly! "
                    },
                    {
                        "username": "akshaydusad",
                        "content": "okay this is genius and surprisingly easier to follow!"
                    },
                    {
                        "username": "evoniuk",
                        "content": "Thank you! This is a solution that\\'s so simple and obvious once you see it you kick yourself for not thinking of it yourself!"
                    },
                    {
                        "username": "ivantchev",
                        "content": "How would the original wording of the problem have to be modified so that the double loop solution _has_ to be used?"
                    },
                    {
                        "username": "ivantchev",
                        "content": "Very helpful, thank you! To add: the reason why using your point 1.) works as a valid check is because given the problem constraints, it will always yield a higher profit down the line regardless of future values.\\n\\nAnd point  2.) shows we don\\'t need a second loop.\\n\\nI wonder, can any concrete aspect of the problem  be used as a clue so that we can reach Serosidium\\'s solution  independently. "
                    },
                    {
                        "username": "VishnuKesav",
                        "content": "[@sharpsailor](/sharpsailor) our target is to get highest possible profit.\\nYou are focusing on buying for the lowest price alone. No matter how low the price is, buying on a last day will yield 0 profit.\\n"
                    },
                    {
                        "username": "kaushar",
                        "content": "[@tengxianrui](/tengxianrui) Thanks  !"
                    },
                    {
                        "username": "neelimag459",
                        "content": "Thank you so much for such good explanation. Happy coding."
                    },
                    {
                        "username": "Nbs-26",
                        "content": "Thank u brother. Your explanation is very clear and well defined."
                    },
                    {
                        "username": "Dabchinsky",
                        "content": "[@sharpsailor](/sharpsailor) if we buy on 2 and sell on 4, our profit would be 4 - 2 = 2. "
                    },
                    {
                        "username": "sharpsailor",
                        "content": "check for {2,4,1} ideally it should give 0 but leetcode gives 2..Help me figure out where am I getting it wrong\\n"
                    },
                    {
                        "username": "jackbb147",
                        "content": "that\\'s actually very smart... thanks"
                    },
                    {
                        "username": "chiahao1",
                        "content": "Thank you! Your technique worked for me."
                    },
                    {
                        "username": "Marre-86",
                        "content": "Man, you made my day! I spent two hours and wrote almost 100 hundred lines code that probably was soving it but had \"time limit exceeded\" with huge input. And after your explanation I rewrite it in freaking 7 lines and it made it right off the bat!"
                    },
                    {
                        "username": "m1ma087",
                        "content": "Best tip! Thanks!"
                    },
                    {
                        "username": "sasaalina1985",
                        "content": "was reading this and solved the problem first try! Very good explanation!!!"
                    },
                    {
                        "username": "Yash_6207",
                        "content": "This is what we call as Greedy ! Good Explanation\\n"
                    },
                    {
                        "username": "iosifpetrupuha",
                        "content": "[@fjod](/fjod) but it\\'s buy day that should be before then sellday"
                    },
                    {
                        "username": "iosifpetrupuha",
                        "content": "[@iosifpetrupuha](/iosifpetrupuha) daaamn there is no indentation in this comment section"
                    },
                    {
                        "username": "iosifpetrupuha",
                        "content": "so I didn\\'t know this was called sliding window or sumthin, but I am second year at CS university, i have some grasp of this kind of logic and I solved it this way:\\nclass Solution:\\n    def maxProfit(self, prices: List[int]) -> int:\\n        #you obviously must buy before you sell(can\\'t go back in time)\\n        GreatestProfit=0\\n        priceToBeat=prices[0]\\n        for i in range(len(prices)-1):#we can iterate through the whole list, otherwise we get out of bounds, so we iterate from the first to the penultimate (so the last comparation we do is between the penultimate and the last element) \\n            if prices[i]<prices[i+1]:#sure profit, possible greatest profit\\n                if prices[i]<=priceToBeat:\\n                    priceToBeat=prices[i]\\n                if GreatestProfit<=prices[i+1]-priceToBeat: #if the GreatestProfit we calculate is greater than the one we have already, we update the Greatest Profit, otherwise we do nothing\\n                    GreatestProfit=prices[i+1]-priceToBeat\\n        return GreatestProfit\\nis this a proper way to solve this kind of problems? (in terms of efficiency I think we\\'re in O(n) so it should be pretty good"
                    },
                    {
                        "username": "Rohit_8412",
                        "content": "Thanks, I was about to see the solution after 10 min I didn\\'t get an approach into my mind.\\nThen I saw your discussion and I solved the question myself \\uD83D\\uDE0E"
                    },
                    {
                        "username": "fjod",
                        "content": "your explanation does not include rule of sellDay must be after buyDay"
                    },
                    {
                        "username": "Hanagaki_Takimichy",
                        "content": "thanks for great explaination without any spoilers.\\ni will try my best for the code, thanks a lot ;)"
                    },
                    {
                        "username": "csrnontol",
                        "content": "Sounds good, but I think your tip fails for [2,9,3,4,5,1,7] (how you\\'d choose 2, 9) and [2,9,3,4,5,1,7,10] (how you\\'d choose 1, 10)."
                    },
                    {
                        "username": "rockmanex",
                        "content": "best explanations so far. Thankyou it\\'s help a lot"
                    },
                    {
                        "username": "ak67",
                        "content": "I think this problem should be catogarise as medium level problem\\n"
                    },
                    {
                        "username": "Sultan_Ul_Arfin",
                        "content": "[@chazwinter](/chazwinter) what is sliding window? I never heard it ..will you explain that please<3\\n "
                    },
                    {
                        "username": "chazwinter",
                        "content": "It doesn\\'t require DP though. You only think it\\'s harder than it is because you\\'re overthinking it. You can use sliding window and just keep track of the lowest price as you go."
                    },
                    {
                        "username": "rwatso",
                        "content": "[@lucky_nik77](/lucky_nik77) Because by its very nature DP is not a beginner / easy level topic."
                    },
                    {
                        "username": "Vectorido",
                        "content": "[@lucky_nik77](/lucky_nik77) This is not hard for simple lists. But all people here usually stuck at TimeLimit error. So algorithm should be another, at least medium level of complexity."
                    },
                    {
                        "username": "lucky_nik77",
                        "content": "But why? It is hard to think about a DP problem that would be easier than this."
                    },
                    {
                        "username": "tiwarimrutunjay",
                        "content": "agreed"
                    },
                    {
                        "username": "codernoob",
                        "content": "how to resolve the time exceeded issue? Mine fails at 203rd test case with a large array"
                    },
                    {
                        "username": "user4279js",
                        "content": "[@rajamandalofficial56](/rajamandalofficial56) I\\'m not a javascript expert, but probably doing prices.slice(index) is looping 0 -index eachtime ... so you have O(N\\n^2) soltuion overall"
                    },
                    {
                        "username": "Behnoosh",
                        "content": "[@htooak2014](/htooak2014) To me it was occurring when my code had an O(n^2) complexity. Resolving that (to O(n)) solved this problem. I start from the end of the array prices and dynamically find the max value from the end of the array until the current step backwards. This way, at the end of the for loop, we can find the max profit with only one single pass over all entries of the array."
                    },
                    {
                        "username": "eyastaifour",
                        "content": "[@htooak2014](/htooak2014) I am hitting a limit error as well and I believe that it is because I keep on querying max() of the window, but when I think of it the max is either on the first index of the window (as I descend), or somewhere else, in which case, it should be cached as it doesnt change... at least, that\\'s what i am thinking\\n"
                    },
                    {
                        "username": "PercyJia95",
                        "content": "[@rajamandalofficial56](/rajamandalofficial56) You need to reconsider your variable naming. They carry very few meanings."
                    },
                    {
                        "username": "knotri",
                        "content": "[@rajamandalofficial56](/rajamandalofficial56) since u iterate over N elements with prices.map, and for each elements u call Math.max(...prices.slice) u need approx additional 1/2N to find maximum. So O(n) = n^2"
                    },
                    {
                        "username": "rajamandalofficial56",
                        "content": " let max = 0;\\n\\n    prices.map((el,index) => {\\n      let tem =  Math.max(...prices.slice(index))\\n      if(el< tem){\\n         if(max< tem-el){\\n             max = tem-el\\n         }\\n      }\\n    })\\n    return max\\n\\nError : Time Limit Exceeded\\n\\nO(n) complexity\\nwhat\\'s wrong this approach? "
                    },
                    {
                        "username": "htooak2014",
                        "content": "me too. time limit error occurs. why? leetcode compiler error?"
                    },
                    {
                        "username": "drmolenhouse",
                        "content": "Same issue, using the LeetCode Official solution lmao. What am I paying $35/month for?"
                    },
                    {
                        "username": "user4387LF",
                        "content": "Because you may be using a brute force approach with two loops checking every combination which takes O(n2) time; Cause it exceeds time limit. Optimize your code. Think to solve it in one pass with one loop in linear time."
                    },
                    {
                        "username": "Sahil481",
                        "content": "Your code is not well optimised. It is not ran within the given time limit."
                    },
                    {
                        "username": "pstrait",
                        "content": "Are you doing it with more than one loop? If so, there\\'s a better solution that has O(n) time complexity"
                    },
                    {
                        "username": "leet_code_master",
                        "content": "prices = [2, 4, 1]\\n\\nOutput: 0\\nExpected: 2\\n\\nYou buy on day three but cannot sell because it is the last day. Should that not be zero?"
                    },
                    {
                        "username": "langhudson870",
                        "content": "You should buy on day 1 and sell on day 2"
                    },
                    {
                        "username": "almaas21",
                        "content": "[@user4391xh](/user4391xh) \\nthe output required is max profit through traversing  in the list, it could be adjacent too like in [2,4,1] max_profit here is 2 not 0"
                    },
                    {
                        "username": "ashish_bhosale848",
                        "content": "Yes , I am facing the same issue at case 154"
                    },
                    {
                        "username": "user4391xh",
                        "content": "According to the example 2 \\n(Input: prices = [7,6,4,3,1]\\nOutput: 0\\nExplanation: In this case, no transactions are done and the max profit = 0.)\\nin the task description, 0 should be returned so looks like tests expect incorrect value here.."
                    },
                    {
                        "username": "kaushit",
                        "content": "[@mp9508](/mp9508) I also done the same thing but if that solution is wrong then what approach should we think."
                    },
                    {
                        "username": "shubhamDhapola",
                        "content": "you buy on the first day and sell on the second"
                    },
                    {
                        "username": "sazuki",
                        "content": "[@mp9508](/mp9508) This happend to me too, because ahahah well, the first value that is taken is the min() so basically 1, but this is the last one because that will end in a 0 output. "
                    },
                    {
                        "username": "HarshitBansal122",
                        "content": "buy on first day and sell on second day makes profit 2 "
                    },
                    {
                        "username": "Dan_A_S",
                        "content": "[@mkv1892](/mkv1892) I don\\'t agree with that (except if the explanation of the problem is not correct). What I understood from the explanation is, you buy when the price is cheapest and sell on a later date when you can maximize profit (meaning the highest prize on a later date from the date of purchase). Going by that, you buy at 1 so the output should be zero and not the expected 2."
                    },
                    {
                        "username": "mkv1892",
                        "content": "No, Here you buy at day 1, Where the buy price is 2 and sell at day 2, Where the sell price is 4."
                    },
                    {
                        "username": "Byas_Yadav",
                        "content": "[@mp9508](/mp9508) you buy on day 1 and sell it on day 2 i.e. profit =sell-buy --> 4-2=2"
                    },
                    {
                        "username": "mp9508",
                        "content": "[@leet_code_master](/leet_code_master) happened the same to me . the approach i took is:\\nfind the minimum element and then maxi=mini then use a loop from the next index of the lowest mini element and then find maxi, then return the output.\\nhope this helps\\n"
                    },
                    {
                        "username": "VaishaliChauhan",
                        "content": "We need to maximize profit, you can buy at 2 and sell on 4, giving a profit of 2"
                    },
                    {
                        "username": "IbrahimJunior",
                        "content": "you have to maintain your profit in a variable and only change the variable if the new profit is greater than the previous one, so for this scenario, 2 is the former profit, 0 is the new one, it is not greater than 2 so you don\\'t change your profit."
                    },
                    {
                        "username": "Hanagaki_Takimichy",
                        "content": "buy = 2 and sell = 4 profit = 2\\ni am facing the same problem bro............."
                    },
                    {
                        "username": "MatsRivel",
                        "content": "[@leet_code_master](/leet_code_master) What I did was look at what the largest value after i is for each i, and what the smallest value is before each i. Then, for each i, i subtract smallest from largest. This is your optimal profit for buying before i and selling after i. Now you just find the largest number out of these, and you\\'re done."
                    },
                    {
                        "username": "leet_code_master",
                        "content": "[@MeriemA](/MeriemA) I see. Thank you :) How do you recommend I go about this? Because now the new code I make messes up the second test case."
                    },
                    {
                        "username": "MeriemA",
                        "content": "Actually,  the idea here is how you can make the maximum of profits. You don\\'t have to buy the stock when it\\'s at its lowest price.\\nHere you can buy the first day and sell the second day and still make a profit which is 2.\\n"
                    },
                    {
                        "username": "EXLsunshine",
                        "content": "Why is this problem tagged with \"Dynamic programming\"?"
                    },
                    {
                        "username": "princebillygk2",
                        "content": "[@aryan14decsingh](/aryan14decsingh) The problem can be solved in Dynamic way but the more efficient way is array traversal approach."
                    },
                    {
                        "username": "Mrinal2100",
                        "content": "It should be tagged as two pointer problem"
                    },
                    {
                        "username": "aryan14decsingh",
                        "content": "Because it is Dynamic  ( debatable ) \\nquestion apart , did you get any job by now ? you posted this on 2015 , if you are still alive let me know if you got any jobs and some tips aswell"
                    },
                    {
                        "username": "djslim",
                        "content": "[@sourov1407](/sourov1407)  tbh it\\'s classic greedy problem, interestingly in leetcode 75 they marked it as greedy"
                    },
                    {
                        "username": "sahle123",
                        "content": "[@AdityaBhate](/AdityaBhate) He/she was asking a question, not for a solution."
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# \\uD83D\\uDEA9Easy C++ O(N) Soln. [ FAANG\\uD83D\\uDE31 Interview Optimized code ]\\n\\nhttps://leetcode.com/problems/best-time-to-buy-and-sell-stock/solutions/2822579/easy-c-o-n-soln-faang-interview-optimized-code/\\n\\n"
                    },
                    {
                        "username": "sourov1407",
                        "content": "Because we can use kadene\\'s algorithm here and as it is widely regarded as dp algorithm so yeah this problem is tagged with dynamic programming"
                    },
                    {
                        "username": "casper07",
                        "content": "I am So dumb...."
                    },
                    {
                        "username": "ydumar",
                        "content": "same bruh"
                    },
                    {
                        "username": "savagesam343",
                        "content": "me too bro, me too..."
                    },
                    {
                        "username": "night07",
                        "content": "me too jit"
                    },
                    {
                        "username": "AlgoEngine",
                        "content": "Video visualizing an intuitive proof of the O(n) solution:\nhttps://youtube.com/watch?v=ioFPBdChabY"
                    },
                    {
                        "username": "astek14",
                        "content": "Thanks it\\'s awesome"
                    },
                    {
                        "username": "shilbabun491",
                        "content": "how to resolve the time exceeded issue? Mine fails at 200th test case with a large array"
                    },
                    {
                        "username": "akelux",
                        "content": "How to get max profit 4 from input [3,2,6,5,0,3]?"
                    },
                    {
                        "username": "jenil59",
                        "content": "buy at 2 and sell at 6"
                    },
                    {
                        "username": "Trinto_610",
                        "content": "damn bro 2013"
                    },
                    {
                        "username": "prasumitmishra",
                        "content": "3 (buy),  2 (buy) , 6 (sell), 5 (hold), 0 (hold), 3 (hold)\\n-3 -2 + (2*6)\\n= -5 + 12 = 7"
                    },
                    {
                        "username": "KayvanShah1",
                        "content": "by selling on 6 and buying on 0\\nwhich means short selling"
                    },
                    {
                        "username": "bhanureddy7",
                        "content": "2,6"
                    },
                    {
                        "username": "Hanagaki_Takimichy",
                        "content": "buy = 2 and sell = 6"
                    },
                    {
                        "username": "hungkiet244203",
                        "content": "[@jannatbushra524](/jannatbushra524) yeah but the profit it provides isnt\\n"
                    },
                    {
                        "username": "MatsRivel",
                        "content": "[@jannatbushra524](/jannatbushra524) Buy at 0, then you have to sell after zero, so the best sell price is 3. 3-0 = 3, 6-2=4"
                    },
                    {
                        "username": "ajjha7203",
                        "content": "6-2 = 4"
                    },
                    {
                        "username": "damajsam93",
                        "content": "6-2 ==> 4 "
                    },
                    {
                        "username": "Jagdeep4485",
                        "content": "6-2= 4"
                    },
                    {
                        "username": "jannatbushra524",
                        "content": "[@rajanhossainkhan](/rajanhossainkhan) isn\\'t \\'0\\' a buy_price ??...and its smallest too."
                    },
                    {
                        "username": "rajanhossainkhan",
                        "content": "Here are the steps - \\n\\n1. First buy out price is 3 and profit is set to 0. \\n2. Now loop through array from index 1, since index 0 (which is 3) is taken as minimum buy out price for now. \\n3. Now if price is 2, then set this as new buy out price, since its smaller. So our current buy out price is 2. \\n4. Now next price is 6. This is bigger, so sell with current buy out price 2. \\n5. Calculate max profit  = max(profit, ( current_price - buy_price) \\n6. In this case, max(0, 6-2) = 4\\n\\nHope this helps. "
                    },
                    {
                        "username": "Amit_Joe",
                        "content": "2 -6\\n"
                    },
                    {
                        "username": "hemantgautam505",
                        "content": "output is 4\\n"
                    },
                    {
                        "username": "Shashi3k",
                        "content": "2-6\\n"
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for February, Day 1.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  **📌 Do you want to learn the problem thoroughly?**\n  Read [**⭐  LeetCode Official Solution⭐**](https://leetcode.com/problems/best-time-to-buy-and-sell-stock/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 2 approaches in the official solution</summary>\n\n  \n**Approach 1:** Brute Force\n\n  \n**Approach 2:** One Pass\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# \\uD83D\\uDEA9Easy C++ O(N) Soln. [ FAANG\\uD83D\\uDE31 Interview Optimized code ]\\n\\nhttps://leetcode.com/problems/best-time-to-buy-and-sell-stock/solutions/2822579/easy-c-o-n-soln-faang-interview-optimized-code/\\n"
                    }
                ]
            },
            {
                "id": 1880567,
                "content": [
                    {
                        "username": "Serosidium",
                        "content": "I couldn\\'t find any good explanations here and only code, so I will do my best to explain how I solved it without providing code. I am sure there are other possible solutions, but this is how it worked for me.\\n\\nThe brute force method of a double for loop is not necessary here, and this problem is marked with dynamic programming because it requires the [Sliding Window technique](https://algorithm-visualizer.org/dynamic-programming/sliding-window).\\n\\nBased on the fact that we have to sell after we buy and we are trying to maximize profit, we can iterate through the prices and only need to consider two things:\\n1.) **Is this price cheaper than any other price I\\'ve seen before?** \\n2.) If I subtract current price by the cheapest price I\\'ve found, **does this yield a greater profit than what I\\'ve seen so far?**\\n\\n*A fun thing to note is if #1 is true, then #2 cannot be true as well so there isn\\'t a need to check*\\n\\nLet\\'s consider an example of [4,1,5,2,7]\\n- 4 is the cheapest price we see to start, and we can\\'t sell on the first day so maxProfit is 0\\n- 1 is now the cheapest price we\\'ve seen. Selling now would lose us money, so we can\\'t update maxProfit\\n- 5 is not cheaper than 1, but if we sell now we get a maxProfit of 4! Better save that for later\\n- 2 is not cheaper than 1 and if we sell, we only get a profit of 1, no need to do anything here\\n- 7 is not cheaper than 1, but if we sell here, we\\'ll increase maxProfit to 6, making this the best profit to return.\\n\\nHope this helps someone else!\\n"
                    },
                    {
                        "username": "Manidgyf_6",
                        "content": "Thank you bro"
                    },
                    {
                        "username": "lorentzimys",
                        "content": "Awesome solution, thanks!"
                    },
                    {
                        "username": "Khoa268",
                        "content": "thanks for sharing!"
                    },
                    {
                        "username": "omeh-a",
                        "content": "This is not a DP solution as described, it is greedy"
                    },
                    {
                        "username": "ankitk742",
                        "content": "Thanks bro for your help without code really appreciate "
                    },
                    {
                        "username": "245120733119",
                        "content": "Brilliant!! Thanks for sharing!!"
                    },
                    {
                        "username": "Aniket_sggs",
                        "content": "Initially, this seemed to be DP problem. but after reading this description it is clear that this is basic problem with greedy solution."
                    },
                    {
                        "username": "duffinson97",
                        "content": "Thank you for not posting code, I don\\'t understand the sliding window technique or how this applies to that. I google it and the image link to this problem doesn\\'t make a lot of sense to me. But this solution works thanks"
                    },
                    {
                        "username": "typranjal1",
                        "content": "Thank you!."
                    },
                    {
                        "username": "jakho100",
                        "content": "was stuck on it for hours, thanks for the simple explanation! "
                    },
                    {
                        "username": "zafeer_rangoonwala",
                        "content": "I was originally not able to solve it but after reading your thought process it was a cake walk! \\n\\nThanks! "
                    },
                    {
                        "username": "mohammed1212345",
                        "content": "thank for helping out"
                    },
                    {
                        "username": "dungtuanuet",
                        "content": "Exellent explaination!"
                    },
                    {
                        "username": "kcleland18",
                        "content": "This was a great explanation!! Thanks!"
                    },
                    {
                        "username": "as358",
                        "content": "Best Explanation ever !!!"
                    },
                    {
                        "username": "user6798sW",
                        "content": "AWESOME BREAKDOWN! Ty"
                    },
                    {
                        "username": "jaydeep-pro",
                        "content": "[@evoniuk](/evoniuk) exactly! "
                    },
                    {
                        "username": "akshaydusad",
                        "content": "okay this is genius and surprisingly easier to follow!"
                    },
                    {
                        "username": "evoniuk",
                        "content": "Thank you! This is a solution that\\'s so simple and obvious once you see it you kick yourself for not thinking of it yourself!"
                    },
                    {
                        "username": "ivantchev",
                        "content": "How would the original wording of the problem have to be modified so that the double loop solution _has_ to be used?"
                    },
                    {
                        "username": "ivantchev",
                        "content": "Very helpful, thank you! To add: the reason why using your point 1.) works as a valid check is because given the problem constraints, it will always yield a higher profit down the line regardless of future values.\\n\\nAnd point  2.) shows we don\\'t need a second loop.\\n\\nI wonder, can any concrete aspect of the problem  be used as a clue so that we can reach Serosidium\\'s solution  independently. "
                    },
                    {
                        "username": "VishnuKesav",
                        "content": "[@sharpsailor](/sharpsailor) our target is to get highest possible profit.\\nYou are focusing on buying for the lowest price alone. No matter how low the price is, buying on a last day will yield 0 profit.\\n"
                    },
                    {
                        "username": "kaushar",
                        "content": "[@tengxianrui](/tengxianrui) Thanks  !"
                    },
                    {
                        "username": "neelimag459",
                        "content": "Thank you so much for such good explanation. Happy coding."
                    },
                    {
                        "username": "Nbs-26",
                        "content": "Thank u brother. Your explanation is very clear and well defined."
                    },
                    {
                        "username": "Dabchinsky",
                        "content": "[@sharpsailor](/sharpsailor) if we buy on 2 and sell on 4, our profit would be 4 - 2 = 2. "
                    },
                    {
                        "username": "sharpsailor",
                        "content": "check for {2,4,1} ideally it should give 0 but leetcode gives 2..Help me figure out where am I getting it wrong\\n"
                    },
                    {
                        "username": "jackbb147",
                        "content": "that\\'s actually very smart... thanks"
                    },
                    {
                        "username": "chiahao1",
                        "content": "Thank you! Your technique worked for me."
                    },
                    {
                        "username": "Marre-86",
                        "content": "Man, you made my day! I spent two hours and wrote almost 100 hundred lines code that probably was soving it but had \"time limit exceeded\" with huge input. And after your explanation I rewrite it in freaking 7 lines and it made it right off the bat!"
                    },
                    {
                        "username": "m1ma087",
                        "content": "Best tip! Thanks!"
                    },
                    {
                        "username": "sasaalina1985",
                        "content": "was reading this and solved the problem first try! Very good explanation!!!"
                    },
                    {
                        "username": "Yash_6207",
                        "content": "This is what we call as Greedy ! Good Explanation\\n"
                    },
                    {
                        "username": "iosifpetrupuha",
                        "content": "[@fjod](/fjod) but it\\'s buy day that should be before then sellday"
                    },
                    {
                        "username": "iosifpetrupuha",
                        "content": "[@iosifpetrupuha](/iosifpetrupuha) daaamn there is no indentation in this comment section"
                    },
                    {
                        "username": "iosifpetrupuha",
                        "content": "so I didn\\'t know this was called sliding window or sumthin, but I am second year at CS university, i have some grasp of this kind of logic and I solved it this way:\\nclass Solution:\\n    def maxProfit(self, prices: List[int]) -> int:\\n        #you obviously must buy before you sell(can\\'t go back in time)\\n        GreatestProfit=0\\n        priceToBeat=prices[0]\\n        for i in range(len(prices)-1):#we can iterate through the whole list, otherwise we get out of bounds, so we iterate from the first to the penultimate (so the last comparation we do is between the penultimate and the last element) \\n            if prices[i]<prices[i+1]:#sure profit, possible greatest profit\\n                if prices[i]<=priceToBeat:\\n                    priceToBeat=prices[i]\\n                if GreatestProfit<=prices[i+1]-priceToBeat: #if the GreatestProfit we calculate is greater than the one we have already, we update the Greatest Profit, otherwise we do nothing\\n                    GreatestProfit=prices[i+1]-priceToBeat\\n        return GreatestProfit\\nis this a proper way to solve this kind of problems? (in terms of efficiency I think we\\'re in O(n) so it should be pretty good"
                    },
                    {
                        "username": "Rohit_8412",
                        "content": "Thanks, I was about to see the solution after 10 min I didn\\'t get an approach into my mind.\\nThen I saw your discussion and I solved the question myself \\uD83D\\uDE0E"
                    },
                    {
                        "username": "fjod",
                        "content": "your explanation does not include rule of sellDay must be after buyDay"
                    },
                    {
                        "username": "Hanagaki_Takimichy",
                        "content": "thanks for great explaination without any spoilers.\\ni will try my best for the code, thanks a lot ;)"
                    },
                    {
                        "username": "csrnontol",
                        "content": "Sounds good, but I think your tip fails for [2,9,3,4,5,1,7] (how you\\'d choose 2, 9) and [2,9,3,4,5,1,7,10] (how you\\'d choose 1, 10)."
                    },
                    {
                        "username": "rockmanex",
                        "content": "best explanations so far. Thankyou it\\'s help a lot"
                    },
                    {
                        "username": "ak67",
                        "content": "I think this problem should be catogarise as medium level problem\\n"
                    },
                    {
                        "username": "Sultan_Ul_Arfin",
                        "content": "[@chazwinter](/chazwinter) what is sliding window? I never heard it ..will you explain that please<3\\n "
                    },
                    {
                        "username": "chazwinter",
                        "content": "It doesn\\'t require DP though. You only think it\\'s harder than it is because you\\'re overthinking it. You can use sliding window and just keep track of the lowest price as you go."
                    },
                    {
                        "username": "rwatso",
                        "content": "[@lucky_nik77](/lucky_nik77) Because by its very nature DP is not a beginner / easy level topic."
                    },
                    {
                        "username": "Vectorido",
                        "content": "[@lucky_nik77](/lucky_nik77) This is not hard for simple lists. But all people here usually stuck at TimeLimit error. So algorithm should be another, at least medium level of complexity."
                    },
                    {
                        "username": "lucky_nik77",
                        "content": "But why? It is hard to think about a DP problem that would be easier than this."
                    },
                    {
                        "username": "tiwarimrutunjay",
                        "content": "agreed"
                    },
                    {
                        "username": "codernoob",
                        "content": "how to resolve the time exceeded issue? Mine fails at 203rd test case with a large array"
                    },
                    {
                        "username": "user4279js",
                        "content": "[@rajamandalofficial56](/rajamandalofficial56) I\\'m not a javascript expert, but probably doing prices.slice(index) is looping 0 -index eachtime ... so you have O(N\\n^2) soltuion overall"
                    },
                    {
                        "username": "Behnoosh",
                        "content": "[@htooak2014](/htooak2014) To me it was occurring when my code had an O(n^2) complexity. Resolving that (to O(n)) solved this problem. I start from the end of the array prices and dynamically find the max value from the end of the array until the current step backwards. This way, at the end of the for loop, we can find the max profit with only one single pass over all entries of the array."
                    },
                    {
                        "username": "eyastaifour",
                        "content": "[@htooak2014](/htooak2014) I am hitting a limit error as well and I believe that it is because I keep on querying max() of the window, but when I think of it the max is either on the first index of the window (as I descend), or somewhere else, in which case, it should be cached as it doesnt change... at least, that\\'s what i am thinking\\n"
                    },
                    {
                        "username": "PercyJia95",
                        "content": "[@rajamandalofficial56](/rajamandalofficial56) You need to reconsider your variable naming. They carry very few meanings."
                    },
                    {
                        "username": "knotri",
                        "content": "[@rajamandalofficial56](/rajamandalofficial56) since u iterate over N elements with prices.map, and for each elements u call Math.max(...prices.slice) u need approx additional 1/2N to find maximum. So O(n) = n^2"
                    },
                    {
                        "username": "rajamandalofficial56",
                        "content": " let max = 0;\\n\\n    prices.map((el,index) => {\\n      let tem =  Math.max(...prices.slice(index))\\n      if(el< tem){\\n         if(max< tem-el){\\n             max = tem-el\\n         }\\n      }\\n    })\\n    return max\\n\\nError : Time Limit Exceeded\\n\\nO(n) complexity\\nwhat\\'s wrong this approach? "
                    },
                    {
                        "username": "htooak2014",
                        "content": "me too. time limit error occurs. why? leetcode compiler error?"
                    },
                    {
                        "username": "drmolenhouse",
                        "content": "Same issue, using the LeetCode Official solution lmao. What am I paying $35/month for?"
                    },
                    {
                        "username": "user4387LF",
                        "content": "Because you may be using a brute force approach with two loops checking every combination which takes O(n2) time; Cause it exceeds time limit. Optimize your code. Think to solve it in one pass with one loop in linear time."
                    },
                    {
                        "username": "Sahil481",
                        "content": "Your code is not well optimised. It is not ran within the given time limit."
                    },
                    {
                        "username": "pstrait",
                        "content": "Are you doing it with more than one loop? If so, there\\'s a better solution that has O(n) time complexity"
                    },
                    {
                        "username": "leet_code_master",
                        "content": "prices = [2, 4, 1]\\n\\nOutput: 0\\nExpected: 2\\n\\nYou buy on day three but cannot sell because it is the last day. Should that not be zero?"
                    },
                    {
                        "username": "langhudson870",
                        "content": "You should buy on day 1 and sell on day 2"
                    },
                    {
                        "username": "almaas21",
                        "content": "[@user4391xh](/user4391xh) \\nthe output required is max profit through traversing  in the list, it could be adjacent too like in [2,4,1] max_profit here is 2 not 0"
                    },
                    {
                        "username": "ashish_bhosale848",
                        "content": "Yes , I am facing the same issue at case 154"
                    },
                    {
                        "username": "user4391xh",
                        "content": "According to the example 2 \\n(Input: prices = [7,6,4,3,1]\\nOutput: 0\\nExplanation: In this case, no transactions are done and the max profit = 0.)\\nin the task description, 0 should be returned so looks like tests expect incorrect value here.."
                    },
                    {
                        "username": "kaushit",
                        "content": "[@mp9508](/mp9508) I also done the same thing but if that solution is wrong then what approach should we think."
                    },
                    {
                        "username": "shubhamDhapola",
                        "content": "you buy on the first day and sell on the second"
                    },
                    {
                        "username": "sazuki",
                        "content": "[@mp9508](/mp9508) This happend to me too, because ahahah well, the first value that is taken is the min() so basically 1, but this is the last one because that will end in a 0 output. "
                    },
                    {
                        "username": "HarshitBansal122",
                        "content": "buy on first day and sell on second day makes profit 2 "
                    },
                    {
                        "username": "Dan_A_S",
                        "content": "[@mkv1892](/mkv1892) I don\\'t agree with that (except if the explanation of the problem is not correct). What I understood from the explanation is, you buy when the price is cheapest and sell on a later date when you can maximize profit (meaning the highest prize on a later date from the date of purchase). Going by that, you buy at 1 so the output should be zero and not the expected 2."
                    },
                    {
                        "username": "mkv1892",
                        "content": "No, Here you buy at day 1, Where the buy price is 2 and sell at day 2, Where the sell price is 4."
                    },
                    {
                        "username": "Byas_Yadav",
                        "content": "[@mp9508](/mp9508) you buy on day 1 and sell it on day 2 i.e. profit =sell-buy --> 4-2=2"
                    },
                    {
                        "username": "mp9508",
                        "content": "[@leet_code_master](/leet_code_master) happened the same to me . the approach i took is:\\nfind the minimum element and then maxi=mini then use a loop from the next index of the lowest mini element and then find maxi, then return the output.\\nhope this helps\\n"
                    },
                    {
                        "username": "VaishaliChauhan",
                        "content": "We need to maximize profit, you can buy at 2 and sell on 4, giving a profit of 2"
                    },
                    {
                        "username": "IbrahimJunior",
                        "content": "you have to maintain your profit in a variable and only change the variable if the new profit is greater than the previous one, so for this scenario, 2 is the former profit, 0 is the new one, it is not greater than 2 so you don\\'t change your profit."
                    },
                    {
                        "username": "Hanagaki_Takimichy",
                        "content": "buy = 2 and sell = 4 profit = 2\\ni am facing the same problem bro............."
                    },
                    {
                        "username": "MatsRivel",
                        "content": "[@leet_code_master](/leet_code_master) What I did was look at what the largest value after i is for each i, and what the smallest value is before each i. Then, for each i, i subtract smallest from largest. This is your optimal profit for buying before i and selling after i. Now you just find the largest number out of these, and you\\'re done."
                    },
                    {
                        "username": "leet_code_master",
                        "content": "[@MeriemA](/MeriemA) I see. Thank you :) How do you recommend I go about this? Because now the new code I make messes up the second test case."
                    },
                    {
                        "username": "MeriemA",
                        "content": "Actually,  the idea here is how you can make the maximum of profits. You don\\'t have to buy the stock when it\\'s at its lowest price.\\nHere you can buy the first day and sell the second day and still make a profit which is 2.\\n"
                    },
                    {
                        "username": "EXLsunshine",
                        "content": "Why is this problem tagged with \"Dynamic programming\"?"
                    },
                    {
                        "username": "princebillygk2",
                        "content": "[@aryan14decsingh](/aryan14decsingh) The problem can be solved in Dynamic way but the more efficient way is array traversal approach."
                    },
                    {
                        "username": "Mrinal2100",
                        "content": "It should be tagged as two pointer problem"
                    },
                    {
                        "username": "aryan14decsingh",
                        "content": "Because it is Dynamic  ( debatable ) \\nquestion apart , did you get any job by now ? you posted this on 2015 , if you are still alive let me know if you got any jobs and some tips aswell"
                    },
                    {
                        "username": "djslim",
                        "content": "[@sourov1407](/sourov1407)  tbh it\\'s classic greedy problem, interestingly in leetcode 75 they marked it as greedy"
                    },
                    {
                        "username": "sahle123",
                        "content": "[@AdityaBhate](/AdityaBhate) He/she was asking a question, not for a solution."
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# \\uD83D\\uDEA9Easy C++ O(N) Soln. [ FAANG\\uD83D\\uDE31 Interview Optimized code ]\\n\\nhttps://leetcode.com/problems/best-time-to-buy-and-sell-stock/solutions/2822579/easy-c-o-n-soln-faang-interview-optimized-code/\\n\\n"
                    },
                    {
                        "username": "sourov1407",
                        "content": "Because we can use kadene\\'s algorithm here and as it is widely regarded as dp algorithm so yeah this problem is tagged with dynamic programming"
                    },
                    {
                        "username": "casper07",
                        "content": "I am So dumb...."
                    },
                    {
                        "username": "ydumar",
                        "content": "same bruh"
                    },
                    {
                        "username": "savagesam343",
                        "content": "me too bro, me too..."
                    },
                    {
                        "username": "night07",
                        "content": "me too jit"
                    },
                    {
                        "username": "AlgoEngine",
                        "content": "Video visualizing an intuitive proof of the O(n) solution:\nhttps://youtube.com/watch?v=ioFPBdChabY"
                    },
                    {
                        "username": "astek14",
                        "content": "Thanks it\\'s awesome"
                    },
                    {
                        "username": "shilbabun491",
                        "content": "how to resolve the time exceeded issue? Mine fails at 200th test case with a large array"
                    },
                    {
                        "username": "akelux",
                        "content": "How to get max profit 4 from input [3,2,6,5,0,3]?"
                    },
                    {
                        "username": "jenil59",
                        "content": "buy at 2 and sell at 6"
                    },
                    {
                        "username": "Trinto_610",
                        "content": "damn bro 2013"
                    },
                    {
                        "username": "prasumitmishra",
                        "content": "3 (buy),  2 (buy) , 6 (sell), 5 (hold), 0 (hold), 3 (hold)\\n-3 -2 + (2*6)\\n= -5 + 12 = 7"
                    },
                    {
                        "username": "KayvanShah1",
                        "content": "by selling on 6 and buying on 0\\nwhich means short selling"
                    },
                    {
                        "username": "bhanureddy7",
                        "content": "2,6"
                    },
                    {
                        "username": "Hanagaki_Takimichy",
                        "content": "buy = 2 and sell = 6"
                    },
                    {
                        "username": "hungkiet244203",
                        "content": "[@jannatbushra524](/jannatbushra524) yeah but the profit it provides isnt\\n"
                    },
                    {
                        "username": "MatsRivel",
                        "content": "[@jannatbushra524](/jannatbushra524) Buy at 0, then you have to sell after zero, so the best sell price is 3. 3-0 = 3, 6-2=4"
                    },
                    {
                        "username": "ajjha7203",
                        "content": "6-2 = 4"
                    },
                    {
                        "username": "damajsam93",
                        "content": "6-2 ==> 4 "
                    },
                    {
                        "username": "Jagdeep4485",
                        "content": "6-2= 4"
                    },
                    {
                        "username": "jannatbushra524",
                        "content": "[@rajanhossainkhan](/rajanhossainkhan) isn\\'t \\'0\\' a buy_price ??...and its smallest too."
                    },
                    {
                        "username": "rajanhossainkhan",
                        "content": "Here are the steps - \\n\\n1. First buy out price is 3 and profit is set to 0. \\n2. Now loop through array from index 1, since index 0 (which is 3) is taken as minimum buy out price for now. \\n3. Now if price is 2, then set this as new buy out price, since its smaller. So our current buy out price is 2. \\n4. Now next price is 6. This is bigger, so sell with current buy out price 2. \\n5. Calculate max profit  = max(profit, ( current_price - buy_price) \\n6. In this case, max(0, 6-2) = 4\\n\\nHope this helps. "
                    },
                    {
                        "username": "Amit_Joe",
                        "content": "2 -6\\n"
                    },
                    {
                        "username": "hemantgautam505",
                        "content": "output is 4\\n"
                    },
                    {
                        "username": "Shashi3k",
                        "content": "2-6\\n"
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for February, Day 1.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  **📌 Do you want to learn the problem thoroughly?**\n  Read [**⭐  LeetCode Official Solution⭐**](https://leetcode.com/problems/best-time-to-buy-and-sell-stock/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 2 approaches in the official solution</summary>\n\n  \n**Approach 1:** Brute Force\n\n  \n**Approach 2:** One Pass\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# \\uD83D\\uDEA9Easy C++ O(N) Soln. [ FAANG\\uD83D\\uDE31 Interview Optimized code ]\\n\\nhttps://leetcode.com/problems/best-time-to-buy-and-sell-stock/solutions/2822579/easy-c-o-n-soln-faang-interview-optimized-code/\\n"
                    }
                ]
            },
            {
                "id": 1756186,
                "content": [
                    {
                        "username": "Serosidium",
                        "content": "I couldn\\'t find any good explanations here and only code, so I will do my best to explain how I solved it without providing code. I am sure there are other possible solutions, but this is how it worked for me.\\n\\nThe brute force method of a double for loop is not necessary here, and this problem is marked with dynamic programming because it requires the [Sliding Window technique](https://algorithm-visualizer.org/dynamic-programming/sliding-window).\\n\\nBased on the fact that we have to sell after we buy and we are trying to maximize profit, we can iterate through the prices and only need to consider two things:\\n1.) **Is this price cheaper than any other price I\\'ve seen before?** \\n2.) If I subtract current price by the cheapest price I\\'ve found, **does this yield a greater profit than what I\\'ve seen so far?**\\n\\n*A fun thing to note is if #1 is true, then #2 cannot be true as well so there isn\\'t a need to check*\\n\\nLet\\'s consider an example of [4,1,5,2,7]\\n- 4 is the cheapest price we see to start, and we can\\'t sell on the first day so maxProfit is 0\\n- 1 is now the cheapest price we\\'ve seen. Selling now would lose us money, so we can\\'t update maxProfit\\n- 5 is not cheaper than 1, but if we sell now we get a maxProfit of 4! Better save that for later\\n- 2 is not cheaper than 1 and if we sell, we only get a profit of 1, no need to do anything here\\n- 7 is not cheaper than 1, but if we sell here, we\\'ll increase maxProfit to 6, making this the best profit to return.\\n\\nHope this helps someone else!\\n"
                    },
                    {
                        "username": "Manidgyf_6",
                        "content": "Thank you bro"
                    },
                    {
                        "username": "lorentzimys",
                        "content": "Awesome solution, thanks!"
                    },
                    {
                        "username": "Khoa268",
                        "content": "thanks for sharing!"
                    },
                    {
                        "username": "omeh-a",
                        "content": "This is not a DP solution as described, it is greedy"
                    },
                    {
                        "username": "ankitk742",
                        "content": "Thanks bro for your help without code really appreciate "
                    },
                    {
                        "username": "245120733119",
                        "content": "Brilliant!! Thanks for sharing!!"
                    },
                    {
                        "username": "Aniket_sggs",
                        "content": "Initially, this seemed to be DP problem. but after reading this description it is clear that this is basic problem with greedy solution."
                    },
                    {
                        "username": "duffinson97",
                        "content": "Thank you for not posting code, I don\\'t understand the sliding window technique or how this applies to that. I google it and the image link to this problem doesn\\'t make a lot of sense to me. But this solution works thanks"
                    },
                    {
                        "username": "typranjal1",
                        "content": "Thank you!."
                    },
                    {
                        "username": "jakho100",
                        "content": "was stuck on it for hours, thanks for the simple explanation! "
                    },
                    {
                        "username": "zafeer_rangoonwala",
                        "content": "I was originally not able to solve it but after reading your thought process it was a cake walk! \\n\\nThanks! "
                    },
                    {
                        "username": "mohammed1212345",
                        "content": "thank for helping out"
                    },
                    {
                        "username": "dungtuanuet",
                        "content": "Exellent explaination!"
                    },
                    {
                        "username": "kcleland18",
                        "content": "This was a great explanation!! Thanks!"
                    },
                    {
                        "username": "as358",
                        "content": "Best Explanation ever !!!"
                    },
                    {
                        "username": "user6798sW",
                        "content": "AWESOME BREAKDOWN! Ty"
                    },
                    {
                        "username": "jaydeep-pro",
                        "content": "[@evoniuk](/evoniuk) exactly! "
                    },
                    {
                        "username": "akshaydusad",
                        "content": "okay this is genius and surprisingly easier to follow!"
                    },
                    {
                        "username": "evoniuk",
                        "content": "Thank you! This is a solution that\\'s so simple and obvious once you see it you kick yourself for not thinking of it yourself!"
                    },
                    {
                        "username": "ivantchev",
                        "content": "How would the original wording of the problem have to be modified so that the double loop solution _has_ to be used?"
                    },
                    {
                        "username": "ivantchev",
                        "content": "Very helpful, thank you! To add: the reason why using your point 1.) works as a valid check is because given the problem constraints, it will always yield a higher profit down the line regardless of future values.\\n\\nAnd point  2.) shows we don\\'t need a second loop.\\n\\nI wonder, can any concrete aspect of the problem  be used as a clue so that we can reach Serosidium\\'s solution  independently. "
                    },
                    {
                        "username": "VishnuKesav",
                        "content": "[@sharpsailor](/sharpsailor) our target is to get highest possible profit.\\nYou are focusing on buying for the lowest price alone. No matter how low the price is, buying on a last day will yield 0 profit.\\n"
                    },
                    {
                        "username": "kaushar",
                        "content": "[@tengxianrui](/tengxianrui) Thanks  !"
                    },
                    {
                        "username": "neelimag459",
                        "content": "Thank you so much for such good explanation. Happy coding."
                    },
                    {
                        "username": "Nbs-26",
                        "content": "Thank u brother. Your explanation is very clear and well defined."
                    },
                    {
                        "username": "Dabchinsky",
                        "content": "[@sharpsailor](/sharpsailor) if we buy on 2 and sell on 4, our profit would be 4 - 2 = 2. "
                    },
                    {
                        "username": "sharpsailor",
                        "content": "check for {2,4,1} ideally it should give 0 but leetcode gives 2..Help me figure out where am I getting it wrong\\n"
                    },
                    {
                        "username": "jackbb147",
                        "content": "that\\'s actually very smart... thanks"
                    },
                    {
                        "username": "chiahao1",
                        "content": "Thank you! Your technique worked for me."
                    },
                    {
                        "username": "Marre-86",
                        "content": "Man, you made my day! I spent two hours and wrote almost 100 hundred lines code that probably was soving it but had \"time limit exceeded\" with huge input. And after your explanation I rewrite it in freaking 7 lines and it made it right off the bat!"
                    },
                    {
                        "username": "m1ma087",
                        "content": "Best tip! Thanks!"
                    },
                    {
                        "username": "sasaalina1985",
                        "content": "was reading this and solved the problem first try! Very good explanation!!!"
                    },
                    {
                        "username": "Yash_6207",
                        "content": "This is what we call as Greedy ! Good Explanation\\n"
                    },
                    {
                        "username": "iosifpetrupuha",
                        "content": "[@fjod](/fjod) but it\\'s buy day that should be before then sellday"
                    },
                    {
                        "username": "iosifpetrupuha",
                        "content": "[@iosifpetrupuha](/iosifpetrupuha) daaamn there is no indentation in this comment section"
                    },
                    {
                        "username": "iosifpetrupuha",
                        "content": "so I didn\\'t know this was called sliding window or sumthin, but I am second year at CS university, i have some grasp of this kind of logic and I solved it this way:\\nclass Solution:\\n    def maxProfit(self, prices: List[int]) -> int:\\n        #you obviously must buy before you sell(can\\'t go back in time)\\n        GreatestProfit=0\\n        priceToBeat=prices[0]\\n        for i in range(len(prices)-1):#we can iterate through the whole list, otherwise we get out of bounds, so we iterate from the first to the penultimate (so the last comparation we do is between the penultimate and the last element) \\n            if prices[i]<prices[i+1]:#sure profit, possible greatest profit\\n                if prices[i]<=priceToBeat:\\n                    priceToBeat=prices[i]\\n                if GreatestProfit<=prices[i+1]-priceToBeat: #if the GreatestProfit we calculate is greater than the one we have already, we update the Greatest Profit, otherwise we do nothing\\n                    GreatestProfit=prices[i+1]-priceToBeat\\n        return GreatestProfit\\nis this a proper way to solve this kind of problems? (in terms of efficiency I think we\\'re in O(n) so it should be pretty good"
                    },
                    {
                        "username": "Rohit_8412",
                        "content": "Thanks, I was about to see the solution after 10 min I didn\\'t get an approach into my mind.\\nThen I saw your discussion and I solved the question myself \\uD83D\\uDE0E"
                    },
                    {
                        "username": "fjod",
                        "content": "your explanation does not include rule of sellDay must be after buyDay"
                    },
                    {
                        "username": "Hanagaki_Takimichy",
                        "content": "thanks for great explaination without any spoilers.\\ni will try my best for the code, thanks a lot ;)"
                    },
                    {
                        "username": "csrnontol",
                        "content": "Sounds good, but I think your tip fails for [2,9,3,4,5,1,7] (how you\\'d choose 2, 9) and [2,9,3,4,5,1,7,10] (how you\\'d choose 1, 10)."
                    },
                    {
                        "username": "rockmanex",
                        "content": "best explanations so far. Thankyou it\\'s help a lot"
                    },
                    {
                        "username": "ak67",
                        "content": "I think this problem should be catogarise as medium level problem\\n"
                    },
                    {
                        "username": "Sultan_Ul_Arfin",
                        "content": "[@chazwinter](/chazwinter) what is sliding window? I never heard it ..will you explain that please<3\\n "
                    },
                    {
                        "username": "chazwinter",
                        "content": "It doesn\\'t require DP though. You only think it\\'s harder than it is because you\\'re overthinking it. You can use sliding window and just keep track of the lowest price as you go."
                    },
                    {
                        "username": "rwatso",
                        "content": "[@lucky_nik77](/lucky_nik77) Because by its very nature DP is not a beginner / easy level topic."
                    },
                    {
                        "username": "Vectorido",
                        "content": "[@lucky_nik77](/lucky_nik77) This is not hard for simple lists. But all people here usually stuck at TimeLimit error. So algorithm should be another, at least medium level of complexity."
                    },
                    {
                        "username": "lucky_nik77",
                        "content": "But why? It is hard to think about a DP problem that would be easier than this."
                    },
                    {
                        "username": "tiwarimrutunjay",
                        "content": "agreed"
                    },
                    {
                        "username": "codernoob",
                        "content": "how to resolve the time exceeded issue? Mine fails at 203rd test case with a large array"
                    },
                    {
                        "username": "user4279js",
                        "content": "[@rajamandalofficial56](/rajamandalofficial56) I\\'m not a javascript expert, but probably doing prices.slice(index) is looping 0 -index eachtime ... so you have O(N\\n^2) soltuion overall"
                    },
                    {
                        "username": "Behnoosh",
                        "content": "[@htooak2014](/htooak2014) To me it was occurring when my code had an O(n^2) complexity. Resolving that (to O(n)) solved this problem. I start from the end of the array prices and dynamically find the max value from the end of the array until the current step backwards. This way, at the end of the for loop, we can find the max profit with only one single pass over all entries of the array."
                    },
                    {
                        "username": "eyastaifour",
                        "content": "[@htooak2014](/htooak2014) I am hitting a limit error as well and I believe that it is because I keep on querying max() of the window, but when I think of it the max is either on the first index of the window (as I descend), or somewhere else, in which case, it should be cached as it doesnt change... at least, that\\'s what i am thinking\\n"
                    },
                    {
                        "username": "PercyJia95",
                        "content": "[@rajamandalofficial56](/rajamandalofficial56) You need to reconsider your variable naming. They carry very few meanings."
                    },
                    {
                        "username": "knotri",
                        "content": "[@rajamandalofficial56](/rajamandalofficial56) since u iterate over N elements with prices.map, and for each elements u call Math.max(...prices.slice) u need approx additional 1/2N to find maximum. So O(n) = n^2"
                    },
                    {
                        "username": "rajamandalofficial56",
                        "content": " let max = 0;\\n\\n    prices.map((el,index) => {\\n      let tem =  Math.max(...prices.slice(index))\\n      if(el< tem){\\n         if(max< tem-el){\\n             max = tem-el\\n         }\\n      }\\n    })\\n    return max\\n\\nError : Time Limit Exceeded\\n\\nO(n) complexity\\nwhat\\'s wrong this approach? "
                    },
                    {
                        "username": "htooak2014",
                        "content": "me too. time limit error occurs. why? leetcode compiler error?"
                    },
                    {
                        "username": "drmolenhouse",
                        "content": "Same issue, using the LeetCode Official solution lmao. What am I paying $35/month for?"
                    },
                    {
                        "username": "user4387LF",
                        "content": "Because you may be using a brute force approach with two loops checking every combination which takes O(n2) time; Cause it exceeds time limit. Optimize your code. Think to solve it in one pass with one loop in linear time."
                    },
                    {
                        "username": "Sahil481",
                        "content": "Your code is not well optimised. It is not ran within the given time limit."
                    },
                    {
                        "username": "pstrait",
                        "content": "Are you doing it with more than one loop? If so, there\\'s a better solution that has O(n) time complexity"
                    },
                    {
                        "username": "leet_code_master",
                        "content": "prices = [2, 4, 1]\\n\\nOutput: 0\\nExpected: 2\\n\\nYou buy on day three but cannot sell because it is the last day. Should that not be zero?"
                    },
                    {
                        "username": "langhudson870",
                        "content": "You should buy on day 1 and sell on day 2"
                    },
                    {
                        "username": "almaas21",
                        "content": "[@user4391xh](/user4391xh) \\nthe output required is max profit through traversing  in the list, it could be adjacent too like in [2,4,1] max_profit here is 2 not 0"
                    },
                    {
                        "username": "ashish_bhosale848",
                        "content": "Yes , I am facing the same issue at case 154"
                    },
                    {
                        "username": "user4391xh",
                        "content": "According to the example 2 \\n(Input: prices = [7,6,4,3,1]\\nOutput: 0\\nExplanation: In this case, no transactions are done and the max profit = 0.)\\nin the task description, 0 should be returned so looks like tests expect incorrect value here.."
                    },
                    {
                        "username": "kaushit",
                        "content": "[@mp9508](/mp9508) I also done the same thing but if that solution is wrong then what approach should we think."
                    },
                    {
                        "username": "shubhamDhapola",
                        "content": "you buy on the first day and sell on the second"
                    },
                    {
                        "username": "sazuki",
                        "content": "[@mp9508](/mp9508) This happend to me too, because ahahah well, the first value that is taken is the min() so basically 1, but this is the last one because that will end in a 0 output. "
                    },
                    {
                        "username": "HarshitBansal122",
                        "content": "buy on first day and sell on second day makes profit 2 "
                    },
                    {
                        "username": "Dan_A_S",
                        "content": "[@mkv1892](/mkv1892) I don\\'t agree with that (except if the explanation of the problem is not correct). What I understood from the explanation is, you buy when the price is cheapest and sell on a later date when you can maximize profit (meaning the highest prize on a later date from the date of purchase). Going by that, you buy at 1 so the output should be zero and not the expected 2."
                    },
                    {
                        "username": "mkv1892",
                        "content": "No, Here you buy at day 1, Where the buy price is 2 and sell at day 2, Where the sell price is 4."
                    },
                    {
                        "username": "Byas_Yadav",
                        "content": "[@mp9508](/mp9508) you buy on day 1 and sell it on day 2 i.e. profit =sell-buy --> 4-2=2"
                    },
                    {
                        "username": "mp9508",
                        "content": "[@leet_code_master](/leet_code_master) happened the same to me . the approach i took is:\\nfind the minimum element and then maxi=mini then use a loop from the next index of the lowest mini element and then find maxi, then return the output.\\nhope this helps\\n"
                    },
                    {
                        "username": "VaishaliChauhan",
                        "content": "We need to maximize profit, you can buy at 2 and sell on 4, giving a profit of 2"
                    },
                    {
                        "username": "IbrahimJunior",
                        "content": "you have to maintain your profit in a variable and only change the variable if the new profit is greater than the previous one, so for this scenario, 2 is the former profit, 0 is the new one, it is not greater than 2 so you don\\'t change your profit."
                    },
                    {
                        "username": "Hanagaki_Takimichy",
                        "content": "buy = 2 and sell = 4 profit = 2\\ni am facing the same problem bro............."
                    },
                    {
                        "username": "MatsRivel",
                        "content": "[@leet_code_master](/leet_code_master) What I did was look at what the largest value after i is for each i, and what the smallest value is before each i. Then, for each i, i subtract smallest from largest. This is your optimal profit for buying before i and selling after i. Now you just find the largest number out of these, and you\\'re done."
                    },
                    {
                        "username": "leet_code_master",
                        "content": "[@MeriemA](/MeriemA) I see. Thank you :) How do you recommend I go about this? Because now the new code I make messes up the second test case."
                    },
                    {
                        "username": "MeriemA",
                        "content": "Actually,  the idea here is how you can make the maximum of profits. You don\\'t have to buy the stock when it\\'s at its lowest price.\\nHere you can buy the first day and sell the second day and still make a profit which is 2.\\n"
                    },
                    {
                        "username": "EXLsunshine",
                        "content": "Why is this problem tagged with \"Dynamic programming\"?"
                    },
                    {
                        "username": "princebillygk2",
                        "content": "[@aryan14decsingh](/aryan14decsingh) The problem can be solved in Dynamic way but the more efficient way is array traversal approach."
                    },
                    {
                        "username": "Mrinal2100",
                        "content": "It should be tagged as two pointer problem"
                    },
                    {
                        "username": "aryan14decsingh",
                        "content": "Because it is Dynamic  ( debatable ) \\nquestion apart , did you get any job by now ? you posted this on 2015 , if you are still alive let me know if you got any jobs and some tips aswell"
                    },
                    {
                        "username": "djslim",
                        "content": "[@sourov1407](/sourov1407)  tbh it\\'s classic greedy problem, interestingly in leetcode 75 they marked it as greedy"
                    },
                    {
                        "username": "sahle123",
                        "content": "[@AdityaBhate](/AdityaBhate) He/she was asking a question, not for a solution."
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# \\uD83D\\uDEA9Easy C++ O(N) Soln. [ FAANG\\uD83D\\uDE31 Interview Optimized code ]\\n\\nhttps://leetcode.com/problems/best-time-to-buy-and-sell-stock/solutions/2822579/easy-c-o-n-soln-faang-interview-optimized-code/\\n\\n"
                    },
                    {
                        "username": "sourov1407",
                        "content": "Because we can use kadene\\'s algorithm here and as it is widely regarded as dp algorithm so yeah this problem is tagged with dynamic programming"
                    },
                    {
                        "username": "casper07",
                        "content": "I am So dumb...."
                    },
                    {
                        "username": "ydumar",
                        "content": "same bruh"
                    },
                    {
                        "username": "savagesam343",
                        "content": "me too bro, me too..."
                    },
                    {
                        "username": "night07",
                        "content": "me too jit"
                    },
                    {
                        "username": "AlgoEngine",
                        "content": "Video visualizing an intuitive proof of the O(n) solution:\nhttps://youtube.com/watch?v=ioFPBdChabY"
                    },
                    {
                        "username": "astek14",
                        "content": "Thanks it\\'s awesome"
                    },
                    {
                        "username": "shilbabun491",
                        "content": "how to resolve the time exceeded issue? Mine fails at 200th test case with a large array"
                    },
                    {
                        "username": "akelux",
                        "content": "How to get max profit 4 from input [3,2,6,5,0,3]?"
                    },
                    {
                        "username": "jenil59",
                        "content": "buy at 2 and sell at 6"
                    },
                    {
                        "username": "Trinto_610",
                        "content": "damn bro 2013"
                    },
                    {
                        "username": "prasumitmishra",
                        "content": "3 (buy),  2 (buy) , 6 (sell), 5 (hold), 0 (hold), 3 (hold)\\n-3 -2 + (2*6)\\n= -5 + 12 = 7"
                    },
                    {
                        "username": "KayvanShah1",
                        "content": "by selling on 6 and buying on 0\\nwhich means short selling"
                    },
                    {
                        "username": "bhanureddy7",
                        "content": "2,6"
                    },
                    {
                        "username": "Hanagaki_Takimichy",
                        "content": "buy = 2 and sell = 6"
                    },
                    {
                        "username": "hungkiet244203",
                        "content": "[@jannatbushra524](/jannatbushra524) yeah but the profit it provides isnt\\n"
                    },
                    {
                        "username": "MatsRivel",
                        "content": "[@jannatbushra524](/jannatbushra524) Buy at 0, then you have to sell after zero, so the best sell price is 3. 3-0 = 3, 6-2=4"
                    },
                    {
                        "username": "ajjha7203",
                        "content": "6-2 = 4"
                    },
                    {
                        "username": "damajsam93",
                        "content": "6-2 ==> 4 "
                    },
                    {
                        "username": "Jagdeep4485",
                        "content": "6-2= 4"
                    },
                    {
                        "username": "jannatbushra524",
                        "content": "[@rajanhossainkhan](/rajanhossainkhan) isn\\'t \\'0\\' a buy_price ??...and its smallest too."
                    },
                    {
                        "username": "rajanhossainkhan",
                        "content": "Here are the steps - \\n\\n1. First buy out price is 3 and profit is set to 0. \\n2. Now loop through array from index 1, since index 0 (which is 3) is taken as minimum buy out price for now. \\n3. Now if price is 2, then set this as new buy out price, since its smaller. So our current buy out price is 2. \\n4. Now next price is 6. This is bigger, so sell with current buy out price 2. \\n5. Calculate max profit  = max(profit, ( current_price - buy_price) \\n6. In this case, max(0, 6-2) = 4\\n\\nHope this helps. "
                    },
                    {
                        "username": "Amit_Joe",
                        "content": "2 -6\\n"
                    },
                    {
                        "username": "hemantgautam505",
                        "content": "output is 4\\n"
                    },
                    {
                        "username": "Shashi3k",
                        "content": "2-6\\n"
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for February, Day 1.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  **📌 Do you want to learn the problem thoroughly?**\n  Read [**⭐  LeetCode Official Solution⭐**](https://leetcode.com/problems/best-time-to-buy-and-sell-stock/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 2 approaches in the official solution</summary>\n\n  \n**Approach 1:** Brute Force\n\n  \n**Approach 2:** One Pass\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# \\uD83D\\uDEA9Easy C++ O(N) Soln. [ FAANG\\uD83D\\uDE31 Interview Optimized code ]\\n\\nhttps://leetcode.com/problems/best-time-to-buy-and-sell-stock/solutions/2822579/easy-c-o-n-soln-faang-interview-optimized-code/\\n"
                    }
                ]
            },
            {
                "id": 1566236,
                "content": [
                    {
                        "username": "Serosidium",
                        "content": "I couldn\\'t find any good explanations here and only code, so I will do my best to explain how I solved it without providing code. I am sure there are other possible solutions, but this is how it worked for me.\\n\\nThe brute force method of a double for loop is not necessary here, and this problem is marked with dynamic programming because it requires the [Sliding Window technique](https://algorithm-visualizer.org/dynamic-programming/sliding-window).\\n\\nBased on the fact that we have to sell after we buy and we are trying to maximize profit, we can iterate through the prices and only need to consider two things:\\n1.) **Is this price cheaper than any other price I\\'ve seen before?** \\n2.) If I subtract current price by the cheapest price I\\'ve found, **does this yield a greater profit than what I\\'ve seen so far?**\\n\\n*A fun thing to note is if #1 is true, then #2 cannot be true as well so there isn\\'t a need to check*\\n\\nLet\\'s consider an example of [4,1,5,2,7]\\n- 4 is the cheapest price we see to start, and we can\\'t sell on the first day so maxProfit is 0\\n- 1 is now the cheapest price we\\'ve seen. Selling now would lose us money, so we can\\'t update maxProfit\\n- 5 is not cheaper than 1, but if we sell now we get a maxProfit of 4! Better save that for later\\n- 2 is not cheaper than 1 and if we sell, we only get a profit of 1, no need to do anything here\\n- 7 is not cheaper than 1, but if we sell here, we\\'ll increase maxProfit to 6, making this the best profit to return.\\n\\nHope this helps someone else!\\n"
                    },
                    {
                        "username": "Manidgyf_6",
                        "content": "Thank you bro"
                    },
                    {
                        "username": "lorentzimys",
                        "content": "Awesome solution, thanks!"
                    },
                    {
                        "username": "Khoa268",
                        "content": "thanks for sharing!"
                    },
                    {
                        "username": "omeh-a",
                        "content": "This is not a DP solution as described, it is greedy"
                    },
                    {
                        "username": "ankitk742",
                        "content": "Thanks bro for your help without code really appreciate "
                    },
                    {
                        "username": "245120733119",
                        "content": "Brilliant!! Thanks for sharing!!"
                    },
                    {
                        "username": "Aniket_sggs",
                        "content": "Initially, this seemed to be DP problem. but after reading this description it is clear that this is basic problem with greedy solution."
                    },
                    {
                        "username": "duffinson97",
                        "content": "Thank you for not posting code, I don\\'t understand the sliding window technique or how this applies to that. I google it and the image link to this problem doesn\\'t make a lot of sense to me. But this solution works thanks"
                    },
                    {
                        "username": "typranjal1",
                        "content": "Thank you!."
                    },
                    {
                        "username": "jakho100",
                        "content": "was stuck on it for hours, thanks for the simple explanation! "
                    },
                    {
                        "username": "zafeer_rangoonwala",
                        "content": "I was originally not able to solve it but after reading your thought process it was a cake walk! \\n\\nThanks! "
                    },
                    {
                        "username": "mohammed1212345",
                        "content": "thank for helping out"
                    },
                    {
                        "username": "dungtuanuet",
                        "content": "Exellent explaination!"
                    },
                    {
                        "username": "kcleland18",
                        "content": "This was a great explanation!! Thanks!"
                    },
                    {
                        "username": "as358",
                        "content": "Best Explanation ever !!!"
                    },
                    {
                        "username": "user6798sW",
                        "content": "AWESOME BREAKDOWN! Ty"
                    },
                    {
                        "username": "jaydeep-pro",
                        "content": "[@evoniuk](/evoniuk) exactly! "
                    },
                    {
                        "username": "akshaydusad",
                        "content": "okay this is genius and surprisingly easier to follow!"
                    },
                    {
                        "username": "evoniuk",
                        "content": "Thank you! This is a solution that\\'s so simple and obvious once you see it you kick yourself for not thinking of it yourself!"
                    },
                    {
                        "username": "ivantchev",
                        "content": "How would the original wording of the problem have to be modified so that the double loop solution _has_ to be used?"
                    },
                    {
                        "username": "ivantchev",
                        "content": "Very helpful, thank you! To add: the reason why using your point 1.) works as a valid check is because given the problem constraints, it will always yield a higher profit down the line regardless of future values.\\n\\nAnd point  2.) shows we don\\'t need a second loop.\\n\\nI wonder, can any concrete aspect of the problem  be used as a clue so that we can reach Serosidium\\'s solution  independently. "
                    },
                    {
                        "username": "VishnuKesav",
                        "content": "[@sharpsailor](/sharpsailor) our target is to get highest possible profit.\\nYou are focusing on buying for the lowest price alone. No matter how low the price is, buying on a last day will yield 0 profit.\\n"
                    },
                    {
                        "username": "kaushar",
                        "content": "[@tengxianrui](/tengxianrui) Thanks  !"
                    },
                    {
                        "username": "neelimag459",
                        "content": "Thank you so much for such good explanation. Happy coding."
                    },
                    {
                        "username": "Nbs-26",
                        "content": "Thank u brother. Your explanation is very clear and well defined."
                    },
                    {
                        "username": "Dabchinsky",
                        "content": "[@sharpsailor](/sharpsailor) if we buy on 2 and sell on 4, our profit would be 4 - 2 = 2. "
                    },
                    {
                        "username": "sharpsailor",
                        "content": "check for {2,4,1} ideally it should give 0 but leetcode gives 2..Help me figure out where am I getting it wrong\\n"
                    },
                    {
                        "username": "jackbb147",
                        "content": "that\\'s actually very smart... thanks"
                    },
                    {
                        "username": "chiahao1",
                        "content": "Thank you! Your technique worked for me."
                    },
                    {
                        "username": "Marre-86",
                        "content": "Man, you made my day! I spent two hours and wrote almost 100 hundred lines code that probably was soving it but had \"time limit exceeded\" with huge input. And after your explanation I rewrite it in freaking 7 lines and it made it right off the bat!"
                    },
                    {
                        "username": "m1ma087",
                        "content": "Best tip! Thanks!"
                    },
                    {
                        "username": "sasaalina1985",
                        "content": "was reading this and solved the problem first try! Very good explanation!!!"
                    },
                    {
                        "username": "Yash_6207",
                        "content": "This is what we call as Greedy ! Good Explanation\\n"
                    },
                    {
                        "username": "iosifpetrupuha",
                        "content": "[@fjod](/fjod) but it\\'s buy day that should be before then sellday"
                    },
                    {
                        "username": "iosifpetrupuha",
                        "content": "[@iosifpetrupuha](/iosifpetrupuha) daaamn there is no indentation in this comment section"
                    },
                    {
                        "username": "iosifpetrupuha",
                        "content": "so I didn\\'t know this was called sliding window or sumthin, but I am second year at CS university, i have some grasp of this kind of logic and I solved it this way:\\nclass Solution:\\n    def maxProfit(self, prices: List[int]) -> int:\\n        #you obviously must buy before you sell(can\\'t go back in time)\\n        GreatestProfit=0\\n        priceToBeat=prices[0]\\n        for i in range(len(prices)-1):#we can iterate through the whole list, otherwise we get out of bounds, so we iterate from the first to the penultimate (so the last comparation we do is between the penultimate and the last element) \\n            if prices[i]<prices[i+1]:#sure profit, possible greatest profit\\n                if prices[i]<=priceToBeat:\\n                    priceToBeat=prices[i]\\n                if GreatestProfit<=prices[i+1]-priceToBeat: #if the GreatestProfit we calculate is greater than the one we have already, we update the Greatest Profit, otherwise we do nothing\\n                    GreatestProfit=prices[i+1]-priceToBeat\\n        return GreatestProfit\\nis this a proper way to solve this kind of problems? (in terms of efficiency I think we\\'re in O(n) so it should be pretty good"
                    },
                    {
                        "username": "Rohit_8412",
                        "content": "Thanks, I was about to see the solution after 10 min I didn\\'t get an approach into my mind.\\nThen I saw your discussion and I solved the question myself \\uD83D\\uDE0E"
                    },
                    {
                        "username": "fjod",
                        "content": "your explanation does not include rule of sellDay must be after buyDay"
                    },
                    {
                        "username": "Hanagaki_Takimichy",
                        "content": "thanks for great explaination without any spoilers.\\ni will try my best for the code, thanks a lot ;)"
                    },
                    {
                        "username": "csrnontol",
                        "content": "Sounds good, but I think your tip fails for [2,9,3,4,5,1,7] (how you\\'d choose 2, 9) and [2,9,3,4,5,1,7,10] (how you\\'d choose 1, 10)."
                    },
                    {
                        "username": "rockmanex",
                        "content": "best explanations so far. Thankyou it\\'s help a lot"
                    },
                    {
                        "username": "ak67",
                        "content": "I think this problem should be catogarise as medium level problem\\n"
                    },
                    {
                        "username": "Sultan_Ul_Arfin",
                        "content": "[@chazwinter](/chazwinter) what is sliding window? I never heard it ..will you explain that please<3\\n "
                    },
                    {
                        "username": "chazwinter",
                        "content": "It doesn\\'t require DP though. You only think it\\'s harder than it is because you\\'re overthinking it. You can use sliding window and just keep track of the lowest price as you go."
                    },
                    {
                        "username": "rwatso",
                        "content": "[@lucky_nik77](/lucky_nik77) Because by its very nature DP is not a beginner / easy level topic."
                    },
                    {
                        "username": "Vectorido",
                        "content": "[@lucky_nik77](/lucky_nik77) This is not hard for simple lists. But all people here usually stuck at TimeLimit error. So algorithm should be another, at least medium level of complexity."
                    },
                    {
                        "username": "lucky_nik77",
                        "content": "But why? It is hard to think about a DP problem that would be easier than this."
                    },
                    {
                        "username": "tiwarimrutunjay",
                        "content": "agreed"
                    },
                    {
                        "username": "codernoob",
                        "content": "how to resolve the time exceeded issue? Mine fails at 203rd test case with a large array"
                    },
                    {
                        "username": "user4279js",
                        "content": "[@rajamandalofficial56](/rajamandalofficial56) I\\'m not a javascript expert, but probably doing prices.slice(index) is looping 0 -index eachtime ... so you have O(N\\n^2) soltuion overall"
                    },
                    {
                        "username": "Behnoosh",
                        "content": "[@htooak2014](/htooak2014) To me it was occurring when my code had an O(n^2) complexity. Resolving that (to O(n)) solved this problem. I start from the end of the array prices and dynamically find the max value from the end of the array until the current step backwards. This way, at the end of the for loop, we can find the max profit with only one single pass over all entries of the array."
                    },
                    {
                        "username": "eyastaifour",
                        "content": "[@htooak2014](/htooak2014) I am hitting a limit error as well and I believe that it is because I keep on querying max() of the window, but when I think of it the max is either on the first index of the window (as I descend), or somewhere else, in which case, it should be cached as it doesnt change... at least, that\\'s what i am thinking\\n"
                    },
                    {
                        "username": "PercyJia95",
                        "content": "[@rajamandalofficial56](/rajamandalofficial56) You need to reconsider your variable naming. They carry very few meanings."
                    },
                    {
                        "username": "knotri",
                        "content": "[@rajamandalofficial56](/rajamandalofficial56) since u iterate over N elements with prices.map, and for each elements u call Math.max(...prices.slice) u need approx additional 1/2N to find maximum. So O(n) = n^2"
                    },
                    {
                        "username": "rajamandalofficial56",
                        "content": " let max = 0;\\n\\n    prices.map((el,index) => {\\n      let tem =  Math.max(...prices.slice(index))\\n      if(el< tem){\\n         if(max< tem-el){\\n             max = tem-el\\n         }\\n      }\\n    })\\n    return max\\n\\nError : Time Limit Exceeded\\n\\nO(n) complexity\\nwhat\\'s wrong this approach? "
                    },
                    {
                        "username": "htooak2014",
                        "content": "me too. time limit error occurs. why? leetcode compiler error?"
                    },
                    {
                        "username": "drmolenhouse",
                        "content": "Same issue, using the LeetCode Official solution lmao. What am I paying $35/month for?"
                    },
                    {
                        "username": "user4387LF",
                        "content": "Because you may be using a brute force approach with two loops checking every combination which takes O(n2) time; Cause it exceeds time limit. Optimize your code. Think to solve it in one pass with one loop in linear time."
                    },
                    {
                        "username": "Sahil481",
                        "content": "Your code is not well optimised. It is not ran within the given time limit."
                    },
                    {
                        "username": "pstrait",
                        "content": "Are you doing it with more than one loop? If so, there\\'s a better solution that has O(n) time complexity"
                    },
                    {
                        "username": "leet_code_master",
                        "content": "prices = [2, 4, 1]\\n\\nOutput: 0\\nExpected: 2\\n\\nYou buy on day three but cannot sell because it is the last day. Should that not be zero?"
                    },
                    {
                        "username": "langhudson870",
                        "content": "You should buy on day 1 and sell on day 2"
                    },
                    {
                        "username": "almaas21",
                        "content": "[@user4391xh](/user4391xh) \\nthe output required is max profit through traversing  in the list, it could be adjacent too like in [2,4,1] max_profit here is 2 not 0"
                    },
                    {
                        "username": "ashish_bhosale848",
                        "content": "Yes , I am facing the same issue at case 154"
                    },
                    {
                        "username": "user4391xh",
                        "content": "According to the example 2 \\n(Input: prices = [7,6,4,3,1]\\nOutput: 0\\nExplanation: In this case, no transactions are done and the max profit = 0.)\\nin the task description, 0 should be returned so looks like tests expect incorrect value here.."
                    },
                    {
                        "username": "kaushit",
                        "content": "[@mp9508](/mp9508) I also done the same thing but if that solution is wrong then what approach should we think."
                    },
                    {
                        "username": "shubhamDhapola",
                        "content": "you buy on the first day and sell on the second"
                    },
                    {
                        "username": "sazuki",
                        "content": "[@mp9508](/mp9508) This happend to me too, because ahahah well, the first value that is taken is the min() so basically 1, but this is the last one because that will end in a 0 output. "
                    },
                    {
                        "username": "HarshitBansal122",
                        "content": "buy on first day and sell on second day makes profit 2 "
                    },
                    {
                        "username": "Dan_A_S",
                        "content": "[@mkv1892](/mkv1892) I don\\'t agree with that (except if the explanation of the problem is not correct). What I understood from the explanation is, you buy when the price is cheapest and sell on a later date when you can maximize profit (meaning the highest prize on a later date from the date of purchase). Going by that, you buy at 1 so the output should be zero and not the expected 2."
                    },
                    {
                        "username": "mkv1892",
                        "content": "No, Here you buy at day 1, Where the buy price is 2 and sell at day 2, Where the sell price is 4."
                    },
                    {
                        "username": "Byas_Yadav",
                        "content": "[@mp9508](/mp9508) you buy on day 1 and sell it on day 2 i.e. profit =sell-buy --> 4-2=2"
                    },
                    {
                        "username": "mp9508",
                        "content": "[@leet_code_master](/leet_code_master) happened the same to me . the approach i took is:\\nfind the minimum element and then maxi=mini then use a loop from the next index of the lowest mini element and then find maxi, then return the output.\\nhope this helps\\n"
                    },
                    {
                        "username": "VaishaliChauhan",
                        "content": "We need to maximize profit, you can buy at 2 and sell on 4, giving a profit of 2"
                    },
                    {
                        "username": "IbrahimJunior",
                        "content": "you have to maintain your profit in a variable and only change the variable if the new profit is greater than the previous one, so for this scenario, 2 is the former profit, 0 is the new one, it is not greater than 2 so you don\\'t change your profit."
                    },
                    {
                        "username": "Hanagaki_Takimichy",
                        "content": "buy = 2 and sell = 4 profit = 2\\ni am facing the same problem bro............."
                    },
                    {
                        "username": "MatsRivel",
                        "content": "[@leet_code_master](/leet_code_master) What I did was look at what the largest value after i is for each i, and what the smallest value is before each i. Then, for each i, i subtract smallest from largest. This is your optimal profit for buying before i and selling after i. Now you just find the largest number out of these, and you\\'re done."
                    },
                    {
                        "username": "leet_code_master",
                        "content": "[@MeriemA](/MeriemA) I see. Thank you :) How do you recommend I go about this? Because now the new code I make messes up the second test case."
                    },
                    {
                        "username": "MeriemA",
                        "content": "Actually,  the idea here is how you can make the maximum of profits. You don\\'t have to buy the stock when it\\'s at its lowest price.\\nHere you can buy the first day and sell the second day and still make a profit which is 2.\\n"
                    },
                    {
                        "username": "EXLsunshine",
                        "content": "Why is this problem tagged with \"Dynamic programming\"?"
                    },
                    {
                        "username": "princebillygk2",
                        "content": "[@aryan14decsingh](/aryan14decsingh) The problem can be solved in Dynamic way but the more efficient way is array traversal approach."
                    },
                    {
                        "username": "Mrinal2100",
                        "content": "It should be tagged as two pointer problem"
                    },
                    {
                        "username": "aryan14decsingh",
                        "content": "Because it is Dynamic  ( debatable ) \\nquestion apart , did you get any job by now ? you posted this on 2015 , if you are still alive let me know if you got any jobs and some tips aswell"
                    },
                    {
                        "username": "djslim",
                        "content": "[@sourov1407](/sourov1407)  tbh it\\'s classic greedy problem, interestingly in leetcode 75 they marked it as greedy"
                    },
                    {
                        "username": "sahle123",
                        "content": "[@AdityaBhate](/AdityaBhate) He/she was asking a question, not for a solution."
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# \\uD83D\\uDEA9Easy C++ O(N) Soln. [ FAANG\\uD83D\\uDE31 Interview Optimized code ]\\n\\nhttps://leetcode.com/problems/best-time-to-buy-and-sell-stock/solutions/2822579/easy-c-o-n-soln-faang-interview-optimized-code/\\n\\n"
                    },
                    {
                        "username": "sourov1407",
                        "content": "Because we can use kadene\\'s algorithm here and as it is widely regarded as dp algorithm so yeah this problem is tagged with dynamic programming"
                    },
                    {
                        "username": "casper07",
                        "content": "I am So dumb...."
                    },
                    {
                        "username": "ydumar",
                        "content": "same bruh"
                    },
                    {
                        "username": "savagesam343",
                        "content": "me too bro, me too..."
                    },
                    {
                        "username": "night07",
                        "content": "me too jit"
                    },
                    {
                        "username": "AlgoEngine",
                        "content": "Video visualizing an intuitive proof of the O(n) solution:\nhttps://youtube.com/watch?v=ioFPBdChabY"
                    },
                    {
                        "username": "astek14",
                        "content": "Thanks it\\'s awesome"
                    },
                    {
                        "username": "shilbabun491",
                        "content": "how to resolve the time exceeded issue? Mine fails at 200th test case with a large array"
                    },
                    {
                        "username": "akelux",
                        "content": "How to get max profit 4 from input [3,2,6,5,0,3]?"
                    },
                    {
                        "username": "jenil59",
                        "content": "buy at 2 and sell at 6"
                    },
                    {
                        "username": "Trinto_610",
                        "content": "damn bro 2013"
                    },
                    {
                        "username": "prasumitmishra",
                        "content": "3 (buy),  2 (buy) , 6 (sell), 5 (hold), 0 (hold), 3 (hold)\\n-3 -2 + (2*6)\\n= -5 + 12 = 7"
                    },
                    {
                        "username": "KayvanShah1",
                        "content": "by selling on 6 and buying on 0\\nwhich means short selling"
                    },
                    {
                        "username": "bhanureddy7",
                        "content": "2,6"
                    },
                    {
                        "username": "Hanagaki_Takimichy",
                        "content": "buy = 2 and sell = 6"
                    },
                    {
                        "username": "hungkiet244203",
                        "content": "[@jannatbushra524](/jannatbushra524) yeah but the profit it provides isnt\\n"
                    },
                    {
                        "username": "MatsRivel",
                        "content": "[@jannatbushra524](/jannatbushra524) Buy at 0, then you have to sell after zero, so the best sell price is 3. 3-0 = 3, 6-2=4"
                    },
                    {
                        "username": "ajjha7203",
                        "content": "6-2 = 4"
                    },
                    {
                        "username": "damajsam93",
                        "content": "6-2 ==> 4 "
                    },
                    {
                        "username": "Jagdeep4485",
                        "content": "6-2= 4"
                    },
                    {
                        "username": "jannatbushra524",
                        "content": "[@rajanhossainkhan](/rajanhossainkhan) isn\\'t \\'0\\' a buy_price ??...and its smallest too."
                    },
                    {
                        "username": "rajanhossainkhan",
                        "content": "Here are the steps - \\n\\n1. First buy out price is 3 and profit is set to 0. \\n2. Now loop through array from index 1, since index 0 (which is 3) is taken as minimum buy out price for now. \\n3. Now if price is 2, then set this as new buy out price, since its smaller. So our current buy out price is 2. \\n4. Now next price is 6. This is bigger, so sell with current buy out price 2. \\n5. Calculate max profit  = max(profit, ( current_price - buy_price) \\n6. In this case, max(0, 6-2) = 4\\n\\nHope this helps. "
                    },
                    {
                        "username": "Amit_Joe",
                        "content": "2 -6\\n"
                    },
                    {
                        "username": "hemantgautam505",
                        "content": "output is 4\\n"
                    },
                    {
                        "username": "Shashi3k",
                        "content": "2-6\\n"
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for February, Day 1.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  **📌 Do you want to learn the problem thoroughly?**\n  Read [**⭐  LeetCode Official Solution⭐**](https://leetcode.com/problems/best-time-to-buy-and-sell-stock/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 2 approaches in the official solution</summary>\n\n  \n**Approach 1:** Brute Force\n\n  \n**Approach 2:** One Pass\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# \\uD83D\\uDEA9Easy C++ O(N) Soln. [ FAANG\\uD83D\\uDE31 Interview Optimized code ]\\n\\nhttps://leetcode.com/problems/best-time-to-buy-and-sell-stock/solutions/2822579/easy-c-o-n-soln-faang-interview-optimized-code/\\n"
                    }
                ]
            },
            {
                "id": 1565340,
                "content": [
                    {
                        "username": "Serosidium",
                        "content": "I couldn\\'t find any good explanations here and only code, so I will do my best to explain how I solved it without providing code. I am sure there are other possible solutions, but this is how it worked for me.\\n\\nThe brute force method of a double for loop is not necessary here, and this problem is marked with dynamic programming because it requires the [Sliding Window technique](https://algorithm-visualizer.org/dynamic-programming/sliding-window).\\n\\nBased on the fact that we have to sell after we buy and we are trying to maximize profit, we can iterate through the prices and only need to consider two things:\\n1.) **Is this price cheaper than any other price I\\'ve seen before?** \\n2.) If I subtract current price by the cheapest price I\\'ve found, **does this yield a greater profit than what I\\'ve seen so far?**\\n\\n*A fun thing to note is if #1 is true, then #2 cannot be true as well so there isn\\'t a need to check*\\n\\nLet\\'s consider an example of [4,1,5,2,7]\\n- 4 is the cheapest price we see to start, and we can\\'t sell on the first day so maxProfit is 0\\n- 1 is now the cheapest price we\\'ve seen. Selling now would lose us money, so we can\\'t update maxProfit\\n- 5 is not cheaper than 1, but if we sell now we get a maxProfit of 4! Better save that for later\\n- 2 is not cheaper than 1 and if we sell, we only get a profit of 1, no need to do anything here\\n- 7 is not cheaper than 1, but if we sell here, we\\'ll increase maxProfit to 6, making this the best profit to return.\\n\\nHope this helps someone else!\\n"
                    },
                    {
                        "username": "Manidgyf_6",
                        "content": "Thank you bro"
                    },
                    {
                        "username": "lorentzimys",
                        "content": "Awesome solution, thanks!"
                    },
                    {
                        "username": "Khoa268",
                        "content": "thanks for sharing!"
                    },
                    {
                        "username": "omeh-a",
                        "content": "This is not a DP solution as described, it is greedy"
                    },
                    {
                        "username": "ankitk742",
                        "content": "Thanks bro for your help without code really appreciate "
                    },
                    {
                        "username": "245120733119",
                        "content": "Brilliant!! Thanks for sharing!!"
                    },
                    {
                        "username": "Aniket_sggs",
                        "content": "Initially, this seemed to be DP problem. but after reading this description it is clear that this is basic problem with greedy solution."
                    },
                    {
                        "username": "duffinson97",
                        "content": "Thank you for not posting code, I don\\'t understand the sliding window technique or how this applies to that. I google it and the image link to this problem doesn\\'t make a lot of sense to me. But this solution works thanks"
                    },
                    {
                        "username": "typranjal1",
                        "content": "Thank you!."
                    },
                    {
                        "username": "jakho100",
                        "content": "was stuck on it for hours, thanks for the simple explanation! "
                    },
                    {
                        "username": "zafeer_rangoonwala",
                        "content": "I was originally not able to solve it but after reading your thought process it was a cake walk! \\n\\nThanks! "
                    },
                    {
                        "username": "mohammed1212345",
                        "content": "thank for helping out"
                    },
                    {
                        "username": "dungtuanuet",
                        "content": "Exellent explaination!"
                    },
                    {
                        "username": "kcleland18",
                        "content": "This was a great explanation!! Thanks!"
                    },
                    {
                        "username": "as358",
                        "content": "Best Explanation ever !!!"
                    },
                    {
                        "username": "user6798sW",
                        "content": "AWESOME BREAKDOWN! Ty"
                    },
                    {
                        "username": "jaydeep-pro",
                        "content": "[@evoniuk](/evoniuk) exactly! "
                    },
                    {
                        "username": "akshaydusad",
                        "content": "okay this is genius and surprisingly easier to follow!"
                    },
                    {
                        "username": "evoniuk",
                        "content": "Thank you! This is a solution that\\'s so simple and obvious once you see it you kick yourself for not thinking of it yourself!"
                    },
                    {
                        "username": "ivantchev",
                        "content": "How would the original wording of the problem have to be modified so that the double loop solution _has_ to be used?"
                    },
                    {
                        "username": "ivantchev",
                        "content": "Very helpful, thank you! To add: the reason why using your point 1.) works as a valid check is because given the problem constraints, it will always yield a higher profit down the line regardless of future values.\\n\\nAnd point  2.) shows we don\\'t need a second loop.\\n\\nI wonder, can any concrete aspect of the problem  be used as a clue so that we can reach Serosidium\\'s solution  independently. "
                    },
                    {
                        "username": "VishnuKesav",
                        "content": "[@sharpsailor](/sharpsailor) our target is to get highest possible profit.\\nYou are focusing on buying for the lowest price alone. No matter how low the price is, buying on a last day will yield 0 profit.\\n"
                    },
                    {
                        "username": "kaushar",
                        "content": "[@tengxianrui](/tengxianrui) Thanks  !"
                    },
                    {
                        "username": "neelimag459",
                        "content": "Thank you so much for such good explanation. Happy coding."
                    },
                    {
                        "username": "Nbs-26",
                        "content": "Thank u brother. Your explanation is very clear and well defined."
                    },
                    {
                        "username": "Dabchinsky",
                        "content": "[@sharpsailor](/sharpsailor) if we buy on 2 and sell on 4, our profit would be 4 - 2 = 2. "
                    },
                    {
                        "username": "sharpsailor",
                        "content": "check for {2,4,1} ideally it should give 0 but leetcode gives 2..Help me figure out where am I getting it wrong\\n"
                    },
                    {
                        "username": "jackbb147",
                        "content": "that\\'s actually very smart... thanks"
                    },
                    {
                        "username": "chiahao1",
                        "content": "Thank you! Your technique worked for me."
                    },
                    {
                        "username": "Marre-86",
                        "content": "Man, you made my day! I spent two hours and wrote almost 100 hundred lines code that probably was soving it but had \"time limit exceeded\" with huge input. And after your explanation I rewrite it in freaking 7 lines and it made it right off the bat!"
                    },
                    {
                        "username": "m1ma087",
                        "content": "Best tip! Thanks!"
                    },
                    {
                        "username": "sasaalina1985",
                        "content": "was reading this and solved the problem first try! Very good explanation!!!"
                    },
                    {
                        "username": "Yash_6207",
                        "content": "This is what we call as Greedy ! Good Explanation\\n"
                    },
                    {
                        "username": "iosifpetrupuha",
                        "content": "[@fjod](/fjod) but it\\'s buy day that should be before then sellday"
                    },
                    {
                        "username": "iosifpetrupuha",
                        "content": "[@iosifpetrupuha](/iosifpetrupuha) daaamn there is no indentation in this comment section"
                    },
                    {
                        "username": "iosifpetrupuha",
                        "content": "so I didn\\'t know this was called sliding window or sumthin, but I am second year at CS university, i have some grasp of this kind of logic and I solved it this way:\\nclass Solution:\\n    def maxProfit(self, prices: List[int]) -> int:\\n        #you obviously must buy before you sell(can\\'t go back in time)\\n        GreatestProfit=0\\n        priceToBeat=prices[0]\\n        for i in range(len(prices)-1):#we can iterate through the whole list, otherwise we get out of bounds, so we iterate from the first to the penultimate (so the last comparation we do is between the penultimate and the last element) \\n            if prices[i]<prices[i+1]:#sure profit, possible greatest profit\\n                if prices[i]<=priceToBeat:\\n                    priceToBeat=prices[i]\\n                if GreatestProfit<=prices[i+1]-priceToBeat: #if the GreatestProfit we calculate is greater than the one we have already, we update the Greatest Profit, otherwise we do nothing\\n                    GreatestProfit=prices[i+1]-priceToBeat\\n        return GreatestProfit\\nis this a proper way to solve this kind of problems? (in terms of efficiency I think we\\'re in O(n) so it should be pretty good"
                    },
                    {
                        "username": "Rohit_8412",
                        "content": "Thanks, I was about to see the solution after 10 min I didn\\'t get an approach into my mind.\\nThen I saw your discussion and I solved the question myself \\uD83D\\uDE0E"
                    },
                    {
                        "username": "fjod",
                        "content": "your explanation does not include rule of sellDay must be after buyDay"
                    },
                    {
                        "username": "Hanagaki_Takimichy",
                        "content": "thanks for great explaination without any spoilers.\\ni will try my best for the code, thanks a lot ;)"
                    },
                    {
                        "username": "csrnontol",
                        "content": "Sounds good, but I think your tip fails for [2,9,3,4,5,1,7] (how you\\'d choose 2, 9) and [2,9,3,4,5,1,7,10] (how you\\'d choose 1, 10)."
                    },
                    {
                        "username": "rockmanex",
                        "content": "best explanations so far. Thankyou it\\'s help a lot"
                    },
                    {
                        "username": "ak67",
                        "content": "I think this problem should be catogarise as medium level problem\\n"
                    },
                    {
                        "username": "Sultan_Ul_Arfin",
                        "content": "[@chazwinter](/chazwinter) what is sliding window? I never heard it ..will you explain that please<3\\n "
                    },
                    {
                        "username": "chazwinter",
                        "content": "It doesn\\'t require DP though. You only think it\\'s harder than it is because you\\'re overthinking it. You can use sliding window and just keep track of the lowest price as you go."
                    },
                    {
                        "username": "rwatso",
                        "content": "[@lucky_nik77](/lucky_nik77) Because by its very nature DP is not a beginner / easy level topic."
                    },
                    {
                        "username": "Vectorido",
                        "content": "[@lucky_nik77](/lucky_nik77) This is not hard for simple lists. But all people here usually stuck at TimeLimit error. So algorithm should be another, at least medium level of complexity."
                    },
                    {
                        "username": "lucky_nik77",
                        "content": "But why? It is hard to think about a DP problem that would be easier than this."
                    },
                    {
                        "username": "tiwarimrutunjay",
                        "content": "agreed"
                    },
                    {
                        "username": "codernoob",
                        "content": "how to resolve the time exceeded issue? Mine fails at 203rd test case with a large array"
                    },
                    {
                        "username": "user4279js",
                        "content": "[@rajamandalofficial56](/rajamandalofficial56) I\\'m not a javascript expert, but probably doing prices.slice(index) is looping 0 -index eachtime ... so you have O(N\\n^2) soltuion overall"
                    },
                    {
                        "username": "Behnoosh",
                        "content": "[@htooak2014](/htooak2014) To me it was occurring when my code had an O(n^2) complexity. Resolving that (to O(n)) solved this problem. I start from the end of the array prices and dynamically find the max value from the end of the array until the current step backwards. This way, at the end of the for loop, we can find the max profit with only one single pass over all entries of the array."
                    },
                    {
                        "username": "eyastaifour",
                        "content": "[@htooak2014](/htooak2014) I am hitting a limit error as well and I believe that it is because I keep on querying max() of the window, but when I think of it the max is either on the first index of the window (as I descend), or somewhere else, in which case, it should be cached as it doesnt change... at least, that\\'s what i am thinking\\n"
                    },
                    {
                        "username": "PercyJia95",
                        "content": "[@rajamandalofficial56](/rajamandalofficial56) You need to reconsider your variable naming. They carry very few meanings."
                    },
                    {
                        "username": "knotri",
                        "content": "[@rajamandalofficial56](/rajamandalofficial56) since u iterate over N elements with prices.map, and for each elements u call Math.max(...prices.slice) u need approx additional 1/2N to find maximum. So O(n) = n^2"
                    },
                    {
                        "username": "rajamandalofficial56",
                        "content": " let max = 0;\\n\\n    prices.map((el,index) => {\\n      let tem =  Math.max(...prices.slice(index))\\n      if(el< tem){\\n         if(max< tem-el){\\n             max = tem-el\\n         }\\n      }\\n    })\\n    return max\\n\\nError : Time Limit Exceeded\\n\\nO(n) complexity\\nwhat\\'s wrong this approach? "
                    },
                    {
                        "username": "htooak2014",
                        "content": "me too. time limit error occurs. why? leetcode compiler error?"
                    },
                    {
                        "username": "drmolenhouse",
                        "content": "Same issue, using the LeetCode Official solution lmao. What am I paying $35/month for?"
                    },
                    {
                        "username": "user4387LF",
                        "content": "Because you may be using a brute force approach with two loops checking every combination which takes O(n2) time; Cause it exceeds time limit. Optimize your code. Think to solve it in one pass with one loop in linear time."
                    },
                    {
                        "username": "Sahil481",
                        "content": "Your code is not well optimised. It is not ran within the given time limit."
                    },
                    {
                        "username": "pstrait",
                        "content": "Are you doing it with more than one loop? If so, there\\'s a better solution that has O(n) time complexity"
                    },
                    {
                        "username": "leet_code_master",
                        "content": "prices = [2, 4, 1]\\n\\nOutput: 0\\nExpected: 2\\n\\nYou buy on day three but cannot sell because it is the last day. Should that not be zero?"
                    },
                    {
                        "username": "langhudson870",
                        "content": "You should buy on day 1 and sell on day 2"
                    },
                    {
                        "username": "almaas21",
                        "content": "[@user4391xh](/user4391xh) \\nthe output required is max profit through traversing  in the list, it could be adjacent too like in [2,4,1] max_profit here is 2 not 0"
                    },
                    {
                        "username": "ashish_bhosale848",
                        "content": "Yes , I am facing the same issue at case 154"
                    },
                    {
                        "username": "user4391xh",
                        "content": "According to the example 2 \\n(Input: prices = [7,6,4,3,1]\\nOutput: 0\\nExplanation: In this case, no transactions are done and the max profit = 0.)\\nin the task description, 0 should be returned so looks like tests expect incorrect value here.."
                    },
                    {
                        "username": "kaushit",
                        "content": "[@mp9508](/mp9508) I also done the same thing but if that solution is wrong then what approach should we think."
                    },
                    {
                        "username": "shubhamDhapola",
                        "content": "you buy on the first day and sell on the second"
                    },
                    {
                        "username": "sazuki",
                        "content": "[@mp9508](/mp9508) This happend to me too, because ahahah well, the first value that is taken is the min() so basically 1, but this is the last one because that will end in a 0 output. "
                    },
                    {
                        "username": "HarshitBansal122",
                        "content": "buy on first day and sell on second day makes profit 2 "
                    },
                    {
                        "username": "Dan_A_S",
                        "content": "[@mkv1892](/mkv1892) I don\\'t agree with that (except if the explanation of the problem is not correct). What I understood from the explanation is, you buy when the price is cheapest and sell on a later date when you can maximize profit (meaning the highest prize on a later date from the date of purchase). Going by that, you buy at 1 so the output should be zero and not the expected 2."
                    },
                    {
                        "username": "mkv1892",
                        "content": "No, Here you buy at day 1, Where the buy price is 2 and sell at day 2, Where the sell price is 4."
                    },
                    {
                        "username": "Byas_Yadav",
                        "content": "[@mp9508](/mp9508) you buy on day 1 and sell it on day 2 i.e. profit =sell-buy --> 4-2=2"
                    },
                    {
                        "username": "mp9508",
                        "content": "[@leet_code_master](/leet_code_master) happened the same to me . the approach i took is:\\nfind the minimum element and then maxi=mini then use a loop from the next index of the lowest mini element and then find maxi, then return the output.\\nhope this helps\\n"
                    },
                    {
                        "username": "VaishaliChauhan",
                        "content": "We need to maximize profit, you can buy at 2 and sell on 4, giving a profit of 2"
                    },
                    {
                        "username": "IbrahimJunior",
                        "content": "you have to maintain your profit in a variable and only change the variable if the new profit is greater than the previous one, so for this scenario, 2 is the former profit, 0 is the new one, it is not greater than 2 so you don\\'t change your profit."
                    },
                    {
                        "username": "Hanagaki_Takimichy",
                        "content": "buy = 2 and sell = 4 profit = 2\\ni am facing the same problem bro............."
                    },
                    {
                        "username": "MatsRivel",
                        "content": "[@leet_code_master](/leet_code_master) What I did was look at what the largest value after i is for each i, and what the smallest value is before each i. Then, for each i, i subtract smallest from largest. This is your optimal profit for buying before i and selling after i. Now you just find the largest number out of these, and you\\'re done."
                    },
                    {
                        "username": "leet_code_master",
                        "content": "[@MeriemA](/MeriemA) I see. Thank you :) How do you recommend I go about this? Because now the new code I make messes up the second test case."
                    },
                    {
                        "username": "MeriemA",
                        "content": "Actually,  the idea here is how you can make the maximum of profits. You don\\'t have to buy the stock when it\\'s at its lowest price.\\nHere you can buy the first day and sell the second day and still make a profit which is 2.\\n"
                    },
                    {
                        "username": "EXLsunshine",
                        "content": "Why is this problem tagged with \"Dynamic programming\"?"
                    },
                    {
                        "username": "princebillygk2",
                        "content": "[@aryan14decsingh](/aryan14decsingh) The problem can be solved in Dynamic way but the more efficient way is array traversal approach."
                    },
                    {
                        "username": "Mrinal2100",
                        "content": "It should be tagged as two pointer problem"
                    },
                    {
                        "username": "aryan14decsingh",
                        "content": "Because it is Dynamic  ( debatable ) \\nquestion apart , did you get any job by now ? you posted this on 2015 , if you are still alive let me know if you got any jobs and some tips aswell"
                    },
                    {
                        "username": "djslim",
                        "content": "[@sourov1407](/sourov1407)  tbh it\\'s classic greedy problem, interestingly in leetcode 75 they marked it as greedy"
                    },
                    {
                        "username": "sahle123",
                        "content": "[@AdityaBhate](/AdityaBhate) He/she was asking a question, not for a solution."
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# \\uD83D\\uDEA9Easy C++ O(N) Soln. [ FAANG\\uD83D\\uDE31 Interview Optimized code ]\\n\\nhttps://leetcode.com/problems/best-time-to-buy-and-sell-stock/solutions/2822579/easy-c-o-n-soln-faang-interview-optimized-code/\\n\\n"
                    },
                    {
                        "username": "sourov1407",
                        "content": "Because we can use kadene\\'s algorithm here and as it is widely regarded as dp algorithm so yeah this problem is tagged with dynamic programming"
                    },
                    {
                        "username": "casper07",
                        "content": "I am So dumb...."
                    },
                    {
                        "username": "ydumar",
                        "content": "same bruh"
                    },
                    {
                        "username": "savagesam343",
                        "content": "me too bro, me too..."
                    },
                    {
                        "username": "night07",
                        "content": "me too jit"
                    },
                    {
                        "username": "AlgoEngine",
                        "content": "Video visualizing an intuitive proof of the O(n) solution:\nhttps://youtube.com/watch?v=ioFPBdChabY"
                    },
                    {
                        "username": "astek14",
                        "content": "Thanks it\\'s awesome"
                    },
                    {
                        "username": "shilbabun491",
                        "content": "how to resolve the time exceeded issue? Mine fails at 200th test case with a large array"
                    },
                    {
                        "username": "akelux",
                        "content": "How to get max profit 4 from input [3,2,6,5,0,3]?"
                    },
                    {
                        "username": "jenil59",
                        "content": "buy at 2 and sell at 6"
                    },
                    {
                        "username": "Trinto_610",
                        "content": "damn bro 2013"
                    },
                    {
                        "username": "prasumitmishra",
                        "content": "3 (buy),  2 (buy) , 6 (sell), 5 (hold), 0 (hold), 3 (hold)\\n-3 -2 + (2*6)\\n= -5 + 12 = 7"
                    },
                    {
                        "username": "KayvanShah1",
                        "content": "by selling on 6 and buying on 0\\nwhich means short selling"
                    },
                    {
                        "username": "bhanureddy7",
                        "content": "2,6"
                    },
                    {
                        "username": "Hanagaki_Takimichy",
                        "content": "buy = 2 and sell = 6"
                    },
                    {
                        "username": "hungkiet244203",
                        "content": "[@jannatbushra524](/jannatbushra524) yeah but the profit it provides isnt\\n"
                    },
                    {
                        "username": "MatsRivel",
                        "content": "[@jannatbushra524](/jannatbushra524) Buy at 0, then you have to sell after zero, so the best sell price is 3. 3-0 = 3, 6-2=4"
                    },
                    {
                        "username": "ajjha7203",
                        "content": "6-2 = 4"
                    },
                    {
                        "username": "damajsam93",
                        "content": "6-2 ==> 4 "
                    },
                    {
                        "username": "Jagdeep4485",
                        "content": "6-2= 4"
                    },
                    {
                        "username": "jannatbushra524",
                        "content": "[@rajanhossainkhan](/rajanhossainkhan) isn\\'t \\'0\\' a buy_price ??...and its smallest too."
                    },
                    {
                        "username": "rajanhossainkhan",
                        "content": "Here are the steps - \\n\\n1. First buy out price is 3 and profit is set to 0. \\n2. Now loop through array from index 1, since index 0 (which is 3) is taken as minimum buy out price for now. \\n3. Now if price is 2, then set this as new buy out price, since its smaller. So our current buy out price is 2. \\n4. Now next price is 6. This is bigger, so sell with current buy out price 2. \\n5. Calculate max profit  = max(profit, ( current_price - buy_price) \\n6. In this case, max(0, 6-2) = 4\\n\\nHope this helps. "
                    },
                    {
                        "username": "Amit_Joe",
                        "content": "2 -6\\n"
                    },
                    {
                        "username": "hemantgautam505",
                        "content": "output is 4\\n"
                    },
                    {
                        "username": "Shashi3k",
                        "content": "2-6\\n"
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for February, Day 1.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  **📌 Do you want to learn the problem thoroughly?**\n  Read [**⭐  LeetCode Official Solution⭐**](https://leetcode.com/problems/best-time-to-buy-and-sell-stock/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 2 approaches in the official solution</summary>\n\n  \n**Approach 1:** Brute Force\n\n  \n**Approach 2:** One Pass\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# \\uD83D\\uDEA9Easy C++ O(N) Soln. [ FAANG\\uD83D\\uDE31 Interview Optimized code ]\\n\\nhttps://leetcode.com/problems/best-time-to-buy-and-sell-stock/solutions/2822579/easy-c-o-n-soln-faang-interview-optimized-code/\\n"
                    }
                ]
            },
            {
                "id": 1757990,
                "content": [
                    {
                        "username": "Serosidium",
                        "content": "I couldn\\'t find any good explanations here and only code, so I will do my best to explain how I solved it without providing code. I am sure there are other possible solutions, but this is how it worked for me.\\n\\nThe brute force method of a double for loop is not necessary here, and this problem is marked with dynamic programming because it requires the [Sliding Window technique](https://algorithm-visualizer.org/dynamic-programming/sliding-window).\\n\\nBased on the fact that we have to sell after we buy and we are trying to maximize profit, we can iterate through the prices and only need to consider two things:\\n1.) **Is this price cheaper than any other price I\\'ve seen before?** \\n2.) If I subtract current price by the cheapest price I\\'ve found, **does this yield a greater profit than what I\\'ve seen so far?**\\n\\n*A fun thing to note is if #1 is true, then #2 cannot be true as well so there isn\\'t a need to check*\\n\\nLet\\'s consider an example of [4,1,5,2,7]\\n- 4 is the cheapest price we see to start, and we can\\'t sell on the first day so maxProfit is 0\\n- 1 is now the cheapest price we\\'ve seen. Selling now would lose us money, so we can\\'t update maxProfit\\n- 5 is not cheaper than 1, but if we sell now we get a maxProfit of 4! Better save that for later\\n- 2 is not cheaper than 1 and if we sell, we only get a profit of 1, no need to do anything here\\n- 7 is not cheaper than 1, but if we sell here, we\\'ll increase maxProfit to 6, making this the best profit to return.\\n\\nHope this helps someone else!\\n"
                    },
                    {
                        "username": "Manidgyf_6",
                        "content": "Thank you bro"
                    },
                    {
                        "username": "lorentzimys",
                        "content": "Awesome solution, thanks!"
                    },
                    {
                        "username": "Khoa268",
                        "content": "thanks for sharing!"
                    },
                    {
                        "username": "omeh-a",
                        "content": "This is not a DP solution as described, it is greedy"
                    },
                    {
                        "username": "ankitk742",
                        "content": "Thanks bro for your help without code really appreciate "
                    },
                    {
                        "username": "245120733119",
                        "content": "Brilliant!! Thanks for sharing!!"
                    },
                    {
                        "username": "Aniket_sggs",
                        "content": "Initially, this seemed to be DP problem. but after reading this description it is clear that this is basic problem with greedy solution."
                    },
                    {
                        "username": "duffinson97",
                        "content": "Thank you for not posting code, I don\\'t understand the sliding window technique or how this applies to that. I google it and the image link to this problem doesn\\'t make a lot of sense to me. But this solution works thanks"
                    },
                    {
                        "username": "typranjal1",
                        "content": "Thank you!."
                    },
                    {
                        "username": "jakho100",
                        "content": "was stuck on it for hours, thanks for the simple explanation! "
                    },
                    {
                        "username": "zafeer_rangoonwala",
                        "content": "I was originally not able to solve it but after reading your thought process it was a cake walk! \\n\\nThanks! "
                    },
                    {
                        "username": "mohammed1212345",
                        "content": "thank for helping out"
                    },
                    {
                        "username": "dungtuanuet",
                        "content": "Exellent explaination!"
                    },
                    {
                        "username": "kcleland18",
                        "content": "This was a great explanation!! Thanks!"
                    },
                    {
                        "username": "as358",
                        "content": "Best Explanation ever !!!"
                    },
                    {
                        "username": "user6798sW",
                        "content": "AWESOME BREAKDOWN! Ty"
                    },
                    {
                        "username": "jaydeep-pro",
                        "content": "[@evoniuk](/evoniuk) exactly! "
                    },
                    {
                        "username": "akshaydusad",
                        "content": "okay this is genius and surprisingly easier to follow!"
                    },
                    {
                        "username": "evoniuk",
                        "content": "Thank you! This is a solution that\\'s so simple and obvious once you see it you kick yourself for not thinking of it yourself!"
                    },
                    {
                        "username": "ivantchev",
                        "content": "How would the original wording of the problem have to be modified so that the double loop solution _has_ to be used?"
                    },
                    {
                        "username": "ivantchev",
                        "content": "Very helpful, thank you! To add: the reason why using your point 1.) works as a valid check is because given the problem constraints, it will always yield a higher profit down the line regardless of future values.\\n\\nAnd point  2.) shows we don\\'t need a second loop.\\n\\nI wonder, can any concrete aspect of the problem  be used as a clue so that we can reach Serosidium\\'s solution  independently. "
                    },
                    {
                        "username": "VishnuKesav",
                        "content": "[@sharpsailor](/sharpsailor) our target is to get highest possible profit.\\nYou are focusing on buying for the lowest price alone. No matter how low the price is, buying on a last day will yield 0 profit.\\n"
                    },
                    {
                        "username": "kaushar",
                        "content": "[@tengxianrui](/tengxianrui) Thanks  !"
                    },
                    {
                        "username": "neelimag459",
                        "content": "Thank you so much for such good explanation. Happy coding."
                    },
                    {
                        "username": "Nbs-26",
                        "content": "Thank u brother. Your explanation is very clear and well defined."
                    },
                    {
                        "username": "Dabchinsky",
                        "content": "[@sharpsailor](/sharpsailor) if we buy on 2 and sell on 4, our profit would be 4 - 2 = 2. "
                    },
                    {
                        "username": "sharpsailor",
                        "content": "check for {2,4,1} ideally it should give 0 but leetcode gives 2..Help me figure out where am I getting it wrong\\n"
                    },
                    {
                        "username": "jackbb147",
                        "content": "that\\'s actually very smart... thanks"
                    },
                    {
                        "username": "chiahao1",
                        "content": "Thank you! Your technique worked for me."
                    },
                    {
                        "username": "Marre-86",
                        "content": "Man, you made my day! I spent two hours and wrote almost 100 hundred lines code that probably was soving it but had \"time limit exceeded\" with huge input. And after your explanation I rewrite it in freaking 7 lines and it made it right off the bat!"
                    },
                    {
                        "username": "m1ma087",
                        "content": "Best tip! Thanks!"
                    },
                    {
                        "username": "sasaalina1985",
                        "content": "was reading this and solved the problem first try! Very good explanation!!!"
                    },
                    {
                        "username": "Yash_6207",
                        "content": "This is what we call as Greedy ! Good Explanation\\n"
                    },
                    {
                        "username": "iosifpetrupuha",
                        "content": "[@fjod](/fjod) but it\\'s buy day that should be before then sellday"
                    },
                    {
                        "username": "iosifpetrupuha",
                        "content": "[@iosifpetrupuha](/iosifpetrupuha) daaamn there is no indentation in this comment section"
                    },
                    {
                        "username": "iosifpetrupuha",
                        "content": "so I didn\\'t know this was called sliding window or sumthin, but I am second year at CS university, i have some grasp of this kind of logic and I solved it this way:\\nclass Solution:\\n    def maxProfit(self, prices: List[int]) -> int:\\n        #you obviously must buy before you sell(can\\'t go back in time)\\n        GreatestProfit=0\\n        priceToBeat=prices[0]\\n        for i in range(len(prices)-1):#we can iterate through the whole list, otherwise we get out of bounds, so we iterate from the first to the penultimate (so the last comparation we do is between the penultimate and the last element) \\n            if prices[i]<prices[i+1]:#sure profit, possible greatest profit\\n                if prices[i]<=priceToBeat:\\n                    priceToBeat=prices[i]\\n                if GreatestProfit<=prices[i+1]-priceToBeat: #if the GreatestProfit we calculate is greater than the one we have already, we update the Greatest Profit, otherwise we do nothing\\n                    GreatestProfit=prices[i+1]-priceToBeat\\n        return GreatestProfit\\nis this a proper way to solve this kind of problems? (in terms of efficiency I think we\\'re in O(n) so it should be pretty good"
                    },
                    {
                        "username": "Rohit_8412",
                        "content": "Thanks, I was about to see the solution after 10 min I didn\\'t get an approach into my mind.\\nThen I saw your discussion and I solved the question myself \\uD83D\\uDE0E"
                    },
                    {
                        "username": "fjod",
                        "content": "your explanation does not include rule of sellDay must be after buyDay"
                    },
                    {
                        "username": "Hanagaki_Takimichy",
                        "content": "thanks for great explaination without any spoilers.\\ni will try my best for the code, thanks a lot ;)"
                    },
                    {
                        "username": "csrnontol",
                        "content": "Sounds good, but I think your tip fails for [2,9,3,4,5,1,7] (how you\\'d choose 2, 9) and [2,9,3,4,5,1,7,10] (how you\\'d choose 1, 10)."
                    },
                    {
                        "username": "rockmanex",
                        "content": "best explanations so far. Thankyou it\\'s help a lot"
                    },
                    {
                        "username": "ak67",
                        "content": "I think this problem should be catogarise as medium level problem\\n"
                    },
                    {
                        "username": "Sultan_Ul_Arfin",
                        "content": "[@chazwinter](/chazwinter) what is sliding window? I never heard it ..will you explain that please<3\\n "
                    },
                    {
                        "username": "chazwinter",
                        "content": "It doesn\\'t require DP though. You only think it\\'s harder than it is because you\\'re overthinking it. You can use sliding window and just keep track of the lowest price as you go."
                    },
                    {
                        "username": "rwatso",
                        "content": "[@lucky_nik77](/lucky_nik77) Because by its very nature DP is not a beginner / easy level topic."
                    },
                    {
                        "username": "Vectorido",
                        "content": "[@lucky_nik77](/lucky_nik77) This is not hard for simple lists. But all people here usually stuck at TimeLimit error. So algorithm should be another, at least medium level of complexity."
                    },
                    {
                        "username": "lucky_nik77",
                        "content": "But why? It is hard to think about a DP problem that would be easier than this."
                    },
                    {
                        "username": "tiwarimrutunjay",
                        "content": "agreed"
                    },
                    {
                        "username": "codernoob",
                        "content": "how to resolve the time exceeded issue? Mine fails at 203rd test case with a large array"
                    },
                    {
                        "username": "user4279js",
                        "content": "[@rajamandalofficial56](/rajamandalofficial56) I\\'m not a javascript expert, but probably doing prices.slice(index) is looping 0 -index eachtime ... so you have O(N\\n^2) soltuion overall"
                    },
                    {
                        "username": "Behnoosh",
                        "content": "[@htooak2014](/htooak2014) To me it was occurring when my code had an O(n^2) complexity. Resolving that (to O(n)) solved this problem. I start from the end of the array prices and dynamically find the max value from the end of the array until the current step backwards. This way, at the end of the for loop, we can find the max profit with only one single pass over all entries of the array."
                    },
                    {
                        "username": "eyastaifour",
                        "content": "[@htooak2014](/htooak2014) I am hitting a limit error as well and I believe that it is because I keep on querying max() of the window, but when I think of it the max is either on the first index of the window (as I descend), or somewhere else, in which case, it should be cached as it doesnt change... at least, that\\'s what i am thinking\\n"
                    },
                    {
                        "username": "PercyJia95",
                        "content": "[@rajamandalofficial56](/rajamandalofficial56) You need to reconsider your variable naming. They carry very few meanings."
                    },
                    {
                        "username": "knotri",
                        "content": "[@rajamandalofficial56](/rajamandalofficial56) since u iterate over N elements with prices.map, and for each elements u call Math.max(...prices.slice) u need approx additional 1/2N to find maximum. So O(n) = n^2"
                    },
                    {
                        "username": "rajamandalofficial56",
                        "content": " let max = 0;\\n\\n    prices.map((el,index) => {\\n      let tem =  Math.max(...prices.slice(index))\\n      if(el< tem){\\n         if(max< tem-el){\\n             max = tem-el\\n         }\\n      }\\n    })\\n    return max\\n\\nError : Time Limit Exceeded\\n\\nO(n) complexity\\nwhat\\'s wrong this approach? "
                    },
                    {
                        "username": "htooak2014",
                        "content": "me too. time limit error occurs. why? leetcode compiler error?"
                    },
                    {
                        "username": "drmolenhouse",
                        "content": "Same issue, using the LeetCode Official solution lmao. What am I paying $35/month for?"
                    },
                    {
                        "username": "user4387LF",
                        "content": "Because you may be using a brute force approach with two loops checking every combination which takes O(n2) time; Cause it exceeds time limit. Optimize your code. Think to solve it in one pass with one loop in linear time."
                    },
                    {
                        "username": "Sahil481",
                        "content": "Your code is not well optimised. It is not ran within the given time limit."
                    },
                    {
                        "username": "pstrait",
                        "content": "Are you doing it with more than one loop? If so, there\\'s a better solution that has O(n) time complexity"
                    },
                    {
                        "username": "leet_code_master",
                        "content": "prices = [2, 4, 1]\\n\\nOutput: 0\\nExpected: 2\\n\\nYou buy on day three but cannot sell because it is the last day. Should that not be zero?"
                    },
                    {
                        "username": "langhudson870",
                        "content": "You should buy on day 1 and sell on day 2"
                    },
                    {
                        "username": "almaas21",
                        "content": "[@user4391xh](/user4391xh) \\nthe output required is max profit through traversing  in the list, it could be adjacent too like in [2,4,1] max_profit here is 2 not 0"
                    },
                    {
                        "username": "ashish_bhosale848",
                        "content": "Yes , I am facing the same issue at case 154"
                    },
                    {
                        "username": "user4391xh",
                        "content": "According to the example 2 \\n(Input: prices = [7,6,4,3,1]\\nOutput: 0\\nExplanation: In this case, no transactions are done and the max profit = 0.)\\nin the task description, 0 should be returned so looks like tests expect incorrect value here.."
                    },
                    {
                        "username": "kaushit",
                        "content": "[@mp9508](/mp9508) I also done the same thing but if that solution is wrong then what approach should we think."
                    },
                    {
                        "username": "shubhamDhapola",
                        "content": "you buy on the first day and sell on the second"
                    },
                    {
                        "username": "sazuki",
                        "content": "[@mp9508](/mp9508) This happend to me too, because ahahah well, the first value that is taken is the min() so basically 1, but this is the last one because that will end in a 0 output. "
                    },
                    {
                        "username": "HarshitBansal122",
                        "content": "buy on first day and sell on second day makes profit 2 "
                    },
                    {
                        "username": "Dan_A_S",
                        "content": "[@mkv1892](/mkv1892) I don\\'t agree with that (except if the explanation of the problem is not correct). What I understood from the explanation is, you buy when the price is cheapest and sell on a later date when you can maximize profit (meaning the highest prize on a later date from the date of purchase). Going by that, you buy at 1 so the output should be zero and not the expected 2."
                    },
                    {
                        "username": "mkv1892",
                        "content": "No, Here you buy at day 1, Where the buy price is 2 and sell at day 2, Where the sell price is 4."
                    },
                    {
                        "username": "Byas_Yadav",
                        "content": "[@mp9508](/mp9508) you buy on day 1 and sell it on day 2 i.e. profit =sell-buy --> 4-2=2"
                    },
                    {
                        "username": "mp9508",
                        "content": "[@leet_code_master](/leet_code_master) happened the same to me . the approach i took is:\\nfind the minimum element and then maxi=mini then use a loop from the next index of the lowest mini element and then find maxi, then return the output.\\nhope this helps\\n"
                    },
                    {
                        "username": "VaishaliChauhan",
                        "content": "We need to maximize profit, you can buy at 2 and sell on 4, giving a profit of 2"
                    },
                    {
                        "username": "IbrahimJunior",
                        "content": "you have to maintain your profit in a variable and only change the variable if the new profit is greater than the previous one, so for this scenario, 2 is the former profit, 0 is the new one, it is not greater than 2 so you don\\'t change your profit."
                    },
                    {
                        "username": "Hanagaki_Takimichy",
                        "content": "buy = 2 and sell = 4 profit = 2\\ni am facing the same problem bro............."
                    },
                    {
                        "username": "MatsRivel",
                        "content": "[@leet_code_master](/leet_code_master) What I did was look at what the largest value after i is for each i, and what the smallest value is before each i. Then, for each i, i subtract smallest from largest. This is your optimal profit for buying before i and selling after i. Now you just find the largest number out of these, and you\\'re done."
                    },
                    {
                        "username": "leet_code_master",
                        "content": "[@MeriemA](/MeriemA) I see. Thank you :) How do you recommend I go about this? Because now the new code I make messes up the second test case."
                    },
                    {
                        "username": "MeriemA",
                        "content": "Actually,  the idea here is how you can make the maximum of profits. You don\\'t have to buy the stock when it\\'s at its lowest price.\\nHere you can buy the first day and sell the second day and still make a profit which is 2.\\n"
                    },
                    {
                        "username": "EXLsunshine",
                        "content": "Why is this problem tagged with \"Dynamic programming\"?"
                    },
                    {
                        "username": "princebillygk2",
                        "content": "[@aryan14decsingh](/aryan14decsingh) The problem can be solved in Dynamic way but the more efficient way is array traversal approach."
                    },
                    {
                        "username": "Mrinal2100",
                        "content": "It should be tagged as two pointer problem"
                    },
                    {
                        "username": "aryan14decsingh",
                        "content": "Because it is Dynamic  ( debatable ) \\nquestion apart , did you get any job by now ? you posted this on 2015 , if you are still alive let me know if you got any jobs and some tips aswell"
                    },
                    {
                        "username": "djslim",
                        "content": "[@sourov1407](/sourov1407)  tbh it\\'s classic greedy problem, interestingly in leetcode 75 they marked it as greedy"
                    },
                    {
                        "username": "sahle123",
                        "content": "[@AdityaBhate](/AdityaBhate) He/she was asking a question, not for a solution."
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# \\uD83D\\uDEA9Easy C++ O(N) Soln. [ FAANG\\uD83D\\uDE31 Interview Optimized code ]\\n\\nhttps://leetcode.com/problems/best-time-to-buy-and-sell-stock/solutions/2822579/easy-c-o-n-soln-faang-interview-optimized-code/\\n\\n"
                    },
                    {
                        "username": "sourov1407",
                        "content": "Because we can use kadene\\'s algorithm here and as it is widely regarded as dp algorithm so yeah this problem is tagged with dynamic programming"
                    },
                    {
                        "username": "casper07",
                        "content": "I am So dumb...."
                    },
                    {
                        "username": "ydumar",
                        "content": "same bruh"
                    },
                    {
                        "username": "savagesam343",
                        "content": "me too bro, me too..."
                    },
                    {
                        "username": "night07",
                        "content": "me too jit"
                    },
                    {
                        "username": "AlgoEngine",
                        "content": "Video visualizing an intuitive proof of the O(n) solution:\nhttps://youtube.com/watch?v=ioFPBdChabY"
                    },
                    {
                        "username": "astek14",
                        "content": "Thanks it\\'s awesome"
                    },
                    {
                        "username": "shilbabun491",
                        "content": "how to resolve the time exceeded issue? Mine fails at 200th test case with a large array"
                    },
                    {
                        "username": "akelux",
                        "content": "How to get max profit 4 from input [3,2,6,5,0,3]?"
                    },
                    {
                        "username": "jenil59",
                        "content": "buy at 2 and sell at 6"
                    },
                    {
                        "username": "Trinto_610",
                        "content": "damn bro 2013"
                    },
                    {
                        "username": "prasumitmishra",
                        "content": "3 (buy),  2 (buy) , 6 (sell), 5 (hold), 0 (hold), 3 (hold)\\n-3 -2 + (2*6)\\n= -5 + 12 = 7"
                    },
                    {
                        "username": "KayvanShah1",
                        "content": "by selling on 6 and buying on 0\\nwhich means short selling"
                    },
                    {
                        "username": "bhanureddy7",
                        "content": "2,6"
                    },
                    {
                        "username": "Hanagaki_Takimichy",
                        "content": "buy = 2 and sell = 6"
                    },
                    {
                        "username": "hungkiet244203",
                        "content": "[@jannatbushra524](/jannatbushra524) yeah but the profit it provides isnt\\n"
                    },
                    {
                        "username": "MatsRivel",
                        "content": "[@jannatbushra524](/jannatbushra524) Buy at 0, then you have to sell after zero, so the best sell price is 3. 3-0 = 3, 6-2=4"
                    },
                    {
                        "username": "ajjha7203",
                        "content": "6-2 = 4"
                    },
                    {
                        "username": "damajsam93",
                        "content": "6-2 ==> 4 "
                    },
                    {
                        "username": "Jagdeep4485",
                        "content": "6-2= 4"
                    },
                    {
                        "username": "jannatbushra524",
                        "content": "[@rajanhossainkhan](/rajanhossainkhan) isn\\'t \\'0\\' a buy_price ??...and its smallest too."
                    },
                    {
                        "username": "rajanhossainkhan",
                        "content": "Here are the steps - \\n\\n1. First buy out price is 3 and profit is set to 0. \\n2. Now loop through array from index 1, since index 0 (which is 3) is taken as minimum buy out price for now. \\n3. Now if price is 2, then set this as new buy out price, since its smaller. So our current buy out price is 2. \\n4. Now next price is 6. This is bigger, so sell with current buy out price 2. \\n5. Calculate max profit  = max(profit, ( current_price - buy_price) \\n6. In this case, max(0, 6-2) = 4\\n\\nHope this helps. "
                    },
                    {
                        "username": "Amit_Joe",
                        "content": "2 -6\\n"
                    },
                    {
                        "username": "hemantgautam505",
                        "content": "output is 4\\n"
                    },
                    {
                        "username": "Shashi3k",
                        "content": "2-6\\n"
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for February, Day 1.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  **📌 Do you want to learn the problem thoroughly?**\n  Read [**⭐  LeetCode Official Solution⭐**](https://leetcode.com/problems/best-time-to-buy-and-sell-stock/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 2 approaches in the official solution</summary>\n\n  \n**Approach 1:** Brute Force\n\n  \n**Approach 2:** One Pass\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# \\uD83D\\uDEA9Easy C++ O(N) Soln. [ FAANG\\uD83D\\uDE31 Interview Optimized code ]\\n\\nhttps://leetcode.com/problems/best-time-to-buy-and-sell-stock/solutions/2822579/easy-c-o-n-soln-faang-interview-optimized-code/\\n"
                    }
                ]
            },
            {
                "id": 1575902,
                "content": [
                    {
                        "username": "Serosidium",
                        "content": "I couldn\\'t find any good explanations here and only code, so I will do my best to explain how I solved it without providing code. I am sure there are other possible solutions, but this is how it worked for me.\\n\\nThe brute force method of a double for loop is not necessary here, and this problem is marked with dynamic programming because it requires the [Sliding Window technique](https://algorithm-visualizer.org/dynamic-programming/sliding-window).\\n\\nBased on the fact that we have to sell after we buy and we are trying to maximize profit, we can iterate through the prices and only need to consider two things:\\n1.) **Is this price cheaper than any other price I\\'ve seen before?** \\n2.) If I subtract current price by the cheapest price I\\'ve found, **does this yield a greater profit than what I\\'ve seen so far?**\\n\\n*A fun thing to note is if #1 is true, then #2 cannot be true as well so there isn\\'t a need to check*\\n\\nLet\\'s consider an example of [4,1,5,2,7]\\n- 4 is the cheapest price we see to start, and we can\\'t sell on the first day so maxProfit is 0\\n- 1 is now the cheapest price we\\'ve seen. Selling now would lose us money, so we can\\'t update maxProfit\\n- 5 is not cheaper than 1, but if we sell now we get a maxProfit of 4! Better save that for later\\n- 2 is not cheaper than 1 and if we sell, we only get a profit of 1, no need to do anything here\\n- 7 is not cheaper than 1, but if we sell here, we\\'ll increase maxProfit to 6, making this the best profit to return.\\n\\nHope this helps someone else!\\n"
                    },
                    {
                        "username": "Manidgyf_6",
                        "content": "Thank you bro"
                    },
                    {
                        "username": "lorentzimys",
                        "content": "Awesome solution, thanks!"
                    },
                    {
                        "username": "Khoa268",
                        "content": "thanks for sharing!"
                    },
                    {
                        "username": "omeh-a",
                        "content": "This is not a DP solution as described, it is greedy"
                    },
                    {
                        "username": "ankitk742",
                        "content": "Thanks bro for your help without code really appreciate "
                    },
                    {
                        "username": "245120733119",
                        "content": "Brilliant!! Thanks for sharing!!"
                    },
                    {
                        "username": "Aniket_sggs",
                        "content": "Initially, this seemed to be DP problem. but after reading this description it is clear that this is basic problem with greedy solution."
                    },
                    {
                        "username": "duffinson97",
                        "content": "Thank you for not posting code, I don\\'t understand the sliding window technique or how this applies to that. I google it and the image link to this problem doesn\\'t make a lot of sense to me. But this solution works thanks"
                    },
                    {
                        "username": "typranjal1",
                        "content": "Thank you!."
                    },
                    {
                        "username": "jakho100",
                        "content": "was stuck on it for hours, thanks for the simple explanation! "
                    },
                    {
                        "username": "zafeer_rangoonwala",
                        "content": "I was originally not able to solve it but after reading your thought process it was a cake walk! \\n\\nThanks! "
                    },
                    {
                        "username": "mohammed1212345",
                        "content": "thank for helping out"
                    },
                    {
                        "username": "dungtuanuet",
                        "content": "Exellent explaination!"
                    },
                    {
                        "username": "kcleland18",
                        "content": "This was a great explanation!! Thanks!"
                    },
                    {
                        "username": "as358",
                        "content": "Best Explanation ever !!!"
                    },
                    {
                        "username": "user6798sW",
                        "content": "AWESOME BREAKDOWN! Ty"
                    },
                    {
                        "username": "jaydeep-pro",
                        "content": "[@evoniuk](/evoniuk) exactly! "
                    },
                    {
                        "username": "akshaydusad",
                        "content": "okay this is genius and surprisingly easier to follow!"
                    },
                    {
                        "username": "evoniuk",
                        "content": "Thank you! This is a solution that\\'s so simple and obvious once you see it you kick yourself for not thinking of it yourself!"
                    },
                    {
                        "username": "ivantchev",
                        "content": "How would the original wording of the problem have to be modified so that the double loop solution _has_ to be used?"
                    },
                    {
                        "username": "ivantchev",
                        "content": "Very helpful, thank you! To add: the reason why using your point 1.) works as a valid check is because given the problem constraints, it will always yield a higher profit down the line regardless of future values.\\n\\nAnd point  2.) shows we don\\'t need a second loop.\\n\\nI wonder, can any concrete aspect of the problem  be used as a clue so that we can reach Serosidium\\'s solution  independently. "
                    },
                    {
                        "username": "VishnuKesav",
                        "content": "[@sharpsailor](/sharpsailor) our target is to get highest possible profit.\\nYou are focusing on buying for the lowest price alone. No matter how low the price is, buying on a last day will yield 0 profit.\\n"
                    },
                    {
                        "username": "kaushar",
                        "content": "[@tengxianrui](/tengxianrui) Thanks  !"
                    },
                    {
                        "username": "neelimag459",
                        "content": "Thank you so much for such good explanation. Happy coding."
                    },
                    {
                        "username": "Nbs-26",
                        "content": "Thank u brother. Your explanation is very clear and well defined."
                    },
                    {
                        "username": "Dabchinsky",
                        "content": "[@sharpsailor](/sharpsailor) if we buy on 2 and sell on 4, our profit would be 4 - 2 = 2. "
                    },
                    {
                        "username": "sharpsailor",
                        "content": "check for {2,4,1} ideally it should give 0 but leetcode gives 2..Help me figure out where am I getting it wrong\\n"
                    },
                    {
                        "username": "jackbb147",
                        "content": "that\\'s actually very smart... thanks"
                    },
                    {
                        "username": "chiahao1",
                        "content": "Thank you! Your technique worked for me."
                    },
                    {
                        "username": "Marre-86",
                        "content": "Man, you made my day! I spent two hours and wrote almost 100 hundred lines code that probably was soving it but had \"time limit exceeded\" with huge input. And after your explanation I rewrite it in freaking 7 lines and it made it right off the bat!"
                    },
                    {
                        "username": "m1ma087",
                        "content": "Best tip! Thanks!"
                    },
                    {
                        "username": "sasaalina1985",
                        "content": "was reading this and solved the problem first try! Very good explanation!!!"
                    },
                    {
                        "username": "Yash_6207",
                        "content": "This is what we call as Greedy ! Good Explanation\\n"
                    },
                    {
                        "username": "iosifpetrupuha",
                        "content": "[@fjod](/fjod) but it\\'s buy day that should be before then sellday"
                    },
                    {
                        "username": "iosifpetrupuha",
                        "content": "[@iosifpetrupuha](/iosifpetrupuha) daaamn there is no indentation in this comment section"
                    },
                    {
                        "username": "iosifpetrupuha",
                        "content": "so I didn\\'t know this was called sliding window or sumthin, but I am second year at CS university, i have some grasp of this kind of logic and I solved it this way:\\nclass Solution:\\n    def maxProfit(self, prices: List[int]) -> int:\\n        #you obviously must buy before you sell(can\\'t go back in time)\\n        GreatestProfit=0\\n        priceToBeat=prices[0]\\n        for i in range(len(prices)-1):#we can iterate through the whole list, otherwise we get out of bounds, so we iterate from the first to the penultimate (so the last comparation we do is between the penultimate and the last element) \\n            if prices[i]<prices[i+1]:#sure profit, possible greatest profit\\n                if prices[i]<=priceToBeat:\\n                    priceToBeat=prices[i]\\n                if GreatestProfit<=prices[i+1]-priceToBeat: #if the GreatestProfit we calculate is greater than the one we have already, we update the Greatest Profit, otherwise we do nothing\\n                    GreatestProfit=prices[i+1]-priceToBeat\\n        return GreatestProfit\\nis this a proper way to solve this kind of problems? (in terms of efficiency I think we\\'re in O(n) so it should be pretty good"
                    },
                    {
                        "username": "Rohit_8412",
                        "content": "Thanks, I was about to see the solution after 10 min I didn\\'t get an approach into my mind.\\nThen I saw your discussion and I solved the question myself \\uD83D\\uDE0E"
                    },
                    {
                        "username": "fjod",
                        "content": "your explanation does not include rule of sellDay must be after buyDay"
                    },
                    {
                        "username": "Hanagaki_Takimichy",
                        "content": "thanks for great explaination without any spoilers.\\ni will try my best for the code, thanks a lot ;)"
                    },
                    {
                        "username": "csrnontol",
                        "content": "Sounds good, but I think your tip fails for [2,9,3,4,5,1,7] (how you\\'d choose 2, 9) and [2,9,3,4,5,1,7,10] (how you\\'d choose 1, 10)."
                    },
                    {
                        "username": "rockmanex",
                        "content": "best explanations so far. Thankyou it\\'s help a lot"
                    },
                    {
                        "username": "ak67",
                        "content": "I think this problem should be catogarise as medium level problem\\n"
                    },
                    {
                        "username": "Sultan_Ul_Arfin",
                        "content": "[@chazwinter](/chazwinter) what is sliding window? I never heard it ..will you explain that please<3\\n "
                    },
                    {
                        "username": "chazwinter",
                        "content": "It doesn\\'t require DP though. You only think it\\'s harder than it is because you\\'re overthinking it. You can use sliding window and just keep track of the lowest price as you go."
                    },
                    {
                        "username": "rwatso",
                        "content": "[@lucky_nik77](/lucky_nik77) Because by its very nature DP is not a beginner / easy level topic."
                    },
                    {
                        "username": "Vectorido",
                        "content": "[@lucky_nik77](/lucky_nik77) This is not hard for simple lists. But all people here usually stuck at TimeLimit error. So algorithm should be another, at least medium level of complexity."
                    },
                    {
                        "username": "lucky_nik77",
                        "content": "But why? It is hard to think about a DP problem that would be easier than this."
                    },
                    {
                        "username": "tiwarimrutunjay",
                        "content": "agreed"
                    },
                    {
                        "username": "codernoob",
                        "content": "how to resolve the time exceeded issue? Mine fails at 203rd test case with a large array"
                    },
                    {
                        "username": "user4279js",
                        "content": "[@rajamandalofficial56](/rajamandalofficial56) I\\'m not a javascript expert, but probably doing prices.slice(index) is looping 0 -index eachtime ... so you have O(N\\n^2) soltuion overall"
                    },
                    {
                        "username": "Behnoosh",
                        "content": "[@htooak2014](/htooak2014) To me it was occurring when my code had an O(n^2) complexity. Resolving that (to O(n)) solved this problem. I start from the end of the array prices and dynamically find the max value from the end of the array until the current step backwards. This way, at the end of the for loop, we can find the max profit with only one single pass over all entries of the array."
                    },
                    {
                        "username": "eyastaifour",
                        "content": "[@htooak2014](/htooak2014) I am hitting a limit error as well and I believe that it is because I keep on querying max() of the window, but when I think of it the max is either on the first index of the window (as I descend), or somewhere else, in which case, it should be cached as it doesnt change... at least, that\\'s what i am thinking\\n"
                    },
                    {
                        "username": "PercyJia95",
                        "content": "[@rajamandalofficial56](/rajamandalofficial56) You need to reconsider your variable naming. They carry very few meanings."
                    },
                    {
                        "username": "knotri",
                        "content": "[@rajamandalofficial56](/rajamandalofficial56) since u iterate over N elements with prices.map, and for each elements u call Math.max(...prices.slice) u need approx additional 1/2N to find maximum. So O(n) = n^2"
                    },
                    {
                        "username": "rajamandalofficial56",
                        "content": " let max = 0;\\n\\n    prices.map((el,index) => {\\n      let tem =  Math.max(...prices.slice(index))\\n      if(el< tem){\\n         if(max< tem-el){\\n             max = tem-el\\n         }\\n      }\\n    })\\n    return max\\n\\nError : Time Limit Exceeded\\n\\nO(n) complexity\\nwhat\\'s wrong this approach? "
                    },
                    {
                        "username": "htooak2014",
                        "content": "me too. time limit error occurs. why? leetcode compiler error?"
                    },
                    {
                        "username": "drmolenhouse",
                        "content": "Same issue, using the LeetCode Official solution lmao. What am I paying $35/month for?"
                    },
                    {
                        "username": "user4387LF",
                        "content": "Because you may be using a brute force approach with two loops checking every combination which takes O(n2) time; Cause it exceeds time limit. Optimize your code. Think to solve it in one pass with one loop in linear time."
                    },
                    {
                        "username": "Sahil481",
                        "content": "Your code is not well optimised. It is not ran within the given time limit."
                    },
                    {
                        "username": "pstrait",
                        "content": "Are you doing it with more than one loop? If so, there\\'s a better solution that has O(n) time complexity"
                    },
                    {
                        "username": "leet_code_master",
                        "content": "prices = [2, 4, 1]\\n\\nOutput: 0\\nExpected: 2\\n\\nYou buy on day three but cannot sell because it is the last day. Should that not be zero?"
                    },
                    {
                        "username": "langhudson870",
                        "content": "You should buy on day 1 and sell on day 2"
                    },
                    {
                        "username": "almaas21",
                        "content": "[@user4391xh](/user4391xh) \\nthe output required is max profit through traversing  in the list, it could be adjacent too like in [2,4,1] max_profit here is 2 not 0"
                    },
                    {
                        "username": "ashish_bhosale848",
                        "content": "Yes , I am facing the same issue at case 154"
                    },
                    {
                        "username": "user4391xh",
                        "content": "According to the example 2 \\n(Input: prices = [7,6,4,3,1]\\nOutput: 0\\nExplanation: In this case, no transactions are done and the max profit = 0.)\\nin the task description, 0 should be returned so looks like tests expect incorrect value here.."
                    },
                    {
                        "username": "kaushit",
                        "content": "[@mp9508](/mp9508) I also done the same thing but if that solution is wrong then what approach should we think."
                    },
                    {
                        "username": "shubhamDhapola",
                        "content": "you buy on the first day and sell on the second"
                    },
                    {
                        "username": "sazuki",
                        "content": "[@mp9508](/mp9508) This happend to me too, because ahahah well, the first value that is taken is the min() so basically 1, but this is the last one because that will end in a 0 output. "
                    },
                    {
                        "username": "HarshitBansal122",
                        "content": "buy on first day and sell on second day makes profit 2 "
                    },
                    {
                        "username": "Dan_A_S",
                        "content": "[@mkv1892](/mkv1892) I don\\'t agree with that (except if the explanation of the problem is not correct). What I understood from the explanation is, you buy when the price is cheapest and sell on a later date when you can maximize profit (meaning the highest prize on a later date from the date of purchase). Going by that, you buy at 1 so the output should be zero and not the expected 2."
                    },
                    {
                        "username": "mkv1892",
                        "content": "No, Here you buy at day 1, Where the buy price is 2 and sell at day 2, Where the sell price is 4."
                    },
                    {
                        "username": "Byas_Yadav",
                        "content": "[@mp9508](/mp9508) you buy on day 1 and sell it on day 2 i.e. profit =sell-buy --> 4-2=2"
                    },
                    {
                        "username": "mp9508",
                        "content": "[@leet_code_master](/leet_code_master) happened the same to me . the approach i took is:\\nfind the minimum element and then maxi=mini then use a loop from the next index of the lowest mini element and then find maxi, then return the output.\\nhope this helps\\n"
                    },
                    {
                        "username": "VaishaliChauhan",
                        "content": "We need to maximize profit, you can buy at 2 and sell on 4, giving a profit of 2"
                    },
                    {
                        "username": "IbrahimJunior",
                        "content": "you have to maintain your profit in a variable and only change the variable if the new profit is greater than the previous one, so for this scenario, 2 is the former profit, 0 is the new one, it is not greater than 2 so you don\\'t change your profit."
                    },
                    {
                        "username": "Hanagaki_Takimichy",
                        "content": "buy = 2 and sell = 4 profit = 2\\ni am facing the same problem bro............."
                    },
                    {
                        "username": "MatsRivel",
                        "content": "[@leet_code_master](/leet_code_master) What I did was look at what the largest value after i is for each i, and what the smallest value is before each i. Then, for each i, i subtract smallest from largest. This is your optimal profit for buying before i and selling after i. Now you just find the largest number out of these, and you\\'re done."
                    },
                    {
                        "username": "leet_code_master",
                        "content": "[@MeriemA](/MeriemA) I see. Thank you :) How do you recommend I go about this? Because now the new code I make messes up the second test case."
                    },
                    {
                        "username": "MeriemA",
                        "content": "Actually,  the idea here is how you can make the maximum of profits. You don\\'t have to buy the stock when it\\'s at its lowest price.\\nHere you can buy the first day and sell the second day and still make a profit which is 2.\\n"
                    },
                    {
                        "username": "EXLsunshine",
                        "content": "Why is this problem tagged with \"Dynamic programming\"?"
                    },
                    {
                        "username": "princebillygk2",
                        "content": "[@aryan14decsingh](/aryan14decsingh) The problem can be solved in Dynamic way but the more efficient way is array traversal approach."
                    },
                    {
                        "username": "Mrinal2100",
                        "content": "It should be tagged as two pointer problem"
                    },
                    {
                        "username": "aryan14decsingh",
                        "content": "Because it is Dynamic  ( debatable ) \\nquestion apart , did you get any job by now ? you posted this on 2015 , if you are still alive let me know if you got any jobs and some tips aswell"
                    },
                    {
                        "username": "djslim",
                        "content": "[@sourov1407](/sourov1407)  tbh it\\'s classic greedy problem, interestingly in leetcode 75 they marked it as greedy"
                    },
                    {
                        "username": "sahle123",
                        "content": "[@AdityaBhate](/AdityaBhate) He/she was asking a question, not for a solution."
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# \\uD83D\\uDEA9Easy C++ O(N) Soln. [ FAANG\\uD83D\\uDE31 Interview Optimized code ]\\n\\nhttps://leetcode.com/problems/best-time-to-buy-and-sell-stock/solutions/2822579/easy-c-o-n-soln-faang-interview-optimized-code/\\n\\n"
                    },
                    {
                        "username": "sourov1407",
                        "content": "Because we can use kadene\\'s algorithm here and as it is widely regarded as dp algorithm so yeah this problem is tagged with dynamic programming"
                    },
                    {
                        "username": "casper07",
                        "content": "I am So dumb...."
                    },
                    {
                        "username": "ydumar",
                        "content": "same bruh"
                    },
                    {
                        "username": "savagesam343",
                        "content": "me too bro, me too..."
                    },
                    {
                        "username": "night07",
                        "content": "me too jit"
                    },
                    {
                        "username": "AlgoEngine",
                        "content": "Video visualizing an intuitive proof of the O(n) solution:\nhttps://youtube.com/watch?v=ioFPBdChabY"
                    },
                    {
                        "username": "astek14",
                        "content": "Thanks it\\'s awesome"
                    },
                    {
                        "username": "shilbabun491",
                        "content": "how to resolve the time exceeded issue? Mine fails at 200th test case with a large array"
                    },
                    {
                        "username": "akelux",
                        "content": "How to get max profit 4 from input [3,2,6,5,0,3]?"
                    },
                    {
                        "username": "jenil59",
                        "content": "buy at 2 and sell at 6"
                    },
                    {
                        "username": "Trinto_610",
                        "content": "damn bro 2013"
                    },
                    {
                        "username": "prasumitmishra",
                        "content": "3 (buy),  2 (buy) , 6 (sell), 5 (hold), 0 (hold), 3 (hold)\\n-3 -2 + (2*6)\\n= -5 + 12 = 7"
                    },
                    {
                        "username": "KayvanShah1",
                        "content": "by selling on 6 and buying on 0\\nwhich means short selling"
                    },
                    {
                        "username": "bhanureddy7",
                        "content": "2,6"
                    },
                    {
                        "username": "Hanagaki_Takimichy",
                        "content": "buy = 2 and sell = 6"
                    },
                    {
                        "username": "hungkiet244203",
                        "content": "[@jannatbushra524](/jannatbushra524) yeah but the profit it provides isnt\\n"
                    },
                    {
                        "username": "MatsRivel",
                        "content": "[@jannatbushra524](/jannatbushra524) Buy at 0, then you have to sell after zero, so the best sell price is 3. 3-0 = 3, 6-2=4"
                    },
                    {
                        "username": "ajjha7203",
                        "content": "6-2 = 4"
                    },
                    {
                        "username": "damajsam93",
                        "content": "6-2 ==> 4 "
                    },
                    {
                        "username": "Jagdeep4485",
                        "content": "6-2= 4"
                    },
                    {
                        "username": "jannatbushra524",
                        "content": "[@rajanhossainkhan](/rajanhossainkhan) isn\\'t \\'0\\' a buy_price ??...and its smallest too."
                    },
                    {
                        "username": "rajanhossainkhan",
                        "content": "Here are the steps - \\n\\n1. First buy out price is 3 and profit is set to 0. \\n2. Now loop through array from index 1, since index 0 (which is 3) is taken as minimum buy out price for now. \\n3. Now if price is 2, then set this as new buy out price, since its smaller. So our current buy out price is 2. \\n4. Now next price is 6. This is bigger, so sell with current buy out price 2. \\n5. Calculate max profit  = max(profit, ( current_price - buy_price) \\n6. In this case, max(0, 6-2) = 4\\n\\nHope this helps. "
                    },
                    {
                        "username": "Amit_Joe",
                        "content": "2 -6\\n"
                    },
                    {
                        "username": "hemantgautam505",
                        "content": "output is 4\\n"
                    },
                    {
                        "username": "Shashi3k",
                        "content": "2-6\\n"
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for February, Day 1.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  **📌 Do you want to learn the problem thoroughly?**\n  Read [**⭐  LeetCode Official Solution⭐**](https://leetcode.com/problems/best-time-to-buy-and-sell-stock/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 2 approaches in the official solution</summary>\n\n  \n**Approach 1:** Brute Force\n\n  \n**Approach 2:** One Pass\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# \\uD83D\\uDEA9Easy C++ O(N) Soln. [ FAANG\\uD83D\\uDE31 Interview Optimized code ]\\n\\nhttps://leetcode.com/problems/best-time-to-buy-and-sell-stock/solutions/2822579/easy-c-o-n-soln-faang-interview-optimized-code/\\n"
                    }
                ]
            },
            {
                "id": 1677787,
                "content": [
                    {
                        "username": "Serosidium",
                        "content": "I couldn\\'t find any good explanations here and only code, so I will do my best to explain how I solved it without providing code. I am sure there are other possible solutions, but this is how it worked for me.\\n\\nThe brute force method of a double for loop is not necessary here, and this problem is marked with dynamic programming because it requires the [Sliding Window technique](https://algorithm-visualizer.org/dynamic-programming/sliding-window).\\n\\nBased on the fact that we have to sell after we buy and we are trying to maximize profit, we can iterate through the prices and only need to consider two things:\\n1.) **Is this price cheaper than any other price I\\'ve seen before?** \\n2.) If I subtract current price by the cheapest price I\\'ve found, **does this yield a greater profit than what I\\'ve seen so far?**\\n\\n*A fun thing to note is if #1 is true, then #2 cannot be true as well so there isn\\'t a need to check*\\n\\nLet\\'s consider an example of [4,1,5,2,7]\\n- 4 is the cheapest price we see to start, and we can\\'t sell on the first day so maxProfit is 0\\n- 1 is now the cheapest price we\\'ve seen. Selling now would lose us money, so we can\\'t update maxProfit\\n- 5 is not cheaper than 1, but if we sell now we get a maxProfit of 4! Better save that for later\\n- 2 is not cheaper than 1 and if we sell, we only get a profit of 1, no need to do anything here\\n- 7 is not cheaper than 1, but if we sell here, we\\'ll increase maxProfit to 6, making this the best profit to return.\\n\\nHope this helps someone else!\\n"
                    },
                    {
                        "username": "Manidgyf_6",
                        "content": "Thank you bro"
                    },
                    {
                        "username": "lorentzimys",
                        "content": "Awesome solution, thanks!"
                    },
                    {
                        "username": "Khoa268",
                        "content": "thanks for sharing!"
                    },
                    {
                        "username": "omeh-a",
                        "content": "This is not a DP solution as described, it is greedy"
                    },
                    {
                        "username": "ankitk742",
                        "content": "Thanks bro for your help without code really appreciate "
                    },
                    {
                        "username": "245120733119",
                        "content": "Brilliant!! Thanks for sharing!!"
                    },
                    {
                        "username": "Aniket_sggs",
                        "content": "Initially, this seemed to be DP problem. but after reading this description it is clear that this is basic problem with greedy solution."
                    },
                    {
                        "username": "duffinson97",
                        "content": "Thank you for not posting code, I don\\'t understand the sliding window technique or how this applies to that. I google it and the image link to this problem doesn\\'t make a lot of sense to me. But this solution works thanks"
                    },
                    {
                        "username": "typranjal1",
                        "content": "Thank you!."
                    },
                    {
                        "username": "jakho100",
                        "content": "was stuck on it for hours, thanks for the simple explanation! "
                    },
                    {
                        "username": "zafeer_rangoonwala",
                        "content": "I was originally not able to solve it but after reading your thought process it was a cake walk! \\n\\nThanks! "
                    },
                    {
                        "username": "mohammed1212345",
                        "content": "thank for helping out"
                    },
                    {
                        "username": "dungtuanuet",
                        "content": "Exellent explaination!"
                    },
                    {
                        "username": "kcleland18",
                        "content": "This was a great explanation!! Thanks!"
                    },
                    {
                        "username": "as358",
                        "content": "Best Explanation ever !!!"
                    },
                    {
                        "username": "user6798sW",
                        "content": "AWESOME BREAKDOWN! Ty"
                    },
                    {
                        "username": "jaydeep-pro",
                        "content": "[@evoniuk](/evoniuk) exactly! "
                    },
                    {
                        "username": "akshaydusad",
                        "content": "okay this is genius and surprisingly easier to follow!"
                    },
                    {
                        "username": "evoniuk",
                        "content": "Thank you! This is a solution that\\'s so simple and obvious once you see it you kick yourself for not thinking of it yourself!"
                    },
                    {
                        "username": "ivantchev",
                        "content": "How would the original wording of the problem have to be modified so that the double loop solution _has_ to be used?"
                    },
                    {
                        "username": "ivantchev",
                        "content": "Very helpful, thank you! To add: the reason why using your point 1.) works as a valid check is because given the problem constraints, it will always yield a higher profit down the line regardless of future values.\\n\\nAnd point  2.) shows we don\\'t need a second loop.\\n\\nI wonder, can any concrete aspect of the problem  be used as a clue so that we can reach Serosidium\\'s solution  independently. "
                    },
                    {
                        "username": "VishnuKesav",
                        "content": "[@sharpsailor](/sharpsailor) our target is to get highest possible profit.\\nYou are focusing on buying for the lowest price alone. No matter how low the price is, buying on a last day will yield 0 profit.\\n"
                    },
                    {
                        "username": "kaushar",
                        "content": "[@tengxianrui](/tengxianrui) Thanks  !"
                    },
                    {
                        "username": "neelimag459",
                        "content": "Thank you so much for such good explanation. Happy coding."
                    },
                    {
                        "username": "Nbs-26",
                        "content": "Thank u brother. Your explanation is very clear and well defined."
                    },
                    {
                        "username": "Dabchinsky",
                        "content": "[@sharpsailor](/sharpsailor) if we buy on 2 and sell on 4, our profit would be 4 - 2 = 2. "
                    },
                    {
                        "username": "sharpsailor",
                        "content": "check for {2,4,1} ideally it should give 0 but leetcode gives 2..Help me figure out where am I getting it wrong\\n"
                    },
                    {
                        "username": "jackbb147",
                        "content": "that\\'s actually very smart... thanks"
                    },
                    {
                        "username": "chiahao1",
                        "content": "Thank you! Your technique worked for me."
                    },
                    {
                        "username": "Marre-86",
                        "content": "Man, you made my day! I spent two hours and wrote almost 100 hundred lines code that probably was soving it but had \"time limit exceeded\" with huge input. And after your explanation I rewrite it in freaking 7 lines and it made it right off the bat!"
                    },
                    {
                        "username": "m1ma087",
                        "content": "Best tip! Thanks!"
                    },
                    {
                        "username": "sasaalina1985",
                        "content": "was reading this and solved the problem first try! Very good explanation!!!"
                    },
                    {
                        "username": "Yash_6207",
                        "content": "This is what we call as Greedy ! Good Explanation\\n"
                    },
                    {
                        "username": "iosifpetrupuha",
                        "content": "[@fjod](/fjod) but it\\'s buy day that should be before then sellday"
                    },
                    {
                        "username": "iosifpetrupuha",
                        "content": "[@iosifpetrupuha](/iosifpetrupuha) daaamn there is no indentation in this comment section"
                    },
                    {
                        "username": "iosifpetrupuha",
                        "content": "so I didn\\'t know this was called sliding window or sumthin, but I am second year at CS university, i have some grasp of this kind of logic and I solved it this way:\\nclass Solution:\\n    def maxProfit(self, prices: List[int]) -> int:\\n        #you obviously must buy before you sell(can\\'t go back in time)\\n        GreatestProfit=0\\n        priceToBeat=prices[0]\\n        for i in range(len(prices)-1):#we can iterate through the whole list, otherwise we get out of bounds, so we iterate from the first to the penultimate (so the last comparation we do is between the penultimate and the last element) \\n            if prices[i]<prices[i+1]:#sure profit, possible greatest profit\\n                if prices[i]<=priceToBeat:\\n                    priceToBeat=prices[i]\\n                if GreatestProfit<=prices[i+1]-priceToBeat: #if the GreatestProfit we calculate is greater than the one we have already, we update the Greatest Profit, otherwise we do nothing\\n                    GreatestProfit=prices[i+1]-priceToBeat\\n        return GreatestProfit\\nis this a proper way to solve this kind of problems? (in terms of efficiency I think we\\'re in O(n) so it should be pretty good"
                    },
                    {
                        "username": "Rohit_8412",
                        "content": "Thanks, I was about to see the solution after 10 min I didn\\'t get an approach into my mind.\\nThen I saw your discussion and I solved the question myself \\uD83D\\uDE0E"
                    },
                    {
                        "username": "fjod",
                        "content": "your explanation does not include rule of sellDay must be after buyDay"
                    },
                    {
                        "username": "Hanagaki_Takimichy",
                        "content": "thanks for great explaination without any spoilers.\\ni will try my best for the code, thanks a lot ;)"
                    },
                    {
                        "username": "csrnontol",
                        "content": "Sounds good, but I think your tip fails for [2,9,3,4,5,1,7] (how you\\'d choose 2, 9) and [2,9,3,4,5,1,7,10] (how you\\'d choose 1, 10)."
                    },
                    {
                        "username": "rockmanex",
                        "content": "best explanations so far. Thankyou it\\'s help a lot"
                    },
                    {
                        "username": "ak67",
                        "content": "I think this problem should be catogarise as medium level problem\\n"
                    },
                    {
                        "username": "Sultan_Ul_Arfin",
                        "content": "[@chazwinter](/chazwinter) what is sliding window? I never heard it ..will you explain that please<3\\n "
                    },
                    {
                        "username": "chazwinter",
                        "content": "It doesn\\'t require DP though. You only think it\\'s harder than it is because you\\'re overthinking it. You can use sliding window and just keep track of the lowest price as you go."
                    },
                    {
                        "username": "rwatso",
                        "content": "[@lucky_nik77](/lucky_nik77) Because by its very nature DP is not a beginner / easy level topic."
                    },
                    {
                        "username": "Vectorido",
                        "content": "[@lucky_nik77](/lucky_nik77) This is not hard for simple lists. But all people here usually stuck at TimeLimit error. So algorithm should be another, at least medium level of complexity."
                    },
                    {
                        "username": "lucky_nik77",
                        "content": "But why? It is hard to think about a DP problem that would be easier than this."
                    },
                    {
                        "username": "tiwarimrutunjay",
                        "content": "agreed"
                    },
                    {
                        "username": "codernoob",
                        "content": "how to resolve the time exceeded issue? Mine fails at 203rd test case with a large array"
                    },
                    {
                        "username": "user4279js",
                        "content": "[@rajamandalofficial56](/rajamandalofficial56) I\\'m not a javascript expert, but probably doing prices.slice(index) is looping 0 -index eachtime ... so you have O(N\\n^2) soltuion overall"
                    },
                    {
                        "username": "Behnoosh",
                        "content": "[@htooak2014](/htooak2014) To me it was occurring when my code had an O(n^2) complexity. Resolving that (to O(n)) solved this problem. I start from the end of the array prices and dynamically find the max value from the end of the array until the current step backwards. This way, at the end of the for loop, we can find the max profit with only one single pass over all entries of the array."
                    },
                    {
                        "username": "eyastaifour",
                        "content": "[@htooak2014](/htooak2014) I am hitting a limit error as well and I believe that it is because I keep on querying max() of the window, but when I think of it the max is either on the first index of the window (as I descend), or somewhere else, in which case, it should be cached as it doesnt change... at least, that\\'s what i am thinking\\n"
                    },
                    {
                        "username": "PercyJia95",
                        "content": "[@rajamandalofficial56](/rajamandalofficial56) You need to reconsider your variable naming. They carry very few meanings."
                    },
                    {
                        "username": "knotri",
                        "content": "[@rajamandalofficial56](/rajamandalofficial56) since u iterate over N elements with prices.map, and for each elements u call Math.max(...prices.slice) u need approx additional 1/2N to find maximum. So O(n) = n^2"
                    },
                    {
                        "username": "rajamandalofficial56",
                        "content": " let max = 0;\\n\\n    prices.map((el,index) => {\\n      let tem =  Math.max(...prices.slice(index))\\n      if(el< tem){\\n         if(max< tem-el){\\n             max = tem-el\\n         }\\n      }\\n    })\\n    return max\\n\\nError : Time Limit Exceeded\\n\\nO(n) complexity\\nwhat\\'s wrong this approach? "
                    },
                    {
                        "username": "htooak2014",
                        "content": "me too. time limit error occurs. why? leetcode compiler error?"
                    },
                    {
                        "username": "drmolenhouse",
                        "content": "Same issue, using the LeetCode Official solution lmao. What am I paying $35/month for?"
                    },
                    {
                        "username": "user4387LF",
                        "content": "Because you may be using a brute force approach with two loops checking every combination which takes O(n2) time; Cause it exceeds time limit. Optimize your code. Think to solve it in one pass with one loop in linear time."
                    },
                    {
                        "username": "Sahil481",
                        "content": "Your code is not well optimised. It is not ran within the given time limit."
                    },
                    {
                        "username": "pstrait",
                        "content": "Are you doing it with more than one loop? If so, there\\'s a better solution that has O(n) time complexity"
                    },
                    {
                        "username": "leet_code_master",
                        "content": "prices = [2, 4, 1]\\n\\nOutput: 0\\nExpected: 2\\n\\nYou buy on day three but cannot sell because it is the last day. Should that not be zero?"
                    },
                    {
                        "username": "langhudson870",
                        "content": "You should buy on day 1 and sell on day 2"
                    },
                    {
                        "username": "almaas21",
                        "content": "[@user4391xh](/user4391xh) \\nthe output required is max profit through traversing  in the list, it could be adjacent too like in [2,4,1] max_profit here is 2 not 0"
                    },
                    {
                        "username": "ashish_bhosale848",
                        "content": "Yes , I am facing the same issue at case 154"
                    },
                    {
                        "username": "user4391xh",
                        "content": "According to the example 2 \\n(Input: prices = [7,6,4,3,1]\\nOutput: 0\\nExplanation: In this case, no transactions are done and the max profit = 0.)\\nin the task description, 0 should be returned so looks like tests expect incorrect value here.."
                    },
                    {
                        "username": "kaushit",
                        "content": "[@mp9508](/mp9508) I also done the same thing but if that solution is wrong then what approach should we think."
                    },
                    {
                        "username": "shubhamDhapola",
                        "content": "you buy on the first day and sell on the second"
                    },
                    {
                        "username": "sazuki",
                        "content": "[@mp9508](/mp9508) This happend to me too, because ahahah well, the first value that is taken is the min() so basically 1, but this is the last one because that will end in a 0 output. "
                    },
                    {
                        "username": "HarshitBansal122",
                        "content": "buy on first day and sell on second day makes profit 2 "
                    },
                    {
                        "username": "Dan_A_S",
                        "content": "[@mkv1892](/mkv1892) I don\\'t agree with that (except if the explanation of the problem is not correct). What I understood from the explanation is, you buy when the price is cheapest and sell on a later date when you can maximize profit (meaning the highest prize on a later date from the date of purchase). Going by that, you buy at 1 so the output should be zero and not the expected 2."
                    },
                    {
                        "username": "mkv1892",
                        "content": "No, Here you buy at day 1, Where the buy price is 2 and sell at day 2, Where the sell price is 4."
                    },
                    {
                        "username": "Byas_Yadav",
                        "content": "[@mp9508](/mp9508) you buy on day 1 and sell it on day 2 i.e. profit =sell-buy --> 4-2=2"
                    },
                    {
                        "username": "mp9508",
                        "content": "[@leet_code_master](/leet_code_master) happened the same to me . the approach i took is:\\nfind the minimum element and then maxi=mini then use a loop from the next index of the lowest mini element and then find maxi, then return the output.\\nhope this helps\\n"
                    },
                    {
                        "username": "VaishaliChauhan",
                        "content": "We need to maximize profit, you can buy at 2 and sell on 4, giving a profit of 2"
                    },
                    {
                        "username": "IbrahimJunior",
                        "content": "you have to maintain your profit in a variable and only change the variable if the new profit is greater than the previous one, so for this scenario, 2 is the former profit, 0 is the new one, it is not greater than 2 so you don\\'t change your profit."
                    },
                    {
                        "username": "Hanagaki_Takimichy",
                        "content": "buy = 2 and sell = 4 profit = 2\\ni am facing the same problem bro............."
                    },
                    {
                        "username": "MatsRivel",
                        "content": "[@leet_code_master](/leet_code_master) What I did was look at what the largest value after i is for each i, and what the smallest value is before each i. Then, for each i, i subtract smallest from largest. This is your optimal profit for buying before i and selling after i. Now you just find the largest number out of these, and you\\'re done."
                    },
                    {
                        "username": "leet_code_master",
                        "content": "[@MeriemA](/MeriemA) I see. Thank you :) How do you recommend I go about this? Because now the new code I make messes up the second test case."
                    },
                    {
                        "username": "MeriemA",
                        "content": "Actually,  the idea here is how you can make the maximum of profits. You don\\'t have to buy the stock when it\\'s at its lowest price.\\nHere you can buy the first day and sell the second day and still make a profit which is 2.\\n"
                    },
                    {
                        "username": "EXLsunshine",
                        "content": "Why is this problem tagged with \"Dynamic programming\"?"
                    },
                    {
                        "username": "princebillygk2",
                        "content": "[@aryan14decsingh](/aryan14decsingh) The problem can be solved in Dynamic way but the more efficient way is array traversal approach."
                    },
                    {
                        "username": "Mrinal2100",
                        "content": "It should be tagged as two pointer problem"
                    },
                    {
                        "username": "aryan14decsingh",
                        "content": "Because it is Dynamic  ( debatable ) \\nquestion apart , did you get any job by now ? you posted this on 2015 , if you are still alive let me know if you got any jobs and some tips aswell"
                    },
                    {
                        "username": "djslim",
                        "content": "[@sourov1407](/sourov1407)  tbh it\\'s classic greedy problem, interestingly in leetcode 75 they marked it as greedy"
                    },
                    {
                        "username": "sahle123",
                        "content": "[@AdityaBhate](/AdityaBhate) He/she was asking a question, not for a solution."
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# \\uD83D\\uDEA9Easy C++ O(N) Soln. [ FAANG\\uD83D\\uDE31 Interview Optimized code ]\\n\\nhttps://leetcode.com/problems/best-time-to-buy-and-sell-stock/solutions/2822579/easy-c-o-n-soln-faang-interview-optimized-code/\\n\\n"
                    },
                    {
                        "username": "sourov1407",
                        "content": "Because we can use kadene\\'s algorithm here and as it is widely regarded as dp algorithm so yeah this problem is tagged with dynamic programming"
                    },
                    {
                        "username": "casper07",
                        "content": "I am So dumb...."
                    },
                    {
                        "username": "ydumar",
                        "content": "same bruh"
                    },
                    {
                        "username": "savagesam343",
                        "content": "me too bro, me too..."
                    },
                    {
                        "username": "night07",
                        "content": "me too jit"
                    },
                    {
                        "username": "AlgoEngine",
                        "content": "Video visualizing an intuitive proof of the O(n) solution:\nhttps://youtube.com/watch?v=ioFPBdChabY"
                    },
                    {
                        "username": "astek14",
                        "content": "Thanks it\\'s awesome"
                    },
                    {
                        "username": "shilbabun491",
                        "content": "how to resolve the time exceeded issue? Mine fails at 200th test case with a large array"
                    },
                    {
                        "username": "akelux",
                        "content": "How to get max profit 4 from input [3,2,6,5,0,3]?"
                    },
                    {
                        "username": "jenil59",
                        "content": "buy at 2 and sell at 6"
                    },
                    {
                        "username": "Trinto_610",
                        "content": "damn bro 2013"
                    },
                    {
                        "username": "prasumitmishra",
                        "content": "3 (buy),  2 (buy) , 6 (sell), 5 (hold), 0 (hold), 3 (hold)\\n-3 -2 + (2*6)\\n= -5 + 12 = 7"
                    },
                    {
                        "username": "KayvanShah1",
                        "content": "by selling on 6 and buying on 0\\nwhich means short selling"
                    },
                    {
                        "username": "bhanureddy7",
                        "content": "2,6"
                    },
                    {
                        "username": "Hanagaki_Takimichy",
                        "content": "buy = 2 and sell = 6"
                    },
                    {
                        "username": "hungkiet244203",
                        "content": "[@jannatbushra524](/jannatbushra524) yeah but the profit it provides isnt\\n"
                    },
                    {
                        "username": "MatsRivel",
                        "content": "[@jannatbushra524](/jannatbushra524) Buy at 0, then you have to sell after zero, so the best sell price is 3. 3-0 = 3, 6-2=4"
                    },
                    {
                        "username": "ajjha7203",
                        "content": "6-2 = 4"
                    },
                    {
                        "username": "damajsam93",
                        "content": "6-2 ==> 4 "
                    },
                    {
                        "username": "Jagdeep4485",
                        "content": "6-2= 4"
                    },
                    {
                        "username": "jannatbushra524",
                        "content": "[@rajanhossainkhan](/rajanhossainkhan) isn\\'t \\'0\\' a buy_price ??...and its smallest too."
                    },
                    {
                        "username": "rajanhossainkhan",
                        "content": "Here are the steps - \\n\\n1. First buy out price is 3 and profit is set to 0. \\n2. Now loop through array from index 1, since index 0 (which is 3) is taken as minimum buy out price for now. \\n3. Now if price is 2, then set this as new buy out price, since its smaller. So our current buy out price is 2. \\n4. Now next price is 6. This is bigger, so sell with current buy out price 2. \\n5. Calculate max profit  = max(profit, ( current_price - buy_price) \\n6. In this case, max(0, 6-2) = 4\\n\\nHope this helps. "
                    },
                    {
                        "username": "Amit_Joe",
                        "content": "2 -6\\n"
                    },
                    {
                        "username": "hemantgautam505",
                        "content": "output is 4\\n"
                    },
                    {
                        "username": "Shashi3k",
                        "content": "2-6\\n"
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for February, Day 1.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  **📌 Do you want to learn the problem thoroughly?**\n  Read [**⭐  LeetCode Official Solution⭐**](https://leetcode.com/problems/best-time-to-buy-and-sell-stock/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 2 approaches in the official solution</summary>\n\n  \n**Approach 1:** Brute Force\n\n  \n**Approach 2:** One Pass\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# \\uD83D\\uDEA9Easy C++ O(N) Soln. [ FAANG\\uD83D\\uDE31 Interview Optimized code ]\\n\\nhttps://leetcode.com/problems/best-time-to-buy-and-sell-stock/solutions/2822579/easy-c-o-n-soln-faang-interview-optimized-code/\\n"
                    }
                ]
            },
            {
                "id": 1665530,
                "content": [
                    {
                        "username": "Serosidium",
                        "content": "I couldn\\'t find any good explanations here and only code, so I will do my best to explain how I solved it without providing code. I am sure there are other possible solutions, but this is how it worked for me.\\n\\nThe brute force method of a double for loop is not necessary here, and this problem is marked with dynamic programming because it requires the [Sliding Window technique](https://algorithm-visualizer.org/dynamic-programming/sliding-window).\\n\\nBased on the fact that we have to sell after we buy and we are trying to maximize profit, we can iterate through the prices and only need to consider two things:\\n1.) **Is this price cheaper than any other price I\\'ve seen before?** \\n2.) If I subtract current price by the cheapest price I\\'ve found, **does this yield a greater profit than what I\\'ve seen so far?**\\n\\n*A fun thing to note is if #1 is true, then #2 cannot be true as well so there isn\\'t a need to check*\\n\\nLet\\'s consider an example of [4,1,5,2,7]\\n- 4 is the cheapest price we see to start, and we can\\'t sell on the first day so maxProfit is 0\\n- 1 is now the cheapest price we\\'ve seen. Selling now would lose us money, so we can\\'t update maxProfit\\n- 5 is not cheaper than 1, but if we sell now we get a maxProfit of 4! Better save that for later\\n- 2 is not cheaper than 1 and if we sell, we only get a profit of 1, no need to do anything here\\n- 7 is not cheaper than 1, but if we sell here, we\\'ll increase maxProfit to 6, making this the best profit to return.\\n\\nHope this helps someone else!\\n"
                    },
                    {
                        "username": "Manidgyf_6",
                        "content": "Thank you bro"
                    },
                    {
                        "username": "lorentzimys",
                        "content": "Awesome solution, thanks!"
                    },
                    {
                        "username": "Khoa268",
                        "content": "thanks for sharing!"
                    },
                    {
                        "username": "omeh-a",
                        "content": "This is not a DP solution as described, it is greedy"
                    },
                    {
                        "username": "ankitk742",
                        "content": "Thanks bro for your help without code really appreciate "
                    },
                    {
                        "username": "245120733119",
                        "content": "Brilliant!! Thanks for sharing!!"
                    },
                    {
                        "username": "Aniket_sggs",
                        "content": "Initially, this seemed to be DP problem. but after reading this description it is clear that this is basic problem with greedy solution."
                    },
                    {
                        "username": "duffinson97",
                        "content": "Thank you for not posting code, I don\\'t understand the sliding window technique or how this applies to that. I google it and the image link to this problem doesn\\'t make a lot of sense to me. But this solution works thanks"
                    },
                    {
                        "username": "typranjal1",
                        "content": "Thank you!."
                    },
                    {
                        "username": "jakho100",
                        "content": "was stuck on it for hours, thanks for the simple explanation! "
                    },
                    {
                        "username": "zafeer_rangoonwala",
                        "content": "I was originally not able to solve it but after reading your thought process it was a cake walk! \\n\\nThanks! "
                    },
                    {
                        "username": "mohammed1212345",
                        "content": "thank for helping out"
                    },
                    {
                        "username": "dungtuanuet",
                        "content": "Exellent explaination!"
                    },
                    {
                        "username": "kcleland18",
                        "content": "This was a great explanation!! Thanks!"
                    },
                    {
                        "username": "as358",
                        "content": "Best Explanation ever !!!"
                    },
                    {
                        "username": "user6798sW",
                        "content": "AWESOME BREAKDOWN! Ty"
                    },
                    {
                        "username": "jaydeep-pro",
                        "content": "[@evoniuk](/evoniuk) exactly! "
                    },
                    {
                        "username": "akshaydusad",
                        "content": "okay this is genius and surprisingly easier to follow!"
                    },
                    {
                        "username": "evoniuk",
                        "content": "Thank you! This is a solution that\\'s so simple and obvious once you see it you kick yourself for not thinking of it yourself!"
                    },
                    {
                        "username": "ivantchev",
                        "content": "How would the original wording of the problem have to be modified so that the double loop solution _has_ to be used?"
                    },
                    {
                        "username": "ivantchev",
                        "content": "Very helpful, thank you! To add: the reason why using your point 1.) works as a valid check is because given the problem constraints, it will always yield a higher profit down the line regardless of future values.\\n\\nAnd point  2.) shows we don\\'t need a second loop.\\n\\nI wonder, can any concrete aspect of the problem  be used as a clue so that we can reach Serosidium\\'s solution  independently. "
                    },
                    {
                        "username": "VishnuKesav",
                        "content": "[@sharpsailor](/sharpsailor) our target is to get highest possible profit.\\nYou are focusing on buying for the lowest price alone. No matter how low the price is, buying on a last day will yield 0 profit.\\n"
                    },
                    {
                        "username": "kaushar",
                        "content": "[@tengxianrui](/tengxianrui) Thanks  !"
                    },
                    {
                        "username": "neelimag459",
                        "content": "Thank you so much for such good explanation. Happy coding."
                    },
                    {
                        "username": "Nbs-26",
                        "content": "Thank u brother. Your explanation is very clear and well defined."
                    },
                    {
                        "username": "Dabchinsky",
                        "content": "[@sharpsailor](/sharpsailor) if we buy on 2 and sell on 4, our profit would be 4 - 2 = 2. "
                    },
                    {
                        "username": "sharpsailor",
                        "content": "check for {2,4,1} ideally it should give 0 but leetcode gives 2..Help me figure out where am I getting it wrong\\n"
                    },
                    {
                        "username": "jackbb147",
                        "content": "that\\'s actually very smart... thanks"
                    },
                    {
                        "username": "chiahao1",
                        "content": "Thank you! Your technique worked for me."
                    },
                    {
                        "username": "Marre-86",
                        "content": "Man, you made my day! I spent two hours and wrote almost 100 hundred lines code that probably was soving it but had \"time limit exceeded\" with huge input. And after your explanation I rewrite it in freaking 7 lines and it made it right off the bat!"
                    },
                    {
                        "username": "m1ma087",
                        "content": "Best tip! Thanks!"
                    },
                    {
                        "username": "sasaalina1985",
                        "content": "was reading this and solved the problem first try! Very good explanation!!!"
                    },
                    {
                        "username": "Yash_6207",
                        "content": "This is what we call as Greedy ! Good Explanation\\n"
                    },
                    {
                        "username": "iosifpetrupuha",
                        "content": "[@fjod](/fjod) but it\\'s buy day that should be before then sellday"
                    },
                    {
                        "username": "iosifpetrupuha",
                        "content": "[@iosifpetrupuha](/iosifpetrupuha) daaamn there is no indentation in this comment section"
                    },
                    {
                        "username": "iosifpetrupuha",
                        "content": "so I didn\\'t know this was called sliding window or sumthin, but I am second year at CS university, i have some grasp of this kind of logic and I solved it this way:\\nclass Solution:\\n    def maxProfit(self, prices: List[int]) -> int:\\n        #you obviously must buy before you sell(can\\'t go back in time)\\n        GreatestProfit=0\\n        priceToBeat=prices[0]\\n        for i in range(len(prices)-1):#we can iterate through the whole list, otherwise we get out of bounds, so we iterate from the first to the penultimate (so the last comparation we do is between the penultimate and the last element) \\n            if prices[i]<prices[i+1]:#sure profit, possible greatest profit\\n                if prices[i]<=priceToBeat:\\n                    priceToBeat=prices[i]\\n                if GreatestProfit<=prices[i+1]-priceToBeat: #if the GreatestProfit we calculate is greater than the one we have already, we update the Greatest Profit, otherwise we do nothing\\n                    GreatestProfit=prices[i+1]-priceToBeat\\n        return GreatestProfit\\nis this a proper way to solve this kind of problems? (in terms of efficiency I think we\\'re in O(n) so it should be pretty good"
                    },
                    {
                        "username": "Rohit_8412",
                        "content": "Thanks, I was about to see the solution after 10 min I didn\\'t get an approach into my mind.\\nThen I saw your discussion and I solved the question myself \\uD83D\\uDE0E"
                    },
                    {
                        "username": "fjod",
                        "content": "your explanation does not include rule of sellDay must be after buyDay"
                    },
                    {
                        "username": "Hanagaki_Takimichy",
                        "content": "thanks for great explaination without any spoilers.\\ni will try my best for the code, thanks a lot ;)"
                    },
                    {
                        "username": "csrnontol",
                        "content": "Sounds good, but I think your tip fails for [2,9,3,4,5,1,7] (how you\\'d choose 2, 9) and [2,9,3,4,5,1,7,10] (how you\\'d choose 1, 10)."
                    },
                    {
                        "username": "rockmanex",
                        "content": "best explanations so far. Thankyou it\\'s help a lot"
                    },
                    {
                        "username": "ak67",
                        "content": "I think this problem should be catogarise as medium level problem\\n"
                    },
                    {
                        "username": "Sultan_Ul_Arfin",
                        "content": "[@chazwinter](/chazwinter) what is sliding window? I never heard it ..will you explain that please<3\\n "
                    },
                    {
                        "username": "chazwinter",
                        "content": "It doesn\\'t require DP though. You only think it\\'s harder than it is because you\\'re overthinking it. You can use sliding window and just keep track of the lowest price as you go."
                    },
                    {
                        "username": "rwatso",
                        "content": "[@lucky_nik77](/lucky_nik77) Because by its very nature DP is not a beginner / easy level topic."
                    },
                    {
                        "username": "Vectorido",
                        "content": "[@lucky_nik77](/lucky_nik77) This is not hard for simple lists. But all people here usually stuck at TimeLimit error. So algorithm should be another, at least medium level of complexity."
                    },
                    {
                        "username": "lucky_nik77",
                        "content": "But why? It is hard to think about a DP problem that would be easier than this."
                    },
                    {
                        "username": "tiwarimrutunjay",
                        "content": "agreed"
                    },
                    {
                        "username": "codernoob",
                        "content": "how to resolve the time exceeded issue? Mine fails at 203rd test case with a large array"
                    },
                    {
                        "username": "user4279js",
                        "content": "[@rajamandalofficial56](/rajamandalofficial56) I\\'m not a javascript expert, but probably doing prices.slice(index) is looping 0 -index eachtime ... so you have O(N\\n^2) soltuion overall"
                    },
                    {
                        "username": "Behnoosh",
                        "content": "[@htooak2014](/htooak2014) To me it was occurring when my code had an O(n^2) complexity. Resolving that (to O(n)) solved this problem. I start from the end of the array prices and dynamically find the max value from the end of the array until the current step backwards. This way, at the end of the for loop, we can find the max profit with only one single pass over all entries of the array."
                    },
                    {
                        "username": "eyastaifour",
                        "content": "[@htooak2014](/htooak2014) I am hitting a limit error as well and I believe that it is because I keep on querying max() of the window, but when I think of it the max is either on the first index of the window (as I descend), or somewhere else, in which case, it should be cached as it doesnt change... at least, that\\'s what i am thinking\\n"
                    },
                    {
                        "username": "PercyJia95",
                        "content": "[@rajamandalofficial56](/rajamandalofficial56) You need to reconsider your variable naming. They carry very few meanings."
                    },
                    {
                        "username": "knotri",
                        "content": "[@rajamandalofficial56](/rajamandalofficial56) since u iterate over N elements with prices.map, and for each elements u call Math.max(...prices.slice) u need approx additional 1/2N to find maximum. So O(n) = n^2"
                    },
                    {
                        "username": "rajamandalofficial56",
                        "content": " let max = 0;\\n\\n    prices.map((el,index) => {\\n      let tem =  Math.max(...prices.slice(index))\\n      if(el< tem){\\n         if(max< tem-el){\\n             max = tem-el\\n         }\\n      }\\n    })\\n    return max\\n\\nError : Time Limit Exceeded\\n\\nO(n) complexity\\nwhat\\'s wrong this approach? "
                    },
                    {
                        "username": "htooak2014",
                        "content": "me too. time limit error occurs. why? leetcode compiler error?"
                    },
                    {
                        "username": "drmolenhouse",
                        "content": "Same issue, using the LeetCode Official solution lmao. What am I paying $35/month for?"
                    },
                    {
                        "username": "user4387LF",
                        "content": "Because you may be using a brute force approach with two loops checking every combination which takes O(n2) time; Cause it exceeds time limit. Optimize your code. Think to solve it in one pass with one loop in linear time."
                    },
                    {
                        "username": "Sahil481",
                        "content": "Your code is not well optimised. It is not ran within the given time limit."
                    },
                    {
                        "username": "pstrait",
                        "content": "Are you doing it with more than one loop? If so, there\\'s a better solution that has O(n) time complexity"
                    },
                    {
                        "username": "leet_code_master",
                        "content": "prices = [2, 4, 1]\\n\\nOutput: 0\\nExpected: 2\\n\\nYou buy on day three but cannot sell because it is the last day. Should that not be zero?"
                    },
                    {
                        "username": "langhudson870",
                        "content": "You should buy on day 1 and sell on day 2"
                    },
                    {
                        "username": "almaas21",
                        "content": "[@user4391xh](/user4391xh) \\nthe output required is max profit through traversing  in the list, it could be adjacent too like in [2,4,1] max_profit here is 2 not 0"
                    },
                    {
                        "username": "ashish_bhosale848",
                        "content": "Yes , I am facing the same issue at case 154"
                    },
                    {
                        "username": "user4391xh",
                        "content": "According to the example 2 \\n(Input: prices = [7,6,4,3,1]\\nOutput: 0\\nExplanation: In this case, no transactions are done and the max profit = 0.)\\nin the task description, 0 should be returned so looks like tests expect incorrect value here.."
                    },
                    {
                        "username": "kaushit",
                        "content": "[@mp9508](/mp9508) I also done the same thing but if that solution is wrong then what approach should we think."
                    },
                    {
                        "username": "shubhamDhapola",
                        "content": "you buy on the first day and sell on the second"
                    },
                    {
                        "username": "sazuki",
                        "content": "[@mp9508](/mp9508) This happend to me too, because ahahah well, the first value that is taken is the min() so basically 1, but this is the last one because that will end in a 0 output. "
                    },
                    {
                        "username": "HarshitBansal122",
                        "content": "buy on first day and sell on second day makes profit 2 "
                    },
                    {
                        "username": "Dan_A_S",
                        "content": "[@mkv1892](/mkv1892) I don\\'t agree with that (except if the explanation of the problem is not correct). What I understood from the explanation is, you buy when the price is cheapest and sell on a later date when you can maximize profit (meaning the highest prize on a later date from the date of purchase). Going by that, you buy at 1 so the output should be zero and not the expected 2."
                    },
                    {
                        "username": "mkv1892",
                        "content": "No, Here you buy at day 1, Where the buy price is 2 and sell at day 2, Where the sell price is 4."
                    },
                    {
                        "username": "Byas_Yadav",
                        "content": "[@mp9508](/mp9508) you buy on day 1 and sell it on day 2 i.e. profit =sell-buy --> 4-2=2"
                    },
                    {
                        "username": "mp9508",
                        "content": "[@leet_code_master](/leet_code_master) happened the same to me . the approach i took is:\\nfind the minimum element and then maxi=mini then use a loop from the next index of the lowest mini element and then find maxi, then return the output.\\nhope this helps\\n"
                    },
                    {
                        "username": "VaishaliChauhan",
                        "content": "We need to maximize profit, you can buy at 2 and sell on 4, giving a profit of 2"
                    },
                    {
                        "username": "IbrahimJunior",
                        "content": "you have to maintain your profit in a variable and only change the variable if the new profit is greater than the previous one, so for this scenario, 2 is the former profit, 0 is the new one, it is not greater than 2 so you don\\'t change your profit."
                    },
                    {
                        "username": "Hanagaki_Takimichy",
                        "content": "buy = 2 and sell = 4 profit = 2\\ni am facing the same problem bro............."
                    },
                    {
                        "username": "MatsRivel",
                        "content": "[@leet_code_master](/leet_code_master) What I did was look at what the largest value after i is for each i, and what the smallest value is before each i. Then, for each i, i subtract smallest from largest. This is your optimal profit for buying before i and selling after i. Now you just find the largest number out of these, and you\\'re done."
                    },
                    {
                        "username": "leet_code_master",
                        "content": "[@MeriemA](/MeriemA) I see. Thank you :) How do you recommend I go about this? Because now the new code I make messes up the second test case."
                    },
                    {
                        "username": "MeriemA",
                        "content": "Actually,  the idea here is how you can make the maximum of profits. You don\\'t have to buy the stock when it\\'s at its lowest price.\\nHere you can buy the first day and sell the second day and still make a profit which is 2.\\n"
                    },
                    {
                        "username": "EXLsunshine",
                        "content": "Why is this problem tagged with \"Dynamic programming\"?"
                    },
                    {
                        "username": "princebillygk2",
                        "content": "[@aryan14decsingh](/aryan14decsingh) The problem can be solved in Dynamic way but the more efficient way is array traversal approach."
                    },
                    {
                        "username": "Mrinal2100",
                        "content": "It should be tagged as two pointer problem"
                    },
                    {
                        "username": "aryan14decsingh",
                        "content": "Because it is Dynamic  ( debatable ) \\nquestion apart , did you get any job by now ? you posted this on 2015 , if you are still alive let me know if you got any jobs and some tips aswell"
                    },
                    {
                        "username": "djslim",
                        "content": "[@sourov1407](/sourov1407)  tbh it\\'s classic greedy problem, interestingly in leetcode 75 they marked it as greedy"
                    },
                    {
                        "username": "sahle123",
                        "content": "[@AdityaBhate](/AdityaBhate) He/she was asking a question, not for a solution."
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# \\uD83D\\uDEA9Easy C++ O(N) Soln. [ FAANG\\uD83D\\uDE31 Interview Optimized code ]\\n\\nhttps://leetcode.com/problems/best-time-to-buy-and-sell-stock/solutions/2822579/easy-c-o-n-soln-faang-interview-optimized-code/\\n\\n"
                    },
                    {
                        "username": "sourov1407",
                        "content": "Because we can use kadene\\'s algorithm here and as it is widely regarded as dp algorithm so yeah this problem is tagged with dynamic programming"
                    },
                    {
                        "username": "casper07",
                        "content": "I am So dumb...."
                    },
                    {
                        "username": "ydumar",
                        "content": "same bruh"
                    },
                    {
                        "username": "savagesam343",
                        "content": "me too bro, me too..."
                    },
                    {
                        "username": "night07",
                        "content": "me too jit"
                    },
                    {
                        "username": "AlgoEngine",
                        "content": "Video visualizing an intuitive proof of the O(n) solution:\nhttps://youtube.com/watch?v=ioFPBdChabY"
                    },
                    {
                        "username": "astek14",
                        "content": "Thanks it\\'s awesome"
                    },
                    {
                        "username": "shilbabun491",
                        "content": "how to resolve the time exceeded issue? Mine fails at 200th test case with a large array"
                    },
                    {
                        "username": "akelux",
                        "content": "How to get max profit 4 from input [3,2,6,5,0,3]?"
                    },
                    {
                        "username": "jenil59",
                        "content": "buy at 2 and sell at 6"
                    },
                    {
                        "username": "Trinto_610",
                        "content": "damn bro 2013"
                    },
                    {
                        "username": "prasumitmishra",
                        "content": "3 (buy),  2 (buy) , 6 (sell), 5 (hold), 0 (hold), 3 (hold)\\n-3 -2 + (2*6)\\n= -5 + 12 = 7"
                    },
                    {
                        "username": "KayvanShah1",
                        "content": "by selling on 6 and buying on 0\\nwhich means short selling"
                    },
                    {
                        "username": "bhanureddy7",
                        "content": "2,6"
                    },
                    {
                        "username": "Hanagaki_Takimichy",
                        "content": "buy = 2 and sell = 6"
                    },
                    {
                        "username": "hungkiet244203",
                        "content": "[@jannatbushra524](/jannatbushra524) yeah but the profit it provides isnt\\n"
                    },
                    {
                        "username": "MatsRivel",
                        "content": "[@jannatbushra524](/jannatbushra524) Buy at 0, then you have to sell after zero, so the best sell price is 3. 3-0 = 3, 6-2=4"
                    },
                    {
                        "username": "ajjha7203",
                        "content": "6-2 = 4"
                    },
                    {
                        "username": "damajsam93",
                        "content": "6-2 ==> 4 "
                    },
                    {
                        "username": "Jagdeep4485",
                        "content": "6-2= 4"
                    },
                    {
                        "username": "jannatbushra524",
                        "content": "[@rajanhossainkhan](/rajanhossainkhan) isn\\'t \\'0\\' a buy_price ??...and its smallest too."
                    },
                    {
                        "username": "rajanhossainkhan",
                        "content": "Here are the steps - \\n\\n1. First buy out price is 3 and profit is set to 0. \\n2. Now loop through array from index 1, since index 0 (which is 3) is taken as minimum buy out price for now. \\n3. Now if price is 2, then set this as new buy out price, since its smaller. So our current buy out price is 2. \\n4. Now next price is 6. This is bigger, so sell with current buy out price 2. \\n5. Calculate max profit  = max(profit, ( current_price - buy_price) \\n6. In this case, max(0, 6-2) = 4\\n\\nHope this helps. "
                    },
                    {
                        "username": "Amit_Joe",
                        "content": "2 -6\\n"
                    },
                    {
                        "username": "hemantgautam505",
                        "content": "output is 4\\n"
                    },
                    {
                        "username": "Shashi3k",
                        "content": "2-6\\n"
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for February, Day 1.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  **📌 Do you want to learn the problem thoroughly?**\n  Read [**⭐  LeetCode Official Solution⭐**](https://leetcode.com/problems/best-time-to-buy-and-sell-stock/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 2 approaches in the official solution</summary>\n\n  \n**Approach 1:** Brute Force\n\n  \n**Approach 2:** One Pass\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# \\uD83D\\uDEA9Easy C++ O(N) Soln. [ FAANG\\uD83D\\uDE31 Interview Optimized code ]\\n\\nhttps://leetcode.com/problems/best-time-to-buy-and-sell-stock/solutions/2822579/easy-c-o-n-soln-faang-interview-optimized-code/\\n"
                    }
                ]
            },
            {
                "id": 1564785,
                "content": [
                    {
                        "username": "Serosidium",
                        "content": "I couldn\\'t find any good explanations here and only code, so I will do my best to explain how I solved it without providing code. I am sure there are other possible solutions, but this is how it worked for me.\\n\\nThe brute force method of a double for loop is not necessary here, and this problem is marked with dynamic programming because it requires the [Sliding Window technique](https://algorithm-visualizer.org/dynamic-programming/sliding-window).\\n\\nBased on the fact that we have to sell after we buy and we are trying to maximize profit, we can iterate through the prices and only need to consider two things:\\n1.) **Is this price cheaper than any other price I\\'ve seen before?** \\n2.) If I subtract current price by the cheapest price I\\'ve found, **does this yield a greater profit than what I\\'ve seen so far?**\\n\\n*A fun thing to note is if #1 is true, then #2 cannot be true as well so there isn\\'t a need to check*\\n\\nLet\\'s consider an example of [4,1,5,2,7]\\n- 4 is the cheapest price we see to start, and we can\\'t sell on the first day so maxProfit is 0\\n- 1 is now the cheapest price we\\'ve seen. Selling now would lose us money, so we can\\'t update maxProfit\\n- 5 is not cheaper than 1, but if we sell now we get a maxProfit of 4! Better save that for later\\n- 2 is not cheaper than 1 and if we sell, we only get a profit of 1, no need to do anything here\\n- 7 is not cheaper than 1, but if we sell here, we\\'ll increase maxProfit to 6, making this the best profit to return.\\n\\nHope this helps someone else!\\n"
                    },
                    {
                        "username": "Manidgyf_6",
                        "content": "Thank you bro"
                    },
                    {
                        "username": "lorentzimys",
                        "content": "Awesome solution, thanks!"
                    },
                    {
                        "username": "Khoa268",
                        "content": "thanks for sharing!"
                    },
                    {
                        "username": "omeh-a",
                        "content": "This is not a DP solution as described, it is greedy"
                    },
                    {
                        "username": "ankitk742",
                        "content": "Thanks bro for your help without code really appreciate "
                    },
                    {
                        "username": "245120733119",
                        "content": "Brilliant!! Thanks for sharing!!"
                    },
                    {
                        "username": "Aniket_sggs",
                        "content": "Initially, this seemed to be DP problem. but after reading this description it is clear that this is basic problem with greedy solution."
                    },
                    {
                        "username": "duffinson97",
                        "content": "Thank you for not posting code, I don\\'t understand the sliding window technique or how this applies to that. I google it and the image link to this problem doesn\\'t make a lot of sense to me. But this solution works thanks"
                    },
                    {
                        "username": "typranjal1",
                        "content": "Thank you!."
                    },
                    {
                        "username": "jakho100",
                        "content": "was stuck on it for hours, thanks for the simple explanation! "
                    },
                    {
                        "username": "zafeer_rangoonwala",
                        "content": "I was originally not able to solve it but after reading your thought process it was a cake walk! \\n\\nThanks! "
                    },
                    {
                        "username": "mohammed1212345",
                        "content": "thank for helping out"
                    },
                    {
                        "username": "dungtuanuet",
                        "content": "Exellent explaination!"
                    },
                    {
                        "username": "kcleland18",
                        "content": "This was a great explanation!! Thanks!"
                    },
                    {
                        "username": "as358",
                        "content": "Best Explanation ever !!!"
                    },
                    {
                        "username": "user6798sW",
                        "content": "AWESOME BREAKDOWN! Ty"
                    },
                    {
                        "username": "jaydeep-pro",
                        "content": "[@evoniuk](/evoniuk) exactly! "
                    },
                    {
                        "username": "akshaydusad",
                        "content": "okay this is genius and surprisingly easier to follow!"
                    },
                    {
                        "username": "evoniuk",
                        "content": "Thank you! This is a solution that\\'s so simple and obvious once you see it you kick yourself for not thinking of it yourself!"
                    },
                    {
                        "username": "ivantchev",
                        "content": "How would the original wording of the problem have to be modified so that the double loop solution _has_ to be used?"
                    },
                    {
                        "username": "ivantchev",
                        "content": "Very helpful, thank you! To add: the reason why using your point 1.) works as a valid check is because given the problem constraints, it will always yield a higher profit down the line regardless of future values.\\n\\nAnd point  2.) shows we don\\'t need a second loop.\\n\\nI wonder, can any concrete aspect of the problem  be used as a clue so that we can reach Serosidium\\'s solution  independently. "
                    },
                    {
                        "username": "VishnuKesav",
                        "content": "[@sharpsailor](/sharpsailor) our target is to get highest possible profit.\\nYou are focusing on buying for the lowest price alone. No matter how low the price is, buying on a last day will yield 0 profit.\\n"
                    },
                    {
                        "username": "kaushar",
                        "content": "[@tengxianrui](/tengxianrui) Thanks  !"
                    },
                    {
                        "username": "neelimag459",
                        "content": "Thank you so much for such good explanation. Happy coding."
                    },
                    {
                        "username": "Nbs-26",
                        "content": "Thank u brother. Your explanation is very clear and well defined."
                    },
                    {
                        "username": "Dabchinsky",
                        "content": "[@sharpsailor](/sharpsailor) if we buy on 2 and sell on 4, our profit would be 4 - 2 = 2. "
                    },
                    {
                        "username": "sharpsailor",
                        "content": "check for {2,4,1} ideally it should give 0 but leetcode gives 2..Help me figure out where am I getting it wrong\\n"
                    },
                    {
                        "username": "jackbb147",
                        "content": "that\\'s actually very smart... thanks"
                    },
                    {
                        "username": "chiahao1",
                        "content": "Thank you! Your technique worked for me."
                    },
                    {
                        "username": "Marre-86",
                        "content": "Man, you made my day! I spent two hours and wrote almost 100 hundred lines code that probably was soving it but had \"time limit exceeded\" with huge input. And after your explanation I rewrite it in freaking 7 lines and it made it right off the bat!"
                    },
                    {
                        "username": "m1ma087",
                        "content": "Best tip! Thanks!"
                    },
                    {
                        "username": "sasaalina1985",
                        "content": "was reading this and solved the problem first try! Very good explanation!!!"
                    },
                    {
                        "username": "Yash_6207",
                        "content": "This is what we call as Greedy ! Good Explanation\\n"
                    },
                    {
                        "username": "iosifpetrupuha",
                        "content": "[@fjod](/fjod) but it\\'s buy day that should be before then sellday"
                    },
                    {
                        "username": "iosifpetrupuha",
                        "content": "[@iosifpetrupuha](/iosifpetrupuha) daaamn there is no indentation in this comment section"
                    },
                    {
                        "username": "iosifpetrupuha",
                        "content": "so I didn\\'t know this was called sliding window or sumthin, but I am second year at CS university, i have some grasp of this kind of logic and I solved it this way:\\nclass Solution:\\n    def maxProfit(self, prices: List[int]) -> int:\\n        #you obviously must buy before you sell(can\\'t go back in time)\\n        GreatestProfit=0\\n        priceToBeat=prices[0]\\n        for i in range(len(prices)-1):#we can iterate through the whole list, otherwise we get out of bounds, so we iterate from the first to the penultimate (so the last comparation we do is between the penultimate and the last element) \\n            if prices[i]<prices[i+1]:#sure profit, possible greatest profit\\n                if prices[i]<=priceToBeat:\\n                    priceToBeat=prices[i]\\n                if GreatestProfit<=prices[i+1]-priceToBeat: #if the GreatestProfit we calculate is greater than the one we have already, we update the Greatest Profit, otherwise we do nothing\\n                    GreatestProfit=prices[i+1]-priceToBeat\\n        return GreatestProfit\\nis this a proper way to solve this kind of problems? (in terms of efficiency I think we\\'re in O(n) so it should be pretty good"
                    },
                    {
                        "username": "Rohit_8412",
                        "content": "Thanks, I was about to see the solution after 10 min I didn\\'t get an approach into my mind.\\nThen I saw your discussion and I solved the question myself \\uD83D\\uDE0E"
                    },
                    {
                        "username": "fjod",
                        "content": "your explanation does not include rule of sellDay must be after buyDay"
                    },
                    {
                        "username": "Hanagaki_Takimichy",
                        "content": "thanks for great explaination without any spoilers.\\ni will try my best for the code, thanks a lot ;)"
                    },
                    {
                        "username": "csrnontol",
                        "content": "Sounds good, but I think your tip fails for [2,9,3,4,5,1,7] (how you\\'d choose 2, 9) and [2,9,3,4,5,1,7,10] (how you\\'d choose 1, 10)."
                    },
                    {
                        "username": "rockmanex",
                        "content": "best explanations so far. Thankyou it\\'s help a lot"
                    },
                    {
                        "username": "ak67",
                        "content": "I think this problem should be catogarise as medium level problem\\n"
                    },
                    {
                        "username": "Sultan_Ul_Arfin",
                        "content": "[@chazwinter](/chazwinter) what is sliding window? I never heard it ..will you explain that please<3\\n "
                    },
                    {
                        "username": "chazwinter",
                        "content": "It doesn\\'t require DP though. You only think it\\'s harder than it is because you\\'re overthinking it. You can use sliding window and just keep track of the lowest price as you go."
                    },
                    {
                        "username": "rwatso",
                        "content": "[@lucky_nik77](/lucky_nik77) Because by its very nature DP is not a beginner / easy level topic."
                    },
                    {
                        "username": "Vectorido",
                        "content": "[@lucky_nik77](/lucky_nik77) This is not hard for simple lists. But all people here usually stuck at TimeLimit error. So algorithm should be another, at least medium level of complexity."
                    },
                    {
                        "username": "lucky_nik77",
                        "content": "But why? It is hard to think about a DP problem that would be easier than this."
                    },
                    {
                        "username": "tiwarimrutunjay",
                        "content": "agreed"
                    },
                    {
                        "username": "codernoob",
                        "content": "how to resolve the time exceeded issue? Mine fails at 203rd test case with a large array"
                    },
                    {
                        "username": "user4279js",
                        "content": "[@rajamandalofficial56](/rajamandalofficial56) I\\'m not a javascript expert, but probably doing prices.slice(index) is looping 0 -index eachtime ... so you have O(N\\n^2) soltuion overall"
                    },
                    {
                        "username": "Behnoosh",
                        "content": "[@htooak2014](/htooak2014) To me it was occurring when my code had an O(n^2) complexity. Resolving that (to O(n)) solved this problem. I start from the end of the array prices and dynamically find the max value from the end of the array until the current step backwards. This way, at the end of the for loop, we can find the max profit with only one single pass over all entries of the array."
                    },
                    {
                        "username": "eyastaifour",
                        "content": "[@htooak2014](/htooak2014) I am hitting a limit error as well and I believe that it is because I keep on querying max() of the window, but when I think of it the max is either on the first index of the window (as I descend), or somewhere else, in which case, it should be cached as it doesnt change... at least, that\\'s what i am thinking\\n"
                    },
                    {
                        "username": "PercyJia95",
                        "content": "[@rajamandalofficial56](/rajamandalofficial56) You need to reconsider your variable naming. They carry very few meanings."
                    },
                    {
                        "username": "knotri",
                        "content": "[@rajamandalofficial56](/rajamandalofficial56) since u iterate over N elements with prices.map, and for each elements u call Math.max(...prices.slice) u need approx additional 1/2N to find maximum. So O(n) = n^2"
                    },
                    {
                        "username": "rajamandalofficial56",
                        "content": " let max = 0;\\n\\n    prices.map((el,index) => {\\n      let tem =  Math.max(...prices.slice(index))\\n      if(el< tem){\\n         if(max< tem-el){\\n             max = tem-el\\n         }\\n      }\\n    })\\n    return max\\n\\nError : Time Limit Exceeded\\n\\nO(n) complexity\\nwhat\\'s wrong this approach? "
                    },
                    {
                        "username": "htooak2014",
                        "content": "me too. time limit error occurs. why? leetcode compiler error?"
                    },
                    {
                        "username": "drmolenhouse",
                        "content": "Same issue, using the LeetCode Official solution lmao. What am I paying $35/month for?"
                    },
                    {
                        "username": "user4387LF",
                        "content": "Because you may be using a brute force approach with two loops checking every combination which takes O(n2) time; Cause it exceeds time limit. Optimize your code. Think to solve it in one pass with one loop in linear time."
                    },
                    {
                        "username": "Sahil481",
                        "content": "Your code is not well optimised. It is not ran within the given time limit."
                    },
                    {
                        "username": "pstrait",
                        "content": "Are you doing it with more than one loop? If so, there\\'s a better solution that has O(n) time complexity"
                    },
                    {
                        "username": "leet_code_master",
                        "content": "prices = [2, 4, 1]\\n\\nOutput: 0\\nExpected: 2\\n\\nYou buy on day three but cannot sell because it is the last day. Should that not be zero?"
                    },
                    {
                        "username": "langhudson870",
                        "content": "You should buy on day 1 and sell on day 2"
                    },
                    {
                        "username": "almaas21",
                        "content": "[@user4391xh](/user4391xh) \\nthe output required is max profit through traversing  in the list, it could be adjacent too like in [2,4,1] max_profit here is 2 not 0"
                    },
                    {
                        "username": "ashish_bhosale848",
                        "content": "Yes , I am facing the same issue at case 154"
                    },
                    {
                        "username": "user4391xh",
                        "content": "According to the example 2 \\n(Input: prices = [7,6,4,3,1]\\nOutput: 0\\nExplanation: In this case, no transactions are done and the max profit = 0.)\\nin the task description, 0 should be returned so looks like tests expect incorrect value here.."
                    },
                    {
                        "username": "kaushit",
                        "content": "[@mp9508](/mp9508) I also done the same thing but if that solution is wrong then what approach should we think."
                    },
                    {
                        "username": "shubhamDhapola",
                        "content": "you buy on the first day and sell on the second"
                    },
                    {
                        "username": "sazuki",
                        "content": "[@mp9508](/mp9508) This happend to me too, because ahahah well, the first value that is taken is the min() so basically 1, but this is the last one because that will end in a 0 output. "
                    },
                    {
                        "username": "HarshitBansal122",
                        "content": "buy on first day and sell on second day makes profit 2 "
                    },
                    {
                        "username": "Dan_A_S",
                        "content": "[@mkv1892](/mkv1892) I don\\'t agree with that (except if the explanation of the problem is not correct). What I understood from the explanation is, you buy when the price is cheapest and sell on a later date when you can maximize profit (meaning the highest prize on a later date from the date of purchase). Going by that, you buy at 1 so the output should be zero and not the expected 2."
                    },
                    {
                        "username": "mkv1892",
                        "content": "No, Here you buy at day 1, Where the buy price is 2 and sell at day 2, Where the sell price is 4."
                    },
                    {
                        "username": "Byas_Yadav",
                        "content": "[@mp9508](/mp9508) you buy on day 1 and sell it on day 2 i.e. profit =sell-buy --> 4-2=2"
                    },
                    {
                        "username": "mp9508",
                        "content": "[@leet_code_master](/leet_code_master) happened the same to me . the approach i took is:\\nfind the minimum element and then maxi=mini then use a loop from the next index of the lowest mini element and then find maxi, then return the output.\\nhope this helps\\n"
                    },
                    {
                        "username": "VaishaliChauhan",
                        "content": "We need to maximize profit, you can buy at 2 and sell on 4, giving a profit of 2"
                    },
                    {
                        "username": "IbrahimJunior",
                        "content": "you have to maintain your profit in a variable and only change the variable if the new profit is greater than the previous one, so for this scenario, 2 is the former profit, 0 is the new one, it is not greater than 2 so you don\\'t change your profit."
                    },
                    {
                        "username": "Hanagaki_Takimichy",
                        "content": "buy = 2 and sell = 4 profit = 2\\ni am facing the same problem bro............."
                    },
                    {
                        "username": "MatsRivel",
                        "content": "[@leet_code_master](/leet_code_master) What I did was look at what the largest value after i is for each i, and what the smallest value is before each i. Then, for each i, i subtract smallest from largest. This is your optimal profit for buying before i and selling after i. Now you just find the largest number out of these, and you\\'re done."
                    },
                    {
                        "username": "leet_code_master",
                        "content": "[@MeriemA](/MeriemA) I see. Thank you :) How do you recommend I go about this? Because now the new code I make messes up the second test case."
                    },
                    {
                        "username": "MeriemA",
                        "content": "Actually,  the idea here is how you can make the maximum of profits. You don\\'t have to buy the stock when it\\'s at its lowest price.\\nHere you can buy the first day and sell the second day and still make a profit which is 2.\\n"
                    },
                    {
                        "username": "EXLsunshine",
                        "content": "Why is this problem tagged with \"Dynamic programming\"?"
                    },
                    {
                        "username": "princebillygk2",
                        "content": "[@aryan14decsingh](/aryan14decsingh) The problem can be solved in Dynamic way but the more efficient way is array traversal approach."
                    },
                    {
                        "username": "Mrinal2100",
                        "content": "It should be tagged as two pointer problem"
                    },
                    {
                        "username": "aryan14decsingh",
                        "content": "Because it is Dynamic  ( debatable ) \\nquestion apart , did you get any job by now ? you posted this on 2015 , if you are still alive let me know if you got any jobs and some tips aswell"
                    },
                    {
                        "username": "djslim",
                        "content": "[@sourov1407](/sourov1407)  tbh it\\'s classic greedy problem, interestingly in leetcode 75 they marked it as greedy"
                    },
                    {
                        "username": "sahle123",
                        "content": "[@AdityaBhate](/AdityaBhate) He/she was asking a question, not for a solution."
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# \\uD83D\\uDEA9Easy C++ O(N) Soln. [ FAANG\\uD83D\\uDE31 Interview Optimized code ]\\n\\nhttps://leetcode.com/problems/best-time-to-buy-and-sell-stock/solutions/2822579/easy-c-o-n-soln-faang-interview-optimized-code/\\n\\n"
                    },
                    {
                        "username": "sourov1407",
                        "content": "Because we can use kadene\\'s algorithm here and as it is widely regarded as dp algorithm so yeah this problem is tagged with dynamic programming"
                    },
                    {
                        "username": "casper07",
                        "content": "I am So dumb...."
                    },
                    {
                        "username": "ydumar",
                        "content": "same bruh"
                    },
                    {
                        "username": "savagesam343",
                        "content": "me too bro, me too..."
                    },
                    {
                        "username": "night07",
                        "content": "me too jit"
                    },
                    {
                        "username": "AlgoEngine",
                        "content": "Video visualizing an intuitive proof of the O(n) solution:\nhttps://youtube.com/watch?v=ioFPBdChabY"
                    },
                    {
                        "username": "astek14",
                        "content": "Thanks it\\'s awesome"
                    },
                    {
                        "username": "shilbabun491",
                        "content": "how to resolve the time exceeded issue? Mine fails at 200th test case with a large array"
                    },
                    {
                        "username": "akelux",
                        "content": "How to get max profit 4 from input [3,2,6,5,0,3]?"
                    },
                    {
                        "username": "jenil59",
                        "content": "buy at 2 and sell at 6"
                    },
                    {
                        "username": "Trinto_610",
                        "content": "damn bro 2013"
                    },
                    {
                        "username": "prasumitmishra",
                        "content": "3 (buy),  2 (buy) , 6 (sell), 5 (hold), 0 (hold), 3 (hold)\\n-3 -2 + (2*6)\\n= -5 + 12 = 7"
                    },
                    {
                        "username": "KayvanShah1",
                        "content": "by selling on 6 and buying on 0\\nwhich means short selling"
                    },
                    {
                        "username": "bhanureddy7",
                        "content": "2,6"
                    },
                    {
                        "username": "Hanagaki_Takimichy",
                        "content": "buy = 2 and sell = 6"
                    },
                    {
                        "username": "hungkiet244203",
                        "content": "[@jannatbushra524](/jannatbushra524) yeah but the profit it provides isnt\\n"
                    },
                    {
                        "username": "MatsRivel",
                        "content": "[@jannatbushra524](/jannatbushra524) Buy at 0, then you have to sell after zero, so the best sell price is 3. 3-0 = 3, 6-2=4"
                    },
                    {
                        "username": "ajjha7203",
                        "content": "6-2 = 4"
                    },
                    {
                        "username": "damajsam93",
                        "content": "6-2 ==> 4 "
                    },
                    {
                        "username": "Jagdeep4485",
                        "content": "6-2= 4"
                    },
                    {
                        "username": "jannatbushra524",
                        "content": "[@rajanhossainkhan](/rajanhossainkhan) isn\\'t \\'0\\' a buy_price ??...and its smallest too."
                    },
                    {
                        "username": "rajanhossainkhan",
                        "content": "Here are the steps - \\n\\n1. First buy out price is 3 and profit is set to 0. \\n2. Now loop through array from index 1, since index 0 (which is 3) is taken as minimum buy out price for now. \\n3. Now if price is 2, then set this as new buy out price, since its smaller. So our current buy out price is 2. \\n4. Now next price is 6. This is bigger, so sell with current buy out price 2. \\n5. Calculate max profit  = max(profit, ( current_price - buy_price) \\n6. In this case, max(0, 6-2) = 4\\n\\nHope this helps. "
                    },
                    {
                        "username": "Amit_Joe",
                        "content": "2 -6\\n"
                    },
                    {
                        "username": "hemantgautam505",
                        "content": "output is 4\\n"
                    },
                    {
                        "username": "Shashi3k",
                        "content": "2-6\\n"
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for February, Day 1.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  **📌 Do you want to learn the problem thoroughly?**\n  Read [**⭐  LeetCode Official Solution⭐**](https://leetcode.com/problems/best-time-to-buy-and-sell-stock/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 2 approaches in the official solution</summary>\n\n  \n**Approach 1:** Brute Force\n\n  \n**Approach 2:** One Pass\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# \\uD83D\\uDEA9Easy C++ O(N) Soln. [ FAANG\\uD83D\\uDE31 Interview Optimized code ]\\n\\nhttps://leetcode.com/problems/best-time-to-buy-and-sell-stock/solutions/2822579/easy-c-o-n-soln-faang-interview-optimized-code/\\n"
                    }
                ]
            },
            {
                "id": 1785221,
                "content": [
                    {
                        "username": "Serosidium",
                        "content": "I couldn\\'t find any good explanations here and only code, so I will do my best to explain how I solved it without providing code. I am sure there are other possible solutions, but this is how it worked for me.\\n\\nThe brute force method of a double for loop is not necessary here, and this problem is marked with dynamic programming because it requires the [Sliding Window technique](https://algorithm-visualizer.org/dynamic-programming/sliding-window).\\n\\nBased on the fact that we have to sell after we buy and we are trying to maximize profit, we can iterate through the prices and only need to consider two things:\\n1.) **Is this price cheaper than any other price I\\'ve seen before?** \\n2.) If I subtract current price by the cheapest price I\\'ve found, **does this yield a greater profit than what I\\'ve seen so far?**\\n\\n*A fun thing to note is if #1 is true, then #2 cannot be true as well so there isn\\'t a need to check*\\n\\nLet\\'s consider an example of [4,1,5,2,7]\\n- 4 is the cheapest price we see to start, and we can\\'t sell on the first day so maxProfit is 0\\n- 1 is now the cheapest price we\\'ve seen. Selling now would lose us money, so we can\\'t update maxProfit\\n- 5 is not cheaper than 1, but if we sell now we get a maxProfit of 4! Better save that for later\\n- 2 is not cheaper than 1 and if we sell, we only get a profit of 1, no need to do anything here\\n- 7 is not cheaper than 1, but if we sell here, we\\'ll increase maxProfit to 6, making this the best profit to return.\\n\\nHope this helps someone else!\\n"
                    },
                    {
                        "username": "Manidgyf_6",
                        "content": "Thank you bro"
                    },
                    {
                        "username": "lorentzimys",
                        "content": "Awesome solution, thanks!"
                    },
                    {
                        "username": "Khoa268",
                        "content": "thanks for sharing!"
                    },
                    {
                        "username": "omeh-a",
                        "content": "This is not a DP solution as described, it is greedy"
                    },
                    {
                        "username": "ankitk742",
                        "content": "Thanks bro for your help without code really appreciate "
                    },
                    {
                        "username": "245120733119",
                        "content": "Brilliant!! Thanks for sharing!!"
                    },
                    {
                        "username": "Aniket_sggs",
                        "content": "Initially, this seemed to be DP problem. but after reading this description it is clear that this is basic problem with greedy solution."
                    },
                    {
                        "username": "duffinson97",
                        "content": "Thank you for not posting code, I don\\'t understand the sliding window technique or how this applies to that. I google it and the image link to this problem doesn\\'t make a lot of sense to me. But this solution works thanks"
                    },
                    {
                        "username": "typranjal1",
                        "content": "Thank you!."
                    },
                    {
                        "username": "jakho100",
                        "content": "was stuck on it for hours, thanks for the simple explanation! "
                    },
                    {
                        "username": "zafeer_rangoonwala",
                        "content": "I was originally not able to solve it but after reading your thought process it was a cake walk! \\n\\nThanks! "
                    },
                    {
                        "username": "mohammed1212345",
                        "content": "thank for helping out"
                    },
                    {
                        "username": "dungtuanuet",
                        "content": "Exellent explaination!"
                    },
                    {
                        "username": "kcleland18",
                        "content": "This was a great explanation!! Thanks!"
                    },
                    {
                        "username": "as358",
                        "content": "Best Explanation ever !!!"
                    },
                    {
                        "username": "user6798sW",
                        "content": "AWESOME BREAKDOWN! Ty"
                    },
                    {
                        "username": "jaydeep-pro",
                        "content": "[@evoniuk](/evoniuk) exactly! "
                    },
                    {
                        "username": "akshaydusad",
                        "content": "okay this is genius and surprisingly easier to follow!"
                    },
                    {
                        "username": "evoniuk",
                        "content": "Thank you! This is a solution that\\'s so simple and obvious once you see it you kick yourself for not thinking of it yourself!"
                    },
                    {
                        "username": "ivantchev",
                        "content": "How would the original wording of the problem have to be modified so that the double loop solution _has_ to be used?"
                    },
                    {
                        "username": "ivantchev",
                        "content": "Very helpful, thank you! To add: the reason why using your point 1.) works as a valid check is because given the problem constraints, it will always yield a higher profit down the line regardless of future values.\\n\\nAnd point  2.) shows we don\\'t need a second loop.\\n\\nI wonder, can any concrete aspect of the problem  be used as a clue so that we can reach Serosidium\\'s solution  independently. "
                    },
                    {
                        "username": "VishnuKesav",
                        "content": "[@sharpsailor](/sharpsailor) our target is to get highest possible profit.\\nYou are focusing on buying for the lowest price alone. No matter how low the price is, buying on a last day will yield 0 profit.\\n"
                    },
                    {
                        "username": "kaushar",
                        "content": "[@tengxianrui](/tengxianrui) Thanks  !"
                    },
                    {
                        "username": "neelimag459",
                        "content": "Thank you so much for such good explanation. Happy coding."
                    },
                    {
                        "username": "Nbs-26",
                        "content": "Thank u brother. Your explanation is very clear and well defined."
                    },
                    {
                        "username": "Dabchinsky",
                        "content": "[@sharpsailor](/sharpsailor) if we buy on 2 and sell on 4, our profit would be 4 - 2 = 2. "
                    },
                    {
                        "username": "sharpsailor",
                        "content": "check for {2,4,1} ideally it should give 0 but leetcode gives 2..Help me figure out where am I getting it wrong\\n"
                    },
                    {
                        "username": "jackbb147",
                        "content": "that\\'s actually very smart... thanks"
                    },
                    {
                        "username": "chiahao1",
                        "content": "Thank you! Your technique worked for me."
                    },
                    {
                        "username": "Marre-86",
                        "content": "Man, you made my day! I spent two hours and wrote almost 100 hundred lines code that probably was soving it but had \"time limit exceeded\" with huge input. And after your explanation I rewrite it in freaking 7 lines and it made it right off the bat!"
                    },
                    {
                        "username": "m1ma087",
                        "content": "Best tip! Thanks!"
                    },
                    {
                        "username": "sasaalina1985",
                        "content": "was reading this and solved the problem first try! Very good explanation!!!"
                    },
                    {
                        "username": "Yash_6207",
                        "content": "This is what we call as Greedy ! Good Explanation\\n"
                    },
                    {
                        "username": "iosifpetrupuha",
                        "content": "[@fjod](/fjod) but it\\'s buy day that should be before then sellday"
                    },
                    {
                        "username": "iosifpetrupuha",
                        "content": "[@iosifpetrupuha](/iosifpetrupuha) daaamn there is no indentation in this comment section"
                    },
                    {
                        "username": "iosifpetrupuha",
                        "content": "so I didn\\'t know this was called sliding window or sumthin, but I am second year at CS university, i have some grasp of this kind of logic and I solved it this way:\\nclass Solution:\\n    def maxProfit(self, prices: List[int]) -> int:\\n        #you obviously must buy before you sell(can\\'t go back in time)\\n        GreatestProfit=0\\n        priceToBeat=prices[0]\\n        for i in range(len(prices)-1):#we can iterate through the whole list, otherwise we get out of bounds, so we iterate from the first to the penultimate (so the last comparation we do is between the penultimate and the last element) \\n            if prices[i]<prices[i+1]:#sure profit, possible greatest profit\\n                if prices[i]<=priceToBeat:\\n                    priceToBeat=prices[i]\\n                if GreatestProfit<=prices[i+1]-priceToBeat: #if the GreatestProfit we calculate is greater than the one we have already, we update the Greatest Profit, otherwise we do nothing\\n                    GreatestProfit=prices[i+1]-priceToBeat\\n        return GreatestProfit\\nis this a proper way to solve this kind of problems? (in terms of efficiency I think we\\'re in O(n) so it should be pretty good"
                    },
                    {
                        "username": "Rohit_8412",
                        "content": "Thanks, I was about to see the solution after 10 min I didn\\'t get an approach into my mind.\\nThen I saw your discussion and I solved the question myself \\uD83D\\uDE0E"
                    },
                    {
                        "username": "fjod",
                        "content": "your explanation does not include rule of sellDay must be after buyDay"
                    },
                    {
                        "username": "Hanagaki_Takimichy",
                        "content": "thanks for great explaination without any spoilers.\\ni will try my best for the code, thanks a lot ;)"
                    },
                    {
                        "username": "csrnontol",
                        "content": "Sounds good, but I think your tip fails for [2,9,3,4,5,1,7] (how you\\'d choose 2, 9) and [2,9,3,4,5,1,7,10] (how you\\'d choose 1, 10)."
                    },
                    {
                        "username": "rockmanex",
                        "content": "best explanations so far. Thankyou it\\'s help a lot"
                    },
                    {
                        "username": "ak67",
                        "content": "I think this problem should be catogarise as medium level problem\\n"
                    },
                    {
                        "username": "Sultan_Ul_Arfin",
                        "content": "[@chazwinter](/chazwinter) what is sliding window? I never heard it ..will you explain that please<3\\n "
                    },
                    {
                        "username": "chazwinter",
                        "content": "It doesn\\'t require DP though. You only think it\\'s harder than it is because you\\'re overthinking it. You can use sliding window and just keep track of the lowest price as you go."
                    },
                    {
                        "username": "rwatso",
                        "content": "[@lucky_nik77](/lucky_nik77) Because by its very nature DP is not a beginner / easy level topic."
                    },
                    {
                        "username": "Vectorido",
                        "content": "[@lucky_nik77](/lucky_nik77) This is not hard for simple lists. But all people here usually stuck at TimeLimit error. So algorithm should be another, at least medium level of complexity."
                    },
                    {
                        "username": "lucky_nik77",
                        "content": "But why? It is hard to think about a DP problem that would be easier than this."
                    },
                    {
                        "username": "tiwarimrutunjay",
                        "content": "agreed"
                    },
                    {
                        "username": "codernoob",
                        "content": "how to resolve the time exceeded issue? Mine fails at 203rd test case with a large array"
                    },
                    {
                        "username": "user4279js",
                        "content": "[@rajamandalofficial56](/rajamandalofficial56) I\\'m not a javascript expert, but probably doing prices.slice(index) is looping 0 -index eachtime ... so you have O(N\\n^2) soltuion overall"
                    },
                    {
                        "username": "Behnoosh",
                        "content": "[@htooak2014](/htooak2014) To me it was occurring when my code had an O(n^2) complexity. Resolving that (to O(n)) solved this problem. I start from the end of the array prices and dynamically find the max value from the end of the array until the current step backwards. This way, at the end of the for loop, we can find the max profit with only one single pass over all entries of the array."
                    },
                    {
                        "username": "eyastaifour",
                        "content": "[@htooak2014](/htooak2014) I am hitting a limit error as well and I believe that it is because I keep on querying max() of the window, but when I think of it the max is either on the first index of the window (as I descend), or somewhere else, in which case, it should be cached as it doesnt change... at least, that\\'s what i am thinking\\n"
                    },
                    {
                        "username": "PercyJia95",
                        "content": "[@rajamandalofficial56](/rajamandalofficial56) You need to reconsider your variable naming. They carry very few meanings."
                    },
                    {
                        "username": "knotri",
                        "content": "[@rajamandalofficial56](/rajamandalofficial56) since u iterate over N elements with prices.map, and for each elements u call Math.max(...prices.slice) u need approx additional 1/2N to find maximum. So O(n) = n^2"
                    },
                    {
                        "username": "rajamandalofficial56",
                        "content": " let max = 0;\\n\\n    prices.map((el,index) => {\\n      let tem =  Math.max(...prices.slice(index))\\n      if(el< tem){\\n         if(max< tem-el){\\n             max = tem-el\\n         }\\n      }\\n    })\\n    return max\\n\\nError : Time Limit Exceeded\\n\\nO(n) complexity\\nwhat\\'s wrong this approach? "
                    },
                    {
                        "username": "htooak2014",
                        "content": "me too. time limit error occurs. why? leetcode compiler error?"
                    },
                    {
                        "username": "drmolenhouse",
                        "content": "Same issue, using the LeetCode Official solution lmao. What am I paying $35/month for?"
                    },
                    {
                        "username": "user4387LF",
                        "content": "Because you may be using a brute force approach with two loops checking every combination which takes O(n2) time; Cause it exceeds time limit. Optimize your code. Think to solve it in one pass with one loop in linear time."
                    },
                    {
                        "username": "Sahil481",
                        "content": "Your code is not well optimised. It is not ran within the given time limit."
                    },
                    {
                        "username": "pstrait",
                        "content": "Are you doing it with more than one loop? If so, there\\'s a better solution that has O(n) time complexity"
                    },
                    {
                        "username": "leet_code_master",
                        "content": "prices = [2, 4, 1]\\n\\nOutput: 0\\nExpected: 2\\n\\nYou buy on day three but cannot sell because it is the last day. Should that not be zero?"
                    },
                    {
                        "username": "langhudson870",
                        "content": "You should buy on day 1 and sell on day 2"
                    },
                    {
                        "username": "almaas21",
                        "content": "[@user4391xh](/user4391xh) \\nthe output required is max profit through traversing  in the list, it could be adjacent too like in [2,4,1] max_profit here is 2 not 0"
                    },
                    {
                        "username": "ashish_bhosale848",
                        "content": "Yes , I am facing the same issue at case 154"
                    },
                    {
                        "username": "user4391xh",
                        "content": "According to the example 2 \\n(Input: prices = [7,6,4,3,1]\\nOutput: 0\\nExplanation: In this case, no transactions are done and the max profit = 0.)\\nin the task description, 0 should be returned so looks like tests expect incorrect value here.."
                    },
                    {
                        "username": "kaushit",
                        "content": "[@mp9508](/mp9508) I also done the same thing but if that solution is wrong then what approach should we think."
                    },
                    {
                        "username": "shubhamDhapola",
                        "content": "you buy on the first day and sell on the second"
                    },
                    {
                        "username": "sazuki",
                        "content": "[@mp9508](/mp9508) This happend to me too, because ahahah well, the first value that is taken is the min() so basically 1, but this is the last one because that will end in a 0 output. "
                    },
                    {
                        "username": "HarshitBansal122",
                        "content": "buy on first day and sell on second day makes profit 2 "
                    },
                    {
                        "username": "Dan_A_S",
                        "content": "[@mkv1892](/mkv1892) I don\\'t agree with that (except if the explanation of the problem is not correct). What I understood from the explanation is, you buy when the price is cheapest and sell on a later date when you can maximize profit (meaning the highest prize on a later date from the date of purchase). Going by that, you buy at 1 so the output should be zero and not the expected 2."
                    },
                    {
                        "username": "mkv1892",
                        "content": "No, Here you buy at day 1, Where the buy price is 2 and sell at day 2, Where the sell price is 4."
                    },
                    {
                        "username": "Byas_Yadav",
                        "content": "[@mp9508](/mp9508) you buy on day 1 and sell it on day 2 i.e. profit =sell-buy --> 4-2=2"
                    },
                    {
                        "username": "mp9508",
                        "content": "[@leet_code_master](/leet_code_master) happened the same to me . the approach i took is:\\nfind the minimum element and then maxi=mini then use a loop from the next index of the lowest mini element and then find maxi, then return the output.\\nhope this helps\\n"
                    },
                    {
                        "username": "VaishaliChauhan",
                        "content": "We need to maximize profit, you can buy at 2 and sell on 4, giving a profit of 2"
                    },
                    {
                        "username": "IbrahimJunior",
                        "content": "you have to maintain your profit in a variable and only change the variable if the new profit is greater than the previous one, so for this scenario, 2 is the former profit, 0 is the new one, it is not greater than 2 so you don\\'t change your profit."
                    },
                    {
                        "username": "Hanagaki_Takimichy",
                        "content": "buy = 2 and sell = 4 profit = 2\\ni am facing the same problem bro............."
                    },
                    {
                        "username": "MatsRivel",
                        "content": "[@leet_code_master](/leet_code_master) What I did was look at what the largest value after i is for each i, and what the smallest value is before each i. Then, for each i, i subtract smallest from largest. This is your optimal profit for buying before i and selling after i. Now you just find the largest number out of these, and you\\'re done."
                    },
                    {
                        "username": "leet_code_master",
                        "content": "[@MeriemA](/MeriemA) I see. Thank you :) How do you recommend I go about this? Because now the new code I make messes up the second test case."
                    },
                    {
                        "username": "MeriemA",
                        "content": "Actually,  the idea here is how you can make the maximum of profits. You don\\'t have to buy the stock when it\\'s at its lowest price.\\nHere you can buy the first day and sell the second day and still make a profit which is 2.\\n"
                    },
                    {
                        "username": "EXLsunshine",
                        "content": "Why is this problem tagged with \"Dynamic programming\"?"
                    },
                    {
                        "username": "princebillygk2",
                        "content": "[@aryan14decsingh](/aryan14decsingh) The problem can be solved in Dynamic way but the more efficient way is array traversal approach."
                    },
                    {
                        "username": "Mrinal2100",
                        "content": "It should be tagged as two pointer problem"
                    },
                    {
                        "username": "aryan14decsingh",
                        "content": "Because it is Dynamic  ( debatable ) \\nquestion apart , did you get any job by now ? you posted this on 2015 , if you are still alive let me know if you got any jobs and some tips aswell"
                    },
                    {
                        "username": "djslim",
                        "content": "[@sourov1407](/sourov1407)  tbh it\\'s classic greedy problem, interestingly in leetcode 75 they marked it as greedy"
                    },
                    {
                        "username": "sahle123",
                        "content": "[@AdityaBhate](/AdityaBhate) He/she was asking a question, not for a solution."
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# \\uD83D\\uDEA9Easy C++ O(N) Soln. [ FAANG\\uD83D\\uDE31 Interview Optimized code ]\\n\\nhttps://leetcode.com/problems/best-time-to-buy-and-sell-stock/solutions/2822579/easy-c-o-n-soln-faang-interview-optimized-code/\\n\\n"
                    },
                    {
                        "username": "sourov1407",
                        "content": "Because we can use kadene\\'s algorithm here and as it is widely regarded as dp algorithm so yeah this problem is tagged with dynamic programming"
                    },
                    {
                        "username": "casper07",
                        "content": "I am So dumb...."
                    },
                    {
                        "username": "ydumar",
                        "content": "same bruh"
                    },
                    {
                        "username": "savagesam343",
                        "content": "me too bro, me too..."
                    },
                    {
                        "username": "night07",
                        "content": "me too jit"
                    },
                    {
                        "username": "AlgoEngine",
                        "content": "Video visualizing an intuitive proof of the O(n) solution:\nhttps://youtube.com/watch?v=ioFPBdChabY"
                    },
                    {
                        "username": "astek14",
                        "content": "Thanks it\\'s awesome"
                    },
                    {
                        "username": "shilbabun491",
                        "content": "how to resolve the time exceeded issue? Mine fails at 200th test case with a large array"
                    },
                    {
                        "username": "akelux",
                        "content": "How to get max profit 4 from input [3,2,6,5,0,3]?"
                    },
                    {
                        "username": "jenil59",
                        "content": "buy at 2 and sell at 6"
                    },
                    {
                        "username": "Trinto_610",
                        "content": "damn bro 2013"
                    },
                    {
                        "username": "prasumitmishra",
                        "content": "3 (buy),  2 (buy) , 6 (sell), 5 (hold), 0 (hold), 3 (hold)\\n-3 -2 + (2*6)\\n= -5 + 12 = 7"
                    },
                    {
                        "username": "KayvanShah1",
                        "content": "by selling on 6 and buying on 0\\nwhich means short selling"
                    },
                    {
                        "username": "bhanureddy7",
                        "content": "2,6"
                    },
                    {
                        "username": "Hanagaki_Takimichy",
                        "content": "buy = 2 and sell = 6"
                    },
                    {
                        "username": "hungkiet244203",
                        "content": "[@jannatbushra524](/jannatbushra524) yeah but the profit it provides isnt\\n"
                    },
                    {
                        "username": "MatsRivel",
                        "content": "[@jannatbushra524](/jannatbushra524) Buy at 0, then you have to sell after zero, so the best sell price is 3. 3-0 = 3, 6-2=4"
                    },
                    {
                        "username": "ajjha7203",
                        "content": "6-2 = 4"
                    },
                    {
                        "username": "damajsam93",
                        "content": "6-2 ==> 4 "
                    },
                    {
                        "username": "Jagdeep4485",
                        "content": "6-2= 4"
                    },
                    {
                        "username": "jannatbushra524",
                        "content": "[@rajanhossainkhan](/rajanhossainkhan) isn\\'t \\'0\\' a buy_price ??...and its smallest too."
                    },
                    {
                        "username": "rajanhossainkhan",
                        "content": "Here are the steps - \\n\\n1. First buy out price is 3 and profit is set to 0. \\n2. Now loop through array from index 1, since index 0 (which is 3) is taken as minimum buy out price for now. \\n3. Now if price is 2, then set this as new buy out price, since its smaller. So our current buy out price is 2. \\n4. Now next price is 6. This is bigger, so sell with current buy out price 2. \\n5. Calculate max profit  = max(profit, ( current_price - buy_price) \\n6. In this case, max(0, 6-2) = 4\\n\\nHope this helps. "
                    },
                    {
                        "username": "Amit_Joe",
                        "content": "2 -6\\n"
                    },
                    {
                        "username": "hemantgautam505",
                        "content": "output is 4\\n"
                    },
                    {
                        "username": "Shashi3k",
                        "content": "2-6\\n"
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for February, Day 1.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  **📌 Do you want to learn the problem thoroughly?**\n  Read [**⭐  LeetCode Official Solution⭐**](https://leetcode.com/problems/best-time-to-buy-and-sell-stock/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 2 approaches in the official solution</summary>\n\n  \n**Approach 1:** Brute Force\n\n  \n**Approach 2:** One Pass\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# \\uD83D\\uDEA9Easy C++ O(N) Soln. [ FAANG\\uD83D\\uDE31 Interview Optimized code ]\\n\\nhttps://leetcode.com/problems/best-time-to-buy-and-sell-stock/solutions/2822579/easy-c-o-n-soln-faang-interview-optimized-code/\\n"
                    }
                ]
            },
            {
                "id": 1880567,
                "content": [
                    {
                        "username": "Serosidium",
                        "content": "I couldn\\'t find any good explanations here and only code, so I will do my best to explain how I solved it without providing code. I am sure there are other possible solutions, but this is how it worked for me.\\n\\nThe brute force method of a double for loop is not necessary here, and this problem is marked with dynamic programming because it requires the [Sliding Window technique](https://algorithm-visualizer.org/dynamic-programming/sliding-window).\\n\\nBased on the fact that we have to sell after we buy and we are trying to maximize profit, we can iterate through the prices and only need to consider two things:\\n1.) **Is this price cheaper than any other price I\\'ve seen before?** \\n2.) If I subtract current price by the cheapest price I\\'ve found, **does this yield a greater profit than what I\\'ve seen so far?**\\n\\n*A fun thing to note is if #1 is true, then #2 cannot be true as well so there isn\\'t a need to check*\\n\\nLet\\'s consider an example of [4,1,5,2,7]\\n- 4 is the cheapest price we see to start, and we can\\'t sell on the first day so maxProfit is 0\\n- 1 is now the cheapest price we\\'ve seen. Selling now would lose us money, so we can\\'t update maxProfit\\n- 5 is not cheaper than 1, but if we sell now we get a maxProfit of 4! Better save that for later\\n- 2 is not cheaper than 1 and if we sell, we only get a profit of 1, no need to do anything here\\n- 7 is not cheaper than 1, but if we sell here, we\\'ll increase maxProfit to 6, making this the best profit to return.\\n\\nHope this helps someone else!\\n"
                    },
                    {
                        "username": "Manidgyf_6",
                        "content": "Thank you bro"
                    },
                    {
                        "username": "lorentzimys",
                        "content": "Awesome solution, thanks!"
                    },
                    {
                        "username": "Khoa268",
                        "content": "thanks for sharing!"
                    },
                    {
                        "username": "omeh-a",
                        "content": "This is not a DP solution as described, it is greedy"
                    },
                    {
                        "username": "ankitk742",
                        "content": "Thanks bro for your help without code really appreciate "
                    },
                    {
                        "username": "245120733119",
                        "content": "Brilliant!! Thanks for sharing!!"
                    },
                    {
                        "username": "Aniket_sggs",
                        "content": "Initially, this seemed to be DP problem. but after reading this description it is clear that this is basic problem with greedy solution."
                    },
                    {
                        "username": "duffinson97",
                        "content": "Thank you for not posting code, I don\\'t understand the sliding window technique or how this applies to that. I google it and the image link to this problem doesn\\'t make a lot of sense to me. But this solution works thanks"
                    },
                    {
                        "username": "typranjal1",
                        "content": "Thank you!."
                    },
                    {
                        "username": "jakho100",
                        "content": "was stuck on it for hours, thanks for the simple explanation! "
                    },
                    {
                        "username": "zafeer_rangoonwala",
                        "content": "I was originally not able to solve it but after reading your thought process it was a cake walk! \\n\\nThanks! "
                    },
                    {
                        "username": "mohammed1212345",
                        "content": "thank for helping out"
                    },
                    {
                        "username": "dungtuanuet",
                        "content": "Exellent explaination!"
                    },
                    {
                        "username": "kcleland18",
                        "content": "This was a great explanation!! Thanks!"
                    },
                    {
                        "username": "as358",
                        "content": "Best Explanation ever !!!"
                    },
                    {
                        "username": "user6798sW",
                        "content": "AWESOME BREAKDOWN! Ty"
                    },
                    {
                        "username": "jaydeep-pro",
                        "content": "[@evoniuk](/evoniuk) exactly! "
                    },
                    {
                        "username": "akshaydusad",
                        "content": "okay this is genius and surprisingly easier to follow!"
                    },
                    {
                        "username": "evoniuk",
                        "content": "Thank you! This is a solution that\\'s so simple and obvious once you see it you kick yourself for not thinking of it yourself!"
                    },
                    {
                        "username": "ivantchev",
                        "content": "How would the original wording of the problem have to be modified so that the double loop solution _has_ to be used?"
                    },
                    {
                        "username": "ivantchev",
                        "content": "Very helpful, thank you! To add: the reason why using your point 1.) works as a valid check is because given the problem constraints, it will always yield a higher profit down the line regardless of future values.\\n\\nAnd point  2.) shows we don\\'t need a second loop.\\n\\nI wonder, can any concrete aspect of the problem  be used as a clue so that we can reach Serosidium\\'s solution  independently. "
                    },
                    {
                        "username": "VishnuKesav",
                        "content": "[@sharpsailor](/sharpsailor) our target is to get highest possible profit.\\nYou are focusing on buying for the lowest price alone. No matter how low the price is, buying on a last day will yield 0 profit.\\n"
                    },
                    {
                        "username": "kaushar",
                        "content": "[@tengxianrui](/tengxianrui) Thanks  !"
                    },
                    {
                        "username": "neelimag459",
                        "content": "Thank you so much for such good explanation. Happy coding."
                    },
                    {
                        "username": "Nbs-26",
                        "content": "Thank u brother. Your explanation is very clear and well defined."
                    },
                    {
                        "username": "Dabchinsky",
                        "content": "[@sharpsailor](/sharpsailor) if we buy on 2 and sell on 4, our profit would be 4 - 2 = 2. "
                    },
                    {
                        "username": "sharpsailor",
                        "content": "check for {2,4,1} ideally it should give 0 but leetcode gives 2..Help me figure out where am I getting it wrong\\n"
                    },
                    {
                        "username": "jackbb147",
                        "content": "that\\'s actually very smart... thanks"
                    },
                    {
                        "username": "chiahao1",
                        "content": "Thank you! Your technique worked for me."
                    },
                    {
                        "username": "Marre-86",
                        "content": "Man, you made my day! I spent two hours and wrote almost 100 hundred lines code that probably was soving it but had \"time limit exceeded\" with huge input. And after your explanation I rewrite it in freaking 7 lines and it made it right off the bat!"
                    },
                    {
                        "username": "m1ma087",
                        "content": "Best tip! Thanks!"
                    },
                    {
                        "username": "sasaalina1985",
                        "content": "was reading this and solved the problem first try! Very good explanation!!!"
                    },
                    {
                        "username": "Yash_6207",
                        "content": "This is what we call as Greedy ! Good Explanation\\n"
                    },
                    {
                        "username": "iosifpetrupuha",
                        "content": "[@fjod](/fjod) but it\\'s buy day that should be before then sellday"
                    },
                    {
                        "username": "iosifpetrupuha",
                        "content": "[@iosifpetrupuha](/iosifpetrupuha) daaamn there is no indentation in this comment section"
                    },
                    {
                        "username": "iosifpetrupuha",
                        "content": "so I didn\\'t know this was called sliding window or sumthin, but I am second year at CS university, i have some grasp of this kind of logic and I solved it this way:\\nclass Solution:\\n    def maxProfit(self, prices: List[int]) -> int:\\n        #you obviously must buy before you sell(can\\'t go back in time)\\n        GreatestProfit=0\\n        priceToBeat=prices[0]\\n        for i in range(len(prices)-1):#we can iterate through the whole list, otherwise we get out of bounds, so we iterate from the first to the penultimate (so the last comparation we do is between the penultimate and the last element) \\n            if prices[i]<prices[i+1]:#sure profit, possible greatest profit\\n                if prices[i]<=priceToBeat:\\n                    priceToBeat=prices[i]\\n                if GreatestProfit<=prices[i+1]-priceToBeat: #if the GreatestProfit we calculate is greater than the one we have already, we update the Greatest Profit, otherwise we do nothing\\n                    GreatestProfit=prices[i+1]-priceToBeat\\n        return GreatestProfit\\nis this a proper way to solve this kind of problems? (in terms of efficiency I think we\\'re in O(n) so it should be pretty good"
                    },
                    {
                        "username": "Rohit_8412",
                        "content": "Thanks, I was about to see the solution after 10 min I didn\\'t get an approach into my mind.\\nThen I saw your discussion and I solved the question myself \\uD83D\\uDE0E"
                    },
                    {
                        "username": "fjod",
                        "content": "your explanation does not include rule of sellDay must be after buyDay"
                    },
                    {
                        "username": "Hanagaki_Takimichy",
                        "content": "thanks for great explaination without any spoilers.\\ni will try my best for the code, thanks a lot ;)"
                    },
                    {
                        "username": "csrnontol",
                        "content": "Sounds good, but I think your tip fails for [2,9,3,4,5,1,7] (how you\\'d choose 2, 9) and [2,9,3,4,5,1,7,10] (how you\\'d choose 1, 10)."
                    },
                    {
                        "username": "rockmanex",
                        "content": "best explanations so far. Thankyou it\\'s help a lot"
                    },
                    {
                        "username": "ak67",
                        "content": "I think this problem should be catogarise as medium level problem\\n"
                    },
                    {
                        "username": "Sultan_Ul_Arfin",
                        "content": "[@chazwinter](/chazwinter) what is sliding window? I never heard it ..will you explain that please<3\\n "
                    },
                    {
                        "username": "chazwinter",
                        "content": "It doesn\\'t require DP though. You only think it\\'s harder than it is because you\\'re overthinking it. You can use sliding window and just keep track of the lowest price as you go."
                    },
                    {
                        "username": "rwatso",
                        "content": "[@lucky_nik77](/lucky_nik77) Because by its very nature DP is not a beginner / easy level topic."
                    },
                    {
                        "username": "Vectorido",
                        "content": "[@lucky_nik77](/lucky_nik77) This is not hard for simple lists. But all people here usually stuck at TimeLimit error. So algorithm should be another, at least medium level of complexity."
                    },
                    {
                        "username": "lucky_nik77",
                        "content": "But why? It is hard to think about a DP problem that would be easier than this."
                    },
                    {
                        "username": "tiwarimrutunjay",
                        "content": "agreed"
                    },
                    {
                        "username": "codernoob",
                        "content": "how to resolve the time exceeded issue? Mine fails at 203rd test case with a large array"
                    },
                    {
                        "username": "user4279js",
                        "content": "[@rajamandalofficial56](/rajamandalofficial56) I\\'m not a javascript expert, but probably doing prices.slice(index) is looping 0 -index eachtime ... so you have O(N\\n^2) soltuion overall"
                    },
                    {
                        "username": "Behnoosh",
                        "content": "[@htooak2014](/htooak2014) To me it was occurring when my code had an O(n^2) complexity. Resolving that (to O(n)) solved this problem. I start from the end of the array prices and dynamically find the max value from the end of the array until the current step backwards. This way, at the end of the for loop, we can find the max profit with only one single pass over all entries of the array."
                    },
                    {
                        "username": "eyastaifour",
                        "content": "[@htooak2014](/htooak2014) I am hitting a limit error as well and I believe that it is because I keep on querying max() of the window, but when I think of it the max is either on the first index of the window (as I descend), or somewhere else, in which case, it should be cached as it doesnt change... at least, that\\'s what i am thinking\\n"
                    },
                    {
                        "username": "PercyJia95",
                        "content": "[@rajamandalofficial56](/rajamandalofficial56) You need to reconsider your variable naming. They carry very few meanings."
                    },
                    {
                        "username": "knotri",
                        "content": "[@rajamandalofficial56](/rajamandalofficial56) since u iterate over N elements with prices.map, and for each elements u call Math.max(...prices.slice) u need approx additional 1/2N to find maximum. So O(n) = n^2"
                    },
                    {
                        "username": "rajamandalofficial56",
                        "content": " let max = 0;\\n\\n    prices.map((el,index) => {\\n      let tem =  Math.max(...prices.slice(index))\\n      if(el< tem){\\n         if(max< tem-el){\\n             max = tem-el\\n         }\\n      }\\n    })\\n    return max\\n\\nError : Time Limit Exceeded\\n\\nO(n) complexity\\nwhat\\'s wrong this approach? "
                    },
                    {
                        "username": "htooak2014",
                        "content": "me too. time limit error occurs. why? leetcode compiler error?"
                    },
                    {
                        "username": "drmolenhouse",
                        "content": "Same issue, using the LeetCode Official solution lmao. What am I paying $35/month for?"
                    },
                    {
                        "username": "user4387LF",
                        "content": "Because you may be using a brute force approach with two loops checking every combination which takes O(n2) time; Cause it exceeds time limit. Optimize your code. Think to solve it in one pass with one loop in linear time."
                    },
                    {
                        "username": "Sahil481",
                        "content": "Your code is not well optimised. It is not ran within the given time limit."
                    },
                    {
                        "username": "pstrait",
                        "content": "Are you doing it with more than one loop? If so, there\\'s a better solution that has O(n) time complexity"
                    },
                    {
                        "username": "leet_code_master",
                        "content": "prices = [2, 4, 1]\\n\\nOutput: 0\\nExpected: 2\\n\\nYou buy on day three but cannot sell because it is the last day. Should that not be zero?"
                    },
                    {
                        "username": "langhudson870",
                        "content": "You should buy on day 1 and sell on day 2"
                    },
                    {
                        "username": "almaas21",
                        "content": "[@user4391xh](/user4391xh) \\nthe output required is max profit through traversing  in the list, it could be adjacent too like in [2,4,1] max_profit here is 2 not 0"
                    },
                    {
                        "username": "ashish_bhosale848",
                        "content": "Yes , I am facing the same issue at case 154"
                    },
                    {
                        "username": "user4391xh",
                        "content": "According to the example 2 \\n(Input: prices = [7,6,4,3,1]\\nOutput: 0\\nExplanation: In this case, no transactions are done and the max profit = 0.)\\nin the task description, 0 should be returned so looks like tests expect incorrect value here.."
                    },
                    {
                        "username": "kaushit",
                        "content": "[@mp9508](/mp9508) I also done the same thing but if that solution is wrong then what approach should we think."
                    },
                    {
                        "username": "shubhamDhapola",
                        "content": "you buy on the first day and sell on the second"
                    },
                    {
                        "username": "sazuki",
                        "content": "[@mp9508](/mp9508) This happend to me too, because ahahah well, the first value that is taken is the min() so basically 1, but this is the last one because that will end in a 0 output. "
                    },
                    {
                        "username": "HarshitBansal122",
                        "content": "buy on first day and sell on second day makes profit 2 "
                    },
                    {
                        "username": "Dan_A_S",
                        "content": "[@mkv1892](/mkv1892) I don\\'t agree with that (except if the explanation of the problem is not correct). What I understood from the explanation is, you buy when the price is cheapest and sell on a later date when you can maximize profit (meaning the highest prize on a later date from the date of purchase). Going by that, you buy at 1 so the output should be zero and not the expected 2."
                    },
                    {
                        "username": "mkv1892",
                        "content": "No, Here you buy at day 1, Where the buy price is 2 and sell at day 2, Where the sell price is 4."
                    },
                    {
                        "username": "Byas_Yadav",
                        "content": "[@mp9508](/mp9508) you buy on day 1 and sell it on day 2 i.e. profit =sell-buy --> 4-2=2"
                    },
                    {
                        "username": "mp9508",
                        "content": "[@leet_code_master](/leet_code_master) happened the same to me . the approach i took is:\\nfind the minimum element and then maxi=mini then use a loop from the next index of the lowest mini element and then find maxi, then return the output.\\nhope this helps\\n"
                    },
                    {
                        "username": "VaishaliChauhan",
                        "content": "We need to maximize profit, you can buy at 2 and sell on 4, giving a profit of 2"
                    },
                    {
                        "username": "IbrahimJunior",
                        "content": "you have to maintain your profit in a variable and only change the variable if the new profit is greater than the previous one, so for this scenario, 2 is the former profit, 0 is the new one, it is not greater than 2 so you don\\'t change your profit."
                    },
                    {
                        "username": "Hanagaki_Takimichy",
                        "content": "buy = 2 and sell = 4 profit = 2\\ni am facing the same problem bro............."
                    },
                    {
                        "username": "MatsRivel",
                        "content": "[@leet_code_master](/leet_code_master) What I did was look at what the largest value after i is for each i, and what the smallest value is before each i. Then, for each i, i subtract smallest from largest. This is your optimal profit for buying before i and selling after i. Now you just find the largest number out of these, and you\\'re done."
                    },
                    {
                        "username": "leet_code_master",
                        "content": "[@MeriemA](/MeriemA) I see. Thank you :) How do you recommend I go about this? Because now the new code I make messes up the second test case."
                    },
                    {
                        "username": "MeriemA",
                        "content": "Actually,  the idea here is how you can make the maximum of profits. You don\\'t have to buy the stock when it\\'s at its lowest price.\\nHere you can buy the first day and sell the second day and still make a profit which is 2.\\n"
                    },
                    {
                        "username": "EXLsunshine",
                        "content": "Why is this problem tagged with \"Dynamic programming\"?"
                    },
                    {
                        "username": "princebillygk2",
                        "content": "[@aryan14decsingh](/aryan14decsingh) The problem can be solved in Dynamic way but the more efficient way is array traversal approach."
                    },
                    {
                        "username": "Mrinal2100",
                        "content": "It should be tagged as two pointer problem"
                    },
                    {
                        "username": "aryan14decsingh",
                        "content": "Because it is Dynamic  ( debatable ) \\nquestion apart , did you get any job by now ? you posted this on 2015 , if you are still alive let me know if you got any jobs and some tips aswell"
                    },
                    {
                        "username": "djslim",
                        "content": "[@sourov1407](/sourov1407)  tbh it\\'s classic greedy problem, interestingly in leetcode 75 they marked it as greedy"
                    },
                    {
                        "username": "sahle123",
                        "content": "[@AdityaBhate](/AdityaBhate) He/she was asking a question, not for a solution."
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# \\uD83D\\uDEA9Easy C++ O(N) Soln. [ FAANG\\uD83D\\uDE31 Interview Optimized code ]\\n\\nhttps://leetcode.com/problems/best-time-to-buy-and-sell-stock/solutions/2822579/easy-c-o-n-soln-faang-interview-optimized-code/\\n\\n"
                    },
                    {
                        "username": "sourov1407",
                        "content": "Because we can use kadene\\'s algorithm here and as it is widely regarded as dp algorithm so yeah this problem is tagged with dynamic programming"
                    },
                    {
                        "username": "casper07",
                        "content": "I am So dumb...."
                    },
                    {
                        "username": "ydumar",
                        "content": "same bruh"
                    },
                    {
                        "username": "savagesam343",
                        "content": "me too bro, me too..."
                    },
                    {
                        "username": "night07",
                        "content": "me too jit"
                    },
                    {
                        "username": "AlgoEngine",
                        "content": "Video visualizing an intuitive proof of the O(n) solution:\nhttps://youtube.com/watch?v=ioFPBdChabY"
                    },
                    {
                        "username": "astek14",
                        "content": "Thanks it\\'s awesome"
                    },
                    {
                        "username": "shilbabun491",
                        "content": "how to resolve the time exceeded issue? Mine fails at 200th test case with a large array"
                    },
                    {
                        "username": "akelux",
                        "content": "How to get max profit 4 from input [3,2,6,5,0,3]?"
                    },
                    {
                        "username": "jenil59",
                        "content": "buy at 2 and sell at 6"
                    },
                    {
                        "username": "Trinto_610",
                        "content": "damn bro 2013"
                    },
                    {
                        "username": "prasumitmishra",
                        "content": "3 (buy),  2 (buy) , 6 (sell), 5 (hold), 0 (hold), 3 (hold)\\n-3 -2 + (2*6)\\n= -5 + 12 = 7"
                    },
                    {
                        "username": "KayvanShah1",
                        "content": "by selling on 6 and buying on 0\\nwhich means short selling"
                    },
                    {
                        "username": "bhanureddy7",
                        "content": "2,6"
                    },
                    {
                        "username": "Hanagaki_Takimichy",
                        "content": "buy = 2 and sell = 6"
                    },
                    {
                        "username": "hungkiet244203",
                        "content": "[@jannatbushra524](/jannatbushra524) yeah but the profit it provides isnt\\n"
                    },
                    {
                        "username": "MatsRivel",
                        "content": "[@jannatbushra524](/jannatbushra524) Buy at 0, then you have to sell after zero, so the best sell price is 3. 3-0 = 3, 6-2=4"
                    },
                    {
                        "username": "ajjha7203",
                        "content": "6-2 = 4"
                    },
                    {
                        "username": "damajsam93",
                        "content": "6-2 ==> 4 "
                    },
                    {
                        "username": "Jagdeep4485",
                        "content": "6-2= 4"
                    },
                    {
                        "username": "jannatbushra524",
                        "content": "[@rajanhossainkhan](/rajanhossainkhan) isn\\'t \\'0\\' a buy_price ??...and its smallest too."
                    },
                    {
                        "username": "rajanhossainkhan",
                        "content": "Here are the steps - \\n\\n1. First buy out price is 3 and profit is set to 0. \\n2. Now loop through array from index 1, since index 0 (which is 3) is taken as minimum buy out price for now. \\n3. Now if price is 2, then set this as new buy out price, since its smaller. So our current buy out price is 2. \\n4. Now next price is 6. This is bigger, so sell with current buy out price 2. \\n5. Calculate max profit  = max(profit, ( current_price - buy_price) \\n6. In this case, max(0, 6-2) = 4\\n\\nHope this helps. "
                    },
                    {
                        "username": "Amit_Joe",
                        "content": "2 -6\\n"
                    },
                    {
                        "username": "hemantgautam505",
                        "content": "output is 4\\n"
                    },
                    {
                        "username": "Shashi3k",
                        "content": "2-6\\n"
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for February, Day 1.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  **📌 Do you want to learn the problem thoroughly?**\n  Read [**⭐  LeetCode Official Solution⭐**](https://leetcode.com/problems/best-time-to-buy-and-sell-stock/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 2 approaches in the official solution</summary>\n\n  \n**Approach 1:** Brute Force\n\n  \n**Approach 2:** One Pass\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# \\uD83D\\uDEA9Easy C++ O(N) Soln. [ FAANG\\uD83D\\uDE31 Interview Optimized code ]\\n\\nhttps://leetcode.com/problems/best-time-to-buy-and-sell-stock/solutions/2822579/easy-c-o-n-soln-faang-interview-optimized-code/\\n"
                    }
                ]
            },
            {
                "id": 1756186,
                "content": [
                    {
                        "username": "Serosidium",
                        "content": "I couldn\\'t find any good explanations here and only code, so I will do my best to explain how I solved it without providing code. I am sure there are other possible solutions, but this is how it worked for me.\\n\\nThe brute force method of a double for loop is not necessary here, and this problem is marked with dynamic programming because it requires the [Sliding Window technique](https://algorithm-visualizer.org/dynamic-programming/sliding-window).\\n\\nBased on the fact that we have to sell after we buy and we are trying to maximize profit, we can iterate through the prices and only need to consider two things:\\n1.) **Is this price cheaper than any other price I\\'ve seen before?** \\n2.) If I subtract current price by the cheapest price I\\'ve found, **does this yield a greater profit than what I\\'ve seen so far?**\\n\\n*A fun thing to note is if #1 is true, then #2 cannot be true as well so there isn\\'t a need to check*\\n\\nLet\\'s consider an example of [4,1,5,2,7]\\n- 4 is the cheapest price we see to start, and we can\\'t sell on the first day so maxProfit is 0\\n- 1 is now the cheapest price we\\'ve seen. Selling now would lose us money, so we can\\'t update maxProfit\\n- 5 is not cheaper than 1, but if we sell now we get a maxProfit of 4! Better save that for later\\n- 2 is not cheaper than 1 and if we sell, we only get a profit of 1, no need to do anything here\\n- 7 is not cheaper than 1, but if we sell here, we\\'ll increase maxProfit to 6, making this the best profit to return.\\n\\nHope this helps someone else!\\n"
                    },
                    {
                        "username": "Manidgyf_6",
                        "content": "Thank you bro"
                    },
                    {
                        "username": "lorentzimys",
                        "content": "Awesome solution, thanks!"
                    },
                    {
                        "username": "Khoa268",
                        "content": "thanks for sharing!"
                    },
                    {
                        "username": "omeh-a",
                        "content": "This is not a DP solution as described, it is greedy"
                    },
                    {
                        "username": "ankitk742",
                        "content": "Thanks bro for your help without code really appreciate "
                    },
                    {
                        "username": "245120733119",
                        "content": "Brilliant!! Thanks for sharing!!"
                    },
                    {
                        "username": "Aniket_sggs",
                        "content": "Initially, this seemed to be DP problem. but after reading this description it is clear that this is basic problem with greedy solution."
                    },
                    {
                        "username": "duffinson97",
                        "content": "Thank you for not posting code, I don\\'t understand the sliding window technique or how this applies to that. I google it and the image link to this problem doesn\\'t make a lot of sense to me. But this solution works thanks"
                    },
                    {
                        "username": "typranjal1",
                        "content": "Thank you!."
                    },
                    {
                        "username": "jakho100",
                        "content": "was stuck on it for hours, thanks for the simple explanation! "
                    },
                    {
                        "username": "zafeer_rangoonwala",
                        "content": "I was originally not able to solve it but after reading your thought process it was a cake walk! \\n\\nThanks! "
                    },
                    {
                        "username": "mohammed1212345",
                        "content": "thank for helping out"
                    },
                    {
                        "username": "dungtuanuet",
                        "content": "Exellent explaination!"
                    },
                    {
                        "username": "kcleland18",
                        "content": "This was a great explanation!! Thanks!"
                    },
                    {
                        "username": "as358",
                        "content": "Best Explanation ever !!!"
                    },
                    {
                        "username": "user6798sW",
                        "content": "AWESOME BREAKDOWN! Ty"
                    },
                    {
                        "username": "jaydeep-pro",
                        "content": "[@evoniuk](/evoniuk) exactly! "
                    },
                    {
                        "username": "akshaydusad",
                        "content": "okay this is genius and surprisingly easier to follow!"
                    },
                    {
                        "username": "evoniuk",
                        "content": "Thank you! This is a solution that\\'s so simple and obvious once you see it you kick yourself for not thinking of it yourself!"
                    },
                    {
                        "username": "ivantchev",
                        "content": "How would the original wording of the problem have to be modified so that the double loop solution _has_ to be used?"
                    },
                    {
                        "username": "ivantchev",
                        "content": "Very helpful, thank you! To add: the reason why using your point 1.) works as a valid check is because given the problem constraints, it will always yield a higher profit down the line regardless of future values.\\n\\nAnd point  2.) shows we don\\'t need a second loop.\\n\\nI wonder, can any concrete aspect of the problem  be used as a clue so that we can reach Serosidium\\'s solution  independently. "
                    },
                    {
                        "username": "VishnuKesav",
                        "content": "[@sharpsailor](/sharpsailor) our target is to get highest possible profit.\\nYou are focusing on buying for the lowest price alone. No matter how low the price is, buying on a last day will yield 0 profit.\\n"
                    },
                    {
                        "username": "kaushar",
                        "content": "[@tengxianrui](/tengxianrui) Thanks  !"
                    },
                    {
                        "username": "neelimag459",
                        "content": "Thank you so much for such good explanation. Happy coding."
                    },
                    {
                        "username": "Nbs-26",
                        "content": "Thank u brother. Your explanation is very clear and well defined."
                    },
                    {
                        "username": "Dabchinsky",
                        "content": "[@sharpsailor](/sharpsailor) if we buy on 2 and sell on 4, our profit would be 4 - 2 = 2. "
                    },
                    {
                        "username": "sharpsailor",
                        "content": "check for {2,4,1} ideally it should give 0 but leetcode gives 2..Help me figure out where am I getting it wrong\\n"
                    },
                    {
                        "username": "jackbb147",
                        "content": "that\\'s actually very smart... thanks"
                    },
                    {
                        "username": "chiahao1",
                        "content": "Thank you! Your technique worked for me."
                    },
                    {
                        "username": "Marre-86",
                        "content": "Man, you made my day! I spent two hours and wrote almost 100 hundred lines code that probably was soving it but had \"time limit exceeded\" with huge input. And after your explanation I rewrite it in freaking 7 lines and it made it right off the bat!"
                    },
                    {
                        "username": "m1ma087",
                        "content": "Best tip! Thanks!"
                    },
                    {
                        "username": "sasaalina1985",
                        "content": "was reading this and solved the problem first try! Very good explanation!!!"
                    },
                    {
                        "username": "Yash_6207",
                        "content": "This is what we call as Greedy ! Good Explanation\\n"
                    },
                    {
                        "username": "iosifpetrupuha",
                        "content": "[@fjod](/fjod) but it\\'s buy day that should be before then sellday"
                    },
                    {
                        "username": "iosifpetrupuha",
                        "content": "[@iosifpetrupuha](/iosifpetrupuha) daaamn there is no indentation in this comment section"
                    },
                    {
                        "username": "iosifpetrupuha",
                        "content": "so I didn\\'t know this was called sliding window or sumthin, but I am second year at CS university, i have some grasp of this kind of logic and I solved it this way:\\nclass Solution:\\n    def maxProfit(self, prices: List[int]) -> int:\\n        #you obviously must buy before you sell(can\\'t go back in time)\\n        GreatestProfit=0\\n        priceToBeat=prices[0]\\n        for i in range(len(prices)-1):#we can iterate through the whole list, otherwise we get out of bounds, so we iterate from the first to the penultimate (so the last comparation we do is between the penultimate and the last element) \\n            if prices[i]<prices[i+1]:#sure profit, possible greatest profit\\n                if prices[i]<=priceToBeat:\\n                    priceToBeat=prices[i]\\n                if GreatestProfit<=prices[i+1]-priceToBeat: #if the GreatestProfit we calculate is greater than the one we have already, we update the Greatest Profit, otherwise we do nothing\\n                    GreatestProfit=prices[i+1]-priceToBeat\\n        return GreatestProfit\\nis this a proper way to solve this kind of problems? (in terms of efficiency I think we\\'re in O(n) so it should be pretty good"
                    },
                    {
                        "username": "Rohit_8412",
                        "content": "Thanks, I was about to see the solution after 10 min I didn\\'t get an approach into my mind.\\nThen I saw your discussion and I solved the question myself \\uD83D\\uDE0E"
                    },
                    {
                        "username": "fjod",
                        "content": "your explanation does not include rule of sellDay must be after buyDay"
                    },
                    {
                        "username": "Hanagaki_Takimichy",
                        "content": "thanks for great explaination without any spoilers.\\ni will try my best for the code, thanks a lot ;)"
                    },
                    {
                        "username": "csrnontol",
                        "content": "Sounds good, but I think your tip fails for [2,9,3,4,5,1,7] (how you\\'d choose 2, 9) and [2,9,3,4,5,1,7,10] (how you\\'d choose 1, 10)."
                    },
                    {
                        "username": "rockmanex",
                        "content": "best explanations so far. Thankyou it\\'s help a lot"
                    },
                    {
                        "username": "ak67",
                        "content": "I think this problem should be catogarise as medium level problem\\n"
                    },
                    {
                        "username": "Sultan_Ul_Arfin",
                        "content": "[@chazwinter](/chazwinter) what is sliding window? I never heard it ..will you explain that please<3\\n "
                    },
                    {
                        "username": "chazwinter",
                        "content": "It doesn\\'t require DP though. You only think it\\'s harder than it is because you\\'re overthinking it. You can use sliding window and just keep track of the lowest price as you go."
                    },
                    {
                        "username": "rwatso",
                        "content": "[@lucky_nik77](/lucky_nik77) Because by its very nature DP is not a beginner / easy level topic."
                    },
                    {
                        "username": "Vectorido",
                        "content": "[@lucky_nik77](/lucky_nik77) This is not hard for simple lists. But all people here usually stuck at TimeLimit error. So algorithm should be another, at least medium level of complexity."
                    },
                    {
                        "username": "lucky_nik77",
                        "content": "But why? It is hard to think about a DP problem that would be easier than this."
                    },
                    {
                        "username": "tiwarimrutunjay",
                        "content": "agreed"
                    },
                    {
                        "username": "codernoob",
                        "content": "how to resolve the time exceeded issue? Mine fails at 203rd test case with a large array"
                    },
                    {
                        "username": "user4279js",
                        "content": "[@rajamandalofficial56](/rajamandalofficial56) I\\'m not a javascript expert, but probably doing prices.slice(index) is looping 0 -index eachtime ... so you have O(N\\n^2) soltuion overall"
                    },
                    {
                        "username": "Behnoosh",
                        "content": "[@htooak2014](/htooak2014) To me it was occurring when my code had an O(n^2) complexity. Resolving that (to O(n)) solved this problem. I start from the end of the array prices and dynamically find the max value from the end of the array until the current step backwards. This way, at the end of the for loop, we can find the max profit with only one single pass over all entries of the array."
                    },
                    {
                        "username": "eyastaifour",
                        "content": "[@htooak2014](/htooak2014) I am hitting a limit error as well and I believe that it is because I keep on querying max() of the window, but when I think of it the max is either on the first index of the window (as I descend), or somewhere else, in which case, it should be cached as it doesnt change... at least, that\\'s what i am thinking\\n"
                    },
                    {
                        "username": "PercyJia95",
                        "content": "[@rajamandalofficial56](/rajamandalofficial56) You need to reconsider your variable naming. They carry very few meanings."
                    },
                    {
                        "username": "knotri",
                        "content": "[@rajamandalofficial56](/rajamandalofficial56) since u iterate over N elements with prices.map, and for each elements u call Math.max(...prices.slice) u need approx additional 1/2N to find maximum. So O(n) = n^2"
                    },
                    {
                        "username": "rajamandalofficial56",
                        "content": " let max = 0;\\n\\n    prices.map((el,index) => {\\n      let tem =  Math.max(...prices.slice(index))\\n      if(el< tem){\\n         if(max< tem-el){\\n             max = tem-el\\n         }\\n      }\\n    })\\n    return max\\n\\nError : Time Limit Exceeded\\n\\nO(n) complexity\\nwhat\\'s wrong this approach? "
                    },
                    {
                        "username": "htooak2014",
                        "content": "me too. time limit error occurs. why? leetcode compiler error?"
                    },
                    {
                        "username": "drmolenhouse",
                        "content": "Same issue, using the LeetCode Official solution lmao. What am I paying $35/month for?"
                    },
                    {
                        "username": "user4387LF",
                        "content": "Because you may be using a brute force approach with two loops checking every combination which takes O(n2) time; Cause it exceeds time limit. Optimize your code. Think to solve it in one pass with one loop in linear time."
                    },
                    {
                        "username": "Sahil481",
                        "content": "Your code is not well optimised. It is not ran within the given time limit."
                    },
                    {
                        "username": "pstrait",
                        "content": "Are you doing it with more than one loop? If so, there\\'s a better solution that has O(n) time complexity"
                    },
                    {
                        "username": "leet_code_master",
                        "content": "prices = [2, 4, 1]\\n\\nOutput: 0\\nExpected: 2\\n\\nYou buy on day three but cannot sell because it is the last day. Should that not be zero?"
                    },
                    {
                        "username": "langhudson870",
                        "content": "You should buy on day 1 and sell on day 2"
                    },
                    {
                        "username": "almaas21",
                        "content": "[@user4391xh](/user4391xh) \\nthe output required is max profit through traversing  in the list, it could be adjacent too like in [2,4,1] max_profit here is 2 not 0"
                    },
                    {
                        "username": "ashish_bhosale848",
                        "content": "Yes , I am facing the same issue at case 154"
                    },
                    {
                        "username": "user4391xh",
                        "content": "According to the example 2 \\n(Input: prices = [7,6,4,3,1]\\nOutput: 0\\nExplanation: In this case, no transactions are done and the max profit = 0.)\\nin the task description, 0 should be returned so looks like tests expect incorrect value here.."
                    },
                    {
                        "username": "kaushit",
                        "content": "[@mp9508](/mp9508) I also done the same thing but if that solution is wrong then what approach should we think."
                    },
                    {
                        "username": "shubhamDhapola",
                        "content": "you buy on the first day and sell on the second"
                    },
                    {
                        "username": "sazuki",
                        "content": "[@mp9508](/mp9508) This happend to me too, because ahahah well, the first value that is taken is the min() so basically 1, but this is the last one because that will end in a 0 output. "
                    },
                    {
                        "username": "HarshitBansal122",
                        "content": "buy on first day and sell on second day makes profit 2 "
                    },
                    {
                        "username": "Dan_A_S",
                        "content": "[@mkv1892](/mkv1892) I don\\'t agree with that (except if the explanation of the problem is not correct). What I understood from the explanation is, you buy when the price is cheapest and sell on a later date when you can maximize profit (meaning the highest prize on a later date from the date of purchase). Going by that, you buy at 1 so the output should be zero and not the expected 2."
                    },
                    {
                        "username": "mkv1892",
                        "content": "No, Here you buy at day 1, Where the buy price is 2 and sell at day 2, Where the sell price is 4."
                    },
                    {
                        "username": "Byas_Yadav",
                        "content": "[@mp9508](/mp9508) you buy on day 1 and sell it on day 2 i.e. profit =sell-buy --> 4-2=2"
                    },
                    {
                        "username": "mp9508",
                        "content": "[@leet_code_master](/leet_code_master) happened the same to me . the approach i took is:\\nfind the minimum element and then maxi=mini then use a loop from the next index of the lowest mini element and then find maxi, then return the output.\\nhope this helps\\n"
                    },
                    {
                        "username": "VaishaliChauhan",
                        "content": "We need to maximize profit, you can buy at 2 and sell on 4, giving a profit of 2"
                    },
                    {
                        "username": "IbrahimJunior",
                        "content": "you have to maintain your profit in a variable and only change the variable if the new profit is greater than the previous one, so for this scenario, 2 is the former profit, 0 is the new one, it is not greater than 2 so you don\\'t change your profit."
                    },
                    {
                        "username": "Hanagaki_Takimichy",
                        "content": "buy = 2 and sell = 4 profit = 2\\ni am facing the same problem bro............."
                    },
                    {
                        "username": "MatsRivel",
                        "content": "[@leet_code_master](/leet_code_master) What I did was look at what the largest value after i is for each i, and what the smallest value is before each i. Then, for each i, i subtract smallest from largest. This is your optimal profit for buying before i and selling after i. Now you just find the largest number out of these, and you\\'re done."
                    },
                    {
                        "username": "leet_code_master",
                        "content": "[@MeriemA](/MeriemA) I see. Thank you :) How do you recommend I go about this? Because now the new code I make messes up the second test case."
                    },
                    {
                        "username": "MeriemA",
                        "content": "Actually,  the idea here is how you can make the maximum of profits. You don\\'t have to buy the stock when it\\'s at its lowest price.\\nHere you can buy the first day and sell the second day and still make a profit which is 2.\\n"
                    },
                    {
                        "username": "EXLsunshine",
                        "content": "Why is this problem tagged with \"Dynamic programming\"?"
                    },
                    {
                        "username": "princebillygk2",
                        "content": "[@aryan14decsingh](/aryan14decsingh) The problem can be solved in Dynamic way but the more efficient way is array traversal approach."
                    },
                    {
                        "username": "Mrinal2100",
                        "content": "It should be tagged as two pointer problem"
                    },
                    {
                        "username": "aryan14decsingh",
                        "content": "Because it is Dynamic  ( debatable ) \\nquestion apart , did you get any job by now ? you posted this on 2015 , if you are still alive let me know if you got any jobs and some tips aswell"
                    },
                    {
                        "username": "djslim",
                        "content": "[@sourov1407](/sourov1407)  tbh it\\'s classic greedy problem, interestingly in leetcode 75 they marked it as greedy"
                    },
                    {
                        "username": "sahle123",
                        "content": "[@AdityaBhate](/AdityaBhate) He/she was asking a question, not for a solution."
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# \\uD83D\\uDEA9Easy C++ O(N) Soln. [ FAANG\\uD83D\\uDE31 Interview Optimized code ]\\n\\nhttps://leetcode.com/problems/best-time-to-buy-and-sell-stock/solutions/2822579/easy-c-o-n-soln-faang-interview-optimized-code/\\n\\n"
                    },
                    {
                        "username": "sourov1407",
                        "content": "Because we can use kadene\\'s algorithm here and as it is widely regarded as dp algorithm so yeah this problem is tagged with dynamic programming"
                    },
                    {
                        "username": "casper07",
                        "content": "I am So dumb...."
                    },
                    {
                        "username": "ydumar",
                        "content": "same bruh"
                    },
                    {
                        "username": "savagesam343",
                        "content": "me too bro, me too..."
                    },
                    {
                        "username": "night07",
                        "content": "me too jit"
                    },
                    {
                        "username": "AlgoEngine",
                        "content": "Video visualizing an intuitive proof of the O(n) solution:\nhttps://youtube.com/watch?v=ioFPBdChabY"
                    },
                    {
                        "username": "astek14",
                        "content": "Thanks it\\'s awesome"
                    },
                    {
                        "username": "shilbabun491",
                        "content": "how to resolve the time exceeded issue? Mine fails at 200th test case with a large array"
                    },
                    {
                        "username": "akelux",
                        "content": "How to get max profit 4 from input [3,2,6,5,0,3]?"
                    },
                    {
                        "username": "jenil59",
                        "content": "buy at 2 and sell at 6"
                    },
                    {
                        "username": "Trinto_610",
                        "content": "damn bro 2013"
                    },
                    {
                        "username": "prasumitmishra",
                        "content": "3 (buy),  2 (buy) , 6 (sell), 5 (hold), 0 (hold), 3 (hold)\\n-3 -2 + (2*6)\\n= -5 + 12 = 7"
                    },
                    {
                        "username": "KayvanShah1",
                        "content": "by selling on 6 and buying on 0\\nwhich means short selling"
                    },
                    {
                        "username": "bhanureddy7",
                        "content": "2,6"
                    },
                    {
                        "username": "Hanagaki_Takimichy",
                        "content": "buy = 2 and sell = 6"
                    },
                    {
                        "username": "hungkiet244203",
                        "content": "[@jannatbushra524](/jannatbushra524) yeah but the profit it provides isnt\\n"
                    },
                    {
                        "username": "MatsRivel",
                        "content": "[@jannatbushra524](/jannatbushra524) Buy at 0, then you have to sell after zero, so the best sell price is 3. 3-0 = 3, 6-2=4"
                    },
                    {
                        "username": "ajjha7203",
                        "content": "6-2 = 4"
                    },
                    {
                        "username": "damajsam93",
                        "content": "6-2 ==> 4 "
                    },
                    {
                        "username": "Jagdeep4485",
                        "content": "6-2= 4"
                    },
                    {
                        "username": "jannatbushra524",
                        "content": "[@rajanhossainkhan](/rajanhossainkhan) isn\\'t \\'0\\' a buy_price ??...and its smallest too."
                    },
                    {
                        "username": "rajanhossainkhan",
                        "content": "Here are the steps - \\n\\n1. First buy out price is 3 and profit is set to 0. \\n2. Now loop through array from index 1, since index 0 (which is 3) is taken as minimum buy out price for now. \\n3. Now if price is 2, then set this as new buy out price, since its smaller. So our current buy out price is 2. \\n4. Now next price is 6. This is bigger, so sell with current buy out price 2. \\n5. Calculate max profit  = max(profit, ( current_price - buy_price) \\n6. In this case, max(0, 6-2) = 4\\n\\nHope this helps. "
                    },
                    {
                        "username": "Amit_Joe",
                        "content": "2 -6\\n"
                    },
                    {
                        "username": "hemantgautam505",
                        "content": "output is 4\\n"
                    },
                    {
                        "username": "Shashi3k",
                        "content": "2-6\\n"
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for February, Day 1.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  **📌 Do you want to learn the problem thoroughly?**\n  Read [**⭐  LeetCode Official Solution⭐**](https://leetcode.com/problems/best-time-to-buy-and-sell-stock/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 2 approaches in the official solution</summary>\n\n  \n**Approach 1:** Brute Force\n\n  \n**Approach 2:** One Pass\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# \\uD83D\\uDEA9Easy C++ O(N) Soln. [ FAANG\\uD83D\\uDE31 Interview Optimized code ]\\n\\nhttps://leetcode.com/problems/best-time-to-buy-and-sell-stock/solutions/2822579/easy-c-o-n-soln-faang-interview-optimized-code/\\n"
                    }
                ]
            },
            {
                "id": 1566236,
                "content": [
                    {
                        "username": "Serosidium",
                        "content": "I couldn\\'t find any good explanations here and only code, so I will do my best to explain how I solved it without providing code. I am sure there are other possible solutions, but this is how it worked for me.\\n\\nThe brute force method of a double for loop is not necessary here, and this problem is marked with dynamic programming because it requires the [Sliding Window technique](https://algorithm-visualizer.org/dynamic-programming/sliding-window).\\n\\nBased on the fact that we have to sell after we buy and we are trying to maximize profit, we can iterate through the prices and only need to consider two things:\\n1.) **Is this price cheaper than any other price I\\'ve seen before?** \\n2.) If I subtract current price by the cheapest price I\\'ve found, **does this yield a greater profit than what I\\'ve seen so far?**\\n\\n*A fun thing to note is if #1 is true, then #2 cannot be true as well so there isn\\'t a need to check*\\n\\nLet\\'s consider an example of [4,1,5,2,7]\\n- 4 is the cheapest price we see to start, and we can\\'t sell on the first day so maxProfit is 0\\n- 1 is now the cheapest price we\\'ve seen. Selling now would lose us money, so we can\\'t update maxProfit\\n- 5 is not cheaper than 1, but if we sell now we get a maxProfit of 4! Better save that for later\\n- 2 is not cheaper than 1 and if we sell, we only get a profit of 1, no need to do anything here\\n- 7 is not cheaper than 1, but if we sell here, we\\'ll increase maxProfit to 6, making this the best profit to return.\\n\\nHope this helps someone else!\\n"
                    },
                    {
                        "username": "Manidgyf_6",
                        "content": "Thank you bro"
                    },
                    {
                        "username": "lorentzimys",
                        "content": "Awesome solution, thanks!"
                    },
                    {
                        "username": "Khoa268",
                        "content": "thanks for sharing!"
                    },
                    {
                        "username": "omeh-a",
                        "content": "This is not a DP solution as described, it is greedy"
                    },
                    {
                        "username": "ankitk742",
                        "content": "Thanks bro for your help without code really appreciate "
                    },
                    {
                        "username": "245120733119",
                        "content": "Brilliant!! Thanks for sharing!!"
                    },
                    {
                        "username": "Aniket_sggs",
                        "content": "Initially, this seemed to be DP problem. but after reading this description it is clear that this is basic problem with greedy solution."
                    },
                    {
                        "username": "duffinson97",
                        "content": "Thank you for not posting code, I don\\'t understand the sliding window technique or how this applies to that. I google it and the image link to this problem doesn\\'t make a lot of sense to me. But this solution works thanks"
                    },
                    {
                        "username": "typranjal1",
                        "content": "Thank you!."
                    },
                    {
                        "username": "jakho100",
                        "content": "was stuck on it for hours, thanks for the simple explanation! "
                    },
                    {
                        "username": "zafeer_rangoonwala",
                        "content": "I was originally not able to solve it but after reading your thought process it was a cake walk! \\n\\nThanks! "
                    },
                    {
                        "username": "mohammed1212345",
                        "content": "thank for helping out"
                    },
                    {
                        "username": "dungtuanuet",
                        "content": "Exellent explaination!"
                    },
                    {
                        "username": "kcleland18",
                        "content": "This was a great explanation!! Thanks!"
                    },
                    {
                        "username": "as358",
                        "content": "Best Explanation ever !!!"
                    },
                    {
                        "username": "user6798sW",
                        "content": "AWESOME BREAKDOWN! Ty"
                    },
                    {
                        "username": "jaydeep-pro",
                        "content": "[@evoniuk](/evoniuk) exactly! "
                    },
                    {
                        "username": "akshaydusad",
                        "content": "okay this is genius and surprisingly easier to follow!"
                    },
                    {
                        "username": "evoniuk",
                        "content": "Thank you! This is a solution that\\'s so simple and obvious once you see it you kick yourself for not thinking of it yourself!"
                    },
                    {
                        "username": "ivantchev",
                        "content": "How would the original wording of the problem have to be modified so that the double loop solution _has_ to be used?"
                    },
                    {
                        "username": "ivantchev",
                        "content": "Very helpful, thank you! To add: the reason why using your point 1.) works as a valid check is because given the problem constraints, it will always yield a higher profit down the line regardless of future values.\\n\\nAnd point  2.) shows we don\\'t need a second loop.\\n\\nI wonder, can any concrete aspect of the problem  be used as a clue so that we can reach Serosidium\\'s solution  independently. "
                    },
                    {
                        "username": "VishnuKesav",
                        "content": "[@sharpsailor](/sharpsailor) our target is to get highest possible profit.\\nYou are focusing on buying for the lowest price alone. No matter how low the price is, buying on a last day will yield 0 profit.\\n"
                    },
                    {
                        "username": "kaushar",
                        "content": "[@tengxianrui](/tengxianrui) Thanks  !"
                    },
                    {
                        "username": "neelimag459",
                        "content": "Thank you so much for such good explanation. Happy coding."
                    },
                    {
                        "username": "Nbs-26",
                        "content": "Thank u brother. Your explanation is very clear and well defined."
                    },
                    {
                        "username": "Dabchinsky",
                        "content": "[@sharpsailor](/sharpsailor) if we buy on 2 and sell on 4, our profit would be 4 - 2 = 2. "
                    },
                    {
                        "username": "sharpsailor",
                        "content": "check for {2,4,1} ideally it should give 0 but leetcode gives 2..Help me figure out where am I getting it wrong\\n"
                    },
                    {
                        "username": "jackbb147",
                        "content": "that\\'s actually very smart... thanks"
                    },
                    {
                        "username": "chiahao1",
                        "content": "Thank you! Your technique worked for me."
                    },
                    {
                        "username": "Marre-86",
                        "content": "Man, you made my day! I spent two hours and wrote almost 100 hundred lines code that probably was soving it but had \"time limit exceeded\" with huge input. And after your explanation I rewrite it in freaking 7 lines and it made it right off the bat!"
                    },
                    {
                        "username": "m1ma087",
                        "content": "Best tip! Thanks!"
                    },
                    {
                        "username": "sasaalina1985",
                        "content": "was reading this and solved the problem first try! Very good explanation!!!"
                    },
                    {
                        "username": "Yash_6207",
                        "content": "This is what we call as Greedy ! Good Explanation\\n"
                    },
                    {
                        "username": "iosifpetrupuha",
                        "content": "[@fjod](/fjod) but it\\'s buy day that should be before then sellday"
                    },
                    {
                        "username": "iosifpetrupuha",
                        "content": "[@iosifpetrupuha](/iosifpetrupuha) daaamn there is no indentation in this comment section"
                    },
                    {
                        "username": "iosifpetrupuha",
                        "content": "so I didn\\'t know this was called sliding window or sumthin, but I am second year at CS university, i have some grasp of this kind of logic and I solved it this way:\\nclass Solution:\\n    def maxProfit(self, prices: List[int]) -> int:\\n        #you obviously must buy before you sell(can\\'t go back in time)\\n        GreatestProfit=0\\n        priceToBeat=prices[0]\\n        for i in range(len(prices)-1):#we can iterate through the whole list, otherwise we get out of bounds, so we iterate from the first to the penultimate (so the last comparation we do is between the penultimate and the last element) \\n            if prices[i]<prices[i+1]:#sure profit, possible greatest profit\\n                if prices[i]<=priceToBeat:\\n                    priceToBeat=prices[i]\\n                if GreatestProfit<=prices[i+1]-priceToBeat: #if the GreatestProfit we calculate is greater than the one we have already, we update the Greatest Profit, otherwise we do nothing\\n                    GreatestProfit=prices[i+1]-priceToBeat\\n        return GreatestProfit\\nis this a proper way to solve this kind of problems? (in terms of efficiency I think we\\'re in O(n) so it should be pretty good"
                    },
                    {
                        "username": "Rohit_8412",
                        "content": "Thanks, I was about to see the solution after 10 min I didn\\'t get an approach into my mind.\\nThen I saw your discussion and I solved the question myself \\uD83D\\uDE0E"
                    },
                    {
                        "username": "fjod",
                        "content": "your explanation does not include rule of sellDay must be after buyDay"
                    },
                    {
                        "username": "Hanagaki_Takimichy",
                        "content": "thanks for great explaination without any spoilers.\\ni will try my best for the code, thanks a lot ;)"
                    },
                    {
                        "username": "csrnontol",
                        "content": "Sounds good, but I think your tip fails for [2,9,3,4,5,1,7] (how you\\'d choose 2, 9) and [2,9,3,4,5,1,7,10] (how you\\'d choose 1, 10)."
                    },
                    {
                        "username": "rockmanex",
                        "content": "best explanations so far. Thankyou it\\'s help a lot"
                    },
                    {
                        "username": "ak67",
                        "content": "I think this problem should be catogarise as medium level problem\\n"
                    },
                    {
                        "username": "Sultan_Ul_Arfin",
                        "content": "[@chazwinter](/chazwinter) what is sliding window? I never heard it ..will you explain that please<3\\n "
                    },
                    {
                        "username": "chazwinter",
                        "content": "It doesn\\'t require DP though. You only think it\\'s harder than it is because you\\'re overthinking it. You can use sliding window and just keep track of the lowest price as you go."
                    },
                    {
                        "username": "rwatso",
                        "content": "[@lucky_nik77](/lucky_nik77) Because by its very nature DP is not a beginner / easy level topic."
                    },
                    {
                        "username": "Vectorido",
                        "content": "[@lucky_nik77](/lucky_nik77) This is not hard for simple lists. But all people here usually stuck at TimeLimit error. So algorithm should be another, at least medium level of complexity."
                    },
                    {
                        "username": "lucky_nik77",
                        "content": "But why? It is hard to think about a DP problem that would be easier than this."
                    },
                    {
                        "username": "tiwarimrutunjay",
                        "content": "agreed"
                    },
                    {
                        "username": "codernoob",
                        "content": "how to resolve the time exceeded issue? Mine fails at 203rd test case with a large array"
                    },
                    {
                        "username": "user4279js",
                        "content": "[@rajamandalofficial56](/rajamandalofficial56) I\\'m not a javascript expert, but probably doing prices.slice(index) is looping 0 -index eachtime ... so you have O(N\\n^2) soltuion overall"
                    },
                    {
                        "username": "Behnoosh",
                        "content": "[@htooak2014](/htooak2014) To me it was occurring when my code had an O(n^2) complexity. Resolving that (to O(n)) solved this problem. I start from the end of the array prices and dynamically find the max value from the end of the array until the current step backwards. This way, at the end of the for loop, we can find the max profit with only one single pass over all entries of the array."
                    },
                    {
                        "username": "eyastaifour",
                        "content": "[@htooak2014](/htooak2014) I am hitting a limit error as well and I believe that it is because I keep on querying max() of the window, but when I think of it the max is either on the first index of the window (as I descend), or somewhere else, in which case, it should be cached as it doesnt change... at least, that\\'s what i am thinking\\n"
                    },
                    {
                        "username": "PercyJia95",
                        "content": "[@rajamandalofficial56](/rajamandalofficial56) You need to reconsider your variable naming. They carry very few meanings."
                    },
                    {
                        "username": "knotri",
                        "content": "[@rajamandalofficial56](/rajamandalofficial56) since u iterate over N elements with prices.map, and for each elements u call Math.max(...prices.slice) u need approx additional 1/2N to find maximum. So O(n) = n^2"
                    },
                    {
                        "username": "rajamandalofficial56",
                        "content": " let max = 0;\\n\\n    prices.map((el,index) => {\\n      let tem =  Math.max(...prices.slice(index))\\n      if(el< tem){\\n         if(max< tem-el){\\n             max = tem-el\\n         }\\n      }\\n    })\\n    return max\\n\\nError : Time Limit Exceeded\\n\\nO(n) complexity\\nwhat\\'s wrong this approach? "
                    },
                    {
                        "username": "htooak2014",
                        "content": "me too. time limit error occurs. why? leetcode compiler error?"
                    },
                    {
                        "username": "drmolenhouse",
                        "content": "Same issue, using the LeetCode Official solution lmao. What am I paying $35/month for?"
                    },
                    {
                        "username": "user4387LF",
                        "content": "Because you may be using a brute force approach with two loops checking every combination which takes O(n2) time; Cause it exceeds time limit. Optimize your code. Think to solve it in one pass with one loop in linear time."
                    },
                    {
                        "username": "Sahil481",
                        "content": "Your code is not well optimised. It is not ran within the given time limit."
                    },
                    {
                        "username": "pstrait",
                        "content": "Are you doing it with more than one loop? If so, there\\'s a better solution that has O(n) time complexity"
                    },
                    {
                        "username": "leet_code_master",
                        "content": "prices = [2, 4, 1]\\n\\nOutput: 0\\nExpected: 2\\n\\nYou buy on day three but cannot sell because it is the last day. Should that not be zero?"
                    },
                    {
                        "username": "langhudson870",
                        "content": "You should buy on day 1 and sell on day 2"
                    },
                    {
                        "username": "almaas21",
                        "content": "[@user4391xh](/user4391xh) \\nthe output required is max profit through traversing  in the list, it could be adjacent too like in [2,4,1] max_profit here is 2 not 0"
                    },
                    {
                        "username": "ashish_bhosale848",
                        "content": "Yes , I am facing the same issue at case 154"
                    },
                    {
                        "username": "user4391xh",
                        "content": "According to the example 2 \\n(Input: prices = [7,6,4,3,1]\\nOutput: 0\\nExplanation: In this case, no transactions are done and the max profit = 0.)\\nin the task description, 0 should be returned so looks like tests expect incorrect value here.."
                    },
                    {
                        "username": "kaushit",
                        "content": "[@mp9508](/mp9508) I also done the same thing but if that solution is wrong then what approach should we think."
                    },
                    {
                        "username": "shubhamDhapola",
                        "content": "you buy on the first day and sell on the second"
                    },
                    {
                        "username": "sazuki",
                        "content": "[@mp9508](/mp9508) This happend to me too, because ahahah well, the first value that is taken is the min() so basically 1, but this is the last one because that will end in a 0 output. "
                    },
                    {
                        "username": "HarshitBansal122",
                        "content": "buy on first day and sell on second day makes profit 2 "
                    },
                    {
                        "username": "Dan_A_S",
                        "content": "[@mkv1892](/mkv1892) I don\\'t agree with that (except if the explanation of the problem is not correct). What I understood from the explanation is, you buy when the price is cheapest and sell on a later date when you can maximize profit (meaning the highest prize on a later date from the date of purchase). Going by that, you buy at 1 so the output should be zero and not the expected 2."
                    },
                    {
                        "username": "mkv1892",
                        "content": "No, Here you buy at day 1, Where the buy price is 2 and sell at day 2, Where the sell price is 4."
                    },
                    {
                        "username": "Byas_Yadav",
                        "content": "[@mp9508](/mp9508) you buy on day 1 and sell it on day 2 i.e. profit =sell-buy --> 4-2=2"
                    },
                    {
                        "username": "mp9508",
                        "content": "[@leet_code_master](/leet_code_master) happened the same to me . the approach i took is:\\nfind the minimum element and then maxi=mini then use a loop from the next index of the lowest mini element and then find maxi, then return the output.\\nhope this helps\\n"
                    },
                    {
                        "username": "VaishaliChauhan",
                        "content": "We need to maximize profit, you can buy at 2 and sell on 4, giving a profit of 2"
                    },
                    {
                        "username": "IbrahimJunior",
                        "content": "you have to maintain your profit in a variable and only change the variable if the new profit is greater than the previous one, so for this scenario, 2 is the former profit, 0 is the new one, it is not greater than 2 so you don\\'t change your profit."
                    },
                    {
                        "username": "Hanagaki_Takimichy",
                        "content": "buy = 2 and sell = 4 profit = 2\\ni am facing the same problem bro............."
                    },
                    {
                        "username": "MatsRivel",
                        "content": "[@leet_code_master](/leet_code_master) What I did was look at what the largest value after i is for each i, and what the smallest value is before each i. Then, for each i, i subtract smallest from largest. This is your optimal profit for buying before i and selling after i. Now you just find the largest number out of these, and you\\'re done."
                    },
                    {
                        "username": "leet_code_master",
                        "content": "[@MeriemA](/MeriemA) I see. Thank you :) How do you recommend I go about this? Because now the new code I make messes up the second test case."
                    },
                    {
                        "username": "MeriemA",
                        "content": "Actually,  the idea here is how you can make the maximum of profits. You don\\'t have to buy the stock when it\\'s at its lowest price.\\nHere you can buy the first day and sell the second day and still make a profit which is 2.\\n"
                    },
                    {
                        "username": "EXLsunshine",
                        "content": "Why is this problem tagged with \"Dynamic programming\"?"
                    },
                    {
                        "username": "princebillygk2",
                        "content": "[@aryan14decsingh](/aryan14decsingh) The problem can be solved in Dynamic way but the more efficient way is array traversal approach."
                    },
                    {
                        "username": "Mrinal2100",
                        "content": "It should be tagged as two pointer problem"
                    },
                    {
                        "username": "aryan14decsingh",
                        "content": "Because it is Dynamic  ( debatable ) \\nquestion apart , did you get any job by now ? you posted this on 2015 , if you are still alive let me know if you got any jobs and some tips aswell"
                    },
                    {
                        "username": "djslim",
                        "content": "[@sourov1407](/sourov1407)  tbh it\\'s classic greedy problem, interestingly in leetcode 75 they marked it as greedy"
                    },
                    {
                        "username": "sahle123",
                        "content": "[@AdityaBhate](/AdityaBhate) He/she was asking a question, not for a solution."
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# \\uD83D\\uDEA9Easy C++ O(N) Soln. [ FAANG\\uD83D\\uDE31 Interview Optimized code ]\\n\\nhttps://leetcode.com/problems/best-time-to-buy-and-sell-stock/solutions/2822579/easy-c-o-n-soln-faang-interview-optimized-code/\\n\\n"
                    },
                    {
                        "username": "sourov1407",
                        "content": "Because we can use kadene\\'s algorithm here and as it is widely regarded as dp algorithm so yeah this problem is tagged with dynamic programming"
                    },
                    {
                        "username": "casper07",
                        "content": "I am So dumb...."
                    },
                    {
                        "username": "ydumar",
                        "content": "same bruh"
                    },
                    {
                        "username": "savagesam343",
                        "content": "me too bro, me too..."
                    },
                    {
                        "username": "night07",
                        "content": "me too jit"
                    },
                    {
                        "username": "AlgoEngine",
                        "content": "Video visualizing an intuitive proof of the O(n) solution:\nhttps://youtube.com/watch?v=ioFPBdChabY"
                    },
                    {
                        "username": "astek14",
                        "content": "Thanks it\\'s awesome"
                    },
                    {
                        "username": "shilbabun491",
                        "content": "how to resolve the time exceeded issue? Mine fails at 200th test case with a large array"
                    },
                    {
                        "username": "akelux",
                        "content": "How to get max profit 4 from input [3,2,6,5,0,3]?"
                    },
                    {
                        "username": "jenil59",
                        "content": "buy at 2 and sell at 6"
                    },
                    {
                        "username": "Trinto_610",
                        "content": "damn bro 2013"
                    },
                    {
                        "username": "prasumitmishra",
                        "content": "3 (buy),  2 (buy) , 6 (sell), 5 (hold), 0 (hold), 3 (hold)\\n-3 -2 + (2*6)\\n= -5 + 12 = 7"
                    },
                    {
                        "username": "KayvanShah1",
                        "content": "by selling on 6 and buying on 0\\nwhich means short selling"
                    },
                    {
                        "username": "bhanureddy7",
                        "content": "2,6"
                    },
                    {
                        "username": "Hanagaki_Takimichy",
                        "content": "buy = 2 and sell = 6"
                    },
                    {
                        "username": "hungkiet244203",
                        "content": "[@jannatbushra524](/jannatbushra524) yeah but the profit it provides isnt\\n"
                    },
                    {
                        "username": "MatsRivel",
                        "content": "[@jannatbushra524](/jannatbushra524) Buy at 0, then you have to sell after zero, so the best sell price is 3. 3-0 = 3, 6-2=4"
                    },
                    {
                        "username": "ajjha7203",
                        "content": "6-2 = 4"
                    },
                    {
                        "username": "damajsam93",
                        "content": "6-2 ==> 4 "
                    },
                    {
                        "username": "Jagdeep4485",
                        "content": "6-2= 4"
                    },
                    {
                        "username": "jannatbushra524",
                        "content": "[@rajanhossainkhan](/rajanhossainkhan) isn\\'t \\'0\\' a buy_price ??...and its smallest too."
                    },
                    {
                        "username": "rajanhossainkhan",
                        "content": "Here are the steps - \\n\\n1. First buy out price is 3 and profit is set to 0. \\n2. Now loop through array from index 1, since index 0 (which is 3) is taken as minimum buy out price for now. \\n3. Now if price is 2, then set this as new buy out price, since its smaller. So our current buy out price is 2. \\n4. Now next price is 6. This is bigger, so sell with current buy out price 2. \\n5. Calculate max profit  = max(profit, ( current_price - buy_price) \\n6. In this case, max(0, 6-2) = 4\\n\\nHope this helps. "
                    },
                    {
                        "username": "Amit_Joe",
                        "content": "2 -6\\n"
                    },
                    {
                        "username": "hemantgautam505",
                        "content": "output is 4\\n"
                    },
                    {
                        "username": "Shashi3k",
                        "content": "2-6\\n"
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for February, Day 1.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  **📌 Do you want to learn the problem thoroughly?**\n  Read [**⭐  LeetCode Official Solution⭐**](https://leetcode.com/problems/best-time-to-buy-and-sell-stock/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 2 approaches in the official solution</summary>\n\n  \n**Approach 1:** Brute Force\n\n  \n**Approach 2:** One Pass\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# \\uD83D\\uDEA9Easy C++ O(N) Soln. [ FAANG\\uD83D\\uDE31 Interview Optimized code ]\\n\\nhttps://leetcode.com/problems/best-time-to-buy-and-sell-stock/solutions/2822579/easy-c-o-n-soln-faang-interview-optimized-code/\\n"
                    }
                ]
            },
            {
                "id": 1565340,
                "content": [
                    {
                        "username": "Serosidium",
                        "content": "I couldn\\'t find any good explanations here and only code, so I will do my best to explain how I solved it without providing code. I am sure there are other possible solutions, but this is how it worked for me.\\n\\nThe brute force method of a double for loop is not necessary here, and this problem is marked with dynamic programming because it requires the [Sliding Window technique](https://algorithm-visualizer.org/dynamic-programming/sliding-window).\\n\\nBased on the fact that we have to sell after we buy and we are trying to maximize profit, we can iterate through the prices and only need to consider two things:\\n1.) **Is this price cheaper than any other price I\\'ve seen before?** \\n2.) If I subtract current price by the cheapest price I\\'ve found, **does this yield a greater profit than what I\\'ve seen so far?**\\n\\n*A fun thing to note is if #1 is true, then #2 cannot be true as well so there isn\\'t a need to check*\\n\\nLet\\'s consider an example of [4,1,5,2,7]\\n- 4 is the cheapest price we see to start, and we can\\'t sell on the first day so maxProfit is 0\\n- 1 is now the cheapest price we\\'ve seen. Selling now would lose us money, so we can\\'t update maxProfit\\n- 5 is not cheaper than 1, but if we sell now we get a maxProfit of 4! Better save that for later\\n- 2 is not cheaper than 1 and if we sell, we only get a profit of 1, no need to do anything here\\n- 7 is not cheaper than 1, but if we sell here, we\\'ll increase maxProfit to 6, making this the best profit to return.\\n\\nHope this helps someone else!\\n"
                    },
                    {
                        "username": "Manidgyf_6",
                        "content": "Thank you bro"
                    },
                    {
                        "username": "lorentzimys",
                        "content": "Awesome solution, thanks!"
                    },
                    {
                        "username": "Khoa268",
                        "content": "thanks for sharing!"
                    },
                    {
                        "username": "omeh-a",
                        "content": "This is not a DP solution as described, it is greedy"
                    },
                    {
                        "username": "ankitk742",
                        "content": "Thanks bro for your help without code really appreciate "
                    },
                    {
                        "username": "245120733119",
                        "content": "Brilliant!! Thanks for sharing!!"
                    },
                    {
                        "username": "Aniket_sggs",
                        "content": "Initially, this seemed to be DP problem. but after reading this description it is clear that this is basic problem with greedy solution."
                    },
                    {
                        "username": "duffinson97",
                        "content": "Thank you for not posting code, I don\\'t understand the sliding window technique or how this applies to that. I google it and the image link to this problem doesn\\'t make a lot of sense to me. But this solution works thanks"
                    },
                    {
                        "username": "typranjal1",
                        "content": "Thank you!."
                    },
                    {
                        "username": "jakho100",
                        "content": "was stuck on it for hours, thanks for the simple explanation! "
                    },
                    {
                        "username": "zafeer_rangoonwala",
                        "content": "I was originally not able to solve it but after reading your thought process it was a cake walk! \\n\\nThanks! "
                    },
                    {
                        "username": "mohammed1212345",
                        "content": "thank for helping out"
                    },
                    {
                        "username": "dungtuanuet",
                        "content": "Exellent explaination!"
                    },
                    {
                        "username": "kcleland18",
                        "content": "This was a great explanation!! Thanks!"
                    },
                    {
                        "username": "as358",
                        "content": "Best Explanation ever !!!"
                    },
                    {
                        "username": "user6798sW",
                        "content": "AWESOME BREAKDOWN! Ty"
                    },
                    {
                        "username": "jaydeep-pro",
                        "content": "[@evoniuk](/evoniuk) exactly! "
                    },
                    {
                        "username": "akshaydusad",
                        "content": "okay this is genius and surprisingly easier to follow!"
                    },
                    {
                        "username": "evoniuk",
                        "content": "Thank you! This is a solution that\\'s so simple and obvious once you see it you kick yourself for not thinking of it yourself!"
                    },
                    {
                        "username": "ivantchev",
                        "content": "How would the original wording of the problem have to be modified so that the double loop solution _has_ to be used?"
                    },
                    {
                        "username": "ivantchev",
                        "content": "Very helpful, thank you! To add: the reason why using your point 1.) works as a valid check is because given the problem constraints, it will always yield a higher profit down the line regardless of future values.\\n\\nAnd point  2.) shows we don\\'t need a second loop.\\n\\nI wonder, can any concrete aspect of the problem  be used as a clue so that we can reach Serosidium\\'s solution  independently. "
                    },
                    {
                        "username": "VishnuKesav",
                        "content": "[@sharpsailor](/sharpsailor) our target is to get highest possible profit.\\nYou are focusing on buying for the lowest price alone. No matter how low the price is, buying on a last day will yield 0 profit.\\n"
                    },
                    {
                        "username": "kaushar",
                        "content": "[@tengxianrui](/tengxianrui) Thanks  !"
                    },
                    {
                        "username": "neelimag459",
                        "content": "Thank you so much for such good explanation. Happy coding."
                    },
                    {
                        "username": "Nbs-26",
                        "content": "Thank u brother. Your explanation is very clear and well defined."
                    },
                    {
                        "username": "Dabchinsky",
                        "content": "[@sharpsailor](/sharpsailor) if we buy on 2 and sell on 4, our profit would be 4 - 2 = 2. "
                    },
                    {
                        "username": "sharpsailor",
                        "content": "check for {2,4,1} ideally it should give 0 but leetcode gives 2..Help me figure out where am I getting it wrong\\n"
                    },
                    {
                        "username": "jackbb147",
                        "content": "that\\'s actually very smart... thanks"
                    },
                    {
                        "username": "chiahao1",
                        "content": "Thank you! Your technique worked for me."
                    },
                    {
                        "username": "Marre-86",
                        "content": "Man, you made my day! I spent two hours and wrote almost 100 hundred lines code that probably was soving it but had \"time limit exceeded\" with huge input. And after your explanation I rewrite it in freaking 7 lines and it made it right off the bat!"
                    },
                    {
                        "username": "m1ma087",
                        "content": "Best tip! Thanks!"
                    },
                    {
                        "username": "sasaalina1985",
                        "content": "was reading this and solved the problem first try! Very good explanation!!!"
                    },
                    {
                        "username": "Yash_6207",
                        "content": "This is what we call as Greedy ! Good Explanation\\n"
                    },
                    {
                        "username": "iosifpetrupuha",
                        "content": "[@fjod](/fjod) but it\\'s buy day that should be before then sellday"
                    },
                    {
                        "username": "iosifpetrupuha",
                        "content": "[@iosifpetrupuha](/iosifpetrupuha) daaamn there is no indentation in this comment section"
                    },
                    {
                        "username": "iosifpetrupuha",
                        "content": "so I didn\\'t know this was called sliding window or sumthin, but I am second year at CS university, i have some grasp of this kind of logic and I solved it this way:\\nclass Solution:\\n    def maxProfit(self, prices: List[int]) -> int:\\n        #you obviously must buy before you sell(can\\'t go back in time)\\n        GreatestProfit=0\\n        priceToBeat=prices[0]\\n        for i in range(len(prices)-1):#we can iterate through the whole list, otherwise we get out of bounds, so we iterate from the first to the penultimate (so the last comparation we do is between the penultimate and the last element) \\n            if prices[i]<prices[i+1]:#sure profit, possible greatest profit\\n                if prices[i]<=priceToBeat:\\n                    priceToBeat=prices[i]\\n                if GreatestProfit<=prices[i+1]-priceToBeat: #if the GreatestProfit we calculate is greater than the one we have already, we update the Greatest Profit, otherwise we do nothing\\n                    GreatestProfit=prices[i+1]-priceToBeat\\n        return GreatestProfit\\nis this a proper way to solve this kind of problems? (in terms of efficiency I think we\\'re in O(n) so it should be pretty good"
                    },
                    {
                        "username": "Rohit_8412",
                        "content": "Thanks, I was about to see the solution after 10 min I didn\\'t get an approach into my mind.\\nThen I saw your discussion and I solved the question myself \\uD83D\\uDE0E"
                    },
                    {
                        "username": "fjod",
                        "content": "your explanation does not include rule of sellDay must be after buyDay"
                    },
                    {
                        "username": "Hanagaki_Takimichy",
                        "content": "thanks for great explaination without any spoilers.\\ni will try my best for the code, thanks a lot ;)"
                    },
                    {
                        "username": "csrnontol",
                        "content": "Sounds good, but I think your tip fails for [2,9,3,4,5,1,7] (how you\\'d choose 2, 9) and [2,9,3,4,5,1,7,10] (how you\\'d choose 1, 10)."
                    },
                    {
                        "username": "rockmanex",
                        "content": "best explanations so far. Thankyou it\\'s help a lot"
                    },
                    {
                        "username": "ak67",
                        "content": "I think this problem should be catogarise as medium level problem\\n"
                    },
                    {
                        "username": "Sultan_Ul_Arfin",
                        "content": "[@chazwinter](/chazwinter) what is sliding window? I never heard it ..will you explain that please<3\\n "
                    },
                    {
                        "username": "chazwinter",
                        "content": "It doesn\\'t require DP though. You only think it\\'s harder than it is because you\\'re overthinking it. You can use sliding window and just keep track of the lowest price as you go."
                    },
                    {
                        "username": "rwatso",
                        "content": "[@lucky_nik77](/lucky_nik77) Because by its very nature DP is not a beginner / easy level topic."
                    },
                    {
                        "username": "Vectorido",
                        "content": "[@lucky_nik77](/lucky_nik77) This is not hard for simple lists. But all people here usually stuck at TimeLimit error. So algorithm should be another, at least medium level of complexity."
                    },
                    {
                        "username": "lucky_nik77",
                        "content": "But why? It is hard to think about a DP problem that would be easier than this."
                    },
                    {
                        "username": "tiwarimrutunjay",
                        "content": "agreed"
                    },
                    {
                        "username": "codernoob",
                        "content": "how to resolve the time exceeded issue? Mine fails at 203rd test case with a large array"
                    },
                    {
                        "username": "user4279js",
                        "content": "[@rajamandalofficial56](/rajamandalofficial56) I\\'m not a javascript expert, but probably doing prices.slice(index) is looping 0 -index eachtime ... so you have O(N\\n^2) soltuion overall"
                    },
                    {
                        "username": "Behnoosh",
                        "content": "[@htooak2014](/htooak2014) To me it was occurring when my code had an O(n^2) complexity. Resolving that (to O(n)) solved this problem. I start from the end of the array prices and dynamically find the max value from the end of the array until the current step backwards. This way, at the end of the for loop, we can find the max profit with only one single pass over all entries of the array."
                    },
                    {
                        "username": "eyastaifour",
                        "content": "[@htooak2014](/htooak2014) I am hitting a limit error as well and I believe that it is because I keep on querying max() of the window, but when I think of it the max is either on the first index of the window (as I descend), or somewhere else, in which case, it should be cached as it doesnt change... at least, that\\'s what i am thinking\\n"
                    },
                    {
                        "username": "PercyJia95",
                        "content": "[@rajamandalofficial56](/rajamandalofficial56) You need to reconsider your variable naming. They carry very few meanings."
                    },
                    {
                        "username": "knotri",
                        "content": "[@rajamandalofficial56](/rajamandalofficial56) since u iterate over N elements with prices.map, and for each elements u call Math.max(...prices.slice) u need approx additional 1/2N to find maximum. So O(n) = n^2"
                    },
                    {
                        "username": "rajamandalofficial56",
                        "content": " let max = 0;\\n\\n    prices.map((el,index) => {\\n      let tem =  Math.max(...prices.slice(index))\\n      if(el< tem){\\n         if(max< tem-el){\\n             max = tem-el\\n         }\\n      }\\n    })\\n    return max\\n\\nError : Time Limit Exceeded\\n\\nO(n) complexity\\nwhat\\'s wrong this approach? "
                    },
                    {
                        "username": "htooak2014",
                        "content": "me too. time limit error occurs. why? leetcode compiler error?"
                    },
                    {
                        "username": "drmolenhouse",
                        "content": "Same issue, using the LeetCode Official solution lmao. What am I paying $35/month for?"
                    },
                    {
                        "username": "user4387LF",
                        "content": "Because you may be using a brute force approach with two loops checking every combination which takes O(n2) time; Cause it exceeds time limit. Optimize your code. Think to solve it in one pass with one loop in linear time."
                    },
                    {
                        "username": "Sahil481",
                        "content": "Your code is not well optimised. It is not ran within the given time limit."
                    },
                    {
                        "username": "pstrait",
                        "content": "Are you doing it with more than one loop? If so, there\\'s a better solution that has O(n) time complexity"
                    },
                    {
                        "username": "leet_code_master",
                        "content": "prices = [2, 4, 1]\\n\\nOutput: 0\\nExpected: 2\\n\\nYou buy on day three but cannot sell because it is the last day. Should that not be zero?"
                    },
                    {
                        "username": "langhudson870",
                        "content": "You should buy on day 1 and sell on day 2"
                    },
                    {
                        "username": "almaas21",
                        "content": "[@user4391xh](/user4391xh) \\nthe output required is max profit through traversing  in the list, it could be adjacent too like in [2,4,1] max_profit here is 2 not 0"
                    },
                    {
                        "username": "ashish_bhosale848",
                        "content": "Yes , I am facing the same issue at case 154"
                    },
                    {
                        "username": "user4391xh",
                        "content": "According to the example 2 \\n(Input: prices = [7,6,4,3,1]\\nOutput: 0\\nExplanation: In this case, no transactions are done and the max profit = 0.)\\nin the task description, 0 should be returned so looks like tests expect incorrect value here.."
                    },
                    {
                        "username": "kaushit",
                        "content": "[@mp9508](/mp9508) I also done the same thing but if that solution is wrong then what approach should we think."
                    },
                    {
                        "username": "shubhamDhapola",
                        "content": "you buy on the first day and sell on the second"
                    },
                    {
                        "username": "sazuki",
                        "content": "[@mp9508](/mp9508) This happend to me too, because ahahah well, the first value that is taken is the min() so basically 1, but this is the last one because that will end in a 0 output. "
                    },
                    {
                        "username": "HarshitBansal122",
                        "content": "buy on first day and sell on second day makes profit 2 "
                    },
                    {
                        "username": "Dan_A_S",
                        "content": "[@mkv1892](/mkv1892) I don\\'t agree with that (except if the explanation of the problem is not correct). What I understood from the explanation is, you buy when the price is cheapest and sell on a later date when you can maximize profit (meaning the highest prize on a later date from the date of purchase). Going by that, you buy at 1 so the output should be zero and not the expected 2."
                    },
                    {
                        "username": "mkv1892",
                        "content": "No, Here you buy at day 1, Where the buy price is 2 and sell at day 2, Where the sell price is 4."
                    },
                    {
                        "username": "Byas_Yadav",
                        "content": "[@mp9508](/mp9508) you buy on day 1 and sell it on day 2 i.e. profit =sell-buy --> 4-2=2"
                    },
                    {
                        "username": "mp9508",
                        "content": "[@leet_code_master](/leet_code_master) happened the same to me . the approach i took is:\\nfind the minimum element and then maxi=mini then use a loop from the next index of the lowest mini element and then find maxi, then return the output.\\nhope this helps\\n"
                    },
                    {
                        "username": "VaishaliChauhan",
                        "content": "We need to maximize profit, you can buy at 2 and sell on 4, giving a profit of 2"
                    },
                    {
                        "username": "IbrahimJunior",
                        "content": "you have to maintain your profit in a variable and only change the variable if the new profit is greater than the previous one, so for this scenario, 2 is the former profit, 0 is the new one, it is not greater than 2 so you don\\'t change your profit."
                    },
                    {
                        "username": "Hanagaki_Takimichy",
                        "content": "buy = 2 and sell = 4 profit = 2\\ni am facing the same problem bro............."
                    },
                    {
                        "username": "MatsRivel",
                        "content": "[@leet_code_master](/leet_code_master) What I did was look at what the largest value after i is for each i, and what the smallest value is before each i. Then, for each i, i subtract smallest from largest. This is your optimal profit for buying before i and selling after i. Now you just find the largest number out of these, and you\\'re done."
                    },
                    {
                        "username": "leet_code_master",
                        "content": "[@MeriemA](/MeriemA) I see. Thank you :) How do you recommend I go about this? Because now the new code I make messes up the second test case."
                    },
                    {
                        "username": "MeriemA",
                        "content": "Actually,  the idea here is how you can make the maximum of profits. You don\\'t have to buy the stock when it\\'s at its lowest price.\\nHere you can buy the first day and sell the second day and still make a profit which is 2.\\n"
                    },
                    {
                        "username": "EXLsunshine",
                        "content": "Why is this problem tagged with \"Dynamic programming\"?"
                    },
                    {
                        "username": "princebillygk2",
                        "content": "[@aryan14decsingh](/aryan14decsingh) The problem can be solved in Dynamic way but the more efficient way is array traversal approach."
                    },
                    {
                        "username": "Mrinal2100",
                        "content": "It should be tagged as two pointer problem"
                    },
                    {
                        "username": "aryan14decsingh",
                        "content": "Because it is Dynamic  ( debatable ) \\nquestion apart , did you get any job by now ? you posted this on 2015 , if you are still alive let me know if you got any jobs and some tips aswell"
                    },
                    {
                        "username": "djslim",
                        "content": "[@sourov1407](/sourov1407)  tbh it\\'s classic greedy problem, interestingly in leetcode 75 they marked it as greedy"
                    },
                    {
                        "username": "sahle123",
                        "content": "[@AdityaBhate](/AdityaBhate) He/she was asking a question, not for a solution."
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# \\uD83D\\uDEA9Easy C++ O(N) Soln. [ FAANG\\uD83D\\uDE31 Interview Optimized code ]\\n\\nhttps://leetcode.com/problems/best-time-to-buy-and-sell-stock/solutions/2822579/easy-c-o-n-soln-faang-interview-optimized-code/\\n\\n"
                    },
                    {
                        "username": "sourov1407",
                        "content": "Because we can use kadene\\'s algorithm here and as it is widely regarded as dp algorithm so yeah this problem is tagged with dynamic programming"
                    },
                    {
                        "username": "casper07",
                        "content": "I am So dumb...."
                    },
                    {
                        "username": "ydumar",
                        "content": "same bruh"
                    },
                    {
                        "username": "savagesam343",
                        "content": "me too bro, me too..."
                    },
                    {
                        "username": "night07",
                        "content": "me too jit"
                    },
                    {
                        "username": "AlgoEngine",
                        "content": "Video visualizing an intuitive proof of the O(n) solution:\nhttps://youtube.com/watch?v=ioFPBdChabY"
                    },
                    {
                        "username": "astek14",
                        "content": "Thanks it\\'s awesome"
                    },
                    {
                        "username": "shilbabun491",
                        "content": "how to resolve the time exceeded issue? Mine fails at 200th test case with a large array"
                    },
                    {
                        "username": "akelux",
                        "content": "How to get max profit 4 from input [3,2,6,5,0,3]?"
                    },
                    {
                        "username": "jenil59",
                        "content": "buy at 2 and sell at 6"
                    },
                    {
                        "username": "Trinto_610",
                        "content": "damn bro 2013"
                    },
                    {
                        "username": "prasumitmishra",
                        "content": "3 (buy),  2 (buy) , 6 (sell), 5 (hold), 0 (hold), 3 (hold)\\n-3 -2 + (2*6)\\n= -5 + 12 = 7"
                    },
                    {
                        "username": "KayvanShah1",
                        "content": "by selling on 6 and buying on 0\\nwhich means short selling"
                    },
                    {
                        "username": "bhanureddy7",
                        "content": "2,6"
                    },
                    {
                        "username": "Hanagaki_Takimichy",
                        "content": "buy = 2 and sell = 6"
                    },
                    {
                        "username": "hungkiet244203",
                        "content": "[@jannatbushra524](/jannatbushra524) yeah but the profit it provides isnt\\n"
                    },
                    {
                        "username": "MatsRivel",
                        "content": "[@jannatbushra524](/jannatbushra524) Buy at 0, then you have to sell after zero, so the best sell price is 3. 3-0 = 3, 6-2=4"
                    },
                    {
                        "username": "ajjha7203",
                        "content": "6-2 = 4"
                    },
                    {
                        "username": "damajsam93",
                        "content": "6-2 ==> 4 "
                    },
                    {
                        "username": "Jagdeep4485",
                        "content": "6-2= 4"
                    },
                    {
                        "username": "jannatbushra524",
                        "content": "[@rajanhossainkhan](/rajanhossainkhan) isn\\'t \\'0\\' a buy_price ??...and its smallest too."
                    },
                    {
                        "username": "rajanhossainkhan",
                        "content": "Here are the steps - \\n\\n1. First buy out price is 3 and profit is set to 0. \\n2. Now loop through array from index 1, since index 0 (which is 3) is taken as minimum buy out price for now. \\n3. Now if price is 2, then set this as new buy out price, since its smaller. So our current buy out price is 2. \\n4. Now next price is 6. This is bigger, so sell with current buy out price 2. \\n5. Calculate max profit  = max(profit, ( current_price - buy_price) \\n6. In this case, max(0, 6-2) = 4\\n\\nHope this helps. "
                    },
                    {
                        "username": "Amit_Joe",
                        "content": "2 -6\\n"
                    },
                    {
                        "username": "hemantgautam505",
                        "content": "output is 4\\n"
                    },
                    {
                        "username": "Shashi3k",
                        "content": "2-6\\n"
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for February, Day 1.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  **📌 Do you want to learn the problem thoroughly?**\n  Read [**⭐  LeetCode Official Solution⭐**](https://leetcode.com/problems/best-time-to-buy-and-sell-stock/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 2 approaches in the official solution</summary>\n\n  \n**Approach 1:** Brute Force\n\n  \n**Approach 2:** One Pass\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# \\uD83D\\uDEA9Easy C++ O(N) Soln. [ FAANG\\uD83D\\uDE31 Interview Optimized code ]\\n\\nhttps://leetcode.com/problems/best-time-to-buy-and-sell-stock/solutions/2822579/easy-c-o-n-soln-faang-interview-optimized-code/\\n"
                    }
                ]
            },
            {
                "id": 1566103,
                "content": [
                    {
                        "username": "Anonymous_Cat",
                        "content": "I solved the problem using dynamic programming (iteratively) but I am trying to draw the recursive tree. Since I am trying to understand DP as well as possible. I failed though so can someone help?\\n\\nAlso is there a way to solve this using memoization (recursively). I tried and failed as well."
                    },
                    {
                        "username": "vladandrei51",
                        "content": "[@tirthprajapati1810](/tirthprajapati1810) Hey"
                    },
                    {
                        "username": "tirthprajapati1810",
                        "content": "hii..\\n"
                    },
                    {
                        "username": "RANJITH_G",
                        "content": "prices=[1,2]\\noutput =2\\nexpected =1\\nhow do I get 1?..\\nwhen buy for rs 1 at day1 and sells at Rs.2 gives the profit ...Then,how do I get day1 as output?"
                    },
                    {
                        "username": "winstonallo",
                        "content": "you don\\'t return the day, you return price[selling day] - price[buying day], so 2 -1 = 1"
                    },
                    {
                        "username": "Miguell0706",
                        "content": "You dont return the day, return the maximum profit "
                    },
                    {
                        "username": "Akshaychouke",
                        "content": "because 2-1 = 1 = profit"
                    },
                    {
                        "username": "mingchoi",
                        "content": "(creative) A Dynamic Programming approch:\nYou can actually solve this problem with by converting it into [53.Maximum Subarray], here's how:\n\nLet's start with case 1:`prices=[7,1,5,3,6,4]`\nnow loop once to calculate the gain/loss if you buy it then sell it on the next day, \n`prices[i] = prices[i+1] - prices[i]`\ne.g. buy at 7 sell at 1: `1-7=-6`, then you will come up with this array:\n`[-6, +4, -2, +3, -2]`\n\nFor now, you need find the range with maximum profit(sub array) from above. The answer can tell by looking at it, the best range is `+4 -2 +3 = 5`.\nIf the maximum is negative you should return 0 and that's all!\n\nBest part of this approch is you can do it in-place, there will be an empty slot at the end of array, but if you think about that -- you can simply put 0 at that empty slot so you don't have to check negative anymore. Perfect!\n"
                    },
                    {
                        "username": "Dabchinsky",
                        "content": "Well, you dont need to create any arrays, you can simply loop prices array once, calculating maximum profit on each step. "
                    },
                    {
                        "username": "WallaWonka",
                        "content": "\\uD83D\\uDC4F\\uD83C\\uDFFE\\uD83D\\uDC4F\\uD83C\\uDFFE"
                    },
                    {
                        "username": "wangxin501",
                        "content": "Input:\\t[6,1,3,2,4,7]\\nOutput:\\t5\\nExpected:\\t6"
                    },
                    {
                        "username": "mdsali914",
                        "content": "Just do + 1 on the answer"
                    },
                    {
                        "username": "bhanureddy7",
                        "content": "1,7\\n"
                    },
                    {
                        "username": "Hanagaki_Takimichy",
                        "content": "buy = 1 and sell = 7 profit = 6"
                    },
                    {
                        "username": "MatsRivel",
                        "content": "[@alangreg](/alangreg) 7-1 *"
                    },
                    {
                        "username": "alangreg",
                        "content": "1-7"
                    },
                    {
                        "username": "Azmankhan",
                        "content": " int maxi = 0;\\n      int minimum = prices[0];\\n      for (int i=0; i< prices.size(); i++ ){\\n          minimum  = min(minimum ,prices[i]);\\n          maxi  = max(maxi ,prices[i] - minimum );\\n      }\\n      return maxi;\\n    }"
                    },
                    {
                        "username": "user1889GX",
                        "content": "This is good solutions"
                    },
                    {
                        "username": "dantruongdo3",
                        "content": "[@Pikachu13](/Pikachu13) dude is a protagonist"
                    },
                    {
                        "username": "Socrii13",
                        "content": "there is also requirement to check for the future day ?\\n"
                    },
                    {
                        "username": "zomart",
                        "content": "Not a dynamic prog problem. Incorrect tagging must be fixed"
                    },
                    {
                        "username": "Anmol_Soni",
                        "content": "probably using knapsack as well"
                    },
                    {
                        "username": "alankrit_1403",
                        "content": "it is a dp problem as we can solve it using kadane algo and that algo is part of dp algo and also we can solve it using memoization"
                    },
                    {
                        "username": "bytecode15",
                        "content": "This should be a medium level question, its demotivating to mark it as Medium :9"
                    },
                    {
                        "username": "pineappleunderthesea",
                        "content": "Because of a fairly pointless test case - it passes in Java though."
                    },
                    {
                        "username": "NEWrecruit",
                        "content": "[2,1,2,1,0,0,1] wrong case?testcase output 1 but submit return 2"
                    },
                    {
                        "username": "HarshitBansal122",
                        "content": "buy on one , sell on the next 2 "
                    },
                    {
                        "username": "inception_007",
                        "content": "i wonder how this problem is of easy on leetcode, it should be medium"
                    }
                ]
            },
            {
                "id": 1772605,
                "content": [
                    {
                        "username": "Anonymous_Cat",
                        "content": "I solved the problem using dynamic programming (iteratively) but I am trying to draw the recursive tree. Since I am trying to understand DP as well as possible. I failed though so can someone help?\\n\\nAlso is there a way to solve this using memoization (recursively). I tried and failed as well."
                    },
                    {
                        "username": "vladandrei51",
                        "content": "[@tirthprajapati1810](/tirthprajapati1810) Hey"
                    },
                    {
                        "username": "tirthprajapati1810",
                        "content": "hii..\\n"
                    },
                    {
                        "username": "RANJITH_G",
                        "content": "prices=[1,2]\\noutput =2\\nexpected =1\\nhow do I get 1?..\\nwhen buy for rs 1 at day1 and sells at Rs.2 gives the profit ...Then,how do I get day1 as output?"
                    },
                    {
                        "username": "winstonallo",
                        "content": "you don\\'t return the day, you return price[selling day] - price[buying day], so 2 -1 = 1"
                    },
                    {
                        "username": "Miguell0706",
                        "content": "You dont return the day, return the maximum profit "
                    },
                    {
                        "username": "Akshaychouke",
                        "content": "because 2-1 = 1 = profit"
                    },
                    {
                        "username": "mingchoi",
                        "content": "(creative) A Dynamic Programming approch:\nYou can actually solve this problem with by converting it into [53.Maximum Subarray], here's how:\n\nLet's start with case 1:`prices=[7,1,5,3,6,4]`\nnow loop once to calculate the gain/loss if you buy it then sell it on the next day, \n`prices[i] = prices[i+1] - prices[i]`\ne.g. buy at 7 sell at 1: `1-7=-6`, then you will come up with this array:\n`[-6, +4, -2, +3, -2]`\n\nFor now, you need find the range with maximum profit(sub array) from above. The answer can tell by looking at it, the best range is `+4 -2 +3 = 5`.\nIf the maximum is negative you should return 0 and that's all!\n\nBest part of this approch is you can do it in-place, there will be an empty slot at the end of array, but if you think about that -- you can simply put 0 at that empty slot so you don't have to check negative anymore. Perfect!\n"
                    },
                    {
                        "username": "Dabchinsky",
                        "content": "Well, you dont need to create any arrays, you can simply loop prices array once, calculating maximum profit on each step. "
                    },
                    {
                        "username": "WallaWonka",
                        "content": "\\uD83D\\uDC4F\\uD83C\\uDFFE\\uD83D\\uDC4F\\uD83C\\uDFFE"
                    },
                    {
                        "username": "wangxin501",
                        "content": "Input:\\t[6,1,3,2,4,7]\\nOutput:\\t5\\nExpected:\\t6"
                    },
                    {
                        "username": "mdsali914",
                        "content": "Just do + 1 on the answer"
                    },
                    {
                        "username": "bhanureddy7",
                        "content": "1,7\\n"
                    },
                    {
                        "username": "Hanagaki_Takimichy",
                        "content": "buy = 1 and sell = 7 profit = 6"
                    },
                    {
                        "username": "MatsRivel",
                        "content": "[@alangreg](/alangreg) 7-1 *"
                    },
                    {
                        "username": "alangreg",
                        "content": "1-7"
                    },
                    {
                        "username": "Azmankhan",
                        "content": " int maxi = 0;\\n      int minimum = prices[0];\\n      for (int i=0; i< prices.size(); i++ ){\\n          minimum  = min(minimum ,prices[i]);\\n          maxi  = max(maxi ,prices[i] - minimum );\\n      }\\n      return maxi;\\n    }"
                    },
                    {
                        "username": "user1889GX",
                        "content": "This is good solutions"
                    },
                    {
                        "username": "dantruongdo3",
                        "content": "[@Pikachu13](/Pikachu13) dude is a protagonist"
                    },
                    {
                        "username": "Socrii13",
                        "content": "there is also requirement to check for the future day ?\\n"
                    },
                    {
                        "username": "zomart",
                        "content": "Not a dynamic prog problem. Incorrect tagging must be fixed"
                    },
                    {
                        "username": "Anmol_Soni",
                        "content": "probably using knapsack as well"
                    },
                    {
                        "username": "alankrit_1403",
                        "content": "it is a dp problem as we can solve it using kadane algo and that algo is part of dp algo and also we can solve it using memoization"
                    },
                    {
                        "username": "bytecode15",
                        "content": "This should be a medium level question, its demotivating to mark it as Medium :9"
                    },
                    {
                        "username": "pineappleunderthesea",
                        "content": "Because of a fairly pointless test case - it passes in Java though."
                    },
                    {
                        "username": "NEWrecruit",
                        "content": "[2,1,2,1,0,0,1] wrong case?testcase output 1 but submit return 2"
                    },
                    {
                        "username": "HarshitBansal122",
                        "content": "buy on one , sell on the next 2 "
                    },
                    {
                        "username": "inception_007",
                        "content": "i wonder how this problem is of easy on leetcode, it should be medium"
                    }
                ]
            },
            {
                "id": 1766938,
                "content": [
                    {
                        "username": "Anonymous_Cat",
                        "content": "I solved the problem using dynamic programming (iteratively) but I am trying to draw the recursive tree. Since I am trying to understand DP as well as possible. I failed though so can someone help?\\n\\nAlso is there a way to solve this using memoization (recursively). I tried and failed as well."
                    },
                    {
                        "username": "vladandrei51",
                        "content": "[@tirthprajapati1810](/tirthprajapati1810) Hey"
                    },
                    {
                        "username": "tirthprajapati1810",
                        "content": "hii..\\n"
                    },
                    {
                        "username": "RANJITH_G",
                        "content": "prices=[1,2]\\noutput =2\\nexpected =1\\nhow do I get 1?..\\nwhen buy for rs 1 at day1 and sells at Rs.2 gives the profit ...Then,how do I get day1 as output?"
                    },
                    {
                        "username": "winstonallo",
                        "content": "you don\\'t return the day, you return price[selling day] - price[buying day], so 2 -1 = 1"
                    },
                    {
                        "username": "Miguell0706",
                        "content": "You dont return the day, return the maximum profit "
                    },
                    {
                        "username": "Akshaychouke",
                        "content": "because 2-1 = 1 = profit"
                    },
                    {
                        "username": "mingchoi",
                        "content": "(creative) A Dynamic Programming approch:\nYou can actually solve this problem with by converting it into [53.Maximum Subarray], here's how:\n\nLet's start with case 1:`prices=[7,1,5,3,6,4]`\nnow loop once to calculate the gain/loss if you buy it then sell it on the next day, \n`prices[i] = prices[i+1] - prices[i]`\ne.g. buy at 7 sell at 1: `1-7=-6`, then you will come up with this array:\n`[-6, +4, -2, +3, -2]`\n\nFor now, you need find the range with maximum profit(sub array) from above. The answer can tell by looking at it, the best range is `+4 -2 +3 = 5`.\nIf the maximum is negative you should return 0 and that's all!\n\nBest part of this approch is you can do it in-place, there will be an empty slot at the end of array, but if you think about that -- you can simply put 0 at that empty slot so you don't have to check negative anymore. Perfect!\n"
                    },
                    {
                        "username": "Dabchinsky",
                        "content": "Well, you dont need to create any arrays, you can simply loop prices array once, calculating maximum profit on each step. "
                    },
                    {
                        "username": "WallaWonka",
                        "content": "\\uD83D\\uDC4F\\uD83C\\uDFFE\\uD83D\\uDC4F\\uD83C\\uDFFE"
                    },
                    {
                        "username": "wangxin501",
                        "content": "Input:\\t[6,1,3,2,4,7]\\nOutput:\\t5\\nExpected:\\t6"
                    },
                    {
                        "username": "mdsali914",
                        "content": "Just do + 1 on the answer"
                    },
                    {
                        "username": "bhanureddy7",
                        "content": "1,7\\n"
                    },
                    {
                        "username": "Hanagaki_Takimichy",
                        "content": "buy = 1 and sell = 7 profit = 6"
                    },
                    {
                        "username": "MatsRivel",
                        "content": "[@alangreg](/alangreg) 7-1 *"
                    },
                    {
                        "username": "alangreg",
                        "content": "1-7"
                    },
                    {
                        "username": "Azmankhan",
                        "content": " int maxi = 0;\\n      int minimum = prices[0];\\n      for (int i=0; i< prices.size(); i++ ){\\n          minimum  = min(minimum ,prices[i]);\\n          maxi  = max(maxi ,prices[i] - minimum );\\n      }\\n      return maxi;\\n    }"
                    },
                    {
                        "username": "user1889GX",
                        "content": "This is good solutions"
                    },
                    {
                        "username": "dantruongdo3",
                        "content": "[@Pikachu13](/Pikachu13) dude is a protagonist"
                    },
                    {
                        "username": "Socrii13",
                        "content": "there is also requirement to check for the future day ?\\n"
                    },
                    {
                        "username": "zomart",
                        "content": "Not a dynamic prog problem. Incorrect tagging must be fixed"
                    },
                    {
                        "username": "Anmol_Soni",
                        "content": "probably using knapsack as well"
                    },
                    {
                        "username": "alankrit_1403",
                        "content": "it is a dp problem as we can solve it using kadane algo and that algo is part of dp algo and also we can solve it using memoization"
                    },
                    {
                        "username": "bytecode15",
                        "content": "This should be a medium level question, its demotivating to mark it as Medium :9"
                    },
                    {
                        "username": "pineappleunderthesea",
                        "content": "Because of a fairly pointless test case - it passes in Java though."
                    },
                    {
                        "username": "NEWrecruit",
                        "content": "[2,1,2,1,0,0,1] wrong case?testcase output 1 but submit return 2"
                    },
                    {
                        "username": "HarshitBansal122",
                        "content": "buy on one , sell on the next 2 "
                    },
                    {
                        "username": "inception_007",
                        "content": "i wonder how this problem is of easy on leetcode, it should be medium"
                    }
                ]
            },
            {
                "id": 1567867,
                "content": [
                    {
                        "username": "Anonymous_Cat",
                        "content": "I solved the problem using dynamic programming (iteratively) but I am trying to draw the recursive tree. Since I am trying to understand DP as well as possible. I failed though so can someone help?\\n\\nAlso is there a way to solve this using memoization (recursively). I tried and failed as well."
                    },
                    {
                        "username": "vladandrei51",
                        "content": "[@tirthprajapati1810](/tirthprajapati1810) Hey"
                    },
                    {
                        "username": "tirthprajapati1810",
                        "content": "hii..\\n"
                    },
                    {
                        "username": "RANJITH_G",
                        "content": "prices=[1,2]\\noutput =2\\nexpected =1\\nhow do I get 1?..\\nwhen buy for rs 1 at day1 and sells at Rs.2 gives the profit ...Then,how do I get day1 as output?"
                    },
                    {
                        "username": "winstonallo",
                        "content": "you don\\'t return the day, you return price[selling day] - price[buying day], so 2 -1 = 1"
                    },
                    {
                        "username": "Miguell0706",
                        "content": "You dont return the day, return the maximum profit "
                    },
                    {
                        "username": "Akshaychouke",
                        "content": "because 2-1 = 1 = profit"
                    },
                    {
                        "username": "mingchoi",
                        "content": "(creative) A Dynamic Programming approch:\nYou can actually solve this problem with by converting it into [53.Maximum Subarray], here's how:\n\nLet's start with case 1:`prices=[7,1,5,3,6,4]`\nnow loop once to calculate the gain/loss if you buy it then sell it on the next day, \n`prices[i] = prices[i+1] - prices[i]`\ne.g. buy at 7 sell at 1: `1-7=-6`, then you will come up with this array:\n`[-6, +4, -2, +3, -2]`\n\nFor now, you need find the range with maximum profit(sub array) from above. The answer can tell by looking at it, the best range is `+4 -2 +3 = 5`.\nIf the maximum is negative you should return 0 and that's all!\n\nBest part of this approch is you can do it in-place, there will be an empty slot at the end of array, but if you think about that -- you can simply put 0 at that empty slot so you don't have to check negative anymore. Perfect!\n"
                    },
                    {
                        "username": "Dabchinsky",
                        "content": "Well, you dont need to create any arrays, you can simply loop prices array once, calculating maximum profit on each step. "
                    },
                    {
                        "username": "WallaWonka",
                        "content": "\\uD83D\\uDC4F\\uD83C\\uDFFE\\uD83D\\uDC4F\\uD83C\\uDFFE"
                    },
                    {
                        "username": "wangxin501",
                        "content": "Input:\\t[6,1,3,2,4,7]\\nOutput:\\t5\\nExpected:\\t6"
                    },
                    {
                        "username": "mdsali914",
                        "content": "Just do + 1 on the answer"
                    },
                    {
                        "username": "bhanureddy7",
                        "content": "1,7\\n"
                    },
                    {
                        "username": "Hanagaki_Takimichy",
                        "content": "buy = 1 and sell = 7 profit = 6"
                    },
                    {
                        "username": "MatsRivel",
                        "content": "[@alangreg](/alangreg) 7-1 *"
                    },
                    {
                        "username": "alangreg",
                        "content": "1-7"
                    },
                    {
                        "username": "Azmankhan",
                        "content": " int maxi = 0;\\n      int minimum = prices[0];\\n      for (int i=0; i< prices.size(); i++ ){\\n          minimum  = min(minimum ,prices[i]);\\n          maxi  = max(maxi ,prices[i] - minimum );\\n      }\\n      return maxi;\\n    }"
                    },
                    {
                        "username": "user1889GX",
                        "content": "This is good solutions"
                    },
                    {
                        "username": "dantruongdo3",
                        "content": "[@Pikachu13](/Pikachu13) dude is a protagonist"
                    },
                    {
                        "username": "Socrii13",
                        "content": "there is also requirement to check for the future day ?\\n"
                    },
                    {
                        "username": "zomart",
                        "content": "Not a dynamic prog problem. Incorrect tagging must be fixed"
                    },
                    {
                        "username": "Anmol_Soni",
                        "content": "probably using knapsack as well"
                    },
                    {
                        "username": "alankrit_1403",
                        "content": "it is a dp problem as we can solve it using kadane algo and that algo is part of dp algo and also we can solve it using memoization"
                    },
                    {
                        "username": "bytecode15",
                        "content": "This should be a medium level question, its demotivating to mark it as Medium :9"
                    },
                    {
                        "username": "pineappleunderthesea",
                        "content": "Because of a fairly pointless test case - it passes in Java though."
                    },
                    {
                        "username": "NEWrecruit",
                        "content": "[2,1,2,1,0,0,1] wrong case?testcase output 1 but submit return 2"
                    },
                    {
                        "username": "HarshitBansal122",
                        "content": "buy on one , sell on the next 2 "
                    },
                    {
                        "username": "inception_007",
                        "content": "i wonder how this problem is of easy on leetcode, it should be medium"
                    }
                ]
            },
            {
                "id": 1702991,
                "content": [
                    {
                        "username": "Anonymous_Cat",
                        "content": "I solved the problem using dynamic programming (iteratively) but I am trying to draw the recursive tree. Since I am trying to understand DP as well as possible. I failed though so can someone help?\\n\\nAlso is there a way to solve this using memoization (recursively). I tried and failed as well."
                    },
                    {
                        "username": "vladandrei51",
                        "content": "[@tirthprajapati1810](/tirthprajapati1810) Hey"
                    },
                    {
                        "username": "tirthprajapati1810",
                        "content": "hii..\\n"
                    },
                    {
                        "username": "RANJITH_G",
                        "content": "prices=[1,2]\\noutput =2\\nexpected =1\\nhow do I get 1?..\\nwhen buy for rs 1 at day1 and sells at Rs.2 gives the profit ...Then,how do I get day1 as output?"
                    },
                    {
                        "username": "winstonallo",
                        "content": "you don\\'t return the day, you return price[selling day] - price[buying day], so 2 -1 = 1"
                    },
                    {
                        "username": "Miguell0706",
                        "content": "You dont return the day, return the maximum profit "
                    },
                    {
                        "username": "Akshaychouke",
                        "content": "because 2-1 = 1 = profit"
                    },
                    {
                        "username": "mingchoi",
                        "content": "(creative) A Dynamic Programming approch:\nYou can actually solve this problem with by converting it into [53.Maximum Subarray], here's how:\n\nLet's start with case 1:`prices=[7,1,5,3,6,4]`\nnow loop once to calculate the gain/loss if you buy it then sell it on the next day, \n`prices[i] = prices[i+1] - prices[i]`\ne.g. buy at 7 sell at 1: `1-7=-6`, then you will come up with this array:\n`[-6, +4, -2, +3, -2]`\n\nFor now, you need find the range with maximum profit(sub array) from above. The answer can tell by looking at it, the best range is `+4 -2 +3 = 5`.\nIf the maximum is negative you should return 0 and that's all!\n\nBest part of this approch is you can do it in-place, there will be an empty slot at the end of array, but if you think about that -- you can simply put 0 at that empty slot so you don't have to check negative anymore. Perfect!\n"
                    },
                    {
                        "username": "Dabchinsky",
                        "content": "Well, you dont need to create any arrays, you can simply loop prices array once, calculating maximum profit on each step. "
                    },
                    {
                        "username": "WallaWonka",
                        "content": "\\uD83D\\uDC4F\\uD83C\\uDFFE\\uD83D\\uDC4F\\uD83C\\uDFFE"
                    },
                    {
                        "username": "wangxin501",
                        "content": "Input:\\t[6,1,3,2,4,7]\\nOutput:\\t5\\nExpected:\\t6"
                    },
                    {
                        "username": "mdsali914",
                        "content": "Just do + 1 on the answer"
                    },
                    {
                        "username": "bhanureddy7",
                        "content": "1,7\\n"
                    },
                    {
                        "username": "Hanagaki_Takimichy",
                        "content": "buy = 1 and sell = 7 profit = 6"
                    },
                    {
                        "username": "MatsRivel",
                        "content": "[@alangreg](/alangreg) 7-1 *"
                    },
                    {
                        "username": "alangreg",
                        "content": "1-7"
                    },
                    {
                        "username": "Azmankhan",
                        "content": " int maxi = 0;\\n      int minimum = prices[0];\\n      for (int i=0; i< prices.size(); i++ ){\\n          minimum  = min(minimum ,prices[i]);\\n          maxi  = max(maxi ,prices[i] - minimum );\\n      }\\n      return maxi;\\n    }"
                    },
                    {
                        "username": "user1889GX",
                        "content": "This is good solutions"
                    },
                    {
                        "username": "dantruongdo3",
                        "content": "[@Pikachu13](/Pikachu13) dude is a protagonist"
                    },
                    {
                        "username": "Socrii13",
                        "content": "there is also requirement to check for the future day ?\\n"
                    },
                    {
                        "username": "zomart",
                        "content": "Not a dynamic prog problem. Incorrect tagging must be fixed"
                    },
                    {
                        "username": "Anmol_Soni",
                        "content": "probably using knapsack as well"
                    },
                    {
                        "username": "alankrit_1403",
                        "content": "it is a dp problem as we can solve it using kadane algo and that algo is part of dp algo and also we can solve it using memoization"
                    },
                    {
                        "username": "bytecode15",
                        "content": "This should be a medium level question, its demotivating to mark it as Medium :9"
                    },
                    {
                        "username": "pineappleunderthesea",
                        "content": "Because of a fairly pointless test case - it passes in Java though."
                    },
                    {
                        "username": "NEWrecruit",
                        "content": "[2,1,2,1,0,0,1] wrong case?testcase output 1 but submit return 2"
                    },
                    {
                        "username": "HarshitBansal122",
                        "content": "buy on one , sell on the next 2 "
                    },
                    {
                        "username": "inception_007",
                        "content": "i wonder how this problem is of easy on leetcode, it should be medium"
                    }
                ]
            },
            {
                "id": 1569240,
                "content": [
                    {
                        "username": "Anonymous_Cat",
                        "content": "I solved the problem using dynamic programming (iteratively) but I am trying to draw the recursive tree. Since I am trying to understand DP as well as possible. I failed though so can someone help?\\n\\nAlso is there a way to solve this using memoization (recursively). I tried and failed as well."
                    },
                    {
                        "username": "vladandrei51",
                        "content": "[@tirthprajapati1810](/tirthprajapati1810) Hey"
                    },
                    {
                        "username": "tirthprajapati1810",
                        "content": "hii..\\n"
                    },
                    {
                        "username": "RANJITH_G",
                        "content": "prices=[1,2]\\noutput =2\\nexpected =1\\nhow do I get 1?..\\nwhen buy for rs 1 at day1 and sells at Rs.2 gives the profit ...Then,how do I get day1 as output?"
                    },
                    {
                        "username": "winstonallo",
                        "content": "you don\\'t return the day, you return price[selling day] - price[buying day], so 2 -1 = 1"
                    },
                    {
                        "username": "Miguell0706",
                        "content": "You dont return the day, return the maximum profit "
                    },
                    {
                        "username": "Akshaychouke",
                        "content": "because 2-1 = 1 = profit"
                    },
                    {
                        "username": "mingchoi",
                        "content": "(creative) A Dynamic Programming approch:\nYou can actually solve this problem with by converting it into [53.Maximum Subarray], here's how:\n\nLet's start with case 1:`prices=[7,1,5,3,6,4]`\nnow loop once to calculate the gain/loss if you buy it then sell it on the next day, \n`prices[i] = prices[i+1] - prices[i]`\ne.g. buy at 7 sell at 1: `1-7=-6`, then you will come up with this array:\n`[-6, +4, -2, +3, -2]`\n\nFor now, you need find the range with maximum profit(sub array) from above. The answer can tell by looking at it, the best range is `+4 -2 +3 = 5`.\nIf the maximum is negative you should return 0 and that's all!\n\nBest part of this approch is you can do it in-place, there will be an empty slot at the end of array, but if you think about that -- you can simply put 0 at that empty slot so you don't have to check negative anymore. Perfect!\n"
                    },
                    {
                        "username": "Dabchinsky",
                        "content": "Well, you dont need to create any arrays, you can simply loop prices array once, calculating maximum profit on each step. "
                    },
                    {
                        "username": "WallaWonka",
                        "content": "\\uD83D\\uDC4F\\uD83C\\uDFFE\\uD83D\\uDC4F\\uD83C\\uDFFE"
                    },
                    {
                        "username": "wangxin501",
                        "content": "Input:\\t[6,1,3,2,4,7]\\nOutput:\\t5\\nExpected:\\t6"
                    },
                    {
                        "username": "mdsali914",
                        "content": "Just do + 1 on the answer"
                    },
                    {
                        "username": "bhanureddy7",
                        "content": "1,7\\n"
                    },
                    {
                        "username": "Hanagaki_Takimichy",
                        "content": "buy = 1 and sell = 7 profit = 6"
                    },
                    {
                        "username": "MatsRivel",
                        "content": "[@alangreg](/alangreg) 7-1 *"
                    },
                    {
                        "username": "alangreg",
                        "content": "1-7"
                    },
                    {
                        "username": "Azmankhan",
                        "content": " int maxi = 0;\\n      int minimum = prices[0];\\n      for (int i=0; i< prices.size(); i++ ){\\n          minimum  = min(minimum ,prices[i]);\\n          maxi  = max(maxi ,prices[i] - minimum );\\n      }\\n      return maxi;\\n    }"
                    },
                    {
                        "username": "user1889GX",
                        "content": "This is good solutions"
                    },
                    {
                        "username": "dantruongdo3",
                        "content": "[@Pikachu13](/Pikachu13) dude is a protagonist"
                    },
                    {
                        "username": "Socrii13",
                        "content": "there is also requirement to check for the future day ?\\n"
                    },
                    {
                        "username": "zomart",
                        "content": "Not a dynamic prog problem. Incorrect tagging must be fixed"
                    },
                    {
                        "username": "Anmol_Soni",
                        "content": "probably using knapsack as well"
                    },
                    {
                        "username": "alankrit_1403",
                        "content": "it is a dp problem as we can solve it using kadane algo and that algo is part of dp algo and also we can solve it using memoization"
                    },
                    {
                        "username": "bytecode15",
                        "content": "This should be a medium level question, its demotivating to mark it as Medium :9"
                    },
                    {
                        "username": "pineappleunderthesea",
                        "content": "Because of a fairly pointless test case - it passes in Java though."
                    },
                    {
                        "username": "NEWrecruit",
                        "content": "[2,1,2,1,0,0,1] wrong case?testcase output 1 but submit return 2"
                    },
                    {
                        "username": "HarshitBansal122",
                        "content": "buy on one , sell on the next 2 "
                    },
                    {
                        "username": "inception_007",
                        "content": "i wonder how this problem is of easy on leetcode, it should be medium"
                    }
                ]
            },
            {
                "id": 1869011,
                "content": [
                    {
                        "username": "Anonymous_Cat",
                        "content": "I solved the problem using dynamic programming (iteratively) but I am trying to draw the recursive tree. Since I am trying to understand DP as well as possible. I failed though so can someone help?\\n\\nAlso is there a way to solve this using memoization (recursively). I tried and failed as well."
                    },
                    {
                        "username": "vladandrei51",
                        "content": "[@tirthprajapati1810](/tirthprajapati1810) Hey"
                    },
                    {
                        "username": "tirthprajapati1810",
                        "content": "hii..\\n"
                    },
                    {
                        "username": "RANJITH_G",
                        "content": "prices=[1,2]\\noutput =2\\nexpected =1\\nhow do I get 1?..\\nwhen buy for rs 1 at day1 and sells at Rs.2 gives the profit ...Then,how do I get day1 as output?"
                    },
                    {
                        "username": "winstonallo",
                        "content": "you don\\'t return the day, you return price[selling day] - price[buying day], so 2 -1 = 1"
                    },
                    {
                        "username": "Miguell0706",
                        "content": "You dont return the day, return the maximum profit "
                    },
                    {
                        "username": "Akshaychouke",
                        "content": "because 2-1 = 1 = profit"
                    },
                    {
                        "username": "mingchoi",
                        "content": "(creative) A Dynamic Programming approch:\nYou can actually solve this problem with by converting it into [53.Maximum Subarray], here's how:\n\nLet's start with case 1:`prices=[7,1,5,3,6,4]`\nnow loop once to calculate the gain/loss if you buy it then sell it on the next day, \n`prices[i] = prices[i+1] - prices[i]`\ne.g. buy at 7 sell at 1: `1-7=-6`, then you will come up with this array:\n`[-6, +4, -2, +3, -2]`\n\nFor now, you need find the range with maximum profit(sub array) from above. The answer can tell by looking at it, the best range is `+4 -2 +3 = 5`.\nIf the maximum is negative you should return 0 and that's all!\n\nBest part of this approch is you can do it in-place, there will be an empty slot at the end of array, but if you think about that -- you can simply put 0 at that empty slot so you don't have to check negative anymore. Perfect!\n"
                    },
                    {
                        "username": "Dabchinsky",
                        "content": "Well, you dont need to create any arrays, you can simply loop prices array once, calculating maximum profit on each step. "
                    },
                    {
                        "username": "WallaWonka",
                        "content": "\\uD83D\\uDC4F\\uD83C\\uDFFE\\uD83D\\uDC4F\\uD83C\\uDFFE"
                    },
                    {
                        "username": "wangxin501",
                        "content": "Input:\\t[6,1,3,2,4,7]\\nOutput:\\t5\\nExpected:\\t6"
                    },
                    {
                        "username": "mdsali914",
                        "content": "Just do + 1 on the answer"
                    },
                    {
                        "username": "bhanureddy7",
                        "content": "1,7\\n"
                    },
                    {
                        "username": "Hanagaki_Takimichy",
                        "content": "buy = 1 and sell = 7 profit = 6"
                    },
                    {
                        "username": "MatsRivel",
                        "content": "[@alangreg](/alangreg) 7-1 *"
                    },
                    {
                        "username": "alangreg",
                        "content": "1-7"
                    },
                    {
                        "username": "Azmankhan",
                        "content": " int maxi = 0;\\n      int minimum = prices[0];\\n      for (int i=0; i< prices.size(); i++ ){\\n          minimum  = min(minimum ,prices[i]);\\n          maxi  = max(maxi ,prices[i] - minimum );\\n      }\\n      return maxi;\\n    }"
                    },
                    {
                        "username": "user1889GX",
                        "content": "This is good solutions"
                    },
                    {
                        "username": "dantruongdo3",
                        "content": "[@Pikachu13](/Pikachu13) dude is a protagonist"
                    },
                    {
                        "username": "Socrii13",
                        "content": "there is also requirement to check for the future day ?\\n"
                    },
                    {
                        "username": "zomart",
                        "content": "Not a dynamic prog problem. Incorrect tagging must be fixed"
                    },
                    {
                        "username": "Anmol_Soni",
                        "content": "probably using knapsack as well"
                    },
                    {
                        "username": "alankrit_1403",
                        "content": "it is a dp problem as we can solve it using kadane algo and that algo is part of dp algo and also we can solve it using memoization"
                    },
                    {
                        "username": "bytecode15",
                        "content": "This should be a medium level question, its demotivating to mark it as Medium :9"
                    },
                    {
                        "username": "pineappleunderthesea",
                        "content": "Because of a fairly pointless test case - it passes in Java though."
                    },
                    {
                        "username": "NEWrecruit",
                        "content": "[2,1,2,1,0,0,1] wrong case?testcase output 1 but submit return 2"
                    },
                    {
                        "username": "HarshitBansal122",
                        "content": "buy on one , sell on the next 2 "
                    },
                    {
                        "username": "inception_007",
                        "content": "i wonder how this problem is of easy on leetcode, it should be medium"
                    }
                ]
            },
            {
                "id": 1567393,
                "content": [
                    {
                        "username": "Anonymous_Cat",
                        "content": "I solved the problem using dynamic programming (iteratively) but I am trying to draw the recursive tree. Since I am trying to understand DP as well as possible. I failed though so can someone help?\\n\\nAlso is there a way to solve this using memoization (recursively). I tried and failed as well."
                    },
                    {
                        "username": "vladandrei51",
                        "content": "[@tirthprajapati1810](/tirthprajapati1810) Hey"
                    },
                    {
                        "username": "tirthprajapati1810",
                        "content": "hii..\\n"
                    },
                    {
                        "username": "RANJITH_G",
                        "content": "prices=[1,2]\\noutput =2\\nexpected =1\\nhow do I get 1?..\\nwhen buy for rs 1 at day1 and sells at Rs.2 gives the profit ...Then,how do I get day1 as output?"
                    },
                    {
                        "username": "winstonallo",
                        "content": "you don\\'t return the day, you return price[selling day] - price[buying day], so 2 -1 = 1"
                    },
                    {
                        "username": "Miguell0706",
                        "content": "You dont return the day, return the maximum profit "
                    },
                    {
                        "username": "Akshaychouke",
                        "content": "because 2-1 = 1 = profit"
                    },
                    {
                        "username": "mingchoi",
                        "content": "(creative) A Dynamic Programming approch:\nYou can actually solve this problem with by converting it into [53.Maximum Subarray], here's how:\n\nLet's start with case 1:`prices=[7,1,5,3,6,4]`\nnow loop once to calculate the gain/loss if you buy it then sell it on the next day, \n`prices[i] = prices[i+1] - prices[i]`\ne.g. buy at 7 sell at 1: `1-7=-6`, then you will come up with this array:\n`[-6, +4, -2, +3, -2]`\n\nFor now, you need find the range with maximum profit(sub array) from above. The answer can tell by looking at it, the best range is `+4 -2 +3 = 5`.\nIf the maximum is negative you should return 0 and that's all!\n\nBest part of this approch is you can do it in-place, there will be an empty slot at the end of array, but if you think about that -- you can simply put 0 at that empty slot so you don't have to check negative anymore. Perfect!\n"
                    },
                    {
                        "username": "Dabchinsky",
                        "content": "Well, you dont need to create any arrays, you can simply loop prices array once, calculating maximum profit on each step. "
                    },
                    {
                        "username": "WallaWonka",
                        "content": "\\uD83D\\uDC4F\\uD83C\\uDFFE\\uD83D\\uDC4F\\uD83C\\uDFFE"
                    },
                    {
                        "username": "wangxin501",
                        "content": "Input:\\t[6,1,3,2,4,7]\\nOutput:\\t5\\nExpected:\\t6"
                    },
                    {
                        "username": "mdsali914",
                        "content": "Just do + 1 on the answer"
                    },
                    {
                        "username": "bhanureddy7",
                        "content": "1,7\\n"
                    },
                    {
                        "username": "Hanagaki_Takimichy",
                        "content": "buy = 1 and sell = 7 profit = 6"
                    },
                    {
                        "username": "MatsRivel",
                        "content": "[@alangreg](/alangreg) 7-1 *"
                    },
                    {
                        "username": "alangreg",
                        "content": "1-7"
                    },
                    {
                        "username": "Azmankhan",
                        "content": " int maxi = 0;\\n      int minimum = prices[0];\\n      for (int i=0; i< prices.size(); i++ ){\\n          minimum  = min(minimum ,prices[i]);\\n          maxi  = max(maxi ,prices[i] - minimum );\\n      }\\n      return maxi;\\n    }"
                    },
                    {
                        "username": "user1889GX",
                        "content": "This is good solutions"
                    },
                    {
                        "username": "dantruongdo3",
                        "content": "[@Pikachu13](/Pikachu13) dude is a protagonist"
                    },
                    {
                        "username": "Socrii13",
                        "content": "there is also requirement to check for the future day ?\\n"
                    },
                    {
                        "username": "zomart",
                        "content": "Not a dynamic prog problem. Incorrect tagging must be fixed"
                    },
                    {
                        "username": "Anmol_Soni",
                        "content": "probably using knapsack as well"
                    },
                    {
                        "username": "alankrit_1403",
                        "content": "it is a dp problem as we can solve it using kadane algo and that algo is part of dp algo and also we can solve it using memoization"
                    },
                    {
                        "username": "bytecode15",
                        "content": "This should be a medium level question, its demotivating to mark it as Medium :9"
                    },
                    {
                        "username": "pineappleunderthesea",
                        "content": "Because of a fairly pointless test case - it passes in Java though."
                    },
                    {
                        "username": "NEWrecruit",
                        "content": "[2,1,2,1,0,0,1] wrong case?testcase output 1 but submit return 2"
                    },
                    {
                        "username": "HarshitBansal122",
                        "content": "buy on one , sell on the next 2 "
                    },
                    {
                        "username": "inception_007",
                        "content": "i wonder how this problem is of easy on leetcode, it should be medium"
                    }
                ]
            },
            {
                "id": 1571250,
                "content": [
                    {
                        "username": "Anonymous_Cat",
                        "content": "I solved the problem using dynamic programming (iteratively) but I am trying to draw the recursive tree. Since I am trying to understand DP as well as possible. I failed though so can someone help?\\n\\nAlso is there a way to solve this using memoization (recursively). I tried and failed as well."
                    },
                    {
                        "username": "vladandrei51",
                        "content": "[@tirthprajapati1810](/tirthprajapati1810) Hey"
                    },
                    {
                        "username": "tirthprajapati1810",
                        "content": "hii..\\n"
                    },
                    {
                        "username": "RANJITH_G",
                        "content": "prices=[1,2]\\noutput =2\\nexpected =1\\nhow do I get 1?..\\nwhen buy for rs 1 at day1 and sells at Rs.2 gives the profit ...Then,how do I get day1 as output?"
                    },
                    {
                        "username": "winstonallo",
                        "content": "you don\\'t return the day, you return price[selling day] - price[buying day], so 2 -1 = 1"
                    },
                    {
                        "username": "Miguell0706",
                        "content": "You dont return the day, return the maximum profit "
                    },
                    {
                        "username": "Akshaychouke",
                        "content": "because 2-1 = 1 = profit"
                    },
                    {
                        "username": "mingchoi",
                        "content": "(creative) A Dynamic Programming approch:\nYou can actually solve this problem with by converting it into [53.Maximum Subarray], here's how:\n\nLet's start with case 1:`prices=[7,1,5,3,6,4]`\nnow loop once to calculate the gain/loss if you buy it then sell it on the next day, \n`prices[i] = prices[i+1] - prices[i]`\ne.g. buy at 7 sell at 1: `1-7=-6`, then you will come up with this array:\n`[-6, +4, -2, +3, -2]`\n\nFor now, you need find the range with maximum profit(sub array) from above. The answer can tell by looking at it, the best range is `+4 -2 +3 = 5`.\nIf the maximum is negative you should return 0 and that's all!\n\nBest part of this approch is you can do it in-place, there will be an empty slot at the end of array, but if you think about that -- you can simply put 0 at that empty slot so you don't have to check negative anymore. Perfect!\n"
                    },
                    {
                        "username": "Dabchinsky",
                        "content": "Well, you dont need to create any arrays, you can simply loop prices array once, calculating maximum profit on each step. "
                    },
                    {
                        "username": "WallaWonka",
                        "content": "\\uD83D\\uDC4F\\uD83C\\uDFFE\\uD83D\\uDC4F\\uD83C\\uDFFE"
                    },
                    {
                        "username": "wangxin501",
                        "content": "Input:\\t[6,1,3,2,4,7]\\nOutput:\\t5\\nExpected:\\t6"
                    },
                    {
                        "username": "mdsali914",
                        "content": "Just do + 1 on the answer"
                    },
                    {
                        "username": "bhanureddy7",
                        "content": "1,7\\n"
                    },
                    {
                        "username": "Hanagaki_Takimichy",
                        "content": "buy = 1 and sell = 7 profit = 6"
                    },
                    {
                        "username": "MatsRivel",
                        "content": "[@alangreg](/alangreg) 7-1 *"
                    },
                    {
                        "username": "alangreg",
                        "content": "1-7"
                    },
                    {
                        "username": "Azmankhan",
                        "content": " int maxi = 0;\\n      int minimum = prices[0];\\n      for (int i=0; i< prices.size(); i++ ){\\n          minimum  = min(minimum ,prices[i]);\\n          maxi  = max(maxi ,prices[i] - minimum );\\n      }\\n      return maxi;\\n    }"
                    },
                    {
                        "username": "user1889GX",
                        "content": "This is good solutions"
                    },
                    {
                        "username": "dantruongdo3",
                        "content": "[@Pikachu13](/Pikachu13) dude is a protagonist"
                    },
                    {
                        "username": "Socrii13",
                        "content": "there is also requirement to check for the future day ?\\n"
                    },
                    {
                        "username": "zomart",
                        "content": "Not a dynamic prog problem. Incorrect tagging must be fixed"
                    },
                    {
                        "username": "Anmol_Soni",
                        "content": "probably using knapsack as well"
                    },
                    {
                        "username": "alankrit_1403",
                        "content": "it is a dp problem as we can solve it using kadane algo and that algo is part of dp algo and also we can solve it using memoization"
                    },
                    {
                        "username": "bytecode15",
                        "content": "This should be a medium level question, its demotivating to mark it as Medium :9"
                    },
                    {
                        "username": "pineappleunderthesea",
                        "content": "Because of a fairly pointless test case - it passes in Java though."
                    },
                    {
                        "username": "NEWrecruit",
                        "content": "[2,1,2,1,0,0,1] wrong case?testcase output 1 but submit return 2"
                    },
                    {
                        "username": "HarshitBansal122",
                        "content": "buy on one , sell on the next 2 "
                    },
                    {
                        "username": "inception_007",
                        "content": "i wonder how this problem is of easy on leetcode, it should be medium"
                    }
                ]
            },
            {
                "id": 1807383,
                "content": [
                    {
                        "username": "Anonymous_Cat",
                        "content": "I solved the problem using dynamic programming (iteratively) but I am trying to draw the recursive tree. Since I am trying to understand DP as well as possible. I failed though so can someone help?\\n\\nAlso is there a way to solve this using memoization (recursively). I tried and failed as well."
                    },
                    {
                        "username": "vladandrei51",
                        "content": "[@tirthprajapati1810](/tirthprajapati1810) Hey"
                    },
                    {
                        "username": "tirthprajapati1810",
                        "content": "hii..\\n"
                    },
                    {
                        "username": "RANJITH_G",
                        "content": "prices=[1,2]\\noutput =2\\nexpected =1\\nhow do I get 1?..\\nwhen buy for rs 1 at day1 and sells at Rs.2 gives the profit ...Then,how do I get day1 as output?"
                    },
                    {
                        "username": "winstonallo",
                        "content": "you don\\'t return the day, you return price[selling day] - price[buying day], so 2 -1 = 1"
                    },
                    {
                        "username": "Miguell0706",
                        "content": "You dont return the day, return the maximum profit "
                    },
                    {
                        "username": "Akshaychouke",
                        "content": "because 2-1 = 1 = profit"
                    },
                    {
                        "username": "mingchoi",
                        "content": "(creative) A Dynamic Programming approch:\nYou can actually solve this problem with by converting it into [53.Maximum Subarray], here's how:\n\nLet's start with case 1:`prices=[7,1,5,3,6,4]`\nnow loop once to calculate the gain/loss if you buy it then sell it on the next day, \n`prices[i] = prices[i+1] - prices[i]`\ne.g. buy at 7 sell at 1: `1-7=-6`, then you will come up with this array:\n`[-6, +4, -2, +3, -2]`\n\nFor now, you need find the range with maximum profit(sub array) from above. The answer can tell by looking at it, the best range is `+4 -2 +3 = 5`.\nIf the maximum is negative you should return 0 and that's all!\n\nBest part of this approch is you can do it in-place, there will be an empty slot at the end of array, but if you think about that -- you can simply put 0 at that empty slot so you don't have to check negative anymore. Perfect!\n"
                    },
                    {
                        "username": "Dabchinsky",
                        "content": "Well, you dont need to create any arrays, you can simply loop prices array once, calculating maximum profit on each step. "
                    },
                    {
                        "username": "WallaWonka",
                        "content": "\\uD83D\\uDC4F\\uD83C\\uDFFE\\uD83D\\uDC4F\\uD83C\\uDFFE"
                    },
                    {
                        "username": "wangxin501",
                        "content": "Input:\\t[6,1,3,2,4,7]\\nOutput:\\t5\\nExpected:\\t6"
                    },
                    {
                        "username": "mdsali914",
                        "content": "Just do + 1 on the answer"
                    },
                    {
                        "username": "bhanureddy7",
                        "content": "1,7\\n"
                    },
                    {
                        "username": "Hanagaki_Takimichy",
                        "content": "buy = 1 and sell = 7 profit = 6"
                    },
                    {
                        "username": "MatsRivel",
                        "content": "[@alangreg](/alangreg) 7-1 *"
                    },
                    {
                        "username": "alangreg",
                        "content": "1-7"
                    },
                    {
                        "username": "Azmankhan",
                        "content": " int maxi = 0;\\n      int minimum = prices[0];\\n      for (int i=0; i< prices.size(); i++ ){\\n          minimum  = min(minimum ,prices[i]);\\n          maxi  = max(maxi ,prices[i] - minimum );\\n      }\\n      return maxi;\\n    }"
                    },
                    {
                        "username": "user1889GX",
                        "content": "This is good solutions"
                    },
                    {
                        "username": "dantruongdo3",
                        "content": "[@Pikachu13](/Pikachu13) dude is a protagonist"
                    },
                    {
                        "username": "Socrii13",
                        "content": "there is also requirement to check for the future day ?\\n"
                    },
                    {
                        "username": "zomart",
                        "content": "Not a dynamic prog problem. Incorrect tagging must be fixed"
                    },
                    {
                        "username": "Anmol_Soni",
                        "content": "probably using knapsack as well"
                    },
                    {
                        "username": "alankrit_1403",
                        "content": "it is a dp problem as we can solve it using kadane algo and that algo is part of dp algo and also we can solve it using memoization"
                    },
                    {
                        "username": "bytecode15",
                        "content": "This should be a medium level question, its demotivating to mark it as Medium :9"
                    },
                    {
                        "username": "pineappleunderthesea",
                        "content": "Because of a fairly pointless test case - it passes in Java though."
                    },
                    {
                        "username": "NEWrecruit",
                        "content": "[2,1,2,1,0,0,1] wrong case?testcase output 1 but submit return 2"
                    },
                    {
                        "username": "HarshitBansal122",
                        "content": "buy on one , sell on the next 2 "
                    },
                    {
                        "username": "inception_007",
                        "content": "i wonder how this problem is of easy on leetcode, it should be medium"
                    }
                ]
            },
            {
                "id": 1813722,
                "content": [
                    {
                        "username": "Promethus",
                        "content": "#Intuition#\\n\\nso keep two variables one keeps track of profit and second keeps track of minimum(minCost) value of stock\\n1. initialize profit with zero and minCost to first price\\n2.  then iterate through the array \\n3. we have to check what profit we can get if we sell the stock at that index and is it greater than our previous profits\\n4.  then we need to also check  if current price of stock is less than the minCost we have been keeping track of\\n5. return profit  after iterating overprice array"
                    },
                    {
                        "username": "hborah@ncsu.edu",
                        "content": "![Don't understand the expected answer][1]\\n\\n\\n  [1]: https://s32.postimg.org/m4zfjazol/Screen_Shot_2016_06_22_at_10_29_32_PM.png"
                    },
                    {
                        "username": "aleksandvladiminikol",
                        "content": "looks like that\\'s not easy level :)"
                    },
                    {
                        "username": "Umair9912",
                        "content": "Bro I miss the old location of the discussion tab ;( damn corporate greed."
                    },
                    {
                        "username": "Michael_Teng6",
                        "content": "This is a very good DP problem for beginners."
                    },
                    {
                        "username": "licy_zane",
                        "content": "class Solution {\\n    public int maxProfit(int[] prices) {\\n        int max = 0;\\n        int delta = 0;\\n        for (int i = prices.length-1; i >= 0; i--) {\\n            if (prices[i] >= max) {\\n                max = prices[i];\\n            } else {\\n                delta = Math.max(max - prices[i], delta);\\n            }\\n        }\\n        return delta;\\n    }\\n}"
                    },
                    {
                        "username": "Sinan6942069",
                        "content": "I really need to learn how to use less for loops, i always run into problems where they ask me huge questions that are impossible to solve quickly enough with nested loops."
                    },
                    {
                        "username": "krishna3062018",
                        "content": "if you learnt then teach us.."
                    },
                    {
                        "username": "binhope",
                        "content": "The case [6,1,3,2,4,7] which  expected ouput is 6.My output is  7.My solution is,at the second day i buy,and the third day sell,the fourth day buy it ,the sixth day sell it .Why the answer is 6?"
                    },
                    {
                        "username": "user2696u",
                        "content": "prices[2,4,1] should have an answer of 0 shouldn\\'t it?"
                    },
                    {
                        "username": "arurahul16",
                        "content": "No bro , you need to understand \"MAX Profit\" focus on that , you will understand why its not 0."
                    },
                    {
                        "username": "lordrsling",
                        "content": "Tiny hint: \\nYou can go through the prices just once."
                    }
                ]
            },
            {
                "id": 1567866,
                "content": [
                    {
                        "username": "Promethus",
                        "content": "#Intuition#\\n\\nso keep two variables one keeps track of profit and second keeps track of minimum(minCost) value of stock\\n1. initialize profit with zero and minCost to first price\\n2.  then iterate through the array \\n3. we have to check what profit we can get if we sell the stock at that index and is it greater than our previous profits\\n4.  then we need to also check  if current price of stock is less than the minCost we have been keeping track of\\n5. return profit  after iterating overprice array"
                    },
                    {
                        "username": "hborah@ncsu.edu",
                        "content": "![Don't understand the expected answer][1]\\n\\n\\n  [1]: https://s32.postimg.org/m4zfjazol/Screen_Shot_2016_06_22_at_10_29_32_PM.png"
                    },
                    {
                        "username": "aleksandvladiminikol",
                        "content": "looks like that\\'s not easy level :)"
                    },
                    {
                        "username": "Umair9912",
                        "content": "Bro I miss the old location of the discussion tab ;( damn corporate greed."
                    },
                    {
                        "username": "Michael_Teng6",
                        "content": "This is a very good DP problem for beginners."
                    },
                    {
                        "username": "licy_zane",
                        "content": "class Solution {\\n    public int maxProfit(int[] prices) {\\n        int max = 0;\\n        int delta = 0;\\n        for (int i = prices.length-1; i >= 0; i--) {\\n            if (prices[i] >= max) {\\n                max = prices[i];\\n            } else {\\n                delta = Math.max(max - prices[i], delta);\\n            }\\n        }\\n        return delta;\\n    }\\n}"
                    },
                    {
                        "username": "Sinan6942069",
                        "content": "I really need to learn how to use less for loops, i always run into problems where they ask me huge questions that are impossible to solve quickly enough with nested loops."
                    },
                    {
                        "username": "krishna3062018",
                        "content": "if you learnt then teach us.."
                    },
                    {
                        "username": "binhope",
                        "content": "The case [6,1,3,2,4,7] which  expected ouput is 6.My output is  7.My solution is,at the second day i buy,and the third day sell,the fourth day buy it ,the sixth day sell it .Why the answer is 6?"
                    },
                    {
                        "username": "user2696u",
                        "content": "prices[2,4,1] should have an answer of 0 shouldn\\'t it?"
                    },
                    {
                        "username": "arurahul16",
                        "content": "No bro , you need to understand \"MAX Profit\" focus on that , you will understand why its not 0."
                    },
                    {
                        "username": "lordrsling",
                        "content": "Tiny hint: \\nYou can go through the prices just once."
                    }
                ]
            },
            {
                "id": 1914445,
                "content": [
                    {
                        "username": "Promethus",
                        "content": "#Intuition#\\n\\nso keep two variables one keeps track of profit and second keeps track of minimum(minCost) value of stock\\n1. initialize profit with zero and minCost to first price\\n2.  then iterate through the array \\n3. we have to check what profit we can get if we sell the stock at that index and is it greater than our previous profits\\n4.  then we need to also check  if current price of stock is less than the minCost we have been keeping track of\\n5. return profit  after iterating overprice array"
                    },
                    {
                        "username": "hborah@ncsu.edu",
                        "content": "![Don't understand the expected answer][1]\\n\\n\\n  [1]: https://s32.postimg.org/m4zfjazol/Screen_Shot_2016_06_22_at_10_29_32_PM.png"
                    },
                    {
                        "username": "aleksandvladiminikol",
                        "content": "looks like that\\'s not easy level :)"
                    },
                    {
                        "username": "Umair9912",
                        "content": "Bro I miss the old location of the discussion tab ;( damn corporate greed."
                    },
                    {
                        "username": "Michael_Teng6",
                        "content": "This is a very good DP problem for beginners."
                    },
                    {
                        "username": "licy_zane",
                        "content": "class Solution {\\n    public int maxProfit(int[] prices) {\\n        int max = 0;\\n        int delta = 0;\\n        for (int i = prices.length-1; i >= 0; i--) {\\n            if (prices[i] >= max) {\\n                max = prices[i];\\n            } else {\\n                delta = Math.max(max - prices[i], delta);\\n            }\\n        }\\n        return delta;\\n    }\\n}"
                    },
                    {
                        "username": "Sinan6942069",
                        "content": "I really need to learn how to use less for loops, i always run into problems where they ask me huge questions that are impossible to solve quickly enough with nested loops."
                    },
                    {
                        "username": "krishna3062018",
                        "content": "if you learnt then teach us.."
                    },
                    {
                        "username": "binhope",
                        "content": "The case [6,1,3,2,4,7] which  expected ouput is 6.My output is  7.My solution is,at the second day i buy,and the third day sell,the fourth day buy it ,the sixth day sell it .Why the answer is 6?"
                    },
                    {
                        "username": "user2696u",
                        "content": "prices[2,4,1] should have an answer of 0 shouldn\\'t it?"
                    },
                    {
                        "username": "arurahul16",
                        "content": "No bro , you need to understand \"MAX Profit\" focus on that , you will understand why its not 0."
                    },
                    {
                        "username": "lordrsling",
                        "content": "Tiny hint: \\nYou can go through the prices just once."
                    }
                ]
            },
            {
                "id": 1813766,
                "content": [
                    {
                        "username": "Promethus",
                        "content": "#Intuition#\\n\\nso keep two variables one keeps track of profit and second keeps track of minimum(minCost) value of stock\\n1. initialize profit with zero and minCost to first price\\n2.  then iterate through the array \\n3. we have to check what profit we can get if we sell the stock at that index and is it greater than our previous profits\\n4.  then we need to also check  if current price of stock is less than the minCost we have been keeping track of\\n5. return profit  after iterating overprice array"
                    },
                    {
                        "username": "hborah@ncsu.edu",
                        "content": "![Don't understand the expected answer][1]\\n\\n\\n  [1]: https://s32.postimg.org/m4zfjazol/Screen_Shot_2016_06_22_at_10_29_32_PM.png"
                    },
                    {
                        "username": "aleksandvladiminikol",
                        "content": "looks like that\\'s not easy level :)"
                    },
                    {
                        "username": "Umair9912",
                        "content": "Bro I miss the old location of the discussion tab ;( damn corporate greed."
                    },
                    {
                        "username": "Michael_Teng6",
                        "content": "This is a very good DP problem for beginners."
                    },
                    {
                        "username": "licy_zane",
                        "content": "class Solution {\\n    public int maxProfit(int[] prices) {\\n        int max = 0;\\n        int delta = 0;\\n        for (int i = prices.length-1; i >= 0; i--) {\\n            if (prices[i] >= max) {\\n                max = prices[i];\\n            } else {\\n                delta = Math.max(max - prices[i], delta);\\n            }\\n        }\\n        return delta;\\n    }\\n}"
                    },
                    {
                        "username": "Sinan6942069",
                        "content": "I really need to learn how to use less for loops, i always run into problems where they ask me huge questions that are impossible to solve quickly enough with nested loops."
                    },
                    {
                        "username": "krishna3062018",
                        "content": "if you learnt then teach us.."
                    },
                    {
                        "username": "binhope",
                        "content": "The case [6,1,3,2,4,7] which  expected ouput is 6.My output is  7.My solution is,at the second day i buy,and the third day sell,the fourth day buy it ,the sixth day sell it .Why the answer is 6?"
                    },
                    {
                        "username": "user2696u",
                        "content": "prices[2,4,1] should have an answer of 0 shouldn\\'t it?"
                    },
                    {
                        "username": "arurahul16",
                        "content": "No bro , you need to understand \"MAX Profit\" focus on that , you will understand why its not 0."
                    },
                    {
                        "username": "lordrsling",
                        "content": "Tiny hint: \\nYou can go through the prices just once."
                    }
                ]
            },
            {
                "id": 1813637,
                "content": [
                    {
                        "username": "Promethus",
                        "content": "#Intuition#\\n\\nso keep two variables one keeps track of profit and second keeps track of minimum(minCost) value of stock\\n1. initialize profit with zero and minCost to first price\\n2.  then iterate through the array \\n3. we have to check what profit we can get if we sell the stock at that index and is it greater than our previous profits\\n4.  then we need to also check  if current price of stock is less than the minCost we have been keeping track of\\n5. return profit  after iterating overprice array"
                    },
                    {
                        "username": "hborah@ncsu.edu",
                        "content": "![Don't understand the expected answer][1]\\n\\n\\n  [1]: https://s32.postimg.org/m4zfjazol/Screen_Shot_2016_06_22_at_10_29_32_PM.png"
                    },
                    {
                        "username": "aleksandvladiminikol",
                        "content": "looks like that\\'s not easy level :)"
                    },
                    {
                        "username": "Umair9912",
                        "content": "Bro I miss the old location of the discussion tab ;( damn corporate greed."
                    },
                    {
                        "username": "Michael_Teng6",
                        "content": "This is a very good DP problem for beginners."
                    },
                    {
                        "username": "licy_zane",
                        "content": "class Solution {\\n    public int maxProfit(int[] prices) {\\n        int max = 0;\\n        int delta = 0;\\n        for (int i = prices.length-1; i >= 0; i--) {\\n            if (prices[i] >= max) {\\n                max = prices[i];\\n            } else {\\n                delta = Math.max(max - prices[i], delta);\\n            }\\n        }\\n        return delta;\\n    }\\n}"
                    },
                    {
                        "username": "Sinan6942069",
                        "content": "I really need to learn how to use less for loops, i always run into problems where they ask me huge questions that are impossible to solve quickly enough with nested loops."
                    },
                    {
                        "username": "krishna3062018",
                        "content": "if you learnt then teach us.."
                    },
                    {
                        "username": "binhope",
                        "content": "The case [6,1,3,2,4,7] which  expected ouput is 6.My output is  7.My solution is,at the second day i buy,and the third day sell,the fourth day buy it ,the sixth day sell it .Why the answer is 6?"
                    },
                    {
                        "username": "user2696u",
                        "content": "prices[2,4,1] should have an answer of 0 shouldn\\'t it?"
                    },
                    {
                        "username": "arurahul16",
                        "content": "No bro , you need to understand \"MAX Profit\" focus on that , you will understand why its not 0."
                    },
                    {
                        "username": "lordrsling",
                        "content": "Tiny hint: \\nYou can go through the prices just once."
                    }
                ]
            },
            {
                "id": 1776027,
                "content": [
                    {
                        "username": "Promethus",
                        "content": "#Intuition#\\n\\nso keep two variables one keeps track of profit and second keeps track of minimum(minCost) value of stock\\n1. initialize profit with zero and minCost to first price\\n2.  then iterate through the array \\n3. we have to check what profit we can get if we sell the stock at that index and is it greater than our previous profits\\n4.  then we need to also check  if current price of stock is less than the minCost we have been keeping track of\\n5. return profit  after iterating overprice array"
                    },
                    {
                        "username": "hborah@ncsu.edu",
                        "content": "![Don't understand the expected answer][1]\\n\\n\\n  [1]: https://s32.postimg.org/m4zfjazol/Screen_Shot_2016_06_22_at_10_29_32_PM.png"
                    },
                    {
                        "username": "aleksandvladiminikol",
                        "content": "looks like that\\'s not easy level :)"
                    },
                    {
                        "username": "Umair9912",
                        "content": "Bro I miss the old location of the discussion tab ;( damn corporate greed."
                    },
                    {
                        "username": "Michael_Teng6",
                        "content": "This is a very good DP problem for beginners."
                    },
                    {
                        "username": "licy_zane",
                        "content": "class Solution {\\n    public int maxProfit(int[] prices) {\\n        int max = 0;\\n        int delta = 0;\\n        for (int i = prices.length-1; i >= 0; i--) {\\n            if (prices[i] >= max) {\\n                max = prices[i];\\n            } else {\\n                delta = Math.max(max - prices[i], delta);\\n            }\\n        }\\n        return delta;\\n    }\\n}"
                    },
                    {
                        "username": "Sinan6942069",
                        "content": "I really need to learn how to use less for loops, i always run into problems where they ask me huge questions that are impossible to solve quickly enough with nested loops."
                    },
                    {
                        "username": "krishna3062018",
                        "content": "if you learnt then teach us.."
                    },
                    {
                        "username": "binhope",
                        "content": "The case [6,1,3,2,4,7] which  expected ouput is 6.My output is  7.My solution is,at the second day i buy,and the third day sell,the fourth day buy it ,the sixth day sell it .Why the answer is 6?"
                    },
                    {
                        "username": "user2696u",
                        "content": "prices[2,4,1] should have an answer of 0 shouldn\\'t it?"
                    },
                    {
                        "username": "arurahul16",
                        "content": "No bro , you need to understand \"MAX Profit\" focus on that , you will understand why its not 0."
                    },
                    {
                        "username": "lordrsling",
                        "content": "Tiny hint: \\nYou can go through the prices just once."
                    }
                ]
            },
            {
                "id": 1668224,
                "content": [
                    {
                        "username": "Promethus",
                        "content": "#Intuition#\\n\\nso keep two variables one keeps track of profit and second keeps track of minimum(minCost) value of stock\\n1. initialize profit with zero and minCost to first price\\n2.  then iterate through the array \\n3. we have to check what profit we can get if we sell the stock at that index and is it greater than our previous profits\\n4.  then we need to also check  if current price of stock is less than the minCost we have been keeping track of\\n5. return profit  after iterating overprice array"
                    },
                    {
                        "username": "hborah@ncsu.edu",
                        "content": "![Don't understand the expected answer][1]\\n\\n\\n  [1]: https://s32.postimg.org/m4zfjazol/Screen_Shot_2016_06_22_at_10_29_32_PM.png"
                    },
                    {
                        "username": "aleksandvladiminikol",
                        "content": "looks like that\\'s not easy level :)"
                    },
                    {
                        "username": "Umair9912",
                        "content": "Bro I miss the old location of the discussion tab ;( damn corporate greed."
                    },
                    {
                        "username": "Michael_Teng6",
                        "content": "This is a very good DP problem for beginners."
                    },
                    {
                        "username": "licy_zane",
                        "content": "class Solution {\\n    public int maxProfit(int[] prices) {\\n        int max = 0;\\n        int delta = 0;\\n        for (int i = prices.length-1; i >= 0; i--) {\\n            if (prices[i] >= max) {\\n                max = prices[i];\\n            } else {\\n                delta = Math.max(max - prices[i], delta);\\n            }\\n        }\\n        return delta;\\n    }\\n}"
                    },
                    {
                        "username": "Sinan6942069",
                        "content": "I really need to learn how to use less for loops, i always run into problems where they ask me huge questions that are impossible to solve quickly enough with nested loops."
                    },
                    {
                        "username": "krishna3062018",
                        "content": "if you learnt then teach us.."
                    },
                    {
                        "username": "binhope",
                        "content": "The case [6,1,3,2,4,7] which  expected ouput is 6.My output is  7.My solution is,at the second day i buy,and the third day sell,the fourth day buy it ,the sixth day sell it .Why the answer is 6?"
                    },
                    {
                        "username": "user2696u",
                        "content": "prices[2,4,1] should have an answer of 0 shouldn\\'t it?"
                    },
                    {
                        "username": "arurahul16",
                        "content": "No bro , you need to understand \"MAX Profit\" focus on that , you will understand why its not 0."
                    },
                    {
                        "username": "lordrsling",
                        "content": "Tiny hint: \\nYou can go through the prices just once."
                    }
                ]
            },
            {
                "id": 1571251,
                "content": [
                    {
                        "username": "Promethus",
                        "content": "#Intuition#\\n\\nso keep two variables one keeps track of profit and second keeps track of minimum(minCost) value of stock\\n1. initialize profit with zero and minCost to first price\\n2.  then iterate through the array \\n3. we have to check what profit we can get if we sell the stock at that index and is it greater than our previous profits\\n4.  then we need to also check  if current price of stock is less than the minCost we have been keeping track of\\n5. return profit  after iterating overprice array"
                    },
                    {
                        "username": "hborah@ncsu.edu",
                        "content": "![Don't understand the expected answer][1]\\n\\n\\n  [1]: https://s32.postimg.org/m4zfjazol/Screen_Shot_2016_06_22_at_10_29_32_PM.png"
                    },
                    {
                        "username": "aleksandvladiminikol",
                        "content": "looks like that\\'s not easy level :)"
                    },
                    {
                        "username": "Umair9912",
                        "content": "Bro I miss the old location of the discussion tab ;( damn corporate greed."
                    },
                    {
                        "username": "Michael_Teng6",
                        "content": "This is a very good DP problem for beginners."
                    },
                    {
                        "username": "licy_zane",
                        "content": "class Solution {\\n    public int maxProfit(int[] prices) {\\n        int max = 0;\\n        int delta = 0;\\n        for (int i = prices.length-1; i >= 0; i--) {\\n            if (prices[i] >= max) {\\n                max = prices[i];\\n            } else {\\n                delta = Math.max(max - prices[i], delta);\\n            }\\n        }\\n        return delta;\\n    }\\n}"
                    },
                    {
                        "username": "Sinan6942069",
                        "content": "I really need to learn how to use less for loops, i always run into problems where they ask me huge questions that are impossible to solve quickly enough with nested loops."
                    },
                    {
                        "username": "krishna3062018",
                        "content": "if you learnt then teach us.."
                    },
                    {
                        "username": "binhope",
                        "content": "The case [6,1,3,2,4,7] which  expected ouput is 6.My output is  7.My solution is,at the second day i buy,and the third day sell,the fourth day buy it ,the sixth day sell it .Why the answer is 6?"
                    },
                    {
                        "username": "user2696u",
                        "content": "prices[2,4,1] should have an answer of 0 shouldn\\'t it?"
                    },
                    {
                        "username": "arurahul16",
                        "content": "No bro , you need to understand \"MAX Profit\" focus on that , you will understand why its not 0."
                    },
                    {
                        "username": "lordrsling",
                        "content": "Tiny hint: \\nYou can go through the prices just once."
                    }
                ]
            },
            {
                "id": 2055422,
                "content": [
                    {
                        "username": "Promethus",
                        "content": "#Intuition#\\n\\nso keep two variables one keeps track of profit and second keeps track of minimum(minCost) value of stock\\n1. initialize profit with zero and minCost to first price\\n2.  then iterate through the array \\n3. we have to check what profit we can get if we sell the stock at that index and is it greater than our previous profits\\n4.  then we need to also check  if current price of stock is less than the minCost we have been keeping track of\\n5. return profit  after iterating overprice array"
                    },
                    {
                        "username": "hborah@ncsu.edu",
                        "content": "![Don't understand the expected answer][1]\\n\\n\\n  [1]: https://s32.postimg.org/m4zfjazol/Screen_Shot_2016_06_22_at_10_29_32_PM.png"
                    },
                    {
                        "username": "aleksandvladiminikol",
                        "content": "looks like that\\'s not easy level :)"
                    },
                    {
                        "username": "Umair9912",
                        "content": "Bro I miss the old location of the discussion tab ;( damn corporate greed."
                    },
                    {
                        "username": "Michael_Teng6",
                        "content": "This is a very good DP problem for beginners."
                    },
                    {
                        "username": "licy_zane",
                        "content": "class Solution {\\n    public int maxProfit(int[] prices) {\\n        int max = 0;\\n        int delta = 0;\\n        for (int i = prices.length-1; i >= 0; i--) {\\n            if (prices[i] >= max) {\\n                max = prices[i];\\n            } else {\\n                delta = Math.max(max - prices[i], delta);\\n            }\\n        }\\n        return delta;\\n    }\\n}"
                    },
                    {
                        "username": "Sinan6942069",
                        "content": "I really need to learn how to use less for loops, i always run into problems where they ask me huge questions that are impossible to solve quickly enough with nested loops."
                    },
                    {
                        "username": "krishna3062018",
                        "content": "if you learnt then teach us.."
                    },
                    {
                        "username": "binhope",
                        "content": "The case [6,1,3,2,4,7] which  expected ouput is 6.My output is  7.My solution is,at the second day i buy,and the third day sell,the fourth day buy it ,the sixth day sell it .Why the answer is 6?"
                    },
                    {
                        "username": "user2696u",
                        "content": "prices[2,4,1] should have an answer of 0 shouldn\\'t it?"
                    },
                    {
                        "username": "arurahul16",
                        "content": "No bro , you need to understand \"MAX Profit\" focus on that , you will understand why its not 0."
                    },
                    {
                        "username": "lordrsling",
                        "content": "Tiny hint: \\nYou can go through the prices just once."
                    }
                ]
            },
            {
                "id": 2018576,
                "content": [
                    {
                        "username": "Promethus",
                        "content": "#Intuition#\\n\\nso keep two variables one keeps track of profit and second keeps track of minimum(minCost) value of stock\\n1. initialize profit with zero and minCost to first price\\n2.  then iterate through the array \\n3. we have to check what profit we can get if we sell the stock at that index and is it greater than our previous profits\\n4.  then we need to also check  if current price of stock is less than the minCost we have been keeping track of\\n5. return profit  after iterating overprice array"
                    },
                    {
                        "username": "hborah@ncsu.edu",
                        "content": "![Don't understand the expected answer][1]\\n\\n\\n  [1]: https://s32.postimg.org/m4zfjazol/Screen_Shot_2016_06_22_at_10_29_32_PM.png"
                    },
                    {
                        "username": "aleksandvladiminikol",
                        "content": "looks like that\\'s not easy level :)"
                    },
                    {
                        "username": "Umair9912",
                        "content": "Bro I miss the old location of the discussion tab ;( damn corporate greed."
                    },
                    {
                        "username": "Michael_Teng6",
                        "content": "This is a very good DP problem for beginners."
                    },
                    {
                        "username": "licy_zane",
                        "content": "class Solution {\\n    public int maxProfit(int[] prices) {\\n        int max = 0;\\n        int delta = 0;\\n        for (int i = prices.length-1; i >= 0; i--) {\\n            if (prices[i] >= max) {\\n                max = prices[i];\\n            } else {\\n                delta = Math.max(max - prices[i], delta);\\n            }\\n        }\\n        return delta;\\n    }\\n}"
                    },
                    {
                        "username": "Sinan6942069",
                        "content": "I really need to learn how to use less for loops, i always run into problems where they ask me huge questions that are impossible to solve quickly enough with nested loops."
                    },
                    {
                        "username": "krishna3062018",
                        "content": "if you learnt then teach us.."
                    },
                    {
                        "username": "binhope",
                        "content": "The case [6,1,3,2,4,7] which  expected ouput is 6.My output is  7.My solution is,at the second day i buy,and the third day sell,the fourth day buy it ,the sixth day sell it .Why the answer is 6?"
                    },
                    {
                        "username": "user2696u",
                        "content": "prices[2,4,1] should have an answer of 0 shouldn\\'t it?"
                    },
                    {
                        "username": "arurahul16",
                        "content": "No bro , you need to understand \"MAX Profit\" focus on that , you will understand why its not 0."
                    },
                    {
                        "username": "lordrsling",
                        "content": "Tiny hint: \\nYou can go through the prices just once."
                    }
                ]
            },
            {
                "id": 1939069,
                "content": [
                    {
                        "username": "avinashsp93",
                        "content": "I think this problem should be categorized as medium and the next problem should be categorized as easy!!"
                    },
                    {
                        "username": "sumeetlalla",
                        "content": "For the testcase 1\\nInput: prices = [7,1,5,3,6,4]\\nOutput: 5\\n\\nHad a query. If we are buying at day 2 then sell it at day 3 we will get a profit of 4 and if we again buy it at day 4 and sell at day 5 we get a profit of 3 so total profit will be 7. If the transaction is single then 5 will come but if we break the buy sell transaction 7 is coming"
                    },
                    {
                        "username": "bparanj",
                        "content": "Your understanding is correct, but the problem statement specifically mentions that you can only make a single transaction, i.e., buy once and sell once. \\n\\nThe problem statement says \"You want to maximize your profit by choosing a single day to buy one stock and choosing a different day in the future to sell that stock.\"\\n\\nSo, you can\\'t buy and sell multiple times. You must decide the best day to buy and the best day to sell to maximize your profit. Hence, the maximum profit for the given input [7,1,5,3,6,4] would be 5 (buy at price 1 and sell at price 6), not 7. \\n\\nIf multiple transactions were allowed, then your approach would be correct, and the maximum profit would indeed be 7. However, that\\'s a different problem altogether."
                    },
                    {
                        "username": "f-rams",
                        "content": "I am encountering Runtime Error on test 198/211. Could it be because I am using a nested loop? "
                    },
                    {
                        "username": "dogukan0101",
                        "content": "I guess it is because of the time complexity. It shouldn\\'t be O(n^2)."
                    },
                    {
                        "username": "ashwinpatel0808",
                        "content": "Time Limit Exceeded after passing 199 test cases, what should I rectify?\\n\\nclass Solution {\\npublic:\\n    int maxProfit(vector<int>& prices) {\\n\\n\\n       int maxnum=INT_MIN;\\n       int current =0;\\n       int st=0;\\n       int en=prices.size()-1;\\n       while(st<prices.size()-1){\\n           if(en==st){\\n               st++;\\n               en=prices.size()-1;\\n           }\\n\\n           else{\\n                current=prices[en]-prices[st];\\n                maxnum=max(maxnum,current);\\n                en--;\\n           }\\n       }\\n       if(maxnum<0){\\n           return 0;\\n       }\\n       return maxnum; \\n    }\\n};"
                    },
                    {
                        "username": "bparanj",
                        "content": "The current approach, in worst-case scenarios, runs in O(n^2) time complexity. This is because for each element in the array, you\\'re scanning all the elements to its right. This could lead to a timeout for larger inputs.\\n\\nHere\\'s an optimized solution with O(n) time complexity:\\n\\n```cpp\\nclass Solution {\\npublic:\\n    int maxProfit(vector<int>& prices) {\\n        int max_profit = 0;\\n        int min_price = prices[0];\\n        \\n        for(int i = 1; i < prices.size(); i++){\\n            if(prices[i] < min_price) {\\n                min_price = prices[i];\\n            } else if(prices[i] - min_price > max_profit) {\\n                max_profit = prices[i] - min_price;\\n            }\\n        }\\n        \\n        return max_profit;\\n    }\\n};\\n```\\n\\nIn this solution, we initialize `min_price` to the first price and `max_profit` to 0. Then, we iterate over the prices from the second price. For each price, we do the following:\\n\\n1. If the current price is less than `min_price`, we update `min_price`.\\n2. If the profit we can get by selling at the current price (which is `prices[i] - min_price`) is more than the current `max_profit`, we update `max_profit`.\\n\\nThis solution works because for each price, we\\'re checking whether we should update our `min_price` and whether selling at the current price would give us a higher profit than any we\\'ve seen before. This ensures that our buy happens before the sell, since we always sell at a price that comes after our `min_price`.\\n\\nThus, this solution is much faster and should not lead to a timeout."
                    },
                    {
                        "username": "htooak2014",
                        "content": "me ,too."
                    },
                    {
                        "username": "Rohith8641",
                        "content": "I have solved this problem with 2 Approaches \\nApproach 1:\\nUsing Auxillary Space\\n1.Initially calculate the maximum right value from right \\n2.Then Iterate through the loop once and calculate the profit.\\n3.Choose the stock which has maximum profit\\nTime Complexity: O(N)\\nAuxillary Space: O(N)\\n----------------------------------------------------------------------\\nApproach 2:\\n1.By Standing over the stock price and calculate the minimum Stock price So far \\nand update it with the maximum Profit.\\n2.Return the Maximum Profit after reaching the end of the Stocks\\n3.It means U need to stand over the price of the stock and calculate the difference between the price of the stock.\\n\\n\\n"
                    },
                    {
                        "username": "Amit_Joe",
                        "content": "test case [3,3]\\nfailed \\nbut in my local machine it give exact output that is  0."
                    },
                    {
                        "username": "alangreg",
                        "content": "I have simillar issue with some other problem. Get error here but on my machine it gives correct answer."
                    },
                    {
                        "username": "t_man",
                        "content": "Hi  everyone,\\nI am really surprised to see that my code has just passed for the custom test case but it\\'s showing error for the same test case when submitted .\\nWhat should I do then?\\n![image](https://assets.leetcode.com/users/images/09fb85df-e144-4726-bdf7-896a62f2f37a_1619278979.3459322.png)\\n"
                    },
                    {
                        "username": "HapticBovine",
                        "content": "Upgrade to Arch Linux :)"
                    },
                    {
                        "username": "undefitied",
                        "content": "I\\'ve got here from the \"Top Interview Questions\" course, and \"Dynamic Programming\" chapter. Can somebody explain me, please, what the problem does in this chapter? Isn\\'t it a simple array-chapter problem?"
                    },
                    {
                        "username": "ronaldabellano",
                        "content": "Input: [7,1,5,3,6,4]\\nOutput: 5\\nExplanation: Buy on day 2 (price = 1) and sell on day 5 (price = 6), profit = 6-1 = 5.\\n             **Not 7-1 = 6, as selling price needs to be larger than buying price.**\\n\\t\\t\\t \\nShould this be that you buy on day 2 and you can\\'t sell it on day 1. Because to how I understand 7-1 selling price on day 1 is 7 is larger than buying price on day 2 which is 1.\\nIt states selling price needs to be larger than buying price which is must be always true to solve the problem."
                    },
                    {
                        "username": "vrushabhshetcr7",
                        "content": "https://www.codemummy.com/2020/08/best-time-to-buy-and-sell-stock.html\\n\\nbest and easiest c++ solution with explanation"
                    }
                ]
            },
            {
                "id": 1893957,
                "content": [
                    {
                        "username": "avinashsp93",
                        "content": "I think this problem should be categorized as medium and the next problem should be categorized as easy!!"
                    },
                    {
                        "username": "sumeetlalla",
                        "content": "For the testcase 1\\nInput: prices = [7,1,5,3,6,4]\\nOutput: 5\\n\\nHad a query. If we are buying at day 2 then sell it at day 3 we will get a profit of 4 and if we again buy it at day 4 and sell at day 5 we get a profit of 3 so total profit will be 7. If the transaction is single then 5 will come but if we break the buy sell transaction 7 is coming"
                    },
                    {
                        "username": "bparanj",
                        "content": "Your understanding is correct, but the problem statement specifically mentions that you can only make a single transaction, i.e., buy once and sell once. \\n\\nThe problem statement says \"You want to maximize your profit by choosing a single day to buy one stock and choosing a different day in the future to sell that stock.\"\\n\\nSo, you can\\'t buy and sell multiple times. You must decide the best day to buy and the best day to sell to maximize your profit. Hence, the maximum profit for the given input [7,1,5,3,6,4] would be 5 (buy at price 1 and sell at price 6), not 7. \\n\\nIf multiple transactions were allowed, then your approach would be correct, and the maximum profit would indeed be 7. However, that\\'s a different problem altogether."
                    },
                    {
                        "username": "f-rams",
                        "content": "I am encountering Runtime Error on test 198/211. Could it be because I am using a nested loop? "
                    },
                    {
                        "username": "dogukan0101",
                        "content": "I guess it is because of the time complexity. It shouldn\\'t be O(n^2)."
                    },
                    {
                        "username": "ashwinpatel0808",
                        "content": "Time Limit Exceeded after passing 199 test cases, what should I rectify?\\n\\nclass Solution {\\npublic:\\n    int maxProfit(vector<int>& prices) {\\n\\n\\n       int maxnum=INT_MIN;\\n       int current =0;\\n       int st=0;\\n       int en=prices.size()-1;\\n       while(st<prices.size()-1){\\n           if(en==st){\\n               st++;\\n               en=prices.size()-1;\\n           }\\n\\n           else{\\n                current=prices[en]-prices[st];\\n                maxnum=max(maxnum,current);\\n                en--;\\n           }\\n       }\\n       if(maxnum<0){\\n           return 0;\\n       }\\n       return maxnum; \\n    }\\n};"
                    },
                    {
                        "username": "bparanj",
                        "content": "The current approach, in worst-case scenarios, runs in O(n^2) time complexity. This is because for each element in the array, you\\'re scanning all the elements to its right. This could lead to a timeout for larger inputs.\\n\\nHere\\'s an optimized solution with O(n) time complexity:\\n\\n```cpp\\nclass Solution {\\npublic:\\n    int maxProfit(vector<int>& prices) {\\n        int max_profit = 0;\\n        int min_price = prices[0];\\n        \\n        for(int i = 1; i < prices.size(); i++){\\n            if(prices[i] < min_price) {\\n                min_price = prices[i];\\n            } else if(prices[i] - min_price > max_profit) {\\n                max_profit = prices[i] - min_price;\\n            }\\n        }\\n        \\n        return max_profit;\\n    }\\n};\\n```\\n\\nIn this solution, we initialize `min_price` to the first price and `max_profit` to 0. Then, we iterate over the prices from the second price. For each price, we do the following:\\n\\n1. If the current price is less than `min_price`, we update `min_price`.\\n2. If the profit we can get by selling at the current price (which is `prices[i] - min_price`) is more than the current `max_profit`, we update `max_profit`.\\n\\nThis solution works because for each price, we\\'re checking whether we should update our `min_price` and whether selling at the current price would give us a higher profit than any we\\'ve seen before. This ensures that our buy happens before the sell, since we always sell at a price that comes after our `min_price`.\\n\\nThus, this solution is much faster and should not lead to a timeout."
                    },
                    {
                        "username": "htooak2014",
                        "content": "me ,too."
                    },
                    {
                        "username": "Rohith8641",
                        "content": "I have solved this problem with 2 Approaches \\nApproach 1:\\nUsing Auxillary Space\\n1.Initially calculate the maximum right value from right \\n2.Then Iterate through the loop once and calculate the profit.\\n3.Choose the stock which has maximum profit\\nTime Complexity: O(N)\\nAuxillary Space: O(N)\\n----------------------------------------------------------------------\\nApproach 2:\\n1.By Standing over the stock price and calculate the minimum Stock price So far \\nand update it with the maximum Profit.\\n2.Return the Maximum Profit after reaching the end of the Stocks\\n3.It means U need to stand over the price of the stock and calculate the difference between the price of the stock.\\n\\n\\n"
                    },
                    {
                        "username": "Amit_Joe",
                        "content": "test case [3,3]\\nfailed \\nbut in my local machine it give exact output that is  0."
                    },
                    {
                        "username": "alangreg",
                        "content": "I have simillar issue with some other problem. Get error here but on my machine it gives correct answer."
                    },
                    {
                        "username": "t_man",
                        "content": "Hi  everyone,\\nI am really surprised to see that my code has just passed for the custom test case but it\\'s showing error for the same test case when submitted .\\nWhat should I do then?\\n![image](https://assets.leetcode.com/users/images/09fb85df-e144-4726-bdf7-896a62f2f37a_1619278979.3459322.png)\\n"
                    },
                    {
                        "username": "HapticBovine",
                        "content": "Upgrade to Arch Linux :)"
                    },
                    {
                        "username": "undefitied",
                        "content": "I\\'ve got here from the \"Top Interview Questions\" course, and \"Dynamic Programming\" chapter. Can somebody explain me, please, what the problem does in this chapter? Isn\\'t it a simple array-chapter problem?"
                    },
                    {
                        "username": "ronaldabellano",
                        "content": "Input: [7,1,5,3,6,4]\\nOutput: 5\\nExplanation: Buy on day 2 (price = 1) and sell on day 5 (price = 6), profit = 6-1 = 5.\\n             **Not 7-1 = 6, as selling price needs to be larger than buying price.**\\n\\t\\t\\t \\nShould this be that you buy on day 2 and you can\\'t sell it on day 1. Because to how I understand 7-1 selling price on day 1 is 7 is larger than buying price on day 2 which is 1.\\nIt states selling price needs to be larger than buying price which is must be always true to solve the problem."
                    },
                    {
                        "username": "vrushabhshetcr7",
                        "content": "https://www.codemummy.com/2020/08/best-time-to-buy-and-sell-stock.html\\n\\nbest and easiest c++ solution with explanation"
                    }
                ]
            },
            {
                "id": 1859704,
                "content": [
                    {
                        "username": "avinashsp93",
                        "content": "I think this problem should be categorized as medium and the next problem should be categorized as easy!!"
                    },
                    {
                        "username": "sumeetlalla",
                        "content": "For the testcase 1\\nInput: prices = [7,1,5,3,6,4]\\nOutput: 5\\n\\nHad a query. If we are buying at day 2 then sell it at day 3 we will get a profit of 4 and if we again buy it at day 4 and sell at day 5 we get a profit of 3 so total profit will be 7. If the transaction is single then 5 will come but if we break the buy sell transaction 7 is coming"
                    },
                    {
                        "username": "bparanj",
                        "content": "Your understanding is correct, but the problem statement specifically mentions that you can only make a single transaction, i.e., buy once and sell once. \\n\\nThe problem statement says \"You want to maximize your profit by choosing a single day to buy one stock and choosing a different day in the future to sell that stock.\"\\n\\nSo, you can\\'t buy and sell multiple times. You must decide the best day to buy and the best day to sell to maximize your profit. Hence, the maximum profit for the given input [7,1,5,3,6,4] would be 5 (buy at price 1 and sell at price 6), not 7. \\n\\nIf multiple transactions were allowed, then your approach would be correct, and the maximum profit would indeed be 7. However, that\\'s a different problem altogether."
                    },
                    {
                        "username": "f-rams",
                        "content": "I am encountering Runtime Error on test 198/211. Could it be because I am using a nested loop? "
                    },
                    {
                        "username": "dogukan0101",
                        "content": "I guess it is because of the time complexity. It shouldn\\'t be O(n^2)."
                    },
                    {
                        "username": "ashwinpatel0808",
                        "content": "Time Limit Exceeded after passing 199 test cases, what should I rectify?\\n\\nclass Solution {\\npublic:\\n    int maxProfit(vector<int>& prices) {\\n\\n\\n       int maxnum=INT_MIN;\\n       int current =0;\\n       int st=0;\\n       int en=prices.size()-1;\\n       while(st<prices.size()-1){\\n           if(en==st){\\n               st++;\\n               en=prices.size()-1;\\n           }\\n\\n           else{\\n                current=prices[en]-prices[st];\\n                maxnum=max(maxnum,current);\\n                en--;\\n           }\\n       }\\n       if(maxnum<0){\\n           return 0;\\n       }\\n       return maxnum; \\n    }\\n};"
                    },
                    {
                        "username": "bparanj",
                        "content": "The current approach, in worst-case scenarios, runs in O(n^2) time complexity. This is because for each element in the array, you\\'re scanning all the elements to its right. This could lead to a timeout for larger inputs.\\n\\nHere\\'s an optimized solution with O(n) time complexity:\\n\\n```cpp\\nclass Solution {\\npublic:\\n    int maxProfit(vector<int>& prices) {\\n        int max_profit = 0;\\n        int min_price = prices[0];\\n        \\n        for(int i = 1; i < prices.size(); i++){\\n            if(prices[i] < min_price) {\\n                min_price = prices[i];\\n            } else if(prices[i] - min_price > max_profit) {\\n                max_profit = prices[i] - min_price;\\n            }\\n        }\\n        \\n        return max_profit;\\n    }\\n};\\n```\\n\\nIn this solution, we initialize `min_price` to the first price and `max_profit` to 0. Then, we iterate over the prices from the second price. For each price, we do the following:\\n\\n1. If the current price is less than `min_price`, we update `min_price`.\\n2. If the profit we can get by selling at the current price (which is `prices[i] - min_price`) is more than the current `max_profit`, we update `max_profit`.\\n\\nThis solution works because for each price, we\\'re checking whether we should update our `min_price` and whether selling at the current price would give us a higher profit than any we\\'ve seen before. This ensures that our buy happens before the sell, since we always sell at a price that comes after our `min_price`.\\n\\nThus, this solution is much faster and should not lead to a timeout."
                    },
                    {
                        "username": "htooak2014",
                        "content": "me ,too."
                    },
                    {
                        "username": "Rohith8641",
                        "content": "I have solved this problem with 2 Approaches \\nApproach 1:\\nUsing Auxillary Space\\n1.Initially calculate the maximum right value from right \\n2.Then Iterate through the loop once and calculate the profit.\\n3.Choose the stock which has maximum profit\\nTime Complexity: O(N)\\nAuxillary Space: O(N)\\n----------------------------------------------------------------------\\nApproach 2:\\n1.By Standing over the stock price and calculate the minimum Stock price So far \\nand update it with the maximum Profit.\\n2.Return the Maximum Profit after reaching the end of the Stocks\\n3.It means U need to stand over the price of the stock and calculate the difference between the price of the stock.\\n\\n\\n"
                    },
                    {
                        "username": "Amit_Joe",
                        "content": "test case [3,3]\\nfailed \\nbut in my local machine it give exact output that is  0."
                    },
                    {
                        "username": "alangreg",
                        "content": "I have simillar issue with some other problem. Get error here but on my machine it gives correct answer."
                    },
                    {
                        "username": "t_man",
                        "content": "Hi  everyone,\\nI am really surprised to see that my code has just passed for the custom test case but it\\'s showing error for the same test case when submitted .\\nWhat should I do then?\\n![image](https://assets.leetcode.com/users/images/09fb85df-e144-4726-bdf7-896a62f2f37a_1619278979.3459322.png)\\n"
                    },
                    {
                        "username": "HapticBovine",
                        "content": "Upgrade to Arch Linux :)"
                    },
                    {
                        "username": "undefitied",
                        "content": "I\\'ve got here from the \"Top Interview Questions\" course, and \"Dynamic Programming\" chapter. Can somebody explain me, please, what the problem does in this chapter? Isn\\'t it a simple array-chapter problem?"
                    },
                    {
                        "username": "ronaldabellano",
                        "content": "Input: [7,1,5,3,6,4]\\nOutput: 5\\nExplanation: Buy on day 2 (price = 1) and sell on day 5 (price = 6), profit = 6-1 = 5.\\n             **Not 7-1 = 6, as selling price needs to be larger than buying price.**\\n\\t\\t\\t \\nShould this be that you buy on day 2 and you can\\'t sell it on day 1. Because to how I understand 7-1 selling price on day 1 is 7 is larger than buying price on day 2 which is 1.\\nIt states selling price needs to be larger than buying price which is must be always true to solve the problem."
                    },
                    {
                        "username": "vrushabhshetcr7",
                        "content": "https://www.codemummy.com/2020/08/best-time-to-buy-and-sell-stock.html\\n\\nbest and easiest c++ solution with explanation"
                    }
                ]
            },
            {
                "id": 1749296,
                "content": [
                    {
                        "username": "avinashsp93",
                        "content": "I think this problem should be categorized as medium and the next problem should be categorized as easy!!"
                    },
                    {
                        "username": "sumeetlalla",
                        "content": "For the testcase 1\\nInput: prices = [7,1,5,3,6,4]\\nOutput: 5\\n\\nHad a query. If we are buying at day 2 then sell it at day 3 we will get a profit of 4 and if we again buy it at day 4 and sell at day 5 we get a profit of 3 so total profit will be 7. If the transaction is single then 5 will come but if we break the buy sell transaction 7 is coming"
                    },
                    {
                        "username": "bparanj",
                        "content": "Your understanding is correct, but the problem statement specifically mentions that you can only make a single transaction, i.e., buy once and sell once. \\n\\nThe problem statement says \"You want to maximize your profit by choosing a single day to buy one stock and choosing a different day in the future to sell that stock.\"\\n\\nSo, you can\\'t buy and sell multiple times. You must decide the best day to buy and the best day to sell to maximize your profit. Hence, the maximum profit for the given input [7,1,5,3,6,4] would be 5 (buy at price 1 and sell at price 6), not 7. \\n\\nIf multiple transactions were allowed, then your approach would be correct, and the maximum profit would indeed be 7. However, that\\'s a different problem altogether."
                    },
                    {
                        "username": "f-rams",
                        "content": "I am encountering Runtime Error on test 198/211. Could it be because I am using a nested loop? "
                    },
                    {
                        "username": "dogukan0101",
                        "content": "I guess it is because of the time complexity. It shouldn\\'t be O(n^2)."
                    },
                    {
                        "username": "ashwinpatel0808",
                        "content": "Time Limit Exceeded after passing 199 test cases, what should I rectify?\\n\\nclass Solution {\\npublic:\\n    int maxProfit(vector<int>& prices) {\\n\\n\\n       int maxnum=INT_MIN;\\n       int current =0;\\n       int st=0;\\n       int en=prices.size()-1;\\n       while(st<prices.size()-1){\\n           if(en==st){\\n               st++;\\n               en=prices.size()-1;\\n           }\\n\\n           else{\\n                current=prices[en]-prices[st];\\n                maxnum=max(maxnum,current);\\n                en--;\\n           }\\n       }\\n       if(maxnum<0){\\n           return 0;\\n       }\\n       return maxnum; \\n    }\\n};"
                    },
                    {
                        "username": "bparanj",
                        "content": "The current approach, in worst-case scenarios, runs in O(n^2) time complexity. This is because for each element in the array, you\\'re scanning all the elements to its right. This could lead to a timeout for larger inputs.\\n\\nHere\\'s an optimized solution with O(n) time complexity:\\n\\n```cpp\\nclass Solution {\\npublic:\\n    int maxProfit(vector<int>& prices) {\\n        int max_profit = 0;\\n        int min_price = prices[0];\\n        \\n        for(int i = 1; i < prices.size(); i++){\\n            if(prices[i] < min_price) {\\n                min_price = prices[i];\\n            } else if(prices[i] - min_price > max_profit) {\\n                max_profit = prices[i] - min_price;\\n            }\\n        }\\n        \\n        return max_profit;\\n    }\\n};\\n```\\n\\nIn this solution, we initialize `min_price` to the first price and `max_profit` to 0. Then, we iterate over the prices from the second price. For each price, we do the following:\\n\\n1. If the current price is less than `min_price`, we update `min_price`.\\n2. If the profit we can get by selling at the current price (which is `prices[i] - min_price`) is more than the current `max_profit`, we update `max_profit`.\\n\\nThis solution works because for each price, we\\'re checking whether we should update our `min_price` and whether selling at the current price would give us a higher profit than any we\\'ve seen before. This ensures that our buy happens before the sell, since we always sell at a price that comes after our `min_price`.\\n\\nThus, this solution is much faster and should not lead to a timeout."
                    },
                    {
                        "username": "htooak2014",
                        "content": "me ,too."
                    },
                    {
                        "username": "Rohith8641",
                        "content": "I have solved this problem with 2 Approaches \\nApproach 1:\\nUsing Auxillary Space\\n1.Initially calculate the maximum right value from right \\n2.Then Iterate through the loop once and calculate the profit.\\n3.Choose the stock which has maximum profit\\nTime Complexity: O(N)\\nAuxillary Space: O(N)\\n----------------------------------------------------------------------\\nApproach 2:\\n1.By Standing over the stock price and calculate the minimum Stock price So far \\nand update it with the maximum Profit.\\n2.Return the Maximum Profit after reaching the end of the Stocks\\n3.It means U need to stand over the price of the stock and calculate the difference between the price of the stock.\\n\\n\\n"
                    },
                    {
                        "username": "Amit_Joe",
                        "content": "test case [3,3]\\nfailed \\nbut in my local machine it give exact output that is  0."
                    },
                    {
                        "username": "alangreg",
                        "content": "I have simillar issue with some other problem. Get error here but on my machine it gives correct answer."
                    },
                    {
                        "username": "t_man",
                        "content": "Hi  everyone,\\nI am really surprised to see that my code has just passed for the custom test case but it\\'s showing error for the same test case when submitted .\\nWhat should I do then?\\n![image](https://assets.leetcode.com/users/images/09fb85df-e144-4726-bdf7-896a62f2f37a_1619278979.3459322.png)\\n"
                    },
                    {
                        "username": "HapticBovine",
                        "content": "Upgrade to Arch Linux :)"
                    },
                    {
                        "username": "undefitied",
                        "content": "I\\'ve got here from the \"Top Interview Questions\" course, and \"Dynamic Programming\" chapter. Can somebody explain me, please, what the problem does in this chapter? Isn\\'t it a simple array-chapter problem?"
                    },
                    {
                        "username": "ronaldabellano",
                        "content": "Input: [7,1,5,3,6,4]\\nOutput: 5\\nExplanation: Buy on day 2 (price = 1) and sell on day 5 (price = 6), profit = 6-1 = 5.\\n             **Not 7-1 = 6, as selling price needs to be larger than buying price.**\\n\\t\\t\\t \\nShould this be that you buy on day 2 and you can\\'t sell it on day 1. Because to how I understand 7-1 selling price on day 1 is 7 is larger than buying price on day 2 which is 1.\\nIt states selling price needs to be larger than buying price which is must be always true to solve the problem."
                    },
                    {
                        "username": "vrushabhshetcr7",
                        "content": "https://www.codemummy.com/2020/08/best-time-to-buy-and-sell-stock.html\\n\\nbest and easiest c++ solution with explanation"
                    }
                ]
            },
            {
                "id": 1721198,
                "content": [
                    {
                        "username": "avinashsp93",
                        "content": "I think this problem should be categorized as medium and the next problem should be categorized as easy!!"
                    },
                    {
                        "username": "sumeetlalla",
                        "content": "For the testcase 1\\nInput: prices = [7,1,5,3,6,4]\\nOutput: 5\\n\\nHad a query. If we are buying at day 2 then sell it at day 3 we will get a profit of 4 and if we again buy it at day 4 and sell at day 5 we get a profit of 3 so total profit will be 7. If the transaction is single then 5 will come but if we break the buy sell transaction 7 is coming"
                    },
                    {
                        "username": "bparanj",
                        "content": "Your understanding is correct, but the problem statement specifically mentions that you can only make a single transaction, i.e., buy once and sell once. \\n\\nThe problem statement says \"You want to maximize your profit by choosing a single day to buy one stock and choosing a different day in the future to sell that stock.\"\\n\\nSo, you can\\'t buy and sell multiple times. You must decide the best day to buy and the best day to sell to maximize your profit. Hence, the maximum profit for the given input [7,1,5,3,6,4] would be 5 (buy at price 1 and sell at price 6), not 7. \\n\\nIf multiple transactions were allowed, then your approach would be correct, and the maximum profit would indeed be 7. However, that\\'s a different problem altogether."
                    },
                    {
                        "username": "f-rams",
                        "content": "I am encountering Runtime Error on test 198/211. Could it be because I am using a nested loop? "
                    },
                    {
                        "username": "dogukan0101",
                        "content": "I guess it is because of the time complexity. It shouldn\\'t be O(n^2)."
                    },
                    {
                        "username": "ashwinpatel0808",
                        "content": "Time Limit Exceeded after passing 199 test cases, what should I rectify?\\n\\nclass Solution {\\npublic:\\n    int maxProfit(vector<int>& prices) {\\n\\n\\n       int maxnum=INT_MIN;\\n       int current =0;\\n       int st=0;\\n       int en=prices.size()-1;\\n       while(st<prices.size()-1){\\n           if(en==st){\\n               st++;\\n               en=prices.size()-1;\\n           }\\n\\n           else{\\n                current=prices[en]-prices[st];\\n                maxnum=max(maxnum,current);\\n                en--;\\n           }\\n       }\\n       if(maxnum<0){\\n           return 0;\\n       }\\n       return maxnum; \\n    }\\n};"
                    },
                    {
                        "username": "bparanj",
                        "content": "The current approach, in worst-case scenarios, runs in O(n^2) time complexity. This is because for each element in the array, you\\'re scanning all the elements to its right. This could lead to a timeout for larger inputs.\\n\\nHere\\'s an optimized solution with O(n) time complexity:\\n\\n```cpp\\nclass Solution {\\npublic:\\n    int maxProfit(vector<int>& prices) {\\n        int max_profit = 0;\\n        int min_price = prices[0];\\n        \\n        for(int i = 1; i < prices.size(); i++){\\n            if(prices[i] < min_price) {\\n                min_price = prices[i];\\n            } else if(prices[i] - min_price > max_profit) {\\n                max_profit = prices[i] - min_price;\\n            }\\n        }\\n        \\n        return max_profit;\\n    }\\n};\\n```\\n\\nIn this solution, we initialize `min_price` to the first price and `max_profit` to 0. Then, we iterate over the prices from the second price. For each price, we do the following:\\n\\n1. If the current price is less than `min_price`, we update `min_price`.\\n2. If the profit we can get by selling at the current price (which is `prices[i] - min_price`) is more than the current `max_profit`, we update `max_profit`.\\n\\nThis solution works because for each price, we\\'re checking whether we should update our `min_price` and whether selling at the current price would give us a higher profit than any we\\'ve seen before. This ensures that our buy happens before the sell, since we always sell at a price that comes after our `min_price`.\\n\\nThus, this solution is much faster and should not lead to a timeout."
                    },
                    {
                        "username": "htooak2014",
                        "content": "me ,too."
                    },
                    {
                        "username": "Rohith8641",
                        "content": "I have solved this problem with 2 Approaches \\nApproach 1:\\nUsing Auxillary Space\\n1.Initially calculate the maximum right value from right \\n2.Then Iterate through the loop once and calculate the profit.\\n3.Choose the stock which has maximum profit\\nTime Complexity: O(N)\\nAuxillary Space: O(N)\\n----------------------------------------------------------------------\\nApproach 2:\\n1.By Standing over the stock price and calculate the minimum Stock price So far \\nand update it with the maximum Profit.\\n2.Return the Maximum Profit after reaching the end of the Stocks\\n3.It means U need to stand over the price of the stock and calculate the difference between the price of the stock.\\n\\n\\n"
                    },
                    {
                        "username": "Amit_Joe",
                        "content": "test case [3,3]\\nfailed \\nbut in my local machine it give exact output that is  0."
                    },
                    {
                        "username": "alangreg",
                        "content": "I have simillar issue with some other problem. Get error here but on my machine it gives correct answer."
                    },
                    {
                        "username": "t_man",
                        "content": "Hi  everyone,\\nI am really surprised to see that my code has just passed for the custom test case but it\\'s showing error for the same test case when submitted .\\nWhat should I do then?\\n![image](https://assets.leetcode.com/users/images/09fb85df-e144-4726-bdf7-896a62f2f37a_1619278979.3459322.png)\\n"
                    },
                    {
                        "username": "HapticBovine",
                        "content": "Upgrade to Arch Linux :)"
                    },
                    {
                        "username": "undefitied",
                        "content": "I\\'ve got here from the \"Top Interview Questions\" course, and \"Dynamic Programming\" chapter. Can somebody explain me, please, what the problem does in this chapter? Isn\\'t it a simple array-chapter problem?"
                    },
                    {
                        "username": "ronaldabellano",
                        "content": "Input: [7,1,5,3,6,4]\\nOutput: 5\\nExplanation: Buy on day 2 (price = 1) and sell on day 5 (price = 6), profit = 6-1 = 5.\\n             **Not 7-1 = 6, as selling price needs to be larger than buying price.**\\n\\t\\t\\t \\nShould this be that you buy on day 2 and you can\\'t sell it on day 1. Because to how I understand 7-1 selling price on day 1 is 7 is larger than buying price on day 2 which is 1.\\nIt states selling price needs to be larger than buying price which is must be always true to solve the problem."
                    },
                    {
                        "username": "vrushabhshetcr7",
                        "content": "https://www.codemummy.com/2020/08/best-time-to-buy-and-sell-stock.html\\n\\nbest and easiest c++ solution with explanation"
                    }
                ]
            },
            {
                "id": 1676300,
                "content": [
                    {
                        "username": "avinashsp93",
                        "content": "I think this problem should be categorized as medium and the next problem should be categorized as easy!!"
                    },
                    {
                        "username": "sumeetlalla",
                        "content": "For the testcase 1\\nInput: prices = [7,1,5,3,6,4]\\nOutput: 5\\n\\nHad a query. If we are buying at day 2 then sell it at day 3 we will get a profit of 4 and if we again buy it at day 4 and sell at day 5 we get a profit of 3 so total profit will be 7. If the transaction is single then 5 will come but if we break the buy sell transaction 7 is coming"
                    },
                    {
                        "username": "bparanj",
                        "content": "Your understanding is correct, but the problem statement specifically mentions that you can only make a single transaction, i.e., buy once and sell once. \\n\\nThe problem statement says \"You want to maximize your profit by choosing a single day to buy one stock and choosing a different day in the future to sell that stock.\"\\n\\nSo, you can\\'t buy and sell multiple times. You must decide the best day to buy and the best day to sell to maximize your profit. Hence, the maximum profit for the given input [7,1,5,3,6,4] would be 5 (buy at price 1 and sell at price 6), not 7. \\n\\nIf multiple transactions were allowed, then your approach would be correct, and the maximum profit would indeed be 7. However, that\\'s a different problem altogether."
                    },
                    {
                        "username": "f-rams",
                        "content": "I am encountering Runtime Error on test 198/211. Could it be because I am using a nested loop? "
                    },
                    {
                        "username": "dogukan0101",
                        "content": "I guess it is because of the time complexity. It shouldn\\'t be O(n^2)."
                    },
                    {
                        "username": "ashwinpatel0808",
                        "content": "Time Limit Exceeded after passing 199 test cases, what should I rectify?\\n\\nclass Solution {\\npublic:\\n    int maxProfit(vector<int>& prices) {\\n\\n\\n       int maxnum=INT_MIN;\\n       int current =0;\\n       int st=0;\\n       int en=prices.size()-1;\\n       while(st<prices.size()-1){\\n           if(en==st){\\n               st++;\\n               en=prices.size()-1;\\n           }\\n\\n           else{\\n                current=prices[en]-prices[st];\\n                maxnum=max(maxnum,current);\\n                en--;\\n           }\\n       }\\n       if(maxnum<0){\\n           return 0;\\n       }\\n       return maxnum; \\n    }\\n};"
                    },
                    {
                        "username": "bparanj",
                        "content": "The current approach, in worst-case scenarios, runs in O(n^2) time complexity. This is because for each element in the array, you\\'re scanning all the elements to its right. This could lead to a timeout for larger inputs.\\n\\nHere\\'s an optimized solution with O(n) time complexity:\\n\\n```cpp\\nclass Solution {\\npublic:\\n    int maxProfit(vector<int>& prices) {\\n        int max_profit = 0;\\n        int min_price = prices[0];\\n        \\n        for(int i = 1; i < prices.size(); i++){\\n            if(prices[i] < min_price) {\\n                min_price = prices[i];\\n            } else if(prices[i] - min_price > max_profit) {\\n                max_profit = prices[i] - min_price;\\n            }\\n        }\\n        \\n        return max_profit;\\n    }\\n};\\n```\\n\\nIn this solution, we initialize `min_price` to the first price and `max_profit` to 0. Then, we iterate over the prices from the second price. For each price, we do the following:\\n\\n1. If the current price is less than `min_price`, we update `min_price`.\\n2. If the profit we can get by selling at the current price (which is `prices[i] - min_price`) is more than the current `max_profit`, we update `max_profit`.\\n\\nThis solution works because for each price, we\\'re checking whether we should update our `min_price` and whether selling at the current price would give us a higher profit than any we\\'ve seen before. This ensures that our buy happens before the sell, since we always sell at a price that comes after our `min_price`.\\n\\nThus, this solution is much faster and should not lead to a timeout."
                    },
                    {
                        "username": "htooak2014",
                        "content": "me ,too."
                    },
                    {
                        "username": "Rohith8641",
                        "content": "I have solved this problem with 2 Approaches \\nApproach 1:\\nUsing Auxillary Space\\n1.Initially calculate the maximum right value from right \\n2.Then Iterate through the loop once and calculate the profit.\\n3.Choose the stock which has maximum profit\\nTime Complexity: O(N)\\nAuxillary Space: O(N)\\n----------------------------------------------------------------------\\nApproach 2:\\n1.By Standing over the stock price and calculate the minimum Stock price So far \\nand update it with the maximum Profit.\\n2.Return the Maximum Profit after reaching the end of the Stocks\\n3.It means U need to stand over the price of the stock and calculate the difference between the price of the stock.\\n\\n\\n"
                    },
                    {
                        "username": "Amit_Joe",
                        "content": "test case [3,3]\\nfailed \\nbut in my local machine it give exact output that is  0."
                    },
                    {
                        "username": "alangreg",
                        "content": "I have simillar issue with some other problem. Get error here but on my machine it gives correct answer."
                    },
                    {
                        "username": "t_man",
                        "content": "Hi  everyone,\\nI am really surprised to see that my code has just passed for the custom test case but it\\'s showing error for the same test case when submitted .\\nWhat should I do then?\\n![image](https://assets.leetcode.com/users/images/09fb85df-e144-4726-bdf7-896a62f2f37a_1619278979.3459322.png)\\n"
                    },
                    {
                        "username": "HapticBovine",
                        "content": "Upgrade to Arch Linux :)"
                    },
                    {
                        "username": "undefitied",
                        "content": "I\\'ve got here from the \"Top Interview Questions\" course, and \"Dynamic Programming\" chapter. Can somebody explain me, please, what the problem does in this chapter? Isn\\'t it a simple array-chapter problem?"
                    },
                    {
                        "username": "ronaldabellano",
                        "content": "Input: [7,1,5,3,6,4]\\nOutput: 5\\nExplanation: Buy on day 2 (price = 1) and sell on day 5 (price = 6), profit = 6-1 = 5.\\n             **Not 7-1 = 6, as selling price needs to be larger than buying price.**\\n\\t\\t\\t \\nShould this be that you buy on day 2 and you can\\'t sell it on day 1. Because to how I understand 7-1 selling price on day 1 is 7 is larger than buying price on day 2 which is 1.\\nIt states selling price needs to be larger than buying price which is must be always true to solve the problem."
                    },
                    {
                        "username": "vrushabhshetcr7",
                        "content": "https://www.codemummy.com/2020/08/best-time-to-buy-and-sell-stock.html\\n\\nbest and easiest c++ solution with explanation"
                    }
                ]
            },
            {
                "id": 1575175,
                "content": [
                    {
                        "username": "avinashsp93",
                        "content": "I think this problem should be categorized as medium and the next problem should be categorized as easy!!"
                    },
                    {
                        "username": "sumeetlalla",
                        "content": "For the testcase 1\\nInput: prices = [7,1,5,3,6,4]\\nOutput: 5\\n\\nHad a query. If we are buying at day 2 then sell it at day 3 we will get a profit of 4 and if we again buy it at day 4 and sell at day 5 we get a profit of 3 so total profit will be 7. If the transaction is single then 5 will come but if we break the buy sell transaction 7 is coming"
                    },
                    {
                        "username": "bparanj",
                        "content": "Your understanding is correct, but the problem statement specifically mentions that you can only make a single transaction, i.e., buy once and sell once. \\n\\nThe problem statement says \"You want to maximize your profit by choosing a single day to buy one stock and choosing a different day in the future to sell that stock.\"\\n\\nSo, you can\\'t buy and sell multiple times. You must decide the best day to buy and the best day to sell to maximize your profit. Hence, the maximum profit for the given input [7,1,5,3,6,4] would be 5 (buy at price 1 and sell at price 6), not 7. \\n\\nIf multiple transactions were allowed, then your approach would be correct, and the maximum profit would indeed be 7. However, that\\'s a different problem altogether."
                    },
                    {
                        "username": "f-rams",
                        "content": "I am encountering Runtime Error on test 198/211. Could it be because I am using a nested loop? "
                    },
                    {
                        "username": "dogukan0101",
                        "content": "I guess it is because of the time complexity. It shouldn\\'t be O(n^2)."
                    },
                    {
                        "username": "ashwinpatel0808",
                        "content": "Time Limit Exceeded after passing 199 test cases, what should I rectify?\\n\\nclass Solution {\\npublic:\\n    int maxProfit(vector<int>& prices) {\\n\\n\\n       int maxnum=INT_MIN;\\n       int current =0;\\n       int st=0;\\n       int en=prices.size()-1;\\n       while(st<prices.size()-1){\\n           if(en==st){\\n               st++;\\n               en=prices.size()-1;\\n           }\\n\\n           else{\\n                current=prices[en]-prices[st];\\n                maxnum=max(maxnum,current);\\n                en--;\\n           }\\n       }\\n       if(maxnum<0){\\n           return 0;\\n       }\\n       return maxnum; \\n    }\\n};"
                    },
                    {
                        "username": "bparanj",
                        "content": "The current approach, in worst-case scenarios, runs in O(n^2) time complexity. This is because for each element in the array, you\\'re scanning all the elements to its right. This could lead to a timeout for larger inputs.\\n\\nHere\\'s an optimized solution with O(n) time complexity:\\n\\n```cpp\\nclass Solution {\\npublic:\\n    int maxProfit(vector<int>& prices) {\\n        int max_profit = 0;\\n        int min_price = prices[0];\\n        \\n        for(int i = 1; i < prices.size(); i++){\\n            if(prices[i] < min_price) {\\n                min_price = prices[i];\\n            } else if(prices[i] - min_price > max_profit) {\\n                max_profit = prices[i] - min_price;\\n            }\\n        }\\n        \\n        return max_profit;\\n    }\\n};\\n```\\n\\nIn this solution, we initialize `min_price` to the first price and `max_profit` to 0. Then, we iterate over the prices from the second price. For each price, we do the following:\\n\\n1. If the current price is less than `min_price`, we update `min_price`.\\n2. If the profit we can get by selling at the current price (which is `prices[i] - min_price`) is more than the current `max_profit`, we update `max_profit`.\\n\\nThis solution works because for each price, we\\'re checking whether we should update our `min_price` and whether selling at the current price would give us a higher profit than any we\\'ve seen before. This ensures that our buy happens before the sell, since we always sell at a price that comes after our `min_price`.\\n\\nThus, this solution is much faster and should not lead to a timeout."
                    },
                    {
                        "username": "htooak2014",
                        "content": "me ,too."
                    },
                    {
                        "username": "Rohith8641",
                        "content": "I have solved this problem with 2 Approaches \\nApproach 1:\\nUsing Auxillary Space\\n1.Initially calculate the maximum right value from right \\n2.Then Iterate through the loop once and calculate the profit.\\n3.Choose the stock which has maximum profit\\nTime Complexity: O(N)\\nAuxillary Space: O(N)\\n----------------------------------------------------------------------\\nApproach 2:\\n1.By Standing over the stock price and calculate the minimum Stock price So far \\nand update it with the maximum Profit.\\n2.Return the Maximum Profit after reaching the end of the Stocks\\n3.It means U need to stand over the price of the stock and calculate the difference between the price of the stock.\\n\\n\\n"
                    },
                    {
                        "username": "Amit_Joe",
                        "content": "test case [3,3]\\nfailed \\nbut in my local machine it give exact output that is  0."
                    },
                    {
                        "username": "alangreg",
                        "content": "I have simillar issue with some other problem. Get error here but on my machine it gives correct answer."
                    },
                    {
                        "username": "t_man",
                        "content": "Hi  everyone,\\nI am really surprised to see that my code has just passed for the custom test case but it\\'s showing error for the same test case when submitted .\\nWhat should I do then?\\n![image](https://assets.leetcode.com/users/images/09fb85df-e144-4726-bdf7-896a62f2f37a_1619278979.3459322.png)\\n"
                    },
                    {
                        "username": "HapticBovine",
                        "content": "Upgrade to Arch Linux :)"
                    },
                    {
                        "username": "undefitied",
                        "content": "I\\'ve got here from the \"Top Interview Questions\" course, and \"Dynamic Programming\" chapter. Can somebody explain me, please, what the problem does in this chapter? Isn\\'t it a simple array-chapter problem?"
                    },
                    {
                        "username": "ronaldabellano",
                        "content": "Input: [7,1,5,3,6,4]\\nOutput: 5\\nExplanation: Buy on day 2 (price = 1) and sell on day 5 (price = 6), profit = 6-1 = 5.\\n             **Not 7-1 = 6, as selling price needs to be larger than buying price.**\\n\\t\\t\\t \\nShould this be that you buy on day 2 and you can\\'t sell it on day 1. Because to how I understand 7-1 selling price on day 1 is 7 is larger than buying price on day 2 which is 1.\\nIt states selling price needs to be larger than buying price which is must be always true to solve the problem."
                    },
                    {
                        "username": "vrushabhshetcr7",
                        "content": "https://www.codemummy.com/2020/08/best-time-to-buy-and-sell-stock.html\\n\\nbest and easiest c++ solution with explanation"
                    }
                ]
            },
            {
                "id": 1573229,
                "content": [
                    {
                        "username": "avinashsp93",
                        "content": "I think this problem should be categorized as medium and the next problem should be categorized as easy!!"
                    },
                    {
                        "username": "sumeetlalla",
                        "content": "For the testcase 1\\nInput: prices = [7,1,5,3,6,4]\\nOutput: 5\\n\\nHad a query. If we are buying at day 2 then sell it at day 3 we will get a profit of 4 and if we again buy it at day 4 and sell at day 5 we get a profit of 3 so total profit will be 7. If the transaction is single then 5 will come but if we break the buy sell transaction 7 is coming"
                    },
                    {
                        "username": "bparanj",
                        "content": "Your understanding is correct, but the problem statement specifically mentions that you can only make a single transaction, i.e., buy once and sell once. \\n\\nThe problem statement says \"You want to maximize your profit by choosing a single day to buy one stock and choosing a different day in the future to sell that stock.\"\\n\\nSo, you can\\'t buy and sell multiple times. You must decide the best day to buy and the best day to sell to maximize your profit. Hence, the maximum profit for the given input [7,1,5,3,6,4] would be 5 (buy at price 1 and sell at price 6), not 7. \\n\\nIf multiple transactions were allowed, then your approach would be correct, and the maximum profit would indeed be 7. However, that\\'s a different problem altogether."
                    },
                    {
                        "username": "f-rams",
                        "content": "I am encountering Runtime Error on test 198/211. Could it be because I am using a nested loop? "
                    },
                    {
                        "username": "dogukan0101",
                        "content": "I guess it is because of the time complexity. It shouldn\\'t be O(n^2)."
                    },
                    {
                        "username": "ashwinpatel0808",
                        "content": "Time Limit Exceeded after passing 199 test cases, what should I rectify?\\n\\nclass Solution {\\npublic:\\n    int maxProfit(vector<int>& prices) {\\n\\n\\n       int maxnum=INT_MIN;\\n       int current =0;\\n       int st=0;\\n       int en=prices.size()-1;\\n       while(st<prices.size()-1){\\n           if(en==st){\\n               st++;\\n               en=prices.size()-1;\\n           }\\n\\n           else{\\n                current=prices[en]-prices[st];\\n                maxnum=max(maxnum,current);\\n                en--;\\n           }\\n       }\\n       if(maxnum<0){\\n           return 0;\\n       }\\n       return maxnum; \\n    }\\n};"
                    },
                    {
                        "username": "bparanj",
                        "content": "The current approach, in worst-case scenarios, runs in O(n^2) time complexity. This is because for each element in the array, you\\'re scanning all the elements to its right. This could lead to a timeout for larger inputs.\\n\\nHere\\'s an optimized solution with O(n) time complexity:\\n\\n```cpp\\nclass Solution {\\npublic:\\n    int maxProfit(vector<int>& prices) {\\n        int max_profit = 0;\\n        int min_price = prices[0];\\n        \\n        for(int i = 1; i < prices.size(); i++){\\n            if(prices[i] < min_price) {\\n                min_price = prices[i];\\n            } else if(prices[i] - min_price > max_profit) {\\n                max_profit = prices[i] - min_price;\\n            }\\n        }\\n        \\n        return max_profit;\\n    }\\n};\\n```\\n\\nIn this solution, we initialize `min_price` to the first price and `max_profit` to 0. Then, we iterate over the prices from the second price. For each price, we do the following:\\n\\n1. If the current price is less than `min_price`, we update `min_price`.\\n2. If the profit we can get by selling at the current price (which is `prices[i] - min_price`) is more than the current `max_profit`, we update `max_profit`.\\n\\nThis solution works because for each price, we\\'re checking whether we should update our `min_price` and whether selling at the current price would give us a higher profit than any we\\'ve seen before. This ensures that our buy happens before the sell, since we always sell at a price that comes after our `min_price`.\\n\\nThus, this solution is much faster and should not lead to a timeout."
                    },
                    {
                        "username": "htooak2014",
                        "content": "me ,too."
                    },
                    {
                        "username": "Rohith8641",
                        "content": "I have solved this problem with 2 Approaches \\nApproach 1:\\nUsing Auxillary Space\\n1.Initially calculate the maximum right value from right \\n2.Then Iterate through the loop once and calculate the profit.\\n3.Choose the stock which has maximum profit\\nTime Complexity: O(N)\\nAuxillary Space: O(N)\\n----------------------------------------------------------------------\\nApproach 2:\\n1.By Standing over the stock price and calculate the minimum Stock price So far \\nand update it with the maximum Profit.\\n2.Return the Maximum Profit after reaching the end of the Stocks\\n3.It means U need to stand over the price of the stock and calculate the difference between the price of the stock.\\n\\n\\n"
                    },
                    {
                        "username": "Amit_Joe",
                        "content": "test case [3,3]\\nfailed \\nbut in my local machine it give exact output that is  0."
                    },
                    {
                        "username": "alangreg",
                        "content": "I have simillar issue with some other problem. Get error here but on my machine it gives correct answer."
                    },
                    {
                        "username": "t_man",
                        "content": "Hi  everyone,\\nI am really surprised to see that my code has just passed for the custom test case but it\\'s showing error for the same test case when submitted .\\nWhat should I do then?\\n![image](https://assets.leetcode.com/users/images/09fb85df-e144-4726-bdf7-896a62f2f37a_1619278979.3459322.png)\\n"
                    },
                    {
                        "username": "HapticBovine",
                        "content": "Upgrade to Arch Linux :)"
                    },
                    {
                        "username": "undefitied",
                        "content": "I\\'ve got here from the \"Top Interview Questions\" course, and \"Dynamic Programming\" chapter. Can somebody explain me, please, what the problem does in this chapter? Isn\\'t it a simple array-chapter problem?"
                    },
                    {
                        "username": "ronaldabellano",
                        "content": "Input: [7,1,5,3,6,4]\\nOutput: 5\\nExplanation: Buy on day 2 (price = 1) and sell on day 5 (price = 6), profit = 6-1 = 5.\\n             **Not 7-1 = 6, as selling price needs to be larger than buying price.**\\n\\t\\t\\t \\nShould this be that you buy on day 2 and you can\\'t sell it on day 1. Because to how I understand 7-1 selling price on day 1 is 7 is larger than buying price on day 2 which is 1.\\nIt states selling price needs to be larger than buying price which is must be always true to solve the problem."
                    },
                    {
                        "username": "vrushabhshetcr7",
                        "content": "https://www.codemummy.com/2020/08/best-time-to-buy-and-sell-stock.html\\n\\nbest and easiest c++ solution with explanation"
                    }
                ]
            },
            {
                "id": 1572764,
                "content": [
                    {
                        "username": "avinashsp93",
                        "content": "I think this problem should be categorized as medium and the next problem should be categorized as easy!!"
                    },
                    {
                        "username": "sumeetlalla",
                        "content": "For the testcase 1\\nInput: prices = [7,1,5,3,6,4]\\nOutput: 5\\n\\nHad a query. If we are buying at day 2 then sell it at day 3 we will get a profit of 4 and if we again buy it at day 4 and sell at day 5 we get a profit of 3 so total profit will be 7. If the transaction is single then 5 will come but if we break the buy sell transaction 7 is coming"
                    },
                    {
                        "username": "bparanj",
                        "content": "Your understanding is correct, but the problem statement specifically mentions that you can only make a single transaction, i.e., buy once and sell once. \\n\\nThe problem statement says \"You want to maximize your profit by choosing a single day to buy one stock and choosing a different day in the future to sell that stock.\"\\n\\nSo, you can\\'t buy and sell multiple times. You must decide the best day to buy and the best day to sell to maximize your profit. Hence, the maximum profit for the given input [7,1,5,3,6,4] would be 5 (buy at price 1 and sell at price 6), not 7. \\n\\nIf multiple transactions were allowed, then your approach would be correct, and the maximum profit would indeed be 7. However, that\\'s a different problem altogether."
                    },
                    {
                        "username": "f-rams",
                        "content": "I am encountering Runtime Error on test 198/211. Could it be because I am using a nested loop? "
                    },
                    {
                        "username": "dogukan0101",
                        "content": "I guess it is because of the time complexity. It shouldn\\'t be O(n^2)."
                    },
                    {
                        "username": "ashwinpatel0808",
                        "content": "Time Limit Exceeded after passing 199 test cases, what should I rectify?\\n\\nclass Solution {\\npublic:\\n    int maxProfit(vector<int>& prices) {\\n\\n\\n       int maxnum=INT_MIN;\\n       int current =0;\\n       int st=0;\\n       int en=prices.size()-1;\\n       while(st<prices.size()-1){\\n           if(en==st){\\n               st++;\\n               en=prices.size()-1;\\n           }\\n\\n           else{\\n                current=prices[en]-prices[st];\\n                maxnum=max(maxnum,current);\\n                en--;\\n           }\\n       }\\n       if(maxnum<0){\\n           return 0;\\n       }\\n       return maxnum; \\n    }\\n};"
                    },
                    {
                        "username": "bparanj",
                        "content": "The current approach, in worst-case scenarios, runs in O(n^2) time complexity. This is because for each element in the array, you\\'re scanning all the elements to its right. This could lead to a timeout for larger inputs.\\n\\nHere\\'s an optimized solution with O(n) time complexity:\\n\\n```cpp\\nclass Solution {\\npublic:\\n    int maxProfit(vector<int>& prices) {\\n        int max_profit = 0;\\n        int min_price = prices[0];\\n        \\n        for(int i = 1; i < prices.size(); i++){\\n            if(prices[i] < min_price) {\\n                min_price = prices[i];\\n            } else if(prices[i] - min_price > max_profit) {\\n                max_profit = prices[i] - min_price;\\n            }\\n        }\\n        \\n        return max_profit;\\n    }\\n};\\n```\\n\\nIn this solution, we initialize `min_price` to the first price and `max_profit` to 0. Then, we iterate over the prices from the second price. For each price, we do the following:\\n\\n1. If the current price is less than `min_price`, we update `min_price`.\\n2. If the profit we can get by selling at the current price (which is `prices[i] - min_price`) is more than the current `max_profit`, we update `max_profit`.\\n\\nThis solution works because for each price, we\\'re checking whether we should update our `min_price` and whether selling at the current price would give us a higher profit than any we\\'ve seen before. This ensures that our buy happens before the sell, since we always sell at a price that comes after our `min_price`.\\n\\nThus, this solution is much faster and should not lead to a timeout."
                    },
                    {
                        "username": "htooak2014",
                        "content": "me ,too."
                    },
                    {
                        "username": "Rohith8641",
                        "content": "I have solved this problem with 2 Approaches \\nApproach 1:\\nUsing Auxillary Space\\n1.Initially calculate the maximum right value from right \\n2.Then Iterate through the loop once and calculate the profit.\\n3.Choose the stock which has maximum profit\\nTime Complexity: O(N)\\nAuxillary Space: O(N)\\n----------------------------------------------------------------------\\nApproach 2:\\n1.By Standing over the stock price and calculate the minimum Stock price So far \\nand update it with the maximum Profit.\\n2.Return the Maximum Profit after reaching the end of the Stocks\\n3.It means U need to stand over the price of the stock and calculate the difference between the price of the stock.\\n\\n\\n"
                    },
                    {
                        "username": "Amit_Joe",
                        "content": "test case [3,3]\\nfailed \\nbut in my local machine it give exact output that is  0."
                    },
                    {
                        "username": "alangreg",
                        "content": "I have simillar issue with some other problem. Get error here but on my machine it gives correct answer."
                    },
                    {
                        "username": "t_man",
                        "content": "Hi  everyone,\\nI am really surprised to see that my code has just passed for the custom test case but it\\'s showing error for the same test case when submitted .\\nWhat should I do then?\\n![image](https://assets.leetcode.com/users/images/09fb85df-e144-4726-bdf7-896a62f2f37a_1619278979.3459322.png)\\n"
                    },
                    {
                        "username": "HapticBovine",
                        "content": "Upgrade to Arch Linux :)"
                    },
                    {
                        "username": "undefitied",
                        "content": "I\\'ve got here from the \"Top Interview Questions\" course, and \"Dynamic Programming\" chapter. Can somebody explain me, please, what the problem does in this chapter? Isn\\'t it a simple array-chapter problem?"
                    },
                    {
                        "username": "ronaldabellano",
                        "content": "Input: [7,1,5,3,6,4]\\nOutput: 5\\nExplanation: Buy on day 2 (price = 1) and sell on day 5 (price = 6), profit = 6-1 = 5.\\n             **Not 7-1 = 6, as selling price needs to be larger than buying price.**\\n\\t\\t\\t \\nShould this be that you buy on day 2 and you can\\'t sell it on day 1. Because to how I understand 7-1 selling price on day 1 is 7 is larger than buying price on day 2 which is 1.\\nIt states selling price needs to be larger than buying price which is must be always true to solve the problem."
                    },
                    {
                        "username": "vrushabhshetcr7",
                        "content": "https://www.codemummy.com/2020/08/best-time-to-buy-and-sell-stock.html\\n\\nbest and easiest c++ solution with explanation"
                    }
                ]
            },
            {
                "id": 1575261,
                "content": [
                    {
                        "username": "avinashsp93",
                        "content": "I think this problem should be categorized as medium and the next problem should be categorized as easy!!"
                    },
                    {
                        "username": "sumeetlalla",
                        "content": "For the testcase 1\\nInput: prices = [7,1,5,3,6,4]\\nOutput: 5\\n\\nHad a query. If we are buying at day 2 then sell it at day 3 we will get a profit of 4 and if we again buy it at day 4 and sell at day 5 we get a profit of 3 so total profit will be 7. If the transaction is single then 5 will come but if we break the buy sell transaction 7 is coming"
                    },
                    {
                        "username": "bparanj",
                        "content": "Your understanding is correct, but the problem statement specifically mentions that you can only make a single transaction, i.e., buy once and sell once. \\n\\nThe problem statement says \"You want to maximize your profit by choosing a single day to buy one stock and choosing a different day in the future to sell that stock.\"\\n\\nSo, you can\\'t buy and sell multiple times. You must decide the best day to buy and the best day to sell to maximize your profit. Hence, the maximum profit for the given input [7,1,5,3,6,4] would be 5 (buy at price 1 and sell at price 6), not 7. \\n\\nIf multiple transactions were allowed, then your approach would be correct, and the maximum profit would indeed be 7. However, that\\'s a different problem altogether."
                    },
                    {
                        "username": "f-rams",
                        "content": "I am encountering Runtime Error on test 198/211. Could it be because I am using a nested loop? "
                    },
                    {
                        "username": "dogukan0101",
                        "content": "I guess it is because of the time complexity. It shouldn\\'t be O(n^2)."
                    },
                    {
                        "username": "ashwinpatel0808",
                        "content": "Time Limit Exceeded after passing 199 test cases, what should I rectify?\\n\\nclass Solution {\\npublic:\\n    int maxProfit(vector<int>& prices) {\\n\\n\\n       int maxnum=INT_MIN;\\n       int current =0;\\n       int st=0;\\n       int en=prices.size()-1;\\n       while(st<prices.size()-1){\\n           if(en==st){\\n               st++;\\n               en=prices.size()-1;\\n           }\\n\\n           else{\\n                current=prices[en]-prices[st];\\n                maxnum=max(maxnum,current);\\n                en--;\\n           }\\n       }\\n       if(maxnum<0){\\n           return 0;\\n       }\\n       return maxnum; \\n    }\\n};"
                    },
                    {
                        "username": "bparanj",
                        "content": "The current approach, in worst-case scenarios, runs in O(n^2) time complexity. This is because for each element in the array, you\\'re scanning all the elements to its right. This could lead to a timeout for larger inputs.\\n\\nHere\\'s an optimized solution with O(n) time complexity:\\n\\n```cpp\\nclass Solution {\\npublic:\\n    int maxProfit(vector<int>& prices) {\\n        int max_profit = 0;\\n        int min_price = prices[0];\\n        \\n        for(int i = 1; i < prices.size(); i++){\\n            if(prices[i] < min_price) {\\n                min_price = prices[i];\\n            } else if(prices[i] - min_price > max_profit) {\\n                max_profit = prices[i] - min_price;\\n            }\\n        }\\n        \\n        return max_profit;\\n    }\\n};\\n```\\n\\nIn this solution, we initialize `min_price` to the first price and `max_profit` to 0. Then, we iterate over the prices from the second price. For each price, we do the following:\\n\\n1. If the current price is less than `min_price`, we update `min_price`.\\n2. If the profit we can get by selling at the current price (which is `prices[i] - min_price`) is more than the current `max_profit`, we update `max_profit`.\\n\\nThis solution works because for each price, we\\'re checking whether we should update our `min_price` and whether selling at the current price would give us a higher profit than any we\\'ve seen before. This ensures that our buy happens before the sell, since we always sell at a price that comes after our `min_price`.\\n\\nThus, this solution is much faster and should not lead to a timeout."
                    },
                    {
                        "username": "htooak2014",
                        "content": "me ,too."
                    },
                    {
                        "username": "Rohith8641",
                        "content": "I have solved this problem with 2 Approaches \\nApproach 1:\\nUsing Auxillary Space\\n1.Initially calculate the maximum right value from right \\n2.Then Iterate through the loop once and calculate the profit.\\n3.Choose the stock which has maximum profit\\nTime Complexity: O(N)\\nAuxillary Space: O(N)\\n----------------------------------------------------------------------\\nApproach 2:\\n1.By Standing over the stock price and calculate the minimum Stock price So far \\nand update it with the maximum Profit.\\n2.Return the Maximum Profit after reaching the end of the Stocks\\n3.It means U need to stand over the price of the stock and calculate the difference between the price of the stock.\\n\\n\\n"
                    },
                    {
                        "username": "Amit_Joe",
                        "content": "test case [3,3]\\nfailed \\nbut in my local machine it give exact output that is  0."
                    },
                    {
                        "username": "alangreg",
                        "content": "I have simillar issue with some other problem. Get error here but on my machine it gives correct answer."
                    },
                    {
                        "username": "t_man",
                        "content": "Hi  everyone,\\nI am really surprised to see that my code has just passed for the custom test case but it\\'s showing error for the same test case when submitted .\\nWhat should I do then?\\n![image](https://assets.leetcode.com/users/images/09fb85df-e144-4726-bdf7-896a62f2f37a_1619278979.3459322.png)\\n"
                    },
                    {
                        "username": "HapticBovine",
                        "content": "Upgrade to Arch Linux :)"
                    },
                    {
                        "username": "undefitied",
                        "content": "I\\'ve got here from the \"Top Interview Questions\" course, and \"Dynamic Programming\" chapter. Can somebody explain me, please, what the problem does in this chapter? Isn\\'t it a simple array-chapter problem?"
                    },
                    {
                        "username": "ronaldabellano",
                        "content": "Input: [7,1,5,3,6,4]\\nOutput: 5\\nExplanation: Buy on day 2 (price = 1) and sell on day 5 (price = 6), profit = 6-1 = 5.\\n             **Not 7-1 = 6, as selling price needs to be larger than buying price.**\\n\\t\\t\\t \\nShould this be that you buy on day 2 and you can\\'t sell it on day 1. Because to how I understand 7-1 selling price on day 1 is 7 is larger than buying price on day 2 which is 1.\\nIt states selling price needs to be larger than buying price which is must be always true to solve the problem."
                    },
                    {
                        "username": "vrushabhshetcr7",
                        "content": "https://www.codemummy.com/2020/08/best-time-to-buy-and-sell-stock.html\\n\\nbest and easiest c++ solution with explanation"
                    }
                ]
            },
            {
                "id": 2077049,
                "content": [
                    {
                        "username": "Himanshu_Singh11",
                        "content": "prices = [7,1,5,3,6,4] \\nProblem Statement :- so basically wht we need to do is buy a stock on any day from 0 to (i-1) index and sell it on on any ith day , in the process we need to do so such that we get the maximum profit by selling the stock we bought\\nLogic:-  so if we sell a stock on ith day say it has a price of  prices[i] so to get max profit by selling it we should have bought a stock before the ith day ie minimum in price so ie basically\\n min(prices[0...i-1])\\n\\nNote :- we can Buy and sell a stock only once \\n"
                    },
                    {
                        "username": "elliekity",
                        "content": "i got time limit exceeded :joe_angry:"
                    },
                    {
                        "username": "RealJiaJie",
                        "content": "you could solve this with a single pass on the array. No need for double array, recursion, etc. Just a simple for loop."
                    },
                    {
                        "username": "icor",
                        "content": "There is wrong testcase 20. prices =\n[1,2] My output 2. Expected 1. Expected 1 is not correct it should be 2. Buy on day 1 and sell on day 2. Profit 1 "
                    },
                    {
                        "username": "RealJiaJie",
                        "content": "You answered your own problem. Profit = 1. "
                    },
                    {
                        "username": "RealJiaJie",
                        "content": "I don\\'t think this is a dynamic problem."
                    },
                    {
                        "username": "Natnael_32",
                        "content": " Why does the test case [2, 4, 1] pass on my machine but fail here?  [@LeetCode](/LeetCode)"
                    },
                    {
                        "username": "nitheshkumar0731",
                        "content": "can anyone tell me  ,how expected outcome become 1\nfor array [4,1,2]   ,  It should be  2 right?"
                    },
                    {
                        "username": "RealJiaJie",
                        "content": "If you buy now, you can only sell in the future. Think of index as the days. Assuming that array is day 0, 1, 2. you cant buy on day 2 and sell on day 1."
                    },
                    {
                        "username": "arurahul16",
                        "content": "HI Nithesh , just understand index position of sell must be greater than buy position. i hope you will understand now"
                    },
                    {
                        "username": "hola_aryan",
                        "content": "This problem must be categorized as medium level problem. "
                    },
                    {
                        "username": "rubayea",
                        "content": "There is some kind inconsistency with the test cases because some assume that its starts from Day 0 while others on Day 1. However the provided examples follows the normal counting of days starting from 1 . "
                    },
                    {
                        "username": "RealJiaJie",
                        "content": "I had no problem"
                    },
                    {
                        "username": "roshanjhakota",
                        "content": "class Solution {\\npublic:\\n          int maxProfit(vector<int>& prices) {\\n        int n = prices.size();\\n        if (n <= 1)\\n            return 0;\\n\\n        int minPrice = prices[0];\\n        int maxProfit = 0;\\n\\n        for (int i = 1; i < n; i++) {\\n            if (prices[i] < minPrice) {\\n                minPrice = prices[i];\\n            } else if (prices[i] - minPrice > maxProfit) {\\n                maxProfit = prices[i] - minPrice;\\n            }\\n        }\\n\\n        return maxProfit;\\n    }\\n};     Here i have first taken min and max price as index = 0 and max as 0 while iterating over the loop i am changing the value of min max accordingly . Let me explain ....   \\nIf the arr[index] < minPrice then i have to change the minPrice as it become minPrice = arr[index]\\nand the using else if this false it means arr[index] > minPrice then i am just subtracting and checking with the maxProfit if it is maximum then it is answer otherwise maxProfit = price[i] - minPrice;"
                    },
                    {
                        "username": "abhijeetyadav82",
                        "content": "prices = [7,1,5,3,6,4]  Shouldn\\'t the max profit be 7 here. buy at 1 sell at 5. then buy at 3 sell at 6. 4+3 = 7 "
                    },
                    {
                        "username": "RealJiaJie",
                        "content": "I also had the same thinking, however, the key point is that you can only perform ONE transaction throughout the problem. Here you did two. "
                    },
                    {
                        "username": "arurahul16",
                        "content": "hi brother , you are adding the profits , that\\'s not the point, understand you need to find max profit and also need to keep in mind that sell index position should greater than buying index position and then check whether the profit you got is maximum."
                    }
                ]
            },
            {
                "id": 2074753,
                "content": [
                    {
                        "username": "Himanshu_Singh11",
                        "content": "prices = [7,1,5,3,6,4] \\nProblem Statement :- so basically wht we need to do is buy a stock on any day from 0 to (i-1) index and sell it on on any ith day , in the process we need to do so such that we get the maximum profit by selling the stock we bought\\nLogic:-  so if we sell a stock on ith day say it has a price of  prices[i] so to get max profit by selling it we should have bought a stock before the ith day ie minimum in price so ie basically\\n min(prices[0...i-1])\\n\\nNote :- we can Buy and sell a stock only once \\n"
                    },
                    {
                        "username": "elliekity",
                        "content": "i got time limit exceeded :joe_angry:"
                    },
                    {
                        "username": "RealJiaJie",
                        "content": "you could solve this with a single pass on the array. No need for double array, recursion, etc. Just a simple for loop."
                    },
                    {
                        "username": "icor",
                        "content": "There is wrong testcase 20. prices =\n[1,2] My output 2. Expected 1. Expected 1 is not correct it should be 2. Buy on day 1 and sell on day 2. Profit 1 "
                    },
                    {
                        "username": "RealJiaJie",
                        "content": "You answered your own problem. Profit = 1. "
                    },
                    {
                        "username": "RealJiaJie",
                        "content": "I don\\'t think this is a dynamic problem."
                    },
                    {
                        "username": "Natnael_32",
                        "content": " Why does the test case [2, 4, 1] pass on my machine but fail here?  [@LeetCode](/LeetCode)"
                    },
                    {
                        "username": "nitheshkumar0731",
                        "content": "can anyone tell me  ,how expected outcome become 1\nfor array [4,1,2]   ,  It should be  2 right?"
                    },
                    {
                        "username": "RealJiaJie",
                        "content": "If you buy now, you can only sell in the future. Think of index as the days. Assuming that array is day 0, 1, 2. you cant buy on day 2 and sell on day 1."
                    },
                    {
                        "username": "arurahul16",
                        "content": "HI Nithesh , just understand index position of sell must be greater than buy position. i hope you will understand now"
                    },
                    {
                        "username": "hola_aryan",
                        "content": "This problem must be categorized as medium level problem. "
                    },
                    {
                        "username": "rubayea",
                        "content": "There is some kind inconsistency with the test cases because some assume that its starts from Day 0 while others on Day 1. However the provided examples follows the normal counting of days starting from 1 . "
                    },
                    {
                        "username": "RealJiaJie",
                        "content": "I had no problem"
                    },
                    {
                        "username": "roshanjhakota",
                        "content": "class Solution {\\npublic:\\n          int maxProfit(vector<int>& prices) {\\n        int n = prices.size();\\n        if (n <= 1)\\n            return 0;\\n\\n        int minPrice = prices[0];\\n        int maxProfit = 0;\\n\\n        for (int i = 1; i < n; i++) {\\n            if (prices[i] < minPrice) {\\n                minPrice = prices[i];\\n            } else if (prices[i] - minPrice > maxProfit) {\\n                maxProfit = prices[i] - minPrice;\\n            }\\n        }\\n\\n        return maxProfit;\\n    }\\n};     Here i have first taken min and max price as index = 0 and max as 0 while iterating over the loop i am changing the value of min max accordingly . Let me explain ....   \\nIf the arr[index] < minPrice then i have to change the minPrice as it become minPrice = arr[index]\\nand the using else if this false it means arr[index] > minPrice then i am just subtracting and checking with the maxProfit if it is maximum then it is answer otherwise maxProfit = price[i] - minPrice;"
                    },
                    {
                        "username": "abhijeetyadav82",
                        "content": "prices = [7,1,5,3,6,4]  Shouldn\\'t the max profit be 7 here. buy at 1 sell at 5. then buy at 3 sell at 6. 4+3 = 7 "
                    },
                    {
                        "username": "RealJiaJie",
                        "content": "I also had the same thinking, however, the key point is that you can only perform ONE transaction throughout the problem. Here you did two. "
                    },
                    {
                        "username": "arurahul16",
                        "content": "hi brother , you are adding the profits , that\\'s not the point, understand you need to find max profit and also need to keep in mind that sell index position should greater than buying index position and then check whether the profit you got is maximum."
                    }
                ]
            },
            {
                "id": 2068195,
                "content": [
                    {
                        "username": "Himanshu_Singh11",
                        "content": "prices = [7,1,5,3,6,4] \\nProblem Statement :- so basically wht we need to do is buy a stock on any day from 0 to (i-1) index and sell it on on any ith day , in the process we need to do so such that we get the maximum profit by selling the stock we bought\\nLogic:-  so if we sell a stock on ith day say it has a price of  prices[i] so to get max profit by selling it we should have bought a stock before the ith day ie minimum in price so ie basically\\n min(prices[0...i-1])\\n\\nNote :- we can Buy and sell a stock only once \\n"
                    },
                    {
                        "username": "elliekity",
                        "content": "i got time limit exceeded :joe_angry:"
                    },
                    {
                        "username": "RealJiaJie",
                        "content": "you could solve this with a single pass on the array. No need for double array, recursion, etc. Just a simple for loop."
                    },
                    {
                        "username": "icor",
                        "content": "There is wrong testcase 20. prices =\n[1,2] My output 2. Expected 1. Expected 1 is not correct it should be 2. Buy on day 1 and sell on day 2. Profit 1 "
                    },
                    {
                        "username": "RealJiaJie",
                        "content": "You answered your own problem. Profit = 1. "
                    },
                    {
                        "username": "RealJiaJie",
                        "content": "I don\\'t think this is a dynamic problem."
                    },
                    {
                        "username": "Natnael_32",
                        "content": " Why does the test case [2, 4, 1] pass on my machine but fail here?  [@LeetCode](/LeetCode)"
                    },
                    {
                        "username": "nitheshkumar0731",
                        "content": "can anyone tell me  ,how expected outcome become 1\nfor array [4,1,2]   ,  It should be  2 right?"
                    },
                    {
                        "username": "RealJiaJie",
                        "content": "If you buy now, you can only sell in the future. Think of index as the days. Assuming that array is day 0, 1, 2. you cant buy on day 2 and sell on day 1."
                    },
                    {
                        "username": "arurahul16",
                        "content": "HI Nithesh , just understand index position of sell must be greater than buy position. i hope you will understand now"
                    },
                    {
                        "username": "hola_aryan",
                        "content": "This problem must be categorized as medium level problem. "
                    },
                    {
                        "username": "rubayea",
                        "content": "There is some kind inconsistency with the test cases because some assume that its starts from Day 0 while others on Day 1. However the provided examples follows the normal counting of days starting from 1 . "
                    },
                    {
                        "username": "RealJiaJie",
                        "content": "I had no problem"
                    },
                    {
                        "username": "roshanjhakota",
                        "content": "class Solution {\\npublic:\\n          int maxProfit(vector<int>& prices) {\\n        int n = prices.size();\\n        if (n <= 1)\\n            return 0;\\n\\n        int minPrice = prices[0];\\n        int maxProfit = 0;\\n\\n        for (int i = 1; i < n; i++) {\\n            if (prices[i] < minPrice) {\\n                minPrice = prices[i];\\n            } else if (prices[i] - minPrice > maxProfit) {\\n                maxProfit = prices[i] - minPrice;\\n            }\\n        }\\n\\n        return maxProfit;\\n    }\\n};     Here i have first taken min and max price as index = 0 and max as 0 while iterating over the loop i am changing the value of min max accordingly . Let me explain ....   \\nIf the arr[index] < minPrice then i have to change the minPrice as it become minPrice = arr[index]\\nand the using else if this false it means arr[index] > minPrice then i am just subtracting and checking with the maxProfit if it is maximum then it is answer otherwise maxProfit = price[i] - minPrice;"
                    },
                    {
                        "username": "abhijeetyadav82",
                        "content": "prices = [7,1,5,3,6,4]  Shouldn\\'t the max profit be 7 here. buy at 1 sell at 5. then buy at 3 sell at 6. 4+3 = 7 "
                    },
                    {
                        "username": "RealJiaJie",
                        "content": "I also had the same thinking, however, the key point is that you can only perform ONE transaction throughout the problem. Here you did two. "
                    },
                    {
                        "username": "arurahul16",
                        "content": "hi brother , you are adding the profits , that\\'s not the point, understand you need to find max profit and also need to keep in mind that sell index position should greater than buying index position and then check whether the profit you got is maximum."
                    }
                ]
            },
            {
                "id": 2068097,
                "content": [
                    {
                        "username": "Himanshu_Singh11",
                        "content": "prices = [7,1,5,3,6,4] \\nProblem Statement :- so basically wht we need to do is buy a stock on any day from 0 to (i-1) index and sell it on on any ith day , in the process we need to do so such that we get the maximum profit by selling the stock we bought\\nLogic:-  so if we sell a stock on ith day say it has a price of  prices[i] so to get max profit by selling it we should have bought a stock before the ith day ie minimum in price so ie basically\\n min(prices[0...i-1])\\n\\nNote :- we can Buy and sell a stock only once \\n"
                    },
                    {
                        "username": "elliekity",
                        "content": "i got time limit exceeded :joe_angry:"
                    },
                    {
                        "username": "RealJiaJie",
                        "content": "you could solve this with a single pass on the array. No need for double array, recursion, etc. Just a simple for loop."
                    },
                    {
                        "username": "icor",
                        "content": "There is wrong testcase 20. prices =\n[1,2] My output 2. Expected 1. Expected 1 is not correct it should be 2. Buy on day 1 and sell on day 2. Profit 1 "
                    },
                    {
                        "username": "RealJiaJie",
                        "content": "You answered your own problem. Profit = 1. "
                    },
                    {
                        "username": "RealJiaJie",
                        "content": "I don\\'t think this is a dynamic problem."
                    },
                    {
                        "username": "Natnael_32",
                        "content": " Why does the test case [2, 4, 1] pass on my machine but fail here?  [@LeetCode](/LeetCode)"
                    },
                    {
                        "username": "nitheshkumar0731",
                        "content": "can anyone tell me  ,how expected outcome become 1\nfor array [4,1,2]   ,  It should be  2 right?"
                    },
                    {
                        "username": "RealJiaJie",
                        "content": "If you buy now, you can only sell in the future. Think of index as the days. Assuming that array is day 0, 1, 2. you cant buy on day 2 and sell on day 1."
                    },
                    {
                        "username": "arurahul16",
                        "content": "HI Nithesh , just understand index position of sell must be greater than buy position. i hope you will understand now"
                    },
                    {
                        "username": "hola_aryan",
                        "content": "This problem must be categorized as medium level problem. "
                    },
                    {
                        "username": "rubayea",
                        "content": "There is some kind inconsistency with the test cases because some assume that its starts from Day 0 while others on Day 1. However the provided examples follows the normal counting of days starting from 1 . "
                    },
                    {
                        "username": "RealJiaJie",
                        "content": "I had no problem"
                    },
                    {
                        "username": "roshanjhakota",
                        "content": "class Solution {\\npublic:\\n          int maxProfit(vector<int>& prices) {\\n        int n = prices.size();\\n        if (n <= 1)\\n            return 0;\\n\\n        int minPrice = prices[0];\\n        int maxProfit = 0;\\n\\n        for (int i = 1; i < n; i++) {\\n            if (prices[i] < minPrice) {\\n                minPrice = prices[i];\\n            } else if (prices[i] - minPrice > maxProfit) {\\n                maxProfit = prices[i] - minPrice;\\n            }\\n        }\\n\\n        return maxProfit;\\n    }\\n};     Here i have first taken min and max price as index = 0 and max as 0 while iterating over the loop i am changing the value of min max accordingly . Let me explain ....   \\nIf the arr[index] < minPrice then i have to change the minPrice as it become minPrice = arr[index]\\nand the using else if this false it means arr[index] > minPrice then i am just subtracting and checking with the maxProfit if it is maximum then it is answer otherwise maxProfit = price[i] - minPrice;"
                    },
                    {
                        "username": "abhijeetyadav82",
                        "content": "prices = [7,1,5,3,6,4]  Shouldn\\'t the max profit be 7 here. buy at 1 sell at 5. then buy at 3 sell at 6. 4+3 = 7 "
                    },
                    {
                        "username": "RealJiaJie",
                        "content": "I also had the same thinking, however, the key point is that you can only perform ONE transaction throughout the problem. Here you did two. "
                    },
                    {
                        "username": "arurahul16",
                        "content": "hi brother , you are adding the profits , that\\'s not the point, understand you need to find max profit and also need to keep in mind that sell index position should greater than buying index position and then check whether the profit you got is maximum."
                    }
                ]
            },
            {
                "id": 2065933,
                "content": [
                    {
                        "username": "Himanshu_Singh11",
                        "content": "prices = [7,1,5,3,6,4] \\nProblem Statement :- so basically wht we need to do is buy a stock on any day from 0 to (i-1) index and sell it on on any ith day , in the process we need to do so such that we get the maximum profit by selling the stock we bought\\nLogic:-  so if we sell a stock on ith day say it has a price of  prices[i] so to get max profit by selling it we should have bought a stock before the ith day ie minimum in price so ie basically\\n min(prices[0...i-1])\\n\\nNote :- we can Buy and sell a stock only once \\n"
                    },
                    {
                        "username": "elliekity",
                        "content": "i got time limit exceeded :joe_angry:"
                    },
                    {
                        "username": "RealJiaJie",
                        "content": "you could solve this with a single pass on the array. No need for double array, recursion, etc. Just a simple for loop."
                    },
                    {
                        "username": "icor",
                        "content": "There is wrong testcase 20. prices =\n[1,2] My output 2. Expected 1. Expected 1 is not correct it should be 2. Buy on day 1 and sell on day 2. Profit 1 "
                    },
                    {
                        "username": "RealJiaJie",
                        "content": "You answered your own problem. Profit = 1. "
                    },
                    {
                        "username": "RealJiaJie",
                        "content": "I don\\'t think this is a dynamic problem."
                    },
                    {
                        "username": "Natnael_32",
                        "content": " Why does the test case [2, 4, 1] pass on my machine but fail here?  [@LeetCode](/LeetCode)"
                    },
                    {
                        "username": "nitheshkumar0731",
                        "content": "can anyone tell me  ,how expected outcome become 1\nfor array [4,1,2]   ,  It should be  2 right?"
                    },
                    {
                        "username": "RealJiaJie",
                        "content": "If you buy now, you can only sell in the future. Think of index as the days. Assuming that array is day 0, 1, 2. you cant buy on day 2 and sell on day 1."
                    },
                    {
                        "username": "arurahul16",
                        "content": "HI Nithesh , just understand index position of sell must be greater than buy position. i hope you will understand now"
                    },
                    {
                        "username": "hola_aryan",
                        "content": "This problem must be categorized as medium level problem. "
                    },
                    {
                        "username": "rubayea",
                        "content": "There is some kind inconsistency with the test cases because some assume that its starts from Day 0 while others on Day 1. However the provided examples follows the normal counting of days starting from 1 . "
                    },
                    {
                        "username": "RealJiaJie",
                        "content": "I had no problem"
                    },
                    {
                        "username": "roshanjhakota",
                        "content": "class Solution {\\npublic:\\n          int maxProfit(vector<int>& prices) {\\n        int n = prices.size();\\n        if (n <= 1)\\n            return 0;\\n\\n        int minPrice = prices[0];\\n        int maxProfit = 0;\\n\\n        for (int i = 1; i < n; i++) {\\n            if (prices[i] < minPrice) {\\n                minPrice = prices[i];\\n            } else if (prices[i] - minPrice > maxProfit) {\\n                maxProfit = prices[i] - minPrice;\\n            }\\n        }\\n\\n        return maxProfit;\\n    }\\n};     Here i have first taken min and max price as index = 0 and max as 0 while iterating over the loop i am changing the value of min max accordingly . Let me explain ....   \\nIf the arr[index] < minPrice then i have to change the minPrice as it become minPrice = arr[index]\\nand the using else if this false it means arr[index] > minPrice then i am just subtracting and checking with the maxProfit if it is maximum then it is answer otherwise maxProfit = price[i] - minPrice;"
                    },
                    {
                        "username": "abhijeetyadav82",
                        "content": "prices = [7,1,5,3,6,4]  Shouldn\\'t the max profit be 7 here. buy at 1 sell at 5. then buy at 3 sell at 6. 4+3 = 7 "
                    },
                    {
                        "username": "RealJiaJie",
                        "content": "I also had the same thinking, however, the key point is that you can only perform ONE transaction throughout the problem. Here you did two. "
                    },
                    {
                        "username": "arurahul16",
                        "content": "hi brother , you are adding the profits , that\\'s not the point, understand you need to find max profit and also need to keep in mind that sell index position should greater than buying index position and then check whether the profit you got is maximum."
                    }
                ]
            },
            {
                "id": 2065291,
                "content": [
                    {
                        "username": "Himanshu_Singh11",
                        "content": "prices = [7,1,5,3,6,4] \\nProblem Statement :- so basically wht we need to do is buy a stock on any day from 0 to (i-1) index and sell it on on any ith day , in the process we need to do so such that we get the maximum profit by selling the stock we bought\\nLogic:-  so if we sell a stock on ith day say it has a price of  prices[i] so to get max profit by selling it we should have bought a stock before the ith day ie minimum in price so ie basically\\n min(prices[0...i-1])\\n\\nNote :- we can Buy and sell a stock only once \\n"
                    },
                    {
                        "username": "elliekity",
                        "content": "i got time limit exceeded :joe_angry:"
                    },
                    {
                        "username": "RealJiaJie",
                        "content": "you could solve this with a single pass on the array. No need for double array, recursion, etc. Just a simple for loop."
                    },
                    {
                        "username": "icor",
                        "content": "There is wrong testcase 20. prices =\n[1,2] My output 2. Expected 1. Expected 1 is not correct it should be 2. Buy on day 1 and sell on day 2. Profit 1 "
                    },
                    {
                        "username": "RealJiaJie",
                        "content": "You answered your own problem. Profit = 1. "
                    },
                    {
                        "username": "RealJiaJie",
                        "content": "I don\\'t think this is a dynamic problem."
                    },
                    {
                        "username": "Natnael_32",
                        "content": " Why does the test case [2, 4, 1] pass on my machine but fail here?  [@LeetCode](/LeetCode)"
                    },
                    {
                        "username": "nitheshkumar0731",
                        "content": "can anyone tell me  ,how expected outcome become 1\nfor array [4,1,2]   ,  It should be  2 right?"
                    },
                    {
                        "username": "RealJiaJie",
                        "content": "If you buy now, you can only sell in the future. Think of index as the days. Assuming that array is day 0, 1, 2. you cant buy on day 2 and sell on day 1."
                    },
                    {
                        "username": "arurahul16",
                        "content": "HI Nithesh , just understand index position of sell must be greater than buy position. i hope you will understand now"
                    },
                    {
                        "username": "hola_aryan",
                        "content": "This problem must be categorized as medium level problem. "
                    },
                    {
                        "username": "rubayea",
                        "content": "There is some kind inconsistency with the test cases because some assume that its starts from Day 0 while others on Day 1. However the provided examples follows the normal counting of days starting from 1 . "
                    },
                    {
                        "username": "RealJiaJie",
                        "content": "I had no problem"
                    },
                    {
                        "username": "roshanjhakota",
                        "content": "class Solution {\\npublic:\\n          int maxProfit(vector<int>& prices) {\\n        int n = prices.size();\\n        if (n <= 1)\\n            return 0;\\n\\n        int minPrice = prices[0];\\n        int maxProfit = 0;\\n\\n        for (int i = 1; i < n; i++) {\\n            if (prices[i] < minPrice) {\\n                minPrice = prices[i];\\n            } else if (prices[i] - minPrice > maxProfit) {\\n                maxProfit = prices[i] - minPrice;\\n            }\\n        }\\n\\n        return maxProfit;\\n    }\\n};     Here i have first taken min and max price as index = 0 and max as 0 while iterating over the loop i am changing the value of min max accordingly . Let me explain ....   \\nIf the arr[index] < minPrice then i have to change the minPrice as it become minPrice = arr[index]\\nand the using else if this false it means arr[index] > minPrice then i am just subtracting and checking with the maxProfit if it is maximum then it is answer otherwise maxProfit = price[i] - minPrice;"
                    },
                    {
                        "username": "abhijeetyadav82",
                        "content": "prices = [7,1,5,3,6,4]  Shouldn\\'t the max profit be 7 here. buy at 1 sell at 5. then buy at 3 sell at 6. 4+3 = 7 "
                    },
                    {
                        "username": "RealJiaJie",
                        "content": "I also had the same thinking, however, the key point is that you can only perform ONE transaction throughout the problem. Here you did two. "
                    },
                    {
                        "username": "arurahul16",
                        "content": "hi brother , you are adding the profits , that\\'s not the point, understand you need to find max profit and also need to keep in mind that sell index position should greater than buying index position and then check whether the profit you got is maximum."
                    }
                ]
            },
            {
                "id": 2064553,
                "content": [
                    {
                        "username": "Himanshu_Singh11",
                        "content": "prices = [7,1,5,3,6,4] \\nProblem Statement :- so basically wht we need to do is buy a stock on any day from 0 to (i-1) index and sell it on on any ith day , in the process we need to do so such that we get the maximum profit by selling the stock we bought\\nLogic:-  so if we sell a stock on ith day say it has a price of  prices[i] so to get max profit by selling it we should have bought a stock before the ith day ie minimum in price so ie basically\\n min(prices[0...i-1])\\n\\nNote :- we can Buy and sell a stock only once \\n"
                    },
                    {
                        "username": "elliekity",
                        "content": "i got time limit exceeded :joe_angry:"
                    },
                    {
                        "username": "RealJiaJie",
                        "content": "you could solve this with a single pass on the array. No need for double array, recursion, etc. Just a simple for loop."
                    },
                    {
                        "username": "icor",
                        "content": "There is wrong testcase 20. prices =\n[1,2] My output 2. Expected 1. Expected 1 is not correct it should be 2. Buy on day 1 and sell on day 2. Profit 1 "
                    },
                    {
                        "username": "RealJiaJie",
                        "content": "You answered your own problem. Profit = 1. "
                    },
                    {
                        "username": "RealJiaJie",
                        "content": "I don\\'t think this is a dynamic problem."
                    },
                    {
                        "username": "Natnael_32",
                        "content": " Why does the test case [2, 4, 1] pass on my machine but fail here?  [@LeetCode](/LeetCode)"
                    },
                    {
                        "username": "nitheshkumar0731",
                        "content": "can anyone tell me  ,how expected outcome become 1\nfor array [4,1,2]   ,  It should be  2 right?"
                    },
                    {
                        "username": "RealJiaJie",
                        "content": "If you buy now, you can only sell in the future. Think of index as the days. Assuming that array is day 0, 1, 2. you cant buy on day 2 and sell on day 1."
                    },
                    {
                        "username": "arurahul16",
                        "content": "HI Nithesh , just understand index position of sell must be greater than buy position. i hope you will understand now"
                    },
                    {
                        "username": "hola_aryan",
                        "content": "This problem must be categorized as medium level problem. "
                    },
                    {
                        "username": "rubayea",
                        "content": "There is some kind inconsistency with the test cases because some assume that its starts from Day 0 while others on Day 1. However the provided examples follows the normal counting of days starting from 1 . "
                    },
                    {
                        "username": "RealJiaJie",
                        "content": "I had no problem"
                    },
                    {
                        "username": "roshanjhakota",
                        "content": "class Solution {\\npublic:\\n          int maxProfit(vector<int>& prices) {\\n        int n = prices.size();\\n        if (n <= 1)\\n            return 0;\\n\\n        int minPrice = prices[0];\\n        int maxProfit = 0;\\n\\n        for (int i = 1; i < n; i++) {\\n            if (prices[i] < minPrice) {\\n                minPrice = prices[i];\\n            } else if (prices[i] - minPrice > maxProfit) {\\n                maxProfit = prices[i] - minPrice;\\n            }\\n        }\\n\\n        return maxProfit;\\n    }\\n};     Here i have first taken min and max price as index = 0 and max as 0 while iterating over the loop i am changing the value of min max accordingly . Let me explain ....   \\nIf the arr[index] < minPrice then i have to change the minPrice as it become minPrice = arr[index]\\nand the using else if this false it means arr[index] > minPrice then i am just subtracting and checking with the maxProfit if it is maximum then it is answer otherwise maxProfit = price[i] - minPrice;"
                    },
                    {
                        "username": "abhijeetyadav82",
                        "content": "prices = [7,1,5,3,6,4]  Shouldn\\'t the max profit be 7 here. buy at 1 sell at 5. then buy at 3 sell at 6. 4+3 = 7 "
                    },
                    {
                        "username": "RealJiaJie",
                        "content": "I also had the same thinking, however, the key point is that you can only perform ONE transaction throughout the problem. Here you did two. "
                    },
                    {
                        "username": "arurahul16",
                        "content": "hi brother , you are adding the profits , that\\'s not the point, understand you need to find max profit and also need to keep in mind that sell index position should greater than buying index position and then check whether the profit you got is maximum."
                    }
                ]
            },
            {
                "id": 2064519,
                "content": [
                    {
                        "username": "Himanshu_Singh11",
                        "content": "prices = [7,1,5,3,6,4] \\nProblem Statement :- so basically wht we need to do is buy a stock on any day from 0 to (i-1) index and sell it on on any ith day , in the process we need to do so such that we get the maximum profit by selling the stock we bought\\nLogic:-  so if we sell a stock on ith day say it has a price of  prices[i] so to get max profit by selling it we should have bought a stock before the ith day ie minimum in price so ie basically\\n min(prices[0...i-1])\\n\\nNote :- we can Buy and sell a stock only once \\n"
                    },
                    {
                        "username": "elliekity",
                        "content": "i got time limit exceeded :joe_angry:"
                    },
                    {
                        "username": "RealJiaJie",
                        "content": "you could solve this with a single pass on the array. No need for double array, recursion, etc. Just a simple for loop."
                    },
                    {
                        "username": "icor",
                        "content": "There is wrong testcase 20. prices =\n[1,2] My output 2. Expected 1. Expected 1 is not correct it should be 2. Buy on day 1 and sell on day 2. Profit 1 "
                    },
                    {
                        "username": "RealJiaJie",
                        "content": "You answered your own problem. Profit = 1. "
                    },
                    {
                        "username": "RealJiaJie",
                        "content": "I don\\'t think this is a dynamic problem."
                    },
                    {
                        "username": "Natnael_32",
                        "content": " Why does the test case [2, 4, 1] pass on my machine but fail here?  [@LeetCode](/LeetCode)"
                    },
                    {
                        "username": "nitheshkumar0731",
                        "content": "can anyone tell me  ,how expected outcome become 1\nfor array [4,1,2]   ,  It should be  2 right?"
                    },
                    {
                        "username": "RealJiaJie",
                        "content": "If you buy now, you can only sell in the future. Think of index as the days. Assuming that array is day 0, 1, 2. you cant buy on day 2 and sell on day 1."
                    },
                    {
                        "username": "arurahul16",
                        "content": "HI Nithesh , just understand index position of sell must be greater than buy position. i hope you will understand now"
                    },
                    {
                        "username": "hola_aryan",
                        "content": "This problem must be categorized as medium level problem. "
                    },
                    {
                        "username": "rubayea",
                        "content": "There is some kind inconsistency with the test cases because some assume that its starts from Day 0 while others on Day 1. However the provided examples follows the normal counting of days starting from 1 . "
                    },
                    {
                        "username": "RealJiaJie",
                        "content": "I had no problem"
                    },
                    {
                        "username": "roshanjhakota",
                        "content": "class Solution {\\npublic:\\n          int maxProfit(vector<int>& prices) {\\n        int n = prices.size();\\n        if (n <= 1)\\n            return 0;\\n\\n        int minPrice = prices[0];\\n        int maxProfit = 0;\\n\\n        for (int i = 1; i < n; i++) {\\n            if (prices[i] < minPrice) {\\n                minPrice = prices[i];\\n            } else if (prices[i] - minPrice > maxProfit) {\\n                maxProfit = prices[i] - minPrice;\\n            }\\n        }\\n\\n        return maxProfit;\\n    }\\n};     Here i have first taken min and max price as index = 0 and max as 0 while iterating over the loop i am changing the value of min max accordingly . Let me explain ....   \\nIf the arr[index] < minPrice then i have to change the minPrice as it become minPrice = arr[index]\\nand the using else if this false it means arr[index] > minPrice then i am just subtracting and checking with the maxProfit if it is maximum then it is answer otherwise maxProfit = price[i] - minPrice;"
                    },
                    {
                        "username": "abhijeetyadav82",
                        "content": "prices = [7,1,5,3,6,4]  Shouldn\\'t the max profit be 7 here. buy at 1 sell at 5. then buy at 3 sell at 6. 4+3 = 7 "
                    },
                    {
                        "username": "RealJiaJie",
                        "content": "I also had the same thinking, however, the key point is that you can only perform ONE transaction throughout the problem. Here you did two. "
                    },
                    {
                        "username": "arurahul16",
                        "content": "hi brother , you are adding the profits , that\\'s not the point, understand you need to find max profit and also need to keep in mind that sell index position should greater than buying index position and then check whether the profit you got is maximum."
                    }
                ]
            },
            {
                "id": 2063495,
                "content": [
                    {
                        "username": "Himanshu_Singh11",
                        "content": "prices = [7,1,5,3,6,4] \\nProblem Statement :- so basically wht we need to do is buy a stock on any day from 0 to (i-1) index and sell it on on any ith day , in the process we need to do so such that we get the maximum profit by selling the stock we bought\\nLogic:-  so if we sell a stock on ith day say it has a price of  prices[i] so to get max profit by selling it we should have bought a stock before the ith day ie minimum in price so ie basically\\n min(prices[0...i-1])\\n\\nNote :- we can Buy and sell a stock only once \\n"
                    },
                    {
                        "username": "elliekity",
                        "content": "i got time limit exceeded :joe_angry:"
                    },
                    {
                        "username": "RealJiaJie",
                        "content": "you could solve this with a single pass on the array. No need for double array, recursion, etc. Just a simple for loop."
                    },
                    {
                        "username": "icor",
                        "content": "There is wrong testcase 20. prices =\n[1,2] My output 2. Expected 1. Expected 1 is not correct it should be 2. Buy on day 1 and sell on day 2. Profit 1 "
                    },
                    {
                        "username": "RealJiaJie",
                        "content": "You answered your own problem. Profit = 1. "
                    },
                    {
                        "username": "RealJiaJie",
                        "content": "I don\\'t think this is a dynamic problem."
                    },
                    {
                        "username": "Natnael_32",
                        "content": " Why does the test case [2, 4, 1] pass on my machine but fail here?  [@LeetCode](/LeetCode)"
                    },
                    {
                        "username": "nitheshkumar0731",
                        "content": "can anyone tell me  ,how expected outcome become 1\nfor array [4,1,2]   ,  It should be  2 right?"
                    },
                    {
                        "username": "RealJiaJie",
                        "content": "If you buy now, you can only sell in the future. Think of index as the days. Assuming that array is day 0, 1, 2. you cant buy on day 2 and sell on day 1."
                    },
                    {
                        "username": "arurahul16",
                        "content": "HI Nithesh , just understand index position of sell must be greater than buy position. i hope you will understand now"
                    },
                    {
                        "username": "hola_aryan",
                        "content": "This problem must be categorized as medium level problem. "
                    },
                    {
                        "username": "rubayea",
                        "content": "There is some kind inconsistency with the test cases because some assume that its starts from Day 0 while others on Day 1. However the provided examples follows the normal counting of days starting from 1 . "
                    },
                    {
                        "username": "RealJiaJie",
                        "content": "I had no problem"
                    },
                    {
                        "username": "roshanjhakota",
                        "content": "class Solution {\\npublic:\\n          int maxProfit(vector<int>& prices) {\\n        int n = prices.size();\\n        if (n <= 1)\\n            return 0;\\n\\n        int minPrice = prices[0];\\n        int maxProfit = 0;\\n\\n        for (int i = 1; i < n; i++) {\\n            if (prices[i] < minPrice) {\\n                minPrice = prices[i];\\n            } else if (prices[i] - minPrice > maxProfit) {\\n                maxProfit = prices[i] - minPrice;\\n            }\\n        }\\n\\n        return maxProfit;\\n    }\\n};     Here i have first taken min and max price as index = 0 and max as 0 while iterating over the loop i am changing the value of min max accordingly . Let me explain ....   \\nIf the arr[index] < minPrice then i have to change the minPrice as it become minPrice = arr[index]\\nand the using else if this false it means arr[index] > minPrice then i am just subtracting and checking with the maxProfit if it is maximum then it is answer otherwise maxProfit = price[i] - minPrice;"
                    },
                    {
                        "username": "abhijeetyadav82",
                        "content": "prices = [7,1,5,3,6,4]  Shouldn\\'t the max profit be 7 here. buy at 1 sell at 5. then buy at 3 sell at 6. 4+3 = 7 "
                    },
                    {
                        "username": "RealJiaJie",
                        "content": "I also had the same thinking, however, the key point is that you can only perform ONE transaction throughout the problem. Here you did two. "
                    },
                    {
                        "username": "arurahul16",
                        "content": "hi brother , you are adding the profits , that\\'s not the point, understand you need to find max profit and also need to keep in mind that sell index position should greater than buying index position and then check whether the profit you got is maximum."
                    }
                ]
            },
            {
                "id": 2062848,
                "content": [
                    {
                        "username": "Himanshu_Singh11",
                        "content": "prices = [7,1,5,3,6,4] \\nProblem Statement :- so basically wht we need to do is buy a stock on any day from 0 to (i-1) index and sell it on on any ith day , in the process we need to do so such that we get the maximum profit by selling the stock we bought\\nLogic:-  so if we sell a stock on ith day say it has a price of  prices[i] so to get max profit by selling it we should have bought a stock before the ith day ie minimum in price so ie basically\\n min(prices[0...i-1])\\n\\nNote :- we can Buy and sell a stock only once \\n"
                    },
                    {
                        "username": "elliekity",
                        "content": "i got time limit exceeded :joe_angry:"
                    },
                    {
                        "username": "RealJiaJie",
                        "content": "you could solve this with a single pass on the array. No need for double array, recursion, etc. Just a simple for loop."
                    },
                    {
                        "username": "icor",
                        "content": "There is wrong testcase 20. prices =\n[1,2] My output 2. Expected 1. Expected 1 is not correct it should be 2. Buy on day 1 and sell on day 2. Profit 1 "
                    },
                    {
                        "username": "RealJiaJie",
                        "content": "You answered your own problem. Profit = 1. "
                    },
                    {
                        "username": "RealJiaJie",
                        "content": "I don\\'t think this is a dynamic problem."
                    },
                    {
                        "username": "Natnael_32",
                        "content": " Why does the test case [2, 4, 1] pass on my machine but fail here?  [@LeetCode](/LeetCode)"
                    },
                    {
                        "username": "nitheshkumar0731",
                        "content": "can anyone tell me  ,how expected outcome become 1\nfor array [4,1,2]   ,  It should be  2 right?"
                    },
                    {
                        "username": "RealJiaJie",
                        "content": "If you buy now, you can only sell in the future. Think of index as the days. Assuming that array is day 0, 1, 2. you cant buy on day 2 and sell on day 1."
                    },
                    {
                        "username": "arurahul16",
                        "content": "HI Nithesh , just understand index position of sell must be greater than buy position. i hope you will understand now"
                    },
                    {
                        "username": "hola_aryan",
                        "content": "This problem must be categorized as medium level problem. "
                    },
                    {
                        "username": "rubayea",
                        "content": "There is some kind inconsistency with the test cases because some assume that its starts from Day 0 while others on Day 1. However the provided examples follows the normal counting of days starting from 1 . "
                    },
                    {
                        "username": "RealJiaJie",
                        "content": "I had no problem"
                    },
                    {
                        "username": "roshanjhakota",
                        "content": "class Solution {\\npublic:\\n          int maxProfit(vector<int>& prices) {\\n        int n = prices.size();\\n        if (n <= 1)\\n            return 0;\\n\\n        int minPrice = prices[0];\\n        int maxProfit = 0;\\n\\n        for (int i = 1; i < n; i++) {\\n            if (prices[i] < minPrice) {\\n                minPrice = prices[i];\\n            } else if (prices[i] - minPrice > maxProfit) {\\n                maxProfit = prices[i] - minPrice;\\n            }\\n        }\\n\\n        return maxProfit;\\n    }\\n};     Here i have first taken min and max price as index = 0 and max as 0 while iterating over the loop i am changing the value of min max accordingly . Let me explain ....   \\nIf the arr[index] < minPrice then i have to change the minPrice as it become minPrice = arr[index]\\nand the using else if this false it means arr[index] > minPrice then i am just subtracting and checking with the maxProfit if it is maximum then it is answer otherwise maxProfit = price[i] - minPrice;"
                    },
                    {
                        "username": "abhijeetyadav82",
                        "content": "prices = [7,1,5,3,6,4]  Shouldn\\'t the max profit be 7 here. buy at 1 sell at 5. then buy at 3 sell at 6. 4+3 = 7 "
                    },
                    {
                        "username": "RealJiaJie",
                        "content": "I also had the same thinking, however, the key point is that you can only perform ONE transaction throughout the problem. Here you did two. "
                    },
                    {
                        "username": "arurahul16",
                        "content": "hi brother , you are adding the profits , that\\'s not the point, understand you need to find max profit and also need to keep in mind that sell index position should greater than buying index position and then check whether the profit you got is maximum."
                    }
                ]
            },
            {
                "id": 2059543,
                "content": [
                    {
                        "username": "KRISHNENDU_MAITY",
                        "content": "prices = [7 , 5 , 2 , 4 , 3 , 1]\\n\\nOutput: 0\\nExpected: 2\\n\\nso you have to transfer \\'max\\' every time you change the \\'min\\'.\\nkeep  record profit = max - min; every time;\\n"
                    },
                    {
                        "username": "adreasnow",
                        "content": "For anyone struggling with time limits in python3, who don't care about getting to an $O(n)$ solution, the bottleneck is probably the use of the `max()` function inside of a loop, that I'm guessing pushes the problem to $O(n^2)$.\n\nIf you use numpy instead, then you can:\n```python\nimport numpy as np\n...\nprices = np.array(prices)\n```\n\nthen you can get the max of the numpy array (or partial numpy array) as `prices.max()` and it will be SIGNIFICANTLY more performant.\n\nI'm guessing (pure speculation) that this is because numpy stores the vector in memory before the loop and only accesses it when called, rather than python constantly building and destroying it with each loop.\n\nI'm sure there's a more efficient way to solve this problem, but getting AN answer is usually more important in an interview than coming up with the *perfect* answer."
                    },
                    {
                        "username": "bharti820",
                        "content": " if we are selling on ith day we have to buy on the minimal price from first i-1\\n\\n\\n\\n    int maxProfit(vector<int>& prices) {\\n       int profit=0,mini=prices[0];\\n       for(int i=1;i<prices.size();i++){\\n           int cost=prices[i]-mini;\\n           profit=max(profit,cost);\\n           mini=min(mini,prices[i]);\\n       } \\n       return profit;\\n    }"
                    },
                    {
                        "username": "praneethKJ",
                        "content": "in question they said prices[i] is the price of a given stock on the ith day,  does mean do we need to consider day from day 0 or 1 as per explation?"
                    },
                    {
                        "username": "parapsychic",
                        "content": "Unless explicitly specified, all problems can be thought of as starting from 0. If not, they\\'ll specify it in the problem or the constraints part."
                    },
                    {
                        "username": "taresh345",
                        "content": "prices =\\n[2,4,1]\\nexpected =2\\nmy output =0 ?\\ncan someone explain it to me how did we arrive to the expected output \\n\\n"
                    },
                    {
                        "username": "arurahul16",
                        "content": "just understand MAX profit , second day you are selling it for profit 2 and 3rd day you cannot sell because the list is empty and also selling index position should be greater than buying index position"
                    },
                    {
                        "username": "ks1313",
                        "content": "[1,2]\\n\\ntest case 3 is wrong, Buy on day 1 and sell on day 2 and return 2. The expected output shows 1. I am confused"
                    },
                    {
                        "username": "shivamyadav2113128",
                        "content": "[@user4279js](/user4279js)  subtract  day1 with day2 \\nprices"
                    },
                    {
                        "username": "user4279js",
                        "content": "If you buy on the first day  that's -\\$1 ... Then sell on the second day +\\$2 ... So you make a profit of $1. You get this value prices[1] - prices[0]"
                    },
                    {
                        "username": "ramongazonil",
                        "content": "I have an issue with the approach shown by [@Adam Kerr](/Serosidium) or [@AlgoEngine](/AlgoEngine), when the array is [3,100, 1, 5] for example. I can not wrap my head around to solve this case with their approach, can someone help me?"
                    },
                    {
                        "username": "Rivo11",
                        "content": "you can think of an array  of max_ right for each element so u can choose the max difference and return it."
                    },
                    {
                        "username": "ChetanJichkar08",
                        "content": "prices =\\n[2,4,1] please explain this output"
                    },
                    {
                        "username": "Rivo11",
                        "content": "the max profit will be 2 .. buy on the first day which is has a value 2 and sell on the second that has value 4.. then the profit = 4 (sell day)- 2 (buy day)= 2"
                    },
                    {
                        "username": "Rivo11",
                        "content": "I got a o(n) solution using o(n) space ... i have only one loop ,and still the time efficency comparing to others not good.. 40% .How can i improve that ?"
                    },
                    {
                        "username": "shivamyadav2113128",
                        "content": "simple dp problem "
                    }
                ]
            },
            {
                "id": 2059222,
                "content": [
                    {
                        "username": "KRISHNENDU_MAITY",
                        "content": "prices = [7 , 5 , 2 , 4 , 3 , 1]\\n\\nOutput: 0\\nExpected: 2\\n\\nso you have to transfer \\'max\\' every time you change the \\'min\\'.\\nkeep  record profit = max - min; every time;\\n"
                    },
                    {
                        "username": "adreasnow",
                        "content": "For anyone struggling with time limits in python3, who don't care about getting to an $O(n)$ solution, the bottleneck is probably the use of the `max()` function inside of a loop, that I'm guessing pushes the problem to $O(n^2)$.\n\nIf you use numpy instead, then you can:\n```python\nimport numpy as np\n...\nprices = np.array(prices)\n```\n\nthen you can get the max of the numpy array (or partial numpy array) as `prices.max()` and it will be SIGNIFICANTLY more performant.\n\nI'm guessing (pure speculation) that this is because numpy stores the vector in memory before the loop and only accesses it when called, rather than python constantly building and destroying it with each loop.\n\nI'm sure there's a more efficient way to solve this problem, but getting AN answer is usually more important in an interview than coming up with the *perfect* answer."
                    },
                    {
                        "username": "bharti820",
                        "content": " if we are selling on ith day we have to buy on the minimal price from first i-1\\n\\n\\n\\n    int maxProfit(vector<int>& prices) {\\n       int profit=0,mini=prices[0];\\n       for(int i=1;i<prices.size();i++){\\n           int cost=prices[i]-mini;\\n           profit=max(profit,cost);\\n           mini=min(mini,prices[i]);\\n       } \\n       return profit;\\n    }"
                    },
                    {
                        "username": "praneethKJ",
                        "content": "in question they said prices[i] is the price of a given stock on the ith day,  does mean do we need to consider day from day 0 or 1 as per explation?"
                    },
                    {
                        "username": "parapsychic",
                        "content": "Unless explicitly specified, all problems can be thought of as starting from 0. If not, they\\'ll specify it in the problem or the constraints part."
                    },
                    {
                        "username": "taresh345",
                        "content": "prices =\\n[2,4,1]\\nexpected =2\\nmy output =0 ?\\ncan someone explain it to me how did we arrive to the expected output \\n\\n"
                    },
                    {
                        "username": "arurahul16",
                        "content": "just understand MAX profit , second day you are selling it for profit 2 and 3rd day you cannot sell because the list is empty and also selling index position should be greater than buying index position"
                    },
                    {
                        "username": "ks1313",
                        "content": "[1,2]\\n\\ntest case 3 is wrong, Buy on day 1 and sell on day 2 and return 2. The expected output shows 1. I am confused"
                    },
                    {
                        "username": "shivamyadav2113128",
                        "content": "[@user4279js](/user4279js)  subtract  day1 with day2 \\nprices"
                    },
                    {
                        "username": "user4279js",
                        "content": "If you buy on the first day  that's -\\$1 ... Then sell on the second day +\\$2 ... So you make a profit of $1. You get this value prices[1] - prices[0]"
                    },
                    {
                        "username": "ramongazonil",
                        "content": "I have an issue with the approach shown by [@Adam Kerr](/Serosidium) or [@AlgoEngine](/AlgoEngine), when the array is [3,100, 1, 5] for example. I can not wrap my head around to solve this case with their approach, can someone help me?"
                    },
                    {
                        "username": "Rivo11",
                        "content": "you can think of an array  of max_ right for each element so u can choose the max difference and return it."
                    },
                    {
                        "username": "ChetanJichkar08",
                        "content": "prices =\\n[2,4,1] please explain this output"
                    },
                    {
                        "username": "Rivo11",
                        "content": "the max profit will be 2 .. buy on the first day which is has a value 2 and sell on the second that has value 4.. then the profit = 4 (sell day)- 2 (buy day)= 2"
                    },
                    {
                        "username": "Rivo11",
                        "content": "I got a o(n) solution using o(n) space ... i have only one loop ,and still the time efficency comparing to others not good.. 40% .How can i improve that ?"
                    },
                    {
                        "username": "shivamyadav2113128",
                        "content": "simple dp problem "
                    }
                ]
            },
            {
                "id": 2058635,
                "content": [
                    {
                        "username": "KRISHNENDU_MAITY",
                        "content": "prices = [7 , 5 , 2 , 4 , 3 , 1]\\n\\nOutput: 0\\nExpected: 2\\n\\nso you have to transfer \\'max\\' every time you change the \\'min\\'.\\nkeep  record profit = max - min; every time;\\n"
                    },
                    {
                        "username": "adreasnow",
                        "content": "For anyone struggling with time limits in python3, who don't care about getting to an $O(n)$ solution, the bottleneck is probably the use of the `max()` function inside of a loop, that I'm guessing pushes the problem to $O(n^2)$.\n\nIf you use numpy instead, then you can:\n```python\nimport numpy as np\n...\nprices = np.array(prices)\n```\n\nthen you can get the max of the numpy array (or partial numpy array) as `prices.max()` and it will be SIGNIFICANTLY more performant.\n\nI'm guessing (pure speculation) that this is because numpy stores the vector in memory before the loop and only accesses it when called, rather than python constantly building and destroying it with each loop.\n\nI'm sure there's a more efficient way to solve this problem, but getting AN answer is usually more important in an interview than coming up with the *perfect* answer."
                    },
                    {
                        "username": "bharti820",
                        "content": " if we are selling on ith day we have to buy on the minimal price from first i-1\\n\\n\\n\\n    int maxProfit(vector<int>& prices) {\\n       int profit=0,mini=prices[0];\\n       for(int i=1;i<prices.size();i++){\\n           int cost=prices[i]-mini;\\n           profit=max(profit,cost);\\n           mini=min(mini,prices[i]);\\n       } \\n       return profit;\\n    }"
                    },
                    {
                        "username": "praneethKJ",
                        "content": "in question they said prices[i] is the price of a given stock on the ith day,  does mean do we need to consider day from day 0 or 1 as per explation?"
                    },
                    {
                        "username": "parapsychic",
                        "content": "Unless explicitly specified, all problems can be thought of as starting from 0. If not, they\\'ll specify it in the problem or the constraints part."
                    },
                    {
                        "username": "taresh345",
                        "content": "prices =\\n[2,4,1]\\nexpected =2\\nmy output =0 ?\\ncan someone explain it to me how did we arrive to the expected output \\n\\n"
                    },
                    {
                        "username": "arurahul16",
                        "content": "just understand MAX profit , second day you are selling it for profit 2 and 3rd day you cannot sell because the list is empty and also selling index position should be greater than buying index position"
                    },
                    {
                        "username": "ks1313",
                        "content": "[1,2]\\n\\ntest case 3 is wrong, Buy on day 1 and sell on day 2 and return 2. The expected output shows 1. I am confused"
                    },
                    {
                        "username": "shivamyadav2113128",
                        "content": "[@user4279js](/user4279js)  subtract  day1 with day2 \\nprices"
                    },
                    {
                        "username": "user4279js",
                        "content": "If you buy on the first day  that's -\\$1 ... Then sell on the second day +\\$2 ... So you make a profit of $1. You get this value prices[1] - prices[0]"
                    },
                    {
                        "username": "ramongazonil",
                        "content": "I have an issue with the approach shown by [@Adam Kerr](/Serosidium) or [@AlgoEngine](/AlgoEngine), when the array is [3,100, 1, 5] for example. I can not wrap my head around to solve this case with their approach, can someone help me?"
                    },
                    {
                        "username": "Rivo11",
                        "content": "you can think of an array  of max_ right for each element so u can choose the max difference and return it."
                    },
                    {
                        "username": "ChetanJichkar08",
                        "content": "prices =\\n[2,4,1] please explain this output"
                    },
                    {
                        "username": "Rivo11",
                        "content": "the max profit will be 2 .. buy on the first day which is has a value 2 and sell on the second that has value 4.. then the profit = 4 (sell day)- 2 (buy day)= 2"
                    },
                    {
                        "username": "Rivo11",
                        "content": "I got a o(n) solution using o(n) space ... i have only one loop ,and still the time efficency comparing to others not good.. 40% .How can i improve that ?"
                    },
                    {
                        "username": "shivamyadav2113128",
                        "content": "simple dp problem "
                    }
                ]
            },
            {
                "id": 2057134,
                "content": [
                    {
                        "username": "KRISHNENDU_MAITY",
                        "content": "prices = [7 , 5 , 2 , 4 , 3 , 1]\\n\\nOutput: 0\\nExpected: 2\\n\\nso you have to transfer \\'max\\' every time you change the \\'min\\'.\\nkeep  record profit = max - min; every time;\\n"
                    },
                    {
                        "username": "adreasnow",
                        "content": "For anyone struggling with time limits in python3, who don't care about getting to an $O(n)$ solution, the bottleneck is probably the use of the `max()` function inside of a loop, that I'm guessing pushes the problem to $O(n^2)$.\n\nIf you use numpy instead, then you can:\n```python\nimport numpy as np\n...\nprices = np.array(prices)\n```\n\nthen you can get the max of the numpy array (or partial numpy array) as `prices.max()` and it will be SIGNIFICANTLY more performant.\n\nI'm guessing (pure speculation) that this is because numpy stores the vector in memory before the loop and only accesses it when called, rather than python constantly building and destroying it with each loop.\n\nI'm sure there's a more efficient way to solve this problem, but getting AN answer is usually more important in an interview than coming up with the *perfect* answer."
                    },
                    {
                        "username": "bharti820",
                        "content": " if we are selling on ith day we have to buy on the minimal price from first i-1\\n\\n\\n\\n    int maxProfit(vector<int>& prices) {\\n       int profit=0,mini=prices[0];\\n       for(int i=1;i<prices.size();i++){\\n           int cost=prices[i]-mini;\\n           profit=max(profit,cost);\\n           mini=min(mini,prices[i]);\\n       } \\n       return profit;\\n    }"
                    },
                    {
                        "username": "praneethKJ",
                        "content": "in question they said prices[i] is the price of a given stock on the ith day,  does mean do we need to consider day from day 0 or 1 as per explation?"
                    },
                    {
                        "username": "parapsychic",
                        "content": "Unless explicitly specified, all problems can be thought of as starting from 0. If not, they\\'ll specify it in the problem or the constraints part."
                    },
                    {
                        "username": "taresh345",
                        "content": "prices =\\n[2,4,1]\\nexpected =2\\nmy output =0 ?\\ncan someone explain it to me how did we arrive to the expected output \\n\\n"
                    },
                    {
                        "username": "arurahul16",
                        "content": "just understand MAX profit , second day you are selling it for profit 2 and 3rd day you cannot sell because the list is empty and also selling index position should be greater than buying index position"
                    },
                    {
                        "username": "ks1313",
                        "content": "[1,2]\\n\\ntest case 3 is wrong, Buy on day 1 and sell on day 2 and return 2. The expected output shows 1. I am confused"
                    },
                    {
                        "username": "shivamyadav2113128",
                        "content": "[@user4279js](/user4279js)  subtract  day1 with day2 \\nprices"
                    },
                    {
                        "username": "user4279js",
                        "content": "If you buy on the first day  that's -\\$1 ... Then sell on the second day +\\$2 ... So you make a profit of $1. You get this value prices[1] - prices[0]"
                    },
                    {
                        "username": "ramongazonil",
                        "content": "I have an issue with the approach shown by [@Adam Kerr](/Serosidium) or [@AlgoEngine](/AlgoEngine), when the array is [3,100, 1, 5] for example. I can not wrap my head around to solve this case with their approach, can someone help me?"
                    },
                    {
                        "username": "Rivo11",
                        "content": "you can think of an array  of max_ right for each element so u can choose the max difference and return it."
                    },
                    {
                        "username": "ChetanJichkar08",
                        "content": "prices =\\n[2,4,1] please explain this output"
                    },
                    {
                        "username": "Rivo11",
                        "content": "the max profit will be 2 .. buy on the first day which is has a value 2 and sell on the second that has value 4.. then the profit = 4 (sell day)- 2 (buy day)= 2"
                    },
                    {
                        "username": "Rivo11",
                        "content": "I got a o(n) solution using o(n) space ... i have only one loop ,and still the time efficency comparing to others not good.. 40% .How can i improve that ?"
                    },
                    {
                        "username": "shivamyadav2113128",
                        "content": "simple dp problem "
                    }
                ]
            },
            {
                "id": 2053504,
                "content": [
                    {
                        "username": "KRISHNENDU_MAITY",
                        "content": "prices = [7 , 5 , 2 , 4 , 3 , 1]\\n\\nOutput: 0\\nExpected: 2\\n\\nso you have to transfer \\'max\\' every time you change the \\'min\\'.\\nkeep  record profit = max - min; every time;\\n"
                    },
                    {
                        "username": "adreasnow",
                        "content": "For anyone struggling with time limits in python3, who don't care about getting to an $O(n)$ solution, the bottleneck is probably the use of the `max()` function inside of a loop, that I'm guessing pushes the problem to $O(n^2)$.\n\nIf you use numpy instead, then you can:\n```python\nimport numpy as np\n...\nprices = np.array(prices)\n```\n\nthen you can get the max of the numpy array (or partial numpy array) as `prices.max()` and it will be SIGNIFICANTLY more performant.\n\nI'm guessing (pure speculation) that this is because numpy stores the vector in memory before the loop and only accesses it when called, rather than python constantly building and destroying it with each loop.\n\nI'm sure there's a more efficient way to solve this problem, but getting AN answer is usually more important in an interview than coming up with the *perfect* answer."
                    },
                    {
                        "username": "bharti820",
                        "content": " if we are selling on ith day we have to buy on the minimal price from first i-1\\n\\n\\n\\n    int maxProfit(vector<int>& prices) {\\n       int profit=0,mini=prices[0];\\n       for(int i=1;i<prices.size();i++){\\n           int cost=prices[i]-mini;\\n           profit=max(profit,cost);\\n           mini=min(mini,prices[i]);\\n       } \\n       return profit;\\n    }"
                    },
                    {
                        "username": "praneethKJ",
                        "content": "in question they said prices[i] is the price of a given stock on the ith day,  does mean do we need to consider day from day 0 or 1 as per explation?"
                    },
                    {
                        "username": "parapsychic",
                        "content": "Unless explicitly specified, all problems can be thought of as starting from 0. If not, they\\'ll specify it in the problem or the constraints part."
                    },
                    {
                        "username": "taresh345",
                        "content": "prices =\\n[2,4,1]\\nexpected =2\\nmy output =0 ?\\ncan someone explain it to me how did we arrive to the expected output \\n\\n"
                    },
                    {
                        "username": "arurahul16",
                        "content": "just understand MAX profit , second day you are selling it for profit 2 and 3rd day you cannot sell because the list is empty and also selling index position should be greater than buying index position"
                    },
                    {
                        "username": "ks1313",
                        "content": "[1,2]\\n\\ntest case 3 is wrong, Buy on day 1 and sell on day 2 and return 2. The expected output shows 1. I am confused"
                    },
                    {
                        "username": "shivamyadav2113128",
                        "content": "[@user4279js](/user4279js)  subtract  day1 with day2 \\nprices"
                    },
                    {
                        "username": "user4279js",
                        "content": "If you buy on the first day  that's -\\$1 ... Then sell on the second day +\\$2 ... So you make a profit of $1. You get this value prices[1] - prices[0]"
                    },
                    {
                        "username": "ramongazonil",
                        "content": "I have an issue with the approach shown by [@Adam Kerr](/Serosidium) or [@AlgoEngine](/AlgoEngine), when the array is [3,100, 1, 5] for example. I can not wrap my head around to solve this case with their approach, can someone help me?"
                    },
                    {
                        "username": "Rivo11",
                        "content": "you can think of an array  of max_ right for each element so u can choose the max difference and return it."
                    },
                    {
                        "username": "ChetanJichkar08",
                        "content": "prices =\\n[2,4,1] please explain this output"
                    },
                    {
                        "username": "Rivo11",
                        "content": "the max profit will be 2 .. buy on the first day which is has a value 2 and sell on the second that has value 4.. then the profit = 4 (sell day)- 2 (buy day)= 2"
                    },
                    {
                        "username": "Rivo11",
                        "content": "I got a o(n) solution using o(n) space ... i have only one loop ,and still the time efficency comparing to others not good.. 40% .How can i improve that ?"
                    },
                    {
                        "username": "shivamyadav2113128",
                        "content": "simple dp problem "
                    }
                ]
            },
            {
                "id": 2050021,
                "content": [
                    {
                        "username": "KRISHNENDU_MAITY",
                        "content": "prices = [7 , 5 , 2 , 4 , 3 , 1]\\n\\nOutput: 0\\nExpected: 2\\n\\nso you have to transfer \\'max\\' every time you change the \\'min\\'.\\nkeep  record profit = max - min; every time;\\n"
                    },
                    {
                        "username": "adreasnow",
                        "content": "For anyone struggling with time limits in python3, who don't care about getting to an $O(n)$ solution, the bottleneck is probably the use of the `max()` function inside of a loop, that I'm guessing pushes the problem to $O(n^2)$.\n\nIf you use numpy instead, then you can:\n```python\nimport numpy as np\n...\nprices = np.array(prices)\n```\n\nthen you can get the max of the numpy array (or partial numpy array) as `prices.max()` and it will be SIGNIFICANTLY more performant.\n\nI'm guessing (pure speculation) that this is because numpy stores the vector in memory before the loop and only accesses it when called, rather than python constantly building and destroying it with each loop.\n\nI'm sure there's a more efficient way to solve this problem, but getting AN answer is usually more important in an interview than coming up with the *perfect* answer."
                    },
                    {
                        "username": "bharti820",
                        "content": " if we are selling on ith day we have to buy on the minimal price from first i-1\\n\\n\\n\\n    int maxProfit(vector<int>& prices) {\\n       int profit=0,mini=prices[0];\\n       for(int i=1;i<prices.size();i++){\\n           int cost=prices[i]-mini;\\n           profit=max(profit,cost);\\n           mini=min(mini,prices[i]);\\n       } \\n       return profit;\\n    }"
                    },
                    {
                        "username": "praneethKJ",
                        "content": "in question they said prices[i] is the price of a given stock on the ith day,  does mean do we need to consider day from day 0 or 1 as per explation?"
                    },
                    {
                        "username": "parapsychic",
                        "content": "Unless explicitly specified, all problems can be thought of as starting from 0. If not, they\\'ll specify it in the problem or the constraints part."
                    },
                    {
                        "username": "taresh345",
                        "content": "prices =\\n[2,4,1]\\nexpected =2\\nmy output =0 ?\\ncan someone explain it to me how did we arrive to the expected output \\n\\n"
                    },
                    {
                        "username": "arurahul16",
                        "content": "just understand MAX profit , second day you are selling it for profit 2 and 3rd day you cannot sell because the list is empty and also selling index position should be greater than buying index position"
                    },
                    {
                        "username": "ks1313",
                        "content": "[1,2]\\n\\ntest case 3 is wrong, Buy on day 1 and sell on day 2 and return 2. The expected output shows 1. I am confused"
                    },
                    {
                        "username": "shivamyadav2113128",
                        "content": "[@user4279js](/user4279js)  subtract  day1 with day2 \\nprices"
                    },
                    {
                        "username": "user4279js",
                        "content": "If you buy on the first day  that's -\\$1 ... Then sell on the second day +\\$2 ... So you make a profit of $1. You get this value prices[1] - prices[0]"
                    },
                    {
                        "username": "ramongazonil",
                        "content": "I have an issue with the approach shown by [@Adam Kerr](/Serosidium) or [@AlgoEngine](/AlgoEngine), when the array is [3,100, 1, 5] for example. I can not wrap my head around to solve this case with their approach, can someone help me?"
                    },
                    {
                        "username": "Rivo11",
                        "content": "you can think of an array  of max_ right for each element so u can choose the max difference and return it."
                    },
                    {
                        "username": "ChetanJichkar08",
                        "content": "prices =\\n[2,4,1] please explain this output"
                    },
                    {
                        "username": "Rivo11",
                        "content": "the max profit will be 2 .. buy on the first day which is has a value 2 and sell on the second that has value 4.. then the profit = 4 (sell day)- 2 (buy day)= 2"
                    },
                    {
                        "username": "Rivo11",
                        "content": "I got a o(n) solution using o(n) space ... i have only one loop ,and still the time efficency comparing to others not good.. 40% .How can i improve that ?"
                    },
                    {
                        "username": "shivamyadav2113128",
                        "content": "simple dp problem "
                    }
                ]
            },
            {
                "id": 2047035,
                "content": [
                    {
                        "username": "KRISHNENDU_MAITY",
                        "content": "prices = [7 , 5 , 2 , 4 , 3 , 1]\\n\\nOutput: 0\\nExpected: 2\\n\\nso you have to transfer \\'max\\' every time you change the \\'min\\'.\\nkeep  record profit = max - min; every time;\\n"
                    },
                    {
                        "username": "adreasnow",
                        "content": "For anyone struggling with time limits in python3, who don't care about getting to an $O(n)$ solution, the bottleneck is probably the use of the `max()` function inside of a loop, that I'm guessing pushes the problem to $O(n^2)$.\n\nIf you use numpy instead, then you can:\n```python\nimport numpy as np\n...\nprices = np.array(prices)\n```\n\nthen you can get the max of the numpy array (or partial numpy array) as `prices.max()` and it will be SIGNIFICANTLY more performant.\n\nI'm guessing (pure speculation) that this is because numpy stores the vector in memory before the loop and only accesses it when called, rather than python constantly building and destroying it with each loop.\n\nI'm sure there's a more efficient way to solve this problem, but getting AN answer is usually more important in an interview than coming up with the *perfect* answer."
                    },
                    {
                        "username": "bharti820",
                        "content": " if we are selling on ith day we have to buy on the minimal price from first i-1\\n\\n\\n\\n    int maxProfit(vector<int>& prices) {\\n       int profit=0,mini=prices[0];\\n       for(int i=1;i<prices.size();i++){\\n           int cost=prices[i]-mini;\\n           profit=max(profit,cost);\\n           mini=min(mini,prices[i]);\\n       } \\n       return profit;\\n    }"
                    },
                    {
                        "username": "praneethKJ",
                        "content": "in question they said prices[i] is the price of a given stock on the ith day,  does mean do we need to consider day from day 0 or 1 as per explation?"
                    },
                    {
                        "username": "parapsychic",
                        "content": "Unless explicitly specified, all problems can be thought of as starting from 0. If not, they\\'ll specify it in the problem or the constraints part."
                    },
                    {
                        "username": "taresh345",
                        "content": "prices =\\n[2,4,1]\\nexpected =2\\nmy output =0 ?\\ncan someone explain it to me how did we arrive to the expected output \\n\\n"
                    },
                    {
                        "username": "arurahul16",
                        "content": "just understand MAX profit , second day you are selling it for profit 2 and 3rd day you cannot sell because the list is empty and also selling index position should be greater than buying index position"
                    },
                    {
                        "username": "ks1313",
                        "content": "[1,2]\\n\\ntest case 3 is wrong, Buy on day 1 and sell on day 2 and return 2. The expected output shows 1. I am confused"
                    },
                    {
                        "username": "shivamyadav2113128",
                        "content": "[@user4279js](/user4279js)  subtract  day1 with day2 \\nprices"
                    },
                    {
                        "username": "user4279js",
                        "content": "If you buy on the first day  that's -\\$1 ... Then sell on the second day +\\$2 ... So you make a profit of $1. You get this value prices[1] - prices[0]"
                    },
                    {
                        "username": "ramongazonil",
                        "content": "I have an issue with the approach shown by [@Adam Kerr](/Serosidium) or [@AlgoEngine](/AlgoEngine), when the array is [3,100, 1, 5] for example. I can not wrap my head around to solve this case with their approach, can someone help me?"
                    },
                    {
                        "username": "Rivo11",
                        "content": "you can think of an array  of max_ right for each element so u can choose the max difference and return it."
                    },
                    {
                        "username": "ChetanJichkar08",
                        "content": "prices =\\n[2,4,1] please explain this output"
                    },
                    {
                        "username": "Rivo11",
                        "content": "the max profit will be 2 .. buy on the first day which is has a value 2 and sell on the second that has value 4.. then the profit = 4 (sell day)- 2 (buy day)= 2"
                    },
                    {
                        "username": "Rivo11",
                        "content": "I got a o(n) solution using o(n) space ... i have only one loop ,and still the time efficency comparing to others not good.. 40% .How can i improve that ?"
                    },
                    {
                        "username": "shivamyadav2113128",
                        "content": "simple dp problem "
                    }
                ]
            },
            {
                "id": 2046535,
                "content": [
                    {
                        "username": "KRISHNENDU_MAITY",
                        "content": "prices = [7 , 5 , 2 , 4 , 3 , 1]\\n\\nOutput: 0\\nExpected: 2\\n\\nso you have to transfer \\'max\\' every time you change the \\'min\\'.\\nkeep  record profit = max - min; every time;\\n"
                    },
                    {
                        "username": "adreasnow",
                        "content": "For anyone struggling with time limits in python3, who don't care about getting to an $O(n)$ solution, the bottleneck is probably the use of the `max()` function inside of a loop, that I'm guessing pushes the problem to $O(n^2)$.\n\nIf you use numpy instead, then you can:\n```python\nimport numpy as np\n...\nprices = np.array(prices)\n```\n\nthen you can get the max of the numpy array (or partial numpy array) as `prices.max()` and it will be SIGNIFICANTLY more performant.\n\nI'm guessing (pure speculation) that this is because numpy stores the vector in memory before the loop and only accesses it when called, rather than python constantly building and destroying it with each loop.\n\nI'm sure there's a more efficient way to solve this problem, but getting AN answer is usually more important in an interview than coming up with the *perfect* answer."
                    },
                    {
                        "username": "bharti820",
                        "content": " if we are selling on ith day we have to buy on the minimal price from first i-1\\n\\n\\n\\n    int maxProfit(vector<int>& prices) {\\n       int profit=0,mini=prices[0];\\n       for(int i=1;i<prices.size();i++){\\n           int cost=prices[i]-mini;\\n           profit=max(profit,cost);\\n           mini=min(mini,prices[i]);\\n       } \\n       return profit;\\n    }"
                    },
                    {
                        "username": "praneethKJ",
                        "content": "in question they said prices[i] is the price of a given stock on the ith day,  does mean do we need to consider day from day 0 or 1 as per explation?"
                    },
                    {
                        "username": "parapsychic",
                        "content": "Unless explicitly specified, all problems can be thought of as starting from 0. If not, they\\'ll specify it in the problem or the constraints part."
                    },
                    {
                        "username": "taresh345",
                        "content": "prices =\\n[2,4,1]\\nexpected =2\\nmy output =0 ?\\ncan someone explain it to me how did we arrive to the expected output \\n\\n"
                    },
                    {
                        "username": "arurahul16",
                        "content": "just understand MAX profit , second day you are selling it for profit 2 and 3rd day you cannot sell because the list is empty and also selling index position should be greater than buying index position"
                    },
                    {
                        "username": "ks1313",
                        "content": "[1,2]\\n\\ntest case 3 is wrong, Buy on day 1 and sell on day 2 and return 2. The expected output shows 1. I am confused"
                    },
                    {
                        "username": "shivamyadav2113128",
                        "content": "[@user4279js](/user4279js)  subtract  day1 with day2 \\nprices"
                    },
                    {
                        "username": "user4279js",
                        "content": "If you buy on the first day  that's -\\$1 ... Then sell on the second day +\\$2 ... So you make a profit of $1. You get this value prices[1] - prices[0]"
                    },
                    {
                        "username": "ramongazonil",
                        "content": "I have an issue with the approach shown by [@Adam Kerr](/Serosidium) or [@AlgoEngine](/AlgoEngine), when the array is [3,100, 1, 5] for example. I can not wrap my head around to solve this case with their approach, can someone help me?"
                    },
                    {
                        "username": "Rivo11",
                        "content": "you can think of an array  of max_ right for each element so u can choose the max difference and return it."
                    },
                    {
                        "username": "ChetanJichkar08",
                        "content": "prices =\\n[2,4,1] please explain this output"
                    },
                    {
                        "username": "Rivo11",
                        "content": "the max profit will be 2 .. buy on the first day which is has a value 2 and sell on the second that has value 4.. then the profit = 4 (sell day)- 2 (buy day)= 2"
                    },
                    {
                        "username": "Rivo11",
                        "content": "I got a o(n) solution using o(n) space ... i have only one loop ,and still the time efficency comparing to others not good.. 40% .How can i improve that ?"
                    },
                    {
                        "username": "shivamyadav2113128",
                        "content": "simple dp problem "
                    }
                ]
            },
            {
                "id": 2040489,
                "content": [
                    {
                        "username": "KRISHNENDU_MAITY",
                        "content": "prices = [7 , 5 , 2 , 4 , 3 , 1]\\n\\nOutput: 0\\nExpected: 2\\n\\nso you have to transfer \\'max\\' every time you change the \\'min\\'.\\nkeep  record profit = max - min; every time;\\n"
                    },
                    {
                        "username": "adreasnow",
                        "content": "For anyone struggling with time limits in python3, who don't care about getting to an $O(n)$ solution, the bottleneck is probably the use of the `max()` function inside of a loop, that I'm guessing pushes the problem to $O(n^2)$.\n\nIf you use numpy instead, then you can:\n```python\nimport numpy as np\n...\nprices = np.array(prices)\n```\n\nthen you can get the max of the numpy array (or partial numpy array) as `prices.max()` and it will be SIGNIFICANTLY more performant.\n\nI'm guessing (pure speculation) that this is because numpy stores the vector in memory before the loop and only accesses it when called, rather than python constantly building and destroying it with each loop.\n\nI'm sure there's a more efficient way to solve this problem, but getting AN answer is usually more important in an interview than coming up with the *perfect* answer."
                    },
                    {
                        "username": "bharti820",
                        "content": " if we are selling on ith day we have to buy on the minimal price from first i-1\\n\\n\\n\\n    int maxProfit(vector<int>& prices) {\\n       int profit=0,mini=prices[0];\\n       for(int i=1;i<prices.size();i++){\\n           int cost=prices[i]-mini;\\n           profit=max(profit,cost);\\n           mini=min(mini,prices[i]);\\n       } \\n       return profit;\\n    }"
                    },
                    {
                        "username": "praneethKJ",
                        "content": "in question they said prices[i] is the price of a given stock on the ith day,  does mean do we need to consider day from day 0 or 1 as per explation?"
                    },
                    {
                        "username": "parapsychic",
                        "content": "Unless explicitly specified, all problems can be thought of as starting from 0. If not, they\\'ll specify it in the problem or the constraints part."
                    },
                    {
                        "username": "taresh345",
                        "content": "prices =\\n[2,4,1]\\nexpected =2\\nmy output =0 ?\\ncan someone explain it to me how did we arrive to the expected output \\n\\n"
                    },
                    {
                        "username": "arurahul16",
                        "content": "just understand MAX profit , second day you are selling it for profit 2 and 3rd day you cannot sell because the list is empty and also selling index position should be greater than buying index position"
                    },
                    {
                        "username": "ks1313",
                        "content": "[1,2]\\n\\ntest case 3 is wrong, Buy on day 1 and sell on day 2 and return 2. The expected output shows 1. I am confused"
                    },
                    {
                        "username": "shivamyadav2113128",
                        "content": "[@user4279js](/user4279js)  subtract  day1 with day2 \\nprices"
                    },
                    {
                        "username": "user4279js",
                        "content": "If you buy on the first day  that's -\\$1 ... Then sell on the second day +\\$2 ... So you make a profit of $1. You get this value prices[1] - prices[0]"
                    },
                    {
                        "username": "ramongazonil",
                        "content": "I have an issue with the approach shown by [@Adam Kerr](/Serosidium) or [@AlgoEngine](/AlgoEngine), when the array is [3,100, 1, 5] for example. I can not wrap my head around to solve this case with their approach, can someone help me?"
                    },
                    {
                        "username": "Rivo11",
                        "content": "you can think of an array  of max_ right for each element so u can choose the max difference and return it."
                    },
                    {
                        "username": "ChetanJichkar08",
                        "content": "prices =\\n[2,4,1] please explain this output"
                    },
                    {
                        "username": "Rivo11",
                        "content": "the max profit will be 2 .. buy on the first day which is has a value 2 and sell on the second that has value 4.. then the profit = 4 (sell day)- 2 (buy day)= 2"
                    },
                    {
                        "username": "Rivo11",
                        "content": "I got a o(n) solution using o(n) space ... i have only one loop ,and still the time efficency comparing to others not good.. 40% .How can i improve that ?"
                    },
                    {
                        "username": "shivamyadav2113128",
                        "content": "simple dp problem "
                    }
                ]
            },
            {
                "id": 2035481,
                "content": [
                    {
                        "username": "KRISHNENDU_MAITY",
                        "content": "prices = [7 , 5 , 2 , 4 , 3 , 1]\\n\\nOutput: 0\\nExpected: 2\\n\\nso you have to transfer \\'max\\' every time you change the \\'min\\'.\\nkeep  record profit = max - min; every time;\\n"
                    },
                    {
                        "username": "adreasnow",
                        "content": "For anyone struggling with time limits in python3, who don't care about getting to an $O(n)$ solution, the bottleneck is probably the use of the `max()` function inside of a loop, that I'm guessing pushes the problem to $O(n^2)$.\n\nIf you use numpy instead, then you can:\n```python\nimport numpy as np\n...\nprices = np.array(prices)\n```\n\nthen you can get the max of the numpy array (or partial numpy array) as `prices.max()` and it will be SIGNIFICANTLY more performant.\n\nI'm guessing (pure speculation) that this is because numpy stores the vector in memory before the loop and only accesses it when called, rather than python constantly building and destroying it with each loop.\n\nI'm sure there's a more efficient way to solve this problem, but getting AN answer is usually more important in an interview than coming up with the *perfect* answer."
                    },
                    {
                        "username": "bharti820",
                        "content": " if we are selling on ith day we have to buy on the minimal price from first i-1\\n\\n\\n\\n    int maxProfit(vector<int>& prices) {\\n       int profit=0,mini=prices[0];\\n       for(int i=1;i<prices.size();i++){\\n           int cost=prices[i]-mini;\\n           profit=max(profit,cost);\\n           mini=min(mini,prices[i]);\\n       } \\n       return profit;\\n    }"
                    },
                    {
                        "username": "praneethKJ",
                        "content": "in question they said prices[i] is the price of a given stock on the ith day,  does mean do we need to consider day from day 0 or 1 as per explation?"
                    },
                    {
                        "username": "parapsychic",
                        "content": "Unless explicitly specified, all problems can be thought of as starting from 0. If not, they\\'ll specify it in the problem or the constraints part."
                    },
                    {
                        "username": "taresh345",
                        "content": "prices =\\n[2,4,1]\\nexpected =2\\nmy output =0 ?\\ncan someone explain it to me how did we arrive to the expected output \\n\\n"
                    },
                    {
                        "username": "arurahul16",
                        "content": "just understand MAX profit , second day you are selling it for profit 2 and 3rd day you cannot sell because the list is empty and also selling index position should be greater than buying index position"
                    },
                    {
                        "username": "ks1313",
                        "content": "[1,2]\\n\\ntest case 3 is wrong, Buy on day 1 and sell on day 2 and return 2. The expected output shows 1. I am confused"
                    },
                    {
                        "username": "shivamyadav2113128",
                        "content": "[@user4279js](/user4279js)  subtract  day1 with day2 \\nprices"
                    },
                    {
                        "username": "user4279js",
                        "content": "If you buy on the first day  that's -\\$1 ... Then sell on the second day +\\$2 ... So you make a profit of $1. You get this value prices[1] - prices[0]"
                    },
                    {
                        "username": "ramongazonil",
                        "content": "I have an issue with the approach shown by [@Adam Kerr](/Serosidium) or [@AlgoEngine](/AlgoEngine), when the array is [3,100, 1, 5] for example. I can not wrap my head around to solve this case with their approach, can someone help me?"
                    },
                    {
                        "username": "Rivo11",
                        "content": "you can think of an array  of max_ right for each element so u can choose the max difference and return it."
                    },
                    {
                        "username": "ChetanJichkar08",
                        "content": "prices =\\n[2,4,1] please explain this output"
                    },
                    {
                        "username": "Rivo11",
                        "content": "the max profit will be 2 .. buy on the first day which is has a value 2 and sell on the second that has value 4.. then the profit = 4 (sell day)- 2 (buy day)= 2"
                    },
                    {
                        "username": "Rivo11",
                        "content": "I got a o(n) solution using o(n) space ... i have only one loop ,and still the time efficency comparing to others not good.. 40% .How can i improve that ?"
                    },
                    {
                        "username": "shivamyadav2113128",
                        "content": "simple dp problem "
                    }
                ]
            },
            {
                "id": 2034941,
                "content": [
                    {
                        "username": "gmnaik96",
                        "content": "Q1. Why am I getting time limit exceeded error for following code?\\n\\nprofit = 0\\n\\n        for i in range(0,len(prices)-1):\\n            key = prices[i]\\n            for j in range(i+1,len(prices)):\\n                if(prices[j] > key):\\n                    newprofit = prices[j] - key\\n                    \\n                    if(newprofit > profit):\\n                        profit = newprofit\\n                  \\n        return profit"
                    },
                    {
                        "username": "Rivo11",
                        "content": "Because your code run in o(n^2) brute force .. and the test cases provided make you must run your code in a less time \\n2 options :\\n1) Optimize your o(n^2) .. you will submit but in a low time efficency\\n2) Find a o(n) solution using extra space."
                    },
                    {
                        "username": "Strix_wl",
                        "content": "This cant be easy XD"
                    },
                    {
                        "username": "daria_mp",
                        "content": "i make this declaration \\ndef maxProfit(self, prices = List[int]) -> int: \\nand it says invalid syntax. I don\\'t know why. I\\'ve used it before and it worked properly. Can someone give me a hint?"
                    },
                    {
                        "username": "kar10arora",
                        "content": "I am getting this error again and again during the compilation of the code. And I have Checked the code in different compiler and it is running successfully. So why I am getting this error here again and again..\\n\\n=================================================================\\n==23==ERROR: AddressSanitizer: heap-buffer-overflow on address 0x603000000028 at pc 0x560e7035f015 bp 0x7ffeb3ced9a0 sp 0x7ffeb3ced990\\nREAD of size 4 at 0x603000000028 thread T0\\n    #2 0x7fdcba585082 in __libc_start_main (/lib/x86_64-linux-gnu/libc.so.6+0x24082)\\n0x603000000028 is located 0 bytes to the right of 24-byte region [0x603000000010,0x603000000028)\\nallocated by thread T0 here:\\n    #0 0x7fdcbb1cd808 in __interceptor_malloc ../../../../src/libsanitizer/asan/asan_malloc_linux.cc:144\\n    #3 0x7fdcba585082 in __libc_start_main (/lib/x86_64-linux-gnu/libc.so.6+0x24082)\\nShadow bytes around the buggy address:\\n  0x0c067fff7fb0: 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00\\n  0x0c067fff7fc0: 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00\\n  0x0c067fff7fd0: 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00\\n  0x0c067fff7fe0: 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00\\n  0x0c067fff7ff0: 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00\\n=>0x0c067fff8000: fa fa 00 00 00[fa]fa fa fa fa fa fa fa fa fa fa\\n  0x0c067fff8010: fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa\\n  0x0c067fff8020: fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa\\n  0x0c067fff8030: fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa\\n  0x0c067fff8040: fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa\\n  0x0c067fff8050: fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa\\nShadow byte legend (one shadow byte represents 8 application bytes):\\n  Addressable:           00\\n  Partially addressable: 01 02 03 04 05 06 07 \\n  Heap left redzone:       fa\\n  Freed heap region:       fd\\n  Stack left redzone:      f1\\n  Stack mid redzone:       f2\\n  Stack right redzone:     f3\\n  Stack after return:      f5\\n  Stack use after scope:   f8\\n  Global redzone:          f9\\n  Global init order:       f6\\n  Poisoned by user:        f7\\n  Container overflow:      fc\\n  Array cookie:            ac\\n  Intra object redzone:    bb\\n  ASan internal:           fe\\n  Left alloca redzone:     ca\\n  Right alloca redzone:    cb\\n  Shadow gap:              cc\\n==23==ABORTING"
                    },
                    {
                        "username": "devhindo",
                        "content": "how is this easy"
                    },
                    {
                        "username": "sunny_nath",
                        "content": "i have simple logic but it is not working for prices=[2,1,4], can anyone help?\nsome part of code is with the question, please consider it.\n\n\n \nclass Solution(object):\n    def maxProfit(self, prices):\n            if len(prices)==2:\n                for i in range(len(prices)-1):\n\n                    if prices[i]<prices[i+1]:\n                        return prices[i+1]-prices[i]\n                    else:\n                        return 0\n            if prices==sorted(prices):\n                return prices[-1]-prices[0]\n            min_p=float(inf)\n            max_p=0\n            for i in range(len(prices) - 1):\n                if prices[i] < min_p:\n                    min_p = prices[i]\n                elif prices[i] > max_p:\n                    max_p = prices[i]\n                else:\n                    continue\n            \n            if min_p <= max_p:\n                return max_p - min_p\n            else:\n                return 0\n"
                    },
                    {
                        "username": "user0570Va",
                        "content": "Having an issue with the test runner not returning from within a while loop. Tried this code for input of [ 7, 1, 5, 3, 6, 4 ] in a node shell and it returns just fine.\\n\\nI\\'ve tried using a break, setting a boolean condition the while evaluates, and explicitly returning from within the while but it always seems to get caught in an infinite loop!\\n\\n```\\n/**\\n * @param {number[]} prices\\n * @return {number}\\n */\\n\\nvar maxProfit = function(prices) {\\nlet process = true\\n\\n  let profit = 0\\n  console.log(\\'process is\\', process)\\n  while(process) {\\n    // profit = prices[0]\\n\\n    console.log(\\'prices\\', prices)\\n    console.log(\\'process\\', process)\\n    const maxPrice = Math.max(...prices)\\n    const minPrice = Math.min(...prices)\\n  \\n    const maxPriceIndex = prices.findIndex((p)=> p===maxPrice)\\n    const minPriceIndex = prices.findIndex((p)=> p===minPrice)\\n    console.log(\\'minIdx\\', minPriceIndex)\\n    console.log(\\'maxIdx\\', maxPriceIndex)\\n    if (minPriceIndex === prices.length-1) {\\n        console.log(\\'why am i here?\\')\\n        prices = [...prices.slice(0, prices.length)]\\n        continue\\n    }\\n    if(minPriceIndex < maxPriceIndex) {\\n        const tempProfit = maxPrice-minPrice\\n        if(tempProfit > profit) {\\n            profit = tempProfit\\n            console.log(\\'returning now\\')\\n            process =false\\n            return profit\\n        }\\n    } else {\\n        prices = [...prices.slice(0,maxPriceIndex),...prices.slice(maxPriceIndex+1,prices.length)]\\n    }\\n  }\\n  \\n    return profit\\n};\\n```\\n\\nLOG OUTPUT:\\n```\\nprocess is true\\nprices [ 7, 1, 5, 3, 6, 4 ]\\nprocess true\\nminIdx 1\\nmaxIdx 0\\nprices [ 1, 5, 3, 6, 4 ]\\nprocess true\\nminIdx 0\\nmaxIdx 3\\nreturning now\\nprocess is true\\nprices [ 7, 6, 4, 3, 1 ]\\nprocess true\\nminIdx 4\\nmaxIdx 0\\nwhy am i here?\\nprices [ 7, 6, 4, 3, 1 ]\\nprocess true\\nminIdx 4\\nmaxIdx 0\\nwhy am i here?\\n```\\n"
                    },
                    {
                        "username": "user4279js",
                        "content": "Strange,... Would be good to console log the version of the node runtime version if that\\'s possible"
                    },
                    {
                        "username": "Subiksha_KS",
                        "content": "For the test case #153,\n`prices = [3,3,5,0,0,3,1,4]`\nHow is the expected output 4 and not 3?\n\nAccording to me the explanation is : Buy on day 7 (price = 1) and sell on day 8 (price = 4), so profit = 4-1 = 3.\n\nWhere am I going wrong?\n"
                    },
                    {
                        "username": "shubhamDhapola",
                        "content": "buy on day 4 or day 5(price = 0) and sell on day 8-- price=4\\n4-0=4 ,  the gap between the buying and selling day doesn\\'t matter"
                    },
                    {
                        "username": "apoorva123sinha123",
                        "content": "how does it make sense that [1,2] expects an output of 1 instead of 2?"
                    },
                    {
                        "username": "shubhamDhapola",
                        "content": "buy on day 1 at 1 , sell on day 2 at 2 -- 2-1=1 answer"
                    },
                    {
                        "username": "darthnithin",
                        "content": "Time limit exceeded using the intuitive brute force method :("
                    }
                ]
            },
            {
                "id": 2027699,
                "content": [
                    {
                        "username": "gmnaik96",
                        "content": "Q1. Why am I getting time limit exceeded error for following code?\\n\\nprofit = 0\\n\\n        for i in range(0,len(prices)-1):\\n            key = prices[i]\\n            for j in range(i+1,len(prices)):\\n                if(prices[j] > key):\\n                    newprofit = prices[j] - key\\n                    \\n                    if(newprofit > profit):\\n                        profit = newprofit\\n                  \\n        return profit"
                    },
                    {
                        "username": "Rivo11",
                        "content": "Because your code run in o(n^2) brute force .. and the test cases provided make you must run your code in a less time \\n2 options :\\n1) Optimize your o(n^2) .. you will submit but in a low time efficency\\n2) Find a o(n) solution using extra space."
                    },
                    {
                        "username": "Strix_wl",
                        "content": "This cant be easy XD"
                    },
                    {
                        "username": "daria_mp",
                        "content": "i make this declaration \\ndef maxProfit(self, prices = List[int]) -> int: \\nand it says invalid syntax. I don\\'t know why. I\\'ve used it before and it worked properly. Can someone give me a hint?"
                    },
                    {
                        "username": "kar10arora",
                        "content": "I am getting this error again and again during the compilation of the code. And I have Checked the code in different compiler and it is running successfully. So why I am getting this error here again and again..\\n\\n=================================================================\\n==23==ERROR: AddressSanitizer: heap-buffer-overflow on address 0x603000000028 at pc 0x560e7035f015 bp 0x7ffeb3ced9a0 sp 0x7ffeb3ced990\\nREAD of size 4 at 0x603000000028 thread T0\\n    #2 0x7fdcba585082 in __libc_start_main (/lib/x86_64-linux-gnu/libc.so.6+0x24082)\\n0x603000000028 is located 0 bytes to the right of 24-byte region [0x603000000010,0x603000000028)\\nallocated by thread T0 here:\\n    #0 0x7fdcbb1cd808 in __interceptor_malloc ../../../../src/libsanitizer/asan/asan_malloc_linux.cc:144\\n    #3 0x7fdcba585082 in __libc_start_main (/lib/x86_64-linux-gnu/libc.so.6+0x24082)\\nShadow bytes around the buggy address:\\n  0x0c067fff7fb0: 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00\\n  0x0c067fff7fc0: 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00\\n  0x0c067fff7fd0: 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00\\n  0x0c067fff7fe0: 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00\\n  0x0c067fff7ff0: 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00\\n=>0x0c067fff8000: fa fa 00 00 00[fa]fa fa fa fa fa fa fa fa fa fa\\n  0x0c067fff8010: fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa\\n  0x0c067fff8020: fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa\\n  0x0c067fff8030: fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa\\n  0x0c067fff8040: fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa\\n  0x0c067fff8050: fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa\\nShadow byte legend (one shadow byte represents 8 application bytes):\\n  Addressable:           00\\n  Partially addressable: 01 02 03 04 05 06 07 \\n  Heap left redzone:       fa\\n  Freed heap region:       fd\\n  Stack left redzone:      f1\\n  Stack mid redzone:       f2\\n  Stack right redzone:     f3\\n  Stack after return:      f5\\n  Stack use after scope:   f8\\n  Global redzone:          f9\\n  Global init order:       f6\\n  Poisoned by user:        f7\\n  Container overflow:      fc\\n  Array cookie:            ac\\n  Intra object redzone:    bb\\n  ASan internal:           fe\\n  Left alloca redzone:     ca\\n  Right alloca redzone:    cb\\n  Shadow gap:              cc\\n==23==ABORTING"
                    },
                    {
                        "username": "devhindo",
                        "content": "how is this easy"
                    },
                    {
                        "username": "sunny_nath",
                        "content": "i have simple logic but it is not working for prices=[2,1,4], can anyone help?\nsome part of code is with the question, please consider it.\n\n\n \nclass Solution(object):\n    def maxProfit(self, prices):\n            if len(prices)==2:\n                for i in range(len(prices)-1):\n\n                    if prices[i]<prices[i+1]:\n                        return prices[i+1]-prices[i]\n                    else:\n                        return 0\n            if prices==sorted(prices):\n                return prices[-1]-prices[0]\n            min_p=float(inf)\n            max_p=0\n            for i in range(len(prices) - 1):\n                if prices[i] < min_p:\n                    min_p = prices[i]\n                elif prices[i] > max_p:\n                    max_p = prices[i]\n                else:\n                    continue\n            \n            if min_p <= max_p:\n                return max_p - min_p\n            else:\n                return 0\n"
                    },
                    {
                        "username": "user0570Va",
                        "content": "Having an issue with the test runner not returning from within a while loop. Tried this code for input of [ 7, 1, 5, 3, 6, 4 ] in a node shell and it returns just fine.\\n\\nI\\'ve tried using a break, setting a boolean condition the while evaluates, and explicitly returning from within the while but it always seems to get caught in an infinite loop!\\n\\n```\\n/**\\n * @param {number[]} prices\\n * @return {number}\\n */\\n\\nvar maxProfit = function(prices) {\\nlet process = true\\n\\n  let profit = 0\\n  console.log(\\'process is\\', process)\\n  while(process) {\\n    // profit = prices[0]\\n\\n    console.log(\\'prices\\', prices)\\n    console.log(\\'process\\', process)\\n    const maxPrice = Math.max(...prices)\\n    const minPrice = Math.min(...prices)\\n  \\n    const maxPriceIndex = prices.findIndex((p)=> p===maxPrice)\\n    const minPriceIndex = prices.findIndex((p)=> p===minPrice)\\n    console.log(\\'minIdx\\', minPriceIndex)\\n    console.log(\\'maxIdx\\', maxPriceIndex)\\n    if (minPriceIndex === prices.length-1) {\\n        console.log(\\'why am i here?\\')\\n        prices = [...prices.slice(0, prices.length)]\\n        continue\\n    }\\n    if(minPriceIndex < maxPriceIndex) {\\n        const tempProfit = maxPrice-minPrice\\n        if(tempProfit > profit) {\\n            profit = tempProfit\\n            console.log(\\'returning now\\')\\n            process =false\\n            return profit\\n        }\\n    } else {\\n        prices = [...prices.slice(0,maxPriceIndex),...prices.slice(maxPriceIndex+1,prices.length)]\\n    }\\n  }\\n  \\n    return profit\\n};\\n```\\n\\nLOG OUTPUT:\\n```\\nprocess is true\\nprices [ 7, 1, 5, 3, 6, 4 ]\\nprocess true\\nminIdx 1\\nmaxIdx 0\\nprices [ 1, 5, 3, 6, 4 ]\\nprocess true\\nminIdx 0\\nmaxIdx 3\\nreturning now\\nprocess is true\\nprices [ 7, 6, 4, 3, 1 ]\\nprocess true\\nminIdx 4\\nmaxIdx 0\\nwhy am i here?\\nprices [ 7, 6, 4, 3, 1 ]\\nprocess true\\nminIdx 4\\nmaxIdx 0\\nwhy am i here?\\n```\\n"
                    },
                    {
                        "username": "user4279js",
                        "content": "Strange,... Would be good to console log the version of the node runtime version if that\\'s possible"
                    },
                    {
                        "username": "Subiksha_KS",
                        "content": "For the test case #153,\n`prices = [3,3,5,0,0,3,1,4]`\nHow is the expected output 4 and not 3?\n\nAccording to me the explanation is : Buy on day 7 (price = 1) and sell on day 8 (price = 4), so profit = 4-1 = 3.\n\nWhere am I going wrong?\n"
                    },
                    {
                        "username": "shubhamDhapola",
                        "content": "buy on day 4 or day 5(price = 0) and sell on day 8-- price=4\\n4-0=4 ,  the gap between the buying and selling day doesn\\'t matter"
                    },
                    {
                        "username": "apoorva123sinha123",
                        "content": "how does it make sense that [1,2] expects an output of 1 instead of 2?"
                    },
                    {
                        "username": "shubhamDhapola",
                        "content": "buy on day 1 at 1 , sell on day 2 at 2 -- 2-1=1 answer"
                    },
                    {
                        "username": "darthnithin",
                        "content": "Time limit exceeded using the intuitive brute force method :("
                    }
                ]
            },
            {
                "id": 2026743,
                "content": [
                    {
                        "username": "gmnaik96",
                        "content": "Q1. Why am I getting time limit exceeded error for following code?\\n\\nprofit = 0\\n\\n        for i in range(0,len(prices)-1):\\n            key = prices[i]\\n            for j in range(i+1,len(prices)):\\n                if(prices[j] > key):\\n                    newprofit = prices[j] - key\\n                    \\n                    if(newprofit > profit):\\n                        profit = newprofit\\n                  \\n        return profit"
                    },
                    {
                        "username": "Rivo11",
                        "content": "Because your code run in o(n^2) brute force .. and the test cases provided make you must run your code in a less time \\n2 options :\\n1) Optimize your o(n^2) .. you will submit but in a low time efficency\\n2) Find a o(n) solution using extra space."
                    },
                    {
                        "username": "Strix_wl",
                        "content": "This cant be easy XD"
                    },
                    {
                        "username": "daria_mp",
                        "content": "i make this declaration \\ndef maxProfit(self, prices = List[int]) -> int: \\nand it says invalid syntax. I don\\'t know why. I\\'ve used it before and it worked properly. Can someone give me a hint?"
                    },
                    {
                        "username": "kar10arora",
                        "content": "I am getting this error again and again during the compilation of the code. And I have Checked the code in different compiler and it is running successfully. So why I am getting this error here again and again..\\n\\n=================================================================\\n==23==ERROR: AddressSanitizer: heap-buffer-overflow on address 0x603000000028 at pc 0x560e7035f015 bp 0x7ffeb3ced9a0 sp 0x7ffeb3ced990\\nREAD of size 4 at 0x603000000028 thread T0\\n    #2 0x7fdcba585082 in __libc_start_main (/lib/x86_64-linux-gnu/libc.so.6+0x24082)\\n0x603000000028 is located 0 bytes to the right of 24-byte region [0x603000000010,0x603000000028)\\nallocated by thread T0 here:\\n    #0 0x7fdcbb1cd808 in __interceptor_malloc ../../../../src/libsanitizer/asan/asan_malloc_linux.cc:144\\n    #3 0x7fdcba585082 in __libc_start_main (/lib/x86_64-linux-gnu/libc.so.6+0x24082)\\nShadow bytes around the buggy address:\\n  0x0c067fff7fb0: 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00\\n  0x0c067fff7fc0: 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00\\n  0x0c067fff7fd0: 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00\\n  0x0c067fff7fe0: 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00\\n  0x0c067fff7ff0: 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00\\n=>0x0c067fff8000: fa fa 00 00 00[fa]fa fa fa fa fa fa fa fa fa fa\\n  0x0c067fff8010: fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa\\n  0x0c067fff8020: fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa\\n  0x0c067fff8030: fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa\\n  0x0c067fff8040: fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa\\n  0x0c067fff8050: fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa\\nShadow byte legend (one shadow byte represents 8 application bytes):\\n  Addressable:           00\\n  Partially addressable: 01 02 03 04 05 06 07 \\n  Heap left redzone:       fa\\n  Freed heap region:       fd\\n  Stack left redzone:      f1\\n  Stack mid redzone:       f2\\n  Stack right redzone:     f3\\n  Stack after return:      f5\\n  Stack use after scope:   f8\\n  Global redzone:          f9\\n  Global init order:       f6\\n  Poisoned by user:        f7\\n  Container overflow:      fc\\n  Array cookie:            ac\\n  Intra object redzone:    bb\\n  ASan internal:           fe\\n  Left alloca redzone:     ca\\n  Right alloca redzone:    cb\\n  Shadow gap:              cc\\n==23==ABORTING"
                    },
                    {
                        "username": "devhindo",
                        "content": "how is this easy"
                    },
                    {
                        "username": "sunny_nath",
                        "content": "i have simple logic but it is not working for prices=[2,1,4], can anyone help?\nsome part of code is with the question, please consider it.\n\n\n \nclass Solution(object):\n    def maxProfit(self, prices):\n            if len(prices)==2:\n                for i in range(len(prices)-1):\n\n                    if prices[i]<prices[i+1]:\n                        return prices[i+1]-prices[i]\n                    else:\n                        return 0\n            if prices==sorted(prices):\n                return prices[-1]-prices[0]\n            min_p=float(inf)\n            max_p=0\n            for i in range(len(prices) - 1):\n                if prices[i] < min_p:\n                    min_p = prices[i]\n                elif prices[i] > max_p:\n                    max_p = prices[i]\n                else:\n                    continue\n            \n            if min_p <= max_p:\n                return max_p - min_p\n            else:\n                return 0\n"
                    },
                    {
                        "username": "user0570Va",
                        "content": "Having an issue with the test runner not returning from within a while loop. Tried this code for input of [ 7, 1, 5, 3, 6, 4 ] in a node shell and it returns just fine.\\n\\nI\\'ve tried using a break, setting a boolean condition the while evaluates, and explicitly returning from within the while but it always seems to get caught in an infinite loop!\\n\\n```\\n/**\\n * @param {number[]} prices\\n * @return {number}\\n */\\n\\nvar maxProfit = function(prices) {\\nlet process = true\\n\\n  let profit = 0\\n  console.log(\\'process is\\', process)\\n  while(process) {\\n    // profit = prices[0]\\n\\n    console.log(\\'prices\\', prices)\\n    console.log(\\'process\\', process)\\n    const maxPrice = Math.max(...prices)\\n    const minPrice = Math.min(...prices)\\n  \\n    const maxPriceIndex = prices.findIndex((p)=> p===maxPrice)\\n    const minPriceIndex = prices.findIndex((p)=> p===minPrice)\\n    console.log(\\'minIdx\\', minPriceIndex)\\n    console.log(\\'maxIdx\\', maxPriceIndex)\\n    if (minPriceIndex === prices.length-1) {\\n        console.log(\\'why am i here?\\')\\n        prices = [...prices.slice(0, prices.length)]\\n        continue\\n    }\\n    if(minPriceIndex < maxPriceIndex) {\\n        const tempProfit = maxPrice-minPrice\\n        if(tempProfit > profit) {\\n            profit = tempProfit\\n            console.log(\\'returning now\\')\\n            process =false\\n            return profit\\n        }\\n    } else {\\n        prices = [...prices.slice(0,maxPriceIndex),...prices.slice(maxPriceIndex+1,prices.length)]\\n    }\\n  }\\n  \\n    return profit\\n};\\n```\\n\\nLOG OUTPUT:\\n```\\nprocess is true\\nprices [ 7, 1, 5, 3, 6, 4 ]\\nprocess true\\nminIdx 1\\nmaxIdx 0\\nprices [ 1, 5, 3, 6, 4 ]\\nprocess true\\nminIdx 0\\nmaxIdx 3\\nreturning now\\nprocess is true\\nprices [ 7, 6, 4, 3, 1 ]\\nprocess true\\nminIdx 4\\nmaxIdx 0\\nwhy am i here?\\nprices [ 7, 6, 4, 3, 1 ]\\nprocess true\\nminIdx 4\\nmaxIdx 0\\nwhy am i here?\\n```\\n"
                    },
                    {
                        "username": "user4279js",
                        "content": "Strange,... Would be good to console log the version of the node runtime version if that\\'s possible"
                    },
                    {
                        "username": "Subiksha_KS",
                        "content": "For the test case #153,\n`prices = [3,3,5,0,0,3,1,4]`\nHow is the expected output 4 and not 3?\n\nAccording to me the explanation is : Buy on day 7 (price = 1) and sell on day 8 (price = 4), so profit = 4-1 = 3.\n\nWhere am I going wrong?\n"
                    },
                    {
                        "username": "shubhamDhapola",
                        "content": "buy on day 4 or day 5(price = 0) and sell on day 8-- price=4\\n4-0=4 ,  the gap between the buying and selling day doesn\\'t matter"
                    },
                    {
                        "username": "apoorva123sinha123",
                        "content": "how does it make sense that [1,2] expects an output of 1 instead of 2?"
                    },
                    {
                        "username": "shubhamDhapola",
                        "content": "buy on day 1 at 1 , sell on day 2 at 2 -- 2-1=1 answer"
                    },
                    {
                        "username": "darthnithin",
                        "content": "Time limit exceeded using the intuitive brute force method :("
                    }
                ]
            },
            {
                "id": 2026572,
                "content": [
                    {
                        "username": "gmnaik96",
                        "content": "Q1. Why am I getting time limit exceeded error for following code?\\n\\nprofit = 0\\n\\n        for i in range(0,len(prices)-1):\\n            key = prices[i]\\n            for j in range(i+1,len(prices)):\\n                if(prices[j] > key):\\n                    newprofit = prices[j] - key\\n                    \\n                    if(newprofit > profit):\\n                        profit = newprofit\\n                  \\n        return profit"
                    },
                    {
                        "username": "Rivo11",
                        "content": "Because your code run in o(n^2) brute force .. and the test cases provided make you must run your code in a less time \\n2 options :\\n1) Optimize your o(n^2) .. you will submit but in a low time efficency\\n2) Find a o(n) solution using extra space."
                    },
                    {
                        "username": "Strix_wl",
                        "content": "This cant be easy XD"
                    },
                    {
                        "username": "daria_mp",
                        "content": "i make this declaration \\ndef maxProfit(self, prices = List[int]) -> int: \\nand it says invalid syntax. I don\\'t know why. I\\'ve used it before and it worked properly. Can someone give me a hint?"
                    },
                    {
                        "username": "kar10arora",
                        "content": "I am getting this error again and again during the compilation of the code. And I have Checked the code in different compiler and it is running successfully. So why I am getting this error here again and again..\\n\\n=================================================================\\n==23==ERROR: AddressSanitizer: heap-buffer-overflow on address 0x603000000028 at pc 0x560e7035f015 bp 0x7ffeb3ced9a0 sp 0x7ffeb3ced990\\nREAD of size 4 at 0x603000000028 thread T0\\n    #2 0x7fdcba585082 in __libc_start_main (/lib/x86_64-linux-gnu/libc.so.6+0x24082)\\n0x603000000028 is located 0 bytes to the right of 24-byte region [0x603000000010,0x603000000028)\\nallocated by thread T0 here:\\n    #0 0x7fdcbb1cd808 in __interceptor_malloc ../../../../src/libsanitizer/asan/asan_malloc_linux.cc:144\\n    #3 0x7fdcba585082 in __libc_start_main (/lib/x86_64-linux-gnu/libc.so.6+0x24082)\\nShadow bytes around the buggy address:\\n  0x0c067fff7fb0: 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00\\n  0x0c067fff7fc0: 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00\\n  0x0c067fff7fd0: 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00\\n  0x0c067fff7fe0: 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00\\n  0x0c067fff7ff0: 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00\\n=>0x0c067fff8000: fa fa 00 00 00[fa]fa fa fa fa fa fa fa fa fa fa\\n  0x0c067fff8010: fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa\\n  0x0c067fff8020: fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa\\n  0x0c067fff8030: fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa\\n  0x0c067fff8040: fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa\\n  0x0c067fff8050: fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa\\nShadow byte legend (one shadow byte represents 8 application bytes):\\n  Addressable:           00\\n  Partially addressable: 01 02 03 04 05 06 07 \\n  Heap left redzone:       fa\\n  Freed heap region:       fd\\n  Stack left redzone:      f1\\n  Stack mid redzone:       f2\\n  Stack right redzone:     f3\\n  Stack after return:      f5\\n  Stack use after scope:   f8\\n  Global redzone:          f9\\n  Global init order:       f6\\n  Poisoned by user:        f7\\n  Container overflow:      fc\\n  Array cookie:            ac\\n  Intra object redzone:    bb\\n  ASan internal:           fe\\n  Left alloca redzone:     ca\\n  Right alloca redzone:    cb\\n  Shadow gap:              cc\\n==23==ABORTING"
                    },
                    {
                        "username": "devhindo",
                        "content": "how is this easy"
                    },
                    {
                        "username": "sunny_nath",
                        "content": "i have simple logic but it is not working for prices=[2,1,4], can anyone help?\nsome part of code is with the question, please consider it.\n\n\n \nclass Solution(object):\n    def maxProfit(self, prices):\n            if len(prices)==2:\n                for i in range(len(prices)-1):\n\n                    if prices[i]<prices[i+1]:\n                        return prices[i+1]-prices[i]\n                    else:\n                        return 0\n            if prices==sorted(prices):\n                return prices[-1]-prices[0]\n            min_p=float(inf)\n            max_p=0\n            for i in range(len(prices) - 1):\n                if prices[i] < min_p:\n                    min_p = prices[i]\n                elif prices[i] > max_p:\n                    max_p = prices[i]\n                else:\n                    continue\n            \n            if min_p <= max_p:\n                return max_p - min_p\n            else:\n                return 0\n"
                    },
                    {
                        "username": "user0570Va",
                        "content": "Having an issue with the test runner not returning from within a while loop. Tried this code for input of [ 7, 1, 5, 3, 6, 4 ] in a node shell and it returns just fine.\\n\\nI\\'ve tried using a break, setting a boolean condition the while evaluates, and explicitly returning from within the while but it always seems to get caught in an infinite loop!\\n\\n```\\n/**\\n * @param {number[]} prices\\n * @return {number}\\n */\\n\\nvar maxProfit = function(prices) {\\nlet process = true\\n\\n  let profit = 0\\n  console.log(\\'process is\\', process)\\n  while(process) {\\n    // profit = prices[0]\\n\\n    console.log(\\'prices\\', prices)\\n    console.log(\\'process\\', process)\\n    const maxPrice = Math.max(...prices)\\n    const minPrice = Math.min(...prices)\\n  \\n    const maxPriceIndex = prices.findIndex((p)=> p===maxPrice)\\n    const minPriceIndex = prices.findIndex((p)=> p===minPrice)\\n    console.log(\\'minIdx\\', minPriceIndex)\\n    console.log(\\'maxIdx\\', maxPriceIndex)\\n    if (minPriceIndex === prices.length-1) {\\n        console.log(\\'why am i here?\\')\\n        prices = [...prices.slice(0, prices.length)]\\n        continue\\n    }\\n    if(minPriceIndex < maxPriceIndex) {\\n        const tempProfit = maxPrice-minPrice\\n        if(tempProfit > profit) {\\n            profit = tempProfit\\n            console.log(\\'returning now\\')\\n            process =false\\n            return profit\\n        }\\n    } else {\\n        prices = [...prices.slice(0,maxPriceIndex),...prices.slice(maxPriceIndex+1,prices.length)]\\n    }\\n  }\\n  \\n    return profit\\n};\\n```\\n\\nLOG OUTPUT:\\n```\\nprocess is true\\nprices [ 7, 1, 5, 3, 6, 4 ]\\nprocess true\\nminIdx 1\\nmaxIdx 0\\nprices [ 1, 5, 3, 6, 4 ]\\nprocess true\\nminIdx 0\\nmaxIdx 3\\nreturning now\\nprocess is true\\nprices [ 7, 6, 4, 3, 1 ]\\nprocess true\\nminIdx 4\\nmaxIdx 0\\nwhy am i here?\\nprices [ 7, 6, 4, 3, 1 ]\\nprocess true\\nminIdx 4\\nmaxIdx 0\\nwhy am i here?\\n```\\n"
                    },
                    {
                        "username": "user4279js",
                        "content": "Strange,... Would be good to console log the version of the node runtime version if that\\'s possible"
                    },
                    {
                        "username": "Subiksha_KS",
                        "content": "For the test case #153,\n`prices = [3,3,5,0,0,3,1,4]`\nHow is the expected output 4 and not 3?\n\nAccording to me the explanation is : Buy on day 7 (price = 1) and sell on day 8 (price = 4), so profit = 4-1 = 3.\n\nWhere am I going wrong?\n"
                    },
                    {
                        "username": "shubhamDhapola",
                        "content": "buy on day 4 or day 5(price = 0) and sell on day 8-- price=4\\n4-0=4 ,  the gap between the buying and selling day doesn\\'t matter"
                    },
                    {
                        "username": "apoorva123sinha123",
                        "content": "how does it make sense that [1,2] expects an output of 1 instead of 2?"
                    },
                    {
                        "username": "shubhamDhapola",
                        "content": "buy on day 1 at 1 , sell on day 2 at 2 -- 2-1=1 answer"
                    },
                    {
                        "username": "darthnithin",
                        "content": "Time limit exceeded using the intuitive brute force method :("
                    }
                ]
            },
            {
                "id": 2025604,
                "content": [
                    {
                        "username": "gmnaik96",
                        "content": "Q1. Why am I getting time limit exceeded error for following code?\\n\\nprofit = 0\\n\\n        for i in range(0,len(prices)-1):\\n            key = prices[i]\\n            for j in range(i+1,len(prices)):\\n                if(prices[j] > key):\\n                    newprofit = prices[j] - key\\n                    \\n                    if(newprofit > profit):\\n                        profit = newprofit\\n                  \\n        return profit"
                    },
                    {
                        "username": "Rivo11",
                        "content": "Because your code run in o(n^2) brute force .. and the test cases provided make you must run your code in a less time \\n2 options :\\n1) Optimize your o(n^2) .. you will submit but in a low time efficency\\n2) Find a o(n) solution using extra space."
                    },
                    {
                        "username": "Strix_wl",
                        "content": "This cant be easy XD"
                    },
                    {
                        "username": "daria_mp",
                        "content": "i make this declaration \\ndef maxProfit(self, prices = List[int]) -> int: \\nand it says invalid syntax. I don\\'t know why. I\\'ve used it before and it worked properly. Can someone give me a hint?"
                    },
                    {
                        "username": "kar10arora",
                        "content": "I am getting this error again and again during the compilation of the code. And I have Checked the code in different compiler and it is running successfully. So why I am getting this error here again and again..\\n\\n=================================================================\\n==23==ERROR: AddressSanitizer: heap-buffer-overflow on address 0x603000000028 at pc 0x560e7035f015 bp 0x7ffeb3ced9a0 sp 0x7ffeb3ced990\\nREAD of size 4 at 0x603000000028 thread T0\\n    #2 0x7fdcba585082 in __libc_start_main (/lib/x86_64-linux-gnu/libc.so.6+0x24082)\\n0x603000000028 is located 0 bytes to the right of 24-byte region [0x603000000010,0x603000000028)\\nallocated by thread T0 here:\\n    #0 0x7fdcbb1cd808 in __interceptor_malloc ../../../../src/libsanitizer/asan/asan_malloc_linux.cc:144\\n    #3 0x7fdcba585082 in __libc_start_main (/lib/x86_64-linux-gnu/libc.so.6+0x24082)\\nShadow bytes around the buggy address:\\n  0x0c067fff7fb0: 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00\\n  0x0c067fff7fc0: 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00\\n  0x0c067fff7fd0: 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00\\n  0x0c067fff7fe0: 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00\\n  0x0c067fff7ff0: 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00\\n=>0x0c067fff8000: fa fa 00 00 00[fa]fa fa fa fa fa fa fa fa fa fa\\n  0x0c067fff8010: fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa\\n  0x0c067fff8020: fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa\\n  0x0c067fff8030: fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa\\n  0x0c067fff8040: fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa\\n  0x0c067fff8050: fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa\\nShadow byte legend (one shadow byte represents 8 application bytes):\\n  Addressable:           00\\n  Partially addressable: 01 02 03 04 05 06 07 \\n  Heap left redzone:       fa\\n  Freed heap region:       fd\\n  Stack left redzone:      f1\\n  Stack mid redzone:       f2\\n  Stack right redzone:     f3\\n  Stack after return:      f5\\n  Stack use after scope:   f8\\n  Global redzone:          f9\\n  Global init order:       f6\\n  Poisoned by user:        f7\\n  Container overflow:      fc\\n  Array cookie:            ac\\n  Intra object redzone:    bb\\n  ASan internal:           fe\\n  Left alloca redzone:     ca\\n  Right alloca redzone:    cb\\n  Shadow gap:              cc\\n==23==ABORTING"
                    },
                    {
                        "username": "devhindo",
                        "content": "how is this easy"
                    },
                    {
                        "username": "sunny_nath",
                        "content": "i have simple logic but it is not working for prices=[2,1,4], can anyone help?\nsome part of code is with the question, please consider it.\n\n\n \nclass Solution(object):\n    def maxProfit(self, prices):\n            if len(prices)==2:\n                for i in range(len(prices)-1):\n\n                    if prices[i]<prices[i+1]:\n                        return prices[i+1]-prices[i]\n                    else:\n                        return 0\n            if prices==sorted(prices):\n                return prices[-1]-prices[0]\n            min_p=float(inf)\n            max_p=0\n            for i in range(len(prices) - 1):\n                if prices[i] < min_p:\n                    min_p = prices[i]\n                elif prices[i] > max_p:\n                    max_p = prices[i]\n                else:\n                    continue\n            \n            if min_p <= max_p:\n                return max_p - min_p\n            else:\n                return 0\n"
                    },
                    {
                        "username": "user0570Va",
                        "content": "Having an issue with the test runner not returning from within a while loop. Tried this code for input of [ 7, 1, 5, 3, 6, 4 ] in a node shell and it returns just fine.\\n\\nI\\'ve tried using a break, setting a boolean condition the while evaluates, and explicitly returning from within the while but it always seems to get caught in an infinite loop!\\n\\n```\\n/**\\n * @param {number[]} prices\\n * @return {number}\\n */\\n\\nvar maxProfit = function(prices) {\\nlet process = true\\n\\n  let profit = 0\\n  console.log(\\'process is\\', process)\\n  while(process) {\\n    // profit = prices[0]\\n\\n    console.log(\\'prices\\', prices)\\n    console.log(\\'process\\', process)\\n    const maxPrice = Math.max(...prices)\\n    const minPrice = Math.min(...prices)\\n  \\n    const maxPriceIndex = prices.findIndex((p)=> p===maxPrice)\\n    const minPriceIndex = prices.findIndex((p)=> p===minPrice)\\n    console.log(\\'minIdx\\', minPriceIndex)\\n    console.log(\\'maxIdx\\', maxPriceIndex)\\n    if (minPriceIndex === prices.length-1) {\\n        console.log(\\'why am i here?\\')\\n        prices = [...prices.slice(0, prices.length)]\\n        continue\\n    }\\n    if(minPriceIndex < maxPriceIndex) {\\n        const tempProfit = maxPrice-minPrice\\n        if(tempProfit > profit) {\\n            profit = tempProfit\\n            console.log(\\'returning now\\')\\n            process =false\\n            return profit\\n        }\\n    } else {\\n        prices = [...prices.slice(0,maxPriceIndex),...prices.slice(maxPriceIndex+1,prices.length)]\\n    }\\n  }\\n  \\n    return profit\\n};\\n```\\n\\nLOG OUTPUT:\\n```\\nprocess is true\\nprices [ 7, 1, 5, 3, 6, 4 ]\\nprocess true\\nminIdx 1\\nmaxIdx 0\\nprices [ 1, 5, 3, 6, 4 ]\\nprocess true\\nminIdx 0\\nmaxIdx 3\\nreturning now\\nprocess is true\\nprices [ 7, 6, 4, 3, 1 ]\\nprocess true\\nminIdx 4\\nmaxIdx 0\\nwhy am i here?\\nprices [ 7, 6, 4, 3, 1 ]\\nprocess true\\nminIdx 4\\nmaxIdx 0\\nwhy am i here?\\n```\\n"
                    },
                    {
                        "username": "user4279js",
                        "content": "Strange,... Would be good to console log the version of the node runtime version if that\\'s possible"
                    },
                    {
                        "username": "Subiksha_KS",
                        "content": "For the test case #153,\n`prices = [3,3,5,0,0,3,1,4]`\nHow is the expected output 4 and not 3?\n\nAccording to me the explanation is : Buy on day 7 (price = 1) and sell on day 8 (price = 4), so profit = 4-1 = 3.\n\nWhere am I going wrong?\n"
                    },
                    {
                        "username": "shubhamDhapola",
                        "content": "buy on day 4 or day 5(price = 0) and sell on day 8-- price=4\\n4-0=4 ,  the gap between the buying and selling day doesn\\'t matter"
                    },
                    {
                        "username": "apoorva123sinha123",
                        "content": "how does it make sense that [1,2] expects an output of 1 instead of 2?"
                    },
                    {
                        "username": "shubhamDhapola",
                        "content": "buy on day 1 at 1 , sell on day 2 at 2 -- 2-1=1 answer"
                    },
                    {
                        "username": "darthnithin",
                        "content": "Time limit exceeded using the intuitive brute force method :("
                    }
                ]
            },
            {
                "id": 2017569,
                "content": [
                    {
                        "username": "gmnaik96",
                        "content": "Q1. Why am I getting time limit exceeded error for following code?\\n\\nprofit = 0\\n\\n        for i in range(0,len(prices)-1):\\n            key = prices[i]\\n            for j in range(i+1,len(prices)):\\n                if(prices[j] > key):\\n                    newprofit = prices[j] - key\\n                    \\n                    if(newprofit > profit):\\n                        profit = newprofit\\n                  \\n        return profit"
                    },
                    {
                        "username": "Rivo11",
                        "content": "Because your code run in o(n^2) brute force .. and the test cases provided make you must run your code in a less time \\n2 options :\\n1) Optimize your o(n^2) .. you will submit but in a low time efficency\\n2) Find a o(n) solution using extra space."
                    },
                    {
                        "username": "Strix_wl",
                        "content": "This cant be easy XD"
                    },
                    {
                        "username": "daria_mp",
                        "content": "i make this declaration \\ndef maxProfit(self, prices = List[int]) -> int: \\nand it says invalid syntax. I don\\'t know why. I\\'ve used it before and it worked properly. Can someone give me a hint?"
                    },
                    {
                        "username": "kar10arora",
                        "content": "I am getting this error again and again during the compilation of the code. And I have Checked the code in different compiler and it is running successfully. So why I am getting this error here again and again..\\n\\n=================================================================\\n==23==ERROR: AddressSanitizer: heap-buffer-overflow on address 0x603000000028 at pc 0x560e7035f015 bp 0x7ffeb3ced9a0 sp 0x7ffeb3ced990\\nREAD of size 4 at 0x603000000028 thread T0\\n    #2 0x7fdcba585082 in __libc_start_main (/lib/x86_64-linux-gnu/libc.so.6+0x24082)\\n0x603000000028 is located 0 bytes to the right of 24-byte region [0x603000000010,0x603000000028)\\nallocated by thread T0 here:\\n    #0 0x7fdcbb1cd808 in __interceptor_malloc ../../../../src/libsanitizer/asan/asan_malloc_linux.cc:144\\n    #3 0x7fdcba585082 in __libc_start_main (/lib/x86_64-linux-gnu/libc.so.6+0x24082)\\nShadow bytes around the buggy address:\\n  0x0c067fff7fb0: 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00\\n  0x0c067fff7fc0: 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00\\n  0x0c067fff7fd0: 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00\\n  0x0c067fff7fe0: 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00\\n  0x0c067fff7ff0: 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00\\n=>0x0c067fff8000: fa fa 00 00 00[fa]fa fa fa fa fa fa fa fa fa fa\\n  0x0c067fff8010: fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa\\n  0x0c067fff8020: fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa\\n  0x0c067fff8030: fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa\\n  0x0c067fff8040: fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa\\n  0x0c067fff8050: fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa\\nShadow byte legend (one shadow byte represents 8 application bytes):\\n  Addressable:           00\\n  Partially addressable: 01 02 03 04 05 06 07 \\n  Heap left redzone:       fa\\n  Freed heap region:       fd\\n  Stack left redzone:      f1\\n  Stack mid redzone:       f2\\n  Stack right redzone:     f3\\n  Stack after return:      f5\\n  Stack use after scope:   f8\\n  Global redzone:          f9\\n  Global init order:       f6\\n  Poisoned by user:        f7\\n  Container overflow:      fc\\n  Array cookie:            ac\\n  Intra object redzone:    bb\\n  ASan internal:           fe\\n  Left alloca redzone:     ca\\n  Right alloca redzone:    cb\\n  Shadow gap:              cc\\n==23==ABORTING"
                    },
                    {
                        "username": "devhindo",
                        "content": "how is this easy"
                    },
                    {
                        "username": "sunny_nath",
                        "content": "i have simple logic but it is not working for prices=[2,1,4], can anyone help?\nsome part of code is with the question, please consider it.\n\n\n \nclass Solution(object):\n    def maxProfit(self, prices):\n            if len(prices)==2:\n                for i in range(len(prices)-1):\n\n                    if prices[i]<prices[i+1]:\n                        return prices[i+1]-prices[i]\n                    else:\n                        return 0\n            if prices==sorted(prices):\n                return prices[-1]-prices[0]\n            min_p=float(inf)\n            max_p=0\n            for i in range(len(prices) - 1):\n                if prices[i] < min_p:\n                    min_p = prices[i]\n                elif prices[i] > max_p:\n                    max_p = prices[i]\n                else:\n                    continue\n            \n            if min_p <= max_p:\n                return max_p - min_p\n            else:\n                return 0\n"
                    },
                    {
                        "username": "user0570Va",
                        "content": "Having an issue with the test runner not returning from within a while loop. Tried this code for input of [ 7, 1, 5, 3, 6, 4 ] in a node shell and it returns just fine.\\n\\nI\\'ve tried using a break, setting a boolean condition the while evaluates, and explicitly returning from within the while but it always seems to get caught in an infinite loop!\\n\\n```\\n/**\\n * @param {number[]} prices\\n * @return {number}\\n */\\n\\nvar maxProfit = function(prices) {\\nlet process = true\\n\\n  let profit = 0\\n  console.log(\\'process is\\', process)\\n  while(process) {\\n    // profit = prices[0]\\n\\n    console.log(\\'prices\\', prices)\\n    console.log(\\'process\\', process)\\n    const maxPrice = Math.max(...prices)\\n    const minPrice = Math.min(...prices)\\n  \\n    const maxPriceIndex = prices.findIndex((p)=> p===maxPrice)\\n    const minPriceIndex = prices.findIndex((p)=> p===minPrice)\\n    console.log(\\'minIdx\\', minPriceIndex)\\n    console.log(\\'maxIdx\\', maxPriceIndex)\\n    if (minPriceIndex === prices.length-1) {\\n        console.log(\\'why am i here?\\')\\n        prices = [...prices.slice(0, prices.length)]\\n        continue\\n    }\\n    if(minPriceIndex < maxPriceIndex) {\\n        const tempProfit = maxPrice-minPrice\\n        if(tempProfit > profit) {\\n            profit = tempProfit\\n            console.log(\\'returning now\\')\\n            process =false\\n            return profit\\n        }\\n    } else {\\n        prices = [...prices.slice(0,maxPriceIndex),...prices.slice(maxPriceIndex+1,prices.length)]\\n    }\\n  }\\n  \\n    return profit\\n};\\n```\\n\\nLOG OUTPUT:\\n```\\nprocess is true\\nprices [ 7, 1, 5, 3, 6, 4 ]\\nprocess true\\nminIdx 1\\nmaxIdx 0\\nprices [ 1, 5, 3, 6, 4 ]\\nprocess true\\nminIdx 0\\nmaxIdx 3\\nreturning now\\nprocess is true\\nprices [ 7, 6, 4, 3, 1 ]\\nprocess true\\nminIdx 4\\nmaxIdx 0\\nwhy am i here?\\nprices [ 7, 6, 4, 3, 1 ]\\nprocess true\\nminIdx 4\\nmaxIdx 0\\nwhy am i here?\\n```\\n"
                    },
                    {
                        "username": "user4279js",
                        "content": "Strange,... Would be good to console log the version of the node runtime version if that\\'s possible"
                    },
                    {
                        "username": "Subiksha_KS",
                        "content": "For the test case #153,\n`prices = [3,3,5,0,0,3,1,4]`\nHow is the expected output 4 and not 3?\n\nAccording to me the explanation is : Buy on day 7 (price = 1) and sell on day 8 (price = 4), so profit = 4-1 = 3.\n\nWhere am I going wrong?\n"
                    },
                    {
                        "username": "shubhamDhapola",
                        "content": "buy on day 4 or day 5(price = 0) and sell on day 8-- price=4\\n4-0=4 ,  the gap between the buying and selling day doesn\\'t matter"
                    },
                    {
                        "username": "apoorva123sinha123",
                        "content": "how does it make sense that [1,2] expects an output of 1 instead of 2?"
                    },
                    {
                        "username": "shubhamDhapola",
                        "content": "buy on day 1 at 1 , sell on day 2 at 2 -- 2-1=1 answer"
                    },
                    {
                        "username": "darthnithin",
                        "content": "Time limit exceeded using the intuitive brute force method :("
                    }
                ]
            },
            {
                "id": 2017052,
                "content": [
                    {
                        "username": "gmnaik96",
                        "content": "Q1. Why am I getting time limit exceeded error for following code?\\n\\nprofit = 0\\n\\n        for i in range(0,len(prices)-1):\\n            key = prices[i]\\n            for j in range(i+1,len(prices)):\\n                if(prices[j] > key):\\n                    newprofit = prices[j] - key\\n                    \\n                    if(newprofit > profit):\\n                        profit = newprofit\\n                  \\n        return profit"
                    },
                    {
                        "username": "Rivo11",
                        "content": "Because your code run in o(n^2) brute force .. and the test cases provided make you must run your code in a less time \\n2 options :\\n1) Optimize your o(n^2) .. you will submit but in a low time efficency\\n2) Find a o(n) solution using extra space."
                    },
                    {
                        "username": "Strix_wl",
                        "content": "This cant be easy XD"
                    },
                    {
                        "username": "daria_mp",
                        "content": "i make this declaration \\ndef maxProfit(self, prices = List[int]) -> int: \\nand it says invalid syntax. I don\\'t know why. I\\'ve used it before and it worked properly. Can someone give me a hint?"
                    },
                    {
                        "username": "kar10arora",
                        "content": "I am getting this error again and again during the compilation of the code. And I have Checked the code in different compiler and it is running successfully. So why I am getting this error here again and again..\\n\\n=================================================================\\n==23==ERROR: AddressSanitizer: heap-buffer-overflow on address 0x603000000028 at pc 0x560e7035f015 bp 0x7ffeb3ced9a0 sp 0x7ffeb3ced990\\nREAD of size 4 at 0x603000000028 thread T0\\n    #2 0x7fdcba585082 in __libc_start_main (/lib/x86_64-linux-gnu/libc.so.6+0x24082)\\n0x603000000028 is located 0 bytes to the right of 24-byte region [0x603000000010,0x603000000028)\\nallocated by thread T0 here:\\n    #0 0x7fdcbb1cd808 in __interceptor_malloc ../../../../src/libsanitizer/asan/asan_malloc_linux.cc:144\\n    #3 0x7fdcba585082 in __libc_start_main (/lib/x86_64-linux-gnu/libc.so.6+0x24082)\\nShadow bytes around the buggy address:\\n  0x0c067fff7fb0: 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00\\n  0x0c067fff7fc0: 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00\\n  0x0c067fff7fd0: 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00\\n  0x0c067fff7fe0: 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00\\n  0x0c067fff7ff0: 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00\\n=>0x0c067fff8000: fa fa 00 00 00[fa]fa fa fa fa fa fa fa fa fa fa\\n  0x0c067fff8010: fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa\\n  0x0c067fff8020: fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa\\n  0x0c067fff8030: fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa\\n  0x0c067fff8040: fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa\\n  0x0c067fff8050: fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa\\nShadow byte legend (one shadow byte represents 8 application bytes):\\n  Addressable:           00\\n  Partially addressable: 01 02 03 04 05 06 07 \\n  Heap left redzone:       fa\\n  Freed heap region:       fd\\n  Stack left redzone:      f1\\n  Stack mid redzone:       f2\\n  Stack right redzone:     f3\\n  Stack after return:      f5\\n  Stack use after scope:   f8\\n  Global redzone:          f9\\n  Global init order:       f6\\n  Poisoned by user:        f7\\n  Container overflow:      fc\\n  Array cookie:            ac\\n  Intra object redzone:    bb\\n  ASan internal:           fe\\n  Left alloca redzone:     ca\\n  Right alloca redzone:    cb\\n  Shadow gap:              cc\\n==23==ABORTING"
                    },
                    {
                        "username": "devhindo",
                        "content": "how is this easy"
                    },
                    {
                        "username": "sunny_nath",
                        "content": "i have simple logic but it is not working for prices=[2,1,4], can anyone help?\nsome part of code is with the question, please consider it.\n\n\n \nclass Solution(object):\n    def maxProfit(self, prices):\n            if len(prices)==2:\n                for i in range(len(prices)-1):\n\n                    if prices[i]<prices[i+1]:\n                        return prices[i+1]-prices[i]\n                    else:\n                        return 0\n            if prices==sorted(prices):\n                return prices[-1]-prices[0]\n            min_p=float(inf)\n            max_p=0\n            for i in range(len(prices) - 1):\n                if prices[i] < min_p:\n                    min_p = prices[i]\n                elif prices[i] > max_p:\n                    max_p = prices[i]\n                else:\n                    continue\n            \n            if min_p <= max_p:\n                return max_p - min_p\n            else:\n                return 0\n"
                    },
                    {
                        "username": "user0570Va",
                        "content": "Having an issue with the test runner not returning from within a while loop. Tried this code for input of [ 7, 1, 5, 3, 6, 4 ] in a node shell and it returns just fine.\\n\\nI\\'ve tried using a break, setting a boolean condition the while evaluates, and explicitly returning from within the while but it always seems to get caught in an infinite loop!\\n\\n```\\n/**\\n * @param {number[]} prices\\n * @return {number}\\n */\\n\\nvar maxProfit = function(prices) {\\nlet process = true\\n\\n  let profit = 0\\n  console.log(\\'process is\\', process)\\n  while(process) {\\n    // profit = prices[0]\\n\\n    console.log(\\'prices\\', prices)\\n    console.log(\\'process\\', process)\\n    const maxPrice = Math.max(...prices)\\n    const minPrice = Math.min(...prices)\\n  \\n    const maxPriceIndex = prices.findIndex((p)=> p===maxPrice)\\n    const minPriceIndex = prices.findIndex((p)=> p===minPrice)\\n    console.log(\\'minIdx\\', minPriceIndex)\\n    console.log(\\'maxIdx\\', maxPriceIndex)\\n    if (minPriceIndex === prices.length-1) {\\n        console.log(\\'why am i here?\\')\\n        prices = [...prices.slice(0, prices.length)]\\n        continue\\n    }\\n    if(minPriceIndex < maxPriceIndex) {\\n        const tempProfit = maxPrice-minPrice\\n        if(tempProfit > profit) {\\n            profit = tempProfit\\n            console.log(\\'returning now\\')\\n            process =false\\n            return profit\\n        }\\n    } else {\\n        prices = [...prices.slice(0,maxPriceIndex),...prices.slice(maxPriceIndex+1,prices.length)]\\n    }\\n  }\\n  \\n    return profit\\n};\\n```\\n\\nLOG OUTPUT:\\n```\\nprocess is true\\nprices [ 7, 1, 5, 3, 6, 4 ]\\nprocess true\\nminIdx 1\\nmaxIdx 0\\nprices [ 1, 5, 3, 6, 4 ]\\nprocess true\\nminIdx 0\\nmaxIdx 3\\nreturning now\\nprocess is true\\nprices [ 7, 6, 4, 3, 1 ]\\nprocess true\\nminIdx 4\\nmaxIdx 0\\nwhy am i here?\\nprices [ 7, 6, 4, 3, 1 ]\\nprocess true\\nminIdx 4\\nmaxIdx 0\\nwhy am i here?\\n```\\n"
                    },
                    {
                        "username": "user4279js",
                        "content": "Strange,... Would be good to console log the version of the node runtime version if that\\'s possible"
                    },
                    {
                        "username": "Subiksha_KS",
                        "content": "For the test case #153,\n`prices = [3,3,5,0,0,3,1,4]`\nHow is the expected output 4 and not 3?\n\nAccording to me the explanation is : Buy on day 7 (price = 1) and sell on day 8 (price = 4), so profit = 4-1 = 3.\n\nWhere am I going wrong?\n"
                    },
                    {
                        "username": "shubhamDhapola",
                        "content": "buy on day 4 or day 5(price = 0) and sell on day 8-- price=4\\n4-0=4 ,  the gap between the buying and selling day doesn\\'t matter"
                    },
                    {
                        "username": "apoorva123sinha123",
                        "content": "how does it make sense that [1,2] expects an output of 1 instead of 2?"
                    },
                    {
                        "username": "shubhamDhapola",
                        "content": "buy on day 1 at 1 , sell on day 2 at 2 -- 2-1=1 answer"
                    },
                    {
                        "username": "darthnithin",
                        "content": "Time limit exceeded using the intuitive brute force method :("
                    }
                ]
            },
            {
                "id": 2012720,
                "content": [
                    {
                        "username": "gmnaik96",
                        "content": "Q1. Why am I getting time limit exceeded error for following code?\\n\\nprofit = 0\\n\\n        for i in range(0,len(prices)-1):\\n            key = prices[i]\\n            for j in range(i+1,len(prices)):\\n                if(prices[j] > key):\\n                    newprofit = prices[j] - key\\n                    \\n                    if(newprofit > profit):\\n                        profit = newprofit\\n                  \\n        return profit"
                    },
                    {
                        "username": "Rivo11",
                        "content": "Because your code run in o(n^2) brute force .. and the test cases provided make you must run your code in a less time \\n2 options :\\n1) Optimize your o(n^2) .. you will submit but in a low time efficency\\n2) Find a o(n) solution using extra space."
                    },
                    {
                        "username": "Strix_wl",
                        "content": "This cant be easy XD"
                    },
                    {
                        "username": "daria_mp",
                        "content": "i make this declaration \\ndef maxProfit(self, prices = List[int]) -> int: \\nand it says invalid syntax. I don\\'t know why. I\\'ve used it before and it worked properly. Can someone give me a hint?"
                    },
                    {
                        "username": "kar10arora",
                        "content": "I am getting this error again and again during the compilation of the code. And I have Checked the code in different compiler and it is running successfully. So why I am getting this error here again and again..\\n\\n=================================================================\\n==23==ERROR: AddressSanitizer: heap-buffer-overflow on address 0x603000000028 at pc 0x560e7035f015 bp 0x7ffeb3ced9a0 sp 0x7ffeb3ced990\\nREAD of size 4 at 0x603000000028 thread T0\\n    #2 0x7fdcba585082 in __libc_start_main (/lib/x86_64-linux-gnu/libc.so.6+0x24082)\\n0x603000000028 is located 0 bytes to the right of 24-byte region [0x603000000010,0x603000000028)\\nallocated by thread T0 here:\\n    #0 0x7fdcbb1cd808 in __interceptor_malloc ../../../../src/libsanitizer/asan/asan_malloc_linux.cc:144\\n    #3 0x7fdcba585082 in __libc_start_main (/lib/x86_64-linux-gnu/libc.so.6+0x24082)\\nShadow bytes around the buggy address:\\n  0x0c067fff7fb0: 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00\\n  0x0c067fff7fc0: 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00\\n  0x0c067fff7fd0: 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00\\n  0x0c067fff7fe0: 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00\\n  0x0c067fff7ff0: 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00\\n=>0x0c067fff8000: fa fa 00 00 00[fa]fa fa fa fa fa fa fa fa fa fa\\n  0x0c067fff8010: fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa\\n  0x0c067fff8020: fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa\\n  0x0c067fff8030: fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa\\n  0x0c067fff8040: fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa\\n  0x0c067fff8050: fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa\\nShadow byte legend (one shadow byte represents 8 application bytes):\\n  Addressable:           00\\n  Partially addressable: 01 02 03 04 05 06 07 \\n  Heap left redzone:       fa\\n  Freed heap region:       fd\\n  Stack left redzone:      f1\\n  Stack mid redzone:       f2\\n  Stack right redzone:     f3\\n  Stack after return:      f5\\n  Stack use after scope:   f8\\n  Global redzone:          f9\\n  Global init order:       f6\\n  Poisoned by user:        f7\\n  Container overflow:      fc\\n  Array cookie:            ac\\n  Intra object redzone:    bb\\n  ASan internal:           fe\\n  Left alloca redzone:     ca\\n  Right alloca redzone:    cb\\n  Shadow gap:              cc\\n==23==ABORTING"
                    },
                    {
                        "username": "devhindo",
                        "content": "how is this easy"
                    },
                    {
                        "username": "sunny_nath",
                        "content": "i have simple logic but it is not working for prices=[2,1,4], can anyone help?\nsome part of code is with the question, please consider it.\n\n\n \nclass Solution(object):\n    def maxProfit(self, prices):\n            if len(prices)==2:\n                for i in range(len(prices)-1):\n\n                    if prices[i]<prices[i+1]:\n                        return prices[i+1]-prices[i]\n                    else:\n                        return 0\n            if prices==sorted(prices):\n                return prices[-1]-prices[0]\n            min_p=float(inf)\n            max_p=0\n            for i in range(len(prices) - 1):\n                if prices[i] < min_p:\n                    min_p = prices[i]\n                elif prices[i] > max_p:\n                    max_p = prices[i]\n                else:\n                    continue\n            \n            if min_p <= max_p:\n                return max_p - min_p\n            else:\n                return 0\n"
                    },
                    {
                        "username": "user0570Va",
                        "content": "Having an issue with the test runner not returning from within a while loop. Tried this code for input of [ 7, 1, 5, 3, 6, 4 ] in a node shell and it returns just fine.\\n\\nI\\'ve tried using a break, setting a boolean condition the while evaluates, and explicitly returning from within the while but it always seems to get caught in an infinite loop!\\n\\n```\\n/**\\n * @param {number[]} prices\\n * @return {number}\\n */\\n\\nvar maxProfit = function(prices) {\\nlet process = true\\n\\n  let profit = 0\\n  console.log(\\'process is\\', process)\\n  while(process) {\\n    // profit = prices[0]\\n\\n    console.log(\\'prices\\', prices)\\n    console.log(\\'process\\', process)\\n    const maxPrice = Math.max(...prices)\\n    const minPrice = Math.min(...prices)\\n  \\n    const maxPriceIndex = prices.findIndex((p)=> p===maxPrice)\\n    const minPriceIndex = prices.findIndex((p)=> p===minPrice)\\n    console.log(\\'minIdx\\', minPriceIndex)\\n    console.log(\\'maxIdx\\', maxPriceIndex)\\n    if (minPriceIndex === prices.length-1) {\\n        console.log(\\'why am i here?\\')\\n        prices = [...prices.slice(0, prices.length)]\\n        continue\\n    }\\n    if(minPriceIndex < maxPriceIndex) {\\n        const tempProfit = maxPrice-minPrice\\n        if(tempProfit > profit) {\\n            profit = tempProfit\\n            console.log(\\'returning now\\')\\n            process =false\\n            return profit\\n        }\\n    } else {\\n        prices = [...prices.slice(0,maxPriceIndex),...prices.slice(maxPriceIndex+1,prices.length)]\\n    }\\n  }\\n  \\n    return profit\\n};\\n```\\n\\nLOG OUTPUT:\\n```\\nprocess is true\\nprices [ 7, 1, 5, 3, 6, 4 ]\\nprocess true\\nminIdx 1\\nmaxIdx 0\\nprices [ 1, 5, 3, 6, 4 ]\\nprocess true\\nminIdx 0\\nmaxIdx 3\\nreturning now\\nprocess is true\\nprices [ 7, 6, 4, 3, 1 ]\\nprocess true\\nminIdx 4\\nmaxIdx 0\\nwhy am i here?\\nprices [ 7, 6, 4, 3, 1 ]\\nprocess true\\nminIdx 4\\nmaxIdx 0\\nwhy am i here?\\n```\\n"
                    },
                    {
                        "username": "user4279js",
                        "content": "Strange,... Would be good to console log the version of the node runtime version if that\\'s possible"
                    },
                    {
                        "username": "Subiksha_KS",
                        "content": "For the test case #153,\n`prices = [3,3,5,0,0,3,1,4]`\nHow is the expected output 4 and not 3?\n\nAccording to me the explanation is : Buy on day 7 (price = 1) and sell on day 8 (price = 4), so profit = 4-1 = 3.\n\nWhere am I going wrong?\n"
                    },
                    {
                        "username": "shubhamDhapola",
                        "content": "buy on day 4 or day 5(price = 0) and sell on day 8-- price=4\\n4-0=4 ,  the gap between the buying and selling day doesn\\'t matter"
                    },
                    {
                        "username": "apoorva123sinha123",
                        "content": "how does it make sense that [1,2] expects an output of 1 instead of 2?"
                    },
                    {
                        "username": "shubhamDhapola",
                        "content": "buy on day 1 at 1 , sell on day 2 at 2 -- 2-1=1 answer"
                    },
                    {
                        "username": "darthnithin",
                        "content": "Time limit exceeded using the intuitive brute force method :("
                    }
                ]
            },
            {
                "id": 2011482,
                "content": [
                    {
                        "username": "gmnaik96",
                        "content": "Q1. Why am I getting time limit exceeded error for following code?\\n\\nprofit = 0\\n\\n        for i in range(0,len(prices)-1):\\n            key = prices[i]\\n            for j in range(i+1,len(prices)):\\n                if(prices[j] > key):\\n                    newprofit = prices[j] - key\\n                    \\n                    if(newprofit > profit):\\n                        profit = newprofit\\n                  \\n        return profit"
                    },
                    {
                        "username": "Rivo11",
                        "content": "Because your code run in o(n^2) brute force .. and the test cases provided make you must run your code in a less time \\n2 options :\\n1) Optimize your o(n^2) .. you will submit but in a low time efficency\\n2) Find a o(n) solution using extra space."
                    },
                    {
                        "username": "Strix_wl",
                        "content": "This cant be easy XD"
                    },
                    {
                        "username": "daria_mp",
                        "content": "i make this declaration \\ndef maxProfit(self, prices = List[int]) -> int: \\nand it says invalid syntax. I don\\'t know why. I\\'ve used it before and it worked properly. Can someone give me a hint?"
                    },
                    {
                        "username": "kar10arora",
                        "content": "I am getting this error again and again during the compilation of the code. And I have Checked the code in different compiler and it is running successfully. So why I am getting this error here again and again..\\n\\n=================================================================\\n==23==ERROR: AddressSanitizer: heap-buffer-overflow on address 0x603000000028 at pc 0x560e7035f015 bp 0x7ffeb3ced9a0 sp 0x7ffeb3ced990\\nREAD of size 4 at 0x603000000028 thread T0\\n    #2 0x7fdcba585082 in __libc_start_main (/lib/x86_64-linux-gnu/libc.so.6+0x24082)\\n0x603000000028 is located 0 bytes to the right of 24-byte region [0x603000000010,0x603000000028)\\nallocated by thread T0 here:\\n    #0 0x7fdcbb1cd808 in __interceptor_malloc ../../../../src/libsanitizer/asan/asan_malloc_linux.cc:144\\n    #3 0x7fdcba585082 in __libc_start_main (/lib/x86_64-linux-gnu/libc.so.6+0x24082)\\nShadow bytes around the buggy address:\\n  0x0c067fff7fb0: 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00\\n  0x0c067fff7fc0: 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00\\n  0x0c067fff7fd0: 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00\\n  0x0c067fff7fe0: 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00\\n  0x0c067fff7ff0: 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00\\n=>0x0c067fff8000: fa fa 00 00 00[fa]fa fa fa fa fa fa fa fa fa fa\\n  0x0c067fff8010: fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa\\n  0x0c067fff8020: fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa\\n  0x0c067fff8030: fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa\\n  0x0c067fff8040: fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa\\n  0x0c067fff8050: fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa\\nShadow byte legend (one shadow byte represents 8 application bytes):\\n  Addressable:           00\\n  Partially addressable: 01 02 03 04 05 06 07 \\n  Heap left redzone:       fa\\n  Freed heap region:       fd\\n  Stack left redzone:      f1\\n  Stack mid redzone:       f2\\n  Stack right redzone:     f3\\n  Stack after return:      f5\\n  Stack use after scope:   f8\\n  Global redzone:          f9\\n  Global init order:       f6\\n  Poisoned by user:        f7\\n  Container overflow:      fc\\n  Array cookie:            ac\\n  Intra object redzone:    bb\\n  ASan internal:           fe\\n  Left alloca redzone:     ca\\n  Right alloca redzone:    cb\\n  Shadow gap:              cc\\n==23==ABORTING"
                    },
                    {
                        "username": "devhindo",
                        "content": "how is this easy"
                    },
                    {
                        "username": "sunny_nath",
                        "content": "i have simple logic but it is not working for prices=[2,1,4], can anyone help?\nsome part of code is with the question, please consider it.\n\n\n \nclass Solution(object):\n    def maxProfit(self, prices):\n            if len(prices)==2:\n                for i in range(len(prices)-1):\n\n                    if prices[i]<prices[i+1]:\n                        return prices[i+1]-prices[i]\n                    else:\n                        return 0\n            if prices==sorted(prices):\n                return prices[-1]-prices[0]\n            min_p=float(inf)\n            max_p=0\n            for i in range(len(prices) - 1):\n                if prices[i] < min_p:\n                    min_p = prices[i]\n                elif prices[i] > max_p:\n                    max_p = prices[i]\n                else:\n                    continue\n            \n            if min_p <= max_p:\n                return max_p - min_p\n            else:\n                return 0\n"
                    },
                    {
                        "username": "user0570Va",
                        "content": "Having an issue with the test runner not returning from within a while loop. Tried this code for input of [ 7, 1, 5, 3, 6, 4 ] in a node shell and it returns just fine.\\n\\nI\\'ve tried using a break, setting a boolean condition the while evaluates, and explicitly returning from within the while but it always seems to get caught in an infinite loop!\\n\\n```\\n/**\\n * @param {number[]} prices\\n * @return {number}\\n */\\n\\nvar maxProfit = function(prices) {\\nlet process = true\\n\\n  let profit = 0\\n  console.log(\\'process is\\', process)\\n  while(process) {\\n    // profit = prices[0]\\n\\n    console.log(\\'prices\\', prices)\\n    console.log(\\'process\\', process)\\n    const maxPrice = Math.max(...prices)\\n    const minPrice = Math.min(...prices)\\n  \\n    const maxPriceIndex = prices.findIndex((p)=> p===maxPrice)\\n    const minPriceIndex = prices.findIndex((p)=> p===minPrice)\\n    console.log(\\'minIdx\\', minPriceIndex)\\n    console.log(\\'maxIdx\\', maxPriceIndex)\\n    if (minPriceIndex === prices.length-1) {\\n        console.log(\\'why am i here?\\')\\n        prices = [...prices.slice(0, prices.length)]\\n        continue\\n    }\\n    if(minPriceIndex < maxPriceIndex) {\\n        const tempProfit = maxPrice-minPrice\\n        if(tempProfit > profit) {\\n            profit = tempProfit\\n            console.log(\\'returning now\\')\\n            process =false\\n            return profit\\n        }\\n    } else {\\n        prices = [...prices.slice(0,maxPriceIndex),...prices.slice(maxPriceIndex+1,prices.length)]\\n    }\\n  }\\n  \\n    return profit\\n};\\n```\\n\\nLOG OUTPUT:\\n```\\nprocess is true\\nprices [ 7, 1, 5, 3, 6, 4 ]\\nprocess true\\nminIdx 1\\nmaxIdx 0\\nprices [ 1, 5, 3, 6, 4 ]\\nprocess true\\nminIdx 0\\nmaxIdx 3\\nreturning now\\nprocess is true\\nprices [ 7, 6, 4, 3, 1 ]\\nprocess true\\nminIdx 4\\nmaxIdx 0\\nwhy am i here?\\nprices [ 7, 6, 4, 3, 1 ]\\nprocess true\\nminIdx 4\\nmaxIdx 0\\nwhy am i here?\\n```\\n"
                    },
                    {
                        "username": "user4279js",
                        "content": "Strange,... Would be good to console log the version of the node runtime version if that\\'s possible"
                    },
                    {
                        "username": "Subiksha_KS",
                        "content": "For the test case #153,\n`prices = [3,3,5,0,0,3,1,4]`\nHow is the expected output 4 and not 3?\n\nAccording to me the explanation is : Buy on day 7 (price = 1) and sell on day 8 (price = 4), so profit = 4-1 = 3.\n\nWhere am I going wrong?\n"
                    },
                    {
                        "username": "shubhamDhapola",
                        "content": "buy on day 4 or day 5(price = 0) and sell on day 8-- price=4\\n4-0=4 ,  the gap between the buying and selling day doesn\\'t matter"
                    },
                    {
                        "username": "apoorva123sinha123",
                        "content": "how does it make sense that [1,2] expects an output of 1 instead of 2?"
                    },
                    {
                        "username": "shubhamDhapola",
                        "content": "buy on day 1 at 1 , sell on day 2 at 2 -- 2-1=1 answer"
                    },
                    {
                        "username": "darthnithin",
                        "content": "Time limit exceeded using the intuitive brute force method :("
                    }
                ]
            },
            {
                "id": 2008881,
                "content": [
                    {
                        "username": "gmnaik96",
                        "content": "Q1. Why am I getting time limit exceeded error for following code?\\n\\nprofit = 0\\n\\n        for i in range(0,len(prices)-1):\\n            key = prices[i]\\n            for j in range(i+1,len(prices)):\\n                if(prices[j] > key):\\n                    newprofit = prices[j] - key\\n                    \\n                    if(newprofit > profit):\\n                        profit = newprofit\\n                  \\n        return profit"
                    },
                    {
                        "username": "Rivo11",
                        "content": "Because your code run in o(n^2) brute force .. and the test cases provided make you must run your code in a less time \\n2 options :\\n1) Optimize your o(n^2) .. you will submit but in a low time efficency\\n2) Find a o(n) solution using extra space."
                    },
                    {
                        "username": "Strix_wl",
                        "content": "This cant be easy XD"
                    },
                    {
                        "username": "daria_mp",
                        "content": "i make this declaration \\ndef maxProfit(self, prices = List[int]) -> int: \\nand it says invalid syntax. I don\\'t know why. I\\'ve used it before and it worked properly. Can someone give me a hint?"
                    },
                    {
                        "username": "kar10arora",
                        "content": "I am getting this error again and again during the compilation of the code. And I have Checked the code in different compiler and it is running successfully. So why I am getting this error here again and again..\\n\\n=================================================================\\n==23==ERROR: AddressSanitizer: heap-buffer-overflow on address 0x603000000028 at pc 0x560e7035f015 bp 0x7ffeb3ced9a0 sp 0x7ffeb3ced990\\nREAD of size 4 at 0x603000000028 thread T0\\n    #2 0x7fdcba585082 in __libc_start_main (/lib/x86_64-linux-gnu/libc.so.6+0x24082)\\n0x603000000028 is located 0 bytes to the right of 24-byte region [0x603000000010,0x603000000028)\\nallocated by thread T0 here:\\n    #0 0x7fdcbb1cd808 in __interceptor_malloc ../../../../src/libsanitizer/asan/asan_malloc_linux.cc:144\\n    #3 0x7fdcba585082 in __libc_start_main (/lib/x86_64-linux-gnu/libc.so.6+0x24082)\\nShadow bytes around the buggy address:\\n  0x0c067fff7fb0: 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00\\n  0x0c067fff7fc0: 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00\\n  0x0c067fff7fd0: 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00\\n  0x0c067fff7fe0: 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00\\n  0x0c067fff7ff0: 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00\\n=>0x0c067fff8000: fa fa 00 00 00[fa]fa fa fa fa fa fa fa fa fa fa\\n  0x0c067fff8010: fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa\\n  0x0c067fff8020: fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa\\n  0x0c067fff8030: fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa\\n  0x0c067fff8040: fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa\\n  0x0c067fff8050: fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa\\nShadow byte legend (one shadow byte represents 8 application bytes):\\n  Addressable:           00\\n  Partially addressable: 01 02 03 04 05 06 07 \\n  Heap left redzone:       fa\\n  Freed heap region:       fd\\n  Stack left redzone:      f1\\n  Stack mid redzone:       f2\\n  Stack right redzone:     f3\\n  Stack after return:      f5\\n  Stack use after scope:   f8\\n  Global redzone:          f9\\n  Global init order:       f6\\n  Poisoned by user:        f7\\n  Container overflow:      fc\\n  Array cookie:            ac\\n  Intra object redzone:    bb\\n  ASan internal:           fe\\n  Left alloca redzone:     ca\\n  Right alloca redzone:    cb\\n  Shadow gap:              cc\\n==23==ABORTING"
                    },
                    {
                        "username": "devhindo",
                        "content": "how is this easy"
                    },
                    {
                        "username": "sunny_nath",
                        "content": "i have simple logic but it is not working for prices=[2,1,4], can anyone help?\nsome part of code is with the question, please consider it.\n\n\n \nclass Solution(object):\n    def maxProfit(self, prices):\n            if len(prices)==2:\n                for i in range(len(prices)-1):\n\n                    if prices[i]<prices[i+1]:\n                        return prices[i+1]-prices[i]\n                    else:\n                        return 0\n            if prices==sorted(prices):\n                return prices[-1]-prices[0]\n            min_p=float(inf)\n            max_p=0\n            for i in range(len(prices) - 1):\n                if prices[i] < min_p:\n                    min_p = prices[i]\n                elif prices[i] > max_p:\n                    max_p = prices[i]\n                else:\n                    continue\n            \n            if min_p <= max_p:\n                return max_p - min_p\n            else:\n                return 0\n"
                    },
                    {
                        "username": "user0570Va",
                        "content": "Having an issue with the test runner not returning from within a while loop. Tried this code for input of [ 7, 1, 5, 3, 6, 4 ] in a node shell and it returns just fine.\\n\\nI\\'ve tried using a break, setting a boolean condition the while evaluates, and explicitly returning from within the while but it always seems to get caught in an infinite loop!\\n\\n```\\n/**\\n * @param {number[]} prices\\n * @return {number}\\n */\\n\\nvar maxProfit = function(prices) {\\nlet process = true\\n\\n  let profit = 0\\n  console.log(\\'process is\\', process)\\n  while(process) {\\n    // profit = prices[0]\\n\\n    console.log(\\'prices\\', prices)\\n    console.log(\\'process\\', process)\\n    const maxPrice = Math.max(...prices)\\n    const minPrice = Math.min(...prices)\\n  \\n    const maxPriceIndex = prices.findIndex((p)=> p===maxPrice)\\n    const minPriceIndex = prices.findIndex((p)=> p===minPrice)\\n    console.log(\\'minIdx\\', minPriceIndex)\\n    console.log(\\'maxIdx\\', maxPriceIndex)\\n    if (minPriceIndex === prices.length-1) {\\n        console.log(\\'why am i here?\\')\\n        prices = [...prices.slice(0, prices.length)]\\n        continue\\n    }\\n    if(minPriceIndex < maxPriceIndex) {\\n        const tempProfit = maxPrice-minPrice\\n        if(tempProfit > profit) {\\n            profit = tempProfit\\n            console.log(\\'returning now\\')\\n            process =false\\n            return profit\\n        }\\n    } else {\\n        prices = [...prices.slice(0,maxPriceIndex),...prices.slice(maxPriceIndex+1,prices.length)]\\n    }\\n  }\\n  \\n    return profit\\n};\\n```\\n\\nLOG OUTPUT:\\n```\\nprocess is true\\nprices [ 7, 1, 5, 3, 6, 4 ]\\nprocess true\\nminIdx 1\\nmaxIdx 0\\nprices [ 1, 5, 3, 6, 4 ]\\nprocess true\\nminIdx 0\\nmaxIdx 3\\nreturning now\\nprocess is true\\nprices [ 7, 6, 4, 3, 1 ]\\nprocess true\\nminIdx 4\\nmaxIdx 0\\nwhy am i here?\\nprices [ 7, 6, 4, 3, 1 ]\\nprocess true\\nminIdx 4\\nmaxIdx 0\\nwhy am i here?\\n```\\n"
                    },
                    {
                        "username": "user4279js",
                        "content": "Strange,... Would be good to console log the version of the node runtime version if that\\'s possible"
                    },
                    {
                        "username": "Subiksha_KS",
                        "content": "For the test case #153,\n`prices = [3,3,5,0,0,3,1,4]`\nHow is the expected output 4 and not 3?\n\nAccording to me the explanation is : Buy on day 7 (price = 1) and sell on day 8 (price = 4), so profit = 4-1 = 3.\n\nWhere am I going wrong?\n"
                    },
                    {
                        "username": "shubhamDhapola",
                        "content": "buy on day 4 or day 5(price = 0) and sell on day 8-- price=4\\n4-0=4 ,  the gap between the buying and selling day doesn\\'t matter"
                    },
                    {
                        "username": "apoorva123sinha123",
                        "content": "how does it make sense that [1,2] expects an output of 1 instead of 2?"
                    },
                    {
                        "username": "shubhamDhapola",
                        "content": "buy on day 1 at 1 , sell on day 2 at 2 -- 2-1=1 answer"
                    },
                    {
                        "username": "darthnithin",
                        "content": "Time limit exceeded using the intuitive brute force method :("
                    }
                ]
            },
            {
                "id": 2008631,
                "content": [
                    {
                        "username": "chakravarthybatna46234",
                        "content": "why this below code shows Time Limit Exceeded when i submit my answer,\\nis this code wrong??????? please tell anyone\\n\\nclass Solution {\\n    public int maxProfit(int[] prices) {\\n        int max=0,profit=0,k=2;\\n        for(int i=prices.length-1;i>=0;i--)\\n        {\\n            for(int j=prices.length-k;j>=0;j--)\\n            {\\n               profit=prices[i]-prices[j];\\n               if(profit>0&&profit>max)\\n               {\\n                   max=profit;\\n               }\\n            }\\n            k++;\\n        }\\n        return max;\\n    }\\n}"
                    },
                    {
                        "username": "user4279js",
                        "content": "You can do this problem in linear time, so this probably isn\\'t accepted for larger inputs "
                    },
                    {
                        "username": "ojjasvi",
                        "content": "This is a tricky question . If you are solving this question using two loop one for smallest number and second loop for maximum profit ..... then think again \\uD83D\\uDE00"
                    },
                    {
                        "username": "aceton41k",
                        "content": "Time Limit Exceeded on test case 200/212 in Java"
                    },
                    {
                        "username": "user4279js",
                        "content": "Please post a snippet or what your expected time complexity is... For this problem, only linear is accepted I think"
                    },
                    {
                        "username": "poornachandra07",
                        "content": "Can someone help me in below C# solution. It fails at 198th testcase\\n\\n`public int MaxProfit(int[] prices) {\\n        if(prices.Length<2) \\nreturn 0;\\n        var bestPrice = prices\\n        .SelectMany((price, index) => prices\\n            .Skip(index + 1)\\n            .Select(nxtPrice => price - nxtPrice))\\n        .Min();\\n\\n\\n        if(bestPrice<0){\\n            return -(bestPrice);\\n        }\\n        return 0;\\n    }`"
                    },
                    {
                        "username": "user4279js",
                        "content": "This approach doesn\\'t work .. firstly  you can\\'t just flip the sign of bestPrice, if it\\'s negative it means you bought for more than you sold so the sign has a significance to the problem.\\nSecondly  I think your code is doing O(n^2) work with the two selects correct me if I\\'m wrong."
                    },
                    {
                        "username": "chandancodes_28",
                        "content": "guys , i code in c and i have 200/212 testcases passed . i applied double pointer and then returned the maximum profit i could . someone plz help"
                    },
                    {
                        "username": "LeetCode_Problem",
                        "content": "prices = [2,4,1] why the expected value is 2. Can anyone please tell me"
                    },
                    {
                        "username": "SwaggerKid",
                        "content": "u bought on the 1st day, and sold on the second. So your profit is 2 dollars. "
                    },
                    {
                        "username": "vamshidharreddy3397",
                        "content": "Should we consider 0 while buying stock or avoid it?\\n\\nthere are 2 test cases which are conflicting\\n1) [3,2,6,5,0,3] in this case expected output is 4 which is (6-2)\\n2) [2,1,2,1,0,1,2] in this case expected output is 2 which can be (2 - 0)\\n\\nThanks in advance"
                    },
                    {
                        "username": "makleo2002",
                        "content": "211 case is incorrect"
                    },
                    {
                        "username": "nikitafeoktistov",
                        "content": "The solutions all mention a greedy approach, where you keep track of the minimum cost and update it whenever there is a smaller value. Why doesn\\'t this fail any testcases? I\\'d imagine something along the lines of [6,12,1,3] would cause those algorithms to fail, no?"
                    },
                    {
                        "username": "bparanj",
                        "content": "This approach doesn\\'t fail any test cases due to the nature of the problem. The problem asks for the maximum profit we can make from a single buy and sell operation. The best time to buy is always the lowest possible price up to the current point in time, which is why we keep track of the minimum cost.\\n\\nFor your example, [6,12,1,3], this approach correctly identifies that the best time to buy is when the cost is 1. However, it also keeps track of the maximum profit possible up to the current point in time, which includes profits made before we encounter this new minimum.\\n\\nLet\\'s break down this example:\\n\\n- Initially, the minimum cost is 6, and the maximum profit is 0.\\n- Next, we see 12. We update our maximum profit to be max(0, 12 - 6) = 6. Minimum cost remains at 6.\\n- Then, we see 1. Now, we update our minimum cost to be 1 since 1 < 6. Our maximum profit is still 6 from before.\\n- Finally, we see 3. The maximum profit becomes max(6, 3 - 1) = 6.\\n\\nSo, the algorithm correctly returns 6 as the maximum profit. It\\'s important to note that the algorithm doesn\\'t just remember the latest minimum cost, but also the maximum profit it can make with previous minimum costs. So, the greedy approach works perfectly for this problem."
                    },
                    {
                        "username": "johngjackson0",
                        "content": "You\\'re not using the minimum of the data set. Whichever element you are on, you need to know the minimum BUY from all other elements in the previous elements only. Calculate the profit and max profit at that element. This ensures you\\'re doing buy and sell in proper order for the answer. "
                    },
                    {
                        "username": "abhishekspawar2003",
                        "content": "[2,11,1,4,7]\\nHow to let code know that there is good option lies at start."
                    }
                ]
            },
            {
                "id": 2007997,
                "content": [
                    {
                        "username": "chakravarthybatna46234",
                        "content": "why this below code shows Time Limit Exceeded when i submit my answer,\\nis this code wrong??????? please tell anyone\\n\\nclass Solution {\\n    public int maxProfit(int[] prices) {\\n        int max=0,profit=0,k=2;\\n        for(int i=prices.length-1;i>=0;i--)\\n        {\\n            for(int j=prices.length-k;j>=0;j--)\\n            {\\n               profit=prices[i]-prices[j];\\n               if(profit>0&&profit>max)\\n               {\\n                   max=profit;\\n               }\\n            }\\n            k++;\\n        }\\n        return max;\\n    }\\n}"
                    },
                    {
                        "username": "user4279js",
                        "content": "You can do this problem in linear time, so this probably isn\\'t accepted for larger inputs "
                    },
                    {
                        "username": "ojjasvi",
                        "content": "This is a tricky question . If you are solving this question using two loop one for smallest number and second loop for maximum profit ..... then think again \\uD83D\\uDE00"
                    },
                    {
                        "username": "aceton41k",
                        "content": "Time Limit Exceeded on test case 200/212 in Java"
                    },
                    {
                        "username": "user4279js",
                        "content": "Please post a snippet or what your expected time complexity is... For this problem, only linear is accepted I think"
                    },
                    {
                        "username": "poornachandra07",
                        "content": "Can someone help me in below C# solution. It fails at 198th testcase\\n\\n`public int MaxProfit(int[] prices) {\\n        if(prices.Length<2) \\nreturn 0;\\n        var bestPrice = prices\\n        .SelectMany((price, index) => prices\\n            .Skip(index + 1)\\n            .Select(nxtPrice => price - nxtPrice))\\n        .Min();\\n\\n\\n        if(bestPrice<0){\\n            return -(bestPrice);\\n        }\\n        return 0;\\n    }`"
                    },
                    {
                        "username": "user4279js",
                        "content": "This approach doesn\\'t work .. firstly  you can\\'t just flip the sign of bestPrice, if it\\'s negative it means you bought for more than you sold so the sign has a significance to the problem.\\nSecondly  I think your code is doing O(n^2) work with the two selects correct me if I\\'m wrong."
                    },
                    {
                        "username": "chandancodes_28",
                        "content": "guys , i code in c and i have 200/212 testcases passed . i applied double pointer and then returned the maximum profit i could . someone plz help"
                    },
                    {
                        "username": "LeetCode_Problem",
                        "content": "prices = [2,4,1] why the expected value is 2. Can anyone please tell me"
                    },
                    {
                        "username": "SwaggerKid",
                        "content": "u bought on the 1st day, and sold on the second. So your profit is 2 dollars. "
                    },
                    {
                        "username": "vamshidharreddy3397",
                        "content": "Should we consider 0 while buying stock or avoid it?\\n\\nthere are 2 test cases which are conflicting\\n1) [3,2,6,5,0,3] in this case expected output is 4 which is (6-2)\\n2) [2,1,2,1,0,1,2] in this case expected output is 2 which can be (2 - 0)\\n\\nThanks in advance"
                    },
                    {
                        "username": "makleo2002",
                        "content": "211 case is incorrect"
                    },
                    {
                        "username": "nikitafeoktistov",
                        "content": "The solutions all mention a greedy approach, where you keep track of the minimum cost and update it whenever there is a smaller value. Why doesn\\'t this fail any testcases? I\\'d imagine something along the lines of [6,12,1,3] would cause those algorithms to fail, no?"
                    },
                    {
                        "username": "bparanj",
                        "content": "This approach doesn\\'t fail any test cases due to the nature of the problem. The problem asks for the maximum profit we can make from a single buy and sell operation. The best time to buy is always the lowest possible price up to the current point in time, which is why we keep track of the minimum cost.\\n\\nFor your example, [6,12,1,3], this approach correctly identifies that the best time to buy is when the cost is 1. However, it also keeps track of the maximum profit possible up to the current point in time, which includes profits made before we encounter this new minimum.\\n\\nLet\\'s break down this example:\\n\\n- Initially, the minimum cost is 6, and the maximum profit is 0.\\n- Next, we see 12. We update our maximum profit to be max(0, 12 - 6) = 6. Minimum cost remains at 6.\\n- Then, we see 1. Now, we update our minimum cost to be 1 since 1 < 6. Our maximum profit is still 6 from before.\\n- Finally, we see 3. The maximum profit becomes max(6, 3 - 1) = 6.\\n\\nSo, the algorithm correctly returns 6 as the maximum profit. It\\'s important to note that the algorithm doesn\\'t just remember the latest minimum cost, but also the maximum profit it can make with previous minimum costs. So, the greedy approach works perfectly for this problem."
                    },
                    {
                        "username": "johngjackson0",
                        "content": "You\\'re not using the minimum of the data set. Whichever element you are on, you need to know the minimum BUY from all other elements in the previous elements only. Calculate the profit and max profit at that element. This ensures you\\'re doing buy and sell in proper order for the answer. "
                    },
                    {
                        "username": "abhishekspawar2003",
                        "content": "[2,11,1,4,7]\\nHow to let code know that there is good option lies at start."
                    }
                ]
            },
            {
                "id": 2007439,
                "content": [
                    {
                        "username": "chakravarthybatna46234",
                        "content": "why this below code shows Time Limit Exceeded when i submit my answer,\\nis this code wrong??????? please tell anyone\\n\\nclass Solution {\\n    public int maxProfit(int[] prices) {\\n        int max=0,profit=0,k=2;\\n        for(int i=prices.length-1;i>=0;i--)\\n        {\\n            for(int j=prices.length-k;j>=0;j--)\\n            {\\n               profit=prices[i]-prices[j];\\n               if(profit>0&&profit>max)\\n               {\\n                   max=profit;\\n               }\\n            }\\n            k++;\\n        }\\n        return max;\\n    }\\n}"
                    },
                    {
                        "username": "user4279js",
                        "content": "You can do this problem in linear time, so this probably isn\\'t accepted for larger inputs "
                    },
                    {
                        "username": "ojjasvi",
                        "content": "This is a tricky question . If you are solving this question using two loop one for smallest number and second loop for maximum profit ..... then think again \\uD83D\\uDE00"
                    },
                    {
                        "username": "aceton41k",
                        "content": "Time Limit Exceeded on test case 200/212 in Java"
                    },
                    {
                        "username": "user4279js",
                        "content": "Please post a snippet or what your expected time complexity is... For this problem, only linear is accepted I think"
                    },
                    {
                        "username": "poornachandra07",
                        "content": "Can someone help me in below C# solution. It fails at 198th testcase\\n\\n`public int MaxProfit(int[] prices) {\\n        if(prices.Length<2) \\nreturn 0;\\n        var bestPrice = prices\\n        .SelectMany((price, index) => prices\\n            .Skip(index + 1)\\n            .Select(nxtPrice => price - nxtPrice))\\n        .Min();\\n\\n\\n        if(bestPrice<0){\\n            return -(bestPrice);\\n        }\\n        return 0;\\n    }`"
                    },
                    {
                        "username": "user4279js",
                        "content": "This approach doesn\\'t work .. firstly  you can\\'t just flip the sign of bestPrice, if it\\'s negative it means you bought for more than you sold so the sign has a significance to the problem.\\nSecondly  I think your code is doing O(n^2) work with the two selects correct me if I\\'m wrong."
                    },
                    {
                        "username": "chandancodes_28",
                        "content": "guys , i code in c and i have 200/212 testcases passed . i applied double pointer and then returned the maximum profit i could . someone plz help"
                    },
                    {
                        "username": "LeetCode_Problem",
                        "content": "prices = [2,4,1] why the expected value is 2. Can anyone please tell me"
                    },
                    {
                        "username": "SwaggerKid",
                        "content": "u bought on the 1st day, and sold on the second. So your profit is 2 dollars. "
                    },
                    {
                        "username": "vamshidharreddy3397",
                        "content": "Should we consider 0 while buying stock or avoid it?\\n\\nthere are 2 test cases which are conflicting\\n1) [3,2,6,5,0,3] in this case expected output is 4 which is (6-2)\\n2) [2,1,2,1,0,1,2] in this case expected output is 2 which can be (2 - 0)\\n\\nThanks in advance"
                    },
                    {
                        "username": "makleo2002",
                        "content": "211 case is incorrect"
                    },
                    {
                        "username": "nikitafeoktistov",
                        "content": "The solutions all mention a greedy approach, where you keep track of the minimum cost and update it whenever there is a smaller value. Why doesn\\'t this fail any testcases? I\\'d imagine something along the lines of [6,12,1,3] would cause those algorithms to fail, no?"
                    },
                    {
                        "username": "bparanj",
                        "content": "This approach doesn\\'t fail any test cases due to the nature of the problem. The problem asks for the maximum profit we can make from a single buy and sell operation. The best time to buy is always the lowest possible price up to the current point in time, which is why we keep track of the minimum cost.\\n\\nFor your example, [6,12,1,3], this approach correctly identifies that the best time to buy is when the cost is 1. However, it also keeps track of the maximum profit possible up to the current point in time, which includes profits made before we encounter this new minimum.\\n\\nLet\\'s break down this example:\\n\\n- Initially, the minimum cost is 6, and the maximum profit is 0.\\n- Next, we see 12. We update our maximum profit to be max(0, 12 - 6) = 6. Minimum cost remains at 6.\\n- Then, we see 1. Now, we update our minimum cost to be 1 since 1 < 6. Our maximum profit is still 6 from before.\\n- Finally, we see 3. The maximum profit becomes max(6, 3 - 1) = 6.\\n\\nSo, the algorithm correctly returns 6 as the maximum profit. It\\'s important to note that the algorithm doesn\\'t just remember the latest minimum cost, but also the maximum profit it can make with previous minimum costs. So, the greedy approach works perfectly for this problem."
                    },
                    {
                        "username": "johngjackson0",
                        "content": "You\\'re not using the minimum of the data set. Whichever element you are on, you need to know the minimum BUY from all other elements in the previous elements only. Calculate the profit and max profit at that element. This ensures you\\'re doing buy and sell in proper order for the answer. "
                    },
                    {
                        "username": "abhishekspawar2003",
                        "content": "[2,11,1,4,7]\\nHow to let code know that there is good option lies at start."
                    }
                ]
            },
            {
                "id": 2005483,
                "content": [
                    {
                        "username": "chakravarthybatna46234",
                        "content": "why this below code shows Time Limit Exceeded when i submit my answer,\\nis this code wrong??????? please tell anyone\\n\\nclass Solution {\\n    public int maxProfit(int[] prices) {\\n        int max=0,profit=0,k=2;\\n        for(int i=prices.length-1;i>=0;i--)\\n        {\\n            for(int j=prices.length-k;j>=0;j--)\\n            {\\n               profit=prices[i]-prices[j];\\n               if(profit>0&&profit>max)\\n               {\\n                   max=profit;\\n               }\\n            }\\n            k++;\\n        }\\n        return max;\\n    }\\n}"
                    },
                    {
                        "username": "user4279js",
                        "content": "You can do this problem in linear time, so this probably isn\\'t accepted for larger inputs "
                    },
                    {
                        "username": "ojjasvi",
                        "content": "This is a tricky question . If you are solving this question using two loop one for smallest number and second loop for maximum profit ..... then think again \\uD83D\\uDE00"
                    },
                    {
                        "username": "aceton41k",
                        "content": "Time Limit Exceeded on test case 200/212 in Java"
                    },
                    {
                        "username": "user4279js",
                        "content": "Please post a snippet or what your expected time complexity is... For this problem, only linear is accepted I think"
                    },
                    {
                        "username": "poornachandra07",
                        "content": "Can someone help me in below C# solution. It fails at 198th testcase\\n\\n`public int MaxProfit(int[] prices) {\\n        if(prices.Length<2) \\nreturn 0;\\n        var bestPrice = prices\\n        .SelectMany((price, index) => prices\\n            .Skip(index + 1)\\n            .Select(nxtPrice => price - nxtPrice))\\n        .Min();\\n\\n\\n        if(bestPrice<0){\\n            return -(bestPrice);\\n        }\\n        return 0;\\n    }`"
                    },
                    {
                        "username": "user4279js",
                        "content": "This approach doesn\\'t work .. firstly  you can\\'t just flip the sign of bestPrice, if it\\'s negative it means you bought for more than you sold so the sign has a significance to the problem.\\nSecondly  I think your code is doing O(n^2) work with the two selects correct me if I\\'m wrong."
                    },
                    {
                        "username": "chandancodes_28",
                        "content": "guys , i code in c and i have 200/212 testcases passed . i applied double pointer and then returned the maximum profit i could . someone plz help"
                    },
                    {
                        "username": "LeetCode_Problem",
                        "content": "prices = [2,4,1] why the expected value is 2. Can anyone please tell me"
                    },
                    {
                        "username": "SwaggerKid",
                        "content": "u bought on the 1st day, and sold on the second. So your profit is 2 dollars. "
                    },
                    {
                        "username": "vamshidharreddy3397",
                        "content": "Should we consider 0 while buying stock or avoid it?\\n\\nthere are 2 test cases which are conflicting\\n1) [3,2,6,5,0,3] in this case expected output is 4 which is (6-2)\\n2) [2,1,2,1,0,1,2] in this case expected output is 2 which can be (2 - 0)\\n\\nThanks in advance"
                    },
                    {
                        "username": "makleo2002",
                        "content": "211 case is incorrect"
                    },
                    {
                        "username": "nikitafeoktistov",
                        "content": "The solutions all mention a greedy approach, where you keep track of the minimum cost and update it whenever there is a smaller value. Why doesn\\'t this fail any testcases? I\\'d imagine something along the lines of [6,12,1,3] would cause those algorithms to fail, no?"
                    },
                    {
                        "username": "bparanj",
                        "content": "This approach doesn\\'t fail any test cases due to the nature of the problem. The problem asks for the maximum profit we can make from a single buy and sell operation. The best time to buy is always the lowest possible price up to the current point in time, which is why we keep track of the minimum cost.\\n\\nFor your example, [6,12,1,3], this approach correctly identifies that the best time to buy is when the cost is 1. However, it also keeps track of the maximum profit possible up to the current point in time, which includes profits made before we encounter this new minimum.\\n\\nLet\\'s break down this example:\\n\\n- Initially, the minimum cost is 6, and the maximum profit is 0.\\n- Next, we see 12. We update our maximum profit to be max(0, 12 - 6) = 6. Minimum cost remains at 6.\\n- Then, we see 1. Now, we update our minimum cost to be 1 since 1 < 6. Our maximum profit is still 6 from before.\\n- Finally, we see 3. The maximum profit becomes max(6, 3 - 1) = 6.\\n\\nSo, the algorithm correctly returns 6 as the maximum profit. It\\'s important to note that the algorithm doesn\\'t just remember the latest minimum cost, but also the maximum profit it can make with previous minimum costs. So, the greedy approach works perfectly for this problem."
                    },
                    {
                        "username": "johngjackson0",
                        "content": "You\\'re not using the minimum of the data set. Whichever element you are on, you need to know the minimum BUY from all other elements in the previous elements only. Calculate the profit and max profit at that element. This ensures you\\'re doing buy and sell in proper order for the answer. "
                    },
                    {
                        "username": "abhishekspawar2003",
                        "content": "[2,11,1,4,7]\\nHow to let code know that there is good option lies at start."
                    }
                ]
            },
            {
                "id": 1997386,
                "content": [
                    {
                        "username": "chakravarthybatna46234",
                        "content": "why this below code shows Time Limit Exceeded when i submit my answer,\\nis this code wrong??????? please tell anyone\\n\\nclass Solution {\\n    public int maxProfit(int[] prices) {\\n        int max=0,profit=0,k=2;\\n        for(int i=prices.length-1;i>=0;i--)\\n        {\\n            for(int j=prices.length-k;j>=0;j--)\\n            {\\n               profit=prices[i]-prices[j];\\n               if(profit>0&&profit>max)\\n               {\\n                   max=profit;\\n               }\\n            }\\n            k++;\\n        }\\n        return max;\\n    }\\n}"
                    },
                    {
                        "username": "user4279js",
                        "content": "You can do this problem in linear time, so this probably isn\\'t accepted for larger inputs "
                    },
                    {
                        "username": "ojjasvi",
                        "content": "This is a tricky question . If you are solving this question using two loop one for smallest number and second loop for maximum profit ..... then think again \\uD83D\\uDE00"
                    },
                    {
                        "username": "aceton41k",
                        "content": "Time Limit Exceeded on test case 200/212 in Java"
                    },
                    {
                        "username": "user4279js",
                        "content": "Please post a snippet or what your expected time complexity is... For this problem, only linear is accepted I think"
                    },
                    {
                        "username": "poornachandra07",
                        "content": "Can someone help me in below C# solution. It fails at 198th testcase\\n\\n`public int MaxProfit(int[] prices) {\\n        if(prices.Length<2) \\nreturn 0;\\n        var bestPrice = prices\\n        .SelectMany((price, index) => prices\\n            .Skip(index + 1)\\n            .Select(nxtPrice => price - nxtPrice))\\n        .Min();\\n\\n\\n        if(bestPrice<0){\\n            return -(bestPrice);\\n        }\\n        return 0;\\n    }`"
                    },
                    {
                        "username": "user4279js",
                        "content": "This approach doesn\\'t work .. firstly  you can\\'t just flip the sign of bestPrice, if it\\'s negative it means you bought for more than you sold so the sign has a significance to the problem.\\nSecondly  I think your code is doing O(n^2) work with the two selects correct me if I\\'m wrong."
                    },
                    {
                        "username": "chandancodes_28",
                        "content": "guys , i code in c and i have 200/212 testcases passed . i applied double pointer and then returned the maximum profit i could . someone plz help"
                    },
                    {
                        "username": "LeetCode_Problem",
                        "content": "prices = [2,4,1] why the expected value is 2. Can anyone please tell me"
                    },
                    {
                        "username": "SwaggerKid",
                        "content": "u bought on the 1st day, and sold on the second. So your profit is 2 dollars. "
                    },
                    {
                        "username": "vamshidharreddy3397",
                        "content": "Should we consider 0 while buying stock or avoid it?\\n\\nthere are 2 test cases which are conflicting\\n1) [3,2,6,5,0,3] in this case expected output is 4 which is (6-2)\\n2) [2,1,2,1,0,1,2] in this case expected output is 2 which can be (2 - 0)\\n\\nThanks in advance"
                    },
                    {
                        "username": "makleo2002",
                        "content": "211 case is incorrect"
                    },
                    {
                        "username": "nikitafeoktistov",
                        "content": "The solutions all mention a greedy approach, where you keep track of the minimum cost and update it whenever there is a smaller value. Why doesn\\'t this fail any testcases? I\\'d imagine something along the lines of [6,12,1,3] would cause those algorithms to fail, no?"
                    },
                    {
                        "username": "bparanj",
                        "content": "This approach doesn\\'t fail any test cases due to the nature of the problem. The problem asks for the maximum profit we can make from a single buy and sell operation. The best time to buy is always the lowest possible price up to the current point in time, which is why we keep track of the minimum cost.\\n\\nFor your example, [6,12,1,3], this approach correctly identifies that the best time to buy is when the cost is 1. However, it also keeps track of the maximum profit possible up to the current point in time, which includes profits made before we encounter this new minimum.\\n\\nLet\\'s break down this example:\\n\\n- Initially, the minimum cost is 6, and the maximum profit is 0.\\n- Next, we see 12. We update our maximum profit to be max(0, 12 - 6) = 6. Minimum cost remains at 6.\\n- Then, we see 1. Now, we update our minimum cost to be 1 since 1 < 6. Our maximum profit is still 6 from before.\\n- Finally, we see 3. The maximum profit becomes max(6, 3 - 1) = 6.\\n\\nSo, the algorithm correctly returns 6 as the maximum profit. It\\'s important to note that the algorithm doesn\\'t just remember the latest minimum cost, but also the maximum profit it can make with previous minimum costs. So, the greedy approach works perfectly for this problem."
                    },
                    {
                        "username": "johngjackson0",
                        "content": "You\\'re not using the minimum of the data set. Whichever element you are on, you need to know the minimum BUY from all other elements in the previous elements only. Calculate the profit and max profit at that element. This ensures you\\'re doing buy and sell in proper order for the answer. "
                    },
                    {
                        "username": "abhishekspawar2003",
                        "content": "[2,11,1,4,7]\\nHow to let code know that there is good option lies at start."
                    }
                ]
            },
            {
                "id": 1995165,
                "content": [
                    {
                        "username": "chakravarthybatna46234",
                        "content": "why this below code shows Time Limit Exceeded when i submit my answer,\\nis this code wrong??????? please tell anyone\\n\\nclass Solution {\\n    public int maxProfit(int[] prices) {\\n        int max=0,profit=0,k=2;\\n        for(int i=prices.length-1;i>=0;i--)\\n        {\\n            for(int j=prices.length-k;j>=0;j--)\\n            {\\n               profit=prices[i]-prices[j];\\n               if(profit>0&&profit>max)\\n               {\\n                   max=profit;\\n               }\\n            }\\n            k++;\\n        }\\n        return max;\\n    }\\n}"
                    },
                    {
                        "username": "user4279js",
                        "content": "You can do this problem in linear time, so this probably isn\\'t accepted for larger inputs "
                    },
                    {
                        "username": "ojjasvi",
                        "content": "This is a tricky question . If you are solving this question using two loop one for smallest number and second loop for maximum profit ..... then think again \\uD83D\\uDE00"
                    },
                    {
                        "username": "aceton41k",
                        "content": "Time Limit Exceeded on test case 200/212 in Java"
                    },
                    {
                        "username": "user4279js",
                        "content": "Please post a snippet or what your expected time complexity is... For this problem, only linear is accepted I think"
                    },
                    {
                        "username": "poornachandra07",
                        "content": "Can someone help me in below C# solution. It fails at 198th testcase\\n\\n`public int MaxProfit(int[] prices) {\\n        if(prices.Length<2) \\nreturn 0;\\n        var bestPrice = prices\\n        .SelectMany((price, index) => prices\\n            .Skip(index + 1)\\n            .Select(nxtPrice => price - nxtPrice))\\n        .Min();\\n\\n\\n        if(bestPrice<0){\\n            return -(bestPrice);\\n        }\\n        return 0;\\n    }`"
                    },
                    {
                        "username": "user4279js",
                        "content": "This approach doesn\\'t work .. firstly  you can\\'t just flip the sign of bestPrice, if it\\'s negative it means you bought for more than you sold so the sign has a significance to the problem.\\nSecondly  I think your code is doing O(n^2) work with the two selects correct me if I\\'m wrong."
                    },
                    {
                        "username": "chandancodes_28",
                        "content": "guys , i code in c and i have 200/212 testcases passed . i applied double pointer and then returned the maximum profit i could . someone plz help"
                    },
                    {
                        "username": "LeetCode_Problem",
                        "content": "prices = [2,4,1] why the expected value is 2. Can anyone please tell me"
                    },
                    {
                        "username": "SwaggerKid",
                        "content": "u bought on the 1st day, and sold on the second. So your profit is 2 dollars. "
                    },
                    {
                        "username": "vamshidharreddy3397",
                        "content": "Should we consider 0 while buying stock or avoid it?\\n\\nthere are 2 test cases which are conflicting\\n1) [3,2,6,5,0,3] in this case expected output is 4 which is (6-2)\\n2) [2,1,2,1,0,1,2] in this case expected output is 2 which can be (2 - 0)\\n\\nThanks in advance"
                    },
                    {
                        "username": "makleo2002",
                        "content": "211 case is incorrect"
                    },
                    {
                        "username": "nikitafeoktistov",
                        "content": "The solutions all mention a greedy approach, where you keep track of the minimum cost and update it whenever there is a smaller value. Why doesn\\'t this fail any testcases? I\\'d imagine something along the lines of [6,12,1,3] would cause those algorithms to fail, no?"
                    },
                    {
                        "username": "bparanj",
                        "content": "This approach doesn\\'t fail any test cases due to the nature of the problem. The problem asks for the maximum profit we can make from a single buy and sell operation. The best time to buy is always the lowest possible price up to the current point in time, which is why we keep track of the minimum cost.\\n\\nFor your example, [6,12,1,3], this approach correctly identifies that the best time to buy is when the cost is 1. However, it also keeps track of the maximum profit possible up to the current point in time, which includes profits made before we encounter this new minimum.\\n\\nLet\\'s break down this example:\\n\\n- Initially, the minimum cost is 6, and the maximum profit is 0.\\n- Next, we see 12. We update our maximum profit to be max(0, 12 - 6) = 6. Minimum cost remains at 6.\\n- Then, we see 1. Now, we update our minimum cost to be 1 since 1 < 6. Our maximum profit is still 6 from before.\\n- Finally, we see 3. The maximum profit becomes max(6, 3 - 1) = 6.\\n\\nSo, the algorithm correctly returns 6 as the maximum profit. It\\'s important to note that the algorithm doesn\\'t just remember the latest minimum cost, but also the maximum profit it can make with previous minimum costs. So, the greedy approach works perfectly for this problem."
                    },
                    {
                        "username": "johngjackson0",
                        "content": "You\\'re not using the minimum of the data set. Whichever element you are on, you need to know the minimum BUY from all other elements in the previous elements only. Calculate the profit and max profit at that element. This ensures you\\'re doing buy and sell in proper order for the answer. "
                    },
                    {
                        "username": "abhishekspawar2003",
                        "content": "[2,11,1,4,7]\\nHow to let code know that there is good option lies at start."
                    }
                ]
            },
            {
                "id": 1990636,
                "content": [
                    {
                        "username": "chakravarthybatna46234",
                        "content": "why this below code shows Time Limit Exceeded when i submit my answer,\\nis this code wrong??????? please tell anyone\\n\\nclass Solution {\\n    public int maxProfit(int[] prices) {\\n        int max=0,profit=0,k=2;\\n        for(int i=prices.length-1;i>=0;i--)\\n        {\\n            for(int j=prices.length-k;j>=0;j--)\\n            {\\n               profit=prices[i]-prices[j];\\n               if(profit>0&&profit>max)\\n               {\\n                   max=profit;\\n               }\\n            }\\n            k++;\\n        }\\n        return max;\\n    }\\n}"
                    },
                    {
                        "username": "user4279js",
                        "content": "You can do this problem in linear time, so this probably isn\\'t accepted for larger inputs "
                    },
                    {
                        "username": "ojjasvi",
                        "content": "This is a tricky question . If you are solving this question using two loop one for smallest number and second loop for maximum profit ..... then think again \\uD83D\\uDE00"
                    },
                    {
                        "username": "aceton41k",
                        "content": "Time Limit Exceeded on test case 200/212 in Java"
                    },
                    {
                        "username": "user4279js",
                        "content": "Please post a snippet or what your expected time complexity is... For this problem, only linear is accepted I think"
                    },
                    {
                        "username": "poornachandra07",
                        "content": "Can someone help me in below C# solution. It fails at 198th testcase\\n\\n`public int MaxProfit(int[] prices) {\\n        if(prices.Length<2) \\nreturn 0;\\n        var bestPrice = prices\\n        .SelectMany((price, index) => prices\\n            .Skip(index + 1)\\n            .Select(nxtPrice => price - nxtPrice))\\n        .Min();\\n\\n\\n        if(bestPrice<0){\\n            return -(bestPrice);\\n        }\\n        return 0;\\n    }`"
                    },
                    {
                        "username": "user4279js",
                        "content": "This approach doesn\\'t work .. firstly  you can\\'t just flip the sign of bestPrice, if it\\'s negative it means you bought for more than you sold so the sign has a significance to the problem.\\nSecondly  I think your code is doing O(n^2) work with the two selects correct me if I\\'m wrong."
                    },
                    {
                        "username": "chandancodes_28",
                        "content": "guys , i code in c and i have 200/212 testcases passed . i applied double pointer and then returned the maximum profit i could . someone plz help"
                    },
                    {
                        "username": "LeetCode_Problem",
                        "content": "prices = [2,4,1] why the expected value is 2. Can anyone please tell me"
                    },
                    {
                        "username": "SwaggerKid",
                        "content": "u bought on the 1st day, and sold on the second. So your profit is 2 dollars. "
                    },
                    {
                        "username": "vamshidharreddy3397",
                        "content": "Should we consider 0 while buying stock or avoid it?\\n\\nthere are 2 test cases which are conflicting\\n1) [3,2,6,5,0,3] in this case expected output is 4 which is (6-2)\\n2) [2,1,2,1,0,1,2] in this case expected output is 2 which can be (2 - 0)\\n\\nThanks in advance"
                    },
                    {
                        "username": "makleo2002",
                        "content": "211 case is incorrect"
                    },
                    {
                        "username": "nikitafeoktistov",
                        "content": "The solutions all mention a greedy approach, where you keep track of the minimum cost and update it whenever there is a smaller value. Why doesn\\'t this fail any testcases? I\\'d imagine something along the lines of [6,12,1,3] would cause those algorithms to fail, no?"
                    },
                    {
                        "username": "bparanj",
                        "content": "This approach doesn\\'t fail any test cases due to the nature of the problem. The problem asks for the maximum profit we can make from a single buy and sell operation. The best time to buy is always the lowest possible price up to the current point in time, which is why we keep track of the minimum cost.\\n\\nFor your example, [6,12,1,3], this approach correctly identifies that the best time to buy is when the cost is 1. However, it also keeps track of the maximum profit possible up to the current point in time, which includes profits made before we encounter this new minimum.\\n\\nLet\\'s break down this example:\\n\\n- Initially, the minimum cost is 6, and the maximum profit is 0.\\n- Next, we see 12. We update our maximum profit to be max(0, 12 - 6) = 6. Minimum cost remains at 6.\\n- Then, we see 1. Now, we update our minimum cost to be 1 since 1 < 6. Our maximum profit is still 6 from before.\\n- Finally, we see 3. The maximum profit becomes max(6, 3 - 1) = 6.\\n\\nSo, the algorithm correctly returns 6 as the maximum profit. It\\'s important to note that the algorithm doesn\\'t just remember the latest minimum cost, but also the maximum profit it can make with previous minimum costs. So, the greedy approach works perfectly for this problem."
                    },
                    {
                        "username": "johngjackson0",
                        "content": "You\\'re not using the minimum of the data set. Whichever element you are on, you need to know the minimum BUY from all other elements in the previous elements only. Calculate the profit and max profit at that element. This ensures you\\'re doing buy and sell in proper order for the answer. "
                    },
                    {
                        "username": "abhishekspawar2003",
                        "content": "[2,11,1,4,7]\\nHow to let code know that there is good option lies at start."
                    }
                ]
            },
            {
                "id": 1988341,
                "content": [
                    {
                        "username": "chakravarthybatna46234",
                        "content": "why this below code shows Time Limit Exceeded when i submit my answer,\\nis this code wrong??????? please tell anyone\\n\\nclass Solution {\\n    public int maxProfit(int[] prices) {\\n        int max=0,profit=0,k=2;\\n        for(int i=prices.length-1;i>=0;i--)\\n        {\\n            for(int j=prices.length-k;j>=0;j--)\\n            {\\n               profit=prices[i]-prices[j];\\n               if(profit>0&&profit>max)\\n               {\\n                   max=profit;\\n               }\\n            }\\n            k++;\\n        }\\n        return max;\\n    }\\n}"
                    },
                    {
                        "username": "user4279js",
                        "content": "You can do this problem in linear time, so this probably isn\\'t accepted for larger inputs "
                    },
                    {
                        "username": "ojjasvi",
                        "content": "This is a tricky question . If you are solving this question using two loop one for smallest number and second loop for maximum profit ..... then think again \\uD83D\\uDE00"
                    },
                    {
                        "username": "aceton41k",
                        "content": "Time Limit Exceeded on test case 200/212 in Java"
                    },
                    {
                        "username": "user4279js",
                        "content": "Please post a snippet or what your expected time complexity is... For this problem, only linear is accepted I think"
                    },
                    {
                        "username": "poornachandra07",
                        "content": "Can someone help me in below C# solution. It fails at 198th testcase\\n\\n`public int MaxProfit(int[] prices) {\\n        if(prices.Length<2) \\nreturn 0;\\n        var bestPrice = prices\\n        .SelectMany((price, index) => prices\\n            .Skip(index + 1)\\n            .Select(nxtPrice => price - nxtPrice))\\n        .Min();\\n\\n\\n        if(bestPrice<0){\\n            return -(bestPrice);\\n        }\\n        return 0;\\n    }`"
                    },
                    {
                        "username": "user4279js",
                        "content": "This approach doesn\\'t work .. firstly  you can\\'t just flip the sign of bestPrice, if it\\'s negative it means you bought for more than you sold so the sign has a significance to the problem.\\nSecondly  I think your code is doing O(n^2) work with the two selects correct me if I\\'m wrong."
                    },
                    {
                        "username": "chandancodes_28",
                        "content": "guys , i code in c and i have 200/212 testcases passed . i applied double pointer and then returned the maximum profit i could . someone plz help"
                    },
                    {
                        "username": "LeetCode_Problem",
                        "content": "prices = [2,4,1] why the expected value is 2. Can anyone please tell me"
                    },
                    {
                        "username": "SwaggerKid",
                        "content": "u bought on the 1st day, and sold on the second. So your profit is 2 dollars. "
                    },
                    {
                        "username": "vamshidharreddy3397",
                        "content": "Should we consider 0 while buying stock or avoid it?\\n\\nthere are 2 test cases which are conflicting\\n1) [3,2,6,5,0,3] in this case expected output is 4 which is (6-2)\\n2) [2,1,2,1,0,1,2] in this case expected output is 2 which can be (2 - 0)\\n\\nThanks in advance"
                    },
                    {
                        "username": "makleo2002",
                        "content": "211 case is incorrect"
                    },
                    {
                        "username": "nikitafeoktistov",
                        "content": "The solutions all mention a greedy approach, where you keep track of the minimum cost and update it whenever there is a smaller value. Why doesn\\'t this fail any testcases? I\\'d imagine something along the lines of [6,12,1,3] would cause those algorithms to fail, no?"
                    },
                    {
                        "username": "bparanj",
                        "content": "This approach doesn\\'t fail any test cases due to the nature of the problem. The problem asks for the maximum profit we can make from a single buy and sell operation. The best time to buy is always the lowest possible price up to the current point in time, which is why we keep track of the minimum cost.\\n\\nFor your example, [6,12,1,3], this approach correctly identifies that the best time to buy is when the cost is 1. However, it also keeps track of the maximum profit possible up to the current point in time, which includes profits made before we encounter this new minimum.\\n\\nLet\\'s break down this example:\\n\\n- Initially, the minimum cost is 6, and the maximum profit is 0.\\n- Next, we see 12. We update our maximum profit to be max(0, 12 - 6) = 6. Minimum cost remains at 6.\\n- Then, we see 1. Now, we update our minimum cost to be 1 since 1 < 6. Our maximum profit is still 6 from before.\\n- Finally, we see 3. The maximum profit becomes max(6, 3 - 1) = 6.\\n\\nSo, the algorithm correctly returns 6 as the maximum profit. It\\'s important to note that the algorithm doesn\\'t just remember the latest minimum cost, but also the maximum profit it can make with previous minimum costs. So, the greedy approach works perfectly for this problem."
                    },
                    {
                        "username": "johngjackson0",
                        "content": "You\\'re not using the minimum of the data set. Whichever element you are on, you need to know the minimum BUY from all other elements in the previous elements only. Calculate the profit and max profit at that element. This ensures you\\'re doing buy and sell in proper order for the answer. "
                    },
                    {
                        "username": "abhishekspawar2003",
                        "content": "[2,11,1,4,7]\\nHow to let code know that there is good option lies at start."
                    }
                ]
            },
            {
                "id": 1987856,
                "content": [
                    {
                        "username": "chakravarthybatna46234",
                        "content": "why this below code shows Time Limit Exceeded when i submit my answer,\\nis this code wrong??????? please tell anyone\\n\\nclass Solution {\\n    public int maxProfit(int[] prices) {\\n        int max=0,profit=0,k=2;\\n        for(int i=prices.length-1;i>=0;i--)\\n        {\\n            for(int j=prices.length-k;j>=0;j--)\\n            {\\n               profit=prices[i]-prices[j];\\n               if(profit>0&&profit>max)\\n               {\\n                   max=profit;\\n               }\\n            }\\n            k++;\\n        }\\n        return max;\\n    }\\n}"
                    },
                    {
                        "username": "user4279js",
                        "content": "You can do this problem in linear time, so this probably isn\\'t accepted for larger inputs "
                    },
                    {
                        "username": "ojjasvi",
                        "content": "This is a tricky question . If you are solving this question using two loop one for smallest number and second loop for maximum profit ..... then think again \\uD83D\\uDE00"
                    },
                    {
                        "username": "aceton41k",
                        "content": "Time Limit Exceeded on test case 200/212 in Java"
                    },
                    {
                        "username": "user4279js",
                        "content": "Please post a snippet or what your expected time complexity is... For this problem, only linear is accepted I think"
                    },
                    {
                        "username": "poornachandra07",
                        "content": "Can someone help me in below C# solution. It fails at 198th testcase\\n\\n`public int MaxProfit(int[] prices) {\\n        if(prices.Length<2) \\nreturn 0;\\n        var bestPrice = prices\\n        .SelectMany((price, index) => prices\\n            .Skip(index + 1)\\n            .Select(nxtPrice => price - nxtPrice))\\n        .Min();\\n\\n\\n        if(bestPrice<0){\\n            return -(bestPrice);\\n        }\\n        return 0;\\n    }`"
                    },
                    {
                        "username": "user4279js",
                        "content": "This approach doesn\\'t work .. firstly  you can\\'t just flip the sign of bestPrice, if it\\'s negative it means you bought for more than you sold so the sign has a significance to the problem.\\nSecondly  I think your code is doing O(n^2) work with the two selects correct me if I\\'m wrong."
                    },
                    {
                        "username": "chandancodes_28",
                        "content": "guys , i code in c and i have 200/212 testcases passed . i applied double pointer and then returned the maximum profit i could . someone plz help"
                    },
                    {
                        "username": "LeetCode_Problem",
                        "content": "prices = [2,4,1] why the expected value is 2. Can anyone please tell me"
                    },
                    {
                        "username": "SwaggerKid",
                        "content": "u bought on the 1st day, and sold on the second. So your profit is 2 dollars. "
                    },
                    {
                        "username": "vamshidharreddy3397",
                        "content": "Should we consider 0 while buying stock or avoid it?\\n\\nthere are 2 test cases which are conflicting\\n1) [3,2,6,5,0,3] in this case expected output is 4 which is (6-2)\\n2) [2,1,2,1,0,1,2] in this case expected output is 2 which can be (2 - 0)\\n\\nThanks in advance"
                    },
                    {
                        "username": "makleo2002",
                        "content": "211 case is incorrect"
                    },
                    {
                        "username": "nikitafeoktistov",
                        "content": "The solutions all mention a greedy approach, where you keep track of the minimum cost and update it whenever there is a smaller value. Why doesn\\'t this fail any testcases? I\\'d imagine something along the lines of [6,12,1,3] would cause those algorithms to fail, no?"
                    },
                    {
                        "username": "bparanj",
                        "content": "This approach doesn\\'t fail any test cases due to the nature of the problem. The problem asks for the maximum profit we can make from a single buy and sell operation. The best time to buy is always the lowest possible price up to the current point in time, which is why we keep track of the minimum cost.\\n\\nFor your example, [6,12,1,3], this approach correctly identifies that the best time to buy is when the cost is 1. However, it also keeps track of the maximum profit possible up to the current point in time, which includes profits made before we encounter this new minimum.\\n\\nLet\\'s break down this example:\\n\\n- Initially, the minimum cost is 6, and the maximum profit is 0.\\n- Next, we see 12. We update our maximum profit to be max(0, 12 - 6) = 6. Minimum cost remains at 6.\\n- Then, we see 1. Now, we update our minimum cost to be 1 since 1 < 6. Our maximum profit is still 6 from before.\\n- Finally, we see 3. The maximum profit becomes max(6, 3 - 1) = 6.\\n\\nSo, the algorithm correctly returns 6 as the maximum profit. It\\'s important to note that the algorithm doesn\\'t just remember the latest minimum cost, but also the maximum profit it can make with previous minimum costs. So, the greedy approach works perfectly for this problem."
                    },
                    {
                        "username": "johngjackson0",
                        "content": "You\\'re not using the minimum of the data set. Whichever element you are on, you need to know the minimum BUY from all other elements in the previous elements only. Calculate the profit and max profit at that element. This ensures you\\'re doing buy and sell in proper order for the answer. "
                    },
                    {
                        "username": "abhishekspawar2003",
                        "content": "[2,11,1,4,7]\\nHow to let code know that there is good option lies at start."
                    }
                ]
            },
            {
                "id": 1984254,
                "content": [
                    {
                        "username": "chakravarthybatna46234",
                        "content": "why this below code shows Time Limit Exceeded when i submit my answer,\\nis this code wrong??????? please tell anyone\\n\\nclass Solution {\\n    public int maxProfit(int[] prices) {\\n        int max=0,profit=0,k=2;\\n        for(int i=prices.length-1;i>=0;i--)\\n        {\\n            for(int j=prices.length-k;j>=0;j--)\\n            {\\n               profit=prices[i]-prices[j];\\n               if(profit>0&&profit>max)\\n               {\\n                   max=profit;\\n               }\\n            }\\n            k++;\\n        }\\n        return max;\\n    }\\n}"
                    },
                    {
                        "username": "user4279js",
                        "content": "You can do this problem in linear time, so this probably isn\\'t accepted for larger inputs "
                    },
                    {
                        "username": "ojjasvi",
                        "content": "This is a tricky question . If you are solving this question using two loop one for smallest number and second loop for maximum profit ..... then think again \\uD83D\\uDE00"
                    },
                    {
                        "username": "aceton41k",
                        "content": "Time Limit Exceeded on test case 200/212 in Java"
                    },
                    {
                        "username": "user4279js",
                        "content": "Please post a snippet or what your expected time complexity is... For this problem, only linear is accepted I think"
                    },
                    {
                        "username": "poornachandra07",
                        "content": "Can someone help me in below C# solution. It fails at 198th testcase\\n\\n`public int MaxProfit(int[] prices) {\\n        if(prices.Length<2) \\nreturn 0;\\n        var bestPrice = prices\\n        .SelectMany((price, index) => prices\\n            .Skip(index + 1)\\n            .Select(nxtPrice => price - nxtPrice))\\n        .Min();\\n\\n\\n        if(bestPrice<0){\\n            return -(bestPrice);\\n        }\\n        return 0;\\n    }`"
                    },
                    {
                        "username": "user4279js",
                        "content": "This approach doesn\\'t work .. firstly  you can\\'t just flip the sign of bestPrice, if it\\'s negative it means you bought for more than you sold so the sign has a significance to the problem.\\nSecondly  I think your code is doing O(n^2) work with the two selects correct me if I\\'m wrong."
                    },
                    {
                        "username": "chandancodes_28",
                        "content": "guys , i code in c and i have 200/212 testcases passed . i applied double pointer and then returned the maximum profit i could . someone plz help"
                    },
                    {
                        "username": "LeetCode_Problem",
                        "content": "prices = [2,4,1] why the expected value is 2. Can anyone please tell me"
                    },
                    {
                        "username": "SwaggerKid",
                        "content": "u bought on the 1st day, and sold on the second. So your profit is 2 dollars. "
                    },
                    {
                        "username": "vamshidharreddy3397",
                        "content": "Should we consider 0 while buying stock or avoid it?\\n\\nthere are 2 test cases which are conflicting\\n1) [3,2,6,5,0,3] in this case expected output is 4 which is (6-2)\\n2) [2,1,2,1,0,1,2] in this case expected output is 2 which can be (2 - 0)\\n\\nThanks in advance"
                    },
                    {
                        "username": "makleo2002",
                        "content": "211 case is incorrect"
                    },
                    {
                        "username": "nikitafeoktistov",
                        "content": "The solutions all mention a greedy approach, where you keep track of the minimum cost and update it whenever there is a smaller value. Why doesn\\'t this fail any testcases? I\\'d imagine something along the lines of [6,12,1,3] would cause those algorithms to fail, no?"
                    },
                    {
                        "username": "bparanj",
                        "content": "This approach doesn\\'t fail any test cases due to the nature of the problem. The problem asks for the maximum profit we can make from a single buy and sell operation. The best time to buy is always the lowest possible price up to the current point in time, which is why we keep track of the minimum cost.\\n\\nFor your example, [6,12,1,3], this approach correctly identifies that the best time to buy is when the cost is 1. However, it also keeps track of the maximum profit possible up to the current point in time, which includes profits made before we encounter this new minimum.\\n\\nLet\\'s break down this example:\\n\\n- Initially, the minimum cost is 6, and the maximum profit is 0.\\n- Next, we see 12. We update our maximum profit to be max(0, 12 - 6) = 6. Minimum cost remains at 6.\\n- Then, we see 1. Now, we update our minimum cost to be 1 since 1 < 6. Our maximum profit is still 6 from before.\\n- Finally, we see 3. The maximum profit becomes max(6, 3 - 1) = 6.\\n\\nSo, the algorithm correctly returns 6 as the maximum profit. It\\'s important to note that the algorithm doesn\\'t just remember the latest minimum cost, but also the maximum profit it can make with previous minimum costs. So, the greedy approach works perfectly for this problem."
                    },
                    {
                        "username": "johngjackson0",
                        "content": "You\\'re not using the minimum of the data set. Whichever element you are on, you need to know the minimum BUY from all other elements in the previous elements only. Calculate the profit and max profit at that element. This ensures you\\'re doing buy and sell in proper order for the answer. "
                    },
                    {
                        "username": "abhishekspawar2003",
                        "content": "[2,11,1,4,7]\\nHow to let code know that there is good option lies at start."
                    }
                ]
            },
            {
                "id": 1984019,
                "content": [
                    {
                        "username": "Shaswat_Pandey",
                        "content": "As the time constraint is given 10^6 , i was thinking that in these type of cases, we can move upto the time complexity of O(n logn). Correct me if i\\'m wrong?\\n\\ncan we solve the same problem in O(n logn)?\\nif yes then kindly suggest the idea.\\nThanks!"
                    },
                    {
                        "username": "woeth",
                        "content": "Most of the solutions are incorrect, as the list represents days and the data represents prices. following logic prices[i] means price on day i. so ->\\n[7,1,5,3,6,4,9,4]\\nbuy in day 2 and sell in day 7 your profit is 8\\nbut the expected output shows 8 as the best day\\n\\nthis solution shows the correct outputs according to the problem description\\n `class Solution:\\n    def maxProfit(self, prices: List[int]) -> int:\\n        profit = 0\\n        day = 0\\n        for i in range(len(prices) - 1):\\n            for j in range(i + 1, len(prices)):\\n                if prices[j] - prices[i] > profit:\\n                    day = j + 1\\n                    profit = prices[j] - prices[i]\\n        return day`"
                    },
                    {
                        "username": "sanskarv120503",
                        "content": "i am not understant this qution "
                    },
                    {
                        "username": "Shaik_Aman_Sayer",
                        "content": "every time i come to solve this problem i cant optimize it "
                    },
                    {
                        "username": "pawarsach_n",
                        "content": "where did i went wrong?\\n\\n `class Solution {\\n    public static class Stock {\\n        int day;\\n        int price;\\n        \\n        Stock(int day, int price) {\\n            this.day = day;\\n            this.price = price;\\n        }\\n    }\\n    \\n    public int maxProfit(int[] prices) {\\n        Stock sell = new Stock(0, 0);\\n        Stock buy = new Stock(0, Integer.MAX_VALUE);\\n        \\n        for (int i = 0; i < prices.length; i++) {\\n            if (prices[i] <= buy.price && sell.day<=buy.day) {\\n                System.out.println(\" stock bought at day \"+(i+1)+\" at price \"+prices[i]);\\n                buy.price = prices[i];\\n                buy.day = i + 1;\\n            }\\n            if (prices[i] >= sell.price && i + 1 > buy.day) {\\n                System.out.println(\" stock selled at day \"+(i+1)+\" at price \"+prices[i]);\\n                sell.price = prices[i];\\n                sell.day = i + 1;\\n            }\\n        }\\n        \\n        int profit = sell.price - buy.price;\\n        return profit > 0 ? profit : 0;\\n    }\\n}\\n`\\n\\n[2,1,2,1,0,1,2]\\n\\nUse Testcase\\nStdout\\n stock bought at day 1 at price 2\\n stock bought at day 2 at price 1\\n stock selled at day 3 at price 2\\n stock selled at day 7 at price 2\\nOutput\\n1\\nExpected\\n2"
                    },
                    {
                        "username": "Radhika_20",
                        "content": "Maintain the minimum price seen so far and update the maximum profit whenever the current profit is greater than maximum profit (curr profit = price[i]-min price)\\nHope it helps !"
                    },
                    {
                        "username": "Meghajit",
                        "content": "We can solve it by memoizing the maximas at each index as seen traversing from the right. \\n\\nSince we can only sell after we buy( that\\'s how stocks work :) ), the problem is simply that: Given I buy a stock on day T, can I sell it at a cheaper price at any day after day T and if so how much is the profit ?\\n\\n\\n\\n"
                    },
                    {
                        "username": "rishith_11203",
                        "content": "[1,4,2]\\noutput :2\\nexpected:3\\nit this worng:\\n1-4 =3\\nwhich is 2nd elemnet can u help me"
                    },
                    {
                        "username": "winstonallo",
                        "content": "you buy at day 0, sell at day 1, 4-1=3"
                    },
                    {
                        "username": "Mkaif_Agb",
                        "content": "prices = [2,4,1] \\nThis should have the expected profit of 0 as the number 1 is the lowest but testcase 154 wants the expected output to be 2. I am unable to understand."
                    },
                    {
                        "username": "winstonallo",
                        "content": "[@bjraval](/bjraval) No, profit is selling price - buying price, in this case you would do 1-4 which is -3."
                    },
                    {
                        "username": "bjraval",
                        "content": "[@winstonallo](/winstonallo) what you are saying doesn\\'t make sense. For the example [2,4,1], the correct solution is 3 i.e. buy on Day2 and sell on day 3 so 4-1 = 3"
                    },
                    {
                        "username": "winstonallo",
                        "content": "You just need to find the biggest difference between one integer and another that comes after in the array.\\nYou would return 0 if for example the array is [5, 4, 3].\\nIn this case, max(s[j > i] - s[i]) = 4 - 2 = 2"
                    },
                    {
                        "username": "soslow",
                        "content": "shorting is common practice.."
                    }
                ]
            },
            {
                "id": 1983668,
                "content": [
                    {
                        "username": "Shaswat_Pandey",
                        "content": "As the time constraint is given 10^6 , i was thinking that in these type of cases, we can move upto the time complexity of O(n logn). Correct me if i\\'m wrong?\\n\\ncan we solve the same problem in O(n logn)?\\nif yes then kindly suggest the idea.\\nThanks!"
                    },
                    {
                        "username": "woeth",
                        "content": "Most of the solutions are incorrect, as the list represents days and the data represents prices. following logic prices[i] means price on day i. so ->\\n[7,1,5,3,6,4,9,4]\\nbuy in day 2 and sell in day 7 your profit is 8\\nbut the expected output shows 8 as the best day\\n\\nthis solution shows the correct outputs according to the problem description\\n `class Solution:\\n    def maxProfit(self, prices: List[int]) -> int:\\n        profit = 0\\n        day = 0\\n        for i in range(len(prices) - 1):\\n            for j in range(i + 1, len(prices)):\\n                if prices[j] - prices[i] > profit:\\n                    day = j + 1\\n                    profit = prices[j] - prices[i]\\n        return day`"
                    },
                    {
                        "username": "sanskarv120503",
                        "content": "i am not understant this qution "
                    },
                    {
                        "username": "Shaik_Aman_Sayer",
                        "content": "every time i come to solve this problem i cant optimize it "
                    },
                    {
                        "username": "pawarsach_n",
                        "content": "where did i went wrong?\\n\\n `class Solution {\\n    public static class Stock {\\n        int day;\\n        int price;\\n        \\n        Stock(int day, int price) {\\n            this.day = day;\\n            this.price = price;\\n        }\\n    }\\n    \\n    public int maxProfit(int[] prices) {\\n        Stock sell = new Stock(0, 0);\\n        Stock buy = new Stock(0, Integer.MAX_VALUE);\\n        \\n        for (int i = 0; i < prices.length; i++) {\\n            if (prices[i] <= buy.price && sell.day<=buy.day) {\\n                System.out.println(\" stock bought at day \"+(i+1)+\" at price \"+prices[i]);\\n                buy.price = prices[i];\\n                buy.day = i + 1;\\n            }\\n            if (prices[i] >= sell.price && i + 1 > buy.day) {\\n                System.out.println(\" stock selled at day \"+(i+1)+\" at price \"+prices[i]);\\n                sell.price = prices[i];\\n                sell.day = i + 1;\\n            }\\n        }\\n        \\n        int profit = sell.price - buy.price;\\n        return profit > 0 ? profit : 0;\\n    }\\n}\\n`\\n\\n[2,1,2,1,0,1,2]\\n\\nUse Testcase\\nStdout\\n stock bought at day 1 at price 2\\n stock bought at day 2 at price 1\\n stock selled at day 3 at price 2\\n stock selled at day 7 at price 2\\nOutput\\n1\\nExpected\\n2"
                    },
                    {
                        "username": "Radhika_20",
                        "content": "Maintain the minimum price seen so far and update the maximum profit whenever the current profit is greater than maximum profit (curr profit = price[i]-min price)\\nHope it helps !"
                    },
                    {
                        "username": "Meghajit",
                        "content": "We can solve it by memoizing the maximas at each index as seen traversing from the right. \\n\\nSince we can only sell after we buy( that\\'s how stocks work :) ), the problem is simply that: Given I buy a stock on day T, can I sell it at a cheaper price at any day after day T and if so how much is the profit ?\\n\\n\\n\\n"
                    },
                    {
                        "username": "rishith_11203",
                        "content": "[1,4,2]\\noutput :2\\nexpected:3\\nit this worng:\\n1-4 =3\\nwhich is 2nd elemnet can u help me"
                    },
                    {
                        "username": "winstonallo",
                        "content": "you buy at day 0, sell at day 1, 4-1=3"
                    },
                    {
                        "username": "Mkaif_Agb",
                        "content": "prices = [2,4,1] \\nThis should have the expected profit of 0 as the number 1 is the lowest but testcase 154 wants the expected output to be 2. I am unable to understand."
                    },
                    {
                        "username": "winstonallo",
                        "content": "[@bjraval](/bjraval) No, profit is selling price - buying price, in this case you would do 1-4 which is -3."
                    },
                    {
                        "username": "bjraval",
                        "content": "[@winstonallo](/winstonallo) what you are saying doesn\\'t make sense. For the example [2,4,1], the correct solution is 3 i.e. buy on Day2 and sell on day 3 so 4-1 = 3"
                    },
                    {
                        "username": "winstonallo",
                        "content": "You just need to find the biggest difference between one integer and another that comes after in the array.\\nYou would return 0 if for example the array is [5, 4, 3].\\nIn this case, max(s[j > i] - s[i]) = 4 - 2 = 2"
                    },
                    {
                        "username": "soslow",
                        "content": "shorting is common practice.."
                    }
                ]
            },
            {
                "id": 1976956,
                "content": [
                    {
                        "username": "Shaswat_Pandey",
                        "content": "As the time constraint is given 10^6 , i was thinking that in these type of cases, we can move upto the time complexity of O(n logn). Correct me if i\\'m wrong?\\n\\ncan we solve the same problem in O(n logn)?\\nif yes then kindly suggest the idea.\\nThanks!"
                    },
                    {
                        "username": "woeth",
                        "content": "Most of the solutions are incorrect, as the list represents days and the data represents prices. following logic prices[i] means price on day i. so ->\\n[7,1,5,3,6,4,9,4]\\nbuy in day 2 and sell in day 7 your profit is 8\\nbut the expected output shows 8 as the best day\\n\\nthis solution shows the correct outputs according to the problem description\\n `class Solution:\\n    def maxProfit(self, prices: List[int]) -> int:\\n        profit = 0\\n        day = 0\\n        for i in range(len(prices) - 1):\\n            for j in range(i + 1, len(prices)):\\n                if prices[j] - prices[i] > profit:\\n                    day = j + 1\\n                    profit = prices[j] - prices[i]\\n        return day`"
                    },
                    {
                        "username": "sanskarv120503",
                        "content": "i am not understant this qution "
                    },
                    {
                        "username": "Shaik_Aman_Sayer",
                        "content": "every time i come to solve this problem i cant optimize it "
                    },
                    {
                        "username": "pawarsach_n",
                        "content": "where did i went wrong?\\n\\n `class Solution {\\n    public static class Stock {\\n        int day;\\n        int price;\\n        \\n        Stock(int day, int price) {\\n            this.day = day;\\n            this.price = price;\\n        }\\n    }\\n    \\n    public int maxProfit(int[] prices) {\\n        Stock sell = new Stock(0, 0);\\n        Stock buy = new Stock(0, Integer.MAX_VALUE);\\n        \\n        for (int i = 0; i < prices.length; i++) {\\n            if (prices[i] <= buy.price && sell.day<=buy.day) {\\n                System.out.println(\" stock bought at day \"+(i+1)+\" at price \"+prices[i]);\\n                buy.price = prices[i];\\n                buy.day = i + 1;\\n            }\\n            if (prices[i] >= sell.price && i + 1 > buy.day) {\\n                System.out.println(\" stock selled at day \"+(i+1)+\" at price \"+prices[i]);\\n                sell.price = prices[i];\\n                sell.day = i + 1;\\n            }\\n        }\\n        \\n        int profit = sell.price - buy.price;\\n        return profit > 0 ? profit : 0;\\n    }\\n}\\n`\\n\\n[2,1,2,1,0,1,2]\\n\\nUse Testcase\\nStdout\\n stock bought at day 1 at price 2\\n stock bought at day 2 at price 1\\n stock selled at day 3 at price 2\\n stock selled at day 7 at price 2\\nOutput\\n1\\nExpected\\n2"
                    },
                    {
                        "username": "Radhika_20",
                        "content": "Maintain the minimum price seen so far and update the maximum profit whenever the current profit is greater than maximum profit (curr profit = price[i]-min price)\\nHope it helps !"
                    },
                    {
                        "username": "Meghajit",
                        "content": "We can solve it by memoizing the maximas at each index as seen traversing from the right. \\n\\nSince we can only sell after we buy( that\\'s how stocks work :) ), the problem is simply that: Given I buy a stock on day T, can I sell it at a cheaper price at any day after day T and if so how much is the profit ?\\n\\n\\n\\n"
                    },
                    {
                        "username": "rishith_11203",
                        "content": "[1,4,2]\\noutput :2\\nexpected:3\\nit this worng:\\n1-4 =3\\nwhich is 2nd elemnet can u help me"
                    },
                    {
                        "username": "winstonallo",
                        "content": "you buy at day 0, sell at day 1, 4-1=3"
                    },
                    {
                        "username": "Mkaif_Agb",
                        "content": "prices = [2,4,1] \\nThis should have the expected profit of 0 as the number 1 is the lowest but testcase 154 wants the expected output to be 2. I am unable to understand."
                    },
                    {
                        "username": "winstonallo",
                        "content": "[@bjraval](/bjraval) No, profit is selling price - buying price, in this case you would do 1-4 which is -3."
                    },
                    {
                        "username": "bjraval",
                        "content": "[@winstonallo](/winstonallo) what you are saying doesn\\'t make sense. For the example [2,4,1], the correct solution is 3 i.e. buy on Day2 and sell on day 3 so 4-1 = 3"
                    },
                    {
                        "username": "winstonallo",
                        "content": "You just need to find the biggest difference between one integer and another that comes after in the array.\\nYou would return 0 if for example the array is [5, 4, 3].\\nIn this case, max(s[j > i] - s[i]) = 4 - 2 = 2"
                    },
                    {
                        "username": "soslow",
                        "content": "shorting is common practice.."
                    }
                ]
            },
            {
                "id": 1976316,
                "content": [
                    {
                        "username": "Shaswat_Pandey",
                        "content": "As the time constraint is given 10^6 , i was thinking that in these type of cases, we can move upto the time complexity of O(n logn). Correct me if i\\'m wrong?\\n\\ncan we solve the same problem in O(n logn)?\\nif yes then kindly suggest the idea.\\nThanks!"
                    },
                    {
                        "username": "woeth",
                        "content": "Most of the solutions are incorrect, as the list represents days and the data represents prices. following logic prices[i] means price on day i. so ->\\n[7,1,5,3,6,4,9,4]\\nbuy in day 2 and sell in day 7 your profit is 8\\nbut the expected output shows 8 as the best day\\n\\nthis solution shows the correct outputs according to the problem description\\n `class Solution:\\n    def maxProfit(self, prices: List[int]) -> int:\\n        profit = 0\\n        day = 0\\n        for i in range(len(prices) - 1):\\n            for j in range(i + 1, len(prices)):\\n                if prices[j] - prices[i] > profit:\\n                    day = j + 1\\n                    profit = prices[j] - prices[i]\\n        return day`"
                    },
                    {
                        "username": "sanskarv120503",
                        "content": "i am not understant this qution "
                    },
                    {
                        "username": "Shaik_Aman_Sayer",
                        "content": "every time i come to solve this problem i cant optimize it "
                    },
                    {
                        "username": "pawarsach_n",
                        "content": "where did i went wrong?\\n\\n `class Solution {\\n    public static class Stock {\\n        int day;\\n        int price;\\n        \\n        Stock(int day, int price) {\\n            this.day = day;\\n            this.price = price;\\n        }\\n    }\\n    \\n    public int maxProfit(int[] prices) {\\n        Stock sell = new Stock(0, 0);\\n        Stock buy = new Stock(0, Integer.MAX_VALUE);\\n        \\n        for (int i = 0; i < prices.length; i++) {\\n            if (prices[i] <= buy.price && sell.day<=buy.day) {\\n                System.out.println(\" stock bought at day \"+(i+1)+\" at price \"+prices[i]);\\n                buy.price = prices[i];\\n                buy.day = i + 1;\\n            }\\n            if (prices[i] >= sell.price && i + 1 > buy.day) {\\n                System.out.println(\" stock selled at day \"+(i+1)+\" at price \"+prices[i]);\\n                sell.price = prices[i];\\n                sell.day = i + 1;\\n            }\\n        }\\n        \\n        int profit = sell.price - buy.price;\\n        return profit > 0 ? profit : 0;\\n    }\\n}\\n`\\n\\n[2,1,2,1,0,1,2]\\n\\nUse Testcase\\nStdout\\n stock bought at day 1 at price 2\\n stock bought at day 2 at price 1\\n stock selled at day 3 at price 2\\n stock selled at day 7 at price 2\\nOutput\\n1\\nExpected\\n2"
                    },
                    {
                        "username": "Radhika_20",
                        "content": "Maintain the minimum price seen so far and update the maximum profit whenever the current profit is greater than maximum profit (curr profit = price[i]-min price)\\nHope it helps !"
                    },
                    {
                        "username": "Meghajit",
                        "content": "We can solve it by memoizing the maximas at each index as seen traversing from the right. \\n\\nSince we can only sell after we buy( that\\'s how stocks work :) ), the problem is simply that: Given I buy a stock on day T, can I sell it at a cheaper price at any day after day T and if so how much is the profit ?\\n\\n\\n\\n"
                    },
                    {
                        "username": "rishith_11203",
                        "content": "[1,4,2]\\noutput :2\\nexpected:3\\nit this worng:\\n1-4 =3\\nwhich is 2nd elemnet can u help me"
                    },
                    {
                        "username": "winstonallo",
                        "content": "you buy at day 0, sell at day 1, 4-1=3"
                    },
                    {
                        "username": "Mkaif_Agb",
                        "content": "prices = [2,4,1] \\nThis should have the expected profit of 0 as the number 1 is the lowest but testcase 154 wants the expected output to be 2. I am unable to understand."
                    },
                    {
                        "username": "winstonallo",
                        "content": "[@bjraval](/bjraval) No, profit is selling price - buying price, in this case you would do 1-4 which is -3."
                    },
                    {
                        "username": "bjraval",
                        "content": "[@winstonallo](/winstonallo) what you are saying doesn\\'t make sense. For the example [2,4,1], the correct solution is 3 i.e. buy on Day2 and sell on day 3 so 4-1 = 3"
                    },
                    {
                        "username": "winstonallo",
                        "content": "You just need to find the biggest difference between one integer and another that comes after in the array.\\nYou would return 0 if for example the array is [5, 4, 3].\\nIn this case, max(s[j > i] - s[i]) = 4 - 2 = 2"
                    },
                    {
                        "username": "soslow",
                        "content": "shorting is common practice.."
                    }
                ]
            },
            {
                "id": 1975276,
                "content": [
                    {
                        "username": "Shaswat_Pandey",
                        "content": "As the time constraint is given 10^6 , i was thinking that in these type of cases, we can move upto the time complexity of O(n logn). Correct me if i\\'m wrong?\\n\\ncan we solve the same problem in O(n logn)?\\nif yes then kindly suggest the idea.\\nThanks!"
                    },
                    {
                        "username": "woeth",
                        "content": "Most of the solutions are incorrect, as the list represents days and the data represents prices. following logic prices[i] means price on day i. so ->\\n[7,1,5,3,6,4,9,4]\\nbuy in day 2 and sell in day 7 your profit is 8\\nbut the expected output shows 8 as the best day\\n\\nthis solution shows the correct outputs according to the problem description\\n `class Solution:\\n    def maxProfit(self, prices: List[int]) -> int:\\n        profit = 0\\n        day = 0\\n        for i in range(len(prices) - 1):\\n            for j in range(i + 1, len(prices)):\\n                if prices[j] - prices[i] > profit:\\n                    day = j + 1\\n                    profit = prices[j] - prices[i]\\n        return day`"
                    },
                    {
                        "username": "sanskarv120503",
                        "content": "i am not understant this qution "
                    },
                    {
                        "username": "Shaik_Aman_Sayer",
                        "content": "every time i come to solve this problem i cant optimize it "
                    },
                    {
                        "username": "pawarsach_n",
                        "content": "where did i went wrong?\\n\\n `class Solution {\\n    public static class Stock {\\n        int day;\\n        int price;\\n        \\n        Stock(int day, int price) {\\n            this.day = day;\\n            this.price = price;\\n        }\\n    }\\n    \\n    public int maxProfit(int[] prices) {\\n        Stock sell = new Stock(0, 0);\\n        Stock buy = new Stock(0, Integer.MAX_VALUE);\\n        \\n        for (int i = 0; i < prices.length; i++) {\\n            if (prices[i] <= buy.price && sell.day<=buy.day) {\\n                System.out.println(\" stock bought at day \"+(i+1)+\" at price \"+prices[i]);\\n                buy.price = prices[i];\\n                buy.day = i + 1;\\n            }\\n            if (prices[i] >= sell.price && i + 1 > buy.day) {\\n                System.out.println(\" stock selled at day \"+(i+1)+\" at price \"+prices[i]);\\n                sell.price = prices[i];\\n                sell.day = i + 1;\\n            }\\n        }\\n        \\n        int profit = sell.price - buy.price;\\n        return profit > 0 ? profit : 0;\\n    }\\n}\\n`\\n\\n[2,1,2,1,0,1,2]\\n\\nUse Testcase\\nStdout\\n stock bought at day 1 at price 2\\n stock bought at day 2 at price 1\\n stock selled at day 3 at price 2\\n stock selled at day 7 at price 2\\nOutput\\n1\\nExpected\\n2"
                    },
                    {
                        "username": "Radhika_20",
                        "content": "Maintain the minimum price seen so far and update the maximum profit whenever the current profit is greater than maximum profit (curr profit = price[i]-min price)\\nHope it helps !"
                    },
                    {
                        "username": "Meghajit",
                        "content": "We can solve it by memoizing the maximas at each index as seen traversing from the right. \\n\\nSince we can only sell after we buy( that\\'s how stocks work :) ), the problem is simply that: Given I buy a stock on day T, can I sell it at a cheaper price at any day after day T and if so how much is the profit ?\\n\\n\\n\\n"
                    },
                    {
                        "username": "rishith_11203",
                        "content": "[1,4,2]\\noutput :2\\nexpected:3\\nit this worng:\\n1-4 =3\\nwhich is 2nd elemnet can u help me"
                    },
                    {
                        "username": "winstonallo",
                        "content": "you buy at day 0, sell at day 1, 4-1=3"
                    },
                    {
                        "username": "Mkaif_Agb",
                        "content": "prices = [2,4,1] \\nThis should have the expected profit of 0 as the number 1 is the lowest but testcase 154 wants the expected output to be 2. I am unable to understand."
                    },
                    {
                        "username": "winstonallo",
                        "content": "[@bjraval](/bjraval) No, profit is selling price - buying price, in this case you would do 1-4 which is -3."
                    },
                    {
                        "username": "bjraval",
                        "content": "[@winstonallo](/winstonallo) what you are saying doesn\\'t make sense. For the example [2,4,1], the correct solution is 3 i.e. buy on Day2 and sell on day 3 so 4-1 = 3"
                    },
                    {
                        "username": "winstonallo",
                        "content": "You just need to find the biggest difference between one integer and another that comes after in the array.\\nYou would return 0 if for example the array is [5, 4, 3].\\nIn this case, max(s[j > i] - s[i]) = 4 - 2 = 2"
                    },
                    {
                        "username": "soslow",
                        "content": "shorting is common practice.."
                    }
                ]
            },
            {
                "id": 1974149,
                "content": [
                    {
                        "username": "Shaswat_Pandey",
                        "content": "As the time constraint is given 10^6 , i was thinking that in these type of cases, we can move upto the time complexity of O(n logn). Correct me if i\\'m wrong?\\n\\ncan we solve the same problem in O(n logn)?\\nif yes then kindly suggest the idea.\\nThanks!"
                    },
                    {
                        "username": "woeth",
                        "content": "Most of the solutions are incorrect, as the list represents days and the data represents prices. following logic prices[i] means price on day i. so ->\\n[7,1,5,3,6,4,9,4]\\nbuy in day 2 and sell in day 7 your profit is 8\\nbut the expected output shows 8 as the best day\\n\\nthis solution shows the correct outputs according to the problem description\\n `class Solution:\\n    def maxProfit(self, prices: List[int]) -> int:\\n        profit = 0\\n        day = 0\\n        for i in range(len(prices) - 1):\\n            for j in range(i + 1, len(prices)):\\n                if prices[j] - prices[i] > profit:\\n                    day = j + 1\\n                    profit = prices[j] - prices[i]\\n        return day`"
                    },
                    {
                        "username": "sanskarv120503",
                        "content": "i am not understant this qution "
                    },
                    {
                        "username": "Shaik_Aman_Sayer",
                        "content": "every time i come to solve this problem i cant optimize it "
                    },
                    {
                        "username": "pawarsach_n",
                        "content": "where did i went wrong?\\n\\n `class Solution {\\n    public static class Stock {\\n        int day;\\n        int price;\\n        \\n        Stock(int day, int price) {\\n            this.day = day;\\n            this.price = price;\\n        }\\n    }\\n    \\n    public int maxProfit(int[] prices) {\\n        Stock sell = new Stock(0, 0);\\n        Stock buy = new Stock(0, Integer.MAX_VALUE);\\n        \\n        for (int i = 0; i < prices.length; i++) {\\n            if (prices[i] <= buy.price && sell.day<=buy.day) {\\n                System.out.println(\" stock bought at day \"+(i+1)+\" at price \"+prices[i]);\\n                buy.price = prices[i];\\n                buy.day = i + 1;\\n            }\\n            if (prices[i] >= sell.price && i + 1 > buy.day) {\\n                System.out.println(\" stock selled at day \"+(i+1)+\" at price \"+prices[i]);\\n                sell.price = prices[i];\\n                sell.day = i + 1;\\n            }\\n        }\\n        \\n        int profit = sell.price - buy.price;\\n        return profit > 0 ? profit : 0;\\n    }\\n}\\n`\\n\\n[2,1,2,1,0,1,2]\\n\\nUse Testcase\\nStdout\\n stock bought at day 1 at price 2\\n stock bought at day 2 at price 1\\n stock selled at day 3 at price 2\\n stock selled at day 7 at price 2\\nOutput\\n1\\nExpected\\n2"
                    },
                    {
                        "username": "Radhika_20",
                        "content": "Maintain the minimum price seen so far and update the maximum profit whenever the current profit is greater than maximum profit (curr profit = price[i]-min price)\\nHope it helps !"
                    },
                    {
                        "username": "Meghajit",
                        "content": "We can solve it by memoizing the maximas at each index as seen traversing from the right. \\n\\nSince we can only sell after we buy( that\\'s how stocks work :) ), the problem is simply that: Given I buy a stock on day T, can I sell it at a cheaper price at any day after day T and if so how much is the profit ?\\n\\n\\n\\n"
                    },
                    {
                        "username": "rishith_11203",
                        "content": "[1,4,2]\\noutput :2\\nexpected:3\\nit this worng:\\n1-4 =3\\nwhich is 2nd elemnet can u help me"
                    },
                    {
                        "username": "winstonallo",
                        "content": "you buy at day 0, sell at day 1, 4-1=3"
                    },
                    {
                        "username": "Mkaif_Agb",
                        "content": "prices = [2,4,1] \\nThis should have the expected profit of 0 as the number 1 is the lowest but testcase 154 wants the expected output to be 2. I am unable to understand."
                    },
                    {
                        "username": "winstonallo",
                        "content": "[@bjraval](/bjraval) No, profit is selling price - buying price, in this case you would do 1-4 which is -3."
                    },
                    {
                        "username": "bjraval",
                        "content": "[@winstonallo](/winstonallo) what you are saying doesn\\'t make sense. For the example [2,4,1], the correct solution is 3 i.e. buy on Day2 and sell on day 3 so 4-1 = 3"
                    },
                    {
                        "username": "winstonallo",
                        "content": "You just need to find the biggest difference between one integer and another that comes after in the array.\\nYou would return 0 if for example the array is [5, 4, 3].\\nIn this case, max(s[j > i] - s[i]) = 4 - 2 = 2"
                    },
                    {
                        "username": "soslow",
                        "content": "shorting is common practice.."
                    }
                ]
            },
            {
                "id": 1972813,
                "content": [
                    {
                        "username": "Shaswat_Pandey",
                        "content": "As the time constraint is given 10^6 , i was thinking that in these type of cases, we can move upto the time complexity of O(n logn). Correct me if i\\'m wrong?\\n\\ncan we solve the same problem in O(n logn)?\\nif yes then kindly suggest the idea.\\nThanks!"
                    },
                    {
                        "username": "woeth",
                        "content": "Most of the solutions are incorrect, as the list represents days and the data represents prices. following logic prices[i] means price on day i. so ->\\n[7,1,5,3,6,4,9,4]\\nbuy in day 2 and sell in day 7 your profit is 8\\nbut the expected output shows 8 as the best day\\n\\nthis solution shows the correct outputs according to the problem description\\n `class Solution:\\n    def maxProfit(self, prices: List[int]) -> int:\\n        profit = 0\\n        day = 0\\n        for i in range(len(prices) - 1):\\n            for j in range(i + 1, len(prices)):\\n                if prices[j] - prices[i] > profit:\\n                    day = j + 1\\n                    profit = prices[j] - prices[i]\\n        return day`"
                    },
                    {
                        "username": "sanskarv120503",
                        "content": "i am not understant this qution "
                    },
                    {
                        "username": "Shaik_Aman_Sayer",
                        "content": "every time i come to solve this problem i cant optimize it "
                    },
                    {
                        "username": "pawarsach_n",
                        "content": "where did i went wrong?\\n\\n `class Solution {\\n    public static class Stock {\\n        int day;\\n        int price;\\n        \\n        Stock(int day, int price) {\\n            this.day = day;\\n            this.price = price;\\n        }\\n    }\\n    \\n    public int maxProfit(int[] prices) {\\n        Stock sell = new Stock(0, 0);\\n        Stock buy = new Stock(0, Integer.MAX_VALUE);\\n        \\n        for (int i = 0; i < prices.length; i++) {\\n            if (prices[i] <= buy.price && sell.day<=buy.day) {\\n                System.out.println(\" stock bought at day \"+(i+1)+\" at price \"+prices[i]);\\n                buy.price = prices[i];\\n                buy.day = i + 1;\\n            }\\n            if (prices[i] >= sell.price && i + 1 > buy.day) {\\n                System.out.println(\" stock selled at day \"+(i+1)+\" at price \"+prices[i]);\\n                sell.price = prices[i];\\n                sell.day = i + 1;\\n            }\\n        }\\n        \\n        int profit = sell.price - buy.price;\\n        return profit > 0 ? profit : 0;\\n    }\\n}\\n`\\n\\n[2,1,2,1,0,1,2]\\n\\nUse Testcase\\nStdout\\n stock bought at day 1 at price 2\\n stock bought at day 2 at price 1\\n stock selled at day 3 at price 2\\n stock selled at day 7 at price 2\\nOutput\\n1\\nExpected\\n2"
                    },
                    {
                        "username": "Radhika_20",
                        "content": "Maintain the minimum price seen so far and update the maximum profit whenever the current profit is greater than maximum profit (curr profit = price[i]-min price)\\nHope it helps !"
                    },
                    {
                        "username": "Meghajit",
                        "content": "We can solve it by memoizing the maximas at each index as seen traversing from the right. \\n\\nSince we can only sell after we buy( that\\'s how stocks work :) ), the problem is simply that: Given I buy a stock on day T, can I sell it at a cheaper price at any day after day T and if so how much is the profit ?\\n\\n\\n\\n"
                    },
                    {
                        "username": "rishith_11203",
                        "content": "[1,4,2]\\noutput :2\\nexpected:3\\nit this worng:\\n1-4 =3\\nwhich is 2nd elemnet can u help me"
                    },
                    {
                        "username": "winstonallo",
                        "content": "you buy at day 0, sell at day 1, 4-1=3"
                    },
                    {
                        "username": "Mkaif_Agb",
                        "content": "prices = [2,4,1] \\nThis should have the expected profit of 0 as the number 1 is the lowest but testcase 154 wants the expected output to be 2. I am unable to understand."
                    },
                    {
                        "username": "winstonallo",
                        "content": "[@bjraval](/bjraval) No, profit is selling price - buying price, in this case you would do 1-4 which is -3."
                    },
                    {
                        "username": "bjraval",
                        "content": "[@winstonallo](/winstonallo) what you are saying doesn\\'t make sense. For the example [2,4,1], the correct solution is 3 i.e. buy on Day2 and sell on day 3 so 4-1 = 3"
                    },
                    {
                        "username": "winstonallo",
                        "content": "You just need to find the biggest difference between one integer and another that comes after in the array.\\nYou would return 0 if for example the array is [5, 4, 3].\\nIn this case, max(s[j > i] - s[i]) = 4 - 2 = 2"
                    },
                    {
                        "username": "soslow",
                        "content": "shorting is common practice.."
                    }
                ]
            },
            {
                "id": 1970161,
                "content": [
                    {
                        "username": "Shaswat_Pandey",
                        "content": "As the time constraint is given 10^6 , i was thinking that in these type of cases, we can move upto the time complexity of O(n logn). Correct me if i\\'m wrong?\\n\\ncan we solve the same problem in O(n logn)?\\nif yes then kindly suggest the idea.\\nThanks!"
                    },
                    {
                        "username": "woeth",
                        "content": "Most of the solutions are incorrect, as the list represents days and the data represents prices. following logic prices[i] means price on day i. so ->\\n[7,1,5,3,6,4,9,4]\\nbuy in day 2 and sell in day 7 your profit is 8\\nbut the expected output shows 8 as the best day\\n\\nthis solution shows the correct outputs according to the problem description\\n `class Solution:\\n    def maxProfit(self, prices: List[int]) -> int:\\n        profit = 0\\n        day = 0\\n        for i in range(len(prices) - 1):\\n            for j in range(i + 1, len(prices)):\\n                if prices[j] - prices[i] > profit:\\n                    day = j + 1\\n                    profit = prices[j] - prices[i]\\n        return day`"
                    },
                    {
                        "username": "sanskarv120503",
                        "content": "i am not understant this qution "
                    },
                    {
                        "username": "Shaik_Aman_Sayer",
                        "content": "every time i come to solve this problem i cant optimize it "
                    },
                    {
                        "username": "pawarsach_n",
                        "content": "where did i went wrong?\\n\\n `class Solution {\\n    public static class Stock {\\n        int day;\\n        int price;\\n        \\n        Stock(int day, int price) {\\n            this.day = day;\\n            this.price = price;\\n        }\\n    }\\n    \\n    public int maxProfit(int[] prices) {\\n        Stock sell = new Stock(0, 0);\\n        Stock buy = new Stock(0, Integer.MAX_VALUE);\\n        \\n        for (int i = 0; i < prices.length; i++) {\\n            if (prices[i] <= buy.price && sell.day<=buy.day) {\\n                System.out.println(\" stock bought at day \"+(i+1)+\" at price \"+prices[i]);\\n                buy.price = prices[i];\\n                buy.day = i + 1;\\n            }\\n            if (prices[i] >= sell.price && i + 1 > buy.day) {\\n                System.out.println(\" stock selled at day \"+(i+1)+\" at price \"+prices[i]);\\n                sell.price = prices[i];\\n                sell.day = i + 1;\\n            }\\n        }\\n        \\n        int profit = sell.price - buy.price;\\n        return profit > 0 ? profit : 0;\\n    }\\n}\\n`\\n\\n[2,1,2,1,0,1,2]\\n\\nUse Testcase\\nStdout\\n stock bought at day 1 at price 2\\n stock bought at day 2 at price 1\\n stock selled at day 3 at price 2\\n stock selled at day 7 at price 2\\nOutput\\n1\\nExpected\\n2"
                    },
                    {
                        "username": "Radhika_20",
                        "content": "Maintain the minimum price seen so far and update the maximum profit whenever the current profit is greater than maximum profit (curr profit = price[i]-min price)\\nHope it helps !"
                    },
                    {
                        "username": "Meghajit",
                        "content": "We can solve it by memoizing the maximas at each index as seen traversing from the right. \\n\\nSince we can only sell after we buy( that\\'s how stocks work :) ), the problem is simply that: Given I buy a stock on day T, can I sell it at a cheaper price at any day after day T and if so how much is the profit ?\\n\\n\\n\\n"
                    },
                    {
                        "username": "rishith_11203",
                        "content": "[1,4,2]\\noutput :2\\nexpected:3\\nit this worng:\\n1-4 =3\\nwhich is 2nd elemnet can u help me"
                    },
                    {
                        "username": "winstonallo",
                        "content": "you buy at day 0, sell at day 1, 4-1=3"
                    },
                    {
                        "username": "Mkaif_Agb",
                        "content": "prices = [2,4,1] \\nThis should have the expected profit of 0 as the number 1 is the lowest but testcase 154 wants the expected output to be 2. I am unable to understand."
                    },
                    {
                        "username": "winstonallo",
                        "content": "[@bjraval](/bjraval) No, profit is selling price - buying price, in this case you would do 1-4 which is -3."
                    },
                    {
                        "username": "bjraval",
                        "content": "[@winstonallo](/winstonallo) what you are saying doesn\\'t make sense. For the example [2,4,1], the correct solution is 3 i.e. buy on Day2 and sell on day 3 so 4-1 = 3"
                    },
                    {
                        "username": "winstonallo",
                        "content": "You just need to find the biggest difference between one integer and another that comes after in the array.\\nYou would return 0 if for example the array is [5, 4, 3].\\nIn this case, max(s[j > i] - s[i]) = 4 - 2 = 2"
                    },
                    {
                        "username": "soslow",
                        "content": "shorting is common practice.."
                    }
                ]
            },
            {
                "id": 1959176,
                "content": [
                    {
                        "username": "Shaswat_Pandey",
                        "content": "As the time constraint is given 10^6 , i was thinking that in these type of cases, we can move upto the time complexity of O(n logn). Correct me if i\\'m wrong?\\n\\ncan we solve the same problem in O(n logn)?\\nif yes then kindly suggest the idea.\\nThanks!"
                    },
                    {
                        "username": "woeth",
                        "content": "Most of the solutions are incorrect, as the list represents days and the data represents prices. following logic prices[i] means price on day i. so ->\\n[7,1,5,3,6,4,9,4]\\nbuy in day 2 and sell in day 7 your profit is 8\\nbut the expected output shows 8 as the best day\\n\\nthis solution shows the correct outputs according to the problem description\\n `class Solution:\\n    def maxProfit(self, prices: List[int]) -> int:\\n        profit = 0\\n        day = 0\\n        for i in range(len(prices) - 1):\\n            for j in range(i + 1, len(prices)):\\n                if prices[j] - prices[i] > profit:\\n                    day = j + 1\\n                    profit = prices[j] - prices[i]\\n        return day`"
                    },
                    {
                        "username": "sanskarv120503",
                        "content": "i am not understant this qution "
                    },
                    {
                        "username": "Shaik_Aman_Sayer",
                        "content": "every time i come to solve this problem i cant optimize it "
                    },
                    {
                        "username": "pawarsach_n",
                        "content": "where did i went wrong?\\n\\n `class Solution {\\n    public static class Stock {\\n        int day;\\n        int price;\\n        \\n        Stock(int day, int price) {\\n            this.day = day;\\n            this.price = price;\\n        }\\n    }\\n    \\n    public int maxProfit(int[] prices) {\\n        Stock sell = new Stock(0, 0);\\n        Stock buy = new Stock(0, Integer.MAX_VALUE);\\n        \\n        for (int i = 0; i < prices.length; i++) {\\n            if (prices[i] <= buy.price && sell.day<=buy.day) {\\n                System.out.println(\" stock bought at day \"+(i+1)+\" at price \"+prices[i]);\\n                buy.price = prices[i];\\n                buy.day = i + 1;\\n            }\\n            if (prices[i] >= sell.price && i + 1 > buy.day) {\\n                System.out.println(\" stock selled at day \"+(i+1)+\" at price \"+prices[i]);\\n                sell.price = prices[i];\\n                sell.day = i + 1;\\n            }\\n        }\\n        \\n        int profit = sell.price - buy.price;\\n        return profit > 0 ? profit : 0;\\n    }\\n}\\n`\\n\\n[2,1,2,1,0,1,2]\\n\\nUse Testcase\\nStdout\\n stock bought at day 1 at price 2\\n stock bought at day 2 at price 1\\n stock selled at day 3 at price 2\\n stock selled at day 7 at price 2\\nOutput\\n1\\nExpected\\n2"
                    },
                    {
                        "username": "Radhika_20",
                        "content": "Maintain the minimum price seen so far and update the maximum profit whenever the current profit is greater than maximum profit (curr profit = price[i]-min price)\\nHope it helps !"
                    },
                    {
                        "username": "Meghajit",
                        "content": "We can solve it by memoizing the maximas at each index as seen traversing from the right. \\n\\nSince we can only sell after we buy( that\\'s how stocks work :) ), the problem is simply that: Given I buy a stock on day T, can I sell it at a cheaper price at any day after day T and if so how much is the profit ?\\n\\n\\n\\n"
                    },
                    {
                        "username": "rishith_11203",
                        "content": "[1,4,2]\\noutput :2\\nexpected:3\\nit this worng:\\n1-4 =3\\nwhich is 2nd elemnet can u help me"
                    },
                    {
                        "username": "winstonallo",
                        "content": "you buy at day 0, sell at day 1, 4-1=3"
                    },
                    {
                        "username": "Mkaif_Agb",
                        "content": "prices = [2,4,1] \\nThis should have the expected profit of 0 as the number 1 is the lowest but testcase 154 wants the expected output to be 2. I am unable to understand."
                    },
                    {
                        "username": "winstonallo",
                        "content": "[@bjraval](/bjraval) No, profit is selling price - buying price, in this case you would do 1-4 which is -3."
                    },
                    {
                        "username": "bjraval",
                        "content": "[@winstonallo](/winstonallo) what you are saying doesn\\'t make sense. For the example [2,4,1], the correct solution is 3 i.e. buy on Day2 and sell on day 3 so 4-1 = 3"
                    },
                    {
                        "username": "winstonallo",
                        "content": "You just need to find the biggest difference between one integer and another that comes after in the array.\\nYou would return 0 if for example the array is [5, 4, 3].\\nIn this case, max(s[j > i] - s[i]) = 4 - 2 = 2"
                    },
                    {
                        "username": "soslow",
                        "content": "shorting is common practice.."
                    }
                ]
            },
            {
                "id": 1958022,
                "content": [
                    {
                        "username": "Shaswat_Pandey",
                        "content": "As the time constraint is given 10^6 , i was thinking that in these type of cases, we can move upto the time complexity of O(n logn). Correct me if i\\'m wrong?\\n\\ncan we solve the same problem in O(n logn)?\\nif yes then kindly suggest the idea.\\nThanks!"
                    },
                    {
                        "username": "woeth",
                        "content": "Most of the solutions are incorrect, as the list represents days and the data represents prices. following logic prices[i] means price on day i. so ->\\n[7,1,5,3,6,4,9,4]\\nbuy in day 2 and sell in day 7 your profit is 8\\nbut the expected output shows 8 as the best day\\n\\nthis solution shows the correct outputs according to the problem description\\n `class Solution:\\n    def maxProfit(self, prices: List[int]) -> int:\\n        profit = 0\\n        day = 0\\n        for i in range(len(prices) - 1):\\n            for j in range(i + 1, len(prices)):\\n                if prices[j] - prices[i] > profit:\\n                    day = j + 1\\n                    profit = prices[j] - prices[i]\\n        return day`"
                    },
                    {
                        "username": "sanskarv120503",
                        "content": "i am not understant this qution "
                    },
                    {
                        "username": "Shaik_Aman_Sayer",
                        "content": "every time i come to solve this problem i cant optimize it "
                    },
                    {
                        "username": "pawarsach_n",
                        "content": "where did i went wrong?\\n\\n `class Solution {\\n    public static class Stock {\\n        int day;\\n        int price;\\n        \\n        Stock(int day, int price) {\\n            this.day = day;\\n            this.price = price;\\n        }\\n    }\\n    \\n    public int maxProfit(int[] prices) {\\n        Stock sell = new Stock(0, 0);\\n        Stock buy = new Stock(0, Integer.MAX_VALUE);\\n        \\n        for (int i = 0; i < prices.length; i++) {\\n            if (prices[i] <= buy.price && sell.day<=buy.day) {\\n                System.out.println(\" stock bought at day \"+(i+1)+\" at price \"+prices[i]);\\n                buy.price = prices[i];\\n                buy.day = i + 1;\\n            }\\n            if (prices[i] >= sell.price && i + 1 > buy.day) {\\n                System.out.println(\" stock selled at day \"+(i+1)+\" at price \"+prices[i]);\\n                sell.price = prices[i];\\n                sell.day = i + 1;\\n            }\\n        }\\n        \\n        int profit = sell.price - buy.price;\\n        return profit > 0 ? profit : 0;\\n    }\\n}\\n`\\n\\n[2,1,2,1,0,1,2]\\n\\nUse Testcase\\nStdout\\n stock bought at day 1 at price 2\\n stock bought at day 2 at price 1\\n stock selled at day 3 at price 2\\n stock selled at day 7 at price 2\\nOutput\\n1\\nExpected\\n2"
                    },
                    {
                        "username": "Radhika_20",
                        "content": "Maintain the minimum price seen so far and update the maximum profit whenever the current profit is greater than maximum profit (curr profit = price[i]-min price)\\nHope it helps !"
                    },
                    {
                        "username": "Meghajit",
                        "content": "We can solve it by memoizing the maximas at each index as seen traversing from the right. \\n\\nSince we can only sell after we buy( that\\'s how stocks work :) ), the problem is simply that: Given I buy a stock on day T, can I sell it at a cheaper price at any day after day T and if so how much is the profit ?\\n\\n\\n\\n"
                    },
                    {
                        "username": "rishith_11203",
                        "content": "[1,4,2]\\noutput :2\\nexpected:3\\nit this worng:\\n1-4 =3\\nwhich is 2nd elemnet can u help me"
                    },
                    {
                        "username": "winstonallo",
                        "content": "you buy at day 0, sell at day 1, 4-1=3"
                    },
                    {
                        "username": "Mkaif_Agb",
                        "content": "prices = [2,4,1] \\nThis should have the expected profit of 0 as the number 1 is the lowest but testcase 154 wants the expected output to be 2. I am unable to understand."
                    },
                    {
                        "username": "winstonallo",
                        "content": "[@bjraval](/bjraval) No, profit is selling price - buying price, in this case you would do 1-4 which is -3."
                    },
                    {
                        "username": "bjraval",
                        "content": "[@winstonallo](/winstonallo) what you are saying doesn\\'t make sense. For the example [2,4,1], the correct solution is 3 i.e. buy on Day2 and sell on day 3 so 4-1 = 3"
                    },
                    {
                        "username": "winstonallo",
                        "content": "You just need to find the biggest difference between one integer and another that comes after in the array.\\nYou would return 0 if for example the array is [5, 4, 3].\\nIn this case, max(s[j > i] - s[i]) = 4 - 2 = 2"
                    },
                    {
                        "username": "soslow",
                        "content": "shorting is common practice.."
                    }
                ]
            },
            {
                "id": 1956000,
                "content": [
                    {
                        "username": "abmath113",
                        "content": "I don\\'t get it, how does this problem is sliding window."
                    },
                    {
                        "username": "Tikam_Gupta",
                        "content": "class Solution{\\npublic:\\n    int maxProfit(vector<int>& prices){\\n        int profit= 0;\\n        for(int i = 0; i<prices.size()-1; i++){\\n            for(int j= i+1; j<prices.size(); j++){\\n                int ans= prices[j] - prices[i];\\n                profit = max(ans, profit);\\n            }\\n        }\\n        return profit;\\n    }\\n\\n};\\n\\nWhy is it showing time limit exceeded?"
                    },
                    {
                        "username": "maharahisoni",
                        "content": "CODE:\\n\\nint maxii=0;\\nclass Solution {\\npublic:\\n    int minimum(vector<int> arr,int size){\\n    if (size==0) return arr[0];\\n    int temp=min(arr[size-1],minimum(arr,size-1));\\n    maxii=max(maxii,arr[size]-temp);\\n    return temp;\\n} \\n    int maxProfit(vector<int> prices) {\\n      \\n       minimum(prices,prices.size()-1);\\n       int temp=maxii;\\n       maxii=0;\\n       return temp;\\n    }\\n};\\n\\nThis code stucks at TC no 198 in  MEMORY LIMIT EXCEED why??"
                    },
                    {
                        "username": "johngjackson0",
                        "content": "There is a much easier way to do this than Sliding Window or Dynamic programming! Instead it would be \"Greedy Algorithm.\" It\\'s a way to say, in the present make the \"best choice.\" \\n\\n1. Since you cannot go in the past, it\\'s not a simple min vs max of nums. i.e. your min number cannot be compared to a max number before it. \\n2. You just calculate the optimal choice in the present."
                    },
                    {
                        "username": "uddiptapathak729",
                        "content": "how can a stock be bought at zero lol"
                    },
                    {
                        "username": "Mr_Jobs",
                        "content": "Time & Space: O(n) & O(1)\\n1. Use two variables to keep track of max_profit and max_price\\n2. Traverse from the end\\n3. If encounter a price that is greater than max_price, update max_price\\n4. Else, calculate profit and update max_profit if profit is greater than max_profit"
                    },
                    {
                        "username": "JeremyAnderson8",
                        "content": "This keeps getting the \"Time Limit Exceeded\" error on the 200th test case. Can anyone please offer some guidance on what I am doing wrong or what I should do to make it work? I am only using one loop\n\nmax_profit = 0\n        for i in range(len(prices)):\n            if i != len(prices)-1:\n                temp_max = max(prices[i+1:len(prices)]) - prices[i]\n                if temp_max > max_profit:\n                    max_profit = temp_max\n        return max_profit"
                    },
                    {
                        "username": "luizhenriquemaia",
                        "content": "Nice one, it's impossible to writing the solution with python, because of runtime, thanks alot leetcode for -1 hour of my life for nothing :)"
                    },
                    {
                        "username": "JeremyAnderson8",
                        "content": "fr, doesn\\'t work with my single for loop. don\\'t know what else to do "
                    },
                    {
                        "username": "chazwinter",
                        "content": "We should be able to flag/report bad solutions. The \"top\" solutions just hard code the answers for the large test cases  to appear faster. That\\'s really lame, and I see it as cheating. We\\'re here to learn, not cheat."
                    },
                    {
                        "username": "prasumitmishra",
                        "content": "for [1, 2, 4], the expected answer is 3. Not sure How?\nYou can do a Buy + Buy + Sell, which means -1 -2 + (2*4) = 5 is your profit. Not sure how come is the expected answer 3?\n\nMy approach includes continue buying till you find max on your right.\nEg.\n\n[1, 3, 5, 3, 1, 2]\nMax is 5 (So sale should happen here)\n[1 (Buy) 3(Buy) 5 (Sell)] [3,  1,  2]\n\nRepeat same with [3, 1, 2] : (if present rate is greater than max on right, skip: don't buy don't sell), i.e. [3(hold) 1 (Buy), 2 (Sell)]\n\n-1 -3 +5*2 + 0 -1  + 2\n= 7.\n\n"
                    },
                    {
                        "username": "bparanj",
                        "content": "This is a single transaction only problem."
                    }
                ]
            },
            {
                "id": 1954492,
                "content": [
                    {
                        "username": "abmath113",
                        "content": "I don\\'t get it, how does this problem is sliding window."
                    },
                    {
                        "username": "Tikam_Gupta",
                        "content": "class Solution{\\npublic:\\n    int maxProfit(vector<int>& prices){\\n        int profit= 0;\\n        for(int i = 0; i<prices.size()-1; i++){\\n            for(int j= i+1; j<prices.size(); j++){\\n                int ans= prices[j] - prices[i];\\n                profit = max(ans, profit);\\n            }\\n        }\\n        return profit;\\n    }\\n\\n};\\n\\nWhy is it showing time limit exceeded?"
                    },
                    {
                        "username": "maharahisoni",
                        "content": "CODE:\\n\\nint maxii=0;\\nclass Solution {\\npublic:\\n    int minimum(vector<int> arr,int size){\\n    if (size==0) return arr[0];\\n    int temp=min(arr[size-1],minimum(arr,size-1));\\n    maxii=max(maxii,arr[size]-temp);\\n    return temp;\\n} \\n    int maxProfit(vector<int> prices) {\\n      \\n       minimum(prices,prices.size()-1);\\n       int temp=maxii;\\n       maxii=0;\\n       return temp;\\n    }\\n};\\n\\nThis code stucks at TC no 198 in  MEMORY LIMIT EXCEED why??"
                    },
                    {
                        "username": "johngjackson0",
                        "content": "There is a much easier way to do this than Sliding Window or Dynamic programming! Instead it would be \"Greedy Algorithm.\" It\\'s a way to say, in the present make the \"best choice.\" \\n\\n1. Since you cannot go in the past, it\\'s not a simple min vs max of nums. i.e. your min number cannot be compared to a max number before it. \\n2. You just calculate the optimal choice in the present."
                    },
                    {
                        "username": "uddiptapathak729",
                        "content": "how can a stock be bought at zero lol"
                    },
                    {
                        "username": "Mr_Jobs",
                        "content": "Time & Space: O(n) & O(1)\\n1. Use two variables to keep track of max_profit and max_price\\n2. Traverse from the end\\n3. If encounter a price that is greater than max_price, update max_price\\n4. Else, calculate profit and update max_profit if profit is greater than max_profit"
                    },
                    {
                        "username": "JeremyAnderson8",
                        "content": "This keeps getting the \"Time Limit Exceeded\" error on the 200th test case. Can anyone please offer some guidance on what I am doing wrong or what I should do to make it work? I am only using one loop\n\nmax_profit = 0\n        for i in range(len(prices)):\n            if i != len(prices)-1:\n                temp_max = max(prices[i+1:len(prices)]) - prices[i]\n                if temp_max > max_profit:\n                    max_profit = temp_max\n        return max_profit"
                    },
                    {
                        "username": "luizhenriquemaia",
                        "content": "Nice one, it's impossible to writing the solution with python, because of runtime, thanks alot leetcode for -1 hour of my life for nothing :)"
                    },
                    {
                        "username": "JeremyAnderson8",
                        "content": "fr, doesn\\'t work with my single for loop. don\\'t know what else to do "
                    },
                    {
                        "username": "chazwinter",
                        "content": "We should be able to flag/report bad solutions. The \"top\" solutions just hard code the answers for the large test cases  to appear faster. That\\'s really lame, and I see it as cheating. We\\'re here to learn, not cheat."
                    },
                    {
                        "username": "prasumitmishra",
                        "content": "for [1, 2, 4], the expected answer is 3. Not sure How?\nYou can do a Buy + Buy + Sell, which means -1 -2 + (2*4) = 5 is your profit. Not sure how come is the expected answer 3?\n\nMy approach includes continue buying till you find max on your right.\nEg.\n\n[1, 3, 5, 3, 1, 2]\nMax is 5 (So sale should happen here)\n[1 (Buy) 3(Buy) 5 (Sell)] [3,  1,  2]\n\nRepeat same with [3, 1, 2] : (if present rate is greater than max on right, skip: don't buy don't sell), i.e. [3(hold) 1 (Buy), 2 (Sell)]\n\n-1 -3 +5*2 + 0 -1  + 2\n= 7.\n\n"
                    },
                    {
                        "username": "bparanj",
                        "content": "This is a single transaction only problem."
                    }
                ]
            },
            {
                "id": 1951533,
                "content": [
                    {
                        "username": "abmath113",
                        "content": "I don\\'t get it, how does this problem is sliding window."
                    },
                    {
                        "username": "Tikam_Gupta",
                        "content": "class Solution{\\npublic:\\n    int maxProfit(vector<int>& prices){\\n        int profit= 0;\\n        for(int i = 0; i<prices.size()-1; i++){\\n            for(int j= i+1; j<prices.size(); j++){\\n                int ans= prices[j] - prices[i];\\n                profit = max(ans, profit);\\n            }\\n        }\\n        return profit;\\n    }\\n\\n};\\n\\nWhy is it showing time limit exceeded?"
                    },
                    {
                        "username": "maharahisoni",
                        "content": "CODE:\\n\\nint maxii=0;\\nclass Solution {\\npublic:\\n    int minimum(vector<int> arr,int size){\\n    if (size==0) return arr[0];\\n    int temp=min(arr[size-1],minimum(arr,size-1));\\n    maxii=max(maxii,arr[size]-temp);\\n    return temp;\\n} \\n    int maxProfit(vector<int> prices) {\\n      \\n       minimum(prices,prices.size()-1);\\n       int temp=maxii;\\n       maxii=0;\\n       return temp;\\n    }\\n};\\n\\nThis code stucks at TC no 198 in  MEMORY LIMIT EXCEED why??"
                    },
                    {
                        "username": "johngjackson0",
                        "content": "There is a much easier way to do this than Sliding Window or Dynamic programming! Instead it would be \"Greedy Algorithm.\" It\\'s a way to say, in the present make the \"best choice.\" \\n\\n1. Since you cannot go in the past, it\\'s not a simple min vs max of nums. i.e. your min number cannot be compared to a max number before it. \\n2. You just calculate the optimal choice in the present."
                    },
                    {
                        "username": "uddiptapathak729",
                        "content": "how can a stock be bought at zero lol"
                    },
                    {
                        "username": "Mr_Jobs",
                        "content": "Time & Space: O(n) & O(1)\\n1. Use two variables to keep track of max_profit and max_price\\n2. Traverse from the end\\n3. If encounter a price that is greater than max_price, update max_price\\n4. Else, calculate profit and update max_profit if profit is greater than max_profit"
                    },
                    {
                        "username": "JeremyAnderson8",
                        "content": "This keeps getting the \"Time Limit Exceeded\" error on the 200th test case. Can anyone please offer some guidance on what I am doing wrong or what I should do to make it work? I am only using one loop\n\nmax_profit = 0\n        for i in range(len(prices)):\n            if i != len(prices)-1:\n                temp_max = max(prices[i+1:len(prices)]) - prices[i]\n                if temp_max > max_profit:\n                    max_profit = temp_max\n        return max_profit"
                    },
                    {
                        "username": "luizhenriquemaia",
                        "content": "Nice one, it's impossible to writing the solution with python, because of runtime, thanks alot leetcode for -1 hour of my life for nothing :)"
                    },
                    {
                        "username": "JeremyAnderson8",
                        "content": "fr, doesn\\'t work with my single for loop. don\\'t know what else to do "
                    },
                    {
                        "username": "chazwinter",
                        "content": "We should be able to flag/report bad solutions. The \"top\" solutions just hard code the answers for the large test cases  to appear faster. That\\'s really lame, and I see it as cheating. We\\'re here to learn, not cheat."
                    },
                    {
                        "username": "prasumitmishra",
                        "content": "for [1, 2, 4], the expected answer is 3. Not sure How?\nYou can do a Buy + Buy + Sell, which means -1 -2 + (2*4) = 5 is your profit. Not sure how come is the expected answer 3?\n\nMy approach includes continue buying till you find max on your right.\nEg.\n\n[1, 3, 5, 3, 1, 2]\nMax is 5 (So sale should happen here)\n[1 (Buy) 3(Buy) 5 (Sell)] [3,  1,  2]\n\nRepeat same with [3, 1, 2] : (if present rate is greater than max on right, skip: don't buy don't sell), i.e. [3(hold) 1 (Buy), 2 (Sell)]\n\n-1 -3 +5*2 + 0 -1  + 2\n= 7.\n\n"
                    },
                    {
                        "username": "bparanj",
                        "content": "This is a single transaction only problem."
                    }
                ]
            },
            {
                "id": 1949654,
                "content": [
                    {
                        "username": "abmath113",
                        "content": "I don\\'t get it, how does this problem is sliding window."
                    },
                    {
                        "username": "Tikam_Gupta",
                        "content": "class Solution{\\npublic:\\n    int maxProfit(vector<int>& prices){\\n        int profit= 0;\\n        for(int i = 0; i<prices.size()-1; i++){\\n            for(int j= i+1; j<prices.size(); j++){\\n                int ans= prices[j] - prices[i];\\n                profit = max(ans, profit);\\n            }\\n        }\\n        return profit;\\n    }\\n\\n};\\n\\nWhy is it showing time limit exceeded?"
                    },
                    {
                        "username": "maharahisoni",
                        "content": "CODE:\\n\\nint maxii=0;\\nclass Solution {\\npublic:\\n    int minimum(vector<int> arr,int size){\\n    if (size==0) return arr[0];\\n    int temp=min(arr[size-1],minimum(arr,size-1));\\n    maxii=max(maxii,arr[size]-temp);\\n    return temp;\\n} \\n    int maxProfit(vector<int> prices) {\\n      \\n       minimum(prices,prices.size()-1);\\n       int temp=maxii;\\n       maxii=0;\\n       return temp;\\n    }\\n};\\n\\nThis code stucks at TC no 198 in  MEMORY LIMIT EXCEED why??"
                    },
                    {
                        "username": "johngjackson0",
                        "content": "There is a much easier way to do this than Sliding Window or Dynamic programming! Instead it would be \"Greedy Algorithm.\" It\\'s a way to say, in the present make the \"best choice.\" \\n\\n1. Since you cannot go in the past, it\\'s not a simple min vs max of nums. i.e. your min number cannot be compared to a max number before it. \\n2. You just calculate the optimal choice in the present."
                    },
                    {
                        "username": "uddiptapathak729",
                        "content": "how can a stock be bought at zero lol"
                    },
                    {
                        "username": "Mr_Jobs",
                        "content": "Time & Space: O(n) & O(1)\\n1. Use two variables to keep track of max_profit and max_price\\n2. Traverse from the end\\n3. If encounter a price that is greater than max_price, update max_price\\n4. Else, calculate profit and update max_profit if profit is greater than max_profit"
                    },
                    {
                        "username": "JeremyAnderson8",
                        "content": "This keeps getting the \"Time Limit Exceeded\" error on the 200th test case. Can anyone please offer some guidance on what I am doing wrong or what I should do to make it work? I am only using one loop\n\nmax_profit = 0\n        for i in range(len(prices)):\n            if i != len(prices)-1:\n                temp_max = max(prices[i+1:len(prices)]) - prices[i]\n                if temp_max > max_profit:\n                    max_profit = temp_max\n        return max_profit"
                    },
                    {
                        "username": "luizhenriquemaia",
                        "content": "Nice one, it's impossible to writing the solution with python, because of runtime, thanks alot leetcode for -1 hour of my life for nothing :)"
                    },
                    {
                        "username": "JeremyAnderson8",
                        "content": "fr, doesn\\'t work with my single for loop. don\\'t know what else to do "
                    },
                    {
                        "username": "chazwinter",
                        "content": "We should be able to flag/report bad solutions. The \"top\" solutions just hard code the answers for the large test cases  to appear faster. That\\'s really lame, and I see it as cheating. We\\'re here to learn, not cheat."
                    },
                    {
                        "username": "prasumitmishra",
                        "content": "for [1, 2, 4], the expected answer is 3. Not sure How?\nYou can do a Buy + Buy + Sell, which means -1 -2 + (2*4) = 5 is your profit. Not sure how come is the expected answer 3?\n\nMy approach includes continue buying till you find max on your right.\nEg.\n\n[1, 3, 5, 3, 1, 2]\nMax is 5 (So sale should happen here)\n[1 (Buy) 3(Buy) 5 (Sell)] [3,  1,  2]\n\nRepeat same with [3, 1, 2] : (if present rate is greater than max on right, skip: don't buy don't sell), i.e. [3(hold) 1 (Buy), 2 (Sell)]\n\n-1 -3 +5*2 + 0 -1  + 2\n= 7.\n\n"
                    },
                    {
                        "username": "bparanj",
                        "content": "This is a single transaction only problem."
                    }
                ]
            },
            {
                "id": 1946608,
                "content": [
                    {
                        "username": "abmath113",
                        "content": "I don\\'t get it, how does this problem is sliding window."
                    },
                    {
                        "username": "Tikam_Gupta",
                        "content": "class Solution{\\npublic:\\n    int maxProfit(vector<int>& prices){\\n        int profit= 0;\\n        for(int i = 0; i<prices.size()-1; i++){\\n            for(int j= i+1; j<prices.size(); j++){\\n                int ans= prices[j] - prices[i];\\n                profit = max(ans, profit);\\n            }\\n        }\\n        return profit;\\n    }\\n\\n};\\n\\nWhy is it showing time limit exceeded?"
                    },
                    {
                        "username": "maharahisoni",
                        "content": "CODE:\\n\\nint maxii=0;\\nclass Solution {\\npublic:\\n    int minimum(vector<int> arr,int size){\\n    if (size==0) return arr[0];\\n    int temp=min(arr[size-1],minimum(arr,size-1));\\n    maxii=max(maxii,arr[size]-temp);\\n    return temp;\\n} \\n    int maxProfit(vector<int> prices) {\\n      \\n       minimum(prices,prices.size()-1);\\n       int temp=maxii;\\n       maxii=0;\\n       return temp;\\n    }\\n};\\n\\nThis code stucks at TC no 198 in  MEMORY LIMIT EXCEED why??"
                    },
                    {
                        "username": "johngjackson0",
                        "content": "There is a much easier way to do this than Sliding Window or Dynamic programming! Instead it would be \"Greedy Algorithm.\" It\\'s a way to say, in the present make the \"best choice.\" \\n\\n1. Since you cannot go in the past, it\\'s not a simple min vs max of nums. i.e. your min number cannot be compared to a max number before it. \\n2. You just calculate the optimal choice in the present."
                    },
                    {
                        "username": "uddiptapathak729",
                        "content": "how can a stock be bought at zero lol"
                    },
                    {
                        "username": "Mr_Jobs",
                        "content": "Time & Space: O(n) & O(1)\\n1. Use two variables to keep track of max_profit and max_price\\n2. Traverse from the end\\n3. If encounter a price that is greater than max_price, update max_price\\n4. Else, calculate profit and update max_profit if profit is greater than max_profit"
                    },
                    {
                        "username": "JeremyAnderson8",
                        "content": "This keeps getting the \"Time Limit Exceeded\" error on the 200th test case. Can anyone please offer some guidance on what I am doing wrong or what I should do to make it work? I am only using one loop\n\nmax_profit = 0\n        for i in range(len(prices)):\n            if i != len(prices)-1:\n                temp_max = max(prices[i+1:len(prices)]) - prices[i]\n                if temp_max > max_profit:\n                    max_profit = temp_max\n        return max_profit"
                    },
                    {
                        "username": "luizhenriquemaia",
                        "content": "Nice one, it's impossible to writing the solution with python, because of runtime, thanks alot leetcode for -1 hour of my life for nothing :)"
                    },
                    {
                        "username": "JeremyAnderson8",
                        "content": "fr, doesn\\'t work with my single for loop. don\\'t know what else to do "
                    },
                    {
                        "username": "chazwinter",
                        "content": "We should be able to flag/report bad solutions. The \"top\" solutions just hard code the answers for the large test cases  to appear faster. That\\'s really lame, and I see it as cheating. We\\'re here to learn, not cheat."
                    },
                    {
                        "username": "prasumitmishra",
                        "content": "for [1, 2, 4], the expected answer is 3. Not sure How?\nYou can do a Buy + Buy + Sell, which means -1 -2 + (2*4) = 5 is your profit. Not sure how come is the expected answer 3?\n\nMy approach includes continue buying till you find max on your right.\nEg.\n\n[1, 3, 5, 3, 1, 2]\nMax is 5 (So sale should happen here)\n[1 (Buy) 3(Buy) 5 (Sell)] [3,  1,  2]\n\nRepeat same with [3, 1, 2] : (if present rate is greater than max on right, skip: don't buy don't sell), i.e. [3(hold) 1 (Buy), 2 (Sell)]\n\n-1 -3 +5*2 + 0 -1  + 2\n= 7.\n\n"
                    },
                    {
                        "username": "bparanj",
                        "content": "This is a single transaction only problem."
                    }
                ]
            },
            {
                "id": 1945955,
                "content": [
                    {
                        "username": "abmath113",
                        "content": "I don\\'t get it, how does this problem is sliding window."
                    },
                    {
                        "username": "Tikam_Gupta",
                        "content": "class Solution{\\npublic:\\n    int maxProfit(vector<int>& prices){\\n        int profit= 0;\\n        for(int i = 0; i<prices.size()-1; i++){\\n            for(int j= i+1; j<prices.size(); j++){\\n                int ans= prices[j] - prices[i];\\n                profit = max(ans, profit);\\n            }\\n        }\\n        return profit;\\n    }\\n\\n};\\n\\nWhy is it showing time limit exceeded?"
                    },
                    {
                        "username": "maharahisoni",
                        "content": "CODE:\\n\\nint maxii=0;\\nclass Solution {\\npublic:\\n    int minimum(vector<int> arr,int size){\\n    if (size==0) return arr[0];\\n    int temp=min(arr[size-1],minimum(arr,size-1));\\n    maxii=max(maxii,arr[size]-temp);\\n    return temp;\\n} \\n    int maxProfit(vector<int> prices) {\\n      \\n       minimum(prices,prices.size()-1);\\n       int temp=maxii;\\n       maxii=0;\\n       return temp;\\n    }\\n};\\n\\nThis code stucks at TC no 198 in  MEMORY LIMIT EXCEED why??"
                    },
                    {
                        "username": "johngjackson0",
                        "content": "There is a much easier way to do this than Sliding Window or Dynamic programming! Instead it would be \"Greedy Algorithm.\" It\\'s a way to say, in the present make the \"best choice.\" \\n\\n1. Since you cannot go in the past, it\\'s not a simple min vs max of nums. i.e. your min number cannot be compared to a max number before it. \\n2. You just calculate the optimal choice in the present."
                    },
                    {
                        "username": "uddiptapathak729",
                        "content": "how can a stock be bought at zero lol"
                    },
                    {
                        "username": "Mr_Jobs",
                        "content": "Time & Space: O(n) & O(1)\\n1. Use two variables to keep track of max_profit and max_price\\n2. Traverse from the end\\n3. If encounter a price that is greater than max_price, update max_price\\n4. Else, calculate profit and update max_profit if profit is greater than max_profit"
                    },
                    {
                        "username": "JeremyAnderson8",
                        "content": "This keeps getting the \"Time Limit Exceeded\" error on the 200th test case. Can anyone please offer some guidance on what I am doing wrong or what I should do to make it work? I am only using one loop\n\nmax_profit = 0\n        for i in range(len(prices)):\n            if i != len(prices)-1:\n                temp_max = max(prices[i+1:len(prices)]) - prices[i]\n                if temp_max > max_profit:\n                    max_profit = temp_max\n        return max_profit"
                    },
                    {
                        "username": "luizhenriquemaia",
                        "content": "Nice one, it's impossible to writing the solution with python, because of runtime, thanks alot leetcode for -1 hour of my life for nothing :)"
                    },
                    {
                        "username": "JeremyAnderson8",
                        "content": "fr, doesn\\'t work with my single for loop. don\\'t know what else to do "
                    },
                    {
                        "username": "chazwinter",
                        "content": "We should be able to flag/report bad solutions. The \"top\" solutions just hard code the answers for the large test cases  to appear faster. That\\'s really lame, and I see it as cheating. We\\'re here to learn, not cheat."
                    },
                    {
                        "username": "prasumitmishra",
                        "content": "for [1, 2, 4], the expected answer is 3. Not sure How?\nYou can do a Buy + Buy + Sell, which means -1 -2 + (2*4) = 5 is your profit. Not sure how come is the expected answer 3?\n\nMy approach includes continue buying till you find max on your right.\nEg.\n\n[1, 3, 5, 3, 1, 2]\nMax is 5 (So sale should happen here)\n[1 (Buy) 3(Buy) 5 (Sell)] [3,  1,  2]\n\nRepeat same with [3, 1, 2] : (if present rate is greater than max on right, skip: don't buy don't sell), i.e. [3(hold) 1 (Buy), 2 (Sell)]\n\n-1 -3 +5*2 + 0 -1  + 2\n= 7.\n\n"
                    },
                    {
                        "username": "bparanj",
                        "content": "This is a single transaction only problem."
                    }
                ]
            },
            {
                "id": 1943053,
                "content": [
                    {
                        "username": "abmath113",
                        "content": "I don\\'t get it, how does this problem is sliding window."
                    },
                    {
                        "username": "Tikam_Gupta",
                        "content": "class Solution{\\npublic:\\n    int maxProfit(vector<int>& prices){\\n        int profit= 0;\\n        for(int i = 0; i<prices.size()-1; i++){\\n            for(int j= i+1; j<prices.size(); j++){\\n                int ans= prices[j] - prices[i];\\n                profit = max(ans, profit);\\n            }\\n        }\\n        return profit;\\n    }\\n\\n};\\n\\nWhy is it showing time limit exceeded?"
                    },
                    {
                        "username": "maharahisoni",
                        "content": "CODE:\\n\\nint maxii=0;\\nclass Solution {\\npublic:\\n    int minimum(vector<int> arr,int size){\\n    if (size==0) return arr[0];\\n    int temp=min(arr[size-1],minimum(arr,size-1));\\n    maxii=max(maxii,arr[size]-temp);\\n    return temp;\\n} \\n    int maxProfit(vector<int> prices) {\\n      \\n       minimum(prices,prices.size()-1);\\n       int temp=maxii;\\n       maxii=0;\\n       return temp;\\n    }\\n};\\n\\nThis code stucks at TC no 198 in  MEMORY LIMIT EXCEED why??"
                    },
                    {
                        "username": "johngjackson0",
                        "content": "There is a much easier way to do this than Sliding Window or Dynamic programming! Instead it would be \"Greedy Algorithm.\" It\\'s a way to say, in the present make the \"best choice.\" \\n\\n1. Since you cannot go in the past, it\\'s not a simple min vs max of nums. i.e. your min number cannot be compared to a max number before it. \\n2. You just calculate the optimal choice in the present."
                    },
                    {
                        "username": "uddiptapathak729",
                        "content": "how can a stock be bought at zero lol"
                    },
                    {
                        "username": "Mr_Jobs",
                        "content": "Time & Space: O(n) & O(1)\\n1. Use two variables to keep track of max_profit and max_price\\n2. Traverse from the end\\n3. If encounter a price that is greater than max_price, update max_price\\n4. Else, calculate profit and update max_profit if profit is greater than max_profit"
                    },
                    {
                        "username": "JeremyAnderson8",
                        "content": "This keeps getting the \"Time Limit Exceeded\" error on the 200th test case. Can anyone please offer some guidance on what I am doing wrong or what I should do to make it work? I am only using one loop\n\nmax_profit = 0\n        for i in range(len(prices)):\n            if i != len(prices)-1:\n                temp_max = max(prices[i+1:len(prices)]) - prices[i]\n                if temp_max > max_profit:\n                    max_profit = temp_max\n        return max_profit"
                    },
                    {
                        "username": "luizhenriquemaia",
                        "content": "Nice one, it's impossible to writing the solution with python, because of runtime, thanks alot leetcode for -1 hour of my life for nothing :)"
                    },
                    {
                        "username": "JeremyAnderson8",
                        "content": "fr, doesn\\'t work with my single for loop. don\\'t know what else to do "
                    },
                    {
                        "username": "chazwinter",
                        "content": "We should be able to flag/report bad solutions. The \"top\" solutions just hard code the answers for the large test cases  to appear faster. That\\'s really lame, and I see it as cheating. We\\'re here to learn, not cheat."
                    },
                    {
                        "username": "prasumitmishra",
                        "content": "for [1, 2, 4], the expected answer is 3. Not sure How?\nYou can do a Buy + Buy + Sell, which means -1 -2 + (2*4) = 5 is your profit. Not sure how come is the expected answer 3?\n\nMy approach includes continue buying till you find max on your right.\nEg.\n\n[1, 3, 5, 3, 1, 2]\nMax is 5 (So sale should happen here)\n[1 (Buy) 3(Buy) 5 (Sell)] [3,  1,  2]\n\nRepeat same with [3, 1, 2] : (if present rate is greater than max on right, skip: don't buy don't sell), i.e. [3(hold) 1 (Buy), 2 (Sell)]\n\n-1 -3 +5*2 + 0 -1  + 2\n= 7.\n\n"
                    },
                    {
                        "username": "bparanj",
                        "content": "This is a single transaction only problem."
                    }
                ]
            },
            {
                "id": 1942138,
                "content": [
                    {
                        "username": "abmath113",
                        "content": "I don\\'t get it, how does this problem is sliding window."
                    },
                    {
                        "username": "Tikam_Gupta",
                        "content": "class Solution{\\npublic:\\n    int maxProfit(vector<int>& prices){\\n        int profit= 0;\\n        for(int i = 0; i<prices.size()-1; i++){\\n            for(int j= i+1; j<prices.size(); j++){\\n                int ans= prices[j] - prices[i];\\n                profit = max(ans, profit);\\n            }\\n        }\\n        return profit;\\n    }\\n\\n};\\n\\nWhy is it showing time limit exceeded?"
                    },
                    {
                        "username": "maharahisoni",
                        "content": "CODE:\\n\\nint maxii=0;\\nclass Solution {\\npublic:\\n    int minimum(vector<int> arr,int size){\\n    if (size==0) return arr[0];\\n    int temp=min(arr[size-1],minimum(arr,size-1));\\n    maxii=max(maxii,arr[size]-temp);\\n    return temp;\\n} \\n    int maxProfit(vector<int> prices) {\\n      \\n       minimum(prices,prices.size()-1);\\n       int temp=maxii;\\n       maxii=0;\\n       return temp;\\n    }\\n};\\n\\nThis code stucks at TC no 198 in  MEMORY LIMIT EXCEED why??"
                    },
                    {
                        "username": "johngjackson0",
                        "content": "There is a much easier way to do this than Sliding Window or Dynamic programming! Instead it would be \"Greedy Algorithm.\" It\\'s a way to say, in the present make the \"best choice.\" \\n\\n1. Since you cannot go in the past, it\\'s not a simple min vs max of nums. i.e. your min number cannot be compared to a max number before it. \\n2. You just calculate the optimal choice in the present."
                    },
                    {
                        "username": "uddiptapathak729",
                        "content": "how can a stock be bought at zero lol"
                    },
                    {
                        "username": "Mr_Jobs",
                        "content": "Time & Space: O(n) & O(1)\\n1. Use two variables to keep track of max_profit and max_price\\n2. Traverse from the end\\n3. If encounter a price that is greater than max_price, update max_price\\n4. Else, calculate profit and update max_profit if profit is greater than max_profit"
                    },
                    {
                        "username": "JeremyAnderson8",
                        "content": "This keeps getting the \"Time Limit Exceeded\" error on the 200th test case. Can anyone please offer some guidance on what I am doing wrong or what I should do to make it work? I am only using one loop\n\nmax_profit = 0\n        for i in range(len(prices)):\n            if i != len(prices)-1:\n                temp_max = max(prices[i+1:len(prices)]) - prices[i]\n                if temp_max > max_profit:\n                    max_profit = temp_max\n        return max_profit"
                    },
                    {
                        "username": "luizhenriquemaia",
                        "content": "Nice one, it's impossible to writing the solution with python, because of runtime, thanks alot leetcode for -1 hour of my life for nothing :)"
                    },
                    {
                        "username": "JeremyAnderson8",
                        "content": "fr, doesn\\'t work with my single for loop. don\\'t know what else to do "
                    },
                    {
                        "username": "chazwinter",
                        "content": "We should be able to flag/report bad solutions. The \"top\" solutions just hard code the answers for the large test cases  to appear faster. That\\'s really lame, and I see it as cheating. We\\'re here to learn, not cheat."
                    },
                    {
                        "username": "prasumitmishra",
                        "content": "for [1, 2, 4], the expected answer is 3. Not sure How?\nYou can do a Buy + Buy + Sell, which means -1 -2 + (2*4) = 5 is your profit. Not sure how come is the expected answer 3?\n\nMy approach includes continue buying till you find max on your right.\nEg.\n\n[1, 3, 5, 3, 1, 2]\nMax is 5 (So sale should happen here)\n[1 (Buy) 3(Buy) 5 (Sell)] [3,  1,  2]\n\nRepeat same with [3, 1, 2] : (if present rate is greater than max on right, skip: don't buy don't sell), i.e. [3(hold) 1 (Buy), 2 (Sell)]\n\n-1 -3 +5*2 + 0 -1  + 2\n= 7.\n\n"
                    },
                    {
                        "username": "bparanj",
                        "content": "This is a single transaction only problem."
                    }
                ]
            },
            {
                "id": 1940079,
                "content": [
                    {
                        "username": "abmath113",
                        "content": "I don\\'t get it, how does this problem is sliding window."
                    },
                    {
                        "username": "Tikam_Gupta",
                        "content": "class Solution{\\npublic:\\n    int maxProfit(vector<int>& prices){\\n        int profit= 0;\\n        for(int i = 0; i<prices.size()-1; i++){\\n            for(int j= i+1; j<prices.size(); j++){\\n                int ans= prices[j] - prices[i];\\n                profit = max(ans, profit);\\n            }\\n        }\\n        return profit;\\n    }\\n\\n};\\n\\nWhy is it showing time limit exceeded?"
                    },
                    {
                        "username": "maharahisoni",
                        "content": "CODE:\\n\\nint maxii=0;\\nclass Solution {\\npublic:\\n    int minimum(vector<int> arr,int size){\\n    if (size==0) return arr[0];\\n    int temp=min(arr[size-1],minimum(arr,size-1));\\n    maxii=max(maxii,arr[size]-temp);\\n    return temp;\\n} \\n    int maxProfit(vector<int> prices) {\\n      \\n       minimum(prices,prices.size()-1);\\n       int temp=maxii;\\n       maxii=0;\\n       return temp;\\n    }\\n};\\n\\nThis code stucks at TC no 198 in  MEMORY LIMIT EXCEED why??"
                    },
                    {
                        "username": "johngjackson0",
                        "content": "There is a much easier way to do this than Sliding Window or Dynamic programming! Instead it would be \"Greedy Algorithm.\" It\\'s a way to say, in the present make the \"best choice.\" \\n\\n1. Since you cannot go in the past, it\\'s not a simple min vs max of nums. i.e. your min number cannot be compared to a max number before it. \\n2. You just calculate the optimal choice in the present."
                    },
                    {
                        "username": "uddiptapathak729",
                        "content": "how can a stock be bought at zero lol"
                    },
                    {
                        "username": "Mr_Jobs",
                        "content": "Time & Space: O(n) & O(1)\\n1. Use two variables to keep track of max_profit and max_price\\n2. Traverse from the end\\n3. If encounter a price that is greater than max_price, update max_price\\n4. Else, calculate profit and update max_profit if profit is greater than max_profit"
                    },
                    {
                        "username": "JeremyAnderson8",
                        "content": "This keeps getting the \"Time Limit Exceeded\" error on the 200th test case. Can anyone please offer some guidance on what I am doing wrong or what I should do to make it work? I am only using one loop\n\nmax_profit = 0\n        for i in range(len(prices)):\n            if i != len(prices)-1:\n                temp_max = max(prices[i+1:len(prices)]) - prices[i]\n                if temp_max > max_profit:\n                    max_profit = temp_max\n        return max_profit"
                    },
                    {
                        "username": "luizhenriquemaia",
                        "content": "Nice one, it's impossible to writing the solution with python, because of runtime, thanks alot leetcode for -1 hour of my life for nothing :)"
                    },
                    {
                        "username": "JeremyAnderson8",
                        "content": "fr, doesn\\'t work with my single for loop. don\\'t know what else to do "
                    },
                    {
                        "username": "chazwinter",
                        "content": "We should be able to flag/report bad solutions. The \"top\" solutions just hard code the answers for the large test cases  to appear faster. That\\'s really lame, and I see it as cheating. We\\'re here to learn, not cheat."
                    },
                    {
                        "username": "prasumitmishra",
                        "content": "for [1, 2, 4], the expected answer is 3. Not sure How?\nYou can do a Buy + Buy + Sell, which means -1 -2 + (2*4) = 5 is your profit. Not sure how come is the expected answer 3?\n\nMy approach includes continue buying till you find max on your right.\nEg.\n\n[1, 3, 5, 3, 1, 2]\nMax is 5 (So sale should happen here)\n[1 (Buy) 3(Buy) 5 (Sell)] [3,  1,  2]\n\nRepeat same with [3, 1, 2] : (if present rate is greater than max on right, skip: don't buy don't sell), i.e. [3(hold) 1 (Buy), 2 (Sell)]\n\n-1 -3 +5*2 + 0 -1  + 2\n= 7.\n\n"
                    },
                    {
                        "username": "bparanj",
                        "content": "This is a single transaction only problem."
                    }
                ]
            },
            {
                "id": 1939930,
                "content": [
                    {
                        "username": "abmath113",
                        "content": "I don\\'t get it, how does this problem is sliding window."
                    },
                    {
                        "username": "Tikam_Gupta",
                        "content": "class Solution{\\npublic:\\n    int maxProfit(vector<int>& prices){\\n        int profit= 0;\\n        for(int i = 0; i<prices.size()-1; i++){\\n            for(int j= i+1; j<prices.size(); j++){\\n                int ans= prices[j] - prices[i];\\n                profit = max(ans, profit);\\n            }\\n        }\\n        return profit;\\n    }\\n\\n};\\n\\nWhy is it showing time limit exceeded?"
                    },
                    {
                        "username": "maharahisoni",
                        "content": "CODE:\\n\\nint maxii=0;\\nclass Solution {\\npublic:\\n    int minimum(vector<int> arr,int size){\\n    if (size==0) return arr[0];\\n    int temp=min(arr[size-1],minimum(arr,size-1));\\n    maxii=max(maxii,arr[size]-temp);\\n    return temp;\\n} \\n    int maxProfit(vector<int> prices) {\\n      \\n       minimum(prices,prices.size()-1);\\n       int temp=maxii;\\n       maxii=0;\\n       return temp;\\n    }\\n};\\n\\nThis code stucks at TC no 198 in  MEMORY LIMIT EXCEED why??"
                    },
                    {
                        "username": "johngjackson0",
                        "content": "There is a much easier way to do this than Sliding Window or Dynamic programming! Instead it would be \"Greedy Algorithm.\" It\\'s a way to say, in the present make the \"best choice.\" \\n\\n1. Since you cannot go in the past, it\\'s not a simple min vs max of nums. i.e. your min number cannot be compared to a max number before it. \\n2. You just calculate the optimal choice in the present."
                    },
                    {
                        "username": "uddiptapathak729",
                        "content": "how can a stock be bought at zero lol"
                    },
                    {
                        "username": "Mr_Jobs",
                        "content": "Time & Space: O(n) & O(1)\\n1. Use two variables to keep track of max_profit and max_price\\n2. Traverse from the end\\n3. If encounter a price that is greater than max_price, update max_price\\n4. Else, calculate profit and update max_profit if profit is greater than max_profit"
                    },
                    {
                        "username": "JeremyAnderson8",
                        "content": "This keeps getting the \"Time Limit Exceeded\" error on the 200th test case. Can anyone please offer some guidance on what I am doing wrong or what I should do to make it work? I am only using one loop\n\nmax_profit = 0\n        for i in range(len(prices)):\n            if i != len(prices)-1:\n                temp_max = max(prices[i+1:len(prices)]) - prices[i]\n                if temp_max > max_profit:\n                    max_profit = temp_max\n        return max_profit"
                    },
                    {
                        "username": "luizhenriquemaia",
                        "content": "Nice one, it's impossible to writing the solution with python, because of runtime, thanks alot leetcode for -1 hour of my life for nothing :)"
                    },
                    {
                        "username": "JeremyAnderson8",
                        "content": "fr, doesn\\'t work with my single for loop. don\\'t know what else to do "
                    },
                    {
                        "username": "chazwinter",
                        "content": "We should be able to flag/report bad solutions. The \"top\" solutions just hard code the answers for the large test cases  to appear faster. That\\'s really lame, and I see it as cheating. We\\'re here to learn, not cheat."
                    },
                    {
                        "username": "prasumitmishra",
                        "content": "for [1, 2, 4], the expected answer is 3. Not sure How?\nYou can do a Buy + Buy + Sell, which means -1 -2 + (2*4) = 5 is your profit. Not sure how come is the expected answer 3?\n\nMy approach includes continue buying till you find max on your right.\nEg.\n\n[1, 3, 5, 3, 1, 2]\nMax is 5 (So sale should happen here)\n[1 (Buy) 3(Buy) 5 (Sell)] [3,  1,  2]\n\nRepeat same with [3, 1, 2] : (if present rate is greater than max on right, skip: don't buy don't sell), i.e. [3(hold) 1 (Buy), 2 (Sell)]\n\n-1 -3 +5*2 + 0 -1  + 2\n= 7.\n\n"
                    },
                    {
                        "username": "bparanj",
                        "content": "This is a single transaction only problem."
                    }
                ]
            },
            {
                "id": 1935929,
                "content": [
                    {
                        "username": "anmolsankadiya",
                        "content": "can someone write dp relation for the recursion code below although it pass all the test \\n\\nclass Solution {\\npublic:\\n    int func(vector<int>& prices ,int i ,int e){\\n        if(i>=prices.size()) return 0;\\n        if(prices[i]>=e && e!=-1){\\n            return max(prices[i]-e , func(prices, i+1,e));\\n        }\\n        else return func(prices,i+1,prices[i]);\\n    }\\n    int maxProfit(vector<int>& prices) {\\n        return func(prices,0,-1);\\n    }\\n};\\n\\n"
                    },
                    {
                        "username": "gribeiro5000",
                        "content": "In testCase:\\nprices = [7, 1, 5, 3, 6, 4]\\nOutput = 5\\nExpected = 5\\nOK\\n\\nAfter i submited my code:\\nprices = [1, 2]\\nOutput = 2\\nExpected = 1"
                    },
                    {
                        "username": "gribeiro5000",
                        "content": "[@ashim_raibs](/ashim_raibs) You are right! Thank you! "
                    },
                    {
                        "username": "ashim_raibs",
                        "content": "you\\'re not supposed to return day, you have to return max profit"
                    },
                    {
                        "username": "dhanushhg",
                        "content": "Hey, i just need a small help, while i code this in VScode, it works, the same code i put it here and i\\'m constantly failing the test case 2, can anyone help me, what i am wrong with at? my code\\nclass Solution {\\n    static int profit=0;\\n    static int main_profit=0;\\n     public static int maxProfit(int[] prices) {\\n      for(int i=0;i<prices.length;i++){\\n        for(int j=i+1;j<prices.length;j++){\\n           main_profit= prices[j]-prices[i];\\n        //   System.out.println(main_profit);\\n            if(profit<main_profit){\\n        profit=main_profit;\\n       }      \\n        }\\n      }              \\n      if(profit<=0){\\n        profit= 0;\\n       }\\n     return profit;\\n} }\\n"
                    },
                    {
                        "username": "bparanj",
                        "content": "The reason you might be failing the second test case could be due to the static variables `profit` and `main_profit`. These variables maintain their values across multiple calls to the function `maxProfit`. If the function is being called more than once (as in the test environment of many online coding platforms), the old values of `profit` and `main_profit` could interfere with the calculations of subsequent calls, leading to incorrect results.\\n\\nHere\\'s your code, adjusted to remove the static variables:\\n\\n```java\\nclass Solution {\\n    public int maxProfit(int[] prices) {\\n        int profit = 0;\\n        int main_profit = 0;\\n\\n        for (int i = 0; i < prices.length; i++) {\\n            for (int j = i + 1; j < prices.length; j++) {\\n                main_profit = prices[j] - prices[i];\\n\\n                if (profit < main_profit) {\\n                    profit = main_profit;\\n                }\\n            }\\n        }\\n\\n        if (profit <= 0) {\\n            profit = 0;\\n        }\\n\\n        return profit;\\n    }\\n}\\n```\\n\\nPlease note that the inner for-loop in your implementation leads to a time complexity of O(n^2) which might cause a timeout for large inputs. A more efficient approach would be to keep track of the minimum price and the maximum profit during a single pass through the array.\\n\\nHere\\'s an efficient solution with O(n) complexity:\\n\\n```java\\nclass Solution {\\n    public int maxProfit(int[] prices) {\\n        int minPrice = Integer.MAX_VALUE;\\n        int maxProfit = 0;\\n        \\n        for (int i = 0; i < prices.length; i++) {\\n            if (prices[i] < minPrice) {\\n                minPrice = prices[i];\\n            } else if (prices[i] - minPrice > maxProfit) {\\n                maxProfit = prices[i] - minPrice;\\n            }\\n        }\\n        \\n        return maxProfit;\\n    }\\n}\\n```"
                    },
                    {
                        "username": "harishini45",
                        "content": "time limit exceeded yaar failed at 202 "
                    },
                    {
                        "username": "mdsang_97",
                        "content": "[1,2]\\noutput:2\\nexpected:1\\n?"
                    },
                    {
                        "username": "ashim_raibs",
                        "content": "1 is the maxProfit, not the day/index, I got confused too "
                    },
                    {
                        "username": "_DarKReapper_",
                        "content": "class Solution {\\n    vector<vector<int>> t;\\npublic:\\n    int maxProfit(vector<int>& prices) \\n    {\\n        int n = prices.size();\\n        t.resize(n + 1, vector<int>(2,-1));\\n        return rec(prices.size(),1,prices);       \\n    }\\n    int rec(int n,int s,vector<int>& nums )\\n    {\\n        if(n <= 0) return 0;\\n        \\n        if(t[n][s] != -1) return t[n][s]; \\n        if(s)\\n        {\\n            return t[n][s] = max(nums[n - 1] + rec(n -1, 0,nums),rec(n -1,s,nums));\\n        }\\n        else \\n        {\\n            return t[n][s] = max(rec(n -1,s,nums), -nums[n - 1] );\\n        }\\n    }\\n};\\n\\n-- why is this code not working and how to correct it?"
                    },
                    {
                        "username": "bparanj",
                        "content": "Your current approach seems to be trying to solve a slightly different problem. In the problem statement, you are asked to find the maximum profit with at most one transaction (buy one and sell one share of the stock). The solution you provided seems to be trying to solve a problem where you can buy and sell as many times as you want.\\n\\nHowever, your recursive function call seems to be a bit off. In the case where you\\'re not holding a stock (`s == 0`), you\\'re not subtracting from `rec(n - 1, 1, nums)` in the return statement, so it effectively ends up ignoring the buying operation and the cost associated with it.\\n\\nA simpler and more efficient approach would be as follows:\\n\\n```cpp\\nclass Solution {\\npublic:\\n    int maxProfit(vector<int>& prices) {\\n        int minPrice = INT_MAX;\\n        int maxProfit = 0;\\n        for(int i=0; i<prices.size(); i++) {\\n            minPrice = min(minPrice, prices[i]);\\n            maxProfit = max(maxProfit, prices[i] - minPrice);\\n        }\\n        return maxProfit;\\n    }\\n};\\n```\\n\\nThis solution works in O(n) time complexity and doesn\\'t require additional space like a DP solution. It keeps track of the minimum price we\\'ve seen so far and the maximum profit we can get from selling at the current price."
                    },
                    {
                        "username": "ssalinasfe",
                        "content": "I cannot solve this problems due to time limitex exceed. It is impossible due to one of the test case is a enormous array of input of 31915 elements,, and I get time limit exceeded only for traverse the array."
                    },
                    {
                        "username": "akarshannigam123",
                        "content": "The compiler has some problem with it as it is not performing appropriately and it is giving error while other compiler are giving correct output"
                    },
                    {
                        "username": "dynamic099",
                        "content": " int maxProfit(vector<int>& prices) {\\n        int mini = INT_MAX;\\n        int minIndex = 0;\\n        int buy ;\\n        int profit ;\\n        int i ; \\n        int n = prices.size();\\n        if(n==0||n==1)\\n        return 0 ;\\n        cout << n ;\\n        for (i = 0 ; i < prices.size() ; i++)\\n        {\\n            \\n            if(prices[i]<mini)\\n            {\\n                mini = prices[i];\\n                minIndex=i;\\n            }\\n            // cout<<\"The value of minIndex is \"<<minIndex;   \\n        }\\n        if(minIndex < n )\\n        {\\n            int max = prices[mini];\\n            for(int i=mini ; i < prices.size();i ++)\\n            {\\n                if(prices[i]>max)\\n                max=prices[i];\\n            }\\n            buy=prices[mini];\\n            profit=max-buy;\\n            return profit ;\\n        }\\n        else\\n        return 0 ;\\n    }\\n\\nWhy is this solution not working for the test case [1,2]"
                    },
                    {
                        "username": "bparanj",
                        "content": "Your current implementation has some logical and syntax errors. Here are some of the reasons why your solution might fail for the test case [1,2]:\\n\\n1. You have initialized `mini` as INT_MAX and then `max` as prices[mini]. This can be problematic because `mini` is the minimum value from the integer range, not the index. It looks like you\\'ve confused the variable `mini` (which is meant to store the minimum price) with `minIndex` (which is meant to store the index of the minimum price). So in the line where you have `int max = prices[mini];`, you should actually have `int max = prices[minIndex];`.\\n\\n2. Your check `if(minIndex < n )` doesn\\'t make sense because `minIndex` will always be less than `n` (which is prices.size()). This if block will always be true and is therefore not needed.\\n\\n3. In the for loop, you\\'ve used `mini` as the start index, but it should be `minIndex`. The loop should start from `minIndex`, not from `mini`.\\n\\nA corrected version of your function could look something like this:\\n\\n```cpp\\nint maxProfit(vector<int>& prices) {\\n    int mini = INT_MAX;\\n    int minIndex = 0;\\n    int n = prices.size();\\n\\n    if(n < 2)\\n        return 0;\\n\\n    // Find the minimum price and its index\\n    for (int i = 0 ; i < n ; i++) {\\n        if(prices[i] < mini) {\\n            mini = prices[i];\\n            minIndex = i;\\n        }\\n    }\\n\\n    // Find the maximum price after the minimum price\\n    int maxPrice = prices[minIndex];\\n    for(int i = minIndex ; i < n; i++) {\\n        if(prices[i] > maxPrice)\\n            maxPrice = prices[i];\\n    }\\n\\n    return maxPrice - mini;\\n}\\n```\\n\\nThis should now work correctly for the input [1,2]. However, this still has a linear time complexity and can be improved to a constant time complexity by keeping track of the minimum price and maximum profit simultaneously:\\n\\n```cpp\\nint maxProfit(vector<int>& prices) {\\n    int minPrice = INT_MAX;\\n    int maxProfit = 0;\\n\\n    for(int i = 0; i < prices.size(); i++) {\\n        if(prices[i] < minPrice) {\\n            minPrice = prices[i];\\n        } else if(prices[i] - minPrice > maxProfit) {\\n            maxProfit = prices[i] - minPrice;\\n        }\\n    }\\n\\n    return maxProfit;\\n}\\n```"
                    },
                    {
                        "username": "teenel",
                        "content": "I dont understand what\\'s wrong with last test? (211)\\nIt\\'s write `Time Limit Exceeded`\\nLast Executed Input `prices = ` (There is nothing, no zero, no digits). I make check for `null`, but it isn\\'t help.\\nAnd also there no output and excepted values"
                    }
                ]
            },
            {
                "id": 1933542,
                "content": [
                    {
                        "username": "anmolsankadiya",
                        "content": "can someone write dp relation for the recursion code below although it pass all the test \\n\\nclass Solution {\\npublic:\\n    int func(vector<int>& prices ,int i ,int e){\\n        if(i>=prices.size()) return 0;\\n        if(prices[i]>=e && e!=-1){\\n            return max(prices[i]-e , func(prices, i+1,e));\\n        }\\n        else return func(prices,i+1,prices[i]);\\n    }\\n    int maxProfit(vector<int>& prices) {\\n        return func(prices,0,-1);\\n    }\\n};\\n\\n"
                    },
                    {
                        "username": "gribeiro5000",
                        "content": "In testCase:\\nprices = [7, 1, 5, 3, 6, 4]\\nOutput = 5\\nExpected = 5\\nOK\\n\\nAfter i submited my code:\\nprices = [1, 2]\\nOutput = 2\\nExpected = 1"
                    },
                    {
                        "username": "gribeiro5000",
                        "content": "[@ashim_raibs](/ashim_raibs) You are right! Thank you! "
                    },
                    {
                        "username": "ashim_raibs",
                        "content": "you\\'re not supposed to return day, you have to return max profit"
                    },
                    {
                        "username": "dhanushhg",
                        "content": "Hey, i just need a small help, while i code this in VScode, it works, the same code i put it here and i\\'m constantly failing the test case 2, can anyone help me, what i am wrong with at? my code\\nclass Solution {\\n    static int profit=0;\\n    static int main_profit=0;\\n     public static int maxProfit(int[] prices) {\\n      for(int i=0;i<prices.length;i++){\\n        for(int j=i+1;j<prices.length;j++){\\n           main_profit= prices[j]-prices[i];\\n        //   System.out.println(main_profit);\\n            if(profit<main_profit){\\n        profit=main_profit;\\n       }      \\n        }\\n      }              \\n      if(profit<=0){\\n        profit= 0;\\n       }\\n     return profit;\\n} }\\n"
                    },
                    {
                        "username": "bparanj",
                        "content": "The reason you might be failing the second test case could be due to the static variables `profit` and `main_profit`. These variables maintain their values across multiple calls to the function `maxProfit`. If the function is being called more than once (as in the test environment of many online coding platforms), the old values of `profit` and `main_profit` could interfere with the calculations of subsequent calls, leading to incorrect results.\\n\\nHere\\'s your code, adjusted to remove the static variables:\\n\\n```java\\nclass Solution {\\n    public int maxProfit(int[] prices) {\\n        int profit = 0;\\n        int main_profit = 0;\\n\\n        for (int i = 0; i < prices.length; i++) {\\n            for (int j = i + 1; j < prices.length; j++) {\\n                main_profit = prices[j] - prices[i];\\n\\n                if (profit < main_profit) {\\n                    profit = main_profit;\\n                }\\n            }\\n        }\\n\\n        if (profit <= 0) {\\n            profit = 0;\\n        }\\n\\n        return profit;\\n    }\\n}\\n```\\n\\nPlease note that the inner for-loop in your implementation leads to a time complexity of O(n^2) which might cause a timeout for large inputs. A more efficient approach would be to keep track of the minimum price and the maximum profit during a single pass through the array.\\n\\nHere\\'s an efficient solution with O(n) complexity:\\n\\n```java\\nclass Solution {\\n    public int maxProfit(int[] prices) {\\n        int minPrice = Integer.MAX_VALUE;\\n        int maxProfit = 0;\\n        \\n        for (int i = 0; i < prices.length; i++) {\\n            if (prices[i] < minPrice) {\\n                minPrice = prices[i];\\n            } else if (prices[i] - minPrice > maxProfit) {\\n                maxProfit = prices[i] - minPrice;\\n            }\\n        }\\n        \\n        return maxProfit;\\n    }\\n}\\n```"
                    },
                    {
                        "username": "harishini45",
                        "content": "time limit exceeded yaar failed at 202 "
                    },
                    {
                        "username": "mdsang_97",
                        "content": "[1,2]\\noutput:2\\nexpected:1\\n?"
                    },
                    {
                        "username": "ashim_raibs",
                        "content": "1 is the maxProfit, not the day/index, I got confused too "
                    },
                    {
                        "username": "_DarKReapper_",
                        "content": "class Solution {\\n    vector<vector<int>> t;\\npublic:\\n    int maxProfit(vector<int>& prices) \\n    {\\n        int n = prices.size();\\n        t.resize(n + 1, vector<int>(2,-1));\\n        return rec(prices.size(),1,prices);       \\n    }\\n    int rec(int n,int s,vector<int>& nums )\\n    {\\n        if(n <= 0) return 0;\\n        \\n        if(t[n][s] != -1) return t[n][s]; \\n        if(s)\\n        {\\n            return t[n][s] = max(nums[n - 1] + rec(n -1, 0,nums),rec(n -1,s,nums));\\n        }\\n        else \\n        {\\n            return t[n][s] = max(rec(n -1,s,nums), -nums[n - 1] );\\n        }\\n    }\\n};\\n\\n-- why is this code not working and how to correct it?"
                    },
                    {
                        "username": "bparanj",
                        "content": "Your current approach seems to be trying to solve a slightly different problem. In the problem statement, you are asked to find the maximum profit with at most one transaction (buy one and sell one share of the stock). The solution you provided seems to be trying to solve a problem where you can buy and sell as many times as you want.\\n\\nHowever, your recursive function call seems to be a bit off. In the case where you\\'re not holding a stock (`s == 0`), you\\'re not subtracting from `rec(n - 1, 1, nums)` in the return statement, so it effectively ends up ignoring the buying operation and the cost associated with it.\\n\\nA simpler and more efficient approach would be as follows:\\n\\n```cpp\\nclass Solution {\\npublic:\\n    int maxProfit(vector<int>& prices) {\\n        int minPrice = INT_MAX;\\n        int maxProfit = 0;\\n        for(int i=0; i<prices.size(); i++) {\\n            minPrice = min(minPrice, prices[i]);\\n            maxProfit = max(maxProfit, prices[i] - minPrice);\\n        }\\n        return maxProfit;\\n    }\\n};\\n```\\n\\nThis solution works in O(n) time complexity and doesn\\'t require additional space like a DP solution. It keeps track of the minimum price we\\'ve seen so far and the maximum profit we can get from selling at the current price."
                    },
                    {
                        "username": "ssalinasfe",
                        "content": "I cannot solve this problems due to time limitex exceed. It is impossible due to one of the test case is a enormous array of input of 31915 elements,, and I get time limit exceeded only for traverse the array."
                    },
                    {
                        "username": "akarshannigam123",
                        "content": "The compiler has some problem with it as it is not performing appropriately and it is giving error while other compiler are giving correct output"
                    },
                    {
                        "username": "dynamic099",
                        "content": " int maxProfit(vector<int>& prices) {\\n        int mini = INT_MAX;\\n        int minIndex = 0;\\n        int buy ;\\n        int profit ;\\n        int i ; \\n        int n = prices.size();\\n        if(n==0||n==1)\\n        return 0 ;\\n        cout << n ;\\n        for (i = 0 ; i < prices.size() ; i++)\\n        {\\n            \\n            if(prices[i]<mini)\\n            {\\n                mini = prices[i];\\n                minIndex=i;\\n            }\\n            // cout<<\"The value of minIndex is \"<<minIndex;   \\n        }\\n        if(minIndex < n )\\n        {\\n            int max = prices[mini];\\n            for(int i=mini ; i < prices.size();i ++)\\n            {\\n                if(prices[i]>max)\\n                max=prices[i];\\n            }\\n            buy=prices[mini];\\n            profit=max-buy;\\n            return profit ;\\n        }\\n        else\\n        return 0 ;\\n    }\\n\\nWhy is this solution not working for the test case [1,2]"
                    },
                    {
                        "username": "bparanj",
                        "content": "Your current implementation has some logical and syntax errors. Here are some of the reasons why your solution might fail for the test case [1,2]:\\n\\n1. You have initialized `mini` as INT_MAX and then `max` as prices[mini]. This can be problematic because `mini` is the minimum value from the integer range, not the index. It looks like you\\'ve confused the variable `mini` (which is meant to store the minimum price) with `minIndex` (which is meant to store the index of the minimum price). So in the line where you have `int max = prices[mini];`, you should actually have `int max = prices[minIndex];`.\\n\\n2. Your check `if(minIndex < n )` doesn\\'t make sense because `minIndex` will always be less than `n` (which is prices.size()). This if block will always be true and is therefore not needed.\\n\\n3. In the for loop, you\\'ve used `mini` as the start index, but it should be `minIndex`. The loop should start from `minIndex`, not from `mini`.\\n\\nA corrected version of your function could look something like this:\\n\\n```cpp\\nint maxProfit(vector<int>& prices) {\\n    int mini = INT_MAX;\\n    int minIndex = 0;\\n    int n = prices.size();\\n\\n    if(n < 2)\\n        return 0;\\n\\n    // Find the minimum price and its index\\n    for (int i = 0 ; i < n ; i++) {\\n        if(prices[i] < mini) {\\n            mini = prices[i];\\n            minIndex = i;\\n        }\\n    }\\n\\n    // Find the maximum price after the minimum price\\n    int maxPrice = prices[minIndex];\\n    for(int i = minIndex ; i < n; i++) {\\n        if(prices[i] > maxPrice)\\n            maxPrice = prices[i];\\n    }\\n\\n    return maxPrice - mini;\\n}\\n```\\n\\nThis should now work correctly for the input [1,2]. However, this still has a linear time complexity and can be improved to a constant time complexity by keeping track of the minimum price and maximum profit simultaneously:\\n\\n```cpp\\nint maxProfit(vector<int>& prices) {\\n    int minPrice = INT_MAX;\\n    int maxProfit = 0;\\n\\n    for(int i = 0; i < prices.size(); i++) {\\n        if(prices[i] < minPrice) {\\n            minPrice = prices[i];\\n        } else if(prices[i] - minPrice > maxProfit) {\\n            maxProfit = prices[i] - minPrice;\\n        }\\n    }\\n\\n    return maxProfit;\\n}\\n```"
                    },
                    {
                        "username": "teenel",
                        "content": "I dont understand what\\'s wrong with last test? (211)\\nIt\\'s write `Time Limit Exceeded`\\nLast Executed Input `prices = ` (There is nothing, no zero, no digits). I make check for `null`, but it isn\\'t help.\\nAnd also there no output and excepted values"
                    }
                ]
            },
            {
                "id": 1933269,
                "content": [
                    {
                        "username": "anmolsankadiya",
                        "content": "can someone write dp relation for the recursion code below although it pass all the test \\n\\nclass Solution {\\npublic:\\n    int func(vector<int>& prices ,int i ,int e){\\n        if(i>=prices.size()) return 0;\\n        if(prices[i]>=e && e!=-1){\\n            return max(prices[i]-e , func(prices, i+1,e));\\n        }\\n        else return func(prices,i+1,prices[i]);\\n    }\\n    int maxProfit(vector<int>& prices) {\\n        return func(prices,0,-1);\\n    }\\n};\\n\\n"
                    },
                    {
                        "username": "gribeiro5000",
                        "content": "In testCase:\\nprices = [7, 1, 5, 3, 6, 4]\\nOutput = 5\\nExpected = 5\\nOK\\n\\nAfter i submited my code:\\nprices = [1, 2]\\nOutput = 2\\nExpected = 1"
                    },
                    {
                        "username": "gribeiro5000",
                        "content": "[@ashim_raibs](/ashim_raibs) You are right! Thank you! "
                    },
                    {
                        "username": "ashim_raibs",
                        "content": "you\\'re not supposed to return day, you have to return max profit"
                    },
                    {
                        "username": "dhanushhg",
                        "content": "Hey, i just need a small help, while i code this in VScode, it works, the same code i put it here and i\\'m constantly failing the test case 2, can anyone help me, what i am wrong with at? my code\\nclass Solution {\\n    static int profit=0;\\n    static int main_profit=0;\\n     public static int maxProfit(int[] prices) {\\n      for(int i=0;i<prices.length;i++){\\n        for(int j=i+1;j<prices.length;j++){\\n           main_profit= prices[j]-prices[i];\\n        //   System.out.println(main_profit);\\n            if(profit<main_profit){\\n        profit=main_profit;\\n       }      \\n        }\\n      }              \\n      if(profit<=0){\\n        profit= 0;\\n       }\\n     return profit;\\n} }\\n"
                    },
                    {
                        "username": "bparanj",
                        "content": "The reason you might be failing the second test case could be due to the static variables `profit` and `main_profit`. These variables maintain their values across multiple calls to the function `maxProfit`. If the function is being called more than once (as in the test environment of many online coding platforms), the old values of `profit` and `main_profit` could interfere with the calculations of subsequent calls, leading to incorrect results.\\n\\nHere\\'s your code, adjusted to remove the static variables:\\n\\n```java\\nclass Solution {\\n    public int maxProfit(int[] prices) {\\n        int profit = 0;\\n        int main_profit = 0;\\n\\n        for (int i = 0; i < prices.length; i++) {\\n            for (int j = i + 1; j < prices.length; j++) {\\n                main_profit = prices[j] - prices[i];\\n\\n                if (profit < main_profit) {\\n                    profit = main_profit;\\n                }\\n            }\\n        }\\n\\n        if (profit <= 0) {\\n            profit = 0;\\n        }\\n\\n        return profit;\\n    }\\n}\\n```\\n\\nPlease note that the inner for-loop in your implementation leads to a time complexity of O(n^2) which might cause a timeout for large inputs. A more efficient approach would be to keep track of the minimum price and the maximum profit during a single pass through the array.\\n\\nHere\\'s an efficient solution with O(n) complexity:\\n\\n```java\\nclass Solution {\\n    public int maxProfit(int[] prices) {\\n        int minPrice = Integer.MAX_VALUE;\\n        int maxProfit = 0;\\n        \\n        for (int i = 0; i < prices.length; i++) {\\n            if (prices[i] < minPrice) {\\n                minPrice = prices[i];\\n            } else if (prices[i] - minPrice > maxProfit) {\\n                maxProfit = prices[i] - minPrice;\\n            }\\n        }\\n        \\n        return maxProfit;\\n    }\\n}\\n```"
                    },
                    {
                        "username": "harishini45",
                        "content": "time limit exceeded yaar failed at 202 "
                    },
                    {
                        "username": "mdsang_97",
                        "content": "[1,2]\\noutput:2\\nexpected:1\\n?"
                    },
                    {
                        "username": "ashim_raibs",
                        "content": "1 is the maxProfit, not the day/index, I got confused too "
                    },
                    {
                        "username": "_DarKReapper_",
                        "content": "class Solution {\\n    vector<vector<int>> t;\\npublic:\\n    int maxProfit(vector<int>& prices) \\n    {\\n        int n = prices.size();\\n        t.resize(n + 1, vector<int>(2,-1));\\n        return rec(prices.size(),1,prices);       \\n    }\\n    int rec(int n,int s,vector<int>& nums )\\n    {\\n        if(n <= 0) return 0;\\n        \\n        if(t[n][s] != -1) return t[n][s]; \\n        if(s)\\n        {\\n            return t[n][s] = max(nums[n - 1] + rec(n -1, 0,nums),rec(n -1,s,nums));\\n        }\\n        else \\n        {\\n            return t[n][s] = max(rec(n -1,s,nums), -nums[n - 1] );\\n        }\\n    }\\n};\\n\\n-- why is this code not working and how to correct it?"
                    },
                    {
                        "username": "bparanj",
                        "content": "Your current approach seems to be trying to solve a slightly different problem. In the problem statement, you are asked to find the maximum profit with at most one transaction (buy one and sell one share of the stock). The solution you provided seems to be trying to solve a problem where you can buy and sell as many times as you want.\\n\\nHowever, your recursive function call seems to be a bit off. In the case where you\\'re not holding a stock (`s == 0`), you\\'re not subtracting from `rec(n - 1, 1, nums)` in the return statement, so it effectively ends up ignoring the buying operation and the cost associated with it.\\n\\nA simpler and more efficient approach would be as follows:\\n\\n```cpp\\nclass Solution {\\npublic:\\n    int maxProfit(vector<int>& prices) {\\n        int minPrice = INT_MAX;\\n        int maxProfit = 0;\\n        for(int i=0; i<prices.size(); i++) {\\n            minPrice = min(minPrice, prices[i]);\\n            maxProfit = max(maxProfit, prices[i] - minPrice);\\n        }\\n        return maxProfit;\\n    }\\n};\\n```\\n\\nThis solution works in O(n) time complexity and doesn\\'t require additional space like a DP solution. It keeps track of the minimum price we\\'ve seen so far and the maximum profit we can get from selling at the current price."
                    },
                    {
                        "username": "ssalinasfe",
                        "content": "I cannot solve this problems due to time limitex exceed. It is impossible due to one of the test case is a enormous array of input of 31915 elements,, and I get time limit exceeded only for traverse the array."
                    },
                    {
                        "username": "akarshannigam123",
                        "content": "The compiler has some problem with it as it is not performing appropriately and it is giving error while other compiler are giving correct output"
                    },
                    {
                        "username": "dynamic099",
                        "content": " int maxProfit(vector<int>& prices) {\\n        int mini = INT_MAX;\\n        int minIndex = 0;\\n        int buy ;\\n        int profit ;\\n        int i ; \\n        int n = prices.size();\\n        if(n==0||n==1)\\n        return 0 ;\\n        cout << n ;\\n        for (i = 0 ; i < prices.size() ; i++)\\n        {\\n            \\n            if(prices[i]<mini)\\n            {\\n                mini = prices[i];\\n                minIndex=i;\\n            }\\n            // cout<<\"The value of minIndex is \"<<minIndex;   \\n        }\\n        if(minIndex < n )\\n        {\\n            int max = prices[mini];\\n            for(int i=mini ; i < prices.size();i ++)\\n            {\\n                if(prices[i]>max)\\n                max=prices[i];\\n            }\\n            buy=prices[mini];\\n            profit=max-buy;\\n            return profit ;\\n        }\\n        else\\n        return 0 ;\\n    }\\n\\nWhy is this solution not working for the test case [1,2]"
                    },
                    {
                        "username": "bparanj",
                        "content": "Your current implementation has some logical and syntax errors. Here are some of the reasons why your solution might fail for the test case [1,2]:\\n\\n1. You have initialized `mini` as INT_MAX and then `max` as prices[mini]. This can be problematic because `mini` is the minimum value from the integer range, not the index. It looks like you\\'ve confused the variable `mini` (which is meant to store the minimum price) with `minIndex` (which is meant to store the index of the minimum price). So in the line where you have `int max = prices[mini];`, you should actually have `int max = prices[minIndex];`.\\n\\n2. Your check `if(minIndex < n )` doesn\\'t make sense because `minIndex` will always be less than `n` (which is prices.size()). This if block will always be true and is therefore not needed.\\n\\n3. In the for loop, you\\'ve used `mini` as the start index, but it should be `minIndex`. The loop should start from `minIndex`, not from `mini`.\\n\\nA corrected version of your function could look something like this:\\n\\n```cpp\\nint maxProfit(vector<int>& prices) {\\n    int mini = INT_MAX;\\n    int minIndex = 0;\\n    int n = prices.size();\\n\\n    if(n < 2)\\n        return 0;\\n\\n    // Find the minimum price and its index\\n    for (int i = 0 ; i < n ; i++) {\\n        if(prices[i] < mini) {\\n            mini = prices[i];\\n            minIndex = i;\\n        }\\n    }\\n\\n    // Find the maximum price after the minimum price\\n    int maxPrice = prices[minIndex];\\n    for(int i = minIndex ; i < n; i++) {\\n        if(prices[i] > maxPrice)\\n            maxPrice = prices[i];\\n    }\\n\\n    return maxPrice - mini;\\n}\\n```\\n\\nThis should now work correctly for the input [1,2]. However, this still has a linear time complexity and can be improved to a constant time complexity by keeping track of the minimum price and maximum profit simultaneously:\\n\\n```cpp\\nint maxProfit(vector<int>& prices) {\\n    int minPrice = INT_MAX;\\n    int maxProfit = 0;\\n\\n    for(int i = 0; i < prices.size(); i++) {\\n        if(prices[i] < minPrice) {\\n            minPrice = prices[i];\\n        } else if(prices[i] - minPrice > maxProfit) {\\n            maxProfit = prices[i] - minPrice;\\n        }\\n    }\\n\\n    return maxProfit;\\n}\\n```"
                    },
                    {
                        "username": "teenel",
                        "content": "I dont understand what\\'s wrong with last test? (211)\\nIt\\'s write `Time Limit Exceeded`\\nLast Executed Input `prices = ` (There is nothing, no zero, no digits). I make check for `null`, but it isn\\'t help.\\nAnd also there no output and excepted values"
                    }
                ]
            },
            {
                "id": 1933183,
                "content": [
                    {
                        "username": "anmolsankadiya",
                        "content": "can someone write dp relation for the recursion code below although it pass all the test \\n\\nclass Solution {\\npublic:\\n    int func(vector<int>& prices ,int i ,int e){\\n        if(i>=prices.size()) return 0;\\n        if(prices[i]>=e && e!=-1){\\n            return max(prices[i]-e , func(prices, i+1,e));\\n        }\\n        else return func(prices,i+1,prices[i]);\\n    }\\n    int maxProfit(vector<int>& prices) {\\n        return func(prices,0,-1);\\n    }\\n};\\n\\n"
                    },
                    {
                        "username": "gribeiro5000",
                        "content": "In testCase:\\nprices = [7, 1, 5, 3, 6, 4]\\nOutput = 5\\nExpected = 5\\nOK\\n\\nAfter i submited my code:\\nprices = [1, 2]\\nOutput = 2\\nExpected = 1"
                    },
                    {
                        "username": "gribeiro5000",
                        "content": "[@ashim_raibs](/ashim_raibs) You are right! Thank you! "
                    },
                    {
                        "username": "ashim_raibs",
                        "content": "you\\'re not supposed to return day, you have to return max profit"
                    },
                    {
                        "username": "dhanushhg",
                        "content": "Hey, i just need a small help, while i code this in VScode, it works, the same code i put it here and i\\'m constantly failing the test case 2, can anyone help me, what i am wrong with at? my code\\nclass Solution {\\n    static int profit=0;\\n    static int main_profit=0;\\n     public static int maxProfit(int[] prices) {\\n      for(int i=0;i<prices.length;i++){\\n        for(int j=i+1;j<prices.length;j++){\\n           main_profit= prices[j]-prices[i];\\n        //   System.out.println(main_profit);\\n            if(profit<main_profit){\\n        profit=main_profit;\\n       }      \\n        }\\n      }              \\n      if(profit<=0){\\n        profit= 0;\\n       }\\n     return profit;\\n} }\\n"
                    },
                    {
                        "username": "bparanj",
                        "content": "The reason you might be failing the second test case could be due to the static variables `profit` and `main_profit`. These variables maintain their values across multiple calls to the function `maxProfit`. If the function is being called more than once (as in the test environment of many online coding platforms), the old values of `profit` and `main_profit` could interfere with the calculations of subsequent calls, leading to incorrect results.\\n\\nHere\\'s your code, adjusted to remove the static variables:\\n\\n```java\\nclass Solution {\\n    public int maxProfit(int[] prices) {\\n        int profit = 0;\\n        int main_profit = 0;\\n\\n        for (int i = 0; i < prices.length; i++) {\\n            for (int j = i + 1; j < prices.length; j++) {\\n                main_profit = prices[j] - prices[i];\\n\\n                if (profit < main_profit) {\\n                    profit = main_profit;\\n                }\\n            }\\n        }\\n\\n        if (profit <= 0) {\\n            profit = 0;\\n        }\\n\\n        return profit;\\n    }\\n}\\n```\\n\\nPlease note that the inner for-loop in your implementation leads to a time complexity of O(n^2) which might cause a timeout for large inputs. A more efficient approach would be to keep track of the minimum price and the maximum profit during a single pass through the array.\\n\\nHere\\'s an efficient solution with O(n) complexity:\\n\\n```java\\nclass Solution {\\n    public int maxProfit(int[] prices) {\\n        int minPrice = Integer.MAX_VALUE;\\n        int maxProfit = 0;\\n        \\n        for (int i = 0; i < prices.length; i++) {\\n            if (prices[i] < minPrice) {\\n                minPrice = prices[i];\\n            } else if (prices[i] - minPrice > maxProfit) {\\n                maxProfit = prices[i] - minPrice;\\n            }\\n        }\\n        \\n        return maxProfit;\\n    }\\n}\\n```"
                    },
                    {
                        "username": "harishini45",
                        "content": "time limit exceeded yaar failed at 202 "
                    },
                    {
                        "username": "mdsang_97",
                        "content": "[1,2]\\noutput:2\\nexpected:1\\n?"
                    },
                    {
                        "username": "ashim_raibs",
                        "content": "1 is the maxProfit, not the day/index, I got confused too "
                    },
                    {
                        "username": "_DarKReapper_",
                        "content": "class Solution {\\n    vector<vector<int>> t;\\npublic:\\n    int maxProfit(vector<int>& prices) \\n    {\\n        int n = prices.size();\\n        t.resize(n + 1, vector<int>(2,-1));\\n        return rec(prices.size(),1,prices);       \\n    }\\n    int rec(int n,int s,vector<int>& nums )\\n    {\\n        if(n <= 0) return 0;\\n        \\n        if(t[n][s] != -1) return t[n][s]; \\n        if(s)\\n        {\\n            return t[n][s] = max(nums[n - 1] + rec(n -1, 0,nums),rec(n -1,s,nums));\\n        }\\n        else \\n        {\\n            return t[n][s] = max(rec(n -1,s,nums), -nums[n - 1] );\\n        }\\n    }\\n};\\n\\n-- why is this code not working and how to correct it?"
                    },
                    {
                        "username": "bparanj",
                        "content": "Your current approach seems to be trying to solve a slightly different problem. In the problem statement, you are asked to find the maximum profit with at most one transaction (buy one and sell one share of the stock). The solution you provided seems to be trying to solve a problem where you can buy and sell as many times as you want.\\n\\nHowever, your recursive function call seems to be a bit off. In the case where you\\'re not holding a stock (`s == 0`), you\\'re not subtracting from `rec(n - 1, 1, nums)` in the return statement, so it effectively ends up ignoring the buying operation and the cost associated with it.\\n\\nA simpler and more efficient approach would be as follows:\\n\\n```cpp\\nclass Solution {\\npublic:\\n    int maxProfit(vector<int>& prices) {\\n        int minPrice = INT_MAX;\\n        int maxProfit = 0;\\n        for(int i=0; i<prices.size(); i++) {\\n            minPrice = min(minPrice, prices[i]);\\n            maxProfit = max(maxProfit, prices[i] - minPrice);\\n        }\\n        return maxProfit;\\n    }\\n};\\n```\\n\\nThis solution works in O(n) time complexity and doesn\\'t require additional space like a DP solution. It keeps track of the minimum price we\\'ve seen so far and the maximum profit we can get from selling at the current price."
                    },
                    {
                        "username": "ssalinasfe",
                        "content": "I cannot solve this problems due to time limitex exceed. It is impossible due to one of the test case is a enormous array of input of 31915 elements,, and I get time limit exceeded only for traverse the array."
                    },
                    {
                        "username": "akarshannigam123",
                        "content": "The compiler has some problem with it as it is not performing appropriately and it is giving error while other compiler are giving correct output"
                    },
                    {
                        "username": "dynamic099",
                        "content": " int maxProfit(vector<int>& prices) {\\n        int mini = INT_MAX;\\n        int minIndex = 0;\\n        int buy ;\\n        int profit ;\\n        int i ; \\n        int n = prices.size();\\n        if(n==0||n==1)\\n        return 0 ;\\n        cout << n ;\\n        for (i = 0 ; i < prices.size() ; i++)\\n        {\\n            \\n            if(prices[i]<mini)\\n            {\\n                mini = prices[i];\\n                minIndex=i;\\n            }\\n            // cout<<\"The value of minIndex is \"<<minIndex;   \\n        }\\n        if(minIndex < n )\\n        {\\n            int max = prices[mini];\\n            for(int i=mini ; i < prices.size();i ++)\\n            {\\n                if(prices[i]>max)\\n                max=prices[i];\\n            }\\n            buy=prices[mini];\\n            profit=max-buy;\\n            return profit ;\\n        }\\n        else\\n        return 0 ;\\n    }\\n\\nWhy is this solution not working for the test case [1,2]"
                    },
                    {
                        "username": "bparanj",
                        "content": "Your current implementation has some logical and syntax errors. Here are some of the reasons why your solution might fail for the test case [1,2]:\\n\\n1. You have initialized `mini` as INT_MAX and then `max` as prices[mini]. This can be problematic because `mini` is the minimum value from the integer range, not the index. It looks like you\\'ve confused the variable `mini` (which is meant to store the minimum price) with `minIndex` (which is meant to store the index of the minimum price). So in the line where you have `int max = prices[mini];`, you should actually have `int max = prices[minIndex];`.\\n\\n2. Your check `if(minIndex < n )` doesn\\'t make sense because `minIndex` will always be less than `n` (which is prices.size()). This if block will always be true and is therefore not needed.\\n\\n3. In the for loop, you\\'ve used `mini` as the start index, but it should be `minIndex`. The loop should start from `minIndex`, not from `mini`.\\n\\nA corrected version of your function could look something like this:\\n\\n```cpp\\nint maxProfit(vector<int>& prices) {\\n    int mini = INT_MAX;\\n    int minIndex = 0;\\n    int n = prices.size();\\n\\n    if(n < 2)\\n        return 0;\\n\\n    // Find the minimum price and its index\\n    for (int i = 0 ; i < n ; i++) {\\n        if(prices[i] < mini) {\\n            mini = prices[i];\\n            minIndex = i;\\n        }\\n    }\\n\\n    // Find the maximum price after the minimum price\\n    int maxPrice = prices[minIndex];\\n    for(int i = minIndex ; i < n; i++) {\\n        if(prices[i] > maxPrice)\\n            maxPrice = prices[i];\\n    }\\n\\n    return maxPrice - mini;\\n}\\n```\\n\\nThis should now work correctly for the input [1,2]. However, this still has a linear time complexity and can be improved to a constant time complexity by keeping track of the minimum price and maximum profit simultaneously:\\n\\n```cpp\\nint maxProfit(vector<int>& prices) {\\n    int minPrice = INT_MAX;\\n    int maxProfit = 0;\\n\\n    for(int i = 0; i < prices.size(); i++) {\\n        if(prices[i] < minPrice) {\\n            minPrice = prices[i];\\n        } else if(prices[i] - minPrice > maxProfit) {\\n            maxProfit = prices[i] - minPrice;\\n        }\\n    }\\n\\n    return maxProfit;\\n}\\n```"
                    },
                    {
                        "username": "teenel",
                        "content": "I dont understand what\\'s wrong with last test? (211)\\nIt\\'s write `Time Limit Exceeded`\\nLast Executed Input `prices = ` (There is nothing, no zero, no digits). I make check for `null`, but it isn\\'t help.\\nAnd also there no output and excepted values"
                    }
                ]
            },
            {
                "id": 1930000,
                "content": [
                    {
                        "username": "anmolsankadiya",
                        "content": "can someone write dp relation for the recursion code below although it pass all the test \\n\\nclass Solution {\\npublic:\\n    int func(vector<int>& prices ,int i ,int e){\\n        if(i>=prices.size()) return 0;\\n        if(prices[i]>=e && e!=-1){\\n            return max(prices[i]-e , func(prices, i+1,e));\\n        }\\n        else return func(prices,i+1,prices[i]);\\n    }\\n    int maxProfit(vector<int>& prices) {\\n        return func(prices,0,-1);\\n    }\\n};\\n\\n"
                    },
                    {
                        "username": "gribeiro5000",
                        "content": "In testCase:\\nprices = [7, 1, 5, 3, 6, 4]\\nOutput = 5\\nExpected = 5\\nOK\\n\\nAfter i submited my code:\\nprices = [1, 2]\\nOutput = 2\\nExpected = 1"
                    },
                    {
                        "username": "gribeiro5000",
                        "content": "[@ashim_raibs](/ashim_raibs) You are right! Thank you! "
                    },
                    {
                        "username": "ashim_raibs",
                        "content": "you\\'re not supposed to return day, you have to return max profit"
                    },
                    {
                        "username": "dhanushhg",
                        "content": "Hey, i just need a small help, while i code this in VScode, it works, the same code i put it here and i\\'m constantly failing the test case 2, can anyone help me, what i am wrong with at? my code\\nclass Solution {\\n    static int profit=0;\\n    static int main_profit=0;\\n     public static int maxProfit(int[] prices) {\\n      for(int i=0;i<prices.length;i++){\\n        for(int j=i+1;j<prices.length;j++){\\n           main_profit= prices[j]-prices[i];\\n        //   System.out.println(main_profit);\\n            if(profit<main_profit){\\n        profit=main_profit;\\n       }      \\n        }\\n      }              \\n      if(profit<=0){\\n        profit= 0;\\n       }\\n     return profit;\\n} }\\n"
                    },
                    {
                        "username": "bparanj",
                        "content": "The reason you might be failing the second test case could be due to the static variables `profit` and `main_profit`. These variables maintain their values across multiple calls to the function `maxProfit`. If the function is being called more than once (as in the test environment of many online coding platforms), the old values of `profit` and `main_profit` could interfere with the calculations of subsequent calls, leading to incorrect results.\\n\\nHere\\'s your code, adjusted to remove the static variables:\\n\\n```java\\nclass Solution {\\n    public int maxProfit(int[] prices) {\\n        int profit = 0;\\n        int main_profit = 0;\\n\\n        for (int i = 0; i < prices.length; i++) {\\n            for (int j = i + 1; j < prices.length; j++) {\\n                main_profit = prices[j] - prices[i];\\n\\n                if (profit < main_profit) {\\n                    profit = main_profit;\\n                }\\n            }\\n        }\\n\\n        if (profit <= 0) {\\n            profit = 0;\\n        }\\n\\n        return profit;\\n    }\\n}\\n```\\n\\nPlease note that the inner for-loop in your implementation leads to a time complexity of O(n^2) which might cause a timeout for large inputs. A more efficient approach would be to keep track of the minimum price and the maximum profit during a single pass through the array.\\n\\nHere\\'s an efficient solution with O(n) complexity:\\n\\n```java\\nclass Solution {\\n    public int maxProfit(int[] prices) {\\n        int minPrice = Integer.MAX_VALUE;\\n        int maxProfit = 0;\\n        \\n        for (int i = 0; i < prices.length; i++) {\\n            if (prices[i] < minPrice) {\\n                minPrice = prices[i];\\n            } else if (prices[i] - minPrice > maxProfit) {\\n                maxProfit = prices[i] - minPrice;\\n            }\\n        }\\n        \\n        return maxProfit;\\n    }\\n}\\n```"
                    },
                    {
                        "username": "harishini45",
                        "content": "time limit exceeded yaar failed at 202 "
                    },
                    {
                        "username": "mdsang_97",
                        "content": "[1,2]\\noutput:2\\nexpected:1\\n?"
                    },
                    {
                        "username": "ashim_raibs",
                        "content": "1 is the maxProfit, not the day/index, I got confused too "
                    },
                    {
                        "username": "_DarKReapper_",
                        "content": "class Solution {\\n    vector<vector<int>> t;\\npublic:\\n    int maxProfit(vector<int>& prices) \\n    {\\n        int n = prices.size();\\n        t.resize(n + 1, vector<int>(2,-1));\\n        return rec(prices.size(),1,prices);       \\n    }\\n    int rec(int n,int s,vector<int>& nums )\\n    {\\n        if(n <= 0) return 0;\\n        \\n        if(t[n][s] != -1) return t[n][s]; \\n        if(s)\\n        {\\n            return t[n][s] = max(nums[n - 1] + rec(n -1, 0,nums),rec(n -1,s,nums));\\n        }\\n        else \\n        {\\n            return t[n][s] = max(rec(n -1,s,nums), -nums[n - 1] );\\n        }\\n    }\\n};\\n\\n-- why is this code not working and how to correct it?"
                    },
                    {
                        "username": "bparanj",
                        "content": "Your current approach seems to be trying to solve a slightly different problem. In the problem statement, you are asked to find the maximum profit with at most one transaction (buy one and sell one share of the stock). The solution you provided seems to be trying to solve a problem where you can buy and sell as many times as you want.\\n\\nHowever, your recursive function call seems to be a bit off. In the case where you\\'re not holding a stock (`s == 0`), you\\'re not subtracting from `rec(n - 1, 1, nums)` in the return statement, so it effectively ends up ignoring the buying operation and the cost associated with it.\\n\\nA simpler and more efficient approach would be as follows:\\n\\n```cpp\\nclass Solution {\\npublic:\\n    int maxProfit(vector<int>& prices) {\\n        int minPrice = INT_MAX;\\n        int maxProfit = 0;\\n        for(int i=0; i<prices.size(); i++) {\\n            minPrice = min(minPrice, prices[i]);\\n            maxProfit = max(maxProfit, prices[i] - minPrice);\\n        }\\n        return maxProfit;\\n    }\\n};\\n```\\n\\nThis solution works in O(n) time complexity and doesn\\'t require additional space like a DP solution. It keeps track of the minimum price we\\'ve seen so far and the maximum profit we can get from selling at the current price."
                    },
                    {
                        "username": "ssalinasfe",
                        "content": "I cannot solve this problems due to time limitex exceed. It is impossible due to one of the test case is a enormous array of input of 31915 elements,, and I get time limit exceeded only for traverse the array."
                    },
                    {
                        "username": "akarshannigam123",
                        "content": "The compiler has some problem with it as it is not performing appropriately and it is giving error while other compiler are giving correct output"
                    },
                    {
                        "username": "dynamic099",
                        "content": " int maxProfit(vector<int>& prices) {\\n        int mini = INT_MAX;\\n        int minIndex = 0;\\n        int buy ;\\n        int profit ;\\n        int i ; \\n        int n = prices.size();\\n        if(n==0||n==1)\\n        return 0 ;\\n        cout << n ;\\n        for (i = 0 ; i < prices.size() ; i++)\\n        {\\n            \\n            if(prices[i]<mini)\\n            {\\n                mini = prices[i];\\n                minIndex=i;\\n            }\\n            // cout<<\"The value of minIndex is \"<<minIndex;   \\n        }\\n        if(minIndex < n )\\n        {\\n            int max = prices[mini];\\n            for(int i=mini ; i < prices.size();i ++)\\n            {\\n                if(prices[i]>max)\\n                max=prices[i];\\n            }\\n            buy=prices[mini];\\n            profit=max-buy;\\n            return profit ;\\n        }\\n        else\\n        return 0 ;\\n    }\\n\\nWhy is this solution not working for the test case [1,2]"
                    },
                    {
                        "username": "bparanj",
                        "content": "Your current implementation has some logical and syntax errors. Here are some of the reasons why your solution might fail for the test case [1,2]:\\n\\n1. You have initialized `mini` as INT_MAX and then `max` as prices[mini]. This can be problematic because `mini` is the minimum value from the integer range, not the index. It looks like you\\'ve confused the variable `mini` (which is meant to store the minimum price) with `minIndex` (which is meant to store the index of the minimum price). So in the line where you have `int max = prices[mini];`, you should actually have `int max = prices[minIndex];`.\\n\\n2. Your check `if(minIndex < n )` doesn\\'t make sense because `minIndex` will always be less than `n` (which is prices.size()). This if block will always be true and is therefore not needed.\\n\\n3. In the for loop, you\\'ve used `mini` as the start index, but it should be `minIndex`. The loop should start from `minIndex`, not from `mini`.\\n\\nA corrected version of your function could look something like this:\\n\\n```cpp\\nint maxProfit(vector<int>& prices) {\\n    int mini = INT_MAX;\\n    int minIndex = 0;\\n    int n = prices.size();\\n\\n    if(n < 2)\\n        return 0;\\n\\n    // Find the minimum price and its index\\n    for (int i = 0 ; i < n ; i++) {\\n        if(prices[i] < mini) {\\n            mini = prices[i];\\n            minIndex = i;\\n        }\\n    }\\n\\n    // Find the maximum price after the minimum price\\n    int maxPrice = prices[minIndex];\\n    for(int i = minIndex ; i < n; i++) {\\n        if(prices[i] > maxPrice)\\n            maxPrice = prices[i];\\n    }\\n\\n    return maxPrice - mini;\\n}\\n```\\n\\nThis should now work correctly for the input [1,2]. However, this still has a linear time complexity and can be improved to a constant time complexity by keeping track of the minimum price and maximum profit simultaneously:\\n\\n```cpp\\nint maxProfit(vector<int>& prices) {\\n    int minPrice = INT_MAX;\\n    int maxProfit = 0;\\n\\n    for(int i = 0; i < prices.size(); i++) {\\n        if(prices[i] < minPrice) {\\n            minPrice = prices[i];\\n        } else if(prices[i] - minPrice > maxProfit) {\\n            maxProfit = prices[i] - minPrice;\\n        }\\n    }\\n\\n    return maxProfit;\\n}\\n```"
                    },
                    {
                        "username": "teenel",
                        "content": "I dont understand what\\'s wrong with last test? (211)\\nIt\\'s write `Time Limit Exceeded`\\nLast Executed Input `prices = ` (There is nothing, no zero, no digits). I make check for `null`, but it isn\\'t help.\\nAnd also there no output and excepted values"
                    }
                ]
            },
            {
                "id": 1923542,
                "content": [
                    {
                        "username": "anmolsankadiya",
                        "content": "can someone write dp relation for the recursion code below although it pass all the test \\n\\nclass Solution {\\npublic:\\n    int func(vector<int>& prices ,int i ,int e){\\n        if(i>=prices.size()) return 0;\\n        if(prices[i]>=e && e!=-1){\\n            return max(prices[i]-e , func(prices, i+1,e));\\n        }\\n        else return func(prices,i+1,prices[i]);\\n    }\\n    int maxProfit(vector<int>& prices) {\\n        return func(prices,0,-1);\\n    }\\n};\\n\\n"
                    },
                    {
                        "username": "gribeiro5000",
                        "content": "In testCase:\\nprices = [7, 1, 5, 3, 6, 4]\\nOutput = 5\\nExpected = 5\\nOK\\n\\nAfter i submited my code:\\nprices = [1, 2]\\nOutput = 2\\nExpected = 1"
                    },
                    {
                        "username": "gribeiro5000",
                        "content": "[@ashim_raibs](/ashim_raibs) You are right! Thank you! "
                    },
                    {
                        "username": "ashim_raibs",
                        "content": "you\\'re not supposed to return day, you have to return max profit"
                    },
                    {
                        "username": "dhanushhg",
                        "content": "Hey, i just need a small help, while i code this in VScode, it works, the same code i put it here and i\\'m constantly failing the test case 2, can anyone help me, what i am wrong with at? my code\\nclass Solution {\\n    static int profit=0;\\n    static int main_profit=0;\\n     public static int maxProfit(int[] prices) {\\n      for(int i=0;i<prices.length;i++){\\n        for(int j=i+1;j<prices.length;j++){\\n           main_profit= prices[j]-prices[i];\\n        //   System.out.println(main_profit);\\n            if(profit<main_profit){\\n        profit=main_profit;\\n       }      \\n        }\\n      }              \\n      if(profit<=0){\\n        profit= 0;\\n       }\\n     return profit;\\n} }\\n"
                    },
                    {
                        "username": "bparanj",
                        "content": "The reason you might be failing the second test case could be due to the static variables `profit` and `main_profit`. These variables maintain their values across multiple calls to the function `maxProfit`. If the function is being called more than once (as in the test environment of many online coding platforms), the old values of `profit` and `main_profit` could interfere with the calculations of subsequent calls, leading to incorrect results.\\n\\nHere\\'s your code, adjusted to remove the static variables:\\n\\n```java\\nclass Solution {\\n    public int maxProfit(int[] prices) {\\n        int profit = 0;\\n        int main_profit = 0;\\n\\n        for (int i = 0; i < prices.length; i++) {\\n            for (int j = i + 1; j < prices.length; j++) {\\n                main_profit = prices[j] - prices[i];\\n\\n                if (profit < main_profit) {\\n                    profit = main_profit;\\n                }\\n            }\\n        }\\n\\n        if (profit <= 0) {\\n            profit = 0;\\n        }\\n\\n        return profit;\\n    }\\n}\\n```\\n\\nPlease note that the inner for-loop in your implementation leads to a time complexity of O(n^2) which might cause a timeout for large inputs. A more efficient approach would be to keep track of the minimum price and the maximum profit during a single pass through the array.\\n\\nHere\\'s an efficient solution with O(n) complexity:\\n\\n```java\\nclass Solution {\\n    public int maxProfit(int[] prices) {\\n        int minPrice = Integer.MAX_VALUE;\\n        int maxProfit = 0;\\n        \\n        for (int i = 0; i < prices.length; i++) {\\n            if (prices[i] < minPrice) {\\n                minPrice = prices[i];\\n            } else if (prices[i] - minPrice > maxProfit) {\\n                maxProfit = prices[i] - minPrice;\\n            }\\n        }\\n        \\n        return maxProfit;\\n    }\\n}\\n```"
                    },
                    {
                        "username": "harishini45",
                        "content": "time limit exceeded yaar failed at 202 "
                    },
                    {
                        "username": "mdsang_97",
                        "content": "[1,2]\\noutput:2\\nexpected:1\\n?"
                    },
                    {
                        "username": "ashim_raibs",
                        "content": "1 is the maxProfit, not the day/index, I got confused too "
                    },
                    {
                        "username": "_DarKReapper_",
                        "content": "class Solution {\\n    vector<vector<int>> t;\\npublic:\\n    int maxProfit(vector<int>& prices) \\n    {\\n        int n = prices.size();\\n        t.resize(n + 1, vector<int>(2,-1));\\n        return rec(prices.size(),1,prices);       \\n    }\\n    int rec(int n,int s,vector<int>& nums )\\n    {\\n        if(n <= 0) return 0;\\n        \\n        if(t[n][s] != -1) return t[n][s]; \\n        if(s)\\n        {\\n            return t[n][s] = max(nums[n - 1] + rec(n -1, 0,nums),rec(n -1,s,nums));\\n        }\\n        else \\n        {\\n            return t[n][s] = max(rec(n -1,s,nums), -nums[n - 1] );\\n        }\\n    }\\n};\\n\\n-- why is this code not working and how to correct it?"
                    },
                    {
                        "username": "bparanj",
                        "content": "Your current approach seems to be trying to solve a slightly different problem. In the problem statement, you are asked to find the maximum profit with at most one transaction (buy one and sell one share of the stock). The solution you provided seems to be trying to solve a problem where you can buy and sell as many times as you want.\\n\\nHowever, your recursive function call seems to be a bit off. In the case where you\\'re not holding a stock (`s == 0`), you\\'re not subtracting from `rec(n - 1, 1, nums)` in the return statement, so it effectively ends up ignoring the buying operation and the cost associated with it.\\n\\nA simpler and more efficient approach would be as follows:\\n\\n```cpp\\nclass Solution {\\npublic:\\n    int maxProfit(vector<int>& prices) {\\n        int minPrice = INT_MAX;\\n        int maxProfit = 0;\\n        for(int i=0; i<prices.size(); i++) {\\n            minPrice = min(minPrice, prices[i]);\\n            maxProfit = max(maxProfit, prices[i] - minPrice);\\n        }\\n        return maxProfit;\\n    }\\n};\\n```\\n\\nThis solution works in O(n) time complexity and doesn\\'t require additional space like a DP solution. It keeps track of the minimum price we\\'ve seen so far and the maximum profit we can get from selling at the current price."
                    },
                    {
                        "username": "ssalinasfe",
                        "content": "I cannot solve this problems due to time limitex exceed. It is impossible due to one of the test case is a enormous array of input of 31915 elements,, and I get time limit exceeded only for traverse the array."
                    },
                    {
                        "username": "akarshannigam123",
                        "content": "The compiler has some problem with it as it is not performing appropriately and it is giving error while other compiler are giving correct output"
                    },
                    {
                        "username": "dynamic099",
                        "content": " int maxProfit(vector<int>& prices) {\\n        int mini = INT_MAX;\\n        int minIndex = 0;\\n        int buy ;\\n        int profit ;\\n        int i ; \\n        int n = prices.size();\\n        if(n==0||n==1)\\n        return 0 ;\\n        cout << n ;\\n        for (i = 0 ; i < prices.size() ; i++)\\n        {\\n            \\n            if(prices[i]<mini)\\n            {\\n                mini = prices[i];\\n                minIndex=i;\\n            }\\n            // cout<<\"The value of minIndex is \"<<minIndex;   \\n        }\\n        if(minIndex < n )\\n        {\\n            int max = prices[mini];\\n            for(int i=mini ; i < prices.size();i ++)\\n            {\\n                if(prices[i]>max)\\n                max=prices[i];\\n            }\\n            buy=prices[mini];\\n            profit=max-buy;\\n            return profit ;\\n        }\\n        else\\n        return 0 ;\\n    }\\n\\nWhy is this solution not working for the test case [1,2]"
                    },
                    {
                        "username": "bparanj",
                        "content": "Your current implementation has some logical and syntax errors. Here are some of the reasons why your solution might fail for the test case [1,2]:\\n\\n1. You have initialized `mini` as INT_MAX and then `max` as prices[mini]. This can be problematic because `mini` is the minimum value from the integer range, not the index. It looks like you\\'ve confused the variable `mini` (which is meant to store the minimum price) with `minIndex` (which is meant to store the index of the minimum price). So in the line where you have `int max = prices[mini];`, you should actually have `int max = prices[minIndex];`.\\n\\n2. Your check `if(minIndex < n )` doesn\\'t make sense because `minIndex` will always be less than `n` (which is prices.size()). This if block will always be true and is therefore not needed.\\n\\n3. In the for loop, you\\'ve used `mini` as the start index, but it should be `minIndex`. The loop should start from `minIndex`, not from `mini`.\\n\\nA corrected version of your function could look something like this:\\n\\n```cpp\\nint maxProfit(vector<int>& prices) {\\n    int mini = INT_MAX;\\n    int minIndex = 0;\\n    int n = prices.size();\\n\\n    if(n < 2)\\n        return 0;\\n\\n    // Find the minimum price and its index\\n    for (int i = 0 ; i < n ; i++) {\\n        if(prices[i] < mini) {\\n            mini = prices[i];\\n            minIndex = i;\\n        }\\n    }\\n\\n    // Find the maximum price after the minimum price\\n    int maxPrice = prices[minIndex];\\n    for(int i = minIndex ; i < n; i++) {\\n        if(prices[i] > maxPrice)\\n            maxPrice = prices[i];\\n    }\\n\\n    return maxPrice - mini;\\n}\\n```\\n\\nThis should now work correctly for the input [1,2]. However, this still has a linear time complexity and can be improved to a constant time complexity by keeping track of the minimum price and maximum profit simultaneously:\\n\\n```cpp\\nint maxProfit(vector<int>& prices) {\\n    int minPrice = INT_MAX;\\n    int maxProfit = 0;\\n\\n    for(int i = 0; i < prices.size(); i++) {\\n        if(prices[i] < minPrice) {\\n            minPrice = prices[i];\\n        } else if(prices[i] - minPrice > maxProfit) {\\n            maxProfit = prices[i] - minPrice;\\n        }\\n    }\\n\\n    return maxProfit;\\n}\\n```"
                    },
                    {
                        "username": "teenel",
                        "content": "I dont understand what\\'s wrong with last test? (211)\\nIt\\'s write `Time Limit Exceeded`\\nLast Executed Input `prices = ` (There is nothing, no zero, no digits). I make check for `null`, but it isn\\'t help.\\nAnd also there no output and excepted values"
                    }
                ]
            },
            {
                "id": 1922941,
                "content": [
                    {
                        "username": "anmolsankadiya",
                        "content": "can someone write dp relation for the recursion code below although it pass all the test \\n\\nclass Solution {\\npublic:\\n    int func(vector<int>& prices ,int i ,int e){\\n        if(i>=prices.size()) return 0;\\n        if(prices[i]>=e && e!=-1){\\n            return max(prices[i]-e , func(prices, i+1,e));\\n        }\\n        else return func(prices,i+1,prices[i]);\\n    }\\n    int maxProfit(vector<int>& prices) {\\n        return func(prices,0,-1);\\n    }\\n};\\n\\n"
                    },
                    {
                        "username": "gribeiro5000",
                        "content": "In testCase:\\nprices = [7, 1, 5, 3, 6, 4]\\nOutput = 5\\nExpected = 5\\nOK\\n\\nAfter i submited my code:\\nprices = [1, 2]\\nOutput = 2\\nExpected = 1"
                    },
                    {
                        "username": "gribeiro5000",
                        "content": "[@ashim_raibs](/ashim_raibs) You are right! Thank you! "
                    },
                    {
                        "username": "ashim_raibs",
                        "content": "you\\'re not supposed to return day, you have to return max profit"
                    },
                    {
                        "username": "dhanushhg",
                        "content": "Hey, i just need a small help, while i code this in VScode, it works, the same code i put it here and i\\'m constantly failing the test case 2, can anyone help me, what i am wrong with at? my code\\nclass Solution {\\n    static int profit=0;\\n    static int main_profit=0;\\n     public static int maxProfit(int[] prices) {\\n      for(int i=0;i<prices.length;i++){\\n        for(int j=i+1;j<prices.length;j++){\\n           main_profit= prices[j]-prices[i];\\n        //   System.out.println(main_profit);\\n            if(profit<main_profit){\\n        profit=main_profit;\\n       }      \\n        }\\n      }              \\n      if(profit<=0){\\n        profit= 0;\\n       }\\n     return profit;\\n} }\\n"
                    },
                    {
                        "username": "bparanj",
                        "content": "The reason you might be failing the second test case could be due to the static variables `profit` and `main_profit`. These variables maintain their values across multiple calls to the function `maxProfit`. If the function is being called more than once (as in the test environment of many online coding platforms), the old values of `profit` and `main_profit` could interfere with the calculations of subsequent calls, leading to incorrect results.\\n\\nHere\\'s your code, adjusted to remove the static variables:\\n\\n```java\\nclass Solution {\\n    public int maxProfit(int[] prices) {\\n        int profit = 0;\\n        int main_profit = 0;\\n\\n        for (int i = 0; i < prices.length; i++) {\\n            for (int j = i + 1; j < prices.length; j++) {\\n                main_profit = prices[j] - prices[i];\\n\\n                if (profit < main_profit) {\\n                    profit = main_profit;\\n                }\\n            }\\n        }\\n\\n        if (profit <= 0) {\\n            profit = 0;\\n        }\\n\\n        return profit;\\n    }\\n}\\n```\\n\\nPlease note that the inner for-loop in your implementation leads to a time complexity of O(n^2) which might cause a timeout for large inputs. A more efficient approach would be to keep track of the minimum price and the maximum profit during a single pass through the array.\\n\\nHere\\'s an efficient solution with O(n) complexity:\\n\\n```java\\nclass Solution {\\n    public int maxProfit(int[] prices) {\\n        int minPrice = Integer.MAX_VALUE;\\n        int maxProfit = 0;\\n        \\n        for (int i = 0; i < prices.length; i++) {\\n            if (prices[i] < minPrice) {\\n                minPrice = prices[i];\\n            } else if (prices[i] - minPrice > maxProfit) {\\n                maxProfit = prices[i] - minPrice;\\n            }\\n        }\\n        \\n        return maxProfit;\\n    }\\n}\\n```"
                    },
                    {
                        "username": "harishini45",
                        "content": "time limit exceeded yaar failed at 202 "
                    },
                    {
                        "username": "mdsang_97",
                        "content": "[1,2]\\noutput:2\\nexpected:1\\n?"
                    },
                    {
                        "username": "ashim_raibs",
                        "content": "1 is the maxProfit, not the day/index, I got confused too "
                    },
                    {
                        "username": "_DarKReapper_",
                        "content": "class Solution {\\n    vector<vector<int>> t;\\npublic:\\n    int maxProfit(vector<int>& prices) \\n    {\\n        int n = prices.size();\\n        t.resize(n + 1, vector<int>(2,-1));\\n        return rec(prices.size(),1,prices);       \\n    }\\n    int rec(int n,int s,vector<int>& nums )\\n    {\\n        if(n <= 0) return 0;\\n        \\n        if(t[n][s] != -1) return t[n][s]; \\n        if(s)\\n        {\\n            return t[n][s] = max(nums[n - 1] + rec(n -1, 0,nums),rec(n -1,s,nums));\\n        }\\n        else \\n        {\\n            return t[n][s] = max(rec(n -1,s,nums), -nums[n - 1] );\\n        }\\n    }\\n};\\n\\n-- why is this code not working and how to correct it?"
                    },
                    {
                        "username": "bparanj",
                        "content": "Your current approach seems to be trying to solve a slightly different problem. In the problem statement, you are asked to find the maximum profit with at most one transaction (buy one and sell one share of the stock). The solution you provided seems to be trying to solve a problem where you can buy and sell as many times as you want.\\n\\nHowever, your recursive function call seems to be a bit off. In the case where you\\'re not holding a stock (`s == 0`), you\\'re not subtracting from `rec(n - 1, 1, nums)` in the return statement, so it effectively ends up ignoring the buying operation and the cost associated with it.\\n\\nA simpler and more efficient approach would be as follows:\\n\\n```cpp\\nclass Solution {\\npublic:\\n    int maxProfit(vector<int>& prices) {\\n        int minPrice = INT_MAX;\\n        int maxProfit = 0;\\n        for(int i=0; i<prices.size(); i++) {\\n            minPrice = min(minPrice, prices[i]);\\n            maxProfit = max(maxProfit, prices[i] - minPrice);\\n        }\\n        return maxProfit;\\n    }\\n};\\n```\\n\\nThis solution works in O(n) time complexity and doesn\\'t require additional space like a DP solution. It keeps track of the minimum price we\\'ve seen so far and the maximum profit we can get from selling at the current price."
                    },
                    {
                        "username": "ssalinasfe",
                        "content": "I cannot solve this problems due to time limitex exceed. It is impossible due to one of the test case is a enormous array of input of 31915 elements,, and I get time limit exceeded only for traverse the array."
                    },
                    {
                        "username": "akarshannigam123",
                        "content": "The compiler has some problem with it as it is not performing appropriately and it is giving error while other compiler are giving correct output"
                    },
                    {
                        "username": "dynamic099",
                        "content": " int maxProfit(vector<int>& prices) {\\n        int mini = INT_MAX;\\n        int minIndex = 0;\\n        int buy ;\\n        int profit ;\\n        int i ; \\n        int n = prices.size();\\n        if(n==0||n==1)\\n        return 0 ;\\n        cout << n ;\\n        for (i = 0 ; i < prices.size() ; i++)\\n        {\\n            \\n            if(prices[i]<mini)\\n            {\\n                mini = prices[i];\\n                minIndex=i;\\n            }\\n            // cout<<\"The value of minIndex is \"<<minIndex;   \\n        }\\n        if(minIndex < n )\\n        {\\n            int max = prices[mini];\\n            for(int i=mini ; i < prices.size();i ++)\\n            {\\n                if(prices[i]>max)\\n                max=prices[i];\\n            }\\n            buy=prices[mini];\\n            profit=max-buy;\\n            return profit ;\\n        }\\n        else\\n        return 0 ;\\n    }\\n\\nWhy is this solution not working for the test case [1,2]"
                    },
                    {
                        "username": "bparanj",
                        "content": "Your current implementation has some logical and syntax errors. Here are some of the reasons why your solution might fail for the test case [1,2]:\\n\\n1. You have initialized `mini` as INT_MAX and then `max` as prices[mini]. This can be problematic because `mini` is the minimum value from the integer range, not the index. It looks like you\\'ve confused the variable `mini` (which is meant to store the minimum price) with `minIndex` (which is meant to store the index of the minimum price). So in the line where you have `int max = prices[mini];`, you should actually have `int max = prices[minIndex];`.\\n\\n2. Your check `if(minIndex < n )` doesn\\'t make sense because `minIndex` will always be less than `n` (which is prices.size()). This if block will always be true and is therefore not needed.\\n\\n3. In the for loop, you\\'ve used `mini` as the start index, but it should be `minIndex`. The loop should start from `minIndex`, not from `mini`.\\n\\nA corrected version of your function could look something like this:\\n\\n```cpp\\nint maxProfit(vector<int>& prices) {\\n    int mini = INT_MAX;\\n    int minIndex = 0;\\n    int n = prices.size();\\n\\n    if(n < 2)\\n        return 0;\\n\\n    // Find the minimum price and its index\\n    for (int i = 0 ; i < n ; i++) {\\n        if(prices[i] < mini) {\\n            mini = prices[i];\\n            minIndex = i;\\n        }\\n    }\\n\\n    // Find the maximum price after the minimum price\\n    int maxPrice = prices[minIndex];\\n    for(int i = minIndex ; i < n; i++) {\\n        if(prices[i] > maxPrice)\\n            maxPrice = prices[i];\\n    }\\n\\n    return maxPrice - mini;\\n}\\n```\\n\\nThis should now work correctly for the input [1,2]. However, this still has a linear time complexity and can be improved to a constant time complexity by keeping track of the minimum price and maximum profit simultaneously:\\n\\n```cpp\\nint maxProfit(vector<int>& prices) {\\n    int minPrice = INT_MAX;\\n    int maxProfit = 0;\\n\\n    for(int i = 0; i < prices.size(); i++) {\\n        if(prices[i] < minPrice) {\\n            minPrice = prices[i];\\n        } else if(prices[i] - minPrice > maxProfit) {\\n            maxProfit = prices[i] - minPrice;\\n        }\\n    }\\n\\n    return maxProfit;\\n}\\n```"
                    },
                    {
                        "username": "teenel",
                        "content": "I dont understand what\\'s wrong with last test? (211)\\nIt\\'s write `Time Limit Exceeded`\\nLast Executed Input `prices = ` (There is nothing, no zero, no digits). I make check for `null`, but it isn\\'t help.\\nAnd also there no output and excepted values"
                    }
                ]
            },
            {
                "id": 1921452,
                "content": [
                    {
                        "username": "anmolsankadiya",
                        "content": "can someone write dp relation for the recursion code below although it pass all the test \\n\\nclass Solution {\\npublic:\\n    int func(vector<int>& prices ,int i ,int e){\\n        if(i>=prices.size()) return 0;\\n        if(prices[i]>=e && e!=-1){\\n            return max(prices[i]-e , func(prices, i+1,e));\\n        }\\n        else return func(prices,i+1,prices[i]);\\n    }\\n    int maxProfit(vector<int>& prices) {\\n        return func(prices,0,-1);\\n    }\\n};\\n\\n"
                    },
                    {
                        "username": "gribeiro5000",
                        "content": "In testCase:\\nprices = [7, 1, 5, 3, 6, 4]\\nOutput = 5\\nExpected = 5\\nOK\\n\\nAfter i submited my code:\\nprices = [1, 2]\\nOutput = 2\\nExpected = 1"
                    },
                    {
                        "username": "gribeiro5000",
                        "content": "[@ashim_raibs](/ashim_raibs) You are right! Thank you! "
                    },
                    {
                        "username": "ashim_raibs",
                        "content": "you\\'re not supposed to return day, you have to return max profit"
                    },
                    {
                        "username": "dhanushhg",
                        "content": "Hey, i just need a small help, while i code this in VScode, it works, the same code i put it here and i\\'m constantly failing the test case 2, can anyone help me, what i am wrong with at? my code\\nclass Solution {\\n    static int profit=0;\\n    static int main_profit=0;\\n     public static int maxProfit(int[] prices) {\\n      for(int i=0;i<prices.length;i++){\\n        for(int j=i+1;j<prices.length;j++){\\n           main_profit= prices[j]-prices[i];\\n        //   System.out.println(main_profit);\\n            if(profit<main_profit){\\n        profit=main_profit;\\n       }      \\n        }\\n      }              \\n      if(profit<=0){\\n        profit= 0;\\n       }\\n     return profit;\\n} }\\n"
                    },
                    {
                        "username": "bparanj",
                        "content": "The reason you might be failing the second test case could be due to the static variables `profit` and `main_profit`. These variables maintain their values across multiple calls to the function `maxProfit`. If the function is being called more than once (as in the test environment of many online coding platforms), the old values of `profit` and `main_profit` could interfere with the calculations of subsequent calls, leading to incorrect results.\\n\\nHere\\'s your code, adjusted to remove the static variables:\\n\\n```java\\nclass Solution {\\n    public int maxProfit(int[] prices) {\\n        int profit = 0;\\n        int main_profit = 0;\\n\\n        for (int i = 0; i < prices.length; i++) {\\n            for (int j = i + 1; j < prices.length; j++) {\\n                main_profit = prices[j] - prices[i];\\n\\n                if (profit < main_profit) {\\n                    profit = main_profit;\\n                }\\n            }\\n        }\\n\\n        if (profit <= 0) {\\n            profit = 0;\\n        }\\n\\n        return profit;\\n    }\\n}\\n```\\n\\nPlease note that the inner for-loop in your implementation leads to a time complexity of O(n^2) which might cause a timeout for large inputs. A more efficient approach would be to keep track of the minimum price and the maximum profit during a single pass through the array.\\n\\nHere\\'s an efficient solution with O(n) complexity:\\n\\n```java\\nclass Solution {\\n    public int maxProfit(int[] prices) {\\n        int minPrice = Integer.MAX_VALUE;\\n        int maxProfit = 0;\\n        \\n        for (int i = 0; i < prices.length; i++) {\\n            if (prices[i] < minPrice) {\\n                minPrice = prices[i];\\n            } else if (prices[i] - minPrice > maxProfit) {\\n                maxProfit = prices[i] - minPrice;\\n            }\\n        }\\n        \\n        return maxProfit;\\n    }\\n}\\n```"
                    },
                    {
                        "username": "harishini45",
                        "content": "time limit exceeded yaar failed at 202 "
                    },
                    {
                        "username": "mdsang_97",
                        "content": "[1,2]\\noutput:2\\nexpected:1\\n?"
                    },
                    {
                        "username": "ashim_raibs",
                        "content": "1 is the maxProfit, not the day/index, I got confused too "
                    },
                    {
                        "username": "_DarKReapper_",
                        "content": "class Solution {\\n    vector<vector<int>> t;\\npublic:\\n    int maxProfit(vector<int>& prices) \\n    {\\n        int n = prices.size();\\n        t.resize(n + 1, vector<int>(2,-1));\\n        return rec(prices.size(),1,prices);       \\n    }\\n    int rec(int n,int s,vector<int>& nums )\\n    {\\n        if(n <= 0) return 0;\\n        \\n        if(t[n][s] != -1) return t[n][s]; \\n        if(s)\\n        {\\n            return t[n][s] = max(nums[n - 1] + rec(n -1, 0,nums),rec(n -1,s,nums));\\n        }\\n        else \\n        {\\n            return t[n][s] = max(rec(n -1,s,nums), -nums[n - 1] );\\n        }\\n    }\\n};\\n\\n-- why is this code not working and how to correct it?"
                    },
                    {
                        "username": "bparanj",
                        "content": "Your current approach seems to be trying to solve a slightly different problem. In the problem statement, you are asked to find the maximum profit with at most one transaction (buy one and sell one share of the stock). The solution you provided seems to be trying to solve a problem where you can buy and sell as many times as you want.\\n\\nHowever, your recursive function call seems to be a bit off. In the case where you\\'re not holding a stock (`s == 0`), you\\'re not subtracting from `rec(n - 1, 1, nums)` in the return statement, so it effectively ends up ignoring the buying operation and the cost associated with it.\\n\\nA simpler and more efficient approach would be as follows:\\n\\n```cpp\\nclass Solution {\\npublic:\\n    int maxProfit(vector<int>& prices) {\\n        int minPrice = INT_MAX;\\n        int maxProfit = 0;\\n        for(int i=0; i<prices.size(); i++) {\\n            minPrice = min(minPrice, prices[i]);\\n            maxProfit = max(maxProfit, prices[i] - minPrice);\\n        }\\n        return maxProfit;\\n    }\\n};\\n```\\n\\nThis solution works in O(n) time complexity and doesn\\'t require additional space like a DP solution. It keeps track of the minimum price we\\'ve seen so far and the maximum profit we can get from selling at the current price."
                    },
                    {
                        "username": "ssalinasfe",
                        "content": "I cannot solve this problems due to time limitex exceed. It is impossible due to one of the test case is a enormous array of input of 31915 elements,, and I get time limit exceeded only for traverse the array."
                    },
                    {
                        "username": "akarshannigam123",
                        "content": "The compiler has some problem with it as it is not performing appropriately and it is giving error while other compiler are giving correct output"
                    },
                    {
                        "username": "dynamic099",
                        "content": " int maxProfit(vector<int>& prices) {\\n        int mini = INT_MAX;\\n        int minIndex = 0;\\n        int buy ;\\n        int profit ;\\n        int i ; \\n        int n = prices.size();\\n        if(n==0||n==1)\\n        return 0 ;\\n        cout << n ;\\n        for (i = 0 ; i < prices.size() ; i++)\\n        {\\n            \\n            if(prices[i]<mini)\\n            {\\n                mini = prices[i];\\n                minIndex=i;\\n            }\\n            // cout<<\"The value of minIndex is \"<<minIndex;   \\n        }\\n        if(minIndex < n )\\n        {\\n            int max = prices[mini];\\n            for(int i=mini ; i < prices.size();i ++)\\n            {\\n                if(prices[i]>max)\\n                max=prices[i];\\n            }\\n            buy=prices[mini];\\n            profit=max-buy;\\n            return profit ;\\n        }\\n        else\\n        return 0 ;\\n    }\\n\\nWhy is this solution not working for the test case [1,2]"
                    },
                    {
                        "username": "bparanj",
                        "content": "Your current implementation has some logical and syntax errors. Here are some of the reasons why your solution might fail for the test case [1,2]:\\n\\n1. You have initialized `mini` as INT_MAX and then `max` as prices[mini]. This can be problematic because `mini` is the minimum value from the integer range, not the index. It looks like you\\'ve confused the variable `mini` (which is meant to store the minimum price) with `minIndex` (which is meant to store the index of the minimum price). So in the line where you have `int max = prices[mini];`, you should actually have `int max = prices[minIndex];`.\\n\\n2. Your check `if(minIndex < n )` doesn\\'t make sense because `minIndex` will always be less than `n` (which is prices.size()). This if block will always be true and is therefore not needed.\\n\\n3. In the for loop, you\\'ve used `mini` as the start index, but it should be `minIndex`. The loop should start from `minIndex`, not from `mini`.\\n\\nA corrected version of your function could look something like this:\\n\\n```cpp\\nint maxProfit(vector<int>& prices) {\\n    int mini = INT_MAX;\\n    int minIndex = 0;\\n    int n = prices.size();\\n\\n    if(n < 2)\\n        return 0;\\n\\n    // Find the minimum price and its index\\n    for (int i = 0 ; i < n ; i++) {\\n        if(prices[i] < mini) {\\n            mini = prices[i];\\n            minIndex = i;\\n        }\\n    }\\n\\n    // Find the maximum price after the minimum price\\n    int maxPrice = prices[minIndex];\\n    for(int i = minIndex ; i < n; i++) {\\n        if(prices[i] > maxPrice)\\n            maxPrice = prices[i];\\n    }\\n\\n    return maxPrice - mini;\\n}\\n```\\n\\nThis should now work correctly for the input [1,2]. However, this still has a linear time complexity and can be improved to a constant time complexity by keeping track of the minimum price and maximum profit simultaneously:\\n\\n```cpp\\nint maxProfit(vector<int>& prices) {\\n    int minPrice = INT_MAX;\\n    int maxProfit = 0;\\n\\n    for(int i = 0; i < prices.size(); i++) {\\n        if(prices[i] < minPrice) {\\n            minPrice = prices[i];\\n        } else if(prices[i] - minPrice > maxProfit) {\\n            maxProfit = prices[i] - minPrice;\\n        }\\n    }\\n\\n    return maxProfit;\\n}\\n```"
                    },
                    {
                        "username": "teenel",
                        "content": "I dont understand what\\'s wrong with last test? (211)\\nIt\\'s write `Time Limit Exceeded`\\nLast Executed Input `prices = ` (There is nothing, no zero, no digits). I make check for `null`, but it isn\\'t help.\\nAnd also there no output and excepted values"
                    }
                ]
            },
            {
                "id": 1919708,
                "content": [
                    {
                        "username": "anmolsankadiya",
                        "content": "can someone write dp relation for the recursion code below although it pass all the test \\n\\nclass Solution {\\npublic:\\n    int func(vector<int>& prices ,int i ,int e){\\n        if(i>=prices.size()) return 0;\\n        if(prices[i]>=e && e!=-1){\\n            return max(prices[i]-e , func(prices, i+1,e));\\n        }\\n        else return func(prices,i+1,prices[i]);\\n    }\\n    int maxProfit(vector<int>& prices) {\\n        return func(prices,0,-1);\\n    }\\n};\\n\\n"
                    },
                    {
                        "username": "gribeiro5000",
                        "content": "In testCase:\\nprices = [7, 1, 5, 3, 6, 4]\\nOutput = 5\\nExpected = 5\\nOK\\n\\nAfter i submited my code:\\nprices = [1, 2]\\nOutput = 2\\nExpected = 1"
                    },
                    {
                        "username": "gribeiro5000",
                        "content": "[@ashim_raibs](/ashim_raibs) You are right! Thank you! "
                    },
                    {
                        "username": "ashim_raibs",
                        "content": "you\\'re not supposed to return day, you have to return max profit"
                    },
                    {
                        "username": "dhanushhg",
                        "content": "Hey, i just need a small help, while i code this in VScode, it works, the same code i put it here and i\\'m constantly failing the test case 2, can anyone help me, what i am wrong with at? my code\\nclass Solution {\\n    static int profit=0;\\n    static int main_profit=0;\\n     public static int maxProfit(int[] prices) {\\n      for(int i=0;i<prices.length;i++){\\n        for(int j=i+1;j<prices.length;j++){\\n           main_profit= prices[j]-prices[i];\\n        //   System.out.println(main_profit);\\n            if(profit<main_profit){\\n        profit=main_profit;\\n       }      \\n        }\\n      }              \\n      if(profit<=0){\\n        profit= 0;\\n       }\\n     return profit;\\n} }\\n"
                    },
                    {
                        "username": "bparanj",
                        "content": "The reason you might be failing the second test case could be due to the static variables `profit` and `main_profit`. These variables maintain their values across multiple calls to the function `maxProfit`. If the function is being called more than once (as in the test environment of many online coding platforms), the old values of `profit` and `main_profit` could interfere with the calculations of subsequent calls, leading to incorrect results.\\n\\nHere\\'s your code, adjusted to remove the static variables:\\n\\n```java\\nclass Solution {\\n    public int maxProfit(int[] prices) {\\n        int profit = 0;\\n        int main_profit = 0;\\n\\n        for (int i = 0; i < prices.length; i++) {\\n            for (int j = i + 1; j < prices.length; j++) {\\n                main_profit = prices[j] - prices[i];\\n\\n                if (profit < main_profit) {\\n                    profit = main_profit;\\n                }\\n            }\\n        }\\n\\n        if (profit <= 0) {\\n            profit = 0;\\n        }\\n\\n        return profit;\\n    }\\n}\\n```\\n\\nPlease note that the inner for-loop in your implementation leads to a time complexity of O(n^2) which might cause a timeout for large inputs. A more efficient approach would be to keep track of the minimum price and the maximum profit during a single pass through the array.\\n\\nHere\\'s an efficient solution with O(n) complexity:\\n\\n```java\\nclass Solution {\\n    public int maxProfit(int[] prices) {\\n        int minPrice = Integer.MAX_VALUE;\\n        int maxProfit = 0;\\n        \\n        for (int i = 0; i < prices.length; i++) {\\n            if (prices[i] < minPrice) {\\n                minPrice = prices[i];\\n            } else if (prices[i] - minPrice > maxProfit) {\\n                maxProfit = prices[i] - minPrice;\\n            }\\n        }\\n        \\n        return maxProfit;\\n    }\\n}\\n```"
                    },
                    {
                        "username": "harishini45",
                        "content": "time limit exceeded yaar failed at 202 "
                    },
                    {
                        "username": "mdsang_97",
                        "content": "[1,2]\\noutput:2\\nexpected:1\\n?"
                    },
                    {
                        "username": "ashim_raibs",
                        "content": "1 is the maxProfit, not the day/index, I got confused too "
                    },
                    {
                        "username": "_DarKReapper_",
                        "content": "class Solution {\\n    vector<vector<int>> t;\\npublic:\\n    int maxProfit(vector<int>& prices) \\n    {\\n        int n = prices.size();\\n        t.resize(n + 1, vector<int>(2,-1));\\n        return rec(prices.size(),1,prices);       \\n    }\\n    int rec(int n,int s,vector<int>& nums )\\n    {\\n        if(n <= 0) return 0;\\n        \\n        if(t[n][s] != -1) return t[n][s]; \\n        if(s)\\n        {\\n            return t[n][s] = max(nums[n - 1] + rec(n -1, 0,nums),rec(n -1,s,nums));\\n        }\\n        else \\n        {\\n            return t[n][s] = max(rec(n -1,s,nums), -nums[n - 1] );\\n        }\\n    }\\n};\\n\\n-- why is this code not working and how to correct it?"
                    },
                    {
                        "username": "bparanj",
                        "content": "Your current approach seems to be trying to solve a slightly different problem. In the problem statement, you are asked to find the maximum profit with at most one transaction (buy one and sell one share of the stock). The solution you provided seems to be trying to solve a problem where you can buy and sell as many times as you want.\\n\\nHowever, your recursive function call seems to be a bit off. In the case where you\\'re not holding a stock (`s == 0`), you\\'re not subtracting from `rec(n - 1, 1, nums)` in the return statement, so it effectively ends up ignoring the buying operation and the cost associated with it.\\n\\nA simpler and more efficient approach would be as follows:\\n\\n```cpp\\nclass Solution {\\npublic:\\n    int maxProfit(vector<int>& prices) {\\n        int minPrice = INT_MAX;\\n        int maxProfit = 0;\\n        for(int i=0; i<prices.size(); i++) {\\n            minPrice = min(minPrice, prices[i]);\\n            maxProfit = max(maxProfit, prices[i] - minPrice);\\n        }\\n        return maxProfit;\\n    }\\n};\\n```\\n\\nThis solution works in O(n) time complexity and doesn\\'t require additional space like a DP solution. It keeps track of the minimum price we\\'ve seen so far and the maximum profit we can get from selling at the current price."
                    },
                    {
                        "username": "ssalinasfe",
                        "content": "I cannot solve this problems due to time limitex exceed. It is impossible due to one of the test case is a enormous array of input of 31915 elements,, and I get time limit exceeded only for traverse the array."
                    },
                    {
                        "username": "akarshannigam123",
                        "content": "The compiler has some problem with it as it is not performing appropriately and it is giving error while other compiler are giving correct output"
                    },
                    {
                        "username": "dynamic099",
                        "content": " int maxProfit(vector<int>& prices) {\\n        int mini = INT_MAX;\\n        int minIndex = 0;\\n        int buy ;\\n        int profit ;\\n        int i ; \\n        int n = prices.size();\\n        if(n==0||n==1)\\n        return 0 ;\\n        cout << n ;\\n        for (i = 0 ; i < prices.size() ; i++)\\n        {\\n            \\n            if(prices[i]<mini)\\n            {\\n                mini = prices[i];\\n                minIndex=i;\\n            }\\n            // cout<<\"The value of minIndex is \"<<minIndex;   \\n        }\\n        if(minIndex < n )\\n        {\\n            int max = prices[mini];\\n            for(int i=mini ; i < prices.size();i ++)\\n            {\\n                if(prices[i]>max)\\n                max=prices[i];\\n            }\\n            buy=prices[mini];\\n            profit=max-buy;\\n            return profit ;\\n        }\\n        else\\n        return 0 ;\\n    }\\n\\nWhy is this solution not working for the test case [1,2]"
                    },
                    {
                        "username": "bparanj",
                        "content": "Your current implementation has some logical and syntax errors. Here are some of the reasons why your solution might fail for the test case [1,2]:\\n\\n1. You have initialized `mini` as INT_MAX and then `max` as prices[mini]. This can be problematic because `mini` is the minimum value from the integer range, not the index. It looks like you\\'ve confused the variable `mini` (which is meant to store the minimum price) with `minIndex` (which is meant to store the index of the minimum price). So in the line where you have `int max = prices[mini];`, you should actually have `int max = prices[minIndex];`.\\n\\n2. Your check `if(minIndex < n )` doesn\\'t make sense because `minIndex` will always be less than `n` (which is prices.size()). This if block will always be true and is therefore not needed.\\n\\n3. In the for loop, you\\'ve used `mini` as the start index, but it should be `minIndex`. The loop should start from `minIndex`, not from `mini`.\\n\\nA corrected version of your function could look something like this:\\n\\n```cpp\\nint maxProfit(vector<int>& prices) {\\n    int mini = INT_MAX;\\n    int minIndex = 0;\\n    int n = prices.size();\\n\\n    if(n < 2)\\n        return 0;\\n\\n    // Find the minimum price and its index\\n    for (int i = 0 ; i < n ; i++) {\\n        if(prices[i] < mini) {\\n            mini = prices[i];\\n            minIndex = i;\\n        }\\n    }\\n\\n    // Find the maximum price after the minimum price\\n    int maxPrice = prices[minIndex];\\n    for(int i = minIndex ; i < n; i++) {\\n        if(prices[i] > maxPrice)\\n            maxPrice = prices[i];\\n    }\\n\\n    return maxPrice - mini;\\n}\\n```\\n\\nThis should now work correctly for the input [1,2]. However, this still has a linear time complexity and can be improved to a constant time complexity by keeping track of the minimum price and maximum profit simultaneously:\\n\\n```cpp\\nint maxProfit(vector<int>& prices) {\\n    int minPrice = INT_MAX;\\n    int maxProfit = 0;\\n\\n    for(int i = 0; i < prices.size(); i++) {\\n        if(prices[i] < minPrice) {\\n            minPrice = prices[i];\\n        } else if(prices[i] - minPrice > maxProfit) {\\n            maxProfit = prices[i] - minPrice;\\n        }\\n    }\\n\\n    return maxProfit;\\n}\\n```"
                    },
                    {
                        "username": "teenel",
                        "content": "I dont understand what\\'s wrong with last test? (211)\\nIt\\'s write `Time Limit Exceeded`\\nLast Executed Input `prices = ` (There is nothing, no zero, no digits). I make check for `null`, but it isn\\'t help.\\nAnd also there no output and excepted values"
                    }
                ]
            },
            {
                "id": 1912831,
                "content": [
                    {
                        "username": "anmolsankadiya",
                        "content": "can someone write dp relation for the recursion code below although it pass all the test \\n\\nclass Solution {\\npublic:\\n    int func(vector<int>& prices ,int i ,int e){\\n        if(i>=prices.size()) return 0;\\n        if(prices[i]>=e && e!=-1){\\n            return max(prices[i]-e , func(prices, i+1,e));\\n        }\\n        else return func(prices,i+1,prices[i]);\\n    }\\n    int maxProfit(vector<int>& prices) {\\n        return func(prices,0,-1);\\n    }\\n};\\n\\n"
                    },
                    {
                        "username": "gribeiro5000",
                        "content": "In testCase:\\nprices = [7, 1, 5, 3, 6, 4]\\nOutput = 5\\nExpected = 5\\nOK\\n\\nAfter i submited my code:\\nprices = [1, 2]\\nOutput = 2\\nExpected = 1"
                    },
                    {
                        "username": "gribeiro5000",
                        "content": "[@ashim_raibs](/ashim_raibs) You are right! Thank you! "
                    },
                    {
                        "username": "ashim_raibs",
                        "content": "you\\'re not supposed to return day, you have to return max profit"
                    },
                    {
                        "username": "dhanushhg",
                        "content": "Hey, i just need a small help, while i code this in VScode, it works, the same code i put it here and i\\'m constantly failing the test case 2, can anyone help me, what i am wrong with at? my code\\nclass Solution {\\n    static int profit=0;\\n    static int main_profit=0;\\n     public static int maxProfit(int[] prices) {\\n      for(int i=0;i<prices.length;i++){\\n        for(int j=i+1;j<prices.length;j++){\\n           main_profit= prices[j]-prices[i];\\n        //   System.out.println(main_profit);\\n            if(profit<main_profit){\\n        profit=main_profit;\\n       }      \\n        }\\n      }              \\n      if(profit<=0){\\n        profit= 0;\\n       }\\n     return profit;\\n} }\\n"
                    },
                    {
                        "username": "bparanj",
                        "content": "The reason you might be failing the second test case could be due to the static variables `profit` and `main_profit`. These variables maintain their values across multiple calls to the function `maxProfit`. If the function is being called more than once (as in the test environment of many online coding platforms), the old values of `profit` and `main_profit` could interfere with the calculations of subsequent calls, leading to incorrect results.\\n\\nHere\\'s your code, adjusted to remove the static variables:\\n\\n```java\\nclass Solution {\\n    public int maxProfit(int[] prices) {\\n        int profit = 0;\\n        int main_profit = 0;\\n\\n        for (int i = 0; i < prices.length; i++) {\\n            for (int j = i + 1; j < prices.length; j++) {\\n                main_profit = prices[j] - prices[i];\\n\\n                if (profit < main_profit) {\\n                    profit = main_profit;\\n                }\\n            }\\n        }\\n\\n        if (profit <= 0) {\\n            profit = 0;\\n        }\\n\\n        return profit;\\n    }\\n}\\n```\\n\\nPlease note that the inner for-loop in your implementation leads to a time complexity of O(n^2) which might cause a timeout for large inputs. A more efficient approach would be to keep track of the minimum price and the maximum profit during a single pass through the array.\\n\\nHere\\'s an efficient solution with O(n) complexity:\\n\\n```java\\nclass Solution {\\n    public int maxProfit(int[] prices) {\\n        int minPrice = Integer.MAX_VALUE;\\n        int maxProfit = 0;\\n        \\n        for (int i = 0; i < prices.length; i++) {\\n            if (prices[i] < minPrice) {\\n                minPrice = prices[i];\\n            } else if (prices[i] - minPrice > maxProfit) {\\n                maxProfit = prices[i] - minPrice;\\n            }\\n        }\\n        \\n        return maxProfit;\\n    }\\n}\\n```"
                    },
                    {
                        "username": "harishini45",
                        "content": "time limit exceeded yaar failed at 202 "
                    },
                    {
                        "username": "mdsang_97",
                        "content": "[1,2]\\noutput:2\\nexpected:1\\n?"
                    },
                    {
                        "username": "ashim_raibs",
                        "content": "1 is the maxProfit, not the day/index, I got confused too "
                    },
                    {
                        "username": "_DarKReapper_",
                        "content": "class Solution {\\n    vector<vector<int>> t;\\npublic:\\n    int maxProfit(vector<int>& prices) \\n    {\\n        int n = prices.size();\\n        t.resize(n + 1, vector<int>(2,-1));\\n        return rec(prices.size(),1,prices);       \\n    }\\n    int rec(int n,int s,vector<int>& nums )\\n    {\\n        if(n <= 0) return 0;\\n        \\n        if(t[n][s] != -1) return t[n][s]; \\n        if(s)\\n        {\\n            return t[n][s] = max(nums[n - 1] + rec(n -1, 0,nums),rec(n -1,s,nums));\\n        }\\n        else \\n        {\\n            return t[n][s] = max(rec(n -1,s,nums), -nums[n - 1] );\\n        }\\n    }\\n};\\n\\n-- why is this code not working and how to correct it?"
                    },
                    {
                        "username": "bparanj",
                        "content": "Your current approach seems to be trying to solve a slightly different problem. In the problem statement, you are asked to find the maximum profit with at most one transaction (buy one and sell one share of the stock). The solution you provided seems to be trying to solve a problem where you can buy and sell as many times as you want.\\n\\nHowever, your recursive function call seems to be a bit off. In the case where you\\'re not holding a stock (`s == 0`), you\\'re not subtracting from `rec(n - 1, 1, nums)` in the return statement, so it effectively ends up ignoring the buying operation and the cost associated with it.\\n\\nA simpler and more efficient approach would be as follows:\\n\\n```cpp\\nclass Solution {\\npublic:\\n    int maxProfit(vector<int>& prices) {\\n        int minPrice = INT_MAX;\\n        int maxProfit = 0;\\n        for(int i=0; i<prices.size(); i++) {\\n            minPrice = min(minPrice, prices[i]);\\n            maxProfit = max(maxProfit, prices[i] - minPrice);\\n        }\\n        return maxProfit;\\n    }\\n};\\n```\\n\\nThis solution works in O(n) time complexity and doesn\\'t require additional space like a DP solution. It keeps track of the minimum price we\\'ve seen so far and the maximum profit we can get from selling at the current price."
                    },
                    {
                        "username": "ssalinasfe",
                        "content": "I cannot solve this problems due to time limitex exceed. It is impossible due to one of the test case is a enormous array of input of 31915 elements,, and I get time limit exceeded only for traverse the array."
                    },
                    {
                        "username": "akarshannigam123",
                        "content": "The compiler has some problem with it as it is not performing appropriately and it is giving error while other compiler are giving correct output"
                    },
                    {
                        "username": "dynamic099",
                        "content": " int maxProfit(vector<int>& prices) {\\n        int mini = INT_MAX;\\n        int minIndex = 0;\\n        int buy ;\\n        int profit ;\\n        int i ; \\n        int n = prices.size();\\n        if(n==0||n==1)\\n        return 0 ;\\n        cout << n ;\\n        for (i = 0 ; i < prices.size() ; i++)\\n        {\\n            \\n            if(prices[i]<mini)\\n            {\\n                mini = prices[i];\\n                minIndex=i;\\n            }\\n            // cout<<\"The value of minIndex is \"<<minIndex;   \\n        }\\n        if(minIndex < n )\\n        {\\n            int max = prices[mini];\\n            for(int i=mini ; i < prices.size();i ++)\\n            {\\n                if(prices[i]>max)\\n                max=prices[i];\\n            }\\n            buy=prices[mini];\\n            profit=max-buy;\\n            return profit ;\\n        }\\n        else\\n        return 0 ;\\n    }\\n\\nWhy is this solution not working for the test case [1,2]"
                    },
                    {
                        "username": "bparanj",
                        "content": "Your current implementation has some logical and syntax errors. Here are some of the reasons why your solution might fail for the test case [1,2]:\\n\\n1. You have initialized `mini` as INT_MAX and then `max` as prices[mini]. This can be problematic because `mini` is the minimum value from the integer range, not the index. It looks like you\\'ve confused the variable `mini` (which is meant to store the minimum price) with `minIndex` (which is meant to store the index of the minimum price). So in the line where you have `int max = prices[mini];`, you should actually have `int max = prices[minIndex];`.\\n\\n2. Your check `if(minIndex < n )` doesn\\'t make sense because `minIndex` will always be less than `n` (which is prices.size()). This if block will always be true and is therefore not needed.\\n\\n3. In the for loop, you\\'ve used `mini` as the start index, but it should be `minIndex`. The loop should start from `minIndex`, not from `mini`.\\n\\nA corrected version of your function could look something like this:\\n\\n```cpp\\nint maxProfit(vector<int>& prices) {\\n    int mini = INT_MAX;\\n    int minIndex = 0;\\n    int n = prices.size();\\n\\n    if(n < 2)\\n        return 0;\\n\\n    // Find the minimum price and its index\\n    for (int i = 0 ; i < n ; i++) {\\n        if(prices[i] < mini) {\\n            mini = prices[i];\\n            minIndex = i;\\n        }\\n    }\\n\\n    // Find the maximum price after the minimum price\\n    int maxPrice = prices[minIndex];\\n    for(int i = minIndex ; i < n; i++) {\\n        if(prices[i] > maxPrice)\\n            maxPrice = prices[i];\\n    }\\n\\n    return maxPrice - mini;\\n}\\n```\\n\\nThis should now work correctly for the input [1,2]. However, this still has a linear time complexity and can be improved to a constant time complexity by keeping track of the minimum price and maximum profit simultaneously:\\n\\n```cpp\\nint maxProfit(vector<int>& prices) {\\n    int minPrice = INT_MAX;\\n    int maxProfit = 0;\\n\\n    for(int i = 0; i < prices.size(); i++) {\\n        if(prices[i] < minPrice) {\\n            minPrice = prices[i];\\n        } else if(prices[i] - minPrice > maxProfit) {\\n            maxProfit = prices[i] - minPrice;\\n        }\\n    }\\n\\n    return maxProfit;\\n}\\n```"
                    },
                    {
                        "username": "teenel",
                        "content": "I dont understand what\\'s wrong with last test? (211)\\nIt\\'s write `Time Limit Exceeded`\\nLast Executed Input `prices = ` (There is nothing, no zero, no digits). I make check for `null`, but it isn\\'t help.\\nAnd also there no output and excepted values"
                    }
                ]
            },
            {
                "id": 1912148,
                "content": [
                    {
                        "username": "dactung93",
                        "content": "At first, I used the nested loop and it went through very well with small array. However, with the last test case, it gave error because it had excessed the time limit.\n\nThen I realised that nested loop was not OK so maximum 1 loop.\nNow, let think what I can do with 1 loop? \nThen boom, using conditional structure inside the loop to find the smallest value and maximum profit by substructing the current value with smallest value (until the loop point).\n\nIn general, it will be like this (no real code)\n\nminValue = [integer max value]\nmaxProfit = 0\n\nloop i from 0 to prices.length\nif prices at position i < minValue then minValue = prices at position i\nelse if prices at position i subtract minValue is greater than maxProfit then maxProfit will be adjusted accordingly.\n\nAlso, you can use Min, Max without using conditional structure.\nminValue = min(minValue, Prices at i)\nmaxProfit = max(maxValue, Prices at i - minValue)\n\nIt will constantly change the minValue in order get the maximum Profit."
                    },
                    {
                        "username": "aysknt_02",
                        "content": "How to resolve the time exceeded issue at 200th testcase ?"
                    },
                    {
                        "username": "KayvanShah1",
                        "content": "Profit can also be maximized for first instance by selling on 1st day and buying on second day\\nInput: prices = [7,1,5,3,6,4]\\nOutput: 6\\n\\nExplanation: Sell on day 1 (price = 7) and buy on day 2 (price = 1), profit = 7-1 = 6."
                    },
                    {
                        "username": "zafar99",
                        "content": "def maxProfit(self, stocks: List[int]) -> int:\\n        outcomes = []\\n        for x in stocks:\\n            for y in stocks[stocks.index(x):]:\\n                outcomes.append(y-x)\\n        return max(outcomes)\\n\\nI am getting Memory Limit Exceeded problem. Why? "
                    },
                    {
                        "username": "bparanj",
                        "content": "The Memory Limit Exceeded error is likely due to the fact that you\\'re storing all possible outcomes in a list before returning the maximum. This can take up a lot of memory especially when the size of the `stocks` list is large.\\n\\nBesides, the time complexity of your solution is also high due to the nested for loops. The time complexity is approximately O(n^2), where n is the length of the `stocks` list. And, you are also using `stocks.index(x)` in your code, which takes O(n) time for each call, making your solution even slower.\\n\\nYou can solve this problem with a linear scan, which only needs to iterate through the `stocks` list once. \\n\\nHere is a more efficient approach using the concept of dynamic programming. This approach only uses O(1) memory and runs in O(n) time:\\n\\n```python\\ndef maxProfit(self, prices: List[int]) -> int:\\n    min_price = float(\\'inf\\')\\n    max_profit = 0\\n\\n    for price in prices:\\n        min_price = min(min_price, price)\\n        profit = price - min_price\\n        max_profit = max(max_profit, profit)\\n\\n    return max_profit\\n```\\n\\nIn this approach, you maintain a variable `min_price` to hold the minimum price seen so far and a variable `max_profit` to hold the maximum profit. You then iterate over the `prices` list updating `min_price` and `max_profit` accordingly. At the end of the loop, `max_profit` will hold the maximum profit that can be achieved."
                    },
                    {
                        "username": "Priyanshu626",
                        "content": "can we do this problem with O(N) time complexity"
                    },
                    {
                        "username": "bparanj",
                        "content": "Yes, this problem can indeed be solved in O(N) time complexity using a technique often referred to as the \"one pass\" approach, which involves a single iteration over the input list.\\n\\nThe key insight here is that the maximum profit that can be made from selling on a particular day is determined by the minimum price seen on any of the previous days. This suggests an algorithm: keep track of the minimum price seen so far, and for each day, check if selling on that day would yield a higher profit than any seen before.\\n\\nHere\\'s a Python implementation of this approach:\\n\\n```python\\ndef maxProfit(prices):\\n    min_price = float(\\'inf\\')  # initialize min_price to be a very large number\\n    max_profit = 0  # initialize max_profit to be 0\\n\\n    for price in prices:  # iterate through the list of prices\\n        if price < min_price:\\n            min_price = price  # update min_price if current price is less than min_price\\n        elif price - min_price > max_profit:\\n            max_profit = price - min_price  # update max_profit if the profit of selling now is more than max_profit\\n\\n    return max_profit\\n```\\n\\nIn this code, we go through the list of prices once, updating the minimum price and maximum profit as necessary. Thus, the time complexity is O(N), where N is the number of days (or the size of the input list). This is much more efficient than an approach that considers all pairs of days, which would have a time complexity of O(N^2)."
                    },
                    {
                        "username": "TandooriRoti",
                        "content": "Did the code in O(n) and still got TLE. After commenting the debug the test case passed successfully. I would suggest using Fast Input-Output for better results."
                    },
                    {
                        "username": "tommy787576",
                        "content": "[Complete Five solutions: One-pass / DP and Optimized DP / Maximum Subarray with Kadane\\'s alg or D&C](https://leetcode.com/problems/best-time-to-buy-and-sell-stock/solutions/3227281/complete-five-solutions-one-pass-dp-and-optimized-dp-maximum-subarray-with-kadane-s-alg-or-d-c/)\\nIf you find it helpful, please give me a star\\uD83D\\uDE00. Thank you!"
                    },
                    {
                        "username": "bader45berro",
                        "content": "can someone explain how this test case is working input [2,4,1] and the expected output is equal to 2\\n"
                    },
                    {
                        "username": "theerawatch",
                        "content": "buy 2, sell 4\\nprofit = 4-2 = 2"
                    },
                    {
                        "username": "anshuuuu____",
                        "content": "To solve this question in O(N) and constant space O(1) :-\n\n1. Make two variables maxprofit and mintillnow.\nmaxprofit=0 and mintillnow=prices[0]\n2. Traverse the array and findmin.\nmintillnow=min(mintillnow,prices[i]);\n3. find profit = prices[i]-mintillnow;\n4. update maxprofit\n\n\nHere we are trying to sell the stock everyday."
                    },
                    {
                        "username": "sahilshinde-45",
                        "content": "can anyone help me with runtime error i.e(Time Limit Exceeded) at 200th case.\\nbelow is my code\\n        profit = 0\\n        min_of_price = prices[0]\\n        for i in range(0,len(prices[1:])):\\n            min_of_price = min(min_of_price,prices[1:][i])\\n            profit = max(profit,prices[1:][i] - min_of_price)  \\n        return(profit)"
                    },
                    {
                        "username": "bparanj",
                        "content": "The issue in your code is that you\\'re slicing the `prices` list in every iteration of your loop, which leads to a large amount of unnecessary computation and increases the time complexity. The slice operation `prices[1:]` creates a new list in each iteration which takes additional time, resulting in a Time Limit Exceeded (TLE) error for large input.\\n\\nHere is the corrected version of your code:\\n\\n```python\\nprofit = 0\\nmin_of_price = prices[0]\\nfor i in range(1, len(prices)):\\n    min_of_price = min(min_of_price, prices[i])\\n    profit = max(profit, prices[i] - min_of_price)\\nreturn profit\\n```\\n\\nIn this code, we start iterating from the second day (`i = 1`) till the end of `prices` list. We find the minimum price till the current day and the maximum profit we could have made till now. This approach ensures we are only using a single pass through the `prices` list, thus achieving a linear time complexity O(N), where N is the size of the `prices` list."
                    }
                ]
            },
            {
                "id": 1903962,
                "content": [
                    {
                        "username": "dactung93",
                        "content": "At first, I used the nested loop and it went through very well with small array. However, with the last test case, it gave error because it had excessed the time limit.\n\nThen I realised that nested loop was not OK so maximum 1 loop.\nNow, let think what I can do with 1 loop? \nThen boom, using conditional structure inside the loop to find the smallest value and maximum profit by substructing the current value with smallest value (until the loop point).\n\nIn general, it will be like this (no real code)\n\nminValue = [integer max value]\nmaxProfit = 0\n\nloop i from 0 to prices.length\nif prices at position i < minValue then minValue = prices at position i\nelse if prices at position i subtract minValue is greater than maxProfit then maxProfit will be adjusted accordingly.\n\nAlso, you can use Min, Max without using conditional structure.\nminValue = min(minValue, Prices at i)\nmaxProfit = max(maxValue, Prices at i - minValue)\n\nIt will constantly change the minValue in order get the maximum Profit."
                    },
                    {
                        "username": "aysknt_02",
                        "content": "How to resolve the time exceeded issue at 200th testcase ?"
                    },
                    {
                        "username": "KayvanShah1",
                        "content": "Profit can also be maximized for first instance by selling on 1st day and buying on second day\\nInput: prices = [7,1,5,3,6,4]\\nOutput: 6\\n\\nExplanation: Sell on day 1 (price = 7) and buy on day 2 (price = 1), profit = 7-1 = 6."
                    },
                    {
                        "username": "zafar99",
                        "content": "def maxProfit(self, stocks: List[int]) -> int:\\n        outcomes = []\\n        for x in stocks:\\n            for y in stocks[stocks.index(x):]:\\n                outcomes.append(y-x)\\n        return max(outcomes)\\n\\nI am getting Memory Limit Exceeded problem. Why? "
                    },
                    {
                        "username": "bparanj",
                        "content": "The Memory Limit Exceeded error is likely due to the fact that you\\'re storing all possible outcomes in a list before returning the maximum. This can take up a lot of memory especially when the size of the `stocks` list is large.\\n\\nBesides, the time complexity of your solution is also high due to the nested for loops. The time complexity is approximately O(n^2), where n is the length of the `stocks` list. And, you are also using `stocks.index(x)` in your code, which takes O(n) time for each call, making your solution even slower.\\n\\nYou can solve this problem with a linear scan, which only needs to iterate through the `stocks` list once. \\n\\nHere is a more efficient approach using the concept of dynamic programming. This approach only uses O(1) memory and runs in O(n) time:\\n\\n```python\\ndef maxProfit(self, prices: List[int]) -> int:\\n    min_price = float(\\'inf\\')\\n    max_profit = 0\\n\\n    for price in prices:\\n        min_price = min(min_price, price)\\n        profit = price - min_price\\n        max_profit = max(max_profit, profit)\\n\\n    return max_profit\\n```\\n\\nIn this approach, you maintain a variable `min_price` to hold the minimum price seen so far and a variable `max_profit` to hold the maximum profit. You then iterate over the `prices` list updating `min_price` and `max_profit` accordingly. At the end of the loop, `max_profit` will hold the maximum profit that can be achieved."
                    },
                    {
                        "username": "Priyanshu626",
                        "content": "can we do this problem with O(N) time complexity"
                    },
                    {
                        "username": "bparanj",
                        "content": "Yes, this problem can indeed be solved in O(N) time complexity using a technique often referred to as the \"one pass\" approach, which involves a single iteration over the input list.\\n\\nThe key insight here is that the maximum profit that can be made from selling on a particular day is determined by the minimum price seen on any of the previous days. This suggests an algorithm: keep track of the minimum price seen so far, and for each day, check if selling on that day would yield a higher profit than any seen before.\\n\\nHere\\'s a Python implementation of this approach:\\n\\n```python\\ndef maxProfit(prices):\\n    min_price = float(\\'inf\\')  # initialize min_price to be a very large number\\n    max_profit = 0  # initialize max_profit to be 0\\n\\n    for price in prices:  # iterate through the list of prices\\n        if price < min_price:\\n            min_price = price  # update min_price if current price is less than min_price\\n        elif price - min_price > max_profit:\\n            max_profit = price - min_price  # update max_profit if the profit of selling now is more than max_profit\\n\\n    return max_profit\\n```\\n\\nIn this code, we go through the list of prices once, updating the minimum price and maximum profit as necessary. Thus, the time complexity is O(N), where N is the number of days (or the size of the input list). This is much more efficient than an approach that considers all pairs of days, which would have a time complexity of O(N^2)."
                    },
                    {
                        "username": "TandooriRoti",
                        "content": "Did the code in O(n) and still got TLE. After commenting the debug the test case passed successfully. I would suggest using Fast Input-Output for better results."
                    },
                    {
                        "username": "tommy787576",
                        "content": "[Complete Five solutions: One-pass / DP and Optimized DP / Maximum Subarray with Kadane\\'s alg or D&C](https://leetcode.com/problems/best-time-to-buy-and-sell-stock/solutions/3227281/complete-five-solutions-one-pass-dp-and-optimized-dp-maximum-subarray-with-kadane-s-alg-or-d-c/)\\nIf you find it helpful, please give me a star\\uD83D\\uDE00. Thank you!"
                    },
                    {
                        "username": "bader45berro",
                        "content": "can someone explain how this test case is working input [2,4,1] and the expected output is equal to 2\\n"
                    },
                    {
                        "username": "theerawatch",
                        "content": "buy 2, sell 4\\nprofit = 4-2 = 2"
                    },
                    {
                        "username": "anshuuuu____",
                        "content": "To solve this question in O(N) and constant space O(1) :-\n\n1. Make two variables maxprofit and mintillnow.\nmaxprofit=0 and mintillnow=prices[0]\n2. Traverse the array and findmin.\nmintillnow=min(mintillnow,prices[i]);\n3. find profit = prices[i]-mintillnow;\n4. update maxprofit\n\n\nHere we are trying to sell the stock everyday."
                    },
                    {
                        "username": "sahilshinde-45",
                        "content": "can anyone help me with runtime error i.e(Time Limit Exceeded) at 200th case.\\nbelow is my code\\n        profit = 0\\n        min_of_price = prices[0]\\n        for i in range(0,len(prices[1:])):\\n            min_of_price = min(min_of_price,prices[1:][i])\\n            profit = max(profit,prices[1:][i] - min_of_price)  \\n        return(profit)"
                    },
                    {
                        "username": "bparanj",
                        "content": "The issue in your code is that you\\'re slicing the `prices` list in every iteration of your loop, which leads to a large amount of unnecessary computation and increases the time complexity. The slice operation `prices[1:]` creates a new list in each iteration which takes additional time, resulting in a Time Limit Exceeded (TLE) error for large input.\\n\\nHere is the corrected version of your code:\\n\\n```python\\nprofit = 0\\nmin_of_price = prices[0]\\nfor i in range(1, len(prices)):\\n    min_of_price = min(min_of_price, prices[i])\\n    profit = max(profit, prices[i] - min_of_price)\\nreturn profit\\n```\\n\\nIn this code, we start iterating from the second day (`i = 1`) till the end of `prices` list. We find the minimum price till the current day and the maximum profit we could have made till now. This approach ensures we are only using a single pass through the `prices` list, thus achieving a linear time complexity O(N), where N is the size of the `prices` list."
                    }
                ]
            },
            {
                "id": 1903519,
                "content": [
                    {
                        "username": "dactung93",
                        "content": "At first, I used the nested loop and it went through very well with small array. However, with the last test case, it gave error because it had excessed the time limit.\n\nThen I realised that nested loop was not OK so maximum 1 loop.\nNow, let think what I can do with 1 loop? \nThen boom, using conditional structure inside the loop to find the smallest value and maximum profit by substructing the current value with smallest value (until the loop point).\n\nIn general, it will be like this (no real code)\n\nminValue = [integer max value]\nmaxProfit = 0\n\nloop i from 0 to prices.length\nif prices at position i < minValue then minValue = prices at position i\nelse if prices at position i subtract minValue is greater than maxProfit then maxProfit will be adjusted accordingly.\n\nAlso, you can use Min, Max without using conditional structure.\nminValue = min(minValue, Prices at i)\nmaxProfit = max(maxValue, Prices at i - minValue)\n\nIt will constantly change the minValue in order get the maximum Profit."
                    },
                    {
                        "username": "aysknt_02",
                        "content": "How to resolve the time exceeded issue at 200th testcase ?"
                    },
                    {
                        "username": "KayvanShah1",
                        "content": "Profit can also be maximized for first instance by selling on 1st day and buying on second day\\nInput: prices = [7,1,5,3,6,4]\\nOutput: 6\\n\\nExplanation: Sell on day 1 (price = 7) and buy on day 2 (price = 1), profit = 7-1 = 6."
                    },
                    {
                        "username": "zafar99",
                        "content": "def maxProfit(self, stocks: List[int]) -> int:\\n        outcomes = []\\n        for x in stocks:\\n            for y in stocks[stocks.index(x):]:\\n                outcomes.append(y-x)\\n        return max(outcomes)\\n\\nI am getting Memory Limit Exceeded problem. Why? "
                    },
                    {
                        "username": "bparanj",
                        "content": "The Memory Limit Exceeded error is likely due to the fact that you\\'re storing all possible outcomes in a list before returning the maximum. This can take up a lot of memory especially when the size of the `stocks` list is large.\\n\\nBesides, the time complexity of your solution is also high due to the nested for loops. The time complexity is approximately O(n^2), where n is the length of the `stocks` list. And, you are also using `stocks.index(x)` in your code, which takes O(n) time for each call, making your solution even slower.\\n\\nYou can solve this problem with a linear scan, which only needs to iterate through the `stocks` list once. \\n\\nHere is a more efficient approach using the concept of dynamic programming. This approach only uses O(1) memory and runs in O(n) time:\\n\\n```python\\ndef maxProfit(self, prices: List[int]) -> int:\\n    min_price = float(\\'inf\\')\\n    max_profit = 0\\n\\n    for price in prices:\\n        min_price = min(min_price, price)\\n        profit = price - min_price\\n        max_profit = max(max_profit, profit)\\n\\n    return max_profit\\n```\\n\\nIn this approach, you maintain a variable `min_price` to hold the minimum price seen so far and a variable `max_profit` to hold the maximum profit. You then iterate over the `prices` list updating `min_price` and `max_profit` accordingly. At the end of the loop, `max_profit` will hold the maximum profit that can be achieved."
                    },
                    {
                        "username": "Priyanshu626",
                        "content": "can we do this problem with O(N) time complexity"
                    },
                    {
                        "username": "bparanj",
                        "content": "Yes, this problem can indeed be solved in O(N) time complexity using a technique often referred to as the \"one pass\" approach, which involves a single iteration over the input list.\\n\\nThe key insight here is that the maximum profit that can be made from selling on a particular day is determined by the minimum price seen on any of the previous days. This suggests an algorithm: keep track of the minimum price seen so far, and for each day, check if selling on that day would yield a higher profit than any seen before.\\n\\nHere\\'s a Python implementation of this approach:\\n\\n```python\\ndef maxProfit(prices):\\n    min_price = float(\\'inf\\')  # initialize min_price to be a very large number\\n    max_profit = 0  # initialize max_profit to be 0\\n\\n    for price in prices:  # iterate through the list of prices\\n        if price < min_price:\\n            min_price = price  # update min_price if current price is less than min_price\\n        elif price - min_price > max_profit:\\n            max_profit = price - min_price  # update max_profit if the profit of selling now is more than max_profit\\n\\n    return max_profit\\n```\\n\\nIn this code, we go through the list of prices once, updating the minimum price and maximum profit as necessary. Thus, the time complexity is O(N), where N is the number of days (or the size of the input list). This is much more efficient than an approach that considers all pairs of days, which would have a time complexity of O(N^2)."
                    },
                    {
                        "username": "TandooriRoti",
                        "content": "Did the code in O(n) and still got TLE. After commenting the debug the test case passed successfully. I would suggest using Fast Input-Output for better results."
                    },
                    {
                        "username": "tommy787576",
                        "content": "[Complete Five solutions: One-pass / DP and Optimized DP / Maximum Subarray with Kadane\\'s alg or D&C](https://leetcode.com/problems/best-time-to-buy-and-sell-stock/solutions/3227281/complete-five-solutions-one-pass-dp-and-optimized-dp-maximum-subarray-with-kadane-s-alg-or-d-c/)\\nIf you find it helpful, please give me a star\\uD83D\\uDE00. Thank you!"
                    },
                    {
                        "username": "bader45berro",
                        "content": "can someone explain how this test case is working input [2,4,1] and the expected output is equal to 2\\n"
                    },
                    {
                        "username": "theerawatch",
                        "content": "buy 2, sell 4\\nprofit = 4-2 = 2"
                    },
                    {
                        "username": "anshuuuu____",
                        "content": "To solve this question in O(N) and constant space O(1) :-\n\n1. Make two variables maxprofit and mintillnow.\nmaxprofit=0 and mintillnow=prices[0]\n2. Traverse the array and findmin.\nmintillnow=min(mintillnow,prices[i]);\n3. find profit = prices[i]-mintillnow;\n4. update maxprofit\n\n\nHere we are trying to sell the stock everyday."
                    },
                    {
                        "username": "sahilshinde-45",
                        "content": "can anyone help me with runtime error i.e(Time Limit Exceeded) at 200th case.\\nbelow is my code\\n        profit = 0\\n        min_of_price = prices[0]\\n        for i in range(0,len(prices[1:])):\\n            min_of_price = min(min_of_price,prices[1:][i])\\n            profit = max(profit,prices[1:][i] - min_of_price)  \\n        return(profit)"
                    },
                    {
                        "username": "bparanj",
                        "content": "The issue in your code is that you\\'re slicing the `prices` list in every iteration of your loop, which leads to a large amount of unnecessary computation and increases the time complexity. The slice operation `prices[1:]` creates a new list in each iteration which takes additional time, resulting in a Time Limit Exceeded (TLE) error for large input.\\n\\nHere is the corrected version of your code:\\n\\n```python\\nprofit = 0\\nmin_of_price = prices[0]\\nfor i in range(1, len(prices)):\\n    min_of_price = min(min_of_price, prices[i])\\n    profit = max(profit, prices[i] - min_of_price)\\nreturn profit\\n```\\n\\nIn this code, we start iterating from the second day (`i = 1`) till the end of `prices` list. We find the minimum price till the current day and the maximum profit we could have made till now. This approach ensures we are only using a single pass through the `prices` list, thus achieving a linear time complexity O(N), where N is the size of the `prices` list."
                    }
                ]
            },
            {
                "id": 1901925,
                "content": [
                    {
                        "username": "dactung93",
                        "content": "At first, I used the nested loop and it went through very well with small array. However, with the last test case, it gave error because it had excessed the time limit.\n\nThen I realised that nested loop was not OK so maximum 1 loop.\nNow, let think what I can do with 1 loop? \nThen boom, using conditional structure inside the loop to find the smallest value and maximum profit by substructing the current value with smallest value (until the loop point).\n\nIn general, it will be like this (no real code)\n\nminValue = [integer max value]\nmaxProfit = 0\n\nloop i from 0 to prices.length\nif prices at position i < minValue then minValue = prices at position i\nelse if prices at position i subtract minValue is greater than maxProfit then maxProfit will be adjusted accordingly.\n\nAlso, you can use Min, Max without using conditional structure.\nminValue = min(minValue, Prices at i)\nmaxProfit = max(maxValue, Prices at i - minValue)\n\nIt will constantly change the minValue in order get the maximum Profit."
                    },
                    {
                        "username": "aysknt_02",
                        "content": "How to resolve the time exceeded issue at 200th testcase ?"
                    },
                    {
                        "username": "KayvanShah1",
                        "content": "Profit can also be maximized for first instance by selling on 1st day and buying on second day\\nInput: prices = [7,1,5,3,6,4]\\nOutput: 6\\n\\nExplanation: Sell on day 1 (price = 7) and buy on day 2 (price = 1), profit = 7-1 = 6."
                    },
                    {
                        "username": "zafar99",
                        "content": "def maxProfit(self, stocks: List[int]) -> int:\\n        outcomes = []\\n        for x in stocks:\\n            for y in stocks[stocks.index(x):]:\\n                outcomes.append(y-x)\\n        return max(outcomes)\\n\\nI am getting Memory Limit Exceeded problem. Why? "
                    },
                    {
                        "username": "bparanj",
                        "content": "The Memory Limit Exceeded error is likely due to the fact that you\\'re storing all possible outcomes in a list before returning the maximum. This can take up a lot of memory especially when the size of the `stocks` list is large.\\n\\nBesides, the time complexity of your solution is also high due to the nested for loops. The time complexity is approximately O(n^2), where n is the length of the `stocks` list. And, you are also using `stocks.index(x)` in your code, which takes O(n) time for each call, making your solution even slower.\\n\\nYou can solve this problem with a linear scan, which only needs to iterate through the `stocks` list once. \\n\\nHere is a more efficient approach using the concept of dynamic programming. This approach only uses O(1) memory and runs in O(n) time:\\n\\n```python\\ndef maxProfit(self, prices: List[int]) -> int:\\n    min_price = float(\\'inf\\')\\n    max_profit = 0\\n\\n    for price in prices:\\n        min_price = min(min_price, price)\\n        profit = price - min_price\\n        max_profit = max(max_profit, profit)\\n\\n    return max_profit\\n```\\n\\nIn this approach, you maintain a variable `min_price` to hold the minimum price seen so far and a variable `max_profit` to hold the maximum profit. You then iterate over the `prices` list updating `min_price` and `max_profit` accordingly. At the end of the loop, `max_profit` will hold the maximum profit that can be achieved."
                    },
                    {
                        "username": "Priyanshu626",
                        "content": "can we do this problem with O(N) time complexity"
                    },
                    {
                        "username": "bparanj",
                        "content": "Yes, this problem can indeed be solved in O(N) time complexity using a technique often referred to as the \"one pass\" approach, which involves a single iteration over the input list.\\n\\nThe key insight here is that the maximum profit that can be made from selling on a particular day is determined by the minimum price seen on any of the previous days. This suggests an algorithm: keep track of the minimum price seen so far, and for each day, check if selling on that day would yield a higher profit than any seen before.\\n\\nHere\\'s a Python implementation of this approach:\\n\\n```python\\ndef maxProfit(prices):\\n    min_price = float(\\'inf\\')  # initialize min_price to be a very large number\\n    max_profit = 0  # initialize max_profit to be 0\\n\\n    for price in prices:  # iterate through the list of prices\\n        if price < min_price:\\n            min_price = price  # update min_price if current price is less than min_price\\n        elif price - min_price > max_profit:\\n            max_profit = price - min_price  # update max_profit if the profit of selling now is more than max_profit\\n\\n    return max_profit\\n```\\n\\nIn this code, we go through the list of prices once, updating the minimum price and maximum profit as necessary. Thus, the time complexity is O(N), where N is the number of days (or the size of the input list). This is much more efficient than an approach that considers all pairs of days, which would have a time complexity of O(N^2)."
                    },
                    {
                        "username": "TandooriRoti",
                        "content": "Did the code in O(n) and still got TLE. After commenting the debug the test case passed successfully. I would suggest using Fast Input-Output for better results."
                    },
                    {
                        "username": "tommy787576",
                        "content": "[Complete Five solutions: One-pass / DP and Optimized DP / Maximum Subarray with Kadane\\'s alg or D&C](https://leetcode.com/problems/best-time-to-buy-and-sell-stock/solutions/3227281/complete-five-solutions-one-pass-dp-and-optimized-dp-maximum-subarray-with-kadane-s-alg-or-d-c/)\\nIf you find it helpful, please give me a star\\uD83D\\uDE00. Thank you!"
                    },
                    {
                        "username": "bader45berro",
                        "content": "can someone explain how this test case is working input [2,4,1] and the expected output is equal to 2\\n"
                    },
                    {
                        "username": "theerawatch",
                        "content": "buy 2, sell 4\\nprofit = 4-2 = 2"
                    },
                    {
                        "username": "anshuuuu____",
                        "content": "To solve this question in O(N) and constant space O(1) :-\n\n1. Make two variables maxprofit and mintillnow.\nmaxprofit=0 and mintillnow=prices[0]\n2. Traverse the array and findmin.\nmintillnow=min(mintillnow,prices[i]);\n3. find profit = prices[i]-mintillnow;\n4. update maxprofit\n\n\nHere we are trying to sell the stock everyday."
                    },
                    {
                        "username": "sahilshinde-45",
                        "content": "can anyone help me with runtime error i.e(Time Limit Exceeded) at 200th case.\\nbelow is my code\\n        profit = 0\\n        min_of_price = prices[0]\\n        for i in range(0,len(prices[1:])):\\n            min_of_price = min(min_of_price,prices[1:][i])\\n            profit = max(profit,prices[1:][i] - min_of_price)  \\n        return(profit)"
                    },
                    {
                        "username": "bparanj",
                        "content": "The issue in your code is that you\\'re slicing the `prices` list in every iteration of your loop, which leads to a large amount of unnecessary computation and increases the time complexity. The slice operation `prices[1:]` creates a new list in each iteration which takes additional time, resulting in a Time Limit Exceeded (TLE) error for large input.\\n\\nHere is the corrected version of your code:\\n\\n```python\\nprofit = 0\\nmin_of_price = prices[0]\\nfor i in range(1, len(prices)):\\n    min_of_price = min(min_of_price, prices[i])\\n    profit = max(profit, prices[i] - min_of_price)\\nreturn profit\\n```\\n\\nIn this code, we start iterating from the second day (`i = 1`) till the end of `prices` list. We find the minimum price till the current day and the maximum profit we could have made till now. This approach ensures we are only using a single pass through the `prices` list, thus achieving a linear time complexity O(N), where N is the size of the `prices` list."
                    }
                ]
            },
            {
                "id": 1898032,
                "content": [
                    {
                        "username": "dactung93",
                        "content": "At first, I used the nested loop and it went through very well with small array. However, with the last test case, it gave error because it had excessed the time limit.\n\nThen I realised that nested loop was not OK so maximum 1 loop.\nNow, let think what I can do with 1 loop? \nThen boom, using conditional structure inside the loop to find the smallest value and maximum profit by substructing the current value with smallest value (until the loop point).\n\nIn general, it will be like this (no real code)\n\nminValue = [integer max value]\nmaxProfit = 0\n\nloop i from 0 to prices.length\nif prices at position i < minValue then minValue = prices at position i\nelse if prices at position i subtract minValue is greater than maxProfit then maxProfit will be adjusted accordingly.\n\nAlso, you can use Min, Max without using conditional structure.\nminValue = min(minValue, Prices at i)\nmaxProfit = max(maxValue, Prices at i - minValue)\n\nIt will constantly change the minValue in order get the maximum Profit."
                    },
                    {
                        "username": "aysknt_02",
                        "content": "How to resolve the time exceeded issue at 200th testcase ?"
                    },
                    {
                        "username": "KayvanShah1",
                        "content": "Profit can also be maximized for first instance by selling on 1st day and buying on second day\\nInput: prices = [7,1,5,3,6,4]\\nOutput: 6\\n\\nExplanation: Sell on day 1 (price = 7) and buy on day 2 (price = 1), profit = 7-1 = 6."
                    },
                    {
                        "username": "zafar99",
                        "content": "def maxProfit(self, stocks: List[int]) -> int:\\n        outcomes = []\\n        for x in stocks:\\n            for y in stocks[stocks.index(x):]:\\n                outcomes.append(y-x)\\n        return max(outcomes)\\n\\nI am getting Memory Limit Exceeded problem. Why? "
                    },
                    {
                        "username": "bparanj",
                        "content": "The Memory Limit Exceeded error is likely due to the fact that you\\'re storing all possible outcomes in a list before returning the maximum. This can take up a lot of memory especially when the size of the `stocks` list is large.\\n\\nBesides, the time complexity of your solution is also high due to the nested for loops. The time complexity is approximately O(n^2), where n is the length of the `stocks` list. And, you are also using `stocks.index(x)` in your code, which takes O(n) time for each call, making your solution even slower.\\n\\nYou can solve this problem with a linear scan, which only needs to iterate through the `stocks` list once. \\n\\nHere is a more efficient approach using the concept of dynamic programming. This approach only uses O(1) memory and runs in O(n) time:\\n\\n```python\\ndef maxProfit(self, prices: List[int]) -> int:\\n    min_price = float(\\'inf\\')\\n    max_profit = 0\\n\\n    for price in prices:\\n        min_price = min(min_price, price)\\n        profit = price - min_price\\n        max_profit = max(max_profit, profit)\\n\\n    return max_profit\\n```\\n\\nIn this approach, you maintain a variable `min_price` to hold the minimum price seen so far and a variable `max_profit` to hold the maximum profit. You then iterate over the `prices` list updating `min_price` and `max_profit` accordingly. At the end of the loop, `max_profit` will hold the maximum profit that can be achieved."
                    },
                    {
                        "username": "Priyanshu626",
                        "content": "can we do this problem with O(N) time complexity"
                    },
                    {
                        "username": "bparanj",
                        "content": "Yes, this problem can indeed be solved in O(N) time complexity using a technique often referred to as the \"one pass\" approach, which involves a single iteration over the input list.\\n\\nThe key insight here is that the maximum profit that can be made from selling on a particular day is determined by the minimum price seen on any of the previous days. This suggests an algorithm: keep track of the minimum price seen so far, and for each day, check if selling on that day would yield a higher profit than any seen before.\\n\\nHere\\'s a Python implementation of this approach:\\n\\n```python\\ndef maxProfit(prices):\\n    min_price = float(\\'inf\\')  # initialize min_price to be a very large number\\n    max_profit = 0  # initialize max_profit to be 0\\n\\n    for price in prices:  # iterate through the list of prices\\n        if price < min_price:\\n            min_price = price  # update min_price if current price is less than min_price\\n        elif price - min_price > max_profit:\\n            max_profit = price - min_price  # update max_profit if the profit of selling now is more than max_profit\\n\\n    return max_profit\\n```\\n\\nIn this code, we go through the list of prices once, updating the minimum price and maximum profit as necessary. Thus, the time complexity is O(N), where N is the number of days (or the size of the input list). This is much more efficient than an approach that considers all pairs of days, which would have a time complexity of O(N^2)."
                    },
                    {
                        "username": "TandooriRoti",
                        "content": "Did the code in O(n) and still got TLE. After commenting the debug the test case passed successfully. I would suggest using Fast Input-Output for better results."
                    },
                    {
                        "username": "tommy787576",
                        "content": "[Complete Five solutions: One-pass / DP and Optimized DP / Maximum Subarray with Kadane\\'s alg or D&C](https://leetcode.com/problems/best-time-to-buy-and-sell-stock/solutions/3227281/complete-five-solutions-one-pass-dp-and-optimized-dp-maximum-subarray-with-kadane-s-alg-or-d-c/)\\nIf you find it helpful, please give me a star\\uD83D\\uDE00. Thank you!"
                    },
                    {
                        "username": "bader45berro",
                        "content": "can someone explain how this test case is working input [2,4,1] and the expected output is equal to 2\\n"
                    },
                    {
                        "username": "theerawatch",
                        "content": "buy 2, sell 4\\nprofit = 4-2 = 2"
                    },
                    {
                        "username": "anshuuuu____",
                        "content": "To solve this question in O(N) and constant space O(1) :-\n\n1. Make two variables maxprofit and mintillnow.\nmaxprofit=0 and mintillnow=prices[0]\n2. Traverse the array and findmin.\nmintillnow=min(mintillnow,prices[i]);\n3. find profit = prices[i]-mintillnow;\n4. update maxprofit\n\n\nHere we are trying to sell the stock everyday."
                    },
                    {
                        "username": "sahilshinde-45",
                        "content": "can anyone help me with runtime error i.e(Time Limit Exceeded) at 200th case.\\nbelow is my code\\n        profit = 0\\n        min_of_price = prices[0]\\n        for i in range(0,len(prices[1:])):\\n            min_of_price = min(min_of_price,prices[1:][i])\\n            profit = max(profit,prices[1:][i] - min_of_price)  \\n        return(profit)"
                    },
                    {
                        "username": "bparanj",
                        "content": "The issue in your code is that you\\'re slicing the `prices` list in every iteration of your loop, which leads to a large amount of unnecessary computation and increases the time complexity. The slice operation `prices[1:]` creates a new list in each iteration which takes additional time, resulting in a Time Limit Exceeded (TLE) error for large input.\\n\\nHere is the corrected version of your code:\\n\\n```python\\nprofit = 0\\nmin_of_price = prices[0]\\nfor i in range(1, len(prices)):\\n    min_of_price = min(min_of_price, prices[i])\\n    profit = max(profit, prices[i] - min_of_price)\\nreturn profit\\n```\\n\\nIn this code, we start iterating from the second day (`i = 1`) till the end of `prices` list. We find the minimum price till the current day and the maximum profit we could have made till now. This approach ensures we are only using a single pass through the `prices` list, thus achieving a linear time complexity O(N), where N is the size of the `prices` list."
                    }
                ]
            },
            {
                "id": 1896805,
                "content": [
                    {
                        "username": "dactung93",
                        "content": "At first, I used the nested loop and it went through very well with small array. However, with the last test case, it gave error because it had excessed the time limit.\n\nThen I realised that nested loop was not OK so maximum 1 loop.\nNow, let think what I can do with 1 loop? \nThen boom, using conditional structure inside the loop to find the smallest value and maximum profit by substructing the current value with smallest value (until the loop point).\n\nIn general, it will be like this (no real code)\n\nminValue = [integer max value]\nmaxProfit = 0\n\nloop i from 0 to prices.length\nif prices at position i < minValue then minValue = prices at position i\nelse if prices at position i subtract minValue is greater than maxProfit then maxProfit will be adjusted accordingly.\n\nAlso, you can use Min, Max without using conditional structure.\nminValue = min(minValue, Prices at i)\nmaxProfit = max(maxValue, Prices at i - minValue)\n\nIt will constantly change the minValue in order get the maximum Profit."
                    },
                    {
                        "username": "aysknt_02",
                        "content": "How to resolve the time exceeded issue at 200th testcase ?"
                    },
                    {
                        "username": "KayvanShah1",
                        "content": "Profit can also be maximized for first instance by selling on 1st day and buying on second day\\nInput: prices = [7,1,5,3,6,4]\\nOutput: 6\\n\\nExplanation: Sell on day 1 (price = 7) and buy on day 2 (price = 1), profit = 7-1 = 6."
                    },
                    {
                        "username": "zafar99",
                        "content": "def maxProfit(self, stocks: List[int]) -> int:\\n        outcomes = []\\n        for x in stocks:\\n            for y in stocks[stocks.index(x):]:\\n                outcomes.append(y-x)\\n        return max(outcomes)\\n\\nI am getting Memory Limit Exceeded problem. Why? "
                    },
                    {
                        "username": "bparanj",
                        "content": "The Memory Limit Exceeded error is likely due to the fact that you\\'re storing all possible outcomes in a list before returning the maximum. This can take up a lot of memory especially when the size of the `stocks` list is large.\\n\\nBesides, the time complexity of your solution is also high due to the nested for loops. The time complexity is approximately O(n^2), where n is the length of the `stocks` list. And, you are also using `stocks.index(x)` in your code, which takes O(n) time for each call, making your solution even slower.\\n\\nYou can solve this problem with a linear scan, which only needs to iterate through the `stocks` list once. \\n\\nHere is a more efficient approach using the concept of dynamic programming. This approach only uses O(1) memory and runs in O(n) time:\\n\\n```python\\ndef maxProfit(self, prices: List[int]) -> int:\\n    min_price = float(\\'inf\\')\\n    max_profit = 0\\n\\n    for price in prices:\\n        min_price = min(min_price, price)\\n        profit = price - min_price\\n        max_profit = max(max_profit, profit)\\n\\n    return max_profit\\n```\\n\\nIn this approach, you maintain a variable `min_price` to hold the minimum price seen so far and a variable `max_profit` to hold the maximum profit. You then iterate over the `prices` list updating `min_price` and `max_profit` accordingly. At the end of the loop, `max_profit` will hold the maximum profit that can be achieved."
                    },
                    {
                        "username": "Priyanshu626",
                        "content": "can we do this problem with O(N) time complexity"
                    },
                    {
                        "username": "bparanj",
                        "content": "Yes, this problem can indeed be solved in O(N) time complexity using a technique often referred to as the \"one pass\" approach, which involves a single iteration over the input list.\\n\\nThe key insight here is that the maximum profit that can be made from selling on a particular day is determined by the minimum price seen on any of the previous days. This suggests an algorithm: keep track of the minimum price seen so far, and for each day, check if selling on that day would yield a higher profit than any seen before.\\n\\nHere\\'s a Python implementation of this approach:\\n\\n```python\\ndef maxProfit(prices):\\n    min_price = float(\\'inf\\')  # initialize min_price to be a very large number\\n    max_profit = 0  # initialize max_profit to be 0\\n\\n    for price in prices:  # iterate through the list of prices\\n        if price < min_price:\\n            min_price = price  # update min_price if current price is less than min_price\\n        elif price - min_price > max_profit:\\n            max_profit = price - min_price  # update max_profit if the profit of selling now is more than max_profit\\n\\n    return max_profit\\n```\\n\\nIn this code, we go through the list of prices once, updating the minimum price and maximum profit as necessary. Thus, the time complexity is O(N), where N is the number of days (or the size of the input list). This is much more efficient than an approach that considers all pairs of days, which would have a time complexity of O(N^2)."
                    },
                    {
                        "username": "TandooriRoti",
                        "content": "Did the code in O(n) and still got TLE. After commenting the debug the test case passed successfully. I would suggest using Fast Input-Output for better results."
                    },
                    {
                        "username": "tommy787576",
                        "content": "[Complete Five solutions: One-pass / DP and Optimized DP / Maximum Subarray with Kadane\\'s alg or D&C](https://leetcode.com/problems/best-time-to-buy-and-sell-stock/solutions/3227281/complete-five-solutions-one-pass-dp-and-optimized-dp-maximum-subarray-with-kadane-s-alg-or-d-c/)\\nIf you find it helpful, please give me a star\\uD83D\\uDE00. Thank you!"
                    },
                    {
                        "username": "bader45berro",
                        "content": "can someone explain how this test case is working input [2,4,1] and the expected output is equal to 2\\n"
                    },
                    {
                        "username": "theerawatch",
                        "content": "buy 2, sell 4\\nprofit = 4-2 = 2"
                    },
                    {
                        "username": "anshuuuu____",
                        "content": "To solve this question in O(N) and constant space O(1) :-\n\n1. Make two variables maxprofit and mintillnow.\nmaxprofit=0 and mintillnow=prices[0]\n2. Traverse the array and findmin.\nmintillnow=min(mintillnow,prices[i]);\n3. find profit = prices[i]-mintillnow;\n4. update maxprofit\n\n\nHere we are trying to sell the stock everyday."
                    },
                    {
                        "username": "sahilshinde-45",
                        "content": "can anyone help me with runtime error i.e(Time Limit Exceeded) at 200th case.\\nbelow is my code\\n        profit = 0\\n        min_of_price = prices[0]\\n        for i in range(0,len(prices[1:])):\\n            min_of_price = min(min_of_price,prices[1:][i])\\n            profit = max(profit,prices[1:][i] - min_of_price)  \\n        return(profit)"
                    },
                    {
                        "username": "bparanj",
                        "content": "The issue in your code is that you\\'re slicing the `prices` list in every iteration of your loop, which leads to a large amount of unnecessary computation and increases the time complexity. The slice operation `prices[1:]` creates a new list in each iteration which takes additional time, resulting in a Time Limit Exceeded (TLE) error for large input.\\n\\nHere is the corrected version of your code:\\n\\n```python\\nprofit = 0\\nmin_of_price = prices[0]\\nfor i in range(1, len(prices)):\\n    min_of_price = min(min_of_price, prices[i])\\n    profit = max(profit, prices[i] - min_of_price)\\nreturn profit\\n```\\n\\nIn this code, we start iterating from the second day (`i = 1`) till the end of `prices` list. We find the minimum price till the current day and the maximum profit we could have made till now. This approach ensures we are only using a single pass through the `prices` list, thus achieving a linear time complexity O(N), where N is the size of the `prices` list."
                    }
                ]
            },
            {
                "id": 1887292,
                "content": [
                    {
                        "username": "dactung93",
                        "content": "At first, I used the nested loop and it went through very well with small array. However, with the last test case, it gave error because it had excessed the time limit.\n\nThen I realised that nested loop was not OK so maximum 1 loop.\nNow, let think what I can do with 1 loop? \nThen boom, using conditional structure inside the loop to find the smallest value and maximum profit by substructing the current value with smallest value (until the loop point).\n\nIn general, it will be like this (no real code)\n\nminValue = [integer max value]\nmaxProfit = 0\n\nloop i from 0 to prices.length\nif prices at position i < minValue then minValue = prices at position i\nelse if prices at position i subtract minValue is greater than maxProfit then maxProfit will be adjusted accordingly.\n\nAlso, you can use Min, Max without using conditional structure.\nminValue = min(minValue, Prices at i)\nmaxProfit = max(maxValue, Prices at i - minValue)\n\nIt will constantly change the minValue in order get the maximum Profit."
                    },
                    {
                        "username": "aysknt_02",
                        "content": "How to resolve the time exceeded issue at 200th testcase ?"
                    },
                    {
                        "username": "KayvanShah1",
                        "content": "Profit can also be maximized for first instance by selling on 1st day and buying on second day\\nInput: prices = [7,1,5,3,6,4]\\nOutput: 6\\n\\nExplanation: Sell on day 1 (price = 7) and buy on day 2 (price = 1), profit = 7-1 = 6."
                    },
                    {
                        "username": "zafar99",
                        "content": "def maxProfit(self, stocks: List[int]) -> int:\\n        outcomes = []\\n        for x in stocks:\\n            for y in stocks[stocks.index(x):]:\\n                outcomes.append(y-x)\\n        return max(outcomes)\\n\\nI am getting Memory Limit Exceeded problem. Why? "
                    },
                    {
                        "username": "bparanj",
                        "content": "The Memory Limit Exceeded error is likely due to the fact that you\\'re storing all possible outcomes in a list before returning the maximum. This can take up a lot of memory especially when the size of the `stocks` list is large.\\n\\nBesides, the time complexity of your solution is also high due to the nested for loops. The time complexity is approximately O(n^2), where n is the length of the `stocks` list. And, you are also using `stocks.index(x)` in your code, which takes O(n) time for each call, making your solution even slower.\\n\\nYou can solve this problem with a linear scan, which only needs to iterate through the `stocks` list once. \\n\\nHere is a more efficient approach using the concept of dynamic programming. This approach only uses O(1) memory and runs in O(n) time:\\n\\n```python\\ndef maxProfit(self, prices: List[int]) -> int:\\n    min_price = float(\\'inf\\')\\n    max_profit = 0\\n\\n    for price in prices:\\n        min_price = min(min_price, price)\\n        profit = price - min_price\\n        max_profit = max(max_profit, profit)\\n\\n    return max_profit\\n```\\n\\nIn this approach, you maintain a variable `min_price` to hold the minimum price seen so far and a variable `max_profit` to hold the maximum profit. You then iterate over the `prices` list updating `min_price` and `max_profit` accordingly. At the end of the loop, `max_profit` will hold the maximum profit that can be achieved."
                    },
                    {
                        "username": "Priyanshu626",
                        "content": "can we do this problem with O(N) time complexity"
                    },
                    {
                        "username": "bparanj",
                        "content": "Yes, this problem can indeed be solved in O(N) time complexity using a technique often referred to as the \"one pass\" approach, which involves a single iteration over the input list.\\n\\nThe key insight here is that the maximum profit that can be made from selling on a particular day is determined by the minimum price seen on any of the previous days. This suggests an algorithm: keep track of the minimum price seen so far, and for each day, check if selling on that day would yield a higher profit than any seen before.\\n\\nHere\\'s a Python implementation of this approach:\\n\\n```python\\ndef maxProfit(prices):\\n    min_price = float(\\'inf\\')  # initialize min_price to be a very large number\\n    max_profit = 0  # initialize max_profit to be 0\\n\\n    for price in prices:  # iterate through the list of prices\\n        if price < min_price:\\n            min_price = price  # update min_price if current price is less than min_price\\n        elif price - min_price > max_profit:\\n            max_profit = price - min_price  # update max_profit if the profit of selling now is more than max_profit\\n\\n    return max_profit\\n```\\n\\nIn this code, we go through the list of prices once, updating the minimum price and maximum profit as necessary. Thus, the time complexity is O(N), where N is the number of days (or the size of the input list). This is much more efficient than an approach that considers all pairs of days, which would have a time complexity of O(N^2)."
                    },
                    {
                        "username": "TandooriRoti",
                        "content": "Did the code in O(n) and still got TLE. After commenting the debug the test case passed successfully. I would suggest using Fast Input-Output for better results."
                    },
                    {
                        "username": "tommy787576",
                        "content": "[Complete Five solutions: One-pass / DP and Optimized DP / Maximum Subarray with Kadane\\'s alg or D&C](https://leetcode.com/problems/best-time-to-buy-and-sell-stock/solutions/3227281/complete-five-solutions-one-pass-dp-and-optimized-dp-maximum-subarray-with-kadane-s-alg-or-d-c/)\\nIf you find it helpful, please give me a star\\uD83D\\uDE00. Thank you!"
                    },
                    {
                        "username": "bader45berro",
                        "content": "can someone explain how this test case is working input [2,4,1] and the expected output is equal to 2\\n"
                    },
                    {
                        "username": "theerawatch",
                        "content": "buy 2, sell 4\\nprofit = 4-2 = 2"
                    },
                    {
                        "username": "anshuuuu____",
                        "content": "To solve this question in O(N) and constant space O(1) :-\n\n1. Make two variables maxprofit and mintillnow.\nmaxprofit=0 and mintillnow=prices[0]\n2. Traverse the array and findmin.\nmintillnow=min(mintillnow,prices[i]);\n3. find profit = prices[i]-mintillnow;\n4. update maxprofit\n\n\nHere we are trying to sell the stock everyday."
                    },
                    {
                        "username": "sahilshinde-45",
                        "content": "can anyone help me with runtime error i.e(Time Limit Exceeded) at 200th case.\\nbelow is my code\\n        profit = 0\\n        min_of_price = prices[0]\\n        for i in range(0,len(prices[1:])):\\n            min_of_price = min(min_of_price,prices[1:][i])\\n            profit = max(profit,prices[1:][i] - min_of_price)  \\n        return(profit)"
                    },
                    {
                        "username": "bparanj",
                        "content": "The issue in your code is that you\\'re slicing the `prices` list in every iteration of your loop, which leads to a large amount of unnecessary computation and increases the time complexity. The slice operation `prices[1:]` creates a new list in each iteration which takes additional time, resulting in a Time Limit Exceeded (TLE) error for large input.\\n\\nHere is the corrected version of your code:\\n\\n```python\\nprofit = 0\\nmin_of_price = prices[0]\\nfor i in range(1, len(prices)):\\n    min_of_price = min(min_of_price, prices[i])\\n    profit = max(profit, prices[i] - min_of_price)\\nreturn profit\\n```\\n\\nIn this code, we start iterating from the second day (`i = 1`) till the end of `prices` list. We find the minimum price till the current day and the maximum profit we could have made till now. This approach ensures we are only using a single pass through the `prices` list, thus achieving a linear time complexity O(N), where N is the size of the `prices` list."
                    }
                ]
            },
            {
                "id": 1876807,
                "content": [
                    {
                        "username": "dactung93",
                        "content": "At first, I used the nested loop and it went through very well with small array. However, with the last test case, it gave error because it had excessed the time limit.\n\nThen I realised that nested loop was not OK so maximum 1 loop.\nNow, let think what I can do with 1 loop? \nThen boom, using conditional structure inside the loop to find the smallest value and maximum profit by substructing the current value with smallest value (until the loop point).\n\nIn general, it will be like this (no real code)\n\nminValue = [integer max value]\nmaxProfit = 0\n\nloop i from 0 to prices.length\nif prices at position i < minValue then minValue = prices at position i\nelse if prices at position i subtract minValue is greater than maxProfit then maxProfit will be adjusted accordingly.\n\nAlso, you can use Min, Max without using conditional structure.\nminValue = min(minValue, Prices at i)\nmaxProfit = max(maxValue, Prices at i - minValue)\n\nIt will constantly change the minValue in order get the maximum Profit."
                    },
                    {
                        "username": "aysknt_02",
                        "content": "How to resolve the time exceeded issue at 200th testcase ?"
                    },
                    {
                        "username": "KayvanShah1",
                        "content": "Profit can also be maximized for first instance by selling on 1st day and buying on second day\\nInput: prices = [7,1,5,3,6,4]\\nOutput: 6\\n\\nExplanation: Sell on day 1 (price = 7) and buy on day 2 (price = 1), profit = 7-1 = 6."
                    },
                    {
                        "username": "zafar99",
                        "content": "def maxProfit(self, stocks: List[int]) -> int:\\n        outcomes = []\\n        for x in stocks:\\n            for y in stocks[stocks.index(x):]:\\n                outcomes.append(y-x)\\n        return max(outcomes)\\n\\nI am getting Memory Limit Exceeded problem. Why? "
                    },
                    {
                        "username": "bparanj",
                        "content": "The Memory Limit Exceeded error is likely due to the fact that you\\'re storing all possible outcomes in a list before returning the maximum. This can take up a lot of memory especially when the size of the `stocks` list is large.\\n\\nBesides, the time complexity of your solution is also high due to the nested for loops. The time complexity is approximately O(n^2), where n is the length of the `stocks` list. And, you are also using `stocks.index(x)` in your code, which takes O(n) time for each call, making your solution even slower.\\n\\nYou can solve this problem with a linear scan, which only needs to iterate through the `stocks` list once. \\n\\nHere is a more efficient approach using the concept of dynamic programming. This approach only uses O(1) memory and runs in O(n) time:\\n\\n```python\\ndef maxProfit(self, prices: List[int]) -> int:\\n    min_price = float(\\'inf\\')\\n    max_profit = 0\\n\\n    for price in prices:\\n        min_price = min(min_price, price)\\n        profit = price - min_price\\n        max_profit = max(max_profit, profit)\\n\\n    return max_profit\\n```\\n\\nIn this approach, you maintain a variable `min_price` to hold the minimum price seen so far and a variable `max_profit` to hold the maximum profit. You then iterate over the `prices` list updating `min_price` and `max_profit` accordingly. At the end of the loop, `max_profit` will hold the maximum profit that can be achieved."
                    },
                    {
                        "username": "Priyanshu626",
                        "content": "can we do this problem with O(N) time complexity"
                    },
                    {
                        "username": "bparanj",
                        "content": "Yes, this problem can indeed be solved in O(N) time complexity using a technique often referred to as the \"one pass\" approach, which involves a single iteration over the input list.\\n\\nThe key insight here is that the maximum profit that can be made from selling on a particular day is determined by the minimum price seen on any of the previous days. This suggests an algorithm: keep track of the minimum price seen so far, and for each day, check if selling on that day would yield a higher profit than any seen before.\\n\\nHere\\'s a Python implementation of this approach:\\n\\n```python\\ndef maxProfit(prices):\\n    min_price = float(\\'inf\\')  # initialize min_price to be a very large number\\n    max_profit = 0  # initialize max_profit to be 0\\n\\n    for price in prices:  # iterate through the list of prices\\n        if price < min_price:\\n            min_price = price  # update min_price if current price is less than min_price\\n        elif price - min_price > max_profit:\\n            max_profit = price - min_price  # update max_profit if the profit of selling now is more than max_profit\\n\\n    return max_profit\\n```\\n\\nIn this code, we go through the list of prices once, updating the minimum price and maximum profit as necessary. Thus, the time complexity is O(N), where N is the number of days (or the size of the input list). This is much more efficient than an approach that considers all pairs of days, which would have a time complexity of O(N^2)."
                    },
                    {
                        "username": "TandooriRoti",
                        "content": "Did the code in O(n) and still got TLE. After commenting the debug the test case passed successfully. I would suggest using Fast Input-Output for better results."
                    },
                    {
                        "username": "tommy787576",
                        "content": "[Complete Five solutions: One-pass / DP and Optimized DP / Maximum Subarray with Kadane\\'s alg or D&C](https://leetcode.com/problems/best-time-to-buy-and-sell-stock/solutions/3227281/complete-five-solutions-one-pass-dp-and-optimized-dp-maximum-subarray-with-kadane-s-alg-or-d-c/)\\nIf you find it helpful, please give me a star\\uD83D\\uDE00. Thank you!"
                    },
                    {
                        "username": "bader45berro",
                        "content": "can someone explain how this test case is working input [2,4,1] and the expected output is equal to 2\\n"
                    },
                    {
                        "username": "theerawatch",
                        "content": "buy 2, sell 4\\nprofit = 4-2 = 2"
                    },
                    {
                        "username": "anshuuuu____",
                        "content": "To solve this question in O(N) and constant space O(1) :-\n\n1. Make two variables maxprofit and mintillnow.\nmaxprofit=0 and mintillnow=prices[0]\n2. Traverse the array and findmin.\nmintillnow=min(mintillnow,prices[i]);\n3. find profit = prices[i]-mintillnow;\n4. update maxprofit\n\n\nHere we are trying to sell the stock everyday."
                    },
                    {
                        "username": "sahilshinde-45",
                        "content": "can anyone help me with runtime error i.e(Time Limit Exceeded) at 200th case.\\nbelow is my code\\n        profit = 0\\n        min_of_price = prices[0]\\n        for i in range(0,len(prices[1:])):\\n            min_of_price = min(min_of_price,prices[1:][i])\\n            profit = max(profit,prices[1:][i] - min_of_price)  \\n        return(profit)"
                    },
                    {
                        "username": "bparanj",
                        "content": "The issue in your code is that you\\'re slicing the `prices` list in every iteration of your loop, which leads to a large amount of unnecessary computation and increases the time complexity. The slice operation `prices[1:]` creates a new list in each iteration which takes additional time, resulting in a Time Limit Exceeded (TLE) error for large input.\\n\\nHere is the corrected version of your code:\\n\\n```python\\nprofit = 0\\nmin_of_price = prices[0]\\nfor i in range(1, len(prices)):\\n    min_of_price = min(min_of_price, prices[i])\\n    profit = max(profit, prices[i] - min_of_price)\\nreturn profit\\n```\\n\\nIn this code, we start iterating from the second day (`i = 1`) till the end of `prices` list. We find the minimum price till the current day and the maximum profit we could have made till now. This approach ensures we are only using a single pass through the `prices` list, thus achieving a linear time complexity O(N), where N is the size of the `prices` list."
                    }
                ]
            },
            {
                "id": 1872643,
                "content": [
                    {
                        "username": "dactung93",
                        "content": "At first, I used the nested loop and it went through very well with small array. However, with the last test case, it gave error because it had excessed the time limit.\n\nThen I realised that nested loop was not OK so maximum 1 loop.\nNow, let think what I can do with 1 loop? \nThen boom, using conditional structure inside the loop to find the smallest value and maximum profit by substructing the current value with smallest value (until the loop point).\n\nIn general, it will be like this (no real code)\n\nminValue = [integer max value]\nmaxProfit = 0\n\nloop i from 0 to prices.length\nif prices at position i < minValue then minValue = prices at position i\nelse if prices at position i subtract minValue is greater than maxProfit then maxProfit will be adjusted accordingly.\n\nAlso, you can use Min, Max without using conditional structure.\nminValue = min(minValue, Prices at i)\nmaxProfit = max(maxValue, Prices at i - minValue)\n\nIt will constantly change the minValue in order get the maximum Profit."
                    },
                    {
                        "username": "aysknt_02",
                        "content": "How to resolve the time exceeded issue at 200th testcase ?"
                    },
                    {
                        "username": "KayvanShah1",
                        "content": "Profit can also be maximized for first instance by selling on 1st day and buying on second day\\nInput: prices = [7,1,5,3,6,4]\\nOutput: 6\\n\\nExplanation: Sell on day 1 (price = 7) and buy on day 2 (price = 1), profit = 7-1 = 6."
                    },
                    {
                        "username": "zafar99",
                        "content": "def maxProfit(self, stocks: List[int]) -> int:\\n        outcomes = []\\n        for x in stocks:\\n            for y in stocks[stocks.index(x):]:\\n                outcomes.append(y-x)\\n        return max(outcomes)\\n\\nI am getting Memory Limit Exceeded problem. Why? "
                    },
                    {
                        "username": "bparanj",
                        "content": "The Memory Limit Exceeded error is likely due to the fact that you\\'re storing all possible outcomes in a list before returning the maximum. This can take up a lot of memory especially when the size of the `stocks` list is large.\\n\\nBesides, the time complexity of your solution is also high due to the nested for loops. The time complexity is approximately O(n^2), where n is the length of the `stocks` list. And, you are also using `stocks.index(x)` in your code, which takes O(n) time for each call, making your solution even slower.\\n\\nYou can solve this problem with a linear scan, which only needs to iterate through the `stocks` list once. \\n\\nHere is a more efficient approach using the concept of dynamic programming. This approach only uses O(1) memory and runs in O(n) time:\\n\\n```python\\ndef maxProfit(self, prices: List[int]) -> int:\\n    min_price = float(\\'inf\\')\\n    max_profit = 0\\n\\n    for price in prices:\\n        min_price = min(min_price, price)\\n        profit = price - min_price\\n        max_profit = max(max_profit, profit)\\n\\n    return max_profit\\n```\\n\\nIn this approach, you maintain a variable `min_price` to hold the minimum price seen so far and a variable `max_profit` to hold the maximum profit. You then iterate over the `prices` list updating `min_price` and `max_profit` accordingly. At the end of the loop, `max_profit` will hold the maximum profit that can be achieved."
                    },
                    {
                        "username": "Priyanshu626",
                        "content": "can we do this problem with O(N) time complexity"
                    },
                    {
                        "username": "bparanj",
                        "content": "Yes, this problem can indeed be solved in O(N) time complexity using a technique often referred to as the \"one pass\" approach, which involves a single iteration over the input list.\\n\\nThe key insight here is that the maximum profit that can be made from selling on a particular day is determined by the minimum price seen on any of the previous days. This suggests an algorithm: keep track of the minimum price seen so far, and for each day, check if selling on that day would yield a higher profit than any seen before.\\n\\nHere\\'s a Python implementation of this approach:\\n\\n```python\\ndef maxProfit(prices):\\n    min_price = float(\\'inf\\')  # initialize min_price to be a very large number\\n    max_profit = 0  # initialize max_profit to be 0\\n\\n    for price in prices:  # iterate through the list of prices\\n        if price < min_price:\\n            min_price = price  # update min_price if current price is less than min_price\\n        elif price - min_price > max_profit:\\n            max_profit = price - min_price  # update max_profit if the profit of selling now is more than max_profit\\n\\n    return max_profit\\n```\\n\\nIn this code, we go through the list of prices once, updating the minimum price and maximum profit as necessary. Thus, the time complexity is O(N), where N is the number of days (or the size of the input list). This is much more efficient than an approach that considers all pairs of days, which would have a time complexity of O(N^2)."
                    },
                    {
                        "username": "TandooriRoti",
                        "content": "Did the code in O(n) and still got TLE. After commenting the debug the test case passed successfully. I would suggest using Fast Input-Output for better results."
                    },
                    {
                        "username": "tommy787576",
                        "content": "[Complete Five solutions: One-pass / DP and Optimized DP / Maximum Subarray with Kadane\\'s alg or D&C](https://leetcode.com/problems/best-time-to-buy-and-sell-stock/solutions/3227281/complete-five-solutions-one-pass-dp-and-optimized-dp-maximum-subarray-with-kadane-s-alg-or-d-c/)\\nIf you find it helpful, please give me a star\\uD83D\\uDE00. Thank you!"
                    },
                    {
                        "username": "bader45berro",
                        "content": "can someone explain how this test case is working input [2,4,1] and the expected output is equal to 2\\n"
                    },
                    {
                        "username": "theerawatch",
                        "content": "buy 2, sell 4\\nprofit = 4-2 = 2"
                    },
                    {
                        "username": "anshuuuu____",
                        "content": "To solve this question in O(N) and constant space O(1) :-\n\n1. Make two variables maxprofit and mintillnow.\nmaxprofit=0 and mintillnow=prices[0]\n2. Traverse the array and findmin.\nmintillnow=min(mintillnow,prices[i]);\n3. find profit = prices[i]-mintillnow;\n4. update maxprofit\n\n\nHere we are trying to sell the stock everyday."
                    },
                    {
                        "username": "sahilshinde-45",
                        "content": "can anyone help me with runtime error i.e(Time Limit Exceeded) at 200th case.\\nbelow is my code\\n        profit = 0\\n        min_of_price = prices[0]\\n        for i in range(0,len(prices[1:])):\\n            min_of_price = min(min_of_price,prices[1:][i])\\n            profit = max(profit,prices[1:][i] - min_of_price)  \\n        return(profit)"
                    },
                    {
                        "username": "bparanj",
                        "content": "The issue in your code is that you\\'re slicing the `prices` list in every iteration of your loop, which leads to a large amount of unnecessary computation and increases the time complexity. The slice operation `prices[1:]` creates a new list in each iteration which takes additional time, resulting in a Time Limit Exceeded (TLE) error for large input.\\n\\nHere is the corrected version of your code:\\n\\n```python\\nprofit = 0\\nmin_of_price = prices[0]\\nfor i in range(1, len(prices)):\\n    min_of_price = min(min_of_price, prices[i])\\n    profit = max(profit, prices[i] - min_of_price)\\nreturn profit\\n```\\n\\nIn this code, we start iterating from the second day (`i = 1`) till the end of `prices` list. We find the minimum price till the current day and the maximum profit we could have made till now. This approach ensures we are only using a single pass through the `prices` list, thus achieving a linear time complexity O(N), where N is the size of the `prices` list."
                    }
                ]
            },
            {
                "id": 1862252,
                "content": [
                    {
                        "username": "dactung93",
                        "content": "At first, I used the nested loop and it went through very well with small array. However, with the last test case, it gave error because it had excessed the time limit.\n\nThen I realised that nested loop was not OK so maximum 1 loop.\nNow, let think what I can do with 1 loop? \nThen boom, using conditional structure inside the loop to find the smallest value and maximum profit by substructing the current value with smallest value (until the loop point).\n\nIn general, it will be like this (no real code)\n\nminValue = [integer max value]\nmaxProfit = 0\n\nloop i from 0 to prices.length\nif prices at position i < minValue then minValue = prices at position i\nelse if prices at position i subtract minValue is greater than maxProfit then maxProfit will be adjusted accordingly.\n\nAlso, you can use Min, Max without using conditional structure.\nminValue = min(minValue, Prices at i)\nmaxProfit = max(maxValue, Prices at i - minValue)\n\nIt will constantly change the minValue in order get the maximum Profit."
                    },
                    {
                        "username": "aysknt_02",
                        "content": "How to resolve the time exceeded issue at 200th testcase ?"
                    },
                    {
                        "username": "KayvanShah1",
                        "content": "Profit can also be maximized for first instance by selling on 1st day and buying on second day\\nInput: prices = [7,1,5,3,6,4]\\nOutput: 6\\n\\nExplanation: Sell on day 1 (price = 7) and buy on day 2 (price = 1), profit = 7-1 = 6."
                    },
                    {
                        "username": "zafar99",
                        "content": "def maxProfit(self, stocks: List[int]) -> int:\\n        outcomes = []\\n        for x in stocks:\\n            for y in stocks[stocks.index(x):]:\\n                outcomes.append(y-x)\\n        return max(outcomes)\\n\\nI am getting Memory Limit Exceeded problem. Why? "
                    },
                    {
                        "username": "bparanj",
                        "content": "The Memory Limit Exceeded error is likely due to the fact that you\\'re storing all possible outcomes in a list before returning the maximum. This can take up a lot of memory especially when the size of the `stocks` list is large.\\n\\nBesides, the time complexity of your solution is also high due to the nested for loops. The time complexity is approximately O(n^2), where n is the length of the `stocks` list. And, you are also using `stocks.index(x)` in your code, which takes O(n) time for each call, making your solution even slower.\\n\\nYou can solve this problem with a linear scan, which only needs to iterate through the `stocks` list once. \\n\\nHere is a more efficient approach using the concept of dynamic programming. This approach only uses O(1) memory and runs in O(n) time:\\n\\n```python\\ndef maxProfit(self, prices: List[int]) -> int:\\n    min_price = float(\\'inf\\')\\n    max_profit = 0\\n\\n    for price in prices:\\n        min_price = min(min_price, price)\\n        profit = price - min_price\\n        max_profit = max(max_profit, profit)\\n\\n    return max_profit\\n```\\n\\nIn this approach, you maintain a variable `min_price` to hold the minimum price seen so far and a variable `max_profit` to hold the maximum profit. You then iterate over the `prices` list updating `min_price` and `max_profit` accordingly. At the end of the loop, `max_profit` will hold the maximum profit that can be achieved."
                    },
                    {
                        "username": "Priyanshu626",
                        "content": "can we do this problem with O(N) time complexity"
                    },
                    {
                        "username": "bparanj",
                        "content": "Yes, this problem can indeed be solved in O(N) time complexity using a technique often referred to as the \"one pass\" approach, which involves a single iteration over the input list.\\n\\nThe key insight here is that the maximum profit that can be made from selling on a particular day is determined by the minimum price seen on any of the previous days. This suggests an algorithm: keep track of the minimum price seen so far, and for each day, check if selling on that day would yield a higher profit than any seen before.\\n\\nHere\\'s a Python implementation of this approach:\\n\\n```python\\ndef maxProfit(prices):\\n    min_price = float(\\'inf\\')  # initialize min_price to be a very large number\\n    max_profit = 0  # initialize max_profit to be 0\\n\\n    for price in prices:  # iterate through the list of prices\\n        if price < min_price:\\n            min_price = price  # update min_price if current price is less than min_price\\n        elif price - min_price > max_profit:\\n            max_profit = price - min_price  # update max_profit if the profit of selling now is more than max_profit\\n\\n    return max_profit\\n```\\n\\nIn this code, we go through the list of prices once, updating the minimum price and maximum profit as necessary. Thus, the time complexity is O(N), where N is the number of days (or the size of the input list). This is much more efficient than an approach that considers all pairs of days, which would have a time complexity of O(N^2)."
                    },
                    {
                        "username": "TandooriRoti",
                        "content": "Did the code in O(n) and still got TLE. After commenting the debug the test case passed successfully. I would suggest using Fast Input-Output for better results."
                    },
                    {
                        "username": "tommy787576",
                        "content": "[Complete Five solutions: One-pass / DP and Optimized DP / Maximum Subarray with Kadane\\'s alg or D&C](https://leetcode.com/problems/best-time-to-buy-and-sell-stock/solutions/3227281/complete-five-solutions-one-pass-dp-and-optimized-dp-maximum-subarray-with-kadane-s-alg-or-d-c/)\\nIf you find it helpful, please give me a star\\uD83D\\uDE00. Thank you!"
                    },
                    {
                        "username": "bader45berro",
                        "content": "can someone explain how this test case is working input [2,4,1] and the expected output is equal to 2\\n"
                    },
                    {
                        "username": "theerawatch",
                        "content": "buy 2, sell 4\\nprofit = 4-2 = 2"
                    },
                    {
                        "username": "anshuuuu____",
                        "content": "To solve this question in O(N) and constant space O(1) :-\n\n1. Make two variables maxprofit and mintillnow.\nmaxprofit=0 and mintillnow=prices[0]\n2. Traverse the array and findmin.\nmintillnow=min(mintillnow,prices[i]);\n3. find profit = prices[i]-mintillnow;\n4. update maxprofit\n\n\nHere we are trying to sell the stock everyday."
                    },
                    {
                        "username": "sahilshinde-45",
                        "content": "can anyone help me with runtime error i.e(Time Limit Exceeded) at 200th case.\\nbelow is my code\\n        profit = 0\\n        min_of_price = prices[0]\\n        for i in range(0,len(prices[1:])):\\n            min_of_price = min(min_of_price,prices[1:][i])\\n            profit = max(profit,prices[1:][i] - min_of_price)  \\n        return(profit)"
                    },
                    {
                        "username": "bparanj",
                        "content": "The issue in your code is that you\\'re slicing the `prices` list in every iteration of your loop, which leads to a large amount of unnecessary computation and increases the time complexity. The slice operation `prices[1:]` creates a new list in each iteration which takes additional time, resulting in a Time Limit Exceeded (TLE) error for large input.\\n\\nHere is the corrected version of your code:\\n\\n```python\\nprofit = 0\\nmin_of_price = prices[0]\\nfor i in range(1, len(prices)):\\n    min_of_price = min(min_of_price, prices[i])\\n    profit = max(profit, prices[i] - min_of_price)\\nreturn profit\\n```\\n\\nIn this code, we start iterating from the second day (`i = 1`) till the end of `prices` list. We find the minimum price till the current day and the maximum profit we could have made till now. This approach ensures we are only using a single pass through the `prices` list, thus achieving a linear time complexity O(N), where N is the size of the `prices` list."
                    }
                ]
            },
            {
                "id": 1858263,
                "content": [
                    {
                        "username": "OctavianSN",
                        "content": "Input : [1,2] (Test 19/211)\\nOutput: 2\\nExpected: 1\\nSo I buy on day one and sell on day one? Not day two to maximize profit? Wat??"
                    },
                    {
                        "username": "PeterTheZoe",
                        "content": "You're buying on day 1 which is 1 and selling on day 2, now 2 and returning a max profit 1 ( 2 - 1)"
                    },
                    {
                        "username": "MeghaShivhare",
                        "content": "First check if the array is empty and return 0 if it is.\\n\\nInitialize variables - min_price and max_profit - to the first price in array and 0, respectively. Iterate through the array and update these variables as follows:\\n\\nIf the current price is less than the minimum price seen so far, update min_price to the current price.\\nOtherwise, if the difference between the current price and min_price is greater than max_profit, update max_profit to this difference.\\nAfter iterating through the entire array, return max_profit"
                    },
                    {
                        "username": "palak8856",
                        "content": "abc"
                    },
                    {
                        "username": "NitinBhalla",
                        "content": "Tip :  Use recursive approach , try to find the difference of arr[j] and arr[i] where j>i , and if that diff is greater than profit update accordingly,\\n\\nDRY RUN THE APPROACH , YOU WILL DEFINATELY FIND THE WAY OUT."
                    },
                    {
                        "username": "adityagupta36",
                        "content": "#JAVA# Test cases passed, but TLE....how to overcome this??\nclass Solution {\n    public int maxProfit(int[] prices) {\n        int maxprofit =0;\n        int n = prices.length;\n        for(int i=0; i<n-1; i++){\n            for(int j=i+1; j<n; j++){\n            int ans=prices[i]-prices[j];\n            if(ans<maxprofit){\n                maxprofit=ans;\n            }\n            else{\n                maxprofit = maxprofit;\n            }\n        }\n        \n    }\n    return maxprofit*(-1);\n}\n}"
                    },
                    {
                        "username": "tirthyakamaldasgupta",
                        "content": "In this test input, [2,1,2,1,0,1,2], I am assuming that the buying price should be 1 and the selling price should be 2, resulting in a profit of 1. But the test case expects the profit to be 2. It will be of great help if someone is generous to help clear the confusion."
                    },
                    {
                        "username": "user4836NR",
                        "content": "you buy at day 5 = 0 then sell at day 7 = 2; 2-0=2"
                    },
                    {
                        "username": "Vithesh",
                        "content": "bruh....this took me around 40min to solve this in O(n) and this was a almost a medium level question.\\n\\nWe are using two pointer.\\nAnd a max variable.\\n"
                    },
                    {
                        "username": "mydjolie",
                        "content": "[2, 1, 2, 1, 0, 1, 2] \\nOutput : 1\\nExpected : 2\\nhow? buy =0 sell =2 ?\\ncan we buy 0 ?"
                    },
                    {
                        "username": "teckyshubham",
                        "content": " `class Solution {\\n    public int maxProfit(int[] prices) {\\n        int minPrice=prices[0];\\n        int profit=0;\\n        for(int i=1;i<prices.length;i++){\\n            int newProfit=prices[i]-minPrice;\\n            \\n            profit=Math.max(profit,newProfit);\\n            minPrice=Math.min(minPrice,prices[i]);\\n        }\\n        return profit;\\n        \\n    }\\n}`"
                    },
                    {
                        "username": "nhefner",
                        "content": "prices = [1,2]\nOutput = 2\nExpected = 1\n\nTest Case # 20\n\nBuy on the first day, sell on the second?\nis this a correct test case?"
                    }
                ]
            },
            {
                "id": 1856403,
                "content": [
                    {
                        "username": "OctavianSN",
                        "content": "Input : [1,2] (Test 19/211)\\nOutput: 2\\nExpected: 1\\nSo I buy on day one and sell on day one? Not day two to maximize profit? Wat??"
                    },
                    {
                        "username": "PeterTheZoe",
                        "content": "You're buying on day 1 which is 1 and selling on day 2, now 2 and returning a max profit 1 ( 2 - 1)"
                    },
                    {
                        "username": "MeghaShivhare",
                        "content": "First check if the array is empty and return 0 if it is.\\n\\nInitialize variables - min_price and max_profit - to the first price in array and 0, respectively. Iterate through the array and update these variables as follows:\\n\\nIf the current price is less than the minimum price seen so far, update min_price to the current price.\\nOtherwise, if the difference between the current price and min_price is greater than max_profit, update max_profit to this difference.\\nAfter iterating through the entire array, return max_profit"
                    },
                    {
                        "username": "palak8856",
                        "content": "abc"
                    },
                    {
                        "username": "NitinBhalla",
                        "content": "Tip :  Use recursive approach , try to find the difference of arr[j] and arr[i] where j>i , and if that diff is greater than profit update accordingly,\\n\\nDRY RUN THE APPROACH , YOU WILL DEFINATELY FIND THE WAY OUT."
                    },
                    {
                        "username": "adityagupta36",
                        "content": "#JAVA# Test cases passed, but TLE....how to overcome this??\nclass Solution {\n    public int maxProfit(int[] prices) {\n        int maxprofit =0;\n        int n = prices.length;\n        for(int i=0; i<n-1; i++){\n            for(int j=i+1; j<n; j++){\n            int ans=prices[i]-prices[j];\n            if(ans<maxprofit){\n                maxprofit=ans;\n            }\n            else{\n                maxprofit = maxprofit;\n            }\n        }\n        \n    }\n    return maxprofit*(-1);\n}\n}"
                    },
                    {
                        "username": "tirthyakamaldasgupta",
                        "content": "In this test input, [2,1,2,1,0,1,2], I am assuming that the buying price should be 1 and the selling price should be 2, resulting in a profit of 1. But the test case expects the profit to be 2. It will be of great help if someone is generous to help clear the confusion."
                    },
                    {
                        "username": "user4836NR",
                        "content": "you buy at day 5 = 0 then sell at day 7 = 2; 2-0=2"
                    },
                    {
                        "username": "Vithesh",
                        "content": "bruh....this took me around 40min to solve this in O(n) and this was a almost a medium level question.\\n\\nWe are using two pointer.\\nAnd a max variable.\\n"
                    },
                    {
                        "username": "mydjolie",
                        "content": "[2, 1, 2, 1, 0, 1, 2] \\nOutput : 1\\nExpected : 2\\nhow? buy =0 sell =2 ?\\ncan we buy 0 ?"
                    },
                    {
                        "username": "teckyshubham",
                        "content": " `class Solution {\\n    public int maxProfit(int[] prices) {\\n        int minPrice=prices[0];\\n        int profit=0;\\n        for(int i=1;i<prices.length;i++){\\n            int newProfit=prices[i]-minPrice;\\n            \\n            profit=Math.max(profit,newProfit);\\n            minPrice=Math.min(minPrice,prices[i]);\\n        }\\n        return profit;\\n        \\n    }\\n}`"
                    },
                    {
                        "username": "nhefner",
                        "content": "prices = [1,2]\nOutput = 2\nExpected = 1\n\nTest Case # 20\n\nBuy on the first day, sell on the second?\nis this a correct test case?"
                    }
                ]
            },
            {
                "id": 1841400,
                "content": [
                    {
                        "username": "OctavianSN",
                        "content": "Input : [1,2] (Test 19/211)\\nOutput: 2\\nExpected: 1\\nSo I buy on day one and sell on day one? Not day two to maximize profit? Wat??"
                    },
                    {
                        "username": "PeterTheZoe",
                        "content": "You're buying on day 1 which is 1 and selling on day 2, now 2 and returning a max profit 1 ( 2 - 1)"
                    },
                    {
                        "username": "MeghaShivhare",
                        "content": "First check if the array is empty and return 0 if it is.\\n\\nInitialize variables - min_price and max_profit - to the first price in array and 0, respectively. Iterate through the array and update these variables as follows:\\n\\nIf the current price is less than the minimum price seen so far, update min_price to the current price.\\nOtherwise, if the difference between the current price and min_price is greater than max_profit, update max_profit to this difference.\\nAfter iterating through the entire array, return max_profit"
                    },
                    {
                        "username": "palak8856",
                        "content": "abc"
                    },
                    {
                        "username": "NitinBhalla",
                        "content": "Tip :  Use recursive approach , try to find the difference of arr[j] and arr[i] where j>i , and if that diff is greater than profit update accordingly,\\n\\nDRY RUN THE APPROACH , YOU WILL DEFINATELY FIND THE WAY OUT."
                    },
                    {
                        "username": "adityagupta36",
                        "content": "#JAVA# Test cases passed, but TLE....how to overcome this??\nclass Solution {\n    public int maxProfit(int[] prices) {\n        int maxprofit =0;\n        int n = prices.length;\n        for(int i=0; i<n-1; i++){\n            for(int j=i+1; j<n; j++){\n            int ans=prices[i]-prices[j];\n            if(ans<maxprofit){\n                maxprofit=ans;\n            }\n            else{\n                maxprofit = maxprofit;\n            }\n        }\n        \n    }\n    return maxprofit*(-1);\n}\n}"
                    },
                    {
                        "username": "tirthyakamaldasgupta",
                        "content": "In this test input, [2,1,2,1,0,1,2], I am assuming that the buying price should be 1 and the selling price should be 2, resulting in a profit of 1. But the test case expects the profit to be 2. It will be of great help if someone is generous to help clear the confusion."
                    },
                    {
                        "username": "user4836NR",
                        "content": "you buy at day 5 = 0 then sell at day 7 = 2; 2-0=2"
                    },
                    {
                        "username": "Vithesh",
                        "content": "bruh....this took me around 40min to solve this in O(n) and this was a almost a medium level question.\\n\\nWe are using two pointer.\\nAnd a max variable.\\n"
                    },
                    {
                        "username": "mydjolie",
                        "content": "[2, 1, 2, 1, 0, 1, 2] \\nOutput : 1\\nExpected : 2\\nhow? buy =0 sell =2 ?\\ncan we buy 0 ?"
                    },
                    {
                        "username": "teckyshubham",
                        "content": " `class Solution {\\n    public int maxProfit(int[] prices) {\\n        int minPrice=prices[0];\\n        int profit=0;\\n        for(int i=1;i<prices.length;i++){\\n            int newProfit=prices[i]-minPrice;\\n            \\n            profit=Math.max(profit,newProfit);\\n            minPrice=Math.min(minPrice,prices[i]);\\n        }\\n        return profit;\\n        \\n    }\\n}`"
                    },
                    {
                        "username": "nhefner",
                        "content": "prices = [1,2]\nOutput = 2\nExpected = 1\n\nTest Case # 20\n\nBuy on the first day, sell on the second?\nis this a correct test case?"
                    }
                ]
            },
            {
                "id": 1836519,
                "content": [
                    {
                        "username": "OctavianSN",
                        "content": "Input : [1,2] (Test 19/211)\\nOutput: 2\\nExpected: 1\\nSo I buy on day one and sell on day one? Not day two to maximize profit? Wat??"
                    },
                    {
                        "username": "PeterTheZoe",
                        "content": "You're buying on day 1 which is 1 and selling on day 2, now 2 and returning a max profit 1 ( 2 - 1)"
                    },
                    {
                        "username": "MeghaShivhare",
                        "content": "First check if the array is empty and return 0 if it is.\\n\\nInitialize variables - min_price and max_profit - to the first price in array and 0, respectively. Iterate through the array and update these variables as follows:\\n\\nIf the current price is less than the minimum price seen so far, update min_price to the current price.\\nOtherwise, if the difference between the current price and min_price is greater than max_profit, update max_profit to this difference.\\nAfter iterating through the entire array, return max_profit"
                    },
                    {
                        "username": "palak8856",
                        "content": "abc"
                    },
                    {
                        "username": "NitinBhalla",
                        "content": "Tip :  Use recursive approach , try to find the difference of arr[j] and arr[i] where j>i , and if that diff is greater than profit update accordingly,\\n\\nDRY RUN THE APPROACH , YOU WILL DEFINATELY FIND THE WAY OUT."
                    },
                    {
                        "username": "adityagupta36",
                        "content": "#JAVA# Test cases passed, but TLE....how to overcome this??\nclass Solution {\n    public int maxProfit(int[] prices) {\n        int maxprofit =0;\n        int n = prices.length;\n        for(int i=0; i<n-1; i++){\n            for(int j=i+1; j<n; j++){\n            int ans=prices[i]-prices[j];\n            if(ans<maxprofit){\n                maxprofit=ans;\n            }\n            else{\n                maxprofit = maxprofit;\n            }\n        }\n        \n    }\n    return maxprofit*(-1);\n}\n}"
                    },
                    {
                        "username": "tirthyakamaldasgupta",
                        "content": "In this test input, [2,1,2,1,0,1,2], I am assuming that the buying price should be 1 and the selling price should be 2, resulting in a profit of 1. But the test case expects the profit to be 2. It will be of great help if someone is generous to help clear the confusion."
                    },
                    {
                        "username": "user4836NR",
                        "content": "you buy at day 5 = 0 then sell at day 7 = 2; 2-0=2"
                    },
                    {
                        "username": "Vithesh",
                        "content": "bruh....this took me around 40min to solve this in O(n) and this was a almost a medium level question.\\n\\nWe are using two pointer.\\nAnd a max variable.\\n"
                    },
                    {
                        "username": "mydjolie",
                        "content": "[2, 1, 2, 1, 0, 1, 2] \\nOutput : 1\\nExpected : 2\\nhow? buy =0 sell =2 ?\\ncan we buy 0 ?"
                    },
                    {
                        "username": "teckyshubham",
                        "content": " `class Solution {\\n    public int maxProfit(int[] prices) {\\n        int minPrice=prices[0];\\n        int profit=0;\\n        for(int i=1;i<prices.length;i++){\\n            int newProfit=prices[i]-minPrice;\\n            \\n            profit=Math.max(profit,newProfit);\\n            minPrice=Math.min(minPrice,prices[i]);\\n        }\\n        return profit;\\n        \\n    }\\n}`"
                    },
                    {
                        "username": "nhefner",
                        "content": "prices = [1,2]\nOutput = 2\nExpected = 1\n\nTest Case # 20\n\nBuy on the first day, sell on the second?\nis this a correct test case?"
                    }
                ]
            },
            {
                "id": 1835268,
                "content": [
                    {
                        "username": "OctavianSN",
                        "content": "Input : [1,2] (Test 19/211)\\nOutput: 2\\nExpected: 1\\nSo I buy on day one and sell on day one? Not day two to maximize profit? Wat??"
                    },
                    {
                        "username": "PeterTheZoe",
                        "content": "You're buying on day 1 which is 1 and selling on day 2, now 2 and returning a max profit 1 ( 2 - 1)"
                    },
                    {
                        "username": "MeghaShivhare",
                        "content": "First check if the array is empty and return 0 if it is.\\n\\nInitialize variables - min_price and max_profit - to the first price in array and 0, respectively. Iterate through the array and update these variables as follows:\\n\\nIf the current price is less than the minimum price seen so far, update min_price to the current price.\\nOtherwise, if the difference between the current price and min_price is greater than max_profit, update max_profit to this difference.\\nAfter iterating through the entire array, return max_profit"
                    },
                    {
                        "username": "palak8856",
                        "content": "abc"
                    },
                    {
                        "username": "NitinBhalla",
                        "content": "Tip :  Use recursive approach , try to find the difference of arr[j] and arr[i] where j>i , and if that diff is greater than profit update accordingly,\\n\\nDRY RUN THE APPROACH , YOU WILL DEFINATELY FIND THE WAY OUT."
                    },
                    {
                        "username": "adityagupta36",
                        "content": "#JAVA# Test cases passed, but TLE....how to overcome this??\nclass Solution {\n    public int maxProfit(int[] prices) {\n        int maxprofit =0;\n        int n = prices.length;\n        for(int i=0; i<n-1; i++){\n            for(int j=i+1; j<n; j++){\n            int ans=prices[i]-prices[j];\n            if(ans<maxprofit){\n                maxprofit=ans;\n            }\n            else{\n                maxprofit = maxprofit;\n            }\n        }\n        \n    }\n    return maxprofit*(-1);\n}\n}"
                    },
                    {
                        "username": "tirthyakamaldasgupta",
                        "content": "In this test input, [2,1,2,1,0,1,2], I am assuming that the buying price should be 1 and the selling price should be 2, resulting in a profit of 1. But the test case expects the profit to be 2. It will be of great help if someone is generous to help clear the confusion."
                    },
                    {
                        "username": "user4836NR",
                        "content": "you buy at day 5 = 0 then sell at day 7 = 2; 2-0=2"
                    },
                    {
                        "username": "Vithesh",
                        "content": "bruh....this took me around 40min to solve this in O(n) and this was a almost a medium level question.\\n\\nWe are using two pointer.\\nAnd a max variable.\\n"
                    },
                    {
                        "username": "mydjolie",
                        "content": "[2, 1, 2, 1, 0, 1, 2] \\nOutput : 1\\nExpected : 2\\nhow? buy =0 sell =2 ?\\ncan we buy 0 ?"
                    },
                    {
                        "username": "teckyshubham",
                        "content": " `class Solution {\\n    public int maxProfit(int[] prices) {\\n        int minPrice=prices[0];\\n        int profit=0;\\n        for(int i=1;i<prices.length;i++){\\n            int newProfit=prices[i]-minPrice;\\n            \\n            profit=Math.max(profit,newProfit);\\n            minPrice=Math.min(minPrice,prices[i]);\\n        }\\n        return profit;\\n        \\n    }\\n}`"
                    },
                    {
                        "username": "nhefner",
                        "content": "prices = [1,2]\nOutput = 2\nExpected = 1\n\nTest Case # 20\n\nBuy on the first day, sell on the second?\nis this a correct test case?"
                    }
                ]
            },
            {
                "id": 1833692,
                "content": [
                    {
                        "username": "OctavianSN",
                        "content": "Input : [1,2] (Test 19/211)\\nOutput: 2\\nExpected: 1\\nSo I buy on day one and sell on day one? Not day two to maximize profit? Wat??"
                    },
                    {
                        "username": "PeterTheZoe",
                        "content": "You're buying on day 1 which is 1 and selling on day 2, now 2 and returning a max profit 1 ( 2 - 1)"
                    },
                    {
                        "username": "MeghaShivhare",
                        "content": "First check if the array is empty and return 0 if it is.\\n\\nInitialize variables - min_price and max_profit - to the first price in array and 0, respectively. Iterate through the array and update these variables as follows:\\n\\nIf the current price is less than the minimum price seen so far, update min_price to the current price.\\nOtherwise, if the difference between the current price and min_price is greater than max_profit, update max_profit to this difference.\\nAfter iterating through the entire array, return max_profit"
                    },
                    {
                        "username": "palak8856",
                        "content": "abc"
                    },
                    {
                        "username": "NitinBhalla",
                        "content": "Tip :  Use recursive approach , try to find the difference of arr[j] and arr[i] where j>i , and if that diff is greater than profit update accordingly,\\n\\nDRY RUN THE APPROACH , YOU WILL DEFINATELY FIND THE WAY OUT."
                    },
                    {
                        "username": "adityagupta36",
                        "content": "#JAVA# Test cases passed, but TLE....how to overcome this??\nclass Solution {\n    public int maxProfit(int[] prices) {\n        int maxprofit =0;\n        int n = prices.length;\n        for(int i=0; i<n-1; i++){\n            for(int j=i+1; j<n; j++){\n            int ans=prices[i]-prices[j];\n            if(ans<maxprofit){\n                maxprofit=ans;\n            }\n            else{\n                maxprofit = maxprofit;\n            }\n        }\n        \n    }\n    return maxprofit*(-1);\n}\n}"
                    },
                    {
                        "username": "tirthyakamaldasgupta",
                        "content": "In this test input, [2,1,2,1,0,1,2], I am assuming that the buying price should be 1 and the selling price should be 2, resulting in a profit of 1. But the test case expects the profit to be 2. It will be of great help if someone is generous to help clear the confusion."
                    },
                    {
                        "username": "user4836NR",
                        "content": "you buy at day 5 = 0 then sell at day 7 = 2; 2-0=2"
                    },
                    {
                        "username": "Vithesh",
                        "content": "bruh....this took me around 40min to solve this in O(n) and this was a almost a medium level question.\\n\\nWe are using two pointer.\\nAnd a max variable.\\n"
                    },
                    {
                        "username": "mydjolie",
                        "content": "[2, 1, 2, 1, 0, 1, 2] \\nOutput : 1\\nExpected : 2\\nhow? buy =0 sell =2 ?\\ncan we buy 0 ?"
                    },
                    {
                        "username": "teckyshubham",
                        "content": " `class Solution {\\n    public int maxProfit(int[] prices) {\\n        int minPrice=prices[0];\\n        int profit=0;\\n        for(int i=1;i<prices.length;i++){\\n            int newProfit=prices[i]-minPrice;\\n            \\n            profit=Math.max(profit,newProfit);\\n            minPrice=Math.min(minPrice,prices[i]);\\n        }\\n        return profit;\\n        \\n    }\\n}`"
                    },
                    {
                        "username": "nhefner",
                        "content": "prices = [1,2]\nOutput = 2\nExpected = 1\n\nTest Case # 20\n\nBuy on the first day, sell on the second?\nis this a correct test case?"
                    }
                ]
            },
            {
                "id": 1832161,
                "content": [
                    {
                        "username": "OctavianSN",
                        "content": "Input : [1,2] (Test 19/211)\\nOutput: 2\\nExpected: 1\\nSo I buy on day one and sell on day one? Not day two to maximize profit? Wat??"
                    },
                    {
                        "username": "PeterTheZoe",
                        "content": "You're buying on day 1 which is 1 and selling on day 2, now 2 and returning a max profit 1 ( 2 - 1)"
                    },
                    {
                        "username": "MeghaShivhare",
                        "content": "First check if the array is empty and return 0 if it is.\\n\\nInitialize variables - min_price and max_profit - to the first price in array and 0, respectively. Iterate through the array and update these variables as follows:\\n\\nIf the current price is less than the minimum price seen so far, update min_price to the current price.\\nOtherwise, if the difference between the current price and min_price is greater than max_profit, update max_profit to this difference.\\nAfter iterating through the entire array, return max_profit"
                    },
                    {
                        "username": "palak8856",
                        "content": "abc"
                    },
                    {
                        "username": "NitinBhalla",
                        "content": "Tip :  Use recursive approach , try to find the difference of arr[j] and arr[i] where j>i , and if that diff is greater than profit update accordingly,\\n\\nDRY RUN THE APPROACH , YOU WILL DEFINATELY FIND THE WAY OUT."
                    },
                    {
                        "username": "adityagupta36",
                        "content": "#JAVA# Test cases passed, but TLE....how to overcome this??\nclass Solution {\n    public int maxProfit(int[] prices) {\n        int maxprofit =0;\n        int n = prices.length;\n        for(int i=0; i<n-1; i++){\n            for(int j=i+1; j<n; j++){\n            int ans=prices[i]-prices[j];\n            if(ans<maxprofit){\n                maxprofit=ans;\n            }\n            else{\n                maxprofit = maxprofit;\n            }\n        }\n        \n    }\n    return maxprofit*(-1);\n}\n}"
                    },
                    {
                        "username": "tirthyakamaldasgupta",
                        "content": "In this test input, [2,1,2,1,0,1,2], I am assuming that the buying price should be 1 and the selling price should be 2, resulting in a profit of 1. But the test case expects the profit to be 2. It will be of great help if someone is generous to help clear the confusion."
                    },
                    {
                        "username": "user4836NR",
                        "content": "you buy at day 5 = 0 then sell at day 7 = 2; 2-0=2"
                    },
                    {
                        "username": "Vithesh",
                        "content": "bruh....this took me around 40min to solve this in O(n) and this was a almost a medium level question.\\n\\nWe are using two pointer.\\nAnd a max variable.\\n"
                    },
                    {
                        "username": "mydjolie",
                        "content": "[2, 1, 2, 1, 0, 1, 2] \\nOutput : 1\\nExpected : 2\\nhow? buy =0 sell =2 ?\\ncan we buy 0 ?"
                    },
                    {
                        "username": "teckyshubham",
                        "content": " `class Solution {\\n    public int maxProfit(int[] prices) {\\n        int minPrice=prices[0];\\n        int profit=0;\\n        for(int i=1;i<prices.length;i++){\\n            int newProfit=prices[i]-minPrice;\\n            \\n            profit=Math.max(profit,newProfit);\\n            minPrice=Math.min(minPrice,prices[i]);\\n        }\\n        return profit;\\n        \\n    }\\n}`"
                    },
                    {
                        "username": "nhefner",
                        "content": "prices = [1,2]\nOutput = 2\nExpected = 1\n\nTest Case # 20\n\nBuy on the first day, sell on the second?\nis this a correct test case?"
                    }
                ]
            },
            {
                "id": 1821442,
                "content": [
                    {
                        "username": "OctavianSN",
                        "content": "Input : [1,2] (Test 19/211)\\nOutput: 2\\nExpected: 1\\nSo I buy on day one and sell on day one? Not day two to maximize profit? Wat??"
                    },
                    {
                        "username": "PeterTheZoe",
                        "content": "You're buying on day 1 which is 1 and selling on day 2, now 2 and returning a max profit 1 ( 2 - 1)"
                    },
                    {
                        "username": "MeghaShivhare",
                        "content": "First check if the array is empty and return 0 if it is.\\n\\nInitialize variables - min_price and max_profit - to the first price in array and 0, respectively. Iterate through the array and update these variables as follows:\\n\\nIf the current price is less than the minimum price seen so far, update min_price to the current price.\\nOtherwise, if the difference between the current price and min_price is greater than max_profit, update max_profit to this difference.\\nAfter iterating through the entire array, return max_profit"
                    },
                    {
                        "username": "palak8856",
                        "content": "abc"
                    },
                    {
                        "username": "NitinBhalla",
                        "content": "Tip :  Use recursive approach , try to find the difference of arr[j] and arr[i] where j>i , and if that diff is greater than profit update accordingly,\\n\\nDRY RUN THE APPROACH , YOU WILL DEFINATELY FIND THE WAY OUT."
                    },
                    {
                        "username": "adityagupta36",
                        "content": "#JAVA# Test cases passed, but TLE....how to overcome this??\nclass Solution {\n    public int maxProfit(int[] prices) {\n        int maxprofit =0;\n        int n = prices.length;\n        for(int i=0; i<n-1; i++){\n            for(int j=i+1; j<n; j++){\n            int ans=prices[i]-prices[j];\n            if(ans<maxprofit){\n                maxprofit=ans;\n            }\n            else{\n                maxprofit = maxprofit;\n            }\n        }\n        \n    }\n    return maxprofit*(-1);\n}\n}"
                    },
                    {
                        "username": "tirthyakamaldasgupta",
                        "content": "In this test input, [2,1,2,1,0,1,2], I am assuming that the buying price should be 1 and the selling price should be 2, resulting in a profit of 1. But the test case expects the profit to be 2. It will be of great help if someone is generous to help clear the confusion."
                    },
                    {
                        "username": "user4836NR",
                        "content": "you buy at day 5 = 0 then sell at day 7 = 2; 2-0=2"
                    },
                    {
                        "username": "Vithesh",
                        "content": "bruh....this took me around 40min to solve this in O(n) and this was a almost a medium level question.\\n\\nWe are using two pointer.\\nAnd a max variable.\\n"
                    },
                    {
                        "username": "mydjolie",
                        "content": "[2, 1, 2, 1, 0, 1, 2] \\nOutput : 1\\nExpected : 2\\nhow? buy =0 sell =2 ?\\ncan we buy 0 ?"
                    },
                    {
                        "username": "teckyshubham",
                        "content": " `class Solution {\\n    public int maxProfit(int[] prices) {\\n        int minPrice=prices[0];\\n        int profit=0;\\n        for(int i=1;i<prices.length;i++){\\n            int newProfit=prices[i]-minPrice;\\n            \\n            profit=Math.max(profit,newProfit);\\n            minPrice=Math.min(minPrice,prices[i]);\\n        }\\n        return profit;\\n        \\n    }\\n}`"
                    },
                    {
                        "username": "nhefner",
                        "content": "prices = [1,2]\nOutput = 2\nExpected = 1\n\nTest Case # 20\n\nBuy on the first day, sell on the second?\nis this a correct test case?"
                    }
                ]
            },
            {
                "id": 1815109,
                "content": [
                    {
                        "username": "OctavianSN",
                        "content": "Input : [1,2] (Test 19/211)\\nOutput: 2\\nExpected: 1\\nSo I buy on day one and sell on day one? Not day two to maximize profit? Wat??"
                    },
                    {
                        "username": "PeterTheZoe",
                        "content": "You're buying on day 1 which is 1 and selling on day 2, now 2 and returning a max profit 1 ( 2 - 1)"
                    },
                    {
                        "username": "MeghaShivhare",
                        "content": "First check if the array is empty and return 0 if it is.\\n\\nInitialize variables - min_price and max_profit - to the first price in array and 0, respectively. Iterate through the array and update these variables as follows:\\n\\nIf the current price is less than the minimum price seen so far, update min_price to the current price.\\nOtherwise, if the difference between the current price and min_price is greater than max_profit, update max_profit to this difference.\\nAfter iterating through the entire array, return max_profit"
                    },
                    {
                        "username": "palak8856",
                        "content": "abc"
                    },
                    {
                        "username": "NitinBhalla",
                        "content": "Tip :  Use recursive approach , try to find the difference of arr[j] and arr[i] where j>i , and if that diff is greater than profit update accordingly,\\n\\nDRY RUN THE APPROACH , YOU WILL DEFINATELY FIND THE WAY OUT."
                    },
                    {
                        "username": "adityagupta36",
                        "content": "#JAVA# Test cases passed, but TLE....how to overcome this??\nclass Solution {\n    public int maxProfit(int[] prices) {\n        int maxprofit =0;\n        int n = prices.length;\n        for(int i=0; i<n-1; i++){\n            for(int j=i+1; j<n; j++){\n            int ans=prices[i]-prices[j];\n            if(ans<maxprofit){\n                maxprofit=ans;\n            }\n            else{\n                maxprofit = maxprofit;\n            }\n        }\n        \n    }\n    return maxprofit*(-1);\n}\n}"
                    },
                    {
                        "username": "tirthyakamaldasgupta",
                        "content": "In this test input, [2,1,2,1,0,1,2], I am assuming that the buying price should be 1 and the selling price should be 2, resulting in a profit of 1. But the test case expects the profit to be 2. It will be of great help if someone is generous to help clear the confusion."
                    },
                    {
                        "username": "user4836NR",
                        "content": "you buy at day 5 = 0 then sell at day 7 = 2; 2-0=2"
                    },
                    {
                        "username": "Vithesh",
                        "content": "bruh....this took me around 40min to solve this in O(n) and this was a almost a medium level question.\\n\\nWe are using two pointer.\\nAnd a max variable.\\n"
                    },
                    {
                        "username": "mydjolie",
                        "content": "[2, 1, 2, 1, 0, 1, 2] \\nOutput : 1\\nExpected : 2\\nhow? buy =0 sell =2 ?\\ncan we buy 0 ?"
                    },
                    {
                        "username": "teckyshubham",
                        "content": " `class Solution {\\n    public int maxProfit(int[] prices) {\\n        int minPrice=prices[0];\\n        int profit=0;\\n        for(int i=1;i<prices.length;i++){\\n            int newProfit=prices[i]-minPrice;\\n            \\n            profit=Math.max(profit,newProfit);\\n            minPrice=Math.min(minPrice,prices[i]);\\n        }\\n        return profit;\\n        \\n    }\\n}`"
                    },
                    {
                        "username": "nhefner",
                        "content": "prices = [1,2]\nOutput = 2\nExpected = 1\n\nTest Case # 20\n\nBuy on the first day, sell on the second?\nis this a correct test case?"
                    }
                ]
            },
            {
                "id": 1814574,
                "content": [
                    {
                        "username": "OctavianSN",
                        "content": "Input : [1,2] (Test 19/211)\\nOutput: 2\\nExpected: 1\\nSo I buy on day one and sell on day one? Not day two to maximize profit? Wat??"
                    },
                    {
                        "username": "PeterTheZoe",
                        "content": "You're buying on day 1 which is 1 and selling on day 2, now 2 and returning a max profit 1 ( 2 - 1)"
                    },
                    {
                        "username": "MeghaShivhare",
                        "content": "First check if the array is empty and return 0 if it is.\\n\\nInitialize variables - min_price and max_profit - to the first price in array and 0, respectively. Iterate through the array and update these variables as follows:\\n\\nIf the current price is less than the minimum price seen so far, update min_price to the current price.\\nOtherwise, if the difference between the current price and min_price is greater than max_profit, update max_profit to this difference.\\nAfter iterating through the entire array, return max_profit"
                    },
                    {
                        "username": "palak8856",
                        "content": "abc"
                    },
                    {
                        "username": "NitinBhalla",
                        "content": "Tip :  Use recursive approach , try to find the difference of arr[j] and arr[i] where j>i , and if that diff is greater than profit update accordingly,\\n\\nDRY RUN THE APPROACH , YOU WILL DEFINATELY FIND THE WAY OUT."
                    },
                    {
                        "username": "adityagupta36",
                        "content": "#JAVA# Test cases passed, but TLE....how to overcome this??\nclass Solution {\n    public int maxProfit(int[] prices) {\n        int maxprofit =0;\n        int n = prices.length;\n        for(int i=0; i<n-1; i++){\n            for(int j=i+1; j<n; j++){\n            int ans=prices[i]-prices[j];\n            if(ans<maxprofit){\n                maxprofit=ans;\n            }\n            else{\n                maxprofit = maxprofit;\n            }\n        }\n        \n    }\n    return maxprofit*(-1);\n}\n}"
                    },
                    {
                        "username": "tirthyakamaldasgupta",
                        "content": "In this test input, [2,1,2,1,0,1,2], I am assuming that the buying price should be 1 and the selling price should be 2, resulting in a profit of 1. But the test case expects the profit to be 2. It will be of great help if someone is generous to help clear the confusion."
                    },
                    {
                        "username": "user4836NR",
                        "content": "you buy at day 5 = 0 then sell at day 7 = 2; 2-0=2"
                    },
                    {
                        "username": "Vithesh",
                        "content": "bruh....this took me around 40min to solve this in O(n) and this was a almost a medium level question.\\n\\nWe are using two pointer.\\nAnd a max variable.\\n"
                    },
                    {
                        "username": "mydjolie",
                        "content": "[2, 1, 2, 1, 0, 1, 2] \\nOutput : 1\\nExpected : 2\\nhow? buy =0 sell =2 ?\\ncan we buy 0 ?"
                    },
                    {
                        "username": "teckyshubham",
                        "content": " `class Solution {\\n    public int maxProfit(int[] prices) {\\n        int minPrice=prices[0];\\n        int profit=0;\\n        for(int i=1;i<prices.length;i++){\\n            int newProfit=prices[i]-minPrice;\\n            \\n            profit=Math.max(profit,newProfit);\\n            minPrice=Math.min(minPrice,prices[i]);\\n        }\\n        return profit;\\n        \\n    }\\n}`"
                    },
                    {
                        "username": "nhefner",
                        "content": "prices = [1,2]\nOutput = 2\nExpected = 1\n\nTest Case # 20\n\nBuy on the first day, sell on the second?\nis this a correct test case?"
                    }
                ]
            },
            {
                "id": 1814450,
                "content": [
                    {
                        "username": "kos2kos",
                        "content": "<div class=\"view-lines monaco-mouse-cursor-text\" role=\"presentation\" aria-hidden=\"true\" data-mprt=\"7\" style=\"position: absolute; font-family: Menlo, Monaco, &quot;Courier New&quot;, monospace; font-weight: normal; font-size: 15px; font-feature-settings: &quot;liga&quot; 0, &quot;calt&quot; 0; line-height: 23px; letter-spacing: 0px; width: 1364px; height: 747px;\"><div style=\"top:8px;height:23px;\" class=\"view-line\"><span><span class=\"mtk4\">class</span><span class=\"mtk1\">&nbsp;</span><span class=\"mtk10\">Solution</span><span class=\"mtk1\">&nbsp;{</span></span></div><div style=\"top:31px;height:23px;\" class=\"view-line\"><span><span class=\"mtk1\">&nbsp;&nbsp;&nbsp;&nbsp;</span><span class=\"mtk4\">public</span><span class=\"mtk1\">&nbsp;</span><span class=\"mtk10\">int</span><span class=\"mtk1\">&nbsp;</span><span class=\"mtk11\">maxProfit</span><span class=\"mtk1\">(</span><span class=\"mtk10\">int</span><span class=\"mtk1\">[]&nbsp;</span><span class=\"mtk14\">prices</span><span class=\"mtk1\">)&nbsp;{</span></span></div><div style=\"top:54px;height:23px;\" class=\"view-line\"><span><span class=\"mtk1\">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class=\"mtk3\">/*Go&nbsp;through&nbsp;list&nbsp;and&nbsp;add&nbsp;all&nbsp;values&nbsp;maintaing&nbsp;max</span><span class=\"mtk3\">imum&nbsp;value&nbsp;</span></span></div><div style=\"top:77px;height:23px;\" class=\"view-line\"><span><span class=\"mtk3\">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;iterate&nbsp;through&nbsp;the&nbsp;list&nbsp;and&nbsp;find&nbsp;differen</span><span class=\"mtk3\">ce&nbsp;between&nbsp;max&nbsp;and&nbsp;current&nbsp;val.&nbsp;set&nbsp;result&nbsp;to&nbsp;larg</span><span class=\"mtk3\">er&nbsp;numnber.</span></span></div><div style=\"top:100px;height:23px;\" class=\"view-line\"><span><span class=\"mtk3\">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;remove&nbsp;currnet&nbsp;number&nbsp;from&nbsp;maxHeap.&nbsp;</span></span></div><div style=\"top:123px;height:23px;\" class=\"view-line\"><span><span class=\"mtk3\">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return&nbsp;result</span></span></div><div style=\"top:146px;height:23px;\" class=\"view-line\"><span><span class=\"mtk3\">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;*/</span></span></div><div style=\"top:169px;height:23px;\" class=\"view-line\"><span><span class=\"mtk1\">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class=\"mtk10\">PriorityQueue</span><span class=\"mtk1\">&lt;</span><span class=\"mtk10\">Integer</span><span class=\"mtk1\">&gt;&nbsp;</span><span class=\"mtk14\">maxHeap</span><span class=\"mtk1\">&nbsp;=&nbsp;</span><span class=\"mtk13\">new</span><span class=\"mtk1\">&nbsp;</span><span class=\"mtk10\">PriorityQueue</span><span class=\"mtk1\">&lt;&gt;(</span><span class=\"mtk14\">Collections</span><span class=\"mtk1\">.</span><span class=\"mtk11\">reverseOrder</span><span class=\"mtk1\">());</span></span></div><div style=\"top:192px;height:23px;\" class=\"view-line\"><span><span></span></span></div><div style=\"top:215px;height:23px;\" class=\"view-line\"><span><span class=\"mtk1\">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class=\"mtk10\">int</span><span class=\"mtk1\">&nbsp;</span><span class=\"mtk14\">result</span><span class=\"mtk1\">&nbsp;=&nbsp;</span><span class=\"mtk7\">0</span><span class=\"mtk1\">;</span></span></div><div style=\"top:238px;height:23px;\" class=\"view-line\"><span><span class=\"mtk1\">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span></span></div><div style=\"top:261px;height:23px;\" class=\"view-line\"><span><span class=\"mtk1\">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class=\"mtk13\">for</span><span class=\"mtk1\">&nbsp;(</span><span class=\"mtk10\">int</span><span class=\"mtk1\">&nbsp;</span><span class=\"mtk14\">stock</span><span class=\"mtk13\">:</span><span class=\"mtk1\">&nbsp;prices){</span></span></div><div style=\"top:284px;height:23px;\" class=\"view-line\"><span><span class=\"mtk1\">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class=\"mtk14\">maxHeap</span><span class=\"mtk1\">.</span><span class=\"mtk11\">add</span><span class=\"mtk1\">(stock);</span></span></div><div style=\"top:307px;height:23px;\" class=\"view-line\"><span><span class=\"mtk1\">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}</span></span></div><div style=\"top:330px;height:23px;\" class=\"view-line\"><span><span></span></span></div><div style=\"top:353px;height:23px;\" class=\"view-line\"><span><span class=\"mtk1\">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class=\"mtk13\">for</span><span class=\"mtk1\">&nbsp;(</span><span class=\"mtk10\">int</span><span class=\"mtk1\">&nbsp;</span><span class=\"mtk14\">i</span><span class=\"mtk1\">&nbsp;=&nbsp;</span><span class=\"mtk7\">0</span><span class=\"mtk1\">;&nbsp;i&nbsp;&lt;&nbsp;</span><span class=\"mtk14\">prices</span><span class=\"mtk1\">.</span><span class=\"mtk14\">length</span><span class=\"mtk1\">;&nbsp;i++){</span></span></div><div style=\"top:376px;height:23px;\" class=\"view-line\"><span><span class=\"mtk1\">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class=\"mtk13\">if</span><span class=\"mtk1\">&nbsp;(prices[i]&nbsp;==&nbsp;</span><span class=\"mtk14\">maxHeap</span><span class=\"mtk1\">.</span><span class=\"mtk11\">peek</span><span class=\"mtk1\">())&nbsp;</span><span class=\"mtk14\">maxHeap</span><span class=\"mtk1\">.</span><span class=\"mtk11\">poll</span><span class=\"mtk1\">();</span></span></div><div style=\"top:399px;height:23px;\" class=\"view-line\"><span><span class=\"mtk1\">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;result&nbsp;=&nbsp;</span><span class=\"mtk14\">Math</span><span class=\"mtk1\">.</span><span class=\"mtk11\">max</span><span class=\"mtk1\">(result,&nbsp;</span><span class=\"mtk14\">maxHeap</span><span class=\"mtk1\">.</span><span class=\"mtk11\">peek</span><span class=\"mtk1\">()&nbsp;-&nbsp;prices[i]);</span></span></div><div style=\"top:422px;height:23px;\" class=\"view-line\"><span><span class=\"mtk1\">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}</span></span></div><div style=\"top:445px;height:23px;\" class=\"view-line\"><span><span></span></span></div><div style=\"top:468px;height:23px;\" class=\"view-line\"><span><span class=\"mtk1\">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class=\"mtk13\">return</span><span class=\"mtk1\">&nbsp;result;</span></span></div><div style=\"top:491px;height:23px;\" class=\"view-line\"><span><span class=\"mtk1\">&nbsp;&nbsp;&nbsp;&nbsp;}</span></span></div><div style=\"top:514px;height:23px;\" class=\"view-line\"><span><span class=\"mtk1\">}</span></span></div></div>\\n\\nThis was my first initial take where I had my current value and tried to find the max difference by comparing the FUTURE VALUES and that\\'s how I interpret the brute force solution by looking forward at all maximum differences. I was stuck for a few minutes on approach two, especially this code block if (prices[i] - minprice > maxprofit) because at first glance I saw that as knowing the future value and then knowing the overall min value, which didn\\'t make sense to me. Now I see the code working as the following, on my current day what was the smallest stock purchase price that proceeded me, find the difference between now and then. I now know I can buy on that day and sell today. A little counterintuitive and not how I think about in practical day to day terms. My first version runs O(n)log(n) with O(n) space. Hope this is helpful for those who need a good middle jumping step to get to the final solution."
                    },
                    {
                        "username": "sanshoys",
                        "content": "return Array.IndexOf(prices, prices.Max()) why is this not working?"
                    },
                    {
                        "username": "mdganapati",
                        "content": "Input: prices = [7,1,5,3,6,4]\\nOutput: 5\\nExplanation: Buy on day 2 (price = 1) and sell on day 5 (price = 6), profit = 6-1 = 5.\\nNote that buying on day 2 and selling on day 1 is not allowed because you must buy before you sell.\\n\\nNow here \\n\\nbuy at 2nd day (1) and sell at 3rd day(5) so profit = 5-1 = 4;\\n\\nnext buy at 4th day(3) and sell on 5th day(6) so the profit = 6-3= 3\\n\\nso the total profit is 4+3 = 7;\\n\\nbut expected is 5 HOW COME ???????????? \\n\\n\\n"
                    },
                    {
                        "username": "FerhatKul",
                        "content": "It was really difficult until manage to solve by 6th submission, seeing actually how it is easy, brrr."
                    },
                    {
                        "username": "mehrak205",
                        "content": "This is my code but it\\'s not working for all the cases .\\n\\nint maxProfit(vector<int>& prices) {\\n        if(prices.size()==1)\\n        return 0;\\n        int bs=INT_MAX;\\n        int ind=-1;\\n        int maxprofit=0;\\n        for(int i=0;i<prices.size()-1;i++){\\n            if(prices[i]<bs){\\n                bs=prices[i];\\n                ind=i;\\n            }\\n        } \\n        for(int i=ind+1;i<prices.size();i++){\\n            if(prices[i]-bs>maxprofit)\\n            maxprofit=prices[i]-prices[ind];\\n        }\\n        return maxprofit;\\n    }"
                    },
                    {
                        "username": "bparanj",
                        "content": "Consider the following array: `[3,2,6,5,0,3]`. The lowest price is `0` (on the 5th day), but if you buy at this day you wouldn\\'t make a profit because there\\'s no higher price after it. The maximum profit you can make is by buying at the 2nd day where the price is `2`, and selling at the 3rd day where the price is `6`, even though `2` isn\\'t the lowest price in the array. \\n\\nThe example illustrates the issue with your code: you cannot simply buy at the lowest price because it doesn\\'t guarantee the maximum profit. \\n\\nThe correct approach is:\\n\\n```cpp\\nint maxProfit(vector<int>& prices) {\\n    int min_price = INT_MAX;\\n    int max_profit = 0;\\n    for (int i = 0; i < prices.size(); i++) {\\n        if (prices[i] < min_price) {\\n            min_price = prices[i];\\n        } else if (prices[i] - min_price > max_profit) {\\n            max_profit = prices[i] - min_price;\\n        }\\n    }\\n    return max_profit;\\n}\\n```\\n\\nThis code iterates over the `prices` array, keeping track of the smallest price seen so far, and updating the maximum profit whenever a larger profit is found.\\n"
                    },
                    {
                        "username": "FerhatKul",
                        "content": "It was really difficult until manage to solve by 6th submission, seeing actually how it is easy, brrr."
                    },
                    {
                        "username": "victorpichugov",
                        "content": "Additional explanation: profit in 2 example 0 because:\\n1) the minimum element is last\\n2) if the last element is the minimum, then you need to search for the minimum first to the minimum, i.e. arr[:len(arr) - 1] , but in the 2 example 7 > 6 > 4 > 3 > 1"
                    },
                    {
                        "username": "_vikash_kumar_",
                        "content": "EASY SOLUTION.......\\nclass Solution {\\n    public int maxProfit(int[] prices) {\\n        int n=prices.length;\\n        int min=Integer.MAX_VALUE;\\n        int diff=0;\\n        for(int i=0;i<n;i++)\\n        {\\n            min=Math.min(prices[i],min);\\n            diff=Math.max(diff,prices[i]-min);\\n        }\\n        return diff;\\n        \\n        \\n    }\\n}\\n"
                    },
                    {
                        "username": "bharti820",
                        "content": "step1: take starting index as lowprice and profit be 0 and initialize i=1\\nstep 2 while(i<:pricesSize)do step 3 to step 6\\nstep3 cost=prices[i]-lowprice\\nstep4 if(profit<cost)\\n     profit=cost\\nstep 5 if (lowprice>prices[i])\\nlowprice=prices[i]\\nstep 6 end of loop\\nstep 7 return profit\\n   "
                    },
                    {
                        "username": "cOde_Ranvir25",
                        "content": "Here is the Approach:-\n\nIterate through the prices array and keep track of the minimum price seen so far, and the maximum profit that can be obtained by selling the stock at the current price after buying it at the minimum price seen so far.\n\nAt each iteration, calculate the difference between the current price and the minimum price seen so far, which gives the profit that can be obtained by selling the stock at the current price after buying it at the minimum price seen so far. Update the maximum profit obtained so far by taking the maximum of the current profit and the maximum profit obtained in the previous iterations. Update the minimum price seen so far by taking the minimum of the current price and the minimum price seen in the previous iterations.\n\nBy the end of the iteration, the maximum profit obtained is returned as the output of the function."
                    },
                    {
                        "username": "cOde_Ranvir25",
                        "content": "Here is the code link for Help:-\\nhttps://leetcode.com/problems/best-time-to-buy-and-sell-stock/solutions/2941124/thanks-to-striver-for-an-great-explanation/?orderBy=most_votes"
                    }
                ]
            },
            {
                "id": 1814409,
                "content": [
                    {
                        "username": "kos2kos",
                        "content": "<div class=\"view-lines monaco-mouse-cursor-text\" role=\"presentation\" aria-hidden=\"true\" data-mprt=\"7\" style=\"position: absolute; font-family: Menlo, Monaco, &quot;Courier New&quot;, monospace; font-weight: normal; font-size: 15px; font-feature-settings: &quot;liga&quot; 0, &quot;calt&quot; 0; line-height: 23px; letter-spacing: 0px; width: 1364px; height: 747px;\"><div style=\"top:8px;height:23px;\" class=\"view-line\"><span><span class=\"mtk4\">class</span><span class=\"mtk1\">&nbsp;</span><span class=\"mtk10\">Solution</span><span class=\"mtk1\">&nbsp;{</span></span></div><div style=\"top:31px;height:23px;\" class=\"view-line\"><span><span class=\"mtk1\">&nbsp;&nbsp;&nbsp;&nbsp;</span><span class=\"mtk4\">public</span><span class=\"mtk1\">&nbsp;</span><span class=\"mtk10\">int</span><span class=\"mtk1\">&nbsp;</span><span class=\"mtk11\">maxProfit</span><span class=\"mtk1\">(</span><span class=\"mtk10\">int</span><span class=\"mtk1\">[]&nbsp;</span><span class=\"mtk14\">prices</span><span class=\"mtk1\">)&nbsp;{</span></span></div><div style=\"top:54px;height:23px;\" class=\"view-line\"><span><span class=\"mtk1\">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class=\"mtk3\">/*Go&nbsp;through&nbsp;list&nbsp;and&nbsp;add&nbsp;all&nbsp;values&nbsp;maintaing&nbsp;max</span><span class=\"mtk3\">imum&nbsp;value&nbsp;</span></span></div><div style=\"top:77px;height:23px;\" class=\"view-line\"><span><span class=\"mtk3\">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;iterate&nbsp;through&nbsp;the&nbsp;list&nbsp;and&nbsp;find&nbsp;differen</span><span class=\"mtk3\">ce&nbsp;between&nbsp;max&nbsp;and&nbsp;current&nbsp;val.&nbsp;set&nbsp;result&nbsp;to&nbsp;larg</span><span class=\"mtk3\">er&nbsp;numnber.</span></span></div><div style=\"top:100px;height:23px;\" class=\"view-line\"><span><span class=\"mtk3\">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;remove&nbsp;currnet&nbsp;number&nbsp;from&nbsp;maxHeap.&nbsp;</span></span></div><div style=\"top:123px;height:23px;\" class=\"view-line\"><span><span class=\"mtk3\">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return&nbsp;result</span></span></div><div style=\"top:146px;height:23px;\" class=\"view-line\"><span><span class=\"mtk3\">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;*/</span></span></div><div style=\"top:169px;height:23px;\" class=\"view-line\"><span><span class=\"mtk1\">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class=\"mtk10\">PriorityQueue</span><span class=\"mtk1\">&lt;</span><span class=\"mtk10\">Integer</span><span class=\"mtk1\">&gt;&nbsp;</span><span class=\"mtk14\">maxHeap</span><span class=\"mtk1\">&nbsp;=&nbsp;</span><span class=\"mtk13\">new</span><span class=\"mtk1\">&nbsp;</span><span class=\"mtk10\">PriorityQueue</span><span class=\"mtk1\">&lt;&gt;(</span><span class=\"mtk14\">Collections</span><span class=\"mtk1\">.</span><span class=\"mtk11\">reverseOrder</span><span class=\"mtk1\">());</span></span></div><div style=\"top:192px;height:23px;\" class=\"view-line\"><span><span></span></span></div><div style=\"top:215px;height:23px;\" class=\"view-line\"><span><span class=\"mtk1\">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class=\"mtk10\">int</span><span class=\"mtk1\">&nbsp;</span><span class=\"mtk14\">result</span><span class=\"mtk1\">&nbsp;=&nbsp;</span><span class=\"mtk7\">0</span><span class=\"mtk1\">;</span></span></div><div style=\"top:238px;height:23px;\" class=\"view-line\"><span><span class=\"mtk1\">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span></span></div><div style=\"top:261px;height:23px;\" class=\"view-line\"><span><span class=\"mtk1\">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class=\"mtk13\">for</span><span class=\"mtk1\">&nbsp;(</span><span class=\"mtk10\">int</span><span class=\"mtk1\">&nbsp;</span><span class=\"mtk14\">stock</span><span class=\"mtk13\">:</span><span class=\"mtk1\">&nbsp;prices){</span></span></div><div style=\"top:284px;height:23px;\" class=\"view-line\"><span><span class=\"mtk1\">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class=\"mtk14\">maxHeap</span><span class=\"mtk1\">.</span><span class=\"mtk11\">add</span><span class=\"mtk1\">(stock);</span></span></div><div style=\"top:307px;height:23px;\" class=\"view-line\"><span><span class=\"mtk1\">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}</span></span></div><div style=\"top:330px;height:23px;\" class=\"view-line\"><span><span></span></span></div><div style=\"top:353px;height:23px;\" class=\"view-line\"><span><span class=\"mtk1\">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class=\"mtk13\">for</span><span class=\"mtk1\">&nbsp;(</span><span class=\"mtk10\">int</span><span class=\"mtk1\">&nbsp;</span><span class=\"mtk14\">i</span><span class=\"mtk1\">&nbsp;=&nbsp;</span><span class=\"mtk7\">0</span><span class=\"mtk1\">;&nbsp;i&nbsp;&lt;&nbsp;</span><span class=\"mtk14\">prices</span><span class=\"mtk1\">.</span><span class=\"mtk14\">length</span><span class=\"mtk1\">;&nbsp;i++){</span></span></div><div style=\"top:376px;height:23px;\" class=\"view-line\"><span><span class=\"mtk1\">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class=\"mtk13\">if</span><span class=\"mtk1\">&nbsp;(prices[i]&nbsp;==&nbsp;</span><span class=\"mtk14\">maxHeap</span><span class=\"mtk1\">.</span><span class=\"mtk11\">peek</span><span class=\"mtk1\">())&nbsp;</span><span class=\"mtk14\">maxHeap</span><span class=\"mtk1\">.</span><span class=\"mtk11\">poll</span><span class=\"mtk1\">();</span></span></div><div style=\"top:399px;height:23px;\" class=\"view-line\"><span><span class=\"mtk1\">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;result&nbsp;=&nbsp;</span><span class=\"mtk14\">Math</span><span class=\"mtk1\">.</span><span class=\"mtk11\">max</span><span class=\"mtk1\">(result,&nbsp;</span><span class=\"mtk14\">maxHeap</span><span class=\"mtk1\">.</span><span class=\"mtk11\">peek</span><span class=\"mtk1\">()&nbsp;-&nbsp;prices[i]);</span></span></div><div style=\"top:422px;height:23px;\" class=\"view-line\"><span><span class=\"mtk1\">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}</span></span></div><div style=\"top:445px;height:23px;\" class=\"view-line\"><span><span></span></span></div><div style=\"top:468px;height:23px;\" class=\"view-line\"><span><span class=\"mtk1\">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class=\"mtk13\">return</span><span class=\"mtk1\">&nbsp;result;</span></span></div><div style=\"top:491px;height:23px;\" class=\"view-line\"><span><span class=\"mtk1\">&nbsp;&nbsp;&nbsp;&nbsp;}</span></span></div><div style=\"top:514px;height:23px;\" class=\"view-line\"><span><span class=\"mtk1\">}</span></span></div></div>\\n\\nThis was my first initial take where I had my current value and tried to find the max difference by comparing the FUTURE VALUES and that\\'s how I interpret the brute force solution by looking forward at all maximum differences. I was stuck for a few minutes on approach two, especially this code block if (prices[i] - minprice > maxprofit) because at first glance I saw that as knowing the future value and then knowing the overall min value, which didn\\'t make sense to me. Now I see the code working as the following, on my current day what was the smallest stock purchase price that proceeded me, find the difference between now and then. I now know I can buy on that day and sell today. A little counterintuitive and not how I think about in practical day to day terms. My first version runs O(n)log(n) with O(n) space. Hope this is helpful for those who need a good middle jumping step to get to the final solution."
                    },
                    {
                        "username": "sanshoys",
                        "content": "return Array.IndexOf(prices, prices.Max()) why is this not working?"
                    },
                    {
                        "username": "mdganapati",
                        "content": "Input: prices = [7,1,5,3,6,4]\\nOutput: 5\\nExplanation: Buy on day 2 (price = 1) and sell on day 5 (price = 6), profit = 6-1 = 5.\\nNote that buying on day 2 and selling on day 1 is not allowed because you must buy before you sell.\\n\\nNow here \\n\\nbuy at 2nd day (1) and sell at 3rd day(5) so profit = 5-1 = 4;\\n\\nnext buy at 4th day(3) and sell on 5th day(6) so the profit = 6-3= 3\\n\\nso the total profit is 4+3 = 7;\\n\\nbut expected is 5 HOW COME ???????????? \\n\\n\\n"
                    },
                    {
                        "username": "FerhatKul",
                        "content": "It was really difficult until manage to solve by 6th submission, seeing actually how it is easy, brrr."
                    },
                    {
                        "username": "mehrak205",
                        "content": "This is my code but it\\'s not working for all the cases .\\n\\nint maxProfit(vector<int>& prices) {\\n        if(prices.size()==1)\\n        return 0;\\n        int bs=INT_MAX;\\n        int ind=-1;\\n        int maxprofit=0;\\n        for(int i=0;i<prices.size()-1;i++){\\n            if(prices[i]<bs){\\n                bs=prices[i];\\n                ind=i;\\n            }\\n        } \\n        for(int i=ind+1;i<prices.size();i++){\\n            if(prices[i]-bs>maxprofit)\\n            maxprofit=prices[i]-prices[ind];\\n        }\\n        return maxprofit;\\n    }"
                    },
                    {
                        "username": "bparanj",
                        "content": "Consider the following array: `[3,2,6,5,0,3]`. The lowest price is `0` (on the 5th day), but if you buy at this day you wouldn\\'t make a profit because there\\'s no higher price after it. The maximum profit you can make is by buying at the 2nd day where the price is `2`, and selling at the 3rd day where the price is `6`, even though `2` isn\\'t the lowest price in the array. \\n\\nThe example illustrates the issue with your code: you cannot simply buy at the lowest price because it doesn\\'t guarantee the maximum profit. \\n\\nThe correct approach is:\\n\\n```cpp\\nint maxProfit(vector<int>& prices) {\\n    int min_price = INT_MAX;\\n    int max_profit = 0;\\n    for (int i = 0; i < prices.size(); i++) {\\n        if (prices[i] < min_price) {\\n            min_price = prices[i];\\n        } else if (prices[i] - min_price > max_profit) {\\n            max_profit = prices[i] - min_price;\\n        }\\n    }\\n    return max_profit;\\n}\\n```\\n\\nThis code iterates over the `prices` array, keeping track of the smallest price seen so far, and updating the maximum profit whenever a larger profit is found.\\n"
                    },
                    {
                        "username": "FerhatKul",
                        "content": "It was really difficult until manage to solve by 6th submission, seeing actually how it is easy, brrr."
                    },
                    {
                        "username": "victorpichugov",
                        "content": "Additional explanation: profit in 2 example 0 because:\\n1) the minimum element is last\\n2) if the last element is the minimum, then you need to search for the minimum first to the minimum, i.e. arr[:len(arr) - 1] , but in the 2 example 7 > 6 > 4 > 3 > 1"
                    },
                    {
                        "username": "_vikash_kumar_",
                        "content": "EASY SOLUTION.......\\nclass Solution {\\n    public int maxProfit(int[] prices) {\\n        int n=prices.length;\\n        int min=Integer.MAX_VALUE;\\n        int diff=0;\\n        for(int i=0;i<n;i++)\\n        {\\n            min=Math.min(prices[i],min);\\n            diff=Math.max(diff,prices[i]-min);\\n        }\\n        return diff;\\n        \\n        \\n    }\\n}\\n"
                    },
                    {
                        "username": "bharti820",
                        "content": "step1: take starting index as lowprice and profit be 0 and initialize i=1\\nstep 2 while(i<:pricesSize)do step 3 to step 6\\nstep3 cost=prices[i]-lowprice\\nstep4 if(profit<cost)\\n     profit=cost\\nstep 5 if (lowprice>prices[i])\\nlowprice=prices[i]\\nstep 6 end of loop\\nstep 7 return profit\\n   "
                    },
                    {
                        "username": "cOde_Ranvir25",
                        "content": "Here is the Approach:-\n\nIterate through the prices array and keep track of the minimum price seen so far, and the maximum profit that can be obtained by selling the stock at the current price after buying it at the minimum price seen so far.\n\nAt each iteration, calculate the difference between the current price and the minimum price seen so far, which gives the profit that can be obtained by selling the stock at the current price after buying it at the minimum price seen so far. Update the maximum profit obtained so far by taking the maximum of the current profit and the maximum profit obtained in the previous iterations. Update the minimum price seen so far by taking the minimum of the current price and the minimum price seen in the previous iterations.\n\nBy the end of the iteration, the maximum profit obtained is returned as the output of the function."
                    },
                    {
                        "username": "cOde_Ranvir25",
                        "content": "Here is the code link for Help:-\\nhttps://leetcode.com/problems/best-time-to-buy-and-sell-stock/solutions/2941124/thanks-to-striver-for-an-great-explanation/?orderBy=most_votes"
                    }
                ]
            },
            {
                "id": 1814269,
                "content": [
                    {
                        "username": "kos2kos",
                        "content": "<div class=\"view-lines monaco-mouse-cursor-text\" role=\"presentation\" aria-hidden=\"true\" data-mprt=\"7\" style=\"position: absolute; font-family: Menlo, Monaco, &quot;Courier New&quot;, monospace; font-weight: normal; font-size: 15px; font-feature-settings: &quot;liga&quot; 0, &quot;calt&quot; 0; line-height: 23px; letter-spacing: 0px; width: 1364px; height: 747px;\"><div style=\"top:8px;height:23px;\" class=\"view-line\"><span><span class=\"mtk4\">class</span><span class=\"mtk1\">&nbsp;</span><span class=\"mtk10\">Solution</span><span class=\"mtk1\">&nbsp;{</span></span></div><div style=\"top:31px;height:23px;\" class=\"view-line\"><span><span class=\"mtk1\">&nbsp;&nbsp;&nbsp;&nbsp;</span><span class=\"mtk4\">public</span><span class=\"mtk1\">&nbsp;</span><span class=\"mtk10\">int</span><span class=\"mtk1\">&nbsp;</span><span class=\"mtk11\">maxProfit</span><span class=\"mtk1\">(</span><span class=\"mtk10\">int</span><span class=\"mtk1\">[]&nbsp;</span><span class=\"mtk14\">prices</span><span class=\"mtk1\">)&nbsp;{</span></span></div><div style=\"top:54px;height:23px;\" class=\"view-line\"><span><span class=\"mtk1\">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class=\"mtk3\">/*Go&nbsp;through&nbsp;list&nbsp;and&nbsp;add&nbsp;all&nbsp;values&nbsp;maintaing&nbsp;max</span><span class=\"mtk3\">imum&nbsp;value&nbsp;</span></span></div><div style=\"top:77px;height:23px;\" class=\"view-line\"><span><span class=\"mtk3\">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;iterate&nbsp;through&nbsp;the&nbsp;list&nbsp;and&nbsp;find&nbsp;differen</span><span class=\"mtk3\">ce&nbsp;between&nbsp;max&nbsp;and&nbsp;current&nbsp;val.&nbsp;set&nbsp;result&nbsp;to&nbsp;larg</span><span class=\"mtk3\">er&nbsp;numnber.</span></span></div><div style=\"top:100px;height:23px;\" class=\"view-line\"><span><span class=\"mtk3\">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;remove&nbsp;currnet&nbsp;number&nbsp;from&nbsp;maxHeap.&nbsp;</span></span></div><div style=\"top:123px;height:23px;\" class=\"view-line\"><span><span class=\"mtk3\">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return&nbsp;result</span></span></div><div style=\"top:146px;height:23px;\" class=\"view-line\"><span><span class=\"mtk3\">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;*/</span></span></div><div style=\"top:169px;height:23px;\" class=\"view-line\"><span><span class=\"mtk1\">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class=\"mtk10\">PriorityQueue</span><span class=\"mtk1\">&lt;</span><span class=\"mtk10\">Integer</span><span class=\"mtk1\">&gt;&nbsp;</span><span class=\"mtk14\">maxHeap</span><span class=\"mtk1\">&nbsp;=&nbsp;</span><span class=\"mtk13\">new</span><span class=\"mtk1\">&nbsp;</span><span class=\"mtk10\">PriorityQueue</span><span class=\"mtk1\">&lt;&gt;(</span><span class=\"mtk14\">Collections</span><span class=\"mtk1\">.</span><span class=\"mtk11\">reverseOrder</span><span class=\"mtk1\">());</span></span></div><div style=\"top:192px;height:23px;\" class=\"view-line\"><span><span></span></span></div><div style=\"top:215px;height:23px;\" class=\"view-line\"><span><span class=\"mtk1\">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class=\"mtk10\">int</span><span class=\"mtk1\">&nbsp;</span><span class=\"mtk14\">result</span><span class=\"mtk1\">&nbsp;=&nbsp;</span><span class=\"mtk7\">0</span><span class=\"mtk1\">;</span></span></div><div style=\"top:238px;height:23px;\" class=\"view-line\"><span><span class=\"mtk1\">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span></span></div><div style=\"top:261px;height:23px;\" class=\"view-line\"><span><span class=\"mtk1\">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class=\"mtk13\">for</span><span class=\"mtk1\">&nbsp;(</span><span class=\"mtk10\">int</span><span class=\"mtk1\">&nbsp;</span><span class=\"mtk14\">stock</span><span class=\"mtk13\">:</span><span class=\"mtk1\">&nbsp;prices){</span></span></div><div style=\"top:284px;height:23px;\" class=\"view-line\"><span><span class=\"mtk1\">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class=\"mtk14\">maxHeap</span><span class=\"mtk1\">.</span><span class=\"mtk11\">add</span><span class=\"mtk1\">(stock);</span></span></div><div style=\"top:307px;height:23px;\" class=\"view-line\"><span><span class=\"mtk1\">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}</span></span></div><div style=\"top:330px;height:23px;\" class=\"view-line\"><span><span></span></span></div><div style=\"top:353px;height:23px;\" class=\"view-line\"><span><span class=\"mtk1\">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class=\"mtk13\">for</span><span class=\"mtk1\">&nbsp;(</span><span class=\"mtk10\">int</span><span class=\"mtk1\">&nbsp;</span><span class=\"mtk14\">i</span><span class=\"mtk1\">&nbsp;=&nbsp;</span><span class=\"mtk7\">0</span><span class=\"mtk1\">;&nbsp;i&nbsp;&lt;&nbsp;</span><span class=\"mtk14\">prices</span><span class=\"mtk1\">.</span><span class=\"mtk14\">length</span><span class=\"mtk1\">;&nbsp;i++){</span></span></div><div style=\"top:376px;height:23px;\" class=\"view-line\"><span><span class=\"mtk1\">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class=\"mtk13\">if</span><span class=\"mtk1\">&nbsp;(prices[i]&nbsp;==&nbsp;</span><span class=\"mtk14\">maxHeap</span><span class=\"mtk1\">.</span><span class=\"mtk11\">peek</span><span class=\"mtk1\">())&nbsp;</span><span class=\"mtk14\">maxHeap</span><span class=\"mtk1\">.</span><span class=\"mtk11\">poll</span><span class=\"mtk1\">();</span></span></div><div style=\"top:399px;height:23px;\" class=\"view-line\"><span><span class=\"mtk1\">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;result&nbsp;=&nbsp;</span><span class=\"mtk14\">Math</span><span class=\"mtk1\">.</span><span class=\"mtk11\">max</span><span class=\"mtk1\">(result,&nbsp;</span><span class=\"mtk14\">maxHeap</span><span class=\"mtk1\">.</span><span class=\"mtk11\">peek</span><span class=\"mtk1\">()&nbsp;-&nbsp;prices[i]);</span></span></div><div style=\"top:422px;height:23px;\" class=\"view-line\"><span><span class=\"mtk1\">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}</span></span></div><div style=\"top:445px;height:23px;\" class=\"view-line\"><span><span></span></span></div><div style=\"top:468px;height:23px;\" class=\"view-line\"><span><span class=\"mtk1\">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class=\"mtk13\">return</span><span class=\"mtk1\">&nbsp;result;</span></span></div><div style=\"top:491px;height:23px;\" class=\"view-line\"><span><span class=\"mtk1\">&nbsp;&nbsp;&nbsp;&nbsp;}</span></span></div><div style=\"top:514px;height:23px;\" class=\"view-line\"><span><span class=\"mtk1\">}</span></span></div></div>\\n\\nThis was my first initial take where I had my current value and tried to find the max difference by comparing the FUTURE VALUES and that\\'s how I interpret the brute force solution by looking forward at all maximum differences. I was stuck for a few minutes on approach two, especially this code block if (prices[i] - minprice > maxprofit) because at first glance I saw that as knowing the future value and then knowing the overall min value, which didn\\'t make sense to me. Now I see the code working as the following, on my current day what was the smallest stock purchase price that proceeded me, find the difference between now and then. I now know I can buy on that day and sell today. A little counterintuitive and not how I think about in practical day to day terms. My first version runs O(n)log(n) with O(n) space. Hope this is helpful for those who need a good middle jumping step to get to the final solution."
                    },
                    {
                        "username": "sanshoys",
                        "content": "return Array.IndexOf(prices, prices.Max()) why is this not working?"
                    },
                    {
                        "username": "mdganapati",
                        "content": "Input: prices = [7,1,5,3,6,4]\\nOutput: 5\\nExplanation: Buy on day 2 (price = 1) and sell on day 5 (price = 6), profit = 6-1 = 5.\\nNote that buying on day 2 and selling on day 1 is not allowed because you must buy before you sell.\\n\\nNow here \\n\\nbuy at 2nd day (1) and sell at 3rd day(5) so profit = 5-1 = 4;\\n\\nnext buy at 4th day(3) and sell on 5th day(6) so the profit = 6-3= 3\\n\\nso the total profit is 4+3 = 7;\\n\\nbut expected is 5 HOW COME ???????????? \\n\\n\\n"
                    },
                    {
                        "username": "FerhatKul",
                        "content": "It was really difficult until manage to solve by 6th submission, seeing actually how it is easy, brrr."
                    },
                    {
                        "username": "mehrak205",
                        "content": "This is my code but it\\'s not working for all the cases .\\n\\nint maxProfit(vector<int>& prices) {\\n        if(prices.size()==1)\\n        return 0;\\n        int bs=INT_MAX;\\n        int ind=-1;\\n        int maxprofit=0;\\n        for(int i=0;i<prices.size()-1;i++){\\n            if(prices[i]<bs){\\n                bs=prices[i];\\n                ind=i;\\n            }\\n        } \\n        for(int i=ind+1;i<prices.size();i++){\\n            if(prices[i]-bs>maxprofit)\\n            maxprofit=prices[i]-prices[ind];\\n        }\\n        return maxprofit;\\n    }"
                    },
                    {
                        "username": "bparanj",
                        "content": "Consider the following array: `[3,2,6,5,0,3]`. The lowest price is `0` (on the 5th day), but if you buy at this day you wouldn\\'t make a profit because there\\'s no higher price after it. The maximum profit you can make is by buying at the 2nd day where the price is `2`, and selling at the 3rd day where the price is `6`, even though `2` isn\\'t the lowest price in the array. \\n\\nThe example illustrates the issue with your code: you cannot simply buy at the lowest price because it doesn\\'t guarantee the maximum profit. \\n\\nThe correct approach is:\\n\\n```cpp\\nint maxProfit(vector<int>& prices) {\\n    int min_price = INT_MAX;\\n    int max_profit = 0;\\n    for (int i = 0; i < prices.size(); i++) {\\n        if (prices[i] < min_price) {\\n            min_price = prices[i];\\n        } else if (prices[i] - min_price > max_profit) {\\n            max_profit = prices[i] - min_price;\\n        }\\n    }\\n    return max_profit;\\n}\\n```\\n\\nThis code iterates over the `prices` array, keeping track of the smallest price seen so far, and updating the maximum profit whenever a larger profit is found.\\n"
                    },
                    {
                        "username": "FerhatKul",
                        "content": "It was really difficult until manage to solve by 6th submission, seeing actually how it is easy, brrr."
                    },
                    {
                        "username": "victorpichugov",
                        "content": "Additional explanation: profit in 2 example 0 because:\\n1) the minimum element is last\\n2) if the last element is the minimum, then you need to search for the minimum first to the minimum, i.e. arr[:len(arr) - 1] , but in the 2 example 7 > 6 > 4 > 3 > 1"
                    },
                    {
                        "username": "_vikash_kumar_",
                        "content": "EASY SOLUTION.......\\nclass Solution {\\n    public int maxProfit(int[] prices) {\\n        int n=prices.length;\\n        int min=Integer.MAX_VALUE;\\n        int diff=0;\\n        for(int i=0;i<n;i++)\\n        {\\n            min=Math.min(prices[i],min);\\n            diff=Math.max(diff,prices[i]-min);\\n        }\\n        return diff;\\n        \\n        \\n    }\\n}\\n"
                    },
                    {
                        "username": "bharti820",
                        "content": "step1: take starting index as lowprice and profit be 0 and initialize i=1\\nstep 2 while(i<:pricesSize)do step 3 to step 6\\nstep3 cost=prices[i]-lowprice\\nstep4 if(profit<cost)\\n     profit=cost\\nstep 5 if (lowprice>prices[i])\\nlowprice=prices[i]\\nstep 6 end of loop\\nstep 7 return profit\\n   "
                    },
                    {
                        "username": "cOde_Ranvir25",
                        "content": "Here is the Approach:-\n\nIterate through the prices array and keep track of the minimum price seen so far, and the maximum profit that can be obtained by selling the stock at the current price after buying it at the minimum price seen so far.\n\nAt each iteration, calculate the difference between the current price and the minimum price seen so far, which gives the profit that can be obtained by selling the stock at the current price after buying it at the minimum price seen so far. Update the maximum profit obtained so far by taking the maximum of the current profit and the maximum profit obtained in the previous iterations. Update the minimum price seen so far by taking the minimum of the current price and the minimum price seen in the previous iterations.\n\nBy the end of the iteration, the maximum profit obtained is returned as the output of the function."
                    },
                    {
                        "username": "cOde_Ranvir25",
                        "content": "Here is the code link for Help:-\\nhttps://leetcode.com/problems/best-time-to-buy-and-sell-stock/solutions/2941124/thanks-to-striver-for-an-great-explanation/?orderBy=most_votes"
                    }
                ]
            },
            {
                "id": 1814096,
                "content": [
                    {
                        "username": "kos2kos",
                        "content": "<div class=\"view-lines monaco-mouse-cursor-text\" role=\"presentation\" aria-hidden=\"true\" data-mprt=\"7\" style=\"position: absolute; font-family: Menlo, Monaco, &quot;Courier New&quot;, monospace; font-weight: normal; font-size: 15px; font-feature-settings: &quot;liga&quot; 0, &quot;calt&quot; 0; line-height: 23px; letter-spacing: 0px; width: 1364px; height: 747px;\"><div style=\"top:8px;height:23px;\" class=\"view-line\"><span><span class=\"mtk4\">class</span><span class=\"mtk1\">&nbsp;</span><span class=\"mtk10\">Solution</span><span class=\"mtk1\">&nbsp;{</span></span></div><div style=\"top:31px;height:23px;\" class=\"view-line\"><span><span class=\"mtk1\">&nbsp;&nbsp;&nbsp;&nbsp;</span><span class=\"mtk4\">public</span><span class=\"mtk1\">&nbsp;</span><span class=\"mtk10\">int</span><span class=\"mtk1\">&nbsp;</span><span class=\"mtk11\">maxProfit</span><span class=\"mtk1\">(</span><span class=\"mtk10\">int</span><span class=\"mtk1\">[]&nbsp;</span><span class=\"mtk14\">prices</span><span class=\"mtk1\">)&nbsp;{</span></span></div><div style=\"top:54px;height:23px;\" class=\"view-line\"><span><span class=\"mtk1\">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class=\"mtk3\">/*Go&nbsp;through&nbsp;list&nbsp;and&nbsp;add&nbsp;all&nbsp;values&nbsp;maintaing&nbsp;max</span><span class=\"mtk3\">imum&nbsp;value&nbsp;</span></span></div><div style=\"top:77px;height:23px;\" class=\"view-line\"><span><span class=\"mtk3\">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;iterate&nbsp;through&nbsp;the&nbsp;list&nbsp;and&nbsp;find&nbsp;differen</span><span class=\"mtk3\">ce&nbsp;between&nbsp;max&nbsp;and&nbsp;current&nbsp;val.&nbsp;set&nbsp;result&nbsp;to&nbsp;larg</span><span class=\"mtk3\">er&nbsp;numnber.</span></span></div><div style=\"top:100px;height:23px;\" class=\"view-line\"><span><span class=\"mtk3\">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;remove&nbsp;currnet&nbsp;number&nbsp;from&nbsp;maxHeap.&nbsp;</span></span></div><div style=\"top:123px;height:23px;\" class=\"view-line\"><span><span class=\"mtk3\">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return&nbsp;result</span></span></div><div style=\"top:146px;height:23px;\" class=\"view-line\"><span><span class=\"mtk3\">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;*/</span></span></div><div style=\"top:169px;height:23px;\" class=\"view-line\"><span><span class=\"mtk1\">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class=\"mtk10\">PriorityQueue</span><span class=\"mtk1\">&lt;</span><span class=\"mtk10\">Integer</span><span class=\"mtk1\">&gt;&nbsp;</span><span class=\"mtk14\">maxHeap</span><span class=\"mtk1\">&nbsp;=&nbsp;</span><span class=\"mtk13\">new</span><span class=\"mtk1\">&nbsp;</span><span class=\"mtk10\">PriorityQueue</span><span class=\"mtk1\">&lt;&gt;(</span><span class=\"mtk14\">Collections</span><span class=\"mtk1\">.</span><span class=\"mtk11\">reverseOrder</span><span class=\"mtk1\">());</span></span></div><div style=\"top:192px;height:23px;\" class=\"view-line\"><span><span></span></span></div><div style=\"top:215px;height:23px;\" class=\"view-line\"><span><span class=\"mtk1\">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class=\"mtk10\">int</span><span class=\"mtk1\">&nbsp;</span><span class=\"mtk14\">result</span><span class=\"mtk1\">&nbsp;=&nbsp;</span><span class=\"mtk7\">0</span><span class=\"mtk1\">;</span></span></div><div style=\"top:238px;height:23px;\" class=\"view-line\"><span><span class=\"mtk1\">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span></span></div><div style=\"top:261px;height:23px;\" class=\"view-line\"><span><span class=\"mtk1\">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class=\"mtk13\">for</span><span class=\"mtk1\">&nbsp;(</span><span class=\"mtk10\">int</span><span class=\"mtk1\">&nbsp;</span><span class=\"mtk14\">stock</span><span class=\"mtk13\">:</span><span class=\"mtk1\">&nbsp;prices){</span></span></div><div style=\"top:284px;height:23px;\" class=\"view-line\"><span><span class=\"mtk1\">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class=\"mtk14\">maxHeap</span><span class=\"mtk1\">.</span><span class=\"mtk11\">add</span><span class=\"mtk1\">(stock);</span></span></div><div style=\"top:307px;height:23px;\" class=\"view-line\"><span><span class=\"mtk1\">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}</span></span></div><div style=\"top:330px;height:23px;\" class=\"view-line\"><span><span></span></span></div><div style=\"top:353px;height:23px;\" class=\"view-line\"><span><span class=\"mtk1\">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class=\"mtk13\">for</span><span class=\"mtk1\">&nbsp;(</span><span class=\"mtk10\">int</span><span class=\"mtk1\">&nbsp;</span><span class=\"mtk14\">i</span><span class=\"mtk1\">&nbsp;=&nbsp;</span><span class=\"mtk7\">0</span><span class=\"mtk1\">;&nbsp;i&nbsp;&lt;&nbsp;</span><span class=\"mtk14\">prices</span><span class=\"mtk1\">.</span><span class=\"mtk14\">length</span><span class=\"mtk1\">;&nbsp;i++){</span></span></div><div style=\"top:376px;height:23px;\" class=\"view-line\"><span><span class=\"mtk1\">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class=\"mtk13\">if</span><span class=\"mtk1\">&nbsp;(prices[i]&nbsp;==&nbsp;</span><span class=\"mtk14\">maxHeap</span><span class=\"mtk1\">.</span><span class=\"mtk11\">peek</span><span class=\"mtk1\">())&nbsp;</span><span class=\"mtk14\">maxHeap</span><span class=\"mtk1\">.</span><span class=\"mtk11\">poll</span><span class=\"mtk1\">();</span></span></div><div style=\"top:399px;height:23px;\" class=\"view-line\"><span><span class=\"mtk1\">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;result&nbsp;=&nbsp;</span><span class=\"mtk14\">Math</span><span class=\"mtk1\">.</span><span class=\"mtk11\">max</span><span class=\"mtk1\">(result,&nbsp;</span><span class=\"mtk14\">maxHeap</span><span class=\"mtk1\">.</span><span class=\"mtk11\">peek</span><span class=\"mtk1\">()&nbsp;-&nbsp;prices[i]);</span></span></div><div style=\"top:422px;height:23px;\" class=\"view-line\"><span><span class=\"mtk1\">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}</span></span></div><div style=\"top:445px;height:23px;\" class=\"view-line\"><span><span></span></span></div><div style=\"top:468px;height:23px;\" class=\"view-line\"><span><span class=\"mtk1\">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class=\"mtk13\">return</span><span class=\"mtk1\">&nbsp;result;</span></span></div><div style=\"top:491px;height:23px;\" class=\"view-line\"><span><span class=\"mtk1\">&nbsp;&nbsp;&nbsp;&nbsp;}</span></span></div><div style=\"top:514px;height:23px;\" class=\"view-line\"><span><span class=\"mtk1\">}</span></span></div></div>\\n\\nThis was my first initial take where I had my current value and tried to find the max difference by comparing the FUTURE VALUES and that\\'s how I interpret the brute force solution by looking forward at all maximum differences. I was stuck for a few minutes on approach two, especially this code block if (prices[i] - minprice > maxprofit) because at first glance I saw that as knowing the future value and then knowing the overall min value, which didn\\'t make sense to me. Now I see the code working as the following, on my current day what was the smallest stock purchase price that proceeded me, find the difference between now and then. I now know I can buy on that day and sell today. A little counterintuitive and not how I think about in practical day to day terms. My first version runs O(n)log(n) with O(n) space. Hope this is helpful for those who need a good middle jumping step to get to the final solution."
                    },
                    {
                        "username": "sanshoys",
                        "content": "return Array.IndexOf(prices, prices.Max()) why is this not working?"
                    },
                    {
                        "username": "mdganapati",
                        "content": "Input: prices = [7,1,5,3,6,4]\\nOutput: 5\\nExplanation: Buy on day 2 (price = 1) and sell on day 5 (price = 6), profit = 6-1 = 5.\\nNote that buying on day 2 and selling on day 1 is not allowed because you must buy before you sell.\\n\\nNow here \\n\\nbuy at 2nd day (1) and sell at 3rd day(5) so profit = 5-1 = 4;\\n\\nnext buy at 4th day(3) and sell on 5th day(6) so the profit = 6-3= 3\\n\\nso the total profit is 4+3 = 7;\\n\\nbut expected is 5 HOW COME ???????????? \\n\\n\\n"
                    },
                    {
                        "username": "FerhatKul",
                        "content": "It was really difficult until manage to solve by 6th submission, seeing actually how it is easy, brrr."
                    },
                    {
                        "username": "mehrak205",
                        "content": "This is my code but it\\'s not working for all the cases .\\n\\nint maxProfit(vector<int>& prices) {\\n        if(prices.size()==1)\\n        return 0;\\n        int bs=INT_MAX;\\n        int ind=-1;\\n        int maxprofit=0;\\n        for(int i=0;i<prices.size()-1;i++){\\n            if(prices[i]<bs){\\n                bs=prices[i];\\n                ind=i;\\n            }\\n        } \\n        for(int i=ind+1;i<prices.size();i++){\\n            if(prices[i]-bs>maxprofit)\\n            maxprofit=prices[i]-prices[ind];\\n        }\\n        return maxprofit;\\n    }"
                    },
                    {
                        "username": "bparanj",
                        "content": "Consider the following array: `[3,2,6,5,0,3]`. The lowest price is `0` (on the 5th day), but if you buy at this day you wouldn\\'t make a profit because there\\'s no higher price after it. The maximum profit you can make is by buying at the 2nd day where the price is `2`, and selling at the 3rd day where the price is `6`, even though `2` isn\\'t the lowest price in the array. \\n\\nThe example illustrates the issue with your code: you cannot simply buy at the lowest price because it doesn\\'t guarantee the maximum profit. \\n\\nThe correct approach is:\\n\\n```cpp\\nint maxProfit(vector<int>& prices) {\\n    int min_price = INT_MAX;\\n    int max_profit = 0;\\n    for (int i = 0; i < prices.size(); i++) {\\n        if (prices[i] < min_price) {\\n            min_price = prices[i];\\n        } else if (prices[i] - min_price > max_profit) {\\n            max_profit = prices[i] - min_price;\\n        }\\n    }\\n    return max_profit;\\n}\\n```\\n\\nThis code iterates over the `prices` array, keeping track of the smallest price seen so far, and updating the maximum profit whenever a larger profit is found.\\n"
                    },
                    {
                        "username": "FerhatKul",
                        "content": "It was really difficult until manage to solve by 6th submission, seeing actually how it is easy, brrr."
                    },
                    {
                        "username": "victorpichugov",
                        "content": "Additional explanation: profit in 2 example 0 because:\\n1) the minimum element is last\\n2) if the last element is the minimum, then you need to search for the minimum first to the minimum, i.e. arr[:len(arr) - 1] , but in the 2 example 7 > 6 > 4 > 3 > 1"
                    },
                    {
                        "username": "_vikash_kumar_",
                        "content": "EASY SOLUTION.......\\nclass Solution {\\n    public int maxProfit(int[] prices) {\\n        int n=prices.length;\\n        int min=Integer.MAX_VALUE;\\n        int diff=0;\\n        for(int i=0;i<n;i++)\\n        {\\n            min=Math.min(prices[i],min);\\n            diff=Math.max(diff,prices[i]-min);\\n        }\\n        return diff;\\n        \\n        \\n    }\\n}\\n"
                    },
                    {
                        "username": "bharti820",
                        "content": "step1: take starting index as lowprice and profit be 0 and initialize i=1\\nstep 2 while(i<:pricesSize)do step 3 to step 6\\nstep3 cost=prices[i]-lowprice\\nstep4 if(profit<cost)\\n     profit=cost\\nstep 5 if (lowprice>prices[i])\\nlowprice=prices[i]\\nstep 6 end of loop\\nstep 7 return profit\\n   "
                    },
                    {
                        "username": "cOde_Ranvir25",
                        "content": "Here is the Approach:-\n\nIterate through the prices array and keep track of the minimum price seen so far, and the maximum profit that can be obtained by selling the stock at the current price after buying it at the minimum price seen so far.\n\nAt each iteration, calculate the difference between the current price and the minimum price seen so far, which gives the profit that can be obtained by selling the stock at the current price after buying it at the minimum price seen so far. Update the maximum profit obtained so far by taking the maximum of the current profit and the maximum profit obtained in the previous iterations. Update the minimum price seen so far by taking the minimum of the current price and the minimum price seen in the previous iterations.\n\nBy the end of the iteration, the maximum profit obtained is returned as the output of the function."
                    },
                    {
                        "username": "cOde_Ranvir25",
                        "content": "Here is the code link for Help:-\\nhttps://leetcode.com/problems/best-time-to-buy-and-sell-stock/solutions/2941124/thanks-to-striver-for-an-great-explanation/?orderBy=most_votes"
                    }
                ]
            },
            {
                "id": 1814094,
                "content": [
                    {
                        "username": "kos2kos",
                        "content": "<div class=\"view-lines monaco-mouse-cursor-text\" role=\"presentation\" aria-hidden=\"true\" data-mprt=\"7\" style=\"position: absolute; font-family: Menlo, Monaco, &quot;Courier New&quot;, monospace; font-weight: normal; font-size: 15px; font-feature-settings: &quot;liga&quot; 0, &quot;calt&quot; 0; line-height: 23px; letter-spacing: 0px; width: 1364px; height: 747px;\"><div style=\"top:8px;height:23px;\" class=\"view-line\"><span><span class=\"mtk4\">class</span><span class=\"mtk1\">&nbsp;</span><span class=\"mtk10\">Solution</span><span class=\"mtk1\">&nbsp;{</span></span></div><div style=\"top:31px;height:23px;\" class=\"view-line\"><span><span class=\"mtk1\">&nbsp;&nbsp;&nbsp;&nbsp;</span><span class=\"mtk4\">public</span><span class=\"mtk1\">&nbsp;</span><span class=\"mtk10\">int</span><span class=\"mtk1\">&nbsp;</span><span class=\"mtk11\">maxProfit</span><span class=\"mtk1\">(</span><span class=\"mtk10\">int</span><span class=\"mtk1\">[]&nbsp;</span><span class=\"mtk14\">prices</span><span class=\"mtk1\">)&nbsp;{</span></span></div><div style=\"top:54px;height:23px;\" class=\"view-line\"><span><span class=\"mtk1\">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class=\"mtk3\">/*Go&nbsp;through&nbsp;list&nbsp;and&nbsp;add&nbsp;all&nbsp;values&nbsp;maintaing&nbsp;max</span><span class=\"mtk3\">imum&nbsp;value&nbsp;</span></span></div><div style=\"top:77px;height:23px;\" class=\"view-line\"><span><span class=\"mtk3\">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;iterate&nbsp;through&nbsp;the&nbsp;list&nbsp;and&nbsp;find&nbsp;differen</span><span class=\"mtk3\">ce&nbsp;between&nbsp;max&nbsp;and&nbsp;current&nbsp;val.&nbsp;set&nbsp;result&nbsp;to&nbsp;larg</span><span class=\"mtk3\">er&nbsp;numnber.</span></span></div><div style=\"top:100px;height:23px;\" class=\"view-line\"><span><span class=\"mtk3\">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;remove&nbsp;currnet&nbsp;number&nbsp;from&nbsp;maxHeap.&nbsp;</span></span></div><div style=\"top:123px;height:23px;\" class=\"view-line\"><span><span class=\"mtk3\">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return&nbsp;result</span></span></div><div style=\"top:146px;height:23px;\" class=\"view-line\"><span><span class=\"mtk3\">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;*/</span></span></div><div style=\"top:169px;height:23px;\" class=\"view-line\"><span><span class=\"mtk1\">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class=\"mtk10\">PriorityQueue</span><span class=\"mtk1\">&lt;</span><span class=\"mtk10\">Integer</span><span class=\"mtk1\">&gt;&nbsp;</span><span class=\"mtk14\">maxHeap</span><span class=\"mtk1\">&nbsp;=&nbsp;</span><span class=\"mtk13\">new</span><span class=\"mtk1\">&nbsp;</span><span class=\"mtk10\">PriorityQueue</span><span class=\"mtk1\">&lt;&gt;(</span><span class=\"mtk14\">Collections</span><span class=\"mtk1\">.</span><span class=\"mtk11\">reverseOrder</span><span class=\"mtk1\">());</span></span></div><div style=\"top:192px;height:23px;\" class=\"view-line\"><span><span></span></span></div><div style=\"top:215px;height:23px;\" class=\"view-line\"><span><span class=\"mtk1\">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class=\"mtk10\">int</span><span class=\"mtk1\">&nbsp;</span><span class=\"mtk14\">result</span><span class=\"mtk1\">&nbsp;=&nbsp;</span><span class=\"mtk7\">0</span><span class=\"mtk1\">;</span></span></div><div style=\"top:238px;height:23px;\" class=\"view-line\"><span><span class=\"mtk1\">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span></span></div><div style=\"top:261px;height:23px;\" class=\"view-line\"><span><span class=\"mtk1\">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class=\"mtk13\">for</span><span class=\"mtk1\">&nbsp;(</span><span class=\"mtk10\">int</span><span class=\"mtk1\">&nbsp;</span><span class=\"mtk14\">stock</span><span class=\"mtk13\">:</span><span class=\"mtk1\">&nbsp;prices){</span></span></div><div style=\"top:284px;height:23px;\" class=\"view-line\"><span><span class=\"mtk1\">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class=\"mtk14\">maxHeap</span><span class=\"mtk1\">.</span><span class=\"mtk11\">add</span><span class=\"mtk1\">(stock);</span></span></div><div style=\"top:307px;height:23px;\" class=\"view-line\"><span><span class=\"mtk1\">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}</span></span></div><div style=\"top:330px;height:23px;\" class=\"view-line\"><span><span></span></span></div><div style=\"top:353px;height:23px;\" class=\"view-line\"><span><span class=\"mtk1\">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class=\"mtk13\">for</span><span class=\"mtk1\">&nbsp;(</span><span class=\"mtk10\">int</span><span class=\"mtk1\">&nbsp;</span><span class=\"mtk14\">i</span><span class=\"mtk1\">&nbsp;=&nbsp;</span><span class=\"mtk7\">0</span><span class=\"mtk1\">;&nbsp;i&nbsp;&lt;&nbsp;</span><span class=\"mtk14\">prices</span><span class=\"mtk1\">.</span><span class=\"mtk14\">length</span><span class=\"mtk1\">;&nbsp;i++){</span></span></div><div style=\"top:376px;height:23px;\" class=\"view-line\"><span><span class=\"mtk1\">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class=\"mtk13\">if</span><span class=\"mtk1\">&nbsp;(prices[i]&nbsp;==&nbsp;</span><span class=\"mtk14\">maxHeap</span><span class=\"mtk1\">.</span><span class=\"mtk11\">peek</span><span class=\"mtk1\">())&nbsp;</span><span class=\"mtk14\">maxHeap</span><span class=\"mtk1\">.</span><span class=\"mtk11\">poll</span><span class=\"mtk1\">();</span></span></div><div style=\"top:399px;height:23px;\" class=\"view-line\"><span><span class=\"mtk1\">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;result&nbsp;=&nbsp;</span><span class=\"mtk14\">Math</span><span class=\"mtk1\">.</span><span class=\"mtk11\">max</span><span class=\"mtk1\">(result,&nbsp;</span><span class=\"mtk14\">maxHeap</span><span class=\"mtk1\">.</span><span class=\"mtk11\">peek</span><span class=\"mtk1\">()&nbsp;-&nbsp;prices[i]);</span></span></div><div style=\"top:422px;height:23px;\" class=\"view-line\"><span><span class=\"mtk1\">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}</span></span></div><div style=\"top:445px;height:23px;\" class=\"view-line\"><span><span></span></span></div><div style=\"top:468px;height:23px;\" class=\"view-line\"><span><span class=\"mtk1\">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class=\"mtk13\">return</span><span class=\"mtk1\">&nbsp;result;</span></span></div><div style=\"top:491px;height:23px;\" class=\"view-line\"><span><span class=\"mtk1\">&nbsp;&nbsp;&nbsp;&nbsp;}</span></span></div><div style=\"top:514px;height:23px;\" class=\"view-line\"><span><span class=\"mtk1\">}</span></span></div></div>\\n\\nThis was my first initial take where I had my current value and tried to find the max difference by comparing the FUTURE VALUES and that\\'s how I interpret the brute force solution by looking forward at all maximum differences. I was stuck for a few minutes on approach two, especially this code block if (prices[i] - minprice > maxprofit) because at first glance I saw that as knowing the future value and then knowing the overall min value, which didn\\'t make sense to me. Now I see the code working as the following, on my current day what was the smallest stock purchase price that proceeded me, find the difference between now and then. I now know I can buy on that day and sell today. A little counterintuitive and not how I think about in practical day to day terms. My first version runs O(n)log(n) with O(n) space. Hope this is helpful for those who need a good middle jumping step to get to the final solution."
                    },
                    {
                        "username": "sanshoys",
                        "content": "return Array.IndexOf(prices, prices.Max()) why is this not working?"
                    },
                    {
                        "username": "mdganapati",
                        "content": "Input: prices = [7,1,5,3,6,4]\\nOutput: 5\\nExplanation: Buy on day 2 (price = 1) and sell on day 5 (price = 6), profit = 6-1 = 5.\\nNote that buying on day 2 and selling on day 1 is not allowed because you must buy before you sell.\\n\\nNow here \\n\\nbuy at 2nd day (1) and sell at 3rd day(5) so profit = 5-1 = 4;\\n\\nnext buy at 4th day(3) and sell on 5th day(6) so the profit = 6-3= 3\\n\\nso the total profit is 4+3 = 7;\\n\\nbut expected is 5 HOW COME ???????????? \\n\\n\\n"
                    },
                    {
                        "username": "FerhatKul",
                        "content": "It was really difficult until manage to solve by 6th submission, seeing actually how it is easy, brrr."
                    },
                    {
                        "username": "mehrak205",
                        "content": "This is my code but it\\'s not working for all the cases .\\n\\nint maxProfit(vector<int>& prices) {\\n        if(prices.size()==1)\\n        return 0;\\n        int bs=INT_MAX;\\n        int ind=-1;\\n        int maxprofit=0;\\n        for(int i=0;i<prices.size()-1;i++){\\n            if(prices[i]<bs){\\n                bs=prices[i];\\n                ind=i;\\n            }\\n        } \\n        for(int i=ind+1;i<prices.size();i++){\\n            if(prices[i]-bs>maxprofit)\\n            maxprofit=prices[i]-prices[ind];\\n        }\\n        return maxprofit;\\n    }"
                    },
                    {
                        "username": "bparanj",
                        "content": "Consider the following array: `[3,2,6,5,0,3]`. The lowest price is `0` (on the 5th day), but if you buy at this day you wouldn\\'t make a profit because there\\'s no higher price after it. The maximum profit you can make is by buying at the 2nd day where the price is `2`, and selling at the 3rd day where the price is `6`, even though `2` isn\\'t the lowest price in the array. \\n\\nThe example illustrates the issue with your code: you cannot simply buy at the lowest price because it doesn\\'t guarantee the maximum profit. \\n\\nThe correct approach is:\\n\\n```cpp\\nint maxProfit(vector<int>& prices) {\\n    int min_price = INT_MAX;\\n    int max_profit = 0;\\n    for (int i = 0; i < prices.size(); i++) {\\n        if (prices[i] < min_price) {\\n            min_price = prices[i];\\n        } else if (prices[i] - min_price > max_profit) {\\n            max_profit = prices[i] - min_price;\\n        }\\n    }\\n    return max_profit;\\n}\\n```\\n\\nThis code iterates over the `prices` array, keeping track of the smallest price seen so far, and updating the maximum profit whenever a larger profit is found.\\n"
                    },
                    {
                        "username": "FerhatKul",
                        "content": "It was really difficult until manage to solve by 6th submission, seeing actually how it is easy, brrr."
                    },
                    {
                        "username": "victorpichugov",
                        "content": "Additional explanation: profit in 2 example 0 because:\\n1) the minimum element is last\\n2) if the last element is the minimum, then you need to search for the minimum first to the minimum, i.e. arr[:len(arr) - 1] , but in the 2 example 7 > 6 > 4 > 3 > 1"
                    },
                    {
                        "username": "_vikash_kumar_",
                        "content": "EASY SOLUTION.......\\nclass Solution {\\n    public int maxProfit(int[] prices) {\\n        int n=prices.length;\\n        int min=Integer.MAX_VALUE;\\n        int diff=0;\\n        for(int i=0;i<n;i++)\\n        {\\n            min=Math.min(prices[i],min);\\n            diff=Math.max(diff,prices[i]-min);\\n        }\\n        return diff;\\n        \\n        \\n    }\\n}\\n"
                    },
                    {
                        "username": "bharti820",
                        "content": "step1: take starting index as lowprice and profit be 0 and initialize i=1\\nstep 2 while(i<:pricesSize)do step 3 to step 6\\nstep3 cost=prices[i]-lowprice\\nstep4 if(profit<cost)\\n     profit=cost\\nstep 5 if (lowprice>prices[i])\\nlowprice=prices[i]\\nstep 6 end of loop\\nstep 7 return profit\\n   "
                    },
                    {
                        "username": "cOde_Ranvir25",
                        "content": "Here is the Approach:-\n\nIterate through the prices array and keep track of the minimum price seen so far, and the maximum profit that can be obtained by selling the stock at the current price after buying it at the minimum price seen so far.\n\nAt each iteration, calculate the difference between the current price and the minimum price seen so far, which gives the profit that can be obtained by selling the stock at the current price after buying it at the minimum price seen so far. Update the maximum profit obtained so far by taking the maximum of the current profit and the maximum profit obtained in the previous iterations. Update the minimum price seen so far by taking the minimum of the current price and the minimum price seen in the previous iterations.\n\nBy the end of the iteration, the maximum profit obtained is returned as the output of the function."
                    },
                    {
                        "username": "cOde_Ranvir25",
                        "content": "Here is the code link for Help:-\\nhttps://leetcode.com/problems/best-time-to-buy-and-sell-stock/solutions/2941124/thanks-to-striver-for-an-great-explanation/?orderBy=most_votes"
                    }
                ]
            },
            {
                "id": 1814093,
                "content": [
                    {
                        "username": "kos2kos",
                        "content": "<div class=\"view-lines monaco-mouse-cursor-text\" role=\"presentation\" aria-hidden=\"true\" data-mprt=\"7\" style=\"position: absolute; font-family: Menlo, Monaco, &quot;Courier New&quot;, monospace; font-weight: normal; font-size: 15px; font-feature-settings: &quot;liga&quot; 0, &quot;calt&quot; 0; line-height: 23px; letter-spacing: 0px; width: 1364px; height: 747px;\"><div style=\"top:8px;height:23px;\" class=\"view-line\"><span><span class=\"mtk4\">class</span><span class=\"mtk1\">&nbsp;</span><span class=\"mtk10\">Solution</span><span class=\"mtk1\">&nbsp;{</span></span></div><div style=\"top:31px;height:23px;\" class=\"view-line\"><span><span class=\"mtk1\">&nbsp;&nbsp;&nbsp;&nbsp;</span><span class=\"mtk4\">public</span><span class=\"mtk1\">&nbsp;</span><span class=\"mtk10\">int</span><span class=\"mtk1\">&nbsp;</span><span class=\"mtk11\">maxProfit</span><span class=\"mtk1\">(</span><span class=\"mtk10\">int</span><span class=\"mtk1\">[]&nbsp;</span><span class=\"mtk14\">prices</span><span class=\"mtk1\">)&nbsp;{</span></span></div><div style=\"top:54px;height:23px;\" class=\"view-line\"><span><span class=\"mtk1\">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class=\"mtk3\">/*Go&nbsp;through&nbsp;list&nbsp;and&nbsp;add&nbsp;all&nbsp;values&nbsp;maintaing&nbsp;max</span><span class=\"mtk3\">imum&nbsp;value&nbsp;</span></span></div><div style=\"top:77px;height:23px;\" class=\"view-line\"><span><span class=\"mtk3\">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;iterate&nbsp;through&nbsp;the&nbsp;list&nbsp;and&nbsp;find&nbsp;differen</span><span class=\"mtk3\">ce&nbsp;between&nbsp;max&nbsp;and&nbsp;current&nbsp;val.&nbsp;set&nbsp;result&nbsp;to&nbsp;larg</span><span class=\"mtk3\">er&nbsp;numnber.</span></span></div><div style=\"top:100px;height:23px;\" class=\"view-line\"><span><span class=\"mtk3\">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;remove&nbsp;currnet&nbsp;number&nbsp;from&nbsp;maxHeap.&nbsp;</span></span></div><div style=\"top:123px;height:23px;\" class=\"view-line\"><span><span class=\"mtk3\">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return&nbsp;result</span></span></div><div style=\"top:146px;height:23px;\" class=\"view-line\"><span><span class=\"mtk3\">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;*/</span></span></div><div style=\"top:169px;height:23px;\" class=\"view-line\"><span><span class=\"mtk1\">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class=\"mtk10\">PriorityQueue</span><span class=\"mtk1\">&lt;</span><span class=\"mtk10\">Integer</span><span class=\"mtk1\">&gt;&nbsp;</span><span class=\"mtk14\">maxHeap</span><span class=\"mtk1\">&nbsp;=&nbsp;</span><span class=\"mtk13\">new</span><span class=\"mtk1\">&nbsp;</span><span class=\"mtk10\">PriorityQueue</span><span class=\"mtk1\">&lt;&gt;(</span><span class=\"mtk14\">Collections</span><span class=\"mtk1\">.</span><span class=\"mtk11\">reverseOrder</span><span class=\"mtk1\">());</span></span></div><div style=\"top:192px;height:23px;\" class=\"view-line\"><span><span></span></span></div><div style=\"top:215px;height:23px;\" class=\"view-line\"><span><span class=\"mtk1\">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class=\"mtk10\">int</span><span class=\"mtk1\">&nbsp;</span><span class=\"mtk14\">result</span><span class=\"mtk1\">&nbsp;=&nbsp;</span><span class=\"mtk7\">0</span><span class=\"mtk1\">;</span></span></div><div style=\"top:238px;height:23px;\" class=\"view-line\"><span><span class=\"mtk1\">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span></span></div><div style=\"top:261px;height:23px;\" class=\"view-line\"><span><span class=\"mtk1\">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class=\"mtk13\">for</span><span class=\"mtk1\">&nbsp;(</span><span class=\"mtk10\">int</span><span class=\"mtk1\">&nbsp;</span><span class=\"mtk14\">stock</span><span class=\"mtk13\">:</span><span class=\"mtk1\">&nbsp;prices){</span></span></div><div style=\"top:284px;height:23px;\" class=\"view-line\"><span><span class=\"mtk1\">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class=\"mtk14\">maxHeap</span><span class=\"mtk1\">.</span><span class=\"mtk11\">add</span><span class=\"mtk1\">(stock);</span></span></div><div style=\"top:307px;height:23px;\" class=\"view-line\"><span><span class=\"mtk1\">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}</span></span></div><div style=\"top:330px;height:23px;\" class=\"view-line\"><span><span></span></span></div><div style=\"top:353px;height:23px;\" class=\"view-line\"><span><span class=\"mtk1\">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class=\"mtk13\">for</span><span class=\"mtk1\">&nbsp;(</span><span class=\"mtk10\">int</span><span class=\"mtk1\">&nbsp;</span><span class=\"mtk14\">i</span><span class=\"mtk1\">&nbsp;=&nbsp;</span><span class=\"mtk7\">0</span><span class=\"mtk1\">;&nbsp;i&nbsp;&lt;&nbsp;</span><span class=\"mtk14\">prices</span><span class=\"mtk1\">.</span><span class=\"mtk14\">length</span><span class=\"mtk1\">;&nbsp;i++){</span></span></div><div style=\"top:376px;height:23px;\" class=\"view-line\"><span><span class=\"mtk1\">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class=\"mtk13\">if</span><span class=\"mtk1\">&nbsp;(prices[i]&nbsp;==&nbsp;</span><span class=\"mtk14\">maxHeap</span><span class=\"mtk1\">.</span><span class=\"mtk11\">peek</span><span class=\"mtk1\">())&nbsp;</span><span class=\"mtk14\">maxHeap</span><span class=\"mtk1\">.</span><span class=\"mtk11\">poll</span><span class=\"mtk1\">();</span></span></div><div style=\"top:399px;height:23px;\" class=\"view-line\"><span><span class=\"mtk1\">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;result&nbsp;=&nbsp;</span><span class=\"mtk14\">Math</span><span class=\"mtk1\">.</span><span class=\"mtk11\">max</span><span class=\"mtk1\">(result,&nbsp;</span><span class=\"mtk14\">maxHeap</span><span class=\"mtk1\">.</span><span class=\"mtk11\">peek</span><span class=\"mtk1\">()&nbsp;-&nbsp;prices[i]);</span></span></div><div style=\"top:422px;height:23px;\" class=\"view-line\"><span><span class=\"mtk1\">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}</span></span></div><div style=\"top:445px;height:23px;\" class=\"view-line\"><span><span></span></span></div><div style=\"top:468px;height:23px;\" class=\"view-line\"><span><span class=\"mtk1\">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class=\"mtk13\">return</span><span class=\"mtk1\">&nbsp;result;</span></span></div><div style=\"top:491px;height:23px;\" class=\"view-line\"><span><span class=\"mtk1\">&nbsp;&nbsp;&nbsp;&nbsp;}</span></span></div><div style=\"top:514px;height:23px;\" class=\"view-line\"><span><span class=\"mtk1\">}</span></span></div></div>\\n\\nThis was my first initial take where I had my current value and tried to find the max difference by comparing the FUTURE VALUES and that\\'s how I interpret the brute force solution by looking forward at all maximum differences. I was stuck for a few minutes on approach two, especially this code block if (prices[i] - minprice > maxprofit) because at first glance I saw that as knowing the future value and then knowing the overall min value, which didn\\'t make sense to me. Now I see the code working as the following, on my current day what was the smallest stock purchase price that proceeded me, find the difference between now and then. I now know I can buy on that day and sell today. A little counterintuitive and not how I think about in practical day to day terms. My first version runs O(n)log(n) with O(n) space. Hope this is helpful for those who need a good middle jumping step to get to the final solution."
                    },
                    {
                        "username": "sanshoys",
                        "content": "return Array.IndexOf(prices, prices.Max()) why is this not working?"
                    },
                    {
                        "username": "mdganapati",
                        "content": "Input: prices = [7,1,5,3,6,4]\\nOutput: 5\\nExplanation: Buy on day 2 (price = 1) and sell on day 5 (price = 6), profit = 6-1 = 5.\\nNote that buying on day 2 and selling on day 1 is not allowed because you must buy before you sell.\\n\\nNow here \\n\\nbuy at 2nd day (1) and sell at 3rd day(5) so profit = 5-1 = 4;\\n\\nnext buy at 4th day(3) and sell on 5th day(6) so the profit = 6-3= 3\\n\\nso the total profit is 4+3 = 7;\\n\\nbut expected is 5 HOW COME ???????????? \\n\\n\\n"
                    },
                    {
                        "username": "FerhatKul",
                        "content": "It was really difficult until manage to solve by 6th submission, seeing actually how it is easy, brrr."
                    },
                    {
                        "username": "mehrak205",
                        "content": "This is my code but it\\'s not working for all the cases .\\n\\nint maxProfit(vector<int>& prices) {\\n        if(prices.size()==1)\\n        return 0;\\n        int bs=INT_MAX;\\n        int ind=-1;\\n        int maxprofit=0;\\n        for(int i=0;i<prices.size()-1;i++){\\n            if(prices[i]<bs){\\n                bs=prices[i];\\n                ind=i;\\n            }\\n        } \\n        for(int i=ind+1;i<prices.size();i++){\\n            if(prices[i]-bs>maxprofit)\\n            maxprofit=prices[i]-prices[ind];\\n        }\\n        return maxprofit;\\n    }"
                    },
                    {
                        "username": "bparanj",
                        "content": "Consider the following array: `[3,2,6,5,0,3]`. The lowest price is `0` (on the 5th day), but if you buy at this day you wouldn\\'t make a profit because there\\'s no higher price after it. The maximum profit you can make is by buying at the 2nd day where the price is `2`, and selling at the 3rd day where the price is `6`, even though `2` isn\\'t the lowest price in the array. \\n\\nThe example illustrates the issue with your code: you cannot simply buy at the lowest price because it doesn\\'t guarantee the maximum profit. \\n\\nThe correct approach is:\\n\\n```cpp\\nint maxProfit(vector<int>& prices) {\\n    int min_price = INT_MAX;\\n    int max_profit = 0;\\n    for (int i = 0; i < prices.size(); i++) {\\n        if (prices[i] < min_price) {\\n            min_price = prices[i];\\n        } else if (prices[i] - min_price > max_profit) {\\n            max_profit = prices[i] - min_price;\\n        }\\n    }\\n    return max_profit;\\n}\\n```\\n\\nThis code iterates over the `prices` array, keeping track of the smallest price seen so far, and updating the maximum profit whenever a larger profit is found.\\n"
                    },
                    {
                        "username": "FerhatKul",
                        "content": "It was really difficult until manage to solve by 6th submission, seeing actually how it is easy, brrr."
                    },
                    {
                        "username": "victorpichugov",
                        "content": "Additional explanation: profit in 2 example 0 because:\\n1) the minimum element is last\\n2) if the last element is the minimum, then you need to search for the minimum first to the minimum, i.e. arr[:len(arr) - 1] , but in the 2 example 7 > 6 > 4 > 3 > 1"
                    },
                    {
                        "username": "_vikash_kumar_",
                        "content": "EASY SOLUTION.......\\nclass Solution {\\n    public int maxProfit(int[] prices) {\\n        int n=prices.length;\\n        int min=Integer.MAX_VALUE;\\n        int diff=0;\\n        for(int i=0;i<n;i++)\\n        {\\n            min=Math.min(prices[i],min);\\n            diff=Math.max(diff,prices[i]-min);\\n        }\\n        return diff;\\n        \\n        \\n    }\\n}\\n"
                    },
                    {
                        "username": "bharti820",
                        "content": "step1: take starting index as lowprice and profit be 0 and initialize i=1\\nstep 2 while(i<:pricesSize)do step 3 to step 6\\nstep3 cost=prices[i]-lowprice\\nstep4 if(profit<cost)\\n     profit=cost\\nstep 5 if (lowprice>prices[i])\\nlowprice=prices[i]\\nstep 6 end of loop\\nstep 7 return profit\\n   "
                    },
                    {
                        "username": "cOde_Ranvir25",
                        "content": "Here is the Approach:-\n\nIterate through the prices array and keep track of the minimum price seen so far, and the maximum profit that can be obtained by selling the stock at the current price after buying it at the minimum price seen so far.\n\nAt each iteration, calculate the difference between the current price and the minimum price seen so far, which gives the profit that can be obtained by selling the stock at the current price after buying it at the minimum price seen so far. Update the maximum profit obtained so far by taking the maximum of the current profit and the maximum profit obtained in the previous iterations. Update the minimum price seen so far by taking the minimum of the current price and the minimum price seen in the previous iterations.\n\nBy the end of the iteration, the maximum profit obtained is returned as the output of the function."
                    },
                    {
                        "username": "cOde_Ranvir25",
                        "content": "Here is the code link for Help:-\\nhttps://leetcode.com/problems/best-time-to-buy-and-sell-stock/solutions/2941124/thanks-to-striver-for-an-great-explanation/?orderBy=most_votes"
                    }
                ]
            },
            {
                "id": 1814039,
                "content": [
                    {
                        "username": "kos2kos",
                        "content": "<div class=\"view-lines monaco-mouse-cursor-text\" role=\"presentation\" aria-hidden=\"true\" data-mprt=\"7\" style=\"position: absolute; font-family: Menlo, Monaco, &quot;Courier New&quot;, monospace; font-weight: normal; font-size: 15px; font-feature-settings: &quot;liga&quot; 0, &quot;calt&quot; 0; line-height: 23px; letter-spacing: 0px; width: 1364px; height: 747px;\"><div style=\"top:8px;height:23px;\" class=\"view-line\"><span><span class=\"mtk4\">class</span><span class=\"mtk1\">&nbsp;</span><span class=\"mtk10\">Solution</span><span class=\"mtk1\">&nbsp;{</span></span></div><div style=\"top:31px;height:23px;\" class=\"view-line\"><span><span class=\"mtk1\">&nbsp;&nbsp;&nbsp;&nbsp;</span><span class=\"mtk4\">public</span><span class=\"mtk1\">&nbsp;</span><span class=\"mtk10\">int</span><span class=\"mtk1\">&nbsp;</span><span class=\"mtk11\">maxProfit</span><span class=\"mtk1\">(</span><span class=\"mtk10\">int</span><span class=\"mtk1\">[]&nbsp;</span><span class=\"mtk14\">prices</span><span class=\"mtk1\">)&nbsp;{</span></span></div><div style=\"top:54px;height:23px;\" class=\"view-line\"><span><span class=\"mtk1\">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class=\"mtk3\">/*Go&nbsp;through&nbsp;list&nbsp;and&nbsp;add&nbsp;all&nbsp;values&nbsp;maintaing&nbsp;max</span><span class=\"mtk3\">imum&nbsp;value&nbsp;</span></span></div><div style=\"top:77px;height:23px;\" class=\"view-line\"><span><span class=\"mtk3\">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;iterate&nbsp;through&nbsp;the&nbsp;list&nbsp;and&nbsp;find&nbsp;differen</span><span class=\"mtk3\">ce&nbsp;between&nbsp;max&nbsp;and&nbsp;current&nbsp;val.&nbsp;set&nbsp;result&nbsp;to&nbsp;larg</span><span class=\"mtk3\">er&nbsp;numnber.</span></span></div><div style=\"top:100px;height:23px;\" class=\"view-line\"><span><span class=\"mtk3\">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;remove&nbsp;currnet&nbsp;number&nbsp;from&nbsp;maxHeap.&nbsp;</span></span></div><div style=\"top:123px;height:23px;\" class=\"view-line\"><span><span class=\"mtk3\">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return&nbsp;result</span></span></div><div style=\"top:146px;height:23px;\" class=\"view-line\"><span><span class=\"mtk3\">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;*/</span></span></div><div style=\"top:169px;height:23px;\" class=\"view-line\"><span><span class=\"mtk1\">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class=\"mtk10\">PriorityQueue</span><span class=\"mtk1\">&lt;</span><span class=\"mtk10\">Integer</span><span class=\"mtk1\">&gt;&nbsp;</span><span class=\"mtk14\">maxHeap</span><span class=\"mtk1\">&nbsp;=&nbsp;</span><span class=\"mtk13\">new</span><span class=\"mtk1\">&nbsp;</span><span class=\"mtk10\">PriorityQueue</span><span class=\"mtk1\">&lt;&gt;(</span><span class=\"mtk14\">Collections</span><span class=\"mtk1\">.</span><span class=\"mtk11\">reverseOrder</span><span class=\"mtk1\">());</span></span></div><div style=\"top:192px;height:23px;\" class=\"view-line\"><span><span></span></span></div><div style=\"top:215px;height:23px;\" class=\"view-line\"><span><span class=\"mtk1\">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class=\"mtk10\">int</span><span class=\"mtk1\">&nbsp;</span><span class=\"mtk14\">result</span><span class=\"mtk1\">&nbsp;=&nbsp;</span><span class=\"mtk7\">0</span><span class=\"mtk1\">;</span></span></div><div style=\"top:238px;height:23px;\" class=\"view-line\"><span><span class=\"mtk1\">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span></span></div><div style=\"top:261px;height:23px;\" class=\"view-line\"><span><span class=\"mtk1\">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class=\"mtk13\">for</span><span class=\"mtk1\">&nbsp;(</span><span class=\"mtk10\">int</span><span class=\"mtk1\">&nbsp;</span><span class=\"mtk14\">stock</span><span class=\"mtk13\">:</span><span class=\"mtk1\">&nbsp;prices){</span></span></div><div style=\"top:284px;height:23px;\" class=\"view-line\"><span><span class=\"mtk1\">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class=\"mtk14\">maxHeap</span><span class=\"mtk1\">.</span><span class=\"mtk11\">add</span><span class=\"mtk1\">(stock);</span></span></div><div style=\"top:307px;height:23px;\" class=\"view-line\"><span><span class=\"mtk1\">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}</span></span></div><div style=\"top:330px;height:23px;\" class=\"view-line\"><span><span></span></span></div><div style=\"top:353px;height:23px;\" class=\"view-line\"><span><span class=\"mtk1\">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class=\"mtk13\">for</span><span class=\"mtk1\">&nbsp;(</span><span class=\"mtk10\">int</span><span class=\"mtk1\">&nbsp;</span><span class=\"mtk14\">i</span><span class=\"mtk1\">&nbsp;=&nbsp;</span><span class=\"mtk7\">0</span><span class=\"mtk1\">;&nbsp;i&nbsp;&lt;&nbsp;</span><span class=\"mtk14\">prices</span><span class=\"mtk1\">.</span><span class=\"mtk14\">length</span><span class=\"mtk1\">;&nbsp;i++){</span></span></div><div style=\"top:376px;height:23px;\" class=\"view-line\"><span><span class=\"mtk1\">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class=\"mtk13\">if</span><span class=\"mtk1\">&nbsp;(prices[i]&nbsp;==&nbsp;</span><span class=\"mtk14\">maxHeap</span><span class=\"mtk1\">.</span><span class=\"mtk11\">peek</span><span class=\"mtk1\">())&nbsp;</span><span class=\"mtk14\">maxHeap</span><span class=\"mtk1\">.</span><span class=\"mtk11\">poll</span><span class=\"mtk1\">();</span></span></div><div style=\"top:399px;height:23px;\" class=\"view-line\"><span><span class=\"mtk1\">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;result&nbsp;=&nbsp;</span><span class=\"mtk14\">Math</span><span class=\"mtk1\">.</span><span class=\"mtk11\">max</span><span class=\"mtk1\">(result,&nbsp;</span><span class=\"mtk14\">maxHeap</span><span class=\"mtk1\">.</span><span class=\"mtk11\">peek</span><span class=\"mtk1\">()&nbsp;-&nbsp;prices[i]);</span></span></div><div style=\"top:422px;height:23px;\" class=\"view-line\"><span><span class=\"mtk1\">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}</span></span></div><div style=\"top:445px;height:23px;\" class=\"view-line\"><span><span></span></span></div><div style=\"top:468px;height:23px;\" class=\"view-line\"><span><span class=\"mtk1\">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class=\"mtk13\">return</span><span class=\"mtk1\">&nbsp;result;</span></span></div><div style=\"top:491px;height:23px;\" class=\"view-line\"><span><span class=\"mtk1\">&nbsp;&nbsp;&nbsp;&nbsp;}</span></span></div><div style=\"top:514px;height:23px;\" class=\"view-line\"><span><span class=\"mtk1\">}</span></span></div></div>\\n\\nThis was my first initial take where I had my current value and tried to find the max difference by comparing the FUTURE VALUES and that\\'s how I interpret the brute force solution by looking forward at all maximum differences. I was stuck for a few minutes on approach two, especially this code block if (prices[i] - minprice > maxprofit) because at first glance I saw that as knowing the future value and then knowing the overall min value, which didn\\'t make sense to me. Now I see the code working as the following, on my current day what was the smallest stock purchase price that proceeded me, find the difference between now and then. I now know I can buy on that day and sell today. A little counterintuitive and not how I think about in practical day to day terms. My first version runs O(n)log(n) with O(n) space. Hope this is helpful for those who need a good middle jumping step to get to the final solution."
                    },
                    {
                        "username": "sanshoys",
                        "content": "return Array.IndexOf(prices, prices.Max()) why is this not working?"
                    },
                    {
                        "username": "mdganapati",
                        "content": "Input: prices = [7,1,5,3,6,4]\\nOutput: 5\\nExplanation: Buy on day 2 (price = 1) and sell on day 5 (price = 6), profit = 6-1 = 5.\\nNote that buying on day 2 and selling on day 1 is not allowed because you must buy before you sell.\\n\\nNow here \\n\\nbuy at 2nd day (1) and sell at 3rd day(5) so profit = 5-1 = 4;\\n\\nnext buy at 4th day(3) and sell on 5th day(6) so the profit = 6-3= 3\\n\\nso the total profit is 4+3 = 7;\\n\\nbut expected is 5 HOW COME ???????????? \\n\\n\\n"
                    },
                    {
                        "username": "FerhatKul",
                        "content": "It was really difficult until manage to solve by 6th submission, seeing actually how it is easy, brrr."
                    },
                    {
                        "username": "mehrak205",
                        "content": "This is my code but it\\'s not working for all the cases .\\n\\nint maxProfit(vector<int>& prices) {\\n        if(prices.size()==1)\\n        return 0;\\n        int bs=INT_MAX;\\n        int ind=-1;\\n        int maxprofit=0;\\n        for(int i=0;i<prices.size()-1;i++){\\n            if(prices[i]<bs){\\n                bs=prices[i];\\n                ind=i;\\n            }\\n        } \\n        for(int i=ind+1;i<prices.size();i++){\\n            if(prices[i]-bs>maxprofit)\\n            maxprofit=prices[i]-prices[ind];\\n        }\\n        return maxprofit;\\n    }"
                    },
                    {
                        "username": "bparanj",
                        "content": "Consider the following array: `[3,2,6,5,0,3]`. The lowest price is `0` (on the 5th day), but if you buy at this day you wouldn\\'t make a profit because there\\'s no higher price after it. The maximum profit you can make is by buying at the 2nd day where the price is `2`, and selling at the 3rd day where the price is `6`, even though `2` isn\\'t the lowest price in the array. \\n\\nThe example illustrates the issue with your code: you cannot simply buy at the lowest price because it doesn\\'t guarantee the maximum profit. \\n\\nThe correct approach is:\\n\\n```cpp\\nint maxProfit(vector<int>& prices) {\\n    int min_price = INT_MAX;\\n    int max_profit = 0;\\n    for (int i = 0; i < prices.size(); i++) {\\n        if (prices[i] < min_price) {\\n            min_price = prices[i];\\n        } else if (prices[i] - min_price > max_profit) {\\n            max_profit = prices[i] - min_price;\\n        }\\n    }\\n    return max_profit;\\n}\\n```\\n\\nThis code iterates over the `prices` array, keeping track of the smallest price seen so far, and updating the maximum profit whenever a larger profit is found.\\n"
                    },
                    {
                        "username": "FerhatKul",
                        "content": "It was really difficult until manage to solve by 6th submission, seeing actually how it is easy, brrr."
                    },
                    {
                        "username": "victorpichugov",
                        "content": "Additional explanation: profit in 2 example 0 because:\\n1) the minimum element is last\\n2) if the last element is the minimum, then you need to search for the minimum first to the minimum, i.e. arr[:len(arr) - 1] , but in the 2 example 7 > 6 > 4 > 3 > 1"
                    },
                    {
                        "username": "_vikash_kumar_",
                        "content": "EASY SOLUTION.......\\nclass Solution {\\n    public int maxProfit(int[] prices) {\\n        int n=prices.length;\\n        int min=Integer.MAX_VALUE;\\n        int diff=0;\\n        for(int i=0;i<n;i++)\\n        {\\n            min=Math.min(prices[i],min);\\n            diff=Math.max(diff,prices[i]-min);\\n        }\\n        return diff;\\n        \\n        \\n    }\\n}\\n"
                    },
                    {
                        "username": "bharti820",
                        "content": "step1: take starting index as lowprice and profit be 0 and initialize i=1\\nstep 2 while(i<:pricesSize)do step 3 to step 6\\nstep3 cost=prices[i]-lowprice\\nstep4 if(profit<cost)\\n     profit=cost\\nstep 5 if (lowprice>prices[i])\\nlowprice=prices[i]\\nstep 6 end of loop\\nstep 7 return profit\\n   "
                    },
                    {
                        "username": "cOde_Ranvir25",
                        "content": "Here is the Approach:-\n\nIterate through the prices array and keep track of the minimum price seen so far, and the maximum profit that can be obtained by selling the stock at the current price after buying it at the minimum price seen so far.\n\nAt each iteration, calculate the difference between the current price and the minimum price seen so far, which gives the profit that can be obtained by selling the stock at the current price after buying it at the minimum price seen so far. Update the maximum profit obtained so far by taking the maximum of the current profit and the maximum profit obtained in the previous iterations. Update the minimum price seen so far by taking the minimum of the current price and the minimum price seen in the previous iterations.\n\nBy the end of the iteration, the maximum profit obtained is returned as the output of the function."
                    },
                    {
                        "username": "cOde_Ranvir25",
                        "content": "Here is the code link for Help:-\\nhttps://leetcode.com/problems/best-time-to-buy-and-sell-stock/solutions/2941124/thanks-to-striver-for-an-great-explanation/?orderBy=most_votes"
                    }
                ]
            },
            {
                "id": 1813951,
                "content": [
                    {
                        "username": "kos2kos",
                        "content": "<div class=\"view-lines monaco-mouse-cursor-text\" role=\"presentation\" aria-hidden=\"true\" data-mprt=\"7\" style=\"position: absolute; font-family: Menlo, Monaco, &quot;Courier New&quot;, monospace; font-weight: normal; font-size: 15px; font-feature-settings: &quot;liga&quot; 0, &quot;calt&quot; 0; line-height: 23px; letter-spacing: 0px; width: 1364px; height: 747px;\"><div style=\"top:8px;height:23px;\" class=\"view-line\"><span><span class=\"mtk4\">class</span><span class=\"mtk1\">&nbsp;</span><span class=\"mtk10\">Solution</span><span class=\"mtk1\">&nbsp;{</span></span></div><div style=\"top:31px;height:23px;\" class=\"view-line\"><span><span class=\"mtk1\">&nbsp;&nbsp;&nbsp;&nbsp;</span><span class=\"mtk4\">public</span><span class=\"mtk1\">&nbsp;</span><span class=\"mtk10\">int</span><span class=\"mtk1\">&nbsp;</span><span class=\"mtk11\">maxProfit</span><span class=\"mtk1\">(</span><span class=\"mtk10\">int</span><span class=\"mtk1\">[]&nbsp;</span><span class=\"mtk14\">prices</span><span class=\"mtk1\">)&nbsp;{</span></span></div><div style=\"top:54px;height:23px;\" class=\"view-line\"><span><span class=\"mtk1\">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class=\"mtk3\">/*Go&nbsp;through&nbsp;list&nbsp;and&nbsp;add&nbsp;all&nbsp;values&nbsp;maintaing&nbsp;max</span><span class=\"mtk3\">imum&nbsp;value&nbsp;</span></span></div><div style=\"top:77px;height:23px;\" class=\"view-line\"><span><span class=\"mtk3\">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;iterate&nbsp;through&nbsp;the&nbsp;list&nbsp;and&nbsp;find&nbsp;differen</span><span class=\"mtk3\">ce&nbsp;between&nbsp;max&nbsp;and&nbsp;current&nbsp;val.&nbsp;set&nbsp;result&nbsp;to&nbsp;larg</span><span class=\"mtk3\">er&nbsp;numnber.</span></span></div><div style=\"top:100px;height:23px;\" class=\"view-line\"><span><span class=\"mtk3\">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;remove&nbsp;currnet&nbsp;number&nbsp;from&nbsp;maxHeap.&nbsp;</span></span></div><div style=\"top:123px;height:23px;\" class=\"view-line\"><span><span class=\"mtk3\">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return&nbsp;result</span></span></div><div style=\"top:146px;height:23px;\" class=\"view-line\"><span><span class=\"mtk3\">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;*/</span></span></div><div style=\"top:169px;height:23px;\" class=\"view-line\"><span><span class=\"mtk1\">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class=\"mtk10\">PriorityQueue</span><span class=\"mtk1\">&lt;</span><span class=\"mtk10\">Integer</span><span class=\"mtk1\">&gt;&nbsp;</span><span class=\"mtk14\">maxHeap</span><span class=\"mtk1\">&nbsp;=&nbsp;</span><span class=\"mtk13\">new</span><span class=\"mtk1\">&nbsp;</span><span class=\"mtk10\">PriorityQueue</span><span class=\"mtk1\">&lt;&gt;(</span><span class=\"mtk14\">Collections</span><span class=\"mtk1\">.</span><span class=\"mtk11\">reverseOrder</span><span class=\"mtk1\">());</span></span></div><div style=\"top:192px;height:23px;\" class=\"view-line\"><span><span></span></span></div><div style=\"top:215px;height:23px;\" class=\"view-line\"><span><span class=\"mtk1\">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class=\"mtk10\">int</span><span class=\"mtk1\">&nbsp;</span><span class=\"mtk14\">result</span><span class=\"mtk1\">&nbsp;=&nbsp;</span><span class=\"mtk7\">0</span><span class=\"mtk1\">;</span></span></div><div style=\"top:238px;height:23px;\" class=\"view-line\"><span><span class=\"mtk1\">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span></span></div><div style=\"top:261px;height:23px;\" class=\"view-line\"><span><span class=\"mtk1\">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class=\"mtk13\">for</span><span class=\"mtk1\">&nbsp;(</span><span class=\"mtk10\">int</span><span class=\"mtk1\">&nbsp;</span><span class=\"mtk14\">stock</span><span class=\"mtk13\">:</span><span class=\"mtk1\">&nbsp;prices){</span></span></div><div style=\"top:284px;height:23px;\" class=\"view-line\"><span><span class=\"mtk1\">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class=\"mtk14\">maxHeap</span><span class=\"mtk1\">.</span><span class=\"mtk11\">add</span><span class=\"mtk1\">(stock);</span></span></div><div style=\"top:307px;height:23px;\" class=\"view-line\"><span><span class=\"mtk1\">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}</span></span></div><div style=\"top:330px;height:23px;\" class=\"view-line\"><span><span></span></span></div><div style=\"top:353px;height:23px;\" class=\"view-line\"><span><span class=\"mtk1\">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class=\"mtk13\">for</span><span class=\"mtk1\">&nbsp;(</span><span class=\"mtk10\">int</span><span class=\"mtk1\">&nbsp;</span><span class=\"mtk14\">i</span><span class=\"mtk1\">&nbsp;=&nbsp;</span><span class=\"mtk7\">0</span><span class=\"mtk1\">;&nbsp;i&nbsp;&lt;&nbsp;</span><span class=\"mtk14\">prices</span><span class=\"mtk1\">.</span><span class=\"mtk14\">length</span><span class=\"mtk1\">;&nbsp;i++){</span></span></div><div style=\"top:376px;height:23px;\" class=\"view-line\"><span><span class=\"mtk1\">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class=\"mtk13\">if</span><span class=\"mtk1\">&nbsp;(prices[i]&nbsp;==&nbsp;</span><span class=\"mtk14\">maxHeap</span><span class=\"mtk1\">.</span><span class=\"mtk11\">peek</span><span class=\"mtk1\">())&nbsp;</span><span class=\"mtk14\">maxHeap</span><span class=\"mtk1\">.</span><span class=\"mtk11\">poll</span><span class=\"mtk1\">();</span></span></div><div style=\"top:399px;height:23px;\" class=\"view-line\"><span><span class=\"mtk1\">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;result&nbsp;=&nbsp;</span><span class=\"mtk14\">Math</span><span class=\"mtk1\">.</span><span class=\"mtk11\">max</span><span class=\"mtk1\">(result,&nbsp;</span><span class=\"mtk14\">maxHeap</span><span class=\"mtk1\">.</span><span class=\"mtk11\">peek</span><span class=\"mtk1\">()&nbsp;-&nbsp;prices[i]);</span></span></div><div style=\"top:422px;height:23px;\" class=\"view-line\"><span><span class=\"mtk1\">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}</span></span></div><div style=\"top:445px;height:23px;\" class=\"view-line\"><span><span></span></span></div><div style=\"top:468px;height:23px;\" class=\"view-line\"><span><span class=\"mtk1\">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class=\"mtk13\">return</span><span class=\"mtk1\">&nbsp;result;</span></span></div><div style=\"top:491px;height:23px;\" class=\"view-line\"><span><span class=\"mtk1\">&nbsp;&nbsp;&nbsp;&nbsp;}</span></span></div><div style=\"top:514px;height:23px;\" class=\"view-line\"><span><span class=\"mtk1\">}</span></span></div></div>\\n\\nThis was my first initial take where I had my current value and tried to find the max difference by comparing the FUTURE VALUES and that\\'s how I interpret the brute force solution by looking forward at all maximum differences. I was stuck for a few minutes on approach two, especially this code block if (prices[i] - minprice > maxprofit) because at first glance I saw that as knowing the future value and then knowing the overall min value, which didn\\'t make sense to me. Now I see the code working as the following, on my current day what was the smallest stock purchase price that proceeded me, find the difference between now and then. I now know I can buy on that day and sell today. A little counterintuitive and not how I think about in practical day to day terms. My first version runs O(n)log(n) with O(n) space. Hope this is helpful for those who need a good middle jumping step to get to the final solution."
                    },
                    {
                        "username": "sanshoys",
                        "content": "return Array.IndexOf(prices, prices.Max()) why is this not working?"
                    },
                    {
                        "username": "mdganapati",
                        "content": "Input: prices = [7,1,5,3,6,4]\\nOutput: 5\\nExplanation: Buy on day 2 (price = 1) and sell on day 5 (price = 6), profit = 6-1 = 5.\\nNote that buying on day 2 and selling on day 1 is not allowed because you must buy before you sell.\\n\\nNow here \\n\\nbuy at 2nd day (1) and sell at 3rd day(5) so profit = 5-1 = 4;\\n\\nnext buy at 4th day(3) and sell on 5th day(6) so the profit = 6-3= 3\\n\\nso the total profit is 4+3 = 7;\\n\\nbut expected is 5 HOW COME ???????????? \\n\\n\\n"
                    },
                    {
                        "username": "FerhatKul",
                        "content": "It was really difficult until manage to solve by 6th submission, seeing actually how it is easy, brrr."
                    },
                    {
                        "username": "mehrak205",
                        "content": "This is my code but it\\'s not working for all the cases .\\n\\nint maxProfit(vector<int>& prices) {\\n        if(prices.size()==1)\\n        return 0;\\n        int bs=INT_MAX;\\n        int ind=-1;\\n        int maxprofit=0;\\n        for(int i=0;i<prices.size()-1;i++){\\n            if(prices[i]<bs){\\n                bs=prices[i];\\n                ind=i;\\n            }\\n        } \\n        for(int i=ind+1;i<prices.size();i++){\\n            if(prices[i]-bs>maxprofit)\\n            maxprofit=prices[i]-prices[ind];\\n        }\\n        return maxprofit;\\n    }"
                    },
                    {
                        "username": "bparanj",
                        "content": "Consider the following array: `[3,2,6,5,0,3]`. The lowest price is `0` (on the 5th day), but if you buy at this day you wouldn\\'t make a profit because there\\'s no higher price after it. The maximum profit you can make is by buying at the 2nd day where the price is `2`, and selling at the 3rd day where the price is `6`, even though `2` isn\\'t the lowest price in the array. \\n\\nThe example illustrates the issue with your code: you cannot simply buy at the lowest price because it doesn\\'t guarantee the maximum profit. \\n\\nThe correct approach is:\\n\\n```cpp\\nint maxProfit(vector<int>& prices) {\\n    int min_price = INT_MAX;\\n    int max_profit = 0;\\n    for (int i = 0; i < prices.size(); i++) {\\n        if (prices[i] < min_price) {\\n            min_price = prices[i];\\n        } else if (prices[i] - min_price > max_profit) {\\n            max_profit = prices[i] - min_price;\\n        }\\n    }\\n    return max_profit;\\n}\\n```\\n\\nThis code iterates over the `prices` array, keeping track of the smallest price seen so far, and updating the maximum profit whenever a larger profit is found.\\n"
                    },
                    {
                        "username": "FerhatKul",
                        "content": "It was really difficult until manage to solve by 6th submission, seeing actually how it is easy, brrr."
                    },
                    {
                        "username": "victorpichugov",
                        "content": "Additional explanation: profit in 2 example 0 because:\\n1) the minimum element is last\\n2) if the last element is the minimum, then you need to search for the minimum first to the minimum, i.e. arr[:len(arr) - 1] , but in the 2 example 7 > 6 > 4 > 3 > 1"
                    },
                    {
                        "username": "_vikash_kumar_",
                        "content": "EASY SOLUTION.......\\nclass Solution {\\n    public int maxProfit(int[] prices) {\\n        int n=prices.length;\\n        int min=Integer.MAX_VALUE;\\n        int diff=0;\\n        for(int i=0;i<n;i++)\\n        {\\n            min=Math.min(prices[i],min);\\n            diff=Math.max(diff,prices[i]-min);\\n        }\\n        return diff;\\n        \\n        \\n    }\\n}\\n"
                    },
                    {
                        "username": "bharti820",
                        "content": "step1: take starting index as lowprice and profit be 0 and initialize i=1\\nstep 2 while(i<:pricesSize)do step 3 to step 6\\nstep3 cost=prices[i]-lowprice\\nstep4 if(profit<cost)\\n     profit=cost\\nstep 5 if (lowprice>prices[i])\\nlowprice=prices[i]\\nstep 6 end of loop\\nstep 7 return profit\\n   "
                    },
                    {
                        "username": "cOde_Ranvir25",
                        "content": "Here is the Approach:-\n\nIterate through the prices array and keep track of the minimum price seen so far, and the maximum profit that can be obtained by selling the stock at the current price after buying it at the minimum price seen so far.\n\nAt each iteration, calculate the difference between the current price and the minimum price seen so far, which gives the profit that can be obtained by selling the stock at the current price after buying it at the minimum price seen so far. Update the maximum profit obtained so far by taking the maximum of the current profit and the maximum profit obtained in the previous iterations. Update the minimum price seen so far by taking the minimum of the current price and the minimum price seen in the previous iterations.\n\nBy the end of the iteration, the maximum profit obtained is returned as the output of the function."
                    },
                    {
                        "username": "cOde_Ranvir25",
                        "content": "Here is the code link for Help:-\\nhttps://leetcode.com/problems/best-time-to-buy-and-sell-stock/solutions/2941124/thanks-to-striver-for-an-great-explanation/?orderBy=most_votes"
                    }
                ]
            },
            {
                "id": 1813896,
                "content": [
                    {
                        "username": "kos2kos",
                        "content": "<div class=\"view-lines monaco-mouse-cursor-text\" role=\"presentation\" aria-hidden=\"true\" data-mprt=\"7\" style=\"position: absolute; font-family: Menlo, Monaco, &quot;Courier New&quot;, monospace; font-weight: normal; font-size: 15px; font-feature-settings: &quot;liga&quot; 0, &quot;calt&quot; 0; line-height: 23px; letter-spacing: 0px; width: 1364px; height: 747px;\"><div style=\"top:8px;height:23px;\" class=\"view-line\"><span><span class=\"mtk4\">class</span><span class=\"mtk1\">&nbsp;</span><span class=\"mtk10\">Solution</span><span class=\"mtk1\">&nbsp;{</span></span></div><div style=\"top:31px;height:23px;\" class=\"view-line\"><span><span class=\"mtk1\">&nbsp;&nbsp;&nbsp;&nbsp;</span><span class=\"mtk4\">public</span><span class=\"mtk1\">&nbsp;</span><span class=\"mtk10\">int</span><span class=\"mtk1\">&nbsp;</span><span class=\"mtk11\">maxProfit</span><span class=\"mtk1\">(</span><span class=\"mtk10\">int</span><span class=\"mtk1\">[]&nbsp;</span><span class=\"mtk14\">prices</span><span class=\"mtk1\">)&nbsp;{</span></span></div><div style=\"top:54px;height:23px;\" class=\"view-line\"><span><span class=\"mtk1\">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class=\"mtk3\">/*Go&nbsp;through&nbsp;list&nbsp;and&nbsp;add&nbsp;all&nbsp;values&nbsp;maintaing&nbsp;max</span><span class=\"mtk3\">imum&nbsp;value&nbsp;</span></span></div><div style=\"top:77px;height:23px;\" class=\"view-line\"><span><span class=\"mtk3\">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;iterate&nbsp;through&nbsp;the&nbsp;list&nbsp;and&nbsp;find&nbsp;differen</span><span class=\"mtk3\">ce&nbsp;between&nbsp;max&nbsp;and&nbsp;current&nbsp;val.&nbsp;set&nbsp;result&nbsp;to&nbsp;larg</span><span class=\"mtk3\">er&nbsp;numnber.</span></span></div><div style=\"top:100px;height:23px;\" class=\"view-line\"><span><span class=\"mtk3\">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;remove&nbsp;currnet&nbsp;number&nbsp;from&nbsp;maxHeap.&nbsp;</span></span></div><div style=\"top:123px;height:23px;\" class=\"view-line\"><span><span class=\"mtk3\">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return&nbsp;result</span></span></div><div style=\"top:146px;height:23px;\" class=\"view-line\"><span><span class=\"mtk3\">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;*/</span></span></div><div style=\"top:169px;height:23px;\" class=\"view-line\"><span><span class=\"mtk1\">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class=\"mtk10\">PriorityQueue</span><span class=\"mtk1\">&lt;</span><span class=\"mtk10\">Integer</span><span class=\"mtk1\">&gt;&nbsp;</span><span class=\"mtk14\">maxHeap</span><span class=\"mtk1\">&nbsp;=&nbsp;</span><span class=\"mtk13\">new</span><span class=\"mtk1\">&nbsp;</span><span class=\"mtk10\">PriorityQueue</span><span class=\"mtk1\">&lt;&gt;(</span><span class=\"mtk14\">Collections</span><span class=\"mtk1\">.</span><span class=\"mtk11\">reverseOrder</span><span class=\"mtk1\">());</span></span></div><div style=\"top:192px;height:23px;\" class=\"view-line\"><span><span></span></span></div><div style=\"top:215px;height:23px;\" class=\"view-line\"><span><span class=\"mtk1\">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class=\"mtk10\">int</span><span class=\"mtk1\">&nbsp;</span><span class=\"mtk14\">result</span><span class=\"mtk1\">&nbsp;=&nbsp;</span><span class=\"mtk7\">0</span><span class=\"mtk1\">;</span></span></div><div style=\"top:238px;height:23px;\" class=\"view-line\"><span><span class=\"mtk1\">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span></span></div><div style=\"top:261px;height:23px;\" class=\"view-line\"><span><span class=\"mtk1\">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class=\"mtk13\">for</span><span class=\"mtk1\">&nbsp;(</span><span class=\"mtk10\">int</span><span class=\"mtk1\">&nbsp;</span><span class=\"mtk14\">stock</span><span class=\"mtk13\">:</span><span class=\"mtk1\">&nbsp;prices){</span></span></div><div style=\"top:284px;height:23px;\" class=\"view-line\"><span><span class=\"mtk1\">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class=\"mtk14\">maxHeap</span><span class=\"mtk1\">.</span><span class=\"mtk11\">add</span><span class=\"mtk1\">(stock);</span></span></div><div style=\"top:307px;height:23px;\" class=\"view-line\"><span><span class=\"mtk1\">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}</span></span></div><div style=\"top:330px;height:23px;\" class=\"view-line\"><span><span></span></span></div><div style=\"top:353px;height:23px;\" class=\"view-line\"><span><span class=\"mtk1\">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class=\"mtk13\">for</span><span class=\"mtk1\">&nbsp;(</span><span class=\"mtk10\">int</span><span class=\"mtk1\">&nbsp;</span><span class=\"mtk14\">i</span><span class=\"mtk1\">&nbsp;=&nbsp;</span><span class=\"mtk7\">0</span><span class=\"mtk1\">;&nbsp;i&nbsp;&lt;&nbsp;</span><span class=\"mtk14\">prices</span><span class=\"mtk1\">.</span><span class=\"mtk14\">length</span><span class=\"mtk1\">;&nbsp;i++){</span></span></div><div style=\"top:376px;height:23px;\" class=\"view-line\"><span><span class=\"mtk1\">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class=\"mtk13\">if</span><span class=\"mtk1\">&nbsp;(prices[i]&nbsp;==&nbsp;</span><span class=\"mtk14\">maxHeap</span><span class=\"mtk1\">.</span><span class=\"mtk11\">peek</span><span class=\"mtk1\">())&nbsp;</span><span class=\"mtk14\">maxHeap</span><span class=\"mtk1\">.</span><span class=\"mtk11\">poll</span><span class=\"mtk1\">();</span></span></div><div style=\"top:399px;height:23px;\" class=\"view-line\"><span><span class=\"mtk1\">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;result&nbsp;=&nbsp;</span><span class=\"mtk14\">Math</span><span class=\"mtk1\">.</span><span class=\"mtk11\">max</span><span class=\"mtk1\">(result,&nbsp;</span><span class=\"mtk14\">maxHeap</span><span class=\"mtk1\">.</span><span class=\"mtk11\">peek</span><span class=\"mtk1\">()&nbsp;-&nbsp;prices[i]);</span></span></div><div style=\"top:422px;height:23px;\" class=\"view-line\"><span><span class=\"mtk1\">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}</span></span></div><div style=\"top:445px;height:23px;\" class=\"view-line\"><span><span></span></span></div><div style=\"top:468px;height:23px;\" class=\"view-line\"><span><span class=\"mtk1\">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class=\"mtk13\">return</span><span class=\"mtk1\">&nbsp;result;</span></span></div><div style=\"top:491px;height:23px;\" class=\"view-line\"><span><span class=\"mtk1\">&nbsp;&nbsp;&nbsp;&nbsp;}</span></span></div><div style=\"top:514px;height:23px;\" class=\"view-line\"><span><span class=\"mtk1\">}</span></span></div></div>\\n\\nThis was my first initial take where I had my current value and tried to find the max difference by comparing the FUTURE VALUES and that\\'s how I interpret the brute force solution by looking forward at all maximum differences. I was stuck for a few minutes on approach two, especially this code block if (prices[i] - minprice > maxprofit) because at first glance I saw that as knowing the future value and then knowing the overall min value, which didn\\'t make sense to me. Now I see the code working as the following, on my current day what was the smallest stock purchase price that proceeded me, find the difference between now and then. I now know I can buy on that day and sell today. A little counterintuitive and not how I think about in practical day to day terms. My first version runs O(n)log(n) with O(n) space. Hope this is helpful for those who need a good middle jumping step to get to the final solution."
                    },
                    {
                        "username": "sanshoys",
                        "content": "return Array.IndexOf(prices, prices.Max()) why is this not working?"
                    },
                    {
                        "username": "mdganapati",
                        "content": "Input: prices = [7,1,5,3,6,4]\\nOutput: 5\\nExplanation: Buy on day 2 (price = 1) and sell on day 5 (price = 6), profit = 6-1 = 5.\\nNote that buying on day 2 and selling on day 1 is not allowed because you must buy before you sell.\\n\\nNow here \\n\\nbuy at 2nd day (1) and sell at 3rd day(5) so profit = 5-1 = 4;\\n\\nnext buy at 4th day(3) and sell on 5th day(6) so the profit = 6-3= 3\\n\\nso the total profit is 4+3 = 7;\\n\\nbut expected is 5 HOW COME ???????????? \\n\\n\\n"
                    },
                    {
                        "username": "FerhatKul",
                        "content": "It was really difficult until manage to solve by 6th submission, seeing actually how it is easy, brrr."
                    },
                    {
                        "username": "mehrak205",
                        "content": "This is my code but it\\'s not working for all the cases .\\n\\nint maxProfit(vector<int>& prices) {\\n        if(prices.size()==1)\\n        return 0;\\n        int bs=INT_MAX;\\n        int ind=-1;\\n        int maxprofit=0;\\n        for(int i=0;i<prices.size()-1;i++){\\n            if(prices[i]<bs){\\n                bs=prices[i];\\n                ind=i;\\n            }\\n        } \\n        for(int i=ind+1;i<prices.size();i++){\\n            if(prices[i]-bs>maxprofit)\\n            maxprofit=prices[i]-prices[ind];\\n        }\\n        return maxprofit;\\n    }"
                    },
                    {
                        "username": "bparanj",
                        "content": "Consider the following array: `[3,2,6,5,0,3]`. The lowest price is `0` (on the 5th day), but if you buy at this day you wouldn\\'t make a profit because there\\'s no higher price after it. The maximum profit you can make is by buying at the 2nd day where the price is `2`, and selling at the 3rd day where the price is `6`, even though `2` isn\\'t the lowest price in the array. \\n\\nThe example illustrates the issue with your code: you cannot simply buy at the lowest price because it doesn\\'t guarantee the maximum profit. \\n\\nThe correct approach is:\\n\\n```cpp\\nint maxProfit(vector<int>& prices) {\\n    int min_price = INT_MAX;\\n    int max_profit = 0;\\n    for (int i = 0; i < prices.size(); i++) {\\n        if (prices[i] < min_price) {\\n            min_price = prices[i];\\n        } else if (prices[i] - min_price > max_profit) {\\n            max_profit = prices[i] - min_price;\\n        }\\n    }\\n    return max_profit;\\n}\\n```\\n\\nThis code iterates over the `prices` array, keeping track of the smallest price seen so far, and updating the maximum profit whenever a larger profit is found.\\n"
                    },
                    {
                        "username": "FerhatKul",
                        "content": "It was really difficult until manage to solve by 6th submission, seeing actually how it is easy, brrr."
                    },
                    {
                        "username": "victorpichugov",
                        "content": "Additional explanation: profit in 2 example 0 because:\\n1) the minimum element is last\\n2) if the last element is the minimum, then you need to search for the minimum first to the minimum, i.e. arr[:len(arr) - 1] , but in the 2 example 7 > 6 > 4 > 3 > 1"
                    },
                    {
                        "username": "_vikash_kumar_",
                        "content": "EASY SOLUTION.......\\nclass Solution {\\n    public int maxProfit(int[] prices) {\\n        int n=prices.length;\\n        int min=Integer.MAX_VALUE;\\n        int diff=0;\\n        for(int i=0;i<n;i++)\\n        {\\n            min=Math.min(prices[i],min);\\n            diff=Math.max(diff,prices[i]-min);\\n        }\\n        return diff;\\n        \\n        \\n    }\\n}\\n"
                    },
                    {
                        "username": "bharti820",
                        "content": "step1: take starting index as lowprice and profit be 0 and initialize i=1\\nstep 2 while(i<:pricesSize)do step 3 to step 6\\nstep3 cost=prices[i]-lowprice\\nstep4 if(profit<cost)\\n     profit=cost\\nstep 5 if (lowprice>prices[i])\\nlowprice=prices[i]\\nstep 6 end of loop\\nstep 7 return profit\\n   "
                    },
                    {
                        "username": "cOde_Ranvir25",
                        "content": "Here is the Approach:-\n\nIterate through the prices array and keep track of the minimum price seen so far, and the maximum profit that can be obtained by selling the stock at the current price after buying it at the minimum price seen so far.\n\nAt each iteration, calculate the difference between the current price and the minimum price seen so far, which gives the profit that can be obtained by selling the stock at the current price after buying it at the minimum price seen so far. Update the maximum profit obtained so far by taking the maximum of the current profit and the maximum profit obtained in the previous iterations. Update the minimum price seen so far by taking the minimum of the current price and the minimum price seen in the previous iterations.\n\nBy the end of the iteration, the maximum profit obtained is returned as the output of the function."
                    },
                    {
                        "username": "cOde_Ranvir25",
                        "content": "Here is the code link for Help:-\\nhttps://leetcode.com/problems/best-time-to-buy-and-sell-stock/solutions/2941124/thanks-to-striver-for-an-great-explanation/?orderBy=most_votes"
                    }
                ]
            },
            {
                "id": 1813788,
                "content": [
                    {
                        "username": "kos2kos",
                        "content": "<div class=\"view-lines monaco-mouse-cursor-text\" role=\"presentation\" aria-hidden=\"true\" data-mprt=\"7\" style=\"position: absolute; font-family: Menlo, Monaco, &quot;Courier New&quot;, monospace; font-weight: normal; font-size: 15px; font-feature-settings: &quot;liga&quot; 0, &quot;calt&quot; 0; line-height: 23px; letter-spacing: 0px; width: 1364px; height: 747px;\"><div style=\"top:8px;height:23px;\" class=\"view-line\"><span><span class=\"mtk4\">class</span><span class=\"mtk1\">&nbsp;</span><span class=\"mtk10\">Solution</span><span class=\"mtk1\">&nbsp;{</span></span></div><div style=\"top:31px;height:23px;\" class=\"view-line\"><span><span class=\"mtk1\">&nbsp;&nbsp;&nbsp;&nbsp;</span><span class=\"mtk4\">public</span><span class=\"mtk1\">&nbsp;</span><span class=\"mtk10\">int</span><span class=\"mtk1\">&nbsp;</span><span class=\"mtk11\">maxProfit</span><span class=\"mtk1\">(</span><span class=\"mtk10\">int</span><span class=\"mtk1\">[]&nbsp;</span><span class=\"mtk14\">prices</span><span class=\"mtk1\">)&nbsp;{</span></span></div><div style=\"top:54px;height:23px;\" class=\"view-line\"><span><span class=\"mtk1\">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class=\"mtk3\">/*Go&nbsp;through&nbsp;list&nbsp;and&nbsp;add&nbsp;all&nbsp;values&nbsp;maintaing&nbsp;max</span><span class=\"mtk3\">imum&nbsp;value&nbsp;</span></span></div><div style=\"top:77px;height:23px;\" class=\"view-line\"><span><span class=\"mtk3\">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;iterate&nbsp;through&nbsp;the&nbsp;list&nbsp;and&nbsp;find&nbsp;differen</span><span class=\"mtk3\">ce&nbsp;between&nbsp;max&nbsp;and&nbsp;current&nbsp;val.&nbsp;set&nbsp;result&nbsp;to&nbsp;larg</span><span class=\"mtk3\">er&nbsp;numnber.</span></span></div><div style=\"top:100px;height:23px;\" class=\"view-line\"><span><span class=\"mtk3\">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;remove&nbsp;currnet&nbsp;number&nbsp;from&nbsp;maxHeap.&nbsp;</span></span></div><div style=\"top:123px;height:23px;\" class=\"view-line\"><span><span class=\"mtk3\">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return&nbsp;result</span></span></div><div style=\"top:146px;height:23px;\" class=\"view-line\"><span><span class=\"mtk3\">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;*/</span></span></div><div style=\"top:169px;height:23px;\" class=\"view-line\"><span><span class=\"mtk1\">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class=\"mtk10\">PriorityQueue</span><span class=\"mtk1\">&lt;</span><span class=\"mtk10\">Integer</span><span class=\"mtk1\">&gt;&nbsp;</span><span class=\"mtk14\">maxHeap</span><span class=\"mtk1\">&nbsp;=&nbsp;</span><span class=\"mtk13\">new</span><span class=\"mtk1\">&nbsp;</span><span class=\"mtk10\">PriorityQueue</span><span class=\"mtk1\">&lt;&gt;(</span><span class=\"mtk14\">Collections</span><span class=\"mtk1\">.</span><span class=\"mtk11\">reverseOrder</span><span class=\"mtk1\">());</span></span></div><div style=\"top:192px;height:23px;\" class=\"view-line\"><span><span></span></span></div><div style=\"top:215px;height:23px;\" class=\"view-line\"><span><span class=\"mtk1\">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class=\"mtk10\">int</span><span class=\"mtk1\">&nbsp;</span><span class=\"mtk14\">result</span><span class=\"mtk1\">&nbsp;=&nbsp;</span><span class=\"mtk7\">0</span><span class=\"mtk1\">;</span></span></div><div style=\"top:238px;height:23px;\" class=\"view-line\"><span><span class=\"mtk1\">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span></span></div><div style=\"top:261px;height:23px;\" class=\"view-line\"><span><span class=\"mtk1\">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class=\"mtk13\">for</span><span class=\"mtk1\">&nbsp;(</span><span class=\"mtk10\">int</span><span class=\"mtk1\">&nbsp;</span><span class=\"mtk14\">stock</span><span class=\"mtk13\">:</span><span class=\"mtk1\">&nbsp;prices){</span></span></div><div style=\"top:284px;height:23px;\" class=\"view-line\"><span><span class=\"mtk1\">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class=\"mtk14\">maxHeap</span><span class=\"mtk1\">.</span><span class=\"mtk11\">add</span><span class=\"mtk1\">(stock);</span></span></div><div style=\"top:307px;height:23px;\" class=\"view-line\"><span><span class=\"mtk1\">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}</span></span></div><div style=\"top:330px;height:23px;\" class=\"view-line\"><span><span></span></span></div><div style=\"top:353px;height:23px;\" class=\"view-line\"><span><span class=\"mtk1\">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class=\"mtk13\">for</span><span class=\"mtk1\">&nbsp;(</span><span class=\"mtk10\">int</span><span class=\"mtk1\">&nbsp;</span><span class=\"mtk14\">i</span><span class=\"mtk1\">&nbsp;=&nbsp;</span><span class=\"mtk7\">0</span><span class=\"mtk1\">;&nbsp;i&nbsp;&lt;&nbsp;</span><span class=\"mtk14\">prices</span><span class=\"mtk1\">.</span><span class=\"mtk14\">length</span><span class=\"mtk1\">;&nbsp;i++){</span></span></div><div style=\"top:376px;height:23px;\" class=\"view-line\"><span><span class=\"mtk1\">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class=\"mtk13\">if</span><span class=\"mtk1\">&nbsp;(prices[i]&nbsp;==&nbsp;</span><span class=\"mtk14\">maxHeap</span><span class=\"mtk1\">.</span><span class=\"mtk11\">peek</span><span class=\"mtk1\">())&nbsp;</span><span class=\"mtk14\">maxHeap</span><span class=\"mtk1\">.</span><span class=\"mtk11\">poll</span><span class=\"mtk1\">();</span></span></div><div style=\"top:399px;height:23px;\" class=\"view-line\"><span><span class=\"mtk1\">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;result&nbsp;=&nbsp;</span><span class=\"mtk14\">Math</span><span class=\"mtk1\">.</span><span class=\"mtk11\">max</span><span class=\"mtk1\">(result,&nbsp;</span><span class=\"mtk14\">maxHeap</span><span class=\"mtk1\">.</span><span class=\"mtk11\">peek</span><span class=\"mtk1\">()&nbsp;-&nbsp;prices[i]);</span></span></div><div style=\"top:422px;height:23px;\" class=\"view-line\"><span><span class=\"mtk1\">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}</span></span></div><div style=\"top:445px;height:23px;\" class=\"view-line\"><span><span></span></span></div><div style=\"top:468px;height:23px;\" class=\"view-line\"><span><span class=\"mtk1\">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class=\"mtk13\">return</span><span class=\"mtk1\">&nbsp;result;</span></span></div><div style=\"top:491px;height:23px;\" class=\"view-line\"><span><span class=\"mtk1\">&nbsp;&nbsp;&nbsp;&nbsp;}</span></span></div><div style=\"top:514px;height:23px;\" class=\"view-line\"><span><span class=\"mtk1\">}</span></span></div></div>\\n\\nThis was my first initial take where I had my current value and tried to find the max difference by comparing the FUTURE VALUES and that\\'s how I interpret the brute force solution by looking forward at all maximum differences. I was stuck for a few minutes on approach two, especially this code block if (prices[i] - minprice > maxprofit) because at first glance I saw that as knowing the future value and then knowing the overall min value, which didn\\'t make sense to me. Now I see the code working as the following, on my current day what was the smallest stock purchase price that proceeded me, find the difference between now and then. I now know I can buy on that day and sell today. A little counterintuitive and not how I think about in practical day to day terms. My first version runs O(n)log(n) with O(n) space. Hope this is helpful for those who need a good middle jumping step to get to the final solution."
                    },
                    {
                        "username": "sanshoys",
                        "content": "return Array.IndexOf(prices, prices.Max()) why is this not working?"
                    },
                    {
                        "username": "mdganapati",
                        "content": "Input: prices = [7,1,5,3,6,4]\\nOutput: 5\\nExplanation: Buy on day 2 (price = 1) and sell on day 5 (price = 6), profit = 6-1 = 5.\\nNote that buying on day 2 and selling on day 1 is not allowed because you must buy before you sell.\\n\\nNow here \\n\\nbuy at 2nd day (1) and sell at 3rd day(5) so profit = 5-1 = 4;\\n\\nnext buy at 4th day(3) and sell on 5th day(6) so the profit = 6-3= 3\\n\\nso the total profit is 4+3 = 7;\\n\\nbut expected is 5 HOW COME ???????????? \\n\\n\\n"
                    },
                    {
                        "username": "FerhatKul",
                        "content": "It was really difficult until manage to solve by 6th submission, seeing actually how it is easy, brrr."
                    },
                    {
                        "username": "mehrak205",
                        "content": "This is my code but it\\'s not working for all the cases .\\n\\nint maxProfit(vector<int>& prices) {\\n        if(prices.size()==1)\\n        return 0;\\n        int bs=INT_MAX;\\n        int ind=-1;\\n        int maxprofit=0;\\n        for(int i=0;i<prices.size()-1;i++){\\n            if(prices[i]<bs){\\n                bs=prices[i];\\n                ind=i;\\n            }\\n        } \\n        for(int i=ind+1;i<prices.size();i++){\\n            if(prices[i]-bs>maxprofit)\\n            maxprofit=prices[i]-prices[ind];\\n        }\\n        return maxprofit;\\n    }"
                    },
                    {
                        "username": "bparanj",
                        "content": "Consider the following array: `[3,2,6,5,0,3]`. The lowest price is `0` (on the 5th day), but if you buy at this day you wouldn\\'t make a profit because there\\'s no higher price after it. The maximum profit you can make is by buying at the 2nd day where the price is `2`, and selling at the 3rd day where the price is `6`, even though `2` isn\\'t the lowest price in the array. \\n\\nThe example illustrates the issue with your code: you cannot simply buy at the lowest price because it doesn\\'t guarantee the maximum profit. \\n\\nThe correct approach is:\\n\\n```cpp\\nint maxProfit(vector<int>& prices) {\\n    int min_price = INT_MAX;\\n    int max_profit = 0;\\n    for (int i = 0; i < prices.size(); i++) {\\n        if (prices[i] < min_price) {\\n            min_price = prices[i];\\n        } else if (prices[i] - min_price > max_profit) {\\n            max_profit = prices[i] - min_price;\\n        }\\n    }\\n    return max_profit;\\n}\\n```\\n\\nThis code iterates over the `prices` array, keeping track of the smallest price seen so far, and updating the maximum profit whenever a larger profit is found.\\n"
                    },
                    {
                        "username": "FerhatKul",
                        "content": "It was really difficult until manage to solve by 6th submission, seeing actually how it is easy, brrr."
                    },
                    {
                        "username": "victorpichugov",
                        "content": "Additional explanation: profit in 2 example 0 because:\\n1) the minimum element is last\\n2) if the last element is the minimum, then you need to search for the minimum first to the minimum, i.e. arr[:len(arr) - 1] , but in the 2 example 7 > 6 > 4 > 3 > 1"
                    },
                    {
                        "username": "_vikash_kumar_",
                        "content": "EASY SOLUTION.......\\nclass Solution {\\n    public int maxProfit(int[] prices) {\\n        int n=prices.length;\\n        int min=Integer.MAX_VALUE;\\n        int diff=0;\\n        for(int i=0;i<n;i++)\\n        {\\n            min=Math.min(prices[i],min);\\n            diff=Math.max(diff,prices[i]-min);\\n        }\\n        return diff;\\n        \\n        \\n    }\\n}\\n"
                    },
                    {
                        "username": "bharti820",
                        "content": "step1: take starting index as lowprice and profit be 0 and initialize i=1\\nstep 2 while(i<:pricesSize)do step 3 to step 6\\nstep3 cost=prices[i]-lowprice\\nstep4 if(profit<cost)\\n     profit=cost\\nstep 5 if (lowprice>prices[i])\\nlowprice=prices[i]\\nstep 6 end of loop\\nstep 7 return profit\\n   "
                    },
                    {
                        "username": "cOde_Ranvir25",
                        "content": "Here is the Approach:-\n\nIterate through the prices array and keep track of the minimum price seen so far, and the maximum profit that can be obtained by selling the stock at the current price after buying it at the minimum price seen so far.\n\nAt each iteration, calculate the difference between the current price and the minimum price seen so far, which gives the profit that can be obtained by selling the stock at the current price after buying it at the minimum price seen so far. Update the maximum profit obtained so far by taking the maximum of the current profit and the maximum profit obtained in the previous iterations. Update the minimum price seen so far by taking the minimum of the current price and the minimum price seen in the previous iterations.\n\nBy the end of the iteration, the maximum profit obtained is returned as the output of the function."
                    },
                    {
                        "username": "cOde_Ranvir25",
                        "content": "Here is the code link for Help:-\\nhttps://leetcode.com/problems/best-time-to-buy-and-sell-stock/solutions/2941124/thanks-to-striver-for-an-great-explanation/?orderBy=most_votes"
                    }
                ]
            },
            {
                "id": 1813656,
                "content": [
                    {
                        "username": "justsolveitlmao",
                        "content": "Ez weekend I guess"
                    },
                    {
                        "username": "jga111",
                        "content": "You can do this in one pass. Keep track of your best time to buy stock. Keep track of your profits. "
                    },
                    {
                        "username": "tanmoysantra67",
                        "content": "class Solution:\\n    def maxProfit(self, prices: List[int]) -> int:\\n        if not prices:\\n            return 0\\n        \\n        min_price = prices[0]\\n        max_profit = 0\\n        \\n        for price in prices:\\n            if price < min_price:\\n                min_price = price\\n            elif price - min_price > max_profit:\\n                max_profit = price - min_price\\n        \\n        return max_profit\\n"
                    },
                    {
                        "username": "cagils",
                        "content": "A quick tip to get a single line solution in js using sliding windows approach:\\n```js\\nwhile (++r < length) if (prices[r] <= prices[l]) l = r; else *CALCULATE_MAX*\\n```"
                    },
                    {
                        "username": "david144",
                        "content": "Just think If I sell the stock in day n, then the max profit will equals today\\'s price minus minimum price from day 0 to day n."
                    },
                    {
                        "username": "parsa-sedigh",
                        "content": "What\\'s wrong with my approach(besides time complexity)?\\n ```javascript\\n    const tradeResults = [];\\n\\n    for (let i = 0; i<prices.length; i++) {\\n        let start = i;\\n        let end = prices.length - 1;\\n\\n        while (start <= end) {\\n            tradeResults.push(prices[end] - prices[start]);\\n            start++;\\n            end--;\\n        }\\n    }\\n\\n    return tradeResults.sort((a, b) => b - a)[0];\\n```"
                    },
                    {
                        "username": "parsa-sedigh",
                        "content": "The problem is I don\\'t consider all the possibilities together because of incrementing and decrementing the start and end simultaneously."
                    },
                    {
                        "username": "Dikshika_12",
                        "content": "for this question you must be familiar with prefix and suffix array \\n\\n in prefix array you will be storing the element minimum till that index for \\ne.g the array is [7,5,8,1,3,4]\\nso your prefix array will look like prefix_array[7,5,5,1,1,1] i.e, minimum element till first index is 7 so we sotred it in the prefix_array then moving on minimum element till 2nd index is 5 and so on we will make the array.\\n\\n in suffix array you will be storing the element maximum till that index for \\ne.g the array is [7,5,8,1,3,4]\\nso your suffix  array will look like suffix_array [8,8,8,4,4,4] i.e, maximum element from last index is 4 so we stored it in the suffix_array then moving on maximum element till 2nd last index is 4 again because 3<4  so on we will make the array.\\nonce you make the array reverse it.\\n\\nnow itreate over the array and store the ans = suffix_array[i]-prefix_array[i],\\nmaxi  = max(maxi,ans);\\n"
                    },
                    {
                        "username": "bparanj",
                        "content": "Your approach is correct and a great demonstration of using prefix and suffix arrays. However, it seems a bit over-complicated for this particular problem. Essentially, you\\'re trying to find the maximum difference between a pair of numbers in the array, where the smaller number comes before the larger one.\\n\\nAs a result, while your solution will certainly work, it also requires extra space to store the prefix and suffix arrays. Additionally, it involves a bit more computation than necessary since it computes the minimum value up to each index and the maximum value after each index, even though this isn\\'t strictly necessary to find the maximum profit.\\n\\nHere\\'s a simpler solution that accomplishes the same thing in O(n) time complexity and O(1) space complexity:\\n\\n```cpp\\nint maxProfit(vector<int>& prices) {\\n    int min_price = INT_MAX;\\n    int max_profit = 0;\\n    \\n    for (int price : prices) {\\n        if (price < min_price) {\\n            min_price = price;\\n        } else if (price - min_price > max_profit) {\\n            max_profit = price - min_price;\\n        }\\n    }\\n    \\n    return max_profit;\\n}\\n```\\n\\nThis solution works by maintaining the minimum price seen so far and the maximum profit that can be made from selling at the current price. By updating these values as it iterates through the array, it ensures that it only considers selling prices that come after the minimum price it\\'s seen."
                    },
                    {
                        "username": "williamhergott",
                        "content": "Hey, when submitting my code I recieve \"time limit exceeded\" and the code is not approved, but I only used one for loop? Why is this the case? Thanks. (python 3)\\n\\n\\nclass Solution:\\n    def maxProfit(self, prices: List[int]) -> int:\\n        \\n        max_prof = 0\\n        \\n        for i in range(len(prices)):\\n            max_prof = max(max(prices[i:]) - prices[i], max_prof)\\n        \\n        return max_prof"
                    },
                    {
                        "username": "Vectorido",
                        "content": "I suppose, when you use max - this is some kind of loop, but built-in and not in python language. Anyway, 2 max\\'s have big complexity. I don\\'t know too how to manage with that. This is definitely not an EASY problem. "
                    },
                    {
                        "username": "voronokKita",
                        "content": "Raise the difficulty from easy to medium.\\nChange the Dynamic Programming tag to the Sliding Window."
                    },
                    {
                        "username": "_IshikaJain",
                        "content": "How to deal with Time Limit Exceeded issue ?"
                    }
                ]
            },
            {
                "id": 1813640,
                "content": [
                    {
                        "username": "justsolveitlmao",
                        "content": "Ez weekend I guess"
                    },
                    {
                        "username": "jga111",
                        "content": "You can do this in one pass. Keep track of your best time to buy stock. Keep track of your profits. "
                    },
                    {
                        "username": "tanmoysantra67",
                        "content": "class Solution:\\n    def maxProfit(self, prices: List[int]) -> int:\\n        if not prices:\\n            return 0\\n        \\n        min_price = prices[0]\\n        max_profit = 0\\n        \\n        for price in prices:\\n            if price < min_price:\\n                min_price = price\\n            elif price - min_price > max_profit:\\n                max_profit = price - min_price\\n        \\n        return max_profit\\n"
                    },
                    {
                        "username": "cagils",
                        "content": "A quick tip to get a single line solution in js using sliding windows approach:\\n```js\\nwhile (++r < length) if (prices[r] <= prices[l]) l = r; else *CALCULATE_MAX*\\n```"
                    },
                    {
                        "username": "david144",
                        "content": "Just think If I sell the stock in day n, then the max profit will equals today\\'s price minus minimum price from day 0 to day n."
                    },
                    {
                        "username": "parsa-sedigh",
                        "content": "What\\'s wrong with my approach(besides time complexity)?\\n ```javascript\\n    const tradeResults = [];\\n\\n    for (let i = 0; i<prices.length; i++) {\\n        let start = i;\\n        let end = prices.length - 1;\\n\\n        while (start <= end) {\\n            tradeResults.push(prices[end] - prices[start]);\\n            start++;\\n            end--;\\n        }\\n    }\\n\\n    return tradeResults.sort((a, b) => b - a)[0];\\n```"
                    },
                    {
                        "username": "parsa-sedigh",
                        "content": "The problem is I don\\'t consider all the possibilities together because of incrementing and decrementing the start and end simultaneously."
                    },
                    {
                        "username": "Dikshika_12",
                        "content": "for this question you must be familiar with prefix and suffix array \\n\\n in prefix array you will be storing the element minimum till that index for \\ne.g the array is [7,5,8,1,3,4]\\nso your prefix array will look like prefix_array[7,5,5,1,1,1] i.e, minimum element till first index is 7 so we sotred it in the prefix_array then moving on minimum element till 2nd index is 5 and so on we will make the array.\\n\\n in suffix array you will be storing the element maximum till that index for \\ne.g the array is [7,5,8,1,3,4]\\nso your suffix  array will look like suffix_array [8,8,8,4,4,4] i.e, maximum element from last index is 4 so we stored it in the suffix_array then moving on maximum element till 2nd last index is 4 again because 3<4  so on we will make the array.\\nonce you make the array reverse it.\\n\\nnow itreate over the array and store the ans = suffix_array[i]-prefix_array[i],\\nmaxi  = max(maxi,ans);\\n"
                    },
                    {
                        "username": "bparanj",
                        "content": "Your approach is correct and a great demonstration of using prefix and suffix arrays. However, it seems a bit over-complicated for this particular problem. Essentially, you\\'re trying to find the maximum difference between a pair of numbers in the array, where the smaller number comes before the larger one.\\n\\nAs a result, while your solution will certainly work, it also requires extra space to store the prefix and suffix arrays. Additionally, it involves a bit more computation than necessary since it computes the minimum value up to each index and the maximum value after each index, even though this isn\\'t strictly necessary to find the maximum profit.\\n\\nHere\\'s a simpler solution that accomplishes the same thing in O(n) time complexity and O(1) space complexity:\\n\\n```cpp\\nint maxProfit(vector<int>& prices) {\\n    int min_price = INT_MAX;\\n    int max_profit = 0;\\n    \\n    for (int price : prices) {\\n        if (price < min_price) {\\n            min_price = price;\\n        } else if (price - min_price > max_profit) {\\n            max_profit = price - min_price;\\n        }\\n    }\\n    \\n    return max_profit;\\n}\\n```\\n\\nThis solution works by maintaining the minimum price seen so far and the maximum profit that can be made from selling at the current price. By updating these values as it iterates through the array, it ensures that it only considers selling prices that come after the minimum price it\\'s seen."
                    },
                    {
                        "username": "williamhergott",
                        "content": "Hey, when submitting my code I recieve \"time limit exceeded\" and the code is not approved, but I only used one for loop? Why is this the case? Thanks. (python 3)\\n\\n\\nclass Solution:\\n    def maxProfit(self, prices: List[int]) -> int:\\n        \\n        max_prof = 0\\n        \\n        for i in range(len(prices)):\\n            max_prof = max(max(prices[i:]) - prices[i], max_prof)\\n        \\n        return max_prof"
                    },
                    {
                        "username": "Vectorido",
                        "content": "I suppose, when you use max - this is some kind of loop, but built-in and not in python language. Anyway, 2 max\\'s have big complexity. I don\\'t know too how to manage with that. This is definitely not an EASY problem. "
                    },
                    {
                        "username": "voronokKita",
                        "content": "Raise the difficulty from easy to medium.\\nChange the Dynamic Programming tag to the Sliding Window."
                    },
                    {
                        "username": "_IshikaJain",
                        "content": "How to deal with Time Limit Exceeded issue ?"
                    }
                ]
            },
            {
                "id": 1812308,
                "content": [
                    {
                        "username": "justsolveitlmao",
                        "content": "Ez weekend I guess"
                    },
                    {
                        "username": "jga111",
                        "content": "You can do this in one pass. Keep track of your best time to buy stock. Keep track of your profits. "
                    },
                    {
                        "username": "tanmoysantra67",
                        "content": "class Solution:\\n    def maxProfit(self, prices: List[int]) -> int:\\n        if not prices:\\n            return 0\\n        \\n        min_price = prices[0]\\n        max_profit = 0\\n        \\n        for price in prices:\\n            if price < min_price:\\n                min_price = price\\n            elif price - min_price > max_profit:\\n                max_profit = price - min_price\\n        \\n        return max_profit\\n"
                    },
                    {
                        "username": "cagils",
                        "content": "A quick tip to get a single line solution in js using sliding windows approach:\\n```js\\nwhile (++r < length) if (prices[r] <= prices[l]) l = r; else *CALCULATE_MAX*\\n```"
                    },
                    {
                        "username": "david144",
                        "content": "Just think If I sell the stock in day n, then the max profit will equals today\\'s price minus minimum price from day 0 to day n."
                    },
                    {
                        "username": "parsa-sedigh",
                        "content": "What\\'s wrong with my approach(besides time complexity)?\\n ```javascript\\n    const tradeResults = [];\\n\\n    for (let i = 0; i<prices.length; i++) {\\n        let start = i;\\n        let end = prices.length - 1;\\n\\n        while (start <= end) {\\n            tradeResults.push(prices[end] - prices[start]);\\n            start++;\\n            end--;\\n        }\\n    }\\n\\n    return tradeResults.sort((a, b) => b - a)[0];\\n```"
                    },
                    {
                        "username": "parsa-sedigh",
                        "content": "The problem is I don\\'t consider all the possibilities together because of incrementing and decrementing the start and end simultaneously."
                    },
                    {
                        "username": "Dikshika_12",
                        "content": "for this question you must be familiar with prefix and suffix array \\n\\n in prefix array you will be storing the element minimum till that index for \\ne.g the array is [7,5,8,1,3,4]\\nso your prefix array will look like prefix_array[7,5,5,1,1,1] i.e, minimum element till first index is 7 so we sotred it in the prefix_array then moving on minimum element till 2nd index is 5 and so on we will make the array.\\n\\n in suffix array you will be storing the element maximum till that index for \\ne.g the array is [7,5,8,1,3,4]\\nso your suffix  array will look like suffix_array [8,8,8,4,4,4] i.e, maximum element from last index is 4 so we stored it in the suffix_array then moving on maximum element till 2nd last index is 4 again because 3<4  so on we will make the array.\\nonce you make the array reverse it.\\n\\nnow itreate over the array and store the ans = suffix_array[i]-prefix_array[i],\\nmaxi  = max(maxi,ans);\\n"
                    },
                    {
                        "username": "bparanj",
                        "content": "Your approach is correct and a great demonstration of using prefix and suffix arrays. However, it seems a bit over-complicated for this particular problem. Essentially, you\\'re trying to find the maximum difference between a pair of numbers in the array, where the smaller number comes before the larger one.\\n\\nAs a result, while your solution will certainly work, it also requires extra space to store the prefix and suffix arrays. Additionally, it involves a bit more computation than necessary since it computes the minimum value up to each index and the maximum value after each index, even though this isn\\'t strictly necessary to find the maximum profit.\\n\\nHere\\'s a simpler solution that accomplishes the same thing in O(n) time complexity and O(1) space complexity:\\n\\n```cpp\\nint maxProfit(vector<int>& prices) {\\n    int min_price = INT_MAX;\\n    int max_profit = 0;\\n    \\n    for (int price : prices) {\\n        if (price < min_price) {\\n            min_price = price;\\n        } else if (price - min_price > max_profit) {\\n            max_profit = price - min_price;\\n        }\\n    }\\n    \\n    return max_profit;\\n}\\n```\\n\\nThis solution works by maintaining the minimum price seen so far and the maximum profit that can be made from selling at the current price. By updating these values as it iterates through the array, it ensures that it only considers selling prices that come after the minimum price it\\'s seen."
                    },
                    {
                        "username": "williamhergott",
                        "content": "Hey, when submitting my code I recieve \"time limit exceeded\" and the code is not approved, but I only used one for loop? Why is this the case? Thanks. (python 3)\\n\\n\\nclass Solution:\\n    def maxProfit(self, prices: List[int]) -> int:\\n        \\n        max_prof = 0\\n        \\n        for i in range(len(prices)):\\n            max_prof = max(max(prices[i:]) - prices[i], max_prof)\\n        \\n        return max_prof"
                    },
                    {
                        "username": "Vectorido",
                        "content": "I suppose, when you use max - this is some kind of loop, but built-in and not in python language. Anyway, 2 max\\'s have big complexity. I don\\'t know too how to manage with that. This is definitely not an EASY problem. "
                    },
                    {
                        "username": "voronokKita",
                        "content": "Raise the difficulty from easy to medium.\\nChange the Dynamic Programming tag to the Sliding Window."
                    },
                    {
                        "username": "_IshikaJain",
                        "content": "How to deal with Time Limit Exceeded issue ?"
                    }
                ]
            },
            {
                "id": 1811887,
                "content": [
                    {
                        "username": "justsolveitlmao",
                        "content": "Ez weekend I guess"
                    },
                    {
                        "username": "jga111",
                        "content": "You can do this in one pass. Keep track of your best time to buy stock. Keep track of your profits. "
                    },
                    {
                        "username": "tanmoysantra67",
                        "content": "class Solution:\\n    def maxProfit(self, prices: List[int]) -> int:\\n        if not prices:\\n            return 0\\n        \\n        min_price = prices[0]\\n        max_profit = 0\\n        \\n        for price in prices:\\n            if price < min_price:\\n                min_price = price\\n            elif price - min_price > max_profit:\\n                max_profit = price - min_price\\n        \\n        return max_profit\\n"
                    },
                    {
                        "username": "cagils",
                        "content": "A quick tip to get a single line solution in js using sliding windows approach:\\n```js\\nwhile (++r < length) if (prices[r] <= prices[l]) l = r; else *CALCULATE_MAX*\\n```"
                    },
                    {
                        "username": "david144",
                        "content": "Just think If I sell the stock in day n, then the max profit will equals today\\'s price minus minimum price from day 0 to day n."
                    },
                    {
                        "username": "parsa-sedigh",
                        "content": "What\\'s wrong with my approach(besides time complexity)?\\n ```javascript\\n    const tradeResults = [];\\n\\n    for (let i = 0; i<prices.length; i++) {\\n        let start = i;\\n        let end = prices.length - 1;\\n\\n        while (start <= end) {\\n            tradeResults.push(prices[end] - prices[start]);\\n            start++;\\n            end--;\\n        }\\n    }\\n\\n    return tradeResults.sort((a, b) => b - a)[0];\\n```"
                    },
                    {
                        "username": "parsa-sedigh",
                        "content": "The problem is I don\\'t consider all the possibilities together because of incrementing and decrementing the start and end simultaneously."
                    },
                    {
                        "username": "Dikshika_12",
                        "content": "for this question you must be familiar with prefix and suffix array \\n\\n in prefix array you will be storing the element minimum till that index for \\ne.g the array is [7,5,8,1,3,4]\\nso your prefix array will look like prefix_array[7,5,5,1,1,1] i.e, minimum element till first index is 7 so we sotred it in the prefix_array then moving on minimum element till 2nd index is 5 and so on we will make the array.\\n\\n in suffix array you will be storing the element maximum till that index for \\ne.g the array is [7,5,8,1,3,4]\\nso your suffix  array will look like suffix_array [8,8,8,4,4,4] i.e, maximum element from last index is 4 so we stored it in the suffix_array then moving on maximum element till 2nd last index is 4 again because 3<4  so on we will make the array.\\nonce you make the array reverse it.\\n\\nnow itreate over the array and store the ans = suffix_array[i]-prefix_array[i],\\nmaxi  = max(maxi,ans);\\n"
                    },
                    {
                        "username": "bparanj",
                        "content": "Your approach is correct and a great demonstration of using prefix and suffix arrays. However, it seems a bit over-complicated for this particular problem. Essentially, you\\'re trying to find the maximum difference between a pair of numbers in the array, where the smaller number comes before the larger one.\\n\\nAs a result, while your solution will certainly work, it also requires extra space to store the prefix and suffix arrays. Additionally, it involves a bit more computation than necessary since it computes the minimum value up to each index and the maximum value after each index, even though this isn\\'t strictly necessary to find the maximum profit.\\n\\nHere\\'s a simpler solution that accomplishes the same thing in O(n) time complexity and O(1) space complexity:\\n\\n```cpp\\nint maxProfit(vector<int>& prices) {\\n    int min_price = INT_MAX;\\n    int max_profit = 0;\\n    \\n    for (int price : prices) {\\n        if (price < min_price) {\\n            min_price = price;\\n        } else if (price - min_price > max_profit) {\\n            max_profit = price - min_price;\\n        }\\n    }\\n    \\n    return max_profit;\\n}\\n```\\n\\nThis solution works by maintaining the minimum price seen so far and the maximum profit that can be made from selling at the current price. By updating these values as it iterates through the array, it ensures that it only considers selling prices that come after the minimum price it\\'s seen."
                    },
                    {
                        "username": "williamhergott",
                        "content": "Hey, when submitting my code I recieve \"time limit exceeded\" and the code is not approved, but I only used one for loop? Why is this the case? Thanks. (python 3)\\n\\n\\nclass Solution:\\n    def maxProfit(self, prices: List[int]) -> int:\\n        \\n        max_prof = 0\\n        \\n        for i in range(len(prices)):\\n            max_prof = max(max(prices[i:]) - prices[i], max_prof)\\n        \\n        return max_prof"
                    },
                    {
                        "username": "Vectorido",
                        "content": "I suppose, when you use max - this is some kind of loop, but built-in and not in python language. Anyway, 2 max\\'s have big complexity. I don\\'t know too how to manage with that. This is definitely not an EASY problem. "
                    },
                    {
                        "username": "voronokKita",
                        "content": "Raise the difficulty from easy to medium.\\nChange the Dynamic Programming tag to the Sliding Window."
                    },
                    {
                        "username": "_IshikaJain",
                        "content": "How to deal with Time Limit Exceeded issue ?"
                    }
                ]
            },
            {
                "id": 1811691,
                "content": [
                    {
                        "username": "justsolveitlmao",
                        "content": "Ez weekend I guess"
                    },
                    {
                        "username": "jga111",
                        "content": "You can do this in one pass. Keep track of your best time to buy stock. Keep track of your profits. "
                    },
                    {
                        "username": "tanmoysantra67",
                        "content": "class Solution:\\n    def maxProfit(self, prices: List[int]) -> int:\\n        if not prices:\\n            return 0\\n        \\n        min_price = prices[0]\\n        max_profit = 0\\n        \\n        for price in prices:\\n            if price < min_price:\\n                min_price = price\\n            elif price - min_price > max_profit:\\n                max_profit = price - min_price\\n        \\n        return max_profit\\n"
                    },
                    {
                        "username": "cagils",
                        "content": "A quick tip to get a single line solution in js using sliding windows approach:\\n```js\\nwhile (++r < length) if (prices[r] <= prices[l]) l = r; else *CALCULATE_MAX*\\n```"
                    },
                    {
                        "username": "david144",
                        "content": "Just think If I sell the stock in day n, then the max profit will equals today\\'s price minus minimum price from day 0 to day n."
                    },
                    {
                        "username": "parsa-sedigh",
                        "content": "What\\'s wrong with my approach(besides time complexity)?\\n ```javascript\\n    const tradeResults = [];\\n\\n    for (let i = 0; i<prices.length; i++) {\\n        let start = i;\\n        let end = prices.length - 1;\\n\\n        while (start <= end) {\\n            tradeResults.push(prices[end] - prices[start]);\\n            start++;\\n            end--;\\n        }\\n    }\\n\\n    return tradeResults.sort((a, b) => b - a)[0];\\n```"
                    },
                    {
                        "username": "parsa-sedigh",
                        "content": "The problem is I don\\'t consider all the possibilities together because of incrementing and decrementing the start and end simultaneously."
                    },
                    {
                        "username": "Dikshika_12",
                        "content": "for this question you must be familiar with prefix and suffix array \\n\\n in prefix array you will be storing the element minimum till that index for \\ne.g the array is [7,5,8,1,3,4]\\nso your prefix array will look like prefix_array[7,5,5,1,1,1] i.e, minimum element till first index is 7 so we sotred it in the prefix_array then moving on minimum element till 2nd index is 5 and so on we will make the array.\\n\\n in suffix array you will be storing the element maximum till that index for \\ne.g the array is [7,5,8,1,3,4]\\nso your suffix  array will look like suffix_array [8,8,8,4,4,4] i.e, maximum element from last index is 4 so we stored it in the suffix_array then moving on maximum element till 2nd last index is 4 again because 3<4  so on we will make the array.\\nonce you make the array reverse it.\\n\\nnow itreate over the array and store the ans = suffix_array[i]-prefix_array[i],\\nmaxi  = max(maxi,ans);\\n"
                    },
                    {
                        "username": "bparanj",
                        "content": "Your approach is correct and a great demonstration of using prefix and suffix arrays. However, it seems a bit over-complicated for this particular problem. Essentially, you\\'re trying to find the maximum difference between a pair of numbers in the array, where the smaller number comes before the larger one.\\n\\nAs a result, while your solution will certainly work, it also requires extra space to store the prefix and suffix arrays. Additionally, it involves a bit more computation than necessary since it computes the minimum value up to each index and the maximum value after each index, even though this isn\\'t strictly necessary to find the maximum profit.\\n\\nHere\\'s a simpler solution that accomplishes the same thing in O(n) time complexity and O(1) space complexity:\\n\\n```cpp\\nint maxProfit(vector<int>& prices) {\\n    int min_price = INT_MAX;\\n    int max_profit = 0;\\n    \\n    for (int price : prices) {\\n        if (price < min_price) {\\n            min_price = price;\\n        } else if (price - min_price > max_profit) {\\n            max_profit = price - min_price;\\n        }\\n    }\\n    \\n    return max_profit;\\n}\\n```\\n\\nThis solution works by maintaining the minimum price seen so far and the maximum profit that can be made from selling at the current price. By updating these values as it iterates through the array, it ensures that it only considers selling prices that come after the minimum price it\\'s seen."
                    },
                    {
                        "username": "williamhergott",
                        "content": "Hey, when submitting my code I recieve \"time limit exceeded\" and the code is not approved, but I only used one for loop? Why is this the case? Thanks. (python 3)\\n\\n\\nclass Solution:\\n    def maxProfit(self, prices: List[int]) -> int:\\n        \\n        max_prof = 0\\n        \\n        for i in range(len(prices)):\\n            max_prof = max(max(prices[i:]) - prices[i], max_prof)\\n        \\n        return max_prof"
                    },
                    {
                        "username": "Vectorido",
                        "content": "I suppose, when you use max - this is some kind of loop, but built-in and not in python language. Anyway, 2 max\\'s have big complexity. I don\\'t know too how to manage with that. This is definitely not an EASY problem. "
                    },
                    {
                        "username": "voronokKita",
                        "content": "Raise the difficulty from easy to medium.\\nChange the Dynamic Programming tag to the Sliding Window."
                    },
                    {
                        "username": "_IshikaJain",
                        "content": "How to deal with Time Limit Exceeded issue ?"
                    }
                ]
            },
            {
                "id": 1811623,
                "content": [
                    {
                        "username": "justsolveitlmao",
                        "content": "Ez weekend I guess"
                    },
                    {
                        "username": "jga111",
                        "content": "You can do this in one pass. Keep track of your best time to buy stock. Keep track of your profits. "
                    },
                    {
                        "username": "tanmoysantra67",
                        "content": "class Solution:\\n    def maxProfit(self, prices: List[int]) -> int:\\n        if not prices:\\n            return 0\\n        \\n        min_price = prices[0]\\n        max_profit = 0\\n        \\n        for price in prices:\\n            if price < min_price:\\n                min_price = price\\n            elif price - min_price > max_profit:\\n                max_profit = price - min_price\\n        \\n        return max_profit\\n"
                    },
                    {
                        "username": "cagils",
                        "content": "A quick tip to get a single line solution in js using sliding windows approach:\\n```js\\nwhile (++r < length) if (prices[r] <= prices[l]) l = r; else *CALCULATE_MAX*\\n```"
                    },
                    {
                        "username": "david144",
                        "content": "Just think If I sell the stock in day n, then the max profit will equals today\\'s price minus minimum price from day 0 to day n."
                    },
                    {
                        "username": "parsa-sedigh",
                        "content": "What\\'s wrong with my approach(besides time complexity)?\\n ```javascript\\n    const tradeResults = [];\\n\\n    for (let i = 0; i<prices.length; i++) {\\n        let start = i;\\n        let end = prices.length - 1;\\n\\n        while (start <= end) {\\n            tradeResults.push(prices[end] - prices[start]);\\n            start++;\\n            end--;\\n        }\\n    }\\n\\n    return tradeResults.sort((a, b) => b - a)[0];\\n```"
                    },
                    {
                        "username": "parsa-sedigh",
                        "content": "The problem is I don\\'t consider all the possibilities together because of incrementing and decrementing the start and end simultaneously."
                    },
                    {
                        "username": "Dikshika_12",
                        "content": "for this question you must be familiar with prefix and suffix array \\n\\n in prefix array you will be storing the element minimum till that index for \\ne.g the array is [7,5,8,1,3,4]\\nso your prefix array will look like prefix_array[7,5,5,1,1,1] i.e, minimum element till first index is 7 so we sotred it in the prefix_array then moving on minimum element till 2nd index is 5 and so on we will make the array.\\n\\n in suffix array you will be storing the element maximum till that index for \\ne.g the array is [7,5,8,1,3,4]\\nso your suffix  array will look like suffix_array [8,8,8,4,4,4] i.e, maximum element from last index is 4 so we stored it in the suffix_array then moving on maximum element till 2nd last index is 4 again because 3<4  so on we will make the array.\\nonce you make the array reverse it.\\n\\nnow itreate over the array and store the ans = suffix_array[i]-prefix_array[i],\\nmaxi  = max(maxi,ans);\\n"
                    },
                    {
                        "username": "bparanj",
                        "content": "Your approach is correct and a great demonstration of using prefix and suffix arrays. However, it seems a bit over-complicated for this particular problem. Essentially, you\\'re trying to find the maximum difference between a pair of numbers in the array, where the smaller number comes before the larger one.\\n\\nAs a result, while your solution will certainly work, it also requires extra space to store the prefix and suffix arrays. Additionally, it involves a bit more computation than necessary since it computes the minimum value up to each index and the maximum value after each index, even though this isn\\'t strictly necessary to find the maximum profit.\\n\\nHere\\'s a simpler solution that accomplishes the same thing in O(n) time complexity and O(1) space complexity:\\n\\n```cpp\\nint maxProfit(vector<int>& prices) {\\n    int min_price = INT_MAX;\\n    int max_profit = 0;\\n    \\n    for (int price : prices) {\\n        if (price < min_price) {\\n            min_price = price;\\n        } else if (price - min_price > max_profit) {\\n            max_profit = price - min_price;\\n        }\\n    }\\n    \\n    return max_profit;\\n}\\n```\\n\\nThis solution works by maintaining the minimum price seen so far and the maximum profit that can be made from selling at the current price. By updating these values as it iterates through the array, it ensures that it only considers selling prices that come after the minimum price it\\'s seen."
                    },
                    {
                        "username": "williamhergott",
                        "content": "Hey, when submitting my code I recieve \"time limit exceeded\" and the code is not approved, but I only used one for loop? Why is this the case? Thanks. (python 3)\\n\\n\\nclass Solution:\\n    def maxProfit(self, prices: List[int]) -> int:\\n        \\n        max_prof = 0\\n        \\n        for i in range(len(prices)):\\n            max_prof = max(max(prices[i:]) - prices[i], max_prof)\\n        \\n        return max_prof"
                    },
                    {
                        "username": "Vectorido",
                        "content": "I suppose, when you use max - this is some kind of loop, but built-in and not in python language. Anyway, 2 max\\'s have big complexity. I don\\'t know too how to manage with that. This is definitely not an EASY problem. "
                    },
                    {
                        "username": "voronokKita",
                        "content": "Raise the difficulty from easy to medium.\\nChange the Dynamic Programming tag to the Sliding Window."
                    },
                    {
                        "username": "_IshikaJain",
                        "content": "How to deal with Time Limit Exceeded issue ?"
                    }
                ]
            },
            {
                "id": 1804275,
                "content": [
                    {
                        "username": "justsolveitlmao",
                        "content": "Ez weekend I guess"
                    },
                    {
                        "username": "jga111",
                        "content": "You can do this in one pass. Keep track of your best time to buy stock. Keep track of your profits. "
                    },
                    {
                        "username": "tanmoysantra67",
                        "content": "class Solution:\\n    def maxProfit(self, prices: List[int]) -> int:\\n        if not prices:\\n            return 0\\n        \\n        min_price = prices[0]\\n        max_profit = 0\\n        \\n        for price in prices:\\n            if price < min_price:\\n                min_price = price\\n            elif price - min_price > max_profit:\\n                max_profit = price - min_price\\n        \\n        return max_profit\\n"
                    },
                    {
                        "username": "cagils",
                        "content": "A quick tip to get a single line solution in js using sliding windows approach:\\n```js\\nwhile (++r < length) if (prices[r] <= prices[l]) l = r; else *CALCULATE_MAX*\\n```"
                    },
                    {
                        "username": "david144",
                        "content": "Just think If I sell the stock in day n, then the max profit will equals today\\'s price minus minimum price from day 0 to day n."
                    },
                    {
                        "username": "parsa-sedigh",
                        "content": "What\\'s wrong with my approach(besides time complexity)?\\n ```javascript\\n    const tradeResults = [];\\n\\n    for (let i = 0; i<prices.length; i++) {\\n        let start = i;\\n        let end = prices.length - 1;\\n\\n        while (start <= end) {\\n            tradeResults.push(prices[end] - prices[start]);\\n            start++;\\n            end--;\\n        }\\n    }\\n\\n    return tradeResults.sort((a, b) => b - a)[0];\\n```"
                    },
                    {
                        "username": "parsa-sedigh",
                        "content": "The problem is I don\\'t consider all the possibilities together because of incrementing and decrementing the start and end simultaneously."
                    },
                    {
                        "username": "Dikshika_12",
                        "content": "for this question you must be familiar with prefix and suffix array \\n\\n in prefix array you will be storing the element minimum till that index for \\ne.g the array is [7,5,8,1,3,4]\\nso your prefix array will look like prefix_array[7,5,5,1,1,1] i.e, minimum element till first index is 7 so we sotred it in the prefix_array then moving on minimum element till 2nd index is 5 and so on we will make the array.\\n\\n in suffix array you will be storing the element maximum till that index for \\ne.g the array is [7,5,8,1,3,4]\\nso your suffix  array will look like suffix_array [8,8,8,4,4,4] i.e, maximum element from last index is 4 so we stored it in the suffix_array then moving on maximum element till 2nd last index is 4 again because 3<4  so on we will make the array.\\nonce you make the array reverse it.\\n\\nnow itreate over the array and store the ans = suffix_array[i]-prefix_array[i],\\nmaxi  = max(maxi,ans);\\n"
                    },
                    {
                        "username": "bparanj",
                        "content": "Your approach is correct and a great demonstration of using prefix and suffix arrays. However, it seems a bit over-complicated for this particular problem. Essentially, you\\'re trying to find the maximum difference between a pair of numbers in the array, where the smaller number comes before the larger one.\\n\\nAs a result, while your solution will certainly work, it also requires extra space to store the prefix and suffix arrays. Additionally, it involves a bit more computation than necessary since it computes the minimum value up to each index and the maximum value after each index, even though this isn\\'t strictly necessary to find the maximum profit.\\n\\nHere\\'s a simpler solution that accomplishes the same thing in O(n) time complexity and O(1) space complexity:\\n\\n```cpp\\nint maxProfit(vector<int>& prices) {\\n    int min_price = INT_MAX;\\n    int max_profit = 0;\\n    \\n    for (int price : prices) {\\n        if (price < min_price) {\\n            min_price = price;\\n        } else if (price - min_price > max_profit) {\\n            max_profit = price - min_price;\\n        }\\n    }\\n    \\n    return max_profit;\\n}\\n```\\n\\nThis solution works by maintaining the minimum price seen so far and the maximum profit that can be made from selling at the current price. By updating these values as it iterates through the array, it ensures that it only considers selling prices that come after the minimum price it\\'s seen."
                    },
                    {
                        "username": "williamhergott",
                        "content": "Hey, when submitting my code I recieve \"time limit exceeded\" and the code is not approved, but I only used one for loop? Why is this the case? Thanks. (python 3)\\n\\n\\nclass Solution:\\n    def maxProfit(self, prices: List[int]) -> int:\\n        \\n        max_prof = 0\\n        \\n        for i in range(len(prices)):\\n            max_prof = max(max(prices[i:]) - prices[i], max_prof)\\n        \\n        return max_prof"
                    },
                    {
                        "username": "Vectorido",
                        "content": "I suppose, when you use max - this is some kind of loop, but built-in and not in python language. Anyway, 2 max\\'s have big complexity. I don\\'t know too how to manage with that. This is definitely not an EASY problem. "
                    },
                    {
                        "username": "voronokKita",
                        "content": "Raise the difficulty from easy to medium.\\nChange the Dynamic Programming tag to the Sliding Window."
                    },
                    {
                        "username": "_IshikaJain",
                        "content": "How to deal with Time Limit Exceeded issue ?"
                    }
                ]
            },
            {
                "id": 1803716,
                "content": [
                    {
                        "username": "justsolveitlmao",
                        "content": "Ez weekend I guess"
                    },
                    {
                        "username": "jga111",
                        "content": "You can do this in one pass. Keep track of your best time to buy stock. Keep track of your profits. "
                    },
                    {
                        "username": "tanmoysantra67",
                        "content": "class Solution:\\n    def maxProfit(self, prices: List[int]) -> int:\\n        if not prices:\\n            return 0\\n        \\n        min_price = prices[0]\\n        max_profit = 0\\n        \\n        for price in prices:\\n            if price < min_price:\\n                min_price = price\\n            elif price - min_price > max_profit:\\n                max_profit = price - min_price\\n        \\n        return max_profit\\n"
                    },
                    {
                        "username": "cagils",
                        "content": "A quick tip to get a single line solution in js using sliding windows approach:\\n```js\\nwhile (++r < length) if (prices[r] <= prices[l]) l = r; else *CALCULATE_MAX*\\n```"
                    },
                    {
                        "username": "david144",
                        "content": "Just think If I sell the stock in day n, then the max profit will equals today\\'s price minus minimum price from day 0 to day n."
                    },
                    {
                        "username": "parsa-sedigh",
                        "content": "What\\'s wrong with my approach(besides time complexity)?\\n ```javascript\\n    const tradeResults = [];\\n\\n    for (let i = 0; i<prices.length; i++) {\\n        let start = i;\\n        let end = prices.length - 1;\\n\\n        while (start <= end) {\\n            tradeResults.push(prices[end] - prices[start]);\\n            start++;\\n            end--;\\n        }\\n    }\\n\\n    return tradeResults.sort((a, b) => b - a)[0];\\n```"
                    },
                    {
                        "username": "parsa-sedigh",
                        "content": "The problem is I don\\'t consider all the possibilities together because of incrementing and decrementing the start and end simultaneously."
                    },
                    {
                        "username": "Dikshika_12",
                        "content": "for this question you must be familiar with prefix and suffix array \\n\\n in prefix array you will be storing the element minimum till that index for \\ne.g the array is [7,5,8,1,3,4]\\nso your prefix array will look like prefix_array[7,5,5,1,1,1] i.e, minimum element till first index is 7 so we sotred it in the prefix_array then moving on minimum element till 2nd index is 5 and so on we will make the array.\\n\\n in suffix array you will be storing the element maximum till that index for \\ne.g the array is [7,5,8,1,3,4]\\nso your suffix  array will look like suffix_array [8,8,8,4,4,4] i.e, maximum element from last index is 4 so we stored it in the suffix_array then moving on maximum element till 2nd last index is 4 again because 3<4  so on we will make the array.\\nonce you make the array reverse it.\\n\\nnow itreate over the array and store the ans = suffix_array[i]-prefix_array[i],\\nmaxi  = max(maxi,ans);\\n"
                    },
                    {
                        "username": "bparanj",
                        "content": "Your approach is correct and a great demonstration of using prefix and suffix arrays. However, it seems a bit over-complicated for this particular problem. Essentially, you\\'re trying to find the maximum difference between a pair of numbers in the array, where the smaller number comes before the larger one.\\n\\nAs a result, while your solution will certainly work, it also requires extra space to store the prefix and suffix arrays. Additionally, it involves a bit more computation than necessary since it computes the minimum value up to each index and the maximum value after each index, even though this isn\\'t strictly necessary to find the maximum profit.\\n\\nHere\\'s a simpler solution that accomplishes the same thing in O(n) time complexity and O(1) space complexity:\\n\\n```cpp\\nint maxProfit(vector<int>& prices) {\\n    int min_price = INT_MAX;\\n    int max_profit = 0;\\n    \\n    for (int price : prices) {\\n        if (price < min_price) {\\n            min_price = price;\\n        } else if (price - min_price > max_profit) {\\n            max_profit = price - min_price;\\n        }\\n    }\\n    \\n    return max_profit;\\n}\\n```\\n\\nThis solution works by maintaining the minimum price seen so far and the maximum profit that can be made from selling at the current price. By updating these values as it iterates through the array, it ensures that it only considers selling prices that come after the minimum price it\\'s seen."
                    },
                    {
                        "username": "williamhergott",
                        "content": "Hey, when submitting my code I recieve \"time limit exceeded\" and the code is not approved, but I only used one for loop? Why is this the case? Thanks. (python 3)\\n\\n\\nclass Solution:\\n    def maxProfit(self, prices: List[int]) -> int:\\n        \\n        max_prof = 0\\n        \\n        for i in range(len(prices)):\\n            max_prof = max(max(prices[i:]) - prices[i], max_prof)\\n        \\n        return max_prof"
                    },
                    {
                        "username": "Vectorido",
                        "content": "I suppose, when you use max - this is some kind of loop, but built-in and not in python language. Anyway, 2 max\\'s have big complexity. I don\\'t know too how to manage with that. This is definitely not an EASY problem. "
                    },
                    {
                        "username": "voronokKita",
                        "content": "Raise the difficulty from easy to medium.\\nChange the Dynamic Programming tag to the Sliding Window."
                    },
                    {
                        "username": "_IshikaJain",
                        "content": "How to deal with Time Limit Exceeded issue ?"
                    }
                ]
            },
            {
                "id": 1802339,
                "content": [
                    {
                        "username": "justsolveitlmao",
                        "content": "Ez weekend I guess"
                    },
                    {
                        "username": "jga111",
                        "content": "You can do this in one pass. Keep track of your best time to buy stock. Keep track of your profits. "
                    },
                    {
                        "username": "tanmoysantra67",
                        "content": "class Solution:\\n    def maxProfit(self, prices: List[int]) -> int:\\n        if not prices:\\n            return 0\\n        \\n        min_price = prices[0]\\n        max_profit = 0\\n        \\n        for price in prices:\\n            if price < min_price:\\n                min_price = price\\n            elif price - min_price > max_profit:\\n                max_profit = price - min_price\\n        \\n        return max_profit\\n"
                    },
                    {
                        "username": "cagils",
                        "content": "A quick tip to get a single line solution in js using sliding windows approach:\\n```js\\nwhile (++r < length) if (prices[r] <= prices[l]) l = r; else *CALCULATE_MAX*\\n```"
                    },
                    {
                        "username": "david144",
                        "content": "Just think If I sell the stock in day n, then the max profit will equals today\\'s price minus minimum price from day 0 to day n."
                    },
                    {
                        "username": "parsa-sedigh",
                        "content": "What\\'s wrong with my approach(besides time complexity)?\\n ```javascript\\n    const tradeResults = [];\\n\\n    for (let i = 0; i<prices.length; i++) {\\n        let start = i;\\n        let end = prices.length - 1;\\n\\n        while (start <= end) {\\n            tradeResults.push(prices[end] - prices[start]);\\n            start++;\\n            end--;\\n        }\\n    }\\n\\n    return tradeResults.sort((a, b) => b - a)[0];\\n```"
                    },
                    {
                        "username": "parsa-sedigh",
                        "content": "The problem is I don\\'t consider all the possibilities together because of incrementing and decrementing the start and end simultaneously."
                    },
                    {
                        "username": "Dikshika_12",
                        "content": "for this question you must be familiar with prefix and suffix array \\n\\n in prefix array you will be storing the element minimum till that index for \\ne.g the array is [7,5,8,1,3,4]\\nso your prefix array will look like prefix_array[7,5,5,1,1,1] i.e, minimum element till first index is 7 so we sotred it in the prefix_array then moving on minimum element till 2nd index is 5 and so on we will make the array.\\n\\n in suffix array you will be storing the element maximum till that index for \\ne.g the array is [7,5,8,1,3,4]\\nso your suffix  array will look like suffix_array [8,8,8,4,4,4] i.e, maximum element from last index is 4 so we stored it in the suffix_array then moving on maximum element till 2nd last index is 4 again because 3<4  so on we will make the array.\\nonce you make the array reverse it.\\n\\nnow itreate over the array and store the ans = suffix_array[i]-prefix_array[i],\\nmaxi  = max(maxi,ans);\\n"
                    },
                    {
                        "username": "bparanj",
                        "content": "Your approach is correct and a great demonstration of using prefix and suffix arrays. However, it seems a bit over-complicated for this particular problem. Essentially, you\\'re trying to find the maximum difference between a pair of numbers in the array, where the smaller number comes before the larger one.\\n\\nAs a result, while your solution will certainly work, it also requires extra space to store the prefix and suffix arrays. Additionally, it involves a bit more computation than necessary since it computes the minimum value up to each index and the maximum value after each index, even though this isn\\'t strictly necessary to find the maximum profit.\\n\\nHere\\'s a simpler solution that accomplishes the same thing in O(n) time complexity and O(1) space complexity:\\n\\n```cpp\\nint maxProfit(vector<int>& prices) {\\n    int min_price = INT_MAX;\\n    int max_profit = 0;\\n    \\n    for (int price : prices) {\\n        if (price < min_price) {\\n            min_price = price;\\n        } else if (price - min_price > max_profit) {\\n            max_profit = price - min_price;\\n        }\\n    }\\n    \\n    return max_profit;\\n}\\n```\\n\\nThis solution works by maintaining the minimum price seen so far and the maximum profit that can be made from selling at the current price. By updating these values as it iterates through the array, it ensures that it only considers selling prices that come after the minimum price it\\'s seen."
                    },
                    {
                        "username": "williamhergott",
                        "content": "Hey, when submitting my code I recieve \"time limit exceeded\" and the code is not approved, but I only used one for loop? Why is this the case? Thanks. (python 3)\\n\\n\\nclass Solution:\\n    def maxProfit(self, prices: List[int]) -> int:\\n        \\n        max_prof = 0\\n        \\n        for i in range(len(prices)):\\n            max_prof = max(max(prices[i:]) - prices[i], max_prof)\\n        \\n        return max_prof"
                    },
                    {
                        "username": "Vectorido",
                        "content": "I suppose, when you use max - this is some kind of loop, but built-in and not in python language. Anyway, 2 max\\'s have big complexity. I don\\'t know too how to manage with that. This is definitely not an EASY problem. "
                    },
                    {
                        "username": "voronokKita",
                        "content": "Raise the difficulty from easy to medium.\\nChange the Dynamic Programming tag to the Sliding Window."
                    },
                    {
                        "username": "_IshikaJain",
                        "content": "How to deal with Time Limit Exceeded issue ?"
                    }
                ]
            },
            {
                "id": 1799870,
                "content": [
                    {
                        "username": "justsolveitlmao",
                        "content": "Ez weekend I guess"
                    },
                    {
                        "username": "jga111",
                        "content": "You can do this in one pass. Keep track of your best time to buy stock. Keep track of your profits. "
                    },
                    {
                        "username": "tanmoysantra67",
                        "content": "class Solution:\\n    def maxProfit(self, prices: List[int]) -> int:\\n        if not prices:\\n            return 0\\n        \\n        min_price = prices[0]\\n        max_profit = 0\\n        \\n        for price in prices:\\n            if price < min_price:\\n                min_price = price\\n            elif price - min_price > max_profit:\\n                max_profit = price - min_price\\n        \\n        return max_profit\\n"
                    },
                    {
                        "username": "cagils",
                        "content": "A quick tip to get a single line solution in js using sliding windows approach:\\n```js\\nwhile (++r < length) if (prices[r] <= prices[l]) l = r; else *CALCULATE_MAX*\\n```"
                    },
                    {
                        "username": "david144",
                        "content": "Just think If I sell the stock in day n, then the max profit will equals today\\'s price minus minimum price from day 0 to day n."
                    },
                    {
                        "username": "parsa-sedigh",
                        "content": "What\\'s wrong with my approach(besides time complexity)?\\n ```javascript\\n    const tradeResults = [];\\n\\n    for (let i = 0; i<prices.length; i++) {\\n        let start = i;\\n        let end = prices.length - 1;\\n\\n        while (start <= end) {\\n            tradeResults.push(prices[end] - prices[start]);\\n            start++;\\n            end--;\\n        }\\n    }\\n\\n    return tradeResults.sort((a, b) => b - a)[0];\\n```"
                    },
                    {
                        "username": "parsa-sedigh",
                        "content": "The problem is I don\\'t consider all the possibilities together because of incrementing and decrementing the start and end simultaneously."
                    },
                    {
                        "username": "Dikshika_12",
                        "content": "for this question you must be familiar with prefix and suffix array \\n\\n in prefix array you will be storing the element minimum till that index for \\ne.g the array is [7,5,8,1,3,4]\\nso your prefix array will look like prefix_array[7,5,5,1,1,1] i.e, minimum element till first index is 7 so we sotred it in the prefix_array then moving on minimum element till 2nd index is 5 and so on we will make the array.\\n\\n in suffix array you will be storing the element maximum till that index for \\ne.g the array is [7,5,8,1,3,4]\\nso your suffix  array will look like suffix_array [8,8,8,4,4,4] i.e, maximum element from last index is 4 so we stored it in the suffix_array then moving on maximum element till 2nd last index is 4 again because 3<4  so on we will make the array.\\nonce you make the array reverse it.\\n\\nnow itreate over the array and store the ans = suffix_array[i]-prefix_array[i],\\nmaxi  = max(maxi,ans);\\n"
                    },
                    {
                        "username": "bparanj",
                        "content": "Your approach is correct and a great demonstration of using prefix and suffix arrays. However, it seems a bit over-complicated for this particular problem. Essentially, you\\'re trying to find the maximum difference between a pair of numbers in the array, where the smaller number comes before the larger one.\\n\\nAs a result, while your solution will certainly work, it also requires extra space to store the prefix and suffix arrays. Additionally, it involves a bit more computation than necessary since it computes the minimum value up to each index and the maximum value after each index, even though this isn\\'t strictly necessary to find the maximum profit.\\n\\nHere\\'s a simpler solution that accomplishes the same thing in O(n) time complexity and O(1) space complexity:\\n\\n```cpp\\nint maxProfit(vector<int>& prices) {\\n    int min_price = INT_MAX;\\n    int max_profit = 0;\\n    \\n    for (int price : prices) {\\n        if (price < min_price) {\\n            min_price = price;\\n        } else if (price - min_price > max_profit) {\\n            max_profit = price - min_price;\\n        }\\n    }\\n    \\n    return max_profit;\\n}\\n```\\n\\nThis solution works by maintaining the minimum price seen so far and the maximum profit that can be made from selling at the current price. By updating these values as it iterates through the array, it ensures that it only considers selling prices that come after the minimum price it\\'s seen."
                    },
                    {
                        "username": "williamhergott",
                        "content": "Hey, when submitting my code I recieve \"time limit exceeded\" and the code is not approved, but I only used one for loop? Why is this the case? Thanks. (python 3)\\n\\n\\nclass Solution:\\n    def maxProfit(self, prices: List[int]) -> int:\\n        \\n        max_prof = 0\\n        \\n        for i in range(len(prices)):\\n            max_prof = max(max(prices[i:]) - prices[i], max_prof)\\n        \\n        return max_prof"
                    },
                    {
                        "username": "Vectorido",
                        "content": "I suppose, when you use max - this is some kind of loop, but built-in and not in python language. Anyway, 2 max\\'s have big complexity. I don\\'t know too how to manage with that. This is definitely not an EASY problem. "
                    },
                    {
                        "username": "voronokKita",
                        "content": "Raise the difficulty from easy to medium.\\nChange the Dynamic Programming tag to the Sliding Window."
                    },
                    {
                        "username": "_IshikaJain",
                        "content": "How to deal with Time Limit Exceeded issue ?"
                    }
                ]
            },
            {
                "id": 1794666,
                "content": [
                    {
                        "username": "kumar_Gaurav_Shrivastav",
                        "content": "i\\'m new on leetcode. can anybody tell where can i get main() of program? "
                    },
                    {
                        "username": "mohamedazizjnayah",
                        "content": "the complexity of this code must be what????"
                    },
                    {
                        "username": "SKYWITCHERY",
                        "content": "please tell me why it isnt work \nC#\n` int[] prices = { 7, 1, 5, 3, 6, 4 };\n            int maxPrice = int.MinValue;\n            int minPrice = int.MaxValue;\n            int minIndex = 0;\n            int maxIndex = 0;\n            for (int i = 0; i < prices.Length + 1; i++)\n            {\n                if (prices[i] < minPrice)\n                {\n                    minPrice = prices[i];\n                    minIndex++;\n                }\n                if (prices[i] > maxPrice)\n                {\n                    maxPrice = prices[i];\n                    maxIndex++;\n                }\n                if (maxIndex < minIndex)\n                {\n                    prices[maxIndex] = prices[minIndex];\n                }\n            }\n            Console.WriteLine(maxPrice - minPrice); `"
                    },
                    {
                        "username": "AvtarS2k2",
                        "content": "This is TLE Please tell me why and also how to improve it. `your inline code...your inline code...`\\n\\n\\nclass Solution {\\npublic:\\n    int maxProfit(vector<int>& prices) {\\n        int sum = 0;\\n      for(int i=0;i<prices.size()-1;i++){\\nfor(int j=i+1;j<prices.size();j++){\\n    if(prices[j]>prices[i]){\\n        int newSum = prices[j]-prices[i];\\n        sum = max(sum,newSum);\\n    }else{\\n        continue;\\n    }\\n}\\n      }\\n      return sum;\\n    }\\n};"
                    },
                    {
                        "username": "khandalshivang2002",
                        "content": "in this problem we just maintain smallest element from left of ith element.\\nint maxProfit(vector<int>& prices) {\\n        int res=0;\\n        int sm=prices[0];\\n        for(int i=1;i<prices.size();i++)\\n        {\\n            if(sm>prices[i]){\\n                sm=prices[i];\\n            }else if(prices[i]>sm){\\n                res=max(prices[i]-sm,res);\\n            }\\n        }\\n        return res;\\n    }"
                    },
                    {
                        "username": "Aastha_09",
                        "content": "class Solution {\\n    public int maxProfit(int[] prices) {\\n             int profit=0;\\n             for(int i=1;i<prices.length;i++){\\n                 if(prices[i] > prices[i-1])\\n                 profit += (prices[i]-prices[i-1]);\\n\\n              \\n             }\\n     return profit;  }\\n} \\n\\n\\nCan someone tell me what to do to make this code work?\\n"
                    },
                    {
                        "username": "guptashubham-sg11",
                        "content": "This problem can also be solved using concept of greatest element on the right for every index. This way you will know what will be the maximum sell price for a buying price."
                    },
                    {
                        "username": "aryandsheth",
                        "content": "python"
                    },
                    {
                        "username": "thatslokesh1",
                        "content": "Input\\nprices =[2,4,1]\\n\\nOutput\\n0\\nExpected\\n2\\nsomeone  please  explain??"
                    },
                    {
                        "username": "ShaggyRobot",
                        "content": "You buy at 2, sell at 4. Max profit is 2."
                    },
                    {
                        "username": "s0me1",
                        "content": "I don\\'t understand why the input [1,2]  expected output is 1?"
                    },
                    {
                        "username": "Brian4755",
                        "content": "if you buy the product on day 1 (index 0, price is 1) and sell on day 2 (index 1, price is 2) your profit is 1"
                    }
                ]
            },
            {
                "id": 1794647,
                "content": [
                    {
                        "username": "kumar_Gaurav_Shrivastav",
                        "content": "i\\'m new on leetcode. can anybody tell where can i get main() of program? "
                    },
                    {
                        "username": "mohamedazizjnayah",
                        "content": "the complexity of this code must be what????"
                    },
                    {
                        "username": "SKYWITCHERY",
                        "content": "please tell me why it isnt work \nC#\n` int[] prices = { 7, 1, 5, 3, 6, 4 };\n            int maxPrice = int.MinValue;\n            int minPrice = int.MaxValue;\n            int minIndex = 0;\n            int maxIndex = 0;\n            for (int i = 0; i < prices.Length + 1; i++)\n            {\n                if (prices[i] < minPrice)\n                {\n                    minPrice = prices[i];\n                    minIndex++;\n                }\n                if (prices[i] > maxPrice)\n                {\n                    maxPrice = prices[i];\n                    maxIndex++;\n                }\n                if (maxIndex < minIndex)\n                {\n                    prices[maxIndex] = prices[minIndex];\n                }\n            }\n            Console.WriteLine(maxPrice - minPrice); `"
                    },
                    {
                        "username": "AvtarS2k2",
                        "content": "This is TLE Please tell me why and also how to improve it. `your inline code...your inline code...`\\n\\n\\nclass Solution {\\npublic:\\n    int maxProfit(vector<int>& prices) {\\n        int sum = 0;\\n      for(int i=0;i<prices.size()-1;i++){\\nfor(int j=i+1;j<prices.size();j++){\\n    if(prices[j]>prices[i]){\\n        int newSum = prices[j]-prices[i];\\n        sum = max(sum,newSum);\\n    }else{\\n        continue;\\n    }\\n}\\n      }\\n      return sum;\\n    }\\n};"
                    },
                    {
                        "username": "khandalshivang2002",
                        "content": "in this problem we just maintain smallest element from left of ith element.\\nint maxProfit(vector<int>& prices) {\\n        int res=0;\\n        int sm=prices[0];\\n        for(int i=1;i<prices.size();i++)\\n        {\\n            if(sm>prices[i]){\\n                sm=prices[i];\\n            }else if(prices[i]>sm){\\n                res=max(prices[i]-sm,res);\\n            }\\n        }\\n        return res;\\n    }"
                    },
                    {
                        "username": "Aastha_09",
                        "content": "class Solution {\\n    public int maxProfit(int[] prices) {\\n             int profit=0;\\n             for(int i=1;i<prices.length;i++){\\n                 if(prices[i] > prices[i-1])\\n                 profit += (prices[i]-prices[i-1]);\\n\\n              \\n             }\\n     return profit;  }\\n} \\n\\n\\nCan someone tell me what to do to make this code work?\\n"
                    },
                    {
                        "username": "guptashubham-sg11",
                        "content": "This problem can also be solved using concept of greatest element on the right for every index. This way you will know what will be the maximum sell price for a buying price."
                    },
                    {
                        "username": "aryandsheth",
                        "content": "python"
                    },
                    {
                        "username": "thatslokesh1",
                        "content": "Input\\nprices =[2,4,1]\\n\\nOutput\\n0\\nExpected\\n2\\nsomeone  please  explain??"
                    },
                    {
                        "username": "ShaggyRobot",
                        "content": "You buy at 2, sell at 4. Max profit is 2."
                    },
                    {
                        "username": "s0me1",
                        "content": "I don\\'t understand why the input [1,2]  expected output is 1?"
                    },
                    {
                        "username": "Brian4755",
                        "content": "if you buy the product on day 1 (index 0, price is 1) and sell on day 2 (index 1, price is 2) your profit is 1"
                    }
                ]
            },
            {
                "id": 1793462,
                "content": [
                    {
                        "username": "kumar_Gaurav_Shrivastav",
                        "content": "i\\'m new on leetcode. can anybody tell where can i get main() of program? "
                    },
                    {
                        "username": "mohamedazizjnayah",
                        "content": "the complexity of this code must be what????"
                    },
                    {
                        "username": "SKYWITCHERY",
                        "content": "please tell me why it isnt work \nC#\n` int[] prices = { 7, 1, 5, 3, 6, 4 };\n            int maxPrice = int.MinValue;\n            int minPrice = int.MaxValue;\n            int minIndex = 0;\n            int maxIndex = 0;\n            for (int i = 0; i < prices.Length + 1; i++)\n            {\n                if (prices[i] < minPrice)\n                {\n                    minPrice = prices[i];\n                    minIndex++;\n                }\n                if (prices[i] > maxPrice)\n                {\n                    maxPrice = prices[i];\n                    maxIndex++;\n                }\n                if (maxIndex < minIndex)\n                {\n                    prices[maxIndex] = prices[minIndex];\n                }\n            }\n            Console.WriteLine(maxPrice - minPrice); `"
                    },
                    {
                        "username": "AvtarS2k2",
                        "content": "This is TLE Please tell me why and also how to improve it. `your inline code...your inline code...`\\n\\n\\nclass Solution {\\npublic:\\n    int maxProfit(vector<int>& prices) {\\n        int sum = 0;\\n      for(int i=0;i<prices.size()-1;i++){\\nfor(int j=i+1;j<prices.size();j++){\\n    if(prices[j]>prices[i]){\\n        int newSum = prices[j]-prices[i];\\n        sum = max(sum,newSum);\\n    }else{\\n        continue;\\n    }\\n}\\n      }\\n      return sum;\\n    }\\n};"
                    },
                    {
                        "username": "khandalshivang2002",
                        "content": "in this problem we just maintain smallest element from left of ith element.\\nint maxProfit(vector<int>& prices) {\\n        int res=0;\\n        int sm=prices[0];\\n        for(int i=1;i<prices.size();i++)\\n        {\\n            if(sm>prices[i]){\\n                sm=prices[i];\\n            }else if(prices[i]>sm){\\n                res=max(prices[i]-sm,res);\\n            }\\n        }\\n        return res;\\n    }"
                    },
                    {
                        "username": "Aastha_09",
                        "content": "class Solution {\\n    public int maxProfit(int[] prices) {\\n             int profit=0;\\n             for(int i=1;i<prices.length;i++){\\n                 if(prices[i] > prices[i-1])\\n                 profit += (prices[i]-prices[i-1]);\\n\\n              \\n             }\\n     return profit;  }\\n} \\n\\n\\nCan someone tell me what to do to make this code work?\\n"
                    },
                    {
                        "username": "guptashubham-sg11",
                        "content": "This problem can also be solved using concept of greatest element on the right for every index. This way you will know what will be the maximum sell price for a buying price."
                    },
                    {
                        "username": "aryandsheth",
                        "content": "python"
                    },
                    {
                        "username": "thatslokesh1",
                        "content": "Input\\nprices =[2,4,1]\\n\\nOutput\\n0\\nExpected\\n2\\nsomeone  please  explain??"
                    },
                    {
                        "username": "ShaggyRobot",
                        "content": "You buy at 2, sell at 4. Max profit is 2."
                    },
                    {
                        "username": "s0me1",
                        "content": "I don\\'t understand why the input [1,2]  expected output is 1?"
                    },
                    {
                        "username": "Brian4755",
                        "content": "if you buy the product on day 1 (index 0, price is 1) and sell on day 2 (index 1, price is 2) your profit is 1"
                    }
                ]
            },
            {
                "id": 1793435,
                "content": [
                    {
                        "username": "kumar_Gaurav_Shrivastav",
                        "content": "i\\'m new on leetcode. can anybody tell where can i get main() of program? "
                    },
                    {
                        "username": "mohamedazizjnayah",
                        "content": "the complexity of this code must be what????"
                    },
                    {
                        "username": "SKYWITCHERY",
                        "content": "please tell me why it isnt work \nC#\n` int[] prices = { 7, 1, 5, 3, 6, 4 };\n            int maxPrice = int.MinValue;\n            int minPrice = int.MaxValue;\n            int minIndex = 0;\n            int maxIndex = 0;\n            for (int i = 0; i < prices.Length + 1; i++)\n            {\n                if (prices[i] < minPrice)\n                {\n                    minPrice = prices[i];\n                    minIndex++;\n                }\n                if (prices[i] > maxPrice)\n                {\n                    maxPrice = prices[i];\n                    maxIndex++;\n                }\n                if (maxIndex < minIndex)\n                {\n                    prices[maxIndex] = prices[minIndex];\n                }\n            }\n            Console.WriteLine(maxPrice - minPrice); `"
                    },
                    {
                        "username": "AvtarS2k2",
                        "content": "This is TLE Please tell me why and also how to improve it. `your inline code...your inline code...`\\n\\n\\nclass Solution {\\npublic:\\n    int maxProfit(vector<int>& prices) {\\n        int sum = 0;\\n      for(int i=0;i<prices.size()-1;i++){\\nfor(int j=i+1;j<prices.size();j++){\\n    if(prices[j]>prices[i]){\\n        int newSum = prices[j]-prices[i];\\n        sum = max(sum,newSum);\\n    }else{\\n        continue;\\n    }\\n}\\n      }\\n      return sum;\\n    }\\n};"
                    },
                    {
                        "username": "khandalshivang2002",
                        "content": "in this problem we just maintain smallest element from left of ith element.\\nint maxProfit(vector<int>& prices) {\\n        int res=0;\\n        int sm=prices[0];\\n        for(int i=1;i<prices.size();i++)\\n        {\\n            if(sm>prices[i]){\\n                sm=prices[i];\\n            }else if(prices[i]>sm){\\n                res=max(prices[i]-sm,res);\\n            }\\n        }\\n        return res;\\n    }"
                    },
                    {
                        "username": "Aastha_09",
                        "content": "class Solution {\\n    public int maxProfit(int[] prices) {\\n             int profit=0;\\n             for(int i=1;i<prices.length;i++){\\n                 if(prices[i] > prices[i-1])\\n                 profit += (prices[i]-prices[i-1]);\\n\\n              \\n             }\\n     return profit;  }\\n} \\n\\n\\nCan someone tell me what to do to make this code work?\\n"
                    },
                    {
                        "username": "guptashubham-sg11",
                        "content": "This problem can also be solved using concept of greatest element on the right for every index. This way you will know what will be the maximum sell price for a buying price."
                    },
                    {
                        "username": "aryandsheth",
                        "content": "python"
                    },
                    {
                        "username": "thatslokesh1",
                        "content": "Input\\nprices =[2,4,1]\\n\\nOutput\\n0\\nExpected\\n2\\nsomeone  please  explain??"
                    },
                    {
                        "username": "ShaggyRobot",
                        "content": "You buy at 2, sell at 4. Max profit is 2."
                    },
                    {
                        "username": "s0me1",
                        "content": "I don\\'t understand why the input [1,2]  expected output is 1?"
                    },
                    {
                        "username": "Brian4755",
                        "content": "if you buy the product on day 1 (index 0, price is 1) and sell on day 2 (index 1, price is 2) your profit is 1"
                    }
                ]
            },
            {
                "id": 1793434,
                "content": [
                    {
                        "username": "kumar_Gaurav_Shrivastav",
                        "content": "i\\'m new on leetcode. can anybody tell where can i get main() of program? "
                    },
                    {
                        "username": "mohamedazizjnayah",
                        "content": "the complexity of this code must be what????"
                    },
                    {
                        "username": "SKYWITCHERY",
                        "content": "please tell me why it isnt work \nC#\n` int[] prices = { 7, 1, 5, 3, 6, 4 };\n            int maxPrice = int.MinValue;\n            int minPrice = int.MaxValue;\n            int minIndex = 0;\n            int maxIndex = 0;\n            for (int i = 0; i < prices.Length + 1; i++)\n            {\n                if (prices[i] < minPrice)\n                {\n                    minPrice = prices[i];\n                    minIndex++;\n                }\n                if (prices[i] > maxPrice)\n                {\n                    maxPrice = prices[i];\n                    maxIndex++;\n                }\n                if (maxIndex < minIndex)\n                {\n                    prices[maxIndex] = prices[minIndex];\n                }\n            }\n            Console.WriteLine(maxPrice - minPrice); `"
                    },
                    {
                        "username": "AvtarS2k2",
                        "content": "This is TLE Please tell me why and also how to improve it. `your inline code...your inline code...`\\n\\n\\nclass Solution {\\npublic:\\n    int maxProfit(vector<int>& prices) {\\n        int sum = 0;\\n      for(int i=0;i<prices.size()-1;i++){\\nfor(int j=i+1;j<prices.size();j++){\\n    if(prices[j]>prices[i]){\\n        int newSum = prices[j]-prices[i];\\n        sum = max(sum,newSum);\\n    }else{\\n        continue;\\n    }\\n}\\n      }\\n      return sum;\\n    }\\n};"
                    },
                    {
                        "username": "khandalshivang2002",
                        "content": "in this problem we just maintain smallest element from left of ith element.\\nint maxProfit(vector<int>& prices) {\\n        int res=0;\\n        int sm=prices[0];\\n        for(int i=1;i<prices.size();i++)\\n        {\\n            if(sm>prices[i]){\\n                sm=prices[i];\\n            }else if(prices[i]>sm){\\n                res=max(prices[i]-sm,res);\\n            }\\n        }\\n        return res;\\n    }"
                    },
                    {
                        "username": "Aastha_09",
                        "content": "class Solution {\\n    public int maxProfit(int[] prices) {\\n             int profit=0;\\n             for(int i=1;i<prices.length;i++){\\n                 if(prices[i] > prices[i-1])\\n                 profit += (prices[i]-prices[i-1]);\\n\\n              \\n             }\\n     return profit;  }\\n} \\n\\n\\nCan someone tell me what to do to make this code work?\\n"
                    },
                    {
                        "username": "guptashubham-sg11",
                        "content": "This problem can also be solved using concept of greatest element on the right for every index. This way you will know what will be the maximum sell price for a buying price."
                    },
                    {
                        "username": "aryandsheth",
                        "content": "python"
                    },
                    {
                        "username": "thatslokesh1",
                        "content": "Input\\nprices =[2,4,1]\\n\\nOutput\\n0\\nExpected\\n2\\nsomeone  please  explain??"
                    },
                    {
                        "username": "ShaggyRobot",
                        "content": "You buy at 2, sell at 4. Max profit is 2."
                    },
                    {
                        "username": "s0me1",
                        "content": "I don\\'t understand why the input [1,2]  expected output is 1?"
                    },
                    {
                        "username": "Brian4755",
                        "content": "if you buy the product on day 1 (index 0, price is 1) and sell on day 2 (index 1, price is 2) your profit is 1"
                    }
                ]
            },
            {
                "id": 1791443,
                "content": [
                    {
                        "username": "kumar_Gaurav_Shrivastav",
                        "content": "i\\'m new on leetcode. can anybody tell where can i get main() of program? "
                    },
                    {
                        "username": "mohamedazizjnayah",
                        "content": "the complexity of this code must be what????"
                    },
                    {
                        "username": "SKYWITCHERY",
                        "content": "please tell me why it isnt work \nC#\n` int[] prices = { 7, 1, 5, 3, 6, 4 };\n            int maxPrice = int.MinValue;\n            int minPrice = int.MaxValue;\n            int minIndex = 0;\n            int maxIndex = 0;\n            for (int i = 0; i < prices.Length + 1; i++)\n            {\n                if (prices[i] < minPrice)\n                {\n                    minPrice = prices[i];\n                    minIndex++;\n                }\n                if (prices[i] > maxPrice)\n                {\n                    maxPrice = prices[i];\n                    maxIndex++;\n                }\n                if (maxIndex < minIndex)\n                {\n                    prices[maxIndex] = prices[minIndex];\n                }\n            }\n            Console.WriteLine(maxPrice - minPrice); `"
                    },
                    {
                        "username": "AvtarS2k2",
                        "content": "This is TLE Please tell me why and also how to improve it. `your inline code...your inline code...`\\n\\n\\nclass Solution {\\npublic:\\n    int maxProfit(vector<int>& prices) {\\n        int sum = 0;\\n      for(int i=0;i<prices.size()-1;i++){\\nfor(int j=i+1;j<prices.size();j++){\\n    if(prices[j]>prices[i]){\\n        int newSum = prices[j]-prices[i];\\n        sum = max(sum,newSum);\\n    }else{\\n        continue;\\n    }\\n}\\n      }\\n      return sum;\\n    }\\n};"
                    },
                    {
                        "username": "khandalshivang2002",
                        "content": "in this problem we just maintain smallest element from left of ith element.\\nint maxProfit(vector<int>& prices) {\\n        int res=0;\\n        int sm=prices[0];\\n        for(int i=1;i<prices.size();i++)\\n        {\\n            if(sm>prices[i]){\\n                sm=prices[i];\\n            }else if(prices[i]>sm){\\n                res=max(prices[i]-sm,res);\\n            }\\n        }\\n        return res;\\n    }"
                    },
                    {
                        "username": "Aastha_09",
                        "content": "class Solution {\\n    public int maxProfit(int[] prices) {\\n             int profit=0;\\n             for(int i=1;i<prices.length;i++){\\n                 if(prices[i] > prices[i-1])\\n                 profit += (prices[i]-prices[i-1]);\\n\\n              \\n             }\\n     return profit;  }\\n} \\n\\n\\nCan someone tell me what to do to make this code work?\\n"
                    },
                    {
                        "username": "guptashubham-sg11",
                        "content": "This problem can also be solved using concept of greatest element on the right for every index. This way you will know what will be the maximum sell price for a buying price."
                    },
                    {
                        "username": "aryandsheth",
                        "content": "python"
                    },
                    {
                        "username": "thatslokesh1",
                        "content": "Input\\nprices =[2,4,1]\\n\\nOutput\\n0\\nExpected\\n2\\nsomeone  please  explain??"
                    },
                    {
                        "username": "ShaggyRobot",
                        "content": "You buy at 2, sell at 4. Max profit is 2."
                    },
                    {
                        "username": "s0me1",
                        "content": "I don\\'t understand why the input [1,2]  expected output is 1?"
                    },
                    {
                        "username": "Brian4755",
                        "content": "if you buy the product on day 1 (index 0, price is 1) and sell on day 2 (index 1, price is 2) your profit is 1"
                    }
                ]
            },
            {
                "id": 1790740,
                "content": [
                    {
                        "username": "kumar_Gaurav_Shrivastav",
                        "content": "i\\'m new on leetcode. can anybody tell where can i get main() of program? "
                    },
                    {
                        "username": "mohamedazizjnayah",
                        "content": "the complexity of this code must be what????"
                    },
                    {
                        "username": "SKYWITCHERY",
                        "content": "please tell me why it isnt work \nC#\n` int[] prices = { 7, 1, 5, 3, 6, 4 };\n            int maxPrice = int.MinValue;\n            int minPrice = int.MaxValue;\n            int minIndex = 0;\n            int maxIndex = 0;\n            for (int i = 0; i < prices.Length + 1; i++)\n            {\n                if (prices[i] < minPrice)\n                {\n                    minPrice = prices[i];\n                    minIndex++;\n                }\n                if (prices[i] > maxPrice)\n                {\n                    maxPrice = prices[i];\n                    maxIndex++;\n                }\n                if (maxIndex < minIndex)\n                {\n                    prices[maxIndex] = prices[minIndex];\n                }\n            }\n            Console.WriteLine(maxPrice - minPrice); `"
                    },
                    {
                        "username": "AvtarS2k2",
                        "content": "This is TLE Please tell me why and also how to improve it. `your inline code...your inline code...`\\n\\n\\nclass Solution {\\npublic:\\n    int maxProfit(vector<int>& prices) {\\n        int sum = 0;\\n      for(int i=0;i<prices.size()-1;i++){\\nfor(int j=i+1;j<prices.size();j++){\\n    if(prices[j]>prices[i]){\\n        int newSum = prices[j]-prices[i];\\n        sum = max(sum,newSum);\\n    }else{\\n        continue;\\n    }\\n}\\n      }\\n      return sum;\\n    }\\n};"
                    },
                    {
                        "username": "khandalshivang2002",
                        "content": "in this problem we just maintain smallest element from left of ith element.\\nint maxProfit(vector<int>& prices) {\\n        int res=0;\\n        int sm=prices[0];\\n        for(int i=1;i<prices.size();i++)\\n        {\\n            if(sm>prices[i]){\\n                sm=prices[i];\\n            }else if(prices[i]>sm){\\n                res=max(prices[i]-sm,res);\\n            }\\n        }\\n        return res;\\n    }"
                    },
                    {
                        "username": "Aastha_09",
                        "content": "class Solution {\\n    public int maxProfit(int[] prices) {\\n             int profit=0;\\n             for(int i=1;i<prices.length;i++){\\n                 if(prices[i] > prices[i-1])\\n                 profit += (prices[i]-prices[i-1]);\\n\\n              \\n             }\\n     return profit;  }\\n} \\n\\n\\nCan someone tell me what to do to make this code work?\\n"
                    },
                    {
                        "username": "guptashubham-sg11",
                        "content": "This problem can also be solved using concept of greatest element on the right for every index. This way you will know what will be the maximum sell price for a buying price."
                    },
                    {
                        "username": "aryandsheth",
                        "content": "python"
                    },
                    {
                        "username": "thatslokesh1",
                        "content": "Input\\nprices =[2,4,1]\\n\\nOutput\\n0\\nExpected\\n2\\nsomeone  please  explain??"
                    },
                    {
                        "username": "ShaggyRobot",
                        "content": "You buy at 2, sell at 4. Max profit is 2."
                    },
                    {
                        "username": "s0me1",
                        "content": "I don\\'t understand why the input [1,2]  expected output is 1?"
                    },
                    {
                        "username": "Brian4755",
                        "content": "if you buy the product on day 1 (index 0, price is 1) and sell on day 2 (index 1, price is 2) your profit is 1"
                    }
                ]
            },
            {
                "id": 1786557,
                "content": [
                    {
                        "username": "kumar_Gaurav_Shrivastav",
                        "content": "i\\'m new on leetcode. can anybody tell where can i get main() of program? "
                    },
                    {
                        "username": "mohamedazizjnayah",
                        "content": "the complexity of this code must be what????"
                    },
                    {
                        "username": "SKYWITCHERY",
                        "content": "please tell me why it isnt work \nC#\n` int[] prices = { 7, 1, 5, 3, 6, 4 };\n            int maxPrice = int.MinValue;\n            int minPrice = int.MaxValue;\n            int minIndex = 0;\n            int maxIndex = 0;\n            for (int i = 0; i < prices.Length + 1; i++)\n            {\n                if (prices[i] < minPrice)\n                {\n                    minPrice = prices[i];\n                    minIndex++;\n                }\n                if (prices[i] > maxPrice)\n                {\n                    maxPrice = prices[i];\n                    maxIndex++;\n                }\n                if (maxIndex < minIndex)\n                {\n                    prices[maxIndex] = prices[minIndex];\n                }\n            }\n            Console.WriteLine(maxPrice - minPrice); `"
                    },
                    {
                        "username": "AvtarS2k2",
                        "content": "This is TLE Please tell me why and also how to improve it. `your inline code...your inline code...`\\n\\n\\nclass Solution {\\npublic:\\n    int maxProfit(vector<int>& prices) {\\n        int sum = 0;\\n      for(int i=0;i<prices.size()-1;i++){\\nfor(int j=i+1;j<prices.size();j++){\\n    if(prices[j]>prices[i]){\\n        int newSum = prices[j]-prices[i];\\n        sum = max(sum,newSum);\\n    }else{\\n        continue;\\n    }\\n}\\n      }\\n      return sum;\\n    }\\n};"
                    },
                    {
                        "username": "khandalshivang2002",
                        "content": "in this problem we just maintain smallest element from left of ith element.\\nint maxProfit(vector<int>& prices) {\\n        int res=0;\\n        int sm=prices[0];\\n        for(int i=1;i<prices.size();i++)\\n        {\\n            if(sm>prices[i]){\\n                sm=prices[i];\\n            }else if(prices[i]>sm){\\n                res=max(prices[i]-sm,res);\\n            }\\n        }\\n        return res;\\n    }"
                    },
                    {
                        "username": "Aastha_09",
                        "content": "class Solution {\\n    public int maxProfit(int[] prices) {\\n             int profit=0;\\n             for(int i=1;i<prices.length;i++){\\n                 if(prices[i] > prices[i-1])\\n                 profit += (prices[i]-prices[i-1]);\\n\\n              \\n             }\\n     return profit;  }\\n} \\n\\n\\nCan someone tell me what to do to make this code work?\\n"
                    },
                    {
                        "username": "guptashubham-sg11",
                        "content": "This problem can also be solved using concept of greatest element on the right for every index. This way you will know what will be the maximum sell price for a buying price."
                    },
                    {
                        "username": "aryandsheth",
                        "content": "python"
                    },
                    {
                        "username": "thatslokesh1",
                        "content": "Input\\nprices =[2,4,1]\\n\\nOutput\\n0\\nExpected\\n2\\nsomeone  please  explain??"
                    },
                    {
                        "username": "ShaggyRobot",
                        "content": "You buy at 2, sell at 4. Max profit is 2."
                    },
                    {
                        "username": "s0me1",
                        "content": "I don\\'t understand why the input [1,2]  expected output is 1?"
                    },
                    {
                        "username": "Brian4755",
                        "content": "if you buy the product on day 1 (index 0, price is 1) and sell on day 2 (index 1, price is 2) your profit is 1"
                    }
                ]
            },
            {
                "id": 1785995,
                "content": [
                    {
                        "username": "kumar_Gaurav_Shrivastav",
                        "content": "i\\'m new on leetcode. can anybody tell where can i get main() of program? "
                    },
                    {
                        "username": "mohamedazizjnayah",
                        "content": "the complexity of this code must be what????"
                    },
                    {
                        "username": "SKYWITCHERY",
                        "content": "please tell me why it isnt work \nC#\n` int[] prices = { 7, 1, 5, 3, 6, 4 };\n            int maxPrice = int.MinValue;\n            int minPrice = int.MaxValue;\n            int minIndex = 0;\n            int maxIndex = 0;\n            for (int i = 0; i < prices.Length + 1; i++)\n            {\n                if (prices[i] < minPrice)\n                {\n                    minPrice = prices[i];\n                    minIndex++;\n                }\n                if (prices[i] > maxPrice)\n                {\n                    maxPrice = prices[i];\n                    maxIndex++;\n                }\n                if (maxIndex < minIndex)\n                {\n                    prices[maxIndex] = prices[minIndex];\n                }\n            }\n            Console.WriteLine(maxPrice - minPrice); `"
                    },
                    {
                        "username": "AvtarS2k2",
                        "content": "This is TLE Please tell me why and also how to improve it. `your inline code...your inline code...`\\n\\n\\nclass Solution {\\npublic:\\n    int maxProfit(vector<int>& prices) {\\n        int sum = 0;\\n      for(int i=0;i<prices.size()-1;i++){\\nfor(int j=i+1;j<prices.size();j++){\\n    if(prices[j]>prices[i]){\\n        int newSum = prices[j]-prices[i];\\n        sum = max(sum,newSum);\\n    }else{\\n        continue;\\n    }\\n}\\n      }\\n      return sum;\\n    }\\n};"
                    },
                    {
                        "username": "khandalshivang2002",
                        "content": "in this problem we just maintain smallest element from left of ith element.\\nint maxProfit(vector<int>& prices) {\\n        int res=0;\\n        int sm=prices[0];\\n        for(int i=1;i<prices.size();i++)\\n        {\\n            if(sm>prices[i]){\\n                sm=prices[i];\\n            }else if(prices[i]>sm){\\n                res=max(prices[i]-sm,res);\\n            }\\n        }\\n        return res;\\n    }"
                    },
                    {
                        "username": "Aastha_09",
                        "content": "class Solution {\\n    public int maxProfit(int[] prices) {\\n             int profit=0;\\n             for(int i=1;i<prices.length;i++){\\n                 if(prices[i] > prices[i-1])\\n                 profit += (prices[i]-prices[i-1]);\\n\\n              \\n             }\\n     return profit;  }\\n} \\n\\n\\nCan someone tell me what to do to make this code work?\\n"
                    },
                    {
                        "username": "guptashubham-sg11",
                        "content": "This problem can also be solved using concept of greatest element on the right for every index. This way you will know what will be the maximum sell price for a buying price."
                    },
                    {
                        "username": "aryandsheth",
                        "content": "python"
                    },
                    {
                        "username": "thatslokesh1",
                        "content": "Input\\nprices =[2,4,1]\\n\\nOutput\\n0\\nExpected\\n2\\nsomeone  please  explain??"
                    },
                    {
                        "username": "ShaggyRobot",
                        "content": "You buy at 2, sell at 4. Max profit is 2."
                    },
                    {
                        "username": "s0me1",
                        "content": "I don\\'t understand why the input [1,2]  expected output is 1?"
                    },
                    {
                        "username": "Brian4755",
                        "content": "if you buy the product on day 1 (index 0, price is 1) and sell on day 2 (index 1, price is 2) your profit is 1"
                    }
                ]
            },
            {
                "id": 1785664,
                "content": [
                    {
                        "username": "kumar_Gaurav_Shrivastav",
                        "content": "i\\'m new on leetcode. can anybody tell where can i get main() of program? "
                    },
                    {
                        "username": "mohamedazizjnayah",
                        "content": "the complexity of this code must be what????"
                    },
                    {
                        "username": "SKYWITCHERY",
                        "content": "please tell me why it isnt work \nC#\n` int[] prices = { 7, 1, 5, 3, 6, 4 };\n            int maxPrice = int.MinValue;\n            int minPrice = int.MaxValue;\n            int minIndex = 0;\n            int maxIndex = 0;\n            for (int i = 0; i < prices.Length + 1; i++)\n            {\n                if (prices[i] < minPrice)\n                {\n                    minPrice = prices[i];\n                    minIndex++;\n                }\n                if (prices[i] > maxPrice)\n                {\n                    maxPrice = prices[i];\n                    maxIndex++;\n                }\n                if (maxIndex < minIndex)\n                {\n                    prices[maxIndex] = prices[minIndex];\n                }\n            }\n            Console.WriteLine(maxPrice - minPrice); `"
                    },
                    {
                        "username": "AvtarS2k2",
                        "content": "This is TLE Please tell me why and also how to improve it. `your inline code...your inline code...`\\n\\n\\nclass Solution {\\npublic:\\n    int maxProfit(vector<int>& prices) {\\n        int sum = 0;\\n      for(int i=0;i<prices.size()-1;i++){\\nfor(int j=i+1;j<prices.size();j++){\\n    if(prices[j]>prices[i]){\\n        int newSum = prices[j]-prices[i];\\n        sum = max(sum,newSum);\\n    }else{\\n        continue;\\n    }\\n}\\n      }\\n      return sum;\\n    }\\n};"
                    },
                    {
                        "username": "khandalshivang2002",
                        "content": "in this problem we just maintain smallest element from left of ith element.\\nint maxProfit(vector<int>& prices) {\\n        int res=0;\\n        int sm=prices[0];\\n        for(int i=1;i<prices.size();i++)\\n        {\\n            if(sm>prices[i]){\\n                sm=prices[i];\\n            }else if(prices[i]>sm){\\n                res=max(prices[i]-sm,res);\\n            }\\n        }\\n        return res;\\n    }"
                    },
                    {
                        "username": "Aastha_09",
                        "content": "class Solution {\\n    public int maxProfit(int[] prices) {\\n             int profit=0;\\n             for(int i=1;i<prices.length;i++){\\n                 if(prices[i] > prices[i-1])\\n                 profit += (prices[i]-prices[i-1]);\\n\\n              \\n             }\\n     return profit;  }\\n} \\n\\n\\nCan someone tell me what to do to make this code work?\\n"
                    },
                    {
                        "username": "guptashubham-sg11",
                        "content": "This problem can also be solved using concept of greatest element on the right for every index. This way you will know what will be the maximum sell price for a buying price."
                    },
                    {
                        "username": "aryandsheth",
                        "content": "python"
                    },
                    {
                        "username": "thatslokesh1",
                        "content": "Input\\nprices =[2,4,1]\\n\\nOutput\\n0\\nExpected\\n2\\nsomeone  please  explain??"
                    },
                    {
                        "username": "ShaggyRobot",
                        "content": "You buy at 2, sell at 4. Max profit is 2."
                    },
                    {
                        "username": "s0me1",
                        "content": "I don\\'t understand why the input [1,2]  expected output is 1?"
                    },
                    {
                        "username": "Brian4755",
                        "content": "if you buy the product on day 1 (index 0, price is 1) and sell on day 2 (index 1, price is 2) your profit is 1"
                    }
                ]
            },
            {
                "id": 1783076,
                "content": [
                    {
                        "username": "durveshpal538",
                        "content": "  int maxProfit(vector<int>& price) {\\n        int n = price.size();\\n        int profit=0;\\n        for(int i=1;i<n;i++)\\n        {\\n            if(price[i]>price[i-1])\\n            {\\n                profit += (price[i]-price[i-1]);\\n            }\\n           \\n        }\\n        return profit;\\n    }"
                    },
                    {
                        "username": "mcnugets",
                        "content": "buggy test case prevents me from compiling a code, "
                    },
                    {
                        "username": "johny_racc00n",
                        "content": "Maybe you didnt notice, but in [7,1,5,3,6,4] you\\'ll get maximum profit when you\\'ll bye when its 7 and sell when it 1, am i wrong?\\n"
                    },
                    {
                        "username": "Sujan-Koirala021",
                        "content": "Its the opposite. You get maximum loss...."
                    },
                    {
                        "username": "juansymontano",
                        "content": "The problem I encountered with this code is I tried so hard to beat O(n).\\nWay easier if I just code it without thinking of complexity."
                    },
                    {
                        "username": "harsh_k112002",
                        "content": "Since this problem explanation is not clearly made in discussion section , I would like to show you an approach to solve the problem:-\\n1. First you have to make a cheap price, let it be first element of array,\\n2. You have to also find the maxprofit. so let it initially be zero.\\n3. Now we have to iterate through the loop and find an element from which if we subtract cheap, we get the maximum profit.\\n4. While iterating we have to do the following:\\n  1. If an element is less than cheap, we have to update the cheap value, so that we can get maxprofit.\\n  2. If an element is greater than  cheap, and element - cheap is greater than maxprofit, then update maxprofit to this new value of element-cheap. \\n3. Do this until the loop ends.\\n4. Now return the maximum profit you got.\\n\\nPlease Upvote if you like my approach.\\n \\n"
                    },
                    {
                        "username": "princethet",
                        "content": "class Solution {\\npublic:\\n    int maxProfit(vector<int>& prices) {\\n        int profit,i,j,buy=INT_MAX,sell=INT_MIN;\\n        int n= prices.size(),b_d;\\n\\n        for(i=0;i<n;i++){\\n            if(buy>prices[i]){ buy = prices[i];\\n                b_d = i;\\n                }\\n        }\\n\\n        if(b_d<n){\\n            for(j=b_d;j<n;j++){\\n                if(sell<prices[j]) sell = prices[j];\\n            }\\n            profit = sell-buy;\\n            return profit;\\n        }\\n\\n        else return 0;\\n\\n         \\n    }\\n};\\n\\ncan anyone modify this code according to question???"
                    },
                    {
                        "username": "karankumar560k",
                        "content": "class Solution {\\npublic:\\n    int maxProfit(vector<int>& prices) {\\n     int maxpro=0;\\n    int minprice=prices[0];\\n    for(int i=0;i<prices.size();i++)\\n    {\\n        minprice=min(minprice,prices[i]);\\n        maxpro=max(maxpro,prices[i]-minprice);\\n        if(prices[i]-minprice < 0)\\n        {\\n            minprice = prices[i];\\n        }\\n    }\\n        return maxpro; \\n    }\\n};"
                    },
                    {
                        "username": "RinkeshKumarSinha",
                        "content": "c++ solution but giving TLE please resolve !!!\\nclass Solution {\\npublic:\\n    int maxProfit(vector<int>& prices) {\\n        vector<int>v=prices;\\n        int count=0;\\n        sort(v.begin(),v.end(),greater<int>());\\n        for(int i=0;i<v.size();i++){\\n            if(v[i]==prices[i])count++;\\n        }\\n        if(count==v.size())return 0;\\n        vector<int>G(prices.size()*prices.size());\\n        for(int i=prices.size()-1;i>0;i--){\\n            for(int j=i-1;j>=0;j--){\\n                int t_dex=prices[i]-prices[j];\\n                G.push_back(t_dex);\\n            }\\n        }\\n        sort(G.begin(),G.end(),greater<int>());\\n        for(int i=0;i<G.size();i++){\\n            if(G[i]>0)return G[i];\\n        }\\n        return 0;\\n    }\\n};"
                    },
                    {
                        "username": "dogpoglog",
                        "content": "I don\\'t understand how my solution exceeds the time limit. \\n `        maxProfit = 0\\n      \\n          \\n        \\n        for x in range(len(prices)):\\n            cheapest = min(prices[:x+1])\\n            if prices[x] - cheapest > maxProfit:\\n                maxProfit = prices[x]-cheapest\\n        return maxProfit`\\nI thought this was an O(n) solution, but it always fails at case 199."
                    },
                    {
                        "username": "bparanj",
                        "content": "Your current approach is actually O(n^2), not O(n). This is because for each iteration of the loop (n iterations), you\\'re calling the `min()` function on a slice of the prices list. This operation itself takes O(n) time because in the worst case, it needs to look at each element in the slice. So, the overall time complexity is O(n) * O(n) = O(n^2).\\n\\nTo achieve an O(n) solution, you want to keep track of the minimum price found so far and the maximum profit found so far in a single pass through the list. Here\\'s a Python solution that demonstrates this:\\n\\n```python\\ndef maxProfit(prices):\\n    min_price = float(\\'inf\\')\\n    max_profit = 0\\n    for price in prices:\\n        min_price = min(min_price, price)\\n        profit = price - min_price\\n        max_profit = max(max_profit, profit)\\n    return max_profit\\n```\\nThis solution iterates through the list once, keeping track of the minimum price and maximum profit as it goes. At each step, it checks whether the current price is less than the minimum price found so far. If it is, the current price becomes the new minimum price. Then, it calculates the profit that could be made by buying at the minimum price and selling at the current price. If this profit is more than the maximum profit found so far, it becomes the new maximum profit. This approach gives you an O(n) time complexity and O(1) space complexity."
                    },
                    {
                        "username": "ashwinpatel0808",
                        "content": "Time limit exceeded after passing 198  test cases. how to optimize?\nI used only one for loop but used sort() and copy() inside it."
                    }
                ]
            },
            {
                "id": 1780811,
                "content": [
                    {
                        "username": "durveshpal538",
                        "content": "  int maxProfit(vector<int>& price) {\\n        int n = price.size();\\n        int profit=0;\\n        for(int i=1;i<n;i++)\\n        {\\n            if(price[i]>price[i-1])\\n            {\\n                profit += (price[i]-price[i-1]);\\n            }\\n           \\n        }\\n        return profit;\\n    }"
                    },
                    {
                        "username": "mcnugets",
                        "content": "buggy test case prevents me from compiling a code, "
                    },
                    {
                        "username": "johny_racc00n",
                        "content": "Maybe you didnt notice, but in [7,1,5,3,6,4] you\\'ll get maximum profit when you\\'ll bye when its 7 and sell when it 1, am i wrong?\\n"
                    },
                    {
                        "username": "Sujan-Koirala021",
                        "content": "Its the opposite. You get maximum loss...."
                    },
                    {
                        "username": "juansymontano",
                        "content": "The problem I encountered with this code is I tried so hard to beat O(n).\\nWay easier if I just code it without thinking of complexity."
                    },
                    {
                        "username": "harsh_k112002",
                        "content": "Since this problem explanation is not clearly made in discussion section , I would like to show you an approach to solve the problem:-\\n1. First you have to make a cheap price, let it be first element of array,\\n2. You have to also find the maxprofit. so let it initially be zero.\\n3. Now we have to iterate through the loop and find an element from which if we subtract cheap, we get the maximum profit.\\n4. While iterating we have to do the following:\\n  1. If an element is less than cheap, we have to update the cheap value, so that we can get maxprofit.\\n  2. If an element is greater than  cheap, and element - cheap is greater than maxprofit, then update maxprofit to this new value of element-cheap. \\n3. Do this until the loop ends.\\n4. Now return the maximum profit you got.\\n\\nPlease Upvote if you like my approach.\\n \\n"
                    },
                    {
                        "username": "princethet",
                        "content": "class Solution {\\npublic:\\n    int maxProfit(vector<int>& prices) {\\n        int profit,i,j,buy=INT_MAX,sell=INT_MIN;\\n        int n= prices.size(),b_d;\\n\\n        for(i=0;i<n;i++){\\n            if(buy>prices[i]){ buy = prices[i];\\n                b_d = i;\\n                }\\n        }\\n\\n        if(b_d<n){\\n            for(j=b_d;j<n;j++){\\n                if(sell<prices[j]) sell = prices[j];\\n            }\\n            profit = sell-buy;\\n            return profit;\\n        }\\n\\n        else return 0;\\n\\n         \\n    }\\n};\\n\\ncan anyone modify this code according to question???"
                    },
                    {
                        "username": "karankumar560k",
                        "content": "class Solution {\\npublic:\\n    int maxProfit(vector<int>& prices) {\\n     int maxpro=0;\\n    int minprice=prices[0];\\n    for(int i=0;i<prices.size();i++)\\n    {\\n        minprice=min(minprice,prices[i]);\\n        maxpro=max(maxpro,prices[i]-minprice);\\n        if(prices[i]-minprice < 0)\\n        {\\n            minprice = prices[i];\\n        }\\n    }\\n        return maxpro; \\n    }\\n};"
                    },
                    {
                        "username": "RinkeshKumarSinha",
                        "content": "c++ solution but giving TLE please resolve !!!\\nclass Solution {\\npublic:\\n    int maxProfit(vector<int>& prices) {\\n        vector<int>v=prices;\\n        int count=0;\\n        sort(v.begin(),v.end(),greater<int>());\\n        for(int i=0;i<v.size();i++){\\n            if(v[i]==prices[i])count++;\\n        }\\n        if(count==v.size())return 0;\\n        vector<int>G(prices.size()*prices.size());\\n        for(int i=prices.size()-1;i>0;i--){\\n            for(int j=i-1;j>=0;j--){\\n                int t_dex=prices[i]-prices[j];\\n                G.push_back(t_dex);\\n            }\\n        }\\n        sort(G.begin(),G.end(),greater<int>());\\n        for(int i=0;i<G.size();i++){\\n            if(G[i]>0)return G[i];\\n        }\\n        return 0;\\n    }\\n};"
                    },
                    {
                        "username": "dogpoglog",
                        "content": "I don\\'t understand how my solution exceeds the time limit. \\n `        maxProfit = 0\\n      \\n          \\n        \\n        for x in range(len(prices)):\\n            cheapest = min(prices[:x+1])\\n            if prices[x] - cheapest > maxProfit:\\n                maxProfit = prices[x]-cheapest\\n        return maxProfit`\\nI thought this was an O(n) solution, but it always fails at case 199."
                    },
                    {
                        "username": "bparanj",
                        "content": "Your current approach is actually O(n^2), not O(n). This is because for each iteration of the loop (n iterations), you\\'re calling the `min()` function on a slice of the prices list. This operation itself takes O(n) time because in the worst case, it needs to look at each element in the slice. So, the overall time complexity is O(n) * O(n) = O(n^2).\\n\\nTo achieve an O(n) solution, you want to keep track of the minimum price found so far and the maximum profit found so far in a single pass through the list. Here\\'s a Python solution that demonstrates this:\\n\\n```python\\ndef maxProfit(prices):\\n    min_price = float(\\'inf\\')\\n    max_profit = 0\\n    for price in prices:\\n        min_price = min(min_price, price)\\n        profit = price - min_price\\n        max_profit = max(max_profit, profit)\\n    return max_profit\\n```\\nThis solution iterates through the list once, keeping track of the minimum price and maximum profit as it goes. At each step, it checks whether the current price is less than the minimum price found so far. If it is, the current price becomes the new minimum price. Then, it calculates the profit that could be made by buying at the minimum price and selling at the current price. If this profit is more than the maximum profit found so far, it becomes the new maximum profit. This approach gives you an O(n) time complexity and O(1) space complexity."
                    },
                    {
                        "username": "ashwinpatel0808",
                        "content": "Time limit exceeded after passing 198  test cases. how to optimize?\nI used only one for loop but used sort() and copy() inside it."
                    }
                ]
            },
            {
                "id": 1778201,
                "content": [
                    {
                        "username": "durveshpal538",
                        "content": "  int maxProfit(vector<int>& price) {\\n        int n = price.size();\\n        int profit=0;\\n        for(int i=1;i<n;i++)\\n        {\\n            if(price[i]>price[i-1])\\n            {\\n                profit += (price[i]-price[i-1]);\\n            }\\n           \\n        }\\n        return profit;\\n    }"
                    },
                    {
                        "username": "mcnugets",
                        "content": "buggy test case prevents me from compiling a code, "
                    },
                    {
                        "username": "johny_racc00n",
                        "content": "Maybe you didnt notice, but in [7,1,5,3,6,4] you\\'ll get maximum profit when you\\'ll bye when its 7 and sell when it 1, am i wrong?\\n"
                    },
                    {
                        "username": "Sujan-Koirala021",
                        "content": "Its the opposite. You get maximum loss...."
                    },
                    {
                        "username": "juansymontano",
                        "content": "The problem I encountered with this code is I tried so hard to beat O(n).\\nWay easier if I just code it without thinking of complexity."
                    },
                    {
                        "username": "harsh_k112002",
                        "content": "Since this problem explanation is not clearly made in discussion section , I would like to show you an approach to solve the problem:-\\n1. First you have to make a cheap price, let it be first element of array,\\n2. You have to also find the maxprofit. so let it initially be zero.\\n3. Now we have to iterate through the loop and find an element from which if we subtract cheap, we get the maximum profit.\\n4. While iterating we have to do the following:\\n  1. If an element is less than cheap, we have to update the cheap value, so that we can get maxprofit.\\n  2. If an element is greater than  cheap, and element - cheap is greater than maxprofit, then update maxprofit to this new value of element-cheap. \\n3. Do this until the loop ends.\\n4. Now return the maximum profit you got.\\n\\nPlease Upvote if you like my approach.\\n \\n"
                    },
                    {
                        "username": "princethet",
                        "content": "class Solution {\\npublic:\\n    int maxProfit(vector<int>& prices) {\\n        int profit,i,j,buy=INT_MAX,sell=INT_MIN;\\n        int n= prices.size(),b_d;\\n\\n        for(i=0;i<n;i++){\\n            if(buy>prices[i]){ buy = prices[i];\\n                b_d = i;\\n                }\\n        }\\n\\n        if(b_d<n){\\n            for(j=b_d;j<n;j++){\\n                if(sell<prices[j]) sell = prices[j];\\n            }\\n            profit = sell-buy;\\n            return profit;\\n        }\\n\\n        else return 0;\\n\\n         \\n    }\\n};\\n\\ncan anyone modify this code according to question???"
                    },
                    {
                        "username": "karankumar560k",
                        "content": "class Solution {\\npublic:\\n    int maxProfit(vector<int>& prices) {\\n     int maxpro=0;\\n    int minprice=prices[0];\\n    for(int i=0;i<prices.size();i++)\\n    {\\n        minprice=min(minprice,prices[i]);\\n        maxpro=max(maxpro,prices[i]-minprice);\\n        if(prices[i]-minprice < 0)\\n        {\\n            minprice = prices[i];\\n        }\\n    }\\n        return maxpro; \\n    }\\n};"
                    },
                    {
                        "username": "RinkeshKumarSinha",
                        "content": "c++ solution but giving TLE please resolve !!!\\nclass Solution {\\npublic:\\n    int maxProfit(vector<int>& prices) {\\n        vector<int>v=prices;\\n        int count=0;\\n        sort(v.begin(),v.end(),greater<int>());\\n        for(int i=0;i<v.size();i++){\\n            if(v[i]==prices[i])count++;\\n        }\\n        if(count==v.size())return 0;\\n        vector<int>G(prices.size()*prices.size());\\n        for(int i=prices.size()-1;i>0;i--){\\n            for(int j=i-1;j>=0;j--){\\n                int t_dex=prices[i]-prices[j];\\n                G.push_back(t_dex);\\n            }\\n        }\\n        sort(G.begin(),G.end(),greater<int>());\\n        for(int i=0;i<G.size();i++){\\n            if(G[i]>0)return G[i];\\n        }\\n        return 0;\\n    }\\n};"
                    },
                    {
                        "username": "dogpoglog",
                        "content": "I don\\'t understand how my solution exceeds the time limit. \\n `        maxProfit = 0\\n      \\n          \\n        \\n        for x in range(len(prices)):\\n            cheapest = min(prices[:x+1])\\n            if prices[x] - cheapest > maxProfit:\\n                maxProfit = prices[x]-cheapest\\n        return maxProfit`\\nI thought this was an O(n) solution, but it always fails at case 199."
                    },
                    {
                        "username": "bparanj",
                        "content": "Your current approach is actually O(n^2), not O(n). This is because for each iteration of the loop (n iterations), you\\'re calling the `min()` function on a slice of the prices list. This operation itself takes O(n) time because in the worst case, it needs to look at each element in the slice. So, the overall time complexity is O(n) * O(n) = O(n^2).\\n\\nTo achieve an O(n) solution, you want to keep track of the minimum price found so far and the maximum profit found so far in a single pass through the list. Here\\'s a Python solution that demonstrates this:\\n\\n```python\\ndef maxProfit(prices):\\n    min_price = float(\\'inf\\')\\n    max_profit = 0\\n    for price in prices:\\n        min_price = min(min_price, price)\\n        profit = price - min_price\\n        max_profit = max(max_profit, profit)\\n    return max_profit\\n```\\nThis solution iterates through the list once, keeping track of the minimum price and maximum profit as it goes. At each step, it checks whether the current price is less than the minimum price found so far. If it is, the current price becomes the new minimum price. Then, it calculates the profit that could be made by buying at the minimum price and selling at the current price. If this profit is more than the maximum profit found so far, it becomes the new maximum profit. This approach gives you an O(n) time complexity and O(1) space complexity."
                    },
                    {
                        "username": "ashwinpatel0808",
                        "content": "Time limit exceeded after passing 198  test cases. how to optimize?\nI used only one for loop but used sort() and copy() inside it."
                    }
                ]
            },
            {
                "id": 1775385,
                "content": [
                    {
                        "username": "durveshpal538",
                        "content": "  int maxProfit(vector<int>& price) {\\n        int n = price.size();\\n        int profit=0;\\n        for(int i=1;i<n;i++)\\n        {\\n            if(price[i]>price[i-1])\\n            {\\n                profit += (price[i]-price[i-1]);\\n            }\\n           \\n        }\\n        return profit;\\n    }"
                    },
                    {
                        "username": "mcnugets",
                        "content": "buggy test case prevents me from compiling a code, "
                    },
                    {
                        "username": "johny_racc00n",
                        "content": "Maybe you didnt notice, but in [7,1,5,3,6,4] you\\'ll get maximum profit when you\\'ll bye when its 7 and sell when it 1, am i wrong?\\n"
                    },
                    {
                        "username": "Sujan-Koirala021",
                        "content": "Its the opposite. You get maximum loss...."
                    },
                    {
                        "username": "juansymontano",
                        "content": "The problem I encountered with this code is I tried so hard to beat O(n).\\nWay easier if I just code it without thinking of complexity."
                    },
                    {
                        "username": "harsh_k112002",
                        "content": "Since this problem explanation is not clearly made in discussion section , I would like to show you an approach to solve the problem:-\\n1. First you have to make a cheap price, let it be first element of array,\\n2. You have to also find the maxprofit. so let it initially be zero.\\n3. Now we have to iterate through the loop and find an element from which if we subtract cheap, we get the maximum profit.\\n4. While iterating we have to do the following:\\n  1. If an element is less than cheap, we have to update the cheap value, so that we can get maxprofit.\\n  2. If an element is greater than  cheap, and element - cheap is greater than maxprofit, then update maxprofit to this new value of element-cheap. \\n3. Do this until the loop ends.\\n4. Now return the maximum profit you got.\\n\\nPlease Upvote if you like my approach.\\n \\n"
                    },
                    {
                        "username": "princethet",
                        "content": "class Solution {\\npublic:\\n    int maxProfit(vector<int>& prices) {\\n        int profit,i,j,buy=INT_MAX,sell=INT_MIN;\\n        int n= prices.size(),b_d;\\n\\n        for(i=0;i<n;i++){\\n            if(buy>prices[i]){ buy = prices[i];\\n                b_d = i;\\n                }\\n        }\\n\\n        if(b_d<n){\\n            for(j=b_d;j<n;j++){\\n                if(sell<prices[j]) sell = prices[j];\\n            }\\n            profit = sell-buy;\\n            return profit;\\n        }\\n\\n        else return 0;\\n\\n         \\n    }\\n};\\n\\ncan anyone modify this code according to question???"
                    },
                    {
                        "username": "karankumar560k",
                        "content": "class Solution {\\npublic:\\n    int maxProfit(vector<int>& prices) {\\n     int maxpro=0;\\n    int minprice=prices[0];\\n    for(int i=0;i<prices.size();i++)\\n    {\\n        minprice=min(minprice,prices[i]);\\n        maxpro=max(maxpro,prices[i]-minprice);\\n        if(prices[i]-minprice < 0)\\n        {\\n            minprice = prices[i];\\n        }\\n    }\\n        return maxpro; \\n    }\\n};"
                    },
                    {
                        "username": "RinkeshKumarSinha",
                        "content": "c++ solution but giving TLE please resolve !!!\\nclass Solution {\\npublic:\\n    int maxProfit(vector<int>& prices) {\\n        vector<int>v=prices;\\n        int count=0;\\n        sort(v.begin(),v.end(),greater<int>());\\n        for(int i=0;i<v.size();i++){\\n            if(v[i]==prices[i])count++;\\n        }\\n        if(count==v.size())return 0;\\n        vector<int>G(prices.size()*prices.size());\\n        for(int i=prices.size()-1;i>0;i--){\\n            for(int j=i-1;j>=0;j--){\\n                int t_dex=prices[i]-prices[j];\\n                G.push_back(t_dex);\\n            }\\n        }\\n        sort(G.begin(),G.end(),greater<int>());\\n        for(int i=0;i<G.size();i++){\\n            if(G[i]>0)return G[i];\\n        }\\n        return 0;\\n    }\\n};"
                    },
                    {
                        "username": "dogpoglog",
                        "content": "I don\\'t understand how my solution exceeds the time limit. \\n `        maxProfit = 0\\n      \\n          \\n        \\n        for x in range(len(prices)):\\n            cheapest = min(prices[:x+1])\\n            if prices[x] - cheapest > maxProfit:\\n                maxProfit = prices[x]-cheapest\\n        return maxProfit`\\nI thought this was an O(n) solution, but it always fails at case 199."
                    },
                    {
                        "username": "bparanj",
                        "content": "Your current approach is actually O(n^2), not O(n). This is because for each iteration of the loop (n iterations), you\\'re calling the `min()` function on a slice of the prices list. This operation itself takes O(n) time because in the worst case, it needs to look at each element in the slice. So, the overall time complexity is O(n) * O(n) = O(n^2).\\n\\nTo achieve an O(n) solution, you want to keep track of the minimum price found so far and the maximum profit found so far in a single pass through the list. Here\\'s a Python solution that demonstrates this:\\n\\n```python\\ndef maxProfit(prices):\\n    min_price = float(\\'inf\\')\\n    max_profit = 0\\n    for price in prices:\\n        min_price = min(min_price, price)\\n        profit = price - min_price\\n        max_profit = max(max_profit, profit)\\n    return max_profit\\n```\\nThis solution iterates through the list once, keeping track of the minimum price and maximum profit as it goes. At each step, it checks whether the current price is less than the minimum price found so far. If it is, the current price becomes the new minimum price. Then, it calculates the profit that could be made by buying at the minimum price and selling at the current price. If this profit is more than the maximum profit found so far, it becomes the new maximum profit. This approach gives you an O(n) time complexity and O(1) space complexity."
                    },
                    {
                        "username": "ashwinpatel0808",
                        "content": "Time limit exceeded after passing 198  test cases. how to optimize?\nI used only one for loop but used sort() and copy() inside it."
                    }
                ]
            },
            {
                "id": 1775328,
                "content": [
                    {
                        "username": "durveshpal538",
                        "content": "  int maxProfit(vector<int>& price) {\\n        int n = price.size();\\n        int profit=0;\\n        for(int i=1;i<n;i++)\\n        {\\n            if(price[i]>price[i-1])\\n            {\\n                profit += (price[i]-price[i-1]);\\n            }\\n           \\n        }\\n        return profit;\\n    }"
                    },
                    {
                        "username": "mcnugets",
                        "content": "buggy test case prevents me from compiling a code, "
                    },
                    {
                        "username": "johny_racc00n",
                        "content": "Maybe you didnt notice, but in [7,1,5,3,6,4] you\\'ll get maximum profit when you\\'ll bye when its 7 and sell when it 1, am i wrong?\\n"
                    },
                    {
                        "username": "Sujan-Koirala021",
                        "content": "Its the opposite. You get maximum loss...."
                    },
                    {
                        "username": "juansymontano",
                        "content": "The problem I encountered with this code is I tried so hard to beat O(n).\\nWay easier if I just code it without thinking of complexity."
                    },
                    {
                        "username": "harsh_k112002",
                        "content": "Since this problem explanation is not clearly made in discussion section , I would like to show you an approach to solve the problem:-\\n1. First you have to make a cheap price, let it be first element of array,\\n2. You have to also find the maxprofit. so let it initially be zero.\\n3. Now we have to iterate through the loop and find an element from which if we subtract cheap, we get the maximum profit.\\n4. While iterating we have to do the following:\\n  1. If an element is less than cheap, we have to update the cheap value, so that we can get maxprofit.\\n  2. If an element is greater than  cheap, and element - cheap is greater than maxprofit, then update maxprofit to this new value of element-cheap. \\n3. Do this until the loop ends.\\n4. Now return the maximum profit you got.\\n\\nPlease Upvote if you like my approach.\\n \\n"
                    },
                    {
                        "username": "princethet",
                        "content": "class Solution {\\npublic:\\n    int maxProfit(vector<int>& prices) {\\n        int profit,i,j,buy=INT_MAX,sell=INT_MIN;\\n        int n= prices.size(),b_d;\\n\\n        for(i=0;i<n;i++){\\n            if(buy>prices[i]){ buy = prices[i];\\n                b_d = i;\\n                }\\n        }\\n\\n        if(b_d<n){\\n            for(j=b_d;j<n;j++){\\n                if(sell<prices[j]) sell = prices[j];\\n            }\\n            profit = sell-buy;\\n            return profit;\\n        }\\n\\n        else return 0;\\n\\n         \\n    }\\n};\\n\\ncan anyone modify this code according to question???"
                    },
                    {
                        "username": "karankumar560k",
                        "content": "class Solution {\\npublic:\\n    int maxProfit(vector<int>& prices) {\\n     int maxpro=0;\\n    int minprice=prices[0];\\n    for(int i=0;i<prices.size();i++)\\n    {\\n        minprice=min(minprice,prices[i]);\\n        maxpro=max(maxpro,prices[i]-minprice);\\n        if(prices[i]-minprice < 0)\\n        {\\n            minprice = prices[i];\\n        }\\n    }\\n        return maxpro; \\n    }\\n};"
                    },
                    {
                        "username": "RinkeshKumarSinha",
                        "content": "c++ solution but giving TLE please resolve !!!\\nclass Solution {\\npublic:\\n    int maxProfit(vector<int>& prices) {\\n        vector<int>v=prices;\\n        int count=0;\\n        sort(v.begin(),v.end(),greater<int>());\\n        for(int i=0;i<v.size();i++){\\n            if(v[i]==prices[i])count++;\\n        }\\n        if(count==v.size())return 0;\\n        vector<int>G(prices.size()*prices.size());\\n        for(int i=prices.size()-1;i>0;i--){\\n            for(int j=i-1;j>=0;j--){\\n                int t_dex=prices[i]-prices[j];\\n                G.push_back(t_dex);\\n            }\\n        }\\n        sort(G.begin(),G.end(),greater<int>());\\n        for(int i=0;i<G.size();i++){\\n            if(G[i]>0)return G[i];\\n        }\\n        return 0;\\n    }\\n};"
                    },
                    {
                        "username": "dogpoglog",
                        "content": "I don\\'t understand how my solution exceeds the time limit. \\n `        maxProfit = 0\\n      \\n          \\n        \\n        for x in range(len(prices)):\\n            cheapest = min(prices[:x+1])\\n            if prices[x] - cheapest > maxProfit:\\n                maxProfit = prices[x]-cheapest\\n        return maxProfit`\\nI thought this was an O(n) solution, but it always fails at case 199."
                    },
                    {
                        "username": "bparanj",
                        "content": "Your current approach is actually O(n^2), not O(n). This is because for each iteration of the loop (n iterations), you\\'re calling the `min()` function on a slice of the prices list. This operation itself takes O(n) time because in the worst case, it needs to look at each element in the slice. So, the overall time complexity is O(n) * O(n) = O(n^2).\\n\\nTo achieve an O(n) solution, you want to keep track of the minimum price found so far and the maximum profit found so far in a single pass through the list. Here\\'s a Python solution that demonstrates this:\\n\\n```python\\ndef maxProfit(prices):\\n    min_price = float(\\'inf\\')\\n    max_profit = 0\\n    for price in prices:\\n        min_price = min(min_price, price)\\n        profit = price - min_price\\n        max_profit = max(max_profit, profit)\\n    return max_profit\\n```\\nThis solution iterates through the list once, keeping track of the minimum price and maximum profit as it goes. At each step, it checks whether the current price is less than the minimum price found so far. If it is, the current price becomes the new minimum price. Then, it calculates the profit that could be made by buying at the minimum price and selling at the current price. If this profit is more than the maximum profit found so far, it becomes the new maximum profit. This approach gives you an O(n) time complexity and O(1) space complexity."
                    },
                    {
                        "username": "ashwinpatel0808",
                        "content": "Time limit exceeded after passing 198  test cases. how to optimize?\nI used only one for loop but used sort() and copy() inside it."
                    }
                ]
            },
            {
                "id": 1774233,
                "content": [
                    {
                        "username": "durveshpal538",
                        "content": "  int maxProfit(vector<int>& price) {\\n        int n = price.size();\\n        int profit=0;\\n        for(int i=1;i<n;i++)\\n        {\\n            if(price[i]>price[i-1])\\n            {\\n                profit += (price[i]-price[i-1]);\\n            }\\n           \\n        }\\n        return profit;\\n    }"
                    },
                    {
                        "username": "mcnugets",
                        "content": "buggy test case prevents me from compiling a code, "
                    },
                    {
                        "username": "johny_racc00n",
                        "content": "Maybe you didnt notice, but in [7,1,5,3,6,4] you\\'ll get maximum profit when you\\'ll bye when its 7 and sell when it 1, am i wrong?\\n"
                    },
                    {
                        "username": "Sujan-Koirala021",
                        "content": "Its the opposite. You get maximum loss...."
                    },
                    {
                        "username": "juansymontano",
                        "content": "The problem I encountered with this code is I tried so hard to beat O(n).\\nWay easier if I just code it without thinking of complexity."
                    },
                    {
                        "username": "harsh_k112002",
                        "content": "Since this problem explanation is not clearly made in discussion section , I would like to show you an approach to solve the problem:-\\n1. First you have to make a cheap price, let it be first element of array,\\n2. You have to also find the maxprofit. so let it initially be zero.\\n3. Now we have to iterate through the loop and find an element from which if we subtract cheap, we get the maximum profit.\\n4. While iterating we have to do the following:\\n  1. If an element is less than cheap, we have to update the cheap value, so that we can get maxprofit.\\n  2. If an element is greater than  cheap, and element - cheap is greater than maxprofit, then update maxprofit to this new value of element-cheap. \\n3. Do this until the loop ends.\\n4. Now return the maximum profit you got.\\n\\nPlease Upvote if you like my approach.\\n \\n"
                    },
                    {
                        "username": "princethet",
                        "content": "class Solution {\\npublic:\\n    int maxProfit(vector<int>& prices) {\\n        int profit,i,j,buy=INT_MAX,sell=INT_MIN;\\n        int n= prices.size(),b_d;\\n\\n        for(i=0;i<n;i++){\\n            if(buy>prices[i]){ buy = prices[i];\\n                b_d = i;\\n                }\\n        }\\n\\n        if(b_d<n){\\n            for(j=b_d;j<n;j++){\\n                if(sell<prices[j]) sell = prices[j];\\n            }\\n            profit = sell-buy;\\n            return profit;\\n        }\\n\\n        else return 0;\\n\\n         \\n    }\\n};\\n\\ncan anyone modify this code according to question???"
                    },
                    {
                        "username": "karankumar560k",
                        "content": "class Solution {\\npublic:\\n    int maxProfit(vector<int>& prices) {\\n     int maxpro=0;\\n    int minprice=prices[0];\\n    for(int i=0;i<prices.size();i++)\\n    {\\n        minprice=min(minprice,prices[i]);\\n        maxpro=max(maxpro,prices[i]-minprice);\\n        if(prices[i]-minprice < 0)\\n        {\\n            minprice = prices[i];\\n        }\\n    }\\n        return maxpro; \\n    }\\n};"
                    },
                    {
                        "username": "RinkeshKumarSinha",
                        "content": "c++ solution but giving TLE please resolve !!!\\nclass Solution {\\npublic:\\n    int maxProfit(vector<int>& prices) {\\n        vector<int>v=prices;\\n        int count=0;\\n        sort(v.begin(),v.end(),greater<int>());\\n        for(int i=0;i<v.size();i++){\\n            if(v[i]==prices[i])count++;\\n        }\\n        if(count==v.size())return 0;\\n        vector<int>G(prices.size()*prices.size());\\n        for(int i=prices.size()-1;i>0;i--){\\n            for(int j=i-1;j>=0;j--){\\n                int t_dex=prices[i]-prices[j];\\n                G.push_back(t_dex);\\n            }\\n        }\\n        sort(G.begin(),G.end(),greater<int>());\\n        for(int i=0;i<G.size();i++){\\n            if(G[i]>0)return G[i];\\n        }\\n        return 0;\\n    }\\n};"
                    },
                    {
                        "username": "dogpoglog",
                        "content": "I don\\'t understand how my solution exceeds the time limit. \\n `        maxProfit = 0\\n      \\n          \\n        \\n        for x in range(len(prices)):\\n            cheapest = min(prices[:x+1])\\n            if prices[x] - cheapest > maxProfit:\\n                maxProfit = prices[x]-cheapest\\n        return maxProfit`\\nI thought this was an O(n) solution, but it always fails at case 199."
                    },
                    {
                        "username": "bparanj",
                        "content": "Your current approach is actually O(n^2), not O(n). This is because for each iteration of the loop (n iterations), you\\'re calling the `min()` function on a slice of the prices list. This operation itself takes O(n) time because in the worst case, it needs to look at each element in the slice. So, the overall time complexity is O(n) * O(n) = O(n^2).\\n\\nTo achieve an O(n) solution, you want to keep track of the minimum price found so far and the maximum profit found so far in a single pass through the list. Here\\'s a Python solution that demonstrates this:\\n\\n```python\\ndef maxProfit(prices):\\n    min_price = float(\\'inf\\')\\n    max_profit = 0\\n    for price in prices:\\n        min_price = min(min_price, price)\\n        profit = price - min_price\\n        max_profit = max(max_profit, profit)\\n    return max_profit\\n```\\nThis solution iterates through the list once, keeping track of the minimum price and maximum profit as it goes. At each step, it checks whether the current price is less than the minimum price found so far. If it is, the current price becomes the new minimum price. Then, it calculates the profit that could be made by buying at the minimum price and selling at the current price. If this profit is more than the maximum profit found so far, it becomes the new maximum profit. This approach gives you an O(n) time complexity and O(1) space complexity."
                    },
                    {
                        "username": "ashwinpatel0808",
                        "content": "Time limit exceeded after passing 198  test cases. how to optimize?\nI used only one for loop but used sort() and copy() inside it."
                    }
                ]
            },
            {
                "id": 1764660,
                "content": [
                    {
                        "username": "durveshpal538",
                        "content": "  int maxProfit(vector<int>& price) {\\n        int n = price.size();\\n        int profit=0;\\n        for(int i=1;i<n;i++)\\n        {\\n            if(price[i]>price[i-1])\\n            {\\n                profit += (price[i]-price[i-1]);\\n            }\\n           \\n        }\\n        return profit;\\n    }"
                    },
                    {
                        "username": "mcnugets",
                        "content": "buggy test case prevents me from compiling a code, "
                    },
                    {
                        "username": "johny_racc00n",
                        "content": "Maybe you didnt notice, but in [7,1,5,3,6,4] you\\'ll get maximum profit when you\\'ll bye when its 7 and sell when it 1, am i wrong?\\n"
                    },
                    {
                        "username": "Sujan-Koirala021",
                        "content": "Its the opposite. You get maximum loss...."
                    },
                    {
                        "username": "juansymontano",
                        "content": "The problem I encountered with this code is I tried so hard to beat O(n).\\nWay easier if I just code it without thinking of complexity."
                    },
                    {
                        "username": "harsh_k112002",
                        "content": "Since this problem explanation is not clearly made in discussion section , I would like to show you an approach to solve the problem:-\\n1. First you have to make a cheap price, let it be first element of array,\\n2. You have to also find the maxprofit. so let it initially be zero.\\n3. Now we have to iterate through the loop and find an element from which if we subtract cheap, we get the maximum profit.\\n4. While iterating we have to do the following:\\n  1. If an element is less than cheap, we have to update the cheap value, so that we can get maxprofit.\\n  2. If an element is greater than  cheap, and element - cheap is greater than maxprofit, then update maxprofit to this new value of element-cheap. \\n3. Do this until the loop ends.\\n4. Now return the maximum profit you got.\\n\\nPlease Upvote if you like my approach.\\n \\n"
                    },
                    {
                        "username": "princethet",
                        "content": "class Solution {\\npublic:\\n    int maxProfit(vector<int>& prices) {\\n        int profit,i,j,buy=INT_MAX,sell=INT_MIN;\\n        int n= prices.size(),b_d;\\n\\n        for(i=0;i<n;i++){\\n            if(buy>prices[i]){ buy = prices[i];\\n                b_d = i;\\n                }\\n        }\\n\\n        if(b_d<n){\\n            for(j=b_d;j<n;j++){\\n                if(sell<prices[j]) sell = prices[j];\\n            }\\n            profit = sell-buy;\\n            return profit;\\n        }\\n\\n        else return 0;\\n\\n         \\n    }\\n};\\n\\ncan anyone modify this code according to question???"
                    },
                    {
                        "username": "karankumar560k",
                        "content": "class Solution {\\npublic:\\n    int maxProfit(vector<int>& prices) {\\n     int maxpro=0;\\n    int minprice=prices[0];\\n    for(int i=0;i<prices.size();i++)\\n    {\\n        minprice=min(minprice,prices[i]);\\n        maxpro=max(maxpro,prices[i]-minprice);\\n        if(prices[i]-minprice < 0)\\n        {\\n            minprice = prices[i];\\n        }\\n    }\\n        return maxpro; \\n    }\\n};"
                    },
                    {
                        "username": "RinkeshKumarSinha",
                        "content": "c++ solution but giving TLE please resolve !!!\\nclass Solution {\\npublic:\\n    int maxProfit(vector<int>& prices) {\\n        vector<int>v=prices;\\n        int count=0;\\n        sort(v.begin(),v.end(),greater<int>());\\n        for(int i=0;i<v.size();i++){\\n            if(v[i]==prices[i])count++;\\n        }\\n        if(count==v.size())return 0;\\n        vector<int>G(prices.size()*prices.size());\\n        for(int i=prices.size()-1;i>0;i--){\\n            for(int j=i-1;j>=0;j--){\\n                int t_dex=prices[i]-prices[j];\\n                G.push_back(t_dex);\\n            }\\n        }\\n        sort(G.begin(),G.end(),greater<int>());\\n        for(int i=0;i<G.size();i++){\\n            if(G[i]>0)return G[i];\\n        }\\n        return 0;\\n    }\\n};"
                    },
                    {
                        "username": "dogpoglog",
                        "content": "I don\\'t understand how my solution exceeds the time limit. \\n `        maxProfit = 0\\n      \\n          \\n        \\n        for x in range(len(prices)):\\n            cheapest = min(prices[:x+1])\\n            if prices[x] - cheapest > maxProfit:\\n                maxProfit = prices[x]-cheapest\\n        return maxProfit`\\nI thought this was an O(n) solution, but it always fails at case 199."
                    },
                    {
                        "username": "bparanj",
                        "content": "Your current approach is actually O(n^2), not O(n). This is because for each iteration of the loop (n iterations), you\\'re calling the `min()` function on a slice of the prices list. This operation itself takes O(n) time because in the worst case, it needs to look at each element in the slice. So, the overall time complexity is O(n) * O(n) = O(n^2).\\n\\nTo achieve an O(n) solution, you want to keep track of the minimum price found so far and the maximum profit found so far in a single pass through the list. Here\\'s a Python solution that demonstrates this:\\n\\n```python\\ndef maxProfit(prices):\\n    min_price = float(\\'inf\\')\\n    max_profit = 0\\n    for price in prices:\\n        min_price = min(min_price, price)\\n        profit = price - min_price\\n        max_profit = max(max_profit, profit)\\n    return max_profit\\n```\\nThis solution iterates through the list once, keeping track of the minimum price and maximum profit as it goes. At each step, it checks whether the current price is less than the minimum price found so far. If it is, the current price becomes the new minimum price. Then, it calculates the profit that could be made by buying at the minimum price and selling at the current price. If this profit is more than the maximum profit found so far, it becomes the new maximum profit. This approach gives you an O(n) time complexity and O(1) space complexity."
                    },
                    {
                        "username": "ashwinpatel0808",
                        "content": "Time limit exceeded after passing 198  test cases. how to optimize?\nI used only one for loop but used sort() and copy() inside it."
                    }
                ]
            },
            {
                "id": 1764204,
                "content": [
                    {
                        "username": "durveshpal538",
                        "content": "  int maxProfit(vector<int>& price) {\\n        int n = price.size();\\n        int profit=0;\\n        for(int i=1;i<n;i++)\\n        {\\n            if(price[i]>price[i-1])\\n            {\\n                profit += (price[i]-price[i-1]);\\n            }\\n           \\n        }\\n        return profit;\\n    }"
                    },
                    {
                        "username": "mcnugets",
                        "content": "buggy test case prevents me from compiling a code, "
                    },
                    {
                        "username": "johny_racc00n",
                        "content": "Maybe you didnt notice, but in [7,1,5,3,6,4] you\\'ll get maximum profit when you\\'ll bye when its 7 and sell when it 1, am i wrong?\\n"
                    },
                    {
                        "username": "Sujan-Koirala021",
                        "content": "Its the opposite. You get maximum loss...."
                    },
                    {
                        "username": "juansymontano",
                        "content": "The problem I encountered with this code is I tried so hard to beat O(n).\\nWay easier if I just code it without thinking of complexity."
                    },
                    {
                        "username": "harsh_k112002",
                        "content": "Since this problem explanation is not clearly made in discussion section , I would like to show you an approach to solve the problem:-\\n1. First you have to make a cheap price, let it be first element of array,\\n2. You have to also find the maxprofit. so let it initially be zero.\\n3. Now we have to iterate through the loop and find an element from which if we subtract cheap, we get the maximum profit.\\n4. While iterating we have to do the following:\\n  1. If an element is less than cheap, we have to update the cheap value, so that we can get maxprofit.\\n  2. If an element is greater than  cheap, and element - cheap is greater than maxprofit, then update maxprofit to this new value of element-cheap. \\n3. Do this until the loop ends.\\n4. Now return the maximum profit you got.\\n\\nPlease Upvote if you like my approach.\\n \\n"
                    },
                    {
                        "username": "princethet",
                        "content": "class Solution {\\npublic:\\n    int maxProfit(vector<int>& prices) {\\n        int profit,i,j,buy=INT_MAX,sell=INT_MIN;\\n        int n= prices.size(),b_d;\\n\\n        for(i=0;i<n;i++){\\n            if(buy>prices[i]){ buy = prices[i];\\n                b_d = i;\\n                }\\n        }\\n\\n        if(b_d<n){\\n            for(j=b_d;j<n;j++){\\n                if(sell<prices[j]) sell = prices[j];\\n            }\\n            profit = sell-buy;\\n            return profit;\\n        }\\n\\n        else return 0;\\n\\n         \\n    }\\n};\\n\\ncan anyone modify this code according to question???"
                    },
                    {
                        "username": "karankumar560k",
                        "content": "class Solution {\\npublic:\\n    int maxProfit(vector<int>& prices) {\\n     int maxpro=0;\\n    int minprice=prices[0];\\n    for(int i=0;i<prices.size();i++)\\n    {\\n        minprice=min(minprice,prices[i]);\\n        maxpro=max(maxpro,prices[i]-minprice);\\n        if(prices[i]-minprice < 0)\\n        {\\n            minprice = prices[i];\\n        }\\n    }\\n        return maxpro; \\n    }\\n};"
                    },
                    {
                        "username": "RinkeshKumarSinha",
                        "content": "c++ solution but giving TLE please resolve !!!\\nclass Solution {\\npublic:\\n    int maxProfit(vector<int>& prices) {\\n        vector<int>v=prices;\\n        int count=0;\\n        sort(v.begin(),v.end(),greater<int>());\\n        for(int i=0;i<v.size();i++){\\n            if(v[i]==prices[i])count++;\\n        }\\n        if(count==v.size())return 0;\\n        vector<int>G(prices.size()*prices.size());\\n        for(int i=prices.size()-1;i>0;i--){\\n            for(int j=i-1;j>=0;j--){\\n                int t_dex=prices[i]-prices[j];\\n                G.push_back(t_dex);\\n            }\\n        }\\n        sort(G.begin(),G.end(),greater<int>());\\n        for(int i=0;i<G.size();i++){\\n            if(G[i]>0)return G[i];\\n        }\\n        return 0;\\n    }\\n};"
                    },
                    {
                        "username": "dogpoglog",
                        "content": "I don\\'t understand how my solution exceeds the time limit. \\n `        maxProfit = 0\\n      \\n          \\n        \\n        for x in range(len(prices)):\\n            cheapest = min(prices[:x+1])\\n            if prices[x] - cheapest > maxProfit:\\n                maxProfit = prices[x]-cheapest\\n        return maxProfit`\\nI thought this was an O(n) solution, but it always fails at case 199."
                    },
                    {
                        "username": "bparanj",
                        "content": "Your current approach is actually O(n^2), not O(n). This is because for each iteration of the loop (n iterations), you\\'re calling the `min()` function on a slice of the prices list. This operation itself takes O(n) time because in the worst case, it needs to look at each element in the slice. So, the overall time complexity is O(n) * O(n) = O(n^2).\\n\\nTo achieve an O(n) solution, you want to keep track of the minimum price found so far and the maximum profit found so far in a single pass through the list. Here\\'s a Python solution that demonstrates this:\\n\\n```python\\ndef maxProfit(prices):\\n    min_price = float(\\'inf\\')\\n    max_profit = 0\\n    for price in prices:\\n        min_price = min(min_price, price)\\n        profit = price - min_price\\n        max_profit = max(max_profit, profit)\\n    return max_profit\\n```\\nThis solution iterates through the list once, keeping track of the minimum price and maximum profit as it goes. At each step, it checks whether the current price is less than the minimum price found so far. If it is, the current price becomes the new minimum price. Then, it calculates the profit that could be made by buying at the minimum price and selling at the current price. If this profit is more than the maximum profit found so far, it becomes the new maximum profit. This approach gives you an O(n) time complexity and O(1) space complexity."
                    },
                    {
                        "username": "ashwinpatel0808",
                        "content": "Time limit exceeded after passing 198  test cases. how to optimize?\nI used only one for loop but used sort() and copy() inside it."
                    }
                ]
            },
            {
                "id": 1763557,
                "content": [
                    {
                        "username": "durveshpal538",
                        "content": "  int maxProfit(vector<int>& price) {\\n        int n = price.size();\\n        int profit=0;\\n        for(int i=1;i<n;i++)\\n        {\\n            if(price[i]>price[i-1])\\n            {\\n                profit += (price[i]-price[i-1]);\\n            }\\n           \\n        }\\n        return profit;\\n    }"
                    },
                    {
                        "username": "mcnugets",
                        "content": "buggy test case prevents me from compiling a code, "
                    },
                    {
                        "username": "johny_racc00n",
                        "content": "Maybe you didnt notice, but in [7,1,5,3,6,4] you\\'ll get maximum profit when you\\'ll bye when its 7 and sell when it 1, am i wrong?\\n"
                    },
                    {
                        "username": "Sujan-Koirala021",
                        "content": "Its the opposite. You get maximum loss...."
                    },
                    {
                        "username": "juansymontano",
                        "content": "The problem I encountered with this code is I tried so hard to beat O(n).\\nWay easier if I just code it without thinking of complexity."
                    },
                    {
                        "username": "harsh_k112002",
                        "content": "Since this problem explanation is not clearly made in discussion section , I would like to show you an approach to solve the problem:-\\n1. First you have to make a cheap price, let it be first element of array,\\n2. You have to also find the maxprofit. so let it initially be zero.\\n3. Now we have to iterate through the loop and find an element from which if we subtract cheap, we get the maximum profit.\\n4. While iterating we have to do the following:\\n  1. If an element is less than cheap, we have to update the cheap value, so that we can get maxprofit.\\n  2. If an element is greater than  cheap, and element - cheap is greater than maxprofit, then update maxprofit to this new value of element-cheap. \\n3. Do this until the loop ends.\\n4. Now return the maximum profit you got.\\n\\nPlease Upvote if you like my approach.\\n \\n"
                    },
                    {
                        "username": "princethet",
                        "content": "class Solution {\\npublic:\\n    int maxProfit(vector<int>& prices) {\\n        int profit,i,j,buy=INT_MAX,sell=INT_MIN;\\n        int n= prices.size(),b_d;\\n\\n        for(i=0;i<n;i++){\\n            if(buy>prices[i]){ buy = prices[i];\\n                b_d = i;\\n                }\\n        }\\n\\n        if(b_d<n){\\n            for(j=b_d;j<n;j++){\\n                if(sell<prices[j]) sell = prices[j];\\n            }\\n            profit = sell-buy;\\n            return profit;\\n        }\\n\\n        else return 0;\\n\\n         \\n    }\\n};\\n\\ncan anyone modify this code according to question???"
                    },
                    {
                        "username": "karankumar560k",
                        "content": "class Solution {\\npublic:\\n    int maxProfit(vector<int>& prices) {\\n     int maxpro=0;\\n    int minprice=prices[0];\\n    for(int i=0;i<prices.size();i++)\\n    {\\n        minprice=min(minprice,prices[i]);\\n        maxpro=max(maxpro,prices[i]-minprice);\\n        if(prices[i]-minprice < 0)\\n        {\\n            minprice = prices[i];\\n        }\\n    }\\n        return maxpro; \\n    }\\n};"
                    },
                    {
                        "username": "RinkeshKumarSinha",
                        "content": "c++ solution but giving TLE please resolve !!!\\nclass Solution {\\npublic:\\n    int maxProfit(vector<int>& prices) {\\n        vector<int>v=prices;\\n        int count=0;\\n        sort(v.begin(),v.end(),greater<int>());\\n        for(int i=0;i<v.size();i++){\\n            if(v[i]==prices[i])count++;\\n        }\\n        if(count==v.size())return 0;\\n        vector<int>G(prices.size()*prices.size());\\n        for(int i=prices.size()-1;i>0;i--){\\n            for(int j=i-1;j>=0;j--){\\n                int t_dex=prices[i]-prices[j];\\n                G.push_back(t_dex);\\n            }\\n        }\\n        sort(G.begin(),G.end(),greater<int>());\\n        for(int i=0;i<G.size();i++){\\n            if(G[i]>0)return G[i];\\n        }\\n        return 0;\\n    }\\n};"
                    },
                    {
                        "username": "dogpoglog",
                        "content": "I don\\'t understand how my solution exceeds the time limit. \\n `        maxProfit = 0\\n      \\n          \\n        \\n        for x in range(len(prices)):\\n            cheapest = min(prices[:x+1])\\n            if prices[x] - cheapest > maxProfit:\\n                maxProfit = prices[x]-cheapest\\n        return maxProfit`\\nI thought this was an O(n) solution, but it always fails at case 199."
                    },
                    {
                        "username": "bparanj",
                        "content": "Your current approach is actually O(n^2), not O(n). This is because for each iteration of the loop (n iterations), you\\'re calling the `min()` function on a slice of the prices list. This operation itself takes O(n) time because in the worst case, it needs to look at each element in the slice. So, the overall time complexity is O(n) * O(n) = O(n^2).\\n\\nTo achieve an O(n) solution, you want to keep track of the minimum price found so far and the maximum profit found so far in a single pass through the list. Here\\'s a Python solution that demonstrates this:\\n\\n```python\\ndef maxProfit(prices):\\n    min_price = float(\\'inf\\')\\n    max_profit = 0\\n    for price in prices:\\n        min_price = min(min_price, price)\\n        profit = price - min_price\\n        max_profit = max(max_profit, profit)\\n    return max_profit\\n```\\nThis solution iterates through the list once, keeping track of the minimum price and maximum profit as it goes. At each step, it checks whether the current price is less than the minimum price found so far. If it is, the current price becomes the new minimum price. Then, it calculates the profit that could be made by buying at the minimum price and selling at the current price. If this profit is more than the maximum profit found so far, it becomes the new maximum profit. This approach gives you an O(n) time complexity and O(1) space complexity."
                    },
                    {
                        "username": "ashwinpatel0808",
                        "content": "Time limit exceeded after passing 198  test cases. how to optimize?\nI used only one for loop but used sort() and copy() inside it."
                    }
                ]
            },
            {
                "id": 1762249,
                "content": [
                    {
                        "username": "durveshpal538",
                        "content": "  int maxProfit(vector<int>& price) {\\n        int n = price.size();\\n        int profit=0;\\n        for(int i=1;i<n;i++)\\n        {\\n            if(price[i]>price[i-1])\\n            {\\n                profit += (price[i]-price[i-1]);\\n            }\\n           \\n        }\\n        return profit;\\n    }"
                    },
                    {
                        "username": "mcnugets",
                        "content": "buggy test case prevents me from compiling a code, "
                    },
                    {
                        "username": "johny_racc00n",
                        "content": "Maybe you didnt notice, but in [7,1,5,3,6,4] you\\'ll get maximum profit when you\\'ll bye when its 7 and sell when it 1, am i wrong?\\n"
                    },
                    {
                        "username": "Sujan-Koirala021",
                        "content": "Its the opposite. You get maximum loss...."
                    },
                    {
                        "username": "juansymontano",
                        "content": "The problem I encountered with this code is I tried so hard to beat O(n).\\nWay easier if I just code it without thinking of complexity."
                    },
                    {
                        "username": "harsh_k112002",
                        "content": "Since this problem explanation is not clearly made in discussion section , I would like to show you an approach to solve the problem:-\\n1. First you have to make a cheap price, let it be first element of array,\\n2. You have to also find the maxprofit. so let it initially be zero.\\n3. Now we have to iterate through the loop and find an element from which if we subtract cheap, we get the maximum profit.\\n4. While iterating we have to do the following:\\n  1. If an element is less than cheap, we have to update the cheap value, so that we can get maxprofit.\\n  2. If an element is greater than  cheap, and element - cheap is greater than maxprofit, then update maxprofit to this new value of element-cheap. \\n3. Do this until the loop ends.\\n4. Now return the maximum profit you got.\\n\\nPlease Upvote if you like my approach.\\n \\n"
                    },
                    {
                        "username": "princethet",
                        "content": "class Solution {\\npublic:\\n    int maxProfit(vector<int>& prices) {\\n        int profit,i,j,buy=INT_MAX,sell=INT_MIN;\\n        int n= prices.size(),b_d;\\n\\n        for(i=0;i<n;i++){\\n            if(buy>prices[i]){ buy = prices[i];\\n                b_d = i;\\n                }\\n        }\\n\\n        if(b_d<n){\\n            for(j=b_d;j<n;j++){\\n                if(sell<prices[j]) sell = prices[j];\\n            }\\n            profit = sell-buy;\\n            return profit;\\n        }\\n\\n        else return 0;\\n\\n         \\n    }\\n};\\n\\ncan anyone modify this code according to question???"
                    },
                    {
                        "username": "karankumar560k",
                        "content": "class Solution {\\npublic:\\n    int maxProfit(vector<int>& prices) {\\n     int maxpro=0;\\n    int minprice=prices[0];\\n    for(int i=0;i<prices.size();i++)\\n    {\\n        minprice=min(minprice,prices[i]);\\n        maxpro=max(maxpro,prices[i]-minprice);\\n        if(prices[i]-minprice < 0)\\n        {\\n            minprice = prices[i];\\n        }\\n    }\\n        return maxpro; \\n    }\\n};"
                    },
                    {
                        "username": "RinkeshKumarSinha",
                        "content": "c++ solution but giving TLE please resolve !!!\\nclass Solution {\\npublic:\\n    int maxProfit(vector<int>& prices) {\\n        vector<int>v=prices;\\n        int count=0;\\n        sort(v.begin(),v.end(),greater<int>());\\n        for(int i=0;i<v.size();i++){\\n            if(v[i]==prices[i])count++;\\n        }\\n        if(count==v.size())return 0;\\n        vector<int>G(prices.size()*prices.size());\\n        for(int i=prices.size()-1;i>0;i--){\\n            for(int j=i-1;j>=0;j--){\\n                int t_dex=prices[i]-prices[j];\\n                G.push_back(t_dex);\\n            }\\n        }\\n        sort(G.begin(),G.end(),greater<int>());\\n        for(int i=0;i<G.size();i++){\\n            if(G[i]>0)return G[i];\\n        }\\n        return 0;\\n    }\\n};"
                    },
                    {
                        "username": "dogpoglog",
                        "content": "I don\\'t understand how my solution exceeds the time limit. \\n `        maxProfit = 0\\n      \\n          \\n        \\n        for x in range(len(prices)):\\n            cheapest = min(prices[:x+1])\\n            if prices[x] - cheapest > maxProfit:\\n                maxProfit = prices[x]-cheapest\\n        return maxProfit`\\nI thought this was an O(n) solution, but it always fails at case 199."
                    },
                    {
                        "username": "bparanj",
                        "content": "Your current approach is actually O(n^2), not O(n). This is because for each iteration of the loop (n iterations), you\\'re calling the `min()` function on a slice of the prices list. This operation itself takes O(n) time because in the worst case, it needs to look at each element in the slice. So, the overall time complexity is O(n) * O(n) = O(n^2).\\n\\nTo achieve an O(n) solution, you want to keep track of the minimum price found so far and the maximum profit found so far in a single pass through the list. Here\\'s a Python solution that demonstrates this:\\n\\n```python\\ndef maxProfit(prices):\\n    min_price = float(\\'inf\\')\\n    max_profit = 0\\n    for price in prices:\\n        min_price = min(min_price, price)\\n        profit = price - min_price\\n        max_profit = max(max_profit, profit)\\n    return max_profit\\n```\\nThis solution iterates through the list once, keeping track of the minimum price and maximum profit as it goes. At each step, it checks whether the current price is less than the minimum price found so far. If it is, the current price becomes the new minimum price. Then, it calculates the profit that could be made by buying at the minimum price and selling at the current price. If this profit is more than the maximum profit found so far, it becomes the new maximum profit. This approach gives you an O(n) time complexity and O(1) space complexity."
                    },
                    {
                        "username": "ashwinpatel0808",
                        "content": "Time limit exceeded after passing 198  test cases. how to optimize?\nI used only one for loop but used sort() and copy() inside it."
                    }
                ]
            },
            {
                "id": 1760881,
                "content": [
                    {
                        "username": "johnnyboy1981",
                        "content": "I\\'m only starting out at this after an almost 20 year hiatus from CS, and I have to say this is the most fun problem I\\'ve done on leetcode yet!"
                    },
                    {
                        "username": "yaagmurss",
                        "content": "input : [3,2,6,5,0,3]\noutput : 4\nisn't 0 the smallest number?"
                    },
                    {
                        "username": "shivakumarkandra420",
                        "content": "you have to make max profit 1. if you buy at 0 and sell at 3 profit =3 2. if you buuy at 2 and sell at 6 profit = 4 that is the answer"
                    },
                    {
                        "username": "mohamed_waseela",
                        "content": "https://youtu.be/-Qpk2XJ5XJQ"
                    },
                    {
                        "username": "haldkar_shubham",
                        "content": "This is a python code with explanation, approach and algorithm. \\n\\nhttps://siteinvokers.com/best-time-to-buy-and-sell-stock-leet-code-121/"
                    },
                    {
                        "username": "rohit-ryuk",
                        "content": "Please note that short selling is not allowed in this Q !! :D"
                    },
                    {
                        "username": "rushi_4123",
                        "content": "Buy a stock when price is lowest and sell it when price is highest"
                    },
                    {
                        "username": "AliJavadov",
                        "content": "public static int maxProfit(int...prices) {\\n        int bestDay = 0;\\n        int bestProfit = 0;\\n        for (int i = 0; i < prices.length - 1; i++) {\\n            for (int j = i + 1; j < prices.length; j++) {\\n                if(Integer.valueOf(prices[j] - prices[i]) > bestProfit){\\n                    bestProfit = Integer.valueOf(prices[j] - prices[i]);\\n                    bestDay = j + 1;\\n\\n                }\\n            }\\n\\n        }\\n        return bestDay;\\n    }\\n\\n\\nIt\\'s my code, but in this case [1,2] and similar\\'s cases i have problems. Output :2 Expected : 1. what am i doing wrong?"
                    },
                    {
                        "username": "omjain",
                        "content": "you have to return max profit, not best day."
                    },
                    {
                        "username": "ghsatpute",
                        "content": "# Memory question \\n\\nI\\'ve two solutions \\n1. One has an additional array of equal to prices array i.e. O(n) extra space\\n2. Second one uses, three additional `int` variables i.e. O(1) extra spaces\\n\\nWhen I run both the programs, the first one says 53MB storage on leetCode while the second one says 56MB. How is this possible?"
                    },
                    {
                        "username": "ponharshita",
                        "content": "Someone tell me why is this not working for the 97th testcase but have passed all the previous testcases ?\\n\\nclass Solution {\\n    public int maxProfit(int[] prices) {\\n\\n        int len = prices.length;\\n        int first = 0;\\n        int last = len - 1;\\n        int res = 0;\\n\\n        while(first < last){\\n            if(prices[first] > prices[last]){\\n                res = Math.max(res,prices[last] - prices[first]);\\n                first++;\\n            }\\n            else{\\n                res = Math.max(res,prices[last] - prices[first]);\\n                last--;\\n            }\\n\\n        }\\n        return res;\\n    }\\n}"
                    },
                    {
                        "username": "bparanj",
                        "content": "The reason this approach is not working for all test cases is due to the logic of how you\\'re trying to find the maximum profit. The maximum profit is not necessarily obtained from the difference of the first and last element in the array. Your approach assumes that we always need to consider the first and last elements in the array, and then compare the difference between the first element and the last element. If the first element is greater, then we move the pointer to the next one and vice versa.\\n\\nBut this approach is incorrect. In this problem, we want to find the maximum profit where the buying price (a smaller value) appears before the selling price (a larger value). Your approach doesn\\'t ensure this order. You may end up with a buying price that comes after the selling price.\\n\\nHere is the correct solution that scans from left to right and always tracks the minimum price (buying price) and calculates the profit if we sell at the current price.\\n\\n```java\\npublic class Solution {\\n    public int maxProfit(int prices[]) {\\n        int minprice = Integer.MAX_VALUE;\\n        int maxprofit = 0;\\n        for (int i = 0; i < prices.length; i++) {\\n            if (prices[i] < minprice)\\n                minprice = prices[i];\\n            else if (prices[i] - minprice > maxprofit)\\n                maxprofit = prices[i] - minprice;\\n        }\\n        return maxprofit;\\n    }\\n}\\n```\\n\\nThis ensures we always sell the stock after buying it and we maximize the profit."
                    },
                    {
                        "username": "Choubey_harsh",
                        "content": "\\nplz help what\\'s wrong with this code------\\nint maxProfit(vector<int>& prices) {\\n        int ansr=0,largest=0,n=prices.size();\\n        for(int i=0;i<n-1;i++){\\n            for(int j=i+1;j<n;j++){\\n                 ansr=prices[j]-prices[i];\\n            }\\n            if(ansr>largest){\\n                largest=ansr;\\n            }\\n            \\n        }\\n        return largest;\\n    }"
                    }
                ]
            },
            {
                "id": 1760451,
                "content": [
                    {
                        "username": "johnnyboy1981",
                        "content": "I\\'m only starting out at this after an almost 20 year hiatus from CS, and I have to say this is the most fun problem I\\'ve done on leetcode yet!"
                    },
                    {
                        "username": "yaagmurss",
                        "content": "input : [3,2,6,5,0,3]\noutput : 4\nisn't 0 the smallest number?"
                    },
                    {
                        "username": "shivakumarkandra420",
                        "content": "you have to make max profit 1. if you buy at 0 and sell at 3 profit =3 2. if you buuy at 2 and sell at 6 profit = 4 that is the answer"
                    },
                    {
                        "username": "mohamed_waseela",
                        "content": "https://youtu.be/-Qpk2XJ5XJQ"
                    },
                    {
                        "username": "haldkar_shubham",
                        "content": "This is a python code with explanation, approach and algorithm. \\n\\nhttps://siteinvokers.com/best-time-to-buy-and-sell-stock-leet-code-121/"
                    },
                    {
                        "username": "rohit-ryuk",
                        "content": "Please note that short selling is not allowed in this Q !! :D"
                    },
                    {
                        "username": "rushi_4123",
                        "content": "Buy a stock when price is lowest and sell it when price is highest"
                    },
                    {
                        "username": "AliJavadov",
                        "content": "public static int maxProfit(int...prices) {\\n        int bestDay = 0;\\n        int bestProfit = 0;\\n        for (int i = 0; i < prices.length - 1; i++) {\\n            for (int j = i + 1; j < prices.length; j++) {\\n                if(Integer.valueOf(prices[j] - prices[i]) > bestProfit){\\n                    bestProfit = Integer.valueOf(prices[j] - prices[i]);\\n                    bestDay = j + 1;\\n\\n                }\\n            }\\n\\n        }\\n        return bestDay;\\n    }\\n\\n\\nIt\\'s my code, but in this case [1,2] and similar\\'s cases i have problems. Output :2 Expected : 1. what am i doing wrong?"
                    },
                    {
                        "username": "omjain",
                        "content": "you have to return max profit, not best day."
                    },
                    {
                        "username": "ghsatpute",
                        "content": "# Memory question \\n\\nI\\'ve two solutions \\n1. One has an additional array of equal to prices array i.e. O(n) extra space\\n2. Second one uses, three additional `int` variables i.e. O(1) extra spaces\\n\\nWhen I run both the programs, the first one says 53MB storage on leetCode while the second one says 56MB. How is this possible?"
                    },
                    {
                        "username": "ponharshita",
                        "content": "Someone tell me why is this not working for the 97th testcase but have passed all the previous testcases ?\\n\\nclass Solution {\\n    public int maxProfit(int[] prices) {\\n\\n        int len = prices.length;\\n        int first = 0;\\n        int last = len - 1;\\n        int res = 0;\\n\\n        while(first < last){\\n            if(prices[first] > prices[last]){\\n                res = Math.max(res,prices[last] - prices[first]);\\n                first++;\\n            }\\n            else{\\n                res = Math.max(res,prices[last] - prices[first]);\\n                last--;\\n            }\\n\\n        }\\n        return res;\\n    }\\n}"
                    },
                    {
                        "username": "bparanj",
                        "content": "The reason this approach is not working for all test cases is due to the logic of how you\\'re trying to find the maximum profit. The maximum profit is not necessarily obtained from the difference of the first and last element in the array. Your approach assumes that we always need to consider the first and last elements in the array, and then compare the difference between the first element and the last element. If the first element is greater, then we move the pointer to the next one and vice versa.\\n\\nBut this approach is incorrect. In this problem, we want to find the maximum profit where the buying price (a smaller value) appears before the selling price (a larger value). Your approach doesn\\'t ensure this order. You may end up with a buying price that comes after the selling price.\\n\\nHere is the correct solution that scans from left to right and always tracks the minimum price (buying price) and calculates the profit if we sell at the current price.\\n\\n```java\\npublic class Solution {\\n    public int maxProfit(int prices[]) {\\n        int minprice = Integer.MAX_VALUE;\\n        int maxprofit = 0;\\n        for (int i = 0; i < prices.length; i++) {\\n            if (prices[i] < minprice)\\n                minprice = prices[i];\\n            else if (prices[i] - minprice > maxprofit)\\n                maxprofit = prices[i] - minprice;\\n        }\\n        return maxprofit;\\n    }\\n}\\n```\\n\\nThis ensures we always sell the stock after buying it and we maximize the profit."
                    },
                    {
                        "username": "Choubey_harsh",
                        "content": "\\nplz help what\\'s wrong with this code------\\nint maxProfit(vector<int>& prices) {\\n        int ansr=0,largest=0,n=prices.size();\\n        for(int i=0;i<n-1;i++){\\n            for(int j=i+1;j<n;j++){\\n                 ansr=prices[j]-prices[i];\\n            }\\n            if(ansr>largest){\\n                largest=ansr;\\n            }\\n            \\n        }\\n        return largest;\\n    }"
                    }
                ]
            },
            {
                "id": 1756340,
                "content": [
                    {
                        "username": "johnnyboy1981",
                        "content": "I\\'m only starting out at this after an almost 20 year hiatus from CS, and I have to say this is the most fun problem I\\'ve done on leetcode yet!"
                    },
                    {
                        "username": "yaagmurss",
                        "content": "input : [3,2,6,5,0,3]\noutput : 4\nisn't 0 the smallest number?"
                    },
                    {
                        "username": "shivakumarkandra420",
                        "content": "you have to make max profit 1. if you buy at 0 and sell at 3 profit =3 2. if you buuy at 2 and sell at 6 profit = 4 that is the answer"
                    },
                    {
                        "username": "mohamed_waseela",
                        "content": "https://youtu.be/-Qpk2XJ5XJQ"
                    },
                    {
                        "username": "haldkar_shubham",
                        "content": "This is a python code with explanation, approach and algorithm. \\n\\nhttps://siteinvokers.com/best-time-to-buy-and-sell-stock-leet-code-121/"
                    },
                    {
                        "username": "rohit-ryuk",
                        "content": "Please note that short selling is not allowed in this Q !! :D"
                    },
                    {
                        "username": "rushi_4123",
                        "content": "Buy a stock when price is lowest and sell it when price is highest"
                    },
                    {
                        "username": "AliJavadov",
                        "content": "public static int maxProfit(int...prices) {\\n        int bestDay = 0;\\n        int bestProfit = 0;\\n        for (int i = 0; i < prices.length - 1; i++) {\\n            for (int j = i + 1; j < prices.length; j++) {\\n                if(Integer.valueOf(prices[j] - prices[i]) > bestProfit){\\n                    bestProfit = Integer.valueOf(prices[j] - prices[i]);\\n                    bestDay = j + 1;\\n\\n                }\\n            }\\n\\n        }\\n        return bestDay;\\n    }\\n\\n\\nIt\\'s my code, but in this case [1,2] and similar\\'s cases i have problems. Output :2 Expected : 1. what am i doing wrong?"
                    },
                    {
                        "username": "omjain",
                        "content": "you have to return max profit, not best day."
                    },
                    {
                        "username": "ghsatpute",
                        "content": "# Memory question \\n\\nI\\'ve two solutions \\n1. One has an additional array of equal to prices array i.e. O(n) extra space\\n2. Second one uses, three additional `int` variables i.e. O(1) extra spaces\\n\\nWhen I run both the programs, the first one says 53MB storage on leetCode while the second one says 56MB. How is this possible?"
                    },
                    {
                        "username": "ponharshita",
                        "content": "Someone tell me why is this not working for the 97th testcase but have passed all the previous testcases ?\\n\\nclass Solution {\\n    public int maxProfit(int[] prices) {\\n\\n        int len = prices.length;\\n        int first = 0;\\n        int last = len - 1;\\n        int res = 0;\\n\\n        while(first < last){\\n            if(prices[first] > prices[last]){\\n                res = Math.max(res,prices[last] - prices[first]);\\n                first++;\\n            }\\n            else{\\n                res = Math.max(res,prices[last] - prices[first]);\\n                last--;\\n            }\\n\\n        }\\n        return res;\\n    }\\n}"
                    },
                    {
                        "username": "bparanj",
                        "content": "The reason this approach is not working for all test cases is due to the logic of how you\\'re trying to find the maximum profit. The maximum profit is not necessarily obtained from the difference of the first and last element in the array. Your approach assumes that we always need to consider the first and last elements in the array, and then compare the difference between the first element and the last element. If the first element is greater, then we move the pointer to the next one and vice versa.\\n\\nBut this approach is incorrect. In this problem, we want to find the maximum profit where the buying price (a smaller value) appears before the selling price (a larger value). Your approach doesn\\'t ensure this order. You may end up with a buying price that comes after the selling price.\\n\\nHere is the correct solution that scans from left to right and always tracks the minimum price (buying price) and calculates the profit if we sell at the current price.\\n\\n```java\\npublic class Solution {\\n    public int maxProfit(int prices[]) {\\n        int minprice = Integer.MAX_VALUE;\\n        int maxprofit = 0;\\n        for (int i = 0; i < prices.length; i++) {\\n            if (prices[i] < minprice)\\n                minprice = prices[i];\\n            else if (prices[i] - minprice > maxprofit)\\n                maxprofit = prices[i] - minprice;\\n        }\\n        return maxprofit;\\n    }\\n}\\n```\\n\\nThis ensures we always sell the stock after buying it and we maximize the profit."
                    },
                    {
                        "username": "Choubey_harsh",
                        "content": "\\nplz help what\\'s wrong with this code------\\nint maxProfit(vector<int>& prices) {\\n        int ansr=0,largest=0,n=prices.size();\\n        for(int i=0;i<n-1;i++){\\n            for(int j=i+1;j<n;j++){\\n                 ansr=prices[j]-prices[i];\\n            }\\n            if(ansr>largest){\\n                largest=ansr;\\n            }\\n            \\n        }\\n        return largest;\\n    }"
                    }
                ]
            },
            {
                "id": 1752674,
                "content": [
                    {
                        "username": "johnnyboy1981",
                        "content": "I\\'m only starting out at this after an almost 20 year hiatus from CS, and I have to say this is the most fun problem I\\'ve done on leetcode yet!"
                    },
                    {
                        "username": "yaagmurss",
                        "content": "input : [3,2,6,5,0,3]\noutput : 4\nisn't 0 the smallest number?"
                    },
                    {
                        "username": "shivakumarkandra420",
                        "content": "you have to make max profit 1. if you buy at 0 and sell at 3 profit =3 2. if you buuy at 2 and sell at 6 profit = 4 that is the answer"
                    },
                    {
                        "username": "mohamed_waseela",
                        "content": "https://youtu.be/-Qpk2XJ5XJQ"
                    },
                    {
                        "username": "haldkar_shubham",
                        "content": "This is a python code with explanation, approach and algorithm. \\n\\nhttps://siteinvokers.com/best-time-to-buy-and-sell-stock-leet-code-121/"
                    },
                    {
                        "username": "rohit-ryuk",
                        "content": "Please note that short selling is not allowed in this Q !! :D"
                    },
                    {
                        "username": "rushi_4123",
                        "content": "Buy a stock when price is lowest and sell it when price is highest"
                    },
                    {
                        "username": "AliJavadov",
                        "content": "public static int maxProfit(int...prices) {\\n        int bestDay = 0;\\n        int bestProfit = 0;\\n        for (int i = 0; i < prices.length - 1; i++) {\\n            for (int j = i + 1; j < prices.length; j++) {\\n                if(Integer.valueOf(prices[j] - prices[i]) > bestProfit){\\n                    bestProfit = Integer.valueOf(prices[j] - prices[i]);\\n                    bestDay = j + 1;\\n\\n                }\\n            }\\n\\n        }\\n        return bestDay;\\n    }\\n\\n\\nIt\\'s my code, but in this case [1,2] and similar\\'s cases i have problems. Output :2 Expected : 1. what am i doing wrong?"
                    },
                    {
                        "username": "omjain",
                        "content": "you have to return max profit, not best day."
                    },
                    {
                        "username": "ghsatpute",
                        "content": "# Memory question \\n\\nI\\'ve two solutions \\n1. One has an additional array of equal to prices array i.e. O(n) extra space\\n2. Second one uses, three additional `int` variables i.e. O(1) extra spaces\\n\\nWhen I run both the programs, the first one says 53MB storage on leetCode while the second one says 56MB. How is this possible?"
                    },
                    {
                        "username": "ponharshita",
                        "content": "Someone tell me why is this not working for the 97th testcase but have passed all the previous testcases ?\\n\\nclass Solution {\\n    public int maxProfit(int[] prices) {\\n\\n        int len = prices.length;\\n        int first = 0;\\n        int last = len - 1;\\n        int res = 0;\\n\\n        while(first < last){\\n            if(prices[first] > prices[last]){\\n                res = Math.max(res,prices[last] - prices[first]);\\n                first++;\\n            }\\n            else{\\n                res = Math.max(res,prices[last] - prices[first]);\\n                last--;\\n            }\\n\\n        }\\n        return res;\\n    }\\n}"
                    },
                    {
                        "username": "bparanj",
                        "content": "The reason this approach is not working for all test cases is due to the logic of how you\\'re trying to find the maximum profit. The maximum profit is not necessarily obtained from the difference of the first and last element in the array. Your approach assumes that we always need to consider the first and last elements in the array, and then compare the difference between the first element and the last element. If the first element is greater, then we move the pointer to the next one and vice versa.\\n\\nBut this approach is incorrect. In this problem, we want to find the maximum profit where the buying price (a smaller value) appears before the selling price (a larger value). Your approach doesn\\'t ensure this order. You may end up with a buying price that comes after the selling price.\\n\\nHere is the correct solution that scans from left to right and always tracks the minimum price (buying price) and calculates the profit if we sell at the current price.\\n\\n```java\\npublic class Solution {\\n    public int maxProfit(int prices[]) {\\n        int minprice = Integer.MAX_VALUE;\\n        int maxprofit = 0;\\n        for (int i = 0; i < prices.length; i++) {\\n            if (prices[i] < minprice)\\n                minprice = prices[i];\\n            else if (prices[i] - minprice > maxprofit)\\n                maxprofit = prices[i] - minprice;\\n        }\\n        return maxprofit;\\n    }\\n}\\n```\\n\\nThis ensures we always sell the stock after buying it and we maximize the profit."
                    },
                    {
                        "username": "Choubey_harsh",
                        "content": "\\nplz help what\\'s wrong with this code------\\nint maxProfit(vector<int>& prices) {\\n        int ansr=0,largest=0,n=prices.size();\\n        for(int i=0;i<n-1;i++){\\n            for(int j=i+1;j<n;j++){\\n                 ansr=prices[j]-prices[i];\\n            }\\n            if(ansr>largest){\\n                largest=ansr;\\n            }\\n            \\n        }\\n        return largest;\\n    }"
                    }
                ]
            },
            {
                "id": 1751046,
                "content": [
                    {
                        "username": "johnnyboy1981",
                        "content": "I\\'m only starting out at this after an almost 20 year hiatus from CS, and I have to say this is the most fun problem I\\'ve done on leetcode yet!"
                    },
                    {
                        "username": "yaagmurss",
                        "content": "input : [3,2,6,5,0,3]\noutput : 4\nisn't 0 the smallest number?"
                    },
                    {
                        "username": "shivakumarkandra420",
                        "content": "you have to make max profit 1. if you buy at 0 and sell at 3 profit =3 2. if you buuy at 2 and sell at 6 profit = 4 that is the answer"
                    },
                    {
                        "username": "mohamed_waseela",
                        "content": "https://youtu.be/-Qpk2XJ5XJQ"
                    },
                    {
                        "username": "haldkar_shubham",
                        "content": "This is a python code with explanation, approach and algorithm. \\n\\nhttps://siteinvokers.com/best-time-to-buy-and-sell-stock-leet-code-121/"
                    },
                    {
                        "username": "rohit-ryuk",
                        "content": "Please note that short selling is not allowed in this Q !! :D"
                    },
                    {
                        "username": "rushi_4123",
                        "content": "Buy a stock when price is lowest and sell it when price is highest"
                    },
                    {
                        "username": "AliJavadov",
                        "content": "public static int maxProfit(int...prices) {\\n        int bestDay = 0;\\n        int bestProfit = 0;\\n        for (int i = 0; i < prices.length - 1; i++) {\\n            for (int j = i + 1; j < prices.length; j++) {\\n                if(Integer.valueOf(prices[j] - prices[i]) > bestProfit){\\n                    bestProfit = Integer.valueOf(prices[j] - prices[i]);\\n                    bestDay = j + 1;\\n\\n                }\\n            }\\n\\n        }\\n        return bestDay;\\n    }\\n\\n\\nIt\\'s my code, but in this case [1,2] and similar\\'s cases i have problems. Output :2 Expected : 1. what am i doing wrong?"
                    },
                    {
                        "username": "omjain",
                        "content": "you have to return max profit, not best day."
                    },
                    {
                        "username": "ghsatpute",
                        "content": "# Memory question \\n\\nI\\'ve two solutions \\n1. One has an additional array of equal to prices array i.e. O(n) extra space\\n2. Second one uses, three additional `int` variables i.e. O(1) extra spaces\\n\\nWhen I run both the programs, the first one says 53MB storage on leetCode while the second one says 56MB. How is this possible?"
                    },
                    {
                        "username": "ponharshita",
                        "content": "Someone tell me why is this not working for the 97th testcase but have passed all the previous testcases ?\\n\\nclass Solution {\\n    public int maxProfit(int[] prices) {\\n\\n        int len = prices.length;\\n        int first = 0;\\n        int last = len - 1;\\n        int res = 0;\\n\\n        while(first < last){\\n            if(prices[first] > prices[last]){\\n                res = Math.max(res,prices[last] - prices[first]);\\n                first++;\\n            }\\n            else{\\n                res = Math.max(res,prices[last] - prices[first]);\\n                last--;\\n            }\\n\\n        }\\n        return res;\\n    }\\n}"
                    },
                    {
                        "username": "bparanj",
                        "content": "The reason this approach is not working for all test cases is due to the logic of how you\\'re trying to find the maximum profit. The maximum profit is not necessarily obtained from the difference of the first and last element in the array. Your approach assumes that we always need to consider the first and last elements in the array, and then compare the difference between the first element and the last element. If the first element is greater, then we move the pointer to the next one and vice versa.\\n\\nBut this approach is incorrect. In this problem, we want to find the maximum profit where the buying price (a smaller value) appears before the selling price (a larger value). Your approach doesn\\'t ensure this order. You may end up with a buying price that comes after the selling price.\\n\\nHere is the correct solution that scans from left to right and always tracks the minimum price (buying price) and calculates the profit if we sell at the current price.\\n\\n```java\\npublic class Solution {\\n    public int maxProfit(int prices[]) {\\n        int minprice = Integer.MAX_VALUE;\\n        int maxprofit = 0;\\n        for (int i = 0; i < prices.length; i++) {\\n            if (prices[i] < minprice)\\n                minprice = prices[i];\\n            else if (prices[i] - minprice > maxprofit)\\n                maxprofit = prices[i] - minprice;\\n        }\\n        return maxprofit;\\n    }\\n}\\n```\\n\\nThis ensures we always sell the stock after buying it and we maximize the profit."
                    },
                    {
                        "username": "Choubey_harsh",
                        "content": "\\nplz help what\\'s wrong with this code------\\nint maxProfit(vector<int>& prices) {\\n        int ansr=0,largest=0,n=prices.size();\\n        for(int i=0;i<n-1;i++){\\n            for(int j=i+1;j<n;j++){\\n                 ansr=prices[j]-prices[i];\\n            }\\n            if(ansr>largest){\\n                largest=ansr;\\n            }\\n            \\n        }\\n        return largest;\\n    }"
                    }
                ]
            },
            {
                "id": 1749800,
                "content": [
                    {
                        "username": "johnnyboy1981",
                        "content": "I\\'m only starting out at this after an almost 20 year hiatus from CS, and I have to say this is the most fun problem I\\'ve done on leetcode yet!"
                    },
                    {
                        "username": "yaagmurss",
                        "content": "input : [3,2,6,5,0,3]\noutput : 4\nisn't 0 the smallest number?"
                    },
                    {
                        "username": "shivakumarkandra420",
                        "content": "you have to make max profit 1. if you buy at 0 and sell at 3 profit =3 2. if you buuy at 2 and sell at 6 profit = 4 that is the answer"
                    },
                    {
                        "username": "mohamed_waseela",
                        "content": "https://youtu.be/-Qpk2XJ5XJQ"
                    },
                    {
                        "username": "haldkar_shubham",
                        "content": "This is a python code with explanation, approach and algorithm. \\n\\nhttps://siteinvokers.com/best-time-to-buy-and-sell-stock-leet-code-121/"
                    },
                    {
                        "username": "rohit-ryuk",
                        "content": "Please note that short selling is not allowed in this Q !! :D"
                    },
                    {
                        "username": "rushi_4123",
                        "content": "Buy a stock when price is lowest and sell it when price is highest"
                    },
                    {
                        "username": "AliJavadov",
                        "content": "public static int maxProfit(int...prices) {\\n        int bestDay = 0;\\n        int bestProfit = 0;\\n        for (int i = 0; i < prices.length - 1; i++) {\\n            for (int j = i + 1; j < prices.length; j++) {\\n                if(Integer.valueOf(prices[j] - prices[i]) > bestProfit){\\n                    bestProfit = Integer.valueOf(prices[j] - prices[i]);\\n                    bestDay = j + 1;\\n\\n                }\\n            }\\n\\n        }\\n        return bestDay;\\n    }\\n\\n\\nIt\\'s my code, but in this case [1,2] and similar\\'s cases i have problems. Output :2 Expected : 1. what am i doing wrong?"
                    },
                    {
                        "username": "omjain",
                        "content": "you have to return max profit, not best day."
                    },
                    {
                        "username": "ghsatpute",
                        "content": "# Memory question \\n\\nI\\'ve two solutions \\n1. One has an additional array of equal to prices array i.e. O(n) extra space\\n2. Second one uses, three additional `int` variables i.e. O(1) extra spaces\\n\\nWhen I run both the programs, the first one says 53MB storage on leetCode while the second one says 56MB. How is this possible?"
                    },
                    {
                        "username": "ponharshita",
                        "content": "Someone tell me why is this not working for the 97th testcase but have passed all the previous testcases ?\\n\\nclass Solution {\\n    public int maxProfit(int[] prices) {\\n\\n        int len = prices.length;\\n        int first = 0;\\n        int last = len - 1;\\n        int res = 0;\\n\\n        while(first < last){\\n            if(prices[first] > prices[last]){\\n                res = Math.max(res,prices[last] - prices[first]);\\n                first++;\\n            }\\n            else{\\n                res = Math.max(res,prices[last] - prices[first]);\\n                last--;\\n            }\\n\\n        }\\n        return res;\\n    }\\n}"
                    },
                    {
                        "username": "bparanj",
                        "content": "The reason this approach is not working for all test cases is due to the logic of how you\\'re trying to find the maximum profit. The maximum profit is not necessarily obtained from the difference of the first and last element in the array. Your approach assumes that we always need to consider the first and last elements in the array, and then compare the difference between the first element and the last element. If the first element is greater, then we move the pointer to the next one and vice versa.\\n\\nBut this approach is incorrect. In this problem, we want to find the maximum profit where the buying price (a smaller value) appears before the selling price (a larger value). Your approach doesn\\'t ensure this order. You may end up with a buying price that comes after the selling price.\\n\\nHere is the correct solution that scans from left to right and always tracks the minimum price (buying price) and calculates the profit if we sell at the current price.\\n\\n```java\\npublic class Solution {\\n    public int maxProfit(int prices[]) {\\n        int minprice = Integer.MAX_VALUE;\\n        int maxprofit = 0;\\n        for (int i = 0; i < prices.length; i++) {\\n            if (prices[i] < minprice)\\n                minprice = prices[i];\\n            else if (prices[i] - minprice > maxprofit)\\n                maxprofit = prices[i] - minprice;\\n        }\\n        return maxprofit;\\n    }\\n}\\n```\\n\\nThis ensures we always sell the stock after buying it and we maximize the profit."
                    },
                    {
                        "username": "Choubey_harsh",
                        "content": "\\nplz help what\\'s wrong with this code------\\nint maxProfit(vector<int>& prices) {\\n        int ansr=0,largest=0,n=prices.size();\\n        for(int i=0;i<n-1;i++){\\n            for(int j=i+1;j<n;j++){\\n                 ansr=prices[j]-prices[i];\\n            }\\n            if(ansr>largest){\\n                largest=ansr;\\n            }\\n            \\n        }\\n        return largest;\\n    }"
                    }
                ]
            },
            {
                "id": 1749490,
                "content": [
                    {
                        "username": "johnnyboy1981",
                        "content": "I\\'m only starting out at this after an almost 20 year hiatus from CS, and I have to say this is the most fun problem I\\'ve done on leetcode yet!"
                    },
                    {
                        "username": "yaagmurss",
                        "content": "input : [3,2,6,5,0,3]\noutput : 4\nisn't 0 the smallest number?"
                    },
                    {
                        "username": "shivakumarkandra420",
                        "content": "you have to make max profit 1. if you buy at 0 and sell at 3 profit =3 2. if you buuy at 2 and sell at 6 profit = 4 that is the answer"
                    },
                    {
                        "username": "mohamed_waseela",
                        "content": "https://youtu.be/-Qpk2XJ5XJQ"
                    },
                    {
                        "username": "haldkar_shubham",
                        "content": "This is a python code with explanation, approach and algorithm. \\n\\nhttps://siteinvokers.com/best-time-to-buy-and-sell-stock-leet-code-121/"
                    },
                    {
                        "username": "rohit-ryuk",
                        "content": "Please note that short selling is not allowed in this Q !! :D"
                    },
                    {
                        "username": "rushi_4123",
                        "content": "Buy a stock when price is lowest and sell it when price is highest"
                    },
                    {
                        "username": "AliJavadov",
                        "content": "public static int maxProfit(int...prices) {\\n        int bestDay = 0;\\n        int bestProfit = 0;\\n        for (int i = 0; i < prices.length - 1; i++) {\\n            for (int j = i + 1; j < prices.length; j++) {\\n                if(Integer.valueOf(prices[j] - prices[i]) > bestProfit){\\n                    bestProfit = Integer.valueOf(prices[j] - prices[i]);\\n                    bestDay = j + 1;\\n\\n                }\\n            }\\n\\n        }\\n        return bestDay;\\n    }\\n\\n\\nIt\\'s my code, but in this case [1,2] and similar\\'s cases i have problems. Output :2 Expected : 1. what am i doing wrong?"
                    },
                    {
                        "username": "omjain",
                        "content": "you have to return max profit, not best day."
                    },
                    {
                        "username": "ghsatpute",
                        "content": "# Memory question \\n\\nI\\'ve two solutions \\n1. One has an additional array of equal to prices array i.e. O(n) extra space\\n2. Second one uses, three additional `int` variables i.e. O(1) extra spaces\\n\\nWhen I run both the programs, the first one says 53MB storage on leetCode while the second one says 56MB. How is this possible?"
                    },
                    {
                        "username": "ponharshita",
                        "content": "Someone tell me why is this not working for the 97th testcase but have passed all the previous testcases ?\\n\\nclass Solution {\\n    public int maxProfit(int[] prices) {\\n\\n        int len = prices.length;\\n        int first = 0;\\n        int last = len - 1;\\n        int res = 0;\\n\\n        while(first < last){\\n            if(prices[first] > prices[last]){\\n                res = Math.max(res,prices[last] - prices[first]);\\n                first++;\\n            }\\n            else{\\n                res = Math.max(res,prices[last] - prices[first]);\\n                last--;\\n            }\\n\\n        }\\n        return res;\\n    }\\n}"
                    },
                    {
                        "username": "bparanj",
                        "content": "The reason this approach is not working for all test cases is due to the logic of how you\\'re trying to find the maximum profit. The maximum profit is not necessarily obtained from the difference of the first and last element in the array. Your approach assumes that we always need to consider the first and last elements in the array, and then compare the difference between the first element and the last element. If the first element is greater, then we move the pointer to the next one and vice versa.\\n\\nBut this approach is incorrect. In this problem, we want to find the maximum profit where the buying price (a smaller value) appears before the selling price (a larger value). Your approach doesn\\'t ensure this order. You may end up with a buying price that comes after the selling price.\\n\\nHere is the correct solution that scans from left to right and always tracks the minimum price (buying price) and calculates the profit if we sell at the current price.\\n\\n```java\\npublic class Solution {\\n    public int maxProfit(int prices[]) {\\n        int minprice = Integer.MAX_VALUE;\\n        int maxprofit = 0;\\n        for (int i = 0; i < prices.length; i++) {\\n            if (prices[i] < minprice)\\n                minprice = prices[i];\\n            else if (prices[i] - minprice > maxprofit)\\n                maxprofit = prices[i] - minprice;\\n        }\\n        return maxprofit;\\n    }\\n}\\n```\\n\\nThis ensures we always sell the stock after buying it and we maximize the profit."
                    },
                    {
                        "username": "Choubey_harsh",
                        "content": "\\nplz help what\\'s wrong with this code------\\nint maxProfit(vector<int>& prices) {\\n        int ansr=0,largest=0,n=prices.size();\\n        for(int i=0;i<n-1;i++){\\n            for(int j=i+1;j<n;j++){\\n                 ansr=prices[j]-prices[i];\\n            }\\n            if(ansr>largest){\\n                largest=ansr;\\n            }\\n            \\n        }\\n        return largest;\\n    }"
                    }
                ]
            },
            {
                "id": 1748741,
                "content": [
                    {
                        "username": "johnnyboy1981",
                        "content": "I\\'m only starting out at this after an almost 20 year hiatus from CS, and I have to say this is the most fun problem I\\'ve done on leetcode yet!"
                    },
                    {
                        "username": "yaagmurss",
                        "content": "input : [3,2,6,5,0,3]\noutput : 4\nisn't 0 the smallest number?"
                    },
                    {
                        "username": "shivakumarkandra420",
                        "content": "you have to make max profit 1. if you buy at 0 and sell at 3 profit =3 2. if you buuy at 2 and sell at 6 profit = 4 that is the answer"
                    },
                    {
                        "username": "mohamed_waseela",
                        "content": "https://youtu.be/-Qpk2XJ5XJQ"
                    },
                    {
                        "username": "haldkar_shubham",
                        "content": "This is a python code with explanation, approach and algorithm. \\n\\nhttps://siteinvokers.com/best-time-to-buy-and-sell-stock-leet-code-121/"
                    },
                    {
                        "username": "rohit-ryuk",
                        "content": "Please note that short selling is not allowed in this Q !! :D"
                    },
                    {
                        "username": "rushi_4123",
                        "content": "Buy a stock when price is lowest and sell it when price is highest"
                    },
                    {
                        "username": "AliJavadov",
                        "content": "public static int maxProfit(int...prices) {\\n        int bestDay = 0;\\n        int bestProfit = 0;\\n        for (int i = 0; i < prices.length - 1; i++) {\\n            for (int j = i + 1; j < prices.length; j++) {\\n                if(Integer.valueOf(prices[j] - prices[i]) > bestProfit){\\n                    bestProfit = Integer.valueOf(prices[j] - prices[i]);\\n                    bestDay = j + 1;\\n\\n                }\\n            }\\n\\n        }\\n        return bestDay;\\n    }\\n\\n\\nIt\\'s my code, but in this case [1,2] and similar\\'s cases i have problems. Output :2 Expected : 1. what am i doing wrong?"
                    },
                    {
                        "username": "omjain",
                        "content": "you have to return max profit, not best day."
                    },
                    {
                        "username": "ghsatpute",
                        "content": "# Memory question \\n\\nI\\'ve two solutions \\n1. One has an additional array of equal to prices array i.e. O(n) extra space\\n2. Second one uses, three additional `int` variables i.e. O(1) extra spaces\\n\\nWhen I run both the programs, the first one says 53MB storage on leetCode while the second one says 56MB. How is this possible?"
                    },
                    {
                        "username": "ponharshita",
                        "content": "Someone tell me why is this not working for the 97th testcase but have passed all the previous testcases ?\\n\\nclass Solution {\\n    public int maxProfit(int[] prices) {\\n\\n        int len = prices.length;\\n        int first = 0;\\n        int last = len - 1;\\n        int res = 0;\\n\\n        while(first < last){\\n            if(prices[first] > prices[last]){\\n                res = Math.max(res,prices[last] - prices[first]);\\n                first++;\\n            }\\n            else{\\n                res = Math.max(res,prices[last] - prices[first]);\\n                last--;\\n            }\\n\\n        }\\n        return res;\\n    }\\n}"
                    },
                    {
                        "username": "bparanj",
                        "content": "The reason this approach is not working for all test cases is due to the logic of how you\\'re trying to find the maximum profit. The maximum profit is not necessarily obtained from the difference of the first and last element in the array. Your approach assumes that we always need to consider the first and last elements in the array, and then compare the difference between the first element and the last element. If the first element is greater, then we move the pointer to the next one and vice versa.\\n\\nBut this approach is incorrect. In this problem, we want to find the maximum profit where the buying price (a smaller value) appears before the selling price (a larger value). Your approach doesn\\'t ensure this order. You may end up with a buying price that comes after the selling price.\\n\\nHere is the correct solution that scans from left to right and always tracks the minimum price (buying price) and calculates the profit if we sell at the current price.\\n\\n```java\\npublic class Solution {\\n    public int maxProfit(int prices[]) {\\n        int minprice = Integer.MAX_VALUE;\\n        int maxprofit = 0;\\n        for (int i = 0; i < prices.length; i++) {\\n            if (prices[i] < minprice)\\n                minprice = prices[i];\\n            else if (prices[i] - minprice > maxprofit)\\n                maxprofit = prices[i] - minprice;\\n        }\\n        return maxprofit;\\n    }\\n}\\n```\\n\\nThis ensures we always sell the stock after buying it and we maximize the profit."
                    },
                    {
                        "username": "Choubey_harsh",
                        "content": "\\nplz help what\\'s wrong with this code------\\nint maxProfit(vector<int>& prices) {\\n        int ansr=0,largest=0,n=prices.size();\\n        for(int i=0;i<n-1;i++){\\n            for(int j=i+1;j<n;j++){\\n                 ansr=prices[j]-prices[i];\\n            }\\n            if(ansr>largest){\\n                largest=ansr;\\n            }\\n            \\n        }\\n        return largest;\\n    }"
                    }
                ]
            },
            {
                "id": 1747151,
                "content": [
                    {
                        "username": "johnnyboy1981",
                        "content": "I\\'m only starting out at this after an almost 20 year hiatus from CS, and I have to say this is the most fun problem I\\'ve done on leetcode yet!"
                    },
                    {
                        "username": "yaagmurss",
                        "content": "input : [3,2,6,5,0,3]\noutput : 4\nisn't 0 the smallest number?"
                    },
                    {
                        "username": "shivakumarkandra420",
                        "content": "you have to make max profit 1. if you buy at 0 and sell at 3 profit =3 2. if you buuy at 2 and sell at 6 profit = 4 that is the answer"
                    },
                    {
                        "username": "mohamed_waseela",
                        "content": "https://youtu.be/-Qpk2XJ5XJQ"
                    },
                    {
                        "username": "haldkar_shubham",
                        "content": "This is a python code with explanation, approach and algorithm. \\n\\nhttps://siteinvokers.com/best-time-to-buy-and-sell-stock-leet-code-121/"
                    },
                    {
                        "username": "rohit-ryuk",
                        "content": "Please note that short selling is not allowed in this Q !! :D"
                    },
                    {
                        "username": "rushi_4123",
                        "content": "Buy a stock when price is lowest and sell it when price is highest"
                    },
                    {
                        "username": "AliJavadov",
                        "content": "public static int maxProfit(int...prices) {\\n        int bestDay = 0;\\n        int bestProfit = 0;\\n        for (int i = 0; i < prices.length - 1; i++) {\\n            for (int j = i + 1; j < prices.length; j++) {\\n                if(Integer.valueOf(prices[j] - prices[i]) > bestProfit){\\n                    bestProfit = Integer.valueOf(prices[j] - prices[i]);\\n                    bestDay = j + 1;\\n\\n                }\\n            }\\n\\n        }\\n        return bestDay;\\n    }\\n\\n\\nIt\\'s my code, but in this case [1,2] and similar\\'s cases i have problems. Output :2 Expected : 1. what am i doing wrong?"
                    },
                    {
                        "username": "omjain",
                        "content": "you have to return max profit, not best day."
                    },
                    {
                        "username": "ghsatpute",
                        "content": "# Memory question \\n\\nI\\'ve two solutions \\n1. One has an additional array of equal to prices array i.e. O(n) extra space\\n2. Second one uses, three additional `int` variables i.e. O(1) extra spaces\\n\\nWhen I run both the programs, the first one says 53MB storage on leetCode while the second one says 56MB. How is this possible?"
                    },
                    {
                        "username": "ponharshita",
                        "content": "Someone tell me why is this not working for the 97th testcase but have passed all the previous testcases ?\\n\\nclass Solution {\\n    public int maxProfit(int[] prices) {\\n\\n        int len = prices.length;\\n        int first = 0;\\n        int last = len - 1;\\n        int res = 0;\\n\\n        while(first < last){\\n            if(prices[first] > prices[last]){\\n                res = Math.max(res,prices[last] - prices[first]);\\n                first++;\\n            }\\n            else{\\n                res = Math.max(res,prices[last] - prices[first]);\\n                last--;\\n            }\\n\\n        }\\n        return res;\\n    }\\n}"
                    },
                    {
                        "username": "bparanj",
                        "content": "The reason this approach is not working for all test cases is due to the logic of how you\\'re trying to find the maximum profit. The maximum profit is not necessarily obtained from the difference of the first and last element in the array. Your approach assumes that we always need to consider the first and last elements in the array, and then compare the difference between the first element and the last element. If the first element is greater, then we move the pointer to the next one and vice versa.\\n\\nBut this approach is incorrect. In this problem, we want to find the maximum profit where the buying price (a smaller value) appears before the selling price (a larger value). Your approach doesn\\'t ensure this order. You may end up with a buying price that comes after the selling price.\\n\\nHere is the correct solution that scans from left to right and always tracks the minimum price (buying price) and calculates the profit if we sell at the current price.\\n\\n```java\\npublic class Solution {\\n    public int maxProfit(int prices[]) {\\n        int minprice = Integer.MAX_VALUE;\\n        int maxprofit = 0;\\n        for (int i = 0; i < prices.length; i++) {\\n            if (prices[i] < minprice)\\n                minprice = prices[i];\\n            else if (prices[i] - minprice > maxprofit)\\n                maxprofit = prices[i] - minprice;\\n        }\\n        return maxprofit;\\n    }\\n}\\n```\\n\\nThis ensures we always sell the stock after buying it and we maximize the profit."
                    },
                    {
                        "username": "Choubey_harsh",
                        "content": "\\nplz help what\\'s wrong with this code------\\nint maxProfit(vector<int>& prices) {\\n        int ansr=0,largest=0,n=prices.size();\\n        for(int i=0;i<n-1;i++){\\n            for(int j=i+1;j<n;j++){\\n                 ansr=prices[j]-prices[i];\\n            }\\n            if(ansr>largest){\\n                largest=ansr;\\n            }\\n            \\n        }\\n        return largest;\\n    }"
                    }
                ]
            },
            {
                "id": 1745671,
                "content": [
                    {
                        "username": "johnnyboy1981",
                        "content": "I\\'m only starting out at this after an almost 20 year hiatus from CS, and I have to say this is the most fun problem I\\'ve done on leetcode yet!"
                    },
                    {
                        "username": "yaagmurss",
                        "content": "input : [3,2,6,5,0,3]\noutput : 4\nisn't 0 the smallest number?"
                    },
                    {
                        "username": "shivakumarkandra420",
                        "content": "you have to make max profit 1. if you buy at 0 and sell at 3 profit =3 2. if you buuy at 2 and sell at 6 profit = 4 that is the answer"
                    },
                    {
                        "username": "mohamed_waseela",
                        "content": "https://youtu.be/-Qpk2XJ5XJQ"
                    },
                    {
                        "username": "haldkar_shubham",
                        "content": "This is a python code with explanation, approach and algorithm. \\n\\nhttps://siteinvokers.com/best-time-to-buy-and-sell-stock-leet-code-121/"
                    },
                    {
                        "username": "rohit-ryuk",
                        "content": "Please note that short selling is not allowed in this Q !! :D"
                    },
                    {
                        "username": "rushi_4123",
                        "content": "Buy a stock when price is lowest and sell it when price is highest"
                    },
                    {
                        "username": "AliJavadov",
                        "content": "public static int maxProfit(int...prices) {\\n        int bestDay = 0;\\n        int bestProfit = 0;\\n        for (int i = 0; i < prices.length - 1; i++) {\\n            for (int j = i + 1; j < prices.length; j++) {\\n                if(Integer.valueOf(prices[j] - prices[i]) > bestProfit){\\n                    bestProfit = Integer.valueOf(prices[j] - prices[i]);\\n                    bestDay = j + 1;\\n\\n                }\\n            }\\n\\n        }\\n        return bestDay;\\n    }\\n\\n\\nIt\\'s my code, but in this case [1,2] and similar\\'s cases i have problems. Output :2 Expected : 1. what am i doing wrong?"
                    },
                    {
                        "username": "omjain",
                        "content": "you have to return max profit, not best day."
                    },
                    {
                        "username": "ghsatpute",
                        "content": "# Memory question \\n\\nI\\'ve two solutions \\n1. One has an additional array of equal to prices array i.e. O(n) extra space\\n2. Second one uses, three additional `int` variables i.e. O(1) extra spaces\\n\\nWhen I run both the programs, the first one says 53MB storage on leetCode while the second one says 56MB. How is this possible?"
                    },
                    {
                        "username": "ponharshita",
                        "content": "Someone tell me why is this not working for the 97th testcase but have passed all the previous testcases ?\\n\\nclass Solution {\\n    public int maxProfit(int[] prices) {\\n\\n        int len = prices.length;\\n        int first = 0;\\n        int last = len - 1;\\n        int res = 0;\\n\\n        while(first < last){\\n            if(prices[first] > prices[last]){\\n                res = Math.max(res,prices[last] - prices[first]);\\n                first++;\\n            }\\n            else{\\n                res = Math.max(res,prices[last] - prices[first]);\\n                last--;\\n            }\\n\\n        }\\n        return res;\\n    }\\n}"
                    },
                    {
                        "username": "bparanj",
                        "content": "The reason this approach is not working for all test cases is due to the logic of how you\\'re trying to find the maximum profit. The maximum profit is not necessarily obtained from the difference of the first and last element in the array. Your approach assumes that we always need to consider the first and last elements in the array, and then compare the difference between the first element and the last element. If the first element is greater, then we move the pointer to the next one and vice versa.\\n\\nBut this approach is incorrect. In this problem, we want to find the maximum profit where the buying price (a smaller value) appears before the selling price (a larger value). Your approach doesn\\'t ensure this order. You may end up with a buying price that comes after the selling price.\\n\\nHere is the correct solution that scans from left to right and always tracks the minimum price (buying price) and calculates the profit if we sell at the current price.\\n\\n```java\\npublic class Solution {\\n    public int maxProfit(int prices[]) {\\n        int minprice = Integer.MAX_VALUE;\\n        int maxprofit = 0;\\n        for (int i = 0; i < prices.length; i++) {\\n            if (prices[i] < minprice)\\n                minprice = prices[i];\\n            else if (prices[i] - minprice > maxprofit)\\n                maxprofit = prices[i] - minprice;\\n        }\\n        return maxprofit;\\n    }\\n}\\n```\\n\\nThis ensures we always sell the stock after buying it and we maximize the profit."
                    },
                    {
                        "username": "Choubey_harsh",
                        "content": "\\nplz help what\\'s wrong with this code------\\nint maxProfit(vector<int>& prices) {\\n        int ansr=0,largest=0,n=prices.size();\\n        for(int i=0;i<n-1;i++){\\n            for(int j=i+1;j<n;j++){\\n                 ansr=prices[j]-prices[i];\\n            }\\n            if(ansr>largest){\\n                largest=ansr;\\n            }\\n            \\n        }\\n        return largest;\\n    }"
                    }
                ]
            },
            {
                "id": 1742562,
                "content": [
                    {
                        "username": "Pratik-Shrivastava",
                        "content": "\\u2705Simple || Java || 6 Lines Solution || Beats 100% || Easy to Understand\\nhttps://leetcode.com/problems/best-time-to-buy-and-sell-stock/solutions/3001669/simple-java-6-lines-solution-beats-100-easy-to-understand/"
                    },
                    {
                        "username": "aditya223307",
                        "content": "pls tell me what wrong with this approach?\\ncase1 and case2 rum but all test cases are not.\\n `int maxProfit(vector<int>& prices) {\\n       auto it = minmax_element(prices.begin(), prices.end());\\n       int min_index = distance(prices.begin(), it.first);\\n       int max_element = prices[min_index];\\n       for(int i=min_index; i<=prices.size()-min_index; i++){\\n           max_element= max(max_element, prices[i]);\\n       }\\n       if(prices[min_index] == max_element){\\n           return 0;\\n       }else{\\n           return max_element - prices[min_index];\\n       }\\n    }`"
                    },
                    {
                        "username": "aditya223307",
                        "content": "can anyone pls tell me what wrong with this approach?\\ncase1 and case2 run but all test cases are not correct.\\nint maxProfit(vector<int>& prices) {\\n       auto it = minmax_element(prices.begin(), prices.end());\\n       int min_index = distance(prices.begin(), it.first);\\n       int max_element = prices[min_index];\\n       for(int i=min_index; i<=prices.size()-min_index; i++){\\n           max_element= max(max_element, prices[i]);\\n       }\\n       if(prices[min_index] == max_element){\\n           return 0;\\n       }else{\\n           return max_element - prices[min_index];\\n       }\\n    }"
                    },
                    {
                        "username": "HinaKiran",
                        "content": "Ok so, i just want to reconfirm if i am getting the problem right or not because most of the test cases are passed but i am stuck at test case 102.\\nso it has an input of [2,4,1].\\nas long as i understood the problem is that it will check for the minimum number. here the smallest number is 1 and after that number index it will start searching for the biggest number and then it will just subtract and returns the answer. but if the smallest number is at the last index then it will return 0 then wht am i getting the wrong answer popup and here it says that expected answer is 2.\\ni dont know what is wrong with my code.\\nits in c# ..\\nwritng it down here so that someone can point it out.\\npublic int SingleNumber(int[] nums)\\n        {\\n            int max = nums[0];\\n            int min = nums[0];\\n            int index = 0;\\n            int minIndex = 0;\\n            int maxIndex = 0;\\n            for (int i=1;i<nums.Length;i++)\\n            {\\n                if (min > nums[i])\\n                {\\n                    min = nums[i];\\n                    minIndex = i;\\n                }\\n            }\\n            if (minIndex == nums.GetUpperBound(0))\\n            {\\n                return 0;\\n            }\\n            for(int j=minIndex; j<=nums.Length; j++)\\n            {\\n                if(j+1 <= nums.GetUpperBound(0))\\n                {\\n                    if (nums[j] < nums[j + 1])\\n                    {\\n                        max = nums[j + 1];\\n                        maxIndex = j + 1;\\n                    }\\n                    else\\n                    {\\n                        max = nums[j];\\n                        maxIndex = j;\\n                    }\\n                }\\n                if (j + 1 > nums.GetUpperBound(0))\\n                {\\n                    return index = nums[maxIndex] - nums[minIndex];\\n                }\\n\\n            }\\n            return index = nums[maxIndex] - nums[minIndex];\\n        }"
                    },
                    {
                        "username": "JCPrice0024",
                        "content": "The problem isn\\'t looking for the minimum buy price it\\'s looking for the maximum sell price. So in this case 4-2 = 2."
                    },
                    {
                        "username": "rashmi_jain18",
                        "content": "Wondering for the below example given in question, how max profit is 5? It should be 7 - if I buy stock on day2 i.e 1 and sell it on day3 at price 5. Again I buy stock on day4 at price 3 and sell on day5 at price 6. Total profit will be (5-1)+(6-3)=7\\nInput: prices = [7,1,5,3,6,4]\\nOutput: 5"
                    },
                    {
                        "username": "vinaykrishna",
                        "content": "should buy stock only once"
                    },
                    {
                        "username": "Beyond_Multiverse",
                        "content": "You can buy stocks atmost once"
                    },
                    {
                        "username": "sharadhachelka",
                        "content": "Could someone explain about buy price and sell price how to take?"
                    },
                    {
                        "username": "siddharthaverma6213",
                        "content": "       int profit = 0 ;\\n       for(int i =1 ; i<prices.size() ;i++){\\n     if(prices[i]>prices[i-1]) profit = profit + (prices[i] - prices[i-1]) ;\\n       } \\n     return profit ; \\n\\n\\nwhat is the problem with this code ? can somebody explain ?"
                    },
                    {
                        "username": "Beyond_Multiverse",
                        "content": "You\\'re comparing only consecutive days"
                    },
                    {
                        "username": "GeetMukherjee",
                        "content": "C++\\n\\nint maxProfit(vector<int>& prices) {\\n        int maxProfit = 0;\\n        int buy = prices[0];\\n        int n = prices.size();\\n\\n        if(n==2 && prices[1]>prices[0]){\\n            return prices[1]-prices[0];\\n        }\\n\\n        for(int i=1;i<n;i++){\\n            buy = min(buy, prices[i]);\\n            maxProfit = max(maxProfit, prices[i]-buy);\\n        }\\n        return maxProfit;\\n    }"
                    },
                    {
                        "username": "AKASHKUMARSINGH",
                        "content": "int maxProfit = -1e9 ;\\n            int minPrice = prices[0] ;\\n            for(int i = 0 ; i < prices.size() ; i++)\\n            {\\n                if(prices[i]-minPrice > maxProfit)\\n                {\\n                    maxProfit = prices[i] - minPrice ;\\n                }\\n                minPrice = min(minPrice , prices[i]);\\n            }\\n            return maxProfit ;\\n"
                    },
                    {
                        "username": "AKASHKUMARSINGH",
                        "content": "class Solution \\n{\\n    public:\\n        int maxProfit(vector<int>& prices) \\n        {\\n            int n = prices.size();\\n            int maxProfit = -1e9  ;\\n            vector<int>aux1(n);\\n            for(int i = n-1 ; i >= 0 ; i--)\\n            {\\n                aux1[i] = max(maxProfit , prices[i]);\\n                if(maxProfit < prices[i])\\n                {\\n                    maxProfit = prices[i] ;\\n                }\\n            }\\n            int maxDifference = -1e9 ;\\n            for(int i = 0 ; i < n ; i++)\\n            {\\n                int diff = aux1[i] - prices[i] ;\\n                if(diff > maxDifference)\\n                {\\n                    maxDifference = diff ;\\n                }\\n            }\\n            return maxDifference ;\\n        }\\n};"
                    }
                ]
            },
            {
                "id": 1742523,
                "content": [
                    {
                        "username": "Pratik-Shrivastava",
                        "content": "\\u2705Simple || Java || 6 Lines Solution || Beats 100% || Easy to Understand\\nhttps://leetcode.com/problems/best-time-to-buy-and-sell-stock/solutions/3001669/simple-java-6-lines-solution-beats-100-easy-to-understand/"
                    },
                    {
                        "username": "aditya223307",
                        "content": "pls tell me what wrong with this approach?\\ncase1 and case2 rum but all test cases are not.\\n `int maxProfit(vector<int>& prices) {\\n       auto it = minmax_element(prices.begin(), prices.end());\\n       int min_index = distance(prices.begin(), it.first);\\n       int max_element = prices[min_index];\\n       for(int i=min_index; i<=prices.size()-min_index; i++){\\n           max_element= max(max_element, prices[i]);\\n       }\\n       if(prices[min_index] == max_element){\\n           return 0;\\n       }else{\\n           return max_element - prices[min_index];\\n       }\\n    }`"
                    },
                    {
                        "username": "aditya223307",
                        "content": "can anyone pls tell me what wrong with this approach?\\ncase1 and case2 run but all test cases are not correct.\\nint maxProfit(vector<int>& prices) {\\n       auto it = minmax_element(prices.begin(), prices.end());\\n       int min_index = distance(prices.begin(), it.first);\\n       int max_element = prices[min_index];\\n       for(int i=min_index; i<=prices.size()-min_index; i++){\\n           max_element= max(max_element, prices[i]);\\n       }\\n       if(prices[min_index] == max_element){\\n           return 0;\\n       }else{\\n           return max_element - prices[min_index];\\n       }\\n    }"
                    },
                    {
                        "username": "HinaKiran",
                        "content": "Ok so, i just want to reconfirm if i am getting the problem right or not because most of the test cases are passed but i am stuck at test case 102.\\nso it has an input of [2,4,1].\\nas long as i understood the problem is that it will check for the minimum number. here the smallest number is 1 and after that number index it will start searching for the biggest number and then it will just subtract and returns the answer. but if the smallest number is at the last index then it will return 0 then wht am i getting the wrong answer popup and here it says that expected answer is 2.\\ni dont know what is wrong with my code.\\nits in c# ..\\nwritng it down here so that someone can point it out.\\npublic int SingleNumber(int[] nums)\\n        {\\n            int max = nums[0];\\n            int min = nums[0];\\n            int index = 0;\\n            int minIndex = 0;\\n            int maxIndex = 0;\\n            for (int i=1;i<nums.Length;i++)\\n            {\\n                if (min > nums[i])\\n                {\\n                    min = nums[i];\\n                    minIndex = i;\\n                }\\n            }\\n            if (minIndex == nums.GetUpperBound(0))\\n            {\\n                return 0;\\n            }\\n            for(int j=minIndex; j<=nums.Length; j++)\\n            {\\n                if(j+1 <= nums.GetUpperBound(0))\\n                {\\n                    if (nums[j] < nums[j + 1])\\n                    {\\n                        max = nums[j + 1];\\n                        maxIndex = j + 1;\\n                    }\\n                    else\\n                    {\\n                        max = nums[j];\\n                        maxIndex = j;\\n                    }\\n                }\\n                if (j + 1 > nums.GetUpperBound(0))\\n                {\\n                    return index = nums[maxIndex] - nums[minIndex];\\n                }\\n\\n            }\\n            return index = nums[maxIndex] - nums[minIndex];\\n        }"
                    },
                    {
                        "username": "JCPrice0024",
                        "content": "The problem isn\\'t looking for the minimum buy price it\\'s looking for the maximum sell price. So in this case 4-2 = 2."
                    },
                    {
                        "username": "rashmi_jain18",
                        "content": "Wondering for the below example given in question, how max profit is 5? It should be 7 - if I buy stock on day2 i.e 1 and sell it on day3 at price 5. Again I buy stock on day4 at price 3 and sell on day5 at price 6. Total profit will be (5-1)+(6-3)=7\\nInput: prices = [7,1,5,3,6,4]\\nOutput: 5"
                    },
                    {
                        "username": "vinaykrishna",
                        "content": "should buy stock only once"
                    },
                    {
                        "username": "Beyond_Multiverse",
                        "content": "You can buy stocks atmost once"
                    },
                    {
                        "username": "sharadhachelka",
                        "content": "Could someone explain about buy price and sell price how to take?"
                    },
                    {
                        "username": "siddharthaverma6213",
                        "content": "       int profit = 0 ;\\n       for(int i =1 ; i<prices.size() ;i++){\\n     if(prices[i]>prices[i-1]) profit = profit + (prices[i] - prices[i-1]) ;\\n       } \\n     return profit ; \\n\\n\\nwhat is the problem with this code ? can somebody explain ?"
                    },
                    {
                        "username": "Beyond_Multiverse",
                        "content": "You\\'re comparing only consecutive days"
                    },
                    {
                        "username": "GeetMukherjee",
                        "content": "C++\\n\\nint maxProfit(vector<int>& prices) {\\n        int maxProfit = 0;\\n        int buy = prices[0];\\n        int n = prices.size();\\n\\n        if(n==2 && prices[1]>prices[0]){\\n            return prices[1]-prices[0];\\n        }\\n\\n        for(int i=1;i<n;i++){\\n            buy = min(buy, prices[i]);\\n            maxProfit = max(maxProfit, prices[i]-buy);\\n        }\\n        return maxProfit;\\n    }"
                    },
                    {
                        "username": "AKASHKUMARSINGH",
                        "content": "int maxProfit = -1e9 ;\\n            int minPrice = prices[0] ;\\n            for(int i = 0 ; i < prices.size() ; i++)\\n            {\\n                if(prices[i]-minPrice > maxProfit)\\n                {\\n                    maxProfit = prices[i] - minPrice ;\\n                }\\n                minPrice = min(minPrice , prices[i]);\\n            }\\n            return maxProfit ;\\n"
                    },
                    {
                        "username": "AKASHKUMARSINGH",
                        "content": "class Solution \\n{\\n    public:\\n        int maxProfit(vector<int>& prices) \\n        {\\n            int n = prices.size();\\n            int maxProfit = -1e9  ;\\n            vector<int>aux1(n);\\n            for(int i = n-1 ; i >= 0 ; i--)\\n            {\\n                aux1[i] = max(maxProfit , prices[i]);\\n                if(maxProfit < prices[i])\\n                {\\n                    maxProfit = prices[i] ;\\n                }\\n            }\\n            int maxDifference = -1e9 ;\\n            for(int i = 0 ; i < n ; i++)\\n            {\\n                int diff = aux1[i] - prices[i] ;\\n                if(diff > maxDifference)\\n                {\\n                    maxDifference = diff ;\\n                }\\n            }\\n            return maxDifference ;\\n        }\\n};"
                    }
                ]
            },
            {
                "id": 1742514,
                "content": [
                    {
                        "username": "Pratik-Shrivastava",
                        "content": "\\u2705Simple || Java || 6 Lines Solution || Beats 100% || Easy to Understand\\nhttps://leetcode.com/problems/best-time-to-buy-and-sell-stock/solutions/3001669/simple-java-6-lines-solution-beats-100-easy-to-understand/"
                    },
                    {
                        "username": "aditya223307",
                        "content": "pls tell me what wrong with this approach?\\ncase1 and case2 rum but all test cases are not.\\n `int maxProfit(vector<int>& prices) {\\n       auto it = minmax_element(prices.begin(), prices.end());\\n       int min_index = distance(prices.begin(), it.first);\\n       int max_element = prices[min_index];\\n       for(int i=min_index; i<=prices.size()-min_index; i++){\\n           max_element= max(max_element, prices[i]);\\n       }\\n       if(prices[min_index] == max_element){\\n           return 0;\\n       }else{\\n           return max_element - prices[min_index];\\n       }\\n    }`"
                    },
                    {
                        "username": "aditya223307",
                        "content": "can anyone pls tell me what wrong with this approach?\\ncase1 and case2 run but all test cases are not correct.\\nint maxProfit(vector<int>& prices) {\\n       auto it = minmax_element(prices.begin(), prices.end());\\n       int min_index = distance(prices.begin(), it.first);\\n       int max_element = prices[min_index];\\n       for(int i=min_index; i<=prices.size()-min_index; i++){\\n           max_element= max(max_element, prices[i]);\\n       }\\n       if(prices[min_index] == max_element){\\n           return 0;\\n       }else{\\n           return max_element - prices[min_index];\\n       }\\n    }"
                    },
                    {
                        "username": "HinaKiran",
                        "content": "Ok so, i just want to reconfirm if i am getting the problem right or not because most of the test cases are passed but i am stuck at test case 102.\\nso it has an input of [2,4,1].\\nas long as i understood the problem is that it will check for the minimum number. here the smallest number is 1 and after that number index it will start searching for the biggest number and then it will just subtract and returns the answer. but if the smallest number is at the last index then it will return 0 then wht am i getting the wrong answer popup and here it says that expected answer is 2.\\ni dont know what is wrong with my code.\\nits in c# ..\\nwritng it down here so that someone can point it out.\\npublic int SingleNumber(int[] nums)\\n        {\\n            int max = nums[0];\\n            int min = nums[0];\\n            int index = 0;\\n            int minIndex = 0;\\n            int maxIndex = 0;\\n            for (int i=1;i<nums.Length;i++)\\n            {\\n                if (min > nums[i])\\n                {\\n                    min = nums[i];\\n                    minIndex = i;\\n                }\\n            }\\n            if (minIndex == nums.GetUpperBound(0))\\n            {\\n                return 0;\\n            }\\n            for(int j=minIndex; j<=nums.Length; j++)\\n            {\\n                if(j+1 <= nums.GetUpperBound(0))\\n                {\\n                    if (nums[j] < nums[j + 1])\\n                    {\\n                        max = nums[j + 1];\\n                        maxIndex = j + 1;\\n                    }\\n                    else\\n                    {\\n                        max = nums[j];\\n                        maxIndex = j;\\n                    }\\n                }\\n                if (j + 1 > nums.GetUpperBound(0))\\n                {\\n                    return index = nums[maxIndex] - nums[minIndex];\\n                }\\n\\n            }\\n            return index = nums[maxIndex] - nums[minIndex];\\n        }"
                    },
                    {
                        "username": "JCPrice0024",
                        "content": "The problem isn\\'t looking for the minimum buy price it\\'s looking for the maximum sell price. So in this case 4-2 = 2."
                    },
                    {
                        "username": "rashmi_jain18",
                        "content": "Wondering for the below example given in question, how max profit is 5? It should be 7 - if I buy stock on day2 i.e 1 and sell it on day3 at price 5. Again I buy stock on day4 at price 3 and sell on day5 at price 6. Total profit will be (5-1)+(6-3)=7\\nInput: prices = [7,1,5,3,6,4]\\nOutput: 5"
                    },
                    {
                        "username": "vinaykrishna",
                        "content": "should buy stock only once"
                    },
                    {
                        "username": "Beyond_Multiverse",
                        "content": "You can buy stocks atmost once"
                    },
                    {
                        "username": "sharadhachelka",
                        "content": "Could someone explain about buy price and sell price how to take?"
                    },
                    {
                        "username": "siddharthaverma6213",
                        "content": "       int profit = 0 ;\\n       for(int i =1 ; i<prices.size() ;i++){\\n     if(prices[i]>prices[i-1]) profit = profit + (prices[i] - prices[i-1]) ;\\n       } \\n     return profit ; \\n\\n\\nwhat is the problem with this code ? can somebody explain ?"
                    },
                    {
                        "username": "Beyond_Multiverse",
                        "content": "You\\'re comparing only consecutive days"
                    },
                    {
                        "username": "GeetMukherjee",
                        "content": "C++\\n\\nint maxProfit(vector<int>& prices) {\\n        int maxProfit = 0;\\n        int buy = prices[0];\\n        int n = prices.size();\\n\\n        if(n==2 && prices[1]>prices[0]){\\n            return prices[1]-prices[0];\\n        }\\n\\n        for(int i=1;i<n;i++){\\n            buy = min(buy, prices[i]);\\n            maxProfit = max(maxProfit, prices[i]-buy);\\n        }\\n        return maxProfit;\\n    }"
                    },
                    {
                        "username": "AKASHKUMARSINGH",
                        "content": "int maxProfit = -1e9 ;\\n            int minPrice = prices[0] ;\\n            for(int i = 0 ; i < prices.size() ; i++)\\n            {\\n                if(prices[i]-minPrice > maxProfit)\\n                {\\n                    maxProfit = prices[i] - minPrice ;\\n                }\\n                minPrice = min(minPrice , prices[i]);\\n            }\\n            return maxProfit ;\\n"
                    },
                    {
                        "username": "AKASHKUMARSINGH",
                        "content": "class Solution \\n{\\n    public:\\n        int maxProfit(vector<int>& prices) \\n        {\\n            int n = prices.size();\\n            int maxProfit = -1e9  ;\\n            vector<int>aux1(n);\\n            for(int i = n-1 ; i >= 0 ; i--)\\n            {\\n                aux1[i] = max(maxProfit , prices[i]);\\n                if(maxProfit < prices[i])\\n                {\\n                    maxProfit = prices[i] ;\\n                }\\n            }\\n            int maxDifference = -1e9 ;\\n            for(int i = 0 ; i < n ; i++)\\n            {\\n                int diff = aux1[i] - prices[i] ;\\n                if(diff > maxDifference)\\n                {\\n                    maxDifference = diff ;\\n                }\\n            }\\n            return maxDifference ;\\n        }\\n};"
                    }
                ]
            },
            {
                "id": 1739404,
                "content": [
                    {
                        "username": "Pratik-Shrivastava",
                        "content": "\\u2705Simple || Java || 6 Lines Solution || Beats 100% || Easy to Understand\\nhttps://leetcode.com/problems/best-time-to-buy-and-sell-stock/solutions/3001669/simple-java-6-lines-solution-beats-100-easy-to-understand/"
                    },
                    {
                        "username": "aditya223307",
                        "content": "pls tell me what wrong with this approach?\\ncase1 and case2 rum but all test cases are not.\\n `int maxProfit(vector<int>& prices) {\\n       auto it = minmax_element(prices.begin(), prices.end());\\n       int min_index = distance(prices.begin(), it.first);\\n       int max_element = prices[min_index];\\n       for(int i=min_index; i<=prices.size()-min_index; i++){\\n           max_element= max(max_element, prices[i]);\\n       }\\n       if(prices[min_index] == max_element){\\n           return 0;\\n       }else{\\n           return max_element - prices[min_index];\\n       }\\n    }`"
                    },
                    {
                        "username": "aditya223307",
                        "content": "can anyone pls tell me what wrong with this approach?\\ncase1 and case2 run but all test cases are not correct.\\nint maxProfit(vector<int>& prices) {\\n       auto it = minmax_element(prices.begin(), prices.end());\\n       int min_index = distance(prices.begin(), it.first);\\n       int max_element = prices[min_index];\\n       for(int i=min_index; i<=prices.size()-min_index; i++){\\n           max_element= max(max_element, prices[i]);\\n       }\\n       if(prices[min_index] == max_element){\\n           return 0;\\n       }else{\\n           return max_element - prices[min_index];\\n       }\\n    }"
                    },
                    {
                        "username": "HinaKiran",
                        "content": "Ok so, i just want to reconfirm if i am getting the problem right or not because most of the test cases are passed but i am stuck at test case 102.\\nso it has an input of [2,4,1].\\nas long as i understood the problem is that it will check for the minimum number. here the smallest number is 1 and after that number index it will start searching for the biggest number and then it will just subtract and returns the answer. but if the smallest number is at the last index then it will return 0 then wht am i getting the wrong answer popup and here it says that expected answer is 2.\\ni dont know what is wrong with my code.\\nits in c# ..\\nwritng it down here so that someone can point it out.\\npublic int SingleNumber(int[] nums)\\n        {\\n            int max = nums[0];\\n            int min = nums[0];\\n            int index = 0;\\n            int minIndex = 0;\\n            int maxIndex = 0;\\n            for (int i=1;i<nums.Length;i++)\\n            {\\n                if (min > nums[i])\\n                {\\n                    min = nums[i];\\n                    minIndex = i;\\n                }\\n            }\\n            if (minIndex == nums.GetUpperBound(0))\\n            {\\n                return 0;\\n            }\\n            for(int j=minIndex; j<=nums.Length; j++)\\n            {\\n                if(j+1 <= nums.GetUpperBound(0))\\n                {\\n                    if (nums[j] < nums[j + 1])\\n                    {\\n                        max = nums[j + 1];\\n                        maxIndex = j + 1;\\n                    }\\n                    else\\n                    {\\n                        max = nums[j];\\n                        maxIndex = j;\\n                    }\\n                }\\n                if (j + 1 > nums.GetUpperBound(0))\\n                {\\n                    return index = nums[maxIndex] - nums[minIndex];\\n                }\\n\\n            }\\n            return index = nums[maxIndex] - nums[minIndex];\\n        }"
                    },
                    {
                        "username": "JCPrice0024",
                        "content": "The problem isn\\'t looking for the minimum buy price it\\'s looking for the maximum sell price. So in this case 4-2 = 2."
                    },
                    {
                        "username": "rashmi_jain18",
                        "content": "Wondering for the below example given in question, how max profit is 5? It should be 7 - if I buy stock on day2 i.e 1 and sell it on day3 at price 5. Again I buy stock on day4 at price 3 and sell on day5 at price 6. Total profit will be (5-1)+(6-3)=7\\nInput: prices = [7,1,5,3,6,4]\\nOutput: 5"
                    },
                    {
                        "username": "vinaykrishna",
                        "content": "should buy stock only once"
                    },
                    {
                        "username": "Beyond_Multiverse",
                        "content": "You can buy stocks atmost once"
                    },
                    {
                        "username": "sharadhachelka",
                        "content": "Could someone explain about buy price and sell price how to take?"
                    },
                    {
                        "username": "siddharthaverma6213",
                        "content": "       int profit = 0 ;\\n       for(int i =1 ; i<prices.size() ;i++){\\n     if(prices[i]>prices[i-1]) profit = profit + (prices[i] - prices[i-1]) ;\\n       } \\n     return profit ; \\n\\n\\nwhat is the problem with this code ? can somebody explain ?"
                    },
                    {
                        "username": "Beyond_Multiverse",
                        "content": "You\\'re comparing only consecutive days"
                    },
                    {
                        "username": "GeetMukherjee",
                        "content": "C++\\n\\nint maxProfit(vector<int>& prices) {\\n        int maxProfit = 0;\\n        int buy = prices[0];\\n        int n = prices.size();\\n\\n        if(n==2 && prices[1]>prices[0]){\\n            return prices[1]-prices[0];\\n        }\\n\\n        for(int i=1;i<n;i++){\\n            buy = min(buy, prices[i]);\\n            maxProfit = max(maxProfit, prices[i]-buy);\\n        }\\n        return maxProfit;\\n    }"
                    },
                    {
                        "username": "AKASHKUMARSINGH",
                        "content": "int maxProfit = -1e9 ;\\n            int minPrice = prices[0] ;\\n            for(int i = 0 ; i < prices.size() ; i++)\\n            {\\n                if(prices[i]-minPrice > maxProfit)\\n                {\\n                    maxProfit = prices[i] - minPrice ;\\n                }\\n                minPrice = min(minPrice , prices[i]);\\n            }\\n            return maxProfit ;\\n"
                    },
                    {
                        "username": "AKASHKUMARSINGH",
                        "content": "class Solution \\n{\\n    public:\\n        int maxProfit(vector<int>& prices) \\n        {\\n            int n = prices.size();\\n            int maxProfit = -1e9  ;\\n            vector<int>aux1(n);\\n            for(int i = n-1 ; i >= 0 ; i--)\\n            {\\n                aux1[i] = max(maxProfit , prices[i]);\\n                if(maxProfit < prices[i])\\n                {\\n                    maxProfit = prices[i] ;\\n                }\\n            }\\n            int maxDifference = -1e9 ;\\n            for(int i = 0 ; i < n ; i++)\\n            {\\n                int diff = aux1[i] - prices[i] ;\\n                if(diff > maxDifference)\\n                {\\n                    maxDifference = diff ;\\n                }\\n            }\\n            return maxDifference ;\\n        }\\n};"
                    }
                ]
            },
            {
                "id": 1738875,
                "content": [
                    {
                        "username": "Pratik-Shrivastava",
                        "content": "\\u2705Simple || Java || 6 Lines Solution || Beats 100% || Easy to Understand\\nhttps://leetcode.com/problems/best-time-to-buy-and-sell-stock/solutions/3001669/simple-java-6-lines-solution-beats-100-easy-to-understand/"
                    },
                    {
                        "username": "aditya223307",
                        "content": "pls tell me what wrong with this approach?\\ncase1 and case2 rum but all test cases are not.\\n `int maxProfit(vector<int>& prices) {\\n       auto it = minmax_element(prices.begin(), prices.end());\\n       int min_index = distance(prices.begin(), it.first);\\n       int max_element = prices[min_index];\\n       for(int i=min_index; i<=prices.size()-min_index; i++){\\n           max_element= max(max_element, prices[i]);\\n       }\\n       if(prices[min_index] == max_element){\\n           return 0;\\n       }else{\\n           return max_element - prices[min_index];\\n       }\\n    }`"
                    },
                    {
                        "username": "aditya223307",
                        "content": "can anyone pls tell me what wrong with this approach?\\ncase1 and case2 run but all test cases are not correct.\\nint maxProfit(vector<int>& prices) {\\n       auto it = minmax_element(prices.begin(), prices.end());\\n       int min_index = distance(prices.begin(), it.first);\\n       int max_element = prices[min_index];\\n       for(int i=min_index; i<=prices.size()-min_index; i++){\\n           max_element= max(max_element, prices[i]);\\n       }\\n       if(prices[min_index] == max_element){\\n           return 0;\\n       }else{\\n           return max_element - prices[min_index];\\n       }\\n    }"
                    },
                    {
                        "username": "HinaKiran",
                        "content": "Ok so, i just want to reconfirm if i am getting the problem right or not because most of the test cases are passed but i am stuck at test case 102.\\nso it has an input of [2,4,1].\\nas long as i understood the problem is that it will check for the minimum number. here the smallest number is 1 and after that number index it will start searching for the biggest number and then it will just subtract and returns the answer. but if the smallest number is at the last index then it will return 0 then wht am i getting the wrong answer popup and here it says that expected answer is 2.\\ni dont know what is wrong with my code.\\nits in c# ..\\nwritng it down here so that someone can point it out.\\npublic int SingleNumber(int[] nums)\\n        {\\n            int max = nums[0];\\n            int min = nums[0];\\n            int index = 0;\\n            int minIndex = 0;\\n            int maxIndex = 0;\\n            for (int i=1;i<nums.Length;i++)\\n            {\\n                if (min > nums[i])\\n                {\\n                    min = nums[i];\\n                    minIndex = i;\\n                }\\n            }\\n            if (minIndex == nums.GetUpperBound(0))\\n            {\\n                return 0;\\n            }\\n            for(int j=minIndex; j<=nums.Length; j++)\\n            {\\n                if(j+1 <= nums.GetUpperBound(0))\\n                {\\n                    if (nums[j] < nums[j + 1])\\n                    {\\n                        max = nums[j + 1];\\n                        maxIndex = j + 1;\\n                    }\\n                    else\\n                    {\\n                        max = nums[j];\\n                        maxIndex = j;\\n                    }\\n                }\\n                if (j + 1 > nums.GetUpperBound(0))\\n                {\\n                    return index = nums[maxIndex] - nums[minIndex];\\n                }\\n\\n            }\\n            return index = nums[maxIndex] - nums[minIndex];\\n        }"
                    },
                    {
                        "username": "JCPrice0024",
                        "content": "The problem isn\\'t looking for the minimum buy price it\\'s looking for the maximum sell price. So in this case 4-2 = 2."
                    },
                    {
                        "username": "rashmi_jain18",
                        "content": "Wondering for the below example given in question, how max profit is 5? It should be 7 - if I buy stock on day2 i.e 1 and sell it on day3 at price 5. Again I buy stock on day4 at price 3 and sell on day5 at price 6. Total profit will be (5-1)+(6-3)=7\\nInput: prices = [7,1,5,3,6,4]\\nOutput: 5"
                    },
                    {
                        "username": "vinaykrishna",
                        "content": "should buy stock only once"
                    },
                    {
                        "username": "Beyond_Multiverse",
                        "content": "You can buy stocks atmost once"
                    },
                    {
                        "username": "sharadhachelka",
                        "content": "Could someone explain about buy price and sell price how to take?"
                    },
                    {
                        "username": "siddharthaverma6213",
                        "content": "       int profit = 0 ;\\n       for(int i =1 ; i<prices.size() ;i++){\\n     if(prices[i]>prices[i-1]) profit = profit + (prices[i] - prices[i-1]) ;\\n       } \\n     return profit ; \\n\\n\\nwhat is the problem with this code ? can somebody explain ?"
                    },
                    {
                        "username": "Beyond_Multiverse",
                        "content": "You\\'re comparing only consecutive days"
                    },
                    {
                        "username": "GeetMukherjee",
                        "content": "C++\\n\\nint maxProfit(vector<int>& prices) {\\n        int maxProfit = 0;\\n        int buy = prices[0];\\n        int n = prices.size();\\n\\n        if(n==2 && prices[1]>prices[0]){\\n            return prices[1]-prices[0];\\n        }\\n\\n        for(int i=1;i<n;i++){\\n            buy = min(buy, prices[i]);\\n            maxProfit = max(maxProfit, prices[i]-buy);\\n        }\\n        return maxProfit;\\n    }"
                    },
                    {
                        "username": "AKASHKUMARSINGH",
                        "content": "int maxProfit = -1e9 ;\\n            int minPrice = prices[0] ;\\n            for(int i = 0 ; i < prices.size() ; i++)\\n            {\\n                if(prices[i]-minPrice > maxProfit)\\n                {\\n                    maxProfit = prices[i] - minPrice ;\\n                }\\n                minPrice = min(minPrice , prices[i]);\\n            }\\n            return maxProfit ;\\n"
                    },
                    {
                        "username": "AKASHKUMARSINGH",
                        "content": "class Solution \\n{\\n    public:\\n        int maxProfit(vector<int>& prices) \\n        {\\n            int n = prices.size();\\n            int maxProfit = -1e9  ;\\n            vector<int>aux1(n);\\n            for(int i = n-1 ; i >= 0 ; i--)\\n            {\\n                aux1[i] = max(maxProfit , prices[i]);\\n                if(maxProfit < prices[i])\\n                {\\n                    maxProfit = prices[i] ;\\n                }\\n            }\\n            int maxDifference = -1e9 ;\\n            for(int i = 0 ; i < n ; i++)\\n            {\\n                int diff = aux1[i] - prices[i] ;\\n                if(diff > maxDifference)\\n                {\\n                    maxDifference = diff ;\\n                }\\n            }\\n            return maxDifference ;\\n        }\\n};"
                    }
                ]
            },
            {
                "id": 1733050,
                "content": [
                    {
                        "username": "Pratik-Shrivastava",
                        "content": "\\u2705Simple || Java || 6 Lines Solution || Beats 100% || Easy to Understand\\nhttps://leetcode.com/problems/best-time-to-buy-and-sell-stock/solutions/3001669/simple-java-6-lines-solution-beats-100-easy-to-understand/"
                    },
                    {
                        "username": "aditya223307",
                        "content": "pls tell me what wrong with this approach?\\ncase1 and case2 rum but all test cases are not.\\n `int maxProfit(vector<int>& prices) {\\n       auto it = minmax_element(prices.begin(), prices.end());\\n       int min_index = distance(prices.begin(), it.first);\\n       int max_element = prices[min_index];\\n       for(int i=min_index; i<=prices.size()-min_index; i++){\\n           max_element= max(max_element, prices[i]);\\n       }\\n       if(prices[min_index] == max_element){\\n           return 0;\\n       }else{\\n           return max_element - prices[min_index];\\n       }\\n    }`"
                    },
                    {
                        "username": "aditya223307",
                        "content": "can anyone pls tell me what wrong with this approach?\\ncase1 and case2 run but all test cases are not correct.\\nint maxProfit(vector<int>& prices) {\\n       auto it = minmax_element(prices.begin(), prices.end());\\n       int min_index = distance(prices.begin(), it.first);\\n       int max_element = prices[min_index];\\n       for(int i=min_index; i<=prices.size()-min_index; i++){\\n           max_element= max(max_element, prices[i]);\\n       }\\n       if(prices[min_index] == max_element){\\n           return 0;\\n       }else{\\n           return max_element - prices[min_index];\\n       }\\n    }"
                    },
                    {
                        "username": "HinaKiran",
                        "content": "Ok so, i just want to reconfirm if i am getting the problem right or not because most of the test cases are passed but i am stuck at test case 102.\\nso it has an input of [2,4,1].\\nas long as i understood the problem is that it will check for the minimum number. here the smallest number is 1 and after that number index it will start searching for the biggest number and then it will just subtract and returns the answer. but if the smallest number is at the last index then it will return 0 then wht am i getting the wrong answer popup and here it says that expected answer is 2.\\ni dont know what is wrong with my code.\\nits in c# ..\\nwritng it down here so that someone can point it out.\\npublic int SingleNumber(int[] nums)\\n        {\\n            int max = nums[0];\\n            int min = nums[0];\\n            int index = 0;\\n            int minIndex = 0;\\n            int maxIndex = 0;\\n            for (int i=1;i<nums.Length;i++)\\n            {\\n                if (min > nums[i])\\n                {\\n                    min = nums[i];\\n                    minIndex = i;\\n                }\\n            }\\n            if (minIndex == nums.GetUpperBound(0))\\n            {\\n                return 0;\\n            }\\n            for(int j=minIndex; j<=nums.Length; j++)\\n            {\\n                if(j+1 <= nums.GetUpperBound(0))\\n                {\\n                    if (nums[j] < nums[j + 1])\\n                    {\\n                        max = nums[j + 1];\\n                        maxIndex = j + 1;\\n                    }\\n                    else\\n                    {\\n                        max = nums[j];\\n                        maxIndex = j;\\n                    }\\n                }\\n                if (j + 1 > nums.GetUpperBound(0))\\n                {\\n                    return index = nums[maxIndex] - nums[minIndex];\\n                }\\n\\n            }\\n            return index = nums[maxIndex] - nums[minIndex];\\n        }"
                    },
                    {
                        "username": "JCPrice0024",
                        "content": "The problem isn\\'t looking for the minimum buy price it\\'s looking for the maximum sell price. So in this case 4-2 = 2."
                    },
                    {
                        "username": "rashmi_jain18",
                        "content": "Wondering for the below example given in question, how max profit is 5? It should be 7 - if I buy stock on day2 i.e 1 and sell it on day3 at price 5. Again I buy stock on day4 at price 3 and sell on day5 at price 6. Total profit will be (5-1)+(6-3)=7\\nInput: prices = [7,1,5,3,6,4]\\nOutput: 5"
                    },
                    {
                        "username": "vinaykrishna",
                        "content": "should buy stock only once"
                    },
                    {
                        "username": "Beyond_Multiverse",
                        "content": "You can buy stocks atmost once"
                    },
                    {
                        "username": "sharadhachelka",
                        "content": "Could someone explain about buy price and sell price how to take?"
                    },
                    {
                        "username": "siddharthaverma6213",
                        "content": "       int profit = 0 ;\\n       for(int i =1 ; i<prices.size() ;i++){\\n     if(prices[i]>prices[i-1]) profit = profit + (prices[i] - prices[i-1]) ;\\n       } \\n     return profit ; \\n\\n\\nwhat is the problem with this code ? can somebody explain ?"
                    },
                    {
                        "username": "Beyond_Multiverse",
                        "content": "You\\'re comparing only consecutive days"
                    },
                    {
                        "username": "GeetMukherjee",
                        "content": "C++\\n\\nint maxProfit(vector<int>& prices) {\\n        int maxProfit = 0;\\n        int buy = prices[0];\\n        int n = prices.size();\\n\\n        if(n==2 && prices[1]>prices[0]){\\n            return prices[1]-prices[0];\\n        }\\n\\n        for(int i=1;i<n;i++){\\n            buy = min(buy, prices[i]);\\n            maxProfit = max(maxProfit, prices[i]-buy);\\n        }\\n        return maxProfit;\\n    }"
                    },
                    {
                        "username": "AKASHKUMARSINGH",
                        "content": "int maxProfit = -1e9 ;\\n            int minPrice = prices[0] ;\\n            for(int i = 0 ; i < prices.size() ; i++)\\n            {\\n                if(prices[i]-minPrice > maxProfit)\\n                {\\n                    maxProfit = prices[i] - minPrice ;\\n                }\\n                minPrice = min(minPrice , prices[i]);\\n            }\\n            return maxProfit ;\\n"
                    },
                    {
                        "username": "AKASHKUMARSINGH",
                        "content": "class Solution \\n{\\n    public:\\n        int maxProfit(vector<int>& prices) \\n        {\\n            int n = prices.size();\\n            int maxProfit = -1e9  ;\\n            vector<int>aux1(n);\\n            for(int i = n-1 ; i >= 0 ; i--)\\n            {\\n                aux1[i] = max(maxProfit , prices[i]);\\n                if(maxProfit < prices[i])\\n                {\\n                    maxProfit = prices[i] ;\\n                }\\n            }\\n            int maxDifference = -1e9 ;\\n            for(int i = 0 ; i < n ; i++)\\n            {\\n                int diff = aux1[i] - prices[i] ;\\n                if(diff > maxDifference)\\n                {\\n                    maxDifference = diff ;\\n                }\\n            }\\n            return maxDifference ;\\n        }\\n};"
                    }
                ]
            },
            {
                "id": 1732900,
                "content": [
                    {
                        "username": "Pratik-Shrivastava",
                        "content": "\\u2705Simple || Java || 6 Lines Solution || Beats 100% || Easy to Understand\\nhttps://leetcode.com/problems/best-time-to-buy-and-sell-stock/solutions/3001669/simple-java-6-lines-solution-beats-100-easy-to-understand/"
                    },
                    {
                        "username": "aditya223307",
                        "content": "pls tell me what wrong with this approach?\\ncase1 and case2 rum but all test cases are not.\\n `int maxProfit(vector<int>& prices) {\\n       auto it = minmax_element(prices.begin(), prices.end());\\n       int min_index = distance(prices.begin(), it.first);\\n       int max_element = prices[min_index];\\n       for(int i=min_index; i<=prices.size()-min_index; i++){\\n           max_element= max(max_element, prices[i]);\\n       }\\n       if(prices[min_index] == max_element){\\n           return 0;\\n       }else{\\n           return max_element - prices[min_index];\\n       }\\n    }`"
                    },
                    {
                        "username": "aditya223307",
                        "content": "can anyone pls tell me what wrong with this approach?\\ncase1 and case2 run but all test cases are not correct.\\nint maxProfit(vector<int>& prices) {\\n       auto it = minmax_element(prices.begin(), prices.end());\\n       int min_index = distance(prices.begin(), it.first);\\n       int max_element = prices[min_index];\\n       for(int i=min_index; i<=prices.size()-min_index; i++){\\n           max_element= max(max_element, prices[i]);\\n       }\\n       if(prices[min_index] == max_element){\\n           return 0;\\n       }else{\\n           return max_element - prices[min_index];\\n       }\\n    }"
                    },
                    {
                        "username": "HinaKiran",
                        "content": "Ok so, i just want to reconfirm if i am getting the problem right or not because most of the test cases are passed but i am stuck at test case 102.\\nso it has an input of [2,4,1].\\nas long as i understood the problem is that it will check for the minimum number. here the smallest number is 1 and after that number index it will start searching for the biggest number and then it will just subtract and returns the answer. but if the smallest number is at the last index then it will return 0 then wht am i getting the wrong answer popup and here it says that expected answer is 2.\\ni dont know what is wrong with my code.\\nits in c# ..\\nwritng it down here so that someone can point it out.\\npublic int SingleNumber(int[] nums)\\n        {\\n            int max = nums[0];\\n            int min = nums[0];\\n            int index = 0;\\n            int minIndex = 0;\\n            int maxIndex = 0;\\n            for (int i=1;i<nums.Length;i++)\\n            {\\n                if (min > nums[i])\\n                {\\n                    min = nums[i];\\n                    minIndex = i;\\n                }\\n            }\\n            if (minIndex == nums.GetUpperBound(0))\\n            {\\n                return 0;\\n            }\\n            for(int j=minIndex; j<=nums.Length; j++)\\n            {\\n                if(j+1 <= nums.GetUpperBound(0))\\n                {\\n                    if (nums[j] < nums[j + 1])\\n                    {\\n                        max = nums[j + 1];\\n                        maxIndex = j + 1;\\n                    }\\n                    else\\n                    {\\n                        max = nums[j];\\n                        maxIndex = j;\\n                    }\\n                }\\n                if (j + 1 > nums.GetUpperBound(0))\\n                {\\n                    return index = nums[maxIndex] - nums[minIndex];\\n                }\\n\\n            }\\n            return index = nums[maxIndex] - nums[minIndex];\\n        }"
                    },
                    {
                        "username": "JCPrice0024",
                        "content": "The problem isn\\'t looking for the minimum buy price it\\'s looking for the maximum sell price. So in this case 4-2 = 2."
                    },
                    {
                        "username": "rashmi_jain18",
                        "content": "Wondering for the below example given in question, how max profit is 5? It should be 7 - if I buy stock on day2 i.e 1 and sell it on day3 at price 5. Again I buy stock on day4 at price 3 and sell on day5 at price 6. Total profit will be (5-1)+(6-3)=7\\nInput: prices = [7,1,5,3,6,4]\\nOutput: 5"
                    },
                    {
                        "username": "vinaykrishna",
                        "content": "should buy stock only once"
                    },
                    {
                        "username": "Beyond_Multiverse",
                        "content": "You can buy stocks atmost once"
                    },
                    {
                        "username": "sharadhachelka",
                        "content": "Could someone explain about buy price and sell price how to take?"
                    },
                    {
                        "username": "siddharthaverma6213",
                        "content": "       int profit = 0 ;\\n       for(int i =1 ; i<prices.size() ;i++){\\n     if(prices[i]>prices[i-1]) profit = profit + (prices[i] - prices[i-1]) ;\\n       } \\n     return profit ; \\n\\n\\nwhat is the problem with this code ? can somebody explain ?"
                    },
                    {
                        "username": "Beyond_Multiverse",
                        "content": "You\\'re comparing only consecutive days"
                    },
                    {
                        "username": "GeetMukherjee",
                        "content": "C++\\n\\nint maxProfit(vector<int>& prices) {\\n        int maxProfit = 0;\\n        int buy = prices[0];\\n        int n = prices.size();\\n\\n        if(n==2 && prices[1]>prices[0]){\\n            return prices[1]-prices[0];\\n        }\\n\\n        for(int i=1;i<n;i++){\\n            buy = min(buy, prices[i]);\\n            maxProfit = max(maxProfit, prices[i]-buy);\\n        }\\n        return maxProfit;\\n    }"
                    },
                    {
                        "username": "AKASHKUMARSINGH",
                        "content": "int maxProfit = -1e9 ;\\n            int minPrice = prices[0] ;\\n            for(int i = 0 ; i < prices.size() ; i++)\\n            {\\n                if(prices[i]-minPrice > maxProfit)\\n                {\\n                    maxProfit = prices[i] - minPrice ;\\n                }\\n                minPrice = min(minPrice , prices[i]);\\n            }\\n            return maxProfit ;\\n"
                    },
                    {
                        "username": "AKASHKUMARSINGH",
                        "content": "class Solution \\n{\\n    public:\\n        int maxProfit(vector<int>& prices) \\n        {\\n            int n = prices.size();\\n            int maxProfit = -1e9  ;\\n            vector<int>aux1(n);\\n            for(int i = n-1 ; i >= 0 ; i--)\\n            {\\n                aux1[i] = max(maxProfit , prices[i]);\\n                if(maxProfit < prices[i])\\n                {\\n                    maxProfit = prices[i] ;\\n                }\\n            }\\n            int maxDifference = -1e9 ;\\n            for(int i = 0 ; i < n ; i++)\\n            {\\n                int diff = aux1[i] - prices[i] ;\\n                if(diff > maxDifference)\\n                {\\n                    maxDifference = diff ;\\n                }\\n            }\\n            return maxDifference ;\\n        }\\n};"
                    }
                ]
            },
            {
                "id": 1729057,
                "content": [
                    {
                        "username": "Pratik-Shrivastava",
                        "content": "\\u2705Simple || Java || 6 Lines Solution || Beats 100% || Easy to Understand\\nhttps://leetcode.com/problems/best-time-to-buy-and-sell-stock/solutions/3001669/simple-java-6-lines-solution-beats-100-easy-to-understand/"
                    },
                    {
                        "username": "aditya223307",
                        "content": "pls tell me what wrong with this approach?\\ncase1 and case2 rum but all test cases are not.\\n `int maxProfit(vector<int>& prices) {\\n       auto it = minmax_element(prices.begin(), prices.end());\\n       int min_index = distance(prices.begin(), it.first);\\n       int max_element = prices[min_index];\\n       for(int i=min_index; i<=prices.size()-min_index; i++){\\n           max_element= max(max_element, prices[i]);\\n       }\\n       if(prices[min_index] == max_element){\\n           return 0;\\n       }else{\\n           return max_element - prices[min_index];\\n       }\\n    }`"
                    },
                    {
                        "username": "aditya223307",
                        "content": "can anyone pls tell me what wrong with this approach?\\ncase1 and case2 run but all test cases are not correct.\\nint maxProfit(vector<int>& prices) {\\n       auto it = minmax_element(prices.begin(), prices.end());\\n       int min_index = distance(prices.begin(), it.first);\\n       int max_element = prices[min_index];\\n       for(int i=min_index; i<=prices.size()-min_index; i++){\\n           max_element= max(max_element, prices[i]);\\n       }\\n       if(prices[min_index] == max_element){\\n           return 0;\\n       }else{\\n           return max_element - prices[min_index];\\n       }\\n    }"
                    },
                    {
                        "username": "HinaKiran",
                        "content": "Ok so, i just want to reconfirm if i am getting the problem right or not because most of the test cases are passed but i am stuck at test case 102.\\nso it has an input of [2,4,1].\\nas long as i understood the problem is that it will check for the minimum number. here the smallest number is 1 and after that number index it will start searching for the biggest number and then it will just subtract and returns the answer. but if the smallest number is at the last index then it will return 0 then wht am i getting the wrong answer popup and here it says that expected answer is 2.\\ni dont know what is wrong with my code.\\nits in c# ..\\nwritng it down here so that someone can point it out.\\npublic int SingleNumber(int[] nums)\\n        {\\n            int max = nums[0];\\n            int min = nums[0];\\n            int index = 0;\\n            int minIndex = 0;\\n            int maxIndex = 0;\\n            for (int i=1;i<nums.Length;i++)\\n            {\\n                if (min > nums[i])\\n                {\\n                    min = nums[i];\\n                    minIndex = i;\\n                }\\n            }\\n            if (minIndex == nums.GetUpperBound(0))\\n            {\\n                return 0;\\n            }\\n            for(int j=minIndex; j<=nums.Length; j++)\\n            {\\n                if(j+1 <= nums.GetUpperBound(0))\\n                {\\n                    if (nums[j] < nums[j + 1])\\n                    {\\n                        max = nums[j + 1];\\n                        maxIndex = j + 1;\\n                    }\\n                    else\\n                    {\\n                        max = nums[j];\\n                        maxIndex = j;\\n                    }\\n                }\\n                if (j + 1 > nums.GetUpperBound(0))\\n                {\\n                    return index = nums[maxIndex] - nums[minIndex];\\n                }\\n\\n            }\\n            return index = nums[maxIndex] - nums[minIndex];\\n        }"
                    },
                    {
                        "username": "JCPrice0024",
                        "content": "The problem isn\\'t looking for the minimum buy price it\\'s looking for the maximum sell price. So in this case 4-2 = 2."
                    },
                    {
                        "username": "rashmi_jain18",
                        "content": "Wondering for the below example given in question, how max profit is 5? It should be 7 - if I buy stock on day2 i.e 1 and sell it on day3 at price 5. Again I buy stock on day4 at price 3 and sell on day5 at price 6. Total profit will be (5-1)+(6-3)=7\\nInput: prices = [7,1,5,3,6,4]\\nOutput: 5"
                    },
                    {
                        "username": "vinaykrishna",
                        "content": "should buy stock only once"
                    },
                    {
                        "username": "Beyond_Multiverse",
                        "content": "You can buy stocks atmost once"
                    },
                    {
                        "username": "sharadhachelka",
                        "content": "Could someone explain about buy price and sell price how to take?"
                    },
                    {
                        "username": "siddharthaverma6213",
                        "content": "       int profit = 0 ;\\n       for(int i =1 ; i<prices.size() ;i++){\\n     if(prices[i]>prices[i-1]) profit = profit + (prices[i] - prices[i-1]) ;\\n       } \\n     return profit ; \\n\\n\\nwhat is the problem with this code ? can somebody explain ?"
                    },
                    {
                        "username": "Beyond_Multiverse",
                        "content": "You\\'re comparing only consecutive days"
                    },
                    {
                        "username": "GeetMukherjee",
                        "content": "C++\\n\\nint maxProfit(vector<int>& prices) {\\n        int maxProfit = 0;\\n        int buy = prices[0];\\n        int n = prices.size();\\n\\n        if(n==2 && prices[1]>prices[0]){\\n            return prices[1]-prices[0];\\n        }\\n\\n        for(int i=1;i<n;i++){\\n            buy = min(buy, prices[i]);\\n            maxProfit = max(maxProfit, prices[i]-buy);\\n        }\\n        return maxProfit;\\n    }"
                    },
                    {
                        "username": "AKASHKUMARSINGH",
                        "content": "int maxProfit = -1e9 ;\\n            int minPrice = prices[0] ;\\n            for(int i = 0 ; i < prices.size() ; i++)\\n            {\\n                if(prices[i]-minPrice > maxProfit)\\n                {\\n                    maxProfit = prices[i] - minPrice ;\\n                }\\n                minPrice = min(minPrice , prices[i]);\\n            }\\n            return maxProfit ;\\n"
                    },
                    {
                        "username": "AKASHKUMARSINGH",
                        "content": "class Solution \\n{\\n    public:\\n        int maxProfit(vector<int>& prices) \\n        {\\n            int n = prices.size();\\n            int maxProfit = -1e9  ;\\n            vector<int>aux1(n);\\n            for(int i = n-1 ; i >= 0 ; i--)\\n            {\\n                aux1[i] = max(maxProfit , prices[i]);\\n                if(maxProfit < prices[i])\\n                {\\n                    maxProfit = prices[i] ;\\n                }\\n            }\\n            int maxDifference = -1e9 ;\\n            for(int i = 0 ; i < n ; i++)\\n            {\\n                int diff = aux1[i] - prices[i] ;\\n                if(diff > maxDifference)\\n                {\\n                    maxDifference = diff ;\\n                }\\n            }\\n            return maxDifference ;\\n        }\\n};"
                    }
                ]
            },
            {
                "id": 1729035,
                "content": [
                    {
                        "username": "Pratik-Shrivastava",
                        "content": "\\u2705Simple || Java || 6 Lines Solution || Beats 100% || Easy to Understand\\nhttps://leetcode.com/problems/best-time-to-buy-and-sell-stock/solutions/3001669/simple-java-6-lines-solution-beats-100-easy-to-understand/"
                    },
                    {
                        "username": "aditya223307",
                        "content": "pls tell me what wrong with this approach?\\ncase1 and case2 rum but all test cases are not.\\n `int maxProfit(vector<int>& prices) {\\n       auto it = minmax_element(prices.begin(), prices.end());\\n       int min_index = distance(prices.begin(), it.first);\\n       int max_element = prices[min_index];\\n       for(int i=min_index; i<=prices.size()-min_index; i++){\\n           max_element= max(max_element, prices[i]);\\n       }\\n       if(prices[min_index] == max_element){\\n           return 0;\\n       }else{\\n           return max_element - prices[min_index];\\n       }\\n    }`"
                    },
                    {
                        "username": "aditya223307",
                        "content": "can anyone pls tell me what wrong with this approach?\\ncase1 and case2 run but all test cases are not correct.\\nint maxProfit(vector<int>& prices) {\\n       auto it = minmax_element(prices.begin(), prices.end());\\n       int min_index = distance(prices.begin(), it.first);\\n       int max_element = prices[min_index];\\n       for(int i=min_index; i<=prices.size()-min_index; i++){\\n           max_element= max(max_element, prices[i]);\\n       }\\n       if(prices[min_index] == max_element){\\n           return 0;\\n       }else{\\n           return max_element - prices[min_index];\\n       }\\n    }"
                    },
                    {
                        "username": "HinaKiran",
                        "content": "Ok so, i just want to reconfirm if i am getting the problem right or not because most of the test cases are passed but i am stuck at test case 102.\\nso it has an input of [2,4,1].\\nas long as i understood the problem is that it will check for the minimum number. here the smallest number is 1 and after that number index it will start searching for the biggest number and then it will just subtract and returns the answer. but if the smallest number is at the last index then it will return 0 then wht am i getting the wrong answer popup and here it says that expected answer is 2.\\ni dont know what is wrong with my code.\\nits in c# ..\\nwritng it down here so that someone can point it out.\\npublic int SingleNumber(int[] nums)\\n        {\\n            int max = nums[0];\\n            int min = nums[0];\\n            int index = 0;\\n            int minIndex = 0;\\n            int maxIndex = 0;\\n            for (int i=1;i<nums.Length;i++)\\n            {\\n                if (min > nums[i])\\n                {\\n                    min = nums[i];\\n                    minIndex = i;\\n                }\\n            }\\n            if (minIndex == nums.GetUpperBound(0))\\n            {\\n                return 0;\\n            }\\n            for(int j=minIndex; j<=nums.Length; j++)\\n            {\\n                if(j+1 <= nums.GetUpperBound(0))\\n                {\\n                    if (nums[j] < nums[j + 1])\\n                    {\\n                        max = nums[j + 1];\\n                        maxIndex = j + 1;\\n                    }\\n                    else\\n                    {\\n                        max = nums[j];\\n                        maxIndex = j;\\n                    }\\n                }\\n                if (j + 1 > nums.GetUpperBound(0))\\n                {\\n                    return index = nums[maxIndex] - nums[minIndex];\\n                }\\n\\n            }\\n            return index = nums[maxIndex] - nums[minIndex];\\n        }"
                    },
                    {
                        "username": "JCPrice0024",
                        "content": "The problem isn\\'t looking for the minimum buy price it\\'s looking for the maximum sell price. So in this case 4-2 = 2."
                    },
                    {
                        "username": "rashmi_jain18",
                        "content": "Wondering for the below example given in question, how max profit is 5? It should be 7 - if I buy stock on day2 i.e 1 and sell it on day3 at price 5. Again I buy stock on day4 at price 3 and sell on day5 at price 6. Total profit will be (5-1)+(6-3)=7\\nInput: prices = [7,1,5,3,6,4]\\nOutput: 5"
                    },
                    {
                        "username": "vinaykrishna",
                        "content": "should buy stock only once"
                    },
                    {
                        "username": "Beyond_Multiverse",
                        "content": "You can buy stocks atmost once"
                    },
                    {
                        "username": "sharadhachelka",
                        "content": "Could someone explain about buy price and sell price how to take?"
                    },
                    {
                        "username": "siddharthaverma6213",
                        "content": "       int profit = 0 ;\\n       for(int i =1 ; i<prices.size() ;i++){\\n     if(prices[i]>prices[i-1]) profit = profit + (prices[i] - prices[i-1]) ;\\n       } \\n     return profit ; \\n\\n\\nwhat is the problem with this code ? can somebody explain ?"
                    },
                    {
                        "username": "Beyond_Multiverse",
                        "content": "You\\'re comparing only consecutive days"
                    },
                    {
                        "username": "GeetMukherjee",
                        "content": "C++\\n\\nint maxProfit(vector<int>& prices) {\\n        int maxProfit = 0;\\n        int buy = prices[0];\\n        int n = prices.size();\\n\\n        if(n==2 && prices[1]>prices[0]){\\n            return prices[1]-prices[0];\\n        }\\n\\n        for(int i=1;i<n;i++){\\n            buy = min(buy, prices[i]);\\n            maxProfit = max(maxProfit, prices[i]-buy);\\n        }\\n        return maxProfit;\\n    }"
                    },
                    {
                        "username": "AKASHKUMARSINGH",
                        "content": "int maxProfit = -1e9 ;\\n            int minPrice = prices[0] ;\\n            for(int i = 0 ; i < prices.size() ; i++)\\n            {\\n                if(prices[i]-minPrice > maxProfit)\\n                {\\n                    maxProfit = prices[i] - minPrice ;\\n                }\\n                minPrice = min(minPrice , prices[i]);\\n            }\\n            return maxProfit ;\\n"
                    },
                    {
                        "username": "AKASHKUMARSINGH",
                        "content": "class Solution \\n{\\n    public:\\n        int maxProfit(vector<int>& prices) \\n        {\\n            int n = prices.size();\\n            int maxProfit = -1e9  ;\\n            vector<int>aux1(n);\\n            for(int i = n-1 ; i >= 0 ; i--)\\n            {\\n                aux1[i] = max(maxProfit , prices[i]);\\n                if(maxProfit < prices[i])\\n                {\\n                    maxProfit = prices[i] ;\\n                }\\n            }\\n            int maxDifference = -1e9 ;\\n            for(int i = 0 ; i < n ; i++)\\n            {\\n                int diff = aux1[i] - prices[i] ;\\n                if(diff > maxDifference)\\n                {\\n                    maxDifference = diff ;\\n                }\\n            }\\n            return maxDifference ;\\n        }\\n};"
                    }
                ]
            },
            {
                "id": 1729008,
                "content": [
                    {
                        "username": "Pratik-Shrivastava",
                        "content": "\\u2705Simple || Java || 6 Lines Solution || Beats 100% || Easy to Understand\\nhttps://leetcode.com/problems/best-time-to-buy-and-sell-stock/solutions/3001669/simple-java-6-lines-solution-beats-100-easy-to-understand/"
                    },
                    {
                        "username": "aditya223307",
                        "content": "pls tell me what wrong with this approach?\\ncase1 and case2 rum but all test cases are not.\\n `int maxProfit(vector<int>& prices) {\\n       auto it = minmax_element(prices.begin(), prices.end());\\n       int min_index = distance(prices.begin(), it.first);\\n       int max_element = prices[min_index];\\n       for(int i=min_index; i<=prices.size()-min_index; i++){\\n           max_element= max(max_element, prices[i]);\\n       }\\n       if(prices[min_index] == max_element){\\n           return 0;\\n       }else{\\n           return max_element - prices[min_index];\\n       }\\n    }`"
                    },
                    {
                        "username": "aditya223307",
                        "content": "can anyone pls tell me what wrong with this approach?\\ncase1 and case2 run but all test cases are not correct.\\nint maxProfit(vector<int>& prices) {\\n       auto it = minmax_element(prices.begin(), prices.end());\\n       int min_index = distance(prices.begin(), it.first);\\n       int max_element = prices[min_index];\\n       for(int i=min_index; i<=prices.size()-min_index; i++){\\n           max_element= max(max_element, prices[i]);\\n       }\\n       if(prices[min_index] == max_element){\\n           return 0;\\n       }else{\\n           return max_element - prices[min_index];\\n       }\\n    }"
                    },
                    {
                        "username": "HinaKiran",
                        "content": "Ok so, i just want to reconfirm if i am getting the problem right or not because most of the test cases are passed but i am stuck at test case 102.\\nso it has an input of [2,4,1].\\nas long as i understood the problem is that it will check for the minimum number. here the smallest number is 1 and after that number index it will start searching for the biggest number and then it will just subtract and returns the answer. but if the smallest number is at the last index then it will return 0 then wht am i getting the wrong answer popup and here it says that expected answer is 2.\\ni dont know what is wrong with my code.\\nits in c# ..\\nwritng it down here so that someone can point it out.\\npublic int SingleNumber(int[] nums)\\n        {\\n            int max = nums[0];\\n            int min = nums[0];\\n            int index = 0;\\n            int minIndex = 0;\\n            int maxIndex = 0;\\n            for (int i=1;i<nums.Length;i++)\\n            {\\n                if (min > nums[i])\\n                {\\n                    min = nums[i];\\n                    minIndex = i;\\n                }\\n            }\\n            if (minIndex == nums.GetUpperBound(0))\\n            {\\n                return 0;\\n            }\\n            for(int j=minIndex; j<=nums.Length; j++)\\n            {\\n                if(j+1 <= nums.GetUpperBound(0))\\n                {\\n                    if (nums[j] < nums[j + 1])\\n                    {\\n                        max = nums[j + 1];\\n                        maxIndex = j + 1;\\n                    }\\n                    else\\n                    {\\n                        max = nums[j];\\n                        maxIndex = j;\\n                    }\\n                }\\n                if (j + 1 > nums.GetUpperBound(0))\\n                {\\n                    return index = nums[maxIndex] - nums[minIndex];\\n                }\\n\\n            }\\n            return index = nums[maxIndex] - nums[minIndex];\\n        }"
                    },
                    {
                        "username": "JCPrice0024",
                        "content": "The problem isn\\'t looking for the minimum buy price it\\'s looking for the maximum sell price. So in this case 4-2 = 2."
                    },
                    {
                        "username": "rashmi_jain18",
                        "content": "Wondering for the below example given in question, how max profit is 5? It should be 7 - if I buy stock on day2 i.e 1 and sell it on day3 at price 5. Again I buy stock on day4 at price 3 and sell on day5 at price 6. Total profit will be (5-1)+(6-3)=7\\nInput: prices = [7,1,5,3,6,4]\\nOutput: 5"
                    },
                    {
                        "username": "vinaykrishna",
                        "content": "should buy stock only once"
                    },
                    {
                        "username": "Beyond_Multiverse",
                        "content": "You can buy stocks atmost once"
                    },
                    {
                        "username": "sharadhachelka",
                        "content": "Could someone explain about buy price and sell price how to take?"
                    },
                    {
                        "username": "siddharthaverma6213",
                        "content": "       int profit = 0 ;\\n       for(int i =1 ; i<prices.size() ;i++){\\n     if(prices[i]>prices[i-1]) profit = profit + (prices[i] - prices[i-1]) ;\\n       } \\n     return profit ; \\n\\n\\nwhat is the problem with this code ? can somebody explain ?"
                    },
                    {
                        "username": "Beyond_Multiverse",
                        "content": "You\\'re comparing only consecutive days"
                    },
                    {
                        "username": "GeetMukherjee",
                        "content": "C++\\n\\nint maxProfit(vector<int>& prices) {\\n        int maxProfit = 0;\\n        int buy = prices[0];\\n        int n = prices.size();\\n\\n        if(n==2 && prices[1]>prices[0]){\\n            return prices[1]-prices[0];\\n        }\\n\\n        for(int i=1;i<n;i++){\\n            buy = min(buy, prices[i]);\\n            maxProfit = max(maxProfit, prices[i]-buy);\\n        }\\n        return maxProfit;\\n    }"
                    },
                    {
                        "username": "AKASHKUMARSINGH",
                        "content": "int maxProfit = -1e9 ;\\n            int minPrice = prices[0] ;\\n            for(int i = 0 ; i < prices.size() ; i++)\\n            {\\n                if(prices[i]-minPrice > maxProfit)\\n                {\\n                    maxProfit = prices[i] - minPrice ;\\n                }\\n                minPrice = min(minPrice , prices[i]);\\n            }\\n            return maxProfit ;\\n"
                    },
                    {
                        "username": "AKASHKUMARSINGH",
                        "content": "class Solution \\n{\\n    public:\\n        int maxProfit(vector<int>& prices) \\n        {\\n            int n = prices.size();\\n            int maxProfit = -1e9  ;\\n            vector<int>aux1(n);\\n            for(int i = n-1 ; i >= 0 ; i--)\\n            {\\n                aux1[i] = max(maxProfit , prices[i]);\\n                if(maxProfit < prices[i])\\n                {\\n                    maxProfit = prices[i] ;\\n                }\\n            }\\n            int maxDifference = -1e9 ;\\n            for(int i = 0 ; i < n ; i++)\\n            {\\n                int diff = aux1[i] - prices[i] ;\\n                if(diff > maxDifference)\\n                {\\n                    maxDifference = diff ;\\n                }\\n            }\\n            return maxDifference ;\\n        }\\n};"
                    }
                ]
            },
            {
                "id": 1725546,
                "content": [
                    {
                        "username": "Siddharth_Sahu",
                        "content": "Someone please tell why this is not working on the site, it works fine on VS code\\n\\n#include <iostream>\\n#include <vector>\\nusing namespace std;\\nclass Solution\\n{\\npublic:\\n    int maxProfit(vector<int> &prices)\\n    {\\n\\n        int min = prices[0];\\n        int minpos;\\n        int ans;\\n\\n        for (int i = 0; i < prices.capacity(); i++)\\n        {\\n            if (prices[i] < min)\\n            {\\n                min = prices[i];\\n                minpos = i;\\n            }\\n        }\\n        int max = min;\\n        \\n        for (int i = minpos; i < prices.capacity(); i++)\\n        {\\n            if (prices[i] > max)\\n            {\\n                max = prices[i];\\n                \\n            }\\n            \\n        }\\n        ans = max - min;\\n        \\n        return ans;\\n    }\\n};\\n\\n\\n\\nint main()\\n{\\n    Solution s1;\\n    vector<int> prices = {7, 1, 5, 3, 6, 4};\\n    cout << s1.maxProfit(prices);\\n    return 0;\\n}"
                    },
                    {
                        "username": "lucyrliu",
                        "content": "My code is basically the same as the first Java solution leetcode provided, but whenever I try to submit it it says Time Limit Exceeded. How should I fix it?"
                    },
                    {
                        "username": "BOOMER0641",
                        "content": "i dont understand the question"
                    },
                    {
                        "username": "vasiltsvetkov20",
                        "content": "\npublic class Solution {\n\n    public int MaxProfit(int[] prices) {\n\n            Stack<int> stack = new Stack<int>();\n\n            int maxProfit = int.MinValue;\n\n            for (int i = 0; i < prices.Length; i++)\n            {\n                for (int j = i + 1; j < prices.Length; j++)\n                {\n                    stack.Push(prices[i]);\n\n                    if (- stack.Peek() + prices[j] > maxProfit)\n                    {\n                        maxProfit = - stack.Pop() + prices[j];\n                    }\n                }\n            }\n\n            return maxProfit > 0 ? maxProfit : 0;\n    }\n}\n\nCan someone tell me why the code above has a runtime error 'Out of memory' and how to fix it?"
                    },
                    {
                        "username": "joyifei",
                        "content": "one pitfall I always fall into is,  trying to calculate more information than required. as this problem I think we need to get the date of buying and selling to determine how to get max profit. "
                    },
                    {
                        "username": "simarpalSingh",
                        "content": " \\ndef maxProfit(self, arr: List[int]) -> int:\\n        sm = arr[0]\\n        max = 0\\n        lr = 0\\n        if len(arr) == 0: return 0\\n        for i in range (1, len(arr)):\\n            if arr[i] > lr:\\n                lr = arr[i]\\n                max = max if max > lr-sm else lr-sm\\n            if arr[i] < sm:\\n                sm = arr[i]\\n                lr = 0\\n        return max  \\n"
                    },
                    {
                        "username": "Asha_nagar",
                        "content": "class Solution {\\n    public int maxProfit(int[] price) {\\n    int buyPrice=Integer.MAX_VALUE;\\n    int max=0;\\n    int i=0;\\n    if(price.length-1==0)return 0;\\n   \\n    \\n    while(i<price.length)\\n    {\\n        if(buyPrice<price[i])\\n        {\\n            int profit = price[i]-buyPrice;\\n             max=Math.max(max,profit);\\n        }\\n        else\\n        {\\n            buyPrice=price[i];\\n        }\\n        i++;\\n    }\\n    return max;\\n        \\n    }\\n}[leetcode](https://leetcode.com) @"
                    },
                    {
                        "username": "ashvinPitukun",
                        "content": "pre computation technique is useful here."
                    },
                    {
                        "username": "emti_19",
                        "content": "Why I am getting Time Limit Exceeded here?\\n\\n `\\nint n = prices.size()-1;\\n        int minn = INT_MAX, maxx = INT_MIN;\\n        int i=0,j=n;\\n        while(i<j){\\n            if(prices[i]<minn)\\n                minn = prices[i++];\\n            if(prices[j]>maxx)\\n                maxx = prices[j--];\\n        }\\n        if(maxx-minn>0) return maxx-minn;\\n        else return 0;\\n`"
                    },
                    {
                        "username": "user1799vO",
                        "content": "That is how I understand/digest the one pass approach. Just think yourself as a some one who can change mind at will. \\n\\nint maxProfit(int* prices, int pricesSize)\\n{\\n    /* You buy the stock at day 1 at whatever price. This is ok since you\\n        can change your mind later.  And this is minimal price so far. */  \\n    int min_price = prices[0];     \\n    int max_profit  = 0;   // No profit at day one.\\n    int i;\\n\\n    for(i = 1; i < pricesSize; i++) {\\n        if(prices[i] < min_price) {\\n            /* As days go by. You see a cheaper price. You are kind of regret that\\n               you bought at higher price. But there is nothing you can do other\\n              than recording the minimal price. */\\n            min_price = prices[i];\\n        } else {\\n            if(prices[i] - min_price > max_profit)\\n               /* Now you see a higher price such that  if you sell today and \\n                   bought at the recorded minimal price you will make more profit. \\n                   You immediately changed your mind  :-) */\\n                max_profit = prices[i] - min_price;\\n        }\\n    }\\n\\n    return max_profit;\\n}"
                    }
                ]
            },
            {
                "id": 1722068,
                "content": [
                    {
                        "username": "Siddharth_Sahu",
                        "content": "Someone please tell why this is not working on the site, it works fine on VS code\\n\\n#include <iostream>\\n#include <vector>\\nusing namespace std;\\nclass Solution\\n{\\npublic:\\n    int maxProfit(vector<int> &prices)\\n    {\\n\\n        int min = prices[0];\\n        int minpos;\\n        int ans;\\n\\n        for (int i = 0; i < prices.capacity(); i++)\\n        {\\n            if (prices[i] < min)\\n            {\\n                min = prices[i];\\n                minpos = i;\\n            }\\n        }\\n        int max = min;\\n        \\n        for (int i = minpos; i < prices.capacity(); i++)\\n        {\\n            if (prices[i] > max)\\n            {\\n                max = prices[i];\\n                \\n            }\\n            \\n        }\\n        ans = max - min;\\n        \\n        return ans;\\n    }\\n};\\n\\n\\n\\nint main()\\n{\\n    Solution s1;\\n    vector<int> prices = {7, 1, 5, 3, 6, 4};\\n    cout << s1.maxProfit(prices);\\n    return 0;\\n}"
                    },
                    {
                        "username": "lucyrliu",
                        "content": "My code is basically the same as the first Java solution leetcode provided, but whenever I try to submit it it says Time Limit Exceeded. How should I fix it?"
                    },
                    {
                        "username": "BOOMER0641",
                        "content": "i dont understand the question"
                    },
                    {
                        "username": "vasiltsvetkov20",
                        "content": "\npublic class Solution {\n\n    public int MaxProfit(int[] prices) {\n\n            Stack<int> stack = new Stack<int>();\n\n            int maxProfit = int.MinValue;\n\n            for (int i = 0; i < prices.Length; i++)\n            {\n                for (int j = i + 1; j < prices.Length; j++)\n                {\n                    stack.Push(prices[i]);\n\n                    if (- stack.Peek() + prices[j] > maxProfit)\n                    {\n                        maxProfit = - stack.Pop() + prices[j];\n                    }\n                }\n            }\n\n            return maxProfit > 0 ? maxProfit : 0;\n    }\n}\n\nCan someone tell me why the code above has a runtime error 'Out of memory' and how to fix it?"
                    },
                    {
                        "username": "joyifei",
                        "content": "one pitfall I always fall into is,  trying to calculate more information than required. as this problem I think we need to get the date of buying and selling to determine how to get max profit. "
                    },
                    {
                        "username": "simarpalSingh",
                        "content": " \\ndef maxProfit(self, arr: List[int]) -> int:\\n        sm = arr[0]\\n        max = 0\\n        lr = 0\\n        if len(arr) == 0: return 0\\n        for i in range (1, len(arr)):\\n            if arr[i] > lr:\\n                lr = arr[i]\\n                max = max if max > lr-sm else lr-sm\\n            if arr[i] < sm:\\n                sm = arr[i]\\n                lr = 0\\n        return max  \\n"
                    },
                    {
                        "username": "Asha_nagar",
                        "content": "class Solution {\\n    public int maxProfit(int[] price) {\\n    int buyPrice=Integer.MAX_VALUE;\\n    int max=0;\\n    int i=0;\\n    if(price.length-1==0)return 0;\\n   \\n    \\n    while(i<price.length)\\n    {\\n        if(buyPrice<price[i])\\n        {\\n            int profit = price[i]-buyPrice;\\n             max=Math.max(max,profit);\\n        }\\n        else\\n        {\\n            buyPrice=price[i];\\n        }\\n        i++;\\n    }\\n    return max;\\n        \\n    }\\n}[leetcode](https://leetcode.com) @"
                    },
                    {
                        "username": "ashvinPitukun",
                        "content": "pre computation technique is useful here."
                    },
                    {
                        "username": "emti_19",
                        "content": "Why I am getting Time Limit Exceeded here?\\n\\n `\\nint n = prices.size()-1;\\n        int minn = INT_MAX, maxx = INT_MIN;\\n        int i=0,j=n;\\n        while(i<j){\\n            if(prices[i]<minn)\\n                minn = prices[i++];\\n            if(prices[j]>maxx)\\n                maxx = prices[j--];\\n        }\\n        if(maxx-minn>0) return maxx-minn;\\n        else return 0;\\n`"
                    },
                    {
                        "username": "user1799vO",
                        "content": "That is how I understand/digest the one pass approach. Just think yourself as a some one who can change mind at will. \\n\\nint maxProfit(int* prices, int pricesSize)\\n{\\n    /* You buy the stock at day 1 at whatever price. This is ok since you\\n        can change your mind later.  And this is minimal price so far. */  \\n    int min_price = prices[0];     \\n    int max_profit  = 0;   // No profit at day one.\\n    int i;\\n\\n    for(i = 1; i < pricesSize; i++) {\\n        if(prices[i] < min_price) {\\n            /* As days go by. You see a cheaper price. You are kind of regret that\\n               you bought at higher price. But there is nothing you can do other\\n              than recording the minimal price. */\\n            min_price = prices[i];\\n        } else {\\n            if(prices[i] - min_price > max_profit)\\n               /* Now you see a higher price such that  if you sell today and \\n                   bought at the recorded minimal price you will make more profit. \\n                   You immediately changed your mind  :-) */\\n                max_profit = prices[i] - min_price;\\n        }\\n    }\\n\\n    return max_profit;\\n}"
                    }
                ]
            },
            {
                "id": 1721400,
                "content": [
                    {
                        "username": "Siddharth_Sahu",
                        "content": "Someone please tell why this is not working on the site, it works fine on VS code\\n\\n#include <iostream>\\n#include <vector>\\nusing namespace std;\\nclass Solution\\n{\\npublic:\\n    int maxProfit(vector<int> &prices)\\n    {\\n\\n        int min = prices[0];\\n        int minpos;\\n        int ans;\\n\\n        for (int i = 0; i < prices.capacity(); i++)\\n        {\\n            if (prices[i] < min)\\n            {\\n                min = prices[i];\\n                minpos = i;\\n            }\\n        }\\n        int max = min;\\n        \\n        for (int i = minpos; i < prices.capacity(); i++)\\n        {\\n            if (prices[i] > max)\\n            {\\n                max = prices[i];\\n                \\n            }\\n            \\n        }\\n        ans = max - min;\\n        \\n        return ans;\\n    }\\n};\\n\\n\\n\\nint main()\\n{\\n    Solution s1;\\n    vector<int> prices = {7, 1, 5, 3, 6, 4};\\n    cout << s1.maxProfit(prices);\\n    return 0;\\n}"
                    },
                    {
                        "username": "lucyrliu",
                        "content": "My code is basically the same as the first Java solution leetcode provided, but whenever I try to submit it it says Time Limit Exceeded. How should I fix it?"
                    },
                    {
                        "username": "BOOMER0641",
                        "content": "i dont understand the question"
                    },
                    {
                        "username": "vasiltsvetkov20",
                        "content": "\npublic class Solution {\n\n    public int MaxProfit(int[] prices) {\n\n            Stack<int> stack = new Stack<int>();\n\n            int maxProfit = int.MinValue;\n\n            for (int i = 0; i < prices.Length; i++)\n            {\n                for (int j = i + 1; j < prices.Length; j++)\n                {\n                    stack.Push(prices[i]);\n\n                    if (- stack.Peek() + prices[j] > maxProfit)\n                    {\n                        maxProfit = - stack.Pop() + prices[j];\n                    }\n                }\n            }\n\n            return maxProfit > 0 ? maxProfit : 0;\n    }\n}\n\nCan someone tell me why the code above has a runtime error 'Out of memory' and how to fix it?"
                    },
                    {
                        "username": "joyifei",
                        "content": "one pitfall I always fall into is,  trying to calculate more information than required. as this problem I think we need to get the date of buying and selling to determine how to get max profit. "
                    },
                    {
                        "username": "simarpalSingh",
                        "content": " \\ndef maxProfit(self, arr: List[int]) -> int:\\n        sm = arr[0]\\n        max = 0\\n        lr = 0\\n        if len(arr) == 0: return 0\\n        for i in range (1, len(arr)):\\n            if arr[i] > lr:\\n                lr = arr[i]\\n                max = max if max > lr-sm else lr-sm\\n            if arr[i] < sm:\\n                sm = arr[i]\\n                lr = 0\\n        return max  \\n"
                    },
                    {
                        "username": "Asha_nagar",
                        "content": "class Solution {\\n    public int maxProfit(int[] price) {\\n    int buyPrice=Integer.MAX_VALUE;\\n    int max=0;\\n    int i=0;\\n    if(price.length-1==0)return 0;\\n   \\n    \\n    while(i<price.length)\\n    {\\n        if(buyPrice<price[i])\\n        {\\n            int profit = price[i]-buyPrice;\\n             max=Math.max(max,profit);\\n        }\\n        else\\n        {\\n            buyPrice=price[i];\\n        }\\n        i++;\\n    }\\n    return max;\\n        \\n    }\\n}[leetcode](https://leetcode.com) @"
                    },
                    {
                        "username": "ashvinPitukun",
                        "content": "pre computation technique is useful here."
                    },
                    {
                        "username": "emti_19",
                        "content": "Why I am getting Time Limit Exceeded here?\\n\\n `\\nint n = prices.size()-1;\\n        int minn = INT_MAX, maxx = INT_MIN;\\n        int i=0,j=n;\\n        while(i<j){\\n            if(prices[i]<minn)\\n                minn = prices[i++];\\n            if(prices[j]>maxx)\\n                maxx = prices[j--];\\n        }\\n        if(maxx-minn>0) return maxx-minn;\\n        else return 0;\\n`"
                    },
                    {
                        "username": "user1799vO",
                        "content": "That is how I understand/digest the one pass approach. Just think yourself as a some one who can change mind at will. \\n\\nint maxProfit(int* prices, int pricesSize)\\n{\\n    /* You buy the stock at day 1 at whatever price. This is ok since you\\n        can change your mind later.  And this is minimal price so far. */  \\n    int min_price = prices[0];     \\n    int max_profit  = 0;   // No profit at day one.\\n    int i;\\n\\n    for(i = 1; i < pricesSize; i++) {\\n        if(prices[i] < min_price) {\\n            /* As days go by. You see a cheaper price. You are kind of regret that\\n               you bought at higher price. But there is nothing you can do other\\n              than recording the minimal price. */\\n            min_price = prices[i];\\n        } else {\\n            if(prices[i] - min_price > max_profit)\\n               /* Now you see a higher price such that  if you sell today and \\n                   bought at the recorded minimal price you will make more profit. \\n                   You immediately changed your mind  :-) */\\n                max_profit = prices[i] - min_price;\\n        }\\n    }\\n\\n    return max_profit;\\n}"
                    }
                ]
            },
            {
                "id": 1720382,
                "content": [
                    {
                        "username": "Siddharth_Sahu",
                        "content": "Someone please tell why this is not working on the site, it works fine on VS code\\n\\n#include <iostream>\\n#include <vector>\\nusing namespace std;\\nclass Solution\\n{\\npublic:\\n    int maxProfit(vector<int> &prices)\\n    {\\n\\n        int min = prices[0];\\n        int minpos;\\n        int ans;\\n\\n        for (int i = 0; i < prices.capacity(); i++)\\n        {\\n            if (prices[i] < min)\\n            {\\n                min = prices[i];\\n                minpos = i;\\n            }\\n        }\\n        int max = min;\\n        \\n        for (int i = minpos; i < prices.capacity(); i++)\\n        {\\n            if (prices[i] > max)\\n            {\\n                max = prices[i];\\n                \\n            }\\n            \\n        }\\n        ans = max - min;\\n        \\n        return ans;\\n    }\\n};\\n\\n\\n\\nint main()\\n{\\n    Solution s1;\\n    vector<int> prices = {7, 1, 5, 3, 6, 4};\\n    cout << s1.maxProfit(prices);\\n    return 0;\\n}"
                    },
                    {
                        "username": "lucyrliu",
                        "content": "My code is basically the same as the first Java solution leetcode provided, but whenever I try to submit it it says Time Limit Exceeded. How should I fix it?"
                    },
                    {
                        "username": "BOOMER0641",
                        "content": "i dont understand the question"
                    },
                    {
                        "username": "vasiltsvetkov20",
                        "content": "\npublic class Solution {\n\n    public int MaxProfit(int[] prices) {\n\n            Stack<int> stack = new Stack<int>();\n\n            int maxProfit = int.MinValue;\n\n            for (int i = 0; i < prices.Length; i++)\n            {\n                for (int j = i + 1; j < prices.Length; j++)\n                {\n                    stack.Push(prices[i]);\n\n                    if (- stack.Peek() + prices[j] > maxProfit)\n                    {\n                        maxProfit = - stack.Pop() + prices[j];\n                    }\n                }\n            }\n\n            return maxProfit > 0 ? maxProfit : 0;\n    }\n}\n\nCan someone tell me why the code above has a runtime error 'Out of memory' and how to fix it?"
                    },
                    {
                        "username": "joyifei",
                        "content": "one pitfall I always fall into is,  trying to calculate more information than required. as this problem I think we need to get the date of buying and selling to determine how to get max profit. "
                    },
                    {
                        "username": "simarpalSingh",
                        "content": " \\ndef maxProfit(self, arr: List[int]) -> int:\\n        sm = arr[0]\\n        max = 0\\n        lr = 0\\n        if len(arr) == 0: return 0\\n        for i in range (1, len(arr)):\\n            if arr[i] > lr:\\n                lr = arr[i]\\n                max = max if max > lr-sm else lr-sm\\n            if arr[i] < sm:\\n                sm = arr[i]\\n                lr = 0\\n        return max  \\n"
                    },
                    {
                        "username": "Asha_nagar",
                        "content": "class Solution {\\n    public int maxProfit(int[] price) {\\n    int buyPrice=Integer.MAX_VALUE;\\n    int max=0;\\n    int i=0;\\n    if(price.length-1==0)return 0;\\n   \\n    \\n    while(i<price.length)\\n    {\\n        if(buyPrice<price[i])\\n        {\\n            int profit = price[i]-buyPrice;\\n             max=Math.max(max,profit);\\n        }\\n        else\\n        {\\n            buyPrice=price[i];\\n        }\\n        i++;\\n    }\\n    return max;\\n        \\n    }\\n}[leetcode](https://leetcode.com) @"
                    },
                    {
                        "username": "ashvinPitukun",
                        "content": "pre computation technique is useful here."
                    },
                    {
                        "username": "emti_19",
                        "content": "Why I am getting Time Limit Exceeded here?\\n\\n `\\nint n = prices.size()-1;\\n        int minn = INT_MAX, maxx = INT_MIN;\\n        int i=0,j=n;\\n        while(i<j){\\n            if(prices[i]<minn)\\n                minn = prices[i++];\\n            if(prices[j]>maxx)\\n                maxx = prices[j--];\\n        }\\n        if(maxx-minn>0) return maxx-minn;\\n        else return 0;\\n`"
                    },
                    {
                        "username": "user1799vO",
                        "content": "That is how I understand/digest the one pass approach. Just think yourself as a some one who can change mind at will. \\n\\nint maxProfit(int* prices, int pricesSize)\\n{\\n    /* You buy the stock at day 1 at whatever price. This is ok since you\\n        can change your mind later.  And this is minimal price so far. */  \\n    int min_price = prices[0];     \\n    int max_profit  = 0;   // No profit at day one.\\n    int i;\\n\\n    for(i = 1; i < pricesSize; i++) {\\n        if(prices[i] < min_price) {\\n            /* As days go by. You see a cheaper price. You are kind of regret that\\n               you bought at higher price. But there is nothing you can do other\\n              than recording the minimal price. */\\n            min_price = prices[i];\\n        } else {\\n            if(prices[i] - min_price > max_profit)\\n               /* Now you see a higher price such that  if you sell today and \\n                   bought at the recorded minimal price you will make more profit. \\n                   You immediately changed your mind  :-) */\\n                max_profit = prices[i] - min_price;\\n        }\\n    }\\n\\n    return max_profit;\\n}"
                    }
                ]
            },
            {
                "id": 1716430,
                "content": [
                    {
                        "username": "Siddharth_Sahu",
                        "content": "Someone please tell why this is not working on the site, it works fine on VS code\\n\\n#include <iostream>\\n#include <vector>\\nusing namespace std;\\nclass Solution\\n{\\npublic:\\n    int maxProfit(vector<int> &prices)\\n    {\\n\\n        int min = prices[0];\\n        int minpos;\\n        int ans;\\n\\n        for (int i = 0; i < prices.capacity(); i++)\\n        {\\n            if (prices[i] < min)\\n            {\\n                min = prices[i];\\n                minpos = i;\\n            }\\n        }\\n        int max = min;\\n        \\n        for (int i = minpos; i < prices.capacity(); i++)\\n        {\\n            if (prices[i] > max)\\n            {\\n                max = prices[i];\\n                \\n            }\\n            \\n        }\\n        ans = max - min;\\n        \\n        return ans;\\n    }\\n};\\n\\n\\n\\nint main()\\n{\\n    Solution s1;\\n    vector<int> prices = {7, 1, 5, 3, 6, 4};\\n    cout << s1.maxProfit(prices);\\n    return 0;\\n}"
                    },
                    {
                        "username": "lucyrliu",
                        "content": "My code is basically the same as the first Java solution leetcode provided, but whenever I try to submit it it says Time Limit Exceeded. How should I fix it?"
                    },
                    {
                        "username": "BOOMER0641",
                        "content": "i dont understand the question"
                    },
                    {
                        "username": "vasiltsvetkov20",
                        "content": "\npublic class Solution {\n\n    public int MaxProfit(int[] prices) {\n\n            Stack<int> stack = new Stack<int>();\n\n            int maxProfit = int.MinValue;\n\n            for (int i = 0; i < prices.Length; i++)\n            {\n                for (int j = i + 1; j < prices.Length; j++)\n                {\n                    stack.Push(prices[i]);\n\n                    if (- stack.Peek() + prices[j] > maxProfit)\n                    {\n                        maxProfit = - stack.Pop() + prices[j];\n                    }\n                }\n            }\n\n            return maxProfit > 0 ? maxProfit : 0;\n    }\n}\n\nCan someone tell me why the code above has a runtime error 'Out of memory' and how to fix it?"
                    },
                    {
                        "username": "joyifei",
                        "content": "one pitfall I always fall into is,  trying to calculate more information than required. as this problem I think we need to get the date of buying and selling to determine how to get max profit. "
                    },
                    {
                        "username": "simarpalSingh",
                        "content": " \\ndef maxProfit(self, arr: List[int]) -> int:\\n        sm = arr[0]\\n        max = 0\\n        lr = 0\\n        if len(arr) == 0: return 0\\n        for i in range (1, len(arr)):\\n            if arr[i] > lr:\\n                lr = arr[i]\\n                max = max if max > lr-sm else lr-sm\\n            if arr[i] < sm:\\n                sm = arr[i]\\n                lr = 0\\n        return max  \\n"
                    },
                    {
                        "username": "Asha_nagar",
                        "content": "class Solution {\\n    public int maxProfit(int[] price) {\\n    int buyPrice=Integer.MAX_VALUE;\\n    int max=0;\\n    int i=0;\\n    if(price.length-1==0)return 0;\\n   \\n    \\n    while(i<price.length)\\n    {\\n        if(buyPrice<price[i])\\n        {\\n            int profit = price[i]-buyPrice;\\n             max=Math.max(max,profit);\\n        }\\n        else\\n        {\\n            buyPrice=price[i];\\n        }\\n        i++;\\n    }\\n    return max;\\n        \\n    }\\n}[leetcode](https://leetcode.com) @"
                    },
                    {
                        "username": "ashvinPitukun",
                        "content": "pre computation technique is useful here."
                    },
                    {
                        "username": "emti_19",
                        "content": "Why I am getting Time Limit Exceeded here?\\n\\n `\\nint n = prices.size()-1;\\n        int minn = INT_MAX, maxx = INT_MIN;\\n        int i=0,j=n;\\n        while(i<j){\\n            if(prices[i]<minn)\\n                minn = prices[i++];\\n            if(prices[j]>maxx)\\n                maxx = prices[j--];\\n        }\\n        if(maxx-minn>0) return maxx-minn;\\n        else return 0;\\n`"
                    },
                    {
                        "username": "user1799vO",
                        "content": "That is how I understand/digest the one pass approach. Just think yourself as a some one who can change mind at will. \\n\\nint maxProfit(int* prices, int pricesSize)\\n{\\n    /* You buy the stock at day 1 at whatever price. This is ok since you\\n        can change your mind later.  And this is minimal price so far. */  \\n    int min_price = prices[0];     \\n    int max_profit  = 0;   // No profit at day one.\\n    int i;\\n\\n    for(i = 1; i < pricesSize; i++) {\\n        if(prices[i] < min_price) {\\n            /* As days go by. You see a cheaper price. You are kind of regret that\\n               you bought at higher price. But there is nothing you can do other\\n              than recording the minimal price. */\\n            min_price = prices[i];\\n        } else {\\n            if(prices[i] - min_price > max_profit)\\n               /* Now you see a higher price such that  if you sell today and \\n                   bought at the recorded minimal price you will make more profit. \\n                   You immediately changed your mind  :-) */\\n                max_profit = prices[i] - min_price;\\n        }\\n    }\\n\\n    return max_profit;\\n}"
                    }
                ]
            },
            {
                "id": 1716278,
                "content": [
                    {
                        "username": "Siddharth_Sahu",
                        "content": "Someone please tell why this is not working on the site, it works fine on VS code\\n\\n#include <iostream>\\n#include <vector>\\nusing namespace std;\\nclass Solution\\n{\\npublic:\\n    int maxProfit(vector<int> &prices)\\n    {\\n\\n        int min = prices[0];\\n        int minpos;\\n        int ans;\\n\\n        for (int i = 0; i < prices.capacity(); i++)\\n        {\\n            if (prices[i] < min)\\n            {\\n                min = prices[i];\\n                minpos = i;\\n            }\\n        }\\n        int max = min;\\n        \\n        for (int i = minpos; i < prices.capacity(); i++)\\n        {\\n            if (prices[i] > max)\\n            {\\n                max = prices[i];\\n                \\n            }\\n            \\n        }\\n        ans = max - min;\\n        \\n        return ans;\\n    }\\n};\\n\\n\\n\\nint main()\\n{\\n    Solution s1;\\n    vector<int> prices = {7, 1, 5, 3, 6, 4};\\n    cout << s1.maxProfit(prices);\\n    return 0;\\n}"
                    },
                    {
                        "username": "lucyrliu",
                        "content": "My code is basically the same as the first Java solution leetcode provided, but whenever I try to submit it it says Time Limit Exceeded. How should I fix it?"
                    },
                    {
                        "username": "BOOMER0641",
                        "content": "i dont understand the question"
                    },
                    {
                        "username": "vasiltsvetkov20",
                        "content": "\npublic class Solution {\n\n    public int MaxProfit(int[] prices) {\n\n            Stack<int> stack = new Stack<int>();\n\n            int maxProfit = int.MinValue;\n\n            for (int i = 0; i < prices.Length; i++)\n            {\n                for (int j = i + 1; j < prices.Length; j++)\n                {\n                    stack.Push(prices[i]);\n\n                    if (- stack.Peek() + prices[j] > maxProfit)\n                    {\n                        maxProfit = - stack.Pop() + prices[j];\n                    }\n                }\n            }\n\n            return maxProfit > 0 ? maxProfit : 0;\n    }\n}\n\nCan someone tell me why the code above has a runtime error 'Out of memory' and how to fix it?"
                    },
                    {
                        "username": "joyifei",
                        "content": "one pitfall I always fall into is,  trying to calculate more information than required. as this problem I think we need to get the date of buying and selling to determine how to get max profit. "
                    },
                    {
                        "username": "simarpalSingh",
                        "content": " \\ndef maxProfit(self, arr: List[int]) -> int:\\n        sm = arr[0]\\n        max = 0\\n        lr = 0\\n        if len(arr) == 0: return 0\\n        for i in range (1, len(arr)):\\n            if arr[i] > lr:\\n                lr = arr[i]\\n                max = max if max > lr-sm else lr-sm\\n            if arr[i] < sm:\\n                sm = arr[i]\\n                lr = 0\\n        return max  \\n"
                    },
                    {
                        "username": "Asha_nagar",
                        "content": "class Solution {\\n    public int maxProfit(int[] price) {\\n    int buyPrice=Integer.MAX_VALUE;\\n    int max=0;\\n    int i=0;\\n    if(price.length-1==0)return 0;\\n   \\n    \\n    while(i<price.length)\\n    {\\n        if(buyPrice<price[i])\\n        {\\n            int profit = price[i]-buyPrice;\\n             max=Math.max(max,profit);\\n        }\\n        else\\n        {\\n            buyPrice=price[i];\\n        }\\n        i++;\\n    }\\n    return max;\\n        \\n    }\\n}[leetcode](https://leetcode.com) @"
                    },
                    {
                        "username": "ashvinPitukun",
                        "content": "pre computation technique is useful here."
                    },
                    {
                        "username": "emti_19",
                        "content": "Why I am getting Time Limit Exceeded here?\\n\\n `\\nint n = prices.size()-1;\\n        int minn = INT_MAX, maxx = INT_MIN;\\n        int i=0,j=n;\\n        while(i<j){\\n            if(prices[i]<minn)\\n                minn = prices[i++];\\n            if(prices[j]>maxx)\\n                maxx = prices[j--];\\n        }\\n        if(maxx-minn>0) return maxx-minn;\\n        else return 0;\\n`"
                    },
                    {
                        "username": "user1799vO",
                        "content": "That is how I understand/digest the one pass approach. Just think yourself as a some one who can change mind at will. \\n\\nint maxProfit(int* prices, int pricesSize)\\n{\\n    /* You buy the stock at day 1 at whatever price. This is ok since you\\n        can change your mind later.  And this is minimal price so far. */  \\n    int min_price = prices[0];     \\n    int max_profit  = 0;   // No profit at day one.\\n    int i;\\n\\n    for(i = 1; i < pricesSize; i++) {\\n        if(prices[i] < min_price) {\\n            /* As days go by. You see a cheaper price. You are kind of regret that\\n               you bought at higher price. But there is nothing you can do other\\n              than recording the minimal price. */\\n            min_price = prices[i];\\n        } else {\\n            if(prices[i] - min_price > max_profit)\\n               /* Now you see a higher price such that  if you sell today and \\n                   bought at the recorded minimal price you will make more profit. \\n                   You immediately changed your mind  :-) */\\n                max_profit = prices[i] - min_price;\\n        }\\n    }\\n\\n    return max_profit;\\n}"
                    }
                ]
            },
            {
                "id": 1715363,
                "content": [
                    {
                        "username": "Siddharth_Sahu",
                        "content": "Someone please tell why this is not working on the site, it works fine on VS code\\n\\n#include <iostream>\\n#include <vector>\\nusing namespace std;\\nclass Solution\\n{\\npublic:\\n    int maxProfit(vector<int> &prices)\\n    {\\n\\n        int min = prices[0];\\n        int minpos;\\n        int ans;\\n\\n        for (int i = 0; i < prices.capacity(); i++)\\n        {\\n            if (prices[i] < min)\\n            {\\n                min = prices[i];\\n                minpos = i;\\n            }\\n        }\\n        int max = min;\\n        \\n        for (int i = minpos; i < prices.capacity(); i++)\\n        {\\n            if (prices[i] > max)\\n            {\\n                max = prices[i];\\n                \\n            }\\n            \\n        }\\n        ans = max - min;\\n        \\n        return ans;\\n    }\\n};\\n\\n\\n\\nint main()\\n{\\n    Solution s1;\\n    vector<int> prices = {7, 1, 5, 3, 6, 4};\\n    cout << s1.maxProfit(prices);\\n    return 0;\\n}"
                    },
                    {
                        "username": "lucyrliu",
                        "content": "My code is basically the same as the first Java solution leetcode provided, but whenever I try to submit it it says Time Limit Exceeded. How should I fix it?"
                    },
                    {
                        "username": "BOOMER0641",
                        "content": "i dont understand the question"
                    },
                    {
                        "username": "vasiltsvetkov20",
                        "content": "\npublic class Solution {\n\n    public int MaxProfit(int[] prices) {\n\n            Stack<int> stack = new Stack<int>();\n\n            int maxProfit = int.MinValue;\n\n            for (int i = 0; i < prices.Length; i++)\n            {\n                for (int j = i + 1; j < prices.Length; j++)\n                {\n                    stack.Push(prices[i]);\n\n                    if (- stack.Peek() + prices[j] > maxProfit)\n                    {\n                        maxProfit = - stack.Pop() + prices[j];\n                    }\n                }\n            }\n\n            return maxProfit > 0 ? maxProfit : 0;\n    }\n}\n\nCan someone tell me why the code above has a runtime error 'Out of memory' and how to fix it?"
                    },
                    {
                        "username": "joyifei",
                        "content": "one pitfall I always fall into is,  trying to calculate more information than required. as this problem I think we need to get the date of buying and selling to determine how to get max profit. "
                    },
                    {
                        "username": "simarpalSingh",
                        "content": " \\ndef maxProfit(self, arr: List[int]) -> int:\\n        sm = arr[0]\\n        max = 0\\n        lr = 0\\n        if len(arr) == 0: return 0\\n        for i in range (1, len(arr)):\\n            if arr[i] > lr:\\n                lr = arr[i]\\n                max = max if max > lr-sm else lr-sm\\n            if arr[i] < sm:\\n                sm = arr[i]\\n                lr = 0\\n        return max  \\n"
                    },
                    {
                        "username": "Asha_nagar",
                        "content": "class Solution {\\n    public int maxProfit(int[] price) {\\n    int buyPrice=Integer.MAX_VALUE;\\n    int max=0;\\n    int i=0;\\n    if(price.length-1==0)return 0;\\n   \\n    \\n    while(i<price.length)\\n    {\\n        if(buyPrice<price[i])\\n        {\\n            int profit = price[i]-buyPrice;\\n             max=Math.max(max,profit);\\n        }\\n        else\\n        {\\n            buyPrice=price[i];\\n        }\\n        i++;\\n    }\\n    return max;\\n        \\n    }\\n}[leetcode](https://leetcode.com) @"
                    },
                    {
                        "username": "ashvinPitukun",
                        "content": "pre computation technique is useful here."
                    },
                    {
                        "username": "emti_19",
                        "content": "Why I am getting Time Limit Exceeded here?\\n\\n `\\nint n = prices.size()-1;\\n        int minn = INT_MAX, maxx = INT_MIN;\\n        int i=0,j=n;\\n        while(i<j){\\n            if(prices[i]<minn)\\n                minn = prices[i++];\\n            if(prices[j]>maxx)\\n                maxx = prices[j--];\\n        }\\n        if(maxx-minn>0) return maxx-minn;\\n        else return 0;\\n`"
                    },
                    {
                        "username": "user1799vO",
                        "content": "That is how I understand/digest the one pass approach. Just think yourself as a some one who can change mind at will. \\n\\nint maxProfit(int* prices, int pricesSize)\\n{\\n    /* You buy the stock at day 1 at whatever price. This is ok since you\\n        can change your mind later.  And this is minimal price so far. */  \\n    int min_price = prices[0];     \\n    int max_profit  = 0;   // No profit at day one.\\n    int i;\\n\\n    for(i = 1; i < pricesSize; i++) {\\n        if(prices[i] < min_price) {\\n            /* As days go by. You see a cheaper price. You are kind of regret that\\n               you bought at higher price. But there is nothing you can do other\\n              than recording the minimal price. */\\n            min_price = prices[i];\\n        } else {\\n            if(prices[i] - min_price > max_profit)\\n               /* Now you see a higher price such that  if you sell today and \\n                   bought at the recorded minimal price you will make more profit. \\n                   You immediately changed your mind  :-) */\\n                max_profit = prices[i] - min_price;\\n        }\\n    }\\n\\n    return max_profit;\\n}"
                    }
                ]
            },
            {
                "id": 1708656,
                "content": [
                    {
                        "username": "Siddharth_Sahu",
                        "content": "Someone please tell why this is not working on the site, it works fine on VS code\\n\\n#include <iostream>\\n#include <vector>\\nusing namespace std;\\nclass Solution\\n{\\npublic:\\n    int maxProfit(vector<int> &prices)\\n    {\\n\\n        int min = prices[0];\\n        int minpos;\\n        int ans;\\n\\n        for (int i = 0; i < prices.capacity(); i++)\\n        {\\n            if (prices[i] < min)\\n            {\\n                min = prices[i];\\n                minpos = i;\\n            }\\n        }\\n        int max = min;\\n        \\n        for (int i = minpos; i < prices.capacity(); i++)\\n        {\\n            if (prices[i] > max)\\n            {\\n                max = prices[i];\\n                \\n            }\\n            \\n        }\\n        ans = max - min;\\n        \\n        return ans;\\n    }\\n};\\n\\n\\n\\nint main()\\n{\\n    Solution s1;\\n    vector<int> prices = {7, 1, 5, 3, 6, 4};\\n    cout << s1.maxProfit(prices);\\n    return 0;\\n}"
                    },
                    {
                        "username": "lucyrliu",
                        "content": "My code is basically the same as the first Java solution leetcode provided, but whenever I try to submit it it says Time Limit Exceeded. How should I fix it?"
                    },
                    {
                        "username": "BOOMER0641",
                        "content": "i dont understand the question"
                    },
                    {
                        "username": "vasiltsvetkov20",
                        "content": "\npublic class Solution {\n\n    public int MaxProfit(int[] prices) {\n\n            Stack<int> stack = new Stack<int>();\n\n            int maxProfit = int.MinValue;\n\n            for (int i = 0; i < prices.Length; i++)\n            {\n                for (int j = i + 1; j < prices.Length; j++)\n                {\n                    stack.Push(prices[i]);\n\n                    if (- stack.Peek() + prices[j] > maxProfit)\n                    {\n                        maxProfit = - stack.Pop() + prices[j];\n                    }\n                }\n            }\n\n            return maxProfit > 0 ? maxProfit : 0;\n    }\n}\n\nCan someone tell me why the code above has a runtime error 'Out of memory' and how to fix it?"
                    },
                    {
                        "username": "joyifei",
                        "content": "one pitfall I always fall into is,  trying to calculate more information than required. as this problem I think we need to get the date of buying and selling to determine how to get max profit. "
                    },
                    {
                        "username": "simarpalSingh",
                        "content": " \\ndef maxProfit(self, arr: List[int]) -> int:\\n        sm = arr[0]\\n        max = 0\\n        lr = 0\\n        if len(arr) == 0: return 0\\n        for i in range (1, len(arr)):\\n            if arr[i] > lr:\\n                lr = arr[i]\\n                max = max if max > lr-sm else lr-sm\\n            if arr[i] < sm:\\n                sm = arr[i]\\n                lr = 0\\n        return max  \\n"
                    },
                    {
                        "username": "Asha_nagar",
                        "content": "class Solution {\\n    public int maxProfit(int[] price) {\\n    int buyPrice=Integer.MAX_VALUE;\\n    int max=0;\\n    int i=0;\\n    if(price.length-1==0)return 0;\\n   \\n    \\n    while(i<price.length)\\n    {\\n        if(buyPrice<price[i])\\n        {\\n            int profit = price[i]-buyPrice;\\n             max=Math.max(max,profit);\\n        }\\n        else\\n        {\\n            buyPrice=price[i];\\n        }\\n        i++;\\n    }\\n    return max;\\n        \\n    }\\n}[leetcode](https://leetcode.com) @"
                    },
                    {
                        "username": "ashvinPitukun",
                        "content": "pre computation technique is useful here."
                    },
                    {
                        "username": "emti_19",
                        "content": "Why I am getting Time Limit Exceeded here?\\n\\n `\\nint n = prices.size()-1;\\n        int minn = INT_MAX, maxx = INT_MIN;\\n        int i=0,j=n;\\n        while(i<j){\\n            if(prices[i]<minn)\\n                minn = prices[i++];\\n            if(prices[j]>maxx)\\n                maxx = prices[j--];\\n        }\\n        if(maxx-minn>0) return maxx-minn;\\n        else return 0;\\n`"
                    },
                    {
                        "username": "user1799vO",
                        "content": "That is how I understand/digest the one pass approach. Just think yourself as a some one who can change mind at will. \\n\\nint maxProfit(int* prices, int pricesSize)\\n{\\n    /* You buy the stock at day 1 at whatever price. This is ok since you\\n        can change your mind later.  And this is minimal price so far. */  \\n    int min_price = prices[0];     \\n    int max_profit  = 0;   // No profit at day one.\\n    int i;\\n\\n    for(i = 1; i < pricesSize; i++) {\\n        if(prices[i] < min_price) {\\n            /* As days go by. You see a cheaper price. You are kind of regret that\\n               you bought at higher price. But there is nothing you can do other\\n              than recording the minimal price. */\\n            min_price = prices[i];\\n        } else {\\n            if(prices[i] - min_price > max_profit)\\n               /* Now you see a higher price such that  if you sell today and \\n                   bought at the recorded minimal price you will make more profit. \\n                   You immediately changed your mind  :-) */\\n                max_profit = prices[i] - min_price;\\n        }\\n    }\\n\\n    return max_profit;\\n}"
                    }
                ]
            },
            {
                "id": 1708235,
                "content": [
                    {
                        "username": "Siddharth_Sahu",
                        "content": "Someone please tell why this is not working on the site, it works fine on VS code\\n\\n#include <iostream>\\n#include <vector>\\nusing namespace std;\\nclass Solution\\n{\\npublic:\\n    int maxProfit(vector<int> &prices)\\n    {\\n\\n        int min = prices[0];\\n        int minpos;\\n        int ans;\\n\\n        for (int i = 0; i < prices.capacity(); i++)\\n        {\\n            if (prices[i] < min)\\n            {\\n                min = prices[i];\\n                minpos = i;\\n            }\\n        }\\n        int max = min;\\n        \\n        for (int i = minpos; i < prices.capacity(); i++)\\n        {\\n            if (prices[i] > max)\\n            {\\n                max = prices[i];\\n                \\n            }\\n            \\n        }\\n        ans = max - min;\\n        \\n        return ans;\\n    }\\n};\\n\\n\\n\\nint main()\\n{\\n    Solution s1;\\n    vector<int> prices = {7, 1, 5, 3, 6, 4};\\n    cout << s1.maxProfit(prices);\\n    return 0;\\n}"
                    },
                    {
                        "username": "lucyrliu",
                        "content": "My code is basically the same as the first Java solution leetcode provided, but whenever I try to submit it it says Time Limit Exceeded. How should I fix it?"
                    },
                    {
                        "username": "BOOMER0641",
                        "content": "i dont understand the question"
                    },
                    {
                        "username": "vasiltsvetkov20",
                        "content": "\npublic class Solution {\n\n    public int MaxProfit(int[] prices) {\n\n            Stack<int> stack = new Stack<int>();\n\n            int maxProfit = int.MinValue;\n\n            for (int i = 0; i < prices.Length; i++)\n            {\n                for (int j = i + 1; j < prices.Length; j++)\n                {\n                    stack.Push(prices[i]);\n\n                    if (- stack.Peek() + prices[j] > maxProfit)\n                    {\n                        maxProfit = - stack.Pop() + prices[j];\n                    }\n                }\n            }\n\n            return maxProfit > 0 ? maxProfit : 0;\n    }\n}\n\nCan someone tell me why the code above has a runtime error 'Out of memory' and how to fix it?"
                    },
                    {
                        "username": "joyifei",
                        "content": "one pitfall I always fall into is,  trying to calculate more information than required. as this problem I think we need to get the date of buying and selling to determine how to get max profit. "
                    },
                    {
                        "username": "simarpalSingh",
                        "content": " \\ndef maxProfit(self, arr: List[int]) -> int:\\n        sm = arr[0]\\n        max = 0\\n        lr = 0\\n        if len(arr) == 0: return 0\\n        for i in range (1, len(arr)):\\n            if arr[i] > lr:\\n                lr = arr[i]\\n                max = max if max > lr-sm else lr-sm\\n            if arr[i] < sm:\\n                sm = arr[i]\\n                lr = 0\\n        return max  \\n"
                    },
                    {
                        "username": "Asha_nagar",
                        "content": "class Solution {\\n    public int maxProfit(int[] price) {\\n    int buyPrice=Integer.MAX_VALUE;\\n    int max=0;\\n    int i=0;\\n    if(price.length-1==0)return 0;\\n   \\n    \\n    while(i<price.length)\\n    {\\n        if(buyPrice<price[i])\\n        {\\n            int profit = price[i]-buyPrice;\\n             max=Math.max(max,profit);\\n        }\\n        else\\n        {\\n            buyPrice=price[i];\\n        }\\n        i++;\\n    }\\n    return max;\\n        \\n    }\\n}[leetcode](https://leetcode.com) @"
                    },
                    {
                        "username": "ashvinPitukun",
                        "content": "pre computation technique is useful here."
                    },
                    {
                        "username": "emti_19",
                        "content": "Why I am getting Time Limit Exceeded here?\\n\\n `\\nint n = prices.size()-1;\\n        int minn = INT_MAX, maxx = INT_MIN;\\n        int i=0,j=n;\\n        while(i<j){\\n            if(prices[i]<minn)\\n                minn = prices[i++];\\n            if(prices[j]>maxx)\\n                maxx = prices[j--];\\n        }\\n        if(maxx-minn>0) return maxx-minn;\\n        else return 0;\\n`"
                    },
                    {
                        "username": "user1799vO",
                        "content": "That is how I understand/digest the one pass approach. Just think yourself as a some one who can change mind at will. \\n\\nint maxProfit(int* prices, int pricesSize)\\n{\\n    /* You buy the stock at day 1 at whatever price. This is ok since you\\n        can change your mind later.  And this is minimal price so far. */  \\n    int min_price = prices[0];     \\n    int max_profit  = 0;   // No profit at day one.\\n    int i;\\n\\n    for(i = 1; i < pricesSize; i++) {\\n        if(prices[i] < min_price) {\\n            /* As days go by. You see a cheaper price. You are kind of regret that\\n               you bought at higher price. But there is nothing you can do other\\n              than recording the minimal price. */\\n            min_price = prices[i];\\n        } else {\\n            if(prices[i] - min_price > max_profit)\\n               /* Now you see a higher price such that  if you sell today and \\n                   bought at the recorded minimal price you will make more profit. \\n                   You immediately changed your mind  :-) */\\n                max_profit = prices[i] - min_price;\\n        }\\n    }\\n\\n    return max_profit;\\n}"
                    }
                ]
            },
            {
                "id": 1708004,
                "content": [
                    {
                        "username": "Siddharth_Sahu",
                        "content": "Someone please tell why this is not working on the site, it works fine on VS code\\n\\n#include <iostream>\\n#include <vector>\\nusing namespace std;\\nclass Solution\\n{\\npublic:\\n    int maxProfit(vector<int> &prices)\\n    {\\n\\n        int min = prices[0];\\n        int minpos;\\n        int ans;\\n\\n        for (int i = 0; i < prices.capacity(); i++)\\n        {\\n            if (prices[i] < min)\\n            {\\n                min = prices[i];\\n                minpos = i;\\n            }\\n        }\\n        int max = min;\\n        \\n        for (int i = minpos; i < prices.capacity(); i++)\\n        {\\n            if (prices[i] > max)\\n            {\\n                max = prices[i];\\n                \\n            }\\n            \\n        }\\n        ans = max - min;\\n        \\n        return ans;\\n    }\\n};\\n\\n\\n\\nint main()\\n{\\n    Solution s1;\\n    vector<int> prices = {7, 1, 5, 3, 6, 4};\\n    cout << s1.maxProfit(prices);\\n    return 0;\\n}"
                    },
                    {
                        "username": "lucyrliu",
                        "content": "My code is basically the same as the first Java solution leetcode provided, but whenever I try to submit it it says Time Limit Exceeded. How should I fix it?"
                    },
                    {
                        "username": "BOOMER0641",
                        "content": "i dont understand the question"
                    },
                    {
                        "username": "vasiltsvetkov20",
                        "content": "\npublic class Solution {\n\n    public int MaxProfit(int[] prices) {\n\n            Stack<int> stack = new Stack<int>();\n\n            int maxProfit = int.MinValue;\n\n            for (int i = 0; i < prices.Length; i++)\n            {\n                for (int j = i + 1; j < prices.Length; j++)\n                {\n                    stack.Push(prices[i]);\n\n                    if (- stack.Peek() + prices[j] > maxProfit)\n                    {\n                        maxProfit = - stack.Pop() + prices[j];\n                    }\n                }\n            }\n\n            return maxProfit > 0 ? maxProfit : 0;\n    }\n}\n\nCan someone tell me why the code above has a runtime error 'Out of memory' and how to fix it?"
                    },
                    {
                        "username": "joyifei",
                        "content": "one pitfall I always fall into is,  trying to calculate more information than required. as this problem I think we need to get the date of buying and selling to determine how to get max profit. "
                    },
                    {
                        "username": "simarpalSingh",
                        "content": " \\ndef maxProfit(self, arr: List[int]) -> int:\\n        sm = arr[0]\\n        max = 0\\n        lr = 0\\n        if len(arr) == 0: return 0\\n        for i in range (1, len(arr)):\\n            if arr[i] > lr:\\n                lr = arr[i]\\n                max = max if max > lr-sm else lr-sm\\n            if arr[i] < sm:\\n                sm = arr[i]\\n                lr = 0\\n        return max  \\n"
                    },
                    {
                        "username": "Asha_nagar",
                        "content": "class Solution {\\n    public int maxProfit(int[] price) {\\n    int buyPrice=Integer.MAX_VALUE;\\n    int max=0;\\n    int i=0;\\n    if(price.length-1==0)return 0;\\n   \\n    \\n    while(i<price.length)\\n    {\\n        if(buyPrice<price[i])\\n        {\\n            int profit = price[i]-buyPrice;\\n             max=Math.max(max,profit);\\n        }\\n        else\\n        {\\n            buyPrice=price[i];\\n        }\\n        i++;\\n    }\\n    return max;\\n        \\n    }\\n}[leetcode](https://leetcode.com) @"
                    },
                    {
                        "username": "ashvinPitukun",
                        "content": "pre computation technique is useful here."
                    },
                    {
                        "username": "emti_19",
                        "content": "Why I am getting Time Limit Exceeded here?\\n\\n `\\nint n = prices.size()-1;\\n        int minn = INT_MAX, maxx = INT_MIN;\\n        int i=0,j=n;\\n        while(i<j){\\n            if(prices[i]<minn)\\n                minn = prices[i++];\\n            if(prices[j]>maxx)\\n                maxx = prices[j--];\\n        }\\n        if(maxx-minn>0) return maxx-minn;\\n        else return 0;\\n`"
                    },
                    {
                        "username": "user1799vO",
                        "content": "That is how I understand/digest the one pass approach. Just think yourself as a some one who can change mind at will. \\n\\nint maxProfit(int* prices, int pricesSize)\\n{\\n    /* You buy the stock at day 1 at whatever price. This is ok since you\\n        can change your mind later.  And this is minimal price so far. */  \\n    int min_price = prices[0];     \\n    int max_profit  = 0;   // No profit at day one.\\n    int i;\\n\\n    for(i = 1; i < pricesSize; i++) {\\n        if(prices[i] < min_price) {\\n            /* As days go by. You see a cheaper price. You are kind of regret that\\n               you bought at higher price. But there is nothing you can do other\\n              than recording the minimal price. */\\n            min_price = prices[i];\\n        } else {\\n            if(prices[i] - min_price > max_profit)\\n               /* Now you see a higher price such that  if you sell today and \\n                   bought at the recorded minimal price you will make more profit. \\n                   You immediately changed your mind  :-) */\\n                max_profit = prices[i] - min_price;\\n        }\\n    }\\n\\n    return max_profit;\\n}"
                    }
                ]
            },
            {
                "id": 1702996,
                "content": [
                    {
                        "username": "Azmankhan",
                        "content": " int maxi = 0; //taking maximum 0\\n      int minimum = prices[0];  // choosing the first element of array as minimum \\n      for (int i=0; i< prices.size(); i++ ){\\n          minimum  = min(minimum ,prices[i]); //calculating the minimum \\n          maxi  = max(maxi ,prices[i] - minimum );  //subtracting the the i form minimum as taking maximum bw both \\n      }\\n      return maxi; //returning the maximum \\n    }"
                    },
                    {
                        "username": "indranil_123",
                        "content": "getting TLE on this, any suggestions ?\\nclass Solution {\\npublic:\\n    int maxProfit(vector<int>& prices) {\\n      int profit=0;\\n      for(int i=0;i<prices.size();i++) {\\n          for(int k=i+1;k<prices.size();k++) {\\n              if(prices[k]-prices[i]>profit) {\\n                  profit=prices[k]-prices[i];\\n              }\\n          }\\n      }\\n      return profit;  \\n    }\\n};"
                    },
                    {
                        "username": "jeelanbashaismgk786",
                        "content": "#Best Time to Buy and Sell Stock\\n`class Solution(object):\\n    def maxProfit(self, prices):\\n        maxP=0        \\n        if len(prices) !=0:\\n            for i in range(0,len(prices)):\\n                for j in range(i+1, len(prices)):\\n                    # print(l[i], l[j])\\n                    if prices[i]<prices[j]:\\n                        if prices[j]-prices[i] >maxP:\\n                            maxP=prices[j]-prices[i]\\n        return maxP`\\ni have written this program , but it doesnot pass the total number of testcase\\nin testcase 198 not sure about the input values \\nerror comes ->Time Limit Exceeded\\ncan anybody help please"
                    },
                    {
                        "username": "Geronim",
                        "content": "The following code I\\'ve come up with passes all tests except the one. What\\'s wrong with it? I can\\'t guess the solution.\\n```\\nclass Solution:\\n    def maxProfit(self, prices: List[int]) -> int:\\n        if len(prices) > 1:\\n            # minPrice, minIdx = min(prices), prices.index(min(prices))\\n            minPrice, minIdx = min(prices[:-1]), prices[:-1].index(min(prices[:-1]))\\n            maxPrice, maxIdx = max(prices[1:]), 1 + prices[1:].index(max(prices[1:]))\\n        else:\\n            return 0\\n\\n        remPricesMin = prices[minIdx:]\\n        maxPriceMin = max(remPricesMin) if len(remPricesMin) > 0 else minPrice\\n        diff1 = maxPriceMin - minPrice\\n        \\n        remPricesMax = prices[:maxIdx]\\n        minPriceMax = min(remPricesMax) if len(remPricesMax) > 0 else maxPrice\\n        diff2 = maxPrice - minPriceMax\\n\\n        diff = max(diff1, diff2)\\n\\n        if diff > 0:\\n            return diff\\n        else:\\n            return 0\\n```"
                    },
                    {
                        "username": "problemsX",
                        "content": " why test case  prices=[1,2] expected 1, when logically if a person buys on the first day he will sell the items on the second day which the expected should be 2"
                    },
                    {
                        "username": "arurahul16",
                        "content": "you need to read the problem , it says profit \\nBuy first day at 1 and Sell on second day 2 \\nso you bought a stock for 1 GBP and selling it to 2 GBP \\nProfit ( 2-1=1 GBP)"
                    },
                    {
                        "username": "dhananjaysarathe26",
                        "content": "in test case prices =\\n[1,4,2]; \\n\\nExpected output is 3. But how???? output must be 2 as if we buy on day 1 and sell on day 2 then we have maximum profit."
                    },
                    {
                        "username": "arurahul16",
                        "content": "you need to read the problem , it says profit\\nBuy first day at 1 and Sell on second day at 4\\nso you bought a stock for 1 GBP and selling it to 4 GBP\\nProfit ( 4-1=3 GBP)\\n\\n******Maximum profit*****"
                    },
                    {
                        "username": "kshitij_2025",
                        "content": "this is my apprach\\n`class Solution {\\npublic:\\n    int maxProfit(vector<int>& prices) {\\n        int currprice=INT_MAX,bestprice=0,op=0;\\n        for(int i=0 ; i<prices.size();i++){\\n            if(currprice > prices[i]){\\n                currprice=prices[i];\\n            }\\n                bestprice=prices[i]-currprice;\\n            if(op<bestprice){\\n                op=bestprice;\\n            }\\n            \\n        }return op;\\n    }\\n};`"
                    },
                    {
                        "username": "Biswajit_sahoo",
                        "content": "class Solution {\\n    public int maxProfit(int[] prices) {\\n        int max=0;\\n        int profit =0;\\n        for(int i=0 ; i<prices.length ;i++)\\n        {\\n            for(int j=i+1 ; j<prices.length ;j++)\\n            {\\n                if(prices[j]<prices[i])\\n                {\\n                    continue;\\n                }\\n                else\\n                {\\n                    profit= prices[j]- prices[i];\\n                }\\n                if(profit>max)\\n                {\\n                    max = profit;\\n                }\\n            }\\n            \\n        }\\n        return max;\\n    }\\n}\\n\\n\\nMy code is showing timeout error ."
                    },
                    {
                        "username": "aanchal9580",
                        "content": "how to resolve the time exceeded issue? Mine fails at 201th test case with a large array"
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# \\uD83D\\uDEA9Easy C++ O(N) Soln. [ FAANG\\uD83D\\uDE31 Interview Optimized code ]\\n\\nhttps://leetcode.com/problems/best-time-to-buy-and-sell-stock/solutions/2822579/easy-c-o-n-soln-faang-interview-optimized-code/\\n"
                    }
                ]
            },
            {
                "id": 1702080,
                "content": [
                    {
                        "username": "Azmankhan",
                        "content": " int maxi = 0; //taking maximum 0\\n      int minimum = prices[0];  // choosing the first element of array as minimum \\n      for (int i=0; i< prices.size(); i++ ){\\n          minimum  = min(minimum ,prices[i]); //calculating the minimum \\n          maxi  = max(maxi ,prices[i] - minimum );  //subtracting the the i form minimum as taking maximum bw both \\n      }\\n      return maxi; //returning the maximum \\n    }"
                    },
                    {
                        "username": "indranil_123",
                        "content": "getting TLE on this, any suggestions ?\\nclass Solution {\\npublic:\\n    int maxProfit(vector<int>& prices) {\\n      int profit=0;\\n      for(int i=0;i<prices.size();i++) {\\n          for(int k=i+1;k<prices.size();k++) {\\n              if(prices[k]-prices[i]>profit) {\\n                  profit=prices[k]-prices[i];\\n              }\\n          }\\n      }\\n      return profit;  \\n    }\\n};"
                    },
                    {
                        "username": "jeelanbashaismgk786",
                        "content": "#Best Time to Buy and Sell Stock\\n`class Solution(object):\\n    def maxProfit(self, prices):\\n        maxP=0        \\n        if len(prices) !=0:\\n            for i in range(0,len(prices)):\\n                for j in range(i+1, len(prices)):\\n                    # print(l[i], l[j])\\n                    if prices[i]<prices[j]:\\n                        if prices[j]-prices[i] >maxP:\\n                            maxP=prices[j]-prices[i]\\n        return maxP`\\ni have written this program , but it doesnot pass the total number of testcase\\nin testcase 198 not sure about the input values \\nerror comes ->Time Limit Exceeded\\ncan anybody help please"
                    },
                    {
                        "username": "Geronim",
                        "content": "The following code I\\'ve come up with passes all tests except the one. What\\'s wrong with it? I can\\'t guess the solution.\\n```\\nclass Solution:\\n    def maxProfit(self, prices: List[int]) -> int:\\n        if len(prices) > 1:\\n            # minPrice, minIdx = min(prices), prices.index(min(prices))\\n            minPrice, minIdx = min(prices[:-1]), prices[:-1].index(min(prices[:-1]))\\n            maxPrice, maxIdx = max(prices[1:]), 1 + prices[1:].index(max(prices[1:]))\\n        else:\\n            return 0\\n\\n        remPricesMin = prices[minIdx:]\\n        maxPriceMin = max(remPricesMin) if len(remPricesMin) > 0 else minPrice\\n        diff1 = maxPriceMin - minPrice\\n        \\n        remPricesMax = prices[:maxIdx]\\n        minPriceMax = min(remPricesMax) if len(remPricesMax) > 0 else maxPrice\\n        diff2 = maxPrice - minPriceMax\\n\\n        diff = max(diff1, diff2)\\n\\n        if diff > 0:\\n            return diff\\n        else:\\n            return 0\\n```"
                    },
                    {
                        "username": "problemsX",
                        "content": " why test case  prices=[1,2] expected 1, when logically if a person buys on the first day he will sell the items on the second day which the expected should be 2"
                    },
                    {
                        "username": "arurahul16",
                        "content": "you need to read the problem , it says profit \\nBuy first day at 1 and Sell on second day 2 \\nso you bought a stock for 1 GBP and selling it to 2 GBP \\nProfit ( 2-1=1 GBP)"
                    },
                    {
                        "username": "dhananjaysarathe26",
                        "content": "in test case prices =\\n[1,4,2]; \\n\\nExpected output is 3. But how???? output must be 2 as if we buy on day 1 and sell on day 2 then we have maximum profit."
                    },
                    {
                        "username": "arurahul16",
                        "content": "you need to read the problem , it says profit\\nBuy first day at 1 and Sell on second day at 4\\nso you bought a stock for 1 GBP and selling it to 4 GBP\\nProfit ( 4-1=3 GBP)\\n\\n******Maximum profit*****"
                    },
                    {
                        "username": "kshitij_2025",
                        "content": "this is my apprach\\n`class Solution {\\npublic:\\n    int maxProfit(vector<int>& prices) {\\n        int currprice=INT_MAX,bestprice=0,op=0;\\n        for(int i=0 ; i<prices.size();i++){\\n            if(currprice > prices[i]){\\n                currprice=prices[i];\\n            }\\n                bestprice=prices[i]-currprice;\\n            if(op<bestprice){\\n                op=bestprice;\\n            }\\n            \\n        }return op;\\n    }\\n};`"
                    },
                    {
                        "username": "Biswajit_sahoo",
                        "content": "class Solution {\\n    public int maxProfit(int[] prices) {\\n        int max=0;\\n        int profit =0;\\n        for(int i=0 ; i<prices.length ;i++)\\n        {\\n            for(int j=i+1 ; j<prices.length ;j++)\\n            {\\n                if(prices[j]<prices[i])\\n                {\\n                    continue;\\n                }\\n                else\\n                {\\n                    profit= prices[j]- prices[i];\\n                }\\n                if(profit>max)\\n                {\\n                    max = profit;\\n                }\\n            }\\n            \\n        }\\n        return max;\\n    }\\n}\\n\\n\\nMy code is showing timeout error ."
                    },
                    {
                        "username": "aanchal9580",
                        "content": "how to resolve the time exceeded issue? Mine fails at 201th test case with a large array"
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# \\uD83D\\uDEA9Easy C++ O(N) Soln. [ FAANG\\uD83D\\uDE31 Interview Optimized code ]\\n\\nhttps://leetcode.com/problems/best-time-to-buy-and-sell-stock/solutions/2822579/easy-c-o-n-soln-faang-interview-optimized-code/\\n"
                    }
                ]
            },
            {
                "id": 1700932,
                "content": [
                    {
                        "username": "Azmankhan",
                        "content": " int maxi = 0; //taking maximum 0\\n      int minimum = prices[0];  // choosing the first element of array as minimum \\n      for (int i=0; i< prices.size(); i++ ){\\n          minimum  = min(minimum ,prices[i]); //calculating the minimum \\n          maxi  = max(maxi ,prices[i] - minimum );  //subtracting the the i form minimum as taking maximum bw both \\n      }\\n      return maxi; //returning the maximum \\n    }"
                    },
                    {
                        "username": "indranil_123",
                        "content": "getting TLE on this, any suggestions ?\\nclass Solution {\\npublic:\\n    int maxProfit(vector<int>& prices) {\\n      int profit=0;\\n      for(int i=0;i<prices.size();i++) {\\n          for(int k=i+1;k<prices.size();k++) {\\n              if(prices[k]-prices[i]>profit) {\\n                  profit=prices[k]-prices[i];\\n              }\\n          }\\n      }\\n      return profit;  \\n    }\\n};"
                    },
                    {
                        "username": "jeelanbashaismgk786",
                        "content": "#Best Time to Buy and Sell Stock\\n`class Solution(object):\\n    def maxProfit(self, prices):\\n        maxP=0        \\n        if len(prices) !=0:\\n            for i in range(0,len(prices)):\\n                for j in range(i+1, len(prices)):\\n                    # print(l[i], l[j])\\n                    if prices[i]<prices[j]:\\n                        if prices[j]-prices[i] >maxP:\\n                            maxP=prices[j]-prices[i]\\n        return maxP`\\ni have written this program , but it doesnot pass the total number of testcase\\nin testcase 198 not sure about the input values \\nerror comes ->Time Limit Exceeded\\ncan anybody help please"
                    },
                    {
                        "username": "Geronim",
                        "content": "The following code I\\'ve come up with passes all tests except the one. What\\'s wrong with it? I can\\'t guess the solution.\\n```\\nclass Solution:\\n    def maxProfit(self, prices: List[int]) -> int:\\n        if len(prices) > 1:\\n            # minPrice, minIdx = min(prices), prices.index(min(prices))\\n            minPrice, minIdx = min(prices[:-1]), prices[:-1].index(min(prices[:-1]))\\n            maxPrice, maxIdx = max(prices[1:]), 1 + prices[1:].index(max(prices[1:]))\\n        else:\\n            return 0\\n\\n        remPricesMin = prices[minIdx:]\\n        maxPriceMin = max(remPricesMin) if len(remPricesMin) > 0 else minPrice\\n        diff1 = maxPriceMin - minPrice\\n        \\n        remPricesMax = prices[:maxIdx]\\n        minPriceMax = min(remPricesMax) if len(remPricesMax) > 0 else maxPrice\\n        diff2 = maxPrice - minPriceMax\\n\\n        diff = max(diff1, diff2)\\n\\n        if diff > 0:\\n            return diff\\n        else:\\n            return 0\\n```"
                    },
                    {
                        "username": "problemsX",
                        "content": " why test case  prices=[1,2] expected 1, when logically if a person buys on the first day he will sell the items on the second day which the expected should be 2"
                    },
                    {
                        "username": "arurahul16",
                        "content": "you need to read the problem , it says profit \\nBuy first day at 1 and Sell on second day 2 \\nso you bought a stock for 1 GBP and selling it to 2 GBP \\nProfit ( 2-1=1 GBP)"
                    },
                    {
                        "username": "dhananjaysarathe26",
                        "content": "in test case prices =\\n[1,4,2]; \\n\\nExpected output is 3. But how???? output must be 2 as if we buy on day 1 and sell on day 2 then we have maximum profit."
                    },
                    {
                        "username": "arurahul16",
                        "content": "you need to read the problem , it says profit\\nBuy first day at 1 and Sell on second day at 4\\nso you bought a stock for 1 GBP and selling it to 4 GBP\\nProfit ( 4-1=3 GBP)\\n\\n******Maximum profit*****"
                    },
                    {
                        "username": "kshitij_2025",
                        "content": "this is my apprach\\n`class Solution {\\npublic:\\n    int maxProfit(vector<int>& prices) {\\n        int currprice=INT_MAX,bestprice=0,op=0;\\n        for(int i=0 ; i<prices.size();i++){\\n            if(currprice > prices[i]){\\n                currprice=prices[i];\\n            }\\n                bestprice=prices[i]-currprice;\\n            if(op<bestprice){\\n                op=bestprice;\\n            }\\n            \\n        }return op;\\n    }\\n};`"
                    },
                    {
                        "username": "Biswajit_sahoo",
                        "content": "class Solution {\\n    public int maxProfit(int[] prices) {\\n        int max=0;\\n        int profit =0;\\n        for(int i=0 ; i<prices.length ;i++)\\n        {\\n            for(int j=i+1 ; j<prices.length ;j++)\\n            {\\n                if(prices[j]<prices[i])\\n                {\\n                    continue;\\n                }\\n                else\\n                {\\n                    profit= prices[j]- prices[i];\\n                }\\n                if(profit>max)\\n                {\\n                    max = profit;\\n                }\\n            }\\n            \\n        }\\n        return max;\\n    }\\n}\\n\\n\\nMy code is showing timeout error ."
                    },
                    {
                        "username": "aanchal9580",
                        "content": "how to resolve the time exceeded issue? Mine fails at 201th test case with a large array"
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# \\uD83D\\uDEA9Easy C++ O(N) Soln. [ FAANG\\uD83D\\uDE31 Interview Optimized code ]\\n\\nhttps://leetcode.com/problems/best-time-to-buy-and-sell-stock/solutions/2822579/easy-c-o-n-soln-faang-interview-optimized-code/\\n"
                    }
                ]
            },
            {
                "id": 1700252,
                "content": [
                    {
                        "username": "Azmankhan",
                        "content": " int maxi = 0; //taking maximum 0\\n      int minimum = prices[0];  // choosing the first element of array as minimum \\n      for (int i=0; i< prices.size(); i++ ){\\n          minimum  = min(minimum ,prices[i]); //calculating the minimum \\n          maxi  = max(maxi ,prices[i] - minimum );  //subtracting the the i form minimum as taking maximum bw both \\n      }\\n      return maxi; //returning the maximum \\n    }"
                    },
                    {
                        "username": "indranil_123",
                        "content": "getting TLE on this, any suggestions ?\\nclass Solution {\\npublic:\\n    int maxProfit(vector<int>& prices) {\\n      int profit=0;\\n      for(int i=0;i<prices.size();i++) {\\n          for(int k=i+1;k<prices.size();k++) {\\n              if(prices[k]-prices[i]>profit) {\\n                  profit=prices[k]-prices[i];\\n              }\\n          }\\n      }\\n      return profit;  \\n    }\\n};"
                    },
                    {
                        "username": "jeelanbashaismgk786",
                        "content": "#Best Time to Buy and Sell Stock\\n`class Solution(object):\\n    def maxProfit(self, prices):\\n        maxP=0        \\n        if len(prices) !=0:\\n            for i in range(0,len(prices)):\\n                for j in range(i+1, len(prices)):\\n                    # print(l[i], l[j])\\n                    if prices[i]<prices[j]:\\n                        if prices[j]-prices[i] >maxP:\\n                            maxP=prices[j]-prices[i]\\n        return maxP`\\ni have written this program , but it doesnot pass the total number of testcase\\nin testcase 198 not sure about the input values \\nerror comes ->Time Limit Exceeded\\ncan anybody help please"
                    },
                    {
                        "username": "Geronim",
                        "content": "The following code I\\'ve come up with passes all tests except the one. What\\'s wrong with it? I can\\'t guess the solution.\\n```\\nclass Solution:\\n    def maxProfit(self, prices: List[int]) -> int:\\n        if len(prices) > 1:\\n            # minPrice, minIdx = min(prices), prices.index(min(prices))\\n            minPrice, minIdx = min(prices[:-1]), prices[:-1].index(min(prices[:-1]))\\n            maxPrice, maxIdx = max(prices[1:]), 1 + prices[1:].index(max(prices[1:]))\\n        else:\\n            return 0\\n\\n        remPricesMin = prices[minIdx:]\\n        maxPriceMin = max(remPricesMin) if len(remPricesMin) > 0 else minPrice\\n        diff1 = maxPriceMin - minPrice\\n        \\n        remPricesMax = prices[:maxIdx]\\n        minPriceMax = min(remPricesMax) if len(remPricesMax) > 0 else maxPrice\\n        diff2 = maxPrice - minPriceMax\\n\\n        diff = max(diff1, diff2)\\n\\n        if diff > 0:\\n            return diff\\n        else:\\n            return 0\\n```"
                    },
                    {
                        "username": "problemsX",
                        "content": " why test case  prices=[1,2] expected 1, when logically if a person buys on the first day he will sell the items on the second day which the expected should be 2"
                    },
                    {
                        "username": "arurahul16",
                        "content": "you need to read the problem , it says profit \\nBuy first day at 1 and Sell on second day 2 \\nso you bought a stock for 1 GBP and selling it to 2 GBP \\nProfit ( 2-1=1 GBP)"
                    },
                    {
                        "username": "dhananjaysarathe26",
                        "content": "in test case prices =\\n[1,4,2]; \\n\\nExpected output is 3. But how???? output must be 2 as if we buy on day 1 and sell on day 2 then we have maximum profit."
                    },
                    {
                        "username": "arurahul16",
                        "content": "you need to read the problem , it says profit\\nBuy first day at 1 and Sell on second day at 4\\nso you bought a stock for 1 GBP and selling it to 4 GBP\\nProfit ( 4-1=3 GBP)\\n\\n******Maximum profit*****"
                    },
                    {
                        "username": "kshitij_2025",
                        "content": "this is my apprach\\n`class Solution {\\npublic:\\n    int maxProfit(vector<int>& prices) {\\n        int currprice=INT_MAX,bestprice=0,op=0;\\n        for(int i=0 ; i<prices.size();i++){\\n            if(currprice > prices[i]){\\n                currprice=prices[i];\\n            }\\n                bestprice=prices[i]-currprice;\\n            if(op<bestprice){\\n                op=bestprice;\\n            }\\n            \\n        }return op;\\n    }\\n};`"
                    },
                    {
                        "username": "Biswajit_sahoo",
                        "content": "class Solution {\\n    public int maxProfit(int[] prices) {\\n        int max=0;\\n        int profit =0;\\n        for(int i=0 ; i<prices.length ;i++)\\n        {\\n            for(int j=i+1 ; j<prices.length ;j++)\\n            {\\n                if(prices[j]<prices[i])\\n                {\\n                    continue;\\n                }\\n                else\\n                {\\n                    profit= prices[j]- prices[i];\\n                }\\n                if(profit>max)\\n                {\\n                    max = profit;\\n                }\\n            }\\n            \\n        }\\n        return max;\\n    }\\n}\\n\\n\\nMy code is showing timeout error ."
                    },
                    {
                        "username": "aanchal9580",
                        "content": "how to resolve the time exceeded issue? Mine fails at 201th test case with a large array"
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# \\uD83D\\uDEA9Easy C++ O(N) Soln. [ FAANG\\uD83D\\uDE31 Interview Optimized code ]\\n\\nhttps://leetcode.com/problems/best-time-to-buy-and-sell-stock/solutions/2822579/easy-c-o-n-soln-faang-interview-optimized-code/\\n"
                    }
                ]
            },
            {
                "id": 1700172,
                "content": [
                    {
                        "username": "Azmankhan",
                        "content": " int maxi = 0; //taking maximum 0\\n      int minimum = prices[0];  // choosing the first element of array as minimum \\n      for (int i=0; i< prices.size(); i++ ){\\n          minimum  = min(minimum ,prices[i]); //calculating the minimum \\n          maxi  = max(maxi ,prices[i] - minimum );  //subtracting the the i form minimum as taking maximum bw both \\n      }\\n      return maxi; //returning the maximum \\n    }"
                    },
                    {
                        "username": "indranil_123",
                        "content": "getting TLE on this, any suggestions ?\\nclass Solution {\\npublic:\\n    int maxProfit(vector<int>& prices) {\\n      int profit=0;\\n      for(int i=0;i<prices.size();i++) {\\n          for(int k=i+1;k<prices.size();k++) {\\n              if(prices[k]-prices[i]>profit) {\\n                  profit=prices[k]-prices[i];\\n              }\\n          }\\n      }\\n      return profit;  \\n    }\\n};"
                    },
                    {
                        "username": "jeelanbashaismgk786",
                        "content": "#Best Time to Buy and Sell Stock\\n`class Solution(object):\\n    def maxProfit(self, prices):\\n        maxP=0        \\n        if len(prices) !=0:\\n            for i in range(0,len(prices)):\\n                for j in range(i+1, len(prices)):\\n                    # print(l[i], l[j])\\n                    if prices[i]<prices[j]:\\n                        if prices[j]-prices[i] >maxP:\\n                            maxP=prices[j]-prices[i]\\n        return maxP`\\ni have written this program , but it doesnot pass the total number of testcase\\nin testcase 198 not sure about the input values \\nerror comes ->Time Limit Exceeded\\ncan anybody help please"
                    },
                    {
                        "username": "Geronim",
                        "content": "The following code I\\'ve come up with passes all tests except the one. What\\'s wrong with it? I can\\'t guess the solution.\\n```\\nclass Solution:\\n    def maxProfit(self, prices: List[int]) -> int:\\n        if len(prices) > 1:\\n            # minPrice, minIdx = min(prices), prices.index(min(prices))\\n            minPrice, minIdx = min(prices[:-1]), prices[:-1].index(min(prices[:-1]))\\n            maxPrice, maxIdx = max(prices[1:]), 1 + prices[1:].index(max(prices[1:]))\\n        else:\\n            return 0\\n\\n        remPricesMin = prices[minIdx:]\\n        maxPriceMin = max(remPricesMin) if len(remPricesMin) > 0 else minPrice\\n        diff1 = maxPriceMin - minPrice\\n        \\n        remPricesMax = prices[:maxIdx]\\n        minPriceMax = min(remPricesMax) if len(remPricesMax) > 0 else maxPrice\\n        diff2 = maxPrice - minPriceMax\\n\\n        diff = max(diff1, diff2)\\n\\n        if diff > 0:\\n            return diff\\n        else:\\n            return 0\\n```"
                    },
                    {
                        "username": "problemsX",
                        "content": " why test case  prices=[1,2] expected 1, when logically if a person buys on the first day he will sell the items on the second day which the expected should be 2"
                    },
                    {
                        "username": "arurahul16",
                        "content": "you need to read the problem , it says profit \\nBuy first day at 1 and Sell on second day 2 \\nso you bought a stock for 1 GBP and selling it to 2 GBP \\nProfit ( 2-1=1 GBP)"
                    },
                    {
                        "username": "dhananjaysarathe26",
                        "content": "in test case prices =\\n[1,4,2]; \\n\\nExpected output is 3. But how???? output must be 2 as if we buy on day 1 and sell on day 2 then we have maximum profit."
                    },
                    {
                        "username": "arurahul16",
                        "content": "you need to read the problem , it says profit\\nBuy first day at 1 and Sell on second day at 4\\nso you bought a stock for 1 GBP and selling it to 4 GBP\\nProfit ( 4-1=3 GBP)\\n\\n******Maximum profit*****"
                    },
                    {
                        "username": "kshitij_2025",
                        "content": "this is my apprach\\n`class Solution {\\npublic:\\n    int maxProfit(vector<int>& prices) {\\n        int currprice=INT_MAX,bestprice=0,op=0;\\n        for(int i=0 ; i<prices.size();i++){\\n            if(currprice > prices[i]){\\n                currprice=prices[i];\\n            }\\n                bestprice=prices[i]-currprice;\\n            if(op<bestprice){\\n                op=bestprice;\\n            }\\n            \\n        }return op;\\n    }\\n};`"
                    },
                    {
                        "username": "Biswajit_sahoo",
                        "content": "class Solution {\\n    public int maxProfit(int[] prices) {\\n        int max=0;\\n        int profit =0;\\n        for(int i=0 ; i<prices.length ;i++)\\n        {\\n            for(int j=i+1 ; j<prices.length ;j++)\\n            {\\n                if(prices[j]<prices[i])\\n                {\\n                    continue;\\n                }\\n                else\\n                {\\n                    profit= prices[j]- prices[i];\\n                }\\n                if(profit>max)\\n                {\\n                    max = profit;\\n                }\\n            }\\n            \\n        }\\n        return max;\\n    }\\n}\\n\\n\\nMy code is showing timeout error ."
                    },
                    {
                        "username": "aanchal9580",
                        "content": "how to resolve the time exceeded issue? Mine fails at 201th test case with a large array"
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# \\uD83D\\uDEA9Easy C++ O(N) Soln. [ FAANG\\uD83D\\uDE31 Interview Optimized code ]\\n\\nhttps://leetcode.com/problems/best-time-to-buy-and-sell-stock/solutions/2822579/easy-c-o-n-soln-faang-interview-optimized-code/\\n"
                    }
                ]
            },
            {
                "id": 1700098,
                "content": [
                    {
                        "username": "Azmankhan",
                        "content": " int maxi = 0; //taking maximum 0\\n      int minimum = prices[0];  // choosing the first element of array as minimum \\n      for (int i=0; i< prices.size(); i++ ){\\n          minimum  = min(minimum ,prices[i]); //calculating the minimum \\n          maxi  = max(maxi ,prices[i] - minimum );  //subtracting the the i form minimum as taking maximum bw both \\n      }\\n      return maxi; //returning the maximum \\n    }"
                    },
                    {
                        "username": "indranil_123",
                        "content": "getting TLE on this, any suggestions ?\\nclass Solution {\\npublic:\\n    int maxProfit(vector<int>& prices) {\\n      int profit=0;\\n      for(int i=0;i<prices.size();i++) {\\n          for(int k=i+1;k<prices.size();k++) {\\n              if(prices[k]-prices[i]>profit) {\\n                  profit=prices[k]-prices[i];\\n              }\\n          }\\n      }\\n      return profit;  \\n    }\\n};"
                    },
                    {
                        "username": "jeelanbashaismgk786",
                        "content": "#Best Time to Buy and Sell Stock\\n`class Solution(object):\\n    def maxProfit(self, prices):\\n        maxP=0        \\n        if len(prices) !=0:\\n            for i in range(0,len(prices)):\\n                for j in range(i+1, len(prices)):\\n                    # print(l[i], l[j])\\n                    if prices[i]<prices[j]:\\n                        if prices[j]-prices[i] >maxP:\\n                            maxP=prices[j]-prices[i]\\n        return maxP`\\ni have written this program , but it doesnot pass the total number of testcase\\nin testcase 198 not sure about the input values \\nerror comes ->Time Limit Exceeded\\ncan anybody help please"
                    },
                    {
                        "username": "Geronim",
                        "content": "The following code I\\'ve come up with passes all tests except the one. What\\'s wrong with it? I can\\'t guess the solution.\\n```\\nclass Solution:\\n    def maxProfit(self, prices: List[int]) -> int:\\n        if len(prices) > 1:\\n            # minPrice, minIdx = min(prices), prices.index(min(prices))\\n            minPrice, minIdx = min(prices[:-1]), prices[:-1].index(min(prices[:-1]))\\n            maxPrice, maxIdx = max(prices[1:]), 1 + prices[1:].index(max(prices[1:]))\\n        else:\\n            return 0\\n\\n        remPricesMin = prices[minIdx:]\\n        maxPriceMin = max(remPricesMin) if len(remPricesMin) > 0 else minPrice\\n        diff1 = maxPriceMin - minPrice\\n        \\n        remPricesMax = prices[:maxIdx]\\n        minPriceMax = min(remPricesMax) if len(remPricesMax) > 0 else maxPrice\\n        diff2 = maxPrice - minPriceMax\\n\\n        diff = max(diff1, diff2)\\n\\n        if diff > 0:\\n            return diff\\n        else:\\n            return 0\\n```"
                    },
                    {
                        "username": "problemsX",
                        "content": " why test case  prices=[1,2] expected 1, when logically if a person buys on the first day he will sell the items on the second day which the expected should be 2"
                    },
                    {
                        "username": "arurahul16",
                        "content": "you need to read the problem , it says profit \\nBuy first day at 1 and Sell on second day 2 \\nso you bought a stock for 1 GBP and selling it to 2 GBP \\nProfit ( 2-1=1 GBP)"
                    },
                    {
                        "username": "dhananjaysarathe26",
                        "content": "in test case prices =\\n[1,4,2]; \\n\\nExpected output is 3. But how???? output must be 2 as if we buy on day 1 and sell on day 2 then we have maximum profit."
                    },
                    {
                        "username": "arurahul16",
                        "content": "you need to read the problem , it says profit\\nBuy first day at 1 and Sell on second day at 4\\nso you bought a stock for 1 GBP and selling it to 4 GBP\\nProfit ( 4-1=3 GBP)\\n\\n******Maximum profit*****"
                    },
                    {
                        "username": "kshitij_2025",
                        "content": "this is my apprach\\n`class Solution {\\npublic:\\n    int maxProfit(vector<int>& prices) {\\n        int currprice=INT_MAX,bestprice=0,op=0;\\n        for(int i=0 ; i<prices.size();i++){\\n            if(currprice > prices[i]){\\n                currprice=prices[i];\\n            }\\n                bestprice=prices[i]-currprice;\\n            if(op<bestprice){\\n                op=bestprice;\\n            }\\n            \\n        }return op;\\n    }\\n};`"
                    },
                    {
                        "username": "Biswajit_sahoo",
                        "content": "class Solution {\\n    public int maxProfit(int[] prices) {\\n        int max=0;\\n        int profit =0;\\n        for(int i=0 ; i<prices.length ;i++)\\n        {\\n            for(int j=i+1 ; j<prices.length ;j++)\\n            {\\n                if(prices[j]<prices[i])\\n                {\\n                    continue;\\n                }\\n                else\\n                {\\n                    profit= prices[j]- prices[i];\\n                }\\n                if(profit>max)\\n                {\\n                    max = profit;\\n                }\\n            }\\n            \\n        }\\n        return max;\\n    }\\n}\\n\\n\\nMy code is showing timeout error ."
                    },
                    {
                        "username": "aanchal9580",
                        "content": "how to resolve the time exceeded issue? Mine fails at 201th test case with a large array"
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# \\uD83D\\uDEA9Easy C++ O(N) Soln. [ FAANG\\uD83D\\uDE31 Interview Optimized code ]\\n\\nhttps://leetcode.com/problems/best-time-to-buy-and-sell-stock/solutions/2822579/easy-c-o-n-soln-faang-interview-optimized-code/\\n"
                    }
                ]
            },
            {
                "id": 1699805,
                "content": [
                    {
                        "username": "Azmankhan",
                        "content": " int maxi = 0; //taking maximum 0\\n      int minimum = prices[0];  // choosing the first element of array as minimum \\n      for (int i=0; i< prices.size(); i++ ){\\n          minimum  = min(minimum ,prices[i]); //calculating the minimum \\n          maxi  = max(maxi ,prices[i] - minimum );  //subtracting the the i form minimum as taking maximum bw both \\n      }\\n      return maxi; //returning the maximum \\n    }"
                    },
                    {
                        "username": "indranil_123",
                        "content": "getting TLE on this, any suggestions ?\\nclass Solution {\\npublic:\\n    int maxProfit(vector<int>& prices) {\\n      int profit=0;\\n      for(int i=0;i<prices.size();i++) {\\n          for(int k=i+1;k<prices.size();k++) {\\n              if(prices[k]-prices[i]>profit) {\\n                  profit=prices[k]-prices[i];\\n              }\\n          }\\n      }\\n      return profit;  \\n    }\\n};"
                    },
                    {
                        "username": "jeelanbashaismgk786",
                        "content": "#Best Time to Buy and Sell Stock\\n`class Solution(object):\\n    def maxProfit(self, prices):\\n        maxP=0        \\n        if len(prices) !=0:\\n            for i in range(0,len(prices)):\\n                for j in range(i+1, len(prices)):\\n                    # print(l[i], l[j])\\n                    if prices[i]<prices[j]:\\n                        if prices[j]-prices[i] >maxP:\\n                            maxP=prices[j]-prices[i]\\n        return maxP`\\ni have written this program , but it doesnot pass the total number of testcase\\nin testcase 198 not sure about the input values \\nerror comes ->Time Limit Exceeded\\ncan anybody help please"
                    },
                    {
                        "username": "Geronim",
                        "content": "The following code I\\'ve come up with passes all tests except the one. What\\'s wrong with it? I can\\'t guess the solution.\\n```\\nclass Solution:\\n    def maxProfit(self, prices: List[int]) -> int:\\n        if len(prices) > 1:\\n            # minPrice, minIdx = min(prices), prices.index(min(prices))\\n            minPrice, minIdx = min(prices[:-1]), prices[:-1].index(min(prices[:-1]))\\n            maxPrice, maxIdx = max(prices[1:]), 1 + prices[1:].index(max(prices[1:]))\\n        else:\\n            return 0\\n\\n        remPricesMin = prices[minIdx:]\\n        maxPriceMin = max(remPricesMin) if len(remPricesMin) > 0 else minPrice\\n        diff1 = maxPriceMin - minPrice\\n        \\n        remPricesMax = prices[:maxIdx]\\n        minPriceMax = min(remPricesMax) if len(remPricesMax) > 0 else maxPrice\\n        diff2 = maxPrice - minPriceMax\\n\\n        diff = max(diff1, diff2)\\n\\n        if diff > 0:\\n            return diff\\n        else:\\n            return 0\\n```"
                    },
                    {
                        "username": "problemsX",
                        "content": " why test case  prices=[1,2] expected 1, when logically if a person buys on the first day he will sell the items on the second day which the expected should be 2"
                    },
                    {
                        "username": "arurahul16",
                        "content": "you need to read the problem , it says profit \\nBuy first day at 1 and Sell on second day 2 \\nso you bought a stock for 1 GBP and selling it to 2 GBP \\nProfit ( 2-1=1 GBP)"
                    },
                    {
                        "username": "dhananjaysarathe26",
                        "content": "in test case prices =\\n[1,4,2]; \\n\\nExpected output is 3. But how???? output must be 2 as if we buy on day 1 and sell on day 2 then we have maximum profit."
                    },
                    {
                        "username": "arurahul16",
                        "content": "you need to read the problem , it says profit\\nBuy first day at 1 and Sell on second day at 4\\nso you bought a stock for 1 GBP and selling it to 4 GBP\\nProfit ( 4-1=3 GBP)\\n\\n******Maximum profit*****"
                    },
                    {
                        "username": "kshitij_2025",
                        "content": "this is my apprach\\n`class Solution {\\npublic:\\n    int maxProfit(vector<int>& prices) {\\n        int currprice=INT_MAX,bestprice=0,op=0;\\n        for(int i=0 ; i<prices.size();i++){\\n            if(currprice > prices[i]){\\n                currprice=prices[i];\\n            }\\n                bestprice=prices[i]-currprice;\\n            if(op<bestprice){\\n                op=bestprice;\\n            }\\n            \\n        }return op;\\n    }\\n};`"
                    },
                    {
                        "username": "Biswajit_sahoo",
                        "content": "class Solution {\\n    public int maxProfit(int[] prices) {\\n        int max=0;\\n        int profit =0;\\n        for(int i=0 ; i<prices.length ;i++)\\n        {\\n            for(int j=i+1 ; j<prices.length ;j++)\\n            {\\n                if(prices[j]<prices[i])\\n                {\\n                    continue;\\n                }\\n                else\\n                {\\n                    profit= prices[j]- prices[i];\\n                }\\n                if(profit>max)\\n                {\\n                    max = profit;\\n                }\\n            }\\n            \\n        }\\n        return max;\\n    }\\n}\\n\\n\\nMy code is showing timeout error ."
                    },
                    {
                        "username": "aanchal9580",
                        "content": "how to resolve the time exceeded issue? Mine fails at 201th test case with a large array"
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# \\uD83D\\uDEA9Easy C++ O(N) Soln. [ FAANG\\uD83D\\uDE31 Interview Optimized code ]\\n\\nhttps://leetcode.com/problems/best-time-to-buy-and-sell-stock/solutions/2822579/easy-c-o-n-soln-faang-interview-optimized-code/\\n"
                    }
                ]
            },
            {
                "id": 1696716,
                "content": [
                    {
                        "username": "Azmankhan",
                        "content": " int maxi = 0; //taking maximum 0\\n      int minimum = prices[0];  // choosing the first element of array as minimum \\n      for (int i=0; i< prices.size(); i++ ){\\n          minimum  = min(minimum ,prices[i]); //calculating the minimum \\n          maxi  = max(maxi ,prices[i] - minimum );  //subtracting the the i form minimum as taking maximum bw both \\n      }\\n      return maxi; //returning the maximum \\n    }"
                    },
                    {
                        "username": "indranil_123",
                        "content": "getting TLE on this, any suggestions ?\\nclass Solution {\\npublic:\\n    int maxProfit(vector<int>& prices) {\\n      int profit=0;\\n      for(int i=0;i<prices.size();i++) {\\n          for(int k=i+1;k<prices.size();k++) {\\n              if(prices[k]-prices[i]>profit) {\\n                  profit=prices[k]-prices[i];\\n              }\\n          }\\n      }\\n      return profit;  \\n    }\\n};"
                    },
                    {
                        "username": "jeelanbashaismgk786",
                        "content": "#Best Time to Buy and Sell Stock\\n`class Solution(object):\\n    def maxProfit(self, prices):\\n        maxP=0        \\n        if len(prices) !=0:\\n            for i in range(0,len(prices)):\\n                for j in range(i+1, len(prices)):\\n                    # print(l[i], l[j])\\n                    if prices[i]<prices[j]:\\n                        if prices[j]-prices[i] >maxP:\\n                            maxP=prices[j]-prices[i]\\n        return maxP`\\ni have written this program , but it doesnot pass the total number of testcase\\nin testcase 198 not sure about the input values \\nerror comes ->Time Limit Exceeded\\ncan anybody help please"
                    },
                    {
                        "username": "Geronim",
                        "content": "The following code I\\'ve come up with passes all tests except the one. What\\'s wrong with it? I can\\'t guess the solution.\\n```\\nclass Solution:\\n    def maxProfit(self, prices: List[int]) -> int:\\n        if len(prices) > 1:\\n            # minPrice, minIdx = min(prices), prices.index(min(prices))\\n            minPrice, minIdx = min(prices[:-1]), prices[:-1].index(min(prices[:-1]))\\n            maxPrice, maxIdx = max(prices[1:]), 1 + prices[1:].index(max(prices[1:]))\\n        else:\\n            return 0\\n\\n        remPricesMin = prices[minIdx:]\\n        maxPriceMin = max(remPricesMin) if len(remPricesMin) > 0 else minPrice\\n        diff1 = maxPriceMin - minPrice\\n        \\n        remPricesMax = prices[:maxIdx]\\n        minPriceMax = min(remPricesMax) if len(remPricesMax) > 0 else maxPrice\\n        diff2 = maxPrice - minPriceMax\\n\\n        diff = max(diff1, diff2)\\n\\n        if diff > 0:\\n            return diff\\n        else:\\n            return 0\\n```"
                    },
                    {
                        "username": "problemsX",
                        "content": " why test case  prices=[1,2] expected 1, when logically if a person buys on the first day he will sell the items on the second day which the expected should be 2"
                    },
                    {
                        "username": "arurahul16",
                        "content": "you need to read the problem , it says profit \\nBuy first day at 1 and Sell on second day 2 \\nso you bought a stock for 1 GBP and selling it to 2 GBP \\nProfit ( 2-1=1 GBP)"
                    },
                    {
                        "username": "dhananjaysarathe26",
                        "content": "in test case prices =\\n[1,4,2]; \\n\\nExpected output is 3. But how???? output must be 2 as if we buy on day 1 and sell on day 2 then we have maximum profit."
                    },
                    {
                        "username": "arurahul16",
                        "content": "you need to read the problem , it says profit\\nBuy first day at 1 and Sell on second day at 4\\nso you bought a stock for 1 GBP and selling it to 4 GBP\\nProfit ( 4-1=3 GBP)\\n\\n******Maximum profit*****"
                    },
                    {
                        "username": "kshitij_2025",
                        "content": "this is my apprach\\n`class Solution {\\npublic:\\n    int maxProfit(vector<int>& prices) {\\n        int currprice=INT_MAX,bestprice=0,op=0;\\n        for(int i=0 ; i<prices.size();i++){\\n            if(currprice > prices[i]){\\n                currprice=prices[i];\\n            }\\n                bestprice=prices[i]-currprice;\\n            if(op<bestprice){\\n                op=bestprice;\\n            }\\n            \\n        }return op;\\n    }\\n};`"
                    },
                    {
                        "username": "Biswajit_sahoo",
                        "content": "class Solution {\\n    public int maxProfit(int[] prices) {\\n        int max=0;\\n        int profit =0;\\n        for(int i=0 ; i<prices.length ;i++)\\n        {\\n            for(int j=i+1 ; j<prices.length ;j++)\\n            {\\n                if(prices[j]<prices[i])\\n                {\\n                    continue;\\n                }\\n                else\\n                {\\n                    profit= prices[j]- prices[i];\\n                }\\n                if(profit>max)\\n                {\\n                    max = profit;\\n                }\\n            }\\n            \\n        }\\n        return max;\\n    }\\n}\\n\\n\\nMy code is showing timeout error ."
                    },
                    {
                        "username": "aanchal9580",
                        "content": "how to resolve the time exceeded issue? Mine fails at 201th test case with a large array"
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# \\uD83D\\uDEA9Easy C++ O(N) Soln. [ FAANG\\uD83D\\uDE31 Interview Optimized code ]\\n\\nhttps://leetcode.com/problems/best-time-to-buy-and-sell-stock/solutions/2822579/easy-c-o-n-soln-faang-interview-optimized-code/\\n"
                    }
                ]
            },
            {
                "id": 1690936,
                "content": [
                    {
                        "username": "Azmankhan",
                        "content": " int maxi = 0; //taking maximum 0\\n      int minimum = prices[0];  // choosing the first element of array as minimum \\n      for (int i=0; i< prices.size(); i++ ){\\n          minimum  = min(minimum ,prices[i]); //calculating the minimum \\n          maxi  = max(maxi ,prices[i] - minimum );  //subtracting the the i form minimum as taking maximum bw both \\n      }\\n      return maxi; //returning the maximum \\n    }"
                    },
                    {
                        "username": "indranil_123",
                        "content": "getting TLE on this, any suggestions ?\\nclass Solution {\\npublic:\\n    int maxProfit(vector<int>& prices) {\\n      int profit=0;\\n      for(int i=0;i<prices.size();i++) {\\n          for(int k=i+1;k<prices.size();k++) {\\n              if(prices[k]-prices[i]>profit) {\\n                  profit=prices[k]-prices[i];\\n              }\\n          }\\n      }\\n      return profit;  \\n    }\\n};"
                    },
                    {
                        "username": "jeelanbashaismgk786",
                        "content": "#Best Time to Buy and Sell Stock\\n`class Solution(object):\\n    def maxProfit(self, prices):\\n        maxP=0        \\n        if len(prices) !=0:\\n            for i in range(0,len(prices)):\\n                for j in range(i+1, len(prices)):\\n                    # print(l[i], l[j])\\n                    if prices[i]<prices[j]:\\n                        if prices[j]-prices[i] >maxP:\\n                            maxP=prices[j]-prices[i]\\n        return maxP`\\ni have written this program , but it doesnot pass the total number of testcase\\nin testcase 198 not sure about the input values \\nerror comes ->Time Limit Exceeded\\ncan anybody help please"
                    },
                    {
                        "username": "Geronim",
                        "content": "The following code I\\'ve come up with passes all tests except the one. What\\'s wrong with it? I can\\'t guess the solution.\\n```\\nclass Solution:\\n    def maxProfit(self, prices: List[int]) -> int:\\n        if len(prices) > 1:\\n            # minPrice, minIdx = min(prices), prices.index(min(prices))\\n            minPrice, minIdx = min(prices[:-1]), prices[:-1].index(min(prices[:-1]))\\n            maxPrice, maxIdx = max(prices[1:]), 1 + prices[1:].index(max(prices[1:]))\\n        else:\\n            return 0\\n\\n        remPricesMin = prices[minIdx:]\\n        maxPriceMin = max(remPricesMin) if len(remPricesMin) > 0 else minPrice\\n        diff1 = maxPriceMin - minPrice\\n        \\n        remPricesMax = prices[:maxIdx]\\n        minPriceMax = min(remPricesMax) if len(remPricesMax) > 0 else maxPrice\\n        diff2 = maxPrice - minPriceMax\\n\\n        diff = max(diff1, diff2)\\n\\n        if diff > 0:\\n            return diff\\n        else:\\n            return 0\\n```"
                    },
                    {
                        "username": "problemsX",
                        "content": " why test case  prices=[1,2] expected 1, when logically if a person buys on the first day he will sell the items on the second day which the expected should be 2"
                    },
                    {
                        "username": "arurahul16",
                        "content": "you need to read the problem , it says profit \\nBuy first day at 1 and Sell on second day 2 \\nso you bought a stock for 1 GBP and selling it to 2 GBP \\nProfit ( 2-1=1 GBP)"
                    },
                    {
                        "username": "dhananjaysarathe26",
                        "content": "in test case prices =\\n[1,4,2]; \\n\\nExpected output is 3. But how???? output must be 2 as if we buy on day 1 and sell on day 2 then we have maximum profit."
                    },
                    {
                        "username": "arurahul16",
                        "content": "you need to read the problem , it says profit\\nBuy first day at 1 and Sell on second day at 4\\nso you bought a stock for 1 GBP and selling it to 4 GBP\\nProfit ( 4-1=3 GBP)\\n\\n******Maximum profit*****"
                    },
                    {
                        "username": "kshitij_2025",
                        "content": "this is my apprach\\n`class Solution {\\npublic:\\n    int maxProfit(vector<int>& prices) {\\n        int currprice=INT_MAX,bestprice=0,op=0;\\n        for(int i=0 ; i<prices.size();i++){\\n            if(currprice > prices[i]){\\n                currprice=prices[i];\\n            }\\n                bestprice=prices[i]-currprice;\\n            if(op<bestprice){\\n                op=bestprice;\\n            }\\n            \\n        }return op;\\n    }\\n};`"
                    },
                    {
                        "username": "Biswajit_sahoo",
                        "content": "class Solution {\\n    public int maxProfit(int[] prices) {\\n        int max=0;\\n        int profit =0;\\n        for(int i=0 ; i<prices.length ;i++)\\n        {\\n            for(int j=i+1 ; j<prices.length ;j++)\\n            {\\n                if(prices[j]<prices[i])\\n                {\\n                    continue;\\n                }\\n                else\\n                {\\n                    profit= prices[j]- prices[i];\\n                }\\n                if(profit>max)\\n                {\\n                    max = profit;\\n                }\\n            }\\n            \\n        }\\n        return max;\\n    }\\n}\\n\\n\\nMy code is showing timeout error ."
                    },
                    {
                        "username": "aanchal9580",
                        "content": "how to resolve the time exceeded issue? Mine fails at 201th test case with a large array"
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# \\uD83D\\uDEA9Easy C++ O(N) Soln. [ FAANG\\uD83D\\uDE31 Interview Optimized code ]\\n\\nhttps://leetcode.com/problems/best-time-to-buy-and-sell-stock/solutions/2822579/easy-c-o-n-soln-faang-interview-optimized-code/\\n"
                    }
                ]
            },
            {
                "id": 1686853,
                "content": [
                    {
                        "username": "Azmankhan",
                        "content": " int maxi = 0; //taking maximum 0\\n      int minimum = prices[0];  // choosing the first element of array as minimum \\n      for (int i=0; i< prices.size(); i++ ){\\n          minimum  = min(minimum ,prices[i]); //calculating the minimum \\n          maxi  = max(maxi ,prices[i] - minimum );  //subtracting the the i form minimum as taking maximum bw both \\n      }\\n      return maxi; //returning the maximum \\n    }"
                    },
                    {
                        "username": "indranil_123",
                        "content": "getting TLE on this, any suggestions ?\\nclass Solution {\\npublic:\\n    int maxProfit(vector<int>& prices) {\\n      int profit=0;\\n      for(int i=0;i<prices.size();i++) {\\n          for(int k=i+1;k<prices.size();k++) {\\n              if(prices[k]-prices[i]>profit) {\\n                  profit=prices[k]-prices[i];\\n              }\\n          }\\n      }\\n      return profit;  \\n    }\\n};"
                    },
                    {
                        "username": "jeelanbashaismgk786",
                        "content": "#Best Time to Buy and Sell Stock\\n`class Solution(object):\\n    def maxProfit(self, prices):\\n        maxP=0        \\n        if len(prices) !=0:\\n            for i in range(0,len(prices)):\\n                for j in range(i+1, len(prices)):\\n                    # print(l[i], l[j])\\n                    if prices[i]<prices[j]:\\n                        if prices[j]-prices[i] >maxP:\\n                            maxP=prices[j]-prices[i]\\n        return maxP`\\ni have written this program , but it doesnot pass the total number of testcase\\nin testcase 198 not sure about the input values \\nerror comes ->Time Limit Exceeded\\ncan anybody help please"
                    },
                    {
                        "username": "Geronim",
                        "content": "The following code I\\'ve come up with passes all tests except the one. What\\'s wrong with it? I can\\'t guess the solution.\\n```\\nclass Solution:\\n    def maxProfit(self, prices: List[int]) -> int:\\n        if len(prices) > 1:\\n            # minPrice, minIdx = min(prices), prices.index(min(prices))\\n            minPrice, minIdx = min(prices[:-1]), prices[:-1].index(min(prices[:-1]))\\n            maxPrice, maxIdx = max(prices[1:]), 1 + prices[1:].index(max(prices[1:]))\\n        else:\\n            return 0\\n\\n        remPricesMin = prices[minIdx:]\\n        maxPriceMin = max(remPricesMin) if len(remPricesMin) > 0 else minPrice\\n        diff1 = maxPriceMin - minPrice\\n        \\n        remPricesMax = prices[:maxIdx]\\n        minPriceMax = min(remPricesMax) if len(remPricesMax) > 0 else maxPrice\\n        diff2 = maxPrice - minPriceMax\\n\\n        diff = max(diff1, diff2)\\n\\n        if diff > 0:\\n            return diff\\n        else:\\n            return 0\\n```"
                    },
                    {
                        "username": "problemsX",
                        "content": " why test case  prices=[1,2] expected 1, when logically if a person buys on the first day he will sell the items on the second day which the expected should be 2"
                    },
                    {
                        "username": "arurahul16",
                        "content": "you need to read the problem , it says profit \\nBuy first day at 1 and Sell on second day 2 \\nso you bought a stock for 1 GBP and selling it to 2 GBP \\nProfit ( 2-1=1 GBP)"
                    },
                    {
                        "username": "dhananjaysarathe26",
                        "content": "in test case prices =\\n[1,4,2]; \\n\\nExpected output is 3. But how???? output must be 2 as if we buy on day 1 and sell on day 2 then we have maximum profit."
                    },
                    {
                        "username": "arurahul16",
                        "content": "you need to read the problem , it says profit\\nBuy first day at 1 and Sell on second day at 4\\nso you bought a stock for 1 GBP and selling it to 4 GBP\\nProfit ( 4-1=3 GBP)\\n\\n******Maximum profit*****"
                    },
                    {
                        "username": "kshitij_2025",
                        "content": "this is my apprach\\n`class Solution {\\npublic:\\n    int maxProfit(vector<int>& prices) {\\n        int currprice=INT_MAX,bestprice=0,op=0;\\n        for(int i=0 ; i<prices.size();i++){\\n            if(currprice > prices[i]){\\n                currprice=prices[i];\\n            }\\n                bestprice=prices[i]-currprice;\\n            if(op<bestprice){\\n                op=bestprice;\\n            }\\n            \\n        }return op;\\n    }\\n};`"
                    },
                    {
                        "username": "Biswajit_sahoo",
                        "content": "class Solution {\\n    public int maxProfit(int[] prices) {\\n        int max=0;\\n        int profit =0;\\n        for(int i=0 ; i<prices.length ;i++)\\n        {\\n            for(int j=i+1 ; j<prices.length ;j++)\\n            {\\n                if(prices[j]<prices[i])\\n                {\\n                    continue;\\n                }\\n                else\\n                {\\n                    profit= prices[j]- prices[i];\\n                }\\n                if(profit>max)\\n                {\\n                    max = profit;\\n                }\\n            }\\n            \\n        }\\n        return max;\\n    }\\n}\\n\\n\\nMy code is showing timeout error ."
                    },
                    {
                        "username": "aanchal9580",
                        "content": "how to resolve the time exceeded issue? Mine fails at 201th test case with a large array"
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# \\uD83D\\uDEA9Easy C++ O(N) Soln. [ FAANG\\uD83D\\uDE31 Interview Optimized code ]\\n\\nhttps://leetcode.com/problems/best-time-to-buy-and-sell-stock/solutions/2822579/easy-c-o-n-soln-faang-interview-optimized-code/\\n"
                    }
                ]
            },
            {
                "id": 1686296,
                "content": [
                    {
                        "username": "Kishore-Thalisetty",
                        "content": "\\nJAVA SOLUTION - (O(N)) time complexity\\nclass Solution {\\n    public int maxProfit(int[] prices) {\\n       int buy=prices[0];\\n        int sell=0;\\n        int max=0;\\n        for(int i=1; i<prices.length; i++){\\n            if(buy>prices[i]){\\n                buy=prices[i];\\n\\n            }else if(buy<prices[i] ){\\n                sell=prices[i]-buy;\\n                if(max<sell) max=sell;\\n            }\\n        }\\n           return max;\\n    }\\n}"
                    },
                    {
                        "username": "apeWithKeyBoard",
                        "content": "I have written basic O(n\\'squared) solution but the 203 testcase fails with Time Limit exceeded ouput. Any suggestions ?\\n"
                    },
                    {
                        "username": "Aman_26",
                        "content": "Whats wrong with this code?\\n    def maxProfit(self, prices: List[int]) -> int:\\n        n = len(prices)\\n        minimum_num = min(prices)\\n        index_min = prices.index(minimum_num)\\n        if index_min != n:\\n            prices = prices[index_min+1:]\\n            if len(prices) != 0:\\n                max_num = max(prices)\\n            else:\\n                max_num = 0\\n                if max_num > minimum_num:\\n                    return max_num - minimum_num\\n                else:\\n                    return 0\\n        return max_num - minimum_num\\n\\nit fails for the input [2,4,1], expected output is 2 my output is 0"
                    },
                    {
                        "username": "MuthuKrishnan007",
                        "content": "Hi,\\nCan anyone explain what is the requirements of the program clearly because in the first example input 715364 day 2 stock is buyed and sell in day 5 .\\nIn example 2 76431 in this example transaction is zero why can\\'t didn\\'t buy any stock.\\nAnyone please explain this."
                    },
                    {
                        "username": "arurahul16",
                        "content": "you need to read the problem , it says profit\\nBuy first day at 1 and Sell on second day 2\\nso you bought a stock for 1 GBP and selling it to 2 GBP\\nProfit ( 2-1=1 GBP)\\n\\nMAKE SURE  **MAXIMUM PROFIT***"
                    },
                    {
                        "username": "Amit_Joe",
                        "content": "only test case with having input 1,2 doesnt work the program is still to produce expected output in local machine. why??"
                    },
                    {
                        "username": "braads07",
                        "content": "[CAN SOMEONE PLS..HELP ME , WHERE M I WRONG?\\nCan we find the solution in this way?](CAN SOMEONE PLS..HELP ME , WHERE M I WRONG?\\nCan we find the solution in this way?)\\n\\n  `class Solution {\\npublic:\\n    int maxProfit(vector<int>& v) {\\n\\n        vector<int>v1=v;\\n        sort(v1.begin() , v1.end());\\n        int num=0;\\n        int n=v.size();\\n        int front=0;\\n        int end=v.size()-1;\\n        int maxx=INT_MIN;\\n        while(num!=n)\\n        {\\n            int i=search(v , 0 , n-1 ,  v1[front]);\\n            int j=search(v , 0 , n-1 ,  v1[end]);\\n            if(i<j)\\n            {\\n                maxx=max(maxx , (v1[end]-v1[front]));\\n                end=v.size()-1;\\n                front++;\\n                num++;\\n            }\\n            else if(front==end)\\n            {\\n                front++;\\n                end=v.size()-1;\\n                num++;\\n            }\\n            else\\n            {\\n                end--;\\n            }\\n        }\\n        if(maxx<=0)\\n        return 0;\\n        else \\n        return maxx;\\n\\n        \\n    }\\n    int search(vector<int>arr , int l , int r , int x)\\n    {\\n         if (r >= l) {\\n        int mid = l + (r - l) / 2;\\n\\n        if (arr[mid] == x)\\n            return mid;\\n \\n        // If element is smaller than mid, then\\n        // it can only be present in left subarray\\n        if (arr[mid] > x)\\n            return search(arr, l, mid - 1, x);\\n \\n        // Else the element can only be present\\n        // in right subarray\\n        return search(arr, mid + 1, r, x);\\n    }\\n    return -1;\\n    }\\n\\n\\n};`"
                    },
                    {
                        "username": "codernoob",
                        "content": "how are ppl doing the very large test array input? I am getting Time Limit Exceeded"
                    },
                    {
                        "username": "user3827xr",
                        "content": "In this problem, can we consider prices are positive numbers ? (remember, 2020 and negative prices of crude oil)"
                    },
                    {
                        "username": "arurahul16",
                        "content": "read problem properly ranges for prices[i] are mentioned from 0"
                    },
                    {
                        "username": "MeriemA",
                        "content": "Hello, \n\nI have tried to solve this problem using C. My solution works for almost all of the TCs. But the problem is that it shows time limit exceeded when the input is so large. So can anyone can help me to optimize my code?\nThanks a lot.\n\n `int maxProfit(int* prices, int pricesSize)\n{   \n    int buy_day = 0;\n    int sell_day = 0;\n    int max_profit = 0;\n    int profit = 0;\n\n    for (buy_day = 0; buy_day<pricesSize; buy_day++)\n    {\n        sell_day = buy_day + 1;\n        for(sell_day; sell_day<pricesSize; sell_day++)\n        {\n            profit = prices[sell_day] - prices[buy_day];\n            if (profit > max_profit)\n            {\n                max_profit = profit;\n            }\n        }\n    }\n\nreturn max_profit;\n}`\n\n"
                    },
                    {
                        "username": "alangreg",
                        "content": "[@MeriemA](/MeriemA) Probably. Thats why times out on large TC. I also striked out few times on time limit but then I changed approach to 1 loop (well 1 and a half as I used built in max() function) and it passed."
                    },
                    {
                        "username": "MeriemA",
                        "content": "[@alangreg](/alangreg) Thank you for you reply. Actually, the second loop won\\'t run over all of the table but only a part of it starting from a predefined index. So here I guess the time complexity is O(nlogn) not O(n\\xB2). right?"
                    },
                    {
                        "username": "alangreg",
                        "content": "The first thing I noticed is you are running with two loops."
                    },
                    {
                        "username": "Amarjeet2909",
                        "content": "Can Anyone tell why time limit exceeding here:\\n\\nclass Solution {\\npublic:\\n    int maxProfit(vector<int>& prices) {\\n        int profit =0;\\n        for(int i=0;i<prices.size()-1;i++){\\n            for(int j=i+1;j<prices.size();j++){\\n                if(prices[i]<prices[j]){\\n                int temp= prices[j]-prices[i];\\n                profit= max(profit, temp);\\n                }\\n            }   \\n        }\\n        return profit;\\n    }\\n};"
                    },
                    {
                        "username": "wodxuming",
                        "content": "```\\n\\nclass Solution {\\n    public int maxProfit(int[] prices) {\\n          int n = prices.length;\\n        // base case: dp[-1][0] = 0, dp[-1][1] = -infinity\\n        int dp_i_0 = 0, dp_i_1 = Integer.MIN_VALUE;\\n        for (int i = 0; i < n; i++) {\\n            // dp[i][0] = max(dp[i-1][0], dp[i-1][1] + prices[i])\\n            dp_i_0 = Math.max(dp_i_0, dp_i_1 + prices[i]);\\n            // dp[i][1] = max(dp[i-1][1], -prices[i])\\n            dp_i_1 = Math.max(dp_i_1, -prices[i]);\\n        }\\n        return dp_i_0; \\n    }\\n}\\n\\n```"
                    }
                ]
            },
            {
                "id": 1684355,
                "content": [
                    {
                        "username": "Kishore-Thalisetty",
                        "content": "\\nJAVA SOLUTION - (O(N)) time complexity\\nclass Solution {\\n    public int maxProfit(int[] prices) {\\n       int buy=prices[0];\\n        int sell=0;\\n        int max=0;\\n        for(int i=1; i<prices.length; i++){\\n            if(buy>prices[i]){\\n                buy=prices[i];\\n\\n            }else if(buy<prices[i] ){\\n                sell=prices[i]-buy;\\n                if(max<sell) max=sell;\\n            }\\n        }\\n           return max;\\n    }\\n}"
                    },
                    {
                        "username": "apeWithKeyBoard",
                        "content": "I have written basic O(n\\'squared) solution but the 203 testcase fails with Time Limit exceeded ouput. Any suggestions ?\\n"
                    },
                    {
                        "username": "Aman_26",
                        "content": "Whats wrong with this code?\\n    def maxProfit(self, prices: List[int]) -> int:\\n        n = len(prices)\\n        minimum_num = min(prices)\\n        index_min = prices.index(minimum_num)\\n        if index_min != n:\\n            prices = prices[index_min+1:]\\n            if len(prices) != 0:\\n                max_num = max(prices)\\n            else:\\n                max_num = 0\\n                if max_num > minimum_num:\\n                    return max_num - minimum_num\\n                else:\\n                    return 0\\n        return max_num - minimum_num\\n\\nit fails for the input [2,4,1], expected output is 2 my output is 0"
                    },
                    {
                        "username": "MuthuKrishnan007",
                        "content": "Hi,\\nCan anyone explain what is the requirements of the program clearly because in the first example input 715364 day 2 stock is buyed and sell in day 5 .\\nIn example 2 76431 in this example transaction is zero why can\\'t didn\\'t buy any stock.\\nAnyone please explain this."
                    },
                    {
                        "username": "arurahul16",
                        "content": "you need to read the problem , it says profit\\nBuy first day at 1 and Sell on second day 2\\nso you bought a stock for 1 GBP and selling it to 2 GBP\\nProfit ( 2-1=1 GBP)\\n\\nMAKE SURE  **MAXIMUM PROFIT***"
                    },
                    {
                        "username": "Amit_Joe",
                        "content": "only test case with having input 1,2 doesnt work the program is still to produce expected output in local machine. why??"
                    },
                    {
                        "username": "braads07",
                        "content": "[CAN SOMEONE PLS..HELP ME , WHERE M I WRONG?\\nCan we find the solution in this way?](CAN SOMEONE PLS..HELP ME , WHERE M I WRONG?\\nCan we find the solution in this way?)\\n\\n  `class Solution {\\npublic:\\n    int maxProfit(vector<int>& v) {\\n\\n        vector<int>v1=v;\\n        sort(v1.begin() , v1.end());\\n        int num=0;\\n        int n=v.size();\\n        int front=0;\\n        int end=v.size()-1;\\n        int maxx=INT_MIN;\\n        while(num!=n)\\n        {\\n            int i=search(v , 0 , n-1 ,  v1[front]);\\n            int j=search(v , 0 , n-1 ,  v1[end]);\\n            if(i<j)\\n            {\\n                maxx=max(maxx , (v1[end]-v1[front]));\\n                end=v.size()-1;\\n                front++;\\n                num++;\\n            }\\n            else if(front==end)\\n            {\\n                front++;\\n                end=v.size()-1;\\n                num++;\\n            }\\n            else\\n            {\\n                end--;\\n            }\\n        }\\n        if(maxx<=0)\\n        return 0;\\n        else \\n        return maxx;\\n\\n        \\n    }\\n    int search(vector<int>arr , int l , int r , int x)\\n    {\\n         if (r >= l) {\\n        int mid = l + (r - l) / 2;\\n\\n        if (arr[mid] == x)\\n            return mid;\\n \\n        // If element is smaller than mid, then\\n        // it can only be present in left subarray\\n        if (arr[mid] > x)\\n            return search(arr, l, mid - 1, x);\\n \\n        // Else the element can only be present\\n        // in right subarray\\n        return search(arr, mid + 1, r, x);\\n    }\\n    return -1;\\n    }\\n\\n\\n};`"
                    },
                    {
                        "username": "codernoob",
                        "content": "how are ppl doing the very large test array input? I am getting Time Limit Exceeded"
                    },
                    {
                        "username": "user3827xr",
                        "content": "In this problem, can we consider prices are positive numbers ? (remember, 2020 and negative prices of crude oil)"
                    },
                    {
                        "username": "arurahul16",
                        "content": "read problem properly ranges for prices[i] are mentioned from 0"
                    },
                    {
                        "username": "MeriemA",
                        "content": "Hello, \n\nI have tried to solve this problem using C. My solution works for almost all of the TCs. But the problem is that it shows time limit exceeded when the input is so large. So can anyone can help me to optimize my code?\nThanks a lot.\n\n `int maxProfit(int* prices, int pricesSize)\n{   \n    int buy_day = 0;\n    int sell_day = 0;\n    int max_profit = 0;\n    int profit = 0;\n\n    for (buy_day = 0; buy_day<pricesSize; buy_day++)\n    {\n        sell_day = buy_day + 1;\n        for(sell_day; sell_day<pricesSize; sell_day++)\n        {\n            profit = prices[sell_day] - prices[buy_day];\n            if (profit > max_profit)\n            {\n                max_profit = profit;\n            }\n        }\n    }\n\nreturn max_profit;\n}`\n\n"
                    },
                    {
                        "username": "alangreg",
                        "content": "[@MeriemA](/MeriemA) Probably. Thats why times out on large TC. I also striked out few times on time limit but then I changed approach to 1 loop (well 1 and a half as I used built in max() function) and it passed."
                    },
                    {
                        "username": "MeriemA",
                        "content": "[@alangreg](/alangreg) Thank you for you reply. Actually, the second loop won\\'t run over all of the table but only a part of it starting from a predefined index. So here I guess the time complexity is O(nlogn) not O(n\\xB2). right?"
                    },
                    {
                        "username": "alangreg",
                        "content": "The first thing I noticed is you are running with two loops."
                    },
                    {
                        "username": "Amarjeet2909",
                        "content": "Can Anyone tell why time limit exceeding here:\\n\\nclass Solution {\\npublic:\\n    int maxProfit(vector<int>& prices) {\\n        int profit =0;\\n        for(int i=0;i<prices.size()-1;i++){\\n            for(int j=i+1;j<prices.size();j++){\\n                if(prices[i]<prices[j]){\\n                int temp= prices[j]-prices[i];\\n                profit= max(profit, temp);\\n                }\\n            }   \\n        }\\n        return profit;\\n    }\\n};"
                    },
                    {
                        "username": "wodxuming",
                        "content": "```\\n\\nclass Solution {\\n    public int maxProfit(int[] prices) {\\n          int n = prices.length;\\n        // base case: dp[-1][0] = 0, dp[-1][1] = -infinity\\n        int dp_i_0 = 0, dp_i_1 = Integer.MIN_VALUE;\\n        for (int i = 0; i < n; i++) {\\n            // dp[i][0] = max(dp[i-1][0], dp[i-1][1] + prices[i])\\n            dp_i_0 = Math.max(dp_i_0, dp_i_1 + prices[i]);\\n            // dp[i][1] = max(dp[i-1][1], -prices[i])\\n            dp_i_1 = Math.max(dp_i_1, -prices[i]);\\n        }\\n        return dp_i_0; \\n    }\\n}\\n\\n```"
                    }
                ]
            },
            {
                "id": 1683906,
                "content": [
                    {
                        "username": "Kishore-Thalisetty",
                        "content": "\\nJAVA SOLUTION - (O(N)) time complexity\\nclass Solution {\\n    public int maxProfit(int[] prices) {\\n       int buy=prices[0];\\n        int sell=0;\\n        int max=0;\\n        for(int i=1; i<prices.length; i++){\\n            if(buy>prices[i]){\\n                buy=prices[i];\\n\\n            }else if(buy<prices[i] ){\\n                sell=prices[i]-buy;\\n                if(max<sell) max=sell;\\n            }\\n        }\\n           return max;\\n    }\\n}"
                    },
                    {
                        "username": "apeWithKeyBoard",
                        "content": "I have written basic O(n\\'squared) solution but the 203 testcase fails with Time Limit exceeded ouput. Any suggestions ?\\n"
                    },
                    {
                        "username": "Aman_26",
                        "content": "Whats wrong with this code?\\n    def maxProfit(self, prices: List[int]) -> int:\\n        n = len(prices)\\n        minimum_num = min(prices)\\n        index_min = prices.index(minimum_num)\\n        if index_min != n:\\n            prices = prices[index_min+1:]\\n            if len(prices) != 0:\\n                max_num = max(prices)\\n            else:\\n                max_num = 0\\n                if max_num > minimum_num:\\n                    return max_num - minimum_num\\n                else:\\n                    return 0\\n        return max_num - minimum_num\\n\\nit fails for the input [2,4,1], expected output is 2 my output is 0"
                    },
                    {
                        "username": "MuthuKrishnan007",
                        "content": "Hi,\\nCan anyone explain what is the requirements of the program clearly because in the first example input 715364 day 2 stock is buyed and sell in day 5 .\\nIn example 2 76431 in this example transaction is zero why can\\'t didn\\'t buy any stock.\\nAnyone please explain this."
                    },
                    {
                        "username": "arurahul16",
                        "content": "you need to read the problem , it says profit\\nBuy first day at 1 and Sell on second day 2\\nso you bought a stock for 1 GBP and selling it to 2 GBP\\nProfit ( 2-1=1 GBP)\\n\\nMAKE SURE  **MAXIMUM PROFIT***"
                    },
                    {
                        "username": "Amit_Joe",
                        "content": "only test case with having input 1,2 doesnt work the program is still to produce expected output in local machine. why??"
                    },
                    {
                        "username": "braads07",
                        "content": "[CAN SOMEONE PLS..HELP ME , WHERE M I WRONG?\\nCan we find the solution in this way?](CAN SOMEONE PLS..HELP ME , WHERE M I WRONG?\\nCan we find the solution in this way?)\\n\\n  `class Solution {\\npublic:\\n    int maxProfit(vector<int>& v) {\\n\\n        vector<int>v1=v;\\n        sort(v1.begin() , v1.end());\\n        int num=0;\\n        int n=v.size();\\n        int front=0;\\n        int end=v.size()-1;\\n        int maxx=INT_MIN;\\n        while(num!=n)\\n        {\\n            int i=search(v , 0 , n-1 ,  v1[front]);\\n            int j=search(v , 0 , n-1 ,  v1[end]);\\n            if(i<j)\\n            {\\n                maxx=max(maxx , (v1[end]-v1[front]));\\n                end=v.size()-1;\\n                front++;\\n                num++;\\n            }\\n            else if(front==end)\\n            {\\n                front++;\\n                end=v.size()-1;\\n                num++;\\n            }\\n            else\\n            {\\n                end--;\\n            }\\n        }\\n        if(maxx<=0)\\n        return 0;\\n        else \\n        return maxx;\\n\\n        \\n    }\\n    int search(vector<int>arr , int l , int r , int x)\\n    {\\n         if (r >= l) {\\n        int mid = l + (r - l) / 2;\\n\\n        if (arr[mid] == x)\\n            return mid;\\n \\n        // If element is smaller than mid, then\\n        // it can only be present in left subarray\\n        if (arr[mid] > x)\\n            return search(arr, l, mid - 1, x);\\n \\n        // Else the element can only be present\\n        // in right subarray\\n        return search(arr, mid + 1, r, x);\\n    }\\n    return -1;\\n    }\\n\\n\\n};`"
                    },
                    {
                        "username": "codernoob",
                        "content": "how are ppl doing the very large test array input? I am getting Time Limit Exceeded"
                    },
                    {
                        "username": "user3827xr",
                        "content": "In this problem, can we consider prices are positive numbers ? (remember, 2020 and negative prices of crude oil)"
                    },
                    {
                        "username": "arurahul16",
                        "content": "read problem properly ranges for prices[i] are mentioned from 0"
                    },
                    {
                        "username": "MeriemA",
                        "content": "Hello, \n\nI have tried to solve this problem using C. My solution works for almost all of the TCs. But the problem is that it shows time limit exceeded when the input is so large. So can anyone can help me to optimize my code?\nThanks a lot.\n\n `int maxProfit(int* prices, int pricesSize)\n{   \n    int buy_day = 0;\n    int sell_day = 0;\n    int max_profit = 0;\n    int profit = 0;\n\n    for (buy_day = 0; buy_day<pricesSize; buy_day++)\n    {\n        sell_day = buy_day + 1;\n        for(sell_day; sell_day<pricesSize; sell_day++)\n        {\n            profit = prices[sell_day] - prices[buy_day];\n            if (profit > max_profit)\n            {\n                max_profit = profit;\n            }\n        }\n    }\n\nreturn max_profit;\n}`\n\n"
                    },
                    {
                        "username": "alangreg",
                        "content": "[@MeriemA](/MeriemA) Probably. Thats why times out on large TC. I also striked out few times on time limit but then I changed approach to 1 loop (well 1 and a half as I used built in max() function) and it passed."
                    },
                    {
                        "username": "MeriemA",
                        "content": "[@alangreg](/alangreg) Thank you for you reply. Actually, the second loop won\\'t run over all of the table but only a part of it starting from a predefined index. So here I guess the time complexity is O(nlogn) not O(n\\xB2). right?"
                    },
                    {
                        "username": "alangreg",
                        "content": "The first thing I noticed is you are running with two loops."
                    },
                    {
                        "username": "Amarjeet2909",
                        "content": "Can Anyone tell why time limit exceeding here:\\n\\nclass Solution {\\npublic:\\n    int maxProfit(vector<int>& prices) {\\n        int profit =0;\\n        for(int i=0;i<prices.size()-1;i++){\\n            for(int j=i+1;j<prices.size();j++){\\n                if(prices[i]<prices[j]){\\n                int temp= prices[j]-prices[i];\\n                profit= max(profit, temp);\\n                }\\n            }   \\n        }\\n        return profit;\\n    }\\n};"
                    },
                    {
                        "username": "wodxuming",
                        "content": "```\\n\\nclass Solution {\\n    public int maxProfit(int[] prices) {\\n          int n = prices.length;\\n        // base case: dp[-1][0] = 0, dp[-1][1] = -infinity\\n        int dp_i_0 = 0, dp_i_1 = Integer.MIN_VALUE;\\n        for (int i = 0; i < n; i++) {\\n            // dp[i][0] = max(dp[i-1][0], dp[i-1][1] + prices[i])\\n            dp_i_0 = Math.max(dp_i_0, dp_i_1 + prices[i]);\\n            // dp[i][1] = max(dp[i-1][1], -prices[i])\\n            dp_i_1 = Math.max(dp_i_1, -prices[i]);\\n        }\\n        return dp_i_0; \\n    }\\n}\\n\\n```"
                    }
                ]
            },
            {
                "id": 1682811,
                "content": [
                    {
                        "username": "Kishore-Thalisetty",
                        "content": "\\nJAVA SOLUTION - (O(N)) time complexity\\nclass Solution {\\n    public int maxProfit(int[] prices) {\\n       int buy=prices[0];\\n        int sell=0;\\n        int max=0;\\n        for(int i=1; i<prices.length; i++){\\n            if(buy>prices[i]){\\n                buy=prices[i];\\n\\n            }else if(buy<prices[i] ){\\n                sell=prices[i]-buy;\\n                if(max<sell) max=sell;\\n            }\\n        }\\n           return max;\\n    }\\n}"
                    },
                    {
                        "username": "apeWithKeyBoard",
                        "content": "I have written basic O(n\\'squared) solution but the 203 testcase fails with Time Limit exceeded ouput. Any suggestions ?\\n"
                    },
                    {
                        "username": "Aman_26",
                        "content": "Whats wrong with this code?\\n    def maxProfit(self, prices: List[int]) -> int:\\n        n = len(prices)\\n        minimum_num = min(prices)\\n        index_min = prices.index(minimum_num)\\n        if index_min != n:\\n            prices = prices[index_min+1:]\\n            if len(prices) != 0:\\n                max_num = max(prices)\\n            else:\\n                max_num = 0\\n                if max_num > minimum_num:\\n                    return max_num - minimum_num\\n                else:\\n                    return 0\\n        return max_num - minimum_num\\n\\nit fails for the input [2,4,1], expected output is 2 my output is 0"
                    },
                    {
                        "username": "MuthuKrishnan007",
                        "content": "Hi,\\nCan anyone explain what is the requirements of the program clearly because in the first example input 715364 day 2 stock is buyed and sell in day 5 .\\nIn example 2 76431 in this example transaction is zero why can\\'t didn\\'t buy any stock.\\nAnyone please explain this."
                    },
                    {
                        "username": "arurahul16",
                        "content": "you need to read the problem , it says profit\\nBuy first day at 1 and Sell on second day 2\\nso you bought a stock for 1 GBP and selling it to 2 GBP\\nProfit ( 2-1=1 GBP)\\n\\nMAKE SURE  **MAXIMUM PROFIT***"
                    },
                    {
                        "username": "Amit_Joe",
                        "content": "only test case with having input 1,2 doesnt work the program is still to produce expected output in local machine. why??"
                    },
                    {
                        "username": "braads07",
                        "content": "[CAN SOMEONE PLS..HELP ME , WHERE M I WRONG?\\nCan we find the solution in this way?](CAN SOMEONE PLS..HELP ME , WHERE M I WRONG?\\nCan we find the solution in this way?)\\n\\n  `class Solution {\\npublic:\\n    int maxProfit(vector<int>& v) {\\n\\n        vector<int>v1=v;\\n        sort(v1.begin() , v1.end());\\n        int num=0;\\n        int n=v.size();\\n        int front=0;\\n        int end=v.size()-1;\\n        int maxx=INT_MIN;\\n        while(num!=n)\\n        {\\n            int i=search(v , 0 , n-1 ,  v1[front]);\\n            int j=search(v , 0 , n-1 ,  v1[end]);\\n            if(i<j)\\n            {\\n                maxx=max(maxx , (v1[end]-v1[front]));\\n                end=v.size()-1;\\n                front++;\\n                num++;\\n            }\\n            else if(front==end)\\n            {\\n                front++;\\n                end=v.size()-1;\\n                num++;\\n            }\\n            else\\n            {\\n                end--;\\n            }\\n        }\\n        if(maxx<=0)\\n        return 0;\\n        else \\n        return maxx;\\n\\n        \\n    }\\n    int search(vector<int>arr , int l , int r , int x)\\n    {\\n         if (r >= l) {\\n        int mid = l + (r - l) / 2;\\n\\n        if (arr[mid] == x)\\n            return mid;\\n \\n        // If element is smaller than mid, then\\n        // it can only be present in left subarray\\n        if (arr[mid] > x)\\n            return search(arr, l, mid - 1, x);\\n \\n        // Else the element can only be present\\n        // in right subarray\\n        return search(arr, mid + 1, r, x);\\n    }\\n    return -1;\\n    }\\n\\n\\n};`"
                    },
                    {
                        "username": "codernoob",
                        "content": "how are ppl doing the very large test array input? I am getting Time Limit Exceeded"
                    },
                    {
                        "username": "user3827xr",
                        "content": "In this problem, can we consider prices are positive numbers ? (remember, 2020 and negative prices of crude oil)"
                    },
                    {
                        "username": "arurahul16",
                        "content": "read problem properly ranges for prices[i] are mentioned from 0"
                    },
                    {
                        "username": "MeriemA",
                        "content": "Hello, \n\nI have tried to solve this problem using C. My solution works for almost all of the TCs. But the problem is that it shows time limit exceeded when the input is so large. So can anyone can help me to optimize my code?\nThanks a lot.\n\n `int maxProfit(int* prices, int pricesSize)\n{   \n    int buy_day = 0;\n    int sell_day = 0;\n    int max_profit = 0;\n    int profit = 0;\n\n    for (buy_day = 0; buy_day<pricesSize; buy_day++)\n    {\n        sell_day = buy_day + 1;\n        for(sell_day; sell_day<pricesSize; sell_day++)\n        {\n            profit = prices[sell_day] - prices[buy_day];\n            if (profit > max_profit)\n            {\n                max_profit = profit;\n            }\n        }\n    }\n\nreturn max_profit;\n}`\n\n"
                    },
                    {
                        "username": "alangreg",
                        "content": "[@MeriemA](/MeriemA) Probably. Thats why times out on large TC. I also striked out few times on time limit but then I changed approach to 1 loop (well 1 and a half as I used built in max() function) and it passed."
                    },
                    {
                        "username": "MeriemA",
                        "content": "[@alangreg](/alangreg) Thank you for you reply. Actually, the second loop won\\'t run over all of the table but only a part of it starting from a predefined index. So here I guess the time complexity is O(nlogn) not O(n\\xB2). right?"
                    },
                    {
                        "username": "alangreg",
                        "content": "The first thing I noticed is you are running with two loops."
                    },
                    {
                        "username": "Amarjeet2909",
                        "content": "Can Anyone tell why time limit exceeding here:\\n\\nclass Solution {\\npublic:\\n    int maxProfit(vector<int>& prices) {\\n        int profit =0;\\n        for(int i=0;i<prices.size()-1;i++){\\n            for(int j=i+1;j<prices.size();j++){\\n                if(prices[i]<prices[j]){\\n                int temp= prices[j]-prices[i];\\n                profit= max(profit, temp);\\n                }\\n            }   \\n        }\\n        return profit;\\n    }\\n};"
                    },
                    {
                        "username": "wodxuming",
                        "content": "```\\n\\nclass Solution {\\n    public int maxProfit(int[] prices) {\\n          int n = prices.length;\\n        // base case: dp[-1][0] = 0, dp[-1][1] = -infinity\\n        int dp_i_0 = 0, dp_i_1 = Integer.MIN_VALUE;\\n        for (int i = 0; i < n; i++) {\\n            // dp[i][0] = max(dp[i-1][0], dp[i-1][1] + prices[i])\\n            dp_i_0 = Math.max(dp_i_0, dp_i_1 + prices[i]);\\n            // dp[i][1] = max(dp[i-1][1], -prices[i])\\n            dp_i_1 = Math.max(dp_i_1, -prices[i]);\\n        }\\n        return dp_i_0; \\n    }\\n}\\n\\n```"
                    }
                ]
            },
            {
                "id": 1676663,
                "content": [
                    {
                        "username": "Kishore-Thalisetty",
                        "content": "\\nJAVA SOLUTION - (O(N)) time complexity\\nclass Solution {\\n    public int maxProfit(int[] prices) {\\n       int buy=prices[0];\\n        int sell=0;\\n        int max=0;\\n        for(int i=1; i<prices.length; i++){\\n            if(buy>prices[i]){\\n                buy=prices[i];\\n\\n            }else if(buy<prices[i] ){\\n                sell=prices[i]-buy;\\n                if(max<sell) max=sell;\\n            }\\n        }\\n           return max;\\n    }\\n}"
                    },
                    {
                        "username": "apeWithKeyBoard",
                        "content": "I have written basic O(n\\'squared) solution but the 203 testcase fails with Time Limit exceeded ouput. Any suggestions ?\\n"
                    },
                    {
                        "username": "Aman_26",
                        "content": "Whats wrong with this code?\\n    def maxProfit(self, prices: List[int]) -> int:\\n        n = len(prices)\\n        minimum_num = min(prices)\\n        index_min = prices.index(minimum_num)\\n        if index_min != n:\\n            prices = prices[index_min+1:]\\n            if len(prices) != 0:\\n                max_num = max(prices)\\n            else:\\n                max_num = 0\\n                if max_num > minimum_num:\\n                    return max_num - minimum_num\\n                else:\\n                    return 0\\n        return max_num - minimum_num\\n\\nit fails for the input [2,4,1], expected output is 2 my output is 0"
                    },
                    {
                        "username": "MuthuKrishnan007",
                        "content": "Hi,\\nCan anyone explain what is the requirements of the program clearly because in the first example input 715364 day 2 stock is buyed and sell in day 5 .\\nIn example 2 76431 in this example transaction is zero why can\\'t didn\\'t buy any stock.\\nAnyone please explain this."
                    },
                    {
                        "username": "arurahul16",
                        "content": "you need to read the problem , it says profit\\nBuy first day at 1 and Sell on second day 2\\nso you bought a stock for 1 GBP and selling it to 2 GBP\\nProfit ( 2-1=1 GBP)\\n\\nMAKE SURE  **MAXIMUM PROFIT***"
                    },
                    {
                        "username": "Amit_Joe",
                        "content": "only test case with having input 1,2 doesnt work the program is still to produce expected output in local machine. why??"
                    },
                    {
                        "username": "braads07",
                        "content": "[CAN SOMEONE PLS..HELP ME , WHERE M I WRONG?\\nCan we find the solution in this way?](CAN SOMEONE PLS..HELP ME , WHERE M I WRONG?\\nCan we find the solution in this way?)\\n\\n  `class Solution {\\npublic:\\n    int maxProfit(vector<int>& v) {\\n\\n        vector<int>v1=v;\\n        sort(v1.begin() , v1.end());\\n        int num=0;\\n        int n=v.size();\\n        int front=0;\\n        int end=v.size()-1;\\n        int maxx=INT_MIN;\\n        while(num!=n)\\n        {\\n            int i=search(v , 0 , n-1 ,  v1[front]);\\n            int j=search(v , 0 , n-1 ,  v1[end]);\\n            if(i<j)\\n            {\\n                maxx=max(maxx , (v1[end]-v1[front]));\\n                end=v.size()-1;\\n                front++;\\n                num++;\\n            }\\n            else if(front==end)\\n            {\\n                front++;\\n                end=v.size()-1;\\n                num++;\\n            }\\n            else\\n            {\\n                end--;\\n            }\\n        }\\n        if(maxx<=0)\\n        return 0;\\n        else \\n        return maxx;\\n\\n        \\n    }\\n    int search(vector<int>arr , int l , int r , int x)\\n    {\\n         if (r >= l) {\\n        int mid = l + (r - l) / 2;\\n\\n        if (arr[mid] == x)\\n            return mid;\\n \\n        // If element is smaller than mid, then\\n        // it can only be present in left subarray\\n        if (arr[mid] > x)\\n            return search(arr, l, mid - 1, x);\\n \\n        // Else the element can only be present\\n        // in right subarray\\n        return search(arr, mid + 1, r, x);\\n    }\\n    return -1;\\n    }\\n\\n\\n};`"
                    },
                    {
                        "username": "codernoob",
                        "content": "how are ppl doing the very large test array input? I am getting Time Limit Exceeded"
                    },
                    {
                        "username": "user3827xr",
                        "content": "In this problem, can we consider prices are positive numbers ? (remember, 2020 and negative prices of crude oil)"
                    },
                    {
                        "username": "arurahul16",
                        "content": "read problem properly ranges for prices[i] are mentioned from 0"
                    },
                    {
                        "username": "MeriemA",
                        "content": "Hello, \n\nI have tried to solve this problem using C. My solution works for almost all of the TCs. But the problem is that it shows time limit exceeded when the input is so large. So can anyone can help me to optimize my code?\nThanks a lot.\n\n `int maxProfit(int* prices, int pricesSize)\n{   \n    int buy_day = 0;\n    int sell_day = 0;\n    int max_profit = 0;\n    int profit = 0;\n\n    for (buy_day = 0; buy_day<pricesSize; buy_day++)\n    {\n        sell_day = buy_day + 1;\n        for(sell_day; sell_day<pricesSize; sell_day++)\n        {\n            profit = prices[sell_day] - prices[buy_day];\n            if (profit > max_profit)\n            {\n                max_profit = profit;\n            }\n        }\n    }\n\nreturn max_profit;\n}`\n\n"
                    },
                    {
                        "username": "alangreg",
                        "content": "[@MeriemA](/MeriemA) Probably. Thats why times out on large TC. I also striked out few times on time limit but then I changed approach to 1 loop (well 1 and a half as I used built in max() function) and it passed."
                    },
                    {
                        "username": "MeriemA",
                        "content": "[@alangreg](/alangreg) Thank you for you reply. Actually, the second loop won\\'t run over all of the table but only a part of it starting from a predefined index. So here I guess the time complexity is O(nlogn) not O(n\\xB2). right?"
                    },
                    {
                        "username": "alangreg",
                        "content": "The first thing I noticed is you are running with two loops."
                    },
                    {
                        "username": "Amarjeet2909",
                        "content": "Can Anyone tell why time limit exceeding here:\\n\\nclass Solution {\\npublic:\\n    int maxProfit(vector<int>& prices) {\\n        int profit =0;\\n        for(int i=0;i<prices.size()-1;i++){\\n            for(int j=i+1;j<prices.size();j++){\\n                if(prices[i]<prices[j]){\\n                int temp= prices[j]-prices[i];\\n                profit= max(profit, temp);\\n                }\\n            }   \\n        }\\n        return profit;\\n    }\\n};"
                    },
                    {
                        "username": "wodxuming",
                        "content": "```\\n\\nclass Solution {\\n    public int maxProfit(int[] prices) {\\n          int n = prices.length;\\n        // base case: dp[-1][0] = 0, dp[-1][1] = -infinity\\n        int dp_i_0 = 0, dp_i_1 = Integer.MIN_VALUE;\\n        for (int i = 0; i < n; i++) {\\n            // dp[i][0] = max(dp[i-1][0], dp[i-1][1] + prices[i])\\n            dp_i_0 = Math.max(dp_i_0, dp_i_1 + prices[i]);\\n            // dp[i][1] = max(dp[i-1][1], -prices[i])\\n            dp_i_1 = Math.max(dp_i_1, -prices[i]);\\n        }\\n        return dp_i_0; \\n    }\\n}\\n\\n```"
                    }
                ]
            },
            {
                "id": 1672220,
                "content": [
                    {
                        "username": "Kishore-Thalisetty",
                        "content": "\\nJAVA SOLUTION - (O(N)) time complexity\\nclass Solution {\\n    public int maxProfit(int[] prices) {\\n       int buy=prices[0];\\n        int sell=0;\\n        int max=0;\\n        for(int i=1; i<prices.length; i++){\\n            if(buy>prices[i]){\\n                buy=prices[i];\\n\\n            }else if(buy<prices[i] ){\\n                sell=prices[i]-buy;\\n                if(max<sell) max=sell;\\n            }\\n        }\\n           return max;\\n    }\\n}"
                    },
                    {
                        "username": "apeWithKeyBoard",
                        "content": "I have written basic O(n\\'squared) solution but the 203 testcase fails with Time Limit exceeded ouput. Any suggestions ?\\n"
                    },
                    {
                        "username": "Aman_26",
                        "content": "Whats wrong with this code?\\n    def maxProfit(self, prices: List[int]) -> int:\\n        n = len(prices)\\n        minimum_num = min(prices)\\n        index_min = prices.index(minimum_num)\\n        if index_min != n:\\n            prices = prices[index_min+1:]\\n            if len(prices) != 0:\\n                max_num = max(prices)\\n            else:\\n                max_num = 0\\n                if max_num > minimum_num:\\n                    return max_num - minimum_num\\n                else:\\n                    return 0\\n        return max_num - minimum_num\\n\\nit fails for the input [2,4,1], expected output is 2 my output is 0"
                    },
                    {
                        "username": "MuthuKrishnan007",
                        "content": "Hi,\\nCan anyone explain what is the requirements of the program clearly because in the first example input 715364 day 2 stock is buyed and sell in day 5 .\\nIn example 2 76431 in this example transaction is zero why can\\'t didn\\'t buy any stock.\\nAnyone please explain this."
                    },
                    {
                        "username": "arurahul16",
                        "content": "you need to read the problem , it says profit\\nBuy first day at 1 and Sell on second day 2\\nso you bought a stock for 1 GBP and selling it to 2 GBP\\nProfit ( 2-1=1 GBP)\\n\\nMAKE SURE  **MAXIMUM PROFIT***"
                    },
                    {
                        "username": "Amit_Joe",
                        "content": "only test case with having input 1,2 doesnt work the program is still to produce expected output in local machine. why??"
                    },
                    {
                        "username": "braads07",
                        "content": "[CAN SOMEONE PLS..HELP ME , WHERE M I WRONG?\\nCan we find the solution in this way?](CAN SOMEONE PLS..HELP ME , WHERE M I WRONG?\\nCan we find the solution in this way?)\\n\\n  `class Solution {\\npublic:\\n    int maxProfit(vector<int>& v) {\\n\\n        vector<int>v1=v;\\n        sort(v1.begin() , v1.end());\\n        int num=0;\\n        int n=v.size();\\n        int front=0;\\n        int end=v.size()-1;\\n        int maxx=INT_MIN;\\n        while(num!=n)\\n        {\\n            int i=search(v , 0 , n-1 ,  v1[front]);\\n            int j=search(v , 0 , n-1 ,  v1[end]);\\n            if(i<j)\\n            {\\n                maxx=max(maxx , (v1[end]-v1[front]));\\n                end=v.size()-1;\\n                front++;\\n                num++;\\n            }\\n            else if(front==end)\\n            {\\n                front++;\\n                end=v.size()-1;\\n                num++;\\n            }\\n            else\\n            {\\n                end--;\\n            }\\n        }\\n        if(maxx<=0)\\n        return 0;\\n        else \\n        return maxx;\\n\\n        \\n    }\\n    int search(vector<int>arr , int l , int r , int x)\\n    {\\n         if (r >= l) {\\n        int mid = l + (r - l) / 2;\\n\\n        if (arr[mid] == x)\\n            return mid;\\n \\n        // If element is smaller than mid, then\\n        // it can only be present in left subarray\\n        if (arr[mid] > x)\\n            return search(arr, l, mid - 1, x);\\n \\n        // Else the element can only be present\\n        // in right subarray\\n        return search(arr, mid + 1, r, x);\\n    }\\n    return -1;\\n    }\\n\\n\\n};`"
                    },
                    {
                        "username": "codernoob",
                        "content": "how are ppl doing the very large test array input? I am getting Time Limit Exceeded"
                    },
                    {
                        "username": "user3827xr",
                        "content": "In this problem, can we consider prices are positive numbers ? (remember, 2020 and negative prices of crude oil)"
                    },
                    {
                        "username": "arurahul16",
                        "content": "read problem properly ranges for prices[i] are mentioned from 0"
                    },
                    {
                        "username": "MeriemA",
                        "content": "Hello, \n\nI have tried to solve this problem using C. My solution works for almost all of the TCs. But the problem is that it shows time limit exceeded when the input is so large. So can anyone can help me to optimize my code?\nThanks a lot.\n\n `int maxProfit(int* prices, int pricesSize)\n{   \n    int buy_day = 0;\n    int sell_day = 0;\n    int max_profit = 0;\n    int profit = 0;\n\n    for (buy_day = 0; buy_day<pricesSize; buy_day++)\n    {\n        sell_day = buy_day + 1;\n        for(sell_day; sell_day<pricesSize; sell_day++)\n        {\n            profit = prices[sell_day] - prices[buy_day];\n            if (profit > max_profit)\n            {\n                max_profit = profit;\n            }\n        }\n    }\n\nreturn max_profit;\n}`\n\n"
                    },
                    {
                        "username": "alangreg",
                        "content": "[@MeriemA](/MeriemA) Probably. Thats why times out on large TC. I also striked out few times on time limit but then I changed approach to 1 loop (well 1 and a half as I used built in max() function) and it passed."
                    },
                    {
                        "username": "MeriemA",
                        "content": "[@alangreg](/alangreg) Thank you for you reply. Actually, the second loop won\\'t run over all of the table but only a part of it starting from a predefined index. So here I guess the time complexity is O(nlogn) not O(n\\xB2). right?"
                    },
                    {
                        "username": "alangreg",
                        "content": "The first thing I noticed is you are running with two loops."
                    },
                    {
                        "username": "Amarjeet2909",
                        "content": "Can Anyone tell why time limit exceeding here:\\n\\nclass Solution {\\npublic:\\n    int maxProfit(vector<int>& prices) {\\n        int profit =0;\\n        for(int i=0;i<prices.size()-1;i++){\\n            for(int j=i+1;j<prices.size();j++){\\n                if(prices[i]<prices[j]){\\n                int temp= prices[j]-prices[i];\\n                profit= max(profit, temp);\\n                }\\n            }   \\n        }\\n        return profit;\\n    }\\n};"
                    },
                    {
                        "username": "wodxuming",
                        "content": "```\\n\\nclass Solution {\\n    public int maxProfit(int[] prices) {\\n          int n = prices.length;\\n        // base case: dp[-1][0] = 0, dp[-1][1] = -infinity\\n        int dp_i_0 = 0, dp_i_1 = Integer.MIN_VALUE;\\n        for (int i = 0; i < n; i++) {\\n            // dp[i][0] = max(dp[i-1][0], dp[i-1][1] + prices[i])\\n            dp_i_0 = Math.max(dp_i_0, dp_i_1 + prices[i]);\\n            // dp[i][1] = max(dp[i-1][1], -prices[i])\\n            dp_i_1 = Math.max(dp_i_1, -prices[i]);\\n        }\\n        return dp_i_0; \\n    }\\n}\\n\\n```"
                    }
                ]
            },
            {
                "id": 1669249,
                "content": [
                    {
                        "username": "Kishore-Thalisetty",
                        "content": "\\nJAVA SOLUTION - (O(N)) time complexity\\nclass Solution {\\n    public int maxProfit(int[] prices) {\\n       int buy=prices[0];\\n        int sell=0;\\n        int max=0;\\n        for(int i=1; i<prices.length; i++){\\n            if(buy>prices[i]){\\n                buy=prices[i];\\n\\n            }else if(buy<prices[i] ){\\n                sell=prices[i]-buy;\\n                if(max<sell) max=sell;\\n            }\\n        }\\n           return max;\\n    }\\n}"
                    },
                    {
                        "username": "apeWithKeyBoard",
                        "content": "I have written basic O(n\\'squared) solution but the 203 testcase fails with Time Limit exceeded ouput. Any suggestions ?\\n"
                    },
                    {
                        "username": "Aman_26",
                        "content": "Whats wrong with this code?\\n    def maxProfit(self, prices: List[int]) -> int:\\n        n = len(prices)\\n        minimum_num = min(prices)\\n        index_min = prices.index(minimum_num)\\n        if index_min != n:\\n            prices = prices[index_min+1:]\\n            if len(prices) != 0:\\n                max_num = max(prices)\\n            else:\\n                max_num = 0\\n                if max_num > minimum_num:\\n                    return max_num - minimum_num\\n                else:\\n                    return 0\\n        return max_num - minimum_num\\n\\nit fails for the input [2,4,1], expected output is 2 my output is 0"
                    },
                    {
                        "username": "MuthuKrishnan007",
                        "content": "Hi,\\nCan anyone explain what is the requirements of the program clearly because in the first example input 715364 day 2 stock is buyed and sell in day 5 .\\nIn example 2 76431 in this example transaction is zero why can\\'t didn\\'t buy any stock.\\nAnyone please explain this."
                    },
                    {
                        "username": "arurahul16",
                        "content": "you need to read the problem , it says profit\\nBuy first day at 1 and Sell on second day 2\\nso you bought a stock for 1 GBP and selling it to 2 GBP\\nProfit ( 2-1=1 GBP)\\n\\nMAKE SURE  **MAXIMUM PROFIT***"
                    },
                    {
                        "username": "Amit_Joe",
                        "content": "only test case with having input 1,2 doesnt work the program is still to produce expected output in local machine. why??"
                    },
                    {
                        "username": "braads07",
                        "content": "[CAN SOMEONE PLS..HELP ME , WHERE M I WRONG?\\nCan we find the solution in this way?](CAN SOMEONE PLS..HELP ME , WHERE M I WRONG?\\nCan we find the solution in this way?)\\n\\n  `class Solution {\\npublic:\\n    int maxProfit(vector<int>& v) {\\n\\n        vector<int>v1=v;\\n        sort(v1.begin() , v1.end());\\n        int num=0;\\n        int n=v.size();\\n        int front=0;\\n        int end=v.size()-1;\\n        int maxx=INT_MIN;\\n        while(num!=n)\\n        {\\n            int i=search(v , 0 , n-1 ,  v1[front]);\\n            int j=search(v , 0 , n-1 ,  v1[end]);\\n            if(i<j)\\n            {\\n                maxx=max(maxx , (v1[end]-v1[front]));\\n                end=v.size()-1;\\n                front++;\\n                num++;\\n            }\\n            else if(front==end)\\n            {\\n                front++;\\n                end=v.size()-1;\\n                num++;\\n            }\\n            else\\n            {\\n                end--;\\n            }\\n        }\\n        if(maxx<=0)\\n        return 0;\\n        else \\n        return maxx;\\n\\n        \\n    }\\n    int search(vector<int>arr , int l , int r , int x)\\n    {\\n         if (r >= l) {\\n        int mid = l + (r - l) / 2;\\n\\n        if (arr[mid] == x)\\n            return mid;\\n \\n        // If element is smaller than mid, then\\n        // it can only be present in left subarray\\n        if (arr[mid] > x)\\n            return search(arr, l, mid - 1, x);\\n \\n        // Else the element can only be present\\n        // in right subarray\\n        return search(arr, mid + 1, r, x);\\n    }\\n    return -1;\\n    }\\n\\n\\n};`"
                    },
                    {
                        "username": "codernoob",
                        "content": "how are ppl doing the very large test array input? I am getting Time Limit Exceeded"
                    },
                    {
                        "username": "user3827xr",
                        "content": "In this problem, can we consider prices are positive numbers ? (remember, 2020 and negative prices of crude oil)"
                    },
                    {
                        "username": "arurahul16",
                        "content": "read problem properly ranges for prices[i] are mentioned from 0"
                    },
                    {
                        "username": "MeriemA",
                        "content": "Hello, \n\nI have tried to solve this problem using C. My solution works for almost all of the TCs. But the problem is that it shows time limit exceeded when the input is so large. So can anyone can help me to optimize my code?\nThanks a lot.\n\n `int maxProfit(int* prices, int pricesSize)\n{   \n    int buy_day = 0;\n    int sell_day = 0;\n    int max_profit = 0;\n    int profit = 0;\n\n    for (buy_day = 0; buy_day<pricesSize; buy_day++)\n    {\n        sell_day = buy_day + 1;\n        for(sell_day; sell_day<pricesSize; sell_day++)\n        {\n            profit = prices[sell_day] - prices[buy_day];\n            if (profit > max_profit)\n            {\n                max_profit = profit;\n            }\n        }\n    }\n\nreturn max_profit;\n}`\n\n"
                    },
                    {
                        "username": "alangreg",
                        "content": "[@MeriemA](/MeriemA) Probably. Thats why times out on large TC. I also striked out few times on time limit but then I changed approach to 1 loop (well 1 and a half as I used built in max() function) and it passed."
                    },
                    {
                        "username": "MeriemA",
                        "content": "[@alangreg](/alangreg) Thank you for you reply. Actually, the second loop won\\'t run over all of the table but only a part of it starting from a predefined index. So here I guess the time complexity is O(nlogn) not O(n\\xB2). right?"
                    },
                    {
                        "username": "alangreg",
                        "content": "The first thing I noticed is you are running with two loops."
                    },
                    {
                        "username": "Amarjeet2909",
                        "content": "Can Anyone tell why time limit exceeding here:\\n\\nclass Solution {\\npublic:\\n    int maxProfit(vector<int>& prices) {\\n        int profit =0;\\n        for(int i=0;i<prices.size()-1;i++){\\n            for(int j=i+1;j<prices.size();j++){\\n                if(prices[i]<prices[j]){\\n                int temp= prices[j]-prices[i];\\n                profit= max(profit, temp);\\n                }\\n            }   \\n        }\\n        return profit;\\n    }\\n};"
                    },
                    {
                        "username": "wodxuming",
                        "content": "```\\n\\nclass Solution {\\n    public int maxProfit(int[] prices) {\\n          int n = prices.length;\\n        // base case: dp[-1][0] = 0, dp[-1][1] = -infinity\\n        int dp_i_0 = 0, dp_i_1 = Integer.MIN_VALUE;\\n        for (int i = 0; i < n; i++) {\\n            // dp[i][0] = max(dp[i-1][0], dp[i-1][1] + prices[i])\\n            dp_i_0 = Math.max(dp_i_0, dp_i_1 + prices[i]);\\n            // dp[i][1] = max(dp[i-1][1], -prices[i])\\n            dp_i_1 = Math.max(dp_i_1, -prices[i]);\\n        }\\n        return dp_i_0; \\n    }\\n}\\n\\n```"
                    }
                ]
            },
            {
                "id": 1656293,
                "content": [
                    {
                        "username": "Kishore-Thalisetty",
                        "content": "\\nJAVA SOLUTION - (O(N)) time complexity\\nclass Solution {\\n    public int maxProfit(int[] prices) {\\n       int buy=prices[0];\\n        int sell=0;\\n        int max=0;\\n        for(int i=1; i<prices.length; i++){\\n            if(buy>prices[i]){\\n                buy=prices[i];\\n\\n            }else if(buy<prices[i] ){\\n                sell=prices[i]-buy;\\n                if(max<sell) max=sell;\\n            }\\n        }\\n           return max;\\n    }\\n}"
                    },
                    {
                        "username": "apeWithKeyBoard",
                        "content": "I have written basic O(n\\'squared) solution but the 203 testcase fails with Time Limit exceeded ouput. Any suggestions ?\\n"
                    },
                    {
                        "username": "Aman_26",
                        "content": "Whats wrong with this code?\\n    def maxProfit(self, prices: List[int]) -> int:\\n        n = len(prices)\\n        minimum_num = min(prices)\\n        index_min = prices.index(minimum_num)\\n        if index_min != n:\\n            prices = prices[index_min+1:]\\n            if len(prices) != 0:\\n                max_num = max(prices)\\n            else:\\n                max_num = 0\\n                if max_num > minimum_num:\\n                    return max_num - minimum_num\\n                else:\\n                    return 0\\n        return max_num - minimum_num\\n\\nit fails for the input [2,4,1], expected output is 2 my output is 0"
                    },
                    {
                        "username": "MuthuKrishnan007",
                        "content": "Hi,\\nCan anyone explain what is the requirements of the program clearly because in the first example input 715364 day 2 stock is buyed and sell in day 5 .\\nIn example 2 76431 in this example transaction is zero why can\\'t didn\\'t buy any stock.\\nAnyone please explain this."
                    },
                    {
                        "username": "arurahul16",
                        "content": "you need to read the problem , it says profit\\nBuy first day at 1 and Sell on second day 2\\nso you bought a stock for 1 GBP and selling it to 2 GBP\\nProfit ( 2-1=1 GBP)\\n\\nMAKE SURE  **MAXIMUM PROFIT***"
                    },
                    {
                        "username": "Amit_Joe",
                        "content": "only test case with having input 1,2 doesnt work the program is still to produce expected output in local machine. why??"
                    },
                    {
                        "username": "braads07",
                        "content": "[CAN SOMEONE PLS..HELP ME , WHERE M I WRONG?\\nCan we find the solution in this way?](CAN SOMEONE PLS..HELP ME , WHERE M I WRONG?\\nCan we find the solution in this way?)\\n\\n  `class Solution {\\npublic:\\n    int maxProfit(vector<int>& v) {\\n\\n        vector<int>v1=v;\\n        sort(v1.begin() , v1.end());\\n        int num=0;\\n        int n=v.size();\\n        int front=0;\\n        int end=v.size()-1;\\n        int maxx=INT_MIN;\\n        while(num!=n)\\n        {\\n            int i=search(v , 0 , n-1 ,  v1[front]);\\n            int j=search(v , 0 , n-1 ,  v1[end]);\\n            if(i<j)\\n            {\\n                maxx=max(maxx , (v1[end]-v1[front]));\\n                end=v.size()-1;\\n                front++;\\n                num++;\\n            }\\n            else if(front==end)\\n            {\\n                front++;\\n                end=v.size()-1;\\n                num++;\\n            }\\n            else\\n            {\\n                end--;\\n            }\\n        }\\n        if(maxx<=0)\\n        return 0;\\n        else \\n        return maxx;\\n\\n        \\n    }\\n    int search(vector<int>arr , int l , int r , int x)\\n    {\\n         if (r >= l) {\\n        int mid = l + (r - l) / 2;\\n\\n        if (arr[mid] == x)\\n            return mid;\\n \\n        // If element is smaller than mid, then\\n        // it can only be present in left subarray\\n        if (arr[mid] > x)\\n            return search(arr, l, mid - 1, x);\\n \\n        // Else the element can only be present\\n        // in right subarray\\n        return search(arr, mid + 1, r, x);\\n    }\\n    return -1;\\n    }\\n\\n\\n};`"
                    },
                    {
                        "username": "codernoob",
                        "content": "how are ppl doing the very large test array input? I am getting Time Limit Exceeded"
                    },
                    {
                        "username": "user3827xr",
                        "content": "In this problem, can we consider prices are positive numbers ? (remember, 2020 and negative prices of crude oil)"
                    },
                    {
                        "username": "arurahul16",
                        "content": "read problem properly ranges for prices[i] are mentioned from 0"
                    },
                    {
                        "username": "MeriemA",
                        "content": "Hello, \n\nI have tried to solve this problem using C. My solution works for almost all of the TCs. But the problem is that it shows time limit exceeded when the input is so large. So can anyone can help me to optimize my code?\nThanks a lot.\n\n `int maxProfit(int* prices, int pricesSize)\n{   \n    int buy_day = 0;\n    int sell_day = 0;\n    int max_profit = 0;\n    int profit = 0;\n\n    for (buy_day = 0; buy_day<pricesSize; buy_day++)\n    {\n        sell_day = buy_day + 1;\n        for(sell_day; sell_day<pricesSize; sell_day++)\n        {\n            profit = prices[sell_day] - prices[buy_day];\n            if (profit > max_profit)\n            {\n                max_profit = profit;\n            }\n        }\n    }\n\nreturn max_profit;\n}`\n\n"
                    },
                    {
                        "username": "alangreg",
                        "content": "[@MeriemA](/MeriemA) Probably. Thats why times out on large TC. I also striked out few times on time limit but then I changed approach to 1 loop (well 1 and a half as I used built in max() function) and it passed."
                    },
                    {
                        "username": "MeriemA",
                        "content": "[@alangreg](/alangreg) Thank you for you reply. Actually, the second loop won\\'t run over all of the table but only a part of it starting from a predefined index. So here I guess the time complexity is O(nlogn) not O(n\\xB2). right?"
                    },
                    {
                        "username": "alangreg",
                        "content": "The first thing I noticed is you are running with two loops."
                    },
                    {
                        "username": "Amarjeet2909",
                        "content": "Can Anyone tell why time limit exceeding here:\\n\\nclass Solution {\\npublic:\\n    int maxProfit(vector<int>& prices) {\\n        int profit =0;\\n        for(int i=0;i<prices.size()-1;i++){\\n            for(int j=i+1;j<prices.size();j++){\\n                if(prices[i]<prices[j]){\\n                int temp= prices[j]-prices[i];\\n                profit= max(profit, temp);\\n                }\\n            }   \\n        }\\n        return profit;\\n    }\\n};"
                    },
                    {
                        "username": "wodxuming",
                        "content": "```\\n\\nclass Solution {\\n    public int maxProfit(int[] prices) {\\n          int n = prices.length;\\n        // base case: dp[-1][0] = 0, dp[-1][1] = -infinity\\n        int dp_i_0 = 0, dp_i_1 = Integer.MIN_VALUE;\\n        for (int i = 0; i < n; i++) {\\n            // dp[i][0] = max(dp[i-1][0], dp[i-1][1] + prices[i])\\n            dp_i_0 = Math.max(dp_i_0, dp_i_1 + prices[i]);\\n            // dp[i][1] = max(dp[i-1][1], -prices[i])\\n            dp_i_1 = Math.max(dp_i_1, -prices[i]);\\n        }\\n        return dp_i_0; \\n    }\\n}\\n\\n```"
                    }
                ]
            },
            {
                "id": 1651214,
                "content": [
                    {
                        "username": "Kishore-Thalisetty",
                        "content": "\\nJAVA SOLUTION - (O(N)) time complexity\\nclass Solution {\\n    public int maxProfit(int[] prices) {\\n       int buy=prices[0];\\n        int sell=0;\\n        int max=0;\\n        for(int i=1; i<prices.length; i++){\\n            if(buy>prices[i]){\\n                buy=prices[i];\\n\\n            }else if(buy<prices[i] ){\\n                sell=prices[i]-buy;\\n                if(max<sell) max=sell;\\n            }\\n        }\\n           return max;\\n    }\\n}"
                    },
                    {
                        "username": "apeWithKeyBoard",
                        "content": "I have written basic O(n\\'squared) solution but the 203 testcase fails with Time Limit exceeded ouput. Any suggestions ?\\n"
                    },
                    {
                        "username": "Aman_26",
                        "content": "Whats wrong with this code?\\n    def maxProfit(self, prices: List[int]) -> int:\\n        n = len(prices)\\n        minimum_num = min(prices)\\n        index_min = prices.index(minimum_num)\\n        if index_min != n:\\n            prices = prices[index_min+1:]\\n            if len(prices) != 0:\\n                max_num = max(prices)\\n            else:\\n                max_num = 0\\n                if max_num > minimum_num:\\n                    return max_num - minimum_num\\n                else:\\n                    return 0\\n        return max_num - minimum_num\\n\\nit fails for the input [2,4,1], expected output is 2 my output is 0"
                    },
                    {
                        "username": "MuthuKrishnan007",
                        "content": "Hi,\\nCan anyone explain what is the requirements of the program clearly because in the first example input 715364 day 2 stock is buyed and sell in day 5 .\\nIn example 2 76431 in this example transaction is zero why can\\'t didn\\'t buy any stock.\\nAnyone please explain this."
                    },
                    {
                        "username": "arurahul16",
                        "content": "you need to read the problem , it says profit\\nBuy first day at 1 and Sell on second day 2\\nso you bought a stock for 1 GBP and selling it to 2 GBP\\nProfit ( 2-1=1 GBP)\\n\\nMAKE SURE  **MAXIMUM PROFIT***"
                    },
                    {
                        "username": "Amit_Joe",
                        "content": "only test case with having input 1,2 doesnt work the program is still to produce expected output in local machine. why??"
                    },
                    {
                        "username": "braads07",
                        "content": "[CAN SOMEONE PLS..HELP ME , WHERE M I WRONG?\\nCan we find the solution in this way?](CAN SOMEONE PLS..HELP ME , WHERE M I WRONG?\\nCan we find the solution in this way?)\\n\\n  `class Solution {\\npublic:\\n    int maxProfit(vector<int>& v) {\\n\\n        vector<int>v1=v;\\n        sort(v1.begin() , v1.end());\\n        int num=0;\\n        int n=v.size();\\n        int front=0;\\n        int end=v.size()-1;\\n        int maxx=INT_MIN;\\n        while(num!=n)\\n        {\\n            int i=search(v , 0 , n-1 ,  v1[front]);\\n            int j=search(v , 0 , n-1 ,  v1[end]);\\n            if(i<j)\\n            {\\n                maxx=max(maxx , (v1[end]-v1[front]));\\n                end=v.size()-1;\\n                front++;\\n                num++;\\n            }\\n            else if(front==end)\\n            {\\n                front++;\\n                end=v.size()-1;\\n                num++;\\n            }\\n            else\\n            {\\n                end--;\\n            }\\n        }\\n        if(maxx<=0)\\n        return 0;\\n        else \\n        return maxx;\\n\\n        \\n    }\\n    int search(vector<int>arr , int l , int r , int x)\\n    {\\n         if (r >= l) {\\n        int mid = l + (r - l) / 2;\\n\\n        if (arr[mid] == x)\\n            return mid;\\n \\n        // If element is smaller than mid, then\\n        // it can only be present in left subarray\\n        if (arr[mid] > x)\\n            return search(arr, l, mid - 1, x);\\n \\n        // Else the element can only be present\\n        // in right subarray\\n        return search(arr, mid + 1, r, x);\\n    }\\n    return -1;\\n    }\\n\\n\\n};`"
                    },
                    {
                        "username": "codernoob",
                        "content": "how are ppl doing the very large test array input? I am getting Time Limit Exceeded"
                    },
                    {
                        "username": "user3827xr",
                        "content": "In this problem, can we consider prices are positive numbers ? (remember, 2020 and negative prices of crude oil)"
                    },
                    {
                        "username": "arurahul16",
                        "content": "read problem properly ranges for prices[i] are mentioned from 0"
                    },
                    {
                        "username": "MeriemA",
                        "content": "Hello, \n\nI have tried to solve this problem using C. My solution works for almost all of the TCs. But the problem is that it shows time limit exceeded when the input is so large. So can anyone can help me to optimize my code?\nThanks a lot.\n\n `int maxProfit(int* prices, int pricesSize)\n{   \n    int buy_day = 0;\n    int sell_day = 0;\n    int max_profit = 0;\n    int profit = 0;\n\n    for (buy_day = 0; buy_day<pricesSize; buy_day++)\n    {\n        sell_day = buy_day + 1;\n        for(sell_day; sell_day<pricesSize; sell_day++)\n        {\n            profit = prices[sell_day] - prices[buy_day];\n            if (profit > max_profit)\n            {\n                max_profit = profit;\n            }\n        }\n    }\n\nreturn max_profit;\n}`\n\n"
                    },
                    {
                        "username": "alangreg",
                        "content": "[@MeriemA](/MeriemA) Probably. Thats why times out on large TC. I also striked out few times on time limit but then I changed approach to 1 loop (well 1 and a half as I used built in max() function) and it passed."
                    },
                    {
                        "username": "MeriemA",
                        "content": "[@alangreg](/alangreg) Thank you for you reply. Actually, the second loop won\\'t run over all of the table but only a part of it starting from a predefined index. So here I guess the time complexity is O(nlogn) not O(n\\xB2). right?"
                    },
                    {
                        "username": "alangreg",
                        "content": "The first thing I noticed is you are running with two loops."
                    },
                    {
                        "username": "Amarjeet2909",
                        "content": "Can Anyone tell why time limit exceeding here:\\n\\nclass Solution {\\npublic:\\n    int maxProfit(vector<int>& prices) {\\n        int profit =0;\\n        for(int i=0;i<prices.size()-1;i++){\\n            for(int j=i+1;j<prices.size();j++){\\n                if(prices[i]<prices[j]){\\n                int temp= prices[j]-prices[i];\\n                profit= max(profit, temp);\\n                }\\n            }   \\n        }\\n        return profit;\\n    }\\n};"
                    },
                    {
                        "username": "wodxuming",
                        "content": "```\\n\\nclass Solution {\\n    public int maxProfit(int[] prices) {\\n          int n = prices.length;\\n        // base case: dp[-1][0] = 0, dp[-1][1] = -infinity\\n        int dp_i_0 = 0, dp_i_1 = Integer.MIN_VALUE;\\n        for (int i = 0; i < n; i++) {\\n            // dp[i][0] = max(dp[i-1][0], dp[i-1][1] + prices[i])\\n            dp_i_0 = Math.max(dp_i_0, dp_i_1 + prices[i]);\\n            // dp[i][1] = max(dp[i-1][1], -prices[i])\\n            dp_i_1 = Math.max(dp_i_1, -prices[i]);\\n        }\\n        return dp_i_0; \\n    }\\n}\\n\\n```"
                    }
                ]
            },
            {
                "id": 1637206,
                "content": [
                    {
                        "username": "Kishore-Thalisetty",
                        "content": "\\nJAVA SOLUTION - (O(N)) time complexity\\nclass Solution {\\n    public int maxProfit(int[] prices) {\\n       int buy=prices[0];\\n        int sell=0;\\n        int max=0;\\n        for(int i=1; i<prices.length; i++){\\n            if(buy>prices[i]){\\n                buy=prices[i];\\n\\n            }else if(buy<prices[i] ){\\n                sell=prices[i]-buy;\\n                if(max<sell) max=sell;\\n            }\\n        }\\n           return max;\\n    }\\n}"
                    },
                    {
                        "username": "apeWithKeyBoard",
                        "content": "I have written basic O(n\\'squared) solution but the 203 testcase fails with Time Limit exceeded ouput. Any suggestions ?\\n"
                    },
                    {
                        "username": "Aman_26",
                        "content": "Whats wrong with this code?\\n    def maxProfit(self, prices: List[int]) -> int:\\n        n = len(prices)\\n        minimum_num = min(prices)\\n        index_min = prices.index(minimum_num)\\n        if index_min != n:\\n            prices = prices[index_min+1:]\\n            if len(prices) != 0:\\n                max_num = max(prices)\\n            else:\\n                max_num = 0\\n                if max_num > minimum_num:\\n                    return max_num - minimum_num\\n                else:\\n                    return 0\\n        return max_num - minimum_num\\n\\nit fails for the input [2,4,1], expected output is 2 my output is 0"
                    },
                    {
                        "username": "MuthuKrishnan007",
                        "content": "Hi,\\nCan anyone explain what is the requirements of the program clearly because in the first example input 715364 day 2 stock is buyed and sell in day 5 .\\nIn example 2 76431 in this example transaction is zero why can\\'t didn\\'t buy any stock.\\nAnyone please explain this."
                    },
                    {
                        "username": "arurahul16",
                        "content": "you need to read the problem , it says profit\\nBuy first day at 1 and Sell on second day 2\\nso you bought a stock for 1 GBP and selling it to 2 GBP\\nProfit ( 2-1=1 GBP)\\n\\nMAKE SURE  **MAXIMUM PROFIT***"
                    },
                    {
                        "username": "Amit_Joe",
                        "content": "only test case with having input 1,2 doesnt work the program is still to produce expected output in local machine. why??"
                    },
                    {
                        "username": "braads07",
                        "content": "[CAN SOMEONE PLS..HELP ME , WHERE M I WRONG?\\nCan we find the solution in this way?](CAN SOMEONE PLS..HELP ME , WHERE M I WRONG?\\nCan we find the solution in this way?)\\n\\n  `class Solution {\\npublic:\\n    int maxProfit(vector<int>& v) {\\n\\n        vector<int>v1=v;\\n        sort(v1.begin() , v1.end());\\n        int num=0;\\n        int n=v.size();\\n        int front=0;\\n        int end=v.size()-1;\\n        int maxx=INT_MIN;\\n        while(num!=n)\\n        {\\n            int i=search(v , 0 , n-1 ,  v1[front]);\\n            int j=search(v , 0 , n-1 ,  v1[end]);\\n            if(i<j)\\n            {\\n                maxx=max(maxx , (v1[end]-v1[front]));\\n                end=v.size()-1;\\n                front++;\\n                num++;\\n            }\\n            else if(front==end)\\n            {\\n                front++;\\n                end=v.size()-1;\\n                num++;\\n            }\\n            else\\n            {\\n                end--;\\n            }\\n        }\\n        if(maxx<=0)\\n        return 0;\\n        else \\n        return maxx;\\n\\n        \\n    }\\n    int search(vector<int>arr , int l , int r , int x)\\n    {\\n         if (r >= l) {\\n        int mid = l + (r - l) / 2;\\n\\n        if (arr[mid] == x)\\n            return mid;\\n \\n        // If element is smaller than mid, then\\n        // it can only be present in left subarray\\n        if (arr[mid] > x)\\n            return search(arr, l, mid - 1, x);\\n \\n        // Else the element can only be present\\n        // in right subarray\\n        return search(arr, mid + 1, r, x);\\n    }\\n    return -1;\\n    }\\n\\n\\n};`"
                    },
                    {
                        "username": "codernoob",
                        "content": "how are ppl doing the very large test array input? I am getting Time Limit Exceeded"
                    },
                    {
                        "username": "user3827xr",
                        "content": "In this problem, can we consider prices are positive numbers ? (remember, 2020 and negative prices of crude oil)"
                    },
                    {
                        "username": "arurahul16",
                        "content": "read problem properly ranges for prices[i] are mentioned from 0"
                    },
                    {
                        "username": "MeriemA",
                        "content": "Hello, \n\nI have tried to solve this problem using C. My solution works for almost all of the TCs. But the problem is that it shows time limit exceeded when the input is so large. So can anyone can help me to optimize my code?\nThanks a lot.\n\n `int maxProfit(int* prices, int pricesSize)\n{   \n    int buy_day = 0;\n    int sell_day = 0;\n    int max_profit = 0;\n    int profit = 0;\n\n    for (buy_day = 0; buy_day<pricesSize; buy_day++)\n    {\n        sell_day = buy_day + 1;\n        for(sell_day; sell_day<pricesSize; sell_day++)\n        {\n            profit = prices[sell_day] - prices[buy_day];\n            if (profit > max_profit)\n            {\n                max_profit = profit;\n            }\n        }\n    }\n\nreturn max_profit;\n}`\n\n"
                    },
                    {
                        "username": "alangreg",
                        "content": "[@MeriemA](/MeriemA) Probably. Thats why times out on large TC. I also striked out few times on time limit but then I changed approach to 1 loop (well 1 and a half as I used built in max() function) and it passed."
                    },
                    {
                        "username": "MeriemA",
                        "content": "[@alangreg](/alangreg) Thank you for you reply. Actually, the second loop won\\'t run over all of the table but only a part of it starting from a predefined index. So here I guess the time complexity is O(nlogn) not O(n\\xB2). right?"
                    },
                    {
                        "username": "alangreg",
                        "content": "The first thing I noticed is you are running with two loops."
                    },
                    {
                        "username": "Amarjeet2909",
                        "content": "Can Anyone tell why time limit exceeding here:\\n\\nclass Solution {\\npublic:\\n    int maxProfit(vector<int>& prices) {\\n        int profit =0;\\n        for(int i=0;i<prices.size()-1;i++){\\n            for(int j=i+1;j<prices.size();j++){\\n                if(prices[i]<prices[j]){\\n                int temp= prices[j]-prices[i];\\n                profit= max(profit, temp);\\n                }\\n            }   \\n        }\\n        return profit;\\n    }\\n};"
                    },
                    {
                        "username": "wodxuming",
                        "content": "```\\n\\nclass Solution {\\n    public int maxProfit(int[] prices) {\\n          int n = prices.length;\\n        // base case: dp[-1][0] = 0, dp[-1][1] = -infinity\\n        int dp_i_0 = 0, dp_i_1 = Integer.MIN_VALUE;\\n        for (int i = 0; i < n; i++) {\\n            // dp[i][0] = max(dp[i-1][0], dp[i-1][1] + prices[i])\\n            dp_i_0 = Math.max(dp_i_0, dp_i_1 + prices[i]);\\n            // dp[i][1] = max(dp[i-1][1], -prices[i])\\n            dp_i_1 = Math.max(dp_i_1, -prices[i]);\\n        }\\n        return dp_i_0; \\n    }\\n}\\n\\n```"
                    }
                ]
            }
        ]
    }
]