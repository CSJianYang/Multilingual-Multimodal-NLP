[
    {
        "title": "Escape a Large Maze",
        "question_content": "There is a 1 million by 1 million grid on an XY-plane, and the coordinates of each grid square are (x, y).\nWe start at the source = [sx, sy] square and want to reach the target = [tx, ty] square. There is also an array of blocked squares, where each blocked[i] = [xi, yi] represents a blocked square with coordinates (xi, yi).\nEach move, we can walk one square north, east, south, or west if the square is not in the array of blocked squares. We are also not allowed to walk outside of the grid.\nReturn true if and only if it is possible to reach the target square from the source square through a sequence of valid moves.\n&nbsp;\nExample 1:\nInput: blocked = [[0,1],[1,0]], source = [0,0], target = [0,2]\nOutput: false\nExplanation: The target square is inaccessible starting from the source square because we cannot move.\nWe cannot move north or east because those squares are blocked.\nWe cannot move south or west because we cannot go outside of the grid.\nExample 2:\nInput: blocked = [], source = [0,0], target = [999999,999999]\nOutput: true\nExplanation: Because there are no blocked cells, it is possible to reach the target square.\n&nbsp;\nConstraints:\n\t0 <= blocked.length <= 200\n\tblocked[i].length == 2\n\t0 <= xi, yi < 106\n\tsource.length == target.length == 2\n\t0 <= sx, sy, tx, ty < 106\n\tsource != target\n\tIt is guaranteed that source and target are not blocked.",
        "solutions": [
            {
                "id": 282849,
                "title": "python-bfs-and-dfs-the-whole-problem-is-broken",
                "content": "# **Important ForeForeWord, 2020-12**\\nThere is a test case added that\\n[[5,20],[10,10],[15,10],[10,30],[15,30],[20,30]]\\n[10,20]\\n[20,30]\\n\\nExpect start from [10,20], and target a blocked point [20,30].\\nNot sure if this is a valid test case, but it defenitely should return **FALSE**.\\n\\nBref: Any accepted solution, must be a **WRONG** solution.\\nUpdate: 2021-12, it\\'s fixed now.\\n<br>\\n\\n# **Important Foreword**\\nLeetcode add some new corner cases recently,\\nif it has different output with solution, don\\'t be surprised.\\nIt\\'s very probably that, my solution is correct, OJ is wrong.\\n\\nAlso, I suggest you read other solutions.\\nBut please don\\'t 100% trust the bound given by the other solution, thanks.\\n(Even these solutions are accepted by Leetcode)\\n\\nIf you doubt the bound that I insist in my solution (you can and you should),\\nPlease refer first to FAQ or replies below,\\nthey may help before we discussed repeated question.\\n<br>\\n\\n# **FAQ**\\n**Question** I think the maximum area is 10000?\\n**Answer**\\nThe maximum area is **NOT** 10000. Even it\\'s accepted with bound 10000, it\\'s **WRONG**.\\nThe same, the bfs with just `block.size` steps, is also wrong.\\n\\nIn the following case, the area is 19900.\\n```\\n0th      _________________________\\n         |O O O O O O O X\\n         |O O O O O O X\\n         |O O O O O X\\n         |O O O O X\\n         .O O O X\\n         .O O X\\n         .O X\\n200th    |X\\n```\\n<br>\\n\\n**Question** I think the maximum area is area of a sector.\\n**Answer**\\nAll cells are **discrete**, so there is **nothing** to do with pi.\\n<br>\\n\\n**Question** What is the maximum area?\\n**Answer**\\nIt maximum blocked is achieved when the blocked squares,\\nsurrounding one of the corners as a 45-degree straight line.\\n\\nAnd it\\'s easily proved.\\n\\nIf two cells are connected horizontally,\\nwe can slide one part vertically to get bigger area.\\n\\nIf two cells are connected vertically,\\nwe can slide one part horizontally to get bigger area.\\n<br>\\n\\n**Question** Can we apply a BFS?\\n**Answer**\\nYes, it works.\\nBFS in 4 directions need `block.length * 2` as step bounds,\\nBFS in 8 directions need `block.length ` as step bounds.\\n\\nIt needs to be noticed that,\\nThe top voted BFS solution is *WRONG* with bound,\\nthough it\\'s accpected by Leetcode.\\n\\nBut compared with the complexity:\\nSearching with limited area is `O(0.5B*B)`.\\nBFS with steps can be `O(2B^B)`.\\n<br>\\n\\n\\n# **Intuition**\\nSimple search will get TLE, because the big search space.\\nAnyway, we don\\'t need to go further to know if we are blocked or not.\\nBecause the maximum area blocked are 19900.\\n<br>\\n\\n# **Explanation**\\nSearch from `source` to `target`,\\nif find, return true;\\nif not find, return false;\\nif reach 20000 steps, return true.\\n\\nThen we do the same thing searching from `target` to `source`.\\n<br>\\n\\n# **Complexity**\\nTime complexity depends on the size of `blocked`\\nThe maximum area blocked are `B * (B - 1) / 2`.\\nAs a result, time and space complexity are both `O(B^2)`\\nIn my solution I used a fixed upper bound 20000.\\n<br>\\n\\n# **Python, DFS:**\\n```\\n    def isEscapePossible(self, blocked, source, target):\\n        blocked = set(map(tuple, blocked))\\n\\n        def dfs(x, y, target, seen):\\n            if not (0 <= x < 10**6 and 0 <= y < 10**6) or (x, y) in blocked or (x, y) in seen: return False\\n            seen.add((x, y))\\n            if len(seen) > 20000 or [x, y] == target: return True\\n            return dfs(x + 1, y, target, seen) or \\\\\\n                dfs(x - 1, y, target, seen) or \\\\\\n                dfs(x, y + 1, target, seen) or \\\\\\n                dfs(x, y - 1, target, seen)\\n        return dfs(source[0], source[1], target, set()) and dfs(target[0], target[1], source, set())\\n```\\n\\n# **Python, BFS:**\\n```\\n    def isEscapePossible(self, blocked, source, target):\\n        blocked = {tuple(p) for p in blocked}\\n\\n        def bfs(source, target):\\n            bfs, seen = [source], {tuple(source)}\\n            for x0, y0 in bfs:\\n                for i, j in [[0, 1], [1, 0], [-1, 0], [0, -1]]:\\n                    x, y = x0 + i, y0 + j\\n                    if 0 <= x < 10**6 and 0 <= y < 10**6 and (x, y) not in seen and (x, y) not in blocked:\\n                        if [x, y] == target: return True\\n                        bfs.append([x, y])\\n                        seen.add((x, y))\\n                if len(bfs) == 20000: return True\\n            return False\\n        return bfs(source, target) and bfs(target, source)\\n```\\n",
                "solutionTags": [],
                "code": "```\\n0th      _________________________\\n         |O O O O O O O X\\n         |O O O O O O X\\n         |O O O O O X\\n         |O O O O X\\n         .O O O X\\n         .O O X\\n         .O X\\n200th    |X\\n```\n```\\n    def isEscapePossible(self, blocked, source, target):\\n        blocked = set(map(tuple, blocked))\\n\\n        def dfs(x, y, target, seen):\\n            if not (0 <= x < 10**6 and 0 <= y < 10**6) or (x, y) in blocked or (x, y) in seen: return False\\n            seen.add((x, y))\\n            if len(seen) > 20000 or [x, y] == target: return True\\n            return dfs(x + 1, y, target, seen) or \\\\\\n                dfs(x - 1, y, target, seen) or \\\\\\n                dfs(x, y + 1, target, seen) or \\\\\\n                dfs(x, y - 1, target, seen)\\n        return dfs(source[0], source[1], target, set()) and dfs(target[0], target[1], source, set())\\n```\n```\\n    def isEscapePossible(self, blocked, source, target):\\n        blocked = {tuple(p) for p in blocked}\\n\\n        def bfs(source, target):\\n            bfs, seen = [source], {tuple(source)}\\n            for x0, y0 in bfs:\\n                for i, j in [[0, 1], [1, 0], [-1, 0], [0, -1]]:\\n                    x, y = x0 + i, y0 + j\\n                    if 0 <= x < 10**6 and 0 <= y < 10**6 and (x, y) not in seen and (x, y) not in blocked:\\n                        if [x, y] == target: return True\\n                        bfs.append([x, y])\\n                        seen.add((x, y))\\n                if len(bfs) == 20000: return True\\n            return False\\n        return bfs(source, target) and bfs(target, source)\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 282870,
                "title": "python-solution-with-picture-show-my-thoughts",
                "content": "a very interesting problem!\\n\\nAt first, I thought that this problem was to construct a closed interval with points in blocked and all boundary points (4\\\\*10^6 points), \\nand then look at the location of the source and target.\\n\\nthen, I draw some cases that shows below\\n\\n![image](https://assets.leetcode.com/users/2017111303/image_1556424333.png)\\n\\nthere are two cases that source node cannot reach target node\\n`case 1` is the blocked points and boundary points form a closed interval and one node(source or target) in,another out.\\n`case 2` is only the blocked points form a closed interval and one node(source or target) in,another out.\\n\\n`the key point is the length of blocked is smaller than 200`, so the closed area will not too large\\nwe can just use bfs to search from the source, and set a maximum step.\\nafter moving maximum step, if we can still move, then it must can reach the target point\\n\\nhere the maximum step should be `the length of blocked`, seen in case 3\\nof course, we should handled the different situation with the starting node\\n```python\\nclass Solution:\\n    def isEscapePossible(self, blocked: List[List[int]], source: List[int], target: List[int]) -> bool:\\n        if not blocked: return True\\n        blocked = set(map(tuple, blocked))\\n        \\n        def check(blocked, source, target):\\n            si, sj = source\\n            ti, tj = target\\n            level = 0\\n            q = collections.deque([(si,sj)])\\n            vis = set()\\n            while q:\\n                for _ in range(len(q)):\\n                    i,j = q.popleft()\\n                    if i == ti and j == tj: return True\\n                    for x,y in ((i+1,j),(i-1,j),(i,j+1),(i,j-1)):\\n                        if 0<=x<10**6 and 0<=y<10**6 and (x,y) not in vis and (x,y) not in blocked:\\n                            vis.add((x,y))\\n                            q.append((x,y))\\n                level += 1\\n                if level == len(blocked): break\\n            else:\\n                return False\\n            return True\\n        \\n        return check(blocked, source, target) and check(blocked, target, source)\\n```",
                "solutionTags": [],
                "code": "```python\\nclass Solution:\\n    def isEscapePossible(self, blocked: List[List[int]], source: List[int], target: List[int]) -> bool:\\n        if not blocked: return True\\n        blocked = set(map(tuple, blocked))\\n        \\n        def check(blocked, source, target):\\n            si, sj = source\\n            ti, tj = target\\n            level = 0\\n            q = collections.deque([(si,sj)])\\n            vis = set()\\n            while q:\\n                for _ in range(len(q)):\\n                    i,j = q.popleft()\\n                    if i == ti and j == tj: return True\\n                    for x,y in ((i+1,j),(i-1,j),(i,j+1),(i,j-1)):\\n                        if 0<=x<10**6 and 0<=y<10**6 and (x,y) not in vis and (x,y) not in blocked:\\n                            vis.add((x,y))\\n                            q.append((x,y))\\n                level += 1\\n                if level == len(blocked): break\\n            else:\\n                return False\\n            return True\\n        \\n        return check(blocked, source, target) and check(blocked, target, source)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 282860,
                "title": "c-limited-bfs-28-ms",
                "content": "# Intuition 1\\nThe target is reacheable if the soruce is not blocked, and the target is not blocked. With 200 blocks, we only need to travel some limited distance to check that we are not blocked.\\n# Solution\\nDo BFS ```50``` times. If we find our target, return true. If after all steps our BFS queue is empty, we are blocked.\\n\\nNote 1: we need to do this operation for both source and target.\\nNote 2: I am using 50 steps here and this solution is accepted (missing test case). I am getting TLE if I do 200 steps or more.\\n```\\nbool bfs(unordered_set<long long> visited, vector<int>& s, vector<int>& t) {\\n  vector<vector<int>> dirs = { {-1, 0}, {1, 0}, {0, -1}, {0, 1} };\\n  vector<pair<int, int>> q = { {s[0], s[1]} };\\n  for (auto dist = 1; !q.empty() && dist < 50; ++dist) {\\n    vector<pair<int, int>> q1;\\n    for (auto p : q) {\\n      for (auto d : dirs) {\\n        auto x = p.first + d[0], y = p.second + d[1];\\n        if (x < 0 || x > 999999 || y < 0 || y > 999999) continue;\\n        if (x == t[0] && y == t[1]) return true;\\n        if (visited.insert(((long long)x << 32) + y).second) q1.push_back({ x, y });\\n      }\\n    }\\n    swap(q, q1);\\n  }\\n  return !q.empty();\\n}\\nbool isEscapePossible(vector<vector<int>>& blocked, vector<int>& s, vector<int>& t) {\\n  unordered_set<long long> visited;\\n  for (auto b : blocked) visited.insert(((long long)b[0] << 32) + b[1]);  \\n  return bfs(visited, s, t) && bfs(visited, t, s);\\n}\\n```\\n# Intuition 2\\nWhen we run BFS, our queue contains the front \"wave\" of our search. If the number of cells is greater than the number of blocks, this wave cannot be contained.\\n# Optimized Solution\\nSame as before, but stop when the queue size exceeds the number of blocks. After this optimization, the runtime is down to 84 ms.\\n\\nWe can further optimize this solution by only considering blocks within 400 steps from the source or target. After this optimization, the runtime is down to 28 ms... Yay!!\\n```\\nbool bfs(unordered_set<long long> &visited, vector<int>& s, vector<int>& t, int blocks) {\\n  vector<vector<int>> dirs = { {-1, 0}, {1, 0}, {0, -1}, {0, 1} };\\n  vector<pair<int, int>> q = { {s[0], s[1]} };\\n  while (!q.empty() && q.size() <= blocks) {\\n    vector<pair<int, int>> q1;\\n    for (auto p : q) {\\n      for (auto d : dirs) {\\n        auto x = p.first + d[0], y = p.second + d[1];\\n        if (x < 0 || x > 999999 || y < 0 || y > 999999) continue;\\n        if (x == t[0] && y == t[1]) return true;\\n        if (visited.insert(((long long)x << 32) + y).second) q1.push_back({ x, y });\\n      }\\n    }\\n    swap(q, q1);\\n  }\\n  return !q.empty();\\n}\\nbool isEscapePossible(vector<vector<int>>& blocked, vector<int>& s, vector<int>& t) {\\n  unordered_set<long long> vis_s, vis_t;\\n  for (auto b : blocked) {\\n      if (abs(b[0] - s[0]) + abs(b[1] - s[1]) < 400) vis_s.insert(((long long)b[0] << 32) + b[1]);\\n      if (abs(b[0] - t[0]) + abs(b[1] - t[1]) < 400) vis_t.insert(((long long)b[0] << 32) + b[1]);\\n  }\\n  return bfs(vis_s, s, t, vis_s.size()) && bfs(vis_t, t, s, vis_t.size());\\n}\\n```",
                "solutionTags": [],
                "code": "```50```\n```\\nbool bfs(unordered_set<long long> visited, vector<int>& s, vector<int>& t) {\\n  vector<vector<int>> dirs = { {-1, 0}, {1, 0}, {0, -1}, {0, 1} };\\n  vector<pair<int, int>> q = { {s[0], s[1]} };\\n  for (auto dist = 1; !q.empty() && dist < 50; ++dist) {\\n    vector<pair<int, int>> q1;\\n    for (auto p : q) {\\n      for (auto d : dirs) {\\n        auto x = p.first + d[0], y = p.second + d[1];\\n        if (x < 0 || x > 999999 || y < 0 || y > 999999) continue;\\n        if (x == t[0] && y == t[1]) return true;\\n        if (visited.insert(((long long)x << 32) + y).second) q1.push_back({ x, y });\\n      }\\n    }\\n    swap(q, q1);\\n  }\\n  return !q.empty();\\n}\\nbool isEscapePossible(vector<vector<int>>& blocked, vector<int>& s, vector<int>& t) {\\n  unordered_set<long long> visited;\\n  for (auto b : blocked) visited.insert(((long long)b[0] << 32) + b[1]);  \\n  return bfs(visited, s, t) && bfs(visited, t, s);\\n}\\n```\n```\\nbool bfs(unordered_set<long long> &visited, vector<int>& s, vector<int>& t, int blocks) {\\n  vector<vector<int>> dirs = { {-1, 0}, {1, 0}, {0, -1}, {0, 1} };\\n  vector<pair<int, int>> q = { {s[0], s[1]} };\\n  while (!q.empty() && q.size() <= blocks) {\\n    vector<pair<int, int>> q1;\\n    for (auto p : q) {\\n      for (auto d : dirs) {\\n        auto x = p.first + d[0], y = p.second + d[1];\\n        if (x < 0 || x > 999999 || y < 0 || y > 999999) continue;\\n        if (x == t[0] && y == t[1]) return true;\\n        if (visited.insert(((long long)x << 32) + y).second) q1.push_back({ x, y });\\n      }\\n    }\\n    swap(q, q1);\\n  }\\n  return !q.empty();\\n}\\nbool isEscapePossible(vector<vector<int>>& blocked, vector<int>& s, vector<int>& t) {\\n  unordered_set<long long> vis_s, vis_t;\\n  for (auto b : blocked) {\\n      if (abs(b[0] - s[0]) + abs(b[1] - s[1]) < 400) vis_s.insert(((long long)b[0] << 32) + b[1]);\\n      if (abs(b[0] - t[0]) + abs(b[1] - t[1]) < 400) vis_t.insert(((long long)b[0] << 32) + b[1]);\\n  }\\n  return bfs(vis_s, s, t, vis_s.size()) && bfs(vis_t, t, s, vis_t.size());\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 282889,
                "title": "my-java-dfs-solution-with-some-thoughts-triangle-v-s-1-4-circle-in-pixels",
                "content": "Note it states `blocks.length <= 200`. We can make use of it.\\n\\nFind as many sqaures as possible from source and target individually. If both can reach more than a specified amount of squares (i.e. the largest closed area the block squares and the grid borders can form), it means they can both go beyond the blocks.\\n\\n```markdown\\nCode Updated (as pointed out by @andrew18):\\n---\\nYou ignore the case that it can move directly from the source to target below the limit of number of moves. Consider the following case:\\nblocked: [[0,2],[1,0],[1,1]]\\nsource: [0,0]; target: [0,1]\\n```\\n\\nBut how can we get the largest closed area? The largest one I can come up with is a `1/4` circle with its arc `200` in length. Then the area is `12,732` roughly.\\n\\nHowever, we are facing a **pixel** problem. It\\'s not a continous line, but is composed by `pixels`, which don\\'t need to be adjacent to form a line (i.e. two pixels are positioned diagonally). In this case, the circle **might not** be the largest.\\n\\nWe can come up with another example: the 200-long line in exactly 45 degree which forms a triangle. The line is made up with `200` pixels but actually is `200 * sqrt(2)` in length. The square is roughly `(200 * sqrt(2)) * (200 * sqrt(2) / 2) / 2 = 20000`. The number of accurate pixels is `1 + 2 + ... + 200 = 20100` (we can reduce `200` because they are blocks themselves XD. Then it\\'s actuall `19900`).\\n\\nLet\\'s see the 1/4 circle again. When we are trying to make a circle, we actually make some diagonally positioned pixels become adjacent. This will reduce the area at every step. So the triangle should be the larger one when the pixel count is fixed.\\n\\nThe following image shows the two examples when pixel count of the border is `13`.\\n\\n![image](https://assets.leetcode.com/users/nullpointer01/image_1556430795.png)\\n\\n\\nI choose `20,000` in the code here.\\n\\n*Thanks **@andrew18** to point out my previous error, though it passed the previous test cases. Below is the updated answer.*\\n\\n```\\nclass Solution {\\n    final int MAX_VISIT = 20000;\\n\\t\\n    public boolean isEscapePossible(int[][] blocked, int[] source, int[] target) {\\n        Set<String> blockedSet = new HashSet<>();\\n        for (int[] point : blocked) {\\n            blockedSet.add(getKey(point));\\n        }\\n        return canVisit(blockedSet, source, getKey(target)) && canVisit(blockedSet, target, getKey(source));\\n    }\\n    \\n    String getKey(int[] point) {\\n        return point[0] + \",\" + point[1];\\n    }\\n    \\n    boolean canVisit(Set<String> blocked, int[] source, String targetKey) {\\n        Set<String> visited = new HashSet<>();\\n        dfs(blocked, source, targetKey, visited);\\n        return visited.size() >= MAX_VISIT || visited.contains(targetKey);\\n    }\\n    \\n    void dfs(Set<String> blocked, int[] curr, String targetKey, Set<String> visited) {\\n        int i = curr[0], j = curr[1];\\n        if (i < 0 || j < 0 || i >= 1e6 || j >= 1e6) { return; }\\n        \\n        String key = getKey(curr);\\n        if (blocked.contains(key)) { return; }\\n        if (visited.size() >= MAX_VISIT || visited.contains(targetKey)) { return; }\\n        \\n        if (visited.contains(key)) { return; }\\n        visited.add(key);\\n        \\n        for (int[] next : new int[][] {{i-1 ,j}, {i+1, j}, {i, j-1}, {i, j+1}}) {\\n            dfs(blocked, next, targetKey, visited);\\n        }\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```markdown\\nCode Updated (as pointed out by @andrew18):\\n---\\nYou ignore the case that it can move directly from the source to target below the limit of number of moves. Consider the following case:\\nblocked: [[0,2],[1,0],[1,1]]\\nsource: [0,0]; target: [0,1]\\n```\n```\\nclass Solution {\\n    final int MAX_VISIT = 20000;\\n\\t\\n    public boolean isEscapePossible(int[][] blocked, int[] source, int[] target) {\\n        Set<String> blockedSet = new HashSet<>();\\n        for (int[] point : blocked) {\\n            blockedSet.add(getKey(point));\\n        }\\n        return canVisit(blockedSet, source, getKey(target)) && canVisit(blockedSet, target, getKey(source));\\n    }\\n    \\n    String getKey(int[] point) {\\n        return point[0] + \",\" + point[1];\\n    }\\n    \\n    boolean canVisit(Set<String> blocked, int[] source, String targetKey) {\\n        Set<String> visited = new HashSet<>();\\n        dfs(blocked, source, targetKey, visited);\\n        return visited.size() >= MAX_VISIT || visited.contains(targetKey);\\n    }\\n    \\n    void dfs(Set<String> blocked, int[] curr, String targetKey, Set<String> visited) {\\n        int i = curr[0], j = curr[1];\\n        if (i < 0 || j < 0 || i >= 1e6 || j >= 1e6) { return; }\\n        \\n        String key = getKey(curr);\\n        if (blocked.contains(key)) { return; }\\n        if (visited.size() >= MAX_VISIT || visited.contains(targetKey)) { return; }\\n        \\n        if (visited.contains(key)) { return; }\\n        visited.add(key);\\n        \\n        for (int[] next : new int[][] {{i-1 ,j}, {i+1, j}, {i, j-1}, {i, j+1}}) {\\n            dfs(blocked, next, targetKey, visited);\\n        }\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 282978,
                "title": "maze-compression-results-in-o-n-2-where-n-is-the-number-of-blocked-squares",
                "content": "The large size of the search spaces precludes either an in-memory representation of the maze or a brute-force search through a virtual maze. But we can dramatically reduce the search space by compressing multiple adjacent blank rows into a single blank row and likewise for columns. This produces a maze that is topologically the same as the original maze but with size O(n) x O(n) instead of 1000000 x 1000000, where n is the number of blocked squares.\\n\\nTo compress the rows, we take all the rows referenced in any of the blocked squares and add the first row, the last row, and the source and target rows. Then we make a sorted distinct list and make sure that no two consecutive values differ by more than two. This produces a map that translates from uncompressed row index to compressed row index and determines the number of comrpessed rows. Then we follow the same procedure for the columns.\\n\\nNow that we have compressed the maze down to a workable size, we can represent it with an in-memory grid and attack the problem using a variety of approaches such as Union-Find or depth first search.\\n\\nThe end result is an algorithm that uses space and time of O(p q), where p is the number of distinct rows, and q is the number of distinct columns, or O(n^2) in the worst case where n is the number of blocked squares\\n\\n```csharp\\npublic class Solution {\\n\\n\\tprivate int rows, cols;\\n\\tprivate Dictionary<int, int> rowMap, colMap;\\n\\n\\tpublic bool IsEscapePossible(int[][] blocked, int[] source, int[] target) {\\n\\n\\t\\t// Compress consecutive blank rows and columns.\\n\\t\\t(rows, rowMap) = GetMap(blocked, source, target, 0);\\n\\t\\t(cols, colMap) = GetMap(blocked, source, target, 1);\\n\\n\\t\\t// Create a grid from the compressed data.\\n\\t\\tvar grid = new bool[rows, cols];\\n\\t\\tforeach (var pair in blocked) grid[rowMap[pair[0]], colMap[pair[1]]] = true;\\n\\n\\t\\t// Connect unblocked squares to each other.\\n\\t\\tvar uf = new UnionFind(rows * cols);\\n\\t\\tvar deltas = new[] { (0, 1), (1, 0), (0, -1), (-1, 0) };\\n\\t\\tfor (var row = 0; row < rows; row++) for (var col = 0; col < cols; col++) {\\n\\t\\t\\tvar id = GetId(row, col);\\n\\t\\t\\tif (!grid[row, col]) foreach (var (dr, dc) in deltas)\\n\\t\\t\\t{\\n\\t\\t\\t\\tvar (r, c) = (row + dr, col + dc);\\n\\t\\t\\t\\tif (r >= 0 && r < rows && c >= 0 && c < cols && !grid[r, c])\\n\\t\\t\\t\\t\\tuf.Union(id, GetId(r, c));\\n\\t\\t\\t}\\n\\t\\t}\\n\\n\\t\\t// Check whether the source is connected to the target.\\n\\t\\treturn uf.Find(GetMappedId(source), GetMappedId(target));\\n\\t}\\n\\n\\tprivate (int, Dictionary<int, int>) GetMap(int[][] blocked, int[] source, int[] target, int index) {\\n\\t\\tvar size = 0;\\n\\t\\tvar map = new Dictionary<int, int>();\\n\\t\\tvar ids = blocked.Select(pair => pair[index])\\n\\t\\t\\t.Concat(new [] { 0, source[index], target[index], 999999 })\\n\\t\\t\\t.OrderBy(id => id).Distinct().ToArray();\\n\\t\\tvar next = 0;\\n\\t\\tfor (var i = 0; i < ids.Length; i++) {\\n\\t\\t\\tif (i != 0) next += Math.Min(2, ids[i] - ids[i - 1]);\\n\\t\\t\\tmap.Add(ids[i], next);\\n\\t\\t\\tsize = Math.Max(size, next + 1);\\n\\t\\t}\\n\\t\\treturn (size, map);\\n\\t}\\n\\tprivate int GetId(int row, int col) {\\n\\t\\treturn row * cols + col;\\n\\t}\\n\\tprivate int GetMappedId(int[] pair) {\\n\\t\\treturn GetId(rowMap[pair[0]], colMap[pair[1]]);\\n\\t}\\n\\n\\t// Union-Find algorithm\\n\\tpublic class UnionFind {\\n\\t\\tprivate int[] id;\\n\\t\\tprivate int[] sz;\\n\\t\\tpublic UnionFind(int n) {\\n\\t\\t\\tid = new int[n];\\n\\t\\t\\tsz = new int[n];\\n\\t\\t\\tfor (var i = 0; i < n; i++) id[i] = i;\\n\\t\\t}\\n\\t\\tprivate int Root(int i) {\\n\\t\\t\\twhile (i != id[i]) {\\n\\t\\t\\t\\tid[i] = id[id[i]];\\n\\t\\t\\t\\ti = id[i];\\n\\t\\t\\t}\\n\\t\\t\\treturn i;\\n\\t\\t}\\n\\t\\tpublic bool Find(int p, int q) {\\n\\t\\t\\treturn Root(p) == Root(q);\\n\\t\\t}\\n\\t\\tpublic void Union(int p, int q) {\\n\\t\\t\\tint i = Root(p);\\n\\t\\t\\tint j = Root(q);\\n\\t\\t\\tif (i == j) return;\\n\\t\\t\\tif (sz[i] < sz[j]) { id[i] = j; sz[j] += sz[i]; }\\n\\t\\t\\telse { id[j] = i; sz[i] += sz[j]; }\\n\\t\\t}\\n\\t}\\n}\\n```\\n",
                "solutionTags": [
                    "C#",
                    "Union Find"
                ],
                "code": "```csharp\\npublic class Solution {\\n\\n\\tprivate int rows, cols;\\n\\tprivate Dictionary<int, int> rowMap, colMap;\\n\\n\\tpublic bool IsEscapePossible(int[][] blocked, int[] source, int[] target) {\\n\\n\\t\\t// Compress consecutive blank rows and columns.\\n\\t\\t(rows, rowMap) = GetMap(blocked, source, target, 0);\\n\\t\\t(cols, colMap) = GetMap(blocked, source, target, 1);\\n\\n\\t\\t// Create a grid from the compressed data.\\n\\t\\tvar grid = new bool[rows, cols];\\n\\t\\tforeach (var pair in blocked) grid[rowMap[pair[0]], colMap[pair[1]]] = true;\\n\\n\\t\\t// Connect unblocked squares to each other.\\n\\t\\tvar uf = new UnionFind(rows * cols);\\n\\t\\tvar deltas = new[] { (0, 1), (1, 0), (0, -1), (-1, 0) };\\n\\t\\tfor (var row = 0; row < rows; row++) for (var col = 0; col < cols; col++) {\\n\\t\\t\\tvar id = GetId(row, col);\\n\\t\\t\\tif (!grid[row, col]) foreach (var (dr, dc) in deltas)\\n\\t\\t\\t{\\n\\t\\t\\t\\tvar (r, c) = (row + dr, col + dc);\\n\\t\\t\\t\\tif (r >= 0 && r < rows && c >= 0 && c < cols && !grid[r, c])\\n\\t\\t\\t\\t\\tuf.Union(id, GetId(r, c));\\n\\t\\t\\t}\\n\\t\\t}\\n\\n\\t\\t// Check whether the source is connected to the target.\\n\\t\\treturn uf.Find(GetMappedId(source), GetMappedId(target));\\n\\t}\\n\\n\\tprivate (int, Dictionary<int, int>) GetMap(int[][] blocked, int[] source, int[] target, int index) {\\n\\t\\tvar size = 0;\\n\\t\\tvar map = new Dictionary<int, int>();\\n\\t\\tvar ids = blocked.Select(pair => pair[index])\\n\\t\\t\\t.Concat(new [] { 0, source[index], target[index], 999999 })\\n\\t\\t\\t.OrderBy(id => id).Distinct().ToArray();\\n\\t\\tvar next = 0;\\n\\t\\tfor (var i = 0; i < ids.Length; i++) {\\n\\t\\t\\tif (i != 0) next += Math.Min(2, ids[i] - ids[i - 1]);\\n\\t\\t\\tmap.Add(ids[i], next);\\n\\t\\t\\tsize = Math.Max(size, next + 1);\\n\\t\\t}\\n\\t\\treturn (size, map);\\n\\t}\\n\\tprivate int GetId(int row, int col) {\\n\\t\\treturn row * cols + col;\\n\\t}\\n\\tprivate int GetMappedId(int[] pair) {\\n\\t\\treturn GetId(rowMap[pair[0]], colMap[pair[1]]);\\n\\t}\\n\\n\\t// Union-Find algorithm\\n\\tpublic class UnionFind {\\n\\t\\tprivate int[] id;\\n\\t\\tprivate int[] sz;\\n\\t\\tpublic UnionFind(int n) {\\n\\t\\t\\tid = new int[n];\\n\\t\\t\\tsz = new int[n];\\n\\t\\t\\tfor (var i = 0; i < n; i++) id[i] = i;\\n\\t\\t}\\n\\t\\tprivate int Root(int i) {\\n\\t\\t\\twhile (i != id[i]) {\\n\\t\\t\\t\\tid[i] = id[id[i]];\\n\\t\\t\\t\\ti = id[i];\\n\\t\\t\\t}\\n\\t\\t\\treturn i;\\n\\t\\t}\\n\\t\\tpublic bool Find(int p, int q) {\\n\\t\\t\\treturn Root(p) == Root(q);\\n\\t\\t}\\n\\t\\tpublic void Union(int p, int q) {\\n\\t\\t\\tint i = Root(p);\\n\\t\\t\\tint j = Root(q);\\n\\t\\t\\tif (i == j) return;\\n\\t\\t\\tif (sz[i] < sz[j]) { id[i] = j; sz[j] += sz[i]; }\\n\\t\\t\\telse { id[j] = i; sz[i] += sz[j]; }\\n\\t\\t}\\n\\t}\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1421121,
                "title": "java-easy-approach-with-explanation-bfs-hashset-1-4-sector",
                "content": "```\\nclass Solution \\n{\\n    static final int limit= 1000000;//boundary check \\n  \\n    public boolean isEscapePossible(int[][] blocked, int[] source, int[] target) \\n    {\\n        Set<String> blocks= new HashSet<>();//HashSet to reduce the access time from O(N)-> O(1)\\n      \\n        for(int block[] : blocked)\\n            blocks.add(block[0]+ \"-\"+ block[1]);//putting the blocked node into the HashSet to access it at O(1)\\n      \\n        return bfsRange(source, target, blocks) && bfsRange(target, source, blocks);//sector division \\n      \\n      /*checking for both the case that the source is blocked or the target is blocked \\n       *if one of them is blocked we return false\\n       *since it is not practical to traverse each node, it will provide us with TLE\\n      */  \\n    }\\n  \\n    /* Formula :: \\n     * shortest arc(displacement) of 1/4 sector of circel is a* 2^1/2\\n     * Area of the triangular sector is 1/2 * ( r{base} * r{height} )\\n     * Number of minimum shell to cover to move ahed of sector or boundary if possible = 0 + 1 + 2 + 3 + ... + 199 = 19900 (A.P)\\n     */\\n  \\n    public boolean bfsRange(int[] source, int[] target, Set<String> blocks)\\n    {//we simply do bsf to check the circular quadrant 1/4th boundary of the sector \\n      \\n        Set<String> visited= new HashSet<>();//visited hash set is so that we dont visit the visited cell again and the access time is O(1)\\n        Queue<int[]> q= new LinkedList<>();//as we use in  BT  \\n      \\n        q.offer(source);//adding the starting BFS node to the Queue\\n      \\n        visited.add(source[0] + \"-\" + source[1]);//marking it as visited so  that we dont traverse it again \\n        \\n        int count= 0;//number of node traverse total outside + inside \\n        while(!q.isEmpty())\\n        {//r m* w a*\\n            int temp[]= q.poll();//poling the node \\n            count+= 1;//counting the number of node traverse\\n          \\n            int trav[][]= {{-1, 0}, {0, 1}, {0, -1}, {1, 0}};//Traversing in 4-Direction \\n          \\n            for(int direction[] : trav)\\n            {\\n                int i= temp[0] + direction[0];\\n                int j= temp[1] + direction[1];\\n              \\n                String key= (i+ \"-\"+ j);\\n              \\n                if(i < 0 || j < 0 || i >= limit || j >= limit || visited.contains(key) || blocks.contains(key)) \\n                    continue;//base case 1)checking the index 2)We dont visit the blocked node 3) we dont visit the visited node \\n              \\n                if(i == target[0] && j == target[1]) //when we find the target within the boundary(same sector or the quadrand) we just return true //best case saves a lot of time \\n                   return true;\\n              \\n                visited.add(key);//marking the node as visited and adding it to the Queue\\n              \\n                q.offer(new int[]{i, j});//Expaning the search for path and adding the node \\n              \\n                if(count > 19900) //number of cell, crossing the boundary limit\\n                   return true;//path exists from this node \\n            }\\n        }\\n        return false;//no path, to reach the node//boundary blocked us \\n    }\\n}//Please do Upvote, it helps a lot\\n```",
                "solutionTags": [
                    "Java",
                    "Breadth-First Search"
                ],
                "code": "```\\nclass Solution \\n{\\n    static final int limit= 1000000;//boundary check \\n  \\n    public boolean isEscapePossible(int[][] blocked, int[] source, int[] target) \\n    {\\n        Set<String> blocks= new HashSet<>();//HashSet to reduce the access time from O(N)-> O(1)\\n      \\n        for(int block[] : blocked)\\n            blocks.add(block[0]+ \"-\"+ block[1]);//putting the blocked node into the HashSet to access it at O(1)\\n      \\n        return bfsRange(source, target, blocks) && bfsRange(target, source, blocks);//sector division \\n      \\n      /*checking for both the case that the source is blocked or the target is blocked \\n       *if one of them is blocked we return false\\n       *since it is not practical to traverse each node, it will provide us with TLE\\n      */  \\n    }\\n  \\n    /* Formula :: \\n     * shortest arc(displacement) of 1/4 sector of circel is a* 2^1/2\\n     * Area of the triangular sector is 1/2 * ( r{base} * r{height} )\\n     * Number of minimum shell to cover to move ahed of sector or boundary if possible = 0 + 1 + 2 + 3 + ... + 199 = 19900 (A.P)\\n     */\\n  \\n    public boolean bfsRange(int[] source, int[] target, Set<String> blocks)\\n    {//we simply do bsf to check the circular quadrant 1/4th boundary of the sector \\n      \\n        Set<String> visited= new HashSet<>();//visited hash set is so that we dont visit the visited cell again and the access time is O(1)\\n        Queue<int[]> q= new LinkedList<>();//as we use in  BT  \\n      \\n        q.offer(source);//adding the starting BFS node to the Queue\\n      \\n        visited.add(source[0] + \"-\" + source[1]);//marking it as visited so  that we dont traverse it again \\n        \\n        int count= 0;//number of node traverse total outside + inside \\n        while(!q.isEmpty())\\n        {//r m* w a*\\n            int temp[]= q.poll();//poling the node \\n            count+= 1;//counting the number of node traverse\\n          \\n            int trav[][]= {{-1, 0}, {0, 1}, {0, -1}, {1, 0}};//Traversing in 4-Direction \\n          \\n            for(int direction[] : trav)\\n            {\\n                int i= temp[0] + direction[0];\\n                int j= temp[1] + direction[1];\\n              \\n                String key= (i+ \"-\"+ j);\\n              \\n                if(i < 0 || j < 0 || i >= limit || j >= limit || visited.contains(key) || blocks.contains(key)) \\n                    continue;//base case 1)checking the index 2)We dont visit the blocked node 3) we dont visit the visited node \\n              \\n                if(i == target[0] && j == target[1]) //when we find the target within the boundary(same sector or the quadrand) we just return true //best case saves a lot of time \\n                   return true;\\n              \\n                visited.add(key);//marking the node as visited and adding it to the Queue\\n              \\n                q.offer(new int[]{i, j});//Expaning the search for path and adding the node \\n              \\n                if(count > 19900) //number of cell, crossing the boundary limit\\n                   return true;//path exists from this node \\n            }\\n        }\\n        return false;//no path, to reach the node//boundary blocked us \\n    }\\n}//Please do Upvote, it helps a lot\\n```",
                "codeTag": "Java"
            },
            {
                "id": 305600,
                "title": "java-most-intuitive-solution-with-detailed-comments",
                "content": "```\\nclass Solution {\\n    Long M = 1000000L; \\n    int[][] dirs = {{1,0}, {-1,0}, {0,-1},{0,1}};\\n    \\n    public boolean isEscapePossible(int[][] blocked, int[] source, int[] target) {\\n        //https://xingxingpark.com/Leetcode-1036-Escape-a-Large-Maze/\\n        /*\\n        Only when source and target are separated completely by blocked squares \\n        will it be impossible to reach target from source. \\n        Since the len of blocked is no larger than 200, \\n        the closed area will be bounded by 200*200. \\n        */\\n        Set<Long> b = new HashSet<>(); //blocked square\\n        for (int[] n: blocked) b.add(n[0]*M + n[1]);\\n        \\n        //make sure both s and t will be surrounded by the block\\n        return check(b, source, target, source, new HashSet<>())\\n            && check(b, target, source, target, new HashSet<>()); \\n    }\\n    \\n    /*\\n    @param b: blocked squares (x, y) -> x*M + y\\n    @param s: source square\\n    @param t: target square\\n    @param cur: current square\\n    @param v: visited squares (x, y) -> x*M + y\\n    */\\n    boolean check(Set<Long> b, int[] s, int[] t, int[] cur, Set<Long> v) {\\n        //we can stop the search when cur[i][j] is beyond the \\n        //largest closed area formed by blocked squares.\\n        if (Math.abs(cur[0] - s[0]) == 200 \\n           || Math.abs(cur[1] - s[1]) == 200\\n            // found the target \\n           || v.size() > 0 && cur[0] == t[0] && cur[1]==t[1]) \\n            return true;\\n        \\n        v.add(cur[0]*M + cur[1]); \\n        \\n        for (int[] dir : dirs) {\\n            int x = cur[0] + dir[0]; \\n            int y = cur[1] + dir[1]; \\n            if (x < 0 || x == M || y < 0 || y == M \\n                || v.contains(x*M+y) || b.contains(x*M+y))\\n                continue;\\n            if (check(b, s, t, new int[]{x,y}, v)) return true; \\n        }\\n        return false; \\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    Long M = 1000000L; \\n    int[][] dirs = {{1,0}, {-1,0}, {0,-1},{0,1}};\\n    \\n    public boolean isEscapePossible(int[][] blocked, int[] source, int[] target) {\\n        //https://xingxingpark.com/Leetcode-1036-Escape-a-Large-Maze/\\n        /*\\n        Only when source and target are separated completely by blocked squares \\n        will it be impossible to reach target from source. \\n        Since the len of blocked is no larger than 200, \\n        the closed area will be bounded by 200*200. \\n        */\\n        Set<Long> b = new HashSet<>(); //blocked square\\n        for (int[] n: blocked) b.add(n[0]*M + n[1]);\\n        \\n        //make sure both s and t will be surrounded by the block\\n        return check(b, source, target, source, new HashSet<>())\\n            && check(b, target, source, target, new HashSet<>()); \\n    }\\n    \\n    /*\\n    @param b: blocked squares (x, y) -> x*M + y\\n    @param s: source square\\n    @param t: target square\\n    @param cur: current square\\n    @param v: visited squares (x, y) -> x*M + y\\n    */\\n    boolean check(Set<Long> b, int[] s, int[] t, int[] cur, Set<Long> v) {\\n        //we can stop the search when cur[i][j] is beyond the \\n        //largest closed area formed by blocked squares.\\n        if (Math.abs(cur[0] - s[0]) == 200 \\n           || Math.abs(cur[1] - s[1]) == 200\\n            // found the target \\n           || v.size() > 0 && cur[0] == t[0] && cur[1]==t[1]) \\n            return true;\\n        \\n        v.add(cur[0]*M + cur[1]); \\n        \\n        for (int[] dir : dirs) {\\n            int x = cur[0] + dir[0]; \\n            int y = cur[1] + dir[1]; \\n            if (x < 0 || x == M || y < 0 || y == M \\n                || v.contains(x*M+y) || b.contains(x*M+y))\\n                continue;\\n            if (check(b, s, t, new int[]{x,y}, v)) return true; \\n        }\\n        return false; \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 283446,
                "title": "c-solution-2-bfs-using-unordered-set-with-explaination",
                "content": "```\\nNote that some solutions in the discussion used the shortcoming of the \\ninput and passed all the test which seems quite unreasonable.\\nIn general if src->target is impossible only 2 cases should be considered:\\n1. src is trapped and target is not in the same trap\\n2. target is trapped and src in not in the same trap\\n\\nThe idea is to use 2 depth limited search one start from the source \\nto destination, other start from destination to source. Note that if we\\ncan moves to a spot which the Mahhatan distance is over 200 to the \\nstarting point we could consider that we escape the blockade.\\nA very special case is that we can reach src to dest within the 200 moves\\nin this way we could just do one BFS and return true.\\nSince the points are given as coordinates a direct mapping is inconvinience\\nin C++, hence, we use unordered_set<long long> which 1000000 * x + y \\nrefers to the value of (x, y).\\n```\\nImplementation:\\n```\\nclass Solution {\\npublic:\\n    bool isEscapePossible(vector<vector<int>>& blocked, \\n                          vector<int>& source, vector<int>& target) {\\n        \\n        hash = unordered_set<long long>();\\n        for (auto b : blocked) {\\n            long long t = (long long) b[0] * 1000000 + b[1];\\n            hash.insert(t);\\n        }\\n\\t\\t// the first BFS from src to dest\\n        int judge1 = BFS(source, target);\\n        if (judge1 == 2) {\\n\\t\\t\\t// if we can reach the dest directly in 200 moves return true\\n            return true;\\n        } else if (judge1 == 0) {\\n\\t\\t\\t// if we the src is surrounded return false\\n            return false;\\n        }\\n        // otherwise we consider the dest ->src \\n        hash = unordered_set<long long>();\\n        for (auto b : blocked) {\\n            long long t = (long long) b[0] * 1000000 + b[1];\\n            hash.insert(t);\\n        }\\n        // as long as the target is not blocked return true\\n        return (BFS(target, source) > 0);\\n    }\\n    \\nprivate:\\n    unordered_set<long long> hash;\\n    int BFS(vector<int> &src, vector<int> &dest) {\\n        queue<pair<int, int>> q = queue<pair<int, int>>();\\n\\t\\t// 4 ways to move\\n        int dx[4] = {0,0,1,-1};\\n        int dy[4] = {1,-1,0,0};\\n        int i;\\n        long long t = (long long) src[0] * 1000000 + src[1];\\n        q.push(pair(src[0], src[1]));\\n        hash.insert(t);\\n        while (!q.empty()) {\\n            pair<int, int> p = q.front();\\n            q.pop();\\n\\t\\t\\t// we reach the target return 2\\n            if (p.first == dest[0] && p.second == dest[1]) return 2;\\n\\t\\t\\t// we escape the block return 1\\n            if (abs(p.first - src[0]) + abs(p.second - src[1]) > 200) return 1;\\n            for (i = 0 ; i < 4; i++) {\\n                int tx = dx[i] + p.first;\\n                int ty = dy[i] + p.second;\\n\\t\\t\\t\\t// this map the coordinate to a unique long long integer\\n                long long t = (long long) tx * 1000000 + ty;\\n                if (tx < 0 || ty < 0 || tx >= 1000000 || ty >= 1000000 \\n                    || hash.find(t) != hash.end()) {\\n                    continue;\\n                } \\n                hash.insert(t);\\n                q.push(pair(tx, ty));\\n            }\\n        }\\n        // we cannot escape the trap return false\\n        return 0;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nNote that some solutions in the discussion used the shortcoming of the \\ninput and passed all the test which seems quite unreasonable.\\nIn general if src->target is impossible only 2 cases should be considered:\\n1. src is trapped and target is not in the same trap\\n2. target is trapped and src in not in the same trap\\n\\nThe idea is to use 2 depth limited search one start from the source \\nto destination, other start from destination to source. Note that if we\\ncan moves to a spot which the Mahhatan distance is over 200 to the \\nstarting point we could consider that we escape the blockade.\\nA very special case is that we can reach src to dest within the 200 moves\\nin this way we could just do one BFS and return true.\\nSince the points are given as coordinates a direct mapping is inconvinience\\nin C++, hence, we use unordered_set<long long> which 1000000 * x + y \\nrefers to the value of (x, y).\\n```\n```\\nclass Solution {\\npublic:\\n    bool isEscapePossible(vector<vector<int>>& blocked, \\n                          vector<int>& source, vector<int>& target) {\\n        \\n        hash = unordered_set<long long>();\\n        for (auto b : blocked) {\\n            long long t = (long long) b[0] * 1000000 + b[1];\\n            hash.insert(t);\\n        }\\n\\t\\t// the first BFS from src to dest\\n        int judge1 = BFS(source, target);\\n        if (judge1 == 2) {\\n\\t\\t\\t// if we can reach the dest directly in 200 moves return true\\n            return true;\\n        } else if (judge1 == 0) {\\n\\t\\t\\t// if we the src is surrounded return false\\n            return false;\\n        }\\n        // otherwise we consider the dest ->src \\n        hash = unordered_set<long long>();\\n        for (auto b : blocked) {\\n            long long t = (long long) b[0] * 1000000 + b[1];\\n            hash.insert(t);\\n        }\\n        // as long as the target is not blocked return true\\n        return (BFS(target, source) > 0);\\n    }\\n    \\nprivate:\\n    unordered_set<long long> hash;\\n    int BFS(vector<int> &src, vector<int> &dest) {\\n        queue<pair<int, int>> q = queue<pair<int, int>>();\\n\\t\\t// 4 ways to move\\n        int dx[4] = {0,0,1,-1};\\n        int dy[4] = {1,-1,0,0};\\n        int i;\\n        long long t = (long long) src[0] * 1000000 + src[1];\\n        q.push(pair(src[0], src[1]));\\n        hash.insert(t);\\n        while (!q.empty()) {\\n            pair<int, int> p = q.front();\\n            q.pop();\\n\\t\\t\\t// we reach the target return 2\\n            if (p.first == dest[0] && p.second == dest[1]) return 2;\\n\\t\\t\\t// we escape the block return 1\\n            if (abs(p.first - src[0]) + abs(p.second - src[1]) > 200) return 1;\\n            for (i = 0 ; i < 4; i++) {\\n                int tx = dx[i] + p.first;\\n                int ty = dy[i] + p.second;\\n\\t\\t\\t\\t// this map the coordinate to a unique long long integer\\n                long long t = (long long) tx * 1000000 + ty;\\n                if (tx < 0 || ty < 0 || tx >= 1000000 || ty >= 1000000 \\n                    || hash.find(t) != hash.end()) {\\n                    continue;\\n                } \\n                hash.insert(t);\\n                q.push(pair(tx, ty));\\n            }\\n        }\\n        // we cannot escape the trap return false\\n        return 0;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 906484,
                "title": "can-target-be-blocked-is-a-blocked-cell-still-reachable-test-case-31",
                "content": "Here is the test case #31. We can see that the target is blocked and the expected answer is `True`. \\n```\\n[[5,20],[10,10],[15,10],[10,30],[15,30],[20,30]]\\n[10,20]\\n[20,30]\\n```\\n\\nIt seems that this test case is inconsistent with the following description: \\n> We start at the source square and want to reach the target square.  Each move, we can walk to a 4-directionally adjacent square in the grid that isn\\'t in the given list of blocked squares.",
                "solutionTags": [],
                "code": "```\\n[[5,20],[10,10],[15,10],[10,30],[15,30],[20,30]]\\n[10,20]\\n[20,30]\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2132711,
                "title": "c-easy-to-understand-simple-code-intuitive-approach",
                "content": "**Refer to this For Explanation**\\nhttps://www.youtube.com/watch?v=bZqIfxD902c\\n```\\nclass Solution {\\npublic:\\n    bool canReach(vector<int> &source,vector<int> &target,int numBlocked,set<pair<int,int>> &block)\\n    {\\n        vector<int> dx,dy;\\n        dx={0,0,1,-1};\\n        dy={1,-1,0,0};\\n        int maxArea=numBlocked*(numBlocked-1)/2;\\n        int currArea=1;\\n        set<pair<int,int>> visited;\\n        queue<pair<int,int>> q;\\n        q.push({source[0],source[1]});\\n        visited.insert({source[0],source[1]});\\n        while(!q.empty())\\n        {\\n            int x=q.front().first;\\n            int y=q.front().second;\\n            q.pop();\\n            for(int i=0;i<4;i++)\\n            {\\n                int new_x,new_y;\\n                new_x=x+dx[i];\\n                new_y=y+dy[i];\\n                if(new_x==target[0]&&new_y==target[1])\\n                return true;\\n                if(currArea>maxArea)\\n                return true;\\n                if(new_x>=0&&new_x<1e6&&new_y>=0&&new_y<1e6&&block.find({new_x,new_y})==block.end()&&visited.find({new_x,new_y})==visited.end())\\n                {\\n                    currArea++;\\n                    visited.insert({new_x,new_y});\\n                    q.push({new_x,new_y});\\n                }\\n            }\\n        }\\n        return false; \\n    }\\n    bool isEscapePossible(vector<vector<int>>& blocked, vector<int>& source, vector<int>& target) {\\n        set<pair<int,int>> block;\\n        int count=0;\\n        for(int i=0;i<blocked.size();i++)\\n        {\\n            count++;\\n            block.insert({blocked[i][0],blocked[i][1]});\\n        }\\n        return canReach(source,target,count,block)&&canReach(target,source,count,block);\\n    }\\n};\\n```\\n**Please upvote to motivate me in my quest of documenting all leetcode solutions(to help the community). HAPPY CODING:)\\nAny suggestions and improvements are always welcome**",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    bool canReach(vector<int> &source,vector<int> &target,int numBlocked,set<pair<int,int>> &block)\\n    {\\n        vector<int> dx,dy;\\n        dx={0,0,1,-1};\\n        dy={1,-1,0,0};\\n        int maxArea=numBlocked*(numBlocked-1)/2;\\n        int currArea=1;\\n        set<pair<int,int>> visited;\\n        queue<pair<int,int>> q;\\n        q.push({source[0],source[1]});\\n        visited.insert({source[0],source[1]});\\n        while(!q.empty())\\n        {\\n            int x=q.front().first;\\n            int y=q.front().second;\\n            q.pop();\\n            for(int i=0;i<4;i++)\\n            {\\n                int new_x,new_y;\\n                new_x=x+dx[i];\\n                new_y=y+dy[i];\\n                if(new_x==target[0]&&new_y==target[1])\\n                return true;\\n                if(currArea>maxArea)\\n                return true;\\n                if(new_x>=0&&new_x<1e6&&new_y>=0&&new_y<1e6&&block.find({new_x,new_y})==block.end()&&visited.find({new_x,new_y})==visited.end())\\n                {\\n                    currArea++;\\n                    visited.insert({new_x,new_y});\\n                    q.push({new_x,new_y});\\n                }\\n            }\\n        }\\n        return false; \\n    }\\n    bool isEscapePossible(vector<vector<int>>& blocked, vector<int>& source, vector<int>& target) {\\n        set<pair<int,int>> block;\\n        int count=0;\\n        for(int i=0;i<blocked.size();i++)\\n        {\\n            count++;\\n            block.insert({blocked[i][0],blocked[i][1]});\\n        }\\n        return canReach(source,target,count,block)&&canReach(target,source,count,block);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 773637,
                "title": "python-bfs-from-both-ends-with-escape-condition",
                "content": "Double ended priority queue BFS seems like a good approach to use here.  Start one queue from the target and the other from the source.  Use the closest point reached by either queue as the new target and return True if the paths ever meet.  \\n\\nThe key insight to this problem is the fact that the grid is 10<sup>6</sup> by 10<sup>6</sup> and there is a maximum of 200 blocks.  That said, if we can get at least 200 blocks away from the target **and** at least 200 blocks away from the source, we can be **certain** that 200 blocks cannot prevent the two points from finding a connecting path.  \\n\\nWith this in mind the booleans ```source_escape``` and ```target_escape``` tell us if this condition is met and return True.  This is very helpful in cases such as the second example given in the description.  \\n\\nHope this helps!\\n\\n```python\\ndef isEscapePossible(self, blocked: List[List[int]], source: List[int], target: List[int]) -> bool:\\n\\n\\t#Column and row of source and target (used for escape condition)\\n\\tsc, sr = source\\n\\ttc, tr = target\\n\\tR, C = 10**6, 10**6\\n\\n\\tdef dist(r1,c1,r2,c2):\\n\\t\\t\\'\\'\\'Calculates Manhattan distance from (r1,c1) to (r2,c2)\\'\\'\\'\\n\\t\\treturn abs(r2-r1)+abs(c2-c1)\\n\\t\\n\\t#Two priority queues: one starting from target and one from source\\n\\t#Two visited sets: one for nodes visited by path from target and the other from source\\n\\tq = [[(0,*source[::-1])], [(0,*target[::-1])]]\\n\\tv = [set(),set()]\\n\\tb = set((tuple(b[::-1]) for b in blocked))\\n\\n\\tif (tuple(source) in b) or (tuple(target) in b):\\n\\t\\treturn False\\n\\n\\t#if source and target can reach 200 distance from their origin\\n\\t#it is safe to say 200 blocked spaces cannot contain them\\n\\tsource_escape = False\\n\\ttarget_escape = False\\n\\n\\twhile q[0] and q[1]:\\n\\n\\t\\tindex = 0 if len(q[0]) <= len(q[1]) else 1\\n\\n\\t\\td, r, c = heapq.heappop(q[index])\\n\\n\\t\\tfor i, j in ((r+1, c), (r-1, c), (r, c+1), (r, c-1)):\\n\\t\\t\\tif (0 <= i < R) and (0 <= j < C) and ((i,j) not in b) and ((i,j) not in v[index]):\\n\\n\\t\\t\\t\\tif (i,j) in v[1-index]:\\n\\t\\t\\t\\t\\treturn True\\n\\n\\t\\t\\t\\tv[index].add((i,j))\\n\\t\\t\\t\\tr_target, c_target = q[1-index][0][1:]\\n\\t\\t\\t\\theapq.heappush(q[index], (dist(i,j,r_target,c_target), i, j))\\n\\n\\t\\tif not source_escape and not index:\\n\\t\\t\\tsource_escape = dist(r, c, sr, sc) > 200\\n\\t\\tif not target_escape and index:\\n\\t\\t\\ttarget_escape = dist(r, c, tr, tc) > 200\\n\\n\\t\\tif source_escape and target_escape:\\n\\t\\t\\treturn True\\n\\n\\treturn False\\n```\\n\\nP.S. Here is another problem that I feel is fairly similar to this one if you want to practice double ended BFS: <a href=\"https://leetcode.com/problems/open-the-lock/\">open-the-lock</a>\\n",
                "solutionTags": [],
                "code": "```source_escape```\n```target_escape```\n```python\\ndef isEscapePossible(self, blocked: List[List[int]], source: List[int], target: List[int]) -> bool:\\n\\n\\t#Column and row of source and target (used for escape condition)\\n\\tsc, sr = source\\n\\ttc, tr = target\\n\\tR, C = 10**6, 10**6\\n\\n\\tdef dist(r1,c1,r2,c2):\\n\\t\\t\\'\\'\\'Calculates Manhattan distance from (r1,c1) to (r2,c2)\\'\\'\\'\\n\\t\\treturn abs(r2-r1)+abs(c2-c1)\\n\\t\\n\\t#Two priority queues: one starting from target and one from source\\n\\t#Two visited sets: one for nodes visited by path from target and the other from source\\n\\tq = [[(0,*source[::-1])], [(0,*target[::-1])]]\\n\\tv = [set(),set()]\\n\\tb = set((tuple(b[::-1]) for b in blocked))\\n\\n\\tif (tuple(source) in b) or (tuple(target) in b):\\n\\t\\treturn False\\n\\n\\t#if source and target can reach 200 distance from their origin\\n\\t#it is safe to say 200 blocked spaces cannot contain them\\n\\tsource_escape = False\\n\\ttarget_escape = False\\n\\n\\twhile q[0] and q[1]:\\n\\n\\t\\tindex = 0 if len(q[0]) <= len(q[1]) else 1\\n\\n\\t\\td, r, c = heapq.heappop(q[index])\\n\\n\\t\\tfor i, j in ((r+1, c), (r-1, c), (r, c+1), (r, c-1)):\\n\\t\\t\\tif (0 <= i < R) and (0 <= j < C) and ((i,j) not in b) and ((i,j) not in v[index]):\\n\\n\\t\\t\\t\\tif (i,j) in v[1-index]:\\n\\t\\t\\t\\t\\treturn True\\n\\n\\t\\t\\t\\tv[index].add((i,j))\\n\\t\\t\\t\\tr_target, c_target = q[1-index][0][1:]\\n\\t\\t\\t\\theapq.heappush(q[index], (dist(i,j,r_target,c_target), i, j))\\n\\n\\t\\tif not source_escape and not index:\\n\\t\\t\\tsource_escape = dist(r, c, sr, sc) > 200\\n\\t\\tif not target_escape and index:\\n\\t\\t\\ttarget_escape = dist(r, c, tr, tc) > 200\\n\\n\\t\\tif source_escape and target_escape:\\n\\t\\t\\treturn True\\n\\n\\treturn False\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 296978,
                "title": "c-remap-locations-then-do-bfs",
                "content": "I read some discussions, which use the property that only 200 blocked squares are used:\\nIf the source and target are not trapped by the blocked squares, then they can be connected.\\nIf the source and target are trapped in the same space by the blocked squares, then they can be connected.\\n\\nI used another way: remapping locations to smaller locations. since only 200 blocked squares and 1 source, 1 target are involved. There are 202 locations, thus 202 x values and y values. We can map them to [0, 201]. Of course, we also need to map the gap between locations. So for a x location, x, x-1, x+1 all need to be mapped. Then it creates a atmost [606, 606] square area, which can be scaned in a reasonable time.\\n\\nBelow is the code.\\n\\n```\\nclass Solution {\\npublic:\\n    bool isEscapePossible(vector<vector<int>>& blocked, vector<int>& source, vector<int>& target) {\\n        map<int, int> x_map;\\n        map<int, int> y_map;\\n        for (auto& b : blocked) {\\n            gen_map(b, x_map, y_map);\\n        }\\n        gen_map(source, x_map, y_map);\\n        gen_map(target, x_map, y_map);\\n        int x_size = 0;\\n        for (auto& p : x_map) {\\n            p.second = x_size++;\\n        }\\n        int y_size = 0;\\n        for (auto& p : y_map) {\\n            p.second = y_size++;\\n        }\\n        vector<vector<int>> grid(x_size, vector<int>(y_size, 0));\\n        for (auto& b : blocked) {\\n            int x = x_map[b[0]];\\n            int y = y_map[b[1]];\\n            grid[x][y] = -1;\\n        }\\n        int end_x = x_map[target[0]];\\n        int end_y = y_map[target[1]];\\n        int x = x_map[source[0]];\\n        int y = y_map[source[1]];\\n        queue<pair<int, int>> q;\\n        q.push(make_pair(x, y));\\n        if (x == end_x && y == end_y) return true;\\n        grid[x][y] = 1;\\n        int dx[4] = {0, 0, -1, 1};\\n        int dy[4] = {-1, 1, 0, 0};\\n        while (!q.empty()) {\\n            x = q.front().first;\\n            y = q.front().second;\\n            q.pop();\\n            for (int i = 0; i < 4; i++) {\\n                int nx = x + dx[i];\\n                int ny = y + dy[i];\\n                if (nx < 0 || nx >= x_size || ny < 0 || ny >= y_size) {\\n                    continue;\\n                }\\n                if (nx == end_x && ny == end_y) return true;\\n                if (grid[nx][ny] != 0) {\\n                    continue;\\n                }\\n                grid[nx][ny] = 1;\\n                q.push(make_pair(nx, ny));\\n            }\\n        }\\n        return false;\\n    }\\n    \\n    void gen_map(const vector<int>& p, map<int, int>& x, map<int, int>& y) {\\n        if (p[0] > 0) {\\n            x[p[0] - 1] = 0;\\n        }\\n        x[p[0]] = 0;\\n        if (p[0] + 1 < 1000000) {\\n            x[p[0] + 1] = 0;\\n        }\\n        if (p[1] > 0) {\\n            y[p[1] - 1] = 0;\\n        }\\n        y[p[1]] = 0;\\n        if (p[1] + 1 < 1000000) {\\n            y[p[1] + 1] = 0;\\n        }\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    bool isEscapePossible(vector<vector<int>>& blocked, vector<int>& source, vector<int>& target) {\\n        map<int, int> x_map;\\n        map<int, int> y_map;\\n        for (auto& b : blocked) {\\n            gen_map(b, x_map, y_map);\\n        }\\n        gen_map(source, x_map, y_map);\\n        gen_map(target, x_map, y_map);\\n        int x_size = 0;\\n        for (auto& p : x_map) {\\n            p.second = x_size++;\\n        }\\n        int y_size = 0;\\n        for (auto& p : y_map) {\\n            p.second = y_size++;\\n        }\\n        vector<vector<int>> grid(x_size, vector<int>(y_size, 0));\\n        for (auto& b : blocked) {\\n            int x = x_map[b[0]];\\n            int y = y_map[b[1]];\\n            grid[x][y] = -1;\\n        }\\n        int end_x = x_map[target[0]];\\n        int end_y = y_map[target[1]];\\n        int x = x_map[source[0]];\\n        int y = y_map[source[1]];\\n        queue<pair<int, int>> q;\\n        q.push(make_pair(x, y));\\n        if (x == end_x && y == end_y) return true;\\n        grid[x][y] = 1;\\n        int dx[4] = {0, 0, -1, 1};\\n        int dy[4] = {-1, 1, 0, 0};\\n        while (!q.empty()) {\\n            x = q.front().first;\\n            y = q.front().second;\\n            q.pop();\\n            for (int i = 0; i < 4; i++) {\\n                int nx = x + dx[i];\\n                int ny = y + dy[i];\\n                if (nx < 0 || nx >= x_size || ny < 0 || ny >= y_size) {\\n                    continue;\\n                }\\n                if (nx == end_x && ny == end_y) return true;\\n                if (grid[nx][ny] != 0) {\\n                    continue;\\n                }\\n                grid[nx][ny] = 1;\\n                q.push(make_pair(nx, ny));\\n            }\\n        }\\n        return false;\\n    }\\n    \\n    void gen_map(const vector<int>& p, map<int, int>& x, map<int, int>& y) {\\n        if (p[0] > 0) {\\n            x[p[0] - 1] = 0;\\n        }\\n        x[p[0]] = 0;\\n        if (p[0] + 1 < 1000000) {\\n            x[p[0] + 1] = 0;\\n        }\\n        if (p[1] > 0) {\\n            y[p[1] - 1] = 0;\\n        }\\n        y[p[1]] = 0;\\n        if (p[1] + 1 < 1000000) {\\n            y[p[1] + 1] = 0;\\n        }\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1464281,
                "title": "perform-partial-bfs-from-source-and-target-cells",
                "content": "Cant do normal DFS/BFS traversal as the possible size of the visited array would be 10^12 = ~1TB.\\n\\nOne of the noticeable constraint is \"only 200 blocks possible\".\\nThat leads me to a hint: if I can possibly perform BFS upto ~200 radius both from source and target cells,\\nit means that blockers cannot block both source and target cells and both are reachable!\\n\\n```\\n    private static long M = 1000000;    \\n    private int[][] DIRS = new int[][]{{1, 0}, {-1, 0}, {0, -1}, {0, 1}};\\n\\n    public boolean isEscapePossible(int[][] blocked, int[] source, int[] target) {\\n\\n        // if no blokers, simply return true.\\n        if(blocked.length == 0) return true;\\n\\n        Set<Long> visited1 = new HashSet<>(); \\n        Set<Long> visited2 = new HashSet<>();\\n        for(int[] b:blocked) {\\n            visited1.add((long)b[0]*M+b[1]);\\n            visited2.add((long)b[0]*M+b[1]);\\n        }\\n\\n        // check if I can traverse from both source and target for atleast 200 radius\\n        return bfs(visited1, source, target) && bfs(visited2, target, source);\\n    }\\n\\n    private boolean bfs(Set<Long> visited, int[] src, int[] dst) {\\n        Queue<int[]> q = new LinkedList<>();\\n        long startCell = (long)src[0]*M+src[1];\\n        q.offer(src);\\n\\n        long rowULimit = Math.min(M-1, src[0]+200);\\n        long rowLLimit = Math.max(0, src[0]-200);\\n        long colULimit = Math.min(M-1, src[1]+200);\\n        long colLLimit = Math.max(0, src[1]-200);        \\n\\n        int radius = 0;\\n        while(!q.isEmpty()) {\\n\\n            // if I can go beyond radius 200, it seems I can reach a point beyond possible blockers\\n            if(radius > 200) return true;\\n\\n            int size = q.size();\\n            while(size > 0) {\\n                size--;\\n                int[] curCell = q.poll();\\n\\n                // did i reach target?\\n                if(curCell[0] == dst[0] && curCell[1] == dst[1]) return true;\\n\\n                for(int[] dir : DIRS) {\\n                    int nextRow = curCell[0]+dir[0]; int nextCol = curCell[1]+dir[1];\\n                    if(nextRow >= rowLLimit && nextRow < rowULimit && \\n                      nextCol >= colLLimit && nextCol< colULimit) {\\n                        long nextCell = nextRow*M+nextCol;\\n                        if(!visited.contains(nextCell)) {\\n                            visited.add(nextCell);\\n                            q.offer(new int[] {nextRow, nextCol});\\n                        }\\n                    }\\n                }\\n            }\\n            radius++;\\n        }\\n        return false;        \\n    }\\n",
                "solutionTags": [
                    "Breadth-First Search"
                ],
                "code": "Cant do normal DFS/BFS traversal as the possible size of the visited array would be 10^12 = ~1TB.\\n\\nOne of the noticeable constraint is \"only 200 blocks possible\".\\nThat leads me to a hint: if I can possibly perform BFS upto ~200 radius both from source and target cells,\\nit means that blockers cannot block both source and target cells and both are reachable!\\n\\n```\\n    private static long M = 1000000;    \\n    private int[][] DIRS = new int[][]{{1, 0}, {-1, 0}, {0, -1}, {0, 1}};\\n\\n    public boolean isEscapePossible(int[][] blocked, int[] source, int[] target) {\\n\\n        // if no blokers, simply return true.\\n        if(blocked.length == 0) return true;\\n\\n        Set<Long> visited1 = new HashSet<>(); \\n        Set<Long> visited2 = new HashSet<>();\\n        for(int[] b:blocked) {\\n            visited1.add((long)b[0]*M+b[1]);\\n            visited2.add((long)b[0]*M+b[1]);\\n        }\\n\\n        // check if I can traverse from both source and target for atleast 200 radius\\n        return bfs(visited1, source, target) && bfs(visited2, target, source);\\n    }\\n\\n    private boolean bfs(Set<Long> visited, int[] src, int[] dst) {\\n        Queue<int[]> q = new LinkedList<>();\\n        long startCell = (long)src[0]*M+src[1];\\n        q.offer(src);\\n\\n        long rowULimit = Math.min(M-1, src[0]+200);\\n        long rowLLimit = Math.max(0, src[0]-200);\\n        long colULimit = Math.min(M-1, src[1]+200);\\n        long colLLimit = Math.max(0, src[1]-200);        \\n\\n        int radius = 0;\\n        while(!q.isEmpty()) {\\n\\n            // if I can go beyond radius 200, it seems I can reach a point beyond possible blockers\\n            if(radius > 200) return true;\\n\\n            int size = q.size();\\n            while(size > 0) {\\n                size--;\\n                int[] curCell = q.poll();\\n\\n                // did i reach target?\\n                if(curCell[0] == dst[0] && curCell[1] == dst[1]) return true;\\n\\n                for(int[] dir : DIRS) {\\n                    int nextRow = curCell[0]+dir[0]; int nextCol = curCell[1]+dir[1];\\n                    if(nextRow >= rowLLimit && nextRow < rowULimit && \\n                      nextCol >= colLLimit && nextCol< colULimit) {\\n                        long nextCell = nextRow*M+nextCol;\\n                        if(!visited.contains(nextCell)) {\\n                            visited.add(nextCell);\\n                            q.offer(new int[] {nextRow, nextCol});\\n                        }\\n                    }\\n                }\\n            }\\n            radius++;\\n        }\\n        return false;        \\n    }\\n",
                "codeTag": "Unknown"
            },
            {
                "id": 282914,
                "title": "reduce-maze-to-just-populated-coordinates-and-then-do-a-regular-dp-maze-search",
                "content": "At most we have 200 X coordinates and 200 Y coordinates that are in use.\\nIf they aren\\'t next to each other then they could be separated by 100k empty coordinate rows/columns or 1 empty row/col, it doesn\\'t matter.\\nSo, first collect all used coordinates, then create a maze grid that only contains the used rows/columns and the ones between them.\\nMap the source, target and blocks from the original 0-1,000,000 coordinate space to the new 0-400 coordinate space and create a new maze based on the mapped coordinates.\\nWe end up with a more manageable 400x400 grid to do a typical DP solution to find a path from source to dest.\\n\\n```\\nclass Solution {\\n    static final int EMPTY = 0;\\n    static final int MARKED = 1;\\n    static final int TARGET = 2;\\n    static final int BLOCK = 3;\\n\\n    int grid[][];\\n    int list[];\\n    int nummarked, numX, numY;\\n\\n    public boolean isEscapePossible(int[][] blocked, int[] source, int[] target) {\\n        makeGrid(blocked, source, target);\\n        for (int i = 0; i < nummarked; i++) {\\n            int xy = list[i];\\n            int x = xy / numY;\\n            int y = xy - x * numY;\\n            if (mark(x-1, y) || mark(x+1, y) || mark(x, y-1) || mark(x, y+1)) return true;\\n        }\\n        return false;\\n    }\\n\\n    boolean mark(int x, int y) {\\n        if (x >= 0 && x < numX && y >= 0 && y < numY) {\\n            if (grid[x][y] == EMPTY) {\\n                grid[x][y] = MARKED;\\n                list[nummarked++] = x * numY + y;\\n            } else if (grid[x][y] == TARGET) {\\n                return true;\\n            }\\n        }\\n        return false;\\n    }\\n\\n    void makeGrid(int[][] blocked, int[] source, int[] target) {\\n        int coords[] = new int[blocked.length + 2];\\n        Map<Integer,Integer> Xmap = reduce(blocked, source, target, coords, 0);\\n        Map<Integer,Integer> Ymap = reduce(blocked, source, target, coords, 1);\\n        numX = Xmap.size();\\n        numY = Ymap.size();\\n        grid = new int[numX][numY];\\n        list = new int[numX * numY];\\n        for (int[] block : blocked) {\\n            grid[Xmap.get(block[0])][Ymap.get(block[1])] = BLOCK;\\n        }\\n        grid[Xmap.get(target[0])][Ymap.get(target[1])] = TARGET;\\n        mark(Xmap.get(source[0]), Ymap.get(source[1]));\\n    }\\n\\n    Map<Integer,Integer> reduce(int[][] blocked, int[] source, int[] target, int[] coords, int index) {\\n        int i = 0;\\n        coords[i++] = source[index];\\n        coords[i++] = target[index];\\n        for (int[] block : blocked) {\\n            coords[i++] = block[index];\\n        }\\n        Arrays.sort(coords);\\n        Map<Integer,Integer> map = new HashMap<>();\\n        int j = 0;\\n        int prev = -1;\\n        for (i = 0; i < coords.length; i++) {\\n            int cur = coords[i];\\n            if (cur > prev) {\\n                if (cur - 1 > prev) map.put(cur - 1, j++);\\n                map.put(cur, j++);\\n                prev = cur;\\n            }\\n        }\\n        if (prev < 1_000_000) map.put(1_000_000, j++);\\n        return map;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    static final int EMPTY = 0;\\n    static final int MARKED = 1;\\n    static final int TARGET = 2;\\n    static final int BLOCK = 3;\\n\\n    int grid[][];\\n    int list[];\\n    int nummarked, numX, numY;\\n\\n    public boolean isEscapePossible(int[][] blocked, int[] source, int[] target) {\\n        makeGrid(blocked, source, target);\\n        for (int i = 0; i < nummarked; i++) {\\n            int xy = list[i];\\n            int x = xy / numY;\\n            int y = xy - x * numY;\\n            if (mark(x-1, y) || mark(x+1, y) || mark(x, y-1) || mark(x, y+1)) return true;\\n        }\\n        return false;\\n    }\\n\\n    boolean mark(int x, int y) {\\n        if (x >= 0 && x < numX && y >= 0 && y < numY) {\\n            if (grid[x][y] == EMPTY) {\\n                grid[x][y] = MARKED;\\n                list[nummarked++] = x * numY + y;\\n            } else if (grid[x][y] == TARGET) {\\n                return true;\\n            }\\n        }\\n        return false;\\n    }\\n\\n    void makeGrid(int[][] blocked, int[] source, int[] target) {\\n        int coords[] = new int[blocked.length + 2];\\n        Map<Integer,Integer> Xmap = reduce(blocked, source, target, coords, 0);\\n        Map<Integer,Integer> Ymap = reduce(blocked, source, target, coords, 1);\\n        numX = Xmap.size();\\n        numY = Ymap.size();\\n        grid = new int[numX][numY];\\n        list = new int[numX * numY];\\n        for (int[] block : blocked) {\\n            grid[Xmap.get(block[0])][Ymap.get(block[1])] = BLOCK;\\n        }\\n        grid[Xmap.get(target[0])][Ymap.get(target[1])] = TARGET;\\n        mark(Xmap.get(source[0]), Ymap.get(source[1]));\\n    }\\n\\n    Map<Integer,Integer> reduce(int[][] blocked, int[] source, int[] target, int[] coords, int index) {\\n        int i = 0;\\n        coords[i++] = source[index];\\n        coords[i++] = target[index];\\n        for (int[] block : blocked) {\\n            coords[i++] = block[index];\\n        }\\n        Arrays.sort(coords);\\n        Map<Integer,Integer> map = new HashMap<>();\\n        int j = 0;\\n        int prev = -1;\\n        for (i = 0; i < coords.length; i++) {\\n            int cur = coords[i];\\n            if (cur > prev) {\\n                if (cur - 1 > prev) map.put(cur - 1, j++);\\n                map.put(cur, j++);\\n                prev = cur;\\n            }\\n        }\\n        if (prev < 1_000_000) map.put(1_000_000, j++);\\n        return map;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 506392,
                "title": "fastest-c-solution-that-is-easy-to-undestand-4-ms",
                "content": "Here is the idea: Start from S point and using BFS try to move away at least 200 points. If you did, you can escape S point. But End point maybe blocked. If you escaped S point, reverse S and E points and try move away from E point at least 200 units. If you escaped - free roam on the rest of your maze.\\n```\\nclass Solution {\\n\\n\\tint y_len;\\n\\tint x_len;\\n\\n\\t// x down, y right.  Top left is 0,0, bottom right is 4,4\\n\\tmap<int, map<int, bool> > m_Visited;\\n\\tint dist;\\n\\tlist< pair<int, int> > m_Queue;\\n\\tpair<int, int>      _end;\\n\\tpair<int, int>      _start;\\n\\n\\tset < pair<int, int> > _block;\\npublic:\\n\\tbool isEscapePossible(vector<vector<int>>& blocked, vector<int>& start, vector<int>& target)\\n\\t{\\n\\t\\tbool res = false;\\n\\n\\t\\tx_len = 1000000;\\n\\t\\ty_len = 1000000;\\n\\n\\t\\tm_Visited[start[0]][start[1]] = true;\\n\\t\\t_start = pair<int, int>(start[0], start[1]);\\n\\t\\t_end = pair<int, int>(target[0], target[1]);\\n\\n\\t\\tfor (const vector<int> & p : blocked)\\n\\t\\t{\\n\\t\\t\\tpair<int, int> t = pair<int, int>(p[0], p[1]);\\n\\t\\t\\t_block.insert(t);\\n\\t\\t}\\n\\n\\t\\tm_Queue.push_front(_start);\\n\\t\\tres = makeMoves(_start);\\n\\n\\t\\tif (res)\\n\\t\\t{\\n\\t\\t\\tprintf(\"%s\", \"\\\\n\");\\n\\t\\t\\tm_Queue.clear();\\n\\t\\t\\tm_Queue.push_front(_end);\\n\\t\\t\\tres = makeMoves(_end);\\n\\t\\t}\\n\\t\\treturn res;\\n\\t}\\n\\tbool makeMoves(pair<int, int>  & to)\\n\\t{\\n\\t\\tbool res = false;\\n\\t\\twhile (m_Queue.size() && res == false)\\n\\t\\t{\\n\\t\\t\\tpair<int, int> & _from = *m_Queue.begin();\\n\\t\\t\\tres = MoveOne(_from, to, \\'l\\') ||\\n\\t\\t\\t\\tMoveOne(_from, to, \\'u\\') ||\\n\\t\\t\\t\\tMoveOne(_from, to, \\'d\\') ||\\n\\t\\t\\t\\tMoveOne(_from, to, \\'r\\');\\n\\t\\t\\tm_Queue.pop_front();\\n\\t\\t}\\n\\t\\treturn res;\\n\\t}\\n\\tbool MoveOne(pair<int, int> & from, pair<int, int> to, char pos)\\n\\t{\\n\\t\\tbool res = false;\\n\\t\\tint idy = from.second;\\n\\t\\tint idx = from.first;\\n\\n\\t\\tpair<int, int> & end = (to == _start) ? _end : _start;\\n\\n\\t\\tbool bMoved = false;\\n\\t\\tswitch (pos)\\n\\t\\t{\\n\\t\\tcase \\'l\\':\\n\\t\\t\\twhile (maze(idx - 1, idy) != 1 && abs(from.first - idx) <= 200)\\n\\t\\t\\t{\\n\\t\\t\\t\\tidx--;\\n\\t\\t\\t\\tbMoved = true;\\n\\t\\t\\t}\\n\\t\\t\\tbreak;\\n\\t\\tcase \\'r\\':\\n\\t\\t\\twhile (maze(idx + 1, idy) != 1 && abs(from.first - idx) <= 200)\\n\\t\\t\\t{\\n\\t\\t\\t\\tidx++;\\n\\t\\t\\t\\tbMoved = true;\\n\\t\\t\\t}\\n\\t\\t\\tbreak;\\n\\t\\tcase \\'u\\':\\n\\t\\t\\twhile (maze(idx, idy + 1) != 1 && abs(from.second - idy) <= 200)\\n\\t\\t\\t{\\n\\t\\t\\t\\tidy++;\\n\\t\\t\\t\\tbMoved = true;\\n\\t\\t\\t}\\n\\t\\t\\tbreak;\\n\\t\\tcase \\'d\\':\\n\\t\\t\\twhile (maze(idx, idy - 1) != 1 && abs(from.second - idy) <= 200)\\n\\t\\t\\t{\\n\\t\\t\\t\\tidy--;\\n\\t\\t\\t\\tbMoved = true;\\n\\t\\t\\t}\\n\\t\\t\\tbreak;\\n\\t\\t}\\n\\n\\t\\tpair<int, int> new_pos = pair<int, int>(idx, idy);\\n\\t\\tint current_dist = getDistance(new_pos, to);\\n\\t\\tif (bMoved &&\\n\\t\\t\\tm_Visited[idx][idy] == false &&\\n\\t\\t\\tcurrent_dist <= 200)\\n\\t\\t{\\n\\t\\t\\tm_Queue.push_back(new_pos);\\n\\t\\t\\tm_Visited[idx][idy] = true;\\n\\t\\t\\t//printf(\" (%d,%d), %c, dist %d\\\\n\", idx,idy, pos, getDistance ( new_pos, to ) );\\n\\t\\t}\\n\\t\\tif (current_dist > 200 || new_pos == end)\\n\\t\\t{\\n\\t\\t\\tres = true;\\n\\t\\t\\tprintf(\"%s\", \"escape\");\\n\\t\\t}\\n\\t\\treturn res;\\n\\t}\\n\\tint maze(int x, int y)\\n\\t{\\n\\t\\tif (x < 0) return 1;\\n\\t\\telse if (x > 1000000) return 1;\\n\\t\\tif (y < 0) return 1;\\n\\t\\telse if (y > 1000000) return 1;\\n\\t\\tpair<int, int> xy = pair<int, int>(x, y);\\n\\t\\tif (_block.find(xy) != _block.end())\\n\\t\\t\\treturn 1;\\n\\t\\treturn 0;\\n\\t}\\n\\tint getDistance(pair<int, int> &one, pair<int, int> & two)\\n\\t{\\n\\t\\tint xdist = abs(one.first - two.first);\\n\\t\\tint ydist = abs(one.second - two.second);\\n\\t\\tint dist = sqrt(xdist*xdist + ydist*ydist);\\n\\t\\treturn dist;\\n\\t}\\n\\tint max(int a, int b)\\n\\t{\\n\\t\\treturn a >= b ? a : b;\\n\\t}\\n};\\n\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n\\n\\tint y_len;\\n\\tint x_len;\\n\\n\\t// x down, y right.  Top left is 0,0, bottom right is 4,4\\n\\tmap<int, map<int, bool> > m_Visited;\\n\\tint dist;\\n\\tlist< pair<int, int> > m_Queue;\\n\\tpair<int, int>      _end;\\n\\tpair<int, int>      _start;\\n\\n\\tset < pair<int, int> > _block;\\npublic:\\n\\tbool isEscapePossible(vector<vector<int>>& blocked, vector<int>& start, vector<int>& target)\\n\\t{\\n\\t\\tbool res = false;\\n\\n\\t\\tx_len = 1000000;\\n\\t\\ty_len = 1000000;\\n\\n\\t\\tm_Visited[start[0]][start[1]] = true;\\n\\t\\t_start = pair<int, int>(start[0], start[1]);\\n\\t\\t_end = pair<int, int>(target[0], target[1]);\\n\\n\\t\\tfor (const vector<int> & p : blocked)\\n\\t\\t{\\n\\t\\t\\tpair<int, int> t = pair<int, int>(p[0], p[1]);\\n\\t\\t\\t_block.insert(t);\\n\\t\\t}\\n\\n\\t\\tm_Queue.push_front(_start);\\n\\t\\tres = makeMoves(_start);\\n\\n\\t\\tif (res)\\n\\t\\t{\\n\\t\\t\\tprintf(\"%s\", \"\\\\n\");\\n\\t\\t\\tm_Queue.clear();\\n\\t\\t\\tm_Queue.push_front(_end);\\n\\t\\t\\tres = makeMoves(_end);\\n\\t\\t}\\n\\t\\treturn res;\\n\\t}\\n\\tbool makeMoves(pair<int, int>  & to)\\n\\t{\\n\\t\\tbool res = false;\\n\\t\\twhile (m_Queue.size() && res == false)\\n\\t\\t{\\n\\t\\t\\tpair<int, int> & _from = *m_Queue.begin();\\n\\t\\t\\tres = MoveOne(_from, to, \\'l\\') ||\\n\\t\\t\\t\\tMoveOne(_from, to, \\'u\\') ||\\n\\t\\t\\t\\tMoveOne(_from, to, \\'d\\') ||\\n\\t\\t\\t\\tMoveOne(_from, to, \\'r\\');\\n\\t\\t\\tm_Queue.pop_front();\\n\\t\\t}\\n\\t\\treturn res;\\n\\t}\\n\\tbool MoveOne(pair<int, int> & from, pair<int, int> to, char pos)\\n\\t{\\n\\t\\tbool res = false;\\n\\t\\tint idy = from.second;\\n\\t\\tint idx = from.first;\\n\\n\\t\\tpair<int, int> & end = (to == _start) ? _end : _start;\\n\\n\\t\\tbool bMoved = false;\\n\\t\\tswitch (pos)\\n\\t\\t{\\n\\t\\tcase \\'l\\':\\n\\t\\t\\twhile (maze(idx - 1, idy) != 1 && abs(from.first - idx) <= 200)\\n\\t\\t\\t{\\n\\t\\t\\t\\tidx--;\\n\\t\\t\\t\\tbMoved = true;\\n\\t\\t\\t}\\n\\t\\t\\tbreak;\\n\\t\\tcase \\'r\\':\\n\\t\\t\\twhile (maze(idx + 1, idy) != 1 && abs(from.first - idx) <= 200)\\n\\t\\t\\t{\\n\\t\\t\\t\\tidx++;\\n\\t\\t\\t\\tbMoved = true;\\n\\t\\t\\t}\\n\\t\\t\\tbreak;\\n\\t\\tcase \\'u\\':\\n\\t\\t\\twhile (maze(idx, idy + 1) != 1 && abs(from.second - idy) <= 200)\\n\\t\\t\\t{\\n\\t\\t\\t\\tidy++;\\n\\t\\t\\t\\tbMoved = true;\\n\\t\\t\\t}\\n\\t\\t\\tbreak;\\n\\t\\tcase \\'d\\':\\n\\t\\t\\twhile (maze(idx, idy - 1) != 1 && abs(from.second - idy) <= 200)\\n\\t\\t\\t{\\n\\t\\t\\t\\tidy--;\\n\\t\\t\\t\\tbMoved = true;\\n\\t\\t\\t}\\n\\t\\t\\tbreak;\\n\\t\\t}\\n\\n\\t\\tpair<int, int> new_pos = pair<int, int>(idx, idy);\\n\\t\\tint current_dist = getDistance(new_pos, to);\\n\\t\\tif (bMoved &&\\n\\t\\t\\tm_Visited[idx][idy] == false &&\\n\\t\\t\\tcurrent_dist <= 200)\\n\\t\\t{\\n\\t\\t\\tm_Queue.push_back(new_pos);\\n\\t\\t\\tm_Visited[idx][idy] = true;\\n\\t\\t\\t//printf(\" (%d,%d), %c, dist %d\\\\n\", idx,idy, pos, getDistance ( new_pos, to ) );\\n\\t\\t}\\n\\t\\tif (current_dist > 200 || new_pos == end)\\n\\t\\t{\\n\\t\\t\\tres = true;\\n\\t\\t\\tprintf(\"%s\", \"escape\");\\n\\t\\t}\\n\\t\\treturn res;\\n\\t}\\n\\tint maze(int x, int y)\\n\\t{\\n\\t\\tif (x < 0) return 1;\\n\\t\\telse if (x > 1000000) return 1;\\n\\t\\tif (y < 0) return 1;\\n\\t\\telse if (y > 1000000) return 1;\\n\\t\\tpair<int, int> xy = pair<int, int>(x, y);\\n\\t\\tif (_block.find(xy) != _block.end())\\n\\t\\t\\treturn 1;\\n\\t\\treturn 0;\\n\\t}\\n\\tint getDistance(pair<int, int> &one, pair<int, int> & two)\\n\\t{\\n\\t\\tint xdist = abs(one.first - two.first);\\n\\t\\tint ydist = abs(one.second - two.second);\\n\\t\\tint dist = sqrt(xdist*xdist + ydist*ydist);\\n\\t\\treturn dist;\\n\\t}\\n\\tint max(int a, int b)\\n\\t{\\n\\t\\treturn a >= b ? a : b;\\n\\t}\\n};\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 283932,
                "title": "java-dfs-solution-with-triangle-limit",
                "content": "I fixed the bug from https://leetcode.com/problems/escape-a-large-maze/discuss/282889/My-Java-DFS-Solution-with-Some-Thoughts-(Triangle-v.s.-14-Circle-in-Pixels).\\n```\\nclass Solution {\\n    final int MAX_VISIT = 20000;\\n\\t\\n    public boolean isEscapePossible(int[][] blocked, int[] source, int[] target) {\\n        Set<String> blockedSet = new HashSet<>();\\n        for (int[] ij : blocked) {\\n            String key = ij[0] + \",\" + ij[1];\\n            blockedSet.add(key);\\n        }\\n        return canVisit(blockedSet, source, target) && canVisit(blockedSet, target, source);\\n    }\\n    \\n    boolean canVisit(Set<String> blocked, int[] start, int[] end) {\\n        Set<String> visited = new HashSet<>();\\n        return dfs(blocked, start[0], start[1], end[0], end[1], visited);\\n    }\\n    \\n    boolean dfs(Set<String> blocked, int i, int j, int m, int n, Set<String> visited) {\\n        visited.add(i + \",\" + j);\\n        if (i == m && j == n || visited.size() >= MAX_VISIT) { return true; }\\n        for (int[] next : new int[][] {{i-1 ,j}, {i+1, j}, {i, j-1}, {i, j+1}}) {\\n            String nextKey = next[0] + \",\" + next[1];\\n            if (next[0] >= 0 && next[1] >= 0 && next[0] < 1e6 && next[1] < 1e6 && !blocked.contains(nextKey) && !visited.contains(nextKey)) {\\n                if (dfs(blocked, next[0], next[1], m, n, visited)) { return true; }\\n            }\\n        }\\n        return false;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Depth-First Search"
                ],
                "code": "```\\nclass Solution {\\n    final int MAX_VISIT = 20000;\\n\\t\\n    public boolean isEscapePossible(int[][] blocked, int[] source, int[] target) {\\n        Set<String> blockedSet = new HashSet<>();\\n        for (int[] ij : blocked) {\\n            String key = ij[0] + \",\" + ij[1];\\n            blockedSet.add(key);\\n        }\\n        return canVisit(blockedSet, source, target) && canVisit(blockedSet, target, source);\\n    }\\n    \\n    boolean canVisit(Set<String> blocked, int[] start, int[] end) {\\n        Set<String> visited = new HashSet<>();\\n        return dfs(blocked, start[0], start[1], end[0], end[1], visited);\\n    }\\n    \\n    boolean dfs(Set<String> blocked, int i, int j, int m, int n, Set<String> visited) {\\n        visited.add(i + \",\" + j);\\n        if (i == m && j == n || visited.size() >= MAX_VISIT) { return true; }\\n        for (int[] next : new int[][] {{i-1 ,j}, {i+1, j}, {i, j-1}, {i, j+1}}) {\\n            String nextKey = next[0] + \",\" + next[1];\\n            if (next[0] >= 0 && next[1] >= 0 && next[0] < 1e6 && next[1] < 1e6 && !blocked.contains(nextKey) && !visited.contains(nextKey)) {\\n                if (dfs(blocked, next[0], next[1], m, n, visited)) { return true; }\\n            }\\n        }\\n        return false;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3631149,
                "title": "c-uses-dfs-w-r-t-manhattan-distance-unordered-set-over-pairs",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nThe  Manhattan distance ($L_1$-norm) between two points $(x_0, y_0), (x,y)$is given by\\n$$\\nL_1((x_0, y_0), (x,y))=|x-x_0|+|y-y_0|.\\n$$\\nIt is important to note that when considering the \"circle\" shape using Manhattan distance, it is actually represented by a diamond or an equilateral quadrilateral. Given that there are at most $B=200$ blocked grids, you can employ either DFS (Depth-First Search) or BFS (Breadth-First Search) to solve this maze with a size of 1M^2. The search can be limited to visiting a maximum of $B(B+1)/2$ grids or extending up to a Manhattan distance from the initial point that is greater than or equal to $B$.\\n\\nDFS with respect to Manhattan distance is significantly faster than DFS with respect to the size of the visited grid. \\n\\nThe hash set can be implemented using either C++ unordered_set or (ordered) set. While the theoretical time complexity for searching and inserting elements in C++ set is O(log m), which is slower than the O(1) time complexity of unordered_set, in practice, set can be faster.\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n//Use unordered_set over pair with own Hash & DFS w.r.t Manhattan distance\\nclass Solution {\\npublic:\\n    struct MyHash\\n    {\\n        size_t operator()(const pair<int, int>& x) const\\n        {\\n            hash<int> f;\\n            size_t digest=f((x.first<<3)^(x.second));\\n            return digest; \\n        }\\n    };\\n    unordered_set<pair<int, int>, MyHash> Blocked, Visit;\\n    bool dfs(int i, int j, int i0, int j0, int t_i, int t_j ){\\n        if (i==t_i && j==t_j) return true;\\n        int d=abs(i-i0)+abs(j-j0);\\n    //    cout<<\"(\"<<i<<\",\"<<j<<\") d=\"<<d<<endl;\\n        if (d>=200) return true;\\n        Visit.insert({i, j});\\n        vector<pair<int, int>> adj={{i+1,j},{i, j+1},{i-1,j}, {i, j-1}};  \\n        for(auto& [a, b]: adj){\\n            if (a>=0 && a<1e6 && b>=0 && b<1e6 &&\\n            Visit.count({a, b})==0 && Blocked.count({a, b})==0)\\n            {\\n                if (dfs(a, b, i0, j0, t_i, t_j)) return true;\\n            }\\n        }\\n        return false;\\n    }\\n\\n    bool isEscapePossible(vector<vector<int>>& blocked, vector<int>& source, vector<int>& target) \\n    {\\n        for (vector<int>& B: blocked){\\n            Blocked.insert({B[0], B[1]});\\n        }\\n        bool a=dfs(source[0], source[1], source[0], source[1],target[0], target[1]);\\n     //   cout<<\"========\\\\n\";\\n        Visit.clear();\\n        bool b=dfs(target[0], target[1], target[0], target[1], source[0], source[1]);\\n        return a && b;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Hash Table",
                    "Depth-First Search"
                ],
                "code": "```\\n//Use unordered_set over pair with own Hash & DFS w.r.t Manhattan distance\\nclass Solution {\\npublic:\\n    struct MyHash\\n    {\\n        size_t operator()(const pair<int, int>& x) const\\n        {\\n            hash<int> f;\\n            size_t digest=f((x.first<<3)^(x.second));\\n            return digest; \\n        }\\n    };\\n    unordered_set<pair<int, int>, MyHash> Blocked, Visit;\\n    bool dfs(int i, int j, int i0, int j0, int t_i, int t_j ){\\n        if (i==t_i && j==t_j) return true;\\n        int d=abs(i-i0)+abs(j-j0);\\n    //    cout<<\"(\"<<i<<\",\"<<j<<\") d=\"<<d<<endl;\\n        if (d>=200) return true;\\n        Visit.insert({i, j});\\n        vector<pair<int, int>> adj={{i+1,j},{i, j+1},{i-1,j}, {i, j-1}};  \\n        for(auto& [a, b]: adj){\\n            if (a>=0 && a<1e6 && b>=0 && b<1e6 &&\\n            Visit.count({a, b})==0 && Blocked.count({a, b})==0)\\n            {\\n                if (dfs(a, b, i0, j0, t_i, t_j)) return true;\\n            }\\n        }\\n        return false;\\n    }\\n\\n    bool isEscapePossible(vector<vector<int>>& blocked, vector<int>& source, vector<int>& target) \\n    {\\n        for (vector<int>& B: blocked){\\n            Blocked.insert({B[0], B[1]});\\n        }\\n        bool a=dfs(source[0], source[1], source[0], source[1],target[0], target[1]);\\n     //   cout<<\"========\\\\n\";\\n        Visit.clear();\\n        bool b=dfs(target[0], target[1], target[0], target[1], source[0], source[1]);\\n        return a && b;\\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 287111,
                "title": "c-8mm-11mb-solution-tracing-chains-of-blocks",
                "content": "This code is quite complex compared to other approaches (and I definitely couldn\\'t have written this during the contest), but I thought it would be worth posting here because I\\'m not seeing anyone else using this technique.\\n\\nThe algorithm traverses all chains of blocks (connected 8-directionally) until they collide with themselves or with the wall. In the meantime it records additional information when the chain passes the source and / or target coordinates in either dimension.\\n\\nA complete chain can either:\\n* start and end at a wall (and the code adds some blocks embedded in the walls to make this more natural); or\\n* float freely, forming a loop (biting its own tail).\\n\\nWhen a complete chain is found, the algorithm checks whether that chain effectively blocks source from target using the recorded \"Pass\" / \"Relation\" information:\\n* Imagine source and target sending out \\'beams\\', horizontally and vertically.\\n* If a complete chain crosses beams for both source and target: It blocks if and only if it passed one of them \\'clockwise\\' and the other \\'counterclockwise\\'.\\n* If a complete chain crosses three or four beams of source or target, but not both: It blocks.\\n* If a complete chain crosses two beams of source or target, but not both: It may block, depending on which beams, and the relative source and target coordinates.\\n* Otherwise, the chain does not block.\\n\\nKeeping track of those passes (beam crosses) requires a bit of extra bookkeeping. When a chain crosses a beam in one direction, and then turns back to cross it again in the opposite direction, the two cancel each other out. But when it makes a loop around all four beams, they stack up.\\n\\n```\\n////////// Direction //////////\\n\\nstruct Direction {\\n  int x;\\n  int y;\\n};\\n\\nconstexpr array<Direction, 8> DIRECTIONS = {{\\n  {-1, -1}, {0, -1}, {+1, -1},\\n  {-1,  0},          {+1,  0},\\n  {-1, +1}, {0, +1}, {+1, +1}\\n}};\\n\\n////////// Relation //////////\\n\\nenum Relation {\\n  NO_RELATION,\\n  OVER,\\n  RIGHT,\\n  UNDER,\\n  LEFT\\n};\\n\\n////////// Pass //////////\\n\\nstruct Pass {\\n  Relation  before;\\n  Direction d;\\n  Relation  after;\\n  \\n  int clockDirection() const {\\n    switch (after) {\\n      case OVER:  return  d.x;\\n      case RIGHT: return -d.y;\\n      case UNDER: return -d.x;\\n      case LEFT:  return  d.y;\\n      default: assert(false and \"unreachable code\");\\n    }\\n  }\\n  \\n  bool cancelledBy(const Pass& b) const {\\n    if (after == b.after) return false;\\n    if ((b.before == OVER || b.before == UNDER) && d.x + b.d.x == 0) return true;\\n    if ((b.before == LEFT || b.before == RIGHT) && d.y + b.d.y == 0) return true;\\n    return false;\\n  }\\n  \\n  bool augmentedBy(const Pass& b) const {\\n    if (after == b.after)       return false;\\n    if (b.after == NO_RELATION) return false;\\n    return true;\\n  }\\n};\\n\\n////////// Solution //////////\\n\\nconstexpr int64_t SIZE = 1000002; // 1e6 as specified + room for outer walls\\n\\nclass Solution {\\npublic:\\n  bool isEscapePossible(vector<vector<int>>& bl, vector<int>& src, vector<int>& trg) {\\n    iosHackery();\\n    \\n    // Store / preprocess input\\n    sx = src[0] + 1;\\n    sy = src[1] + 1;\\n    tx = trg[0] + 1;\\n    ty = trg[1] + 1;\\n    for (auto& xy : bl) {\\n      xy[0]++;\\n      xy[1]++;\\n      blocks.insert(xy[0] * SIZE + xy[1]);\\n      if (xy[0] == 1) {\\n        blocks    .insert(0 * SIZE + xy[1]);\\n        wallBlocks.insert(0 * SIZE + xy[1]);\\n      } else if (xy[0] == SIZE - 2) {\\n        blocks    .insert((SIZE - 1) * SIZE + xy[1]);\\n        wallBlocks.insert((SIZE - 1) * SIZE + xy[1]);\\n      } else if (xy[1] == 1) {\\n        blocks    .insert(xy[0] * SIZE + 0);\\n        wallBlocks.insert(xy[0] * SIZE + 0);\\n      } else if (xy[1] == SIZE - 2) {\\n        blocks    .insert(xy[0] * SIZE + (SIZE - 1));\\n        wallBlocks.insert(xy[0] * SIZE + (SIZE - 1));\\n      }\\n    }\\n    \\n    // Follow all block-chains, checking whether they separate source from target\\n    for (auto block : wallBlocks)\\n      if (chainSeparatesPoints(block))\\n        return false;\\n    for (auto block : blocks)\\n      if (chainSeparatesPoints(block))\\n        return false;\\n    \\n    // Yay! Escape!\\n    return true;\\n  }\\n  \\nprivate:\\n  // input\\n  int sx;  int sy;\\n  int tx;  int ty;\\n  std::unordered_set<int64_t> blocks;\\n  \\n  // constructed blocks inside walls, adjacent to other blocks\\n  std::unordered_set<int64_t> wallBlocks;\\n  \\n  // global bookkeeping\\n  std::unordered_set<int64_t> visited;\\n  \\n  // single traversal bookkeeping\\n  struct PassIterators { int s; int t; };\\n  std::unordered_map<int64_t, PassIterators> visitedRecently;\\n  std::vector<Pass> sPasses;\\n  std::vector<Pass> tPasses;\\n  bool wallStart;\\n  \\n  // to wring a bit of extra speed out of this\\n  void iosHackery() {\\n    ios_base::sync_with_stdio(false);\\n    cin.tie(nullptr);\\n    cout.tie(nullptr);\\n  }\\n  \\n  // starting investigation of a chain\\n  bool chainSeparatesPoints(int64_t block) {\\n    if (visited.count(block))\\n      return false;\\n    wallStart = !!wallBlocks.count(block);\\n    sPasses = {{NO_RELATION, {0, 0}, NO_RELATION}};\\n    tPasses = {{NO_RELATION, {0, 0}, NO_RELATION}};\\n    int x = block / SIZE;\\n    int y = block % SIZE;\\n    return chainSeparatesPoints(NO_RELATION, NO_RELATION, {0, 0}, x, y);\\n  }\\n  \\n  // continuing investigation of a chain, recursively\\n  bool chainSeparatesPoints(Relation sBefore, Relation tBefore, Direction d, int x, int y) {\\n    // Process passes\\n    auto getRelation = [x, y](int rx, int ry) -> Relation {\\n      if (x == rx) return ry < y ? OVER : UNDER;\\n      if (y == ry) return rx < x ? RIGHT : LEFT;\\n      return NO_RELATION;\\n    };\\n    auto sRelation = getRelation(sx, sy);\\n    auto tRelation = getRelation(tx, ty);\\n    Pass sPass = {sBefore, d, sRelation};\\n    Pass tPass = {tBefore, d, tRelation};\\n    if (sPasses.back().cancelledBy(sPass)) sPasses.pop_back();\\n    if (sPasses.back().augmentedBy(sPass)) sPasses.push_back(sPass);\\n    if (tPasses.back().cancelledBy(tPass)) tPasses.pop_back();\\n    if (tPasses.back().augmentedBy(tPass)) tPasses.push_back(tPass);\\n    \\n    int64_t block = x * SIZE + y;\\n    \\n    // When hitting a wall, or a previously visited block, check for separation\\n    if (visitedRecently.count(block))\\n      return checkSeparation(visitedRecently[block].s, visitedRecently[block].t);\\n    if (wallBlocks.count(block) && !(d.x == 0 && d.y == 0))\\n      return wallStart && checkSeparation(1, 1);\\n    \\n    // Visit neighbouring blocks, continuing the chain\\n    visited.insert(block);\\n    visitedRecently[block] = { sPasses.size() - 1, tPasses.size() - 1 };\\n    for (auto d : DIRECTIONS) {\\n      int nx = x + d.x;\\n      int ny = y + d.y;\\n      int64_t nblock = nx * SIZE + ny;\\n      if (blocks.count(nblock))\\n        if (chainSeparatesPoints(sRelation, tRelation, d, nx, ny))\\n          return true;\\n    }\\n    visitedRecently.erase(block);\\n    \\n    //\\n    return false;\\n  }\\n  \\n  // Given a sequence of block-passes for source and target,\\n  // determine whether that section of chain effectively\\n  // separates the two.\\n  bool checkSeparation (int s, int t) {\\n    int sEnd = sPasses.size();\\n    int tEnd = tPasses.size();\\n    \\n    if (s != sEnd && sPasses[s].after == NO_RELATION) ++s;\\n    if (t != tEnd && tPasses[t].after == NO_RELATION) ++t;\\n    \\n    if (s == sEnd) {\\n      if (tEnd - t <= 1)\\n        return false;\\n      if (tEnd - t >= 3)\\n        return true;\\n      switch (tPasses[t].after) {\\n        case OVER:  return ty < sy;\\n        case RIGHT: return tx < sx;\\n        case UNDER: return ty > sy;\\n        case LEFT:  return tx > sx;\\n        default: assert(false and \"unreachable code\");\\n      }\\n    } else if (t == tEnd) {\\n      if (sEnd - s <= 1)\\n        return false;\\n      if (sEnd - s >= 3)\\n        return true;\\n      switch (sPasses[s].after) {\\n        case OVER:  return sy < ty;\\n        case RIGHT: return sx < tx;\\n        case UNDER: return sy > ty;\\n        case LEFT:  return sx > tx;\\n        default: assert(false and \"unreachable code\");\\n      }\\n    } else {\\n      return sPasses[s].clockDirection() != tPasses[t].clockDirection();\\n    }\\n  }\\n};\\n```",
                "solutionTags": [
                    "Backtracking",
                    "Geometry"
                ],
                "code": "```\\n////////// Direction //////////\\n\\nstruct Direction {\\n  int x;\\n  int y;\\n};\\n\\nconstexpr array<Direction, 8> DIRECTIONS = {{\\n  {-1, -1}, {0, -1}, {+1, -1},\\n  {-1,  0},          {+1,  0},\\n  {-1, +1}, {0, +1}, {+1, +1}\\n}};\\n\\n////////// Relation //////////\\n\\nenum Relation {\\n  NO_RELATION,\\n  OVER,\\n  RIGHT,\\n  UNDER,\\n  LEFT\\n};\\n\\n////////// Pass //////////\\n\\nstruct Pass {\\n  Relation  before;\\n  Direction d;\\n  Relation  after;\\n  \\n  int clockDirection() const {\\n    switch (after) {\\n      case OVER:  return  d.x;\\n      case RIGHT: return -d.y;\\n      case UNDER: return -d.x;\\n      case LEFT:  return  d.y;\\n      default: assert(false and \"unreachable code\");\\n    }\\n  }\\n  \\n  bool cancelledBy(const Pass& b) const {\\n    if (after == b.after) return false;\\n    if ((b.before == OVER || b.before == UNDER) && d.x + b.d.x == 0) return true;\\n    if ((b.before == LEFT || b.before == RIGHT) && d.y + b.d.y == 0) return true;\\n    return false;\\n  }\\n  \\n  bool augmentedBy(const Pass& b) const {\\n    if (after == b.after)       return false;\\n    if (b.after == NO_RELATION) return false;\\n    return true;\\n  }\\n};\\n\\n////////// Solution //////////\\n\\nconstexpr int64_t SIZE = 1000002; // 1e6 as specified + room for outer walls\\n\\nclass Solution {\\npublic:\\n  bool isEscapePossible(vector<vector<int>>& bl, vector<int>& src, vector<int>& trg) {\\n    iosHackery();\\n    \\n    // Store / preprocess input\\n    sx = src[0] + 1;\\n    sy = src[1] + 1;\\n    tx = trg[0] + 1;\\n    ty = trg[1] + 1;\\n    for (auto& xy : bl) {\\n      xy[0]++;\\n      xy[1]++;\\n      blocks.insert(xy[0] * SIZE + xy[1]);\\n      if (xy[0] == 1) {\\n        blocks    .insert(0 * SIZE + xy[1]);\\n        wallBlocks.insert(0 * SIZE + xy[1]);\\n      } else if (xy[0] == SIZE - 2) {\\n        blocks    .insert((SIZE - 1) * SIZE + xy[1]);\\n        wallBlocks.insert((SIZE - 1) * SIZE + xy[1]);\\n      } else if (xy[1] == 1) {\\n        blocks    .insert(xy[0] * SIZE + 0);\\n        wallBlocks.insert(xy[0] * SIZE + 0);\\n      } else if (xy[1] == SIZE - 2) {\\n        blocks    .insert(xy[0] * SIZE + (SIZE - 1));\\n        wallBlocks.insert(xy[0] * SIZE + (SIZE - 1));\\n      }\\n    }\\n    \\n    // Follow all block-chains, checking whether they separate source from target\\n    for (auto block : wallBlocks)\\n      if (chainSeparatesPoints(block))\\n        return false;\\n    for (auto block : blocks)\\n      if (chainSeparatesPoints(block))\\n        return false;\\n    \\n    // Yay! Escape!\\n    return true;\\n  }\\n  \\nprivate:\\n  // input\\n  int sx;  int sy;\\n  int tx;  int ty;\\n  std::unordered_set<int64_t> blocks;\\n  \\n  // constructed blocks inside walls, adjacent to other blocks\\n  std::unordered_set<int64_t> wallBlocks;\\n  \\n  // global bookkeeping\\n  std::unordered_set<int64_t> visited;\\n  \\n  // single traversal bookkeeping\\n  struct PassIterators { int s; int t; };\\n  std::unordered_map<int64_t, PassIterators> visitedRecently;\\n  std::vector<Pass> sPasses;\\n  std::vector<Pass> tPasses;\\n  bool wallStart;\\n  \\n  // to wring a bit of extra speed out of this\\n  void iosHackery() {\\n    ios_base::sync_with_stdio(false);\\n    cin.tie(nullptr);\\n    cout.tie(nullptr);\\n  }\\n  \\n  // starting investigation of a chain\\n  bool chainSeparatesPoints(int64_t block) {\\n    if (visited.count(block))\\n      return false;\\n    wallStart = !!wallBlocks.count(block);\\n    sPasses = {{NO_RELATION, {0, 0}, NO_RELATION}};\\n    tPasses = {{NO_RELATION, {0, 0}, NO_RELATION}};\\n    int x = block / SIZE;\\n    int y = block % SIZE;\\n    return chainSeparatesPoints(NO_RELATION, NO_RELATION, {0, 0}, x, y);\\n  }\\n  \\n  // continuing investigation of a chain, recursively\\n  bool chainSeparatesPoints(Relation sBefore, Relation tBefore, Direction d, int x, int y) {\\n    // Process passes\\n    auto getRelation = [x, y](int rx, int ry) -> Relation {\\n      if (x == rx) return ry < y ? OVER : UNDER;\\n      if (y == ry) return rx < x ? RIGHT : LEFT;\\n      return NO_RELATION;\\n    };\\n    auto sRelation = getRelation(sx, sy);\\n    auto tRelation = getRelation(tx, ty);\\n    Pass sPass = {sBefore, d, sRelation};\\n    Pass tPass = {tBefore, d, tRelation};\\n    if (sPasses.back().cancelledBy(sPass)) sPasses.pop_back();\\n    if (sPasses.back().augmentedBy(sPass)) sPasses.push_back(sPass);\\n    if (tPasses.back().cancelledBy(tPass)) tPasses.pop_back();\\n    if (tPasses.back().augmentedBy(tPass)) tPasses.push_back(tPass);\\n    \\n    int64_t block = x * SIZE + y;\\n    \\n    // When hitting a wall, or a previously visited block, check for separation\\n    if (visitedRecently.count(block))\\n      return checkSeparation(visitedRecently[block].s, visitedRecently[block].t);\\n    if (wallBlocks.count(block) && !(d.x == 0 && d.y == 0))\\n      return wallStart && checkSeparation(1, 1);\\n    \\n    // Visit neighbouring blocks, continuing the chain\\n    visited.insert(block);\\n    visitedRecently[block] = { sPasses.size() - 1, tPasses.size() - 1 };\\n    for (auto d : DIRECTIONS) {\\n      int nx = x + d.x;\\n      int ny = y + d.y;\\n      int64_t nblock = nx * SIZE + ny;\\n      if (blocks.count(nblock))\\n        if (chainSeparatesPoints(sRelation, tRelation, d, nx, ny))\\n          return true;\\n    }\\n    visitedRecently.erase(block);\\n    \\n    //\\n    return false;\\n  }\\n  \\n  // Given a sequence of block-passes for source and target,\\n  // determine whether that section of chain effectively\\n  // separates the two.\\n  bool checkSeparation (int s, int t) {\\n    int sEnd = sPasses.size();\\n    int tEnd = tPasses.size();\\n    \\n    if (s != sEnd && sPasses[s].after == NO_RELATION) ++s;\\n    if (t != tEnd && tPasses[t].after == NO_RELATION) ++t;\\n    \\n    if (s == sEnd) {\\n      if (tEnd - t <= 1)\\n        return false;\\n      if (tEnd - t >= 3)\\n        return true;\\n      switch (tPasses[t].after) {\\n        case OVER:  return ty < sy;\\n        case RIGHT: return tx < sx;\\n        case UNDER: return ty > sy;\\n        case LEFT:  return tx > sx;\\n        default: assert(false and \"unreachable code\");\\n      }\\n    } else if (t == tEnd) {\\n      if (sEnd - s <= 1)\\n        return false;\\n      if (sEnd - s >= 3)\\n        return true;\\n      switch (sPasses[s].after) {\\n        case OVER:  return sy < ty;\\n        case RIGHT: return sx < tx;\\n        case UNDER: return sy > ty;\\n        case LEFT:  return sx > tx;\\n        default: assert(false and \"unreachable code\");\\n      }\\n    } else {\\n      return sPasses[s].clockDirection() != tPasses[t].clockDirection();\\n    }\\n  }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 282923,
                "title": "o-blocked-2-time-make-the-sparse-matrix-dense-then-dfs-bfs-with-picture-examples",
                "content": "Observing that `blocked.length <= 200`, we can convert the sparse matrix to a dense one with size no more than `405 * 405`. (`405 = (200 + 1 + 1) * 2 + 1`.) For example (`1` is block):\\n\\n```\\n0 0 0 0 0 0 0 0 0\\n0 s 0 0 0 0 0 0 0\\n0 0 0 0 0 1 0 0 0\\n0 0 0 0 0 0 0 0 0\\n0 0 0 0 0 0 0 0 0\\n0 0 0 0 0 0 0 0 0\\n0 0 0 0 0 0 0 t 0\\n0 0 0 0 0 0 0 0 0\\n```\\ncan be converted to \\n```\\n0 0 0 0 0 0 0\\n0 s 0 0 0 0 0\\n0 0 0 1 0 0 0\\n0 0 0 0 0 0 0\\n0 0 0 0 0 t 0\\n0 0 0 0 0 0 0\\n```\\nNote that in the sparse matrix if two adjacent rows/columns both have non-zero elements, then they should be adjacent in the dense matrix (eg. the row with `s` and the row with `1` in the matrix above). If they are not adjacent in the sparse matrix, they should not be adjacent in the dense matrix. (eg. the column with `s` and the column with `1` in the matrix above)\\n\\nAlso note that the points at the border of the original sparse matrix shoud stay at the border of the dense matrix. For example:\\n```\\ns 0 0 0 0 0 0\\n0 t 0 0 0 0 0\\n0 0 0 0 0 0 0\\n0 0 0 0 0 0 0\\n```\\ncan be converted to \\n```\\ns 0 0\\n0 t 0\\n0 0 0\\n```\\n\\nThen we can do DFS or BFS on this dense matrix of size no more than 405 * 405. The number 405 is from the worst case where the source, the target and all of the 200 blocked squares are on the diagnals of the sparse matrix and any two of them are not (8-directionally) neighbors.\\n\\nPython code:\\n```\\nclass Solution(object):\\n    def isEscapePossible(self, blocked, source, target):\\n        self.size = [None] * 2\\n        for dim in (0, 1):\\n            self.makeDenseMap(dim, blocked, source, target)\\n        blocked = set(map(tuple, blocked))\\n        source = tuple(source)\\n        target = tuple(target)\\n        queue = collections.deque([source])\\n\\t\\t# Solving by BFS. DFS will work too.\\n        while queue:\\n            p = queue.popleft()\\n            delta = (1, 0, -1, 0, 1)\\n            for i in xrange(4):\\n                next_point = p[0] + delta[i], p[1] + delta[i + 1]\\n                if next_point == target:\\n                    return True\\n                if self.isValid(next_point) and next_point not in blocked:\\n                    blocked.add(next_point)\\n                    queue.append(next_point)\\n        return False\\n\\t\\t\\n\\tdef makeDenseMap(self, dim, blocked, source, target):\\n        points = blocked + [source, target]\\n        X = sorted([p[dim] for p in points])\\n        mapping = {}\\n        index = -1\\n        for x in X:\\n            if x not in mapping:\\n                index += 1 if x - 1 in mapping or x == 0 else 2\\n                mapping[x] = index\\n        source[dim] = mapping[source[dim]]\\n        target[dim] = mapping[target[dim]]\\n        for b in blocked:\\n            b[dim] = mapping[b[dim]]\\n        self.size[dim] = index\\n        if 999999 not in mapping:\\n            self.size[dim] += 1\\n    \\n    def isValid(self, point):\\n        return all(0 <= point[dim] <= self.size[dim] for dim in (0, 1))\\n\\n```\\n",
                "solutionTags": [],
                "code": "```\\n0 0 0 0 0 0 0 0 0\\n0 s 0 0 0 0 0 0 0\\n0 0 0 0 0 1 0 0 0\\n0 0 0 0 0 0 0 0 0\\n0 0 0 0 0 0 0 0 0\\n0 0 0 0 0 0 0 0 0\\n0 0 0 0 0 0 0 t 0\\n0 0 0 0 0 0 0 0 0\\n```\n```\\n0 0 0 0 0 0 0\\n0 s 0 0 0 0 0\\n0 0 0 1 0 0 0\\n0 0 0 0 0 0 0\\n0 0 0 0 0 t 0\\n0 0 0 0 0 0 0\\n```\n```\\ns 0 0 0 0 0 0\\n0 t 0 0 0 0 0\\n0 0 0 0 0 0 0\\n0 0 0 0 0 0 0\\n```\n```\\ns 0 0\\n0 t 0\\n0 0 0\\n```\n```\\nclass Solution(object):\\n    def isEscapePossible(self, blocked, source, target):\\n        self.size = [None] * 2\\n        for dim in (0, 1):\\n            self.makeDenseMap(dim, blocked, source, target)\\n        blocked = set(map(tuple, blocked))\\n        source = tuple(source)\\n        target = tuple(target)\\n        queue = collections.deque([source])\\n\\t\\t# Solving by BFS. DFS will work too.\\n        while queue:\\n            p = queue.popleft()\\n            delta = (1, 0, -1, 0, 1)\\n            for i in xrange(4):\\n                next_point = p[0] + delta[i], p[1] + delta[i + 1]\\n                if next_point == target:\\n                    return True\\n                if self.isValid(next_point) and next_point not in blocked:\\n                    blocked.add(next_point)\\n                    queue.append(next_point)\\n        return False\\n\\t\\t\\n\\tdef makeDenseMap(self, dim, blocked, source, target):\\n        points = blocked + [source, target]\\n        X = sorted([p[dim] for p in points])\\n        mapping = {}\\n        index = -1\\n        for x in X:\\n            if x not in mapping:\\n                index += 1 if x - 1 in mapping or x == 0 else 2\\n                mapping[x] = index\\n        source[dim] = mapping[source[dim]]\\n        target[dim] = mapping[target[dim]]\\n        for b in blocked:\\n            b[dim] = mapping[b[dim]]\\n        self.size[dim] = index\\n        if 999999 not in mapping:\\n            self.size[dim] += 1\\n    \\n    def isValid(self, point):\\n        return all(0 <= point[dim] <= self.size[dim] for dim in (0, 1))\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3976443,
                "title": "simple-bfs-using-unordered-map-for-space-optimisation",
                "content": "\\n# Code\\n```\\nclass Solution {\\npublic:\\n    unordered_map<int, unordered_map<int,bool>> block;\\n    bool isvalid(int x,int y) {\\n        if(x<0 || y<0 || x>=1e6 || y>=1e6) return false;\\n        // here we use block[x][y] because if it is a blocked block then it will return false otherwise true\\n        return !block[x][y];\\n    }\\n    bool isEscapePossible(vector<vector<int>>& blocked, vector<int>& source, vector<int>& target) {\\n        int cnt=0;\\n        for (auto it : blocked) {\\n            cnt++;\\n            block[it[0]][it[1]]=1;\\n        }\\n\\n        // here we are checking if on all four side of source and target are blocked block then it will return false, this will just reduce your time complexity \\n        if (block[source[0]-1][source[1]] && block[source[0]+1][source[1]] && block[source[0]][source[1]-1] && block[source[0]][source[1]+1]) return false;\\n        if (block[target[0]-1][target[1]] && block[target[0]+1][target[1]] && block[target[0]][target[1]-1] && block[target[0]][target[1]+1]) return false;\\n\\n        // this is just calculating the total area that is formed by the blocked blocks\\n        int maxarea=(cnt*(cnt-1))/2;\\n\\n        // BFS\\n        unordered_map<int, unordered_map<int, bool>> vis;\\n        vis[source[0]][source[1]]=1;\\n        queue<pair<int, int>> q;\\n        int area=1;\\n        q.push({source[0], source[1]});\\n        while (!q.empty()) {\\n            int r=q.front().first;\\n            int c=q.front().second;\\n            q.pop();\\n            if (r==target[0] && c==target[1]) return true;\\n            if (area>maxarea) return true;\\n            if (isvalid(r-1, c) && !vis[r-1][c]) {\\n                vis[r-1][c]=1;\\n                area++;\\n                q.push({r-1, c});\\n            } \\n            if (isvalid(r, c+1) && !vis[r][c+1]) {\\n                vis[r][c+1]=1;\\n                area++;\\n                q.push({r, c+1});\\n            } \\n            if (isvalid(r+1, c) && !vis[r+1][c]) {\\n                vis[r+1][c]=1;\\n                area++;\\n                q.push({r+1, c});\\n            }\\n            if (isvalid(r, c-1) && !vis[r][c-1]) {\\n                vis[r][c-1]=1;\\n                area++;\\n                q.push({r, c-1});\\n            }\\n        }\\n        return false;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    unordered_map<int, unordered_map<int,bool>> block;\\n    bool isvalid(int x,int y) {\\n        if(x<0 || y<0 || x>=1e6 || y>=1e6) return false;\\n        // here we use block[x][y] because if it is a blocked block then it will return false otherwise true\\n        return !block[x][y];\\n    }\\n    bool isEscapePossible(vector<vector<int>>& blocked, vector<int>& source, vector<int>& target) {\\n        int cnt=0;\\n        for (auto it : blocked) {\\n            cnt++;\\n            block[it[0]][it[1]]=1;\\n        }\\n\\n        // here we are checking if on all four side of source and target are blocked block then it will return false, this will just reduce your time complexity \\n        if (block[source[0]-1][source[1]] && block[source[0]+1][source[1]] && block[source[0]][source[1]-1] && block[source[0]][source[1]+1]) return false;\\n        if (block[target[0]-1][target[1]] && block[target[0]+1][target[1]] && block[target[0]][target[1]-1] && block[target[0]][target[1]+1]) return false;\\n\\n        // this is just calculating the total area that is formed by the blocked blocks\\n        int maxarea=(cnt*(cnt-1))/2;\\n\\n        // BFS\\n        unordered_map<int, unordered_map<int, bool>> vis;\\n        vis[source[0]][source[1]]=1;\\n        queue<pair<int, int>> q;\\n        int area=1;\\n        q.push({source[0], source[1]});\\n        while (!q.empty()) {\\n            int r=q.front().first;\\n            int c=q.front().second;\\n            q.pop();\\n            if (r==target[0] && c==target[1]) return true;\\n            if (area>maxarea) return true;\\n            if (isvalid(r-1, c) && !vis[r-1][c]) {\\n                vis[r-1][c]=1;\\n                area++;\\n                q.push({r-1, c});\\n            } \\n            if (isvalid(r, c+1) && !vis[r][c+1]) {\\n                vis[r][c+1]=1;\\n                area++;\\n                q.push({r, c+1});\\n            } \\n            if (isvalid(r+1, c) && !vis[r+1][c]) {\\n                vis[r+1][c]=1;\\n                area++;\\n                q.push({r+1, c});\\n            }\\n            if (isvalid(r, c-1) && !vis[r][c-1]) {\\n                vis[r][c-1]=1;\\n                area++;\\n                q.push({r, c-1});\\n            }\\n        }\\n        return false;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1778684,
                "title": "c-dfs-easy-solution",
                "content": "\\n    \\n    // hash function to create unordered_set of pairs\\n    struct hashFunction\\n    {\\n        size_t operator()(const pair<int,int> &x) const\\n        {\\n            return x.first ^ x.second;\\n        }\\n    };\\n     \\n    // funcion to traverse in the grid\\n    bool dfs(unordered_set<pair<int, int>, hashFunction> &v, unordered_set<pair<int, int>, hashFunction> &s, int i, int j, int x, int y)\\n    {\\n        // array to move right, left, up, down\\n        int dx[] = {1, -1, 0, 0};\\n        int dy[] = {0, 0, 1, -1};\\n        \\n        v.insert({i, j});\\n        \\n        if (v.size() >= 20000)\\n        {\\n            return true;\\n        }\\n        // to check if destination is reached\\n        if (i == x && j == y)\\n        {\\n            return true;\\n        }\\n        for (int k = 0; k < 4; k++)\\n        {\\n            int nX = i + dx[k];\\n            int nY = j + dy[k];\\n            if (nX >= 0 && nY >= 0 && nX < 1e6 && nY < 1e6 && s.find({nX, nY}) == s.end() && v.find({nX, nY}) == v.end())\\n            {\\n                if (dfs(v, s, nX, nY, x, y))\\n                    return true;\\n            }\\n        }\\n        return false;\\n    }\\n    bool isEscapePossible(vector<vector<int>> &blocked, vector<int> &source, vector<int> &target)\\n    {\\n        unordered_set<pair<int, int>, hashFunction> v;\\n        unordered_set<pair<int, int>, hashFunction> s;\\n        \\n        for (auto i : blocked)\\n        {\\n            s.insert({i[0], i[1]});\\n        }\\n        // moving from source to target\\n        int k = dfs(v, s, source[0], source[1], target[0], target[1]);\\n        v.clear();\\n        // moving from target to source\\n        int l = dfs(v, s, target[0], target[1], source[0], source[1]);\\n        return k & l;\\n    }\\n",
                "solutionTags": [
                    "C++",
                    "C",
                    "Depth-First Search"
                ],
                "code": "\\n    \\n    // hash function to create unordered_set of pairs\\n    struct hashFunction\\n    {\\n        size_t operator()(const pair<int,int> &x) const\\n        {\\n            return x.first ^ x.second;\\n        }\\n    };\\n     \\n    // funcion to traverse in the grid\\n    bool dfs(unordered_set<pair<int, int>, hashFunction> &v, unordered_set<pair<int, int>, hashFunction> &s, int i, int j, int x, int y)\\n    {\\n        // array to move right, left, up, down\\n        int dx[] = {1, -1, 0, 0};\\n        int dy[] = {0, 0, 1, -1};\\n        \\n        v.insert({i, j});\\n        \\n        if (v.size() >= 20000)\\n        {\\n            return true;\\n        }\\n        // to check if destination is reached\\n        if (i == x && j == y)\\n        {\\n            return true;\\n        }\\n        for (int k = 0; k < 4; k++)\\n        {\\n            int nX = i + dx[k];\\n            int nY = j + dy[k];\\n            if (nX >= 0 && nY >= 0 && nX < 1e6 && nY < 1e6 && s.find({nX, nY}) == s.end() && v.find({nX, nY}) == v.end())\\n            {\\n                if (dfs(v, s, nX, nY, x, y))\\n                    return true;\\n            }\\n        }\\n        return false;\\n    }\\n    bool isEscapePossible(vector<vector<int>> &blocked, vector<int> &source, vector<int> &target)\\n    {\\n        unordered_set<pair<int, int>, hashFunction> v;\\n        unordered_set<pair<int, int>, hashFunction> s;\\n        \\n        for (auto i : blocked)\\n        {\\n            s.insert({i[0], i[1]});\\n        }\\n        // moving from source to target\\n        int k = dfs(v, s, source[0], source[1], target[0], target[1]);\\n        v.clear();\\n        // moving from target to source\\n        int l = dfs(v, s, target[0], target[1], source[0], source[1]);\\n        return k & l;\\n    }\\n",
                "codeTag": "Unknown"
            },
            {
                "id": 1292945,
                "title": "python3-bfs-dfs",
                "content": "\\n```\\nclass Solution:\\n    def isEscapePossible(self, blocked: List[List[int]], source: List[int], target: List[int]) -> bool:\\n        blocked = set(map(tuple, blocked))\\n        \\n        def fn(x, y, tx, ty): \\n            \"\"\"Return True if (x, y) is not looped from (tx, ty).\"\"\"\\n            seen = {(x, y)}\\n            queue = [(x, y)]\\n            level = 0 \\n            while queue: \\n                level += 1\\n                if level > 200: return True \\n                newq = []\\n                for x, y in queue: \\n                    if (x, y) == (tx, ty): return True \\n                    for xx, yy in (x-1, y), (x, y-1), (x, y+1), (x+1, y): \\n                        if 0 <= xx < 1e6 and 0 <= yy < 1e6 and (xx, yy) not in blocked and (xx, yy) not in seen: \\n                            seen.add((xx, yy))\\n                            newq.append((xx, yy))\\n                queue = newq\\n            return False \\n        \\n        return fn(*source, *target) and fn(*target, *source)\\n```\\n\\n```\\nclass Solution:\\n    def isEscapePossible(self, blocked: List[List[int]], source: List[int], target: List[int]) -> bool:\\n        blocked = set(map(tuple, blocked))\\n        \\n        def dfs(sx, sy, tx, ty): \\n            \"\"\"Return True if (x, y) is not looped from (tx, ty).\"\"\"\\n            seen = {(sx, sy)}\\n            stack = [(sx, sy)]\\n            while stack: \\n                x, y = stack.pop()\\n                if abs(x - sx) + abs(y - sy) > 200 or (x, y) == (tx, ty): return True \\n                for xx, yy in (x-1, y), (x, y-1), (x, y+1), (x+1, y): \\n                    if 0 <= xx < 1e6 and 0 <= yy < 1e6 and (xx, yy) not in blocked and (xx, yy) not in seen: \\n                        seen.add((xx, yy))\\n                        stack.append((xx, yy))\\n            return False \\n        \\n        return dfs(*source, *target) and dfs(*target, *source)\\n```\\n\\nBtw, dfs is a lot quicker.",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def isEscapePossible(self, blocked: List[List[int]], source: List[int], target: List[int]) -> bool:\\n        blocked = set(map(tuple, blocked))\\n        \\n        def fn(x, y, tx, ty): \\n            \"\"\"Return True if (x, y) is not looped from (tx, ty).\"\"\"\\n            seen = {(x, y)}\\n            queue = [(x, y)]\\n            level = 0 \\n            while queue: \\n                level += 1\\n                if level > 200: return True \\n                newq = []\\n                for x, y in queue: \\n                    if (x, y) == (tx, ty): return True \\n                    for xx, yy in (x-1, y), (x, y-1), (x, y+1), (x+1, y): \\n                        if 0 <= xx < 1e6 and 0 <= yy < 1e6 and (xx, yy) not in blocked and (xx, yy) not in seen: \\n                            seen.add((xx, yy))\\n                            newq.append((xx, yy))\\n                queue = newq\\n            return False \\n        \\n        return fn(*source, *target) and fn(*target, *source)\\n```\n```\\nclass Solution:\\n    def isEscapePossible(self, blocked: List[List[int]], source: List[int], target: List[int]) -> bool:\\n        blocked = set(map(tuple, blocked))\\n        \\n        def dfs(sx, sy, tx, ty): \\n            \"\"\"Return True if (x, y) is not looped from (tx, ty).\"\"\"\\n            seen = {(sx, sy)}\\n            stack = [(sx, sy)]\\n            while stack: \\n                x, y = stack.pop()\\n                if abs(x - sx) + abs(y - sy) > 200 or (x, y) == (tx, ty): return True \\n                for xx, yy in (x-1, y), (x, y-1), (x, y+1), (x+1, y): \\n                    if 0 <= xx < 1e6 and 0 <= yy < 1e6 and (xx, yy) not in blocked and (xx, yy) not in seen: \\n                        seen.add((xx, yy))\\n                        stack.append((xx, yy))\\n            return False \\n        \\n        return dfs(*source, *target) and dfs(*target, *source)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1225499,
                "title": "c-bfs-and-some-follow-up",
                "content": "The idea:\\nIt is important to notice that there can only be at most 200 blocks. This means that the maximum area that a wall can block off is about 20,000 by forming a wall like this:\\n```\\n0 0 0 ... 0 0 1\\n0 0 ... 0 0 1\\n0 ... 0 0 1\\n... 0 0 1\\n... 0 1\\n0 1\\n1\\n```\\nThus, all we need to do is run BFS on both the source and the target to see if they are blocked off. We stop the BFS after seeing 20000 blocks.\\n\\nRemarks:\\nI think that the problem description should include the limit of the number of blocks instead of leaving it at the end of the specifications. It seems like a critical information that should be highlighted. However, this get me thinking of what to do if there is no limit to the number of blocks. A simple BFS would be way too time consuming. To those of you who are interested, google \"A* algorithm\". A* is used commonly in games as path finding algorithm for NPC/enemies find the closest route. \\n\\nImplementation:\\n```\\nclass Solution {\\n    int n = 1e6;\\n    unordered_set<long long> wall;\\n\\n    bool isValid(long long coor, unordered_set<long long>& seen) {\\n        long i = coor / n;\\n        long j = coor % n;\\n\\n        if (seen.find(coor) != seen.end() || wall.find(coor) != wall.end()) return false;\\n        return true;\\n    }\\n\\n    bool bfs(vector<int>& source, vector<int>& target) {\\n        unordered_set<long long> seen;\\n        queue<long long> q;\\n        q.push((long long)source[0] * n + source[1]);\\n        int processed = 0;\\n        while (!q.empty()) {\\n            long long curr = q.front();\\n            q.pop();\\n\\n            if (!isValid(curr, seen)) continue;\\n\\n            long i = curr / n;\\n            long j = curr % n;\\n\\n            if (i == target[0] && j == target[1]) return true;\\n\\n            if(i < n - 1)q.push((i + 1) * n + j);\\n            if(i > 0)q.push((i - 1) * n + j);\\n            if(j < n - 1)q.push(i * n + (j + 1));\\n            if(j > 0)q.push(i * n + (j - 1));\\n\\n            seen.insert(curr);\\n\\n            if (seen.size() == 20000) return true;\\n        }\\n\\n        return false;\\n    }\\n\\npublic:\\n    bool isEscapePossible(vector<vector<int>>& blocked, vector<int>& source, vector<int>& target) {\\n        for (vector<int>& w : blocked) {\\n            wall.insert((long long)w[0] * n + w[1]);\\n        }\\n\\n        return bfs(source, target) && bfs(target, source);\\n    }\\n};\\n```\\nTime complexity is O(40000 + 200)  or O(1) (ironic), the space complexity is also O(20000 +200);",
                "solutionTags": [],
                "code": "```\\n0 0 0 ... 0 0 1\\n0 0 ... 0 0 1\\n0 ... 0 0 1\\n... 0 0 1\\n... 0 1\\n0 1\\n1\\n```\n```\\nclass Solution {\\n    int n = 1e6;\\n    unordered_set<long long> wall;\\n\\n    bool isValid(long long coor, unordered_set<long long>& seen) {\\n        long i = coor / n;\\n        long j = coor % n;\\n\\n        if (seen.find(coor) != seen.end() || wall.find(coor) != wall.end()) return false;\\n        return true;\\n    }\\n\\n    bool bfs(vector<int>& source, vector<int>& target) {\\n        unordered_set<long long> seen;\\n        queue<long long> q;\\n        q.push((long long)source[0] * n + source[1]);\\n        int processed = 0;\\n        while (!q.empty()) {\\n            long long curr = q.front();\\n            q.pop();\\n\\n            if (!isValid(curr, seen)) continue;\\n\\n            long i = curr / n;\\n            long j = curr % n;\\n\\n            if (i == target[0] && j == target[1]) return true;\\n\\n            if(i < n - 1)q.push((i + 1) * n + j);\\n            if(i > 0)q.push((i - 1) * n + j);\\n            if(j < n - 1)q.push(i * n + (j + 1));\\n            if(j > 0)q.push(i * n + (j - 1));\\n\\n            seen.insert(curr);\\n\\n            if (seen.size() == 20000) return true;\\n        }\\n\\n        return false;\\n    }\\n\\npublic:\\n    bool isEscapePossible(vector<vector<int>>& blocked, vector<int>& source, vector<int>& target) {\\n        for (vector<int>& w : blocked) {\\n            wall.insert((long long)w[0] * n + w[1]);\\n        }\\n\\n        return bfs(source, target) && bfs(target, source);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 568759,
                "title": "accepted-c-bfs",
                "content": "```\\n\\n    public class Solution\\n    {\\n        private static readonly (int di, int dj)[] _directions = { (0, 1), (1, 0), (0, -1), (-1, 0) };\\n\\n        private bool Helper(int[] source, int[] target, ISet<(int i, int j)> blocked)\\n        {\\n            ISet<(int i, int j)> visited = new HashSet<(int i, int j)>();\\n            Queue<(int i, int j)> bfs = new Queue<(int i, int j)>();\\n\\n            bfs.Enqueue((source[0], source[1]));\\n            visited.Add((source[0], source[1]));\\n\\n            (int i, int j) t = (target[0], target[1]);\\n            int depth = 0;\\n\\n            while (bfs.Count != 0)\\n            {\\n                int count = bfs.Count;\\n\\n                for (int i = 0; i < count; i++)\\n                {\\n                    (int i, int j) curr = bfs.Dequeue();\\n\\n                    if (curr.i == t.i && curr.j == t.j)\\n                    {\\n                        return true;\\n                    }\\n\\n                    foreach (var dir in _directions)\\n                    {\\n                        int newI = curr.i + dir.di;\\n                        int newJ = curr.j + dir.dj;\\n\\n                        if (newI >= 0 && newJ >= 0 && newI < 1_000_000 && newJ < 1_000_000)\\n                        {\\n                            if (!blocked.Contains((newI, newJ)) && visited.Add((newI, newJ)))\\n                            {\\n                                bfs.Enqueue((newI, newJ));\\n                            }\\n                        }\\n                    }\\n                }\\n\\n                depth++;\\n                if(depth >= blocked.Count)\\n                {\\n                    return true;\\n                }\\n            }\\n\\n            return false;\\n        }\\n\\n        public bool IsEscapePossible(int[][] blocked, int[] source, int[] target)\\n        {\\n            ISet<(int i, int j)> bSet = blocked.Select(b => (b[0], b[1])).ToHashSet();\\n            return Helper(source, target, bSet) && Helper(target, source, bSet);\\n        }\\n    }\\n```",
                "solutionTags": [
                    "Breadth-First Search"
                ],
                "code": "```\\n\\n    public class Solution\\n    {\\n        private static readonly (int di, int dj)[] _directions = { (0, 1), (1, 0), (0, -1), (-1, 0) };\\n\\n        private bool Helper(int[] source, int[] target, ISet<(int i, int j)> blocked)\\n        {\\n            ISet<(int i, int j)> visited = new HashSet<(int i, int j)>();\\n            Queue<(int i, int j)> bfs = new Queue<(int i, int j)>();\\n\\n            bfs.Enqueue((source[0], source[1]));\\n            visited.Add((source[0], source[1]));\\n\\n            (int i, int j) t = (target[0], target[1]);\\n            int depth = 0;\\n\\n            while (bfs.Count != 0)\\n            {\\n                int count = bfs.Count;\\n\\n                for (int i = 0; i < count; i++)\\n                {\\n                    (int i, int j) curr = bfs.Dequeue();\\n\\n                    if (curr.i == t.i && curr.j == t.j)\\n                    {\\n                        return true;\\n                    }\\n\\n                    foreach (var dir in _directions)\\n                    {\\n                        int newI = curr.i + dir.di;\\n                        int newJ = curr.j + dir.dj;\\n\\n                        if (newI >= 0 && newJ >= 0 && newI < 1_000_000 && newJ < 1_000_000)\\n                        {\\n                            if (!blocked.Contains((newI, newJ)) && visited.Add((newI, newJ)))\\n                            {\\n                                bfs.Enqueue((newI, newJ));\\n                            }\\n                        }\\n                    }\\n                }\\n\\n                depth++;\\n                if(depth >= blocked.Count)\\n                {\\n                    return true;\\n                }\\n            }\\n\\n            return false;\\n        }\\n\\n        public bool IsEscapePossible(int[][] blocked, int[] source, int[] target)\\n        {\\n            ISet<(int i, int j)> bSet = blocked.Select(b => (b[0], b[1])).ToHashSet();\\n            return Helper(source, target, bSet) && Helper(target, source, bSet);\\n        }\\n    }\\n```",
                "codeTag": "Java"
            },
            {
                "id": 289204,
                "title": "what-s-the-output-for-this-test-case",
                "content": "For the following test case, the expected output is *False* when running this single test case (ctrl+\\') locally, However when submitting solution, its expected output became *True*, leading to my submission to fail. Anyone has the same issue?\\n\\n```\\n[[0,199],[1,198],[2,197],[3,196],[4,195],[5,194],[6,193],[7,192],[8,191],[9,190],[10,189],[11,188],[12,187],[13,186],[14,185],[15,184],[16,183],[17,182],[18,181],[19,180],[20,179],[21,178],[22,177],[23,176],[24,175],[25,174],[26,173],[27,172],[28,171],[29,170],[30,169],[31,168],[32,167],[33,166],[34,165],[35,164],[36,163],[37,162],[38,161],[39,160],[40,159],[41,158],[42,157],[43,156],[44,155],[45,154],[46,153],[47,152],[48,151],[49,150],[50,149],[51,148],[52,147],[53,146],[54,145],[55,144],[56,143],[57,142],[58,141],[59,140],[60,139],[61,138],[62,137],[63,136],[64,135],[65,134],[66,133],[67,132],[68,131],[69,130],[70,129],[71,128],[72,127],[73,126],[74,125],[75,124],[76,123],[77,122],[78,121],[79,120],[80,119],[81,118],[82,117],[83,116],[84,115],[85,114],[86,113],[87,112],[88,111],[89,110],[90,109],[91,108],[92,107],[93,106],[94,105],[95,104],[96,103],[97,102],[98,101],[99,100],[100,99],[101,98],[102,97],[103,96],[104,95],[105,94],[106,93],[107,92],[108,91],[109,90],[110,89],[111,88],[...\\n[0,0]\\n[200,200]\\n```\\n\\nMy solution attached FYI\\n```\\nclass Solution {\\npublic:\\n    int dir[4][2] = {{0,1}, {1,0}, {0,-1}, {-1,0}};\\n    bool isEscapePossible(vector<vector<int>>& blocked, vector<int>& source, vector<int>& target) {\\n        return check(blocked, source, target) && check(blocked, target, source);        \\n    }\\n    \\n    bool check(vector<vector<int>> &blocked, vector<int> &source, vector<int> &target){\\n        deque<long long> p;\\n        const long long N = 1000000;        \\n        unordered_set<int> visited;\\n        unordered_set<int> block;\\n        for(auto &b : blocked) {\\n            block.insert(b[0] * N + b[1]);\\n        }\\n        \\n        p.push_back(source[0] * N + source[1]);\\n        visited.insert(source[0] * N + source[1]);\\n        int level = 200;\\n        while(level--) {\\n            if(p.size()==0) return false;\\n            for(int i = 0 ; i < p.size(); i++) {\\n                auto cur = p.front(); p.pop_front();\\n                if(cur == (target[0] * N + target[1])) \\n                    return true;\\n                int x = cur / N, y = cur % N;\\n                for(int i = 0; i < 4; i++) {\\n                    int nx = x + dir[i][0];\\n                    int ny = y + dir[i][1];\\n                    long long n = nx * N + ny;\\n                    if( nx >= 0 && nx < N && ny >= 0 && ny < N &&\\n                       !block.count(n) && \\n                       !visited.count(n)) {\\n                        visited.insert(n);\\n                        p.push_back(n);\\n                    } \\n                }    \\n            }\\n        }\\n        return true;\\n\\n    }\\n};\\n```\\n",
                "solutionTags": [],
                "code": "```\\n[[0,199],[1,198],[2,197],[3,196],[4,195],[5,194],[6,193],[7,192],[8,191],[9,190],[10,189],[11,188],[12,187],[13,186],[14,185],[15,184],[16,183],[17,182],[18,181],[19,180],[20,179],[21,178],[22,177],[23,176],[24,175],[25,174],[26,173],[27,172],[28,171],[29,170],[30,169],[31,168],[32,167],[33,166],[34,165],[35,164],[36,163],[37,162],[38,161],[39,160],[40,159],[41,158],[42,157],[43,156],[44,155],[45,154],[46,153],[47,152],[48,151],[49,150],[50,149],[51,148],[52,147],[53,146],[54,145],[55,144],[56,143],[57,142],[58,141],[59,140],[60,139],[61,138],[62,137],[63,136],[64,135],[65,134],[66,133],[67,132],[68,131],[69,130],[70,129],[71,128],[72,127],[73,126],[74,125],[75,124],[76,123],[77,122],[78,121],[79,120],[80,119],[81,118],[82,117],[83,116],[84,115],[85,114],[86,113],[87,112],[88,111],[89,110],[90,109],[91,108],[92,107],[93,106],[94,105],[95,104],[96,103],[97,102],[98,101],[99,100],[100,99],[101,98],[102,97],[103,96],[104,95],[105,94],[106,93],[107,92],[108,91],[109,90],[110,89],[111,88],[...\\n[0,0]\\n[200,200]\\n```\n```\\nclass Solution {\\npublic:\\n    int dir[4][2] = {{0,1}, {1,0}, {0,-1}, {-1,0}};\\n    bool isEscapePossible(vector<vector<int>>& blocked, vector<int>& source, vector<int>& target) {\\n        return check(blocked, source, target) && check(blocked, target, source);        \\n    }\\n    \\n    bool check(vector<vector<int>> &blocked, vector<int> &source, vector<int> &target){\\n        deque<long long> p;\\n        const long long N = 1000000;        \\n        unordered_set<int> visited;\\n        unordered_set<int> block;\\n        for(auto &b : blocked) {\\n            block.insert(b[0] * N + b[1]);\\n        }\\n        \\n        p.push_back(source[0] * N + source[1]);\\n        visited.insert(source[0] * N + source[1]);\\n        int level = 200;\\n        while(level--) {\\n            if(p.size()==0) return false;\\n            for(int i = 0 ; i < p.size(); i++) {\\n                auto cur = p.front(); p.pop_front();\\n                if(cur == (target[0] * N + target[1])) \\n                    return true;\\n                int x = cur / N, y = cur % N;\\n                for(int i = 0; i < 4; i++) {\\n                    int nx = x + dir[i][0];\\n                    int ny = y + dir[i][1];\\n                    long long n = nx * N + ny;\\n                    if( nx >= 0 && nx < N && ny >= 0 && ny < N &&\\n                       !block.count(n) && \\n                       !visited.count(n)) {\\n                        visited.insert(n);\\n                        p.push_back(n);\\n                    } \\n                }    \\n            }\\n        }\\n        return true;\\n\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 282993,
                "title": "easy-java-bfs-solution",
                "content": "there are two cases make source can not move to target:\\n1. source is surrounding.\\n2. target is surrounding.\\n\\nthe longest distance from source point to boundary in largest rectangle or triangle formed by blocked points is about number of blocked points, so we can try number of blocked points as level, finally if Queue is not empty, which means the rest of poins in the Queue can move to target. \\n\\n```\\nclass Solution {\\n    Set<String> bb;\\n    public boolean isEscapePossible(int[][] blocked, int[] s, int[] t) {\\n        \\n        if (blocked.length == 0) return true;\\n        bb = new HashSet<>();\\n        for (int[] block : blocked) {\\n            bb.add(block[0]+\"_\"+block[1]);\\n        }\\n        return helper(new HashSet<>(), s, t) && helper(new HashSet<>(), t, s);\\n    }\\n        \\n        \\n    public boolean helper(Set<String> visited, int[] s, int[] target) {\\n        \\n        Queue<int[]> queue = new LinkedList<>();\\n        queue.offer(new int[]{s[0], s[1]});\\n        int level = bb.size();\\n        \\n        while (!queue.isEmpty() && level-- >= 0) {\\n            int size = queue.size();\\n            for (int i = 0; i < size; i++) {\\n                int[] t = queue.poll();\\n                String v = t[0] +\"_\" + t[1];\\n                if (t[0] == target[0] && t[1] == target[1]) return true;\\n            \\n                if (!bb.contains(v) && !visited.contains(v)) {\\n                    visited.add(v);\\n                    if (t[0] - 1 >= 0) {\\n                        queue.offer(new int[]{t[0]-1, t[1]});\\n                    } \\n\\n                    if (t[0] + 1 <= 1000000) {\\n                        queue.offer(new int[]{t[0]+1, t[1]});\\n                    } \\n\\n                     if (t[1] - 1 >= 0) {\\n                        queue.offer(new int[]{t[0], t[1]-1});\\n                    } \\n\\n                    if (t[1] + 1 <= 1000000) {\\n                        queue.offer(new int[]{t[0], t[1]+1});\\n                    } \\n                }\\n                \\n            }    \\n        }\\n        \\n        return !queue.isEmpty();\\n    } \\n}",
                "solutionTags": [],
                "code": "class Solution {\\n    Set<String> bb;\\n    public boolean isEscapePossible(int[][] blocked, int[] s, int[] t) {\\n        \\n        if (blocked.length == 0) return true;\\n        bb = new HashSet<>();\\n        for (int[] block : blocked) {\\n            bb.add(block[0]+\"_\"+block[1]);\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 282857,
                "title": "backtrace-java-7ms",
                "content": "if the source square and the target square is not surround by the blocked grid then we Escape\\n```\\npublic boolean isEscapePossible(int[][] blocked, int[] source, int[] target) {\\n\\tSet<Long> blockedSet=new HashSet<>();\\n\\tfor(int[] p:blocked)\\n\\t\\tblockedSet.add(p[0]*M+p[1]);\\n\\treturn backTrace(blockedSet, source,target, source, new HashSet<>())\\n\\t\\t\\t&& backTrace(blockedSet, target, source, target, new HashSet<>());\\n}\\nlong M=1000000l;\\nint[][] dire=new int[][]{{1,0},{0,1},{0,-1},{-1,0}};\\npublic boolean backTrace(Set<Long> blocked,int[] s, int[] t, int[] p, Set<Long> visited){\\n\\tif(p[0]>=s[0]+200 || p[0]<=s[0]-200 || p[1]>=s[1]+200 || p[1]<=s[1]-200 || !visited.isEmpty() && p[0]==t[0] && p[1]==t[1]) return true;\\n\\tvisited.add(p[0]*M+p[1]);\\n\\tboolean pass=false;\\n\\tfor(int[] d:dire) {\\n\\t\\tint x=p[0]+d[0], y=p[1]+d[1];\\n\\t\\tif (!visited.contains(x*M + y) && !blocked.contains(x * M + y) && x>=0 && x<M && y>=0 && y<M)\\n\\t\\t   pass = pass || backTrace(blocked, s,t, new int[]{x,y}, visited);\\n\\t}\\n\\treturn pass;\\n}\\n```",
                "solutionTags": [],
                "code": "```\\npublic boolean isEscapePossible(int[][] blocked, int[] source, int[] target) {\\n\\tSet<Long> blockedSet=new HashSet<>();\\n\\tfor(int[] p:blocked)\\n\\t\\tblockedSet.add(p[0]*M+p[1]);\\n\\treturn backTrace(blockedSet, source,target, source, new HashSet<>())\\n\\t\\t\\t&& backTrace(blockedSet, target, source, target, new HashSet<>());\\n}\\nlong M=1000000l;\\nint[][] dire=new int[][]{{1,0},{0,1},{0,-1},{-1,0}};\\npublic boolean backTrace(Set<Long> blocked,int[] s, int[] t, int[] p, Set<Long> visited){\\n\\tif(p[0]>=s[0]+200 || p[0]<=s[0]-200 || p[1]>=s[1]+200 || p[1]<=s[1]-200 || !visited.isEmpty() && p[0]==t[0] && p[1]==t[1]) return true;\\n\\tvisited.add(p[0]*M+p[1]);\\n\\tboolean pass=false;\\n\\tfor(int[] d:dire) {\\n\\t\\tint x=p[0]+d[0], y=p[1]+d[1];\\n\\t\\tif (!visited.contains(x*M + y) && !blocked.contains(x * M + y) && x>=0 && x<M && y>=0 && y<M)\\n\\t\\t   pass = pass || backTrace(blocked, s,t, new int[]{x,y}, visited);\\n\\t}\\n\\treturn pass;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3521274,
                "title": "java-solution-with-comment-explanation",
                "content": "\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution \\n{\\n    //check for boundary first\\n    static final int limit= 1000000;\\n    public boolean isEscapePossible(int[][] blocked, int[] source, int[] target) \\n    {\\n    // use hashset for constant time access\\n        Set<String> blocks= new HashSet<>();\\n      \\n        for(int block[] : blocked)\\n            blocks.add(block[0]+ \"-\"+ block[1]);//putting the blocked node into the HashSet to access it at O(1)\\n      \\n        return bfsRange(source, target, blocks) && bfsRange(target, source, blocks);//sector division \\n      \\n      /*checking for both the case that the source is blocked or the target is blocked \\n       *if one of them is blocked we return false\\n       *since it is not practical to traverse each node, it will provide us with TLE\\n      */  \\n    }\\n  \\n    /* Formula :: \\n     * shortest arc(displacement) of 1/4 sector of circel is a* 2^1/2\\n     * Area of the triangular sector is 1/2 * ( r{base} * r{height} )\\n     * Number of minimum shell to cover to move ahed of sector or boundary if possible = 0 + 1 + 2 + 3 + ... + 199 = 19900 (A.P)\\n     */\\n  \\n    public boolean bfsRange(int[] source, int[] target, Set<String> blocks)\\n    {//we simply do bsf to check the circular quadrant 1/4th boundary of the sector \\n      \\n        Set<String> visited= new HashSet<>();//visited hash set is so that we dont visit the visited cell again and the access time is O(1)\\n        Queue<int[]> q= new LinkedList<>();//as we use in  BT  \\n      \\n        q.offer(source);//adding the starting BFS node to the Queue\\n      \\n        visited.add(source[0] + \"-\" + source[1]);//marking it as visited so  that we dont traverse it again \\n        \\n        int count= 0;//number of node traverse total outside + inside \\n        while(!q.isEmpty())\\n        {//r m* w a*\\n            int temp[]= q.poll();//poling the node \\n            count+= 1;//counting the number of node traverse\\n          \\n            int trav[][]= {{-1, 0}, {0, 1}, {0, -1}, {1, 0}};//Traversing in 4-Direction \\n          \\n            for(int direction[] : trav)\\n            {\\n                int i= temp[0] + direction[0];\\n                int j= temp[1] + direction[1];\\n              \\n                String key= (i+ \"-\"+ j);\\n              \\n                if(i < 0 || j < 0 || i >= limit || j >= limit || visited.contains(key) || blocks.contains(key)) \\n                    continue;//base case 1)checking the index 2)We dont visit the blocked node 3) we dont visit the visited node \\n              \\n                if(i == target[0] && j == target[1]) //when we find the target within the boundary(same sector or the quadrand) we just return true //best case saves a lot of time \\n                   return true;\\n              \\n                visited.add(key);//marking the node as visited and adding it to the Queue\\n              \\n                q.offer(new int[]{i, j});//Expaning the search for path and adding the node \\n              \\n                if(count > 19900) //number of cell, crossing the boundary limit\\n                   return true;//path exists from this node \\n            }\\n        }\\n        return false;//no path, to reach the node//boundary blocked us \\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Array",
                    "Hash Table",
                    "Depth-First Search",
                    "Breadth-First Search"
                ],
                "code": "```\\nclass Solution \\n{\\n    //check for boundary first\\n    static final int limit= 1000000;\\n    public boolean isEscapePossible(int[][] blocked, int[] source, int[] target) \\n    {\\n    // use hashset for constant time access\\n        Set<String> blocks= new HashSet<>();\\n      \\n        for(int block[] : blocked)\\n            blocks.add(block[0]+ \"-\"+ block[1]);//putting the blocked node into the HashSet to access it at O(1)\\n      \\n        return bfsRange(source, target, blocks) && bfsRange(target, source, blocks);//sector division \\n      \\n      /*checking for both the case that the source is blocked or the target is blocked \\n       *if one of them is blocked we return false\\n       *since it is not practical to traverse each node, it will provide us with TLE\\n      */  \\n    }\\n  \\n    /* Formula :: \\n     * shortest arc(displacement) of 1/4 sector of circel is a* 2^1/2\\n     * Area of the triangular sector is 1/2 * ( r{base} * r{height} )\\n     * Number of minimum shell to cover to move ahed of sector or boundary if possible = 0 + 1 + 2 + 3 + ... + 199 = 19900 (A.P)\\n     */\\n  \\n    public boolean bfsRange(int[] source, int[] target, Set<String> blocks)\\n    {//we simply do bsf to check the circular quadrant 1/4th boundary of the sector \\n      \\n        Set<String> visited= new HashSet<>();//visited hash set is so that we dont visit the visited cell again and the access time is O(1)\\n        Queue<int[]> q= new LinkedList<>();//as we use in  BT  \\n      \\n        q.offer(source);//adding the starting BFS node to the Queue\\n      \\n        visited.add(source[0] + \"-\" + source[1]);//marking it as visited so  that we dont traverse it again \\n        \\n        int count= 0;//number of node traverse total outside + inside \\n        while(!q.isEmpty())\\n        {//r m* w a*\\n            int temp[]= q.poll();//poling the node \\n            count+= 1;//counting the number of node traverse\\n          \\n            int trav[][]= {{-1, 0}, {0, 1}, {0, -1}, {1, 0}};//Traversing in 4-Direction \\n          \\n            for(int direction[] : trav)\\n            {\\n                int i= temp[0] + direction[0];\\n                int j= temp[1] + direction[1];\\n              \\n                String key= (i+ \"-\"+ j);\\n              \\n                if(i < 0 || j < 0 || i >= limit || j >= limit || visited.contains(key) || blocks.contains(key)) \\n                    continue;//base case 1)checking the index 2)We dont visit the blocked node 3) we dont visit the visited node \\n              \\n                if(i == target[0] && j == target[1]) //when we find the target within the boundary(same sector or the quadrand) we just return true //best case saves a lot of time \\n                   return true;\\n              \\n                visited.add(key);//marking the node as visited and adding it to the Queue\\n              \\n                q.offer(new int[]{i, j});//Expaning the search for path and adding the node \\n              \\n                if(count > 19900) //number of cell, crossing the boundary limit\\n                   return true;//path exists from this node \\n            }\\n        }\\n        return false;//no path, to reach the node//boundary blocked us \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2769036,
                "title": "c-easy-short",
                "content": "\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n  bool canReach(vector<int> &source,vector<int> &target,int numBlocked,set<pair<int,int>> &block)\\n    {\\n        vector<int> dx,dy;\\n        dx={0,0,1,-1};\\n        dy={1,-1,0,0};\\n        int maxArea=numBlocked*(numBlocked-1)/2;\\n        int currArea=1;\\n        set<pair<int,int>> visited;\\n        queue<pair<int,int>> q;\\n        q.push({source[0],source[1]});\\n        visited.insert({source[0],source[1]});\\n        while(!q.empty())\\n        {\\n            int x=q.front().first;\\n            int y=q.front().second;\\n            q.pop();\\n            for(int i=0;i<4;i++)\\n            {\\n                int new_x,new_y;\\n                new_x=x+dx[i];\\n                new_y=y+dy[i];\\n                if(new_x==target[0]&&new_y==target[1])\\n                return true;\\n                if(currArea>maxArea)\\n                return true;\\n                if(new_x>=0&&new_x<1e6&&new_y>=0&&new_y<1e6&&block.find({new_x,new_y})==block.end()&&visited.find({new_x,new_y})==visited.end())\\n                {\\n                    currArea++;\\n                    visited.insert({new_x,new_y});\\n                    q.push({new_x,new_y});\\n                }\\n            }\\n        }\\n        return false; \\n    }\\n    bool isEscapePossible(vector<vector<int>>& blocked, vector<int>& source, vector<int>& target) {\\n        set<pair<int,int>> block;\\n        int count=0;\\n        for(int i=0;i<blocked.size();i++)\\n        {\\n            count++;\\n            block.insert({blocked[i][0],blocked[i][1]});\\n        }\\n        return canReach(source,target,count,block)&&canReach(target,source,count,block);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n  bool canReach(vector<int> &source,vector<int> &target,int numBlocked,set<pair<int,int>> &block)\\n    {\\n        vector<int> dx,dy;\\n        dx={0,0,1,-1};\\n        dy={1,-1,0,0};\\n        int maxArea=numBlocked*(numBlocked-1)/2;\\n        int currArea=1;\\n        set<pair<int,int>> visited;\\n        queue<pair<int,int>> q;\\n        q.push({source[0],source[1]});\\n        visited.insert({source[0],source[1]});\\n        while(!q.empty())\\n        {\\n            int x=q.front().first;\\n            int y=q.front().second;\\n            q.pop();\\n            for(int i=0;i<4;i++)\\n            {\\n                int new_x,new_y;\\n                new_x=x+dx[i];\\n                new_y=y+dy[i];\\n                if(new_x==target[0]&&new_y==target[1])\\n                return true;\\n                if(currArea>maxArea)\\n                return true;\\n                if(new_x>=0&&new_x<1e6&&new_y>=0&&new_y<1e6&&block.find({new_x,new_y})==block.end()&&visited.find({new_x,new_y})==visited.end())\\n                {\\n                    currArea++;\\n                    visited.insert({new_x,new_y});\\n                    q.push({new_x,new_y});\\n                }\\n            }\\n        }\\n        return false; \\n    }\\n    bool isEscapePossible(vector<vector<int>>& blocked, vector<int>& source, vector<int>& target) {\\n        set<pair<int,int>> block;\\n        int count=0;\\n        for(int i=0;i<blocked.size();i++)\\n        {\\n            count++;\\n            block.insert({blocked[i][0],blocked[i][1]});\\n        }\\n        return canReach(source,target,count,block)&&canReach(target,source,count,block);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2287674,
                "title": "python-100-o-n-trace-outlines-no-size-limits-on-blocked-grid",
                "content": "This is a solution that runs in O(n) time in the size of blocked, and works for arbitrary sizes of blocked and the bounding grid.\\n\\nThe key intuition used here is that you can test whether or not the target is reachable from the source by first tracing out all of the outlines that would appear after painting in all of the blocked cells, and then checking to see if there exists an outline that separates the source from the target. \\n\\n![image](https://assets.leetcode.com/users/images/97767121-ebf3-4b31-8736-347af3ee8785_1657948987.675496.png)\\n![image](https://assets.leetcode.com/users/images/b4dfb2fa-9988-426c-b921-95ae0af9c70a_1657981501.1923728.png)\\n\\n\\nGiven the source, target, and an outline (which is always a closed loop without any branches), there are four possibilites:\\n\\n1. Both source and target are on the inside of the outline\\n2. Both source and target are on the outside of the outline\\n3. Source is inside the outline and target is outside the outline\\n4. Source is outside the outline and target is inside the outline\\n\\nFor cases 3 & 4, we see that it\\'s impossible to go from source to target without crossing the outline, meaning that no path exists. If we find that, for all outlines, case 1 or 2 is true, then there is a path from source to target.\\n\\nHow do you check which case is true? This is where the topology part comes in. Consider a path P from source to target. For cases 1 & 2, P will cross the outline an even number of times, and for cases 3 & 4, P will cross the outline an odd number of times. \\n\\nIn the example below , it is possible to reach the source from the target. We see that each loop intersects each of the two orange paths an even number of times.\\n![image](https://assets.leetcode.com/users/images/cda9c73c-f8b8-4119-a5ba-b380ce8331e6_1657981514.3184123.png)\\n\\n\\n\\nIn the example below, the source is trapped. Here, we see that the loops trapping the source intersect each of the two orange paths an odd nuber of times.\\n![image](https://assets.leetcode.com/users/images/b83388b6-34e3-4e95-9960-db03c458960e_1657981538.999841.png)\\n\\n\\n\\n\\nSince this property holds true for any path from the source to the target, we can choose a very simple path that makes checking the number of crossings easy. I chose the path that, starting from the source, goes straight horizontally until reaching the  x coordinate of target, and then travels straight vertically to target. I\\'ll call this the \"easy path\".  We\\'ll never actually traverse this path (since that would put our time complexity at the manhattan distance between source and target). Instead, given how it\\'s constructed, testing a unit length edge of an outline for whether or not it intersects the \"easy path\" takes constant time.\\n![image](https://assets.leetcode.com/users/images/b6f81210-4d3a-4ad0-af31-66966060cb36_1657981680.3718183.png)\\n\\n\\n\\nThe algorithm is just to traverse the edges of each outline, while counting the number of edges that intersect the \"easy path\". If the number of intersections are all even, return true, otherwise return false. As we go along, we\\'ll mark each edge as visited, so we don\\'t need to retrace the same outline over and over.\\n\\nOne thing to note is that, sometimes,  an outline of blocked cells can link up with the boundaries of the grid to form a loop that prevents source from reaching the target. We do need to check these cases too when they come up, but the issue is that we don\\'t want to trace out the boundary of the grid while traversing an outline, because the grid is huge and this is a waste of time.\\n\\nThus, if we do touch the boundary of a grid while tracing an outline,\\n![image](https://assets.leetcode.com/users/images/2123847d-ba99-46f0-a06f-68dc94000639_1657948415.2402787.png)\\n\\nwe stop, go back to where we started, and trace out the rest of the outline in the reverse direction until we hit the grid boundary again, after which point, we can stop (the boundaries of the grid will never intersect the \"easy path\" anyway, so we don\\'t need to check them).\\n![image](https://assets.leetcode.com/users/images/ef5d385c-ee4f-409a-9577-4303f424ceaa_1657948433.5690157.png)\\n\\nThe outline traversal is mostly bookkeeping. We store blocked in a hashset, so that we can lookup to see if a cell is occupied in constant time (while using linear space). When facing foward along an edge, we\\'ll keep the occupied cell to our left. We can determine when to turn right or left by looking at the two cells ahead of us. If the right of these two cells is occupied, we need to turn right. If the left is occupied but not the right, we go straight. If neither are occupied, we round the corner by turning left:\\n![image](https://assets.leetcode.com/users/images/616ee38d-8afb-430b-8961-576c453c9f39_1657952661.619793.png)\\n\\nThe rules are flipped when going in the reverse direction (keeping the occupied cells to our right). We don\\'t travel in reverse often (only when we need to complete an outline that touches the grid boundary):\\n![image](https://assets.leetcode.com/users/images/e38f5263-8489-4f1c-9e5f-05027d66fc9c_1657952679.6514275.png)\\n\\nIn the code provided, I refer to these two options as counter-clockwise/clockwise, though it\\'s a bit incorrect. If you keep occupied cells to your left, then you will travel in a counter-clockwise loop (winding number of 1) when tracing the exterior of a region, but when tracing the interior, you will travel in a clockwise loop (winding number of -1). It\\'s reversed when keeping occupied cells to your right.\\n\\nThis algorithm is O(n) in the size of blocked, since we only visit each edge  at most twice (once when traversing an outline, and another time as we iterate through blocked cells), and there are at most 4 len(blocked) possible outline edges. The key reason why this works well is  that the outlines of the painted regions do not branch, and an edge cannot belong to more than one outline. Asymptotically, this is better than a graph search (searching for a path from source to target, or searching the graph formed by neighboring blocked cells).\\n\\nI got it to run in ~81ms. The real tricky part is the coordinate bookkeeping for traversing an outline (either clockwise or counterclockwise), and the fact that we need to keep track of cells, gridpoints and edges (both directed and undirected). \\n\\n\\n```\\nclass Solution(object):   \\n    def isEscapePossible(self, blocked, source, target):\\n        \"\"\"\\n        :type blocked: List[List[int]]\\n        :type source: List[int]\\n        :type target: List[int]\\n        :rtype: bool\\n        \"\"\"\\n        \\n        self.blocked = blocked\\n        self.source = source\\n        self.target = target\\n        \\n        #hashset of all blocked cells\\n        self.blocked_dict = {}\\n        \\n        #hashset of all visited edges\\n        self.edge_dict = {}\\n        \\n        #min/max x/y coords used for checking if an edge intersects the \"easy path\"\\n        self.min_x = min(self.source[0],self.target[0])\\n        self.max_x = max(self.source[0],self.target[0])\\n        self.min_y = min(self.source[1],self.target[1])\\n        self.max_y = max(self.source[1],self.target[1])\\n        \\n        #iterate through all cells in blocked,\\n        #and add each cell to the hash set\\n        for blocked_cell in blocked:\\n            if blocked_cell[0] in self.blocked_dict:\\n                self.blocked_dict[blocked_cell[0]][blocked_cell[1]] = None\\n            else:\\n                self.blocked_dict[blocked_cell[0]]={blocked_cell[1]:None}\\n        \\n        #for each cell in blocked\\n        for blocked_cell in self.blocked:\\n            \\n            #list the faces of blocked_cell that belong to an outline (4 of these at most)\\n            exposed_faces = self.enumerate_exposed_faces(blocked_cell[0],blocked_cell[1])\\n            \\n            #for each of these faces\\n            for face in exposed_faces:\\n                \\n                #check to see if we\\'ve already visited the edge while tracing out a loop\\n                x_edge = face[3]\\n                y_edge = face[4]\\n                edge_type = face[5]\\n                edge_visited = (x_edge in self.edge_dict \\n                                and y_edge in self.edge_dict[x_edge]\\n                                and edge_type in self.edge_dict[x_edge][y_edge])\\n                \\n                #if not, then we are looking at a new outline that we haven\\'t seen before\\n                if not edge_visited:   \\n                   \\n                    #count the number of edges of the outline that intersect the \"easy path\"\\n                    num_intervening_edges =  self.check_loop(face[0],face[1],face[2])\\n                    \\n                    #if the number of intersections is odd, a path does not exist. return false\\n                    if num_intervening_edges%2==1:\\n                        return False\\n            \\n        #if we could not find an outline the separates source from target, return true    \\n        return True\\n    \\n    #lists the faces of occupied cell x,y that do not touch other occupied cells\\n    #these cell faces are edges that belong to one of the outlines that are formed \\n    #by painting in all occupied cells and grid boundaries\\n    #there are at most 4 such edges per cell\\n    def enumerate_exposed_faces(self,x,y):\\n        out_list = []\\n        \\n        #iterate through each neighbor of the cell\\n        for i in range(4):\\n            \\n            #if the neighbor cell is not occupied (blocked), then the corresponding face is a boundary face\\n            #in which case, add it to the list\\n            if not self.is_occupied(x+self.dxe[i],y+self.dye[i]):\\n                \\n                #there is a little bit of accounting going on to keep track of the correct edge coordinates\\n                #note that what we are really listing here is a starting grid point (not cell) + starting direction\\n                #and we also need to take into account that cells are indexed by their bottom left corner\\n                x_star = x+self.dxe2[i]\\n                y_star = y+self.dye2[i]\\n                x_edge_coords = x_star + self.dx_edge_coords[(i+2)%4]\\n                y_edge_coords = y_star + self.dy_edge_coords[(i+2)%4]\\n                \\n                out_list.append([x_star,y_star,i,x_edge_coords,y_edge_coords,self.edge_code_list[i]])\\n        return out_list\\n        \\n    #returns the number of times a given outline intersects the \"easy path\"\\n    #x_start,y_start is the starting gridpoint on the outline\\n    #starting_direction is... the starting direction (see __init__ for how it\\'s coded)\\n    #is_cc is True if traversing in counterclockwise direction, False if clockwise\\n    #note that (counter)clockwise is referring to the winding number of the whole outline we are tracing\\n    def check_loop(self,x_start,y_start,starting_direction,is_cc = True):\\n        #correct the starting direction if it needs to be adjusted\\n        starting_direction = self.update_edge_direction(x_start,y_start,starting_direction,is_cc)\\n        direction = starting_direction\\n        \\n        x = x_start\\n        y = y_start\\n                \\n        num_intervening_edges = 0\\n        \\n        # return False\\n        touched_grid_boundary = False\\n        \\n        #iterate until we either touch the grid boundary\\n        #or return to where we started\\n        #this is a do-while, hence the True + break condition\\n        while True:  \\n            #evaluate next grid point after moving along edge\\n            x_new = x+self.dxp[direction]\\n            y_new = y+self.dyp[direction]\\n            \\n            #if the edge is on the boundary, do not proceed. break out of the loop\\n            if self.edge_on_boundary(x,y,x_new,y_new):\\n                touched_grid_boundary = True\\n                break\\n            \\n            #otherwise, mark the edge as visited\\n            x_edge_coords = x + self.dx_edge_coords[direction]\\n            y_edge_coords = y + self.dy_edge_coords[direction]\\n            edge_coords = [x_edge_coords,y_edge_coords]\\n            \\n            #a little bit of a hassle since it\\'s a dictionary of dictionaries of 1-2 element lists\\n            if x_edge_coords in self.edge_dict:\\n                if y_edge_coords in self.edge_dict[x_edge_coords]:\\n                    if self.edge_code_list[direction] not in self.edge_dict[x_edge_coords][y_edge_coords]:\\n                        self.edge_dict[x_edge_coords][y_edge_coords].append(self.edge_code_list[direction])\\n                else:\\n                    self.edge_dict[x_edge_coords][y_edge_coords] = [self.edge_code_list[direction]] \\n            else:\\n                self.edge_dict[x_edge_coords] = {y_edge_coords: [self.edge_code_list[direction]]}\\n            \\n            \\n            #check to see if the edge intersects our \"easy path\" from source to target\\n            #if an intersection has occured, increment the intersection counter\\n            \\n            #checks to see if the edge intersects the horizontal portion of the easy path\\n            #for an edge to do so, it must be vertical, have the same y as source\\n            #and must have an x between source and target\\n            if self.edge_code_list[direction]==\\'v\\':\\n                if (self.min_x<edge_coords[0] and edge_coords[0]<=self.max_x\\n                    and edge_coords[1]==self.source[1]):\\n                    \\n                    num_intervening_edges+=1\\n                    \\n            #checks to see if the edge interesects the vertical portion of the easy path\\n            #for an edge to do so, it must be horizontal, have the same x as source\\n            #and must have a y between source and target\\n            if self.edge_code_list[direction]==\\'h\\':\\n                if (self.min_y<edge_coords[1] and edge_coords[1]<=self.max_y \\n                    and edge_coords[0]==self.target[0]):\\n                    \\n                    num_intervening_edges+=1\\n            \\n            #update the grid point\\n            x=x_new\\n            y=y_new\\n            \\n            #update the direction\\n            direction = self.update_edge_direction(x,y,direction,is_cc)\\n            \\n            #if we returned back to the beginning, break out of the loop\\n            #we need to take direction into account, because it is possible to return to\\n            #the same grid point during the the middle of the traversal\\n            #for example, imagine tracing the outline of two cells that are diagonally adjacent\\n            #here, you would pass through the point where the two cells touch each other twice\\n            #if you happen to get unlucky and start at such a point, things would break if you \\n            #terminated conditioned just on the x/y coordinates\\n            #taking into account the current direction dodges this issue\\n            if x==x_start and y==y_start and direction == starting_direction:\\n                break\\n        \\n        #if we touched a grid boundary, we need to go back to the beginning\\n        #and then go in reverse until we touch the grid boundary again\\n        #thus finishing the outline.\\n        #since we are going in reverse direction,\\n        #the setting is clockwise instead of counter-clockwise\\n        if touched_grid_boundary and is_cc:\\n            num_intervening_edges+=self.check_loop(\\n                x_start,y_start,(starting_direction+2)%4,is_cc = False)\\n        \\n        #return the number of intersections between the loop and the easy path\\n        return num_intervening_edges\\n    \\n    #changes the edge direction right or left (or keeps straight)\\n    #depending on our current grid point and direction\\n    def update_edge_direction(self,x,y,direction,is_cc):\\n        #coordinate of the cell in front of us (given our current direction) and to the right\\n        x_right = x + self.dx_fwrd_right[direction]\\n        y_right = y + self.dy_fwrd_right[direction]\\n\\n        #coordinate of the cell in front of us (given our current direction) and to the left\\n        x_left = x + self.dx_fwrd_left[direction]\\n        y_left = y + self.dy_fwrd_left[direction]\\n            \\n            \\n        #the following logic tells us how to change the direction as we move along the outline\\n        #I\\'m not going to explain it here, but if you draw the cases out, it will become apparent\\n        #the one thing to note is that, you can still turn right during a counter-clockwise traversal\\n        #(and left during a clockwise traversal). The traversal handedness is referring \\n        #to the global winding number of the whole loop \\n        #(which is either +1 or -1 depending on clockwise or counter-clockwise)\\n        #if we are doing a counterclockwise traversal...\\n        if is_cc:\\n            #if the cell in front of us to the right is occupied, turn right\\n            if self.is_occupied(x_right,y_right):\\n                direction+=1\\n                direction%=4\\n            #if neither cells in front of us are occupied, turn left\\n            elif not self.is_occupied(x_left,y_left):\\n                direction-=1\\n                direction%=4\\n\\n        #if we are doing a clockwise traversal...\\n        else:\\n            #if the cell in front of us to the left is occupied, turn left\\n            if self.is_occupied(x_left,y_left):\\n                direction-=1\\n                direction%=4\\n            #if neither cells in front of us are occupied, turn right\\n            elif not self.is_occupied(x_right,y_right):\\n                direction+=1\\n                direction%=4\\n        return direction\\n    \\n    #checks to see if an edge belongs to the boundary of the grid\\n    def edge_on_boundary(self,x0,y0,x1,y1):\\n        #an edge is on the boundary of the grid iff both endpoints\\n        #are on the boundary of the grid\\n        b_test0 = x0==0 or x0==self.l or y0==0 or y0==self.l\\n        b_test1 = x1==0 or x1==self.l or y1==0 or y1==self.l\\n        return b_test0 and b_test1\\n    \\n    #checks to see if a given cell is blocked. a cell is blocked if either \\n    #it is on the boundary/exterior of the grid, or it was listed in blocked\\n    def is_occupied(self,x,y):\\n        return (x in self.blocked_dict and y in self.blocked_dict[x]) or x<0 or y<0 or x==self.l or y==self.l\\n        \\n    #here is where I hid away all the definitions of constants that we use to make things easier    \\n    def __init__(self):    \\n        #grid dimensions, which we use to check if we hit a grid boundary\\n        self.l = 10**6\\n        \\n        #used to traverse perimeter. clockwise order\\n        #direction 0 = down\\n        #direction 1 = left\\n        #direction 2 = up\\n        #direction 3 = right\\n        self.dxp = [ 0,-1, 0, 1]\\n        self.dyp = [-1, 0, 1, 0]\\n        \\n        #used to check for faces of a cell that are exposed\\n        #if the face of a cell is exposed, then that face belongs\\n        #to a perimeter that may prevent source from reaching target\\n        \\n        #perimeters are traversed in a counterclockwise loop by default\\n        #specifically, while travelling along a perimenter,\\n        #the cell to your left will always be occupied and the\\n        #the cell to your right will always be empty\\n        \\n        #faces of the cell are indexed as:\\n        #[left, top, right, bottom]\\n        #if cell x+dxe[i],y+dye[i] if not occupied, then the ith face\\n        #of the cell is part of a perimeter, which corresponds to motion\\n        #in direction i\\n        self.dxe = [-1, 0, 1, 0]\\n        self.dye = [ 0, 1, 0,-1]\\n        \\n        #used to maps an exposed face of a cell to the corner of the cell\\n        #used to start the perimeter traversal\\n        #left face: start at bottom left corner\\n        #top face: start at top left corner\\n        #right face: start at top right corner\\n        #bottom face: start at bottom right corner\\n        self.dxe2 = [ 0, 0, 1, 1]\\n        self.dye2 = [ 0, 1, 1, 0]\\n        \\n        #used to determine what cells to look at\\n        #when checking if we need to turn clockwise or counterclockwise\\n        #while traversing the perimeter\\n        self.dx_fwrd_right = [-1,-1, 0, 0]\\n        self.dy_fwrd_right = [-1, 0, 0,-1]\\n        \\n        self.dx_fwrd_left  = [ 0,-1,-1, 0]\\n        self.dy_fwrd_left  = [-1,-1, 0, 0]\\n        \\n        #note that, for the above, a grid point and a cell have the same\\n        #coordinates if the grid point is the bottom left corner of that cell\\n        \\n        \\n        #used to map directed edges to undirected edges\\n        #we index edges using their bottom/leftmost point, and whether they\\n        #are vertical or horizontal\\n        self.edge_code_list = [\\'v\\',\\'h\\',\\'v\\',\\'h\\']\\n        self.dx_edge_coords = [ 0,-1, 0, 0]\\n        self.dy_edge_coords = [-1, 0, 0, 0]\\n\\n        \\n\\n        \\n\\n\\n        \\n        \\n\\n        \\n",
                "solutionTags": [
                    "Python"
                ],
                "code": "class Solution(object):   \\n    def isEscapePossible(self, blocked, source, target):\\n        \"\"\"\\n        :type blocked: List[List[int]]\\n        :type source: List[int]\\n        :type target: List[int]\\n        :rtype: bool\\n        \"\"\"\\n        \\n        self.blocked = blocked\\n        self.source = source\\n        self.target = target\\n        \\n        #hashset of all blocked cells\\n        self.blocked_dict = {}",
                "codeTag": "Java"
            },
            {
                "id": 2069328,
                "title": "javascript-solution-100-100",
                "content": "<img src=\"https://assets.leetcode.com/users/images/88bb50fd-0236-4129-bbf3-e5860a0e7763_1653383384.5933099.png\" width=\"640\" />\\n\\n```\\nvar isEscapePossible = function (b, s, t) {\\n    // Set max for 2 points\\n    const max = b.length ** 2 / 2;\\n    // 4 Types\\n    const dir = [[0, 1], [0, -1], [1, 0], [-1, 0]];\\n    // Set as Hash Result\\n    const spc = b.reduce((a, c) => a.add(hash(c[0], c[1])), new Set());\\n\\n    // s and t as x, y\\n    return dfs(...s, max, new Set(), t) && dfs(...t, max, new Set(), s);\\n\\n    // Get Hash\\n    function hash(x, y) {\\n        return 1123 * x + y;\\n    }\\n\\n    // DFS Handler\\n    function dfs(x, y, max, v, t) {\\n        if (x < 0 || x >= 1e6 || y < 0 || y >= 1e6 || spc.has(hash(x, y)) || v.has(hash(x, y))) {\\n            return false;\\n        }\\n        if (--max <= 0 || (x === t[0] && y === t[1])) {\\n            return true;\\n        }\\n        // Add Hash into Set\\n        v.add(hash(x, y));\\n        \\n        // Recursion\\n        return dir.reduce((a, c) => a || dfs(x + c[0], y + c[1], max, v, t), false);\\n    }\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\nvar isEscapePossible = function (b, s, t) {\\n    // Set max for 2 points\\n    const max = b.length ** 2 / 2;\\n    // 4 Types\\n    const dir = [[0, 1], [0, -1], [1, 0], [-1, 0]];\\n    // Set as Hash Result\\n    const spc = b.reduce((a, c) => a.add(hash(c[0], c[1])), new Set());\\n\\n    // s and t as x, y\\n    return dfs(...s, max, new Set(), t) && dfs(...t, max, new Set(), s);\\n\\n    // Get Hash\\n    function hash(x, y) {\\n        return 1123 * x + y;\\n    }\\n\\n    // DFS Handler\\n    function dfs(x, y, max, v, t) {\\n        if (x < 0 || x >= 1e6 || y < 0 || y >= 1e6 || spc.has(hash(x, y)) || v.has(hash(x, y))) {\\n            return false;\\n        }\\n        if (--max <= 0 || (x === t[0] && y === t[1])) {\\n            return true;\\n        }\\n        // Add Hash into Set\\n        v.add(hash(x, y));\\n        \\n        // Recursion\\n        return dir.reduce((a, c) => a || dfs(x + c[0], y + c[1], max, v, t), false);\\n    }\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1481290,
                "title": "python-bfs-with-improvement",
                "content": "```python\\nclass Solution:\\n    def isEscapePossible(\\n        self,\\n        blocked: list[list[int]],\\n        source: list[int],\\n        target: list[int]\\n    ) -> bool:\\n        \"\"\"\\n        1. If the total length of blocked is B, the maximum area those\\n            blocks could block is B * (B - 1) // 2. We could simply put\\n            them on the diagonal to achieve the maximum blocked area:\\n            0    oooox\\n            1    ooox\\n            2    oox\\n            3    ox\\n            4    x\\n            B = 5, blocked area is 4 + 3 + 2 + 1 + 0 = 5 * 4 / 2 = 10.\\n        2. Then we could do a bfs search from source cell to target. when\\n            we have walked more steps than the above maximum blocked area,\\n            we could take that we are no longer blocked if we still have\\n            not reached the target yet.\\n        3. Notice that we should check both sides: from source to target\\n            and from target to source to make sure both sides are not\\n            blocked by those blockers.\\n        \"\"\"\\n        def walk(source: list[int], target: list[int]) -> bool:\\n            currCells = [source]\\n            visited = {tuple(source)}\\n            for r, c in currCells:\\n                for nr, nc in [(r - 1, c), (r + 1, c), (r, c - 1), (r, c + 1)]:\\n                    if 0 <= nr < MAX_POSITION and 0 <= nc < MAX_POSITION and \\\\\\n                            (nr, nc) not in visited and (nr, nc) not in blocks:\\n                        if [nr, nc] == target:\\n                            return True\\n\\n                        currCells.append([nr, nc])\\n                        visited.add((nr, nc))\\n\\n                if len(currCells) > MAX_BLOCKED_AREA:\\n                    return True\\n\\n            return False\\n\\n        if not blocked:  # No blocks.\\n            return True\\n\\n        B = len(blocked)\\n        MAX_POSITION = 10 ** 6\\n        MAX_BLOCKED_AREA = (B * (B - 1)) >> 1\\n        blocks = {tuple(cell) for cell in blocked}\\n        return walk(source, target) and walk(target, source)\\n```",
                "solutionTags": [
                    "Python3",
                    "Breadth-First Search"
                ],
                "code": "```python\\nclass Solution:\\n    def isEscapePossible(\\n        self,\\n        blocked: list[list[int]],\\n        source: list[int],\\n        target: list[int]\\n    ) -> bool:\\n        \"\"\"\\n        1. If the total length of blocked is B, the maximum area those\\n            blocks could block is B * (B - 1) // 2. We could simply put\\n            them on the diagonal to achieve the maximum blocked area:\\n            0    oooox\\n            1    ooox\\n            2    oox\\n            3    ox\\n            4    x\\n            B = 5, blocked area is 4 + 3 + 2 + 1 + 0 = 5 * 4 / 2 = 10.\\n        2. Then we could do a bfs search from source cell to target. when\\n            we have walked more steps than the above maximum blocked area,\\n            we could take that we are no longer blocked if we still have\\n            not reached the target yet.\\n        3. Notice that we should check both sides: from source to target\\n            and from target to source to make sure both sides are not\\n            blocked by those blockers.\\n        \"\"\"\\n        def walk(source: list[int], target: list[int]) -> bool:\\n            currCells = [source]\\n            visited = {tuple(source)}\\n            for r, c in currCells:\\n                for nr, nc in [(r - 1, c), (r + 1, c), (r, c - 1), (r, c + 1)]:\\n                    if 0 <= nr < MAX_POSITION and 0 <= nc < MAX_POSITION and \\\\\\n                            (nr, nc) not in visited and (nr, nc) not in blocks:\\n                        if [nr, nc] == target:\\n                            return True\\n\\n                        currCells.append([nr, nc])\\n                        visited.add((nr, nc))\\n\\n                if len(currCells) > MAX_BLOCKED_AREA:\\n                    return True\\n\\n            return False\\n\\n        if not blocked:  # No blocks.\\n            return True\\n\\n        B = len(blocked)\\n        MAX_POSITION = 10 ** 6\\n        MAX_BLOCKED_AREA = (B * (B - 1)) >> 1\\n        blocks = {tuple(cell) for cell in blocked}\\n        return walk(source, target) and walk(target, source)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 765663,
                "title": "java-simple-compression-bfs-beats-92-with-comments",
                "content": "```\\nclass Solution {\\n    int dir[][] = {\\n        {0, 1}, {1, 0}, {-1, 0}, {0, -1}\\n    };\\n\\n    int MILLION = 1000000 - 1;\\n    public boolean isEscapePossible(int[][] blocked, int[] source, int[] target) {\\n        List<Point> list = new ArrayList();\\n        \\n        // let\\'s find we have any element i.e. source, target or blocked on boundary.\\n        // If no than we can add extra layer of rows to our compressed matrix.\\n        boolean isBoundary = false;\\n        for(int[] b: blocked) {\\n            if(b[0] == 0 || b[1] == 0 || b[0] == MILLION || b[1] == MILLION) isBoundary = true;\\n            list.add(new Point(b[0], b[1], \\'b\\'));\\n        }\\n        \\n        isBoundary = onBoundary(source) || onBoundary(target);\\n         \\n        list.add(new Point(source[0], source[1], \\'s\\'));\\n        list.add(new Point(target[0], target[1], \\'t\\'));\\n        \\n        // Let\\'s compress are blocked points for reasonable BFS.\\n        int n = compressX(list);\\n        int m = compressY(list);\\n        /*\\n        if any element is on boundary than we do not need to add extra layer of rows as it will provide a non-\\n        existent path\\n        consider this case (s -> source, t -> target, 1 -> blocked)\\n        s 0 1 0 0\\n        0 1 0 1 0\\n        1 0 0 0 1\\n        0 1 0 1 0\\n        0 0 1 0 t\\n        \\n        we need an extra layer of rows in this case, as otherwise out of bounds will lead to wrong answer.\\n        s 0 0 0 0\\n        0 1 0 1 0\\n        1 0 0 0 1\\n        0 1 0 1 0\\n        0 0 1 0 t\\n        */\\n        \\n        // n + 2 size, if we shift entire matrix by size 1, i.e. adding cushion of one layer.\\n        n = isBoundary?n + 1:n + 2;\\n        m = isBoundary?m + 1:m + 2;\\n       \\n        int[][] matrix = new int[n][m];\\n        int[] src = new int[2];\\n        int[] trg = new int[2];\\n\\n        for(Point p: list) {\\n            int x = isBoundary?p.x:p.x + 1; // shifting by 1\\n            int y = isBoundary?p.y:p.y + 1; // shifting by 1\\n\\n            if(p.id == \\'s\\') {\\n                src[0] = x;\\n                src[1] = y;\\n            } else if(p.id == \\'t\\') {\\n                trg[0] = x;\\n                trg[1] = y;\\n            } else matrix[x][y] = 1; // marking as blocked\\n            \\n        }\\n              \\n        // Simple BFS\\n        Queue<int[]> q = new LinkedList();\\n        boolean[][] visit = new boolean[n][m];\\n        q.offer(src);\\n        visit[src[0]][src[1]] = true;\\n        \\n        while(!q.isEmpty()) {\\n            int cur[] = q.poll();\\n\\n            for(int[] d: dir) {\\n                int x = cur[0] + d[0];\\n                int y = cur[1] + d[1];\\n                if(x == trg[0] && y == trg[1]) return true;\\n                \\n                if(x < 0 || y < 0 || x == n || y == m || matrix[x][y] == 1 || visit[x][y]) continue;\\n\\n                q.offer(new int[]{x, y});\\n                visit[x][y] = true;\\n            }\\n            \\n        }\\n      \\n        return false;\\n\\n    }\\n    \\n    public int compressX(List<Point> list)  {\\n        // sorting in ascending order\\n        Collections.sort(list, (a, b) -> a.x - b.x);\\n        Point actualPrev = null, prev = null;\\n        int offset = list.get(0).x;\\n        int n = 0;\\n        for(Point p: list) {\\n            p.x -= offset;\\n            Point temp = new Point(p.x, p.y, p.id);\\n\\n            if(prev == null) p.x = 0;\\n            else {\\n                int diff = p.x - actualPrev.x;\\n                // even if difference is 100000, it can be represented as 2\\n                // e.g. 1 0 0 0 0 0 0 0 1 -> 1 0 1 (1 is blocked point)\\n                if(diff > 1) p.x = prev.x + 2;\\n                else if(diff == 1) p.x = prev.x + 1;\\n                else p.x = prev.x;\\n                 \\n            }\\n            n = Math.max(n, p.x);\\n            prev = p;\\n            actualPrev = temp;\\n        }        \\n        \\n        return n;\\n    }\\n    \\n     public int compressY(List<Point> list)  {\\n        // sorting in ascending order\\n        Collections.sort(list, (a, b) -> a.y - b.y);\\n        Point prev = null;\\n        Point actualPrev = null;\\n        int offset = list.get(0).y;\\n        int m = 0;\\n        for(Point p: list) {\\n            p.y -= offset;\\n            Point temp = new Point(p.x, p.y, p.id);\\n\\n            if(prev == null) p.y = 0;\\n            else {\\n                int diff = p.y - actualPrev.y; \\n                // even if difference is 100000, it can be represented as 2\\n                // e.g. 1 0 0 0 0 0 0 0 1 -> 1 0 1 (1 is blocked point)\\n                if(diff > 1) p.y = prev.y + 2;\\n                else if(p.y - actualPrev.y == 1) p.y = prev.y + 1;\\n                else p.y = prev.y;    \\n            }\\n            \\n            m = Math.max(m, p.y);\\n            prev = p;\\n            actualPrev = temp;\\n        }\\n         return m;\\n    }\\n    \\n    public boolean onBoundary(int[] arr) {\\n         return (arr[0] == 0 || arr[1] == 0 || arr[0] == MILLION || arr[1] == MILLION);\\n    }\\n    \\n    class Point {\\n        int x, y;\\n        char id;\\n        Point(int x, int y, char id) {\\n            this.x = x;\\n            this.y = y;\\n            this.id = id;\\n        }\\n        \\n        public String toString() {\\n            return \"[\" + x + \", \" + y + \", \" + id + \"]\";\\n        }\\n        \\n        public boolean equals(Object other) {\\n            Point o = (Point)other;\\n            return o.x == x && o.y == y;\\n        }\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    int dir[][] = {\\n        {0, 1}, {1, 0}, {-1, 0}, {0, -1}\\n    };\\n\\n    int MILLION = 1000000 - 1;\\n    public boolean isEscapePossible(int[][] blocked, int[] source, int[] target) {\\n        List<Point> list = new ArrayList();\\n        \\n        // let\\'s find we have any element i.e. source, target or blocked on boundary.\\n        // If no than we can add extra layer of rows to our compressed matrix.\\n        boolean isBoundary = false;\\n        for(int[] b: blocked) {\\n            if(b[0] == 0 || b[1] == 0 || b[0] == MILLION || b[1] == MILLION) isBoundary = true;\\n            list.add(new Point(b[0], b[1], \\'b\\'));\\n        }\\n        \\n        isBoundary = onBoundary(source) || onBoundary(target);\\n         \\n        list.add(new Point(source[0], source[1], \\'s\\'));\\n        list.add(new Point(target[0], target[1], \\'t\\'));\\n        \\n        // Let\\'s compress are blocked points for reasonable BFS.\\n        int n = compressX(list);\\n        int m = compressY(list);\\n        /*\\n        if any element is on boundary than we do not need to add extra layer of rows as it will provide a non-\\n        existent path\\n        consider this case (s -> source, t -> target, 1 -> blocked)\\n        s 0 1 0 0\\n        0 1 0 1 0\\n        1 0 0 0 1\\n        0 1 0 1 0\\n        0 0 1 0 t\\n        \\n        we need an extra layer of rows in this case, as otherwise out of bounds will lead to wrong answer.\\n        s 0 0 0 0\\n        0 1 0 1 0\\n        1 0 0 0 1\\n        0 1 0 1 0\\n        0 0 1 0 t\\n        */\\n        \\n        // n + 2 size, if we shift entire matrix by size 1, i.e. adding cushion of one layer.\\n        n = isBoundary?n + 1:n + 2;\\n        m = isBoundary?m + 1:m + 2;\\n       \\n        int[][] matrix = new int[n][m];\\n        int[] src = new int[2];\\n        int[] trg = new int[2];\\n\\n        for(Point p: list) {\\n            int x = isBoundary?p.x:p.x + 1; // shifting by 1\\n            int y = isBoundary?p.y:p.y + 1; // shifting by 1\\n\\n            if(p.id == \\'s\\') {\\n                src[0] = x;\\n                src[1] = y;\\n            } else if(p.id == \\'t\\') {\\n                trg[0] = x;\\n                trg[1] = y;\\n            } else matrix[x][y] = 1; // marking as blocked\\n            \\n        }\\n              \\n        // Simple BFS\\n        Queue<int[]> q = new LinkedList();\\n        boolean[][] visit = new boolean[n][m];\\n        q.offer(src);\\n        visit[src[0]][src[1]] = true;\\n        \\n        while(!q.isEmpty()) {\\n            int cur[] = q.poll();\\n\\n            for(int[] d: dir) {\\n                int x = cur[0] + d[0];\\n                int y = cur[1] + d[1];\\n                if(x == trg[0] && y == trg[1]) return true;\\n                \\n                if(x < 0 || y < 0 || x == n || y == m || matrix[x][y] == 1 || visit[x][y]) continue;\\n\\n                q.offer(new int[]{x, y});\\n                visit[x][y] = true;\\n            }\\n            \\n        }\\n      \\n        return false;\\n\\n    }\\n    \\n    public int compressX(List<Point> list)  {\\n        // sorting in ascending order\\n        Collections.sort(list, (a, b) -> a.x - b.x);\\n        Point actualPrev = null, prev = null;\\n        int offset = list.get(0).x;\\n        int n = 0;\\n        for(Point p: list) {\\n            p.x -= offset;\\n            Point temp = new Point(p.x, p.y, p.id);\\n\\n            if(prev == null) p.x = 0;\\n            else {\\n                int diff = p.x - actualPrev.x;\\n                // even if difference is 100000, it can be represented as 2\\n                // e.g. 1 0 0 0 0 0 0 0 1 -> 1 0 1 (1 is blocked point)\\n                if(diff > 1) p.x = prev.x + 2;\\n                else if(diff == 1) p.x = prev.x + 1;\\n                else p.x = prev.x;\\n                 \\n            }\\n            n = Math.max(n, p.x);\\n            prev = p;\\n            actualPrev = temp;\\n        }        \\n        \\n        return n;\\n    }\\n    \\n     public int compressY(List<Point> list)  {\\n        // sorting in ascending order\\n        Collections.sort(list, (a, b) -> a.y - b.y);\\n        Point prev = null;\\n        Point actualPrev = null;\\n        int offset = list.get(0).y;\\n        int m = 0;\\n        for(Point p: list) {\\n            p.y -= offset;\\n            Point temp = new Point(p.x, p.y, p.id);\\n\\n            if(prev == null) p.y = 0;\\n            else {\\n                int diff = p.y - actualPrev.y; \\n                // even if difference is 100000, it can be represented as 2\\n                // e.g. 1 0 0 0 0 0 0 0 1 -> 1 0 1 (1 is blocked point)\\n                if(diff > 1) p.y = prev.y + 2;\\n                else if(p.y - actualPrev.y == 1) p.y = prev.y + 1;\\n                else p.y = prev.y;    \\n            }\\n            \\n            m = Math.max(m, p.y);\\n            prev = p;\\n            actualPrev = temp;\\n        }\\n         return m;\\n    }\\n    \\n    public boolean onBoundary(int[] arr) {\\n         return (arr[0] == 0 || arr[1] == 0 || arr[0] == MILLION || arr[1] == MILLION);\\n    }\\n    \\n    class Point {\\n        int x, y;\\n        char id;\\n        Point(int x, int y, char id) {\\n            this.x = x;\\n            this.y = y;\\n            this.id = id;\\n        }\\n        \\n        public String toString() {\\n            return \"[\" + x + \", \" + y + \", \" + id + \"]\";\\n        }\\n        \\n        public boolean equals(Object other) {\\n            Point o = (Point)other;\\n            return o.x == x && o.y == y;\\n        }\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 446172,
                "title": "java-two-bfs-count-visited-area-runtime-80",
                "content": "```\\nclass Solution {\\n    int border = 1000000;\\n    int[][] dirs = new int[][]{{0,1},{0,-1},{1,0},{-1,0}};\\n    public boolean isEscapePossible(int[][] blocked, int[] source, int[] target) {\\n        HashSet<Long> blocks = new HashSet();\\n        for(int[] block : blocked){\\n            blocks.add(hash(block));\\n        }\\n        return !(isBlocked(blocks, source, target) || isBlocked(blocks, target, source));\\n    }\\n    \\n    private boolean isBlocked(HashSet<Long> blocks, int[] source, int[] target){\\n        int n = blocks.size();\\n        int area = n*n/2;\\n        HashSet<Long> visited = new HashSet();\\n        Queue<int[]> q = new LinkedList();\\n        q.offer(source);\\n        visited.add(hash(source));\\n        while(!q.isEmpty()){\\n            int[] pos = q.poll();\\n            if(pos[0]==target[0] && pos[1]==target[1] || visited.size() > area){\\n                return false;\\n            }\\n            for(int[] dir : dirs){\\n                int nextX = dir[0] + pos[0];\\n                int nextY = dir[1] + pos[1];\\n                long nextHash = hash(new int[]{nextX, nextY});\\n                if(nextX>=0 && nextX<border && nextY>=0 && nextY<border && !visited.contains(nextHash) && !blocks.contains(nextHash)){\\n                    visited.add(nextHash);\\n                    q.offer(new int[]{nextX, nextY});\\n                }\\n            }\\n        }\\n        return true;\\n    }\\n    \\n    private long hash(int[] pos){\\n        return pos[0]*1000000+pos[1];\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    int border = 1000000;\\n    int[][] dirs = new int[][]{{0,1},{0,-1},{1,0},{-1,0}};\\n    public boolean isEscapePossible(int[][] blocked, int[] source, int[] target) {\\n        HashSet<Long> blocks = new HashSet();\\n        for(int[] block : blocked){\\n            blocks.add(hash(block));\\n        }\\n        return !(isBlocked(blocks, source, target) || isBlocked(blocks, target, source));\\n    }\\n    \\n    private boolean isBlocked(HashSet<Long> blocks, int[] source, int[] target){\\n        int n = blocks.size();\\n        int area = n*n/2;\\n        HashSet<Long> visited = new HashSet();\\n        Queue<int[]> q = new LinkedList();\\n        q.offer(source);\\n        visited.add(hash(source));\\n        while(!q.isEmpty()){\\n            int[] pos = q.poll();\\n            if(pos[0]==target[0] && pos[1]==target[1] || visited.size() > area){\\n                return false;\\n            }\\n            for(int[] dir : dirs){\\n                int nextX = dir[0] + pos[0];\\n                int nextY = dir[1] + pos[1];\\n                long nextHash = hash(new int[]{nextX, nextY});\\n                if(nextX>=0 && nextX<border && nextY>=0 && nextY<border && !visited.contains(nextHash) && !blocks.contains(nextHash)){\\n                    visited.add(nextHash);\\n                    q.offer(new int[]{nextX, nextY});\\n                }\\n            }\\n        }\\n        return true;\\n    }\\n    \\n    private long hash(int[] pos){\\n        return pos[0]*1000000+pos[1];\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 291549,
                "title": "c-bfs-solution",
                "content": "```\\n\\npublic class Solution {\\n    public bool IsEscapePossible(int[][] blocked, int[] source, int[] target) {\\n        if (blocked.Count() < 2) {\\n            return true;\\n        }\\n        int isBlocked = isSurroanded(blocked, source, target);\\n        if(isBlocked == 2) {\\n            return true;\\n        }\\n        if(isBlocked == 0) {\\n            return false;\\n        }\\n        \\n        return isSurroanded(blocked, target, source) != 0;\\n    }\\n    \\n    public int isSurroanded(int[][] blocked, int[] point, int[] target) {\\n        \\n        Queue<int[]> numbers = new Queue<int[]>();\\n                        \\n        int maxFit = blocked.Count() * (blocked.Count() - 1) / 2;\\n        \\n        HashSet<string> visited = new HashSet<string>();  \\n        \\n        foreach(var b in blocked) {\\n            visited.Add(b[0] + \",\" + b[1]);\\n        }\\n        \\n        \\n        if(point[0] > 0){\\n            numbers.Enqueue(new int[]{point[0] - 1, point[1]});\\n        }\\n        \\n        if(point[0] < 999999){\\n            numbers.Enqueue(new int[]{point[0] + 1, point[1]});\\n        }\\n        \\n        if(point[1] > 0){\\n            numbers.Enqueue(new int[]{point[0], point[1] - 1});\\n        }\\n        \\n        if(point[1] < 999999){\\n            numbers.Enqueue(new int[]{point[0], point[1] + 1});\\n        }\\n        \\n       \\n                \\n        while(numbers.Count() != 0) {\\n            int[] newPoint = numbers.Dequeue();               \\n            \\n            if(visited.Contains(newPoint[0] + \",\" + newPoint[1])){\\n                continue;\\n            } \\n            \\n            if (visited.Count() >= maxFit)\\n            {\\n                return 1;\\n            }\\n            \\n            if(newPoint[0] == target[0] && newPoint[1] == target[1]) \\n            {\\n                return 2;\\n            }\\n                     \\n            visited.Add(newPoint[0] + \",\" +  newPoint[1]);\\n            \\n            if(newPoint[0] > 0){\\n                numbers.Enqueue(new int[]{newPoint[0] - 1, newPoint[1]});\\n            }\\n        \\n            if(newPoint[0] < 999999){\\n                numbers.Enqueue(new int[]{newPoint[0] + 1, newPoint[1]});\\n            }\\n        \\n            if(newPoint[1] > 0){\\n                numbers.Enqueue(new int[]{newPoint[0], newPoint[1] - 1});\\n            }\\n        \\n            if(newPoint[1] < 999999){\\n                numbers.Enqueue(new int[]{newPoint[0], newPoint[1] + 1});\\n            }            \\n        }\\n        return 0;\\n    }\\n    \\n    \\n}\\n\\n```",
                "solutionTags": [],
                "code": "```\\n\\npublic class Solution {\\n    public bool IsEscapePossible(int[][] blocked, int[] source, int[] target) {\\n        if (blocked.Count() < 2) {\\n            return true;\\n        }\\n        int isBlocked = isSurroanded(blocked, source, target);\\n        if(isBlocked == 2) {\\n            return true;\\n        }\\n        if(isBlocked == 0) {\\n            return false;\\n        }\\n        \\n        return isSurroanded(blocked, target, source) != 0;\\n    }\\n    \\n    public int isSurroanded(int[][] blocked, int[] point, int[] target) {\\n        \\n        Queue<int[]> numbers = new Queue<int[]>();\\n                        \\n        int maxFit = blocked.Count() * (blocked.Count() - 1) / 2;\\n        \\n        HashSet<string> visited = new HashSet<string>();  \\n        \\n        foreach(var b in blocked) {\\n            visited.Add(b[0] + \",\" + b[1]);\\n        }\\n        \\n        \\n        if(point[0] > 0){\\n            numbers.Enqueue(new int[]{point[0] - 1, point[1]});\\n        }\\n        \\n        if(point[0] < 999999){\\n            numbers.Enqueue(new int[]{point[0] + 1, point[1]});\\n        }\\n        \\n        if(point[1] > 0){\\n            numbers.Enqueue(new int[]{point[0], point[1] - 1});\\n        }\\n        \\n        if(point[1] < 999999){\\n            numbers.Enqueue(new int[]{point[0], point[1] + 1});\\n        }\\n        \\n       \\n                \\n        while(numbers.Count() != 0) {\\n            int[] newPoint = numbers.Dequeue();               \\n            \\n            if(visited.Contains(newPoint[0] + \",\" + newPoint[1])){\\n                continue;\\n            } \\n            \\n            if (visited.Count() >= maxFit)\\n            {\\n                return 1;\\n            }\\n            \\n            if(newPoint[0] == target[0] && newPoint[1] == target[1]) \\n            {\\n                return 2;\\n            }\\n                     \\n            visited.Add(newPoint[0] + \",\" +  newPoint[1]);\\n            \\n            if(newPoint[0] > 0){\\n                numbers.Enqueue(new int[]{newPoint[0] - 1, newPoint[1]});\\n            }\\n        \\n            if(newPoint[0] < 999999){\\n                numbers.Enqueue(new int[]{newPoint[0] + 1, newPoint[1]});\\n            }\\n        \\n            if(newPoint[1] > 0){\\n                numbers.Enqueue(new int[]{newPoint[0], newPoint[1] - 1});\\n            }\\n        \\n            if(newPoint[1] < 999999){\\n                numbers.Enqueue(new int[]{newPoint[0], newPoint[1] + 1});\\n            }            \\n        }\\n        return 0;\\n    }\\n    \\n    \\n}\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 284446,
                "title": "c-limited-bfs-memory-usage-less-than-100",
                "content": "Informed by solution from lee215\\nhttps://leetcode.com/problems/escape-a-large-maze/discuss/282849/Python-Maximum-Blocked-19900-(Video)\\n\\n```\\nclass Solution {\\nprivate:\\n    int length = 1e6;\\n\\n    bool search(vector<int>& source, vector<int>& target, unordered_map<int, unordered_map<int, bool>>& blocked) {\\n        unordered_map<int, unordered_map<int, bool>> visited;\\n        visited[source[0]][source[1]] = true;\\n\\n        queue<pair<int, int>> bfs;\\n        bfs.push({source[0], source[1]});\\n\\n        vector<int> rDiff = {0, 0, 1, -1};\\n        vector<int> cDiff = {1, -1, 0, 0};\\n        int area = 1;\\n        while (!bfs.empty()) {\\n            int r = bfs.front().first;\\n            int c = bfs.front().second;\\n            bfs.pop();\\n\\n            if (r == target[0] and c == target[1]) {\\n                return true;\\n            }\\n\\n            if (area == 20000) {\\n                return true;\\n            }\\n\\n            for (int i = 0; i < 4; ++i) {\\n                int nr = r + rDiff[i];\\n                int nc = c + cDiff[i];\\n                if (nr >= 0 and nr < length and nc >= 0 and nc < length and !visited[nr][nc] and !blocked[nr][nc]) {\\n                    area += 1;\\n                    bfs.push({nr, nc});\\n                    visited[nr][nc] = true;\\n                }\\n            }\\n        }\\n        return false;\\n    }\\npublic:\\n    bool isEscapePossible(vector<vector<int>>& blocked, vector<int>& source, vector<int>& target) {\\n        unordered_map<int, unordered_map<int, bool>> blocks;\\n        for (vector<int>& b : blocked) {\\n            blocks[b[0]][b[1]] = true;\\n        }\\n        return search(source, target, blocks) and search(target, source, blocks);\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\nprivate:\\n    int length = 1e6;\\n\\n    bool search(vector<int>& source, vector<int>& target, unordered_map<int, unordered_map<int, bool>>& blocked) {\\n        unordered_map<int, unordered_map<int, bool>> visited;\\n        visited[source[0]][source[1]] = true;\\n\\n        queue<pair<int, int>> bfs;\\n        bfs.push({source[0], source[1]});\\n\\n        vector<int> rDiff = {0, 0, 1, -1};\\n        vector<int> cDiff = {1, -1, 0, 0};\\n        int area = 1;\\n        while (!bfs.empty()) {\\n            int r = bfs.front().first;\\n            int c = bfs.front().second;\\n            bfs.pop();\\n\\n            if (r == target[0] and c == target[1]) {\\n                return true;\\n            }\\n\\n            if (area == 20000) {\\n                return true;\\n            }\\n\\n            for (int i = 0; i < 4; ++i) {\\n                int nr = r + rDiff[i];\\n                int nc = c + cDiff[i];\\n                if (nr >= 0 and nr < length and nc >= 0 and nc < length and !visited[nr][nc] and !blocked[nr][nc]) {\\n                    area += 1;\\n                    bfs.push({nr, nc});\\n                    visited[nr][nc] = true;\\n                }\\n            }\\n        }\\n        return false;\\n    }\\npublic:\\n    bool isEscapePossible(vector<vector<int>>& blocked, vector<int>& source, vector<int>& target) {\\n        unordered_map<int, unordered_map<int, bool>> blocks;\\n        for (vector<int>& b : blocked) {\\n            blocks[b[0]][b[1]] = true;\\n        }\\n        return search(source, target, blocks) and search(target, source, blocks);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 282837,
                "title": "java-bfs-with-limited-steps",
                "content": "it can pass, though this might be not the best solution, I feel bi-directional BFS should be better. \\n\\n\\n```\\nclass Solution {\\n    public boolean isEscapePossible(int[][] blocked, int[] source, int[] target) {\\n        \\n        Map<Integer, Set<Integer>> map = new HashMap<>();\\n        for(int[] item: blocked) {\\n            Set<Integer> set = map.get(item[0]);\\n            if(null == set) {\\n                set = new HashSet<>();\\n                map.put(item[0], set);\\n            }\\n            set.add(item[1]);\\n        }\\n        \\n        if(bfsBlocked(map, blocked.length+1, source, target) || bfsBlocked(map, blocked.length+1, target, source)) {\\n            return false;\\n        }\\n        return true;\\n    }\\n    \\n    boolean bfsBlocked(Map<Integer, Set<Integer>> blocked, int maxsteps, int[] source, int[] target) {\\n        Queue<int[]> queue = new LinkedList<>();\\n        queue.add(source);\\n        int steps = 0;\\n        Map<Integer, Set<Integer>> visited = new HashMap<>();\\n        Set<Integer> set0 = new HashSet<>();\\n        set0.add(source[1]);\\n        visited.put(source[0], set0);\\n        \\n        int[][] dirs = {{-1,0}, {1,0}, {0,1}, {0,-1}};\\n        \\n        while(!queue.isEmpty()) {\\n            Queue<int[]> nextQueue = new LinkedList<>();\\n            while(!queue.isEmpty()) {\\n                int[] cur = queue.poll();\\n                //System.out.println(cur[0] + \",\" + cur[1]);\\n                \\n                for(int k = 0; k < dirs.length; ++k) {\\n                    int nextx = cur[0] + dirs[k][0];\\n                    int nexty = cur[1] + dirs[k][1];\\n                    if(nextx < 0 || nexty < 0 || nextx >= 1000000 || nexty >= 1000000) continue;\\n                    \\n                    Set<Integer> blockedSet = blocked.get(nextx);\\n                    if(null != blockedSet && blockedSet.contains(nexty)) {\\n                        continue;\\n                    }\\n                    \\n                    if(nextx == target[0] && nexty == target[1]) {\\n                        return false;\\n                    }\\n                    \\n                    Set<Integer> visitedSet = visited.get(nextx);\\n                    if(null == visitedSet || !visitedSet.contains(nexty)) {\\n                        if(null == visitedSet) {\\n                            visitedSet = new HashSet<>();\\n                            visited.put(nextx, visitedSet);\\n                        }\\n                        visitedSet.add(nexty);\\n                        nextQueue.add(new int[]{nextx, nexty});\\n                    }\\n                }        \\n            }\\n            queue = nextQueue;\\n            steps++;\\n            if(steps > maxsteps) {\\n                return false;\\n            }\\n        }\\n        return true;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public boolean isEscapePossible(int[][] blocked, int[] source, int[] target) {\\n        \\n        Map<Integer, Set<Integer>> map = new HashMap<>();\\n        for(int[] item: blocked) {\\n            Set<Integer> set = map.get(item[0]);\\n            if(null == set) {\\n                set = new HashSet<>();\\n                map.put(item[0], set);\\n            }\\n            set.add(item[1]);\\n        }\\n        \\n        if(bfsBlocked(map, blocked.length+1, source, target) || bfsBlocked(map, blocked.length+1, target, source)) {\\n            return false;\\n        }\\n        return true;\\n    }\\n    \\n    boolean bfsBlocked(Map<Integer, Set<Integer>> blocked, int maxsteps, int[] source, int[] target) {\\n        Queue<int[]> queue = new LinkedList<>();\\n        queue.add(source);\\n        int steps = 0;\\n        Map<Integer, Set<Integer>> visited = new HashMap<>();\\n        Set<Integer> set0 = new HashSet<>();\\n        set0.add(source[1]);\\n        visited.put(source[0], set0);\\n        \\n        int[][] dirs = {{-1,0}, {1,0}, {0,1}, {0,-1}};\\n        \\n        while(!queue.isEmpty()) {\\n            Queue<int[]> nextQueue = new LinkedList<>();\\n            while(!queue.isEmpty()) {\\n                int[] cur = queue.poll();\\n                //System.out.println(cur[0] + \",\" + cur[1]);\\n                \\n                for(int k = 0; k < dirs.length; ++k) {\\n                    int nextx = cur[0] + dirs[k][0];\\n                    int nexty = cur[1] + dirs[k][1];\\n                    if(nextx < 0 || nexty < 0 || nextx >= 1000000 || nexty >= 1000000) continue;\\n                    \\n                    Set<Integer> blockedSet = blocked.get(nextx);\\n                    if(null != blockedSet && blockedSet.contains(nexty)) {\\n                        continue;\\n                    }\\n                    \\n                    if(nextx == target[0] && nexty == target[1]) {\\n                        return false;\\n                    }\\n                    \\n                    Set<Integer> visitedSet = visited.get(nextx);\\n                    if(null == visitedSet || !visitedSet.contains(nexty)) {\\n                        if(null == visitedSet) {\\n                            visitedSet = new HashSet<>();\\n                            visited.put(nextx, visitedSet);\\n                        }\\n                        visitedSet.add(nexty);\\n                        nextQueue.add(new int[]{nextx, nexty});\\n                    }\\n                }        \\n            }\\n            queue = nextQueue;\\n            steps++;\\n            if(steps > maxsteps) {\\n                return false;\\n            }\\n        }\\n        return true;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4082042,
                "title": "apply-bfs-2-times-complete-approach-explained",
                "content": "# Approach\\n```\\n1. We make use of the fact that there can be maximum of\\n   200 blocked cells as given in problem statement.\\n\\n2. So, we perform BFS from source and try to reach at least 200 cells far. \\n   This means source was not surrounded by blocked states from all sides.\\n\\n3. Similarly, we start from target cell and try to reach at least 200 cells far. \\n   This means target was not surrounded by blocked  states from all sides.\\n\\n4. If above 2 conditions hold simultaneously, then we can return true, \\n   otherwise we return false.\\n\\n5. We used vis[i*1e6+j] notation instead of traditional vis[i][j] \\n   in order to save space which is crucial to pass all test cases.\\n```\\n# Complexity\\n- Time complexity: $$O(n^2)$$ \\n\\n- Space complexity: $$O(n)$$ \\n# Code\\n```\\nclass Solution {\\n    vector<int> dx = {-1,0,1,0};\\n    vector<int> dy = {0,1,0,-1};\\n    bool solve(int x, int y, vector<int>& last, unordered_set<long long>& isBlocked)\\n    {\\n        queue<long long> q;\\n        unordered_set<long long> vis;\\n        q.push(x*1e6+y);\\n        vis.insert(x*1e6+y);\\n        int dis = 0;\\n        while(!q.empty())\\n        {\\n            int size = q.size();\\n            while(size--)\\n            {\\n                long long curr = q.front();\\n                q.pop();\\n\\n                int row = curr/1e6, col = curr%1000000;\\n\\n                //if we can cross 200 cells or we have reached our destination cell\\n                if(dis >= 200 || (row == last[0] && col == last[1]))\\n                 return true;\\n                \\n                for(int k=0; k<4; k++)\\n                {\\n                  int i = row + dx[k];\\n                  int j = col + dy[k];\\n                  long long currCell = i*1e6 + j;\\n                   if(i >= 0 && i < 1e6 && j >= 0 && j < 1e6 && (vis.find(currCell) == vis.end()) && (isBlocked.find(currCell) == isBlocked.end()))\\n                   {\\n                     q.push(currCell);\\n                     vis.insert(currCell);\\n                    }\\n                }\\n            }\\n        dis++;\\n        }\\n    return false;\\n    }\\npublic:\\n    bool isEscapePossible(vector<vector<int>>& blocked, vector<int>& source, vector<int>& target) {\\n        if(blocked.size() == 0) //edge case\\n         return true;\\n        unordered_set<long long> isBlocked;\\n        for(auto it : blocked) {\\n            isBlocked.insert(it[0]*1e6+it[1]);\\n        }\\n        return solve(source[0], source[1], target, isBlocked) \\n            && solve(target[0], target[1], source, isBlocked);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Hash Table",
                    "Breadth-First Search"
                ],
                "code": "```\\n1. We make use of the fact that there can be maximum of\\n   200 blocked cells as given in problem statement.\\n\\n2. So, we perform BFS from source and try to reach at least 200 cells far. \\n   This means source was not surrounded by blocked states from all sides.\\n\\n3. Similarly, we start from target cell and try to reach at least 200 cells far. \\n   This means target was not surrounded by blocked  states from all sides.\\n\\n4. If above 2 conditions hold simultaneously, then we can return true, \\n   otherwise we return false.\\n\\n5. We used vis[i*1e6+j] notation instead of traditional vis[i][j] \\n   in order to save space which is crucial to pass all test cases.\\n```\n```\\nclass Solution {\\n    vector<int> dx = {-1,0,1,0};\\n    vector<int> dy = {0,1,0,-1};\\n    bool solve(int x, int y, vector<int>& last, unordered_set<long long>& isBlocked)\\n    {\\n        queue<long long> q;\\n        unordered_set<long long> vis;\\n        q.push(x*1e6+y);\\n        vis.insert(x*1e6+y);\\n        int dis = 0;\\n        while(!q.empty())\\n        {\\n            int size = q.size();\\n            while(size--)\\n            {\\n                long long curr = q.front();\\n                q.pop();\\n\\n                int row = curr/1e6, col = curr%1000000;\\n\\n                //if we can cross 200 cells or we have reached our destination cell\\n                if(dis >= 200 || (row == last[0] && col == last[1]))\\n                 return true;\\n                \\n                for(int k=0; k<4; k++)\\n                {\\n                  int i = row + dx[k];\\n                  int j = col + dy[k];\\n                  long long currCell = i*1e6 + j;\\n                   if(i >= 0 && i < 1e6 && j >= 0 && j < 1e6 && (vis.find(currCell) == vis.end()) && (isBlocked.find(currCell) == isBlocked.end()))\\n                   {\\n                     q.push(currCell);\\n                     vis.insert(currCell);\\n                    }\\n                }\\n            }\\n        dis++;\\n        }\\n    return false;\\n    }\\npublic:\\n    bool isEscapePossible(vector<vector<int>>& blocked, vector<int>& source, vector<int>& target) {\\n        if(blocked.size() == 0) //edge case\\n         return true;\\n        unordered_set<long long> isBlocked;\\n        for(auto it : blocked) {\\n            isBlocked.insert(it[0]*1e6+it[1]);\\n        }\\n        return solve(source[0], source[1], target, isBlocked) \\n            && solve(target[0], target[1], source, isBlocked);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3561289,
                "title": "solution",
                "content": "```C++ []\\nclass Solution {\\npublic:\\n    vector<vector<int>> dirs = {{1, 0}, {-1, 0}, {0, 1}, {0, -1}}; \\n   \\n    bool isEscapePossible(vector<vector<int>>& blocked, vector<int>& source, vector<int>& target) {\\n      unordered_set<long long> visited_s;\\n      unordered_set<long long> visited_t;\\n      for (auto& block : blocked) {\\n        if (abs(source[0] - block[0]) + abs(source[1] - block[1]) <= 200)\\n          visited_s.insert(((long long)block[0] << 32) + block[1]);\\n        if (abs(target[0] - block[0]) + abs(target[1] - block[1]) <= 200)\\n          visited_t.insert(((long long)block[0] << 32) + block[1]);\\n      }\\n      return bfs(source, target, visited_s, visited_s.size()) &&\\n             bfs(target, source, visited_t, visited_t.size());\\n    }\\n    bool bfs(vector<int>& source, vector<int>& target, \\n             unordered_set<long long>& visited, int blocks) {\\n      queue<pair<int, int>> q;\\n      q.push({source[0], source[1]});\\n      while (!q.empty() && q.size() <= blocks) {\\n        int x = q.front().first;\\n        int y = q.front().second;\\n        q.pop();\\n        if (x == target[0] && y == target[1])\\n          return true;\\n        for (auto& dir : dirs) {\\n          int next_x = x + dir[0];\\n          int next_y = y + dir[1];\\n          if (next_x < 0 || next_x > 999999 || next_y < 0 || next_y > 999999\\n              || visited.find(((long long)next_x << 32) + next_y) != visited.end())\\n            continue;\\n          q.push({next_x, next_y});\\n          visited.insert(((long long)next_x << 32) + next_y);\\n        }\\n      }\\n      return !q.empty();\\n    }\\n};\\n```\\n\\n```Python3 []\\nclass Solution:\\n    def isEscapePossible(self, blocked: List[List[int]], source: List[int], target: List[int]) -> bool:\\n        \\n        escapeDist = len(blocked)\\n        \\n        def dfs(s, t, blocked):\\n            nonlocal escapeDist\\n            stk = [s]\\n            blocked.add(tuple(s))\\n            while len(stk) != 0:\\n                x, y = stk.pop()\\n                if (abs(s[0]-x) + abs(s[1]-y) >= escapeDist):\\n                    return True\\n                neighbours = [(x+1, y), (x-1, y), (x, y+1), (x, y-1)]\\n                for n in neighbours:\\n                    if n[0] > -1 and n[0] < 1000000 and n[1] > -1 and n[1] < 1000000 and n not in blocked:\\n                        stk.append(n)\\n                        blocked.add(n)\\n            return (t[0], t[1]) in blocked\\n        \\n        blocked = {(a[0], a[1]) for a in blocked}\\n        return dfs(source, target, set(blocked)) and dfs(target, source, set(blocked))\\n```\\n\\n```Java []\\nclass Solution {\\n    \\n    int[]source;\\n    int[]target;\\n    int xmin;\\n    int xmax;\\n    int ymin;\\n    int ymax;\\n    HashSet<Node>blocks;\\n    HashSet<Node>been;\\n    LinkedList<Integer>vertical;\\n    LinkedList<Integer>horizontal;\\n    int[][]neigh={{-1,-1},{-1,0},{-1,1},{0,-1},{0,1},{1,-1},{1,0},{1,1}};\\n    int[][]ds={{-1,0},{1,0},{0,-1},{0,1}};\\n    int[][]want;\\n    \\n    public boolean isEscapePossible(int[][] blocked, int[] source, int[] target) {\\n        this.source=target;\\n        this.target=target;\\n        blocks=new HashSet();\\n        been=new HashSet();\\n        vertical=new LinkedList();\\n        horizontal=new LinkedList();\\n        \\n        int xmirror=source[0]<=target[0]?1:-1;\\n        int ymirror=source[1]<=target[1]?1:-1;\\n        \\n        source[0]*=xmirror;\\n        source[1]*=ymirror;\\n        target[0]*=xmirror;\\n        target[1]*=ymirror;\\n        \\n        xmin=xmirror==1?0:(-1000000+1);\\n        xmax=xmirror==1?(1000000-1):0;\\n        ymin=ymirror==1?0:(-1000000+1);\\n        ymax=ymirror==1?(1000000-1):0;\\n        \\n        for(int[]b:blocked){\\n            int x=(b[0]*=xmirror),y=(b[1]*=ymirror);\\n            blocks.add(new Node(x,y));\\n            if(y==source[1])horizontal.offer(x);\\n            if(x==target[0])vertical.offer(y);\\n        }\\n        Collections.sort(horizontal);\\n        Collections.sort(vertical);\\n        \\n        want=new int[][]{{source[0]+1,target[0]-1,source[1],source[1]},{target[0],target[0],source[1],target[1]}};\\n        \\n        return dfs(source[0],source[1],true);   \\n    }\\n    private boolean dfs(int x,int y,boolean jump){\\n        if(x==target[0]&&y==target[1])return true;\\n        if(jump){\\n            if(x!=target[0]){\\n                ceil(horizontal,x);\\n                if(horizontal.isEmpty()||horizontal.peek()>target[0]){\\n                    want[0][0]=want[0][1]+1;//means disabled\\n                    want[1][2]=y+1;\\n                    return dfs(target[0],y,true);\\n                }\\n                else{\\n                    int nx=horizontal.peek()-1;\\n                    been.add(new Node(nx,y));\\n                    want[0][0]=nx+1;\\n                    return dfs(nx,y,false);\\n                }\\n            }\\n            else{\\n                ceil(vertical,y);\\n                if(vertical.isEmpty()||vertical.peek()>target[1])\\n                    return true;\\n                else{\\n                    int ny=vertical.peek()-1;\\n                    been.add(new Node(x,ny));\\n                    want[1][2]=ny+1;\\n                    return dfs(x,ny,false);\\n                }\\n            }\\n        }\\n        for(int[]d:ds){\\n            int nx=x+d[0], ny=y+d[1];\\n            Node node=new Node(nx,ny);\\n            if(nx>=xmin&&nx<=xmax&&ny>=ymin&&ny<=ymax\\n               &&!blocks.contains(node)&&!been.contains(node)\\n               &&hasBlockedNeighbor(nx,ny)){\\n                been.add(node);\\n                if(readyToJump(nx,ny)&&dfs(nx,ny,true))return true;\\n                if(dfs(nx,ny,false))return true;\\n            }\\n        }\\n        return false;\\n    }\\n    private void ceil(LinkedList<Integer>list,int n){\\n        while(!list.isEmpty()&&list.peek()<n)list.poll();\\n    }\\n    private boolean hasBlockedNeighbor(int x,int y){\\n        for(int[]ngh:neigh){\\n            if(blocks.contains(new Node(x+ngh[0],y+ngh[1])))\\n                return true;\\n        }\\n        return false;\\n    }\\n    private boolean readyToJump(int x,int y){\\n        if(x>=want[0][0]&&x<=want[0][1]&&y>=want[0][2]&&y<=want[0][3]){\\n            want[0][0]=x+1;\\n            return true;\\n        }\\n        if(x>=want[1][0]&&x<=want[1][1]&&y>=want[1][2]&&y<=want[1][3]){\\n            want[1][2]=y+1;\\n            return true;\\n        }\\n        return false;\\n    }   \\n}\\nclass Node {\\n    int x;\\n    int y;\\n    public Node(int xx,int yy){\\n        x=xx;\\n        y=yy;\\n    }\\n    \\n    public int hashCode(){\\n        return x+20773*y;\\n    }\\n    public boolean equals(Object obj){\\n        if(obj instanceof Node){\\n            Node n=(Node)obj;\\n            return x==n.x&&y==n.y;\\n        }\\n        return false;\\n    }\\n}\\n```",
                "solutionTags": [
                    "C++",
                    "Java",
                    "Python3"
                ],
                "code": "```C++ []\\nclass Solution {\\npublic:\\n    vector<vector<int>> dirs = {{1, 0}, {-1, 0}, {0, 1}, {0, -1}}; \\n   \\n    bool isEscapePossible(vector<vector<int>>& blocked, vector<int>& source, vector<int>& target) {\\n      unordered_set<long long> visited_s;\\n      unordered_set<long long> visited_t;\\n      for (auto& block : blocked) {\\n        if (abs(source[0] - block[0]) + abs(source[1] - block[1]) <= 200)\\n          visited_s.insert(((long long)block[0] << 32) + block[1]);\\n        if (abs(target[0] - block[0]) + abs(target[1] - block[1]) <= 200)\\n          visited_t.insert(((long long)block[0] << 32) + block[1]);\\n      }\\n      return bfs(source, target, visited_s, visited_s.size()) &&\\n             bfs(target, source, visited_t, visited_t.size());\\n    }\\n    bool bfs(vector<int>& source, vector<int>& target, \\n             unordered_set<long long>& visited, int blocks) {\\n      queue<pair<int, int>> q;\\n      q.push({source[0], source[1]});\\n      while (!q.empty() && q.size() <= blocks) {\\n        int x = q.front().first;\\n        int y = q.front().second;\\n        q.pop();\\n        if (x == target[0] && y == target[1])\\n          return true;\\n        for (auto& dir : dirs) {\\n          int next_x = x + dir[0];\\n          int next_y = y + dir[1];\\n          if (next_x < 0 || next_x > 999999 || next_y < 0 || next_y > 999999\\n              || visited.find(((long long)next_x << 32) + next_y) != visited.end())\\n            continue;\\n          q.push({next_x, next_y});\\n          visited.insert(((long long)next_x << 32) + next_y);\\n        }\\n      }\\n      return !q.empty();\\n    }\\n};\\n```\n```Python3 []\\nclass Solution:\\n    def isEscapePossible(self, blocked: List[List[int]], source: List[int], target: List[int]) -> bool:\\n        \\n        escapeDist = len(blocked)\\n        \\n        def dfs(s, t, blocked):\\n            nonlocal escapeDist\\n            stk = [s]\\n            blocked.add(tuple(s))\\n            while len(stk) != 0:\\n                x, y = stk.pop()\\n                if (abs(s[0]-x) + abs(s[1]-y) >= escapeDist):\\n                    return True\\n                neighbours = [(x+1, y), (x-1, y), (x, y+1), (x, y-1)]\\n                for n in neighbours:\\n                    if n[0] > -1 and n[0] < 1000000 and n[1] > -1 and n[1] < 1000000 and n not in blocked:\\n                        stk.append(n)\\n                        blocked.add(n)\\n            return (t[0], t[1]) in blocked\\n        \\n        blocked = {(a[0], a[1]) for a in blocked}\\n        return dfs(source, target, set(blocked)) and dfs(target, source, set(blocked))\\n```\n```Java []\\nclass Solution {\\n    \\n    int[]source;\\n    int[]target;\\n    int xmin;\\n    int xmax;\\n    int ymin;\\n    int ymax;\\n    HashSet<Node>blocks;\\n    HashSet<Node>been;\\n    LinkedList<Integer>vertical;\\n    LinkedList<Integer>horizontal;\\n    int[][]neigh={{-1,-1},{-1,0},{-1,1},{0,-1},{0,1},{1,-1},{1,0},{1,1}};\\n    int[][]ds={{-1,0},{1,0},{0,-1},{0,1}};\\n    int[][]want;\\n    \\n    public boolean isEscapePossible(int[][] blocked, int[] source, int[] target) {\\n        this.source=target;\\n        this.target=target;\\n        blocks=new HashSet();\\n        been=new HashSet();\\n        vertical=new LinkedList();\\n        horizontal=new LinkedList();\\n        \\n        int xmirror=source[0]<=target[0]?1:-1;\\n        int ymirror=source[1]<=target[1]?1:-1;\\n        \\n        source[0]*=xmirror;\\n        source[1]*=ymirror;\\n        target[0]*=xmirror;\\n        target[1]*=ymirror;\\n        \\n        xmin=xmirror==1?0:(-1000000+1);\\n        xmax=xmirror==1?(1000000-1):0;\\n        ymin=ymirror==1?0:(-1000000+1);\\n        ymax=ymirror==1?(1000000-1):0;\\n        \\n        for(int[]b:blocked){\\n            int x=(b[0]*=xmirror),y=(b[1]*=ymirror);\\n            blocks.add(new Node(x,y));\\n            if(y==source[1])horizontal.offer(x);\\n            if(x==target[0])vertical.offer(y);\\n        }\\n        Collections.sort(horizontal);\\n        Collections.sort(vertical);\\n        \\n        want=new int[][]{{source[0]+1,target[0]-1,source[1],source[1]},{target[0],target[0],source[1],target[1]}};\\n        \\n        return dfs(source[0],source[1],true);   \\n    }\\n    private boolean dfs(int x,int y,boolean jump){\\n        if(x==target[0]&&y==target[1])return true;\\n        if(jump){\\n            if(x!=target[0]){\\n                ceil(horizontal,x);\\n                if(horizontal.isEmpty()||horizontal.peek()>target[0]){\\n                    want[0][0]=want[0][1]+1;//means disabled\\n                    want[1][2]=y+1;\\n                    return dfs(target[0],y,true);\\n                }\\n                else{\\n                    int nx=horizontal.peek()-1;\\n                    been.add(new Node(nx,y));\\n                    want[0][0]=nx+1;\\n                    return dfs(nx,y,false);\\n                }\\n            }\\n            else{\\n                ceil(vertical,y);\\n                if(vertical.isEmpty()||vertical.peek()>target[1])\\n                    return true;\\n                else{\\n                    int ny=vertical.peek()-1;\\n                    been.add(new Node(x,ny));\\n                    want[1][2]=ny+1;\\n                    return dfs(x,ny,false);\\n                }\\n            }\\n        }\\n        for(int[]d:ds){\\n            int nx=x+d[0], ny=y+d[1];\\n            Node node=new Node(nx,ny);\\n            if(nx>=xmin&&nx<=xmax&&ny>=ymin&&ny<=ymax\\n               &&!blocks.contains(node)&&!been.contains(node)\\n               &&hasBlockedNeighbor(nx,ny)){\\n                been.add(node);\\n                if(readyToJump(nx,ny)&&dfs(nx,ny,true))return true;\\n                if(dfs(nx,ny,false))return true;\\n            }\\n        }\\n        return false;\\n    }\\n    private void ceil(LinkedList<Integer>list,int n){\\n        while(!list.isEmpty()&&list.peek()<n)list.poll();\\n    }\\n    private boolean hasBlockedNeighbor(int x,int y){\\n        for(int[]ngh:neigh){\\n            if(blocks.contains(new Node(x+ngh[0],y+ngh[1])))\\n                return true;\\n        }\\n        return false;\\n    }\\n    private boolean readyToJump(int x,int y){\\n        if(x>=want[0][0]&&x<=want[0][1]&&y>=want[0][2]&&y<=want[0][3]){\\n            want[0][0]=x+1;\\n            return true;\\n        }\\n        if(x>=want[1][0]&&x<=want[1][1]&&y>=want[1][2]&&y<=want[1][3]){\\n            want[1][2]=y+1;\\n            return true;\\n        }\\n        return false;\\n    }   \\n}\\nclass Node {\\n    int x;\\n    int y;\\n    public Node(int xx,int yy){\\n        x=xx;\\n        y=yy;\\n    }\\n    \\n    public int hashCode(){\\n        return x+20773*y;\\n    }\\n    public boolean equals(Object obj){\\n        if(obj instanceof Node){\\n            Node n=(Node)obj;\\n            return x==n.x&&y==n.y;\\n        }\\n        return false;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3061564,
                "title": "clean-python-high-speed-o-n-time-o-1-space-beats-96-9",
                "content": "# Code\\n\\n```\\nclass Solution:\\n    def isEscapePossible(self, blocked: List[List[int]], source: List[int], target: List[int]) -> bool:\\n        blocked = set(map(tuple, blocked))\\n        \\n        def fn(x, y, tx, ty): \\n            \"\"\"Return True if (x, y) is not looped from (tx, ty).\"\"\"\\n            seen = {(x, y)}\\n            queue = [(x, y)]\\n            level = 0 \\n            while queue: \\n                level += 1\\n                if level > 200: return True \\n                newq = []\\n                for x, y in queue: \\n                    if (x, y) == (tx, ty): return True \\n                    for xx, yy in (x-1, y), (x, y-1), (x, y+1), (x+1, y): \\n                        if 0 <= xx < 1e6 and 0 <= yy < 1e6 and (xx, yy) not in blocked and (xx, yy) not in seen: \\n                            seen.add((xx, yy))\\n                            newq.append((xx, yy))\\n                queue = newq\\n            return False \\n        \\n        return fn(*source, *target) and fn(*target, *source)\\n```\\n\\n\\n# Faster Code\\n```\\nclass Solution:\\n    def isEscapePossible(self, blocked: List[List[int]], source: List[int], target: List[int]) -> bool:\\n        blocked = set(map(tuple, blocked))\\n        \\n        def dfs(sx, sy, tx, ty): \\n            \"\"\"Return True if (x, y) is not looped from (tx, ty).\"\"\"\\n            seen = {(sx, sy)}\\n            stack = [(sx, sy)]\\n            while stack: \\n                x, y = stack.pop()\\n                if abs(x - sx) + abs(y - sy) > 200 or (x, y) == (tx, ty): return True \\n                for xx, yy in (x-1, y), (x, y-1), (x, y+1), (x+1, y): \\n                    if 0 <= xx < 1e6 and 0 <= yy < 1e6 and (xx, yy) not in blocked and (xx, yy) not in seen: \\n                        seen.add((xx, yy))\\n                        stack.append((xx, yy))\\n            return False \\n        \\n        return dfs(*source, *target) and dfs(*target, *source)\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def isEscapePossible(self, blocked: List[List[int]], source: List[int], target: List[int]) -> bool:\\n        blocked = set(map(tuple, blocked))\\n        \\n        def fn(x, y, tx, ty): \\n            \"\"\"Return True if (x, y) is not looped from (tx, ty).\"\"\"\\n            seen = {(x, y)}\\n            queue = [(x, y)]\\n            level = 0 \\n            while queue: \\n                level += 1\\n                if level > 200: return True \\n                newq = []\\n                for x, y in queue: \\n                    if (x, y) == (tx, ty): return True \\n                    for xx, yy in (x-1, y), (x, y-1), (x, y+1), (x+1, y): \\n                        if 0 <= xx < 1e6 and 0 <= yy < 1e6 and (xx, yy) not in blocked and (xx, yy) not in seen: \\n                            seen.add((xx, yy))\\n                            newq.append((xx, yy))\\n                queue = newq\\n            return False \\n        \\n        return fn(*source, *target) and fn(*target, *source)\\n```\n```\\nclass Solution:\\n    def isEscapePossible(self, blocked: List[List[int]], source: List[int], target: List[int]) -> bool:\\n        blocked = set(map(tuple, blocked))\\n        \\n        def dfs(sx, sy, tx, ty): \\n            \"\"\"Return True if (x, y) is not looped from (tx, ty).\"\"\"\\n            seen = {(sx, sy)}\\n            stack = [(sx, sy)]\\n            while stack: \\n                x, y = stack.pop()\\n                if abs(x - sx) + abs(y - sy) > 200 or (x, y) == (tx, ty): return True \\n                for xx, yy in (x-1, y), (x, y-1), (x, y+1), (x+1, y): \\n                    if 0 <= xx < 1e6 and 0 <= yy < 1e6 and (xx, yy) not in blocked and (xx, yy) not in seen: \\n                        seen.add((xx, yy))\\n                        stack.append((xx, yy))\\n            return False \\n        \\n        return dfs(*source, *target) and dfs(*target, *source)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2722405,
                "title": "bfs",
                "content": "\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    string get_s(vector<int>v){\\n        string ans = to_string(v[0]) + \"#\" + to_string(v[1]);\\n        return ans;\\n    }\\n\\n    int check( int x , int y , unordered_map<int, unordered_map<int,bool>>&mp ){\\n        if( x < 0 || y < 0 || x >999999 || y >999999 || mp[x][y]==1)\\n            return 1;\\n        return 0;\\n    }\\n\\n    int solve(vector<int>& source, vector<int>& target , unordered_map<int, unordered_map<int,bool>>&mp){\\n        queue<pair<int , int>>q;\\n        int dx[4] = {0,  0,  1 , -1};\\n        int dy[4] = {1 ,-1 , 0 , 0 };\\n        q.push({source[0], source[1]});\\n        mp[source[0]][source[1]] = 1;\\n        int mx_area = 1;\\n        while(!q.empty()){\\n            int q_size = q.size();\\n            mx_area += 1;\\n            if(mx_area == 201 )\\n                return 1;\\n\\n            for( int k = 0  ; k<q_size ; ++k ){\\n                 auto[ tx , ty]  = q.front();\\n                 q.pop();\\n                 for( int i = 0  ; i<4 ; ++i ){\\n                    int x = tx + dx[i];\\n                    int y = ty + dy[i];\\n                    if(check(x,y , mp ))continue;\\n                    if(x==target[0] && y==target[1]){\\n                        return 1;\\n                    }\\n                   mp[x][y] = 1; \\n                    q.push({x,y});\\n                }\\n            } \\n        }\\n        return 0;\\n\\n    }\\n\\n    bool isEscapePossible(vector<vector<int>>& blocked, vector<int>& source, vector<int>& target) {\\n        unordered_map<int, unordered_map<int,bool>>mp;\\n        for(auto it : blocked ){\\n            mp[it[0]][it[1]] = 1;\\n        }\\n        if(solve(source , target , mp )==0)\\n            return false;\\n        \\n        mp.clear();\\n        for(auto it : blocked ){\\n            mp[it[0]][it[1]] = 1;\\n        }\\n        return solve(target , source  , mp );\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    string get_s(vector<int>v){\\n        string ans = to_string(v[0]) + \"#\" + to_string(v[1]);\\n        return ans;\\n    }\\n\\n    int check( int x , int y , unordered_map<int, unordered_map<int,bool>>&mp ){\\n        if( x < 0 || y < 0 || x >999999 || y >999999 || mp[x][y]==1)\\n            return 1;\\n        return 0;\\n    }\\n\\n    int solve(vector<int>& source, vector<int>& target , unordered_map<int, unordered_map<int,bool>>&mp){\\n        queue<pair<int , int>>q;\\n        int dx[4] = {0,  0,  1 , -1};\\n        int dy[4] = {1 ,-1 , 0 , 0 };\\n        q.push({source[0], source[1]});\\n        mp[source[0]][source[1]] = 1;\\n        int mx_area = 1;\\n        while(!q.empty()){\\n            int q_size = q.size();\\n            mx_area += 1;\\n            if(mx_area == 201 )\\n                return 1;\\n\\n            for( int k = 0  ; k<q_size ; ++k ){\\n                 auto[ tx , ty]  = q.front();\\n                 q.pop();\\n                 for( int i = 0  ; i<4 ; ++i ){\\n                    int x = tx + dx[i];\\n                    int y = ty + dy[i];\\n                    if(check(x,y , mp ))continue;\\n                    if(x==target[0] && y==target[1]){\\n                        return 1;\\n                    }\\n                   mp[x][y] = 1; \\n                    q.push({x,y});\\n                }\\n            } \\n        }\\n        return 0;\\n\\n    }\\n\\n    bool isEscapePossible(vector<vector<int>>& blocked, vector<int>& source, vector<int>& target) {\\n        unordered_map<int, unordered_map<int,bool>>mp;\\n        for(auto it : blocked ){\\n            mp[it[0]][it[1]] = 1;\\n        }\\n        if(solve(source , target , mp )==0)\\n            return false;\\n        \\n        mp.clear();\\n        for(auto it : blocked ){\\n            mp[it[0]][it[1]] = 1;\\n        }\\n        return solve(target , source  , mp );\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2712317,
                "title": "java-javascript-c-solution",
                "content": "**Java**\\n```\\nimport java.util.HashSet;\\nimport java.util.LinkedList;\\nimport java.util.Queue;\\nimport java.util.Set;\\n\\npublic class Solution {\\n\\n    private static final int TOTAL_ROWS = (int) Math.pow(10, 6);\\n    private static final int TOTAL_COLUMNS = TOTAL_ROWS;\\n    private static final int[][] MOVES = {{1, 0}, {-1, 0}, {0, 1}, {0, -1}};\\n    private record Point(int row, int column) {}\\n\\n    public boolean isEscapePossible(int[][] blocked, int[] source, int[] target) {\\n        Set<Integer> setBlocked = initializeSetBlockedPoints(blocked, source, target);\\n        return breadthFirstSearch(setBlocked, source, target) && breadthFirstSearch(setBlocked, target, source);\\n    }\\n\\n    private boolean breadthFirstSearch(Set<Integer> setBlocked, int[] source, int[] target) {\\n        Set<Integer> setVisited = new HashSet<>();\\n        setVisited.add(hashPoint(source[0], source[1]));\\n        Queue<Point> queue = new LinkedList<>();\\n        queue.add(new Point(source[0], source[1]));\\n        int numberOfMoves = 0;\\n\\n        while (!queue.isEmpty()) {\\n\\n            ++numberOfMoves;\\n            for (int i = queue.size(); i > 0; --i) {\\n\\n                Point current = queue.poll();\\n                if (numberOfMoves > setBlocked.size() || (current.row == target[0] && current.column == target[1])) {\\n                    return true;\\n                }\\n\\n                for (int[] move : MOVES) {\\n                    int nextRow = current.row + move[0];\\n                    int nextColumn = current.column + move[1];\\n                    if (isInMatrix(nextRow, nextColumn) && setVisited.add(hashPoint(nextRow, nextColumn)) \\n                        && !setBlocked.contains(hashPoint(nextRow, nextColumn))) {\\n                        queue.add(new Point(nextRow, nextColumn));\\n                    }\\n                }\\n            }\\n        }\\n        return false;\\n    }\\n\\n    private Set<Integer> initializeSetBlockedPoints(int[][] blocked, int[] source, int[] target) {\\n        Set<Integer> setBlocked = new HashSet<>();\\n        for (int[] blockedPoint : blocked) {\\n            if (distance(blockedPoint, source) <= blocked.length || distance(blockedPoint, target) <= blocked.length) {\\n                setBlocked.add(hashPoint(blockedPoint[0], blockedPoint[1]));\\n            }\\n        }\\n        return setBlocked;\\n    }\\n\\n    private boolean isInMatrix(int row, int column) {\\n        return row >= 0 && row < TOTAL_ROWS && column >= 0 && column < TOTAL_COLUMNS;\\n    }\\n\\n    private int hashPoint(int row, int column) {\\n        return 991 * row + column;\\n    }\\n\\n    private int distance(int[] firstPoint, int[] secondPoint) {\\n        return Math.abs(firstPoint[0] - secondPoint[0]) + Math.abs(firstPoint[1] - secondPoint[1]);\\n    }\\n}\\n```\\n**JavaScript**\\n```\\n/**\\n * @param {number[][]} blocked\\n * @param {number[]} source\\n * @param {number[]} target\\n * @return {boolean}\\n */\\nvar isEscapePossible = function (blocked, source, target) {\\n    this.TOTAL_ROWS = Math.pow(10, 6);\\n    this.TOTAL_COLUMNS = TOTAL_ROWS;\\n    this.MOVES = [[1, 0], [-1, 0], [0, 1], [0, -1]];\\n\\n    const setBlocked = initializeSetBlockedPoints(blocked, source, target);\\n    return breadthFirstSearch(setBlocked, source, target) && breadthFirstSearch(setBlocked, target, source);\\n};\\n\\n/**\\n * @param {number} row\\n * @param {number} column\\n */\\nfunction Point(row, column) {\\n    this.row = row;\\n    this.column = column;\\n}\\n\\n/**\\n * @param {Set<number>} setBlocked\\n * @param {number} source\\n * @param {number} target\\n * @return {boolean}\\n */\\nfunction breadthFirstSearch(setBlocked, source, target) {\\n    const setVisited = new Set();\\n    setVisited.add(hashPoint(source[0], source[1]));\\n    const queue = new Queue();\\n    queue.enqueue(new Point(source[0], source[1]));\\n    let numberOfMoves = 0;\\n\\n    while (!queue.isEmpty()) {\\n\\n        ++numberOfMoves;\\n        for (let i = queue.size(); i > 0; --i) {\\n\\n            let current = queue.dequeue();\\n            if (numberOfMoves > setBlocked.size || (current.row === target[0] && current.column === target[1])) {\\n                return true;\\n            }\\n\\n            for (let move of this.MOVES) {\\n                let nextRow = current.row + move[0];\\n                let nextColumn = current.column + move[1];\\n                if (isInMatrix(nextRow, nextColumn) && !setVisited.has(hashPoint(nextRow, nextColumn))\\n                    && !setBlocked.has(hashPoint(nextRow, nextColumn))) {\\n                    queue.enqueue(new Point(nextRow, nextColumn));\\n                    setVisited.add(hashPoint(nextRow, nextColumn));\\n                }\\n            }\\n        }\\n    }\\n    return false;\\n}\\n\\n/**\\n * @param {number[][]} blocked\\n * @param {number[]} source\\n * @param {number[]} target\\n * @return {Set<number>}\\n */\\nfunction initializeSetBlockedPoints(blocked, source, target) {\\n    const setBlocked = new Set();\\n    for (let blockedPoint of blocked) {\\n        if (distance(blockedPoint, source) <= blocked.length || distance(blockedPoint, target) <= blocked.length) {\\n            setBlocked.add(hashPoint(blockedPoint[0], blockedPoint[1]));\\n        }\\n    }\\n    return setBlocked;\\n}\\n\\n/**\\n * @param {number} row\\n * @param {number} column\\n * @return {boolean}\\n */\\nfunction isInMatrix(row, column) {\\n    return row >= 0 && row < this.TOTAL_ROWS && column >= 0 && column < this.TOTAL_COLUMNS;\\n}\\n\\n/**\\n * @param {number} row\\n * @param {number} column\\n * @return {number}\\n */\\nfunction hashPoint(row, column) {\\n    return 991 * row + column;\\n}\\n\\n/**\\n * @param {number[]} firstPoint\\n * @param {number[]} secondPoint\\n * @return {number}\\n */\\nfunction distance(firstPoint, secondPoint) {\\n    return Math.abs(firstPoint[0] - secondPoint[0]) + Math.abs(firstPoint[1] - secondPoint[1]);\\n}\\n```\\n**C++**\\n```\\n#include <queue>\\n#include <vector>\\n#include <unordered_map>\\nusing namespace std;\\n\\nclass Solution {\\n    \\n    inline static const int TOTAL_ROWS = pow(10, 6);\\n    inline static const int TOTAL_COLUMNS = TOTAL_ROWS;\\n    inline static const array<array<int, 2>, 4> MOVES{ {{1, 0}, {-1, 0}, {0, 1}, {0, -1}} };\\n\\n    struct Point {\\n        int row{};\\n        int column{};\\n        Point(int row, int column) : row{row}, column{column}{}\\n    };\\n\\npublic:\\n    bool isEscapePossible(const vector<vector<int>>& blocked, const vector<int>& source, const vector<int>& target) const {\\n        unordered_set<int> setBlocked{ initializeSetBlockedPoints(blocked, source, target) };\\n        return breadthFirstSearch(setBlocked, source, target) && breadthFirstSearch(setBlocked, target, source);\\n    }\\n\\nprivate:\\n    bool breadthFirstSearch(const unordered_set<int>& setBlocked, const vector<int>& source, const vector<int>& target) const {\\n        unordered_set<int> setVisited;\\n        setVisited.insert(hashPoint(source[0], source[1]));\\n        queue<Point> queue;\\n        queue.emplace(Point(source[0], source[1]));\\n        int numberOfMoves = 0;\\n\\n        while (!queue.empty()) {\\n\\n            ++numberOfMoves;\\n            for (int i = queue.size(); i > 0; --i) {\\n\\n                Point current = queue.front();\\n                queue.pop();\\n                if (numberOfMoves > setBlocked.size() || (current.row == target[0] && current.column == target[1])) {\\n                    return true;\\n                }\\n\\n                for (const auto& move : MOVES) {\\n                    int nextRow = current.row + move[0];\\n                    int nextColumn = current.column + move[1];\\n\\n                    //C++20: setVisited.contains(...), setBlocked.contains(...), done the old way for compatibility.\\n                    if (isInMatrix(nextRow, nextColumn) && setVisited.find(hashPoint(nextRow, nextColumn)) == setVisited.end()\\n                        && setBlocked.find(hashPoint(nextRow, nextColumn)) == setBlocked.end()) {\\n                        queue.emplace(Point(nextRow, nextColumn));\\n                        setVisited.insert(hashPoint(nextRow, nextColumn));\\n                    }\\n                }\\n            }\\n        }\\n        return false;\\n    }\\n\\n    unordered_set<int> initializeSetBlockedPoints(const vector<vector<int>>& blocked, const vector<int>& source, const vector<int>& target) const {\\n        unordered_set<int> setBlocked;\\n        for (const auto& blockedPoint : blocked) {\\n            if (distance(blockedPoint, source) <= blocked.size() || distance(blockedPoint, target) <= blocked.size()) {\\n                setBlocked.insert(hashPoint(blockedPoint[0], blockedPoint[1]));\\n            }\\n        }\\n        return setBlocked;\\n    }\\n\\n    bool isInMatrix(int row, int column) const {\\n        return row >= 0 && row < TOTAL_ROWS && column >= 0 && column < TOTAL_COLUMNS;\\n    }\\n\\n    int hashPoint(int row, int column) const {\\n        return 991 * row + column;\\n    }\\n\\n    int distance(const vector<int>& firstPoint, const vector<int>& secondPoint) const {\\n        return abs(firstPoint[0] - secondPoint[0]) + abs(firstPoint[1] - secondPoint[1]);\\n    }\\n};\\n```",
                "solutionTags": [
                    "Java",
                    "C",
                    "JavaScript"
                ],
                "code": "```\\nimport java.util.HashSet;\\nimport java.util.LinkedList;\\nimport java.util.Queue;\\nimport java.util.Set;\\n\\npublic class Solution {\\n\\n    private static final int TOTAL_ROWS = (int) Math.pow(10, 6);\\n    private static final int TOTAL_COLUMNS = TOTAL_ROWS;\\n    private static final int[][] MOVES = {{1, 0}, {-1, 0}, {0, 1}, {0, -1}};\\n    private record Point(int row, int column) {}\\n\\n    public boolean isEscapePossible(int[][] blocked, int[] source, int[] target) {\\n        Set<Integer> setBlocked = initializeSetBlockedPoints(blocked, source, target);\\n        return breadthFirstSearch(setBlocked, source, target) && breadthFirstSearch(setBlocked, target, source);\\n    }\\n\\n    private boolean breadthFirstSearch(Set<Integer> setBlocked, int[] source, int[] target) {\\n        Set<Integer> setVisited = new HashSet<>();\\n        setVisited.add(hashPoint(source[0], source[1]));\\n        Queue<Point> queue = new LinkedList<>();\\n        queue.add(new Point(source[0], source[1]));\\n        int numberOfMoves = 0;\\n\\n        while (!queue.isEmpty()) {\\n\\n            ++numberOfMoves;\\n            for (int i = queue.size(); i > 0; --i) {\\n\\n                Point current = queue.poll();\\n                if (numberOfMoves > setBlocked.size() || (current.row == target[0] && current.column == target[1])) {\\n                    return true;\\n                }\\n\\n                for (int[] move : MOVES) {\\n                    int nextRow = current.row + move[0];\\n                    int nextColumn = current.column + move[1];\\n                    if (isInMatrix(nextRow, nextColumn) && setVisited.add(hashPoint(nextRow, nextColumn)) \\n                        && !setBlocked.contains(hashPoint(nextRow, nextColumn))) {\\n                        queue.add(new Point(nextRow, nextColumn));\\n                    }\\n                }\\n            }\\n        }\\n        return false;\\n    }\\n\\n    private Set<Integer> initializeSetBlockedPoints(int[][] blocked, int[] source, int[] target) {\\n        Set<Integer> setBlocked = new HashSet<>();\\n        for (int[] blockedPoint : blocked) {\\n            if (distance(blockedPoint, source) <= blocked.length || distance(blockedPoint, target) <= blocked.length) {\\n                setBlocked.add(hashPoint(blockedPoint[0], blockedPoint[1]));\\n            }\\n        }\\n        return setBlocked;\\n    }\\n\\n    private boolean isInMatrix(int row, int column) {\\n        return row >= 0 && row < TOTAL_ROWS && column >= 0 && column < TOTAL_COLUMNS;\\n    }\\n\\n    private int hashPoint(int row, int column) {\\n        return 991 * row + column;\\n    }\\n\\n    private int distance(int[] firstPoint, int[] secondPoint) {\\n        return Math.abs(firstPoint[0] - secondPoint[0]) + Math.abs(firstPoint[1] - secondPoint[1]);\\n    }\\n}\\n```\n```\\n/**\\n * @param {number[][]} blocked\\n * @param {number[]} source\\n * @param {number[]} target\\n * @return {boolean}\\n */\\nvar isEscapePossible = function (blocked, source, target) {\\n    this.TOTAL_ROWS = Math.pow(10, 6);\\n    this.TOTAL_COLUMNS = TOTAL_ROWS;\\n    this.MOVES = [[1, 0], [-1, 0], [0, 1], [0, -1]];\\n\\n    const setBlocked = initializeSetBlockedPoints(blocked, source, target);\\n    return breadthFirstSearch(setBlocked, source, target) && breadthFirstSearch(setBlocked, target, source);\\n};\\n\\n/**\\n * @param {number} row\\n * @param {number} column\\n */\\nfunction Point(row, column) {\\n    this.row = row;\\n    this.column = column;\\n}\\n\\n/**\\n * @param {Set<number>} setBlocked\\n * @param {number} source\\n * @param {number} target\\n * @return {boolean}\\n */\\nfunction breadthFirstSearch(setBlocked, source, target) {\\n    const setVisited = new Set();\\n    setVisited.add(hashPoint(source[0], source[1]));\\n    const queue = new Queue();\\n    queue.enqueue(new Point(source[0], source[1]));\\n    let numberOfMoves = 0;\\n\\n    while (!queue.isEmpty()) {\\n\\n        ++numberOfMoves;\\n        for (let i = queue.size(); i > 0; --i) {\\n\\n            let current = queue.dequeue();\\n            if (numberOfMoves > setBlocked.size || (current.row === target[0] && current.column === target[1])) {\\n                return true;\\n            }\\n\\n            for (let move of this.MOVES) {\\n                let nextRow = current.row + move[0];\\n                let nextColumn = current.column + move[1];\\n                if (isInMatrix(nextRow, nextColumn) && !setVisited.has(hashPoint(nextRow, nextColumn))\\n                    && !setBlocked.has(hashPoint(nextRow, nextColumn))) {\\n                    queue.enqueue(new Point(nextRow, nextColumn));\\n                    setVisited.add(hashPoint(nextRow, nextColumn));\\n                }\\n            }\\n        }\\n    }\\n    return false;\\n}\\n\\n/**\\n * @param {number[][]} blocked\\n * @param {number[]} source\\n * @param {number[]} target\\n * @return {Set<number>}\\n */\\nfunction initializeSetBlockedPoints(blocked, source, target) {\\n    const setBlocked = new Set();\\n    for (let blockedPoint of blocked) {\\n        if (distance(blockedPoint, source) <= blocked.length || distance(blockedPoint, target) <= blocked.length) {\\n            setBlocked.add(hashPoint(blockedPoint[0], blockedPoint[1]));\\n        }\\n    }\\n    return setBlocked;\\n}\\n\\n/**\\n * @param {number} row\\n * @param {number} column\\n * @return {boolean}\\n */\\nfunction isInMatrix(row, column) {\\n    return row >= 0 && row < this.TOTAL_ROWS && column >= 0 && column < this.TOTAL_COLUMNS;\\n}\\n\\n/**\\n * @param {number} row\\n * @param {number} column\\n * @return {number}\\n */\\nfunction hashPoint(row, column) {\\n    return 991 * row + column;\\n}\\n\\n/**\\n * @param {number[]} firstPoint\\n * @param {number[]} secondPoint\\n * @return {number}\\n */\\nfunction distance(firstPoint, secondPoint) {\\n    return Math.abs(firstPoint[0] - secondPoint[0]) + Math.abs(firstPoint[1] - secondPoint[1]);\\n}\\n```\n```\\n#include <queue>\\n#include <vector>\\n#include <unordered_map>\\nusing namespace std;\\n\\nclass Solution {\\n    \\n    inline static const int TOTAL_ROWS = pow(10, 6);\\n    inline static const int TOTAL_COLUMNS = TOTAL_ROWS;\\n    inline static const array<array<int, 2>, 4> MOVES{ {{1, 0}, {-1, 0}, {0, 1}, {0, -1}} };\\n\\n    struct Point {\\n        int row{};\\n        int column{};\\n        Point(int row, int column) : row{row}, column{column}{}\\n    };\\n\\npublic:\\n    bool isEscapePossible(const vector<vector<int>>& blocked, const vector<int>& source, const vector<int>& target) const {\\n        unordered_set<int> setBlocked{ initializeSetBlockedPoints(blocked, source, target) };\\n        return breadthFirstSearch(setBlocked, source, target) && breadthFirstSearch(setBlocked, target, source);\\n    }\\n\\nprivate:\\n    bool breadthFirstSearch(const unordered_set<int>& setBlocked, const vector<int>& source, const vector<int>& target) const {\\n        unordered_set<int> setVisited;\\n        setVisited.insert(hashPoint(source[0], source[1]));\\n        queue<Point> queue;\\n        queue.emplace(Point(source[0], source[1]));\\n        int numberOfMoves = 0;\\n\\n        while (!queue.empty()) {\\n\\n            ++numberOfMoves;\\n            for (int i = queue.size(); i > 0; --i) {\\n\\n                Point current = queue.front();\\n                queue.pop();\\n                if (numberOfMoves > setBlocked.size() || (current.row == target[0] && current.column == target[1])) {\\n                    return true;\\n                }\\n\\n                for (const auto& move : MOVES) {\\n                    int nextRow = current.row + move[0];\\n                    int nextColumn = current.column + move[1];\\n\\n                    //C++20: setVisited.contains(...), setBlocked.contains(...), done the old way for compatibility.\\n                    if (isInMatrix(nextRow, nextColumn) && setVisited.find(hashPoint(nextRow, nextColumn)) == setVisited.end()\\n                        && setBlocked.find(hashPoint(nextRow, nextColumn)) == setBlocked.end()) {\\n                        queue.emplace(Point(nextRow, nextColumn));\\n                        setVisited.insert(hashPoint(nextRow, nextColumn));\\n                    }\\n                }\\n            }\\n        }\\n        return false;\\n    }\\n\\n    unordered_set<int> initializeSetBlockedPoints(const vector<vector<int>>& blocked, const vector<int>& source, const vector<int>& target) const {\\n        unordered_set<int> setBlocked;\\n        for (const auto& blockedPoint : blocked) {\\n            if (distance(blockedPoint, source) <= blocked.size() || distance(blockedPoint, target) <= blocked.size()) {\\n                setBlocked.insert(hashPoint(blockedPoint[0], blockedPoint[1]));\\n            }\\n        }\\n        return setBlocked;\\n    }\\n\\n    bool isInMatrix(int row, int column) const {\\n        return row >= 0 && row < TOTAL_ROWS && column >= 0 && column < TOTAL_COLUMNS;\\n    }\\n\\n    int hashPoint(int row, int column) const {\\n        return 991 * row + column;\\n    }\\n\\n    int distance(const vector<int>& firstPoint, const vector<int>& secondPoint) const {\\n        return abs(firstPoint[0] - secondPoint[0]) + abs(firstPoint[1] - secondPoint[1]);\\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 2452121,
                "title": "python-solution-bfs-for-len-blocked-steps",
                "content": "```\\nclass Solution:\\n    # Key to observe: 0 <= blocked.length <= 200\\n    # So the only way you cannot reach from source to target is because there\\'s a ring formed by the boundary and blocked points such that if I BFS from either one of them I cannot get out of the block\\n    # An illustrative example is this:\\n    # XXXXXXXXXX\\n    # S         X   T\\n    # BBBBBBBBBBBBBBB  S = source, T = target, B = boundary\\n    # Because block length is quite limited, We just need to BFS from both target and source for at most blocked.length. If we see possible steps < blocked.length for either one of them we return False\\n    # We also return True if we see target from source\\'s BFS\\n\\n    def isEscapePossible(self, blocked: List[List[int]], source: List[int], target: List[int]) -> bool:\\n        blocked_set = set()\\n        for block in blocked:\\n            blocked_set.add(tuple(block))\\n        \\n        # BFS from source and target\\n        bfs_source = [tuple(source), tuple(target)]\\n        for j in range(2):\\n            dq, visited, steps = deque(), set(), 0\\n            dq.append(bfs_source[j])\\n            visited.add(bfs_source[j])\\n            while dq and steps < len(blocked_set):\\n                for i in range(len(dq)):\\n                    x, y = dq.popleft()\\n                    if (x, y) == bfs_source[(j+1)%2]:\\n                        return True\\n                    neighbours = [(x-1,y), (x+1,y), (x,y-1), (x, y+1)]\\n                    for xn, yn in neighbours:\\n                        if xn >= 0 and yn >= 0 and xn < pow(10,6) and yn < pow(10,6) and (xn, yn) not in blocked_set and (xn, yn) not in visited:\\n                            visited.add((xn, yn))\\n                            dq.append((xn, yn))\\n                if dq:\\n                    steps += 1\\n            if steps < len(blocked_set):\\n                return False\\n        return True\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    # Key to observe: 0 <= blocked.length <= 200\\n    # So the only way you cannot reach from source to target is because there\\'s a ring formed by the boundary and blocked points such that if I BFS from either one of them I cannot get out of the block\\n    # An illustrative example is this:\\n    # XXXXXXXXXX\\n    # S         X   T\\n    # BBBBBBBBBBBBBBB  S = source, T = target, B = boundary\\n    # Because block length is quite limited, We just need to BFS from both target and source for at most blocked.length. If we see possible steps < blocked.length for either one of them we return False\\n    # We also return True if we see target from source\\'s BFS\\n\\n    def isEscapePossible(self, blocked: List[List[int]], source: List[int], target: List[int]) -> bool:\\n        blocked_set = set()\\n        for block in blocked:\\n            blocked_set.add(tuple(block))\\n        \\n        # BFS from source and target\\n        bfs_source = [tuple(source), tuple(target)]\\n        for j in range(2):\\n            dq, visited, steps = deque(), set(), 0\\n            dq.append(bfs_source[j])\\n            visited.add(bfs_source[j])\\n            while dq and steps < len(blocked_set):\\n                for i in range(len(dq)):\\n                    x, y = dq.popleft()\\n                    if (x, y) == bfs_source[(j+1)%2]:\\n                        return True\\n                    neighbours = [(x-1,y), (x+1,y), (x,y-1), (x, y+1)]\\n                    for xn, yn in neighbours:\\n                        if xn >= 0 and yn >= 0 and xn < pow(10,6) and yn < pow(10,6) and (xn, yn) not in blocked_set and (xn, yn) not in visited:\\n                            visited.add((xn, yn))\\n                            dq.append((xn, yn))\\n                if dq:\\n                    steps += 1\\n            if steps < len(blocked_set):\\n                return False\\n        return True\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2337507,
                "title": "python3-dfs-beats-100-simple-explanation",
                "content": "Explanation: Since there are only 200 blocks at most, all we need to do is check if we can escape to a distance of more than 200 from both the source and the target. If so, there are not enough blocks to block them hence return true.\\n\\n```\\nclass Solution:\\n    def isEscapePossible(self, blocked: List[List[int]], source: List[int], target: List[int]) -> bool:\\n        \\n        escapeDist = len(blocked)\\n        \\n        def dfs(s, t, blocked):\\n            nonlocal escapeDist\\n            stk = [s]\\n            blocked.add(tuple(s))\\n            while len(stk) != 0:\\n                x, y = stk.pop()\\n                if (abs(s[0]-x) + abs(s[1]-y) >= escapeDist):\\n                    return True\\n                neighbours = [(x+1, y), (x-1, y), (x, y+1), (x, y-1)]\\n                for n in neighbours:\\n                    if n[0] > -1 and n[0] < 1000000 and n[1] > -1 and n[1] < 1000000 and n not in blocked:\\n                        stk.append(n)\\n                        blocked.add(n)\\n            return (t[0], t[1]) in blocked\\n        \\n        blocked = {(a[0], a[1]) for a in blocked}\\n        return dfs(source, target, set(blocked)) and dfs(target, source, set(blocked))\\n```",
                "solutionTags": [
                    "Depth-First Search"
                ],
                "code": "```\\nclass Solution:\\n    def isEscapePossible(self, blocked: List[List[int]], source: List[int], target: List[int]) -> bool:\\n        \\n        escapeDist = len(blocked)\\n        \\n        def dfs(s, t, blocked):\\n            nonlocal escapeDist\\n            stk = [s]\\n            blocked.add(tuple(s))\\n            while len(stk) != 0:\\n                x, y = stk.pop()\\n                if (abs(s[0]-x) + abs(s[1]-y) >= escapeDist):\\n                    return True\\n                neighbours = [(x+1, y), (x-1, y), (x, y+1), (x, y-1)]\\n                for n in neighbours:\\n                    if n[0] > -1 and n[0] < 1000000 and n[1] > -1 and n[1] < 1000000 and n not in blocked:\\n                        stk.append(n)\\n                        blocked.add(n)\\n            return (t[0], t[1]) in blocked\\n        \\n        blocked = {(a[0], a[1]) for a in blocked}\\n        return dfs(source, target, set(blocked)) and dfs(target, source, set(blocked))\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2067668,
                "title": "c-dfs-solution",
                "content": "```\\nclass Solution {\\nprivate:\\n    int dir[4][2] = {{1, 0}, {-1, 0}, {0, 1}, {0, -1}};\\n    \\n    bool valid(int x, int y) {\\n        return x >= 0 && x < 1e6 && y >= 0 && y < 1e6;\\n    }\\n    \\n    bool dfs(vector<int> &source, vector<int> &target, vector<int> &curr, set<pair<int, int>> &blocked, set<pair<int, int>> &used) {\\n        if(curr[0] == target[0] && curr[1] == target[1])\\n            return true;\\n        else if(abs(curr[0]-source[0]) + abs(curr[1]-source[1]) >= 200)\\n            return true;\\n        \\n        used.insert({curr[0], curr[1]});\\n        for(int i = 0; i < 4; i++) {\\n            int x = curr[0] + dir[i][0];\\n            int y = curr[1] + dir[i][1];\\n            if(valid(x, y) && !blocked.count({x, y}) && !used.count({x, y})) {\\n                vector<int> tmp = {x, y};\\n                if(dfs(source, target, tmp, blocked, used))\\n                    return true;\\n            }\\n        }\\n        \\n        return false;\\n    }\\n    \\n    \\npublic:\\n    bool isEscapePossible(vector<vector<int>>& blocked, vector<int>& source, vector<int>& target) {\\n        set<pair<int, int>> blocked_set;\\n        for(auto it: blocked) \\n            blocked_set.insert({it[0], it[1]});\\n        \\n        set<pair<int, int>> used1, used2;\\n        return dfs(source, target, source, blocked_set, used1) && dfs(target, source, target, blocked_set, used2);\\n    }\\n};\\n\\n```",
                "solutionTags": [
                    "C",
                    "Depth-First Search"
                ],
                "code": "```\\nclass Solution {\\nprivate:\\n    int dir[4][2] = {{1, 0}, {-1, 0}, {0, 1}, {0, -1}};\\n    \\n    bool valid(int x, int y) {\\n        return x >= 0 && x < 1e6 && y >= 0 && y < 1e6;\\n    }\\n    \\n    bool dfs(vector<int> &source, vector<int> &target, vector<int> &curr, set<pair<int, int>> &blocked, set<pair<int, int>> &used) {\\n        if(curr[0] == target[0] && curr[1] == target[1])\\n            return true;\\n        else if(abs(curr[0]-source[0]) + abs(curr[1]-source[1]) >= 200)\\n            return true;\\n        \\n        used.insert({curr[0], curr[1]});\\n        for(int i = 0; i < 4; i++) {\\n            int x = curr[0] + dir[i][0];\\n            int y = curr[1] + dir[i][1];\\n            if(valid(x, y) && !blocked.count({x, y}) && !used.count({x, y})) {\\n                vector<int> tmp = {x, y};\\n                if(dfs(source, target, tmp, blocked, used))\\n                    return true;\\n            }\\n        }\\n        \\n        return false;\\n    }\\n    \\n    \\npublic:\\n    bool isEscapePossible(vector<vector<int>>& blocked, vector<int>& source, vector<int>& target) {\\n        set<pair<int, int>> blocked_set;\\n        for(auto it: blocked) \\n            blocked_set.insert({it[0], it[1]});\\n        \\n        set<pair<int, int>> used1, used2;\\n        return dfs(source, target, source, blocked_set, used1) && dfs(target, source, target, blocked_set, used2);\\n    }\\n};\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2002941,
                "title": "python-bfs",
                "content": "It is mentioned in the question that length of blocked is 200 at max. We use this to our advantage. \\n\\nAs we have a very large grid, we will only be blocked if there is a ring or a closed figure formed by the blocked points around target or source. Look for such rings using BFS by moving out one distance outwards in each iteration. I tried working with 200 outward movements. If you can move 200 times from each source and target then we don\\'t need to care at all.\\nThere is one more case when both start and target are inside the enclosed figure. That\\'s why bfs also checks if we have reached the target from start.\\n\\n```\\nclass Solution:\\n    def isEscapePossible(self, blocked: List[List[int]], source: List[int], target: List[int]) -> bool:\\n        \\n        direction = [(-1,0) , (1,0) , (0,1) , (0,-1)]\\n        noEntry = set()\\n        for x,y in blocked:\\n            noEntry.add((x,y))\\n            \\n        startX , startY = source\\n        endX , endY = target\\n        \\n        def bfs(sx,sy,tx,ty):\\n            queue = [(sx , sy)]\\n            visited = set()\\n            visited.add((sx , sy))\\n            count = 0\\n            while(queue and count < 200):\\n                arr = []\\n                l = len(queue)\\n                for i in range(l):\\n                    x , y = queue.pop(0)\\n                    if x == tx and y == ty:\\n                        return True\\n                    for d in direction:\\n                        new_x = x + d[0]\\n                        new_y = y + d[1]\\n                        if 0<=new_x<1000000 and 0<=new_y<1000000 and (new_x , new_y) not in visited and (new_x , new_y) not in noEntry:\\n                            arr.append((new_x , new_y))\\n                            visited.add((new_x , new_y))\\n                if len(arr) == 0:\\n                    return False\\n                queue = arr\\n                count += 1\\n\\n            return True\\n        \\n        return bfs(startX , startY , endX , endY) and bfs(endX , endY , startX , startY)\\n```",
                "solutionTags": [
                    "Breadth-First Search"
                ],
                "code": "```\\nclass Solution:\\n    def isEscapePossible(self, blocked: List[List[int]], source: List[int], target: List[int]) -> bool:\\n        \\n        direction = [(-1,0) , (1,0) , (0,1) , (0,-1)]\\n        noEntry = set()\\n        for x,y in blocked:\\n            noEntry.add((x,y))\\n            \\n        startX , startY = source\\n        endX , endY = target\\n        \\n        def bfs(sx,sy,tx,ty):\\n            queue = [(sx , sy)]\\n            visited = set()\\n            visited.add((sx , sy))\\n            count = 0\\n            while(queue and count < 200):\\n                arr = []\\n                l = len(queue)\\n                for i in range(l):\\n                    x , y = queue.pop(0)\\n                    if x == tx and y == ty:\\n                        return True\\n                    for d in direction:\\n                        new_x = x + d[0]\\n                        new_y = y + d[1]\\n                        if 0<=new_x<1000000 and 0<=new_y<1000000 and (new_x , new_y) not in visited and (new_x , new_y) not in noEntry:\\n                            arr.append((new_x , new_y))\\n                            visited.add((new_x , new_y))\\n                if len(arr) == 0:\\n                    return False\\n                queue = arr\\n                count += 1\\n\\n            return True\\n        \\n        return bfs(startX , startY , endX , endY) and bfs(endX , endY , startX , startY)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1777771,
                "title": "simple-java-bfs-only-explained-with-picture",
                "content": "Since there are at most `200` blocks. There can never be a horizontal or vertical block dividing the matrix. So the only possible types of block that can prevent the the source or target from reaching each other is a circular, rectangle or other illegular-shaped block formed by the blocks. The circumference or perimeter of such block is 200 at max (see the image below).\\n![image](https://assets.leetcode.com/users/images/42ff5f69-ab03-4168-98bd-571d17e49ef0_1645087477.5043776.png)\\n\\n\\nSo, we can perform a bfs from the either the source. we can either get blocked below 200 moves else we can never get block. It is also possible to meet the other (target or source) before reaching 200 moves.\\n```\\nclass Solution {\\n    long n = (long)1e6;\\n    Set<Long> blocks;\\n    int[][] vecs = {{0,1},{0,-1},{1,0},{-1,0}};\\n    public boolean isEscapePossible(int[][] blocked, int[] source, int[] target) {\\n        int n = (int)1e6;\\n        blocks = new HashSet<>();\\n        for(int[] block: blocked){\\n            blocks.add(cellValue(block));\\n        }\\n        boolean s_t = bfs(source, target);\\n        s_t = s_t?bfs(target, source):s_t;\\n        return s_t;\\n    }\\n    \\n    private boolean bfs(int[] src, int[] tgt){\\n        Set<Long> visited = new HashSet<>();\\n        Queue<int[]> pq = new LinkedList<>();\\n        pq.offer(src);\\n        visited.add(cellValue(src));\\n        int moves = 0;\\n        long target = cellValue(tgt);\\n        \\n        while(!pq.isEmpty()){\\n            int size = pq.size();\\n            moves++;\\n            //blockes can\\'t create cycle anymore\\n            if(moves==201){\\n                return true;\\n            }\\n            for(int i=0; i<size; i++){\\n                int[] next = pq.poll();\\n                for(int[] v:vecs){\\n                    int x = next[0]+v[0];\\n                    int y = next[1]+v[1];\\n                    if(x < 0 || x >= n || y < 0 || y >= n)\\n                        continue;\\n                    long value = cellValue(x,y);\\n                    if(value == target){\\n                        return true;\\n                    }\\n                    if(blocks.contains(value) || visited.contains(value))\\n                        continue;\\n                    visited.add(value);\\n                    pq.offer(new int[]{x,y});\\n                }\\n            }\\n        }\\n        //got blocked\\n        return false;\\n    }\\n    private long cellValue(int... x){\\n        return Long.valueOf(x[0])*n + Long.valueOf(x[1]);\\n    }\\n}\\n```\\n",
                "solutionTags": [
                    "Breadth-First Search"
                ],
                "code": "```\\nclass Solution {\\n    long n = (long)1e6;\\n    Set<Long> blocks;\\n    int[][] vecs = {{0,1},{0,-1},{1,0},{-1,0}};\\n    public boolean isEscapePossible(int[][] blocked, int[] source, int[] target) {\\n        int n = (int)1e6;\\n        blocks = new HashSet<>();\\n        for(int[] block: blocked){\\n            blocks.add(cellValue(block));\\n        }\\n        boolean s_t = bfs(source, target);\\n        s_t = s_t?bfs(target, source):s_t;\\n        return s_t;\\n    }\\n    \\n    private boolean bfs(int[] src, int[] tgt){\\n        Set<Long> visited = new HashSet<>();\\n        Queue<int[]> pq = new LinkedList<>();\\n        pq.offer(src);\\n        visited.add(cellValue(src));\\n        int moves = 0;\\n        long target = cellValue(tgt);\\n        \\n        while(!pq.isEmpty()){\\n            int size = pq.size();\\n            moves++;\\n            //blockes can\\'t create cycle anymore\\n            if(moves==201){\\n                return true;\\n            }\\n            for(int i=0; i<size; i++){\\n                int[] next = pq.poll();\\n                for(int[] v:vecs){\\n                    int x = next[0]+v[0];\\n                    int y = next[1]+v[1];\\n                    if(x < 0 || x >= n || y < 0 || y >= n)\\n                        continue;\\n                    long value = cellValue(x,y);\\n                    if(value == target){\\n                        return true;\\n                    }\\n                    if(blocks.contains(value) || visited.contains(value))\\n                        continue;\\n                    visited.add(value);\\n                    pq.offer(new int[]{x,y});\\n                }\\n            }\\n        }\\n        //got blocked\\n        return false;\\n    }\\n    private long cellValue(int... x){\\n        return Long.valueOf(x[0])*n + Long.valueOf(x[1]);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1669380,
                "title": "python-100-100",
                "content": "19900 is the maximum area that can be surrounded by 200 blockers (when they form a triangle with grid\\'s corner). If it\\'s possible to reach more than 19900 points from source, it means it is not blocked. The same for target. If both of them are not blocked that means there is definitely a path between them. Another option is to reach a distance more then 200 from source, it will also mean it is not blocked. DFS is used to optimise these cases.\\nIf both of them are blocked in the same space, they will meet as well.\\n\\n```\\nclass Solution(object):\\n    def isEscapePossible(self, blocked, source, target):\\n        blocked = set((a,b) for a, b in blocked)\\n        \\n        def canBreakThrough(source, target):\\n            visited = set((source[0], source[1]))\\n            q = [source]\\n            while len(visited) <= 19901:\\n                i = q.pop()\\n                dir = [(i[0]+1, i[1]), (i[0]-1, i[1]), (i[0], i[1]+1), (i[0], i[1]-1)]\\n                for d in dir:\\n                    if d not in blocked and d not in visited:\\n                        if d[0] < 0 or d[0] >= 10**6 or d[1] < 0 or d[1] >= 10**6: continue\\n                        if d[0] == target[0] and d[1] == target[1]: return True\\n                        if abs(d[0] - source[0]) > 200 or abs(d[1] - source[1]) > 200: return True\\n                        visited.add(d)\\n                        q.append(d)\\n                if not q: return False\\n            return True\\n        \\n        return canBreakThrough(source, target) and canBreakThrough(target, source)\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution(object):\\n    def isEscapePossible(self, blocked, source, target):\\n        blocked = set((a,b) for a, b in blocked)\\n        \\n        def canBreakThrough(source, target):\\n            visited = set((source[0], source[1]))\\n            q = [source]\\n            while len(visited) <= 19901:\\n                i = q.pop()\\n                dir = [(i[0]+1, i[1]), (i[0]-1, i[1]), (i[0], i[1]+1), (i[0], i[1]-1)]\\n                for d in dir:\\n                    if d not in blocked and d not in visited:\\n                        if d[0] < 0 or d[0] >= 10**6 or d[1] < 0 or d[1] >= 10**6: continue\\n                        if d[0] == target[0] and d[1] == target[1]: return True\\n                        if abs(d[0] - source[0]) > 200 or abs(d[1] - source[1]) > 200: return True\\n                        visited.add(d)\\n                        q.append(d)\\n                if not q: return False\\n            return True\\n        \\n        return canBreakThrough(source, target) and canBreakThrough(target, source)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1605464,
                "title": "java-bfs-with-explanations",
                "content": "Since we know that there are at most 200 obstacles, it means that we only have to search the 200 by 200 regions around both Target and Source, if both are still going after reaching 200 steps, we know for sure it is not blocked and there exists a path between them. \\n\\n```\\nclass Solution {\\n    private static final int N = 1000000;\\n    private static final int[][] dirs = {{1, 0}, {0, 1}, {-1, 0}, {0, -1}};\\n\\n    public boolean isEscapePossible(int[][] blocked, int[] source, int[] target) {\\n        HashSet<List<Integer>> blockSet = new HashSet<>();\\n        for (int[] b : blocked) \\n            blockSet.add(new ArrayList<>(List.of(b[0], b[1])));\\n        \\n        return check(source, target, blockSet) && check(target, source, blockSet);\\n    }\\n\\n    private boolean check(int[] source, int[] target, HashSet<List<Integer>> blockSet){\\n        int step = 0;\\n        Queue<int[]> queue = new LinkedList<>();\\n        queue.offer(source);\\n\\n        boolean[][] seen = new boolean[401][401]; //center is 200, 200 (source)\\n        while(!queue.isEmpty()){\\n            int size = queue.size();\\n            while(size-- > 0){\\n                int[] cur = queue.poll();\\n                int r = cur[0];\\n                int c = cur[1];\\n                int adjustedR = 200 + r - source[0];\\n                int adjustedC = 200 + c - source[1];\\n                if (seen[adjustedR][adjustedC]) continue;\\n                if (cur[0] == target[0] && cur[1] == target[1]) return true;\\n                seen[adjustedR][adjustedC] = true;\\n\\n                for (int[] d : dirs){\\n                    int nr = r + d[0];\\n                    int nc = c + d[1];\\n                    if (nr < 0 || nr >= N || nc < 0 || nc >= N\\n                            || blockSet.contains(List.of(nr, nc))) continue;\\n                    queue.offer(new int[]{nr, nc});\\n                }\\n            }\\n            step++;\\n            if (step > 200) return true;\\n        }\\n\\n        return false;\\n    }\\n\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    private static final int N = 1000000;\\n    private static final int[][] dirs = {{1, 0}, {0, 1}, {-1, 0}, {0, -1}};\\n\\n    public boolean isEscapePossible(int[][] blocked, int[] source, int[] target) {\\n        HashSet<List<Integer>> blockSet = new HashSet<>();\\n        for (int[] b : blocked) \\n            blockSet.add(new ArrayList<>(List.of(b[0], b[1])));\\n        \\n        return check(source, target, blockSet) && check(target, source, blockSet);\\n    }\\n\\n    private boolean check(int[] source, int[] target, HashSet<List<Integer>> blockSet){\\n        int step = 0;\\n        Queue<int[]> queue = new LinkedList<>();\\n        queue.offer(source);\\n\\n        boolean[][] seen = new boolean[401][401]; //center is 200, 200 (source)\\n        while(!queue.isEmpty()){\\n            int size = queue.size();\\n            while(size-- > 0){\\n                int[] cur = queue.poll();\\n                int r = cur[0];\\n                int c = cur[1];\\n                int adjustedR = 200 + r - source[0];\\n                int adjustedC = 200 + c - source[1];\\n                if (seen[adjustedR][adjustedC]) continue;\\n                if (cur[0] == target[0] && cur[1] == target[1]) return true;\\n                seen[adjustedR][adjustedC] = true;\\n\\n                for (int[] d : dirs){\\n                    int nr = r + d[0];\\n                    int nc = c + d[1];\\n                    if (nr < 0 || nr >= N || nc < 0 || nc >= N\\n                            || blockSet.contains(List.of(nr, nc))) continue;\\n                    queue.offer(new int[]{nr, nc});\\n                }\\n            }\\n            step++;\\n            if (step > 200) return true;\\n        }\\n\\n        return false;\\n    }\\n\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1357840,
                "title": "python-dfs-bfs-48-ms-14-6-mb-100-100-invalid-solution-please-help",
                "content": "So I\\'m not actually very hapy with this code, because it doesn\\'t actually solves all possible test cases, and it\\'s kinda clunky. But it performed well, and I think it\\'s a promising method, so I decided to post it anyway, and explain my thought process to see what the rest of you all think!\\n\\nThe basic premise of my algorithm is that we can quickly determine a lot of test cases by mapping out the walls, and then looking at which regions the source and target are in relative to the wall. For example, as a human a case like\\n\\n![image](https://assets.leetcode.com/users/images/5d8325e1-643b-4f0d-8eef-74287727a249_1627061411.2029922.png)\\n\\nis easy to solve because we can clearly see that the wall divides the space into 2 regions, and that the source and target are in different regions (\\'#\\' is blocking, \\'.\\' is open, \\'S\\' is the source, and \\'T\\' is the target). My algorithm reflects this because it notes that the source is below and to the left of the wall, while the target is above and to the right of the wall, and that the wall touches 2 different edges of the map (implying that the regions are separate). Similarly, for a case like\\n\\n![image](https://assets.leetcode.com/users/images/f751d9f0-5615-42de-be11-7a7dd630e07a_1627061508.945018.png)\\n\\nwe note that the target is fully enclosed by the wall, and that the source is in a separate region that is not enclosed by the wall. My algorithm achieves this too by looking at the extrema of the wall, and then noting that it\\'s fully closed. It maps the wall using a depth-first search where it marks when it encounters something which looks like an endpoint. If the endpoints connect, then the region is fully closed. If the endpoints aren\\'t connected though, then there\\'s a hole somewhere we can use to reach the target. Where this gets tricky is if there are multiple enclosed (or almost enclosed) regions within a single wall. For example, in the figure 8 case, the only method I could think of to determine if the source and target are connected was to use a breadth-first search. For example:\\n\\n![image](https://assets.leetcode.com/users/images/585abcca-14f1-4a54-942d-e2e00c37bf31_1627062137.8809328.png)\\n\\nand\\n\\n![image](https://assets.leetcode.com/users/images/faffb16c-47c8-4ad3-8b19-5b1f67629213_1627062225.3956003.png)\\n\\nare both easily solvable with a breadth-first search from the source to the target. The cases which trick my algorithm though are like this:\\n\\n![image](https://assets.leetcode.com/users/images/23825e89-658c-4b3f-848f-2219cb12ce75_1627062541.8083136.png)\\n\\nwhere there are points directly in all 4 directions from the target, and a separate enclosed region. This tricks my algorithm into thinking that the target is completely enclosed by the current wall even though it isn\\'t. Another example it messes up is\\n\\n![image](https://assets.leetcode.com/users/images/a8d8dff5-3619-4395-8778-e85eeecfb6cb_1627068768.6292272.png)\\n\\nwhere it doesn\\'t understand that the target is fully walled off. Does anyone have any ideas of how to either fix this or detect when cases like these happen? Thanks! (If cases like these were detectable then I could just use a bfs to try to escape the walled region per usual)\\n\\n\\'\\'\\'\\n\\n    #Check if 2 Points Form a Wall\\n    def isWall(self, x1:int, y1:int, x2:int, y2:int) -> int:\\n        return abs(x2 - x1) < 2 and abs(y2 - y1) < 2\\n    \\n    #Solve the Puzzle\\n    def isEscapePossible(self, blocked: List[List[int]], source: List[int], target: List[int]) -> bool:\\n        #Make it Easier to Look Up Blocked Points\\n        blocked = {tuple(blocked.pop()) for i in range(len(blocked))}\\n        \\n        #Split the Source and Target Points\\n        ys, xs = source.pop(), source.pop()\\n        yt, xt = target.pop(), target.pop()\\n        \\n        #A DFS to Map Out Walls\\n        wall = set()\\n        B = [False]*4           #[Bottom, Left, Top, Right]\\n        S = [False]*4           #[Bottom, Left, Top, Right]\\n        T = [False]*4           #[Bottom, Left, Top, Right]\\n        def dfs(x:int, y:int, count:int) -> (int, int):\\n            #Record the Current Point in the Wall\\n            wall.add((x, y))\\n            \\n            #Update the Bounds of the Wall\\n            B[0] |= y == 0\\n            B[1] |= x == 0\\n            B[2] |= y == 999999\\n            B[3] |= x == 999999\\n            \\n            #Check if the Point is In Line With the Source or Target\\n            if x == xs or y == ys:\\n                #Update the Relative Source Bounds\\n                S[0] |= y < ys\\n                S[1] |= x < xs\\n                S[2] |= y > ys\\n                S[3] |= x > xs\\n            if x == xt or y == yt:\\n                #Update the Relative Target Bounds\\n                T[0] |= y < yt\\n                T[1] |= x < xt\\n                T[2] |= y > yt\\n                T[3] |= x > xt\\n            \\n            #Visit the Neighbors\\n            for dx in [-1, 0, 1]:\\n                for dy in [-1, 0, 1]:\\n                    #Compute the New Point\\n                    a = x + dx\\n                    b = y + dy\\n                    \\n                    #Check if the Point is a New Point on the Wall\\n                    if (a, b) in blocked:\\n                        #Remove the Point From \\'blocked\\'\\n                        blocked.remove((a, b))\\n                        \\n                        #Recurse\\n                        yield from dfs(a, b, 0)\\n\\n                        #Increment the Count\\n                        count += 1\\n            \\n            #Check the Count\\n            if count == 0:\\n                #Yield the Endpoint/Loop Point\\n                yield (x, y)\\n        \\n        #Split the Blocked Points into Distinct Walls\\n        while blocked:\\n            #Reset the DFS Memory\\n            wall.clear()\\n            B = [False]*4\\n            S = [False]*4\\n            T = [False]*4\\n            \\n            #Run the DFS on the Next Point (Builds a List of Endpoints)\\n            E = list(dfs(*blocked.pop(), -1))\\n            \\n            #Check if the Source and Target are in Different Regions\\n            if any(s != t for s, t in zip(S, T)):\\n                #Check if Either Point is Fully Enclosed, or if the the Wall Extends to 2 Edges\\n                if (all(S) or all(T) and any(self.isWall(*E[i], *E[j]) for i in range(1, len(E)) for j in range(i))) or sum(B) > 1:\\n                    return False\\n            elif all(S):\\n                #Do a BFS\\n                seen = {(xs, ys)}\\n                queue = deque([(xs, ys)])\\n                while queue:\\n                    #Get the Next Point\\n                    x, y = queue.popleft()\\n                    \\n                    #Check the Point\\n                    if x == xt and y == yt:\\n                        #The Target was Reached\\n                        return True\\n                    \\n                    #Visit the Neighbors\\n                    for x, y in [(x + 1, y), (x, y + 1), (x - 1, y), (x, y - 1)]:\\n                        #Check if the Point is New\\n                        if (x, y) not in wall and (x, y) not in seen:\\n                            #Record the Point\\n                            seen.add((x, y))\\n                            \\n                            #Add the Point to the Queue\\n                            queue.append((x, y))\\n                \\n                #No Path was Found\\n                return False\\n        \\n        #There Isn\\'t a Blocking Wall\\n        return True\\n\\'\\'\\'\\n\\n![image](https://assets.leetcode.com/users/images/fd96b700-7185-4f31-a7cf-adc175a43552_1627060849.1399243.png)\\n\\n",
                "solutionTags": [
                    "Python",
                    "Depth-First Search",
                    "Breadth-First Search"
                ],
                "code": "So I\\'m not actually very hapy with this code, because it doesn\\'t actually solves all possible test cases, and it\\'s kinda clunky. But it performed well, and I think it\\'s a promising method, so I decided to post it anyway, and explain my thought process to see what the rest of you all think!\\n\\nThe basic premise of my algorithm is that we can quickly determine a lot of test cases by mapping out the walls, and then looking at which regions the source and target are in relative to the wall. For example, as a human a case like\\n\\n![image](https://assets.leetcode.com/users/images/5d8325e1-643b-4f0d-8eef-74287727a249_1627061411.2029922.png)\\n\\nis easy to solve because we can clearly see that the wall divides the space into 2 regions, and that the source and target are in different regions (\\'#\\' is blocking, \\'.\\' is open, \\'S\\' is the source, and \\'T\\' is the target). My algorithm reflects this because it notes that the source is below and to the left of the wall, while the target is above and to the right of the wall, and that the wall touches 2 different edges of the map (implying that the regions are separate). Similarly, for a case like\\n\\n![image](https://assets.leetcode.com/users/images/f751d9f0-5615-42de-be11-7a7dd630e07a_1627061508.945018.png)\\n\\nwe note that the target is fully enclosed by the wall, and that the source is in a separate region that is not enclosed by the wall. My algorithm achieves this too by looking at the extrema of the wall, and then noting that it\\'s fully closed. It maps the wall using a depth-first search where it marks when it encounters something which looks like an endpoint. If the endpoints connect, then the region is fully closed. If the endpoints aren\\'t connected though, then there\\'s a hole somewhere we can use to reach the target. Where this gets tricky is if there are multiple enclosed (or almost enclosed) regions within a single wall. For example, in the figure 8 case, the only method I could think of to determine if the source and target are connected was to use a breadth-first search. For example:\\n\\n![image](https://assets.leetcode.com/users/images/585abcca-14f1-4a54-942d-e2e00c37bf31_1627062137.8809328.png)\\n\\nand\\n\\n![image](https://assets.leetcode.com/users/images/faffb16c-47c8-4ad3-8b19-5b1f67629213_1627062225.3956003.png)\\n\\nare both easily solvable with a breadth-first search from the source to the target. The cases which trick my algorithm though are like this:\\n\\n![image](https://assets.leetcode.com/users/images/23825e89-658c-4b3f-848f-2219cb12ce75_1627062541.8083136.png)\\n\\nwhere there are points directly in all 4 directions from the target, and a separate enclosed region. This tricks my algorithm into thinking that the target is completely enclosed by the current wall even though it isn\\'t. Another example it messes up is\\n\\n![image](https://assets.leetcode.com/users/images/a8d8dff5-3619-4395-8778-e85eeecfb6cb_1627068768.6292272.png)\\n\\nwhere it doesn\\'t understand that the target is fully walled off. Does anyone have any ideas of how to either fix this or detect when cases like these happen? Thanks! (If cases like these were detectable then I could just use a bfs to try to escape the walled region per usual)\\n\\n\\'\\'\\'\\n\\n    #Check if 2 Points Form a Wall\\n    def isWall(self, x1:int, y1:int, x2:int, y2:int) -> int:\\n        return abs(x2 - x1) < 2 and abs(y2 - y1) < 2\\n    \\n    #Solve the Puzzle\\n    def isEscapePossible(self, blocked: List[List[int]], source: List[int], target: List[int]) -> bool:\\n        #Make it Easier to Look Up Blocked Points\\n        blocked = {tuple(blocked.pop()) for i in range(len(blocked))}\\n        \\n        #Split the Source and Target Points\\n        ys, xs = source.pop(), source.pop()\\n        yt, xt = target.pop(), target.pop()\\n        \\n        #A DFS to Map Out Walls\\n        wall = set()\\n        B = [False]*4           #[Bottom, Left, Top, Right]\\n        S = [False]*4           #[Bottom, Left, Top, Right]\\n        T = [False]*4           #[Bottom, Left, Top, Right]\\n        def dfs(x:int, y:int, count:int) -> (int, int):\\n            #Record the Current Point in the Wall\\n            wall.add((x, y))\\n            \\n            #Update the Bounds of the Wall\\n            B[0] |= y == 0\\n            B[1] |= x == 0\\n            B[2] |= y == 999999\\n            B[3] |= x == 999999\\n            \\n            #Check if the Point is In Line With the Source or Target\\n            if x == xs or y == ys:\\n                #Update the Relative Source Bounds\\n                S[0] |= y < ys\\n                S[1] |= x < xs\\n                S[2] |= y > ys\\n                S[3] |= x > xs\\n            if x == xt or y == yt:\\n                #Update the Relative Target Bounds\\n                T[0] |= y < yt\\n                T[1] |= x < xt\\n                T[2] |= y > yt\\n                T[3] |= x > xt\\n            \\n            #Visit the Neighbors\\n            for dx in [-1, 0, 1]:\\n                for dy in [-1, 0, 1]:\\n                    #Compute the New Point\\n                    a = x + dx\\n                    b = y + dy\\n                    \\n                    #Check if the Point is a New Point on the Wall\\n                    if (a, b) in blocked:\\n                        #Remove the Point From \\'blocked\\'\\n                        blocked.remove((a, b))\\n                        \\n                        #Recurse\\n                        yield from dfs(a, b, 0)\\n\\n                        #Increment the Count\\n                        count += 1\\n            \\n            #Check the Count\\n            if count == 0:\\n                #Yield the Endpoint/Loop Point\\n                yield (x, y)\\n        \\n        #Split the Blocked Points into Distinct Walls\\n        while blocked:\\n            #Reset the DFS Memory\\n            wall.clear()\\n            B = [False]*4\\n            S = [False]*4\\n            T = [False]*4\\n            \\n            #Run the DFS on the Next Point (Builds a List of Endpoints)\\n            E = list(dfs(*blocked.pop(), -1))\\n            \\n            #Check if the Source and Target are in Different Regions\\n            if any(s != t for s, t in zip(S, T)):\\n                #Check if Either Point is Fully Enclosed, or if the the Wall Extends to 2 Edges\\n                if (all(S) or all(T) and any(self.isWall(*E[i], *E[j]) for i in range(1, len(E)) for j in range(i))) or sum(B) > 1:\\n                    return False\\n            elif all(S):\\n                #Do a BFS\\n                seen = {(xs, ys)}\\n                queue = deque([(xs, ys)])\\n                while queue:\\n                    #Get the Next Point\\n                    x, y = queue.popleft()\\n                    \\n                    #Check the Point\\n                    if x == xt and y == yt:\\n                        #The Target was Reached\\n                        return True\\n                    \\n                    #Visit the Neighbors\\n                    for x, y in [(x + 1, y), (x, y + 1), (x - 1, y), (x, y - 1)]:\\n                        #Check if the Point is New\\n                        if (x, y) not in wall and (x, y) not in seen:\\n                            #Record the Point\\n                            seen.add((x, y))\\n                            \\n                            #Add the Point to the Queue\\n                            queue.append((x, y))\\n                \\n                #No Path was Found\\n                return False\\n        \\n        #There Isn\\'t a Blocking Wall\\n        return True\\n\\'\\'\\'\\n\\n![image](https://assets.leetcode.com/users/images/fd96b700-7185-4f31-a7cf-adc175a43552_1627060849.1399243.png)\\n\\n",
                "codeTag": "Python3"
            },
            {
                "id": 974779,
                "title": "bfs-o-block-2",
                "content": "```\\nunordered_map<int,unordered_map<int,bool>>block;\\n    int max_area;\\n    bool isValid(int x,int y)\\n    {\\n        if(x<0 || y<0|| x>=1000000 || y>=1000000)\\n            return false;\\n        return !block[x][y];\\n    }\\n    bool isPossible(vector<int>& source,vector<int>&target)\\n    {\\n        unordered_map<int,unordered_map<int,bool>> visited;\\n        visited[source[0]][source[1]]=true;\\n        \\n        queue<pair<int,int>>q;\\n        q.push(make_pair(source[0],source[1]));\\n        int t=1;\\n        \\n        while(!q.empty())\\n        {\\n            int x=q.front().first;\\n            int y=q.front().second;\\n            q.pop();\\n          \\n            if(x==target[0] && y== target[1])\\n                return true;\\n            if(t>max_area)\\n                return true;\\n            if(isValid(x-1,y) && !visited[x-1][y])\\n            {\\n                t++;\\n                visited[x-1][y]=true;\\n                q.push(make_pair(x-1,y));\\n            }\\n            if(isValid(x+1,y) && !visited[x+1][y])\\n            {\\n                t++;\\n                visited[x+1][y]=true;\\n                q.push(make_pair(x+1,y));   \\n            }\\n            if(isValid(x,y-1) && !visited[x][y-1])\\n            {\\n                t++;\\n                visited[x][y-1]=true;\\n                q.push(make_pair(x,y-1));\\n            }\\n            if(isValid(x,y+1) && !visited[x][y+1])\\n            {\\n                t++;\\n                visited[x][y+1]=true;\\n                q.push(make_pair(x,y+1));\\n            }\\n        }\\n        return false;\\n    }\\n    bool isEscapePossible(vector<vector<int>>& blocked, vector<int>& source, vector<int>& target)     {\\n        int cnt=0;\\n        \\n        for(int i=0;i<blocked.size();i++)\\n        {\\n            cnt++;\\n            block[blocked[i][0]][blocked[i][1]]=true;\\n        }\\n        max_area = (cnt*(cnt-1))/2;\\n        return isPossible(source,target) && isPossible(target,source);\\n    }\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Breadth-First Search"
                ],
                "code": "```\\nunordered_map<int,unordered_map<int,bool>>block;\\n    int max_area;\\n    bool isValid(int x,int y)\\n    {\\n        if(x<0 || y<0|| x>=1000000 || y>=1000000)\\n            return false;\\n        return !block[x][y];\\n    }\\n    bool isPossible(vector<int>& source,vector<int>&target)\\n    {\\n        unordered_map<int,unordered_map<int,bool>> visited;\\n        visited[source[0]][source[1]]=true;\\n        \\n        queue<pair<int,int>>q;\\n        q.push(make_pair(source[0],source[1]));\\n        int t=1;\\n        \\n        while(!q.empty())\\n        {\\n            int x=q.front().first;\\n            int y=q.front().second;\\n            q.pop();\\n          \\n            if(x==target[0] && y== target[1])\\n                return true;\\n            if(t>max_area)\\n                return true;\\n            if(isValid(x-1,y) && !visited[x-1][y])\\n            {\\n                t++;\\n                visited[x-1][y]=true;\\n                q.push(make_pair(x-1,y));\\n            }\\n            if(isValid(x+1,y) && !visited[x+1][y])\\n            {\\n                t++;\\n                visited[x+1][y]=true;\\n                q.push(make_pair(x+1,y));   \\n            }\\n            if(isValid(x,y-1) && !visited[x][y-1])\\n            {\\n                t++;\\n                visited[x][y-1]=true;\\n                q.push(make_pair(x,y-1));\\n            }\\n            if(isValid(x,y+1) && !visited[x][y+1])\\n            {\\n                t++;\\n                visited[x][y+1]=true;\\n                q.push(make_pair(x,y+1));\\n            }\\n        }\\n        return false;\\n    }\\n    bool isEscapePossible(vector<vector<int>>& blocked, vector<int>& source, vector<int>& target)     {\\n        int cnt=0;\\n        \\n        for(int i=0;i<blocked.size();i++)\\n        {\\n            cnt++;\\n            block[blocked[i][0]][blocked[i][1]]=true;\\n        }\\n        max_area = (cnt*(cnt-1))/2;\\n        return isPossible(source,target) && isPossible(target,source);\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 874695,
                "title": "rust-translated-8ms-100",
                "content": "```rust\\nimpl Solution {\\n    pub fn is_escape_possible(blocked: Vec<Vec<i32>>, source: Vec<i32>, target: Vec<i32>) -> bool {\\n        use std::collections::HashSet;\\n        fn bfs(\\n            visited: &mut HashSet<(i32, i32)>,\\n            source: (i32, i32),\\n            target: (i32, i32),\\n            blocks: usize,\\n        ) -> bool {\\n            const DIRS: [i32; 5] = [0, 1, 0, -1, 0];\\n            let mut q: Vec<(i32, i32)> = vec![source];\\n            while !q.is_empty() && q.len() <= blocks {\\n                let mut q1 = Vec::<(i32, i32)>::new();\\n                for &(x0, y0) in &q {\\n                    for d in 0..4 {\\n                        let x = x0 + DIRS[d];\\n                        let y = y0 + DIRS[d + 1];\\n                        if !(x >= 0 && x < 1_000_000 && y >= 0 && y < 1_000_000) {\\n                            continue;\\n                        }\\n                        if x == target.0 && y == target.1 {\\n                            return true;\\n                        }\\n                        if visited.insert((x, y)) {\\n                            q1.push((x, y));\\n                        }\\n                    }\\n                }\\n                std::mem::swap(&mut q, &mut q1);\\n            }\\n            !q.is_empty()\\n        }\\n        let mut visited_source = blocked\\n            .iter()\\n            .filter(|&v| (v[0] - source[0]).abs() + (v[1] - source[1]).abs() < 400)\\n            .map(|v| (v[0], v[1]))\\n            .collect::<HashSet<(i32, i32)>>();\\n        let mut visited_target = blocked\\n            .iter()\\n            .filter(|&v| (v[0] - target[0]).abs() + (v[1] - target[1]).abs() < 400)\\n            .map(|v| (v[0], v[1]))\\n            .collect::<HashSet<(i32, i32)>>();\\n        let source_blocks = visited_source.len();\\n        let target_blocks = visited_target.len();\\n        let source = (source[0], source[1]);\\n        let target = (target[0], target[1]);\\n        bfs(&mut visited_source, source, target, source_blocks)\\n            && bfs(&mut visited_target, target, source, target_blocks)\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```rust\\nimpl Solution {\\n    pub fn is_escape_possible(blocked: Vec<Vec<i32>>, source: Vec<i32>, target: Vec<i32>) -> bool {\\n        use std::collections::HashSet;\\n        fn bfs(\\n            visited: &mut HashSet<(i32, i32)>,\\n            source: (i32, i32),\\n            target: (i32, i32),\\n            blocks: usize,\\n        ) -> bool {\\n            const DIRS: [i32; 5] = [0, 1, 0, -1, 0];\\n            let mut q: Vec<(i32, i32)> = vec![source];\\n            while !q.is_empty() && q.len() <= blocks {\\n                let mut q1 = Vec::<(i32, i32)>::new();\\n                for &(x0, y0) in &q {\\n                    for d in 0..4 {\\n                        let x = x0 + DIRS[d];\\n                        let y = y0 + DIRS[d + 1];\\n                        if !(x >= 0 && x < 1_000_000 && y >= 0 && y < 1_000_000) {\\n                            continue;\\n                        }\\n                        if x == target.0 && y == target.1 {\\n                            return true;\\n                        }\\n                        if visited.insert((x, y)) {\\n                            q1.push((x, y));\\n                        }\\n                    }\\n                }\\n                std::mem::swap(&mut q, &mut q1);\\n            }\\n            !q.is_empty()\\n        }\\n        let mut visited_source = blocked\\n            .iter()\\n            .filter(|&v| (v[0] - source[0]).abs() + (v[1] - source[1]).abs() < 400)\\n            .map(|v| (v[0], v[1]))\\n            .collect::<HashSet<(i32, i32)>>();\\n        let mut visited_target = blocked\\n            .iter()\\n            .filter(|&v| (v[0] - target[0]).abs() + (v[1] - target[1]).abs() < 400)\\n            .map(|v| (v[0], v[1]))\\n            .collect::<HashSet<(i32, i32)>>();\\n        let source_blocks = visited_source.len();\\n        let target_blocks = visited_target.len();\\n        let source = (source[0], source[1]);\\n        let target = (target[0], target[1]);\\n        bfs(&mut visited_source, source, target, source_blocks)\\n            && bfs(&mut visited_target, target, source, target_blocks)\\n    }\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 864087,
                "title": "c-the-fastest-solution-n-log-n",
                "content": "Almost every uploaded solution is based on hack with blocked size limit.\\nThis solution provides general approach, based on graph building and DFS:\\n\\n1. Build graph, so each branch will represent line on a plane.\\n2. Traverse all these lines using standard DFS.\\n3. Count point occurences (source and target) below and above line.\\n3. Checks conditions: loop detected, traversed from left to bottom, from top to right and so on ...\\n4. Make verdict whether points are separated based on bottom and top occurences count (probably left and right also needed).\\n\\nBTW, I used map in order to shorten code. You can use sorting and then vector to reach 100% beat on space and time.\\n\\n```\\nbool dfs(map<pair<int,int>, set<pair<int,int>>>& graph, set<pair<int,int>>& seen, \\n\\tpair<int,int> cur, pair<int,int> start, int bottom, int top, vector<int>& s, vector<int>& t, pair<int,int> prev)\\n{\\n\\tseen.insert(cur);\\n\\tbottom += !!(s[0] == cur.first && s[1] < cur.second) + !!(t[0] == cur.first && t[1] < cur.second);\\n\\ttop += !!(s[0] == cur.first && s[1] > cur.second) + !!(t[0] == cur.first && t[1] > cur.second);\\n\\n\\tif (cur == start || (start.first == 0 && cur.second == 0) || (start.second == 1e6-1 && cur.first == 1e6-1)) // add more cases\\n\\t\\tif ((bottom && bottom == top) || (bottom == 1 && top == 0) || (bottom == 0 && top == 1)) // add more cases\\n\\t\\t\\treturn false;\\n\\n\\tfor (auto adj : graph[cur])\\n\\t\\tif (!seen.count(adj) || (adj == start && adj != prev))\\n\\t\\t\\tif (!dfs(graph, seen, adj, start, bottom, top, s, t, cur))\\n\\t\\t\\t\\treturn false;\\n\\n\\treturn true;\\n}\\n\\nbool isEscapePossible(vector<vector<int>>& blocked, vector<int>& source, vector<int>& target) \\n{\\n\\tconst vector<int> moves { -1, 0, 1 };\\n\\tmap<pair<int,int>, set<pair<int,int>>> graph;\\n\\tset<pair<int,int>> seen;\\n\\n\\tfor (auto point : blocked)\\n\\t\\tgraph[{point[0], point[1]}] = set<pair<int,int>>();\\n\\n\\tfor (auto point : blocked)\\n\\t\\tfor (auto move : moves)\\n\\t\\t\\tif (graph.count({point[0] + 1, point[1] + move}))\\n\\t\\t\\t\\tgraph[{point[0], point[1]}].insert({point[0] + 1, point[1] + move}),\\n\\t\\t\\t\\tgraph[{point[0] + 1, point[1] + move}].insert({point[0], point[1]});\\n\\n\\tfor (auto [cur, adjs] : graph)\\n\\t\\tif (!seen.count(cur) && !dfs(graph, seen, cur, cur, 0, 0, source, target, {-1,-1}))\\n\\t\\t\\treturn false;\\n\\n\\treturn true;\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nbool dfs(map<pair<int,int>, set<pair<int,int>>>& graph, set<pair<int,int>>& seen, \\n\\tpair<int,int> cur, pair<int,int> start, int bottom, int top, vector<int>& s, vector<int>& t, pair<int,int> prev)\\n{\\n\\tseen.insert(cur);\\n\\tbottom += !!(s[0] == cur.first && s[1] < cur.second) + !!(t[0] == cur.first && t[1] < cur.second);\\n\\ttop += !!(s[0] == cur.first && s[1] > cur.second) + !!(t[0] == cur.first && t[1] > cur.second);\\n\\n\\tif (cur == start || (start.first == 0 && cur.second == 0) || (start.second == 1e6-1 && cur.first == 1e6-1)) // add more cases\\n\\t\\tif ((bottom && bottom == top) || (bottom == 1 && top == 0) || (bottom == 0 && top == 1)) // add more cases\\n\\t\\t\\treturn false;\\n\\n\\tfor (auto adj : graph[cur])\\n\\t\\tif (!seen.count(adj) || (adj == start && adj != prev))\\n\\t\\t\\tif (!dfs(graph, seen, adj, start, bottom, top, s, t, cur))\\n\\t\\t\\t\\treturn false;\\n\\n\\treturn true;\\n}\\n\\nbool isEscapePossible(vector<vector<int>>& blocked, vector<int>& source, vector<int>& target) \\n{\\n\\tconst vector<int> moves { -1, 0, 1 };\\n\\tmap<pair<int,int>, set<pair<int,int>>> graph;\\n\\tset<pair<int,int>> seen;\\n\\n\\tfor (auto point : blocked)\\n\\t\\tgraph[{point[0], point[1]}] = set<pair<int,int>>();\\n\\n\\tfor (auto point : blocked)\\n\\t\\tfor (auto move : moves)\\n\\t\\t\\tif (graph.count({point[0] + 1, point[1] + move}))\\n\\t\\t\\t\\tgraph[{point[0], point[1]}].insert({point[0] + 1, point[1] + move}),\\n\\t\\t\\t\\tgraph[{point[0] + 1, point[1] + move}].insert({point[0], point[1]});\\n\\n\\tfor (auto [cur, adjs] : graph)\\n\\t\\tif (!seen.count(cur) && !dfs(graph, seen, cur, cur, 0, 0, source, target, {-1,-1}))\\n\\t\\t\\treturn false;\\n\\n\\treturn true;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 759141,
                "title": "dfs-a-beats-83",
                "content": "We can use the fact that there are only 200 blocked points. While exploring the area at each point calculate the distance from this point to SOURCE and if it is > 200 we have escaped the blocked area. Going from source to target there can only be three options:\\n1) we reach the target\\n2) we reach the distance > 200\\n3) we explore all the area not reaching the target and staying within 200 distance from SOURCE, i.e. we are blocked\\n\\nI use DFS to explore the area. Also, to minimize the number of explored points and go directly from SOURCE to TARGET I use Min-Heap instead of stack for DFS. The key for the heap is as follows: distance(POINT,TARGET) - distance(POINT, SOURCE). This will always favor points that are further from SOURCE and closer to TARGET so they will be seleced first.  Approach is similar to A* search algorithm.\\n\\n```\\nm = 10**6\\n\\nblocked_set = set()\\nfor x, y in blocked: \\n\\tblocked_set.add((x,y))\\n\\n# distance between two points\\ndef distance(src, target): return abs(target[0]-src[0]) + abs(target[1]-src[1])\\n\\n# score for the heap = [distance to target] - [distance to source]\\ndef calcScore(point, src, target): return distance(point, target) - distance(point, src)\\n\\n# DFS + Min-Heap\\ndef explore(src, target):\\n\\th = [(0,src[0],src[1])]\\n\\tvisited = set()\\n\\twhile h:\\n\\t\\tscore, i, j = heappop(h)\\n\\t\\tif (i,j) not in visited:\\n\\t\\t\\tvisited.add((i,j))\\n\\t\\t\\tif [i,j] == target:\\n\\t\\t\\t\\treturn 2 # we reached target\\n\\t\\t\\tdist = distance([i,j], src)\\n\\t\\t\\tif dist > 200:\\n\\t\\t\\t\\treturn 1 # we can escape the blocked area\\n\\t\\t\\tfor d in [[0,1],[1,0],[0,-1],[-1,0]]:\\n\\t\\t\\t\\tni,nj = i+d[0], j+d[1]\\n\\t\\t\\t\\tif 0 <= ni < m and 0 <= nj < m and (ni,nj) not in blocked_set and (ni,nj) not in visited:\\n\\t\\t\\t\\t\\tscore = calcScore([ni,nj], src, target)\\n\\t\\t\\t\\t\\theappush(h, (score, ni, nj))\\n\\treturn 0 # we are blocked\\n\\n    ex1 = explore(source, target)\\n    if ex1 == 2:\\n        return True\\n    return ex1 > 0 and explore(target, source) > 0\\n```",
                "solutionTags": [
                    "Depth-First Search",
                    "Iterator"
                ],
                "code": "```\\nm = 10**6\\n\\nblocked_set = set()\\nfor x, y in blocked: \\n\\tblocked_set.add((x,y))\\n\\n# distance between two points\\ndef distance(src, target): return abs(target[0]-src[0]) + abs(target[1]-src[1])\\n\\n# score for the heap = [distance to target] - [distance to source]\\ndef calcScore(point, src, target): return distance(point, target) - distance(point, src)\\n\\n# DFS + Min-Heap\\ndef explore(src, target):\\n\\th = [(0,src[0],src[1])]\\n\\tvisited = set()\\n\\twhile h:\\n\\t\\tscore, i, j = heappop(h)\\n\\t\\tif (i,j) not in visited:\\n\\t\\t\\tvisited.add((i,j))\\n\\t\\t\\tif [i,j] == target:\\n\\t\\t\\t\\treturn 2 # we reached target\\n\\t\\t\\tdist = distance([i,j], src)\\n\\t\\t\\tif dist > 200:\\n\\t\\t\\t\\treturn 1 # we can escape the blocked area\\n\\t\\t\\tfor d in [[0,1],[1,0],[0,-1],[-1,0]]:\\n\\t\\t\\t\\tni,nj = i+d[0], j+d[1]\\n\\t\\t\\t\\tif 0 <= ni < m and 0 <= nj < m and (ni,nj) not in blocked_set and (ni,nj) not in visited:\\n\\t\\t\\t\\t\\tscore = calcScore([ni,nj], src, target)\\n\\t\\t\\t\\t\\theappush(h, (score, ni, nj))\\n\\treturn 0 # we are blocked\\n\\n    ex1 = explore(source, target)\\n    if ex1 == 2:\\n        return True\\n    return ex1 > 0 and explore(target, source) > 0\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 755256,
                "title": "java-bfs-block-check-using-queue-size",
                "content": "~~~java\\n\\n    public boolean isEscapePossible(int[][] blocked, int[] source, int[] target) {\\n        int n = blocked.length;\\n        if (n == 0 || Arrays.equals(source, target)) return true;\\n        \\n        Set<String> blocks = new HashSet<>();\\n        for (int[] b : blocked) {\\n            blocks.add(Arrays.toString(b));\\n        }\\n        \\n        Set<String> visited = new HashSet<>();\\n        \\n        boolean sourceCanPass = bfs(source, target, visited, blocks);\\n        if (!sourceCanPass) return false;\\n        \\n        visited.clear();\\n        boolean targetCanPass = bfs(target, source, visited, blocks);\\n        return targetCanPass;\\n    }\\n    \\n    private boolean bfs(int[] start, int[] end, Set<String> visited, Set<String> blocks) {\\n        int[] dx = new int[]{1,-1,0,0};\\n        int[] dy = new int[]{0,0,1,-1};\\n        Queue<int[]> q = new LinkedList<>();\\n        q.offer(start);\\n        visited.add(start[0] + \",\" + start[1]);\\n        \\n        while (!q.isEmpty()) {\\n            int[] cur = q.poll();\\n            if (Arrays.equals(cur, end)) return true;\\n            for (int k = 0; k < 4; k++) {\\n                int nx = cur[0] + dx[k], ny = cur[1] + dy[k];\\n                if (nx < 0 || ny < 0 || nx >= 1000000 || ny >= 1000000) continue;\\n                String s = Arrays.toString(new int[]{nx, ny});\\n                if (blocks.contains(s) || !visited.add(s)) continue;\\n                q.offer(new int[]{nx, ny});\\n            }\\n            // if we have q.size() nodes visited, we need at least q.size() nodes to block it\\n            if (q.size() > blocks.size()) return true;\\n        }\\n        \\n        return false;\\n    }\\n\\n~~~",
                "solutionTags": [],
                "code": "~~~java\\n\\n    public boolean isEscapePossible(int[][] blocked, int[] source, int[] target) {\\n        int n = blocked.length;\\n        if (n == 0 || Arrays.equals(source, target)) return true;\\n        \\n        Set<String> blocks = new HashSet<>();\\n        for (int[] b : blocked) {\\n            blocks.add(Arrays.toString(b));\\n        }\\n        \\n        Set<String> visited = new HashSet<>();\\n        \\n        boolean sourceCanPass = bfs(source, target, visited, blocks);\\n        if (!sourceCanPass) return false;\\n        \\n        visited.clear();\\n        boolean targetCanPass = bfs(target, source, visited, blocks);\\n        return targetCanPass;\\n    }\\n    \\n    private boolean bfs(int[] start, int[] end, Set<String> visited, Set<String> blocks) {\\n        int[] dx = new int[]{1,-1,0,0};\\n        int[] dy = new int[]{0,0,1,-1};\\n        Queue<int[]> q = new LinkedList<>();\\n        q.offer(start);\\n        visited.add(start[0] + \",\" + start[1]);\\n        \\n        while (!q.isEmpty()) {\\n            int[] cur = q.poll();\\n            if (Arrays.equals(cur, end)) return true;\\n            for (int k = 0; k < 4; k++) {\\n                int nx = cur[0] + dx[k], ny = cur[1] + dy[k];\\n                if (nx < 0 || ny < 0 || nx >= 1000000 || ny >= 1000000) continue;\\n                String s = Arrays.toString(new int[]{nx, ny});\\n                if (blocks.contains(s) || !visited.add(s)) continue;\\n                q.offer(new int[]{nx, ny});\\n            }\\n            // if we have q.size() nodes visited, we need at least q.size() nodes to block it\\n            if (q.size() > blocks.size()) return true;\\n        }\\n        \\n        return false;\\n    }\\n\\n~~~",
                "codeTag": "Unknown"
            },
            {
                "id": 621173,
                "title": "o-nlogn-method-where-n-is-the-number-of-blocked-squares-java-solution",
                "content": "Almost all people are talking about how large an area the blocked cells can form, and use that to stop DFS/BFS earlier. I was thinking of a more general method that assumes nothing about the number of blocked cells.\\n\\nIf there is no blocked cell, we can easily reach the target by first moving horizontally then vertically. I call this the ***main route***. If there is a blocked cell on the route, then we can go along the blocked \"wall\" to see if we can go around it to get back to the main route.\\n\\nBelow is the code. Sorting the blocked cells takes O(NlogN) time, where N is the number of blocked cells. DFS only takes O(N) time because we only step on those cells surrounding the blocked cells, and there are at most O(N) such cells. Overall, O(NlogN) time.\\n\\nThe code is long and hard to read, I have to admit. Any comment or counter-example is welcome.\\n\\n```\\nclass Solution {\\n    \\n    int[]source;\\n    int[]target;\\n    int xmin;\\n    int xmax;\\n    int ymin;\\n    int ymax;\\n    HashSet<Node>blocks;\\n    HashSet<Node>been;\\n    LinkedList<Integer>vertical;\\n    LinkedList<Integer>horizontal;\\n    int[][]neigh={{-1,-1},{-1,0},{-1,1},{0,-1},{0,1},{1,-1},{1,0},{1,1}};\\n    int[][]ds={{-1,0},{1,0},{0,-1},{0,1}};\\n    int[][]want;\\n    \\n    public boolean isEscapePossible(int[][] blocked, int[] source, int[] target) {\\n        this.source=target;\\n        this.target=target;\\n        blocks=new HashSet();\\n        been=new HashSet();\\n        vertical=new LinkedList();\\n        horizontal=new LinkedList();\\n        \\n        // Mirror if necessary\\n        int xmirror=source[0]<=target[0]?1:-1;\\n        int ymirror=source[1]<=target[1]?1:-1;\\n        \\n        source[0]*=xmirror;\\n        source[1]*=ymirror;\\n        target[0]*=xmirror;\\n        target[1]*=ymirror;\\n        \\n        xmin=xmirror==1?0:(-1000000+1);\\n        xmax=xmirror==1?(1000000-1):0;\\n        ymin=ymirror==1?0:(-1000000+1);\\n        ymax=ymirror==1?(1000000-1):0;\\n        \\n        for(int[]b:blocked){\\n            int x=(b[0]*=xmirror),y=(b[1]*=ymirror);\\n            blocks.add(new Node(x,y));\\n            if(y==source[1])horizontal.offer(x);\\n            if(x==target[0])vertical.offer(y);\\n        }\\n        \\n        Collections.sort(horizontal);\\n        Collections.sort(vertical);\\n        \\n        want=new int[][]{{source[0]+1,target[0]-1,source[1],source[1]},{target[0],target[0],source[1],target[1]}};\\n        \\n        return dfs(source[0],source[1],true);\\n        \\n    }\\n    \\n    private boolean dfs(int x,int y,boolean jump){\\n        if(x==target[0]&&y==target[1])return true;\\n        if(jump){\\n            if(x!=target[0]){\\n                // jump horizontally\\n                ceil(horizontal,x);\\n                if(horizontal.isEmpty()||horizontal.peek()>target[0]){\\n                    want[0][0]=want[0][1]+1;//means disabled\\n                    want[1][2]=y+1;\\n                    return dfs(target[0],y,true);\\n                }\\n                else{\\n                    int nx=horizontal.peek()-1;\\n                    been.add(new Node(nx,y));\\n                    want[0][0]=nx+1;\\n                    return dfs(nx,y,false);\\n                }\\n            }\\n            else{\\n                // jump vertcally\\n                ceil(vertical,y);\\n                if(vertical.isEmpty()||vertical.peek()>target[1])\\n                    return true;\\n                else{\\n                    int ny=vertical.peek()-1;\\n                    been.add(new Node(x,ny));\\n                    want[1][2]=ny+1;\\n                    return dfs(x,ny,false);\\n                }\\n            }\\n        }\\n        \\n        for(int[]d:ds){\\n            int nx=x+d[0], ny=y+d[1];\\n            Node node=new Node(nx,ny);\\n            if(nx>=xmin&&nx<=xmax&&ny>=ymin&&ny<=ymax\\n               &&!blocks.contains(node)&&!been.contains(node)\\n               &&hasBlockedNeighbor(nx,ny)){\\n                been.add(node);\\n                if(readyToJump(nx,ny)&&dfs(nx,ny,true))return true;\\n                if(dfs(nx,ny,false))return true;\\n            }\\n        }\\n        \\n        return false;\\n    }\\n    \\n    private void ceil(LinkedList<Integer>list,int n){\\n        while(!list.isEmpty()&&list.peek()<n)list.poll();\\n    }\\n    \\n    private boolean hasBlockedNeighbor(int x,int y){\\n        for(int[]ngh:neigh){\\n            if(blocks.contains(new Node(x+ngh[0],y+ngh[1])))\\n                return true;\\n        }\\n        return false;\\n    }\\n    \\n    private boolean readyToJump(int x,int y){\\n        // update \\'want\\' if necessary\\n        if(x>=want[0][0]&&x<=want[0][1]&&y>=want[0][2]&&y<=want[0][3]){\\n            want[0][0]=x+1;\\n            return true;\\n        }\\n        if(x>=want[1][0]&&x<=want[1][1]&&y>=want[1][2]&&y<=want[1][3]){\\n            want[1][2]=y+1;\\n            return true;\\n        }\\n        return false;\\n    }\\n    \\n}\\n\\nclass Node {\\n    int x;\\n    int y;\\n    public Node(int xx,int yy){\\n        x=xx;\\n        y=yy;\\n    }\\n    \\n    public int hashCode(){\\n        return x+20773*y;\\n    }\\n    public boolean equals(Object obj){\\n        if(obj instanceof Node){\\n            Node n=(Node)obj;\\n            return x==n.x&&y==n.y;\\n        }\\n        return false;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    \\n    int[]source;\\n    int[]target;\\n    int xmin;\\n    int xmax;\\n    int ymin;\\n    int ymax;\\n    HashSet<Node>blocks;\\n    HashSet<Node>been;\\n    LinkedList<Integer>vertical;\\n    LinkedList<Integer>horizontal;\\n    int[][]neigh={{-1,-1},{-1,0},{-1,1},{0,-1},{0,1},{1,-1},{1,0},{1,1}};\\n    int[][]ds={{-1,0},{1,0},{0,-1},{0,1}};\\n    int[][]want;\\n    \\n    public boolean isEscapePossible(int[][] blocked, int[] source, int[] target) {\\n        this.source=target;\\n        this.target=target;\\n        blocks=new HashSet();\\n        been=new HashSet();\\n        vertical=new LinkedList();\\n        horizontal=new LinkedList();\\n        \\n        // Mirror if necessary\\n        int xmirror=source[0]<=target[0]?1:-1;\\n        int ymirror=source[1]<=target[1]?1:-1;\\n        \\n        source[0]*=xmirror;\\n        source[1]*=ymirror;\\n        target[0]*=xmirror;\\n        target[1]*=ymirror;\\n        \\n        xmin=xmirror==1?0:(-1000000+1);\\n        xmax=xmirror==1?(1000000-1):0;\\n        ymin=ymirror==1?0:(-1000000+1);\\n        ymax=ymirror==1?(1000000-1):0;\\n        \\n        for(int[]b:blocked){\\n            int x=(b[0]*=xmirror),y=(b[1]*=ymirror);\\n            blocks.add(new Node(x,y));\\n            if(y==source[1])horizontal.offer(x);\\n            if(x==target[0])vertical.offer(y);\\n        }\\n        \\n        Collections.sort(horizontal);\\n        Collections.sort(vertical);\\n        \\n        want=new int[][]{{source[0]+1,target[0]-1,source[1],source[1]},{target[0],target[0],source[1],target[1]}};\\n        \\n        return dfs(source[0],source[1],true);\\n        \\n    }\\n    \\n    private boolean dfs(int x,int y,boolean jump){\\n        if(x==target[0]&&y==target[1])return true;\\n        if(jump){\\n            if(x!=target[0]){\\n                // jump horizontally\\n                ceil(horizontal,x);\\n                if(horizontal.isEmpty()||horizontal.peek()>target[0]){\\n                    want[0][0]=want[0][1]+1;//means disabled\\n                    want[1][2]=y+1;\\n                    return dfs(target[0],y,true);\\n                }\\n                else{\\n                    int nx=horizontal.peek()-1;\\n                    been.add(new Node(nx,y));\\n                    want[0][0]=nx+1;\\n                    return dfs(nx,y,false);\\n                }\\n            }\\n            else{\\n                // jump vertcally\\n                ceil(vertical,y);\\n                if(vertical.isEmpty()||vertical.peek()>target[1])\\n                    return true;\\n                else{\\n                    int ny=vertical.peek()-1;\\n                    been.add(new Node(x,ny));\\n                    want[1][2]=ny+1;\\n                    return dfs(x,ny,false);\\n                }\\n            }\\n        }\\n        \\n        for(int[]d:ds){\\n            int nx=x+d[0], ny=y+d[1];\\n            Node node=new Node(nx,ny);\\n            if(nx>=xmin&&nx<=xmax&&ny>=ymin&&ny<=ymax\\n               &&!blocks.contains(node)&&!been.contains(node)\\n               &&hasBlockedNeighbor(nx,ny)){\\n                been.add(node);\\n                if(readyToJump(nx,ny)&&dfs(nx,ny,true))return true;\\n                if(dfs(nx,ny,false))return true;\\n            }\\n        }\\n        \\n        return false;\\n    }\\n    \\n    private void ceil(LinkedList<Integer>list,int n){\\n        while(!list.isEmpty()&&list.peek()<n)list.poll();\\n    }\\n    \\n    private boolean hasBlockedNeighbor(int x,int y){\\n        for(int[]ngh:neigh){\\n            if(blocks.contains(new Node(x+ngh[0],y+ngh[1])))\\n                return true;\\n        }\\n        return false;\\n    }\\n    \\n    private boolean readyToJump(int x,int y){\\n        // update \\'want\\' if necessary\\n        if(x>=want[0][0]&&x<=want[0][1]&&y>=want[0][2]&&y<=want[0][3]){\\n            want[0][0]=x+1;\\n            return true;\\n        }\\n        if(x>=want[1][0]&&x<=want[1][1]&&y>=want[1][2]&&y<=want[1][3]){\\n            want[1][2]=y+1;\\n            return true;\\n        }\\n        return false;\\n    }\\n    \\n}\\n\\nclass Node {\\n    int x;\\n    int y;\\n    public Node(int xx,int yy){\\n        x=xx;\\n        y=yy;\\n    }\\n    \\n    public int hashCode(){\\n        return x+20773*y;\\n    }\\n    public boolean equals(Object obj){\\n        if(obj instanceof Node){\\n            Node n=(Node)obj;\\n            return x==n.x&&y==n.y;\\n        }\\n        return false;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 574724,
                "title": "javascript-bfs",
                "content": "```\\nconst isEscapePossible = (blocked, source, target) => {\\n    \\n  // Need to check possibility to escape for both target and source\\n  return helper(blocked, source, target) && helper(blocked, target, source);\\n};\\n\\nconst helper = (blocked, source, target) => {\\n  if (!blocked || blocked.length === 0) return true;\\n\\n  // Creating hash maps for visited and blocked values\\n  blocked = new Set(blocked.map(arr => arr.toString()));\\n  let visited = new Set();\\n  let queue = [source];\\n\\n  let n = 10 ** 6;\\n  let m = 10 ** 6;\\n  let level = 0;\\n\\n  // Using queue for BFS\\n  while (queue.length > 0) {\\n      \\n    // Counting levels from the source\\n    const levelLength = queue.length;\\n    for (let k = 0; k < levelLength; k++) {\\n      const [i, j] = queue.shift();\\n      if (i === target[0] && j === target[1]) return true;\\n        \\n      // Checkig each of 4 directions and adding them to queue and visited hash map\\n      for (const [x, y] of [[i + 1, j], [i - 1, j], [i, j + 1], [i, j - 1]]) {\\n        const stringed = [x, y].toString();\\n        if (x >= 0 && x < n && y >= 0 && y < m && !visited.has(stringed) && !blocked.has(stringed)) {\\n          queue.push([x, y]);\\n          visited.add(stringed);\\n        }\\n          \\n      }\\n    }\\n    level += 1;\\n      \\n    // If level is bigger than the amount of blocked position we can assume that escape exists\\n    if (level > blocked.size) return true;\\n  }\\n\\n  return false;\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nconst isEscapePossible = (blocked, source, target) => {\\n    \\n  // Need to check possibility to escape for both target and source\\n  return helper(blocked, source, target) && helper(blocked, target, source);\\n};\\n\\nconst helper = (blocked, source, target) => {\\n  if (!blocked || blocked.length === 0) return true;\\n\\n  // Creating hash maps for visited and blocked values\\n  blocked = new Set(blocked.map(arr => arr.toString()));\\n  let visited = new Set();\\n  let queue = [source];\\n\\n  let n = 10 ** 6;\\n  let m = 10 ** 6;\\n  let level = 0;\\n\\n  // Using queue for BFS\\n  while (queue.length > 0) {\\n      \\n    // Counting levels from the source\\n    const levelLength = queue.length;\\n    for (let k = 0; k < levelLength; k++) {\\n      const [i, j] = queue.shift();\\n      if (i === target[0] && j === target[1]) return true;\\n        \\n      // Checkig each of 4 directions and adding them to queue and visited hash map\\n      for (const [x, y] of [[i + 1, j], [i - 1, j], [i, j + 1], [i, j - 1]]) {\\n        const stringed = [x, y].toString();\\n        if (x >= 0 && x < n && y >= 0 && y < m && !visited.has(stringed) && !blocked.has(stringed)) {\\n          queue.push([x, y]);\\n          visited.add(stringed);\\n        }\\n          \\n      }\\n    }\\n    level += 1;\\n      \\n    // If level is bigger than the amount of blocked position we can assume that escape exists\\n    if (level > blocked.size) return true;\\n  }\\n\\n  return false;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 561992,
                "title": "javascript-bfs-solution-with-explanation",
                "content": "```javascript\\n/**\\n * Define row directions [north, south, east, west]\\n * @type {number[]}\\n */\\nconst dr = [-1, +1, 0, 0];\\n\\n/**\\n * Define col directions [north, south, east, west]\\n * @type {number[]}\\n */\\nconst dc = [0, 0, +1, -1];\\n\\n/**\\n * Maximum row index 10^6\\n * @type {number}\\n */\\nconst R = 10 ** 6;\\n\\n/**\\n * Maximum col index 10^6\\n * @type {number}\\n */\\nconst C = 10 ** 6;\\n\\n/**\\n * @param {number[][]} blocked\\n * @param {number[]} source\\n * @param {number[]} target\\n * @return {boolean}\\n */\\nconst isEscapePossible = function (blocked, source, target) {\\n\\n    /**\\n     * Create a hash map of blocked cells\\n     * @type {Record<string, undefined>}\\n     */\\n    const blocks = blocked.reduce((acc, [r, c]) => {\\n        acc[`${r}-${c}`] = undefined;\\n        return acc;\\n    }, {});\\n\\n    /**\\n     * Method explores neighborhood cells and add them\\n     * to bfs queue\\n     *\\n     * @param r         - current row\\n     * @param c         - current cell\\n     * @param visited   - visited map\\n     * @param rq        - row queue\\n     * @param cq        - col queue\\n     */\\n    function checkNeighborhood(r, c, visited, rq, cq) {\\n        /*\\n         * Go through all possible directions\\n         */\\n        for (let side = 0; side < 4; side++) {\\n            const nr = r + dr[side];\\n            const nc = c + dc[side];\\n\\n            /*\\n             * Do not add new cell if it\\'s not valid\\n             */\\n            if (nr < 0 || nr >= R) continue;\\n            if (nc < 0 || nc >= C) continue;\\n\\n            /*\\n             * Create a key for cell in order to store it\\n             * as visited\\n             */\\n            const cell = `${nr}-${nc}`;\\n\\n            /*\\n             * Check if the side is blocked or visited.\\n             */\\n            if (\\n                blocks.hasOwnProperty(cell) ||\\n                visited.hasOwnProperty(cell)\\n            ) continue;\\n\\n            /*\\n             * If the cell is valid, we add its row and col\\n             * to queues\\n             */\\n            rq.push(nr);\\n            cq.push(nc);\\n\\n            /*\\n             * Mark as visited\\n             */\\n            visited[`${nr}-${nc}`] = undefined;\\n        }\\n    }\\n\\n    /*\\n     * We need some heuristic for determining if\\n     * it\\'s possible to go to the end. In this solution\\n     * we use a Manhattan distance. \\n     * \\n     * If manhattan distance from source to current cell\\n     * is bigger than number of blocked cell we can say\\n     * that it\\'s possible to go to the end\\n     *\\n     * https://cs.stanford.edu/people/abisee/gs.pdf\\n     */\\n    const LIMIT = blocked.length;\\n\\n    /**\\n     * Performs BFS for target position from source\\n     * @param sr - start row\\n     * @param sc - start col\\n     * @param tR - target row\\n     * @param tC - target col\\n     * @returns {boolean}\\n     */\\n    function bfs([sr, sc], [tR, tC]) {\\n        /**\\n         * Stores visited cells\\n         * @type {Record<string, undefined>}\\n         */\\n        const visited = {};\\n        \\n        /*\\n         * Queues for storing cells\\n         */\\n        const rq = [];\\n        const cq = [];\\n\\n        /*\\n         * Push start points\\n         */\\n        rq.push(sr);\\n        cq.push(sc);\\n\\n        while (rq.length !== 0) {\\n            const r = rq.shift();\\n            const c = cq.shift();\\n            /*\\n             * If current cell equals to target, we found a solution\\n             */\\n            if (r === tR && c === tC) return true;\\n            \\n            /*\\n             * If manhattan distance from source to current cell\\n             * is bigger than number of blocked cell we can say\\n             * that it\\'s possible to go to the end\\n             */\\n            if ((Math.abs(sr - r) + Math.abs(sc - c)) > LIMIT) return true;\\n\\n            /*\\n             * Perform neighborhood check\\n             */\\n            checkNeighborhood(r, c, visited, rq, cq);\\n        }\\n\\n        // if no solution found\\n        return false;\\n    }\\n    \\n    /*\\n     * Here we check two things\\n     * 1. It\\'s possible to go from source to target\\n     * 2. It\\'s possible to go from target to source\\n     * \\n     * If both true, it\\'s possible to get to target\\n     * position\\n     */\\n    return bfs(source, target) && bfs(target, source);\\n};\\n```",
                "solutionTags": [],
                "code": "```javascript\\n/**\\n * Define row directions [north, south, east, west]\\n * @type {number[]}\\n */\\nconst dr = [-1, +1, 0, 0];\\n\\n/**\\n * Define col directions [north, south, east, west]\\n * @type {number[]}\\n */\\nconst dc = [0, 0, +1, -1];\\n\\n/**\\n * Maximum row index 10^6\\n * @type {number}\\n */\\nconst R = 10 ** 6;\\n\\n/**\\n * Maximum col index 10^6\\n * @type {number}\\n */\\nconst C = 10 ** 6;\\n\\n/**\\n * @param {number[][]} blocked\\n * @param {number[]} source\\n * @param {number[]} target\\n * @return {boolean}\\n */\\nconst isEscapePossible = function (blocked, source, target) {\\n\\n    /**\\n     * Create a hash map of blocked cells\\n     * @type {Record<string, undefined>}\\n     */\\n    const blocks = blocked.reduce((acc, [r, c]) => {\\n        acc[`${r}-${c}`] = undefined;\\n        return acc;\\n    }, {});\\n\\n    /**\\n     * Method explores neighborhood cells and add them\\n     * to bfs queue\\n     *\\n     * @param r         - current row\\n     * @param c         - current cell\\n     * @param visited   - visited map\\n     * @param rq        - row queue\\n     * @param cq        - col queue\\n     */\\n    function checkNeighborhood(r, c, visited, rq, cq) {\\n        /*\\n         * Go through all possible directions\\n         */\\n        for (let side = 0; side < 4; side++) {\\n            const nr = r + dr[side];\\n            const nc = c + dc[side];\\n\\n            /*\\n             * Do not add new cell if it\\'s not valid\\n             */\\n            if (nr < 0 || nr >= R) continue;\\n            if (nc < 0 || nc >= C) continue;\\n\\n            /*\\n             * Create a key for cell in order to store it\\n             * as visited\\n             */\\n            const cell = `${nr}-${nc}`;\\n\\n            /*\\n             * Check if the side is blocked or visited.\\n             */\\n            if (\\n                blocks.hasOwnProperty(cell) ||\\n                visited.hasOwnProperty(cell)\\n            ) continue;\\n\\n            /*\\n             * If the cell is valid, we add its row and col\\n             * to queues\\n             */\\n            rq.push(nr);\\n            cq.push(nc);\\n\\n            /*\\n             * Mark as visited\\n             */\\n            visited[`${nr}-${nc}`] = undefined;\\n        }\\n    }\\n\\n    /*\\n     * We need some heuristic for determining if\\n     * it\\'s possible to go to the end. In this solution\\n     * we use a Manhattan distance. \\n     * \\n     * If manhattan distance from source to current cell\\n     * is bigger than number of blocked cell we can say\\n     * that it\\'s possible to go to the end\\n     *\\n     * https://cs.stanford.edu/people/abisee/gs.pdf\\n     */\\n    const LIMIT = blocked.length;\\n\\n    /**\\n     * Performs BFS for target position from source\\n     * @param sr - start row\\n     * @param sc - start col\\n     * @param tR - target row\\n     * @param tC - target col\\n     * @returns {boolean}\\n     */\\n    function bfs([sr, sc], [tR, tC]) {\\n        /**\\n         * Stores visited cells\\n         * @type {Record<string, undefined>}\\n         */\\n        const visited = {};\\n        \\n        /*\\n         * Queues for storing cells\\n         */\\n        const rq = [];\\n        const cq = [];\\n\\n        /*\\n         * Push start points\\n         */\\n        rq.push(sr);\\n        cq.push(sc);\\n\\n        while (rq.length !== 0) {\\n            const r = rq.shift();\\n            const c = cq.shift();\\n            /*\\n             * If current cell equals to target, we found a solution\\n             */\\n            if (r === tR && c === tC) return true;\\n            \\n            /*\\n             * If manhattan distance from source to current cell\\n             * is bigger than number of blocked cell we can say\\n             * that it\\'s possible to go to the end\\n             */\\n            if ((Math.abs(sr - r) + Math.abs(sc - c)) > LIMIT) return true;\\n\\n            /*\\n             * Perform neighborhood check\\n             */\\n            checkNeighborhood(r, c, visited, rq, cq);\\n        }\\n\\n        // if no solution found\\n        return false;\\n    }\\n    \\n    /*\\n     * Here we check two things\\n     * 1. It\\'s possible to go from source to target\\n     * 2. It\\'s possible to go from target to source\\n     * \\n     * If both true, it\\'s possible to get to target\\n     * position\\n     */\\n    return bfs(source, target) && bfs(target, source);\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 414644,
                "title": "better-bfs-termination-len-queue-len-blocked-len-visited-block",
                "content": "Based on Lee215\\'s inspiration, but with some modifications. Ideas are below:\\n1. we can track the visited blocked, if all blocked are visited and BFS queue is not empty, then it means source is not trapped\\n2. if we have more alive nodes in our BFS queue than the count of non-visited blocks, then source is definitely not trapped.\\n3. using BFS depth as the termination condition is very time-consuming as BFS queue increases very quickly\\n\\n```\\nfrom collections import deque\\nclass Solution(object):\\n    def isEscapePossible(self, blocked, source, target):\\n        \"\"\"\\n        :type blocked: List[List[int]]\\n        :type source: List[int]\\n        :type target: List[int]\\n        :rtype: bool\\n        \"\"\"\\n        blocked = map(tuple, blocked)  # list is not hashable\\n        blocked = set(blocked)  # don\\'t forget !\\n        source = tuple(source)\\n        target = tuple(target)\\n        if not blocked: return True\\n        if target in blocked or source in blocked:\\n            return False\\n        return self.bfs(blocked, source, target) and self.bfs(blocked, target, source)\\n    \\n    def bfs(self, blocked, source, target):\\n        queue = deque([source])\\n        visited = set([source])\\n        seen_block = set()     # the visited blocks\\n        while queue:\\n            for _ in range(len(queue)):\\n                i, j = queue.popleft()\\n                if (i, j) == target:\\n                    return True\\n                for v in ((0, 1), (0,-1), (1,0), (-1,0)):\\n                    p, q = i+v[0], j+v[1]\\n                    if (p, q) in blocked:\\n                        seen_block.add((p, q))\\n                        continue\\n                    if p >= 0 and q >= 0 and (p, q) not in visited:\\n                        queue.append((p, q))\\n                        visited.add((p, q))\\n            if len(queue) > len(blocked) - len(seen_block):   # much faster than BFS_depth > len(blocked)*2\\n                return True\\n        return False\\n    \\n```\\n\\nchanging:\\n       len(queue) > len(blocked) - len(seen_block)\\nto:\\n       len(queue) > (len(blocked) - len(seen_block))*2\\nwill only cost one more BFS step instead of double it",
                "solutionTags": [],
                "code": "```\\nfrom collections import deque\\nclass Solution(object):\\n    def isEscapePossible(self, blocked, source, target):\\n        \"\"\"\\n        :type blocked: List[List[int]]\\n        :type source: List[int]\\n        :type target: List[int]\\n        :rtype: bool\\n        \"\"\"\\n        blocked = map(tuple, blocked)  # list is not hashable\\n        blocked = set(blocked)  # don\\'t forget !\\n        source = tuple(source)\\n        target = tuple(target)\\n        if not blocked: return True\\n        if target in blocked or source in blocked:\\n            return False\\n        return self.bfs(blocked, source, target) and self.bfs(blocked, target, source)\\n    \\n    def bfs(self, blocked, source, target):\\n        queue = deque([source])\\n        visited = set([source])\\n        seen_block = set()     # the visited blocks\\n        while queue:\\n            for _ in range(len(queue)):\\n                i, j = queue.popleft()\\n                if (i, j) == target:\\n                    return True\\n                for v in ((0, 1), (0,-1), (1,0), (-1,0)):\\n                    p, q = i+v[0], j+v[1]\\n                    if (p, q) in blocked:\\n                        seen_block.add((p, q))\\n                        continue\\n                    if p >= 0 and q >= 0 and (p, q) not in visited:\\n                        queue.append((p, q))\\n                        visited.add((p, q))\\n            if len(queue) > len(blocked) - len(seen_block):   # much faster than BFS_depth > len(blocked)*2\\n                return True\\n        return False\\n    \\n```",
                "codeTag": "Java"
            },
            {
                "id": 365529,
                "title": "python-faster-than-96",
                "content": "Follows https://leetcode.com/problems/escape-a-large-maze/discuss/282870/python-solution-with-picture-show-my-thoughts but simpler. The idea is:\\n\\nIf you want to arrange the blocks so that you can\\'t move from source to destination, then you have to put the blocks inside the square defined by center = source and height = len(block).\\n```\\n    def isEscapePossible(self, blocked, source, target):\\n        \"\"\"\\n        :type blocked: List[List[int]]\\n        :type source: List[int]\\n        :type target: List[int]\\n        :rtype: bool\\n        \"\"\"\\n        blocked = set([(x[0], x[1]) for x in blocked])\\n        dir = [(-1, 0), (1, 0), (0, 1), (0, -1)]\\n\\n        def gen_neighbor(x, y):\\n            for dx, dy in dir:\\n                if x + dx < 0 or x + dx > 1e6 or y + dy < 0 or y + dy > 1e6:\\n                    continue\\n                nx, ny = x + dx, y + dy\\n                yield nx, ny\\n\\n        def is_in_box(x, y, center_x, center_y, length):\\n            return center_x - length <= x <= center_x + length and \\\\\\n                center_y - length <= y <= center_y + length\\n\\n\\n        def is_blocked(start_x, start_y, end_x, end_y):\\n            seen = set()\\n            stack = [(start_x, start_y)]\\n            seen.add((start_x, start_y))\\n            while stack:\\n                x, y = stack.pop(-1)\\n                if not is_in_box(x, y, start_x, start_y, len(blocked)) or \\\\\\n                        (x == end_x and y == end_y):\\n                    return True\\n\\n                for nx, ny in gen_neighbor(x, y):\\n                    if (nx, ny) in blocked or (nx, ny) in seen: continue\\n                    seen.add((nx, ny))\\n                    stack.append((nx, ny))\\n            return False\\n\\n        return is_blocked(source[0], source[1], target[0], target[1]) and \\\\\\n               is_blocked(target[0], target[1], source[0], source[1])\\n```",
                "solutionTags": [],
                "code": "```\\n    def isEscapePossible(self, blocked, source, target):\\n        \"\"\"\\n        :type blocked: List[List[int]]\\n        :type source: List[int]\\n        :type target: List[int]\\n        :rtype: bool\\n        \"\"\"\\n        blocked = set([(x[0], x[1]) for x in blocked])\\n        dir = [(-1, 0), (1, 0), (0, 1), (0, -1)]\\n\\n        def gen_neighbor(x, y):\\n            for dx, dy in dir:\\n                if x + dx < 0 or x + dx > 1e6 or y + dy < 0 or y + dy > 1e6:\\n                    continue\\n                nx, ny = x + dx, y + dy\\n                yield nx, ny\\n\\n        def is_in_box(x, y, center_x, center_y, length):\\n            return center_x - length <= x <= center_x + length and \\\\\\n                center_y - length <= y <= center_y + length\\n\\n\\n        def is_blocked(start_x, start_y, end_x, end_y):\\n            seen = set()\\n            stack = [(start_x, start_y)]\\n            seen.add((start_x, start_y))\\n            while stack:\\n                x, y = stack.pop(-1)\\n                if not is_in_box(x, y, start_x, start_y, len(blocked)) or \\\\\\n                        (x == end_x and y == end_y):\\n                    return True\\n\\n                for nx, ny in gen_neighbor(x, y):\\n                    if (nx, ny) in blocked or (nx, ny) in seen: continue\\n                    seen.add((nx, ny))\\n                    stack.append((nx, ny))\\n            return False\\n\\n        return is_blocked(source[0], source[1], target[0], target[1]) and \\\\\\n               is_blocked(target[0], target[1], source[0], source[1])\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 351161,
                "title": "java-dfs-with-code-comments-and-descriptive-naming-14-ms",
                "content": "Here is my most recent DFS submission. It is much fast than my earlier BFS submission. My logic is spelled out in code comments and descriptive variable and method names in the code below. This is the culmination of reading over a few different solutions posted so far in this discussion forum (thank you all). For more details, look at the higher rated/viewed entries in the discussion.\\n\\nThe trick, as many people have pointed out, is to pay attention to the \"sparse\" information: the small number of blocked cells in the grid. In many cases, this logic will only theoretically solve the problem (as in it won\\'t actually find the path from source to target, but simply prove it should exist unblocked).\\n\\nIf interested, I encourage you to write a simple for loop that sums indicies from 0 to the size of the proposed grid ((10e6)^2) and see how far the code gets before TLE (hint: not very far). Then try to sum all indices in just one row and see how long that takes.\\n\\nOnline Judge results copied below:\\nRuntime: 14 ms, faster than 92.53% of Java online submissions....\\nMemory Usage: 44.5 MB, less than 66.36% of Java online submissions....\\n\\n```Java\\nclass Solution {\\n    // A collection of XY offsets to enable easy checking of {N, E, S, W} from current position\\n    private static int[][] rcOffsets = new int[][] { {-1,0}, {0,-1}, {0,1}, {1,0} };\\n\\t// The H and W of the maze\\n    private static int N = 10_000_000;\\n    // Note: 1D index values are out-of-range of the int32 data type.\\n    // Note: summing all the numbers in the grid would take hrs with OLJ.\\n    public boolean isEscapePossible(int[][] blocked, int[] source, int[] target) {\\n        if (blocked.length == 0) {\\n            return true;\\n        }\\n        // Translate blockages into a constant time lookup set (value = 1D grid index).\\n        Set<Long> blockages = new HashSet<>();\\n        for (int[] blockage : blocked) {\\n            blockages.add(getIndex(blockage));\\n        }\\n        // Check if source or target start on a blocked position (just-in-case).\\n        if (blockages.contains(source) || blockages.contains(target)) {\\n            return false;\\n        }\\n        // Check for freedom to move beyond a straight line of the blockages (worst case).\\n        // Do this from both source and target to assert neither is possibly enclosed.\\n        boolean sourceFree = dfsSeed(source, target, blockages);\\n        boolean targetFree = dfsSeed(target, source, blockages);\\n        return (sourceFree && targetFree);\\n    }\\n    // Simple wrapper to help kick-off DFS recursion.\\n    private boolean dfsSeed(int[] source, int[] target, Set<Long> blockages) {\\n        int[] current = source;\\n        Set<Long> marked = new HashSet<>();\\n        return dfs(source, target, current, blockages, marked);\\n    }\\n    // Core DFS recursion method.\\n    private boolean dfs(int[] source, int[] target, int[] current, \\n                       Set<Long> blockages, Set<Long> marked) {\\n        if (isBeyondBlockages(source, current, blockages) || \\n            arrivedAtTarget(current, target)) {\\n            return true;\\n        }\\n\\t\\t// Find {N,E,S,W} positions from current\\n        for (int k = 0; k < 4; k++) {\\n\\t\\t    // New row and column\\n            int nr = current[0] + rcOffsets[k][0];\\n            int nc = current[1] + rcOffsets[k][1];\\n\\t\\t\\t// Check if new position is within the bounds of the grid\\n            if (nr >= 0 && nr < N && nc >= 0 && nc < N) {\\n                int[] nrc = new int[] {nr, nc};\\n                long nInd = getIndex(nrc);\\n\\t\\t\\t\\t// Check if already visited\\n                if (!marked.contains(nInd)) {\\n                    marked.add(nInd);\\n\\t\\t\\t\\t\\t// Check if blocked\\n                    if (!blockages.contains(nInd)) {\\n                        // Extend recursion outward.\\n                        boolean isNowFree = dfs(source, target, nrc, blockages, marked);\\n                        if (isNowFree) {\\n                            return true;\\n                        }\\n                    }\\n                }\\n            }\\n        }\\n        return false;\\n    }\\n    // Converts a 2D coordinate pair in to a unique 1D index.\\n    private static long getIndex(int[] coords) {\\n        return (long)coords[0] * (long)N + (long)coords[1];\\n    }\\n    private boolean isBeyondBlockages(int[] source, int[] current, Set<Long> blockages) {\\n        // DFS is like quickly trying to escape max bounds (1D linear approach).\\n        // - A max blockage would be all of them in a straight line, so bloackages.size().\\n        // - Just check if beyond that.\\n        // BFS is like trying to cover more area than max bounds (2D approach).\\n        // - If all 200 blockages team up to use grid boarder real-estate, \\n        //   then rouhgly 19,900 px can be contained (triangle calculus result).\\n        for (int k = 0; k < 2; k++) {\\n            if (Math.abs(source[k] - current[k]) >= blockages.size()) {\\n                return true;\\n            }\\n        }\\n        return false;\\n    }\\n    private boolean arrivedAtTarget(int[] current, int[] target) {\\n        return (current[0] == target[0] && current[1] == target[1]);\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Depth-First Search"
                ],
                "code": "```Java\\nclass Solution {\\n    // A collection of XY offsets to enable easy checking of {N, E, S, W} from current position\\n    private static int[][] rcOffsets = new int[][] { {-1,0}, {0,-1}, {0,1}, {1,0} };\\n\\t// The H and W of the maze\\n    private static int N = 10_000_000;\\n    // Note: 1D index values are out-of-range of the int32 data type.\\n    // Note: summing all the numbers in the grid would take hrs with OLJ.\\n    public boolean isEscapePossible(int[][] blocked, int[] source, int[] target) {\\n        if (blocked.length == 0) {\\n            return true;\\n        }\\n        // Translate blockages into a constant time lookup set (value = 1D grid index).\\n        Set<Long> blockages = new HashSet<>();\\n        for (int[] blockage : blocked) {\\n            blockages.add(getIndex(blockage));\\n        }\\n        // Check if source or target start on a blocked position (just-in-case).\\n        if (blockages.contains(source) || blockages.contains(target)) {\\n            return false;\\n        }\\n        // Check for freedom to move beyond a straight line of the blockages (worst case).\\n        // Do this from both source and target to assert neither is possibly enclosed.\\n        boolean sourceFree = dfsSeed(source, target, blockages);\\n        boolean targetFree = dfsSeed(target, source, blockages);\\n        return (sourceFree && targetFree);\\n    }\\n    // Simple wrapper to help kick-off DFS recursion.\\n    private boolean dfsSeed(int[] source, int[] target, Set<Long> blockages) {\\n        int[] current = source;\\n        Set<Long> marked = new HashSet<>();\\n        return dfs(source, target, current, blockages, marked);\\n    }\\n    // Core DFS recursion method.\\n    private boolean dfs(int[] source, int[] target, int[] current, \\n                       Set<Long> blockages, Set<Long> marked) {\\n        if (isBeyondBlockages(source, current, blockages) || \\n            arrivedAtTarget(current, target)) {\\n            return true;\\n        }\\n\\t\\t// Find {N,E,S,W} positions from current\\n        for (int k = 0; k < 4; k++) {\\n\\t\\t    // New row and column\\n            int nr = current[0] + rcOffsets[k][0];\\n            int nc = current[1] + rcOffsets[k][1];\\n\\t\\t\\t// Check if new position is within the bounds of the grid\\n            if (nr >= 0 && nr < N && nc >= 0 && nc < N) {\\n                int[] nrc = new int[] {nr, nc};\\n                long nInd = getIndex(nrc);\\n\\t\\t\\t\\t// Check if already visited\\n                if (!marked.contains(nInd)) {\\n                    marked.add(nInd);\\n\\t\\t\\t\\t\\t// Check if blocked\\n                    if (!blockages.contains(nInd)) {\\n                        // Extend recursion outward.\\n                        boolean isNowFree = dfs(source, target, nrc, blockages, marked);\\n                        if (isNowFree) {\\n                            return true;\\n                        }\\n                    }\\n                }\\n            }\\n        }\\n        return false;\\n    }\\n    // Converts a 2D coordinate pair in to a unique 1D index.\\n    private static long getIndex(int[] coords) {\\n        return (long)coords[0] * (long)N + (long)coords[1];\\n    }\\n    private boolean isBeyondBlockages(int[] source, int[] current, Set<Long> blockages) {\\n        // DFS is like quickly trying to escape max bounds (1D linear approach).\\n        // - A max blockage would be all of them in a straight line, so bloackages.size().\\n        // - Just check if beyond that.\\n        // BFS is like trying to cover more area than max bounds (2D approach).\\n        // - If all 200 blockages team up to use grid boarder real-estate, \\n        //   then rouhgly 19,900 px can be contained (triangle calculus result).\\n        for (int k = 0; k < 2; k++) {\\n            if (Math.abs(source[k] - current[k]) >= blockages.size()) {\\n                return true;\\n            }\\n        }\\n        return false;\\n    }\\n    private boolean arrivedAtTarget(int[] current, int[] target) {\\n        return (current[0] == target[0] && current[1] == target[1]);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 301033,
                "title": "golang-concise-solution-using-dfs",
                "content": "```\\nvar MAX_WIDTH=1000000\\ntype cell struct {x,y int}\\n\\nfunc isEscapePossible(deadCells [][]int, source []int, target []int) bool {\\n    if len(deadCells)==0 {return true}\\n    src,dst := cell{x:source[0], y:source[1]}, cell{x:target[0], y:target[1]}\\n    blocked := make(map[cell]bool)\\n    for _,a := range deadCells {blocked[cell{x:a[0], y:a[1]}]=true}\\n    \\n    return dfs(src, dst, make(map[cell]bool), blocked) &&\\n            dfs(dst, src, make(map[cell]bool), blocked)\\n}\\n\\n\\nfunc dfs(src, dst cell, seen map[cell]bool, blocked map[cell]bool) bool {\\n    i,j:=src.x,src.y\\n    if i<0 || i==MAX_WIDTH || j<0 || j==MAX_WIDTH {return false}\\n    _,isBlocked := blocked[src]\\n    _,isSeen := seen[src]\\n    if isBlocked || isSeen {return false}\\n    \\n    // Mark cell as seen\\n    seen[src]=true\\n    \\n    // Reached target or went beyond the 200 cells triangle (0.5x200x200)\\n\\t// Many posts talk about the triangle, so won\\'t repeat here again.\\n    if src==dst || len(seen)>20000 {return true}\\n    \\n    return dfs(cell{x:i+1, y:j}, dst, seen, blocked) ||\\n            dfs(cell{x:i-1, y:j}, dst, seen, blocked) ||\\n            dfs(cell{x:i, y:j+1}, dst, seen, blocked) ||\\n            dfs(cell{x:i, y:j-1}, dst, seen, blocked)\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nvar MAX_WIDTH=1000000\\ntype cell struct {x,y int}\\n\\nfunc isEscapePossible(deadCells [][]int, source []int, target []int) bool {\\n    if len(deadCells)==0 {return true}\\n    src,dst := cell{x:source[0], y:source[1]}, cell{x:target[0], y:target[1]}\\n    blocked := make(map[cell]bool)\\n    for _,a := range deadCells {blocked[cell{x:a[0], y:a[1]}]=true}\\n    \\n    return dfs(src, dst, make(map[cell]bool), blocked) &&\\n            dfs(dst, src, make(map[cell]bool), blocked)\\n}\\n\\n\\nfunc dfs(src, dst cell, seen map[cell]bool, blocked map[cell]bool) bool {\\n    i,j:=src.x,src.y\\n    if i<0 || i==MAX_WIDTH || j<0 || j==MAX_WIDTH {return false}\\n    _,isBlocked := blocked[src]\\n    _,isSeen := seen[src]\\n    if isBlocked || isSeen {return false}\\n    \\n    // Mark cell as seen\\n    seen[src]=true\\n    \\n    // Reached target or went beyond the 200 cells triangle (0.5x200x200)\\n\\t// Many posts talk about the triangle, so won\\'t repeat here again.\\n    if src==dst || len(seen)>20000 {return true}\\n    \\n    return dfs(cell{x:i+1, y:j}, dst, seen, blocked) ||\\n            dfs(cell{x:i-1, y:j}, dst, seen, blocked) ||\\n            dfs(cell{x:i, y:j+1}, dst, seen, blocked) ||\\n            dfs(cell{x:i, y:j-1}, dst, seen, blocked)\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 287344,
                "title": "easy-understand-java-bsf-solution-what-i-learnt",
                "content": "The same idea of checking both source & target sourrounding to see if either of them is in the blocks loop. The code is not short, but easy to understand. \\n\\n**What I learnt?**\\nFirst, fully take the advantages of the given information from the input.\\nInfo we could get in this maze problem:\\n1. source location\\n2. grid size\\n3. blocked squares locations\\n4. target location (unknown in normal maze problems) \\n5. count of blocked squares (hidden, hard to notice)\\n\\nSecond, pick up a base solution at first and try to optimize it. To solve a maze problem, BSF & DSF are good enough. But considering the grid size is pretty large, it is better to find a way to reduce visits. The fifth hidden info, the count of blocked squares, does help reducing the visits.\\n\\n```java\\nimport java.util.HashMap;\\nimport java.util.LinkedList;\\nimport java.util.Queue;\\n\\n/*\\n * @lc app=leetcode id=1036 lang=java\\n *\\n * [1036] Escape a Large Maze\\n */\\nclass Solution {\\n    private static final int BOUNDARY = 1000000;\\n    private int maxSquaresInLoop;\\n    private int moves;\\n    public boolean isEscapePossible(final int[][] blocked, \\n                                    final int[] source, \\n                                    final int[] target) {\\n        // blocked is empty\\n        if (blocked.length == 0) {\\n            return true;\\n        } else {\\n            maxSquaresInLoop = (blocked.length / 2) * (blocked.length / 2);\\n            System.out.println(maxSquaresInLoop);\\n        }\\n        final Map<Integer, Set<Integer>> visited = new HashMap<>();\\n        final Map<Integer, Set<Integer>> blocksMap = converBlocks(blocked);\\n        final Queue<int[]> bsfQueue = new LinkedList<>();\\n        // check source\\n        bsfQueue.add(source);\\n        moves = 0;\\n        while (!bsfQueue.isEmpty() && moves <= maxSquaresInLoop) {\\n            final int[] current = bsfQueue.poll();\\n            final int x = current[0];\\n            final int y = current[1];\\n            if (check(current, target, blocksMap, visited, bsfQueue)) {\\n                return true;\\n            }\\n        }\\n        // source isn\\'t in loop. go on checking target\\n        if (moves > maxSquaresInLoop) {\\n            moves = 0;\\n            bsfQueue.clear();\\n            bsfQueue.add(target);\\n            visited.clear();\\n            while (!bsfQueue.isEmpty() && moves <= maxSquaresInLoop) {\\n                final int[] current = bsfQueue.poll();\\n                final int x = current[0];\\n                final int y = current[1];\\n                if (check(current, source, blocksMap, visited, bsfQueue)) {\\n                    return true;\\n                }\\n            }\\n            // target is also not in loop. escaped\\n            if (moves > maxSquaresInLoop) {\\n                return true;\\n            }\\n        }\\n        return false;\\n    }\\n\\n    private boolean check(final int[] current,\\n                          final int[] target,\\n                          final Map<Integer, Set<Integer>> blocksMap,\\n                          final Map<Integer, Set<Integer>> visited,\\n                          final Queue<int[]> bsfQueue) {\\n        final int x = current[0];\\n        final int y = current[1];\\n        // visited\\n        if (visited.containsKey(x) && visited.get(x).contains(y)) {\\n            return false;\\n        }\\n        // found\\n        if (x == target[0] && y == target[1]) {\\n            return true;\\n        }\\n        // out of boundary\\n        if (x < 0 || x >= BOUNDARY || y < 0 || y >= BOUNDARY) {\\n            return false;\\n        }\\n        // mark visited\\n        if (!visited.containsKey(x)) {\\n            visited.put(x, new HashSet<>());\\n        }\\n        visited.get(x).add(y);\\n        // blocked\\n        if (blocksMap.containsKey(x) && blocksMap.get(x).contains(y)) {\\n            return false;\\n        }\\n        // empty\\n        moves++;\\n        //up\\n        bsfQueue.add(new int[]{x, y - 1});\\n        //right\\n        bsfQueue.add(new int[]{x + 1, y});\\n        //down\\n        bsfQueue.add(new int[]{x, y + 1});\\n        //left\\n        bsfQueue.add(new int[]{x - 1, y});\\n        return false;\\n    }\\n\\n    private Map<Integer, Set<Integer>> converBlocks(final int[][] blocked) {\\n        final Map<Integer, Set<Integer>> blocksMap = new HashMap<>();\\n        for (final int[] point : blocked) {\\n            final int x = point[0];\\n            final int y = point[1];\\n            if (!blocksMap.containsKey(x)) {\\n                blocksMap.put(x, new HashSet<>());\\n            }\\n            blocksMap.get(x).add(y);\\n        }\\n        return blocksMap;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```java\\nimport java.util.HashMap;\\nimport java.util.LinkedList;\\nimport java.util.Queue;\\n\\n/*\\n * @lc app=leetcode id=1036 lang=java\\n *\\n * [1036] Escape a Large Maze\\n */\\nclass Solution {\\n    private static final int BOUNDARY = 1000000;\\n    private int maxSquaresInLoop;\\n    private int moves;\\n    public boolean isEscapePossible(final int[][] blocked, \\n                                    final int[] source, \\n                                    final int[] target) {\\n        // blocked is empty\\n        if (blocked.length == 0) {\\n            return true;\\n        } else {\\n            maxSquaresInLoop = (blocked.length / 2) * (blocked.length / 2);\\n            System.out.println(maxSquaresInLoop);\\n        }\\n        final Map<Integer, Set<Integer>> visited = new HashMap<>();\\n        final Map<Integer, Set<Integer>> blocksMap = converBlocks(blocked);\\n        final Queue<int[]> bsfQueue = new LinkedList<>();\\n        // check source\\n        bsfQueue.add(source);\\n        moves = 0;\\n        while (!bsfQueue.isEmpty() && moves <= maxSquaresInLoop) {\\n            final int[] current = bsfQueue.poll();\\n            final int x = current[0];\\n            final int y = current[1];\\n            if (check(current, target, blocksMap, visited, bsfQueue)) {\\n                return true;\\n            }\\n        }\\n        // source isn\\'t in loop. go on checking target\\n        if (moves > maxSquaresInLoop) {\\n            moves = 0;\\n            bsfQueue.clear();\\n            bsfQueue.add(target);\\n            visited.clear();\\n            while (!bsfQueue.isEmpty() && moves <= maxSquaresInLoop) {\\n                final int[] current = bsfQueue.poll();\\n                final int x = current[0];\\n                final int y = current[1];\\n                if (check(current, source, blocksMap, visited, bsfQueue)) {\\n                    return true;\\n                }\\n            }\\n            // target is also not in loop. escaped\\n            if (moves > maxSquaresInLoop) {\\n                return true;\\n            }\\n        }\\n        return false;\\n    }\\n\\n    private boolean check(final int[] current,\\n                          final int[] target,\\n                          final Map<Integer, Set<Integer>> blocksMap,\\n                          final Map<Integer, Set<Integer>> visited,\\n                          final Queue<int[]> bsfQueue) {\\n        final int x = current[0];\\n        final int y = current[1];\\n        // visited\\n        if (visited.containsKey(x) && visited.get(x).contains(y)) {\\n            return false;\\n        }\\n        // found\\n        if (x == target[0] && y == target[1]) {\\n            return true;\\n        }\\n        // out of boundary\\n        if (x < 0 || x >= BOUNDARY || y < 0 || y >= BOUNDARY) {\\n            return false;\\n        }\\n        // mark visited\\n        if (!visited.containsKey(x)) {\\n            visited.put(x, new HashSet<>());\\n        }\\n        visited.get(x).add(y);\\n        // blocked\\n        if (blocksMap.containsKey(x) && blocksMap.get(x).contains(y)) {\\n            return false;\\n        }\\n        // empty\\n        moves++;\\n        //up\\n        bsfQueue.add(new int[]{x, y - 1});\\n        //right\\n        bsfQueue.add(new int[]{x + 1, y});\\n        //down\\n        bsfQueue.add(new int[]{x, y + 1});\\n        //left\\n        bsfQueue.add(new int[]{x - 1, y});\\n        return false;\\n    }\\n\\n    private Map<Integer, Set<Integer>> converBlocks(final int[][] blocked) {\\n        final Map<Integer, Set<Integer>> blocksMap = new HashMap<>();\\n        for (final int[] point : blocked) {\\n            final int x = point[0];\\n            final int y = point[1];\\n            if (!blocksMap.containsKey(x)) {\\n                blocksMap.put(x, new HashSet<>());\\n            }\\n            blocksMap.get(x).add(y);\\n        }\\n        return blocksMap;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 285599,
                "title": "python-bidirectional-bfs",
                "content": "For this problem, if we conduct two independent search to find out whether either two pointer is blocked or not, we may search many dupicated and unnessary points in the case that two pointer can reach each other. So we can start BFS form both direction simultaneously, one layer frontward and one layer backward, when they are meet, we can return True.\\n\\n```\\nfrom collections import deque\\n\\nclass Solution:\\n    # Bidirectional BFS\\n    def isEscapePossible(self, blocked: List[List[int]], source: List[int], target: List[int]) -> bool:\\n        if len(blocked) < 2:\\n            return True\\n        n = 10 ** 6\\n        block_set = set(map(tuple, blocked))\\n        #initialize two deque\\n        bfs_que_s = deque([tuple(source)])\\n        bfs_que_t = deque([tuple(target)])\\n        # visited sets for the two points\\n        visited_s = set([tuple(source)])\\n        visited_t = set([tuple(target)])\\n        # wave set means the outline of BFS\\n        wave_s = set([tuple(source)])\\n        wave_t = set([tuple(target)])\\n        # bfs into the next layer, if current queue is empty, return False, which means this point is sealed by blocks\\n        def bfs_next(bfs_que, visited, wave):\\n            size = len(bfs_que)\\n            if not size:\\n                return False\\n            wave.clear()\\n            for _ in range(size):\\n                c_r, c_c = bfs_que.popleft()\\n                for dx, dy in [(0, 1), (1, 0), (0, -1), (-1, 0)]:\\n                    n_r = c_r + dx\\n                    n_c = c_c + dy\\n                    if 0 <= n_r < n and 0 <= n_c < n and (n_r, n_c) not in block_set and (n_r, n_c) not in visited:\\n                        bfs_que.append((n_r, n_c))\\n                        visited.add((n_r, n_c))\\n                        wave.add((n_r, n_c))\\n            return True\\n        # mark the points have escaped or not\\n        escape_s = False\\n        escape_t = False\\n        # when waves share some same values, they meeted in the search, return True\\n        while not wave_s & wave_t:\\n            if not escape_s:\\n                if not bfs_next(bfs_que_s, visited_s, wave_s):\\n                    return False\\n                # when wave\\'s length > blocks\\' length, the point must have escaped the blocks\\n                if len(wave_s) > len(blocked):\\n                    escape_s = True\\n\\t\\t\\t\\tif wave_s & wave_t:\\n                    return True\\n            if not escape_t:\\n                if not bfs_next(bfs_que_t, visited_t, wave_t):\\n                    return False\\n                if len(wave_t) > len(blocked):\\n                    escape_t = True\\n            #both of the points are escaped\\n            if escape_s and escape_t:\\n                return True\\n        return True\\n```",
                "solutionTags": [],
                "code": "```\\nfrom collections import deque\\n\\nclass Solution:\\n    # Bidirectional BFS\\n    def isEscapePossible(self, blocked: List[List[int]], source: List[int], target: List[int]) -> bool:\\n        if len(blocked) < 2:\\n            return True\\n        n = 10 ** 6\\n        block_set = set(map(tuple, blocked))\\n        #initialize two deque\\n        bfs_que_s = deque([tuple(source)])\\n        bfs_que_t = deque([tuple(target)])\\n        # visited sets for the two points\\n        visited_s = set([tuple(source)])\\n        visited_t = set([tuple(target)])\\n        # wave set means the outline of BFS\\n        wave_s = set([tuple(source)])\\n        wave_t = set([tuple(target)])\\n        # bfs into the next layer, if current queue is empty, return False, which means this point is sealed by blocks\\n        def bfs_next(bfs_que, visited, wave):\\n            size = len(bfs_que)\\n            if not size:\\n                return False\\n            wave.clear()\\n            for _ in range(size):\\n                c_r, c_c = bfs_que.popleft()\\n                for dx, dy in [(0, 1), (1, 0), (0, -1), (-1, 0)]:\\n                    n_r = c_r + dx\\n                    n_c = c_c + dy\\n                    if 0 <= n_r < n and 0 <= n_c < n and (n_r, n_c) not in block_set and (n_r, n_c) not in visited:\\n                        bfs_que.append((n_r, n_c))\\n                        visited.add((n_r, n_c))\\n                        wave.add((n_r, n_c))\\n            return True\\n        # mark the points have escaped or not\\n        escape_s = False\\n        escape_t = False\\n        # when waves share some same values, they meeted in the search, return True\\n        while not wave_s & wave_t:\\n            if not escape_s:\\n                if not bfs_next(bfs_que_s, visited_s, wave_s):\\n                    return False\\n                # when wave\\'s length > blocks\\' length, the point must have escaped the blocks\\n                if len(wave_s) > len(blocked):\\n                    escape_s = True\\n\\t\\t\\t\\tif wave_s & wave_t:\\n                    return True\\n            if not escape_t:\\n                if not bfs_next(bfs_que_t, visited_t, wave_t):\\n                    return False\\n                if len(wave_t) > len(blocked):\\n                    escape_t = True\\n            #both of the points are escaped\\n            if escape_s and escape_t:\\n                return True\\n        return True\\n```",
                "codeTag": "Java"
            },
            {
                "id": 285282,
                "title": "c-simple-solution-52ms-and-15-3mb",
                "content": "The basic idea here is to determine whether or not a given cell (source or target) is blocked off from the rest of the grid by checking if one of the borders is reachable from that cell. Because there are at most 200 blocks, the maximum length enclosure that can contain source or target is 99. Therefore, by separately centering source and target in a 200x200 subgrid***, if we can reach a border of this subgrid then we know source and target can reach any other unblocked cell in the rest of the main grid. Of course, if source or target is within 100 units of a border on the main grid (0 or 999999) reaching a main grid border does not count as source or target could still be blocked by a pattern of blocks originating and terminating at this main grid border - so we have to reach a border other than a main grid border. Lastly, if both source and target are in the same blocked off enclosure we check for that as well.\\n\\n*** It turns out there is a pesky edge case where the subgrid needs to be expanded to 400x400. This occurs when the source is within range of any of the four corners of the main grid and the blocked cells span the line with endpoints intersecting the x and y axes at y = 199 and x = 199 respectively with the target on the other side of this line.\\n\\nPLEASE NOTE: The runtime distributions for this question are distorted because there were originally only 20 test cases.\\n\\n```\\nclass Solution {\\npublic:\\n    bool isEscapePossible(vector<vector<int>>& blocked, vector<int>& source, vector<int>& target) {\\n        unordered_map<int, unordered_set<int>> blocks;\\n        for (const auto& block : blocked) blocks[block[0]].insert(block[1]);\\n        int sx = source[0], sy = source[1], tx = target[0], ty = target[1];\\n        return isEscapePossible(blocks, sx, sy, tx, ty) && isEscapePossible(blocks, tx, ty, sx, sy);\\n    }\\n    \\n    bool isEscapePossible(unordered_map<int, unordered_set<int>>& blocked, int& sx, int& sy, int tx, int ty)\\n    {\\n        stack<pair<int,int>> s;\\n        s.emplace(sx,sy);\\n        int offset = withinRangeOfCorner(sx, sy) ? 199 : 99;\\n        const int north_border = min(height - 1, sy + offset);\\n        const int east_border = min(width - 1, sx + offset);\\n        const int south_border = max(0, sy - offset);\\n        const int west_border = max(0, sx - offset);\\n        while (!s.empty())\\n        {\\n            int prev_size = s.size();\\n            auto [x,y] = s.top();\\n            if ((x == east_border && east_border < width - 1) || \\n                (x == west_border && west_border > 0) ||\\n                (y == north_border && north_border < height - 1) ||\\n                (y == south_border && south_border > 0) ||\\n                (x == tx && y == ty))\\n            {\\n                if (x == tx && y == ty) { sx = tx; sy = ty; }\\n                return true;\\n            }\\n            for (const auto& dir : directions)\\n            {\\n                int x2 = x + dir[0];\\n                int y2 = y + dir[1];\\n                if (x2 >= 0 && x2 < width && y2 >= 0 && y2 < height && !blocked[x2].count(y2))\\n                {\\n                    s.emplace(x2, y2);\\n                    break;\\n                }\\n            }\\n            if (s.size() == prev_size)\\n            {\\n                s.pop(); // top element fully blocked so pop it off\\n            }\\n            blocked[x].insert(y);\\n        }\\n        return false;\\n    }\\nprivate:\\n    bool withinRangeOfCorner(int x, int y)\\n    {\\n        // y = -x + 199\\n        \\n        // y = x + height - 200\\n        \\n        // y = -x + width - 1 + height - 200\\n        \\n        // y = x - (width - 200)\\n        \\n        bool bottomLeft = y < (-x + 199);\\n        bool bottomRight = y < (x - (width - 200));\\n        bool topLeft = y > (x + height - 200);\\n        bool topRight = y > (-x + width - 1 + height - 200);\\n        \\n        return bottomLeft || bottomRight || topLeft || topRight;\\n    }\\n    \\n    const vector<vector<int>> directions{{-1,0},{0,1},{1,0},{0,-1}};\\n    const int width = 1e6;\\n    const int height = 1e6;\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    bool isEscapePossible(vector<vector<int>>& blocked, vector<int>& source, vector<int>& target) {\\n        unordered_map<int, unordered_set<int>> blocks;\\n        for (const auto& block : blocked) blocks[block[0]].insert(block[1]);\\n        int sx = source[0], sy = source[1], tx = target[0], ty = target[1];\\n        return isEscapePossible(blocks, sx, sy, tx, ty) && isEscapePossible(blocks, tx, ty, sx, sy);\\n    }\\n    \\n    bool isEscapePossible(unordered_map<int, unordered_set<int>>& blocked, int& sx, int& sy, int tx, int ty)\\n    {\\n        stack<pair<int,int>> s;\\n        s.emplace(sx,sy);\\n        int offset = withinRangeOfCorner(sx, sy) ? 199 : 99;\\n        const int north_border = min(height - 1, sy + offset);\\n        const int east_border = min(width - 1, sx + offset);\\n        const int south_border = max(0, sy - offset);\\n        const int west_border = max(0, sx - offset);\\n        while (!s.empty())\\n        {\\n            int prev_size = s.size();\\n            auto [x,y] = s.top();\\n            if ((x == east_border && east_border < width - 1) || \\n                (x == west_border && west_border > 0) ||\\n                (y == north_border && north_border < height - 1) ||\\n                (y == south_border && south_border > 0) ||\\n                (x == tx && y == ty))\\n            {\\n                if (x == tx && y == ty) { sx = tx; sy = ty; }\\n                return true;\\n            }\\n            for (const auto& dir : directions)\\n            {\\n                int x2 = x + dir[0];\\n                int y2 = y + dir[1];\\n                if (x2 >= 0 && x2 < width && y2 >= 0 && y2 < height && !blocked[x2].count(y2))\\n                {\\n                    s.emplace(x2, y2);\\n                    break;\\n                }\\n            }\\n            if (s.size() == prev_size)\\n            {\\n                s.pop(); // top element fully blocked so pop it off\\n            }\\n            blocked[x].insert(y);\\n        }\\n        return false;\\n    }\\nprivate:\\n    bool withinRangeOfCorner(int x, int y)\\n    {\\n        // y = -x + 199\\n        \\n        // y = x + height - 200\\n        \\n        // y = -x + width - 1 + height - 200\\n        \\n        // y = x - (width - 200)\\n        \\n        bool bottomLeft = y < (-x + 199);\\n        bool bottomRight = y < (x - (width - 200));\\n        bool topLeft = y > (x + height - 200);\\n        bool topRight = y > (-x + width - 1 + height - 200);\\n        \\n        return bottomLeft || bottomRight || topLeft || topRight;\\n    }\\n    \\n    const vector<vector<int>> directions{{-1,0},{0,1},{1,0},{0,-1}};\\n    const int width = 1e6;\\n    const int height = 1e6;\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 284560,
                "title": "discretization-union-find",
                "content": "Each point have it\\'s left/right/upper/button edges, use those edges to cut the plain into blocks.\\nMaxinum (202*2)^2 blocks\\nJust need to judge the if source and target block is connected\\n\\n```\\n    int find(vector<int>&u, int i){\\n        if(u[i]!=-1){\\n            u[i]=find(u,u[i]);\\n        }\\n        return u[i]==-1?i:u[i];\\n    }\\n    bool isEscapePossible(vector<vector<int>>& blocked, vector<int>& source, vector<int>& target) {\\n        map<int,int>v,h;v[0]=0;h[0]=0;\\n        v[source[0]]=0;v[source[0]+1]=0;h[source[1]]=0;h[source[1]+1]=0;\\n        v[target[0]]=0;v[target[0]+1]=0;h[target[1]]=0;h[target[1]+1]=0;\\n        for(auto i:blocked){\\n            v[i[0]]=0;v[i[0]+1]=0;\\n            h[i[1]]=0;h[i[1]+1]=0;\\n        }\\n        int cnt=0;\\n        for(auto i=v.begin();i!=v.end();i++,cnt++)i->second=cnt;\\n        cnt=0;\\n        for(auto i=h.begin();i!=h.end();i++,cnt++)i->second=cnt;\\n        vector<vector<int>>grid(v.size(),vector<int>(h.size(),0));\\n        for(auto i:blocked)grid[v[i[0]]][h[i[1]]]=1;\\n        vector<int>u(v.size()*h.size(),-1);\\n        for(int i=0;i<v.size();i++)for(int j=0;j<h.size();j++){\\n            if(grid[i][j])continue;\\n            if(i+1<v.size() && !grid[i+1][j] && find(u,i*h.size()+j)!=find(u,(i+1)*h.size()+j))\\n                u[find(u,i*h.size()+j)]=find(u,(i+1)*h.size()+j);\\n            if(j+1<h.size() && !grid[i][j+1] && find(u,i*h.size()+j)!=find(u,i*h.size()+j+1))\\n                u[find(u,i*h.size()+j)]=find(u,i*h.size()+j+1);\\n        }\\n        return find(u,v[source[0]]*h.size()+h[source[1]])==find(u,v[target[0]]*h.size()+h[target[1]]);\\n    }\\n```",
                "solutionTags": [],
                "code": "```\\n    int find(vector<int>&u, int i){\\n        if(u[i]!=-1){\\n            u[i]=find(u,u[i]);\\n        }\\n        return u[i]==-1?i:u[i];\\n    }\\n    bool isEscapePossible(vector<vector<int>>& blocked, vector<int>& source, vector<int>& target) {\\n        map<int,int>v,h;v[0]=0;h[0]=0;\\n        v[source[0]]=0;v[source[0]+1]=0;h[source[1]]=0;h[source[1]+1]=0;\\n        v[target[0]]=0;v[target[0]+1]=0;h[target[1]]=0;h[target[1]+1]=0;\\n        for(auto i:blocked){\\n            v[i[0]]=0;v[i[0]+1]=0;\\n            h[i[1]]=0;h[i[1]+1]=0;\\n        }\\n        int cnt=0;\\n        for(auto i=v.begin();i!=v.end();i++,cnt++)i->second=cnt;\\n        cnt=0;\\n        for(auto i=h.begin();i!=h.end();i++,cnt++)i->second=cnt;\\n        vector<vector<int>>grid(v.size(),vector<int>(h.size(),0));\\n        for(auto i:blocked)grid[v[i[0]]][h[i[1]]]=1;\\n        vector<int>u(v.size()*h.size(),-1);\\n        for(int i=0;i<v.size();i++)for(int j=0;j<h.size();j++){\\n            if(grid[i][j])continue;\\n            if(i+1<v.size() && !grid[i+1][j] && find(u,i*h.size()+j)!=find(u,(i+1)*h.size()+j))\\n                u[find(u,i*h.size()+j)]=find(u,(i+1)*h.size()+j);\\n            if(j+1<h.size() && !grid[i][j+1] && find(u,i*h.size()+j)!=find(u,i*h.size()+j+1))\\n                u[find(u,i*h.size()+j)]=find(u,i*h.size()+j+1);\\n        }\\n        return find(u,v[source[0]]*h.size()+h[source[1]])==find(u,v[target[0]]*h.size()+h[target[1]]);\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 283505,
                "title": "c-20ms-12-6m-dfs-solution-that-combines-others-ideal",
                "content": "seeing a lot about this question, thank you all for your good idea\\n\\n- ### [lee215\\'s solution](https://leetcode.com/problems/escape-a-large-maze/discuss/282849/Python-Maximum-Blocked-19900-(Video))    \\nfirst i use lee\\'s solution,but find that in my c++ DFS solution, 20000(or 10000) recursive iterations will cause error:stack overflow,\\n\\nthen i try to use BFS solution  which using \\'while loop\\' so that the solution will not cause stack overflow, but a 20000 step also cause  time timit exceeded.\\n\\n- ### [blue1\\'s solution](https://leetcode.com/problems/escape-a-large-maze/discuss/283446/C%2B%2B-solution-2-BFS-using-unordered_set-with-explaination)\\nThen i saw blue1\\'s solution, its a good idea that  if we can moves to a spot which the Mahhatan distance is over 200 to the \\nstarting point we could consider that we escape the blockade\\uFF0Cbelow is the analyzing conditions\\uFF1A\\n> ` if (abs(p.first - src[0]) + abs(p.second - src[1]) > 200) return 1;`\\n\\n\\n\\nso let **bnum** be the number of blocked squares, and we can dynamically  scale down the searching space:\\n> `abs(x-s[0])+abs(y-s[1])>bnum`\\n\\n\\n```cpp\\nclass Solution {\\npublic:\\n    int dir[8]={-1,0,1,0,0,-1,0,1};\\n    set<vector<int> > B;\\n    vector<int> t;\\n    vector<int> s;\\n    int bnum;\\n    bool dfs(int x,int y,int step){\\n        if(B.find(vector<int>({x,y}))==B.end()){\\n                B.insert(vector<int>({x,y}));\\n        }\\n        if(abs(x-s[0])+abs(y-s[1])>bnum||(x==t[0]&&y==t[1])){\\n            return true;\\n        }\\n        for(int i=0;i<4;i++){\\n            int dx = x+dir[i*2];\\n            int dy = y+dir[i*2+1];\\n            if(dx<0||dx>999999||dy<0||dy>999999){\\n                continue;\\n            }\\n            if(B.find(vector<int>({dx,dy}))!=B.end()){\\n                continue;\\n            }\\n            return dfs(dx,dy,step+1);\\n        }\\n        return false;\\n    }\\n    bool isEscapePossible(vector<vector<int>>& blocked, vector<int>& source, vector<int>& target) {\\n        bnum=blocked.size();\\n        if(bnum<=1)   return true;\\n        s=source;\\n        t = target;\\n        for(int i=0;i<blocked.size();i++){\\n            B.insert(blocked[i]);\\n        }\\n        if(dfs(source[0],source[1],0)){\\n            B.clear();\\n            s=target;\\n            t=source;\\n            for(int i=0;i<blocked.size();i++){\\n                B.insert(blocked[i]);\\n            }\\n            if(dfs(target[0],target[1],0))  return true;\\n        }\\n        return false;\\n    }\\n};",
                "solutionTags": [],
                "code": "class Solution {\\npublic:\\n    int dir[8]={-1,0,1,0,0,-1,0,1}",
                "codeTag": "Java"
            },
            {
                "id": 282905,
                "title": "java-bfs-with-limit",
                "content": "BFS from source and target with limit equal to number of blocks. If either stopped before hitting limit it means it\\'s blocked.\\n\\n```\\nclass Solution {\\n    class P {\\n        int x; int y;\\n        P(int[] a) { this(a[0], a[1]); }\\n        P(int x, int y) { this.x = x; this.y = y; }\\n        public boolean equals(Object o) {\\n            if (!(o instanceof P)) return false;\\n            P p = (P) o;\\n            return p.x == x && p.y == y;\\n        }\\n        public int hashCode() { return x * y; }\\n    }\\n    \\n    private static final int[][] dirs = new int[][] {{0,1},{1,0},{0,-1},{-1,0}};\\n\\n    public boolean isEscapePossible(int[][] blocked, int[] source, int[] target) {\\n        if (blocked.length < 2) return true;\\n        Set<P> block = new HashSet<>();\\n        for (int[] b : blocked) block.add(new P(b));\\n        return !blocked(block, source, target) && !blocked(block, target, source);\\n    }\\n    \\n    private boolean blocked(Set<P> block, int[] source, int[] target) {\\n        int limit = block.size();\\n        int curDepth = 0;\\n        Set<P> q = new HashSet<>();\\n        Set<P> visited = new HashSet<>();\\n        q.add(new P(source));\\n        while (curDepth != limit && !q.isEmpty()) {\\n            Set<P> current = q;\\n            q = new HashSet<>();\\n            for (P p : current) {\\n                visited.add(p);\\n                if (p.x == target[0] && p.y == target[1]) return false;\\n                for (int[] d : dirs) {\\n                    P newp = new P(p.x + d[0], p.y + d[1]);\\n                    if (newp.x >= 0 && newp.x < 1_000_000 && newp.y >= 0 && newp.y < 1_000_000\\n                        && !visited.contains(newp) && !block.contains(newp)) {\\n                        q.add(newp);\\n                    }\\n                }\\n            }\\n            curDepth++;\\n        }\\n        return limit != curDepth;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Breadth-First Search"
                ],
                "code": "```\\nclass Solution {\\n    class P {\\n        int x; int y;\\n        P(int[] a) { this(a[0], a[1]); }\\n        P(int x, int y) { this.x = x; this.y = y; }\\n        public boolean equals(Object o) {\\n            if (!(o instanceof P)) return false;\\n            P p = (P) o;\\n            return p.x == x && p.y == y;\\n        }\\n        public int hashCode() { return x * y; }\\n    }\\n    \\n    private static final int[][] dirs = new int[][] {{0,1},{1,0},{0,-1},{-1,0}};\\n\\n    public boolean isEscapePossible(int[][] blocked, int[] source, int[] target) {\\n        if (blocked.length < 2) return true;\\n        Set<P> block = new HashSet<>();\\n        for (int[] b : blocked) block.add(new P(b));\\n        return !blocked(block, source, target) && !blocked(block, target, source);\\n    }\\n    \\n    private boolean blocked(Set<P> block, int[] source, int[] target) {\\n        int limit = block.size();\\n        int curDepth = 0;\\n        Set<P> q = new HashSet<>();\\n        Set<P> visited = new HashSet<>();\\n        q.add(new P(source));\\n        while (curDepth != limit && !q.isEmpty()) {\\n            Set<P> current = q;\\n            q = new HashSet<>();\\n            for (P p : current) {\\n                visited.add(p);\\n                if (p.x == target[0] && p.y == target[1]) return false;\\n                for (int[] d : dirs) {\\n                    P newp = new P(p.x + d[0], p.y + d[1]);\\n                    if (newp.x >= 0 && newp.x < 1_000_000 && newp.y >= 0 && newp.y < 1_000_000\\n                        && !visited.contains(newp) && !block.contains(newp)) {\\n                        q.add(newp);\\n                    }\\n                }\\n            }\\n            curDepth++;\\n        }\\n        return limit != curDepth;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 282853,
                "title": "trick-is-the-0-blocked-length-200",
                "content": "0 <= blocked.length <= 200\\nBFS from the starting point, when you can reach the point that (x1- x0) + (y1 - x0) > 200 then you can escape from the blocking so you can always reach the target",
                "solutionTags": [],
                "code": "0 <= blocked.length <= 200\\nBFS from the starting point, when you can reach the point that (x1- x0) + (y1 - x0) > 200 then you can escape from the blocking so you can always reach the target",
                "codeTag": "Unknown"
            },
            {
                "id": 4069943,
                "title": "easy-bfs",
                "content": "\\n# Code\\n```\\nclass Solution {\\npublic:\\n    bool bfs(set<pair<int, int>>& blockedSet, vector<int>& source, vector<int>& target, int cnt) {\\n        set<pair<int, int>> visited;\\n        int x = source[0];\\n        int y = source[1];\\n        queue<pair<int, int>> q;\\n        int delRow[] = {-1,0,1,0};\\n        int delCol[] = {0,1,0,-1};\\n        int maxArea =  cnt * (cnt-1)/2;\\n        int currArea = 1;\\n        q.push({x, y});\\n        visited.insert({x, y});\\n        while(!q.empty()) {\\n            int row = q.front().first;\\n            int col = q.front().second;\\n            q.pop();\\n            for(int i =0;i<4;i++) {\\n                int nRow = row + delRow[i];\\n                int nCol = col + delCol[i];\\n                if(nRow == target[0] && nCol == target[1]){\\n                    return true;\\n                }\\n                if(currArea > maxArea) return true;\\n                if(nRow >=0 && nRow < 1e6 && nCol >=0 && nCol < 1e6 && blockedSet.find({nRow, nCol}) == blockedSet.end() && visited.find({nRow, nCol}) == visited.end())\\n                { \\n                    currArea++;\\n                    visited.insert({nRow, nCol});\\n                    q.push({nRow, nCol});\\n                }\\n            }\\n        }\\n        return false;\\n    }\\n    bool isEscapePossible(vector<vector<int>>& blocked, vector<int>& source, vector<int>& target) {\\n        int cnt = 0;\\n        set<pair<int, int>> blockedSet;\\n        for(auto it: blocked) {\\n            cnt++;\\n            blockedSet.insert({it[0], it[1]});\\n        }\\n        \\n        return bfs(blockedSet, source, target, cnt) && bfs(blockedSet, target, source, cnt);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool bfs(set<pair<int, int>>& blockedSet, vector<int>& source, vector<int>& target, int cnt) {\\n        set<pair<int, int>> visited;\\n        int x = source[0];\\n        int y = source[1];\\n        queue<pair<int, int>> q;\\n        int delRow[] = {-1,0,1,0};\\n        int delCol[] = {0,1,0,-1};\\n        int maxArea =  cnt * (cnt-1)/2;\\n        int currArea = 1;\\n        q.push({x, y});\\n        visited.insert({x, y});\\n        while(!q.empty()) {\\n            int row = q.front().first;\\n            int col = q.front().second;\\n            q.pop();\\n            for(int i =0;i<4;i++) {\\n                int nRow = row + delRow[i];\\n                int nCol = col + delCol[i];\\n                if(nRow == target[0] && nCol == target[1]){\\n                    return true;\\n                }\\n                if(currArea > maxArea) return true;\\n                if(nRow >=0 && nRow < 1e6 && nCol >=0 && nCol < 1e6 && blockedSet.find({nRow, nCol}) == blockedSet.end() && visited.find({nRow, nCol}) == visited.end())\\n                { \\n                    currArea++;\\n                    visited.insert({nRow, nCol});\\n                    q.push({nRow, nCol});\\n                }\\n            }\\n        }\\n        return false;\\n    }\\n    bool isEscapePossible(vector<vector<int>>& blocked, vector<int>& source, vector<int>& target) {\\n        int cnt = 0;\\n        set<pair<int, int>> blockedSet;\\n        for(auto it: blocked) {\\n            cnt++;\\n            blockedSet.insert({it[0], it[1]});\\n        }\\n        \\n        return bfs(blockedSet, source, target, cnt) && bfs(blockedSet, target, source, cnt);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3876302,
                "title": "easy-and-simple-code",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nLook at constraints of blocked array\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nWe can not traverse by creating 2d array but we can traverse till blocked.size() items\\nstart from source and target and find can you move more than blocked.size() length if you can then it means that blocked items can not cover block your path\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int dx[4]={1,0,-1,0};\\n    int dy[4]={0,-1,0,1};\\n\\n    int dis(int i,int j,int a,int b){\\n        return abs(i-a)+abs(j-b);\\n    }\\n\\n    bool rec(int i,int j,int a,int b,int c,int d, set<pair<int,int>> &st,set<pair<int,int>> &vis,int dist){\\n        if(i==c and j==d) return 1;\\n        if(i<0 || i>=1e6 || j<0 || j>=1e6 || st.find({i,j})!=st.end()) return 0;\\n\\n        if(dis(i,j,a,b)>=dist) return 1;\\n\\n        vis.insert({i,j});\\n        int ans=0;\\n        for(int k=0;k<4;k++){\\n            int x=i+dx[k];\\n            int y=j+dy[k];\\n            if(vis.find({x,y})==vis.end())\\n                ans|=rec(x,y,a,b,c,d,st,vis,dist);\\n        }\\n\\n        return ans;\\n    }\\n\\n    bool isEscapePossible(vector<vector<int>>& blocked, vector<int>& source, vector<int>& target) {\\n        set<pair<int,int>>mp,vis;\\n        for(auto i: blocked)\\n            mp.insert(make_pair(i[0],i[1]));\\n\\n        int ans=1;\\n        ans &= rec(source[0],source[1],source[0],source[1],target[0],target[1],mp,vis,blocked.size());\\n        vis.clear();\\n        // cout<<\"ans= \"<<ans<<endl;\\n        ans &= rec(target[0],target[1],target[0],target[1],source[0],source[1],mp,vis,blocked.size());\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int dx[4]={1,0,-1,0};\\n    int dy[4]={0,-1,0,1};\\n\\n    int dis(int i,int j,int a,int b){\\n        return abs(i-a)+abs(j-b);\\n    }\\n\\n    bool rec(int i,int j,int a,int b,int c,int d, set<pair<int,int>> &st,set<pair<int,int>> &vis,int dist){\\n        if(i==c and j==d) return 1;\\n        if(i<0 || i>=1e6 || j<0 || j>=1e6 || st.find({i,j})!=st.end()) return 0;\\n\\n        if(dis(i,j,a,b)>=dist) return 1;\\n\\n        vis.insert({i,j});\\n        int ans=0;\\n        for(int k=0;k<4;k++){\\n            int x=i+dx[k];\\n            int y=j+dy[k];\\n            if(vis.find({x,y})==vis.end())\\n                ans|=rec(x,y,a,b,c,d,st,vis,dist);\\n        }\\n\\n        return ans;\\n    }\\n\\n    bool isEscapePossible(vector<vector<int>>& blocked, vector<int>& source, vector<int>& target) {\\n        set<pair<int,int>>mp,vis;\\n        for(auto i: blocked)\\n            mp.insert(make_pair(i[0],i[1]));\\n\\n        int ans=1;\\n        ans &= rec(source[0],source[1],source[0],source[1],target[0],target[1],mp,vis,blocked.size());\\n        vis.clear();\\n        // cout<<\"ans= \"<<ans<<endl;\\n        ans &= rec(target[0],target[1],target[0],target[1],source[0],source[1],mp,vis,blocked.size());\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 3686541,
                "title": "simplest-bfs-with-simple-explanation-c",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nNormal BFS/DFS wouldn\\'t work here since grid size is million x million. So we need to think of some observation.\\n\\nWhen can answer becomes False? \\nWhen either Source or Target is trapped.\\n\\n\\'Blocked list\\' size = 200 indicates at max we can have 200 blocks that means in worst case we will having a boundary trap at 200 distance from Source. \\n\\nSo we can just run a BFS/DFS till distance 200 and if any node can cross this much distance that means there are no more blocks and we can surely reach to target.\\n\\nBut wait what if Target is trapped?\\nJust run the same BFS/DFS from Target to Source now.\\n\\n\\n\\n\\n# Complexity\\n- Time complexity: O(blockSize * blockSize)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n- O(blockSize * blockSize)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n\\n    int dx[4] = {0,0,-1,1};\\n    int dy[4] = {1,-1,0,0};\\n\\n    bool valid(int x, int y){\\n        return x >= 0 and y >= 0 and x < 1000000 and y < 1000000;\\n    }\\n\\n    bool bfs(vector<vector<int>>& blocked, vector<int>& source, vector<int>& target){\\n        queue<vector<int>> q;\\n        q.push(source);\\n\\n        set<vector<int>> seen;\\n        seen.insert(source);\\n\\n        for(auto v: blocked) seen.insert(v);\\n\\n        int distCovered = 0;\\n        while(!q.empty()){\\n            int siz = q.size();\\n            while(siz--){\\n                int x = q.front()[0], y = q.front()[1];\\n                q.pop();\\n\\n                if(x == target[0] and y == target[1] or distCovered > blocked.size()) {\\n                    return true;\\n                }\\n\\n                for(int k=0;k<4;k++){\\n                    int nx = x + dx[k], ny = y + dy[k];\\n                    vector<int> temp = {nx, ny};\\n                    if(valid(nx, ny) and seen.find(temp) == seen.end()){\\n                        q.push(temp);\\n                        seen.insert(temp);\\n                    }\\n                }\\n            }\\n            distCovered++;\\n        }\\n\\n        return false;\\n    }\\n\\n    bool isEscapePossible(vector<vector<int>>& blocked, vector<int>& source, vector<int>& target) {\\n        return bfs(blocked, source, target) and bfs(blocked, target, source);\\n    }\\n\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Breadth-First Search",
                    "Graph"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n\\n    int dx[4] = {0,0,-1,1};\\n    int dy[4] = {1,-1,0,0};\\n\\n    bool valid(int x, int y){\\n        return x >= 0 and y >= 0 and x < 1000000 and y < 1000000;\\n    }\\n\\n    bool bfs(vector<vector<int>>& blocked, vector<int>& source, vector<int>& target){\\n        queue<vector<int>> q;\\n        q.push(source);\\n\\n        set<vector<int>> seen;\\n        seen.insert(source);\\n\\n        for(auto v: blocked) seen.insert(v);\\n\\n        int distCovered = 0;\\n        while(!q.empty()){\\n            int siz = q.size();\\n            while(siz--){\\n                int x = q.front()[0], y = q.front()[1];\\n                q.pop();\\n\\n                if(x == target[0] and y == target[1] or distCovered > blocked.size()) {\\n                    return true;\\n                }\\n\\n                for(int k=0;k<4;k++){\\n                    int nx = x + dx[k], ny = y + dy[k];\\n                    vector<int> temp = {nx, ny};\\n                    if(valid(nx, ny) and seen.find(temp) == seen.end()){\\n                        q.push(temp);\\n                        seen.insert(temp);\\n                    }\\n                }\\n            }\\n            distCovered++;\\n        }\\n\\n        return false;\\n    }\\n\\n    bool isEscapePossible(vector<vector<int>>& blocked, vector<int>& source, vector<int>& target) {\\n        return bfs(blocked, source, target) and bfs(blocked, target, source);\\n    }\\n\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3668636,
                "title": "escape-a-large-maze",
                "content": "# Intuition\\n\\uAC04\\uB2E8\\uD55C \\uBB38\\uC81C\\uC5D0 \\uBC94\\uC704\\uAC00 10e6 * 10e6 \\uB77C\\uC11C \\uBD84\\uBA85 block \\uACFC \\uAD00\\uB828\\uB41C \\uD480\\uC774\\uAC00 \\uC788\\uC744 \\uAC83 \\uAC19\\uB2E4\\uACE0 \\uC0DD\\uAC01\\uD588\\uB2E4.\\n\\n# Approach\\nblock \\uC758 \\uCD5C\\uB300 \\uAC2F\\uC218\\uB294 200\\uAC1C. 10e6 * 10e6 \\uACF5\\uAC04\\uC744 \\uCDA9\\uBD84\\uD788 \\uB9C9\\uAE30\\uC5D4 \\uBD80\\uC871\\uD55C \\uAC2F\\uC218\\uB2E4. 200\\uAC1C\\uC758 \\uBE14\\uB85D\\uC73C\\uB85C \\uB124 \\uBCC0\\uC744 \\uAD6C\\uC131\\uD55C\\uB2E4\\uBA74 50 * 50 = 2500, \\uB450 \\uBAA8\\uC11C\\uB9AC\\uB97C \\uC774\\uC6A9\\uD574 \\uB450 \\uBCC0\\uC744 \\uAD6C\\uC131\\uD55C\\uB2E4\\uBA74 100 * 100 = 10000 \\uB9CC\\uD07C\\uC758 \\uB113\\uC774\\uC758 \\uACF5\\uAC04\\uC744 Block \\uD560 \\uC218 \\uC788\\uB2E4. \\uC989, \\uC2DC\\uC791\\uC810\\uACFC \\uB3C4\\uCC29\\uC810 \\uAC01\\uAC01\\uC5D0\\uC11C\\uBD80\\uD130 BFS \\uB97C \\uC9C4\\uD589\\uD574\\uC11C \\uB113\\uC774\\uAC00 10000 \\uBCF4\\uB2E4 \\uCEE4\\uC9C0\\uBA74, \\uC774\\uBBF8 \\uC8FC\\uC5B4\\uC9C4 block \\uC73C\\uB85C\\uB294 \\uB9C9\\uC744 \\uC218 \\uC5C6\\uB2E4\\uB294 \\uB73B\\uC774\\uB2E4. \\uCF54\\uB4DC\\uC5D0\\uC120 \\uBD88\\uC548\\uD558\\uB2C8 10000\\uBCF4\\uB2E4 \\uB354 \\uD070 \\uAC12\\uC744 \\uB9AC\\uBBF8\\uD2B8\\uB85C \\uC8FC\\uC5C8\\uB2E4.\\n\\uBB38\\uC81C\\uB294 BFS\\uB97C \\uD560 \\uB54C \\uBC29\\uBB38\\uD55C \\uC704\\uCE58 \\uCCB4\\uD06C visited\\uC640 block\\uC758 \\uC704\\uCE58 \\uCCB4\\uD06C \\uC600\\uB294\\uB370, \\uC774\\uB97C HashMap\\uACFC List \\uB97C \\uC774\\uC6A9\\uD574 \\uAD6C\\uD604\\uD588\\uB2E4. $$O(nlogn)$$\\uC758 \\uC2DC\\uAC04\\uBCF5\\uC7A1\\uB3C4\\uB97C \\uAC00\\uC9C0\\uAE30\\uC5D0 \\uCDA9\\uBD84\\uD558\\uB2E4\\uACE0 \\uC0DD\\uAC01\\uD588\\uB2E4.\\n\\n\\n# Complexity\\n- Time complexity:\\nBlock \\uC704\\uCE58 \\uCCB4\\uD06C: $$O(nlogn)$$\\nVisited \\uC704\\uCE58 \\uCCB4\\uD06C: $$O(nlogn)$$\\nBFS: \\uCD5C\\uB300 20000\\uAC1C\\uC758 \\uC810 * 4 \\uBC29\\uD5A5\\n\\n\\uB9CE\\uC774 \\uB290\\uB9B0 \\uD3B8\\uC778\\uAC70 \\uAC19\\uB2E4.\\n\\n# Code\\n```\\nclass Solution {\\n    private HashMap<Integer, List<Integer>> blockMap = new HashMap<>();\\n    private HashMap<Integer, List<Integer>> visited = new HashMap<>();\\n\\n    private int[] dx = {-1, 0, 1, 0};\\n    private int[] dy = {0, -1, 0, 1}; \\n    public boolean isEscapePossible(int[][] blocked, int[] source, int[] target) {\\n        for(int[] b : blocked) {\\n            if(!blockMap.containsKey(b[0])) blockMap.put(b[0], new ArrayList<Integer>());\\n            blockMap.get(b[0]).add(b[1]);\\n        }\\n\\n        Queue<Integer> xq = new LinkedList<>();\\n        Queue<Integer> yq = new LinkedList<>();\\n        xq.add(source[0]);\\n        yq.add(source[1]);\\n\\n        int area = 0;\\n        while(!xq.isEmpty()) {\\n            int x = xq.poll();\\n            int y = yq.poll();\\n\\n            if(x == target[0] && y == target[1]) return true;\\n\\n            area++;\\n            if(area > 20000) break;\\n\\n            for(int d=0; d<4; d++) {\\n                int nx = x + dx[d];\\n                int ny = y + dy[d];\\n                boolean isValid = nx >= 0 && nx < 1000000 && ny >= 0 && ny < 1000000;\\n                if(isValid && !isBlocked(nx, ny) && !isVisited(nx, ny)) {\\n                    xq.add(nx);\\n                    yq.add(ny);\\n                    \\n                    if(!visited.containsKey(nx)) visited.put(nx, new LinkedList<Integer>());\\n                    visited.get(nx).add(ny);\\n                }\\n            }\\n        }\\n\\n        if(area < 20000) return false;\\n        area = 0;\\n        visited = new HashMap<>();\\n        xq = new LinkedList<>();\\n        yq = new LinkedList<>();\\n        xq.add(target[0]);\\n        yq.add(target[1]);\\n\\n        while(!xq.isEmpty()) {\\n            int x = xq.poll();\\n            int y = yq.poll();\\n\\n            if(x == source[0] && y == source[1]) return true;\\n\\n            area++;\\n            if(area > 20000) break;\\n\\n            for(int d=0; d<4; d++) {\\n                int nx = x + dx[d];\\n                int ny = y + dy[d];\\n                boolean isValid = nx >= 0 && nx < 1000000 && ny >= 0 && ny < 1000000;\\n                if(isValid && !isBlocked(nx, ny) && !isVisited(nx, ny)) {\\n                    xq.add(nx);\\n                    yq.add(ny);\\n                    \\n                    if(!visited.containsKey(nx)) visited.put(nx, new LinkedList<Integer>());\\n                    visited.get(nx).add(ny);\\n                }\\n            }\\n        }\\n\\n        if(area < 20000) return false;\\n\\n        return true;\\n    }\\n\\n    private boolean isBlocked(int x, int y) {\\n        return blockMap.containsKey(x) && blockMap.get(x).contains(y);\\n    }\\n\\n    private boolean isVisited(int x, int y) {\\n        return visited.containsKey(x) && visited.get(x).contains(y);\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    private HashMap<Integer, List<Integer>> blockMap = new HashMap<>();\\n    private HashMap<Integer, List<Integer>> visited = new HashMap<>();\\n\\n    private int[] dx = {-1, 0, 1, 0};\\n    private int[] dy = {0, -1, 0, 1}; \\n    public boolean isEscapePossible(int[][] blocked, int[] source, int[] target) {\\n        for(int[] b : blocked) {\\n            if(!blockMap.containsKey(b[0])) blockMap.put(b[0], new ArrayList<Integer>());\\n            blockMap.get(b[0]).add(b[1]);\\n        }\\n\\n        Queue<Integer> xq = new LinkedList<>();\\n        Queue<Integer> yq = new LinkedList<>();\\n        xq.add(source[0]);\\n        yq.add(source[1]);\\n\\n        int area = 0;\\n        while(!xq.isEmpty()) {\\n            int x = xq.poll();\\n            int y = yq.poll();\\n\\n            if(x == target[0] && y == target[1]) return true;\\n\\n            area++;\\n            if(area > 20000) break;\\n\\n            for(int d=0; d<4; d++) {\\n                int nx = x + dx[d];\\n                int ny = y + dy[d];\\n                boolean isValid = nx >= 0 && nx < 1000000 && ny >= 0 && ny < 1000000;\\n                if(isValid && !isBlocked(nx, ny) && !isVisited(nx, ny)) {\\n                    xq.add(nx);\\n                    yq.add(ny);\\n                    \\n                    if(!visited.containsKey(nx)) visited.put(nx, new LinkedList<Integer>());\\n                    visited.get(nx).add(ny);\\n                }\\n            }\\n        }\\n\\n        if(area < 20000) return false;\\n        area = 0;\\n        visited = new HashMap<>();\\n        xq = new LinkedList<>();\\n        yq = new LinkedList<>();\\n        xq.add(target[0]);\\n        yq.add(target[1]);\\n\\n        while(!xq.isEmpty()) {\\n            int x = xq.poll();\\n            int y = yq.poll();\\n\\n            if(x == source[0] && y == source[1]) return true;\\n\\n            area++;\\n            if(area > 20000) break;\\n\\n            for(int d=0; d<4; d++) {\\n                int nx = x + dx[d];\\n                int ny = y + dy[d];\\n                boolean isValid = nx >= 0 && nx < 1000000 && ny >= 0 && ny < 1000000;\\n                if(isValid && !isBlocked(nx, ny) && !isVisited(nx, ny)) {\\n                    xq.add(nx);\\n                    yq.add(ny);\\n                    \\n                    if(!visited.containsKey(nx)) visited.put(nx, new LinkedList<Integer>());\\n                    visited.get(nx).add(ny);\\n                }\\n            }\\n        }\\n\\n        if(area < 20000) return false;\\n\\n        return true;\\n    }\\n\\n    private boolean isBlocked(int x, int y) {\\n        return blockMap.containsKey(x) && blockMap.get(x).contains(y);\\n    }\\n\\n    private boolean isVisited(int x, int y) {\\n        return visited.containsKey(x) && visited.get(x).contains(y);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3621084,
                "title": "python-o-n-easy-explanation",
                "content": "Since maximum length of square is 200, we just check if we can visit that far without being blocked.\\n\\n# Code\\n```\\nclass Solution:\\n    def isEscapePossible(self, blocked: List[List[int]], source: List[int], target: List[int]) -> bool:\\n        dx = [0,0,-1,1]\\n        dy =  [1,-1,0,0]\\n        MAX = 200\\n        N = 10**6 \\n        # Three cases to block \\n        # either make sq around target or source, solution- since limit on size of blocks max side of rec that can be blocked is MAX\\n        # or parition gird into two such that soruce and target seprate, solution just check if we can reach target before max \\n        def dfs(sy,sx,ty,tx,y,x,vis):\\n            if abs(y-sy)>MAX or abs(x-sx)>MAX or (x==tx and y==ty): \\n                # print(y,x)\\n                return True\\n            vis.add((y,x))\\n            for k in range(4):\\n                i,j = y+dy[k],x+dx[k]\\n                if i>=0 and j>=0 and i<N and j<N and (i,j) not in vis:\\n                    if dfs(sy,sx,ty,tx,i,j,vis): return True\\n            return False\\n        res = []\\n        r = [source,target]\\n        for i,(x,y) in enumerate(r):\\n            vis = set(map(lambda x:(x[1],x[0]) , blocked))\\n            res.append(dfs(y,x,r[i^1][1],r[i^1][0],y,x,vis))\\n        return all(res)\\n\\n\\n\\n            \\n\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def isEscapePossible(self, blocked: List[List[int]], source: List[int], target: List[int]) -> bool:\\n        dx = [0,0,-1,1]\\n        dy =  [1,-1,0,0]\\n        MAX = 200\\n        N = 10**6 \\n        # Three cases to block \\n        # either make sq around target or source, solution- since limit on size of blocks max side of rec that can be blocked is MAX\\n        # or parition gird into two such that soruce and target seprate, solution just check if we can reach target before max \\n        def dfs(sy,sx,ty,tx,y,x,vis):\\n            if abs(y-sy)>MAX or abs(x-sx)>MAX or (x==tx and y==ty): \\n                # print(y,x)\\n                return True\\n            vis.add((y,x))\\n            for k in range(4):\\n                i,j = y+dy[k],x+dx[k]\\n                if i>=0 and j>=0 and i<N and j<N and (i,j) not in vis:\\n                    if dfs(sy,sx,ty,tx,i,j,vis): return True\\n            return False\\n        res = []\\n        r = [source,target]\\n        for i,(x,y) in enumerate(r):\\n            vis = set(map(lambda x:(x[1],x[0]) , blocked))\\n            res.append(dfs(y,x,r[i^1][1],r[i^1][0],y,x,vis))\\n        return all(res)\\n\\n\\n\\n            \\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3567855,
                "title": "very-easy-to-understand-c-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n#include <queue>\\n#include <vector>\\n#include <unordered_map>\\nusing namespace std;\\n\\nclass Solution {\\n    \\n    inline static const int TOTAL_ROWS = pow(10, 6);\\n    inline static const int TOTAL_COLUMNS = TOTAL_ROWS;\\n    inline static const array<array<int, 2>, 4> MOVES{ {{1, 0}, {-1, 0}, {0, 1}, {0, -1}} };\\n\\n    struct Point {\\n        int row{};\\n        int column{};\\n        Point(int row, int column) : row{row}, column{column}{}\\n    };\\n\\npublic:\\n    bool isEscapePossible(const vector<vector<int>>& blocked, const vector<int>& source, const vector<int>& target) const {\\n        unordered_set<int> setBlocked{ initializeSetBlockedPoints(blocked, source, target) };\\n        return breadthFirstSearch(setBlocked, source, target) && breadthFirstSearch(setBlocked, target, source);\\n    }\\n\\nprivate:\\n    bool breadthFirstSearch(const unordered_set<int>& setBlocked, const vector<int>& source, const vector<int>& target) const {\\n        unordered_set<int> setVisited;\\n        setVisited.insert(hashPoint(source[0], source[1]));\\n        queue<Point> queue;\\n        queue.emplace(Point(source[0], source[1]));\\n        int numberOfMoves = 0;\\n\\n        while (!queue.empty()) {\\n\\n            ++numberOfMoves;\\n            for (int i = queue.size(); i > 0; --i) {\\n\\n                Point current = queue.front();\\n                queue.pop();\\n                if (numberOfMoves > setBlocked.size() || (current.row == target[0] && current.column == target[1])) {\\n                    return true;\\n                }\\n\\n                for (const auto& move : MOVES) {\\n                    int nextRow = current.row + move[0];\\n                    int nextColumn = current.column + move[1];\\n\\n                    //C++20: setVisited.contains(...), setBlocked.contains(...), done the old way for compatibility.\\n                    if (isInMatrix(nextRow, nextColumn) && setVisited.find(hashPoint(nextRow, nextColumn)) == setVisited.end()\\n                        && setBlocked.find(hashPoint(nextRow, nextColumn)) == setBlocked.end()) {\\n                        queue.emplace(Point(nextRow, nextColumn));\\n                        setVisited.insert(hashPoint(nextRow, nextColumn));\\n                    }\\n                }\\n            }\\n        }\\n        return false;\\n    }\\n\\n    unordered_set<int> initializeSetBlockedPoints(const vector<vector<int>>& blocked, const vector<int>& source, const vector<int>& target) const {\\n        unordered_set<int> setBlocked;\\n        for (const auto& blockedPoint : blocked) {\\n            if (distance(blockedPoint, source) <= blocked.size() || distance(blockedPoint, target) <= blocked.size()) {\\n                setBlocked.insert(hashPoint(blockedPoint[0], blockedPoint[1]));\\n            }\\n        }\\n        return setBlocked;\\n    }\\n\\n    bool isInMatrix(int row, int column) const {\\n        return row >= 0 && row < TOTAL_ROWS && column >= 0 && column < TOTAL_COLUMNS;\\n    }\\n\\n    int hashPoint(int row, int column) const {\\n        return 991 * row + column;\\n    }\\n\\n    int distance(const vector<int>& firstPoint, const vector<int>& secondPoint) const {\\n        return abs(firstPoint[0] - secondPoint[0]) + abs(firstPoint[1] - secondPoint[1]);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\n#include <queue>\\n#include <vector>\\n#include <unordered_map>\\nusing namespace std;\\n\\nclass Solution {\\n    \\n    inline static const int TOTAL_ROWS = pow(10, 6);\\n    inline static const int TOTAL_COLUMNS = TOTAL_ROWS;\\n    inline static const array<array<int, 2>, 4> MOVES{ {{1, 0}, {-1, 0}, {0, 1}, {0, -1}} };\\n\\n    struct Point {\\n        int row{};\\n        int column{};\\n        Point(int row, int column) : row{row}, column{column}{}\\n    };\\n\\npublic:\\n    bool isEscapePossible(const vector<vector<int>>& blocked, const vector<int>& source, const vector<int>& target) const {\\n        unordered_set<int> setBlocked{ initializeSetBlockedPoints(blocked, source, target) };\\n        return breadthFirstSearch(setBlocked, source, target) && breadthFirstSearch(setBlocked, target, source);\\n    }\\n\\nprivate:\\n    bool breadthFirstSearch(const unordered_set<int>& setBlocked, const vector<int>& source, const vector<int>& target) const {\\n        unordered_set<int> setVisited;\\n        setVisited.insert(hashPoint(source[0], source[1]));\\n        queue<Point> queue;\\n        queue.emplace(Point(source[0], source[1]));\\n        int numberOfMoves = 0;\\n\\n        while (!queue.empty()) {\\n\\n            ++numberOfMoves;\\n            for (int i = queue.size(); i > 0; --i) {\\n\\n                Point current = queue.front();\\n                queue.pop();\\n                if (numberOfMoves > setBlocked.size() || (current.row == target[0] && current.column == target[1])) {\\n                    return true;\\n                }\\n\\n                for (const auto& move : MOVES) {\\n                    int nextRow = current.row + move[0];\\n                    int nextColumn = current.column + move[1];\\n\\n                    //C++20: setVisited.contains(...), setBlocked.contains(...), done the old way for compatibility.\\n                    if (isInMatrix(nextRow, nextColumn) && setVisited.find(hashPoint(nextRow, nextColumn)) == setVisited.end()\\n                        && setBlocked.find(hashPoint(nextRow, nextColumn)) == setBlocked.end()) {\\n                        queue.emplace(Point(nextRow, nextColumn));\\n                        setVisited.insert(hashPoint(nextRow, nextColumn));\\n                    }\\n                }\\n            }\\n        }\\n        return false;\\n    }\\n\\n    unordered_set<int> initializeSetBlockedPoints(const vector<vector<int>>& blocked, const vector<int>& source, const vector<int>& target) const {\\n        unordered_set<int> setBlocked;\\n        for (const auto& blockedPoint : blocked) {\\n            if (distance(blockedPoint, source) <= blocked.size() || distance(blockedPoint, target) <= blocked.size()) {\\n                setBlocked.insert(hashPoint(blockedPoint[0], blockedPoint[1]));\\n            }\\n        }\\n        return setBlocked;\\n    }\\n\\n    bool isInMatrix(int row, int column) const {\\n        return row >= 0 && row < TOTAL_ROWS && column >= 0 && column < TOTAL_COLUMNS;\\n    }\\n\\n    int hashPoint(int row, int column) const {\\n        return 991 * row + column;\\n    }\\n\\n    int distance(const vector<int>& firstPoint, const vector<int>& secondPoint) const {\\n        return abs(firstPoint[0] - secondPoint[0]) + abs(firstPoint[1] - secondPoint[1]);\\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 3562740,
                "title": "optimized-dfs-approach-escape-distance-o-b-2-t-and-s-commented-and-explained",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nThe two ways to phrase the question are if a route is blocked or if a route is open. We can check this with one function using alternate styles of return, which is a focus in this implementation for those still learning that style of return. This allows for generator style functionality in returns, speeding up submissions on leetcode and elsewhere. \\n\\nTo approach the problem, we know that the length of our blocked array is relative to the manhattan distance of an open route between source and some point (if we escape the blocked neighborhood, we can get anywhere). \\n\\nWith this in mind, we start by first getting the non-unique size of our blocked list, then converting our blocked list to a set of tuples for the points in the list. After that, the approach is carried out to solve the problem. \\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nFor any possible route between two points we cacn consider it to either be blocked or open, which we use a flip flag defaulted to True to consider which case we are working on at the time. We will be considering two points and are given a blocked listing within the maxe to use at the start of it. Our progression then is \\n\\n- set up a stack using the first point passed as a list\\n- set up a visited set using a tuple of first point \\n- add the first point passed to blocked points \\n- while you have stack \\n    - pop off a point \\n    - if manhattan distance between this point and p1 is gte our escape distance or this point is our target \\n        - return False if doing is_blocked else True \\n    - otherwise, get neighbors in N4 of this point \\n    - for neighbor in N4 \\n        - if valid point and not in blocked or visited\\n            - add to stack, blocked, and visited \\n- return True if flip else False \\n\\nTo set up our algorithm, return False if blocked from source to Target, otherwise return whether or not the path is open from target to source \\n\\n# Complexity\\n- Time complexity : O(B^2) \\n    - We loop over blocked for as much as 200 points \\n    - We carry out a dfs for at most 40000 unique points (visited and blocked contribute to this, ensuring minimal stack space as well) \\n    - We do dfs at most 2 times for up to 40000 points, which is our blocked distance squared (the number of points within escape distance)\\n    - So, we run in O(B^2) to process the stack space \\n\\n- Space complexity : O(B^2) \\n    - Due to stack space considerations, we at most use up to O(B^2) in the stack inside is blocked\\n    - We save on space by requiring only unique points via visited with no repeats   \\n\\n\\n# Code\\n```\\nclass Solution:\\n    def isEscapePossible(self, blocked: List[List[int]], source: List[int], target: List[int]) -> bool:\\n        # get escape distance \\n        self.escape_distance = len(blocked)\\n        # set up blocked as set of tuples \\n        blocked = {tuple(point) for point in blocked}\\n\\n        # set up is_blocked function passing two points, blocked, and which type of check\\n        def is_blocked(p1, p2, blocked, flip=True) :\\n            # set up initial stack \\n            stack = [p1]\\n            # set up visited \\n            visited = set()\\n            visited.add(tuple(p1))\\n            # add p1 to blocked \\n            blocked.add(tuple(p1))\\n            # while you have a stack \\n            while stack :\\n                # pop one off the top \\n                x, y = stack.pop()\\n                # check mhd. If at or above escape distance, or if this is the target, return False, not blocked\\n                if (abs(p1[0]-x) + abs(p1[1]-y) >= self.escape_distance) or (x == p2[0] and y == p2[1]) :\\n                    return False if flip else True\\n                # get 4 directional neighbors \\n                N4 = [(x+1, y), (x-1, y), (x, y+1), (x, y-1)]\\n                # loop over each \\n                for N_i in N4 :\\n                    # if valid point and not blocked -> append to consider it and add to blocked\\n                    if ((0 <= N_i[0] < 1e6) and (0 <= N_i[1] < 1e6)) and ((N_i not in blocked) and (N_i not in visited)) :\\n                        stack.append(N_i)\\n                        blocked.add(N_i)\\n                        visited.add(N_i)\\n            # return True if never escape distance or reached target \\n            return True if flip else False\\n            \\n        # return False if blocked source to target else return not is blocked target to source \\n        return False if is_blocked(source, target, set(blocked)) else is_blocked(target, source, set(blocked), False)\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def isEscapePossible(self, blocked: List[List[int]], source: List[int], target: List[int]) -> bool:\\n        # get escape distance \\n        self.escape_distance = len(blocked)\\n        # set up blocked as set of tuples \\n        blocked = {tuple(point) for point in blocked}\\n\\n        # set up is_blocked function passing two points, blocked, and which type of check\\n        def is_blocked(p1, p2, blocked, flip=True) :\\n            # set up initial stack \\n            stack = [p1]\\n            # set up visited \\n            visited = set()\\n            visited.add(tuple(p1))\\n            # add p1 to blocked \\n            blocked.add(tuple(p1))\\n            # while you have a stack \\n            while stack :\\n                # pop one off the top \\n                x, y = stack.pop()\\n                # check mhd. If at or above escape distance, or if this is the target, return False, not blocked\\n                if (abs(p1[0]-x) + abs(p1[1]-y) >= self.escape_distance) or (x == p2[0] and y == p2[1]) :\\n                    return False if flip else True\\n                # get 4 directional neighbors \\n                N4 = [(x+1, y), (x-1, y), (x, y+1), (x, y-1)]\\n                # loop over each \\n                for N_i in N4 :\\n                    # if valid point and not blocked -> append to consider it and add to blocked\\n                    if ((0 <= N_i[0] < 1e6) and (0 <= N_i[1] < 1e6)) and ((N_i not in blocked) and (N_i not in visited)) :\\n                        stack.append(N_i)\\n                        blocked.add(N_i)\\n                        visited.add(N_i)\\n            # return True if never escape distance or reached target \\n            return True if flip else False\\n            \\n        # return False if blocked source to target else return not is blocked target to source \\n        return False if is_blocked(source, target, set(blocked)) else is_blocked(target, source, set(blocked), False)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3405478,
                "title": "c-coordinate-compression-simple-bfs-beats-90",
                "content": "time~O(500^2)\\nspace~O(500^2)\\n```\\nclass Solution {\\n    int dirx[4]={1,0,-1,0};\\n    int diry[4]={0,1,0,-1};\\npublic:\\n    bool isEscapePossible(vector<vector<int>>& blocked, vector<int>& source, vector<int>& target) {\\n        map<int,int> m1,m2;\\n        m1[source[0]]=1;\\n        m2[source[1]]=1;\\n        m1[target[0]]=1;\\n        m2[target[1]]=1;\\n        m1[0]=1;//first\\n        m2[0]=1;//first\\n        vector<vector<int>> visited(500,vector<int>(500));\\n        for(auto &a:blocked){\\n            m1[a[0]]=1;\\n            m2[a[1]]=1;\\n            if(a[0]+1<1e6)\\n                m1[a[0]+1]=1;//after&last\\n            if(a[1]+1<1e6)\\n                m2[a[1]+1]=1;//after&last\\n        }\\n        int xx=1,yy=1;\\n        for(auto &a:m1)\\n            a.second=xx++;\\n        for(auto &a:m2)\\n            a.second=yy++;\\n        for(auto &a:blocked)\\n            visited[m1[a[0]]][m2[a[1]]]=-1;\\n        \\n        visited[m1[source[0]]][m2[source[1]]]=1;\\n        queue<pair<int,int>> q;\\n        q.push({m1[source[0]],m2[source[1]]});\\n        while(q.size()){\\n            auto [x,y]=q.front();\\n            q.pop();\\n            for(int dir=0;dir<4;dir++){\\n                int nx=x+dirx[dir];\\n                int ny=y+diry[dir];\\n                if(nx>=1 and nx-1<m1.size() and\\n                  ny>=1 and ny-1<m2.size() and \\n                  visited[nx][ny]==0\\n                  ){\\n                    visited[nx][ny]=1;\\n                    q.push({nx,ny});\\n                    if(nx==m1[target[0]] and\\n                      ny==m2[target[1]])\\n                        return true;\\n                }\\n            }\\n        }\\n        return false;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Breadth-First Search",
                    "Queue"
                ],
                "code": "```\\nclass Solution {\\n    int dirx[4]={1,0,-1,0};\\n    int diry[4]={0,1,0,-1};\\npublic:\\n    bool isEscapePossible(vector<vector<int>>& blocked, vector<int>& source, vector<int>& target) {\\n        map<int,int> m1,m2;\\n        m1[source[0]]=1;\\n        m2[source[1]]=1;\\n        m1[target[0]]=1;\\n        m2[target[1]]=1;\\n        m1[0]=1;//first\\n        m2[0]=1;//first\\n        vector<vector<int>> visited(500,vector<int>(500));\\n        for(auto &a:blocked){\\n            m1[a[0]]=1;\\n            m2[a[1]]=1;\\n            if(a[0]+1<1e6)\\n                m1[a[0]+1]=1;//after&last\\n            if(a[1]+1<1e6)\\n                m2[a[1]+1]=1;//after&last\\n        }\\n        int xx=1,yy=1;\\n        for(auto &a:m1)\\n            a.second=xx++;\\n        for(auto &a:m2)\\n            a.second=yy++;\\n        for(auto &a:blocked)\\n            visited[m1[a[0]]][m2[a[1]]]=-1;\\n        \\n        visited[m1[source[0]]][m2[source[1]]]=1;\\n        queue<pair<int,int>> q;\\n        q.push({m1[source[0]],m2[source[1]]});\\n        while(q.size()){\\n            auto [x,y]=q.front();\\n            q.pop();\\n            for(int dir=0;dir<4;dir++){\\n                int nx=x+dirx[dir];\\n                int ny=y+diry[dir];\\n                if(nx>=1 and nx-1<m1.size() and\\n                  ny>=1 and ny-1<m2.size() and \\n                  visited[nx][ny]==0\\n                  ){\\n                    visited[nx][ny]=1;\\n                    q.push({nx,ny});\\n                    if(nx==m1[target[0]] and\\n                      ny==m2[target[1]])\\n                        return true;\\n                }\\n            }\\n        }\\n        return false;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3374929,
                "title": "reducing-problem-space-and-then-simple-bfs-dfs",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nThe idea is about minimizing the space and then run the normal BFS/DFS. \\n- Imagining having 0 blocks: We have one fully accessible grid\\n```\\n.\\n```\\nImagining having 1 block: Problem space can be reduced down to a 3x3 grid.\\n```\\n...\\n.X.\\n...\\n```\\nImagining having 2 blocks: Problem space can be reduced down to 4x4 grid.\\n```\\n....\\n.X..\\n..X.\\n....\\n```\\n.\\n.\\n.\\nImagining having N blocks: Problem space can be reduced down to (N+1)x(N+1) grid.\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nEach block, is splitting the problem space into 3 sections on each axis:\\n- Before the block\\n- Same as block\\n- After block\\n\\nThese can be represented as lines. If we have no blocks, the problem space only consists of 2 lines: 0 and M (size of problem space).\\nFor each block, we add 2 lines to represent the split in the problem space.\\n\\nThen we create the smaller grid out of these lines and then run normal BFS/DFS.\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nassuming $$n$$ is number of blocks:\\nCreation of the grid: $$O(n*logn)$$\\nTesting reachability: $$O(n^2)$$\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nOur smaller grid is $$(2 * n + 1)$$x$$(2 * n + 1)$$ in worse-case scenario, so the Space complexity will be $$O(n^2)$$\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    bool isEscapePossible(vector<vector<int>>& blocked, vector<int>& source, vector<int>& target) {\\n        vector<int> xLines, yLines;\\n        xLines.push_back(0); // first element is 0\\n        xLines.push_back(1000000);\\n        yLines.push_back(0); // first element is 0\\n        yLines.push_back(1000000);\\n\\n        // Extract lines\\n        for (int i = 0; i < blocked.size(); i++) {\\n            auto x = blocked[i][0];\\n            xLines.push_back(x);\\n            xLines.push_back(x + 1);\\n            auto y = blocked[i][1];\\n            yLines.push_back(y);\\n            yLines.push_back(y + 1);\\n        }\\n\\n        // Remove duplicate lines\\n        sort(xLines.begin(), xLines.end());\\n        xLines.resize(distance(xLines.begin(), unique(xLines.begin(), xLines.end())));\\n        sort(yLines.begin(), yLines.end());\\n        yLines.resize(distance(yLines.begin(), unique(yLines.begin(), yLines.end())));\\n\\n        // Create grid\\n        auto m = xLines.size();\\n        auto n = yLines.size();\\n        vector<vector<int>> grid(m+1, vector<int>(n+1, 1));\\n        // Embed grid into a frame to simplify searching algorithm\\n        for (int i = 0; i <= m; i++)\\n            grid[i][0] = grid[i][n] = 0;\\n        for (int j = 0; j <= n; j++)\\n            grid[0][j] = grid[m][j] = 0;\\n        \\n        // Find block\\'s representation in smaller grid and mark them as obstacle\\n        for (int i = 0; i < blocked.size(); i++) {\\n            auto x = distance(xLines.begin(), lower_bound(xLines.begin(), xLines.end(), blocked[i][0]));\\n            auto y = distance(yLines.begin(), lower_bound(yLines.begin(), yLines.end(), blocked[i][1]));\\n            grid[x+1][y+1] = 0;\\n        }\\n\\n        // Find `source` and `target` points in smaller grid.\\n        auto s = make_pair(\\n            distance(xLines.begin(), upper_bound(xLines.begin(), xLines.end(), source[0])),\\n            distance(yLines.begin(), upper_bound(yLines.begin(), yLines.end(), source[1]))\\n        );\\n        auto t = make_pair(\\n            distance(xLines.begin(), upper_bound(xLines.begin(), xLines.end(), target[0])),\\n            distance(yLines.begin(), upper_bound(yLines.begin(), yLines.end(), target[1]))\\n        );\\n\\n        return bfs_test(grid, s, t);\\n    }\\n\\n    bool bfs_test(vector<vector<int>>& grid, pair<int, int> s, pair<int, int> t) {\\n        queue<pair<int, int>> qu;\\n        qu.push(s);\\n        grid[s.first][s.second] = 0;\\n        while (!qu.empty()) {\\n            auto top = qu.front();\\n            qu.pop();\\n            if (top == t) return true;\\n            int dx[] = {0, +1, -1, 0};\\n            int dy[] = {-1, 0, 0, +1};\\n\\n            for (int i = 0; i < 4; i++) {\\n                auto newX = top.first + dx[i];\\n                auto newY = top.second+ dy[i];\\n\\n                if (grid[newX][newY]) {\\n                    grid[newX][newY] = 0;\\n                    qu.push({newX, newY});\\n                }\\n            }\\n        }\\n        return false;\\n    }\\n};\\n\\n\\n```",
                "solutionTags": [
                    "C++",
                    "Depth-First Search",
                    "Breadth-First Search"
                ],
                "code": "```\\n.\\n```\n```\\n...\\n.X.\\n...\\n```\n```\\n....\\n.X..\\n..X.\\n....\\n```\n```\\nclass Solution {\\npublic:\\n    bool isEscapePossible(vector<vector<int>>& blocked, vector<int>& source, vector<int>& target) {\\n        vector<int> xLines, yLines;\\n        xLines.push_back(0); // first element is 0\\n        xLines.push_back(1000000);\\n        yLines.push_back(0); // first element is 0\\n        yLines.push_back(1000000);\\n\\n        // Extract lines\\n        for (int i = 0; i < blocked.size(); i++) {\\n            auto x = blocked[i][0];\\n            xLines.push_back(x);\\n            xLines.push_back(x + 1);\\n            auto y = blocked[i][1];\\n            yLines.push_back(y);\\n            yLines.push_back(y + 1);\\n        }\\n\\n        // Remove duplicate lines\\n        sort(xLines.begin(), xLines.end());\\n        xLines.resize(distance(xLines.begin(), unique(xLines.begin(), xLines.end())));\\n        sort(yLines.begin(), yLines.end());\\n        yLines.resize(distance(yLines.begin(), unique(yLines.begin(), yLines.end())));\\n\\n        // Create grid\\n        auto m = xLines.size();\\n        auto n = yLines.size();\\n        vector<vector<int>> grid(m+1, vector<int>(n+1, 1));\\n        // Embed grid into a frame to simplify searching algorithm\\n        for (int i = 0; i <= m; i++)\\n            grid[i][0] = grid[i][n] = 0;\\n        for (int j = 0; j <= n; j++)\\n            grid[0][j] = grid[m][j] = 0;\\n        \\n        // Find block\\'s representation in smaller grid and mark them as obstacle\\n        for (int i = 0; i < blocked.size(); i++) {\\n            auto x = distance(xLines.begin(), lower_bound(xLines.begin(), xLines.end(), blocked[i][0]));\\n            auto y = distance(yLines.begin(), lower_bound(yLines.begin(), yLines.end(), blocked[i][1]));\\n            grid[x+1][y+1] = 0;\\n        }\\n\\n        // Find `source` and `target` points in smaller grid.\\n        auto s = make_pair(\\n            distance(xLines.begin(), upper_bound(xLines.begin(), xLines.end(), source[0])),\\n            distance(yLines.begin(), upper_bound(yLines.begin(), yLines.end(), source[1]))\\n        );\\n        auto t = make_pair(\\n            distance(xLines.begin(), upper_bound(xLines.begin(), xLines.end(), target[0])),\\n            distance(yLines.begin(), upper_bound(yLines.begin(), yLines.end(), target[1]))\\n        );\\n\\n        return bfs_test(grid, s, t);\\n    }\\n\\n    bool bfs_test(vector<vector<int>>& grid, pair<int, int> s, pair<int, int> t) {\\n        queue<pair<int, int>> qu;\\n        qu.push(s);\\n        grid[s.first][s.second] = 0;\\n        while (!qu.empty()) {\\n            auto top = qu.front();\\n            qu.pop();\\n            if (top == t) return true;\\n            int dx[] = {0, +1, -1, 0};\\n            int dy[] = {-1, 0, 0, +1};\\n\\n            for (int i = 0; i < 4; i++) {\\n                auto newX = top.first + dx[i];\\n                auto newY = top.second+ dy[i];\\n\\n                if (grid[newX][newY]) {\\n                    grid[newX][newY] = 0;\\n                    qu.push({newX, newY});\\n                }\\n            }\\n        }\\n        return false;\\n    }\\n};\\n\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3069549,
                "title": "dfs-solution-python",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nThe problem is asking to determine if it\\'s possible to escape a blocked grid by starting at the source point and reaching the target point. The approach I\\'m thinking of using is using breadth-first search (BFS) to check if the source point can reach the target point.\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nMy approach is to use BFS to check if the source point can reach the target point. I will use a queue to keep track of all the points that need to be visited and a set to keep track of all the points that have been visited. I will also use a set to store all the blocked points. If at any point the number of seen points exceeds 20000, I will return True as it is not possible to escape from a blocked grid if the number of seen points exceeds 20000.\\n\\n\\n# Complexity\\n- Time complexity: $$O(b + n)$$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nwhere b is the number of blocked points and n is the number of points visited.\\n\\n- Space complexity: $$O(b + n)$$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nwhere b is the number of blocked points and n is the number of points visited.\\n\\n# Code\\n```\\nclass Solution:\\n    def isEscapePossible(self, blocked: List[List[int]], source: List[int], target: List[int]) -> bool:\\n        blocked = set(map(tuple, blocked))\\n        return self.bfs(blocked, source, target) and self.bfs(blocked, target, source)\\n\\n    def bfs(self, blocked, source, target):\\n        q = collections.deque([tuple(source)])\\n        seen = set(q)\\n        while q:\\n            if len(seen) > 20000:\\n                return True\\n            x, y = q.popleft()\\n            if [x, y] == target:\\n                return True\\n            for dx, dy in ((1, 0), (-1, 0), (0, 1), (0, -1)):\\n                nx, ny = x + dx, y + dy\\n                if 0 <= nx < 10 ** 6 and 0 <= ny < 10 ** 6 and (nx, ny) not in blocked and (nx, ny) not in seen:\\n                    seen.add((nx, ny))\\n                    q.append((nx, ny))\\n        return False\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def isEscapePossible(self, blocked: List[List[int]], source: List[int], target: List[int]) -> bool:\\n        blocked = set(map(tuple, blocked))\\n        return self.bfs(blocked, source, target) and self.bfs(blocked, target, source)\\n\\n    def bfs(self, blocked, source, target):\\n        q = collections.deque([tuple(source)])\\n        seen = set(q)\\n        while q:\\n            if len(seen) > 20000:\\n                return True\\n            x, y = q.popleft()\\n            if [x, y] == target:\\n                return True\\n            for dx, dy in ((1, 0), (-1, 0), (0, 1), (0, -1)):\\n                nx, ny = x + dx, y + dy\\n                if 0 <= nx < 10 ** 6 and 0 <= ny < 10 ** 6 and (nx, ny) not in blocked and (nx, ny) not in seen:\\n                    seen.add((nx, ny))\\n                    q.append((nx, ny))\\n        return False\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3034603,
                "title": "just-a-runnable-solution",
                "content": "# Code\\n```\\nimpl Solution {\\n    pub fn is_escape_possible(blocked: Vec<Vec<i32>>, source: Vec<i32>, target: Vec<i32>) -> bool {\\n        fn can_reach(\\n            source: &[i32],\\n            target: &[i32],\\n            num_blocked: i32,\\n            block: &std::collections::HashSet<(i32, i32)>,\\n        ) -> bool {\\n            let dx = vec![0, 0, 1, -1];\\n            let dy = vec![1, -1, 0, 0];\\n            let max_area = num_blocked * (num_blocked - 1) / 2;\\n            let mut curr_area = 1;\\n            let mut visited = std::collections::HashSet::new();\\n            let mut q = std::collections::VecDeque::new();\\n            q.push_back((source[0], source[1]));\\n            visited.insert((source[0], source[1]));\\n            while !q.is_empty() {\\n                let (x, y) = q.pop_front().unwrap();\\n                for i in 0..4 {\\n                    let new_x = x + dx[i];\\n                    let new_y = y + dy[i];\\n                    if new_x == target[0] && new_y == target[1] {\\n                        return true;\\n                    }\\n                    if curr_area > max_area {\\n                        return true;\\n                    }\\n                    if new_x >= 0\\n                        && new_x < 1e6 as i32\\n                        && new_y >= 0\\n                        && new_y < 1e6 as i32\\n                        && !block.contains(&(new_x, new_y))\\n                        && !visited.contains(&(new_x, new_y))\\n                    {\\n                        curr_area += 1;\\n                        visited.insert((new_x, new_y));\\n                        q.push_back((new_x, new_y));\\n                    }\\n                }\\n            }\\n            false\\n        }\\n\\n        let mut block = std::collections::HashSet::new();\\n        let mut count = 0;\\n        for item in &blocked {\\n            count += 1;\\n            block.insert((item[0], item[1]));\\n        }\\n        can_reach(&source, &target, count, &block) && can_reach(&target, &source, count, &block)\\n    }\\n}\\n```",
                "solutionTags": [
                    "Rust"
                ],
                "code": "```\\nimpl Solution {\\n    pub fn is_escape_possible(blocked: Vec<Vec<i32>>, source: Vec<i32>, target: Vec<i32>) -> bool {\\n        fn can_reach(\\n            source: &[i32],\\n            target: &[i32],\\n            num_blocked: i32,\\n            block: &std::collections::HashSet<(i32, i32)>,\\n        ) -> bool {\\n            let dx = vec![0, 0, 1, -1];\\n            let dy = vec![1, -1, 0, 0];\\n            let max_area = num_blocked * (num_blocked - 1) / 2;\\n            let mut curr_area = 1;\\n            let mut visited = std::collections::HashSet::new();\\n            let mut q = std::collections::VecDeque::new();\\n            q.push_back((source[0], source[1]));\\n            visited.insert((source[0], source[1]));\\n            while !q.is_empty() {\\n                let (x, y) = q.pop_front().unwrap();\\n                for i in 0..4 {\\n                    let new_x = x + dx[i];\\n                    let new_y = y + dy[i];\\n                    if new_x == target[0] && new_y == target[1] {\\n                        return true;\\n                    }\\n                    if curr_area > max_area {\\n                        return true;\\n                    }\\n                    if new_x >= 0\\n                        && new_x < 1e6 as i32\\n                        && new_y >= 0\\n                        && new_y < 1e6 as i32\\n                        && !block.contains(&(new_x, new_y))\\n                        && !visited.contains(&(new_x, new_y))\\n                    {\\n                        curr_area += 1;\\n                        visited.insert((new_x, new_y));\\n                        q.push_back((new_x, new_y));\\n                    }\\n                }\\n            }\\n            false\\n        }\\n\\n        let mut block = std::collections::HashSet::new();\\n        let mut count = 0;\\n        for item in &blocked {\\n            count += 1;\\n            block.insert((item[0], item[1]));\\n        }\\n        can_reach(&source, &target, count, &block) && can_reach(&target, &source, count, &block)\\n    }\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3022786,
                "title": "bfs-from-source-and-target-to-see-if-we-can-reach-a-point-200-unit",
                "content": "```\\nclass Solution:\\n    def isEscapePossible(self, blocked: List[List[int]], source: List[int], target: List[int]) -> bool:\\n        \"\"\"\\n        the blocked is only of length 200\\n        we cannot reach from source to target if either the source is bounded/completely \\n        isolated by points in blocked or the target is bounded/isolated by blocked points\\n        hence, we need to run bfs twice. One from source and one time from target\\n        if we are able to reach a point which is 200 manhattan distance away from the source,\\n        hence we can confirm that source is not blocked\\n        we repeat the same process for target\\n        \"\"\"\\n        m, n = 1000000, 1000000\\n        blocked = {tuple(item) for item in blocked}\\n        def is_valid(i, j):\\n            return 0 <= i < m and 0 <= j < n\\n        \\n        def get_neighbors(i, j):\\n            return [(i+1,j), (i-1,j), (i,j+1), (i,j-1)]\\n        \\n        def get_distance(pt1, pt2):\\n            dist = abs(pt2[1] - pt1[1]) + abs(pt2[0] - pt1[0])\\n            return dist\\n\\n        def bfs(point, dest):\\n            que = deque([point])\\n            visited = {point}\\n            while len(que):\\n                i,j = que.popleft()\\n\\n                if (i,j) == dest:\\n                    return True\\n                if dist(point, (i,j)) >= 200:\\n                    return True\\n\\n                for nei in get_neighbors(i,j):\\n                    x, y = nei\\n                    if is_valid(x, y) and (x, y) not in blocked and (x,y) not in visited:\\n                        visited.add((x,y))\\n                        que.append((x,y))\\n\\n            \\n        a = bfs(tuple(source), tuple(target))\\n        b = bfs(tuple(target), tuple(source))\\n        return a and b\\n```",
                "solutionTags": [
                    "Python3",
                    "Breadth-First Search"
                ],
                "code": "```\\nclass Solution:\\n    def isEscapePossible(self, blocked: List[List[int]], source: List[int], target: List[int]) -> bool:\\n        \"\"\"\\n        the blocked is only of length 200\\n        we cannot reach from source to target if either the source is bounded/completely \\n        isolated by points in blocked or the target is bounded/isolated by blocked points\\n        hence, we need to run bfs twice. One from source and one time from target\\n        if we are able to reach a point which is 200 manhattan distance away from the source,\\n        hence we can confirm that source is not blocked\\n        we repeat the same process for target\\n        \"\"\"\\n        m, n = 1000000, 1000000\\n        blocked = {tuple(item) for item in blocked}\\n        def is_valid(i, j):\\n            return 0 <= i < m and 0 <= j < n\\n        \\n        def get_neighbors(i, j):\\n            return [(i+1,j), (i-1,j), (i,j+1), (i,j-1)]\\n        \\n        def get_distance(pt1, pt2):\\n            dist = abs(pt2[1] - pt1[1]) + abs(pt2[0] - pt1[0])\\n            return dist\\n\\n        def bfs(point, dest):\\n            que = deque([point])\\n            visited = {point}\\n            while len(que):\\n                i,j = que.popleft()\\n\\n                if (i,j) == dest:\\n                    return True\\n                if dist(point, (i,j)) >= 200:\\n                    return True\\n\\n                for nei in get_neighbors(i,j):\\n                    x, y = nei\\n                    if is_valid(x, y) and (x, y) not in blocked and (x,y) not in visited:\\n                        visited.add((x,y))\\n                        que.append((x,y))\\n\\n            \\n        a = bfs(tuple(source), tuple(target))\\n        b = bfs(tuple(target), tuple(source))\\n        return a and b\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3020939,
                "title": "js",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nconst isEscapePossible = (blocked, source, target) => {\\n    \\n  // Need to check possibility to escape for both target and source\\n  return helper(blocked, source, target) && helper(blocked, target, source);\\n};\\n\\nconst helper = (blocked, source, target) => {\\n  if (!blocked || blocked.length === 0) return true;\\n\\n  // Creating hash maps for visited and blocked values\\n  blocked = new Set(blocked.map(arr => arr.toString()));\\n  let visited = new Set();\\n  let queue = [source];\\n\\n  let n = 10 ** 6;\\n  let m = 10 ** 6;\\n  let level = 0;\\n\\n  // Using queue for BFS\\n  while (queue.length > 0) {\\n      \\n    // Counting levels from the source\\n    const levelLength = queue.length;\\n    for (let k = 0; k < levelLength; k++) {\\n      const [i, j] = queue.shift();\\n      if (i === target[0] && j === target[1]) return true;\\n        \\n      // Checkig each of 4 directions and adding them to queue and visited hash map\\n      for (const [x, y] of [[i + 1, j], [i - 1, j], [i, j + 1], [i, j - 1]]) {\\n        const stringed = [x, y].toString();\\n        if (x >= 0 && x < n && y >= 0 && y < m && !visited.has(stringed) && !blocked.has(stringed)) {\\n          queue.push([x, y]);\\n          visited.add(stringed);\\n        }\\n          \\n      }\\n    }\\n    level += 1;\\n      \\n    // If level is bigger than the amount of blocked position we can assume that escape exists\\n    if (level > blocked.size) return true;\\n  }\\n\\n  return false;\\n};\\n\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\nconst isEscapePossible = (blocked, source, target) => {\\n    \\n  // Need to check possibility to escape for both target and source\\n  return helper(blocked, source, target) && helper(blocked, target, source);\\n};\\n\\nconst helper = (blocked, source, target) => {\\n  if (!blocked || blocked.length === 0) return true;\\n\\n  // Creating hash maps for visited and blocked values\\n  blocked = new Set(blocked.map(arr => arr.toString()));\\n  let visited = new Set();\\n  let queue = [source];\\n\\n  let n = 10 ** 6;\\n  let m = 10 ** 6;\\n  let level = 0;\\n\\n  // Using queue for BFS\\n  while (queue.length > 0) {\\n      \\n    // Counting levels from the source\\n    const levelLength = queue.length;\\n    for (let k = 0; k < levelLength; k++) {\\n      const [i, j] = queue.shift();\\n      if (i === target[0] && j === target[1]) return true;\\n        \\n      // Checkig each of 4 directions and adding them to queue and visited hash map\\n      for (const [x, y] of [[i + 1, j], [i - 1, j], [i, j + 1], [i, j - 1]]) {\\n        const stringed = [x, y].toString();\\n        if (x >= 0 && x < n && y >= 0 && y < m && !visited.has(stringed) && !blocked.has(stringed)) {\\n          queue.push([x, y]);\\n          visited.add(stringed);\\n        }\\n          \\n      }\\n    }\\n    level += 1;\\n      \\n    // If level is bigger than the amount of blocked position we can assume that escape exists\\n    if (level > blocked.size) return true;\\n  }\\n\\n  return false;\\n};\\n\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3015799,
                "title": "python-simple-bfs",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def isEscapePossible(self, blocked, source, target):\\n        if not blocked:\\n            return True\\n\\n        n = len(blocked)\\n\\n        def dfs(start,end,visited):\\n            stack = [start]\\n\\n            while stack:\\n                i, j = stack.pop(0)\\n\\n                if abs(start[0]-i) + abs(start[1]-j) >= n or [i,j] == end:\\n                    return True\\n\\n                for ni,nj in [(i-1,j),(i+1,j),(i,j-1),(i,j+1)]:\\n                    if 0 <= ni < 10**6 and 0 <= nj < 10**6 and [ni,nj] not in blocked and (ni,nj) not in visited:\\n                        stack.append((ni,nj))\\n                        visited.add((ni,nj))\\n\\n            return False\\n\\n        return dfs(source,target,set(source)) and dfs(target,source,set(target))\\n\\n\\n\\n\\n\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def isEscapePossible(self, blocked, source, target):\\n        if not blocked:\\n            return True\\n\\n        n = len(blocked)\\n\\n        def dfs(start,end,visited):\\n            stack = [start]\\n\\n            while stack:\\n                i, j = stack.pop(0)\\n\\n                if abs(start[0]-i) + abs(start[1]-j) >= n or [i,j] == end:\\n                    return True\\n\\n                for ni,nj in [(i-1,j),(i+1,j),(i,j-1),(i,j+1)]:\\n                    if 0 <= ni < 10**6 and 0 <= nj < 10**6 and [ni,nj] not in blocked and (ni,nj) not in visited:\\n                        stack.append((ni,nj))\\n                        visited.add((ni,nj))\\n\\n            return False\\n\\n        return dfs(source,target,set(source)) and dfs(target,source,set(target))\\n\\n\\n\\n\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3004837,
                "title": "layz-guy-only-explore-as-much-as-needed-with-bfs-algorithm",
                "content": "# Intuition\\nLayz guy only explore as  much as needed with BFS algorithm\\n\\n# Approach\\nBFS\\n\\n\\n\\n# Code\\n```\\n#https://leetcode.com/problems/escape-a-large-maze/solutions/282849/python-bfs-and-dfs-the-whole-problem-is-broken/?orderBy=most_votes\\nclass Solution:    \\n    def isEscapePossible(self, blocked, source, target):\\n        MAX_BLOCK_AREA = 200 * (200-1) / 2\\n        blocked = {tuple(p) for p in blocked}\\n\\n        def bfs(source, target):\\n            q, seen = [source], {tuple(source)}\\n            for x0, y0 in q:\\n                for i, j in [[0, 1], [1, 0], [-1, 0], [0, -1]]:\\n                    x, y = x0 + i, y0 + j\\n                    if 0 <= x < 10**6 and 0 <= y < 10**6 and (x, y) not in seen and (x, y) not in blocked:\\n                        if [x, y] == target: return True\\n                        q.append([x, y])\\n                        seen.add((x, y))\\n                if len(q) > MAX_BLOCK_AREA: return True                \\n            return False\\n        return bfs(source, target) and bfs(target, source)\\n        \\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\n#https://leetcode.com/problems/escape-a-large-maze/solutions/282849/python-bfs-and-dfs-the-whole-problem-is-broken/?orderBy=most_votes\\nclass Solution:    \\n    def isEscapePossible(self, blocked, source, target):\\n        MAX_BLOCK_AREA = 200 * (200-1) / 2\\n        blocked = {tuple(p) for p in blocked}\\n\\n        def bfs(source, target):\\n            q, seen = [source], {tuple(source)}\\n            for x0, y0 in q:\\n                for i, j in [[0, 1], [1, 0], [-1, 0], [0, -1]]:\\n                    x, y = x0 + i, y0 + j\\n                    if 0 <= x < 10**6 and 0 <= y < 10**6 and (x, y) not in seen and (x, y) not in blocked:\\n                        if [x, y] == target: return True\\n                        q.append([x, y])\\n                        seen.add((x, y))\\n                if len(q) > MAX_BLOCK_AREA: return True                \\n            return False\\n        return bfs(source, target) and bfs(target, source)\\n        \\n```",
                "codeTag": "Java"
            },
            {
                "id": 2863033,
                "title": "c-bfs-using-the-fact-that-there-are-at-most-200-obstacles",
                "content": "I don\\'t think it is a good solution, but at least it passes all the tests and can be helpful for someone.\\n\\n\\tpublic class Solution \\n\\t{\\n\\t\\t// The grid splits board on connected componnents. We need to check if target and destination\\n\\t\\t// belong to the same componnent. Since blocked.length <= 200 is small we run BFS from source and target and check if they can reach a cell on a distance at least 200. If so they are connected, because they are connected to a \"common space without holes\". If not we also check if they can reach each other with less than 200 steps.\\n\\t\\tpublic bool IsEscapePossible(int[][] blocked, int[] source, int[] target) \\n\\t\\t{\\n\\t\\t\\tvar totalBlocked = new HashSet<(int, int)>();\\n\\n\\t\\t\\tfor(int i = 0; i < blocked.Length; ++i)\\n\\t\\t\\t{\\n\\t\\t\\t\\ttotalBlocked.Add((blocked[i][0], blocked[i][1]));\\n\\t\\t\\t}\\n\\n\\t\\t\\tvar k = totalBlocked.Count + 1;\\n\\n\\t\\t\\treturn BFSLongerThanKSteps(totalBlocked, source, target, k) && \\n\\t\\t\\t\\t   BFSLongerThanKSteps(totalBlocked, target, source, k);  \\n\\t\\t}\\n\\n\\t\\tpublic bool BFSLongerThanKSteps(HashSet<(int, int)> blocked, int[] source, int[] target, int k)\\n\\t\\t{   \\n\\t\\t\\tvar uppperBound = 1_000_000;\\n\\n\\t\\t\\tvar directions = new List<(int, int)> {(-1, 0), (1, 0), (0, 1), (0, -1)};\\n\\n\\t\\t\\tvar visited = new HashSet<(int, int)>();\\n\\n\\t\\t\\tvar toVisit = new HashSet<(int, int)>();\\n\\n\\t\\t\\ttoVisit.Add((source[0], source[1]));\\n\\n\\t\\t\\tvar counter = 0;\\n\\n\\t\\t\\twhile(toVisit.Count > 0 && counter <= k)\\n\\t\\t\\t{\\n\\t\\t\\t\\tvar newToVisit = new HashSet<(int, int)>();\\n\\n\\t\\t\\t\\tforeach(var (x,y) in toVisit)\\n\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\tif(x == target[0] && y == target[1])\\n\\t\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\t\\treturn true;\\n\\t\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\t\\tvisited.Add(((x,y)));\\n\\n\\t\\t\\t\\t\\tforeach(var (dx, dy) in directions)\\n\\t\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\t\\tvar X = x + dx;\\n\\t\\t\\t\\t\\t\\tvar Y = y + dy;\\n\\t\\t\\t\\t\\t\\tif( 0 <= X &&  X < uppperBound &&\\n\\t\\t\\t\\t\\t\\t\\t0 <= Y &&  Y < uppperBound && \\n\\t\\t\\t\\t\\t\\t\\t!visited.Contains((X, Y)) &&\\n\\t\\t\\t\\t\\t\\t\\t!blocked.Contains((X,Y))\\n\\t\\t\\t\\t\\t\\t   )\\n\\t\\t\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\t\\t\\tnewToVisit.Add((X,Y));        \\n\\t\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\ttoVisit = newToVisit;\\n\\t\\t\\t\\t++counter;\\n\\t\\t\\t}\\n\\n\\t\\t\\treturn counter > k;\\n\\t\\t}\\n\\t}",
                "solutionTags": [],
                "code": "class Solution \\n\\t{\\n\\t\\t// The grid splits board on connected componnents. We need to check if target and destination\\n\\t\\t// belong to the same componnent. Since blocked.length <= 200 is small we run BFS from source and target and check if they can reach a cell on a distance at least 200. If so they are connected, because they are connected to a \"common space without holes\". If not we also check if they can reach each other with less than 200 steps.\\n\\t\\tpublic bool IsEscapePossible(int[][] blocked, int[] source, int[] target) \\n\\t\\t{\\n\\t\\t\\tvar totalBlocked = new HashSet<(int, int)>();\\n\\n\\t\\t\\tfor(int i = 0; i < blocked.Length; ++i)\\n\\t\\t\\t{\\n\\t\\t\\t\\ttotalBlocked.Add((blocked[i][0], blocked[i][1]));\\n\\t\\t\\t}",
                "codeTag": "Java"
            },
            {
                "id": 2861511,
                "title": "python3",
                "content": "class Solution:\\n\\n    def isEscapePossible(self, blocked: List[List[int]], source: List[int], target: List[int]) -> bool:\\n        total_blocks = len(blocked)\\n        maxArea = total_blocks*(total_blocks-1)//2\\n        blocked_set = set()\\n        for x,y in blocked:\\n            blocked_set.add((x,y))\\n        directions = [[-1,0],[1,0],[0,-1],[0,1]]\\n        ROWS = COLS = 10**6\\n        \\n        def bfs(source,target):\\n            visited = {(source[0],source[1])}\\n            area =1\\n            queue = deque([source])\\n            while queue:\\n                currX,currY = queue.popleft()\\n                if [currX,currY] == target or area>maxArea:\\n                    return True\\n                for x,y in directions:\\n                    nX,nY = currX+x,currY+y\\n                    if nX not in [-1,ROWS] and nY not in [-1,COLS] and (nX,nY) not in visited and (nX,nY) not in blocked_set:\\n                        visited.add((nX,nY))\\n                        area+=1\\n                        queue.append([nX,nY])\\n            return False\\n        \\n        return bfs(source,target) and bfs(target,source)",
                "solutionTags": [],
                "code": "class Solution:\\n\\n    def isEscapePossible(self, blocked: List[List[int]], source: List[int], target: List[int]) -> bool:\\n        total_blocks = len(blocked)\\n        maxArea = total_blocks*(total_blocks-1)//2\\n        blocked_set = set()\\n        for x,y in blocked:\\n            blocked_set.add((x,y))\\n        directions = [[-1,0],[1,0],[0,-1],[0,1]]\\n        ROWS = COLS = 10**6\\n        \\n        def bfs(source,target):\\n            visited = {(source[0],source[1])}",
                "codeTag": "Java"
            },
            {
                "id": 2612614,
                "title": "help-needed-for-optimization",
                "content": "Can anyone pls optimize my solution?\\n```\\nclass Solution {\\n    public boolean isEscapePossible(int[][] blocked, int[] source, int[] target)\\n    {\\n        int ar[][]=new int[1000000][1000000];\\n        ar[target[0]][target[1]]=2;\\n        for(int i=0;i<blocked.length;i++)\\n            ar[blocked[i][0]][blocked[i][1]]=1;\\n        return main(ar,source[0],source[1]);\\n        \\n    }\\n    boolean main(int board[][],int i,int j)\\n    {\\n        if(board[i][j]==2)\\n            return true;\\n        if(i < 0 || j < 0 || i == board.length || j == board[0].length || board[i][j] ==1)\\n        return false ;\\n           board[i][j]=1;\\n    boolean op1 = main(board,i + 1 , j ) ;\\n\\n   \\n    boolean op2 = main(board,i , j + 1 ) ;\\n\\n    \\n\\n    boolean op3 = main(board,i - 1 , j ) ;\\n\\n   \\n    boolean op4 = main(board,i , j - 1 ) ;\\n\\n   \\n    board[i][j] = 0 ;\\n\\n   \\n\\n    return op1 || op2 || op3 || op4 ;\\n           \\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public boolean isEscapePossible(int[][] blocked, int[] source, int[] target)\\n    {\\n        int ar[][]=new int[1000000][1000000];\\n        ar[target[0]][target[1]]=2;\\n        for(int i=0;i<blocked.length;i++)\\n            ar[blocked[i][0]][blocked[i][1]]=1;\\n        return main(ar,source[0],source[1]);\\n        \\n    }\\n    boolean main(int board[][],int i,int j)\\n    {\\n        if(board[i][j]==2)\\n            return true;\\n        if(i < 0 || j < 0 || i == board.length || j == board[0].length || board[i][j] ==1)\\n        return false ;\\n           board[i][j]=1;\\n    boolean op1 = main(board,i + 1 , j ) ;\\n\\n   \\n    boolean op2 = main(board,i , j + 1 ) ;\\n\\n    \\n\\n    boolean op3 = main(board,i - 1 , j ) ;\\n\\n   \\n    boolean op4 = main(board,i , j - 1 ) ;\\n\\n   \\n    board[i][j] = 0 ;\\n\\n   \\n\\n    return op1 || op2 || op3 || op4 ;\\n           \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2522937,
                "title": "something-is-wrong-with-oj-o-50000-log-50000-solution-still-giving-tle",
                "content": "```\\nclass Solution {\\npublic:\\n    bool func(vector<vector<int>>& b, vector<int>& s, vector<int>& t) {\\n        unordered_map<string, int> mp;\\n        for(int i=0; i<b.size(); i++)\\n        {\\n            mp[to_string(b[i][0])+\"*\"+to_string(b[i][1])]=1;\\n        }\\n        priority_queue<vector<int>, vector<vector<int>>, greater<vector<int>> > pq;\\n        pq.push({abs(t[0]-s[0])+abs(t[1]-s[1]), s[0], s[1]});\\n        int v[4]={0, 0, 1, -1}, h[4]={1, -1, 0, 0};\\n        int cnt=0;\\n        while(!pq.empty() && cnt<50000)\\n        {  \\n\\t\\t\\tcnt++;\\n            vector<int> curr = pq.top();\\n            pq.pop();\\n            if(curr[0]==0)\\n                return true;\\n            for(int i=0; i<4; i++)\\n            {\\n                int x=curr[1]+h[i], y=curr[2]+v[i];\\n                if(x<0 || y<0 || x>=1000000 || y>=1000000 || mp[to_string(x)+\"*\"+to_string(y)]==1)\\n                    continue;\\n                mp[to_string(x)+\"*\"+to_string(y)]=1;\\n                pq.push({abs(x-t[0])+abs(y-t[1]) ,x, y});\\n            }\\n        }\\n        if(cnt<50000)\\n            return false;\\n        return true;\\n    }\\n    bool isEscapePossible(vector<vector<int>>& b, vector<int>& s, vector<int>& t) {\\n        return func(b, s, t) & func(b, t, s);\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    bool func(vector<vector<int>>& b, vector<int>& s, vector<int>& t) {\\n        unordered_map<string, int> mp;\\n        for(int i=0; i<b.size(); i++)\\n        {\\n            mp[to_string(b[i][0])+\"*\"+to_string(b[i][1])]=1;\\n        }\\n        priority_queue<vector<int>, vector<vector<int>>, greater<vector<int>> > pq;\\n        pq.push({abs(t[0]-s[0])+abs(t[1]-s[1]), s[0], s[1]});\\n        int v[4]={0, 0, 1, -1}, h[4]={1, -1, 0, 0};\\n        int cnt=0;\\n        while(!pq.empty() && cnt<50000)\\n        {  \\n\\t\\t\\tcnt++;\\n            vector<int> curr = pq.top();\\n            pq.pop();\\n            if(curr[0]==0)\\n                return true;\\n            for(int i=0; i<4; i++)\\n            {\\n                int x=curr[1]+h[i], y=curr[2]+v[i];\\n                if(x<0 || y<0 || x>=1000000 || y>=1000000 || mp[to_string(x)+\"*\"+to_string(y)]==1)\\n                    continue;\\n                mp[to_string(x)+\"*\"+to_string(y)]=1;\\n                pq.push({abs(x-t[0])+abs(y-t[1]) ,x, y});\\n            }\\n        }\\n        if(cnt<50000)\\n            return false;\\n        return true;\\n    }\\n    bool isEscapePossible(vector<vector<int>>& b, vector<int>& s, vector<int>& t) {\\n        return func(b, s, t) & func(b, t, s);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2477551,
                "title": "python-cutout-enclosing-group-o-n-time-o-1-space-beats-100",
                "content": "Consider a 1-million-by-1-million inch sheet of paper, and overlay a grid so that each coordinate corresponds to a 1-square-inch cell. Cut out all of the blocked cells, noting that this may separate the paper into several pieces (e.g. if there\\'s a halo of blocked cells, the center will be fully cut out from the sheet).\\n\\nNow back the original question: can you draw a line from the start cell to the target cell? Key observation: the answer is always yes... if and only if they remain on the same piece of paper after cutting out all the blocked cells.\\n\\nConsider the outline/perimeter of the remaining pieces of paper, and for simplicity pretend that the edges of the original sheet count as blocked cells. Now, imagine you are extending a line outwards to the right of the source point. The longest distance that line could possibly go in a cutout surrounded by k blocked cells is k/2 (in the worst-case scenario of a \"horizontal tube\" shape). Therefore, by extending a straight line a distance of k/2 cells outwards, you will always hit the outer edge of your cutout, and you can use that outer edge to identify the cutout uniquely.\\n\\nIt also turns out that since we have at most 200 blocked cells, the perimeter of each sheet of paper must be either tiny or massive. The largest perimeter you could have for the \"tiny\" case would be if all of the n blocked cells formed a narrow tube along the edge of the sheet of paper, so k = 2\\\\*n = 400, which is much smaller than the smallest possible perimeter of the \"massive\" case. Therefore, once you\\'ve extended a line k/2 = 200 cells outward (crawling around any holes), either you\\'ve hit the wall of your tiny piece, you\\'ve hit the wall of your massive cutout, or you\\'re in the middle of the massive cutout. Either way we can just extend the arm until we hit a blocked square, then crawl along the edge. If it\\'s a hole in the paper or the wall of a tiny cutout, it should consist of <4\\\\*k=1600 edges (4\\\\*k is very safe, I think it\\'s even under 3\\\\*k). We can just crawl to the right until we get back to where we started; if we end up going clockwise, it\\'s the wall of a tiny cutout, and if we end up counterclockwise, it\\'s just a hole and we can ignore it. If we keep crawling past 1600 edges, we can stop since we know it must be the \"massive\" cutout.\\n\\nNow that we have a way to identify which cutout each cell is in, all we need to do is return true iff the start and target cells are in the same cutout.\\n\\n```python\\nclass Solution:\\n    def isEscapePossible(self, blocked: List[List[int]], source: List[int], target: List[int]) -> bool:        \\n        blocked_set = set(tuple(p) for p in blocked)\\n        \\n        def blocked(x, y):\\n            return x < 0 or y < 0 or x >= 1000000 or y >= 1000000 or (x, y) in blocked_set\\n        \\n        def crawl(x, y):\\n            # crawls to the right along an edge\\n            # returns (enclosing_edge, exit_x)\\n            # exit_x is:\\n            #   -1 if this is the massive case,\\n            #   the right edge of the hole (if this is a hole)\\n            #   undefined but nonnegative if this is the tiny case\\n            # enclosing_edge is some unique ID for the cutout, None if a hole\\n            #   (here I also use None for massive case, and I use the position\\n            #   of the bottom of the leftmost edge for the tiny case)\\n            x0, y0 = x, y\\n            test_x, test_y = x, y\\n            exit_x = -1\\n            edge = 0 # 0 is left, 1 is down, etc.\\n            first = True\\n            i = 0\\n            while first or (x, y, edge%4) != (x0, y0, 0):\\n                first = False\\n                i += 1\\n                # unenclosed\\n                if i > 1600: return None, -1 # limit exceeded (massive case)\\n                if x <= test_x:\\n                    test_x = min(test_x, x)\\n                    test_y = min(test_y, y)\\n                if edge%4 == 0:\\n                    if blocked(x-1, y-1):\\n                        x, y = x-1, y-1\\n                        edge -= 1\\n                    elif blocked(x, y-1):\\n                        y -= 1\\n                    else:\\n                        edge += 1\\n                elif edge%4 == 1:\\n                    if blocked(x+1, y-1):\\n                        x, y = x+1, y-1\\n                        edge -= 1\\n                    elif blocked(x+1, y):\\n                        x += 1\\n                    else:\\n                        edge += 1\\n                elif edge%4 == 2:\\n                    if y == y0:\\n                        exit_x = max(exit_x, x+1)\\n                    \\n                    if blocked(x+1, y+1):\\n                        x, y = x+1, y+1\\n                        edge -= 1\\n                    elif blocked(x, y+1):\\n                        y += 1\\n                    else:\\n                        edge += 1\\n                else: # edge%4 == 3\\n                    if blocked(x-1, y+1):\\n                        x, y = x-1, y+1\\n                        edge -= 1\\n                    elif blocked(x-1, y):\\n                        x -= 1\\n                    else:\\n                        edge += 1 \\n                        \\n            assert abs(edge) == 4\\n            if edge > 0:\\n                # hole\\n                return None, exit_x\\n            else:\\n                # enclosed (tiny case)\\n                return (test_x, test_y), exit_x\\n        \\n        def enclosed(x0, y):\\n            # returns the enclosure ID containing the point\\n            x = x0\\n            # extend the arm up to 200 units to the right\\n            while x < x0+200:\\n                x += 1\\n                if blocked(x, y):\\n                    encl_test, exit_x = crawl(x, y)\\n                    if exit_x == -1: return None # massive\\n                    if encl_test is not None: return encl_test # tiny\\n                    # by here we hit a hole, continue on the other side\\n                    x = exit_x\\n            # by here, assume the massive case\\n            return None\\n        \\n        return enclosed(*source) == enclosed(*target)     \\n```\\n\\nTime: O(n)\\nSpace: O(1)\\n\\n[Aside: funny enough, I *think* this algorithm is still always linear even for much larger numbers of blocked cells; once the search limit reaches the area of the sheet you can just ignore the \"massive\" case].",
                "solutionTags": [],
                "code": "```python\\nclass Solution:\\n    def isEscapePossible(self, blocked: List[List[int]], source: List[int], target: List[int]) -> bool:        \\n        blocked_set = set(tuple(p) for p in blocked)\\n        \\n        def blocked(x, y):\\n            return x < 0 or y < 0 or x >= 1000000 or y >= 1000000 or (x, y) in blocked_set\\n        \\n        def crawl(x, y):\\n            # crawls to the right along an edge\\n            # returns (enclosing_edge, exit_x)\\n            # exit_x is:\\n            #   -1 if this is the massive case,\\n            #   the right edge of the hole (if this is a hole)\\n            #   undefined but nonnegative if this is the tiny case\\n            # enclosing_edge is some unique ID for the cutout, None if a hole\\n            #   (here I also use None for massive case, and I use the position\\n            #   of the bottom of the leftmost edge for the tiny case)\\n            x0, y0 = x, y\\n            test_x, test_y = x, y\\n            exit_x = -1\\n            edge = 0 # 0 is left, 1 is down, etc.\\n            first = True\\n            i = 0\\n            while first or (x, y, edge%4) != (x0, y0, 0):\\n                first = False\\n                i += 1\\n                # unenclosed\\n                if i > 1600: return None, -1 # limit exceeded (massive case)\\n                if x <= test_x:\\n                    test_x = min(test_x, x)\\n                    test_y = min(test_y, y)\\n                if edge%4 == 0:\\n                    if blocked(x-1, y-1):\\n                        x, y = x-1, y-1\\n                        edge -= 1\\n                    elif blocked(x, y-1):\\n                        y -= 1\\n                    else:\\n                        edge += 1\\n                elif edge%4 == 1:\\n                    if blocked(x+1, y-1):\\n                        x, y = x+1, y-1\\n                        edge -= 1\\n                    elif blocked(x+1, y):\\n                        x += 1\\n                    else:\\n                        edge += 1\\n                elif edge%4 == 2:\\n                    if y == y0:\\n                        exit_x = max(exit_x, x+1)\\n                    \\n                    if blocked(x+1, y+1):\\n                        x, y = x+1, y+1\\n                        edge -= 1\\n                    elif blocked(x, y+1):\\n                        y += 1\\n                    else:\\n                        edge += 1\\n                else: # edge%4 == 3\\n                    if blocked(x-1, y+1):\\n                        x, y = x-1, y+1\\n                        edge -= 1\\n                    elif blocked(x-1, y):\\n                        x -= 1\\n                    else:\\n                        edge += 1 \\n                        \\n            assert abs(edge) == 4\\n            if edge > 0:\\n                # hole\\n                return None, exit_x\\n            else:\\n                # enclosed (tiny case)\\n                return (test_x, test_y), exit_x\\n        \\n        def enclosed(x0, y):\\n            # returns the enclosure ID containing the point\\n            x = x0\\n            # extend the arm up to 200 units to the right\\n            while x < x0+200:\\n                x += 1\\n                if blocked(x, y):\\n                    encl_test, exit_x = crawl(x, y)\\n                    if exit_x == -1: return None # massive\\n                    if encl_test is not None: return encl_test # tiny\\n                    # by here we hit a hole, continue on the other side\\n                    x = exit_x\\n            # by here, assume the massive case\\n            return None\\n        \\n        return enclosed(*source) == enclosed(*target)     \\n```",
                "codeTag": "Java"
            },
            {
                "id": 2327584,
                "title": "c-solution-beats-100-with-explanation-and-proof",
                "content": "Boundry Scenarios:\\nAssuming source is at (0,0) for simplicity, below worst case scenarios arise:\\n1. The blocks can make a straight line horizontally or vertically, in both of this cases they cannot bind source as grid is of size 1 million and blocks are limited to 200, hence the source can easily escape from other end of line\\n2. the blocks bound the source making right angled triangle with base/height of 1 unit and hypotenous of 200 units, in this scenario the height/base will come around 199.9, i.e; from souce you cannot go more than 199 unit distance in any valid direction.\\n3. Scenarios where blocks are making curves/arcs can be ignored as the above cases will generate maximum distance possible. I hope it is clear.\\n\\nTaking in mind above cases , we can easily say that if source can reach more than 199 unit distance , i.e; manhattan distance between source and present coordinate is greater than 199. Then it is not bounded by blocks\\n\\nSimilary we need to check if target is also not bound.\\n\\nIf both the source and target are not bounded then return true.\\n\\n```\\npublic class Solution {\\n    HashSet<string> blockedCoordinates;\\n    int n = 1000000;    \\n    int[] xDir = new int[4]{0,0,1,-1};\\n    int[] yDir = new int[4]{1,-1,0,0};\\n    \\n    public bool DFS(int u, int v, int sX,int sY, int tX, int tY,HashSet<string> visitedCoordinates)\\n    {\\n        //if target is reached return true\\n        if((u==tX && v ==tY)) return  true;\\n        \\n        //if manhatten distance between source and current coordinate is greater than 199 then source is not bounded by blocks and assume target is reachable\\n        if(Math.Abs(sX-u) + Math.Abs(sY-v) >199) return true;\\n        \\n        visitedCoordinates.Add(u+\"-\"+v);\\n        \\n        for(int d=0;d<4;d++)\\n        {\\n            int x = u + xDir[d];\\n            int y = v + yDir[d];\\n            string temp = x+\"-\"+y;\\n            \\n            if(x<0 || x>=n || y<0 || y>=n || visitedCoordinates.Contains(temp) || blockedCoordinates.Contains(temp)) continue;\\n            \\n            if(DFS(x,y,sX,sY,tX,tY,visitedCoordinates))\\n            {\\n                return true;\\n            }\\n        }\\n        \\n        return false;\\n    }\\n    \\n    public bool IsEscapePossible(int[][] blocked, int[] source, int[] target) {\\n        \\n        blockedCoordinates = new HashSet<string>();\\n        \\n        foreach(int[] block in blocked)\\n        {\\n            int x = block[0];\\n            int y = block[1];\\n            \\n            blockedCoordinates.Add(x+\"-\"+y);\\n        }\\n        \\n        //Search from Source to target assuming that source is bounded by blocks\\n        //Search from target to source assuming that target is bounded by blocks\\n        //if both source and target are not bound then return true\\n        return DFS(source[0],source[1],source[0],source[1], target[0],target[1], new HashSet<string>()) && DFS(target[0],target[1],target[0],target[1], source[0],source[1], new HashSet<string>());\\n    }\\n}\\n```",
                "solutionTags": [
                    "Math",
                    "Depth-First Search"
                ],
                "code": "```\\npublic class Solution {\\n    HashSet<string> blockedCoordinates;\\n    int n = 1000000;    \\n    int[] xDir = new int[4]{0,0,1,-1};\\n    int[] yDir = new int[4]{1,-1,0,0};\\n    \\n    public bool DFS(int u, int v, int sX,int sY, int tX, int tY,HashSet<string> visitedCoordinates)\\n    {\\n        //if target is reached return true\\n        if((u==tX && v ==tY)) return  true;\\n        \\n        //if manhatten distance between source and current coordinate is greater than 199 then source is not bounded by blocks and assume target is reachable\\n        if(Math.Abs(sX-u) + Math.Abs(sY-v) >199) return true;\\n        \\n        visitedCoordinates.Add(u+\"-\"+v);\\n        \\n        for(int d=0;d<4;d++)\\n        {\\n            int x = u + xDir[d];\\n            int y = v + yDir[d];\\n            string temp = x+\"-\"+y;\\n            \\n            if(x<0 || x>=n || y<0 || y>=n || visitedCoordinates.Contains(temp) || blockedCoordinates.Contains(temp)) continue;\\n            \\n            if(DFS(x,y,sX,sY,tX,tY,visitedCoordinates))\\n            {\\n                return true;\\n            }\\n        }\\n        \\n        return false;\\n    }\\n    \\n    public bool IsEscapePossible(int[][] blocked, int[] source, int[] target) {\\n        \\n        blockedCoordinates = new HashSet<string>();\\n        \\n        foreach(int[] block in blocked)\\n        {\\n            int x = block[0];\\n            int y = block[1];\\n            \\n            blockedCoordinates.Add(x+\"-\"+y);\\n        }\\n        \\n        //Search from Source to target assuming that source is bounded by blocks\\n        //Search from target to source assuming that target is bounded by blocks\\n        //if both source and target are not bound then return true\\n        return DFS(source[0],source[1],source[0],source[1], target[0],target[1], new HashSet<string>()) && DFS(target[0],target[1],target[0],target[1], source[0],source[1], new HashSet<string>());\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2171623,
                "title": "simplest-bfs-solution-easiest-solution-self-explanatory",
                "content": "```\\nfrom collections import deque\\nclass Solution:\\n    def isSafe(self, i, j):\\n        return 0 <= i < 10**6 and 0 <= j < 10**6\\n    \\n    def bfs(self, source, target, blocked):\\n        a = source[0]\\n        b = source[1]\\n        \\n        \\n        if len(blocked) == 0:\\n            return True\\n        \\n        queue, visited = deque([(a, b)]), set([(a, b)])\\n        \\n        directions = [[0, 1], [0, -1], [1, 0], [-1, 0]]\\n        \\n        while queue:\\n            coordinates = queue.popleft()\\n            x = coordinates[0]\\n            y = coordinates[1]\\n            \\n            if [x, y] == target:\\n                return True\\n            \\n            if x in (a + 210,a - 210) or y in (b + 210, b - 210):\\n                return True\\n            \\n            for direction in directions:\\n                xNew = x + direction[0]\\n                yNew = y + direction[1]\\n                \\n                newPair = (xNew, yNew)\\n                if self.isSafe(xNew, yNew) and (newPair not in visited) and (list(newPair) not in blocked):\\n                    queue.append((xNew, yNew))\\n                    visited.add((xNew, yNew))\\n        \\n        return False\\n    def isEscapePossible(self, blocked: List[List[int]], source: List[int], target: List[int]) -> bool:\\n        return self.bfs(source, target, blocked) and self.bfs(target, source, blocked)\\n```",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Breadth-First Search"
                ],
                "code": "```\\nfrom collections import deque\\nclass Solution:\\n    def isSafe(self, i, j):\\n        return 0 <= i < 10**6 and 0 <= j < 10**6\\n    \\n    def bfs(self, source, target, blocked):\\n        a = source[0]\\n        b = source[1]\\n        \\n        \\n        if len(blocked) == 0:\\n            return True\\n        \\n        queue, visited = deque([(a, b)]), set([(a, b)])\\n        \\n        directions = [[0, 1], [0, -1], [1, 0], [-1, 0]]\\n        \\n        while queue:\\n            coordinates = queue.popleft()\\n            x = coordinates[0]\\n            y = coordinates[1]\\n            \\n            if [x, y] == target:\\n                return True\\n            \\n            if x in (a + 210,a - 210) or y in (b + 210, b - 210):\\n                return True\\n            \\n            for direction in directions:\\n                xNew = x + direction[0]\\n                yNew = y + direction[1]\\n                \\n                newPair = (xNew, yNew)\\n                if self.isSafe(xNew, yNew) and (newPair not in visited) and (list(newPair) not in blocked):\\n                    queue.append((xNew, yNew))\\n                    visited.add((xNew, yNew))\\n        \\n        return False\\n    def isEscapePossible(self, blocked: List[List[int]], source: List[int], target: List[int]) -> bool:\\n        return self.bfs(source, target, blocked) and self.bfs(target, source, blocked)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2072043,
                "title": "simple-bfs-for-src-tar-with-one-line-modification",
                "content": "```\\n#define ff first\\n#define ss second\\n\\nconst int N=1e6;\\n\\nclass Solution {\\npublic:\\n    bool isEscapePossible(vector<vector<int>>& blkd, vector<int>& srcc, vector<int>& tarr) \\n    {\\n        int yes1=0,yes2=0;\\n        int dx[4]={0,0,1,-1};\\n        int dy[4]={1,-1,0,0};\\n        \\n        map<pair<int,int>,bool> blk,vis;\\n        for(int i=0;i<blkd.size();i++)\\n            blk[{blkd[i][0],blkd[i][1]}]=1;\\n        \\n        pair<int,int> src={srcc[0],srcc[1]},tar={tarr[0],tarr[1]};\\n        \\n        queue<pair<pair<int,int>,int>> q;\\n        q.push({src,0});\\n        vis.clear();\\n        vis[src]=1;\\n        while(!q.empty())\\n        {\\n            pair xy=q.front().ff;\\n            int dis=q.front().ss;\\n            q.pop();\\n            \\n            if(xy==tar) return 1;\\n            if(q.size()>200)\\n            {\\n                // cout<<xy.ff<<\" \"<<xy.ss<<endl;\\n                yes1=1;\\n                break;\\n            }\\n            for(int i=0;i<4;i++)\\n            {\\n                int nx=xy.ff+dx[i],ny=xy.ss+dy[i];\\n                if(nx>=0 && ny>=0 && nx<N && ny<N && !blk.count({nx,ny}) && !vis.count({nx,ny}))\\n                {\\n                    vis[{nx,ny}]=1;\\n                    q.push({{nx,ny},dis+1});\\n                }\\n            }\\n        }\\n        \\n        while(!q.empty()) q.pop();\\n        q.push({tar,0});\\n        vis.clear();\\n        vis[tar]=1;\\n        while(!q.empty())\\n        {\\n            pair xy=q.front().ff;\\n            int dis=q.front().ss;\\n            q.pop();\\n            \\n            if(xy==src) return 1;\\n            if(q.size()>200)\\n            {\\n                // cout<<xy.ff<<\" \"<<xy.ss<<endl;\\n                yes2=1;\\n                break;\\n            }\\n            \\n            for(int i=0;i<4;i++)\\n            {\\n                int nx=xy.ff+dx[i],ny=xy.ss+dy[i];\\n                if(nx>=0 && ny>=0 && nx<N && ny<N && !blk.count({nx,ny}) && !vis.count({nx,ny}))\\n                {\\n                    vis[{nx,ny}]=1;\\n                    q.push({{nx,ny},dis+1});\\n                }\\n            }\\n        }\\n        \\n        return (yes1 & yes2);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Breadth-First Search"
                ],
                "code": "```\\n#define ff first\\n#define ss second\\n\\nconst int N=1e6;\\n\\nclass Solution {\\npublic:\\n    bool isEscapePossible(vector<vector<int>>& blkd, vector<int>& srcc, vector<int>& tarr) \\n    {\\n        int yes1=0,yes2=0;\\n        int dx[4]={0,0,1,-1};\\n        int dy[4]={1,-1,0,0};\\n        \\n        map<pair<int,int>,bool> blk,vis;\\n        for(int i=0;i<blkd.size();i++)\\n            blk[{blkd[i][0],blkd[i][1]}]=1;\\n        \\n        pair<int,int> src={srcc[0],srcc[1]},tar={tarr[0],tarr[1]};\\n        \\n        queue<pair<pair<int,int>,int>> q;\\n        q.push({src,0});\\n        vis.clear();\\n        vis[src]=1;\\n        while(!q.empty())\\n        {\\n            pair xy=q.front().ff;\\n            int dis=q.front().ss;\\n            q.pop();\\n            \\n            if(xy==tar) return 1;\\n            if(q.size()>200)\\n            {\\n                // cout<<xy.ff<<\" \"<<xy.ss<<endl;\\n                yes1=1;\\n                break;\\n            }\\n            for(int i=0;i<4;i++)\\n            {\\n                int nx=xy.ff+dx[i],ny=xy.ss+dy[i];\\n                if(nx>=0 && ny>=0 && nx<N && ny<N && !blk.count({nx,ny}) && !vis.count({nx,ny}))\\n                {\\n                    vis[{nx,ny}]=1;\\n                    q.push({{nx,ny},dis+1});\\n                }\\n            }\\n        }\\n        \\n        while(!q.empty()) q.pop();\\n        q.push({tar,0});\\n        vis.clear();\\n        vis[tar]=1;\\n        while(!q.empty())\\n        {\\n            pair xy=q.front().ff;\\n            int dis=q.front().ss;\\n            q.pop();\\n            \\n            if(xy==src) return 1;\\n            if(q.size()>200)\\n            {\\n                // cout<<xy.ff<<\" \"<<xy.ss<<endl;\\n                yes2=1;\\n                break;\\n            }\\n            \\n            for(int i=0;i<4;i++)\\n            {\\n                int nx=xy.ff+dx[i],ny=xy.ss+dy[i];\\n                if(nx>=0 && ny>=0 && nx<N && ny<N && !blk.count({nx,ny}) && !vis.count({nx,ny}))\\n                {\\n                    vis[{nx,ny}]=1;\\n                    q.push({{nx,ny},dis+1});\\n                }\\n            }\\n        }\\n        \\n        return (yes1 & yes2);\\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 1850370,
                "title": "what-if-the-board-is-infinite-and-there-s-no-constraint-on-blocked-size",
                "content": "I got asked during the interview with a follow-up: what if we remove the constraints on bloked size and the board size? (e.g., no upper bound for blocked.length and board size)",
                "solutionTags": [],
                "code": "I got asked during the interview with a follow-up: what if we remove the constraints on bloked size and the board size? (e.g., no upper bound for blocked.length and board size)",
                "codeTag": "Unknown"
            },
            {
                "id": 1685537,
                "title": "golang",
                "content": "\\n\\n```\\n\\nfunc isEscapePossible(blocked [][]int, source []int, target []int) bool {\\n\\tblockLimit := len(blocked) * (len(blocked)-1)/2\\n\\t\\n\\tvar blockMp1, blockMp2 = map[int]bool{}, map[int]bool{}\\n\\tvar size int\\n\\tfor _, block := range blocked {\\n\\t\\tblockMp1[hash(block[0], block[1])] = true\\n\\t\\tblockMp2[hash(block[0], block[1])] = true\\n\\t\\tsize++\\n\\t}\\n\\t\\n\\t\\n\\t\\n\\tvar dfs func(x1, y1, x2, y2 int, mp map[int]bool) bool\\n\\n\\tdfs = func(x1, y1, x2, y2 int, mp map[int]bool) bool {\\n\\t\\tkey := hash(x1, y1)\\n\\t\\tif x1 < 0 || x1 >= 1000000 || y1 < 0 || y1 >= 1000000 || mp[key] {\\n\\t\\t\\treturn false\\n\\t\\t}\\n\\n\\t\\tif len(mp)-size >= blockLimit || (x1 == x2 && y1 == y2) {\\n\\t\\t\\treturn true\\n\\t\\t}\\n\\n\\t\\tmp[key] = true\\n\\n\\t\\treturn dfs(x1, y1-1, x2, y2, mp) || dfs(x1, y1+1, x2, y2, mp) || dfs(x1-1, y1, x2, y2, mp) || dfs(x1+1, y1, x2, y2, mp)\\n\\n\\t}\\n\\n\\treturn dfs(source[0], source[1], target[0], target[1], blockMp1) && dfs(target[0], target[1], source[0], source[1], blockMp2)\\n}\\n\\n\\n// \\u81EA\\u5B9A\\u4E49hash\\u4F18\\u5316\\nfunc hash(x, y int) int {\\n\\treturn x * 1000000 + y\\n}\\n```",
                "solutionTags": [],
                "code": "```\\n\\nfunc isEscapePossible(blocked [][]int, source []int, target []int) bool {\\n\\tblockLimit := len(blocked) * (len(blocked)-1)/2\\n\\t\\n\\tvar blockMp1, blockMp2 = map[int]bool{}, map[int]bool{}\\n\\tvar size int\\n\\tfor _, block := range blocked {\\n\\t\\tblockMp1[hash(block[0], block[1])] = true\\n\\t\\tblockMp2[hash(block[0], block[1])] = true\\n\\t\\tsize++\\n\\t}\\n\\t\\n\\t\\n\\t\\n\\tvar dfs func(x1, y1, x2, y2 int, mp map[int]bool) bool\\n\\n\\tdfs = func(x1, y1, x2, y2 int, mp map[int]bool) bool {\\n\\t\\tkey := hash(x1, y1)\\n\\t\\tif x1 < 0 || x1 >= 1000000 || y1 < 0 || y1 >= 1000000 || mp[key] {\\n\\t\\t\\treturn false\\n\\t\\t}\\n\\n\\t\\tif len(mp)-size >= blockLimit || (x1 == x2 && y1 == y2) {\\n\\t\\t\\treturn true\\n\\t\\t}\\n\\n\\t\\tmp[key] = true\\n\\n\\t\\treturn dfs(x1, y1-1, x2, y2, mp) || dfs(x1, y1+1, x2, y2, mp) || dfs(x1-1, y1, x2, y2, mp) || dfs(x1+1, y1, x2, y2, mp)\\n\\n\\t}\\n\\n\\treturn dfs(source[0], source[1], target[0], target[1], blockMp1) && dfs(target[0], target[1], source[0], source[1], blockMp2)\\n}\\n\\n\\n// \\u81EA\\u5B9A\\u4E49hash\\u4F18\\u5316\\nfunc hash(x, y int) int {\\n\\treturn x * 1000000 + y\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1661251,
                "title": "kotlin-a-search-but-problem-is-broken-in-the-leetcode-backend",
                "content": "```\\n\\nfun isEscapePossible(blocked: Array<IntArray>, source: IntArray, target: IntArray): Boolean {\\n    val blockedSet = HashSet<Pair<Int, Int>>()\\n    for (b in blocked) blockedSet.add(Pair(b[0], b[1]))\\n    fun h(x: Int, y: Int) = abs(target[0] - x) + abs(target[1] - y)\\n    data class Point(val x: Int, val y: Int, val cost: Int = 1000000, val h: Int = h(x,y))\\n    fun getInBoundsNeighbours(p: Point): List<Point> {\\n        val points = mutableListOf<Point>()\\n        if (p.x-1 >= 0 && Pair(p.x-1,p.y) !in blockedSet) points.add(Point(p.x-1, p.y, p.cost+1))\\n        if (p.y-1 >= 0 && Pair(p.x, p.y-1) !in blockedSet) points.add(Point(p.x, p.y-1, p.cost+1))\\n        if (p.x < 1000000 && Pair(p.x+1, p.y) !in blockedSet) points.add(Point(p.x+1, p.y, p.cost+1))\\n        if (p.y < 1000000 && Pair(p.x, p.y+1) !in blockedSet) points.add(Point(p.x, p.y+1, p.cost+1))\\n        return points\\n    }\\n    /* getInBoundsNeighbours */\\n    val frontier = PriorityQueue<Point>(compareBy { it.cost + it.h })\\n    frontier.add(Point(source[0], source[1], 0))\\n    val visited = HashMap<Pair<Int, Int>, Int>()\\n    while (!frontier.isEmpty()) {\\n        val p = frontier.poll()\\n        visited.put(Pair(p.x, p.y), p.cost)\\n        if (p.x == target[0] && p.y == target[1]) return true\\n        val neighbours = getInBoundsNeighbours(p)\\n        for (n in neighbours) {\\n            if (visited.contains(Pair(n.x, n.y))) {\\n                if (visited[Pair(n.x, n.y)]!! > n.cost) {\\n                    frontier.add(n)\\n                }\\n            } else {\\n                frontier.add(n)\\n            }\\n        }\\n    }\\n    return false\\n}\\n```",
                "solutionTags": [],
                "code": "```\\n\\nfun isEscapePossible(blocked: Array<IntArray>, source: IntArray, target: IntArray): Boolean {\\n    val blockedSet = HashSet<Pair<Int, Int>>()\\n    for (b in blocked) blockedSet.add(Pair(b[0], b[1]))\\n    fun h(x: Int, y: Int) = abs(target[0] - x) + abs(target[1] - y)\\n    data class Point(val x: Int, val y: Int, val cost: Int = 1000000, val h: Int = h(x,y))\\n    fun getInBoundsNeighbours(p: Point): List<Point> {\\n        val points = mutableListOf<Point>()\\n        if (p.x-1 >= 0 && Pair(p.x-1,p.y) !in blockedSet) points.add(Point(p.x-1, p.y, p.cost+1))\\n        if (p.y-1 >= 0 && Pair(p.x, p.y-1) !in blockedSet) points.add(Point(p.x, p.y-1, p.cost+1))\\n        if (p.x < 1000000 && Pair(p.x+1, p.y) !in blockedSet) points.add(Point(p.x+1, p.y, p.cost+1))\\n        if (p.y < 1000000 && Pair(p.x, p.y+1) !in blockedSet) points.add(Point(p.x, p.y+1, p.cost+1))\\n        return points\\n    }\\n    /* getInBoundsNeighbours */\\n    val frontier = PriorityQueue<Point>(compareBy { it.cost + it.h })\\n    frontier.add(Point(source[0], source[1], 0))\\n    val visited = HashMap<Pair<Int, Int>, Int>()\\n    while (!frontier.isEmpty()) {\\n        val p = frontier.poll()\\n        visited.put(Pair(p.x, p.y), p.cost)\\n        if (p.x == target[0] && p.y == target[1]) return true\\n        val neighbours = getInBoundsNeighbours(p)\\n        for (n in neighbours) {\\n            if (visited.contains(Pair(n.x, n.y))) {\\n                if (visited[Pair(n.x, n.y)]!! > n.cost) {\\n                    frontier.add(n)\\n                }\\n            } else {\\n                frontier.add(n)\\n            }\\n        }\\n    }\\n    return false\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1637714,
                "title": "coordinates-compression-java-26ms",
                "content": "```\\nclass Solution {\\n    public boolean isEscapePossible(int[][] blocked, int[] source, int[] target) {\\n        Set<Integer> sx = new HashSet<>();\\n        Set<Integer> sy = new HashSet<>();\\n        for (int[] block : blocked) {\\n            sx.add(block[0]);\\n            sy.add(block[1]);\\n        }\\n        sx.add(source[0]);\\n        sy.add(source[1]);\\n        sx.add(target[0]);\\n        sy.add(target[1]);\\n        List<Integer> ax = sx.stream().sorted().collect(Collectors.toList());\\n        List<Integer> ay = sy.stream().sorted().collect(Collectors.toList());\\n        List<Integer> nx = new ArrayList<>();\\n        List<Integer> ny = new ArrayList<>();\\n        int pre = -1;\\n        for (int i : ax) {\\n            if (pre < i - 1) {\\n                nx.add(pre + 1);\\n            }\\n            nx.add(i);\\n            pre = i;\\n        }\\n        if (pre < 999999) nx.add(pre + 1);\\n        pre = -1;\\n        for (int i : ay) {\\n            if (pre < i - 1) {\\n                ny.add(pre + 1);\\n            }\\n            ny.add(i);\\n            pre = i;\\n        }\\n        if (pre < 999999) ny.add(pre + 1);\\n        int[] x = nx.stream().mapToInt(Integer::intValue).toArray();\\n        int[] y = ny.stream().mapToInt(Integer::intValue).toArray();\\n        boolean[][] b = new boolean[x.length][y.length];\\n        for (int[] block : blocked) {\\n            b[Arrays.binarySearch(x, block[0])][Arrays.binarySearch(y, block[1])] = true;\\n        }\\n        int sourceX = Arrays.binarySearch(x, source[0]);\\n        int sourceY = Arrays.binarySearch(y, source[1]);\\n        int targetX = Arrays.binarySearch(x, target[0]);\\n        int targetY = Arrays.binarySearch(y, target[1]);\\n        if (b[sourceX][sourceY] || b[targetX][targetY]) {\\n            return false;\\n        }\\n        Queue<Integer> qx = new LinkedList<>();\\n        Queue<Integer> qy = new LinkedList<>();\\n        qx.offer(sourceX);\\n        qy.offer(sourceY);\\n        int[][] dirs = new int[][]{{-1,0},{1,0},{0,1},{0,-1}};\\n        while (!qx.isEmpty()) {\\n            int size = qx.size();\\n            int cx = qx.poll();\\n            int cy = qy.poll();\\n            if (cx == targetX && cy == targetY) return true;\\n            for (int[] dir : dirs) {\\n                if (0 <= cx + dir[0] && cx + dir[0] < x.length && 0 <= cy + dir[1] && cy + dir[1] < y.length) {\\n                    if (!b[cx + dir[0]][cy + dir[1]]) {\\n                        b[cx + dir[0]][cy + dir[1]] = true;\\n                        qx.offer(cx + dir[0]);\\n                        qy.offer(cy + dir[1]);\\n                    }\\n                }\\n            }\\n        }\\n        return false;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public boolean isEscapePossible(int[][] blocked, int[] source, int[] target) {\\n        Set<Integer> sx = new HashSet<>();\\n        Set<Integer> sy = new HashSet<>();\\n        for (int[] block : blocked) {\\n            sx.add(block[0]);\\n            sy.add(block[1]);\\n        }\\n        sx.add(source[0]);\\n        sy.add(source[1]);\\n        sx.add(target[0]);\\n        sy.add(target[1]);\\n        List<Integer> ax = sx.stream().sorted().collect(Collectors.toList());\\n        List<Integer> ay = sy.stream().sorted().collect(Collectors.toList());\\n        List<Integer> nx = new ArrayList<>();\\n        List<Integer> ny = new ArrayList<>();\\n        int pre = -1;\\n        for (int i : ax) {\\n            if (pre < i - 1) {\\n                nx.add(pre + 1);\\n            }\\n            nx.add(i);\\n            pre = i;\\n        }\\n        if (pre < 999999) nx.add(pre + 1);\\n        pre = -1;\\n        for (int i : ay) {\\n            if (pre < i - 1) {\\n                ny.add(pre + 1);\\n            }\\n            ny.add(i);\\n            pre = i;\\n        }\\n        if (pre < 999999) ny.add(pre + 1);\\n        int[] x = nx.stream().mapToInt(Integer::intValue).toArray();\\n        int[] y = ny.stream().mapToInt(Integer::intValue).toArray();\\n        boolean[][] b = new boolean[x.length][y.length];\\n        for (int[] block : blocked) {\\n            b[Arrays.binarySearch(x, block[0])][Arrays.binarySearch(y, block[1])] = true;\\n        }\\n        int sourceX = Arrays.binarySearch(x, source[0]);\\n        int sourceY = Arrays.binarySearch(y, source[1]);\\n        int targetX = Arrays.binarySearch(x, target[0]);\\n        int targetY = Arrays.binarySearch(y, target[1]);\\n        if (b[sourceX][sourceY] || b[targetX][targetY]) {\\n            return false;\\n        }\\n        Queue<Integer> qx = new LinkedList<>();\\n        Queue<Integer> qy = new LinkedList<>();\\n        qx.offer(sourceX);\\n        qy.offer(sourceY);\\n        int[][] dirs = new int[][]{{-1,0},{1,0},{0,1},{0,-1}};\\n        while (!qx.isEmpty()) {\\n            int size = qx.size();\\n            int cx = qx.poll();\\n            int cy = qy.poll();\\n            if (cx == targetX && cy == targetY) return true;\\n            for (int[] dir : dirs) {\\n                if (0 <= cx + dir[0] && cx + dir[0] < x.length && 0 <= cy + dir[1] && cy + dir[1] < y.length) {\\n                    if (!b[cx + dir[0]][cy + dir[1]]) {\\n                        b[cx + dir[0]][cy + dir[1]] = true;\\n                        qx.offer(cx + dir[0]);\\n                        qy.offer(cy + dir[1]);\\n                    }\\n                }\\n            }\\n        }\\n        return false;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1569856,
                "title": "python-144-ms-bfs-dsu-connected-blocked-regions-covered-by-rectangles",
                "content": "So, we have some blocked cells, let\\'s cover all them with rectangles (+). Now if our source and target are outside of rectangles, return true. \\nElse, just start bfs-ing from source and target if they both reach the region outside of rectangles or they reach each other, return true. If else, that means they got stuck in some region bounded by blocked cells and cant reach each other, return false in this case.\\n\\n(+) How to cover with rectangles? In general, if blocked cells are too much apart from each other covering them with one single rectangle is not optimal. We should find connected regions of blocked cells using DSU, and cover the same connected region with one rectangle. If some connected region has k blocked cells, it at most neads k by k rectangle to cover it. We record the cells inside rectangles in some set, which takes us k ^ 2 time for each rectangle, and in worst case in sum we perform 200 ^ 2 operations. Two runs of bfs inside these regions (before they reach cell outside of rectangles) takes us complexity linear to the number of cells in rectangles.\\n\\n```\\nfrom collections import deque\\n\\nclass DSU:\\n    def __init__(self, elements):\\n        self.rnk = {el: 0 for el in elements}\\n        self.pr = {el: el for el in elements}\\n        self.s = {el: {el} for el in elements}\\n\\n    def find(self, x):\\n        if self.pr[x] != x:\\n            self.pr[x] = self.find(self.pr[x])\\n        return self.pr[x]\\n\\n    def union(self, x, y):\\n        px, py = self.find(x), self.find(y)\\n        if px == py: return False\\n        if self.rnk[py] > self.rnk[px]: px, py = py, px\\n        self.pr[py] = px\\n        self.s[px] |= self.s[py]\\n        self.rnk[px] += 1 if self.rnk[px] == self.rnk[py] else 0\\n        return True\\n\\n\\nclass Solution:\\n    def isEscapePossible(self, blocked, source, target):\\n        source, target = tuple(source), tuple(target)\\n        blocked = {tuple(b) for b in blocked}\\n        dsu = DSU(blocked)\\n        can_go = lambda dx, dy: (dx, dy) not in blocked and 0 <= dx < 10 ** 6 and 0 <= dy < 10 ** 6\\n        nbs = lambda x, y: [(dx, dy) for dx in [x - 1, x, x + 1] for dy in [y - 1, y, y + 1]]\\n\\n        for b in blocked:\\n            for nb in nbs(*b):\\n                if nb in blocked:\\n                    dsu.union(b, nb)\\n\\n        def get_rect(cells):\\n            min_x, max_x = min(x for x, y in cells), max(x for x, y in cells)\\n            min_y, max_y = min(y for x, y in cells), max(y for x, y in cells)\\n\\n            return [(x, y) for x in range(min_x, max_x + 1) for y in range(min_y, max_y + 1)]\\n\\n        closed = set()\\n        unique_comps = {dsu.find(b) for b in blocked}\\n        for uq in unique_comps:\\n            for x, y in get_rect(dsu.s[uq]):\\n                closed.add((x, y))\\n\\n        def bfs(start, finish):\\n            q = deque([start])\\n            attended = {start}\\n\\n            while len(q):\\n                x, y = q.popleft()\\n                if (x, y) == finish:\\n                    return 2\\n                if (x, y) not in closed:\\n                    return 1\\n\\n                for dx, dy in [(x + 1, y), (x - 1, y), (x, y + 1), (x, y - 1)]:\\n                    if (dx, dy) not in attended and can_go(dx, dy):\\n                        attended.add((dx, dy))\\n                        q.append((dx, dy))\\n            return 0\\n\\n        return bfs(source, target) + bfs(target, source) >= 2\\n```",
                "solutionTags": [],
                "code": "```\\nfrom collections import deque\\n\\nclass DSU:\\n    def __init__(self, elements):\\n        self.rnk = {el: 0 for el in elements}\\n        self.pr = {el: el for el in elements}\\n        self.s = {el: {el} for el in elements}\\n\\n    def find(self, x):\\n        if self.pr[x] != x:\\n            self.pr[x] = self.find(self.pr[x])\\n        return self.pr[x]\\n\\n    def union(self, x, y):\\n        px, py = self.find(x), self.find(y)\\n        if px == py: return False\\n        if self.rnk[py] > self.rnk[px]: px, py = py, px\\n        self.pr[py] = px\\n        self.s[px] |= self.s[py]\\n        self.rnk[px] += 1 if self.rnk[px] == self.rnk[py] else 0\\n        return True\\n\\n\\nclass Solution:\\n    def isEscapePossible(self, blocked, source, target):\\n        source, target = tuple(source), tuple(target)\\n        blocked = {tuple(b) for b in blocked}\\n        dsu = DSU(blocked)\\n        can_go = lambda dx, dy: (dx, dy) not in blocked and 0 <= dx < 10 ** 6 and 0 <= dy < 10 ** 6\\n        nbs = lambda x, y: [(dx, dy) for dx in [x - 1, x, x + 1] for dy in [y - 1, y, y + 1]]\\n\\n        for b in blocked:\\n            for nb in nbs(*b):\\n                if nb in blocked:\\n                    dsu.union(b, nb)\\n\\n        def get_rect(cells):\\n            min_x, max_x = min(x for x, y in cells), max(x for x, y in cells)\\n            min_y, max_y = min(y for x, y in cells), max(y for x, y in cells)\\n\\n            return [(x, y) for x in range(min_x, max_x + 1) for y in range(min_y, max_y + 1)]\\n\\n        closed = set()\\n        unique_comps = {dsu.find(b) for b in blocked}\\n        for uq in unique_comps:\\n            for x, y in get_rect(dsu.s[uq]):\\n                closed.add((x, y))\\n\\n        def bfs(start, finish):\\n            q = deque([start])\\n            attended = {start}\\n\\n            while len(q):\\n                x, y = q.popleft()\\n                if (x, y) == finish:\\n                    return 2\\n                if (x, y) not in closed:\\n                    return 1\\n\\n                for dx, dy in [(x + 1, y), (x - 1, y), (x, y + 1), (x, y - 1)]:\\n                    if (dx, dy) not in attended and can_go(dx, dy):\\n                        attended.add((dx, dy))\\n                        q.append((dx, dy))\\n            return 0\\n\\n        return bfs(source, target) + bfs(target, source) >= 2\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1515072,
                "title": "java-recursive-dfs",
                "content": "```\\nclass Solution {\\n    int max = 1000000;\\n    int blockSize = 0;\\n    public boolean isEscapePossible(int[][] blocked, int[] source, int[] target) {\\n        Set<String> set1 = new HashSet();\\n        Set<String> set2 = new HashSet();\\n        if(blocked.length == 0) {\\n            return true;\\n        }\\n        blockSize = blocked.length * (blocked.length+1);\\n        for(int[] a:blocked) {\\n            set1.add(a[0]+\"-\"+a[1]);\\n            set2.add(a[0]+\"-\"+a[1]);\\n        }\\n        \\n        return check(set1, source[0], source[1], target, 0) && check(set2, target[0], target[1], source, 0);\\n        \\n    }\\n    int row[] = {0,0,1,-1};\\n    int col[] = {1,-1,0,0};\\n    public boolean check(Set<String> visited, int i, int j, int[] target, int radius) {\\n        if(i < 0 || j < 0 || i>= max || j>= max) {\\n            return false;\\n        }\\n        if( i == target[0] && j == target[1]) {\\n            return true;\\n        }\\n        if(visited.contains(i+\"-\"+j)) {\\n            return false;\\n        }\\n        if(radius>blockSize) {\\n            return true;\\n        }\\n        visited.add(i+\"-\"+j);\\n        boolean res = false;\\n        for(int k = 0; k < 4; k++) {\\n            res = res || check(visited, i + row[k], j + col[k], target, radius+1) ;\\n            visited.add(i+\"-\"+j);\\n        }\\n        return res;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    int max = 1000000;\\n    int blockSize = 0;\\n    public boolean isEscapePossible(int[][] blocked, int[] source, int[] target) {\\n        Set<String> set1 = new HashSet();\\n        Set<String> set2 = new HashSet();\\n        if(blocked.length == 0) {\\n            return true;\\n        }\\n        blockSize = blocked.length * (blocked.length+1);\\n        for(int[] a:blocked) {\\n            set1.add(a[0]+\"-\"+a[1]);\\n            set2.add(a[0]+\"-\"+a[1]);\\n        }\\n        \\n        return check(set1, source[0], source[1], target, 0) && check(set2, target[0], target[1], source, 0);\\n        \\n    }\\n    int row[] = {0,0,1,-1};\\n    int col[] = {1,-1,0,0};\\n    public boolean check(Set<String> visited, int i, int j, int[] target, int radius) {\\n        if(i < 0 || j < 0 || i>= max || j>= max) {\\n            return false;\\n        }\\n        if( i == target[0] && j == target[1]) {\\n            return true;\\n        }\\n        if(visited.contains(i+\"-\"+j)) {\\n            return false;\\n        }\\n        if(radius>blockSize) {\\n            return true;\\n        }\\n        visited.add(i+\"-\"+j);\\n        boolean res = false;\\n        for(int k = 0; k < 4; k++) {\\n            res = res || check(visited, i + row[k], j + col[k], target, radius+1) ;\\n            visited.add(i+\"-\"+j);\\n        }\\n        return res;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1447998,
                "title": "bfs-approach",
                "content": "```\\n#define vvi vector<vector<int>>\\n#define vi vector<int>\\nclass Solution {\\npublic:\\n    bool isEscapePossible(vvi& b, vi& s, vi& t) {\\n        int n=b.size(),i,diff=0;\\n        bool fs=0,ft=0;\\n        int mxx=1e5;\\n        int mr=s[0],mc=s[1];\\n        \\n        set<vector<int>> blk,vis;\\n        for(auto v:b)\\n            blk.insert(v);\\n        \\n        queue<vector<int>> q;\\n        q.push({s[0],s[1]});\\n        vis.insert({s[0],s[1]});\\n        \\n        while(q.size()){\\n            vector<int> p=q.front();\\n            q.pop();\\n            diff=max({diff,abs(p[1]-s[1]),abs(p[0]-s[0])});\\n            \\n            if(p==t)\\n                return 1;\\n            \\n            if(diff>=b.size()){\\n                fs=1;\\n                break;\\n            }\\n            \\n            if(p[0]+1<mxx && blk.find({p[0]+1,p[1]})==blk.end() && vis.find({p[0]+1,p[1]})==vis.end()){\\n                q.push({p[0]+1,p[1]});\\n                vis.insert({p[0]+1,p[1]});\\n            }\\n            \\n            if(p[1]+1<mxx && blk.find({p[0],p[1]+1})==blk.end() && vis.find({p[0],p[1]+1})==vis.end()){\\n                q.push({p[0],p[1]+1});\\n                vis.insert({p[0],p[1]+1});\\n            }\\n            \\n            if(p[0] && blk.find({p[0]-1,p[1]})==blk.end() && vis.find({p[0]-1,p[1]})==vis.end()){\\n                q.push({p[0]-1,p[1]});\\n                vis.insert({p[0]-1,p[1]});\\n            }\\n            \\n            if(p[1] && blk.find({p[0],p[1]-1})==blk.end() && vis.find({p[0],p[1]-1})==vis.end()){\\n                q.push({p[0],p[1]-1});\\n                vis.insert({p[0],p[1]-1});\\n            }\\n        }\\n        \\n        if(!fs)\\n            return 0;\\n        \\n        mr=t[0],mc=t[1];\\n        while(q.size())\\n            q.pop();\\n        \\n        vis.clear();\\n        \\n        q.push({t[0],t[1]});\\n        vis.insert({t[0],t[1]});\\n        diff=0;\\n        \\n        while(q.size()){\\n            vector<int> p=q.front();\\n            q.pop();\\n            \\n            diff=max({diff,abs(p[1]-t[1]),abs(p[0]-t[0])});\\n            \\n            if(p==s)\\n                return 1;\\n            \\n            if(diff>=b.size()){\\n                ft=1;\\n                break;\\n            }\\n            \\n            if(p[0]+1<mxx && blk.find({p[0]+1,p[1]})==blk.end() && vis.find({p[0]+1,p[1]})==vis.end()){\\n                q.push({p[0]+1,p[1]});\\n                vis.insert({p[0]+1,p[1]});\\n            }\\n            \\n            if(p[1]+1<mxx && blk.find({p[0],p[1]+1})==blk.end() && vis.find({p[0],p[1]+1})==vis.end()){\\n                q.push({p[0],p[1]+1});\\n                vis.insert({p[0],p[1]+1});\\n            }\\n            \\n            if(p[0] && blk.find({p[0]-1,p[1]})==blk.end() && vis.find({p[0]-1,p[1]})==vis.end()){\\n                q.push({p[0]-1,p[1]});\\n                vis.insert({p[0]-1,p[1]});\\n            }\\n            \\n            if(p[1] && blk.find({p[0],p[1]-1})==blk.end() && vis.find({p[0],p[1]-1})==vis.end()){\\n                q.push({p[0],p[1]-1});\\n                vis.insert({p[0],p[1]-1});\\n            }\\n        }\\n        \\n        if(!ft)\\n            return 0;\\n        return 1;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Math",
                    "Breadth-First Search"
                ],
                "code": "```\\n#define vvi vector<vector<int>>\\n#define vi vector<int>\\nclass Solution {\\npublic:\\n    bool isEscapePossible(vvi& b, vi& s, vi& t) {\\n        int n=b.size(),i,diff=0;\\n        bool fs=0,ft=0;\\n        int mxx=1e5;\\n        int mr=s[0],mc=s[1];\\n        \\n        set<vector<int>> blk,vis;\\n        for(auto v:b)\\n            blk.insert(v);\\n        \\n        queue<vector<int>> q;\\n        q.push({s[0],s[1]});\\n        vis.insert({s[0],s[1]});\\n        \\n        while(q.size()){\\n            vector<int> p=q.front();\\n            q.pop();\\n            diff=max({diff,abs(p[1]-s[1]),abs(p[0]-s[0])});\\n            \\n            if(p==t)\\n                return 1;\\n            \\n            if(diff>=b.size()){\\n                fs=1;\\n                break;\\n            }\\n            \\n            if(p[0]+1<mxx && blk.find({p[0]+1,p[1]})==blk.end() && vis.find({p[0]+1,p[1]})==vis.end()){\\n                q.push({p[0]+1,p[1]});\\n                vis.insert({p[0]+1,p[1]});\\n            }\\n            \\n            if(p[1]+1<mxx && blk.find({p[0],p[1]+1})==blk.end() && vis.find({p[0],p[1]+1})==vis.end()){\\n                q.push({p[0],p[1]+1});\\n                vis.insert({p[0],p[1]+1});\\n            }\\n            \\n            if(p[0] && blk.find({p[0]-1,p[1]})==blk.end() && vis.find({p[0]-1,p[1]})==vis.end()){\\n                q.push({p[0]-1,p[1]});\\n                vis.insert({p[0]-1,p[1]});\\n            }\\n            \\n            if(p[1] && blk.find({p[0],p[1]-1})==blk.end() && vis.find({p[0],p[1]-1})==vis.end()){\\n                q.push({p[0],p[1]-1});\\n                vis.insert({p[0],p[1]-1});\\n            }\\n        }\\n        \\n        if(!fs)\\n            return 0;\\n        \\n        mr=t[0],mc=t[1];\\n        while(q.size())\\n            q.pop();\\n        \\n        vis.clear();\\n        \\n        q.push({t[0],t[1]});\\n        vis.insert({t[0],t[1]});\\n        diff=0;\\n        \\n        while(q.size()){\\n            vector<int> p=q.front();\\n            q.pop();\\n            \\n            diff=max({diff,abs(p[1]-t[1]),abs(p[0]-t[0])});\\n            \\n            if(p==s)\\n                return 1;\\n            \\n            if(diff>=b.size()){\\n                ft=1;\\n                break;\\n            }\\n            \\n            if(p[0]+1<mxx && blk.find({p[0]+1,p[1]})==blk.end() && vis.find({p[0]+1,p[1]})==vis.end()){\\n                q.push({p[0]+1,p[1]});\\n                vis.insert({p[0]+1,p[1]});\\n            }\\n            \\n            if(p[1]+1<mxx && blk.find({p[0],p[1]+1})==blk.end() && vis.find({p[0],p[1]+1})==vis.end()){\\n                q.push({p[0],p[1]+1});\\n                vis.insert({p[0],p[1]+1});\\n            }\\n            \\n            if(p[0] && blk.find({p[0]-1,p[1]})==blk.end() && vis.find({p[0]-1,p[1]})==vis.end()){\\n                q.push({p[0]-1,p[1]});\\n                vis.insert({p[0]-1,p[1]});\\n            }\\n            \\n            if(p[1] && blk.find({p[0],p[1]-1})==blk.end() && vis.find({p[0],p[1]-1})==vis.end()){\\n                q.push({p[0],p[1]-1});\\n                vis.insert({p[0],p[1]-1});\\n            }\\n        }\\n        \\n        if(!ft)\\n            return 0;\\n        return 1;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1442549,
                "title": "c-660ms-34-double-bfs-very-simple-idea",
                "content": "Runtime: 660 ms, faster than 34.34% of C++ online submissions for Escape a Large Maze.\\nMemory Usage: 74.8 MB, less than 45.78% of C++ online submissions for Escape a Large Maze.\\n```\\nclass Solution {\\npublic: \\n  bool isEscapePossible(vector<vector<int>>& blocked, vector<int>& source, vector<int>& target) {\\n    if(blocked.size() < 2) return true;\\n    set<pair<int,int>> visited, obstacles;\\n    int y = 999999, x = 999999;\\n    \\n    for(auto &b: blocked) obstacles.insert({b[1],b[0]});\\n    \\n    queue<pair<int,int>> q;\\n    q.push({source[1], source[0]});\\n    int lim = blocked.size();\\n    while(!q.empty()){\\n      if(--lim == 0) goto mark;\\n      int n = q.size();\\n      \\n      while(n--){\\n        auto[ty, tx] = q.front(); q.pop();\\n        if(visited.count({ty,tx})) continue;\\n        if(ty == target[1] && tx == target[0]) return true;\\n        visited.insert({ty,tx});\\n      \\n        if(ty && !visited.count({ty-1,tx}) && !obstacles.count({ty-1,tx})) q.push({ty-1, tx});\\n        if(tx && !visited.count({ty,tx-1}) && !obstacles.count({ty,tx-1})) q.push({ty, tx-1});\\n        if(ty != y && !visited.count({ty+1,tx}) && !obstacles.count({ty+1,tx})) q.push({ty+1, tx});\\n        if(tx != x && !visited.count({ty,tx+1}) && !obstacles.count({ty,tx+1})) q.push({ty, tx+1});\\n      }\\n    }\\n    return false;\\n    \\n    mark:;\\n    \\n    visited.clear();\\n    while(!q.empty()) q.pop();\\n    q.push({target[1], target[0]});\\n    lim = blocked.size();\\n    while(!q.empty()){\\n      if(--lim == 0) return true;\\n      int n = q.size();\\n      \\n      while(n--){\\n        auto[ty, tx] = q.front(); q.pop();\\n        if(visited.count({ty,tx})) continue;\\n        visited.insert({ty,tx});\\n      \\n        if(ty && !visited.count({ty-1,tx}) && !obstacles.count({ty-1,tx})) q.push({ty-1, tx});\\n        if(tx && !visited.count({ty,tx-1}) && !obstacles.count({ty,tx-1})) q.push({ty, tx-1});\\n        if(ty != y && !visited.count({ty+1,tx}) && !obstacles.count({ty+1,tx})) q.push({ty+1, tx});\\n        if(tx != x && !visited.count({ty,tx+1}) && !obstacles.count({ty,tx+1})) q.push({ty, tx+1});\\n      }\\n    }\\n    \\n    return false;\\n  }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic: \\n  bool isEscapePossible(vector<vector<int>>& blocked, vector<int>& source, vector<int>& target) {\\n    if(blocked.size() < 2) return true;\\n    set<pair<int,int>> visited, obstacles;\\n    int y = 999999, x = 999999;\\n    \\n    for(auto &b: blocked) obstacles.insert({b[1],b[0]});\\n    \\n    queue<pair<int,int>> q;\\n    q.push({source[1], source[0]});\\n    int lim = blocked.size();\\n    while(!q.empty()){\\n      if(--lim == 0) goto mark;\\n      int n = q.size();\\n      \\n      while(n--){\\n        auto[ty, tx] = q.front(); q.pop();\\n        if(visited.count({ty,tx})) continue;\\n        if(ty == target[1] && tx == target[0]) return true;\\n        visited.insert({ty,tx});\\n      \\n        if(ty && !visited.count({ty-1,tx}) && !obstacles.count({ty-1,tx})) q.push({ty-1, tx});\\n        if(tx && !visited.count({ty,tx-1}) && !obstacles.count({ty,tx-1})) q.push({ty, tx-1});\\n        if(ty != y && !visited.count({ty+1,tx}) && !obstacles.count({ty+1,tx})) q.push({ty+1, tx});\\n        if(tx != x && !visited.count({ty,tx+1}) && !obstacles.count({ty,tx+1})) q.push({ty, tx+1});\\n      }\\n    }\\n    return false;\\n    \\n    mark:;\\n    \\n    visited.clear();\\n    while(!q.empty()) q.pop();\\n    q.push({target[1], target[0]});\\n    lim = blocked.size();\\n    while(!q.empty()){\\n      if(--lim == 0) return true;\\n      int n = q.size();\\n      \\n      while(n--){\\n        auto[ty, tx] = q.front(); q.pop();\\n        if(visited.count({ty,tx})) continue;\\n        visited.insert({ty,tx});\\n      \\n        if(ty && !visited.count({ty-1,tx}) && !obstacles.count({ty-1,tx})) q.push({ty-1, tx});\\n        if(tx && !visited.count({ty,tx-1}) && !obstacles.count({ty,tx-1})) q.push({ty, tx-1});\\n        if(ty != y && !visited.count({ty+1,tx}) && !obstacles.count({ty+1,tx})) q.push({ty+1, tx});\\n        if(tx != x && !visited.count({ty,tx+1}) && !obstacles.count({ty,tx+1})) q.push({ty, tx+1});\\n      }\\n    }\\n    \\n    return false;\\n  }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1396114,
                "title": "c-beats-100-space-and-time",
                "content": "This version of solution beats 100% other submissions in time and space. O(N^2) in space and time where N = 202 (the max size of the blocked array)\\n\\nBasically the algorithm is:\\n* Find the x and y range of the blocked elements\\n* Create a grid for this range, adding the blockades\\n* BFS to determine how many \"regions\" are present in the grid. For example, there may be 1 region covered by the blockades. And another region free of any blockades.\\n* If the source and target belong in the same regions, we can escape\\n\\n```\\nclass Solution {\\n    int grid_size = 1000000;\\npublic:\\n    bool isEscapePossible(vector<vector<int>>& blocked, vector<int>& source, vector<int>& target) {\\n        if (blocked.empty()) return true;\\n        \\n        // Look inside the blocked array and figure out the range of x and y in the blocked array\\n        pair<int,int> range_x = {blocked[0][0],blocked[0][0]};\\n        pair<int,int> range_y = {blocked[0][1],blocked[0][1]};\\n        for (auto a : blocked) // O(N) - n = size of the block\\n        {\\n            range_x.first = min(range_x.first, a[0]);\\n            range_x.second = max(range_x.second, a[0]);\\n            \\n            range_y.first = min(range_y.first, a[1]);\\n            range_y.second = max(range_y.second, a[1]);\\n        }\\n        // Adding boundaries such that we have a layer that can be walked on!\\n        if (range_x.first > 0) range_x.first--;\\n        if (range_x.second < grid_size-1) range_x.second++;\\n        if (range_y.first > 0) range_y.first--;\\n        if (range_y.second < grid_size-1) range_y.second++;\\n        \\n        // Find the size of the grid that we\\'d be working with\\n        // Note that this shouldn\\'t be bigger than the max possible size of the blocked array + 2 (which is 200 + 2 = 202)\\n        int m = range_x.second - range_x.first + 1;\\n        int n = range_y.second - range_y.first + 1;\\n        \\n        int max_possible_size = 202;\\n        if (m > max_possible_size || n > max_possible_size) return true;\\n                \\n        // Create the grid\\n        vector<vector<int>> grid(m, vector<int>(n, -1)); // O(n^2) space and time\\n        \\n        // Add the blockage inside the grid\\n        for (auto a : blocked) // O(n) time\\n        {\\n            int x = a[0] - range_x.first;\\n            int y = a[1] - range_y.first;\\n            grid[x][y] = 0; // 0 stands for blocked area\\n        }\\n                \\n        // DFS to find the regions\\n        int total_region = DFSToFindRegions(grid); // O(n^2) time        \\n        if (total_region < 2) return true;\\n        \\n        // Now check if the source and target are in the same region.\\n        // If they are, they should be good.\\n        int a = RegionNumber(grid, source, range_x, range_y);\\n        int b = RegionNumber(grid, target, range_x, range_y);\\n        \\n        return a == b;\\n    }\\n    \\n    int RegionNumber(vector<vector<int>>& grid, vector<int>& point, pair<int,int>& range_x, pair<int,int>& range_y)\\n    {\\n        int x = point[0] - range_x.first;\\n        int y = point[1] - range_y.first;\\n        \\n        if (x < 0) x = 0;\\n        if (x >= grid.size()) x = grid.size()-1;\\n        \\n        if (y < 0) y = 0;\\n        if (y >= grid[x].size()) y = grid[x].size()-1;\\n        \\n        return grid[x][y];\\n    }\\n    \\n    int DFSToFindRegions(vector<vector<int>>& grid)\\n    {\\n        int region_size = 0;\\n        for (int i = 0; i < grid.size(); ++i)\\n        {\\n            for (int j = 0; j < grid[i].size(); ++j)\\n            {\\n                if (grid[i][j] == -1) visit(++region_size, grid, i, j);    \\n            }\\n        }\\n        return region_size;\\n    }\\n    \\n    void visit(int val, vector<vector<int>>& grid, int i, int j)\\n    {\\n        if (i < 0 || i >= grid.size() || j < 0 || j >= grid[i].size() || grid[i][j] != -1) return;\\n        grid[i][j] = val;\\n        visit(val, grid, i, j+1);\\n        visit(val, grid, i, j-1);\\n        visit(val, grid, i+1, j);\\n        visit(val, grid, i-1, j);\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    int grid_size = 1000000;\\npublic:\\n    bool isEscapePossible(vector<vector<int>>& blocked, vector<int>& source, vector<int>& target) {\\n        if (blocked.empty()) return true;\\n        \\n        // Look inside the blocked array and figure out the range of x and y in the blocked array\\n        pair<int,int> range_x = {blocked[0][0],blocked[0][0]};\\n        pair<int,int> range_y = {blocked[0][1],blocked[0][1]};\\n        for (auto a : blocked) // O(N) - n = size of the block\\n        {\\n            range_x.first = min(range_x.first, a[0]);\\n            range_x.second = max(range_x.second, a[0]);\\n            \\n            range_y.first = min(range_y.first, a[1]);\\n            range_y.second = max(range_y.second, a[1]);\\n        }\\n        // Adding boundaries such that we have a layer that can be walked on!\\n        if (range_x.first > 0) range_x.first--;\\n        if (range_x.second < grid_size-1) range_x.second++;\\n        if (range_y.first > 0) range_y.first--;\\n        if (range_y.second < grid_size-1) range_y.second++;\\n        \\n        // Find the size of the grid that we\\'d be working with\\n        // Note that this shouldn\\'t be bigger than the max possible size of the blocked array + 2 (which is 200 + 2 = 202)\\n        int m = range_x.second - range_x.first + 1;\\n        int n = range_y.second - range_y.first + 1;\\n        \\n        int max_possible_size = 202;\\n        if (m > max_possible_size || n > max_possible_size) return true;\\n                \\n        // Create the grid\\n        vector<vector<int>> grid(m, vector<int>(n, -1)); // O(n^2) space and time\\n        \\n        // Add the blockage inside the grid\\n        for (auto a : blocked) // O(n) time\\n        {\\n            int x = a[0] - range_x.first;\\n            int y = a[1] - range_y.first;\\n            grid[x][y] = 0; // 0 stands for blocked area\\n        }\\n                \\n        // DFS to find the regions\\n        int total_region = DFSToFindRegions(grid); // O(n^2) time        \\n        if (total_region < 2) return true;\\n        \\n        // Now check if the source and target are in the same region.\\n        // If they are, they should be good.\\n        int a = RegionNumber(grid, source, range_x, range_y);\\n        int b = RegionNumber(grid, target, range_x, range_y);\\n        \\n        return a == b;\\n    }\\n    \\n    int RegionNumber(vector<vector<int>>& grid, vector<int>& point, pair<int,int>& range_x, pair<int,int>& range_y)\\n    {\\n        int x = point[0] - range_x.first;\\n        int y = point[1] - range_y.first;\\n        \\n        if (x < 0) x = 0;\\n        if (x >= grid.size()) x = grid.size()-1;\\n        \\n        if (y < 0) y = 0;\\n        if (y >= grid[x].size()) y = grid[x].size()-1;\\n        \\n        return grid[x][y];\\n    }\\n    \\n    int DFSToFindRegions(vector<vector<int>>& grid)\\n    {\\n        int region_size = 0;\\n        for (int i = 0; i < grid.size(); ++i)\\n        {\\n            for (int j = 0; j < grid[i].size(); ++j)\\n            {\\n                if (grid[i][j] == -1) visit(++region_size, grid, i, j);    \\n            }\\n        }\\n        return region_size;\\n    }\\n    \\n    void visit(int val, vector<vector<int>>& grid, int i, int j)\\n    {\\n        if (i < 0 || i >= grid.size() || j < 0 || j >= grid[i].size() || grid[i][j] != -1) return;\\n        grid[i][j] = val;\\n        visit(val, grid, i, j+1);\\n        visit(val, grid, i, j-1);\\n        visit(val, grid, i+1, j);\\n        visit(val, grid, i-1, j);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1292998,
                "title": "c-1036-escape-a-large-maze",
                "content": "\\n```\\nclass Solution {\\npublic:\\n    bool isEscapePossible(vector<vector<int>>& blocked, vector<int>& source, vector<int>& target) {\\n        vector<int> dir = {1, 0, -1, 0, 1}; \\n        \\n        unordered_set<long long> forbid; \\n        for (auto blk : blocked) forbid.insert(((long long)blk[0] << 32) + blk[1]); \\n        \\n        function<bool(int, int, int, int)> dfs = [&](int sx, int sy, int tx, int ty) {\\n            stack<pair<int, int>> stk; \\n            stk.emplace(sx, sy); \\n            unordered_set<long long> seen = {((long long)sx << 32) + sy}; \\n            while (stk.size()) {\\n                auto [x, y] = stk.top(); stk.pop(); \\n                if (abs(x - sx) + abs(y - sy) > 200 || x == tx && y == ty) return true; \\n                for (int k = 0; k < 4; ++k) {\\n                    int xx = x + dir[k], yy = y + dir[k+1]; \\n                    if (0 <= xx && xx < 1e6 && 0 <= yy && yy < 1e6) {\\n                        long long key = ((long long)xx << 32) + yy; \\n                        if (forbid.find(key) == forbid.end() && seen.find(key) == seen.end()) {\\n                            stk.emplace(xx, yy); \\n                            seen.emplace(key); \\n                        }\\n                    }\\n                }\\n            }\\n            return false; \\n        }; \\n        \\n        return dfs(source[0], source[1], target[0], target[1]) && dfs(target[0], target[1], source[0], source[1]); \\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool isEscapePossible(vector<vector<int>>& blocked, vector<int>& source, vector<int>& target) {\\n        vector<int> dir = {1, 0, -1, 0, 1}; \\n        \\n        unordered_set<long long> forbid; \\n        for (auto blk : blocked) forbid.insert(((long long)blk[0] << 32) + blk[1]); \\n        \\n        function<bool(int, int, int, int)> dfs = [&](int sx, int sy, int tx, int ty) {\\n            stack<pair<int, int>> stk; \\n            stk.emplace(sx, sy); \\n            unordered_set<long long> seen = {((long long)sx << 32) + sy}; \\n            while (stk.size()) {\\n                auto [x, y] = stk.top(); stk.pop(); \\n                if (abs(x - sx) + abs(y - sy) > 200 || x == tx && y == ty) return true; \\n                for (int k = 0; k < 4; ++k) {\\n                    int xx = x + dir[k], yy = y + dir[k+1]; \\n                    if (0 <= xx && xx < 1e6 && 0 <= yy && yy < 1e6) {\\n                        long long key = ((long long)xx << 32) + yy; \\n                        if (forbid.find(key) == forbid.end() && seen.find(key) == seen.end()) {\\n                            stk.emplace(xx, yy); \\n                            seen.emplace(key); \\n                        }\\n                    }\\n                }\\n            }\\n            return false; \\n        }; \\n        \\n        return dfs(source[0], source[1], target[0], target[1]) && dfs(target[0], target[1], source[0], source[1]); \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1274220,
                "title": "c-solution",
                "content": "```\\npublic class Solution {\\n    private  int MAX_VISIT = 20000;\\n\\n        public  bool IsEscapePossible(int[][] blocked, int[] source, int[] target)\\n            {\\n            var blockedSet = new HashSet<string>();\\n            foreach (var point in blocked)\\n            {\\n                blockedSet.Add(getKeyValue(point));\\n            }\\n            return isCanVisit(blockedSet, source, getKeyValue(target)) && isCanVisit(blockedSet, target, getKeyValue(source));\\n        }\\n\\n        private  string getKeyValue(int[] point)\\n        {\\n            return point[0] + \",\" + point[1];\\n        }\\n\\n        private  bool isCanVisit(HashSet<String> blocked, int[] source, String targetKey)\\n        {\\n            var visited = new HashSet<string>();\\n            ceck(blocked, source, targetKey, visited);\\n            return visited.Count >= MAX_VISIT || visited.Contains(targetKey);\\n        }\\n\\n        private  void ceck(HashSet<string> blocked, int[] curr, string targetKey, HashSet<string> visited)\\n        {\\n            int i = curr[0], j = curr[1];\\n            if (i < 0 || j < 0 || i >= 1e6 || j >= 1e6) { return; }\\n\\n            String key = getKeyValue(curr);\\n            if (blocked.Contains(key)) { return; }\\n            if (visited.Count >= MAX_VISIT || visited.Contains(targetKey)) { return; }\\n\\n            if (visited.Contains(key)) { return; }\\n            visited.Add(key);\\n            ceck(blocked, new int[]{ i - 1, j }, targetKey, visited);\\n            ceck(blocked, new int[] { i + 1, j }, targetKey, visited);\\n            ceck(blocked, new int[] { i, j - 1 }, targetKey, visited);\\n            ceck(blocked, new int[] { i, j + 1 }, targetKey, visited);\\n        }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\npublic class Solution {\\n    private  int MAX_VISIT = 20000;\\n\\n        public  bool IsEscapePossible(int[][] blocked, int[] source, int[] target)\\n            {\\n            var blockedSet = new HashSet<string>();\\n            foreach (var point in blocked)\\n            {\\n                blockedSet.Add(getKeyValue(point));\\n            }\\n            return isCanVisit(blockedSet, source, getKeyValue(target)) && isCanVisit(blockedSet, target, getKeyValue(source));\\n        }\\n\\n        private  string getKeyValue(int[] point)\\n        {\\n            return point[0] + \",\" + point[1];\\n        }\\n\\n        private  bool isCanVisit(HashSet<String> blocked, int[] source, String targetKey)\\n        {\\n            var visited = new HashSet<string>();\\n            ceck(blocked, source, targetKey, visited);\\n            return visited.Count >= MAX_VISIT || visited.Contains(targetKey);\\n        }\\n\\n        private  void ceck(HashSet<string> blocked, int[] curr, string targetKey, HashSet<string> visited)\\n        {\\n            int i = curr[0], j = curr[1];\\n            if (i < 0 || j < 0 || i >= 1e6 || j >= 1e6) { return; }\\n\\n            String key = getKeyValue(curr);\\n            if (blocked.Contains(key)) { return; }\\n            if (visited.Count >= MAX_VISIT || visited.Contains(targetKey)) { return; }\\n\\n            if (visited.Contains(key)) { return; }\\n            visited.Add(key);\\n            ceck(blocked, new int[]{ i - 1, j }, targetKey, visited);\\n            ceck(blocked, new int[] { i + 1, j }, targetKey, visited);\\n            ceck(blocked, new int[] { i, j - 1 }, targetKey, visited);\\n            ceck(blocked, new int[] { i, j + 1 }, targetKey, visited);\\n        }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1117617,
                "title": "java-solution",
                "content": "```\\nclass Solution {\\n    private int[][] dirs={{0,1}, {0, -1}, {1,0}, {-1,0}};\\n    \\n    public boolean isEscapePossible(int[][] blocked, int[] source, int[] target) {\\n        Set<String> block=new HashSet<>();\\n        for(int[] p: blocked){\\n            block.add(p[0] + \"->\" + p[1]);\\n        }\\n        return dfs(source, target, source, block, new HashSet<>()) && dfs(target, source, target, block, new HashSet<>());\\n    }\\n    \\n    private boolean dfs(int[] source, int[] target, int[] cur, Set<String> block, Set<String> visited){\\n        if(cur[0] == target[0] && cur[1] == target[1]){\\n            return true;\\n        }\\n        \\n        if(Math.abs(source[0] - cur[0]) + Math.abs(source[1] - cur[1]) > 200){\\n            return true;\\n        }\\n        \\n        visited.add(cur[0] + \"->\" + cur[1]);\\n        for(int[] d: dirs){\\n            int r=d[0] + cur[0];\\n            int c=d[1]+cur[1];\\n            String str=r+\"->\" + c;\\n            \\n            if(r >= 0 && r < 1000000 && c >= 0 && c < 1000000 && !block.contains(str) && !visited.contains(str)){\\n                if(dfs(source, target, new int[] {r, c}, block, visited)){\\n                    return true;\\n                }\\n            }\\n        }\\n        return false;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    private int[][] dirs={{0,1}, {0, -1}, {1,0}, {-1,0}};\\n    \\n    public boolean isEscapePossible(int[][] blocked, int[] source, int[] target) {\\n        Set<String> block=new HashSet<>();\\n        for(int[] p: blocked){\\n            block.add(p[0] + \"->\" + p[1]);\\n        }\\n        return dfs(source, target, source, block, new HashSet<>()) && dfs(target, source, target, block, new HashSet<>());\\n    }\\n    \\n    private boolean dfs(int[] source, int[] target, int[] cur, Set<String> block, Set<String> visited){\\n        if(cur[0] == target[0] && cur[1] == target[1]){\\n            return true;\\n        }\\n        \\n        if(Math.abs(source[0] - cur[0]) + Math.abs(source[1] - cur[1]) > 200){\\n            return true;\\n        }\\n        \\n        visited.add(cur[0] + \"->\" + cur[1]);\\n        for(int[] d: dirs){\\n            int r=d[0] + cur[0];\\n            int c=d[1]+cur[1];\\n            String str=r+\"->\" + c;\\n            \\n            if(r >= 0 && r < 1000000 && c >= 0 && c < 1000000 && !block.contains(str) && !visited.contains(str)){\\n                if(dfs(source, target, new int[] {r, c}, block, visited)){\\n                    return true;\\n                }\\n            }\\n        }\\n        return false;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1070023,
                "title": "python3-see-if-any-cc-of-blocking-graph-surrounds-source-or-target",
                "content": "```\\nN = 1000000\\n\\nclass Solution:\\n    def getRect(self, points: Iterable[tuple[int, int]]) -> tuple[int, int, int, int]:\\n        min_x, max_x = inf, -inf\\n        min_y, max_y = inf, -inf\\n        for x, y in points:\\n            min_x, max_x = min(min_x, x), max(max_x, x)\\n            min_y, max_y = min(min_y, y), max(max_y, y)\\n        return min_x, max_x, min_y, max_y    \\n   \\n    def neighbors(self, x, y, diag=False) -> Iterator[tuple[int, int]]:\\n        min_x, max_x, min_y, max_y = 0, N-1, 0, N-1\\n        deltas = ((-1, 0), (+1, 0), (0, +1), (0, -1))\\n        if diag:\\n            deltas += ((-1, -1), (-1, +1), (+1, -1), (+1, +1))\\n        for dx, dy in deltas:\\n            nx, ny = x + dx, y + dy\\n            if min_x <= nx <= max_x and min_y <= ny <= max_y:\\n                yield nx, ny\\n\\n    def getBlockedGraph(self, blocked: set[tuple[int, int]]) -> dict[int, set[tuple[int, int]]]:\\n        graph = defaultdict(set)\\n        for x, y in blocked:\\n            for nei in self.neighbors(x, y, diag=True):\\n                if nei not in blocked:\\n                    continue\\n                graph[x, y].add(nei)\\n                graph[nei].add((x, y))\\n        return graph\\n    \\n    def dfsComp(self, start: tuple[int, int], \\n                      graph: dict[int, set[tuple[int, int]]]) -> set[int]: \\n        stack = [start]\\n        visited = set()\\n        while stack:\\n            node = stack.pop()\\n            if node in visited:\\n                continue\\n            else:\\n                visited.add(node)\\n            for child in graph[node]:\\n                stack.append(child)\\n        return visited\\n\\n    def getCC(self, graph: dict[int, set[tuple[int, int]]]) -> list[set[tuple[int, int]]]:\\n        visited = set()\\n        cc = []\\n        for node in graph:\\n            if node not in visited:\\n                comp = self.dfsComp(node, graph)\\n                cc.append(comp)\\n                visited |= comp\\n        return cc\\n    \\n    def isTrapped(self, p: tuple[int, int], comp: set[tuple[int, int]]) -> bool:\\n        stack = [p]\\n        visited = set()\\n        min_x, max_x, min_y, max_y = self.getRect(comp)\\n        while stack:\\n            node = stack.pop()\\n            if node in visited:\\n                continue\\n            else:\\n                visited.add(node)\\n            x, y = node\\n            if not (min_x <= x <= max_x) or not (min_y <= y <= max_y):\\n                return False\\n            for child in self.neighbors(x, y):\\n                if child not in comp:\\n                    stack.append(child)\\n        return True\\n    \\n    def isReachable(self, source: tuple[int, int], \\n                    target: tuple[int, int], blocked: set[tuple[int, int]]) -> bool:\\n        queue = deque([source])\\n        visited = {source}\\n        min_x, max_x, min_y, max_y = self.getRect(blocked)        \\n        while queue:\\n            node = queue.popleft()\\n            if node == target:\\n                return True\\n            x, y = node            \\n            if not (min_x <= x <= max_x and min_y <= y <= max_y):\\n                break\\n            for child in self.neighbors(x, y):\\n                if child not in visited and child not in blocked:\\n                    visited.add(child)\\n                    queue.append(child)\\n        return False\\n    \\n    def isEscapePossible(self, blocked: List[List[int]], source: List[int], target: List[int]) -> bool:\\n        source, target = tuple(source), tuple(target)\\n        blocked = {tuple(p) for p in blocked}\\n        graph = self.getBlockedGraph(blocked)\\n        for comp in self.getCC(graph):\\n            trap_src = self.isTrapped(source, comp)\\n            trap_tgt = self.isTrapped(target, comp)\\n            if trap_src and trap_tgt:\\n                return self.isReachable(source, target, comp)\\n            elif trap_src != trap_tgt:\\n                return False\\n        return True\\n```",
                "solutionTags": [],
                "code": "```\\nN = 1000000\\n\\nclass Solution:\\n    def getRect(self, points: Iterable[tuple[int, int]]) -> tuple[int, int, int, int]:\\n        min_x, max_x = inf, -inf\\n        min_y, max_y = inf, -inf\\n        for x, y in points:\\n            min_x, max_x = min(min_x, x), max(max_x, x)\\n            min_y, max_y = min(min_y, y), max(max_y, y)\\n        return min_x, max_x, min_y, max_y    \\n   \\n    def neighbors(self, x, y, diag=False) -> Iterator[tuple[int, int]]:\\n        min_x, max_x, min_y, max_y = 0, N-1, 0, N-1\\n        deltas = ((-1, 0), (+1, 0), (0, +1), (0, -1))\\n        if diag:\\n            deltas += ((-1, -1), (-1, +1), (+1, -1), (+1, +1))\\n        for dx, dy in deltas:\\n            nx, ny = x + dx, y + dy\\n            if min_x <= nx <= max_x and min_y <= ny <= max_y:\\n                yield nx, ny\\n\\n    def getBlockedGraph(self, blocked: set[tuple[int, int]]) -> dict[int, set[tuple[int, int]]]:\\n        graph = defaultdict(set)\\n        for x, y in blocked:\\n            for nei in self.neighbors(x, y, diag=True):\\n                if nei not in blocked:\\n                    continue\\n                graph[x, y].add(nei)\\n                graph[nei].add((x, y))\\n        return graph\\n    \\n    def dfsComp(self, start: tuple[int, int], \\n                      graph: dict[int, set[tuple[int, int]]]) -> set[int]: \\n        stack = [start]\\n        visited = set()\\n        while stack:\\n            node = stack.pop()\\n            if node in visited:\\n                continue\\n            else:\\n                visited.add(node)\\n            for child in graph[node]:\\n                stack.append(child)\\n        return visited\\n\\n    def getCC(self, graph: dict[int, set[tuple[int, int]]]) -> list[set[tuple[int, int]]]:\\n        visited = set()\\n        cc = []\\n        for node in graph:\\n            if node not in visited:\\n                comp = self.dfsComp(node, graph)\\n                cc.append(comp)\\n                visited |= comp\\n        return cc\\n    \\n    def isTrapped(self, p: tuple[int, int], comp: set[tuple[int, int]]) -> bool:\\n        stack = [p]\\n        visited = set()\\n        min_x, max_x, min_y, max_y = self.getRect(comp)\\n        while stack:\\n            node = stack.pop()\\n            if node in visited:\\n                continue\\n            else:\\n                visited.add(node)\\n            x, y = node\\n            if not (min_x <= x <= max_x) or not (min_y <= y <= max_y):\\n                return False\\n            for child in self.neighbors(x, y):\\n                if child not in comp:\\n                    stack.append(child)\\n        return True\\n    \\n    def isReachable(self, source: tuple[int, int], \\n                    target: tuple[int, int], blocked: set[tuple[int, int]]) -> bool:\\n        queue = deque([source])\\n        visited = {source}\\n        min_x, max_x, min_y, max_y = self.getRect(blocked)        \\n        while queue:\\n            node = queue.popleft()\\n            if node == target:\\n                return True\\n            x, y = node            \\n            if not (min_x <= x <= max_x and min_y <= y <= max_y):\\n                break\\n            for child in self.neighbors(x, y):\\n                if child not in visited and child not in blocked:\\n                    visited.add(child)\\n                    queue.append(child)\\n        return False\\n    \\n    def isEscapePossible(self, blocked: List[List[int]], source: List[int], target: List[int]) -> bool:\\n        source, target = tuple(source), tuple(target)\\n        blocked = {tuple(p) for p in blocked}\\n        graph = self.getBlockedGraph(blocked)\\n        for comp in self.getCC(graph):\\n            trap_src = self.isTrapped(source, comp)\\n            trap_tgt = self.isTrapped(target, comp)\\n            if trap_src and trap_tgt:\\n                return self.isReachable(source, target, comp)\\n            elif trap_src != trap_tgt:\\n                return False\\n        return True\\n```",
                "codeTag": "Java"
            },
            {
                "id": 979613,
                "title": "java-dfs",
                "content": "the 31st test case may not be right, why when target is blocked we can still find a sequence, I don\\'t get it.\\n```\\nclass Solution {\\n    public boolean isEscapePossible(int[][] blocked, int[] source, int[] target) {\\n        if(blocked.length == 0) return true;\\n        Set<Integer> blocks = new HashSet();\\n        for(int[] b : blocked)\\n            if(target[0]*1000000+target[1] != b[0]*1000000+b[1])\\n                blocks.add(b[0]*1000000+b[1]);\\n        return dfs(blocks, source, source[0], source[1], new HashSet<Integer>(), target) && dfs(blocks, target, target[0], target[1], new HashSet<Integer>(), source);\\n    }\\n    public boolean dfs(Set<Integer> blocks, int[] start, int i, int j, Set<Integer> visited, int[] target){\\n        if(i<0 || j<0 || i>999999 || j>999999 || blocks.contains(i*1000000+j) || visited.contains(i*1000000+j)) return false;\\n        if(i==target[0] && j==target[1]) return true;\\n        visited.add(i*1000000+j);\\n        if(visited.size() > blocks.size()*(blocks.size()+1))\\n            return true;\\n        return dfs(blocks, start, i+1, j, visited, target) || dfs(blocks, start, i-1, j, visited, target) || dfs(blocks, start, i, j+1, visited, target) || dfs(blocks, start, i, j-1, visited, target);\\n    }\\n}",
                "solutionTags": [],
                "code": "class Solution {\\n    public boolean isEscapePossible(int[][] blocked, int[] source, int[] target) {\\n        if(blocked.length == 0) return true;\\n        Set<Integer> blocks = new HashSet();\\n        for(int[] b : blocked)\\n            if(target[0]*1000000+target[1] != b[0]*1000000+b[1])\\n                blocks.add(b[0]*1000000+b[1]);\\n        return dfs(blocks, source, source[0], source[1], new HashSet<Integer>(), target) && dfs(blocks, target, target[0], target[1], new HashSet<Integer>(), source);\\n    }",
                "codeTag": "Java"
            },
            {
                "id": 920712,
                "title": "wrong-test-case",
                "content": "[[5,20],[10,10],[15,10],[10,30],[15,30],[20,30]]\\n[10,20]\\n[20,30]\\n\\nThis test case is wrong. The expected case on leetcode is True. However, the target point is blocked, so we can never reach the target",
                "solutionTags": [],
                "code": "",
                "codeTag": "Unknown"
            },
            {
                "id": 904126,
                "title": "rust-simple-floodfill-20-ms",
                "content": "The key idea to early return floodfill if we are sure that our cell is not surrounded by blocks.\\nIf both start and end not surrounded, they can be connected.\\n```\\nuse std::collections::HashSet;\\nuse std::convert::TryFrom;\\n\\nfn gen_neighbors((x, y): (u32, u32))->[Option<(u32, u32)>;4]{\\n    const LIMIT: u32 = 1000_000;\\n    [\\n        if x>0 {Some((x-1, y))} else {None},\\n        if x+1 < LIMIT {Some((x+1, y))} else {None},\\n        if y>0 {Some((x, y-1))} else {None},\\n        if y+1 < LIMIT {Some((x, y+1))} else {None},\\n    ]\\n}\\n\\n#[derive(Eq, PartialEq)]\\nenum States{\\n    Possible,\\n    Blocked,\\n    Solved,\\n}\\n\\nfn try_flood_fill(pos: (u32, u32), target: (u32, u32), blocked: &HashSet<(u32, u32)>, block_rows: &HashSet<u32>, block_cols:&HashSet<u32>)->States{\\n    // if we can flood at least 6xnumber of blocked tiles\\n    let mut flooded = HashSet::new();\\n    let mut stack = vec![pos];\\n    while let Some(curr) = stack.pop(){\\n        if curr == target{\\n            return States::Solved;\\n        }\\n        if !block_rows.contains(&curr.0){\\n            return States::Possible;\\n        }\\n        if !block_cols.contains(&curr.1){\\n            return States::Possible;\\n        }\\n        flooded.insert(curr);\\n        for neighbor in gen_neighbors(curr).iter().copied().flatten(){\\n            if !blocked.contains(&neighbor) && !flooded.contains(&neighbor){\\n                stack.push(neighbor);\\n            }\\n        }\\n    }\\n    States::Blocked\\n}\\n\\nfn conv_vec(v: Vec<i32>)->(u32, u32){\\n    (u32::try_from(v[0]).unwrap(), u32::try_from(v[1]).unwrap())\\n}\\n\\nimpl Solution {\\n    pub fn is_escape_possible(blocked: Vec<Vec<i32>>, source: Vec<i32>, target: Vec<i32>) -> bool {       \\n        if blocked.is_empty(){\\n            return true;\\n        }\\n        \\n        let source = conv_vec(source);\\n        let target = conv_vec(target);\\n        let blocked: HashSet<(u32, u32)> = blocked.into_iter()\\n            .map(conv_vec)\\n            .collect();\\n        let block_rows: HashSet<u32> = blocked.iter().copied().map(|(x,_)|x).collect();\\n        let block_cols: HashSet<u32> = blocked.iter().copied().map(|(_,y)|y).collect();\\n        \\n        let r1 = try_flood_fill(source, target, &blocked, &block_rows, &block_cols);\\n        if r1==States::Solved{\\n            return true;\\n        }\\n        let r2 = try_flood_fill(target, source, &blocked, &block_rows, &block_cols);\\n        match (r1, r2){\\n            (States::Possible, States::Solved) => true,\\n            (States::Possible, States::Possible) => true,\\n            _ => false,\\n        }\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nuse std::collections::HashSet;\\nuse std::convert::TryFrom;\\n\\nfn gen_neighbors((x, y): (u32, u32))->[Option<(u32, u32)>;4]{\\n    const LIMIT: u32 = 1000_000;\\n    [\\n        if x>0 {Some((x-1, y))} else {None},\\n        if x+1 < LIMIT {Some((x+1, y))} else {None},\\n        if y>0 {Some((x, y-1))} else {None},\\n        if y+1 < LIMIT {Some((x, y+1))} else {None},\\n    ]\\n}\\n\\n#[derive(Eq, PartialEq)]\\nenum States{\\n    Possible,\\n    Blocked,\\n    Solved,\\n}\\n\\nfn try_flood_fill(pos: (u32, u32), target: (u32, u32), blocked: &HashSet<(u32, u32)>, block_rows: &HashSet<u32>, block_cols:&HashSet<u32>)->States{\\n    // if we can flood at least 6xnumber of blocked tiles\\n    let mut flooded = HashSet::new();\\n    let mut stack = vec![pos];\\n    while let Some(curr) = stack.pop(){\\n        if curr == target{\\n            return States::Solved;\\n        }\\n        if !block_rows.contains(&curr.0){\\n            return States::Possible;\\n        }\\n        if !block_cols.contains(&curr.1){\\n            return States::Possible;\\n        }\\n        flooded.insert(curr);\\n        for neighbor in gen_neighbors(curr).iter().copied().flatten(){\\n            if !blocked.contains(&neighbor) && !flooded.contains(&neighbor){\\n                stack.push(neighbor);\\n            }\\n        }\\n    }\\n    States::Blocked\\n}\\n\\nfn conv_vec(v: Vec<i32>)->(u32, u32){\\n    (u32::try_from(v[0]).unwrap(), u32::try_from(v[1]).unwrap())\\n}\\n\\nimpl Solution {\\n    pub fn is_escape_possible(blocked: Vec<Vec<i32>>, source: Vec<i32>, target: Vec<i32>) -> bool {       \\n        if blocked.is_empty(){\\n            return true;\\n        }\\n        \\n        let source = conv_vec(source);\\n        let target = conv_vec(target);\\n        let blocked: HashSet<(u32, u32)> = blocked.into_iter()\\n            .map(conv_vec)\\n            .collect();\\n        let block_rows: HashSet<u32> = blocked.iter().copied().map(|(x,_)|x).collect();\\n        let block_cols: HashSet<u32> = blocked.iter().copied().map(|(_,y)|y).collect();\\n        \\n        let r1 = try_flood_fill(source, target, &blocked, &block_rows, &block_cols);\\n        if r1==States::Solved{\\n            return true;\\n        }\\n        let r2 = try_flood_fill(target, source, &blocked, &block_rows, &block_cols);\\n        match (r1, r2){\\n            (States::Possible, States::Solved) => true,\\n            (States::Possible, States::Possible) => true,\\n            _ => false,\\n        }\\n    }\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 902650,
                "title": "python-3-71",
                "content": "```\\nclass Solution:\\n    def isEscapePossible(self, blocked, source, target):\\n        if not blocked: return True\\n        B = { (x[0], x[1]) for x in blocked }\\n        T = 200 #if you move more than T in bfs you have escaped.\\n        \\n        def bfs(s, t):\\n            visited, queue = { (t[0], t[1]) }, deque([(t[0], t[1], 0)])\\n            while queue:\\n                i,j,d = queue.popleft()\\n                if i == s[0] and j == s[1]: return True # Direct path found\\n                if d > T: return True #we have escaped.\\n                #Check if we can escape right away in any of the 4 directions\\n                # Not clear but we are assuming the 10^6 bounday can be crossed in moves\\n                # i.e. should be explictly blocked in blocked as opposed to >=0 bounday.\\n                if any([all((i + k, j) not in B and (i + k, j) not in visited for k in range(1,T+2-d)),\\n                        all((i - k, j) not in B and (i - k, j) not in visited and i >= k for k in range(1, T + 2 - d)),\\n                        all((i, j + k) not in B and (i, j + k) not in visited for k in range(1, T + 2 - d)),\\n                        all((i, j - k) not in B and (i, j - k) not in visited and j >= k for k in range(1, T + 2 - d))]):\\n                    return True\\n                # Usual BFS layer.\\n                for x, y in [(i + 1, j), (i - 1, j), (i, j + 1), (i, j - 1)]:\\n                    if x >= 0 and y >= 0 and (x, y) not in B and (x, y) not in visited:\\n                        visited.add((x, y))\\n                        queue.append((x, y, d + 1))\\n\\n        return bfs(source, target) and bfs(target, source)\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def isEscapePossible(self, blocked, source, target):\\n        if not blocked: return True\\n        B = { (x[0], x[1]) for x in blocked }\\n        T = 200 #if you move more than T in bfs you have escaped.\\n        \\n        def bfs(s, t):\\n            visited, queue = { (t[0], t[1]) }, deque([(t[0], t[1], 0)])\\n            while queue:\\n                i,j,d = queue.popleft()\\n                if i == s[0] and j == s[1]: return True # Direct path found\\n                if d > T: return True #we have escaped.\\n                #Check if we can escape right away in any of the 4 directions\\n                # Not clear but we are assuming the 10^6 bounday can be crossed in moves\\n                # i.e. should be explictly blocked in blocked as opposed to >=0 bounday.\\n                if any([all((i + k, j) not in B and (i + k, j) not in visited for k in range(1,T+2-d)),\\n                        all((i - k, j) not in B and (i - k, j) not in visited and i >= k for k in range(1, T + 2 - d)),\\n                        all((i, j + k) not in B and (i, j + k) not in visited for k in range(1, T + 2 - d)),\\n                        all((i, j - k) not in B and (i, j - k) not in visited and j >= k for k in range(1, T + 2 - d))]):\\n                    return True\\n                # Usual BFS layer.\\n                for x, y in [(i + 1, j), (i - 1, j), (i, j + 1), (i, j - 1)]:\\n                    if x >= 0 and y >= 0 and (x, y) not in B and (x, y) not in visited:\\n                        visited.add((x, y))\\n                        queue.append((x, y, d + 1))\\n\\n        return bfs(source, target) and bfs(target, source)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 888225,
                "title": "dfs-approach-over-cells-adjacent-to-blocked-nodes",
                "content": "```\\nclass Solution {\\npublic:\\n    static constexpr int64_t M = 1000000;\\n    unordered_map<int, set<int>> rows;\\n    unordered_map<int, set<int>> cols;\\n    unordered_map<int, unordered_set<int>> visited;\\n    \\n    bool dfs(pair<int, int> pos, const pair<int, int> target) {\\n        if (pos == target)\\n            return true;\\n\\n        auto [x, y] = pos;\\n        \\n        if (visited[x].count(y))\\n            return false;\\n        \\n        visited[x].insert(y);\\n\\n        {\\n            const auto &row = rows.at(x);\\n            auto row_it = row.find(y);\\n            if (row_it != row.begin()) {\\n                if (dfs({x, *prev(row_it)}, target))\\n                    return  true;\\n            }\\n            ++row_it;\\n            if (row_it != row.end()) {\\n                if (dfs({x, *row_it}, target))\\n                    return  true;\\n            }\\n        }\\n\\n        {\\n            const auto &col = cols.at(y);\\n            auto col_it = col.find(x);\\n            if (col_it != col.begin()) {\\n                if (dfs({*prev(col_it), y}, target))\\n                    return  true;\\n            }\\n            ++col_it;\\n            if (col_it != col.end()) {\\n                if (dfs({*col_it, y}, target))\\n                    return  true;\\n            }\\n        }\\n        return false;\\n    }\\n    \\n    \\n    bool isEscapePossible(vector<vector<int>>& blocked, vector<int>& source, vector<int>& target) { \\n        \\n        auto addPoint = [&](int px, int py) {\\n            rows[px].insert(py);\\n            cols[py].insert(px);                                    \\n        };\\n        \\n        for (const auto &b : blocked) {\\n            visited[b[0]].insert(b[1]);\\n            for (int dx = -1; dx <= 1; ++dx)\\n                for (int dy = -1; dy <= 1; ++dy) {\\n                    int px = b[0] + dx;\\n                    int py = b[1] + dy;\\n                    if (px >= 0 && px < M && py >= 0 && py < M) {\\n                        addPoint(px, py);\\n                        addPoint(px, target[1]);\\n                        addPoint(target[0], py);\\n                    }\\n                }\\n        }\\n        \\n        addPoint(source[0], source[1]);\\n        addPoint(target[0], target[1]);\\n        addPoint(source[0], target[1]);\\n        addPoint(target[0], source[1]);\\n        \\n        return dfs({source[0], source[1]}, {target[0], target[1]});      \\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    static constexpr int64_t M = 1000000;\\n    unordered_map<int, set<int>> rows;\\n    unordered_map<int, set<int>> cols;\\n    unordered_map<int, unordered_set<int>> visited;\\n    \\n    bool dfs(pair<int, int> pos, const pair<int, int> target) {\\n        if (pos == target)\\n            return true;\\n\\n        auto [x, y] = pos;\\n        \\n        if (visited[x].count(y))\\n            return false;\\n        \\n        visited[x].insert(y);\\n\\n        {\\n            const auto &row = rows.at(x);\\n            auto row_it = row.find(y);\\n            if (row_it != row.begin()) {\\n                if (dfs({x, *prev(row_it)}, target))\\n                    return  true;\\n            }\\n            ++row_it;\\n            if (row_it != row.end()) {\\n                if (dfs({x, *row_it}, target))\\n                    return  true;\\n            }\\n        }\\n\\n        {\\n            const auto &col = cols.at(y);\\n            auto col_it = col.find(x);\\n            if (col_it != col.begin()) {\\n                if (dfs({*prev(col_it), y}, target))\\n                    return  true;\\n            }\\n            ++col_it;\\n            if (col_it != col.end()) {\\n                if (dfs({*col_it, y}, target))\\n                    return  true;\\n            }\\n        }\\n        return false;\\n    }\\n    \\n    \\n    bool isEscapePossible(vector<vector<int>>& blocked, vector<int>& source, vector<int>& target) { \\n        \\n        auto addPoint = [&](int px, int py) {\\n            rows[px].insert(py);\\n            cols[py].insert(px);                                    \\n        };\\n        \\n        for (const auto &b : blocked) {\\n            visited[b[0]].insert(b[1]);\\n            for (int dx = -1; dx <= 1; ++dx)\\n                for (int dy = -1; dy <= 1; ++dy) {\\n                    int px = b[0] + dx;\\n                    int py = b[1] + dy;\\n                    if (px >= 0 && px < M && py >= 0 && py < M) {\\n                        addPoint(px, py);\\n                        addPoint(px, target[1]);\\n                        addPoint(target[0], py);\\n                    }\\n                }\\n        }\\n        \\n        addPoint(source[0], source[1]);\\n        addPoint(target[0], target[1]);\\n        addPoint(source[0], target[1]);\\n        addPoint(target[0], source[1]);\\n        \\n        return dfs({source[0], source[1]}, {target[0], target[1]});      \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 856372,
                "title": "swift-bfs-try-to-escape-the-blocking-area",
                "content": "Time: O(b^2) Space: O(b^2) where b is the length of the blocked array\\n```\\nfunc isEscapePossible(_ blocked: [[Int]], _ source: [Int], _ target: [Int]) -> Bool {\\n\\tif blocked.isEmpty { return true }\\n\\tlet blockeds = Set(blocked)\\n\\n\\treturn canEscape(source, target, blockeds) && canEscape(target, source, blockeds)\\n}\\n\\nfunc canEscape(_ source: [Int], _ target: [Int], _ blockeds: Set<[Int]>) -> Bool {\\n\\tlet directions = [(1, 0), (0, 1), (-1, 0), (0, -1)]\\n\\tlet blockCount = blockeds.count\\n\\tlet blockArea = blockCount * (blockCount - 1) / 2\\n\\n\\tvar visiteds = Set<[Int]>()\\n\\tvar queue = [[Int]]()\\n\\tvar queueHead = 0\\n\\tvar queueCount = 1\\n\\tvisiteds.insert([source[0], source[1]])\\n\\tqueue.append([source[0], source[1]])\\n\\n\\twhile queueHead < queueCount {\\n\\t\\tif queue[queueHead] == target { return true }\\n\\n\\t\\tlet curX = queue[queueHead][0]\\n\\t\\tlet curY = queue[queueHead][1]\\n\\t\\tfor direction in directions {\\n\\t\\t\\tlet nextX = curX + direction.0\\n\\t\\t\\tlet nextY = curY + direction.1\\n\\t\\t\\tif nextX < 0 || nextX > 999999 || nextY < 0 || nextY > 999999 { continue }\\n\\n\\t\\t\\tlet nextCell = [nextX, nextY]\\n\\t\\t\\tif !blockeds.contains(nextCell) && !visiteds.contains(nextCell) {\\n\\t\\t\\t\\tvisiteds.insert(nextCell)\\n\\t\\t\\t\\tqueue.append(nextCell)\\n\\t\\t\\t\\tqueueCount += 1\\n\\t\\t\\t}\\n\\t\\t}\\n\\n\\t\\tif queueCount > blockArea { return true }\\n\\n\\t\\tqueueHead += 1\\n\\t}\\n\\n\\treturn false // can\\'t escape\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nfunc isEscapePossible(_ blocked: [[Int]], _ source: [Int], _ target: [Int]) -> Bool {\\n\\tif blocked.isEmpty { return true }\\n\\tlet blockeds = Set(blocked)\\n\\n\\treturn canEscape(source, target, blockeds) && canEscape(target, source, blockeds)\\n}\\n\\nfunc canEscape(_ source: [Int], _ target: [Int], _ blockeds: Set<[Int]>) -> Bool {\\n\\tlet directions = [(1, 0), (0, 1), (-1, 0), (0, -1)]\\n\\tlet blockCount = blockeds.count\\n\\tlet blockArea = blockCount * (blockCount - 1) / 2\\n\\n\\tvar visiteds = Set<[Int]>()\\n\\tvar queue = [[Int]]()\\n\\tvar queueHead = 0\\n\\tvar queueCount = 1\\n\\tvisiteds.insert([source[0], source[1]])\\n\\tqueue.append([source[0], source[1]])\\n\\n\\twhile queueHead < queueCount {\\n\\t\\tif queue[queueHead] == target { return true }\\n\\n\\t\\tlet curX = queue[queueHead][0]\\n\\t\\tlet curY = queue[queueHead][1]\\n\\t\\tfor direction in directions {\\n\\t\\t\\tlet nextX = curX + direction.0\\n\\t\\t\\tlet nextY = curY + direction.1\\n\\t\\t\\tif nextX < 0 || nextX > 999999 || nextY < 0 || nextY > 999999 { continue }\\n\\n\\t\\t\\tlet nextCell = [nextX, nextY]\\n\\t\\t\\tif !blockeds.contains(nextCell) && !visiteds.contains(nextCell) {\\n\\t\\t\\t\\tvisiteds.insert(nextCell)\\n\\t\\t\\t\\tqueue.append(nextCell)\\n\\t\\t\\t\\tqueueCount += 1\\n\\t\\t\\t}\\n\\t\\t}\\n\\n\\t\\tif queueCount > blockArea { return true }\\n\\n\\t\\tqueueHead += 1\\n\\t}\\n\\n\\treturn false // can\\'t escape\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 845199,
                "title": "python3-greedy-accepted-solution",
                "content": "```\\nfrom typing import List\\n\\n\\nclass Solution:\\n    def isEscapePossible(self, blocked: List[List[int]], source: List[int], target: List[int]) -> bool:\\n\\n        bound = pow(10, 6)\\n        b = {(i, j) for i, j in blocked}\\n\\n        def mandis(i, j):\\n            return abs(i - sr) + abs(j - sc)\\n\\n        def greedmove(i, j):\\n            if i == tr and j == tc:\\n                return True\\n            if mandis(i, j) > 200:\\n                return True\\n\\n            d1 = (tr - i) // abs(tr - i) if tr - i != 0 else 0     # try greedy direction\\n            d2 = (tc - j) // abs(tc - j) if tc - j != 0 else 0   # try another greedy direction\\n\\n            getpath = False\\n            if d1 != 0 and 0 <= i + d1 < bound and (i + d1, j) not in b and (i + d1, j) not in visited:\\n                visited.add((i + d1, j))\\n                getpath = getpath or greedmove(i + d1, j)\\n            if d2 != 0 and 0 <= j + d2 < bound and (i, j + d2) not in b and (i, j + d2) not in visited:\\n                visited.add((i, j + d2))\\n                getpath = getpath or greedmove(i, j + d2)\\n            if 0 <= i + 1 < bound and (i + 1, j) not in b and (i + 1, j) not in visited:\\n                visited.add((i + 1, j))\\n                getpath = getpath or greedmove(i + 1, j)\\n            if 0 <= i - 1 < bound and (i - 1, j) not in b and (i - 1, j) not in visited:\\n                visited.add((i - 1, j))\\n                getpath = getpath or greedmove(i - 1, j)\\n            if 0 <= j + 1 < bound and (i, j + 1) not in b and (i, j + 1) not in visited:\\n                visited.add((i, j + 1))\\n                getpath = getpath or greedmove(i, j + 1)\\n            if 0 <= j - 1 < bound and (i, j - 1) not in b and (i, j - 1) not in visited:\\n                visited.add((i, j - 1))\\n                getpath = getpath or greedmove(i, j - 1)\\n\\n            return getpath\\n\\n        visited = set()\\n        visited.add((source[0], source[1]))\\n        sr, sc = source\\n        tr, tc = target\\n        result1 = greedmove(source[0], source[1])\\n\\n        visited = set()\\n        visited.add((target[0], target[1]))\\n        sr, sc = target\\n        tr, tc = source\\n        result2 = greedmove(target[0], target[1])\\n        return result1 and result2\\n\\n\\n\\n\\n```",
                "solutionTags": [],
                "code": "```\\nfrom typing import List\\n\\n\\nclass Solution:\\n    def isEscapePossible(self, blocked: List[List[int]], source: List[int], target: List[int]) -> bool:\\n\\n        bound = pow(10, 6)\\n        b = {(i, j) for i, j in blocked}\\n\\n        def mandis(i, j):\\n            return abs(i - sr) + abs(j - sc)\\n\\n        def greedmove(i, j):\\n            if i == tr and j == tc:\\n                return True\\n            if mandis(i, j) > 200:\\n                return True\\n\\n            d1 = (tr - i) // abs(tr - i) if tr - i != 0 else 0     # try greedy direction\\n            d2 = (tc - j) // abs(tc - j) if tc - j != 0 else 0   # try another greedy direction\\n\\n            getpath = False\\n            if d1 != 0 and 0 <= i + d1 < bound and (i + d1, j) not in b and (i + d1, j) not in visited:\\n                visited.add((i + d1, j))\\n                getpath = getpath or greedmove(i + d1, j)\\n            if d2 != 0 and 0 <= j + d2 < bound and (i, j + d2) not in b and (i, j + d2) not in visited:\\n                visited.add((i, j + d2))\\n                getpath = getpath or greedmove(i, j + d2)\\n            if 0 <= i + 1 < bound and (i + 1, j) not in b and (i + 1, j) not in visited:\\n                visited.add((i + 1, j))\\n                getpath = getpath or greedmove(i + 1, j)\\n            if 0 <= i - 1 < bound and (i - 1, j) not in b and (i - 1, j) not in visited:\\n                visited.add((i - 1, j))\\n                getpath = getpath or greedmove(i - 1, j)\\n            if 0 <= j + 1 < bound and (i, j + 1) not in b and (i, j + 1) not in visited:\\n                visited.add((i, j + 1))\\n                getpath = getpath or greedmove(i, j + 1)\\n            if 0 <= j - 1 < bound and (i, j - 1) not in b and (i, j - 1) not in visited:\\n                visited.add((i, j - 1))\\n                getpath = getpath or greedmove(i, j - 1)\\n\\n            return getpath\\n\\n        visited = set()\\n        visited.add((source[0], source[1]))\\n        sr, sc = source\\n        tr, tc = target\\n        result1 = greedmove(source[0], source[1])\\n\\n        visited = set()\\n        visited.add((target[0], target[1]))\\n        sr, sc = target\\n        tr, tc = source\\n        result2 = greedmove(target[0], target[1])\\n        return result1 and result2\\n\\n\\n\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 773029,
                "title": "python-easy-but-slow-15-lines-only",
                "content": "```\\ndef bfs(s,t,b):\\n    q,v=[s],{s}\\n    while len(q)>0:\\n        i,j=q.pop(0)\\n        if (i,j)==t:return True\\n        if i in (s[0]+210,s[0]-210) or j in (s[1]+210,s[1]-210):return True\\n        for d,e in ((i+1,j),(i,j+1),(i-1,j),(i,j-1)):\\n            if d>=0 and d<10**6 and e>=0 and e<10**6 and (d,e) not in v and (d,e) not in b:\\n                v.add((d,e))\\n                q.append((d,e))\\n    return False\\nclass Solution:\\n    def isEscapePossible(self, b: List[List[int]], s: List[int], t: List[int]) -> bool:\\n        b=set(tuple(i) for i in b)\\n        return bfs(tuple(s),tuple(t),b) and bfs(tuple(t),tuple(s),b)\\n```",
                "solutionTags": [],
                "code": "```\\ndef bfs(s,t,b):\\n    q,v=[s],{s}\\n    while len(q)>0:\\n        i,j=q.pop(0)\\n        if (i,j)==t:return True\\n        if i in (s[0]+210,s[0]-210) or j in (s[1]+210,s[1]-210):return True\\n        for d,e in ((i+1,j),(i,j+1),(i-1,j),(i,j-1)):\\n            if d>=0 and d<10**6 and e>=0 and e<10**6 and (d,e) not in v and (d,e) not in b:\\n                v.add((d,e))\\n                q.append((d,e))\\n    return False\\nclass Solution:\\n    def isEscapePossible(self, b: List[List[int]], s: List[int], t: List[int]) -> bool:\\n        b=set(tuple(i) for i in b)\\n        return bfs(tuple(s),tuple(t),b) and bfs(tuple(t),tuple(s),b)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 770507,
                "title": "consider-depth-or-consider-area-two-methods-with-explanations",
                "content": "Two methods:\\n1. consider the depth (layer/level) during BFS, if the depth == len(blocked), then this is a success;\\n2. consider the region area (\\u9762\\u79EF) that can be reached by these maximum 200 points, the largest is 20000 (refer the following figure).\\n   (note that, the max area by 200 points is not 40000/pai)\\n\\n![image](https://assets.leetcode.com/users/images/62902202-7667-4b79-92cf-7b5aa067752a_1596443326.0487142.png)\\n\\n```\\nclass Solution:\\n    def isEscapePossible1(self, blocked: List[List[int]], source: List[int], target: List[int]) -> bool:\\n        if not blocked: return True\\n        \\n        blocked = set(map(tuple, blocked))\\n        \\n        def check(blocked, source, target):\\n            si, sj = source\\n            ti, tj = target\\n            \\n            level = 0\\n            q = collections.deque([(si,sj)])\\n            visited = set()\\n            \\n            while q:\\n                for _ in range(len(q)):\\n                    i,j = q.popleft()\\n                    \\n                    if i == ti and j == tj:\\n                        return True\\n                    \\n                    for x, y in [(i+1,j), (i-1, j), (i, j+1), (i,j-1)]:\\n                        if 0<=x < 10**6 and 0<=y <=10**6 and (x,y) not in visited and (x,y) not in blocked: \\n\\t\\t\\t\\t\\t\\t# grid \\u662F 1M * 1M\\u7684\\uFF01\\n                            visited.add((x,y))\\n                            q.append((x,y))\\n                level += 1\\n                \\n                #if level == len(blocked)*2: # extremely slow here!\\n                if level == len(blocked): # point\\uFF01level of BFS reached block\\'s length then its a successful escape!\\n                    break\\n                    \\n            if len(q) == 0:\\n                return False # no available ways to go anymore!\\n            \\n            return True # since already reached level==len(blocked)\\uFF01\\n\\t\\t\\t\\n        # the key point is the length of blocked is smaller than 200, so the closed area will not too large\\n        #we can just use bfs to search from the source, and set a maximum step.\\n        #after moving maximum step, if we can still move, then it must can reach the target point\\n        \\n        return check(blocked, source, target) and check(blocked, target, source) #two directions! bi-directional bfs\\n        \\n        # \\u6709\\u4E00\\u6761\\u957F\\u5EA6\\u4E3A200\\u7684\\u7EBF\\uFF0C\\u53EF\\u4EE5\\u6700\\u5927\\u56F4\\u6210\\u591A\\u5927\\u7684\\u9762\\u79EF\\uFF1F\\n    \\n    def isEscapePossible(self, blocked, source, target):\\n        # \\u9762\\u79EF area , blocked area!\\n        maxlen = 10**6\\n        #maxarea = (4/3.14) * 17000 # maxarea = (4/3.14) * 10000 does not work!\\n        maxarea = 20000\\n        dirs = [(1, 0), (-1, 0), (0, 1), (0, -1)]\\n        \\n        blocked = set(map(tuple, blocked)) # use a set to make it faster for retrieving\\n        \\n        def bfs(source, target):\\n            q = collections.deque()\\n            aset = set()\\n            q.append(source)\\n            while q and len(aset) < maxarea:\\n                row, col = q.popleft()\\n                if row == target[0] and col == target[1]:\\n                    return True\\n                aset.add((row,col))\\n                \\n                for dir in dirs:\\n                    row2 = row + dir[0]\\n                    col2 = col + dir[1]\\n                    if 0<=row2<maxlen and 0<=col2 < maxlen and not (row2, col2) in aset and not (row2,col2) in blocked:\\n                        q.append([row2, col2])\\n                        aset.add((row2, col2))\\n            return len(aset) >= maxarea # evaluate by max-area(\\u6700\\u5927\\u9762\\u79EF)\\n        return bfs(source, target) and bfs(target, source)\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def isEscapePossible1(self, blocked: List[List[int]], source: List[int], target: List[int]) -> bool:\\n        if not blocked: return True\\n        \\n        blocked = set(map(tuple, blocked))\\n        \\n        def check(blocked, source, target):\\n            si, sj = source\\n            ti, tj = target\\n            \\n            level = 0\\n            q = collections.deque([(si,sj)])\\n            visited = set()\\n            \\n            while q:\\n                for _ in range(len(q)):\\n                    i,j = q.popleft()\\n                    \\n                    if i == ti and j == tj:\\n                        return True\\n                    \\n                    for x, y in [(i+1,j), (i-1, j), (i, j+1), (i,j-1)]:\\n                        if 0<=x < 10**6 and 0<=y <=10**6 and (x,y) not in visited and (x,y) not in blocked: \\n\\t\\t\\t\\t\\t\\t# grid \\u662F 1M * 1M\\u7684\\uFF01\\n                            visited.add((x,y))\\n                            q.append((x,y))\\n                level += 1\\n                \\n                #if level == len(blocked)*2: # extremely slow here!\\n                if level == len(blocked): # point\\uFF01level of BFS reached block\\'s length then its a successful escape!\\n                    break\\n                    \\n            if len(q) == 0:\\n                return False # no available ways to go anymore!\\n            \\n            return True # since already reached level==len(blocked)\\uFF01\\n\\t\\t\\t\\n        # the key point is the length of blocked is smaller than 200, so the closed area will not too large\\n        #we can just use bfs to search from the source, and set a maximum step.\\n        #after moving maximum step, if we can still move, then it must can reach the target point\\n        \\n        return check(blocked, source, target) and check(blocked, target, source) #two directions! bi-directional bfs\\n        \\n        # \\u6709\\u4E00\\u6761\\u957F\\u5EA6\\u4E3A200\\u7684\\u7EBF\\uFF0C\\u53EF\\u4EE5\\u6700\\u5927\\u56F4\\u6210\\u591A\\u5927\\u7684\\u9762\\u79EF\\uFF1F\\n    \\n    def isEscapePossible(self, blocked, source, target):\\n        # \\u9762\\u79EF area , blocked area!\\n        maxlen = 10**6\\n        #maxarea = (4/3.14) * 17000 # maxarea = (4/3.14) * 10000 does not work!\\n        maxarea = 20000\\n        dirs = [(1, 0), (-1, 0), (0, 1), (0, -1)]\\n        \\n        blocked = set(map(tuple, blocked)) # use a set to make it faster for retrieving\\n        \\n        def bfs(source, target):\\n            q = collections.deque()\\n            aset = set()\\n            q.append(source)\\n            while q and len(aset) < maxarea:\\n                row, col = q.popleft()\\n                if row == target[0] and col == target[1]:\\n                    return True\\n                aset.add((row,col))\\n                \\n                for dir in dirs:\\n                    row2 = row + dir[0]\\n                    col2 = col + dir[1]\\n                    if 0<=row2<maxlen and 0<=col2 < maxlen and not (row2, col2) in aset and not (row2,col2) in blocked:\\n                        q.append([row2, col2])\\n                        aset.add((row2, col2))\\n            return len(aset) >= maxarea # evaluate by max-area(\\u6700\\u5927\\u9762\\u79EF)\\n        return bfs(source, target) and bfs(target, source)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 756214,
                "title": "java-union-find-bfs-checked-connected-blockers-and-bfs-only-from-within-the-blocker-area",
                "content": "```\\nclass Solution {\\n    public boolean isEscapePossible(int[][] blocked, int[] source, int[] target) {\\n        List<Point> points = Arrays.stream(blocked).map(Point::new).collect(Collectors.toList());\\n        Set<Point> blockedPoints = new HashSet<>(points);\\n\\n        // Map for union-find parent relationship\\n        Map<Point, Point> parentMap = new HashMap<>();\\n        \\n        // Combine points into a single range, if they are next to each other                \\n        for (Point point : points) parentMap.put(point, point);\\n        for (int i = 0; i < points.size(); i++) {\\n            for (int j = i + 1; j < points.size(); j++) {\\n                Point p1 = points.get(i);\\n                Point p2 = points.get(j);\\n\\n                if (Math.abs(p1.x - p2.x) <= 1 && Math.abs(p1.y - p2.y) <= 1) {\\n                    combine(p1, p2, parentMap);\\n                }\\n            }\\n        }\\n\\n        // Let\\'s check how many connected ranges (rectangular)\\n        Map<Point, int[]> boundaryMap = new HashMap<>(); // int[4]{ left, right, top, bottom }\\n        for (Point point : points) {\\n            Point root = getRoot(point, parentMap);\\n\\n            if (boundaryMap.containsKey(root)) {\\n                int[] range = boundaryMap.get(root);\\n                boundaryMap.put(root, new int[]{\\n                        Math.min(point.x, range[0]),\\n                        Math.max(point.x, range[1]),\\n                        Math.min(point.y, range[2]),\\n                        Math.max(point.y, range[3])\\n                });\\n            } else {\\n                boundaryMap.put(root, new int[]{point.x, point.x, point.y, point.y});\\n            }\\n        }\\n\\n        // If soruce cannot reach target, one of them has to be trapped inside one of the ranges\\n        // BFS if one of the end point is within one of the ranges\\n        Point start = new Point(source);\\n        Point end = new Point(target);\\n\\n        for (int[] range : boundaryMap.values()) {\\n            if (withinRange(start, range) && !bfs(start, end, range, blockedPoints)\\n                    || withinRange(end, range) && !bfs(end, start, range, blockedPoints)) {\\n                return false;\\n            }\\n        }\\n\\n        return true;\\n    }\\n\\n    private boolean bfs(Point start, Point end, int[] range, Set<Point> blocked) {\\n        Deque<Point> queue = new LinkedList<>();\\n        Set<Point> visited = new HashSet<>();\\n\\n        queue.add(start);\\n\\n        while (queue.size() > 0) {\\n            Point point = queue.poll();\\n\\n            if (visited.contains(point)) continue;\\n            if (point.x < 0 || point.x >= 1000000 || point.y < 0 || point.y >= 1000000) continue;\\n            if (blocked.contains(point)) continue;\\n\\n            visited.add(point);\\n\\n            if (!withinRange(point, range)) {\\n                return true;\\n            }\\n\\n            if (point.equals(end)) {\\n                return true;\\n            }\\n\\n            queue.add(new Point(point.x - 1, point.y));\\n            queue.add(new Point(point.x + 1, point.y));\\n            queue.add(new Point(point.x, point.y - 1));\\n            queue.add(new Point(point.x, point.y + 1));\\n        }\\n\\n        return false;\\n    }\\n\\n    private boolean withinRange(Point p, int[] range) {\\n        return withinRange(p.x, p.y, range);\\n    }\\n\\n    private boolean withinRange(int x, int y, int[] range) {\\n        return x >= range[0] && x <= range[1] && y >= range[2] && y <= range[3];\\n    }\\n\\n    private Point combine(Point p1, Point p2, Map<Point, Point> parentMap) {\\n        Point p1Parent = parentMap.get(p1);\\n        parentMap.put(p2, p1Parent);\\n\\n        return p1Parent;\\n    }\\n\\n    private Point getRoot(Point p, Map<Point, Point> parentMap) {\\n        Point parent = parentMap.get(p);\\n\\n        if (p.equals(parent)) return parent;\\n\\n        Point root = getRoot(parent, parentMap);\\n        parentMap.put(p, root);\\n\\n        return root;\\n    }\\n\\n    private static class Point {\\n        int x, y;\\n\\n        public Point(int[] p) {\\n            this.x = p[0];\\n            this.y = p[1];\\n        }\\n\\n        public Point(int x, int y) {\\n            this.x = x;\\n            this.y = y;\\n        }\\n\\n        @Override\\n        public boolean equals(Object o) {\\n            if (this == o) return true;\\n            if (!(o instanceof Point)) return false;\\n\\n            Point that = (Point) o;\\n\\n            return this.x == that.x && this.y == that.y;\\n        }\\n\\n        @Override\\n        public int hashCode() {\\n            return (x << 16) ^ y;\\n        }\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public boolean isEscapePossible(int[][] blocked, int[] source, int[] target) {\\n        List<Point> points = Arrays.stream(blocked).map(Point::new).collect(Collectors.toList());\\n        Set<Point> blockedPoints = new HashSet<>(points);\\n\\n        // Map for union-find parent relationship\\n        Map<Point, Point> parentMap = new HashMap<>();\\n        \\n        // Combine points into a single range, if they are next to each other                \\n        for (Point point : points) parentMap.put(point, point);\\n        for (int i = 0; i < points.size(); i++) {\\n            for (int j = i + 1; j < points.size(); j++) {\\n                Point p1 = points.get(i);\\n                Point p2 = points.get(j);\\n\\n                if (Math.abs(p1.x - p2.x) <= 1 && Math.abs(p1.y - p2.y) <= 1) {\\n                    combine(p1, p2, parentMap);\\n                }\\n            }\\n        }\\n\\n        // Let\\'s check how many connected ranges (rectangular)\\n        Map<Point, int[]> boundaryMap = new HashMap<>(); // int[4]{ left, right, top, bottom }\\n        for (Point point : points) {\\n            Point root = getRoot(point, parentMap);\\n\\n            if (boundaryMap.containsKey(root)) {\\n                int[] range = boundaryMap.get(root);\\n                boundaryMap.put(root, new int[]{\\n                        Math.min(point.x, range[0]),\\n                        Math.max(point.x, range[1]),\\n                        Math.min(point.y, range[2]),\\n                        Math.max(point.y, range[3])\\n                });\\n            } else {\\n                boundaryMap.put(root, new int[]{point.x, point.x, point.y, point.y});\\n            }\\n        }\\n\\n        // If soruce cannot reach target, one of them has to be trapped inside one of the ranges\\n        // BFS if one of the end point is within one of the ranges\\n        Point start = new Point(source);\\n        Point end = new Point(target);\\n\\n        for (int[] range : boundaryMap.values()) {\\n            if (withinRange(start, range) && !bfs(start, end, range, blockedPoints)\\n                    || withinRange(end, range) && !bfs(end, start, range, blockedPoints)) {\\n                return false;\\n            }\\n        }\\n\\n        return true;\\n    }\\n\\n    private boolean bfs(Point start, Point end, int[] range, Set<Point> blocked) {\\n        Deque<Point> queue = new LinkedList<>();\\n        Set<Point> visited = new HashSet<>();\\n\\n        queue.add(start);\\n\\n        while (queue.size() > 0) {\\n            Point point = queue.poll();\\n\\n            if (visited.contains(point)) continue;\\n            if (point.x < 0 || point.x >= 1000000 || point.y < 0 || point.y >= 1000000) continue;\\n            if (blocked.contains(point)) continue;\\n\\n            visited.add(point);\\n\\n            if (!withinRange(point, range)) {\\n                return true;\\n            }\\n\\n            if (point.equals(end)) {\\n                return true;\\n            }\\n\\n            queue.add(new Point(point.x - 1, point.y));\\n            queue.add(new Point(point.x + 1, point.y));\\n            queue.add(new Point(point.x, point.y - 1));\\n            queue.add(new Point(point.x, point.y + 1));\\n        }\\n\\n        return false;\\n    }\\n\\n    private boolean withinRange(Point p, int[] range) {\\n        return withinRange(p.x, p.y, range);\\n    }\\n\\n    private boolean withinRange(int x, int y, int[] range) {\\n        return x >= range[0] && x <= range[1] && y >= range[2] && y <= range[3];\\n    }\\n\\n    private Point combine(Point p1, Point p2, Map<Point, Point> parentMap) {\\n        Point p1Parent = parentMap.get(p1);\\n        parentMap.put(p2, p1Parent);\\n\\n        return p1Parent;\\n    }\\n\\n    private Point getRoot(Point p, Map<Point, Point> parentMap) {\\n        Point parent = parentMap.get(p);\\n\\n        if (p.equals(parent)) return parent;\\n\\n        Point root = getRoot(parent, parentMap);\\n        parentMap.put(p, root);\\n\\n        return root;\\n    }\\n\\n    private static class Point {\\n        int x, y;\\n\\n        public Point(int[] p) {\\n            this.x = p[0];\\n            this.y = p[1];\\n        }\\n\\n        public Point(int x, int y) {\\n            this.x = x;\\n            this.y = y;\\n        }\\n\\n        @Override\\n        public boolean equals(Object o) {\\n            if (this == o) return true;\\n            if (!(o instanceof Point)) return false;\\n\\n            Point that = (Point) o;\\n\\n            return this.x == that.x && this.y == that.y;\\n        }\\n\\n        @Override\\n        public int hashCode() {\\n            return (x << 16) ^ y;\\n        }\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 748150,
                "title": "c-bfs-with-explanation",
                "content": "Notice that the dimension of the grid is 10^6 which is very large so that we will get TLE if we do BFS directly. Also notice that the number of blocked cell is at most 200, which means that most of the cells in the grid is empty and basically useless.\\n\\nTo solve the aforementioned issue, we need to compress the large grid into a smaller one by observing which cells are meaningful.\\n\\nWe use a set to storage every x cooredinate of ```blocked[i]```, ```source```, and ```target```. Then, we re-index the numbers in the set. We leave an empty index for the spaces between any two adjacent numbers in the set except for the case that the two adjacent numbers are different by one.\\n\\nNotice that we also need to be careful about the edge cases to prevent the correspondence from going wrong.\\n\\nFor example:\\n```\\nset     =   { 5,    60,     102,      103,      992,    999999}\\nnew index = { 1,     3,       5,        6,        8,        10}\\n--> new grid has n = 11\\n(index 0 represents the whole range of 0 ~ 4,\\n index 2 represents the whole range of 61 ~ 101, and so on)\\n%---------------------------------------------------------------\\nset     =   { 0,    60,     102,      103,       1000}\\nnew index = { 0,     2,       4,        5,          7}\\n(index 8 represents the whole range of 1001 ~ 999999)\\n--> new grid has n = 9\\n```\\n\\nAfter that, we can just do a simple BFS since the dimension now is smaller than 500.\\n\\nCode:\\n\\n```\\nclass Solution {\\npublic:\\n    bool isEscapePossible(vector<vector<int>>& blocked, vector<int>& source, vector<int>& target) {\\n        set<int> sx, sy;\\n        for (vector<int>& b : blocked) sx.insert(b[0]), sy.insert(b[1]);\\n        sx.insert(source[0]), sy.insert(source[1]);\\n        sx.insert(target[0]), sy.insert(target[1]);\\n        int n = -1, m = -1, last = -1;\\n        unordered_map<int, int> xm, ym;\\n        for (auto it = sx.begin(); it != sx.end(); it++)\\n        {\\n            if (*it == last + 1) n++;\\n            else n += 2;\\n            xm[*it] = n;\\n            last = *it;\\n        }\\n        if (last != 999999) n++;\\n        n++;\\n        last = -1;\\n        for (auto it = sy.begin(); it != sy.end(); it++)\\n        {\\n            if (*it == last + 1) m++;\\n            else m += 2;\\n            ym[*it] = m;\\n            last = *it;\\n        }\\n        if (last != 999999) m++;\\n        m++;\\n        vector<vector<bool>> v(n, vector<bool>(m, true));\\n        vector<vector<bool>> vis(n, vector<bool>(m, false));\\n        for (vector<int>& b : blocked) v[xm[b[0]]][ym[b[1]]] = false;\\n        int x = xm[source[0]], y = ym[source[1]];\\n        int tx = xm[target[0]], ty = ym[target[1]];\\n        queue<int> que;\\n        que.push(x << 16 | y);\\n        vis[x][y] = true;\\n        vector<vector<int>> dirs = {{1,0},{0,1},{-1,0},{0,-1}};\\n        while (!que.empty())\\n        {\\n            int p = que.front(), q = p & 0xFFFF;\\n            p >>= 16;\\n            que.pop();\\n            for (vector<int>& d : dirs)\\n            {\\n                int tmpp = p + d[0], tmpq = q + d[1];\\n                if (tmpp < 0 || tmpp >= n || tmpq < 0 || tmpq >= m || !v[tmpp][tmpq] || vis[tmpp][tmpq]) continue;\\n                if (tmpp == tx && tmpq == ty) return true;\\n                vis[tmpp][tmpq] = true;\\n                que.push(tmpp << 16 | tmpq);\\n            }\\n        }\\n        return false;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```blocked[i]```\n```source```\n```target```\n```\\nset     =   { 5,    60,     102,      103,      992,    999999}\\nnew index = { 1,     3,       5,        6,        8,        10}\\n--> new grid has n = 11\\n(index 0 represents the whole range of 0 ~ 4,\\n index 2 represents the whole range of 61 ~ 101, and so on)\\n%---------------------------------------------------------------\\nset     =   { 0,    60,     102,      103,       1000}\\nnew index = { 0,     2,       4,        5,          7}\\n(index 8 represents the whole range of 1001 ~ 999999)\\n--> new grid has n = 9\\n```\n```\\nclass Solution {\\npublic:\\n    bool isEscapePossible(vector<vector<int>>& blocked, vector<int>& source, vector<int>& target) {\\n        set<int> sx, sy;\\n        for (vector<int>& b : blocked) sx.insert(b[0]), sy.insert(b[1]);\\n        sx.insert(source[0]), sy.insert(source[1]);\\n        sx.insert(target[0]), sy.insert(target[1]);\\n        int n = -1, m = -1, last = -1;\\n        unordered_map<int, int> xm, ym;\\n        for (auto it = sx.begin(); it != sx.end(); it++)\\n        {\\n            if (*it == last + 1) n++;\\n            else n += 2;\\n            xm[*it] = n;\\n            last = *it;\\n        }\\n        if (last != 999999) n++;\\n        n++;\\n        last = -1;\\n        for (auto it = sy.begin(); it != sy.end(); it++)\\n        {\\n            if (*it == last + 1) m++;\\n            else m += 2;\\n            ym[*it] = m;\\n            last = *it;\\n        }\\n        if (last != 999999) m++;\\n        m++;\\n        vector<vector<bool>> v(n, vector<bool>(m, true));\\n        vector<vector<bool>> vis(n, vector<bool>(m, false));\\n        for (vector<int>& b : blocked) v[xm[b[0]]][ym[b[1]]] = false;\\n        int x = xm[source[0]], y = ym[source[1]];\\n        int tx = xm[target[0]], ty = ym[target[1]];\\n        queue<int> que;\\n        que.push(x << 16 | y);\\n        vis[x][y] = true;\\n        vector<vector<int>> dirs = {{1,0},{0,1},{-1,0},{0,-1}};\\n        while (!que.empty())\\n        {\\n            int p = que.front(), q = p & 0xFFFF;\\n            p >>= 16;\\n            que.pop();\\n            for (vector<int>& d : dirs)\\n            {\\n                int tmpp = p + d[0], tmpq = q + d[1];\\n                if (tmpp < 0 || tmpp >= n || tmpq < 0 || tmpq >= m || !v[tmpp][tmpq] || vis[tmpp][tmpq]) continue;\\n                if (tmpp == tx && tmpq == ty) return true;\\n                vis[tmpp][tmpq] = true;\\n                que.push(tmpp << 16 | tmpq);\\n            }\\n        }\\n        return false;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 671558,
                "title": "simple-c-solution",
                "content": "```\\nclass Solution {\\n\\tint y_len;\\n\\tint x_len;\\n\\n\\tmap<int, map<int, bool> > m_Visited;\\n\\tint dist;\\n\\tlist< pair<int, int>> m_Queue;\\n\\tpair<int, int>      _end;\\n\\tpair<int, int>      _start;\\n\\n\\tset <pair<int, int> > _block;\\npublic:\\n\\tbool isEscapePossible(vector<vector<int>>& blocked, vector<int>& start, vector<int>& target){\\n\\t\\tbool res = false;\\n\\n\\t\\tx_len = 1000000;\\n\\t\\ty_len = 1000000;\\n\\n\\t\\tm_Visited[start[0]][start[1]] = true;\\n\\t\\t_start = pair<int, int>(start[0], start[1]);\\n\\t\\t_end = pair<int, int>(target[0], target[1]);\\n\\n\\t\\tfor (const vector<int> & p : blocked){\\n\\t\\t\\tpair<int, int> t = pair<int, int>(p[0], p[1]);\\n\\t\\t\\t_block.insert(t);\\n\\t\\t}\\n\\n\\t\\tm_Queue.push_front(_start);\\n\\t\\tres = makeMoves(_start);\\n\\n\\t\\tif (res){\\n\\t\\t\\tprintf(\"%s\", \"\\\\n\");\\n\\t\\t\\tm_Queue.clear();\\n\\t\\t\\tm_Queue.push_front(_end);\\n\\t\\t\\tres = makeMoves(_end);\\n\\t\\t}\\n\\t\\treturn res;\\n\\t}\\n    \\n\\tbool makeMoves(pair<int, int>  & to){\\n\\t\\tbool res = false;\\n\\t\\twhile (m_Queue.size() && res == false){\\n\\t\\t\\tpair<int, int> & _from = *m_Queue.begin();\\n\\t\\t\\tres = MoveOne(_from, to, \\'l\\') ||\\n\\t\\t\\t\\tMoveOne(_from, to, \\'u\\') ||\\n\\t\\t\\t\\tMoveOne(_from, to, \\'d\\') ||\\n\\t\\t\\t\\tMoveOne(_from, to, \\'r\\');\\n\\t\\t\\tm_Queue.pop_front();\\n\\t\\t}\\n\\t\\treturn res;\\n\\t}\\n    \\n\\tbool MoveOne(pair<int, int> & from, pair<int, int> to, char pos){\\n\\t\\tbool res = false;\\n\\t\\tint idy = from.second;\\n\\t\\tint idx = from.first;\\n\\n\\t\\tpair<int, int> & end = (to == _start) ? _end : _start;\\n\\n\\t\\tbool bMoved = false;\\n\\t\\tswitch (pos){\\n\\t\\tcase \\'l\\':\\n\\t\\t\\twhile (maze(idx - 1, idy) != 1 && abs(from.first - idx) <= 200){\\n\\t\\t\\t\\tidx--;\\n\\t\\t\\t\\tbMoved = true;\\n\\t\\t\\t}\\n\\t\\t\\tbreak;\\n\\t\\tcase \\'r\\':\\n\\t\\t\\twhile (maze(idx + 1, idy) != 1 && abs(from.first - idx) <= 200){\\n\\t\\t\\t\\tidx++;\\n\\t\\t\\t\\tbMoved = true;\\n\\t\\t\\t}\\n\\t\\t\\tbreak;\\n\\t\\tcase \\'u\\':\\n\\t\\t\\twhile (maze(idx, idy + 1) != 1 && abs(from.second - idy) <= 200){\\n\\t\\t\\t\\tidy++;\\n\\t\\t\\t\\tbMoved = true;\\n\\t\\t\\t}\\n\\t\\t\\tbreak;\\n\\t\\tcase \\'d\\':\\n\\t\\t\\twhile (maze(idx, idy - 1) != 1 && abs(from.second - idy) <= 200){\\n\\t\\t\\t\\tidy--;\\n\\t\\t\\t\\tbMoved = true;\\n\\t\\t\\t}\\n\\t\\t\\tbreak;\\n\\t\\t}\\n\\n\\t\\tpair<int, int> new_pos = pair<int, int>(idx, idy);\\n\\t\\tint current_dist = getDistance(new_pos, to);\\n\\t\\tif (bMoved &&\\n\\t\\t\\tm_Visited[idx][idy] == false &&\\n\\t\\t\\tcurrent_dist <= 200){\\n\\t\\t\\tm_Queue.push_back(new_pos);\\n\\t\\t\\tm_Visited[idx][idy] = true;\\n\\t\\t}\\n\\t\\tif (current_dist > 200 || new_pos == end){\\n\\t\\t\\tres = true;\\n\\t\\t}\\n\\t\\treturn res;\\n\\t}\\n    \\n\\tint maze(int x, int y){\\n\\t\\tif (x < 0) return 1;\\n\\t\\telse if (x > 1000000) return 1;\\n\\t\\tif (y < 0) return 1;\\n\\t\\telse if (y > 1000000) return 1;\\n\\t\\tpair<int, int> xy = pair<int, int>(x, y);\\n\\t\\tif (_block.find(xy) != _block.end())\\n\\t\\t\\treturn 1;\\n\\t\\treturn 0;\\n\\t}\\n    \\n\\tint getDistance(pair<int, int> &one, pair<int, int> & two){\\n\\t\\tint xdist = abs(one.first - two.first);\\n\\t\\tint ydist = abs(one.second - two.second);\\n\\t\\tint dist = sqrt(xdist*xdist + ydist*ydist);\\n\\t\\treturn dist;\\n\\t}\\n    \\n\\tint max(int a, int b){\\n\\t\\treturn a >= b ? a : b;\\n\\t}\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n\\tint y_len;\\n\\tint x_len;\\n\\n\\tmap<int, map<int, bool> > m_Visited;\\n\\tint dist;\\n\\tlist< pair<int, int>> m_Queue;\\n\\tpair<int, int>      _end;\\n\\tpair<int, int>      _start;\\n\\n\\tset <pair<int, int> > _block;\\npublic:\\n\\tbool isEscapePossible(vector<vector<int>>& blocked, vector<int>& start, vector<int>& target){\\n\\t\\tbool res = false;\\n\\n\\t\\tx_len = 1000000;\\n\\t\\ty_len = 1000000;\\n\\n\\t\\tm_Visited[start[0]][start[1]] = true;\\n\\t\\t_start = pair<int, int>(start[0], start[1]);\\n\\t\\t_end = pair<int, int>(target[0], target[1]);\\n\\n\\t\\tfor (const vector<int> & p : blocked){\\n\\t\\t\\tpair<int, int> t = pair<int, int>(p[0], p[1]);\\n\\t\\t\\t_block.insert(t);\\n\\t\\t}\\n\\n\\t\\tm_Queue.push_front(_start);\\n\\t\\tres = makeMoves(_start);\\n\\n\\t\\tif (res){\\n\\t\\t\\tprintf(\"%s\", \"\\\\n\");\\n\\t\\t\\tm_Queue.clear();\\n\\t\\t\\tm_Queue.push_front(_end);\\n\\t\\t\\tres = makeMoves(_end);\\n\\t\\t}\\n\\t\\treturn res;\\n\\t}\\n    \\n\\tbool makeMoves(pair<int, int>  & to){\\n\\t\\tbool res = false;\\n\\t\\twhile (m_Queue.size() && res == false){\\n\\t\\t\\tpair<int, int> & _from = *m_Queue.begin();\\n\\t\\t\\tres = MoveOne(_from, to, \\'l\\') ||\\n\\t\\t\\t\\tMoveOne(_from, to, \\'u\\') ||\\n\\t\\t\\t\\tMoveOne(_from, to, \\'d\\') ||\\n\\t\\t\\t\\tMoveOne(_from, to, \\'r\\');\\n\\t\\t\\tm_Queue.pop_front();\\n\\t\\t}\\n\\t\\treturn res;\\n\\t}\\n    \\n\\tbool MoveOne(pair<int, int> & from, pair<int, int> to, char pos){\\n\\t\\tbool res = false;\\n\\t\\tint idy = from.second;\\n\\t\\tint idx = from.first;\\n\\n\\t\\tpair<int, int> & end = (to == _start) ? _end : _start;\\n\\n\\t\\tbool bMoved = false;\\n\\t\\tswitch (pos){\\n\\t\\tcase \\'l\\':\\n\\t\\t\\twhile (maze(idx - 1, idy) != 1 && abs(from.first - idx) <= 200){\\n\\t\\t\\t\\tidx--;\\n\\t\\t\\t\\tbMoved = true;\\n\\t\\t\\t}\\n\\t\\t\\tbreak;\\n\\t\\tcase \\'r\\':\\n\\t\\t\\twhile (maze(idx + 1, idy) != 1 && abs(from.first - idx) <= 200){\\n\\t\\t\\t\\tidx++;\\n\\t\\t\\t\\tbMoved = true;\\n\\t\\t\\t}\\n\\t\\t\\tbreak;\\n\\t\\tcase \\'u\\':\\n\\t\\t\\twhile (maze(idx, idy + 1) != 1 && abs(from.second - idy) <= 200){\\n\\t\\t\\t\\tidy++;\\n\\t\\t\\t\\tbMoved = true;\\n\\t\\t\\t}\\n\\t\\t\\tbreak;\\n\\t\\tcase \\'d\\':\\n\\t\\t\\twhile (maze(idx, idy - 1) != 1 && abs(from.second - idy) <= 200){\\n\\t\\t\\t\\tidy--;\\n\\t\\t\\t\\tbMoved = true;\\n\\t\\t\\t}\\n\\t\\t\\tbreak;\\n\\t\\t}\\n\\n\\t\\tpair<int, int> new_pos = pair<int, int>(idx, idy);\\n\\t\\tint current_dist = getDistance(new_pos, to);\\n\\t\\tif (bMoved &&\\n\\t\\t\\tm_Visited[idx][idy] == false &&\\n\\t\\t\\tcurrent_dist <= 200){\\n\\t\\t\\tm_Queue.push_back(new_pos);\\n\\t\\t\\tm_Visited[idx][idy] = true;\\n\\t\\t}\\n\\t\\tif (current_dist > 200 || new_pos == end){\\n\\t\\t\\tres = true;\\n\\t\\t}\\n\\t\\treturn res;\\n\\t}\\n    \\n\\tint maze(int x, int y){\\n\\t\\tif (x < 0) return 1;\\n\\t\\telse if (x > 1000000) return 1;\\n\\t\\tif (y < 0) return 1;\\n\\t\\telse if (y > 1000000) return 1;\\n\\t\\tpair<int, int> xy = pair<int, int>(x, y);\\n\\t\\tif (_block.find(xy) != _block.end())\\n\\t\\t\\treturn 1;\\n\\t\\treturn 0;\\n\\t}\\n    \\n\\tint getDistance(pair<int, int> &one, pair<int, int> & two){\\n\\t\\tint xdist = abs(one.first - two.first);\\n\\t\\tint ydist = abs(one.second - two.second);\\n\\t\\tint dist = sqrt(xdist*xdist + ydist*ydist);\\n\\t\\treturn dist;\\n\\t}\\n    \\n\\tint max(int a, int b){\\n\\t\\treturn a >= b ? a : b;\\n\\t}\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 588273,
                "title": "condition-0-blocked-i-j-10-6",
                "content": "I guess you are trying to say that `i` and `j` themselves are within the range of [0, 10^6) ?",
                "solutionTags": [],
                "code": "I guess you are trying to say that `i` and `j` themselves are within the range of [0, 10^6) ?",
                "codeTag": "Unknown"
            },
            {
                "id": 560787,
                "title": "100-100-dfs-solution-go",
                "content": "```\\n\\ntype DFSBase struct{\\n    startX int\\n    startY int\\n    points map[int]int\\n   \\n}\\n\\nfunc (host *DFSBase) locked(x int, y int) bool{\\n    if x<0 {\\n        return true\\n    }\\n    if x>1000000 {\\n        return true\\n    }\\n    if y<0 {\\n        return true\\n    }\\n    if y>1000000 {\\n        return true\\n    }\\n    a:=x-host.startX\\n    if a<0 {\\n        a = -a\\n    }\\n    b:=y-host.startY\\n    if b<0 {\\n        b = -b\\n    }\\n    if a+b > 210 {\\n        return false\\n    }\\n    \\n    z:=1000001*x + y\\n    _, ok := host.points[z]\\n    if ok {\\n        return true\\n    }\\n    host.points[z] = 1\\n    return  host.locked(x, y-1) && host.locked(x, y +1) && host.locked(x-1, y) && host.locked(x+1, y)\\n}\\n\\n\\n\\n\\n\\n\\n\\nfunc isEscapePossible(blocked [][]int, source []int, target []int) bool {\\n    var b DFSBase\\n    b.points = make(map[int]int)\\n    n:=len(blocked)\\n    for i:=0; i<n; i++ {\\n        if blocked[i][0] == source[0] && blocked[i][1] == source[1] {\\n            return false\\n        }\\n        if blocked[i][0] == target[0] && blocked[i][1] == target[1] {\\n            return false\\n        }\\n        b.points[1000001*blocked[i][0] +  blocked[i][1]] = 1\\n    }\\n    b.startX = source[0]\\n    b.startY = source[1]\\n    \\n    if b.locked(source[0], source[1]) {\\n        _, ok :=b.points[target[0]*1000001+target[1]]\\n        return ok\\n    }\\n    \\n    b.points = make(map[int]int)\\n    for i:=0; i<n; i++ {\\n        if blocked[i][0] == source[0] && blocked[i][1] == source[1] {\\n            return false\\n        }\\n        if blocked[i][0] == target[0] && blocked[i][1] == target[1] {\\n            return false\\n        }\\n        b.points[1000001*blocked[i][0] +  blocked[i][1]] = 1\\n    }\\n    b.startX = target[0]\\n    b.startY = target[1]\\n    \\n    return !b.locked(target[0], target[1])\\n    \\n}\\n```",
                "solutionTags": [],
                "code": "```\\n\\ntype DFSBase struct{\\n    startX int\\n    startY int\\n    points map[int]int\\n   \\n}\\n\\nfunc (host *DFSBase) locked(x int, y int) bool{\\n    if x<0 {\\n        return true\\n    }\\n    if x>1000000 {\\n        return true\\n    }\\n    if y<0 {\\n        return true\\n    }\\n    if y>1000000 {\\n        return true\\n    }\\n    a:=x-host.startX\\n    if a<0 {\\n        a = -a\\n    }\\n    b:=y-host.startY\\n    if b<0 {\\n        b = -b\\n    }\\n    if a+b > 210 {\\n        return false\\n    }\\n    \\n    z:=1000001*x + y\\n    _, ok := host.points[z]\\n    if ok {\\n        return true\\n    }\\n    host.points[z] = 1\\n    return  host.locked(x, y-1) && host.locked(x, y +1) && host.locked(x-1, y) && host.locked(x+1, y)\\n}\\n\\n\\n\\n\\n\\n\\n\\nfunc isEscapePossible(blocked [][]int, source []int, target []int) bool {\\n    var b DFSBase\\n    b.points = make(map[int]int)\\n    n:=len(blocked)\\n    for i:=0; i<n; i++ {\\n        if blocked[i][0] == source[0] && blocked[i][1] == source[1] {\\n            return false\\n        }\\n        if blocked[i][0] == target[0] && blocked[i][1] == target[1] {\\n            return false\\n        }\\n        b.points[1000001*blocked[i][0] +  blocked[i][1]] = 1\\n    }\\n    b.startX = source[0]\\n    b.startY = source[1]\\n    \\n    if b.locked(source[0], source[1]) {\\n        _, ok :=b.points[target[0]*1000001+target[1]]\\n        return ok\\n    }\\n    \\n    b.points = make(map[int]int)\\n    for i:=0; i<n; i++ {\\n        if blocked[i][0] == source[0] && blocked[i][1] == source[1] {\\n            return false\\n        }\\n        if blocked[i][0] == target[0] && blocked[i][1] == target[1] {\\n            return false\\n        }\\n        b.points[1000001*blocked[i][0] +  blocked[i][1]] = 1\\n    }\\n    b.startX = target[0]\\n    b.startY = target[1]\\n    \\n    return !b.locked(target[0], target[1])\\n    \\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 540003,
                "title": "split-blocks-to-connected-subset-o-b-2",
                "content": "If we split `blocked` to a set of connected subsets, we can solve our issue separately for every connected set. B(x) - the minimal rectangle which contains block `x`. There are 4 possibilities:\\n1) `s` and `t` is inside B(x). In this case we need to find the way from `s` to `t`. We can do it inside a rectangle containing B(x) and its frame (where its frame is inside the grid). We must add the frame, as the way only inside B(x) can not exists. Like:\\n```\\n|xt.\\n|sx.\\n|...\\n+--\\n```\\n2-3) only `s`(`t`) is inside B(x), so we need to check if there is a way from `s`(`t`) to the outside\\n4) `s` and `t` are outdside B(x) - the way exists. \\nMy Scala version:\\n```\\nobject Solution {\\n  type Cell = (Int, Int)\\n\\n  def isEscapePossible(blocked: Array[Array[Int]], source: Array[Int], target: Array[Int]): Boolean = helper(\\n      blocked.map(b => b.head -> b.last).toSet,\\n      (source.head, source.last),\\n      (target.head, target.last)\\n    )\\n\\n  private def helper(blocks: Set[Cell], s: Cell, t: Cell): Boolean =\\n    if (blocks.isEmpty) true\\n    else {\\n      val ConnectedResp(connected, newBlocks, tl, br) = // get subset of connected blocks related with the first element\\n        getConnected(Set(blocks.head), ConnectedResp(Set.empty, blocks, (1000000, -1), (-1, 1000000)))\\n\\n      val sIsInside = isInside(tl, br, s)\\n      val tIsInside = isInside(tl, br, t)\\n\\n      val passed = // is there a way?\\n        if (sIsInside && tIsInside) {\\n          val vis = Array.fill(br._1 - tl._1 + 3)(Array.fill(tl._2 - br._2 + 3)(false)) // we can move not only\\n          // inside of the square, but on the periphery, so we must add a frame of 2 rows and 2 columns to visited\\n          wayToExists(connected, Set(s), t, tl, br, vis)\\n        }\\n        else {\\n          val vis = Array.fill(br._1 - tl._1 + 1)(Array.fill(tl._2 - br._2 + 1)(false))\\n          if (sIsInside) wayOutsideExists(connected, Set(s), tl, br, vis)\\n          else if (tIsInside) wayOutsideExists(connected, Set(t), tl, br, vis)\\n          else true\\n        }\\n\\n      if (passed) helper(newBlocks, s, t) // check the next connected maze\\n      else false\\n    }\\n\\n  case class ConnectedResp(connected: Set[Cell], rest: Set[Cell], topLeft: Cell, bottomRight: Cell)\\n\\n  // Splits set of Cells on connected subset and the rest\\n  private def getConnected(\\n    q: Set[Cell],\\n    res: ConnectedResp\\n  ): ConnectedResp =\\n    if (q.isEmpty) res\\n    else {\\n      val rest = res.rest -- q\\n      val (newTopLeft, newTopRight) = ((res.topLeft, res.bottomRight) /: q){ case ((t, b), p) =>\\n        ((t._1 min p._1, t._2 max p._2), (b._1 max p._1, b._2 min p._2))\\n      }\\n\\n      getConnected(\\n        q.flatMap(getNeighbours(_).filter(rest.contains)),\\n        ConnectedResp(res.connected ++ q, rest, newTopLeft, newTopRight)\\n      )\\n    }\\n\\n  // all cells around p (diagonally also). Actually there is p too, but we are going to filter it, as visited\\n  private def getNeighbours(p: Cell): Seq[Cell] = for (i <- -1 to 1; j <- -1 to 1) yield (p._1 + i, p._2 + j)\\n\\n  // if p is inside the minimal square including (tl and br)\\n  private def isInside(tl: Cell, br: Cell, p: Cell) =\\n    p._1 >= tl._1 && p._1 <= br._1 && p._2 <= tl._2 && p._2 >= br._2\\n\\n  // bfs travers of a maze in search a way from `s` to `t`\\n  private def wayToExists(\\n    blocks: Set[Cell],\\n    s: Set[Cell],\\n    t: Cell,\\n    tl: Cell,\\n    br: Cell,\\n    vis: Array[Array[Boolean]]\\n  ): Boolean =\\n    if (s.isEmpty) false\\n    else {\\n      s.foreach(c => vis(c._1 - tl._1 + 1)(c._2 - br._2 + 1) = true)\\n\\n      val np = s\\n        .flatMap(getMoves)\\n        .filter{p =>\\n          p._1 >= tl._1 - 1 && // we must use not only (tl, br)-rectangle, but also its frame\\n          p._1 <= br._1 + 1 && // so we can solve cases like\\n          p._2 <= tl._2 + 1 && // xt\\n          p._2 >= br._2 - 1 && // sx\\n          !vis(p._1 - tl._1 + 1)(p._2 - br._2 + 1) &&\\n          !blocks.contains(p)\\n        }\\n\\n      if (np.contains(t)) true\\n      else wayToExists(blocks, np, t, tl, br, vis)\\n    }\\n\\n  // possible moves from cell `p`\\n  private def getMoves(p: Cell) =\\n    Seq((p._1 - 1, p._2), (p._1 + 1, p._2), (p._1, p._2 - 1), (p._1, p._2 + 1))\\n      .filter(c => c._1 >= 0 && c._1 < 1000000 && c._2 >= 0 && c._2 < 1000000)\\n\\n  // check if there is a way from cell `p` outside the (tl, br)-rectangle\\n  private def wayOutsideExists(\\n    blocks: Set[Cell],\\n    p: Set[Cell],\\n    tl: Cell,\\n    br: Cell,\\n    vis: Array[Array[Boolean]]\\n  ): Boolean =\\n    if (p.isEmpty) false\\n    else {\\n      p.foreach(c => vis(c._1 - tl._1)(c._2 - br._2) = true)\\n      val np = p.flatMap(getMoves)\\n\\n      if (np.exists(!isInside(tl, br, _))) true\\n      else {\\n        wayOutsideExists(blocks, np\\n          .filter { p =>\\n            !vis(p._1 - tl._1)(p._2 - br._2) &&\\n            !blocks.contains(p)\\n          }, tl, br, vis)\\n      }\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\n|xt.\\n|sx.\\n|...\\n+--\\n```\n```\\nobject Solution {\\n  type Cell = (Int, Int)\\n\\n  def isEscapePossible(blocked: Array[Array[Int]], source: Array[Int], target: Array[Int]): Boolean = helper(\\n      blocked.map(b => b.head -> b.last).toSet,\\n      (source.head, source.last),\\n      (target.head, target.last)\\n    )\\n\\n  private def helper(blocks: Set[Cell], s: Cell, t: Cell): Boolean =\\n    if (blocks.isEmpty) true\\n    else {\\n      val ConnectedResp(connected, newBlocks, tl, br) = // get subset of connected blocks related with the first element\\n        getConnected(Set(blocks.head), ConnectedResp(Set.empty, blocks, (1000000, -1), (-1, 1000000)))\\n\\n      val sIsInside = isInside(tl, br, s)\\n      val tIsInside = isInside(tl, br, t)\\n\\n      val passed = // is there a way?\\n        if (sIsInside && tIsInside) {\\n          val vis = Array.fill(br._1 - tl._1 + 3)(Array.fill(tl._2 - br._2 + 3)(false)) // we can move not only\\n          // inside of the square, but on the periphery, so we must add a frame of 2 rows and 2 columns to visited\\n          wayToExists(connected, Set(s), t, tl, br, vis)\\n        }\\n        else {\\n          val vis = Array.fill(br._1 - tl._1 + 1)(Array.fill(tl._2 - br._2 + 1)(false))\\n          if (sIsInside) wayOutsideExists(connected, Set(s), tl, br, vis)\\n          else if (tIsInside) wayOutsideExists(connected, Set(t), tl, br, vis)\\n          else true\\n        }\\n\\n      if (passed) helper(newBlocks, s, t) // check the next connected maze\\n      else false\\n    }\\n\\n  case class ConnectedResp(connected: Set[Cell], rest: Set[Cell], topLeft: Cell, bottomRight: Cell)\\n\\n  // Splits set of Cells on connected subset and the rest\\n  private def getConnected(\\n    q: Set[Cell],\\n    res: ConnectedResp\\n  ): ConnectedResp =\\n    if (q.isEmpty) res\\n    else {\\n      val rest = res.rest -- q\\n      val (newTopLeft, newTopRight) = ((res.topLeft, res.bottomRight) /: q){ case ((t, b), p) =>\\n        ((t._1 min p._1, t._2 max p._2), (b._1 max p._1, b._2 min p._2))\\n      }\\n\\n      getConnected(\\n        q.flatMap(getNeighbours(_).filter(rest.contains)),\\n        ConnectedResp(res.connected ++ q, rest, newTopLeft, newTopRight)\\n      )\\n    }\\n\\n  // all cells around p (diagonally also). Actually there is p too, but we are going to filter it, as visited\\n  private def getNeighbours(p: Cell): Seq[Cell] = for (i <- -1 to 1; j <- -1 to 1) yield (p._1 + i, p._2 + j)\\n\\n  // if p is inside the minimal square including (tl and br)\\n  private def isInside(tl: Cell, br: Cell, p: Cell) =\\n    p._1 >= tl._1 && p._1 <= br._1 && p._2 <= tl._2 && p._2 >= br._2\\n\\n  // bfs travers of a maze in search a way from `s` to `t`\\n  private def wayToExists(\\n    blocks: Set[Cell],\\n    s: Set[Cell],\\n    t: Cell,\\n    tl: Cell,\\n    br: Cell,\\n    vis: Array[Array[Boolean]]\\n  ): Boolean =\\n    if (s.isEmpty) false\\n    else {\\n      s.foreach(c => vis(c._1 - tl._1 + 1)(c._2 - br._2 + 1) = true)\\n\\n      val np = s\\n        .flatMap(getMoves)\\n        .filter{p =>\\n          p._1 >= tl._1 - 1 && // we must use not only (tl, br)-rectangle, but also its frame\\n          p._1 <= br._1 + 1 && // so we can solve cases like\\n          p._2 <= tl._2 + 1 && // xt\\n          p._2 >= br._2 - 1 && // sx\\n          !vis(p._1 - tl._1 + 1)(p._2 - br._2 + 1) &&\\n          !blocks.contains(p)\\n        }\\n\\n      if (np.contains(t)) true\\n      else wayToExists(blocks, np, t, tl, br, vis)\\n    }\\n\\n  // possible moves from cell `p`\\n  private def getMoves(p: Cell) =\\n    Seq((p._1 - 1, p._2), (p._1 + 1, p._2), (p._1, p._2 - 1), (p._1, p._2 + 1))\\n      .filter(c => c._1 >= 0 && c._1 < 1000000 && c._2 >= 0 && c._2 < 1000000)\\n\\n  // check if there is a way from cell `p` outside the (tl, br)-rectangle\\n  private def wayOutsideExists(\\n    blocks: Set[Cell],\\n    p: Set[Cell],\\n    tl: Cell,\\n    br: Cell,\\n    vis: Array[Array[Boolean]]\\n  ): Boolean =\\n    if (p.isEmpty) false\\n    else {\\n      p.foreach(c => vis(c._1 - tl._1)(c._2 - br._2) = true)\\n      val np = p.flatMap(getMoves)\\n\\n      if (np.exists(!isInside(tl, br, _))) true\\n      else {\\n        wayOutsideExists(blocks, np\\n          .filter { p =>\\n            !vis(p._1 - tl._1)(p._2 - br._2) &&\\n            !blocks.contains(p)\\n          }, tl, br, vis)\\n      }\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 515975,
                "title": "java-solution",
                "content": "```\\n\\nclass Solution {\\n    public boolean isEscapePossible(int[][] blocked, int[] source, int[] target) {\\n        if(blocked.length == 0)\\n            return true;\\n        Set<String>block=new HashSet<>();\\n             for(int i=0;i<blocked.length;i++)\\n                block.add(blocked[i][0]+\"->\"+blocked[i][1]);\\n        int sx=source[0],sy=source[1],tx=target[0],ty=target[1];\\n        if(block.contains(sx+\"->\"+(sy+1)) && block.contains(sx+\"->\"+(sy-1)) && block.contains((sx+1)+\"->\"+sy) && block.contains((sx-1)+\"->\"+sy))\\n           return false;\\n          if(block.contains(tx+\"->\"+(ty+1)) && block.contains(tx+\"->\"+(ty-1)) && block.contains((tx+1)+\"->\"+ty) && block.contains((tx-1)+\"->\"+ty))\\n           return false;\\n        return SolveUtil(block,sx,sy,sx,sy,tx,ty,new HashSet<>());\\n        }\\n    public boolean isSafe(int x, int y) \\n    {  \\n        return (x >= 0 && x <= 999999 && y >= 0 && y <= 999999); \\n    }\\n    public boolean SolveUtil(Set<String>block, int x, int y, int sx, int sy, int tx, int ty, Set<String>v){\\n        if(sx==tx && sy==ty)\\n            return true;\\n         if(Math.abs(sx-x)+Math.abs(sy-y) > 200) return true;\\n            v.add(sx+\"->\"+sy);\\n            if(isSafe(sx,sy+1) && !block.contains(sx+\"->\"+(sy+1)) && !v.contains(sx+\"->\"+(sy+1)))\\n                if(SolveUtil(block,x,y,sx,sy+1,tx,ty,v)) return true;\\n            if(isSafe(sx,sy-1) && !block.contains(sx+\"->\"+(sy-1)) && !v.contains(sx+\"->\"+(sy-1)))\\n                if(SolveUtil(block,x,y,sx,sy-1,tx,ty,v)) return true;\\n            if(isSafe(sx+1,sy) && !block.contains((sx+1)+\"->\"+sy) && !v.contains((sx+1)+\"->\"+sy))\\n                if(SolveUtil(block,x,y,sx+1,sy,tx,ty,v)) return true;\\n            if(isSafe(sx-1,sy) && !block.contains((sx-1)+\"->\"+sy) && !v.contains((sx-1)+\"->\"+sy))\\n                if(SolveUtil(block,x,y,sx-1,sy,tx,ty,v)) return true;\\n        return false;\\n    }\\n}",
                "solutionTags": [],
                "code": "class Solution {\\n    public boolean isEscapePossible(int[][] blocked, int[] source, int[] target) {\\n        if(blocked.length == 0)\\n            return true;\\n        Set<String>block=new HashSet<>();\\n             for(int i=0;i<blocked.length;i++)\\n                block.add(blocked[i][0]+\"->\"+blocked[i][1]);\\n        int sx=source[0],sy=source[1],tx=target[0],ty=target[1];\\n        if(block.contains(sx+\"->\"+(sy+1)) && block.contains(sx+\"->\"+(sy-1)) && block.contains((sx+1)+\"->\"+sy) && block.contains((sx-1)+\"->\"+sy))\\n           return false;\\n          if(block.contains(tx+\"->\"+(ty+1)) && block.contains(tx+\"->\"+(ty-1)) && block.contains((tx+1)+\"->\"+ty) && block.contains((tx-1)+\"->\"+ty))\\n           return false;\\n        return SolveUtil(block,sx,sy,sx,sy,tx,ty,new HashSet<>());\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 488620,
                "title": "100-runtime-scala-just-use-the-maximal-trapped-area-as-the-break-condition-two-parallelized-bfs",
                "content": "```Scala\\n  object Solution {\\n    def isEscapePossible(blocked: Array[Array[Int]], source: Array[Int], target: Array[Int]): Boolean = {\\n\\n      if (Math.abs((source(0) - target(0))) + Math.abs((source(1) - target(1))) <= 1 || blocked.isEmpty) return true\\n\\n      val maxSize = (blocked.length * blocked.length) >> 1\\n      val n = Math.pow(10, 6)\\n      val dx = Array(Array(0, 1), Array(0, -1), Array(1, 0), Array(-1, 0))\\n      val blockTuple = blocked.map(x => Tuple2(x(0), x(1)))\\n\\n      def f(root: (Int, Int), dest: (Int, Int)): Boolean = {\\n        if (blockTuple.contains(root) || blockTuple.contains(dest)) return false\\n        import scala.collection.mutable.{Queue, Set}\\n        val queue = Queue[(Int, Int)]()\\n        val isVisited = Set[(Int, Int)]()\\n        queue enqueue root\\n        while (!queue.isEmpty) {\\n          val curr = queue.dequeue()\\n          if ((curr._1 == dest._1 && curr._2 == dest._2) || isVisited.size > maxSize) return true\\n          if (!isVisited.contains(curr)) {\\n            isVisited add curr\\n            for (d <- dx) {\\n              val x = curr._1 + d(0)\\n              val y = curr._2 + d(1)\\n              if (x >= 0 && y >= 0 && x < n && y < n && !isVisited.contains(Tuple2(x, y)) && !blockTuple.contains(Tuple2(x, y))) queue enqueue Tuple2(x, y)\\n            }\\n          }\\n        }\\n        false\\n      }\\n\\n      import java.util.concurrent.{Executors, Callable}\\n      val executor = Executors.newFixedThreadPool(2)\\n      val task1: Callable[Boolean] = () => f(Tuple2(source(0), source(1)), Tuple2(target(0), target(1)))\\n      val task2: Callable[Boolean] = () => f(Tuple2(target(0), target(1)), Tuple2(source(0), source(1)))\\n      val r1 = executor.submit(task1)\\n      val r2 = executor.submit(task2)\\n      executor.shutdown\\n      r1.get() && r2.get()\\n    }\\n  }\\n```",
                "solutionTags": [],
                "code": "```Scala\\n  object Solution {\\n    def isEscapePossible(blocked: Array[Array[Int]], source: Array[Int], target: Array[Int]): Boolean = {\\n\\n      if (Math.abs((source(0) - target(0))) + Math.abs((source(1) - target(1))) <= 1 || blocked.isEmpty) return true\\n\\n      val maxSize = (blocked.length * blocked.length) >> 1\\n      val n = Math.pow(10, 6)\\n      val dx = Array(Array(0, 1), Array(0, -1), Array(1, 0), Array(-1, 0))\\n      val blockTuple = blocked.map(x => Tuple2(x(0), x(1)))\\n\\n      def f(root: (Int, Int), dest: (Int, Int)): Boolean = {\\n        if (blockTuple.contains(root) || blockTuple.contains(dest)) return false\\n        import scala.collection.mutable.{Queue, Set}\\n        val queue = Queue[(Int, Int)]()\\n        val isVisited = Set[(Int, Int)]()\\n        queue enqueue root\\n        while (!queue.isEmpty) {\\n          val curr = queue.dequeue()\\n          if ((curr._1 == dest._1 && curr._2 == dest._2) || isVisited.size > maxSize) return true\\n          if (!isVisited.contains(curr)) {\\n            isVisited add curr\\n            for (d <- dx) {\\n              val x = curr._1 + d(0)\\n              val y = curr._2 + d(1)\\n              if (x >= 0 && y >= 0 && x < n && y < n && !isVisited.contains(Tuple2(x, y)) && !blockTuple.contains(Tuple2(x, y))) queue enqueue Tuple2(x, y)\\n            }\\n          }\\n        }\\n        false\\n      }\\n\\n      import java.util.concurrent.{Executors, Callable}\\n      val executor = Executors.newFixedThreadPool(2)\\n      val task1: Callable[Boolean] = () => f(Tuple2(source(0), source(1)), Tuple2(target(0), target(1)))\\n      val task2: Callable[Boolean] = () => f(Tuple2(target(0), target(1)), Tuple2(source(0), source(1)))\\n      val r1 = executor.submit(task1)\\n      val r2 = executor.submit(task2)\\n      executor.shutdown\\n      r1.get() && r2.get()\\n    }\\n  }\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 434444,
                "title": "python-bfs-count-blocked-max-area",
                "content": "```\\nclass Solution:\\n    def isEscapePossible(self, blocked: List[List[int]], source: List[int], target: List[int]) -> bool:\\n        N=10**6\\n        bs=set() \\n        for b in blocked:\\n            bs.add(tuple(b))\\n\\n        def bfs(p):\\n            q=collections.deque()\\n            q.append(p)\\n            seen=set([tuple(p)])\\n            while q:\\n                x,y=q.popleft()\\n                if len(seen)>19900:return 1 # outside\\n                for nx,ny in ((x-1,y),(x,y-1),(x,y+1),(x+1,y)):\\n                    if (nx,ny) not in bs and (nx,ny,) not in seen and 0<=nx<N and 0<=ny<N:\\n                        q.append((nx,ny))\\n                        seen.add((nx,ny))\\n            return 0 # inside\\n        x,y=bfs(source),bfs(target)\\n        if x ^ y==1:return False\\n        else:return True\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def isEscapePossible(self, blocked: List[List[int]], source: List[int], target: List[int]) -> bool:\\n        N=10**6\\n        bs=set() \\n        for b in blocked:\\n            bs.add(tuple(b))\\n\\n        def bfs(p):\\n            q=collections.deque()\\n            q.append(p)\\n            seen=set([tuple(p)])\\n            while q:\\n                x,y=q.popleft()\\n                if len(seen)>19900:return 1 # outside\\n                for nx,ny in ((x-1,y),(x,y-1),(x,y+1),(x+1,y)):\\n                    if (nx,ny) not in bs and (nx,ny,) not in seen and 0<=nx<N and 0<=ny<N:\\n                        q.append((nx,ny))\\n                        seen.add((nx,ny))\\n            return 0 # inside\\n        x,y=bfs(source),bfs(target)\\n        if x ^ y==1:return False\\n        else:return True\\n```",
                "codeTag": "Java"
            },
            {
                "id": 384920,
                "title": "large-maze-to-small-maze",
                "content": "Although this maze is quite large, there\\'s only less block. Only the row of source, target, every block and rows besides them, and the column of source, target, every block and columns besides them matters. So we can convert it to a smaller maze.\\n```c++\\nconst static int _ = [](){\\n    ios::sync_with_stdio(false);\\n    cin.tie(0);\\n    return 0;\\n}();\\n\\nstruct MyHash {\\n    size_t operator() (const vector<int>& v) const {\\n        size_t h = 0;\\n        for (auto vv : v) h ^= hash<int>()(vv);\\n        return h;\\n    }\\n};\\n\\nclass Solution {\\npublic:\\n    bool isEscapePossible(vector<vector<int>>& blocked, vector<int>& source, vector<int>& target) {\\n        set<int> rows;\\n        rows.insert(source[0]);\\n        rows.insert(target[0]);\\n        set<int> cols;\\n        cols.insert(source[1]);\\n        cols.insert(target[1]);\\n        unordered_set<vector<int>, MyHash> visited;\\n        for (auto b : blocked) {\\n            rows.insert(b[0]);\\n            if (b[0] - 1 >= 0) rows.insert(b[0] - 1);\\n            if (b[0] + 1 < 1e6) rows.insert(b[0] + 1);\\n            cols.insert(b[1]);\\n            if (b[1] - 1 >= 0) cols.insert(b[1] - 1);\\n            if (b[1] + 1 < 1e6) cols.insert(b[1] + 1);\\n            visited.insert(b);\\n        }\\n        vector<int> rs(rows.begin(), rows.end());\\n        vector<int> cs(cols.begin(), cols.end());\\n        if (visited.find(source) != visited.end()) return false;\\n        visited.insert(source);\\n        int i = lower_bound(rs.begin(), rs.end(), source[0]) - rs.begin();\\n        int j = lower_bound(cs.begin(), cs.end(), source[1]) - cs.begin();\\n        int ti = lower_bound(rs.begin(), rs.end(), target[0]) - rs.begin();\\n        int tj = lower_bound(cs.begin(), cs.end(), target[1]) - cs.begin();\\n        queue<vector<int>> q;\\n        q.push({i, j});\\n        while (!q.empty()) {\\n            int i = q.front()[0];\\n            int j = q.front()[1];\\n            q.pop();\\n            if (i == ti && j == tj) return true;\\n            // up\\n            if (i-1 >= 0) {\\n                if (visited.find({rs[i-1], cs[j]}) == visited.end()) {\\n                    visited.insert({rs[i-1], cs[j]});\\n                    q.push({i-1, j});\\n                }\\n            }\\n            // down \\n            if (i+1 < rs.size()) {\\n                if (visited.find({rs[i+1], cs[j]}) == visited.end()) {\\n                    visited.insert({rs[i+1], cs[j]});\\n                    q.push({i+1, j});\\n                }\\n            }\\n            // left\\n            if (j-1 >= 0) {\\n                if (visited.find({rs[i], cs[j-1]}) == visited.end()) {\\n                    visited.insert({rs[i], cs[j-1]});\\n                    q.push({i, j-1});\\n                }\\n            }\\n            // right\\n            if (j+1 < cs.size()) {\\n                if (visited.find({rs[i], cs[j+1]}) == visited.end()) {\\n                    visited.insert({rs[i], cs[j+1]});\\n                    q.push({i, j+1});\\n                }\\n            }\\n        }\\n        return false;\\n    }\\n    \\n};\\n```",
                "solutionTags": [],
                "code": "```c++\\nconst static int _ = [](){\\n    ios::sync_with_stdio(false);\\n    cin.tie(0);\\n    return 0;\\n}();\\n\\nstruct MyHash {\\n    size_t operator() (const vector<int>& v) const {\\n        size_t h = 0;\\n        for (auto vv : v) h ^= hash<int>()(vv);\\n        return h;\\n    }\\n};\\n\\nclass Solution {\\npublic:\\n    bool isEscapePossible(vector<vector<int>>& blocked, vector<int>& source, vector<int>& target) {\\n        set<int> rows;\\n        rows.insert(source[0]);\\n        rows.insert(target[0]);\\n        set<int> cols;\\n        cols.insert(source[1]);\\n        cols.insert(target[1]);\\n        unordered_set<vector<int>, MyHash> visited;\\n        for (auto b : blocked) {\\n            rows.insert(b[0]);\\n            if (b[0] - 1 >= 0) rows.insert(b[0] - 1);\\n            if (b[0] + 1 < 1e6) rows.insert(b[0] + 1);\\n            cols.insert(b[1]);\\n            if (b[1] - 1 >= 0) cols.insert(b[1] - 1);\\n            if (b[1] + 1 < 1e6) cols.insert(b[1] + 1);\\n            visited.insert(b);\\n        }\\n        vector<int> rs(rows.begin(), rows.end());\\n        vector<int> cs(cols.begin(), cols.end());\\n        if (visited.find(source) != visited.end()) return false;\\n        visited.insert(source);\\n        int i = lower_bound(rs.begin(), rs.end(), source[0]) - rs.begin();\\n        int j = lower_bound(cs.begin(), cs.end(), source[1]) - cs.begin();\\n        int ti = lower_bound(rs.begin(), rs.end(), target[0]) - rs.begin();\\n        int tj = lower_bound(cs.begin(), cs.end(), target[1]) - cs.begin();\\n        queue<vector<int>> q;\\n        q.push({i, j});\\n        while (!q.empty()) {\\n            int i = q.front()[0];\\n            int j = q.front()[1];\\n            q.pop();\\n            if (i == ti && j == tj) return true;\\n            // up\\n            if (i-1 >= 0) {\\n                if (visited.find({rs[i-1], cs[j]}) == visited.end()) {\\n                    visited.insert({rs[i-1], cs[j]});\\n                    q.push({i-1, j});\\n                }\\n            }\\n            // down \\n            if (i+1 < rs.size()) {\\n                if (visited.find({rs[i+1], cs[j]}) == visited.end()) {\\n                    visited.insert({rs[i+1], cs[j]});\\n                    q.push({i+1, j});\\n                }\\n            }\\n            // left\\n            if (j-1 >= 0) {\\n                if (visited.find({rs[i], cs[j-1]}) == visited.end()) {\\n                    visited.insert({rs[i], cs[j-1]});\\n                    q.push({i, j-1});\\n                }\\n            }\\n            // right\\n            if (j+1 < cs.size()) {\\n                if (visited.find({rs[i], cs[j+1]}) == visited.end()) {\\n                    visited.insert({rs[i], cs[j+1]});\\n                    q.push({i, j+1});\\n                }\\n            }\\n        }\\n        return false;\\n    }\\n    \\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 381784,
                "title": "java-bfs",
                "content": "```\\nclass Solution \\n{\\n    public boolean isEscapePossible(int[][] blocked, int[] source, int[] target) \\n    {\\n        return bfs(blocked, source, target) && bfs(blocked, target, source);\\n    }\\n    \\n    boolean bfs(int[][] blocked, int[] source, int[] target)\\n    {\\n        Map<Integer, Set<Integer>> map = new HashMap();\\n        for (int[] b : blocked)\\n        {\\n            add(map, b);\\n        }\\n        \\n        int[][] dir = {{-1,0},{1,0},{0,-1},{0,1}};\\n        Queue<int[]> q = new LinkedList();\\n        q.add(source);\\n        add(map, source);\\n        \\n        int N = 1000000;\\n        int c_step = 0;\\n        while (!q.isEmpty())\\n        {\\n            ++c_step;\\n            if (c_step >= blocked.length) return true;\\n            for (int i = q.size(); i > 0; --i)\\n            {\\n\\n                int[] node = q.poll();\\n                for (int[] d : dir)\\n                {\\n                    int x = node[0] + d[0];\\n                    int y = node[1] + d[1];\\n                    if (x >= 0 && x < N && y >= 0 && y < N)\\n                    {\\n                        if (x == target[0] && y == target[1]) return true;\\n                        if (is_valid(map, x, y))\\n                        {\\n                            int[] next = new int[]{ x, y };\\n                            q.add(next);\\n                            add(map, next);\\n                        }\\n                    }\\n                }                \\n\\n            }\\n        }\\n        \\n        return false;\\n    }\\n    \\n    boolean is_valid(Map<Integer, Set<Integer>> map, int x, int y)\\n    {\\n        Set<Integer> ys = map.get(x);\\n        if (ys == null) return true;\\n        return !ys.contains(y);\\n    }\\n    \\n    void add(Map<Integer, Set<Integer>> map, int[] a)\\n    {\\n        Set<Integer> set = map.get(a[0]);\\n        if (set == null)\\n        {\\n            set = new HashSet();\\n            set.add(a[1]);\\n            map.put(a[0], set);\\n        }\\n        else\\n        {\\n            set.add(a[1]);\\n        }\\n    }\\n}\\n\\n\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution \\n{\\n    public boolean isEscapePossible(int[][] blocked, int[] source, int[] target) \\n    {\\n        return bfs(blocked, source, target) && bfs(blocked, target, source);\\n    }\\n    \\n    boolean bfs(int[][] blocked, int[] source, int[] target)\\n    {\\n        Map<Integer, Set<Integer>> map = new HashMap();\\n        for (int[] b : blocked)\\n        {\\n            add(map, b);\\n        }\\n        \\n        int[][] dir = {{-1,0},{1,0},{0,-1},{0,1}};\\n        Queue<int[]> q = new LinkedList();\\n        q.add(source);\\n        add(map, source);\\n        \\n        int N = 1000000;\\n        int c_step = 0;\\n        while (!q.isEmpty())\\n        {\\n            ++c_step;\\n            if (c_step >= blocked.length) return true;\\n            for (int i = q.size(); i > 0; --i)\\n            {\\n\\n                int[] node = q.poll();\\n                for (int[] d : dir)\\n                {\\n                    int x = node[0] + d[0];\\n                    int y = node[1] + d[1];\\n                    if (x >= 0 && x < N && y >= 0 && y < N)\\n                    {\\n                        if (x == target[0] && y == target[1]) return true;\\n                        if (is_valid(map, x, y))\\n                        {\\n                            int[] next = new int[]{ x, y };\\n                            q.add(next);\\n                            add(map, next);\\n                        }\\n                    }\\n                }                \\n\\n            }\\n        }\\n        \\n        return false;\\n    }\\n    \\n    boolean is_valid(Map<Integer, Set<Integer>> map, int x, int y)\\n    {\\n        Set<Integer> ys = map.get(x);\\n        if (ys == null) return true;\\n        return !ys.contains(y);\\n    }\\n    \\n    void add(Map<Integer, Set<Integer>> map, int[] a)\\n    {\\n        Set<Integer> set = map.get(a[0]);\\n        if (set == null)\\n        {\\n            set = new HashSet();\\n            set.add(a[1]);\\n            map.put(a[0], set);\\n        }\\n        else\\n        {\\n            set.add(a[1]);\\n        }\\n    }\\n}\\n\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 374261,
                "title": "java-bfs",
                "content": "```\\nclass Solution {\\n    \\n    int max_size;\\n    public boolean isEscapePossible(int[][] blocked, int[] source, int[] target) {\\n        if(blocked == null) return true;\\n        max_size = blocked.length;\\n        if(max_size == 0) return true;\\n        Set<String> set = new HashSet();\\n        for(int[] block: blocked){\\n            set.add(block[0] + \" \"+ block[1]);\\n        }\\n        return dfs(set, source, target) && dfs(set, target, source);\\n    }\\n    \\n    public boolean dfs(Set<String> set, int[] source, int[] target){\\n        int[][] moves = new int[][]{{-1,0}, {1, 0}, {0, -1}, {0, 1}};\\n        Set<String> seen = new HashSet();\\n        Queue<int[]> q = new ArrayDeque();\\n        q.offer(source);\\n        int level = 0;\\n        while(!q.isEmpty()){\\n            int size = q.size();\\n            for(int k=0; k<size; k++){\\n                int[] curr = q.poll();\\n                if(curr[0] == target[0] && curr[1] == target[1]) return true;\\n                for(int[] move: moves){\\n                    int new_x = curr[0] + move[0];\\n                    int new_y = curr[1] + move[1];\\n                    String node = new_x + \" \"+ new_y;\\n                    if(!set.contains(node) && !seen.contains(node) &&  new_x >=0 && new_y >=0 && new_x < (int)(1e6) && new_y < (int)(1e6)){\\n                        q.offer(new int[] {new_x, new_y});\\n                        seen.add(node);\\n                    }\\n                }\\n            }\\n            level++;     \\n            if(level == max_size) return true;\\n        }\\n        return false;\\n    }\\n    \\n    \\n}\\n```\\n\\nN = len(blocked)\\nTime: O(N)\\nSpace: O(N)",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    \\n    int max_size;\\n    public boolean isEscapePossible(int[][] blocked, int[] source, int[] target) {\\n        if(blocked == null) return true;\\n        max_size = blocked.length;\\n        if(max_size == 0) return true;\\n        Set<String> set = new HashSet();\\n        for(int[] block: blocked){\\n            set.add(block[0] + \" \"+ block[1]);\\n        }\\n        return dfs(set, source, target) && dfs(set, target, source);\\n    }\\n    \\n    public boolean dfs(Set<String> set, int[] source, int[] target){\\n        int[][] moves = new int[][]{{-1,0}, {1, 0}, {0, -1}, {0, 1}};\\n        Set<String> seen = new HashSet();\\n        Queue<int[]> q = new ArrayDeque();\\n        q.offer(source);\\n        int level = 0;\\n        while(!q.isEmpty()){\\n            int size = q.size();\\n            for(int k=0; k<size; k++){\\n                int[] curr = q.poll();\\n                if(curr[0] == target[0] && curr[1] == target[1]) return true;\\n                for(int[] move: moves){\\n                    int new_x = curr[0] + move[0];\\n                    int new_y = curr[1] + move[1];\\n                    String node = new_x + \" \"+ new_y;\\n                    if(!set.contains(node) && !seen.contains(node) &&  new_x >=0 && new_y >=0 && new_x < (int)(1e6) && new_y < (int)(1e6)){\\n                        q.offer(new int[] {new_x, new_y});\\n                        seen.add(node);\\n                    }\\n                }\\n            }\\n            level++;     \\n            if(level == max_size) return true;\\n        }\\n        return false;\\n    }\\n    \\n    \\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 353110,
                "title": "python-dfs-faster-then-100-other-submissions",
                "content": "Basically simple DFS, but with more complex logic to find out where we can go.\\n\\n```python\\n\\nfrom bisect import bisect_right\\nfrom typing import List\\nfrom collections import defaultdict\\n\\n\\nclass Solution:\\n    def isEscapePossible(self, blocked: List[List[int]], source: List[int], target: List[int]) -> bool:\\n        blocked_rows = defaultdict(list)\\n        bloked_cols = defaultdict(list)\\n\\n        for row, col in sorted(blocked):\\n            blocked_rows[col].append(row)\\n            bloked_cols[row].append(col)\\n\\n        target_col = target[1]\\n        target_row = target[0]\\n\\n        visited = set()\\n\\n        # directions\\n        RIGHT = 0\\n        DOWN = 1\\n        LEFT = 2\\n        TOP = 3\\n\\n        def dfs(row, col):\\n            if row == target_row and col == target_col:\\n                return True\\n\\n            for direction in RIGHT, DOWN, LEFT, TOP:\\n                next_row = row\\n                next_col = col\\n                if direction == RIGHT:\\n                    i = bisect_right(bloked_cols[row], col)\\n\\n                    next_blocked_col = float(\\'inf\\')\\n                    if i < len(bloked_cols[row]):\\n                        next_blocked_col = bloked_cols[row][i]\\n\\n                    next_col = min(next_blocked_col - 1, target_col)\\n                elif direction == LEFT:\\n                    i = bisect_right(bloked_cols[row], col) - 1\\n\\n                    next_blocked_col = -1\\n                    if i >= 0:\\n                        next_blocked_col = bloked_cols[row][i]\\n\\n                    next_col = min(next_blocked_col + 1, target_col)\\n                elif direction == DOWN:\\n                    i = bisect_right(blocked_rows[col], row)\\n\\n                    next_blocked_row = float(\\'inf\\')\\n                    if i < len(blocked_rows[col]):\\n                        next_blocked_row = blocked_rows[col][i]\\n\\n                    next_row = min(next_blocked_row - 1, target_row)\\n                elif direction == TOP:\\n                    i = bisect_right(blocked_rows[col], row) - 1\\n\\n                    next_blocked_row = -1\\n                    if i >= 0:\\n                        next_blocked_row = blocked_rows[col][i]\\n\\n                    next_row = min(next_blocked_row + 1, target_row)\\n\\n                key = (next_row, next_col)\\n\\n                if key in visited:\\n                    continue\\n\\n                visited.add(key)\\n\\n                if dfs(next_row, next_col):\\n                    return True\\n\\n            return False\\n\\n        return dfs(source[0], source[1])\\n\\n\\n```\\n",
                "solutionTags": [],
                "code": "```python\\n\\nfrom bisect import bisect_right\\nfrom typing import List\\nfrom collections import defaultdict\\n\\n\\nclass Solution:\\n    def isEscapePossible(self, blocked: List[List[int]], source: List[int], target: List[int]) -> bool:\\n        blocked_rows = defaultdict(list)\\n        bloked_cols = defaultdict(list)\\n\\n        for row, col in sorted(blocked):\\n            blocked_rows[col].append(row)\\n            bloked_cols[row].append(col)\\n\\n        target_col = target[1]\\n        target_row = target[0]\\n\\n        visited = set()\\n\\n        # directions\\n        RIGHT = 0\\n        DOWN = 1\\n        LEFT = 2\\n        TOP = 3\\n\\n        def dfs(row, col):\\n            if row == target_row and col == target_col:\\n                return True\\n\\n            for direction in RIGHT, DOWN, LEFT, TOP:\\n                next_row = row\\n                next_col = col\\n                if direction == RIGHT:\\n                    i = bisect_right(bloked_cols[row], col)\\n\\n                    next_blocked_col = float(\\'inf\\')\\n                    if i < len(bloked_cols[row]):\\n                        next_blocked_col = bloked_cols[row][i]\\n\\n                    next_col = min(next_blocked_col - 1, target_col)\\n                elif direction == LEFT:\\n                    i = bisect_right(bloked_cols[row], col) - 1\\n\\n                    next_blocked_col = -1\\n                    if i >= 0:\\n                        next_blocked_col = bloked_cols[row][i]\\n\\n                    next_col = min(next_blocked_col + 1, target_col)\\n                elif direction == DOWN:\\n                    i = bisect_right(blocked_rows[col], row)\\n\\n                    next_blocked_row = float(\\'inf\\')\\n                    if i < len(blocked_rows[col]):\\n                        next_blocked_row = blocked_rows[col][i]\\n\\n                    next_row = min(next_blocked_row - 1, target_row)\\n                elif direction == TOP:\\n                    i = bisect_right(blocked_rows[col], row) - 1\\n\\n                    next_blocked_row = -1\\n                    if i >= 0:\\n                        next_blocked_row = blocked_rows[col][i]\\n\\n                    next_row = min(next_blocked_row + 1, target_row)\\n\\n                key = (next_row, next_col)\\n\\n                if key in visited:\\n                    continue\\n\\n                visited.add(key)\\n\\n                if dfs(next_row, next_col):\\n                    return True\\n\\n            return False\\n\\n        return dfs(source[0], source[1])\\n\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 332246,
                "title": "easy-to-understand-java-dfs-solution",
                "content": "```\\nclass Solution {\\n    public boolean isEscapePossible(int[][] blocked, int[] source, int[] target) {\\n        Set<List<Integer>> blockedSet = new HashSet<>();\\n        for (int[] square : blocked) {\\n            blockedSet.add(Arrays.asList(square[0], square[1]));\\n        }\\n        \\n        return checkPoint(source, target, blockedSet) && checkPoint(target, source, blockedSet);\\n    }\\n    \\n    private boolean checkPoint(int[] point, int[] target, Set<List<Integer>> blockedSet) {\\n        int checked = 0;\\n\\n        Set<List<Integer>> allSeen = new HashSet<>();\\n        Set<List<Integer>> currentLevel = new HashSet<>();\\n        currentLevel.add(Arrays.asList(point[0], point[1]));\\n        allSeen.add(Arrays.asList(point[0], point[1]));\\n        \\n        while(checked < blockedSet.size()) {\\n            if (currentLevel.isEmpty()) {\\n                return false;\\n            }\\n            \\n            Set<List<Integer>> nextLevel = new HashSet<>();\\n            \\n            for(List<Integer> sq : currentLevel) {\\n                int x = sq.get(0);\\n                int y = sq.get(1);\\n                \\n                if (target[0] == x && target[1] == y) {\\n                    return true;\\n                }\\n\\n                addNext(nextLevel, allSeen, blockedSet, x + 1, y);\\n                addNext(nextLevel, allSeen, blockedSet, x - 1, y);\\n                addNext(nextLevel, allSeen, blockedSet, x, y + 1);\\n                addNext(nextLevel, allSeen, blockedSet, x, y - 1);\\n            }\\n            \\n            currentLevel = nextLevel;\\n            \\n            checked++;\\n        }\\n        \\n        return true;\\n    }\\n    \\n    private void addNext(Set<List<Integer>> nextLevel, Set<List<Integer>> allSeen, Set<List<Integer>> blockedSet, int x, int y) {\\n        if (x < 0 || x > 1000000 || y < 0 || y > 1000000) {\\n            return;\\n        }\\n        \\n        List<Integer> sq = Arrays.asList(x, y);\\n        \\n        if (blockedSet.contains(sq)) {\\n            return;\\n        }\\n        \\n        if (allSeen.contains(sq)) {\\n            return;\\n        }\\n        \\n        nextLevel.add(sq);\\n        allSeen.add(sq);\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public boolean isEscapePossible(int[][] blocked, int[] source, int[] target) {\\n        Set<List<Integer>> blockedSet = new HashSet<>();\\n        for (int[] square : blocked) {\\n            blockedSet.add(Arrays.asList(square[0], square[1]));\\n        }\\n        \\n        return checkPoint(source, target, blockedSet) && checkPoint(target, source, blockedSet);\\n    }\\n    \\n    private boolean checkPoint(int[] point, int[] target, Set<List<Integer>> blockedSet) {\\n        int checked = 0;\\n\\n        Set<List<Integer>> allSeen = new HashSet<>();\\n        Set<List<Integer>> currentLevel = new HashSet<>();\\n        currentLevel.add(Arrays.asList(point[0], point[1]));\\n        allSeen.add(Arrays.asList(point[0], point[1]));\\n        \\n        while(checked < blockedSet.size()) {\\n            if (currentLevel.isEmpty()) {\\n                return false;\\n            }\\n            \\n            Set<List<Integer>> nextLevel = new HashSet<>();\\n            \\n            for(List<Integer> sq : currentLevel) {\\n                int x = sq.get(0);\\n                int y = sq.get(1);\\n                \\n                if (target[0] == x && target[1] == y) {\\n                    return true;\\n                }\\n\\n                addNext(nextLevel, allSeen, blockedSet, x + 1, y);\\n                addNext(nextLevel, allSeen, blockedSet, x - 1, y);\\n                addNext(nextLevel, allSeen, blockedSet, x, y + 1);\\n                addNext(nextLevel, allSeen, blockedSet, x, y - 1);\\n            }\\n            \\n            currentLevel = nextLevel;\\n            \\n            checked++;\\n        }\\n        \\n        return true;\\n    }\\n    \\n    private void addNext(Set<List<Integer>> nextLevel, Set<List<Integer>> allSeen, Set<List<Integer>> blockedSet, int x, int y) {\\n        if (x < 0 || x > 1000000 || y < 0 || y > 1000000) {\\n            return;\\n        }\\n        \\n        List<Integer> sq = Arrays.asList(x, y);\\n        \\n        if (blockedSet.contains(sq)) {\\n            return;\\n        }\\n        \\n        if (allSeen.contains(sq)) {\\n            return;\\n        }\\n        \\n        nextLevel.add(sq);\\n        allSeen.add(sq);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 306566,
                "title": "python-dfs-solution",
                "content": "```python\\nclass Solution:\\n    def isEscapePossible(self, blocked: List[List[int]], source: List[int], target: List[int]) -> bool:\\n        return self.helper(blocked, source, target) and self.helper(blocked, target, source)\\n    def helper(self, blocked, source, target):\\n        if not blocked: return True\\n        dq = collections.deque([tuple(source)])\\n        l = len(blocked)\\n        seen = {tuple(source)}\\n        blocked = set(map(tuple, blocked))\\n        while dq:\\n            sz = len(dq)\\n            for _ in range(sz):\\n                x, y = dq.popleft()\\n                for dx, dy in ((1, 0), (-1, 0), (0, 1), (0, -1)):\\n                    xx, yy = x + dx, y + dy\\n                    if 0 <= xx < 10 ** 6 and 0 <= yy < 10 ** 6 and (xx, yy) not in seen and (xx, yy) not in blocked:\\n                        seen.add((xx, yy))\\n                        dq.append((xx, yy))\\n                        # the maximum area covered by blocks will be an isosceles right triangle with area less than l * l // 2\\n                        # if we can cover more cells than l * l // 2, we will be bound to break the block\\n                        if (xx, yy) == tuple(target) or len(seen) >= l * l // 2: return True\\n        return False\\n```",
                "solutionTags": [],
                "code": "```python\\nclass Solution:\\n    def isEscapePossible(self, blocked: List[List[int]], source: List[int], target: List[int]) -> bool:\\n        return self.helper(blocked, source, target) and self.helper(blocked, target, source)\\n    def helper(self, blocked, source, target):\\n        if not blocked: return True\\n        dq = collections.deque([tuple(source)])\\n        l = len(blocked)\\n        seen = {tuple(source)}\\n        blocked = set(map(tuple, blocked))\\n        while dq:\\n            sz = len(dq)\\n            for _ in range(sz):\\n                x, y = dq.popleft()\\n                for dx, dy in ((1, 0), (-1, 0), (0, 1), (0, -1)):\\n                    xx, yy = x + dx, y + dy\\n                    if 0 <= xx < 10 ** 6 and 0 <= yy < 10 ** 6 and (xx, yy) not in seen and (xx, yy) not in blocked:\\n                        seen.add((xx, yy))\\n                        dq.append((xx, yy))\\n                        # the maximum area covered by blocks will be an isosceles right triangle with area less than l * l // 2\\n                        # if we can cover more cells than l * l // 2, we will be bound to break the block\\n                        if (xx, yy) == tuple(target) or len(seen) >= l * l // 2: return True\\n        return False\\n```",
                "codeTag": "Java"
            },
            {
                "id": 289012,
                "title": "easy-understand-java-bfs-solution",
                "content": "we make a tricky here, if the current visit position abs(Pos.x - src.x)+abs(Pos.y-src.y)>200 then return true.\\n```\\nclass Solution {\\n\\tSet<Long> visited;\\n\\tclass Pos{\\n\\t\\tint x; int y;\\n\\t\\tPos(int x, int y){\\n\\t\\t\\tthis.x = x;\\n\\t\\t\\tthis.y = y;\\n\\t\\t}\\n\\t}\\n\\t\\n\\tpublic boolean isEscapePossible(\\n\\t\\t\\tint[][] blocked, int[] source, int[] target) {\\n\\t\\tvisited = new HashSet<Long>();\\n\\t\\tfor(int[] b:blocked) {\\n\\t\\t\\tlong tmp = b[0]*1000000+b[1];\\n\\t\\t\\tvisited.add(tmp);\\n\\t\\t}\\n\\t\\tint ans = BFS(source,target);\\n        return ans>0;\\n    }\\n\\t\\n\\tprivate int BFS(int[] source, int[] target)\\n\\t{\\n\\t\\tQueue<Pos> que = new LinkedList<Pos>();\\n\\t\\tint[] dx = {0,0,1,-1};\\n\\t\\tint[] dy = {1,-1,0,0};\\n\\t\\tque.offer(new Pos(source[0],source[1]));\\n\\t\\tvisited.add((long) (source[0] * 1000000 + source[1]));\\n\\t\\twhile(!que.isEmpty()) {\\n\\t\\t\\tPos p = que.peek();\\n\\t\\t\\tque.poll();\\n\\t\\t\\t\\n\\t\\t\\tif(p.x == target[0] && p.y == target[1]) {\\n\\t\\t\\t\\treturn 2;\\n\\t\\t\\t}\\n\\t\\t\\t\\n\\t\\t\\tif(Math.abs(p.x - source[0])+\\n\\t\\t\\t\\t\\tMath.abs(p.y - source[1])>200) {\\n\\t\\t\\t\\treturn 1;\\n\\t\\t\\t}\\n\\t\\t\\t\\n\\t\\t\\tfor(int i=0;i<4;i++) {\\n\\t\\t\\t\\tint tx = dx[i]+p.x;\\n\\t\\t\\t\\tint ty = dy[i]+p.y;\\n\\t\\t\\t\\tlong tmp = tx*1000000+ty;\\n\\t\\t\\t\\tif(tx<0 || ty<0 || tx>=1000000 || ty>=1000000\\n\\t\\t\\t\\t\\t\\t|| visited.contains(tmp)) {\\n\\t\\t\\t\\t\\tcontinue;\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\tvisited.add(tmp);\\n\\t\\t\\t\\tque.offer(new Pos(tx,ty));\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\treturn 0;\\n\\t}\\n\\t\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n\\tSet<Long> visited;\\n\\tclass Pos{\\n\\t\\tint x; int y;\\n\\t\\tPos(int x, int y){\\n\\t\\t\\tthis.x = x;\\n\\t\\t\\tthis.y = y;\\n\\t\\t}\\n\\t}\\n\\t\\n\\tpublic boolean isEscapePossible(\\n\\t\\t\\tint[][] blocked, int[] source, int[] target) {\\n\\t\\tvisited = new HashSet<Long>();\\n\\t\\tfor(int[] b:blocked) {\\n\\t\\t\\tlong tmp = b[0]*1000000+b[1];\\n\\t\\t\\tvisited.add(tmp);\\n\\t\\t}\\n\\t\\tint ans = BFS(source,target);\\n        return ans>0;\\n    }\\n\\t\\n\\tprivate int BFS(int[] source, int[] target)\\n\\t{\\n\\t\\tQueue<Pos> que = new LinkedList<Pos>();\\n\\t\\tint[] dx = {0,0,1,-1};\\n\\t\\tint[] dy = {1,-1,0,0};\\n\\t\\tque.offer(new Pos(source[0],source[1]));\\n\\t\\tvisited.add((long) (source[0] * 1000000 + source[1]));\\n\\t\\twhile(!que.isEmpty()) {\\n\\t\\t\\tPos p = que.peek();\\n\\t\\t\\tque.poll();\\n\\t\\t\\t\\n\\t\\t\\tif(p.x == target[0] && p.y == target[1]) {\\n\\t\\t\\t\\treturn 2;\\n\\t\\t\\t}\\n\\t\\t\\t\\n\\t\\t\\tif(Math.abs(p.x - source[0])+\\n\\t\\t\\t\\t\\tMath.abs(p.y - source[1])>200) {\\n\\t\\t\\t\\treturn 1;\\n\\t\\t\\t}\\n\\t\\t\\t\\n\\t\\t\\tfor(int i=0;i<4;i++) {\\n\\t\\t\\t\\tint tx = dx[i]+p.x;\\n\\t\\t\\t\\tint ty = dy[i]+p.y;\\n\\t\\t\\t\\tlong tmp = tx*1000000+ty;\\n\\t\\t\\t\\tif(tx<0 || ty<0 || tx>=1000000 || ty>=1000000\\n\\t\\t\\t\\t\\t\\t|| visited.contains(tmp)) {\\n\\t\\t\\t\\t\\tcontinue;\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\tvisited.add(tmp);\\n\\t\\t\\t\\tque.offer(new Pos(tx,ty));\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\treturn 0;\\n\\t}\\n\\t\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 287155,
                "title": "leetcode-java-set-java-awt-point-contains-return-unexpected-result",
                "content": "I have following code works in local eclipse that uses openjdk-1.8.0 for the case [[0,1],[1,0]][0,0][0,2] but not through leetcode submission or Run Code. It appears that blocked.contains(r) (the contains() method on Set<Point>) behaves differently in LeetCode Java. Explicitly uses java.awt.Point makes no difference. Which Java version does LeetCode uses and what\\'s wrong with the contains() on Set<Point>? \\n\\n```\\n  public static boolean isEscapePossible(int[][] blocked, int[] source, int[] target) {\\n    Set<Point> bs = new HashSet<>();\\n    for (int i = 0; i < blocked.length; i++) {\\n      bs.add(new Point(blocked[i][0], blocked[i][1]));\\n    }\\n    Point src = new Point(source[0], source[1]);\\n    Point dst = new Point(target[0], target[1]);\\n    return bfs(bs, src, dst) && bfs(bs, dst, src);\\n  }\\n\\n  public static boolean bfs(Set<Point> blocked, Point src, Point dst) {\\n    int N = 1000000;\\n    int[][] dirs = new int[][] {{-1,0},{1,0},{0,-1},{0,1}};\\n    Queue<Point> q = new LinkedList<>();\\n    Set<Point> visited = new HashSet<>();\\n    q.add(src);\\n    visited.add(src);\\n    while (!q.isEmpty()) {\\n      Point p = q.poll();\\n      if (p.equals(dst)) {\\n        return true;\\n      }\\n      int dist = Math.abs(p.x - src.x) + Math.abs(p.y - src.y);\\n      if (dist > blocked.size()) {\\n        // source point is not blocked\\n        return true;\\n      }\\n      for (int[] dir : dirs) {\\n        Point r = new Point(p.x + dir[0], p.y + dir[1]);\\n        if (r.x >= 0 && r.x < N && r.y >= 0 && r.y < N && !visited.contains(r) && !blocked.contains(r)) {\\n          q.add(r);\\n          visited.add(r);\\n        }\\n      }\\n    }\\n    return false;\\n  }\\n  ```",
                "solutionTags": [],
                "code": "```\\n  public static boolean isEscapePossible(int[][] blocked, int[] source, int[] target) {\\n    Set<Point> bs = new HashSet<>();\\n    for (int i = 0; i < blocked.length; i++) {\\n      bs.add(new Point(blocked[i][0], blocked[i][1]));\\n    }\\n    Point src = new Point(source[0], source[1]);\\n    Point dst = new Point(target[0], target[1]);\\n    return bfs(bs, src, dst) && bfs(bs, dst, src);\\n  }\\n\\n  public static boolean bfs(Set<Point> blocked, Point src, Point dst) {\\n    int N = 1000000;\\n    int[][] dirs = new int[][] {{-1,0},{1,0},{0,-1},{0,1}};\\n    Queue<Point> q = new LinkedList<>();\\n    Set<Point> visited = new HashSet<>();\\n    q.add(src);\\n    visited.add(src);\\n    while (!q.isEmpty()) {\\n      Point p = q.poll();\\n      if (p.equals(dst)) {\\n        return true;\\n      }\\n      int dist = Math.abs(p.x - src.x) + Math.abs(p.y - src.y);\\n      if (dist > blocked.size()) {\\n        // source point is not blocked\\n        return true;\\n      }\\n      for (int[] dir : dirs) {\\n        Point r = new Point(p.x + dir[0], p.y + dir[1]);\\n        if (r.x >= 0 && r.x < N && r.y >= 0 && r.y < N && !visited.contains(r) && !blocked.contains(r)) {\\n          q.add(r);\\n          visited.add(r);\\n        }\\n      }\\n    }\\n    return false;\\n  }\\n  ```",
                "codeTag": "Unknown"
            },
            {
                "id": 285625,
                "title": "why-my-answer-is-tle-can-someone-help",
                "content": "```\\n public bool IsEscapePossible(int[][] blocked, int[] source, int[] target)\\n        {\\n            if (blocked.Length == 0) return true;\\n            var blockers = new HashSet<string>();\\n            foreach (var b in blocked)\\n            {\\n                blockers.Add(b[0] + \",\" + b[1]);\\n            }\\n            return IsEscapePossibleBFS(blockers, source, target) && IsEscapePossibleBFS(blockers, target, source);\\n        }\\n\\n        private bool IsEscapePossibleBFS(HashSet<string> blockers, int[] source, int[] target)\\n        {\\n            if (target[0] < 0 || target[0] >= 1_000_000 || target[1] < 0 || target[1] >= 1_000_000) return false;\\n\\n            var dirs = new int[4][];\\n            dirs[0] = new int[] { 1, 0 };\\n            dirs[1] = new int[] { 0, 1 };\\n            dirs[2] = new int[] { -1, 0 };\\n            dirs[3] = new int[] { 0, -1 };\\n\\n\\n            var q = new Queue<int[]>();\\n            var seen = new HashSet<string>();\\n\\n            q.Enqueue(source);\\n\\n            while (q.Count != 0)\\n            {\\n                int size = q.Count;\\n\\n                for (int i = 0; i < size; i++)\\n                {\\n                    var point = q.Dequeue();\\n                    if (point[0] == target[0] && point[1] == target[1]) return true;\\n\\n                    foreach (var dir in dirs)\\n                    {\\n                        int x = point[0] + dir[0];\\n                        int y = point[1] + dir[1];\\n                        var str = x + \",\" + y;\\n                        if (x >= 0 && x < 1_000_000 && y >= 0 && y < 1_000_000 && !blockers.Contains(str) && !seen.Contains(str))\\n                        {\\n                            if (target[0] == x && target[1] == y) return true;\\n                            q.Enqueue(new int[] { x, y });\\n                            seen.Add(str);\\n                            if (seen.Count == 20_000) return true;\\n                        }\\n                        \\n                    }\\n                }\\n            }\\n            return false;\\n        }\\n```",
                "solutionTags": [],
                "code": "```\\n public bool IsEscapePossible(int[][] blocked, int[] source, int[] target)\\n        {\\n            if (blocked.Length == 0) return true;\\n            var blockers = new HashSet<string>();\\n            foreach (var b in blocked)\\n            {\\n                blockers.Add(b[0] + \",\" + b[1]);\\n            }\\n            return IsEscapePossibleBFS(blockers, source, target) && IsEscapePossibleBFS(blockers, target, source);\\n        }\\n\\n        private bool IsEscapePossibleBFS(HashSet<string> blockers, int[] source, int[] target)\\n        {\\n            if (target[0] < 0 || target[0] >= 1_000_000 || target[1] < 0 || target[1] >= 1_000_000) return false;\\n\\n            var dirs = new int[4][];\\n            dirs[0] = new int[] { 1, 0 };\\n            dirs[1] = new int[] { 0, 1 };\\n            dirs[2] = new int[] { -1, 0 };\\n            dirs[3] = new int[] { 0, -1 };\\n\\n\\n            var q = new Queue<int[]>();\\n            var seen = new HashSet<string>();\\n\\n            q.Enqueue(source);\\n\\n            while (q.Count != 0)\\n            {\\n                int size = q.Count;\\n\\n                for (int i = 0; i < size; i++)\\n                {\\n                    var point = q.Dequeue();\\n                    if (point[0] == target[0] && point[1] == target[1]) return true;\\n\\n                    foreach (var dir in dirs)\\n                    {\\n                        int x = point[0] + dir[0];\\n                        int y = point[1] + dir[1];\\n                        var str = x + \",\" + y;\\n                        if (x >= 0 && x < 1_000_000 && y >= 0 && y < 1_000_000 && !blockers.Contains(str) && !seen.Contains(str))\\n                        {\\n                            if (target[0] == x && target[1] == y) return true;\\n                            q.Enqueue(new int[] { x, y });\\n                            seen.Add(str);\\n                            if (seen.Count == 20_000) return true;\\n                        }\\n                        \\n                    }\\n                }\\n            }\\n            return false;\\n        }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 284610,
                "title": "c-bfs",
                "content": "```\\nclass Solution {\\n    int updateMap(map<int, int>& m) {\\n        auto it = m.begin();\\n        int index = 0, last = it->first;\\n        m[it->first] = index;\\n        it++;\\n        for( ; it != m.end(); it++) {\\n            if(it->first == last+1) {\\n                m[it->first] = ++index;\\n            }\\n            else {\\n                index += 2;\\n                m[it->first] = index;\\n            }\\n            last = it->first;\\n        }\\n        return index+1;\\n    }\\n    \\n    bool isValidNeighbor(int row, int col, int **nodes, queue<vector<int>>& q, int rowMax, int colMax) {\\n        if(row < 0 || col < 0 || row >= rowMax || col >= colMax || nodes[row][col] > 0)\\n            return false;\\n        vector<int> t;\\n        t.push_back(row);\\n        t.push_back(col);\\n        nodes[row][col] = 1;  // marking it as visited\\n        q.push(t);\\n        return true;\\n    }\\n    \\npublic:\\n    bool isEscapePossible(vector<vector<int>>& blocked, vector<int>& source, vector<int>& target) {\\n        //Fetching all the possible values for rows and columns for blocked elements, source, target, matrix two extreme corners (0,0) and (999999,999999)\\n        map<int, int> rows, cols;\\n        for(int i =0; i < blocked.size(); i++) {\\n            rows.insert(pair<int, int>(blocked[i][0], -1));\\n            cols.insert(pair<int, int>(blocked[i][1], -1));\\n        }\\n        rows.insert(pair<int, int>(source[0], -1));\\n        cols.insert(pair<int, int>(source[1], -1));\\n        rows.insert(pair<int, int>(target[0], -1));\\n        cols.insert(pair<int, int>(target[1], -1));\\n        rows.insert(pair<int, int>(0, -1));\\n        cols.insert(pair<int, int>(0, -1));\\n        rows.insert(pair<int, int>(999999, -1));\\n        cols.insert(pair<int, int>(999999, -1));\\n        \\n        // Creating compressed matrix row map and column map.\\n        int numR = updateMap(rows);\\n        int numC = updateMap(cols);\\n        \\n        int **nodes = new int*[numR];\\n        for(int i =0; i < numR; i++) {\\n            nodes[i] = new int[numC]();\\n        }\\n        source[0] = rows[source[0]];\\n        source[1] = cols[source[1]];\\n        target[0] = rows[target[0]];\\n        target[1] = cols[target[1]];\\n        for(int i=0; i < blocked.size(); i++) {\\n            nodes[rows[blocked[i][0]]][cols[blocked[i][1]]] = 2;\\n        }\\n        queue<vector<int>> q;\\n        q.push(source);\\n        vector<int> t;\\n        while(!q.empty()) {\\n            t = q.front();\\n            q.pop();\\n            if(isValidNeighbor(t[0]-1, t[1], nodes, q, numR, numC))\\n                if(t[0]-1 == target[0] && t[1] == target[1])\\n                    return true;\\n            if(isValidNeighbor(t[0], t[1]-1, nodes, q, numR, numC))\\n                if(t[0] == target[0] && t[1]-1 == target[1])\\n                    return true;\\n            if(isValidNeighbor(t[0]+1, t[1], nodes, q, numR, numC))\\n                if(t[0]+1 == target[0] && t[1] == target[1])\\n                    return true;\\n            if(isValidNeighbor(t[0], t[1]+1, nodes, q, numR, numC))\\n                if(t[0] == target[0] && t[1]+1 == target[1])\\n                    return true;\\n        }\\n        return false;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    int updateMap(map<int, int>& m) {\\n        auto it = m.begin();\\n        int index = 0, last = it->first;\\n        m[it->first] = index;\\n        it++;\\n        for( ; it != m.end(); it++) {\\n            if(it->first == last+1) {\\n                m[it->first] = ++index;\\n            }\\n            else {\\n                index += 2;\\n                m[it->first] = index;\\n            }\\n            last = it->first;\\n        }\\n        return index+1;\\n    }\\n    \\n    bool isValidNeighbor(int row, int col, int **nodes, queue<vector<int>>& q, int rowMax, int colMax) {\\n        if(row < 0 || col < 0 || row >= rowMax || col >= colMax || nodes[row][col] > 0)\\n            return false;\\n        vector<int> t;\\n        t.push_back(row);\\n        t.push_back(col);\\n        nodes[row][col] = 1;  // marking it as visited\\n        q.push(t);\\n        return true;\\n    }\\n    \\npublic:\\n    bool isEscapePossible(vector<vector<int>>& blocked, vector<int>& source, vector<int>& target) {\\n        //Fetching all the possible values for rows and columns for blocked elements, source, target, matrix two extreme corners (0,0) and (999999,999999)\\n        map<int, int> rows, cols;\\n        for(int i =0; i < blocked.size(); i++) {\\n            rows.insert(pair<int, int>(blocked[i][0], -1));\\n            cols.insert(pair<int, int>(blocked[i][1], -1));\\n        }\\n        rows.insert(pair<int, int>(source[0], -1));\\n        cols.insert(pair<int, int>(source[1], -1));\\n        rows.insert(pair<int, int>(target[0], -1));\\n        cols.insert(pair<int, int>(target[1], -1));\\n        rows.insert(pair<int, int>(0, -1));\\n        cols.insert(pair<int, int>(0, -1));\\n        rows.insert(pair<int, int>(999999, -1));\\n        cols.insert(pair<int, int>(999999, -1));\\n        \\n        // Creating compressed matrix row map and column map.\\n        int numR = updateMap(rows);\\n        int numC = updateMap(cols);\\n        \\n        int **nodes = new int*[numR];\\n        for(int i =0; i < numR; i++) {\\n            nodes[i] = new int[numC]();\\n        }\\n        source[0] = rows[source[0]];\\n        source[1] = cols[source[1]];\\n        target[0] = rows[target[0]];\\n        target[1] = cols[target[1]];\\n        for(int i=0; i < blocked.size(); i++) {\\n            nodes[rows[blocked[i][0]]][cols[blocked[i][1]]] = 2;\\n        }\\n        queue<vector<int>> q;\\n        q.push(source);\\n        vector<int> t;\\n        while(!q.empty()) {\\n            t = q.front();\\n            q.pop();\\n            if(isValidNeighbor(t[0]-1, t[1], nodes, q, numR, numC))\\n                if(t[0]-1 == target[0] && t[1] == target[1])\\n                    return true;\\n            if(isValidNeighbor(t[0], t[1]-1, nodes, q, numR, numC))\\n                if(t[0] == target[0] && t[1]-1 == target[1])\\n                    return true;\\n            if(isValidNeighbor(t[0]+1, t[1], nodes, q, numR, numC))\\n                if(t[0]+1 == target[0] && t[1] == target[1])\\n                    return true;\\n            if(isValidNeighbor(t[0], t[1]+1, nodes, q, numR, numC))\\n                if(t[0] == target[0] && t[1]+1 == target[1])\\n                    return true;\\n        }\\n        return false;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 284520,
                "title": "c-leetcode-runtime-error-for-solution-that-works-on-clang",
                "content": "I\\'m running the same code on Clang compiler v7 and don\\'t see any problems. \\nLeetcode C++ compiler throws runtime errors with Address Sanitization. Not sure if this is a compiler specific problem. \\n```\\n\\nvector<int> target;\\nset<vector<int>> seen; \\n  int N=pow(10,6);\\n  bool isValid (int r, int c) {\\n    return (r>=0 && r<N && c>=0 && c<N);\\n  }\\n  bool dfs (int x, int y, int l) {\\n    if ((x==target[0] && y==target[1]) || l>=20000) \\n        return true;\\n      if (seen.count({x,y}) || !isValid(x,y)) \\n          return false;\\n      seen.insert({x,y});\\n      return dfs(x,y-1,l+1) || dfs(x,y+1,l+1) || dfs(x-1,y,l+1) \\n          || dfs(x+1,y,l+1); \\n      \\n  }\\n  bool isEscapePossible(vector<vector<int> >& blocked, vector<int>& source, vector<int>& dst) {\\n    if (blocked.empty()) return true;  \\n    for (auto block: blocked)\\n    seen.insert(block);  \\n  target=dst;\\n \\n  return dfs(source[0],source[1],1); \\n  }\\nint main() {\\n  vector<vector<int> > mblocked {{691938,300406},{710196,624190},{858790,609485},{268029,225806},{200010,188664},{132599,612099},{329444,633495},{196657,757958},{628509,883388}};\\n  vector<int> source {655988,180910};\\n  vector<int> dest {267728,840949};\\n  if (isEscapePossible(mblocked, source, dest))\\n    cout << \"Success!\\\\n\";\\n  else \\n    cout << \"Failure!\\\\n\";   \\n}\\n```",
                "solutionTags": [],
                "code": "```\\n\\nvector<int> target;\\nset<vector<int>> seen; \\n  int N=pow(10,6);\\n  bool isValid (int r, int c) {\\n    return (r>=0 && r<N && c>=0 && c<N);\\n  }\\n  bool dfs (int x, int y, int l) {\\n    if ((x==target[0] && y==target[1]) || l>=20000) \\n        return true;\\n      if (seen.count({x,y}) || !isValid(x,y)) \\n          return false;\\n      seen.insert({x,y});\\n      return dfs(x,y-1,l+1) || dfs(x,y+1,l+1) || dfs(x-1,y,l+1) \\n          || dfs(x+1,y,l+1); \\n      \\n  }\\n  bool isEscapePossible(vector<vector<int> >& blocked, vector<int>& source, vector<int>& dst) {\\n    if (blocked.empty()) return true;  \\n    for (auto block: blocked)\\n    seen.insert(block);  \\n  target=dst;\\n \\n  return dfs(source[0],source[1],1); \\n  }\\nint main() {\\n  vector<vector<int> > mblocked {{691938,300406},{710196,624190},{858790,609485},{268029,225806},{200010,188664},{132599,612099},{329444,633495},{196657,757958},{628509,883388}};\\n  vector<int> source {655988,180910};\\n  vector<int> dest {267728,840949};\\n  if (isEscapePossible(mblocked, source, dest))\\n    cout << \"Success!\\\\n\";\\n  else \\n    cout << \"Failure!\\\\n\";   \\n}\\n```",
                "codeTag": "C++"
            },
            {
                "id": 283544,
                "title": "don-t-understand-constraints",
                "content": "These two problem constraints don\\'t make sense to me:\\n\\n```\\n0 <= blocked[i][j] < 10^6\\n0 <= source[i][j], target[i][j] < 10^6\\n```\\nAt least in the python code, I think we have for all of `blocked`, `source`, and `target`:\\n```\\n0 <= i <= 10^6 \\n0 <= j <= 10^6\\n```\\n\\nWhy do the constraints refer to the value of e.g. `blocked[i][j]`?",
                "solutionTags": [],
                "code": "```\\n0 <= blocked[i][j] < 10^6\\n0 <= source[i][j], target[i][j] < 10^6\\n```\n```\\n0 <= i <= 10^6 \\n0 <= j <= 10^6\\n```",
                "codeTag": "Unknown"
            }
        ],
        "discussions": [
            {
                "id": 1565201,
                "content": [
                    {
                        "username": "samizzy18",
                        "content": "You want to traverse from a src point to a target point but there are certain blocks that are not accessible.\\nThis would have been a very easy dfs/bfs problem, had the max array length had not been 10^6\\n\\nThere is a hacky solution which takes into consideration the blocked list length constraint which is only 200.\\nIts going to be hard to block a element from traversal in 10^ by 10^6 grid with only max 200 blocks\\n\\nTherefore, we do normal bfs from source to target and check 2 conditions\\n    1. Whether we have reached target\\n    2. Whether we have exceeded 200 distance, here distance is calculated using manhattan distance, |(diff of x)| + |(diff of y)|\\nIf any of above is true, then return result true.\\n\\nBut wait, what if blocked points are not trying to surround source point but have surrounded the target point?\\n\\nFor above, scenario we again do a bfs bt this time from target to source, if we are able to reach now , we return true.\\n\\nOnly if both traversal return true then we can truly escape.............\\n\\nAlso first check should be whether the src/target point lie on blocked list if yes, then escape is impossible\\n"
                    },
                    {
                        "username": "tejasX",
                        "content": "Crystal Clear !!"
                    },
                    {
                        "username": "1yangshuang",
                        "content": "I submitted multiple instances of the discussion forum where the AC code is wrong.\\n\\n[[0,199],[1,198],[2,197],[3,196],[4,195],[5,194],[6,193],[7,192],[8,191],[9,190],[10,189],[11,188],[12,187],[13,186],[14,185],[15,184],[16,183],[17,182],[18,181],[19,180],[20,179],[21,178],[22,177],[23,176],[24,175],[25,174],[26,173],[27,172],[28,171],[29,170],[30,169],[31,168],[32,167],[33,166],[34,165],[35,164],[36,163],[37,162],[38,161],[39,160],[40,159],[41,158],[42,157],[43,156],[44,155],[45,154],[46,153],[47,152],[48,151],[49,150],[50,149],[51,148],[52,147],[53,146],[54,145],[55,144],[56,143],[57,142],[58,141],[59,140],[60,139],[61,138],[62,137],[63,136],[64,135],[65,134],[66,133],[67,132],[68,131],[69,130],[70,129],[71,128],[72,127],[73,126],[74,125],[75,124],[76,123],[77,122],[78,121],[79,120],[80,119],[81,118],[82,117],[83,116],[84,115],[85,114],[86,113],[87,112],[88,111],[89,110],[90,109],[91,108],[92,107],[93,106],[94,105],[95,104],[96,103],[97,102],[98,101],[99,100],[100,99],[101,98],[102,97],[103,96],[104,95],[105,94],[106,93],[107,92],[108,91],[109,90],[110,89],[111,88],[112,87],[113,86],[114,85],[115,84],[116,83],[117,82],[118,81],[119,80],[120,79],[121,78],[122,77],[123,76],[124,75],[125,74],[126,73],[127,72],[128,71],[129,70],[130,69],[131,68],[132,67],[133,66],[134,65],[135,64],[136,63],[137,62],[138,61],[139,60],[140,59],[141,58],[142,57],[143,56],[144,55],[145,54],[146,53],[147,52],[148,51],[149,50],[150,49],[151,48],[152,47],[153,46],[154,45],[155,44],[156,43],[157,42],[158,41],[159,40],[160,39],[161,38],[162,37],[163,36],[164,35],[165,34],[166,33],[167,32],[168,31],[169,30],[170,29],[171,28],[172,27],[173,26],[174,25],[175,24],[176,23],[177,22],[178,21],[179,20],[180,19],[181,18],[182,17],[183,16],[184,15],[185,14],[186,13],[187,12],[188,11],[189,10],[190,9],[191,8],[192,7],[193,6],[194,5],[195,4],[196,3],[197,2],[198,1],[199,0]]\\n[0,0]\\n[200,200]\\n"
                    },
                    {
                        "username": "anwendeng",
                        "content": "It is to notice that the \"circle\" w.r.t Manhattan distance is in fact  a diamond. Since there are at most B=200 blocked grids, you can use DFS/BFS for solving this 1M^2 size maze, either up to $B(B+1)/2)$ visited grids or up to Manhattan distance to the initial point larger or equal to $B$.\n\nDFS w.r.t Manhattan distance is much faster DFS w.r.t. visited grid size."
                    },
                    {
                        "username": "hussainafroz903",
                        "content": "thank you for saving our time"
                    },
                    {
                        "username": "obiwon84",
                        "content": "I didnt notice the 200 blocked array until after I implemented A* and discovered it was too slow for a couple test cases ... honestly im not sure how i feel about such a small amount of blocked squares as it really trivializes the problem but I had a blast!\\n\\nCheers"
                    },
                    {
                        "username": "hussainafroz903",
                        "content": "can you share your a* search algorithm "
                    }
                ]
            },
            {
                "id": 1566554,
                "content": [
                    {
                        "username": "samizzy18",
                        "content": "You want to traverse from a src point to a target point but there are certain blocks that are not accessible.\\nThis would have been a very easy dfs/bfs problem, had the max array length had not been 10^6\\n\\nThere is a hacky solution which takes into consideration the blocked list length constraint which is only 200.\\nIts going to be hard to block a element from traversal in 10^ by 10^6 grid with only max 200 blocks\\n\\nTherefore, we do normal bfs from source to target and check 2 conditions\\n    1. Whether we have reached target\\n    2. Whether we have exceeded 200 distance, here distance is calculated using manhattan distance, |(diff of x)| + |(diff of y)|\\nIf any of above is true, then return result true.\\n\\nBut wait, what if blocked points are not trying to surround source point but have surrounded the target point?\\n\\nFor above, scenario we again do a bfs bt this time from target to source, if we are able to reach now , we return true.\\n\\nOnly if both traversal return true then we can truly escape.............\\n\\nAlso first check should be whether the src/target point lie on blocked list if yes, then escape is impossible\\n"
                    },
                    {
                        "username": "tejasX",
                        "content": "Crystal Clear !!"
                    },
                    {
                        "username": "1yangshuang",
                        "content": "I submitted multiple instances of the discussion forum where the AC code is wrong.\\n\\n[[0,199],[1,198],[2,197],[3,196],[4,195],[5,194],[6,193],[7,192],[8,191],[9,190],[10,189],[11,188],[12,187],[13,186],[14,185],[15,184],[16,183],[17,182],[18,181],[19,180],[20,179],[21,178],[22,177],[23,176],[24,175],[25,174],[26,173],[27,172],[28,171],[29,170],[30,169],[31,168],[32,167],[33,166],[34,165],[35,164],[36,163],[37,162],[38,161],[39,160],[40,159],[41,158],[42,157],[43,156],[44,155],[45,154],[46,153],[47,152],[48,151],[49,150],[50,149],[51,148],[52,147],[53,146],[54,145],[55,144],[56,143],[57,142],[58,141],[59,140],[60,139],[61,138],[62,137],[63,136],[64,135],[65,134],[66,133],[67,132],[68,131],[69,130],[70,129],[71,128],[72,127],[73,126],[74,125],[75,124],[76,123],[77,122],[78,121],[79,120],[80,119],[81,118],[82,117],[83,116],[84,115],[85,114],[86,113],[87,112],[88,111],[89,110],[90,109],[91,108],[92,107],[93,106],[94,105],[95,104],[96,103],[97,102],[98,101],[99,100],[100,99],[101,98],[102,97],[103,96],[104,95],[105,94],[106,93],[107,92],[108,91],[109,90],[110,89],[111,88],[112,87],[113,86],[114,85],[115,84],[116,83],[117,82],[118,81],[119,80],[120,79],[121,78],[122,77],[123,76],[124,75],[125,74],[126,73],[127,72],[128,71],[129,70],[130,69],[131,68],[132,67],[133,66],[134,65],[135,64],[136,63],[137,62],[138,61],[139,60],[140,59],[141,58],[142,57],[143,56],[144,55],[145,54],[146,53],[147,52],[148,51],[149,50],[150,49],[151,48],[152,47],[153,46],[154,45],[155,44],[156,43],[157,42],[158,41],[159,40],[160,39],[161,38],[162,37],[163,36],[164,35],[165,34],[166,33],[167,32],[168,31],[169,30],[170,29],[171,28],[172,27],[173,26],[174,25],[175,24],[176,23],[177,22],[178,21],[179,20],[180,19],[181,18],[182,17],[183,16],[184,15],[185,14],[186,13],[187,12],[188,11],[189,10],[190,9],[191,8],[192,7],[193,6],[194,5],[195,4],[196,3],[197,2],[198,1],[199,0]]\\n[0,0]\\n[200,200]\\n"
                    },
                    {
                        "username": "anwendeng",
                        "content": "It is to notice that the \"circle\" w.r.t Manhattan distance is in fact  a diamond. Since there are at most B=200 blocked grids, you can use DFS/BFS for solving this 1M^2 size maze, either up to $B(B+1)/2)$ visited grids or up to Manhattan distance to the initial point larger or equal to $B$.\n\nDFS w.r.t Manhattan distance is much faster DFS w.r.t. visited grid size."
                    },
                    {
                        "username": "hussainafroz903",
                        "content": "thank you for saving our time"
                    },
                    {
                        "username": "obiwon84",
                        "content": "I didnt notice the 200 blocked array until after I implemented A* and discovered it was too slow for a couple test cases ... honestly im not sure how i feel about such a small amount of blocked squares as it really trivializes the problem but I had a blast!\\n\\nCheers"
                    },
                    {
                        "username": "hussainafroz903",
                        "content": "can you share your a* search algorithm "
                    }
                ]
            },
            {
                "id": 1927329,
                "content": [
                    {
                        "username": "samizzy18",
                        "content": "You want to traverse from a src point to a target point but there are certain blocks that are not accessible.\\nThis would have been a very easy dfs/bfs problem, had the max array length had not been 10^6\\n\\nThere is a hacky solution which takes into consideration the blocked list length constraint which is only 200.\\nIts going to be hard to block a element from traversal in 10^ by 10^6 grid with only max 200 blocks\\n\\nTherefore, we do normal bfs from source to target and check 2 conditions\\n    1. Whether we have reached target\\n    2. Whether we have exceeded 200 distance, here distance is calculated using manhattan distance, |(diff of x)| + |(diff of y)|\\nIf any of above is true, then return result true.\\n\\nBut wait, what if blocked points are not trying to surround source point but have surrounded the target point?\\n\\nFor above, scenario we again do a bfs bt this time from target to source, if we are able to reach now , we return true.\\n\\nOnly if both traversal return true then we can truly escape.............\\n\\nAlso first check should be whether the src/target point lie on blocked list if yes, then escape is impossible\\n"
                    },
                    {
                        "username": "tejasX",
                        "content": "Crystal Clear !!"
                    },
                    {
                        "username": "1yangshuang",
                        "content": "I submitted multiple instances of the discussion forum where the AC code is wrong.\\n\\n[[0,199],[1,198],[2,197],[3,196],[4,195],[5,194],[6,193],[7,192],[8,191],[9,190],[10,189],[11,188],[12,187],[13,186],[14,185],[15,184],[16,183],[17,182],[18,181],[19,180],[20,179],[21,178],[22,177],[23,176],[24,175],[25,174],[26,173],[27,172],[28,171],[29,170],[30,169],[31,168],[32,167],[33,166],[34,165],[35,164],[36,163],[37,162],[38,161],[39,160],[40,159],[41,158],[42,157],[43,156],[44,155],[45,154],[46,153],[47,152],[48,151],[49,150],[50,149],[51,148],[52,147],[53,146],[54,145],[55,144],[56,143],[57,142],[58,141],[59,140],[60,139],[61,138],[62,137],[63,136],[64,135],[65,134],[66,133],[67,132],[68,131],[69,130],[70,129],[71,128],[72,127],[73,126],[74,125],[75,124],[76,123],[77,122],[78,121],[79,120],[80,119],[81,118],[82,117],[83,116],[84,115],[85,114],[86,113],[87,112],[88,111],[89,110],[90,109],[91,108],[92,107],[93,106],[94,105],[95,104],[96,103],[97,102],[98,101],[99,100],[100,99],[101,98],[102,97],[103,96],[104,95],[105,94],[106,93],[107,92],[108,91],[109,90],[110,89],[111,88],[112,87],[113,86],[114,85],[115,84],[116,83],[117,82],[118,81],[119,80],[120,79],[121,78],[122,77],[123,76],[124,75],[125,74],[126,73],[127,72],[128,71],[129,70],[130,69],[131,68],[132,67],[133,66],[134,65],[135,64],[136,63],[137,62],[138,61],[139,60],[140,59],[141,58],[142,57],[143,56],[144,55],[145,54],[146,53],[147,52],[148,51],[149,50],[150,49],[151,48],[152,47],[153,46],[154,45],[155,44],[156,43],[157,42],[158,41],[159,40],[160,39],[161,38],[162,37],[163,36],[164,35],[165,34],[166,33],[167,32],[168,31],[169,30],[170,29],[171,28],[172,27],[173,26],[174,25],[175,24],[176,23],[177,22],[178,21],[179,20],[180,19],[181,18],[182,17],[183,16],[184,15],[185,14],[186,13],[187,12],[188,11],[189,10],[190,9],[191,8],[192,7],[193,6],[194,5],[195,4],[196,3],[197,2],[198,1],[199,0]]\\n[0,0]\\n[200,200]\\n"
                    },
                    {
                        "username": "anwendeng",
                        "content": "It is to notice that the \"circle\" w.r.t Manhattan distance is in fact  a diamond. Since there are at most B=200 blocked grids, you can use DFS/BFS for solving this 1M^2 size maze, either up to $B(B+1)/2)$ visited grids or up to Manhattan distance to the initial point larger or equal to $B$.\n\nDFS w.r.t Manhattan distance is much faster DFS w.r.t. visited grid size."
                    },
                    {
                        "username": "hussainafroz903",
                        "content": "thank you for saving our time"
                    },
                    {
                        "username": "obiwon84",
                        "content": "I didnt notice the 200 blocked array until after I implemented A* and discovered it was too slow for a couple test cases ... honestly im not sure how i feel about such a small amount of blocked squares as it really trivializes the problem but I had a blast!\\n\\nCheers"
                    },
                    {
                        "username": "hussainafroz903",
                        "content": "can you share your a* search algorithm "
                    }
                ]
            },
            {
                "id": 1573035,
                "content": [
                    {
                        "username": "samizzy18",
                        "content": "You want to traverse from a src point to a target point but there are certain blocks that are not accessible.\\nThis would have been a very easy dfs/bfs problem, had the max array length had not been 10^6\\n\\nThere is a hacky solution which takes into consideration the blocked list length constraint which is only 200.\\nIts going to be hard to block a element from traversal in 10^ by 10^6 grid with only max 200 blocks\\n\\nTherefore, we do normal bfs from source to target and check 2 conditions\\n    1. Whether we have reached target\\n    2. Whether we have exceeded 200 distance, here distance is calculated using manhattan distance, |(diff of x)| + |(diff of y)|\\nIf any of above is true, then return result true.\\n\\nBut wait, what if blocked points are not trying to surround source point but have surrounded the target point?\\n\\nFor above, scenario we again do a bfs bt this time from target to source, if we are able to reach now , we return true.\\n\\nOnly if both traversal return true then we can truly escape.............\\n\\nAlso first check should be whether the src/target point lie on blocked list if yes, then escape is impossible\\n"
                    },
                    {
                        "username": "tejasX",
                        "content": "Crystal Clear !!"
                    },
                    {
                        "username": "1yangshuang",
                        "content": "I submitted multiple instances of the discussion forum where the AC code is wrong.\\n\\n[[0,199],[1,198],[2,197],[3,196],[4,195],[5,194],[6,193],[7,192],[8,191],[9,190],[10,189],[11,188],[12,187],[13,186],[14,185],[15,184],[16,183],[17,182],[18,181],[19,180],[20,179],[21,178],[22,177],[23,176],[24,175],[25,174],[26,173],[27,172],[28,171],[29,170],[30,169],[31,168],[32,167],[33,166],[34,165],[35,164],[36,163],[37,162],[38,161],[39,160],[40,159],[41,158],[42,157],[43,156],[44,155],[45,154],[46,153],[47,152],[48,151],[49,150],[50,149],[51,148],[52,147],[53,146],[54,145],[55,144],[56,143],[57,142],[58,141],[59,140],[60,139],[61,138],[62,137],[63,136],[64,135],[65,134],[66,133],[67,132],[68,131],[69,130],[70,129],[71,128],[72,127],[73,126],[74,125],[75,124],[76,123],[77,122],[78,121],[79,120],[80,119],[81,118],[82,117],[83,116],[84,115],[85,114],[86,113],[87,112],[88,111],[89,110],[90,109],[91,108],[92,107],[93,106],[94,105],[95,104],[96,103],[97,102],[98,101],[99,100],[100,99],[101,98],[102,97],[103,96],[104,95],[105,94],[106,93],[107,92],[108,91],[109,90],[110,89],[111,88],[112,87],[113,86],[114,85],[115,84],[116,83],[117,82],[118,81],[119,80],[120,79],[121,78],[122,77],[123,76],[124,75],[125,74],[126,73],[127,72],[128,71],[129,70],[130,69],[131,68],[132,67],[133,66],[134,65],[135,64],[136,63],[137,62],[138,61],[139,60],[140,59],[141,58],[142,57],[143,56],[144,55],[145,54],[146,53],[147,52],[148,51],[149,50],[150,49],[151,48],[152,47],[153,46],[154,45],[155,44],[156,43],[157,42],[158,41],[159,40],[160,39],[161,38],[162,37],[163,36],[164,35],[165,34],[166,33],[167,32],[168,31],[169,30],[170,29],[171,28],[172,27],[173,26],[174,25],[175,24],[176,23],[177,22],[178,21],[179,20],[180,19],[181,18],[182,17],[183,16],[184,15],[185,14],[186,13],[187,12],[188,11],[189,10],[190,9],[191,8],[192,7],[193,6],[194,5],[195,4],[196,3],[197,2],[198,1],[199,0]]\\n[0,0]\\n[200,200]\\n"
                    },
                    {
                        "username": "anwendeng",
                        "content": "It is to notice that the \"circle\" w.r.t Manhattan distance is in fact  a diamond. Since there are at most B=200 blocked grids, you can use DFS/BFS for solving this 1M^2 size maze, either up to $B(B+1)/2)$ visited grids or up to Manhattan distance to the initial point larger or equal to $B$.\n\nDFS w.r.t Manhattan distance is much faster DFS w.r.t. visited grid size."
                    },
                    {
                        "username": "hussainafroz903",
                        "content": "thank you for saving our time"
                    },
                    {
                        "username": "obiwon84",
                        "content": "I didnt notice the 200 blocked array until after I implemented A* and discovered it was too slow for a couple test cases ... honestly im not sure how i feel about such a small amount of blocked squares as it really trivializes the problem but I had a blast!\\n\\nCheers"
                    },
                    {
                        "username": "hussainafroz903",
                        "content": "can you share your a* search algorithm "
                    }
                ]
            }
        ]
    }
]