[
    {
        "title": "Generate Parentheses",
        "question_content": "Given n pairs of parentheses, write a function to generate all combinations of well-formed parentheses.\n&nbsp;\nExample 1:\nInput: n = 3\nOutput: [\"((()))\",\"(()())\",\"(())()\",\"()(())\",\"()()()\"]\nExample 2:\nInput: n = 1\nOutput: [\"()\"]\n&nbsp;\nConstraints:\n\n\t1 <= n <= 8",
        "solutions": [
            {
                "id": 10100,
                "title": "easy-to-understand-java-backtracking-solution",
                "content": "     public List<String> generateParenthesis(int n) {\\n            List<String> list = new ArrayList<String>();\\n            backtrack(list, \"\", 0, 0, n);\\n            return list;\\n        }\\n        \\n        public void backtrack(List<String> list, String str, int open, int close, int max){\\n            \\n            if(str.length() == max*2){\\n                list.add(str);\\n                return;\\n            }\\n            \\n            if(open < max)\\n                backtrack(list, str+\"(\", open+1, close, max);\\n            if(close < open)\\n                backtrack(list, str+\")\", open, close+1, max);\\n        }\\n\\nThe idea here is to only add '(' and ')' that we know will guarantee us a solution (instead of adding 1 too many close). Once we add a '(' we will then discard it and try a ')' which can only close a valid '('. Each of these steps are recursively called.",
                "solutionTags": [
                    "Java"
                ],
                "code": "     public List<String> generateParenthesis(int n) {\\n            List<String> list = new ArrayList<String>();\\n            backtrack(list, \"\", 0, 0, n);\\n            return list;\\n        }\\n        \\n        public void backtrack(List<String> list, String str, int open, int close, int max){\\n            \\n            if(str.length() == max*2){\\n                list.add(str);\\n                return;\\n            }\\n            \\n            if(open < max)\\n                backtrack(list, str+\"(\", open+1, close, max);\\n            if(close < open)\\n                backtrack(list, str+\")\", open, close+1, max);\\n        }\\n\\nThe idea here is to only add '(' and ')' that we know will guarantee us a solution (instead of adding 1 too many close). Once we add a '(' we will then discard it and try a ')' which can only close a valid '('. Each of these steps are recursively called.",
                "codeTag": "Unknown"
            },
            {
                "id": 2542620,
                "title": "python-java-w-explanation-faster-than-96-w-proof-easy-to-understand",
                "content": "1. The idea is to add `\\')\\'` only after valid `\\'(\\'`\\n2. We use two integer variables `left` & `right` to see how many `\\'(\\'` & `\\')\\'` are in the current string\\n3. If `left < n` then we can add `\\'(\\'` to the current string\\n4. If `right < left` then we can add `\\')\\'` to the current string\\n\\n**Python Code:**\\n```\\ndef generateParenthesis(self, n: int) -> List[str]:\\n\\tdef dfs(left, right, s):\\n\\t\\tif len(s) == n * 2:\\n\\t\\t\\tres.append(s)\\n\\t\\t\\treturn \\n\\n\\t\\tif left < n:\\n\\t\\t\\tdfs(left + 1, right, s + \\'(\\')\\n\\n\\t\\tif right < left:\\n\\t\\t\\tdfs(left, right + 1, s + \\')\\')\\n\\n\\tres = []\\n\\tdfs(0, 0, \\'\\')\\n\\treturn res\\n```\\n\\nFor` n = 2`, the recursion tree will be something like this,\\n```\\n\\t\\t\\t\\t\\t\\t\\t\\t   \\t(0, 0, \\'\\')\\n\\t\\t\\t\\t\\t\\t\\t\\t \\t    |\\t\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t(1, 0, \\'(\\')  \\n\\t\\t\\t\\t\\t\\t\\t\\t   /           \\\\\\n\\t\\t\\t\\t\\t\\t\\t(2, 0, \\'((\\')      (1, 1, \\'()\\')\\n\\t\\t\\t\\t\\t\\t\\t   /                 \\\\\\n\\t\\t\\t\\t\\t\\t(2, 1, \\'(()\\')           (2, 1, \\'()(\\')\\n\\t\\t\\t\\t\\t\\t   /                       \\\\\\n\\t\\t\\t\\t\\t(2, 2, \\'(())\\')                (2, 2, \\'()()\\')\\n\\t\\t\\t\\t\\t\\t      |\\t                             |\\n\\t\\t\\t\\t\\tres.append(\\'(())\\')             res.append(\\'()()\\')\\n   \\n```\\n\\n**Java Code:**\\n```java\\nclass Solution {\\n    public List<String> generateParenthesis(int n) {\\n        List<String> res = new ArrayList<String>();\\n        recurse(res, 0, 0, \"\", n);\\n        return res;\\n    }\\n    \\n    public void recurse(List<String> res, int left, int right, String s, int n) {\\n        if (s.length() == n * 2) {\\n            res.add(s);\\n            return;\\n        }\\n        \\n        if (left < n) {\\n            recurse(res, left + 1, right, s + \"(\", n);\\n        }\\n        \\n        if (right < left) {\\n            recurse(res, left, right + 1, s + \")\", n);\\n        }\\n    }\\n\\t// See above tree diagram with parameters (left, right, s) for better understanding\\n}\\n```\\n![image](https://assets.leetcode.com/users/images/7df8c537-35e6-42a5-8b91-e2f6ec9031d0_1662519743.7174962.png)\\n\\n\\n![image](https://assets.leetcode.com/users/images/227fc269-7b54-4e64-b490-66e6154a40cd_1662518370.2619233.png)\\n\\n\\n\\n",
                "solutionTags": [
                    "Java",
                    "Python",
                    "Python3",
                    "Backtracking",
                    "Depth-First Search",
                    "Recursion"
                ],
                "code": "```\\ndef generateParenthesis(self, n: int) -> List[str]:\\n\\tdef dfs(left, right, s):\\n\\t\\tif len(s) == n * 2:\\n\\t\\t\\tres.append(s)\\n\\t\\t\\treturn \\n\\n\\t\\tif left < n:\\n\\t\\t\\tdfs(left + 1, right, s + \\'(\\')\\n\\n\\t\\tif right < left:\\n\\t\\t\\tdfs(left, right + 1, s + \\')\\')\\n\\n\\tres = []\\n\\tdfs(0, 0, \\'\\')\\n\\treturn res\\n```\n```\\n\\t\\t\\t\\t\\t\\t\\t\\t   \\t(0, 0, \\'\\')\\n\\t\\t\\t\\t\\t\\t\\t\\t \\t    |\\t\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t(1, 0, \\'(\\')  \\n\\t\\t\\t\\t\\t\\t\\t\\t   /           \\\\\\n\\t\\t\\t\\t\\t\\t\\t(2, 0, \\'((\\')      (1, 1, \\'()\\')\\n\\t\\t\\t\\t\\t\\t\\t   /                 \\\\\\n\\t\\t\\t\\t\\t\\t(2, 1, \\'(()\\')           (2, 1, \\'()(\\')\\n\\t\\t\\t\\t\\t\\t   /                       \\\\\\n\\t\\t\\t\\t\\t(2, 2, \\'(())\\')                (2, 2, \\'()()\\')\\n\\t\\t\\t\\t\\t\\t      |\\t                             |\\n\\t\\t\\t\\t\\tres.append(\\'(())\\')             res.append(\\'()()\\')\\n   \\n```\n```java\\nclass Solution {\\n    public List<String> generateParenthesis(int n) {\\n        List<String> res = new ArrayList<String>();\\n        recurse(res, 0, 0, \"\", n);\\n        return res;\\n    }\\n    \\n    public void recurse(List<String> res, int left, int right, String s, int n) {\\n        if (s.length() == n * 2) {\\n            res.add(s);\\n            return;\\n        }\\n        \\n        if (left < n) {\\n            recurse(res, left + 1, right, s + \"(\", n);\\n        }\\n        \\n        if (right < left) {\\n            recurse(res, left, right + 1, s + \")\", n);\\n        }\\n    }\\n\\t// See above tree diagram with parameters (left, right, s) for better understanding\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 10105,
                "title": "concise-recursive-c-solution",
                "content": "The idea is intuitive. Use two integers to count the remaining left parenthesis (n) and the right parenthesis (m) to be added. At each function call add a left parenthesis if n >0 and add a right parenthesis if m>0. Append the result and terminate recursive calls when both m and n are zero.\\n\\n    class Solution {\\n    public:\\n        vector<string> generateParenthesis(int n) {\\n            vector<string> res;\\n            addingpar(res, \"\", n, 0);\\n            return res;\\n        }\\n        void addingpar(vector<string> &v, string str, int n, int m){\\n            if(n==0 && m==0) {\\n                v.push_back(str);\\n                return;\\n            }\\n            if(m > 0){ addingpar(v, str+\")\", n, m-1); }\\n            if(n > 0){ addingpar(v, str+\"(\", n-1, m+1); }\\n        }\\n    };",
                "solutionTags": [],
                "code": "class Solution {\\n    public:\\n        vector<string> generateParenthesis(int n) {\\n            vector<string> res;\\n            addingpar(res, \"\", n, 0);\\n            return res;\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 10096,
                "title": "4-7-lines-python",
                "content": "`p` is the parenthesis-string built so far, `left` and `right` tell the number of left and right parentheses still to add, and `parens` collects the parentheses.\\n\\n**Solution 1**\\n\\nI used a few \"tricks\"... how many can you find? :-)\\n\\n    def generateParenthesis(self, n):\\n        def generate(p, left, right, parens=[]):\\n            if left:         generate(p + '(', left-1, right)\\n            if right > left: generate(p + ')', left, right-1)\\n            if not right:    parens += p,\\n            return parens\\n        return generate('', n, n)\\n\\n**Solution 2**\\n\\nHere I wrote an actual Python generator. I allow myself to put the `yield q` at the end of the line because it's not that bad and because in \"real life\" I use Python 3 where I just say `yield from generate(...)`.\\n\\n    def generateParenthesis(self, n):\\n        def generate(p, left, right):\\n            if right >= left >= 0:\\n                if not right:\\n                    yield p\\n                for q in generate(p + '(', left-1, right): yield q\\n                for q in generate(p + ')', left, right-1): yield q\\n        return list(generate('', n, n))\\n\\n**Solution 3**\\n\\nImproved version of [this](https://leetcode.com/discuss/25725/7-lines-in-python-44-ms). Parameter `open` tells the number of \"already opened\" parentheses, and I continue the recursion as long as I still have to open parentheses (`n > 0`) and I haven't made a mistake yet (`open >= 0`).\\n\\n    def generateParenthesis(self, n, open=0):\\n        if n > 0 <= open:\\n            return ['(' + p for p in self.generateParenthesis(n-1, open+1)] + \\\\\\n                   [')' + p for p in self.generateParenthesis(n, open-1)]\\n        return [')' * open] * (not n)",
                "solutionTags": [
                    "Python"
                ],
                "code": "`p` is the parenthesis-string built so far, `left` and `right` tell the number of left and right parentheses still to add, and `parens` collects the parentheses.\\n\\n**Solution 1**\\n\\nI used a few \"tricks\"... how many can you find? :-)\\n\\n    def generateParenthesis(self, n):\\n        def generate(p, left, right, parens=[]):\\n            if left:         generate(p + '(', left-1, right)\\n            if right > left: generate(p + ')', left, right-1)\\n            if not right:    parens += p,\\n            return parens\\n        return generate('', n, n)\\n\\n**Solution 2**\\n\\nHere I wrote an actual Python generator. I allow myself to put the `yield q` at the end of the line because it's not that bad and because in \"real life\" I use Python 3 where I just say `yield from generate(...)`.\\n\\n    def generateParenthesis(self, n):\\n        def generate(p, left, right):\\n            if right >= left >= 0:\\n                if not right:\\n                    yield p\\n                for q in generate(p + '(', left-1, right): yield q\\n                for q in generate(p + ')', left, right-1): yield q\\n        return list(generate('', n, n))\\n\\n**Solution 3**\\n\\nImproved version of [this](https://leetcode.com/discuss/25725/7-lines-in-python-44-ms). Parameter `open` tells the number of \"already opened\" parentheses, and I continue the recursion as long as I still have to open parentheses (`n > 0`) and I haven't made a mistake yet (`open >= 0`).\\n\\n    def generateParenthesis(self, n, open=0):\\n        if n > 0 <= open:\\n            return ['(' + p for p in self.generateParenthesis(n-1, open+1)] + \\\\\\n                   [')' + p for p in self.generateParenthesis(n, open-1)]\\n        return [')' * open] * (not n)",
                "codeTag": "Python3"
            },
            {
                "id": 10127,
                "title": "an-iterative-method",
                "content": "My method is DP. First consider how to get the result f(n) from previous result f(0)...f(n-1).\\nActually, the result f(n) will be put an extra () pair to f(n-1). Let the \"(\" always at the first position, to produce a valid result, we can only put \")\" in a way that there will be i pairs () inside the extra () and n - 1 - i pairs () outside the extra pair.\\n\\nLet us consider an example to get clear view:\\n\\nf(0):  \"\"\\n\\nf(1):  \"(\"f(0)\")\"\\n\\nf(2): \"(\"f(0)\")\"f(1), \"(\"f(1)\")\"\\n\\nf(3): \"(\"f(0)\")\"f(2), \"(\"f(1)\")\"f(1), \"(\"f(2)\")\"\\n\\nSo f(n) = \"(\"f(0)\")\"f(n-1) , \"(\"f(1)\")\"f(n-2) \"(\"f(2)\")\"f(n-3) ... \"(\"f(i)\")\"f(n-1-i) ... \"(f(n-1)\")\"\\n\\nBelow is my code:\\n\\n    public class Solution\\n    {\\n        public List<String> generateParenthesis(int n)\\n        {\\n            List<List<String>> lists = new ArrayList<>();\\n            lists.add(Collections.singletonList(\"\"));\\n            \\n            for (int i = 1; i <= n; ++i)\\n            {\\n                final List<String> list = new ArrayList<>();\\n                \\n                for (int j = 0; j < i; ++j)\\n                {\\n                    for (final String first : lists.get(j))\\n                    {\\n                        for (final String second : lists.get(i - 1 - j))\\n                        {\\n                            list.add(\"(\" + first + \")\" + second);\\n                        }\\n                    }\\n                }\\n                \\n                lists.add(list);\\n            }\\n            \\n            return lists.get(lists.size() - 1);\\n        }\\n    }",
                "solutionTags": [
                    "Java"
                ],
                "code": "class Solution\\n    {\\n        public List<String> generateParenthesis(int n)\\n        {\\n            List<List<String>> lists = new ArrayList<>();\\n            lists.add(Collections.singletonList(\"\"));\\n            \\n            for (int i = 1; i <= n; ++i)\\n            {\\n                final List<String> list = new ArrayList<>();\\n                \\n                for (int j = 0; j < i; ++j)\\n                {\\n                    for (final String first : lists.get(j))\\n                    {\\n                        for (final String second : lists.get(i - 1 - j))\\n                        {\\n                            list.add(\"(\" + first + \")\" + second);\\n                        }",
                "codeTag": "Java"
            },
            {
                "id": 10369,
                "title": "clean-python-dp-solution",
                "content": "To generate all n-pair parentheses, we can do the following:\\n\\n1. Generate one pair: ()\\n2. Generate 0 pair inside, n - 1 afterward: () (...)...\\n\\n    Generate 1 pair inside, n - 2 afterward: (()) (...)...\\n\\n    ...\\n\\n    Generate n - 1 pair inside, 0 afterward: ((...)) \\n\\nI bet you see the overlapping subproblems here. Here is the code:\\n\\n(you could see in the code that `x` represents one j-pair solution and `y` represents one (i - j - 1) pair solution, and we are taking into account all possible of combinations of them)\\n\\n    class Solution(object):\\n        def generateParenthesis(self, n):\\n            \"\"\"\\n            :type n: int\\n            :rtype: List[str]\\n            \"\"\"\\n            dp = [[] for i in range(n + 1)]\\n            dp[0].append('')\\n            for i in range(n + 1):\\n                for j in range(i):\\n                    dp[i] += ['(' + x + ')' + y for x in dp[j] for y in dp[i - j - 1]]\\n            return dp[n]",
                "solutionTags": [],
                "code": "To generate all n-pair parentheses, we can do the following:\\n\\n1. Generate one pair: ()\\n2. Generate 0 pair inside, n - 1 afterward: () (...)...\\n\\n    Generate 1 pair inside, n - 2 afterward: (()) (...)...\\n\\n    ...\\n\\n    Generate n - 1 pair inside, 0 afterward: ((...)) \\n\\nI bet you see the overlapping subproblems here. Here is the code:\\n\\n(you could see in the code that `x` represents one j-pair solution and `y` represents one (i - j - 1) pair solution, and we are taking into account all possible of combinations of them)\\n\\n    class Solution(object):\\n        def generateParenthesis(self, n):\\n            \"\"\"\\n            :type n: int\\n            :rtype: List[str]\\n            \"\"\"\\n            dp = [[] for i in range(n + 1)]\\n            dp[0].append('')\\n            for i in range(n + 1):\\n                for j in range(i):\\n                    dp[i] += ['(' + x + ')' + y for x in dp[j] for y in dp[i - j - 1]]\\n            return dp[n]",
                "codeTag": "Java"
            },
            {
                "id": 1131364,
                "title": "clear-and-simple-explanation-with-intuition-100-faster",
                "content": "**Intuition:** Since we are asked to calculate all the possible permutations of brackets , hence we have to use backtracking\\n\\n**Concept:** In every backtracking problem , there are two things to keep in mind , which we will explore here as well :\\n*  Base Case: Every problem of backtracking has some base case which tells us at which point we have to stop with the recursion process. In our case, when the length of our string has reached the maximum length(`n*2`), we stop with the recursion for that case and that is our base case.\\n\\n*   Conditions: On observing carefully we find that there are two conditions present:\\n    *  For adding **`(`**:  If number of opening brackets(`open`) is less than the the given length(`n`) i.e.\\n        if `max`<`n`, then we can add **`(`**,else not.\\n\\t*  For adding **`)`**: If number of close brackets(`close`) is less than the opening brackets(`open`), i.e.\\n\\t    if `open`<`close`, we can add **`)`**, else not\\n\\t\\t\\nAnd thats it!!! Keeping these two things in mind here is the code: \\n\\n**Code:**\\n\\n```\\nclass Solution {\\npublic:\\n    vector<string>result;\\n    \\n    void helper(int open,int close,int n,string current)\\n    {\\n        if(current.length()==n*2)\\n        {\\n            result.push_back(current);\\n            return;\\n        }\\n        if(open<n)  helper(open+1,close,n,current+\"(\");\\n        if(close<open)  helper(open,close+1,n,current+\")\");\\n    }\\n    vector<string> generateParenthesis(int n) {\\n        helper(0,0,n,\"\");\\n        return result;\\n    }\\n};\\n```\\n\\n**For similar problems: [Backtracking Collection](https://leetcode.com/discuss/interview-question/1141947/backtracking-study-and-analysis)**\\n\\nIf you like, please **UPVOTE**\\nHappy Coding :))",
                "solutionTags": [
                    "C++",
                    "C",
                    "Backtracking",
                    "Recursion"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<string>result;\\n    \\n    void helper(int open,int close,int n,string current)\\n    {\\n        if(current.length()==n*2)\\n        {\\n            result.push_back(current);\\n            return;\\n        }\\n        if(open<n)  helper(open+1,close,n,current+\"(\");\\n        if(close<open)  helper(open,close+1,n,current+\")\");\\n    }\\n    vector<string> generateParenthesis(int n) {\\n        helper(0,0,n,\"\");\\n        return result;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3290261,
                "title": "i-bet-you-will-understand-intutive-solution-beginner-friendly-c",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nThis problem is one of the classical recursion problems. \\nFor any given n, lets say n = 2, we have to fill four places in our output (\"_ _ _ _\"). And each of these places can be either filled by an open braces \"(\" or a closed braces \")\". \\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n                                    \"_  _  _  _\"\\n                                    / \\\\     \\n                                  \\'(\\' \\')\\'\\n\\nFor every place we have two choices and 1 decision to make. \\nOur choices are to either use \\'(\\' or \\')\\'.\\n\\nNow lets try to visualize the recursive tree based upon the choices discussed above.\\n\\nInitially, we have:\\nFor n = 3\\ncurrent ouput = \"\"\\navailableOpenBracketsCnt = 3 and availableCloseBracketsCnt  = 3\\n\\nThe first choise is very simple. Since we can not start a balanced parenthesis sequence with \\')\\', we have only one choice in the begining. So our output will be \\'(\\' and count of open brackets left = 2 and count of closed brackets left = 3.\\n\\n                                        op      ip\\n                                        \"\"   O-3, C-3\\n                                \\n                                        \"(\",O-2,C-3\\n                        \\n                    \"((\",O-1,C-3                            \"()\", O-2,C-2\\n\\n        \"(((\",0,3             \"(()\",1,2                       \"()(\",1,2\\n\\n        \"((()\",0,2      \"(()(\",0,2    \"(())\",1,1        \"()((\",0,2      \"()()\",1,1\\n\\n        \"((())\",0,1     \"(()()\",0,1   \"(())(\",0,1       \"()(()\",0,1     \"()()(\",0,1\\n\\n        \"((()))\",0,0   \"(()())\",0,0   \"(())()\",0,0      \"()(())\",0,0    \"()()()\", 0,0\\n                            \\n\\n# Observation from the recursive tree\\n\\n - Whenever we have count of open brackets equal to the count of close brackets, we have only one choice - that is to use \\'(\\'. Because, all the brackets till now have been balanced. And we can not start a new sequence with \\')\\'. \\n - Whenever, count of close bracket is 0, we can only use \\'(\\'.\\n - Whenever, count of open bracket is 0, we can only use \\')\\'.\\n - And for all the remaining cases, we have both the choices.\\n - We get an answer, when count of open == 0 and count of close == 0.\\n\\nJust convert these 5 observations into an algorithm and write the code. \\n\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    void solve(string op, int open, int close, vector<string> &ans){\\n        if(open == 0 && close == 0){\\n            ans.push_back(op);\\n            return;\\n        }\\n        //when count of open and close brackets are same then \\n        //we have only one choice to put open bracket \\n        if(open == close){\\n            string op1 = op;\\n            op1.push_back(\\'(\\');\\n            solve(op1, open-1, close, ans);\\n        }\\n        else if(open == 0){\\n            //only choice is to put close brackets \\n            string op1 = op;\\n            op1.push_back(\\')\\');\\n            solve(op1, open, close-1, ans);\\n        }\\n        else if(close == 0){\\n            //only choise is to use open bracket \\n            string op1 = op;\\n            op1.push_back(\\'(\\');\\n            solve(op1, open-1, close, ans);\\n        }\\n        else{\\n            string op1 = op;\\n            string op2 = op;\\n            op1.push_back(\\'(\\');\\n            op2.push_back(\\')\\');\\n            solve(op1, open-1, close, ans);\\n            solve(op2, open, close-1, ans);\\n        }\\n    }\\n    vector<string> generateParenthesis(int n) {\\n        int open = n;\\n        int close = n;\\n        vector<string> ans;\\n        string op = \"\";\\n        solve(op, open, close, ans);\\n        return ans;\\n    }\\n};\\n```\\n**Note** : I have kept the code implementation simple by just following the observations I mentioned. The same code can be made more compact by reducing some conditional statements (although the time and space complexity will remain the same).\\nTry to come up with your own compact version. Refer the comments of other peers for help.\\n\\n# Complexity Analysis: \\n- Time Complexity : $O(N*2^N)$ where N = 2*n\\n $O(2^N)$ : We have N = 2n places to fill and for every place we will have a maximum of 2 choices. \\n $O(N)$ : We will have to multiply our TC by a factor of N, as every time when we hit the base case, we will copy current op (which is of size N) into the answer vector.\\n- Space Complexity : $O(N)$ + Recursive Stack Space\\n We have used an extra string of size N for storing current output\\n# Please upvote the solution if you understood it.\\n\\n![NRRa.gif](https://assets.leetcode.com/users/images/ac16397a-5dda-46bb-8508-a6caf66f016b_1679243081.1794233.gif)\\n\\n**You can connect with me on linkedin, If you understood my solution :D**\\nhttps://www.linkedin.com/in/imraghavagr/\\n\\n",
                "solutionTags": [
                    "C++",
                    "Recursion"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    void solve(string op, int open, int close, vector<string> &ans){\\n        if(open == 0 && close == 0){\\n            ans.push_back(op);\\n            return;\\n        }\\n        //when count of open and close brackets are same then \\n        //we have only one choice to put open bracket \\n        if(open == close){\\n            string op1 = op;\\n            op1.push_back(\\'(\\');\\n            solve(op1, open-1, close, ans);\\n        }\\n        else if(open == 0){\\n            //only choice is to put close brackets \\n            string op1 = op;\\n            op1.push_back(\\')\\');\\n            solve(op1, open, close-1, ans);\\n        }\\n        else if(close == 0){\\n            //only choise is to use open bracket \\n            string op1 = op;\\n            op1.push_back(\\'(\\');\\n            solve(op1, open-1, close, ans);\\n        }\\n        else{\\n            string op1 = op;\\n            string op2 = op;\\n            op1.push_back(\\'(\\');\\n            op2.push_back(\\')\\');\\n            solve(op1, open-1, close, ans);\\n            solve(op2, open, close-1, ans);\\n        }\\n    }\\n    vector<string> generateParenthesis(int n) {\\n        int open = n;\\n        int close = n;\\n        vector<string> ans;\\n        string op = \"\";\\n        solve(op, open, close, ans);\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 10110,
                "title": "simple-python-dfs-solution-with-explanation",
                "content": "If you have two stacks, one for n \"(\", the other for n \")\", you generate a binary tree from these two stacks of left/right parentheses to form an output string. \\n\\n\\nThis means that whenever you traverse deeper, you pop one parentheses from one of stacks. When two stacks are empty, you form an output string.\\n\\nHow to form a legal string? Here is the simple observation:\\n\\n - For the output string to be right, stack of \")\" most be larger than stack of \"(\". If not, it creates string like \"())\"\\n - Since elements in each of stack are the same, we can simply express them with a number. For example, left = 3 is like a stacks [\"(\", \"(\", \"(\"]\\n\\nSo, here is my sample code in Python:\\n\\n    class Solution:\\n    # @param {integer} n\\n    # @return {string[]}\\n    def generateParenthesis(self, n):\\n        if not n:\\n            return []\\n        left, right, ans = n, n, []\\n        self.dfs(left,right, ans, \"\")\\n        return ans\\n\\n    def dfs(self, left, right, ans, string):\\n        if right < left:\\n            return\\n        if not left and not right:\\n            ans.append(string)\\n            return\\n        if left:\\n            self.dfs(left-1, right, ans, string + \"(\")\\n        if right:\\n            self.dfs(left, right-1, ans, string + \")\")",
                "solutionTags": [
                    "Python",
                    "Depth-First Search"
                ],
                "code": "class Solution:\\n    # @param {integer}",
                "codeTag": "Java"
            },
            {
                "id": 10099,
                "title": "time-complexity-to-generate-all-combinations-of-well-formed-parentheses",
                "content": "Generating all combinations of well formed paranthesis is a typical example of catalan numbers. You can use the links at the bottom here if you are not aware of the catalan numbers since they are at the heart of the exercise.\\nLet time complexity for the generating all combinations of well-formed parentheses is f(n), then\\nf(n) = g(n) * h(n) where g(n) is the time complexity for calculating nth catalan number, and h(n) is the time required to copy this combination to result array.\\nTherefore, f(n) = catalan(n) * O(n) which is O(4^n/n^1.5)*(n)). Broadly saying just remember that this is a typical example of catalan number and it's time complexity is similar to how catalan(n) is got.\\nFurther readings in to catalan numbers:\\nhttps://en.wikipedia.org/wiki/Catalan_number\\nhttps://www.youtube.com/watch?v=GlI17WaMrtw\\nhttps://www.youtube.com/watch?v=eoofvKI_Okg",
                "solutionTags": [],
                "code": "Generating all combinations of well formed paranthesis is a typical example of catalan numbers. You can use the links at the bottom here if you are not aware of the catalan numbers since they are at the heart of the exercise.\\nLet time complexity for the generating all combinations of well-formed parentheses is f(n), then\\nf(n) = g(n) * h(n) where g(n) is the time complexity for calculating nth catalan number, and h(n) is the time required to copy this combination to result array.\\nTherefore, f(n) = catalan(n) * O(n) which is O(4^n/n^1.5)*(n)). Broadly saying just remember that this is a typical example of catalan number and it's time complexity is similar to how catalan(n) is got.\\nFurther readings in to catalan numbers:\\nhttps://en.wikipedia.org/wiki/Catalan_number\\nhttps://www.youtube.com/watch?v=GlI17WaMrtw\\nhttps://www.youtube.com/watch?v=eoofvKI_Okg",
                "codeTag": "Unknown"
            },
            {
                "id": 10283,
                "title": "python-simple-stack-solution-without-recursion",
                "content": "    def generateParenthesis(self, n):\\n        res = []\\n        s = [(\"(\", 1, 0)]\\n        while s:\\n            x, l, r = s.pop()\\n            if l - r < 0 or l > n or r > n:\\n                continue\\n            if l == n and r == n:\\n                res.append(x)\\n            s.append((x+\"(\", l+1, r))\\n            s.append((x+\")\", l, r+1))\\n        return res\\n\\n\\nvariable l is current left parenthesis count\\n\\nvariable r is current right parenthesis count\\n\\nl - r < 0 means this is not a valid parenthesis",
                "solutionTags": [
                    "Python",
                    "Stack"
                ],
                "code": "    def generateParenthesis(self, n):\\n        res = []\\n        s = [(\"(\", 1, 0)]\\n        while s:\\n            x, l, r = s.pop()\\n            if l - r < 0 or l > n or r > n:\\n                continue\\n            if l == n and r == n:\\n                res.append(x)\\n            s.append((x+\"(\", l+1, r))\\n            s.append((x+\")\", l, r+1))\\n        return res\\n\\n\\nvariable l is current left parenthesis count\\n\\nvariable r is current right parenthesis count\\n\\nl - r < 0 means this is not a valid parenthesis",
                "codeTag": "Python3"
            },
            {
                "id": 10098,
                "title": "java-dfs-way-solution",
                "content": "    public List<String> generateParenthesis(int n) {\\n        List<String> list = new ArrayList<String>();\\n        generateOneByOne(\"\", list, n, n);\\n        return list;\\n    }\\n    public void generateOneByOne(String sublist, List<String> list, int left, int right){\\n        if(left > right){\\n            return;\\n        }\\n        if(left > 0){\\n            generateOneByOne( sublist + \"(\" , list, left-1, right);\\n        }\\n        if(right > 0){\\n            generateOneByOne( sublist + \")\" , list, left, right-1);\\n        }\\n        if(left == 0 && right == 0){\\n            list.add(sublist);\\n            return;\\n        }\\n    }",
                "solutionTags": [],
                "code": "    public List<String> generateParenthesis(int n) {\\n        List<String> list = new ArrayList<String>();\\n        generateOneByOne(\"\", list, n, n);\\n        return list;\\n    }\\n    public void generateOneByOne(String sublist, List<String> list, int left, int right){\\n        if(left > right){\\n            return;\\n        }\\n        if(left > 0){\\n            generateOneByOne( sublist + \"(\" , list, left-1, right);\\n        }\\n        if(right > 0){\\n            generateOneByOne( sublist + \")\" , list, left, right-1);\\n        }\\n        if(left == 0 && right == 0){\\n            list.add(sublist);\\n            return;\\n        }\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 10388,
                "title": "python-easy-to-understand-dfs-solution",
                "content": "        \\n    def generateParenthesis(self, n):\\n        res = []\\n        self.dfs(n, n, \"\", res)\\n        return res\\n            \\n    def dfs(self, leftRemain, rightRemain, path, res):\\n        if leftRemain > rightRemain or leftRemain < 0 or rightRemain < 0:\\n            return  # backtracking\\n        if leftRemain == 0 and rightRemain == 0:\\n            res.append(path)\\n            return \\n        self.dfs(leftRemain-1, rightRemain, path+\"(\", res)\\n        self.dfs(leftRemain, rightRemain-1, path+\")\", res)",
                "solutionTags": [
                    "Python",
                    "Backtracking",
                    "Depth-First Search"
                ],
                "code": "        \\n    def generateParenthesis(self, n):\\n        res = []\\n        self.dfs(n, n, \"\", res)\\n        return res\\n            \\n    def dfs(self, leftRemain, rightRemain, path, res):\\n        if leftRemain > rightRemain or leftRemain < 0 or rightRemain < 0:\\n            return  # backtracking\\n        if leftRemain == 0 and rightRemain == 0:\\n            res.append(path)\\n            return \\n        self.dfs(leftRemain-1, rightRemain, path+\"(\", res)\\n        self.dfs(leftRemain, rightRemain-1, path+\")\", res)",
                "codeTag": "Python3"
            },
            {
                "id": 139455,
                "title": "clean-javascript-backtracking-solution",
                "content": "**Solution 1**\\n\\n```js\\nconst generateParenthesis = (n) => {\\n  const res = [];\\n\\n  const go = (l, r, s) => {\\n    if (s.length === 2 * n) {\\n      res.push(s);\\n      return;\\n    }\\n\\n    if (l < n) go(l + 1, r, s + \\'(\\');\\n    if (r < l) go(l, r + 1, s + \\')\\');\\n  };\\n\\n  go(0, 0, \\'\\');\\n  return res;\\n};\\n```\\n\\n**Solution 2**\\n\\n```js\\nconst generateParenthesis = (n) => {\\n  const res = [];\\n\\n  const go = (l, r, s) => { // l: left remaining, r: right remaining\\n    if (l > r) return; // Validate by the number of \\'(\\' should be always >= \\')\\'\\n\\n    if (l === 0 && r === 0) {\\n      res.push(s);\\n      return;\\n    }\\n\\n    if (l > 0) go(l - 1, r, s + \\'(\\');\\n    if (r > 0) go(l, r - 1, s + \\')\\');\\n  };\\n\\n  go(n, n, \\'\\');\\n  return res;\\n};\\n```\\n\\n",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```js\\nconst generateParenthesis = (n) => {\\n  const res = [];\\n\\n  const go = (l, r, s) => {\\n    if (s.length === 2 * n) {\\n      res.push(s);\\n      return;\\n    }\\n\\n    if (l < n) go(l + 1, r, s + \\'(\\');\\n    if (r < l) go(l, r + 1, s + \\')\\');\\n  };\\n\\n  go(0, 0, \\'\\');\\n  return res;\\n};\\n```\n```js\\nconst generateParenthesis = (n) => {\\n  const res = [];\\n\\n  const go = (l, r, s) => { // l: left remaining, r: right remaining\\n    if (l > r) return; // Validate by the number of \\'(\\' should be always >= \\')\\'\\n\\n    if (l === 0 && r === 0) {\\n      res.push(s);\\n      return;\\n    }\\n\\n    if (l > 0) go(l - 1, r, s + \\'(\\');\\n    if (r > 0) go(l, r - 1, s + \\')\\');\\n  };\\n\\n  go(n, n, \\'\\');\\n  return res;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1276079,
                "title": "python-backtracking-complexity-analysis-clean-concise",
                "content": "**\\u2714\\uFE0F Solution 1: Naive Backtracking**\\n```python\\nclass Solution:\\n    def generateParenthesis(self, n: int) -> List[str]:\\n        ans = []\\n        \\n        def isValidParenthesis(s):\\n            cntOpen = 0\\n            for c in s:\\n                if c == \\'(\\':\\n                    cntOpen += 1\\n                else:\\n                    if cntOpen == 0: return False  # Don\\'t have enough open to match with this close parentheses\\n                    cntOpen -= 1\\n            return cntOpen == 0  #\\xA0Fully match all open parentheses\\n        \\n        def bt(i, path):\\n            if i == 2 * n:\\n                if isValidParenthesis(path):\\n                    ans.append(path)\\n                return\\n            \\n            bt(i+1, path + \"(\")  # Add open\\n            bt(i+1, path + \")\")  # Add close\\n            \\n        bt(0, \"\")\\n        return ans\\n```\\nComplexity:\\n- Time: `O(2^m * m)`, where `m = 2n`, `n <= 8`\\n- Space: `n-th` Catalan Number.\\n\\n---\\n**\\u2714\\uFE0F Solution 2: Smart Backtracking**\\n```python\\nclass Solution:\\n    def generateParenthesis(self, n: int) -> List[str]:\\n        def backtracking(nOpen, nClose, path):\\n            if n == nClose:  # Found a valid n pairs of parentheses\\n                ans.append(path)\\n                return\\n\\n            if nOpen < n:  # Number of opening bracket up to `n`\\n                backtracking(nOpen + 1, nClose, path + \"(\")\\n            if nClose < nOpen:  # Number of closing bracket up to opening bracket\\n                backtracking(nOpen, nClose + 1, path + \")\")\\n\\n        ans = []\\n        backtracking(0, 0, \"\")\\n        return ans\\n```\\n**Complexity**\\n- Our complexity analysis based on how many elements there are in `generateParenthesis(n)`. \\n- This is the `n-th` [Catalan number](https://en.wikipedia.org/wiki/Catalan_number), where the first Catalan numbers for `n = 0, 1, 2, 3, ...` are `1, 1, 2, 5, 14, 42, 132, 429, 1430, 4862, 16796, 58786,...`\\n- Time & Space: `n-th` Catalan Number.",
                "solutionTags": [],
                "code": "```python\\nclass Solution:\\n    def generateParenthesis(self, n: int) -> List[str]:\\n        ans = []\\n        \\n        def isValidParenthesis(s):\\n            cntOpen = 0\\n            for c in s:\\n                if c == \\'(\\':\\n                    cntOpen += 1\\n                else:\\n                    if cntOpen == 0: return False  # Don\\'t have enough open to match with this close parentheses\\n                    cntOpen -= 1\\n            return cntOpen == 0  #\\xA0Fully match all open parentheses\\n        \\n        def bt(i, path):\\n            if i == 2 * n:\\n                if isValidParenthesis(path):\\n                    ans.append(path)\\n                return\\n            \\n            bt(i+1, path + \"(\")  # Add open\\n            bt(i+1, path + \")\")  # Add close\\n            \\n        bt(0, \"\")\\n        return ans\\n```\n```python\\nclass Solution:\\n    def generateParenthesis(self, n: int) -> List[str]:\\n        def backtracking(nOpen, nClose, path):\\n            if n == nClose:  # Found a valid n pairs of parentheses\\n                ans.append(path)\\n                return\\n\\n            if nOpen < n:  # Number of opening bracket up to `n`\\n                backtracking(nOpen + 1, nClose, path + \"(\")\\n            if nClose < nOpen:  # Number of closing bracket up to opening bracket\\n                backtracking(nOpen, nClose + 1, path + \")\")\\n\\n        ans = []\\n        backtracking(0, 0, \"\")\\n        return ans\\n```",
                "codeTag": "Java"
            },
            {
                "id": 10367,
                "title": "simple-2ms-c-solution-with-explanation",
                "content": "class Solution {\\npublic:\\n\\n    vector<string> result;\\n    vector<string> generateParenthesis(int n) {\\n        helper(\"\", n, 0);\\n        return result;\\n    }\\n\\n    /*  this hepler function insert result strings to \"vector<string> result\"\\n   \\t\\tWhen number of '(' less than \"n\", can append '(';\\n   \\t\\tWhen number of '(' is more than number of ')', can append ')';\\n\\n    \\tstring s : current string;\\n    \\tint leftpare_need : number of '(' that have not put into \"string s\";\\n    \\tint moreleft : number of '(' minus number of ')' in the \"string s\";\\n    */\\n\\n    void helper(string s, int leftpare_need, int moreleft)\\n    {\\n    \\tif(leftpare_need == 0 && moreleft == 0)\\n    \\t{\\n    \\t    result.push_back(s);\\n    \\t    return;\\n    \\t}\\n    \\tif(leftpare_need > 0)\\n    \\t\\thelper(s + \"(\", leftpare_need - 1, moreleft+1);\\n    \\tif(moreleft > 0)\\n    \\t\\thelper(s + \")\", leftpare_need, moreleft - 1);\\n    }\\n};",
                "solutionTags": [],
                "code": "class Solution {\\npublic:\\n\\n    vector<string> result;\\n    vector<string> generateParenthesis(int n) {\\n        helper(\"\", n, 0);\\n        return result;\\n    }",
                "codeTag": "Java"
            },
            {
                "id": 1561062,
                "title": "python3-recursive-approach-simple-logic-step-by-step-explanation",
                "content": "One thing we need to understand is, we need a way to add \\u201C(\\u201D and \\u201C)\\u201D to all possible cases and \\nthen find a way to validate so that we don\\u2019t generate the unnecessary ones.\\n\\nThe first condition is if there are more than 0 open / left brackets, we recurse with the right\\nones. And if we have more than 0 right brackets, we recurse with the left ones. Left and right\\nare initialized with` \\'n\\' `- the number given.\\n\\n\\n```\\n\\t\\t\\tif left>0:\\n                helper(ans, s+\\'(\\', left-1, right)\\n                \\n            if right>0:\\n                helper(ans, s+\\')\\', left, right-1)\\n```\\n\\n<br>\\n\\nThere\\u2019s a catch. We can\\u2019t add the \\u201C)\\u201D everytime we have `right>0` cause then it will not be\\nbalanced. We can balance that with a simple condition of `left<right.`\\n\\n```\\n\\t\\t\\tif left>0:\\n                helper(ans, s+\\'(\\', left-1, right)\\n                \\n            if right>0 and left<right:\\n                helper(ans, s+\\')\\', left, right-1)\\n```\\n\\n<br>\\nSince this is a recursive approach we need to have a **BASE condition**,\\nand the base case is: \\n\\nWhen both right and left are 0, \\nwe have found one possible combination of parentheses \\n& we now need to append/add the `\\'s\\'` to `\\'ans\\'` list.\\n\\n```\\n\\t\\t\\tif left==0 and right==0:\\n                ans.append(s)\\n```\\n\\n<br>\\n<br>\\n\\n**Complete code**\\n```\\nclass Solution:\\n    def generateParenthesis(self, n: int) -> List[str]:\\n        \\n        \\n        def helper(ans, s, left, right):\\n            if left==0 and right==0:\\n                ans.append(s)\\n                \\n            if left>0:\\n                helper(ans, s+\\'(\\', left-1, right)\\n                \\n            if right>0 and left<right:\\n                helper(ans, s+\\')\\', left, right-1)\\n        \\n        ans = []\\n        helper(ans, \\'\\', n, n)\\n        \\n        return ans\\n```\\n\\n\\n\\n<br>\\n<br>\\n*If this post seems to be helpful, please upvote!!*",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Recursion"
                ],
                "code": "```\\n\\t\\t\\tif left>0:\\n                helper(ans, s+\\'(\\', left-1, right)\\n                \\n            if right>0:\\n                helper(ans, s+\\')\\', left, right-1)\\n```\n```\\n\\t\\t\\tif left>0:\\n                helper(ans, s+\\'(\\', left-1, right)\\n                \\n            if right>0 and left<right:\\n                helper(ans, s+\\')\\', left, right-1)\\n```\n```\\n\\t\\t\\tif left==0 and right==0:\\n                ans.append(s)\\n```\n```\\nclass Solution:\\n    def generateParenthesis(self, n: int) -> List[str]:\\n        \\n        \\n        def helper(ans, s, left, right):\\n            if left==0 and right==0:\\n                ans.append(s)\\n                \\n            if left>0:\\n                helper(ans, s+\\'(\\', left-1, right)\\n                \\n            if right>0 and left<right:\\n                helper(ans, s+\\')\\', left, right-1)\\n        \\n        ans = []\\n        helper(ans, \\'\\', n, n)\\n        \\n        return ans\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2679907,
                "title": "easy-recursive-c-solution-clearly-explained",
                "content": "Hello all, \\n\\nBefore jumping to the code, go through the explanation. I have curated the explanation for your easy understanding. This will help you build a clear logic for many recursive problems moving forward.\\n\\nStep1: Identification of Problem\\nThe problem asks us to generate all the valid paranthesis sequences, the first thing that should come to mind is recursion. Hence recursion is the way forward.  \\n\\nStep2: Correctness of Solution\\nIt is really crucial to understand that the solution should be correct befire being optimized. \\n\\nStep3: Building Solution \\nWe start by maintaining a count for both the opening and closing paranthesis as\\n```\\n// count1 is used to flag the base case \\n// count2 is used to react to the base case \\ncount1=0 and count2=0 respectively.\\n\\n// following is the signature for the recursive function\\nsubseq(int count1,int count2,string v,vector<string> &ans,int n)\\n\\n// only the first three parameters are determining the state of each recursive call.\\n// vector<string> &ans   is passed with every recursive call to store the final valid strings\\n// int n   is used to check the base condition\\n```\\n\\nStep 4: Logic\\n\\n* A Valid sequence will include the closing paranthesis only when there are more opening paranthesis. Hence, the condition\\n```\\nif(count2<count1){\\n\\tsubseq(count1,count2+1,v+\")\",ans,n);    \\n}\\n```\\n* An opening paranthesis is always open to be the part of a valid paranthesis till it has a count less than n. \\n* As soon as the count of opening paranthesis reaches n, we push all the remaining closing paranthesis into the sequence, because there are no more opening paranthesis to add.\\n\\nStep5: Code\\n```\\nvoid subseq(int count1,int count2,string v,vector<string> &ans,int n){\\n        if(count1==n){\\n            // if there are n open \\'(\\', we simply push the rest closing \\')\\'\\n            while(count2<n){\\n                v+=\")\";\\n                count2+=1;\\n            }\\n\\t\\t\\t// v is pushed to the answer vector\\n\\t\\t\\t\\n            ans.push_back(v);\\n            return;\\n        }\\n\\t\\t\\n        subseq(count1+1,count2,v+\"(\",ans,n);\\n\\t\\t\\n        if(count2<count1){\\n            subseq(count1,count2+1,v+\")\",ans,n);    \\n        }\\n    }\\n    vector<string> generateParenthesis(int n) {\\n        vector<string> ans;\\n        string v;\\n        subseq(0,0,v,ans,n);\\n\\n        return ans;\\n    }\\n```\\n\\n**Please upvote, if the solution was of help to you. This will help other people in the community optimize their search for the best solution.**\\n\\nCheers!!\\n\\n\\n\\n",
                "solutionTags": [
                    "C",
                    "Recursion"
                ],
                "code": "```\\n// count1 is used to flag the base case \\n// count2 is used to react to the base case \\ncount1=0 and count2=0 respectively.\\n\\n// following is the signature for the recursive function\\nsubseq(int count1,int count2,string v,vector<string> &ans,int n)\\n\\n// only the first three parameters are determining the state of each recursive call.\\n// vector<string> &ans   is passed with every recursive call to store the final valid strings\\n// int n   is used to check the base condition\\n```\n```\\nif(count2<count1){\\n\\tsubseq(count1,count2+1,v+\")\",ans,n);    \\n}\\n```\n```\\nvoid subseq(int count1,int count2,string v,vector<string> &ans,int n){\\n        if(count1==n){\\n            // if there are n open \\'(\\', we simply push the rest closing \\')\\'\\n            while(count2<n){\\n                v+=\")\";\\n                count2+=1;\\n            }\\n\\t\\t\\t// v is pushed to the answer vector\\n\\t\\t\\t\\n            ans.push_back(v);\\n            return;\\n        }\\n\\t\\t\\n        subseq(count1+1,count2,v+\"(\",ans,n);\\n\\t\\t\\n        if(count2<count1){\\n            subseq(count1,count2+1,v+\")\",ans,n);    \\n        }\\n    }\\n    vector<string> generateParenthesis(int n) {\\n        vector<string> ans;\\n        string v;\\n        subseq(0,0,v,ans,n);\\n\\n        return ans;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 594770,
                "title": "c-2-solutions-backtracking-and-dp",
                "content": "**Solution One**\\n\\nGiven a number n, we have to generate all valid `n` pairs of parenthesis. Since we have to generate all the valid combinations, the first solution which comes to our mind is backtracking (recursion). Given the constraint, I would say that is the best solution. \\n\\nWe start with number of open brackets `open = 0`, and number of close brackets `close = 0`. Now at any given recursion level, either we can put one open bracket or one close bracket. The constraints would be that `open can never be greater than n` and that `close < open` at all times. Below code is self explanatory. **Note I used string references to obtain a gain in speed**.\\n\\n```\\nclass Solution {\\npublic:\\n    void util(vector<string>& res, int open, int close, string& tmp, int n)\\n    {\\n        if(tmp.length()==2*n) {res.push_back(tmp); return;}\\n        if(open<n){\\n            tmp.push_back(\\'(\\');\\n            util(res,open+1,close,tmp,n);\\n            tmp.pop_back();\\n        }\\n        if(close<open){\\n            tmp.push_back(\\')\\');\\n            util(res,open,close+1,tmp,n);\\n            tmp.pop_back();\\n        }\\n    }\\n    vector<string> generateParenthesis(int n) {\\n        int open=0,close=0; // open -> number of open brackets\\n\\t\\t\\t\\t\\t\\t // close -> number of close brackets\\n        vector<string> res;\\n        if(n==0) return res;\\n        string temp=\"\";\\n        util(res,open,close,temp,n);\\n        return res;\\n    }\\n};\\n```\\n\\n*Time Complexity* - Very important for these kind of questions. Since recursion is a tree, and here there are two recursive calls possible at any level. Heigh of the tree will be `2*n`, since we are generating `2*n` number of brackets. So, **worst-case Time Complexity will be** ```O(2^(2n))```.\\n\\n*Space Complexity* - `O(2*n)` (Stack space after using recursion)\\n\\n**Solution Two**\\n\\nNow, given the constraints in the problem, backtracking is good. But what if, `n` is large. We can\\'t afford exponential solution. The next thought should be dynamic programming, and if there is a overlapping subproblems nature to it.\\n\\nSuppose `dp[i]` contains all the valid parentheses possible of length `2*i`. Suppose you got `dp[2]` which is `{ (()) , ()() }`. Now what will be `dp[3]`? It can be written as -\\n\\n`(` + dp[0] + `)` + dp[2] = `()(())` and `()()()`\\n`(` + dp[1] + `)` + dp[1] = `(())()`\\n`(` + dp[2] + `)` + dp[0] = `((()))` and `(()())`\\n\\nSo you see, we have an overlapping subproblems structure. It\\'s good to know here that this structure closely follows `Catalan Numbers`. (You can find the number of valid parentheses using Catalan Numbers).\\n\\n`dp[i] = \"(\" + dp[j] + \")\" + dp[i-j-1]`   (Recursive relation. Similar to a binary tree generation).\\n\\n```\\nvector<string> generateParenthesis(int n) {\\n        vector<vector<string>> dp(n+1); // cache to store all generated strings\\n        dp[0] = {\"\"}; \\n        for(int i=1;i<=n;i++){\\n            for(int j=0;j<i;j++){\\n                vector<string> left = dp[j];\\n                vector<string> right = dp[i-j-1];\\n                for(int k=0;k<left.size();k++){\\n                    for(int l=0;l<right.size();l++){\\n                        dp[i].push_back(\"(\" + left[k] + \")\" + right[l]);\\n                    }\\n                }\\n            }\\n        }\\n        return dp[n];\\n    }\\n```\\n\\n*Time Complexity* - `O(n^4)`.\\n*Space Complexity* - `O(n)`.",
                "solutionTags": [
                    "C++",
                    "Dynamic Programming",
                    "Backtracking",
                    "Recursion"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    void util(vector<string>& res, int open, int close, string& tmp, int n)\\n    {\\n        if(tmp.length()==2*n) {res.push_back(tmp); return;}\\n        if(open<n){\\n            tmp.push_back(\\'(\\');\\n            util(res,open+1,close,tmp,n);\\n            tmp.pop_back();\\n        }\\n        if(close<open){\\n            tmp.push_back(\\')\\');\\n            util(res,open,close+1,tmp,n);\\n            tmp.pop_back();\\n        }\\n    }\\n    vector<string> generateParenthesis(int n) {\\n        int open=0,close=0; // open -> number of open brackets\\n\\t\\t\\t\\t\\t\\t // close -> number of close brackets\\n        vector<string> res;\\n        if(n==0) return res;\\n        string temp=\"\";\\n        util(res,open,close,temp,n);\\n        return res;\\n    }\\n};\\n```\n```O(2^(2n))```\n```\\nvector<string> generateParenthesis(int n) {\\n        vector<vector<string>> dp(n+1); // cache to store all generated strings\\n        dp[0] = {\"\"}; \\n        for(int i=1;i<=n;i++){\\n            for(int j=0;j<i;j++){\\n                vector<string> left = dp[j];\\n                vector<string> right = dp[i-j-1];\\n                for(int k=0;k<left.size();k++){\\n                    for(int l=0;l<right.size();l++){\\n                        dp[i].push_back(\"(\" + left[k] + \")\" + right[l]);\\n                    }\\n                }\\n            }\\n        }\\n        return dp[n];\\n    }\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1276579,
                "title": "short-easy-solution-w-explanation-beats-100",
                "content": "\\u2714\\uFE0F ***Solution - I (Brute - Force)***\\n\\nWe have `n` pair of parenthesis which means we are required to form a valid parenthesis string of `length == 2*n`. Let\\'s start with the brute-force way. At each position of the string, we can insert **`(`** or **`)`** brackets and so we will try both the options. Atlast, when the length of string becomes `2*n`, we will perform a check and insert into `ans` array if it is valid.\\n\\n```\\nvector<string> ans;\\nvector<string> generateParenthesis(int n) {\\n\\tsolve(\"\", 2*n);\\n\\treturn ans;\\n}\\nvoid solve(string s, int N){\\n\\tif(size(s) == N){\\n\\t\\tif(valid(s)) ans.push_back(s);\\n\\t\\treturn;\\n\\t}\\n\\tsolve(s + \\'(\\', N);\\n\\tsolve(s + \\')\\', N);\\n}\\nbool valid(string& s, int diff = 0) {\\n\\tfor(auto& ch: s) {\\n\\t\\tdiff += (ch == \\'(\\' ? 1 : -1);\\n\\t\\tif(diff < 0) return false;\\n\\t}\\n\\treturn !diff;\\n}\\n```\\n\\n***Time Complexity :*** **<code>O(4<sup>n</sup> * n)</code>**, for each index in string, we try both the parenthesis which is <code>2`*`2`*`2...2n times = O(2<sup>2n</sup>) = O(4<sup>n</sup>) </code> and lastly, we spend an `O(n)` time to check for the formed string\\'s validity. \\n**Space Complexity :** **<code>O(4<sup>n</sup>)</code>** (A tighter bound exists)\\n\\n---\\n\\n\\u2714\\uFE0F ***Solution - II (Optimized Approach)***\\n\\nInstead of trying out both the brackets at each index of the string, we only try them at places which won\\'t outright invalidate the string. For eg. In the previous approach, we were trying to insert `)` even at the start which would surely not have generated a valid parenthesis. Here, we avoid that. We have 2 cases:\\n\\n* **`(`** can be inserted anywhere till its count is less than `n`\\n* **`)`** can be inserted whenever its count is less than `start` (number of openinig parenthesis)\\n\\nFinally, we will insert the string when its length reaches `2*n`.\\n\\n```\\nvector<string> generateParenthesis(int n) {\\n\\tvector<string> ans;\\n\\tsolve(0, 0, n, \"\", ans);\\n\\treturn ans;\\n}\\nvoid solve(int start, int close, int n, string s, vector<string>& ans) {\\n\\tif(size(s) == 2*n) ans.push_back(move(s));  // use move to directly push the constructed string into vector instead of creating a copy\\n\\tif(start < n) solve(start + 1, close, n, s + \\'(\\', ans);\\n\\tif(close < start) solve(start, close + 1, n, s + \\')\\', ans);\\n}\\n```\\n\\n***Time Complexity :*** **<code>O(4<sup>n</sup>)</code>** Here we save the time for string validation at the end and also avoid the extra recursive calls which we know are invalid anyway. \\n**Note**: There exists a tighter bound - <code>O(4<sup>n</sup> / &radic;n)</code>  but without deep analysis of the recursion structure, it\\'s very hard to arrive at it. So, <code>O(4<sup>n</sup>)</code> is good enough for quick estimations\\n**Space Complexity :** **<code>O(4<sup>n</sup>)</code>**, Tighter bound - **<code>O(4<sup>n</sup> / &radic;n)</code>**\\n\\n---\\n\\n*Best Runtime -*\\n\\n<table><tr><td><img src=https://assets.leetcode.com/users/images/001e3d19-b69f-4c1b-96c9-f760343aef54_1623844459.7738905.png  /></td></tr></table>\\n\\n\\n\\n---\\n---\\n\\n\\uD83D\\uDCBB\\uD83D\\uDC31\\u200D\\uD83D\\uDCBBIf there are any suggestions / questions / mistakes in my post, please do comment below \\uD83D\\uDC47 \\n\\n---\\n",
                "solutionTags": [
                    "C",
                    "Backtracking",
                    "Recursion"
                ],
                "code": "```\\nvector<string> ans;\\nvector<string> generateParenthesis(int n) {\\n\\tsolve(\"\", 2*n);\\n\\treturn ans;\\n}\\nvoid solve(string s, int N){\\n\\tif(size(s) == N){\\n\\t\\tif(valid(s)) ans.push_back(s);\\n\\t\\treturn;\\n\\t}\\n\\tsolve(s + \\'(\\', N);\\n\\tsolve(s + \\')\\', N);\\n}\\nbool valid(string& s, int diff = 0) {\\n\\tfor(auto& ch: s) {\\n\\t\\tdiff += (ch == \\'(\\' ? 1 : -1);\\n\\t\\tif(diff < 0) return false;\\n\\t}\\n\\treturn !diff;\\n}\\n```\n```\\nvector<string> generateParenthesis(int n) {\\n\\tvector<string> ans;\\n\\tsolve(0, 0, n, \"\", ans);\\n\\treturn ans;\\n}\\nvoid solve(int start, int close, int n, string s, vector<string>& ans) {\\n\\tif(size(s) == 2*n) ans.push_back(move(s));  // use move to directly push the constructed string into vector instead of creating a copy\\n\\tif(start < n) solve(start + 1, close, n, s + \\'(\\', ans);\\n\\tif(close < start) solve(start, close + 1, n, s + \\')\\', ans);\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3909785,
                "title": "beats-100-this-is-how-you-explain-it-to-your-interviewer",
                "content": "UPVOTE IT TO KEEP IT AT THE TOP!\\n\\n# Intuition\\nThis code aims to generate all valid combinations of balanced parentheses pairs given a positive integer n. The goal is to produce all possible strings of length 2*n, where each character is either \\'(\\' or \\')\\', and the resulting strings are valid parentheses expressions.\\n\\n# Approach\\nThe code uses a recursive approach to generate these combinations. The solve function is called recursively to build the strings while maintaining the count of open and closed parentheses. Here\\'s how it works:\\n\\nThe base case is when the index ind reaches or exceeds n * 2. At this point, the constructed string op is a valid combination of parentheses, so it\\'s added to the result vector ans.\\n\\nIf the count of open parentheses cnt1 is less than n and the current index ind is less than n * 2 - 1, a \\'(\\' character is added to the string op, and the solve function is called recursively with cnt1 incremented by 1 and the index increased by 1.\\n\\nIf the count of closed parentheses cnt2 is less than cnt1 and the current index ind is greater than 0, a \\')\\' character is added to the string op, and the solve function is called recursively with cnt2 incremented by 1 and the index increased by 1.\\n\\nAfter each recursive call, the last character is removed from the string op using op.pop_back() to backtrack and explore different combinations.\\n\\nThe generateParenthesis function initializes the result vector ans and calls the solve function with initial counts and index.\\n\\n# Complexity\\n- Time complexity: O(4^n / sqrt(n))\\nTime complexity: The recursive approach explores all possible combinations, and the total number of valid combinations is bounded by the nth Catalan number, which grows exponentially with n. Thus, the time complexity is exponential, approximately O(4^n / sqrt(n)).\\n\\n- Space complexity:  O(n)\\nSpace complexity: The space complexity is determined by the maximum recursion depth, which is proportional to n. Additionally, the space used by the string op in each recursive call contributes to the space complexity. Therefore, the space complexity is O(n) due to the recursion depth.\\n\\n\\n![5d0bae9a5411b.jpeg](https://assets.leetcode.com/users/images/7a8eeaa3-6860-49ad-a76b-c322ca710c63_1692032658.6172345.jpeg)\\n\\n\\n# Code\\n```\\nclass Solution {\\n    private:\\n    void solve(int cnt1,int cnt2,int n,vector<string> &ans,string &op,int ind)\\n    {\\n        if(ind>=n*2)\\n        {\\n            ans.push_back(op);\\n            return;}\\n        if(cnt1<n and ind<n*2-1)\\n        {\\n            op+=\\'(\\';\\n            solve(cnt1+1,cnt2,n,ans,op,ind+1);\\n            op.pop_back();\\n        }\\n        \\n        if(cnt2<cnt1 and ind>0)\\n        {\\n            op+=\\')\\';\\n \\n            solve(cnt1,cnt2+1,n,ans,op,ind+1);\\n            op.pop_back();\\n        }\\n        \\n    }\\npublic:\\n    vector<string> generateParenthesis(int n) {\\n         string op=\"\";\\n        vector<string> ans;\\n        solve(0,0,n,ans,op,0);\\n        return ans;\\n    }\\n};\\n\\n\\n\\n\\n",
                "solutionTags": [
                    "C++",
                    "Backtracking",
                    "Recursion"
                ],
                "code": "class Solution {\\n    private:\\n    void solve(int cnt1,int cnt2,int n,vector<string> &ans,string &op,int ind)\\n    {\\n        if(ind>=n*2)\\n        {\\n            ans.push_back(op);\\n            return;}",
                "codeTag": "Java"
            },
            {
                "id": 10337,
                "title": "my-accepted-java-solution",
                "content": "For 2, it should place one \"()\" and add another one insert it but none tail it,\\n\\n'(' f(1) ')' f(0)\\n\\nor add none insert it but tail it by another one,\\n\\n'(' f(0) ')' f(1)\\n\\nThus for n,  we can insert f(i) and tail f(j) and i+j=n-1,\\n\\n'(' f(i) ')' f(j)              \\n\\n\\n\\n\\tpublic List<String> generateParenthesis(int n) {\\n\\t\\tList<String> result = new ArrayList<String>();\\n\\t\\tif (n == 0) {\\n\\t\\t\\tresult.add(\"\");\\n\\t\\t} else {\\n\\t\\t\\tfor (int i = n - 1; i >= 0; i--) {\\n\\t\\t\\t\\tList<String> insertSub = generateParenthesis(i);\\n\\t\\t\\t\\tList<String> tailSub = generateParenthesis(n - 1 - i);\\n\\t\\t\\t\\tfor (String insert : insertSub) {\\n\\t\\t\\t\\t\\tfor (String tail : tailSub) {\\n\\t\\t\\t\\t\\t\\tresult.add(\"(\" + insert + \")\" + tail);\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t}\\n\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\treturn result;\\n\\t}",
                "solutionTags": [
                    "Java"
                ],
                "code": "For 2, it should place one \"()\" and add another one insert it but none tail it,\\n\\n'(' f(1) ')' f(0)\\n\\nor add none insert it but tail it by another one,\\n\\n'(' f(0) ')' f(1)\\n\\nThus for n,  we can insert f(i) and tail f(j) and i+j=n-1,\\n\\n'(' f(i) ')' f(j)              \\n\\n\\n\\n\\tpublic List<String> generateParenthesis(int n) {\\n\\t\\tList<String> result = new ArrayList<String>();\\n\\t\\tif (n == 0) {\\n\\t\\t\\tresult.add(\"\");\\n\\t\\t} else {\\n\\t\\t\\tfor (int i = n - 1; i >= 0; i--) {\\n\\t\\t\\t\\tList<String> insertSub = generateParenthesis(i);\\n\\t\\t\\t\\tList<String> tailSub = generateParenthesis(n - 1 - i);\\n\\t\\t\\t\\tfor (String insert : insertSub) {\\n\\t\\t\\t\\t\\tfor (String tail : tailSub) {\\n\\t\\t\\t\\t\\t\\tresult.add(\"(\" + insert + \")\" + tail);\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t}\\n\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\treturn result;\\n\\t}",
                "codeTag": "Unknown"
            },
            {
                "id": 313945,
                "title": "recursion-with-backtracking",
                "content": "The key to this problem is writing a recursive function that operates in a manner similar to how we would generate all valid pairs by hand.\\n\\nAt every step of the way, we choose to add either an open bracket or a close bracket. This can easily be implemented as part of the recursive call. The trick is to also implement the restraint, namely \\'dont add a close bracket if there isnt already an open bracket\\'. AKA: only add if right > left. The restraint for adding open brackets is simple, add one if there are still open brackets to be added.\\n\\nFollowing this logic allows us to only generate valid strings, and we are done generating a particular string when we dont have any more brackets left ot add.\\n\\nParameters:\\n\\t(int) left:       set to n, keep track of open brackets that need to be added\\n\\t(int) right:     set to n, keep track of close brackets that need to be add\\n\\t(str) curr:     set to \"\", used to store the current version of the string\\n\\t(dict()) res:  hold all valid strings, is returned by the function\\n```\\nclass Solution(object):\\n    def generateParenthesis(self, n):\\n        \\n\\t\\tdef paren(left, right, curr, res):\\n\\t\\t\\t# \\'evaluate current string\\n\\t\\t\\t# if we are out of brackets to add, we must be at a valid string\\n\\t\\t\\tif left == 0 and right == 0:\\n\\t\\t\\t\\tres.append(curr)\\n\\t\\t\\t\\treturn\\n\\n\\t\\t\\t# recursive call: add either open or close\\n\\t\\t\\t# if adding open bracket is valid\\n\\t\\t\\tif left > 0:\\n\\t\\t\\t\\t# add open bracket, decr count\\n\\t\\t\\t\\tparen(left-1, right, curr + \"(\", res)\\n\\n\\t\\t\\t# if adding close bracket is valid\\n\\t\\t\\tif right > left:\\n\\t\\t\\t\\t# add close bracket, decr count\\n\\t\\t\\t\\tparen(left, right-1, curr + \")\", res)\\n\\n\\t\\t\\treturn res\\n\\t\\t# end paren()\\n\\n\\t\\tres = paren(n, n, \\'\\', [])\\n\\n\\t\\treturn res\\n```",
                "solutionTags": [
                    "Python",
                    "Recursion"
                ],
                "code": "```\\nclass Solution(object):\\n    def generateParenthesis(self, n):\\n        \\n\\t\\tdef paren(left, right, curr, res):\\n\\t\\t\\t# \\'evaluate current string\\n\\t\\t\\t# if we are out of brackets to add, we must be at a valid string\\n\\t\\t\\tif left == 0 and right == 0:\\n\\t\\t\\t\\tres.append(curr)\\n\\t\\t\\t\\treturn\\n\\n\\t\\t\\t# recursive call: add either open or close\\n\\t\\t\\t# if adding open bracket is valid\\n\\t\\t\\tif left > 0:\\n\\t\\t\\t\\t# add open bracket, decr count\\n\\t\\t\\t\\tparen(left-1, right, curr + \"(\", res)\\n\\n\\t\\t\\t# if adding close bracket is valid\\n\\t\\t\\tif right > left:\\n\\t\\t\\t\\t# add close bracket, decr count\\n\\t\\t\\t\\tparen(left, right-1, curr + \")\", res)\\n\\n\\t\\t\\treturn res\\n\\t\\t# end paren()\\n\\n\\t\\tres = paren(n, n, \\'\\', [])\\n\\n\\t\\treturn res\\n```",
                "codeTag": "Java"
            },
            {
                "id": 10299,
                "title": "c-recursive-iterative",
                "content": "**Recursive (backtracking)**\\n\\nWe use `l` and `r` to denote the number of `(`s and `)`s. If `l < n`, we can add a `(`. If `r < l`, we can add a `)`.\\n\\n```cpp\\nclass Solution {\\npublic:\\n    vector<string> generateParenthesis(int n) {\\n        vector<string> parens;\\n        string paren;\\n        generate(n, 0, 0, paren, parens);\\n        return parens;\\n    }\\nprivate:\\n    void generate(int n, int l, int r, string paren, vector<string>& parens) {\\n        if (l == n && r == n) {\\n            parens.push_back(paren);\\n        } else {\\n            if (l < n) {\\n                generate(n, l + 1, r, paren + \\'(\\', parens);\\n            }\\n            if (r < l) {\\n                generate(n, l, r + 1, paren + \\')\\', parens);\\n            }\\n        }\\n    }\\n};\\n```\\n\\n**Iterative**\\n\\nThis idea is taken from the official solution.\\n\\n```cpp\\nclass Solution {\\npublic:\\n    vector<string> generateParenthesis(int n) {\\n        if (!n) {\\n            return {\"\"};\\n        }\\n        vector<string> parens;\\n        for (int i = 0; i < n; i++) {\\n            for (string l : generateParenthesis(i)) {\\n                for (string r : generateParenthesis(n - 1 - i)) {\\n                    parens.push_back(\\'(\\' + l + \\')\\' + r);\\n                }\\n            }\\n        }\\n        return parens;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Backtracking",
                    "Recursion",
                    "Iterator"
                ],
                "code": "```cpp\\nclass Solution {\\npublic:\\n    vector<string> generateParenthesis(int n) {\\n        vector<string> parens;\\n        string paren;\\n        generate(n, 0, 0, paren, parens);\\n        return parens;\\n    }\\nprivate:\\n    void generate(int n, int l, int r, string paren, vector<string>& parens) {\\n        if (l == n && r == n) {\\n            parens.push_back(paren);\\n        } else {\\n            if (l < n) {\\n                generate(n, l + 1, r, paren + \\'(\\', parens);\\n            }\\n            if (r < l) {\\n                generate(n, l, r + 1, paren + \\')\\', parens);\\n            }\\n        }\\n    }\\n};\\n```\n```cpp\\nclass Solution {\\npublic:\\n    vector<string> generateParenthesis(int n) {\\n        if (!n) {\\n            return {\"\"};\\n        }\\n        vector<string> parens;\\n        for (int i = 0; i < n; i++) {\\n            for (string l : generateParenthesis(i)) {\\n                for (string r : generateParenthesis(n - 1 - i)) {\\n                    parens.push_back(\\'(\\' + l + \\')\\' + r);\\n                }\\n            }\\n        }\\n        return parens;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2936271,
                "title": "simple-java-sol",
                "content": "\\n```\\nclass Solution {\\n    public List<String> generateParenthesis(int n) {\\n        List<String> res = new ArrayList();\\n        findAll(\"(\",1,0,res,n);\\n\\n        return res;\\n    }\\n\\n    void findAll(String current,int op , int cl , List<String> res, int n){\\n        if(current.length()==2*n){\\n            res.add(current);\\n            return;\\n        }\\n        if(op<n)\\n        findAll(current+\"(\", op+1,cl,res,n);\\n        if(cl<op)\\n        findAll(current+\")\",op,cl+1,res,n);\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public List<String> generateParenthesis(int n) {\\n        List<String> res = new ArrayList();\\n        findAll(\"(\",1,0,res,n);\\n\\n        return res;\\n    }\\n\\n    void findAll(String current,int op , int cl , List<String> res, int n){\\n        if(current.length()==2*n){\\n            res.add(current);\\n            return;\\n        }\\n        if(op<n)\\n        findAll(current+\"(\", op+1,cl,res,n);\\n        if(cl<op)\\n        findAll(current+\")\",op,cl+1,res,n);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1370756,
                "title": "accepted-c-whiteboard-recursion-tree-easy-please-upvote",
                "content": "**Whiteboard Recursion Tree**\\nHere n = 3\\n* Star marks the string to be pushed in ans vector\\n* When open < close, only then we go further\\n* If open == 0 stop there, as opening parenthesis are exhausted\\n* If open < close, it means some of open are used so only now we can close\\n* If open == close == 0 then no more parenthesis left so add the string to ans vector and return\\n\\n![image](https://assets.leetcode.com/users/images/c33fedf4-ccdd-4ae6-a830-2c18943d1cb4_1627579698.6112955.jpeg)\\n\\nPardon my drawing \\uD83D\\uDE02\\uD83D\\uDE02\\nSuggestions are welcomed. \\n\\n**Code**\\n```\\nclass Solution {\\npublic:\\n    vector<string>ans;\\n    vector<string>generateParenthesis(int n) {\\n        f(\"\",n,n);\\n        return ans;\\n    }\\n    void f(string s, int open, int close){\\n        if(open==0 && close==0){\\n            ans.push_back(s);\\n            return;\\n        }\\n        if(open>0)f(s+\"(\",open-1,close);\\n        if(open<close)f(s+\")\",open,close-1);\\n    }\\n};\\n\\n```",
                "solutionTags": [
                    "C",
                    "Recursion"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<string>ans;\\n    vector<string>generateParenthesis(int n) {\\n        f(\"\",n,n);\\n        return ans;\\n    }\\n    void f(string s, int open, int close){\\n        if(open==0 && close==0){\\n            ans.push_back(s);\\n            return;\\n        }\\n        if(open>0)f(s+\"(\",open-1,close);\\n        if(open<close)f(s+\")\",open,close-1);\\n    }\\n};\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 10400,
                "title": "6-lines-c-3-4-ms-super-easy-to-understand",
                "content": "    vector<string> result;\\n    \\n    void helper(string str, int left, int right){\\n        if(left == 0 && right == 0)  result.push_back(str);\\n        if(left!=0)                  helper(str+'(', left-1, right);\\n        if(right!=0 && right > left) helper(str+')', left, right-1);\\n    }    \\n    \\n    vector<string> generateParenthesis(int n) {\\n        helper(\"\",n,n);\\n        return result;\\n    }",
                "solutionTags": [],
                "code": "    vector<string> result;\\n    \\n    void helper(string str, int left, int right){\\n        if(left == 0 && right == 0)  result.push_back(str);\\n        if(left!=0)                  helper(str+'(', left-1, right);\\n        if(right!=0 && right > left) helper(str+')', left, right-1);\\n    }    \\n    \\n    vector<string> generateParenthesis(int n) {\\n        helper(\"\",n,n);\\n        return result;\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 1276049,
                "title": "python-recursive-solution-with-dp-explained",
                "content": "For each valid parentheses there smallest `k`, for which the first `k` symbols compose well-formed parentheses: `(left)right`. Let us `ans[i]` be all valid parentheses of length `i`. Then we can generate them using recursion. For every `k in range(n+1)` and for every `i in range(k)` we choose left part and right part and append it to final answer. Because we memorize our intermediate results, we can also say that we use dp approach here.\\n\\n#### Complexity\\nTime complexity is `O(C_n * n) = O(4^n/n^0.5)`, where `C_n` is Catalan number. Space complexity is the same.\\n\\n#### Code\\n```python\\nclass Solution:\\n    def generateParenthesis(self, n):\\n        ans = [[] for _ in range(n+1)]\\n        ans[0] = [\"\"]\\n        for k in range(n + 1):\\n            for i in range(k):\\n                for left in ans[i]:\\n                    for right in ans[k-i-1]:\\n                        ans[k].append(\"(\" + left + \")\" + right)\\n        \\n        return ans[-1]\\n```\\n\\nIf you have any question, feel free to ask. If you like the explanations, please **Upvote!**",
                "solutionTags": [
                    "Dynamic Programming",
                    "Recursion"
                ],
                "code": "```python\\nclass Solution:\\n    def generateParenthesis(self, n):\\n        ans = [[] for _ in range(n+1)]\\n        ans[0] = [\"\"]\\n        for k in range(n + 1):\\n            for i in range(k):\\n                for left in ans[i]:\\n                    for right in ans[k-i-1]:\\n                        ans[k].append(\"(\" + left + \")\" + right)\\n        \\n        return ans[-1]\\n```",
                "codeTag": "Java"
            },
            {
                "id": 10136,
                "title": "easy-java-solution",
                "content": "    public class Solution {\\n    private void helper(List<String> res, String present, int left, int right) {\\n        if (right == 0) {\\n            res.add(present);\\n        }\\n        if (left > 0) {\\n            helper(res, present + \"(\", left - 1, right);\\n        }\\n        if (right > left) {\\n            helper(res, present + \")\", left, right - 1);\\n        }\\n    }\\n    public List<String> generateParenthesis(int n) {\\n        List<String> res = new ArrayList<String>();\\n        if (n == 0) {\\n            return res;\\n        }\\n        helper(res, \"\", n, n);\\n        return res;\\n    }\\n}",
                "solutionTags": [
                    "Java"
                ],
                "code": "class Solution {\\n    private void helper(List<String> res, String present, int left, int right) {\\n        if (right == 0) {\\n            res.add(present);\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 3211825,
                "title": "best-c-2-solution-ever-easy-solution-backtracking-one-stop-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nWe can solve this problem using Array + Backtracking.\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nWe can easily understand the all the approaches by seeing the code which is easy to understand with comments.\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nTime complexity is given in code comment.\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nSpace complexity is given in code comment.\\n\\n# Code\\n```\\n/*\\n\\n    Time Complexity : O((2^2*N)*N). For each of 2^2*N sequences, we need to create and validate the sequence,\\n    which takes O(N) work.\\n\\n    Space Complexity : O((2^2*N)*N) vector(output) space.\\n\\n    Solved using Array + Backtracking. Brute Force Approach.\\n\\n*/\\n\\n\\n/***************************************** Approach 1 *****************************************/\\n\\nclass Solution {\\nprivate:\\n    bool valid(vector<char> temp){\\n        int balance = 0;\\n        for(auto c : temp){\\n            if(c == \\'(\\') balance++;\\n            else balance--;\\n            if(balance < 0) return false;\\n        }\\n        return balance == 0;\\n    }\\n    void generateAllParenthesis(vector<string>& parenthesesCombinations, vector<char> temp, int position){\\n        if(position == temp.size()){\\n            if(valid(temp)){\\n                string s(temp.begin(), temp.end());\\n                parenthesesCombinations.push_back(s);\\n            }\\n            return;\\n        }\\n        temp[position] = \\'(\\';\\n        generateAllParenthesis(parenthesesCombinations, temp, position+1);\\n        temp[position] = \\')\\';\\n        generateAllParenthesis(parenthesesCombinations, temp, position+1); \\n    }\\npublic:\\n    vector<string> generateParenthesis(int n) {\\n        vector<string> parenthesesCombinations;\\n        vector<char> temp(2*n);\\n        generateAllParenthesis(parenthesesCombinations, temp, 0);\\n        return parenthesesCombinations;\\n    }\\n};\\n\\n\\n\\n\\n\\n\\n/*\\n\\n    Time Complexity : O(O(2^2*N)The time complexity of the above code is O(2^(2N)) since in the worst case we\\n    need to consider every possibility of opening and closing brackets where N = the number of pairs we need to\\n    form.\\n\\n    Space Complexity : O((2^2*N)*N) vector(output) space.\\n\\n    Solved using Array + Backtracking. Brute Force Approach.\\n\\n*/\\n\\n/***************************************** Approach 2 *****************************************/\\n\\nclass Solution {\\nprivate:\\n    void recurse(vector<string>& output, string s, int open, int close, int n){\\n        if(open==n and close==n){\\n            output.push_back(s);\\n            return;\\n        }\\n        if(open<n)\\n            recurse(output, s+\"(\" , open+1, close, n);\\n        if(close<open)\\n            recurse(output, s+\")\", open, close+1, n);\\n    }\\npublic:\\n    vector<string> generateParenthesis(int n) {\\n        vector<string> output;\\n        recurse(output, \"\", 0, 0, n);\\n        return output;\\n    }\\n};\\n\\n```\\n\\n***IF YOU LIKE THE SOLUTION THEN PLEASE UPVOTE MY SOLUTION BECAUSE IT GIVES ME MOTIVATION TO REGULARLY POST THE SOLUTION.***\\n\\n![WhatsApp Image 2023-02-10 at 19.01.02.jpeg](https://assets.leetcode.com/users/images/0a95fea4-64f4-4502-82aa-41db6d77c05c_1676054939.8270252.jpeg)",
                "solutionTags": [
                    "C++",
                    "Array",
                    "Backtracking"
                ],
                "code": "```\\n/*\\n\\n    Time Complexity : O((2^2*N)*N). For each of 2^2*N sequences, we need to create and validate the sequence,\\n    which takes O(N) work.\\n\\n    Space Complexity : O((2^2*N)*N) vector(output) space.\\n\\n    Solved using Array + Backtracking. Brute Force Approach.\\n\\n*/\\n\\n\\n/***************************************** Approach 1 *****************************************/\\n\\nclass Solution {\\nprivate:\\n    bool valid(vector<char> temp){\\n        int balance = 0;\\n        for(auto c : temp){\\n            if(c == \\'(\\') balance++;\\n            else balance--;\\n            if(balance < 0) return false;\\n        }\\n        return balance == 0;\\n    }\\n    void generateAllParenthesis(vector<string>& parenthesesCombinations, vector<char> temp, int position){\\n        if(position == temp.size()){\\n            if(valid(temp)){\\n                string s(temp.begin(), temp.end());\\n                parenthesesCombinations.push_back(s);\\n            }\\n            return;\\n        }\\n        temp[position] = \\'(\\';\\n        generateAllParenthesis(parenthesesCombinations, temp, position+1);\\n        temp[position] = \\')\\';\\n        generateAllParenthesis(parenthesesCombinations, temp, position+1); \\n    }\\npublic:\\n    vector<string> generateParenthesis(int n) {\\n        vector<string> parenthesesCombinations;\\n        vector<char> temp(2*n);\\n        generateAllParenthesis(parenthesesCombinations, temp, 0);\\n        return parenthesesCombinations;\\n    }\\n};\\n\\n\\n\\n\\n\\n\\n/*\\n\\n    Time Complexity : O(O(2^2*N)The time complexity of the above code is O(2^(2N)) since in the worst case we\\n    need to consider every possibility of opening and closing brackets where N = the number of pairs we need to\\n    form.\\n\\n    Space Complexity : O((2^2*N)*N) vector(output) space.\\n\\n    Solved using Array + Backtracking. Brute Force Approach.\\n\\n*/\\n\\n/***************************************** Approach 2 *****************************************/\\n\\nclass Solution {\\nprivate:\\n    void recurse(vector<string>& output, string s, int open, int close, int n){\\n        if(open==n and close==n){\\n            output.push_back(s);\\n            return;\\n        }\\n        if(open<n)\\n            recurse(output, s+\"(\" , open+1, close, n);\\n        if(close<open)\\n            recurse(output, s+\")\", open, close+1, n);\\n    }\\npublic:\\n    vector<string> generateParenthesis(int n) {\\n        vector<string> output;\\n        recurse(output, \"\", 0, 0, n);\\n        return output;\\n    }\\n};\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 193155,
                "title": "python3-dp-solution-with-explanation-36-ms-beat-99-96",
                "content": "It\\'s intuitive to find the common subproblems, so dp is a natural choice.\\n\\ntwo base cases: \\nif n = 1, result = [\\'()\\']\\nif n = 2, result = [\\'(())\\', \\'()()\\']\\n\\nif n = 3, result = [\\n  \"((()))\",  # pattern: result of dp[2] is around by an outer \\'()\\'\\n  \"(()())\",  # the same pattern as above\\n  \"(())()\",  # pattern: result of dp[2] + result of dp[1]\\n  \"()(())\",  # the same pattern as above with another permutation order: dp[1] + dp[2]\\n  \"()()()\"  #  the same pattern as above\\n]\\n\\nwe can found the same recursive patterns for n > 3:\\n**pattern 1**: candidates = \\'(\\' + x + \\')\\' , where x is element of dp[n-1]\\n**pattern 2**: candidates = [x + y] , where x is element of dp[i] and y is element of dp[n-i] (the range of i is [0 : n])\\n\\n\\n```\\nclass Solution:\\n    def generateParenthesis(self, n):\\n        \"\"\"\\n        :type n: int\\n        :rtype: List[str]\\n        \"\"\"\\n                \\n        # 1 and 2 is base cases (set is used to deduplicate candidates)\\n        dp = {1: set([\\'()\\']), 2: set([\\'(())\\', \\'()()\\'])}\\n        for i in range(3, n+1):\\n            # pattern 1: outer parenthese + subproblem with length - 1\\n            dp[i] = set([\\'(\\' + x + \\')\\' for x in dp[i-1]])\\n            for j in range(1, i):\\n                # pattern 2: dp[i] is formed by dp[j] + dp[i-j]\\n                dp[i] = dp[i].union([x + y for x in dp[j] for y in dp[i-j]])\\n        return list(dp[n])\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def generateParenthesis(self, n):\\n        \"\"\"\\n        :type n: int\\n        :rtype: List[str]\\n        \"\"\"\\n                \\n        # 1 and 2 is base cases (set is used to deduplicate candidates)\\n        dp = {1: set([\\'()\\']), 2: set([\\'(())\\', \\'()()\\'])}\\n        for i in range(3, n+1):\\n            # pattern 1: outer parenthese + subproblem with length - 1\\n            dp[i] = set([\\'(\\' + x + \\')\\' for x in dp[i-1]])\\n            for j in range(1, i):\\n                # pattern 2: dp[i] is formed by dp[j] + dp[i-j]\\n                dp[i] = dp[i].union([x + y for x in dp[j] for y in dp[i-j]])\\n        return list(dp[n])\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1656798,
                "title": "solution-swift-generate-parentheses-test-cases",
                "content": "```swift\\nclass Solution {\\n    func generateParenthesis(_ n: Int) -> [String] {\\n        guard n > 0 else { return [\"\"] }\\n        \\n        var map: [Int:[String]] = [:], result: [String] = []\\n        if let parentheses = map[n] { return parentheses }\\n        \\n        for i in 0..<n {\\n            for l in generateParenthesis(i) {\\n                for r in generateParenthesis(n - 1 - i) {\\n                    result.append(\"(\" + l + \")\" + r)\\n                }\\n            }\\n        }\\n        return result\\n    }\\n}\\n```\\n\\n---\\n\\n<details>\\n<summary>\\n<img src=\"https://git.io/JDblm\" height=\"24\">\\n<b>TEST CASES</b>\\n</summary>\\n\\n<p><pre>\\n<b>Result:</b> Executed 2 tests, with 0 failures (0 unexpected) in 0.009 (0.011) seconds\\n</pre></p>\\n\\n```swift\\nimport XCTest\\n\\nclass Tests: XCTestCase {\\n    \\n    private let solution = Solution()\\n    \\n    func test0() {\\n        let value = solution.generateParenthesis(3)\\n        XCTAssertEqual(value, [\"()()()\",\"()(())\",\"(())()\",\"(()())\",\"((()))\"])\\n    }\\n    \\n    func test1() {\\n        let value = solution.generateParenthesis(1)\\n        XCTAssertEqual(value, [\"()\"])\\n    }\\n}\\n\\nTests.defaultTestSuite.run()\\n```\\n</details>",
                "solutionTags": [
                    "Swift"
                ],
                "code": "```swift\\nclass Solution {\\n    func generateParenthesis(_ n: Int) -> [String] {\\n        guard n > 0 else { return [\"\"] }\\n        \\n        var map: [Int:[String]] = [:], result: [String] = []\\n        if let parentheses = map[n] { return parentheses }\\n        \\n        for i in 0..<n {\\n            for l in generateParenthesis(i) {\\n                for r in generateParenthesis(n - 1 - i) {\\n                    result.append(\"(\" + l + \")\" + r)\\n                }\\n            }\\n        }\\n        return result\\n    }\\n}\\n```\n```swift\\nimport XCTest\\n\\nclass Tests: XCTestCase {\\n    \\n    private let solution = Solution()\\n    \\n    func test0() {\\n        let value = solution.generateParenthesis(3)\\n        XCTAssertEqual(value, [\"()()()\",\"()(())\",\"(())()\",\"(()())\",\"((()))\"])\\n    }\\n    \\n    func test1() {\\n        let value = solution.generateParenthesis(1)\\n        XCTAssertEqual(value, [\"()\"])\\n    }\\n}\\n\\nTests.defaultTestSuite.run()\\n```",
                "codeTag": "Java"
            },
            {
                "id": 617936,
                "title": "intuitive-javascript-solution-with-bracktracking",
                "content": "```\\n/**\\n * @param {number} n\\n * @return {string[]}\\n */\\nvar generateParenthesis = function(n) {\\n  const output = [];\\n  /**\\n   * Examples \\n   * n = 1\\n   *  ()\\n   *\\n   *  n = 2\\n   *  (())\\n   *  ()()\\n   *\\n   *  n = 3\\n   *  ((()))\\n   *  (()())\\n   *  (())()\\n   *  ()(())\\n   *  ()()()\\n   */\\n  const dfs = (str, open, close) => {\\n    // Close parentheses can not be more than open parentheses at any \\n    // given time to stay valid.\\n    if (open > close) {\\n      return;\\n    }\\n    // Base case. We now have n pairs of parentheses\\n    if (open === 0 && close === 0) {\\n      output.push(str);\\n      return;\\n    }\\n    // Insert open parenthsis and search for the next valid insertion.\\n    if (open > 0) {\\n      dfs(`${str}(`, open - 1, close);\\n    }\\n    // Insert close parenthsis and search for the next valid insertion.\\n    if (close > 0) {\\n      dfs(`${str})`, open, close - 1);\\n    }\\n  };\\n  dfs(\\'\\', n, n);\\n  return output;\\n};\\n```",
                "solutionTags": [
                    "JavaScript",
                    "Backtracking",
                    "Depth-First Search",
                    "Recursion"
                ],
                "code": "```\\n/**\\n * @param {number} n\\n * @return {string[]}\\n */\\nvar generateParenthesis = function(n) {\\n  const output = [];\\n  /**\\n   * Examples \\n   * n = 1\\n   *  ()\\n   *\\n   *  n = 2\\n   *  (())\\n   *  ()()\\n   *\\n   *  n = 3\\n   *  ((()))\\n   *  (()())\\n   *  (())()\\n   *  ()(())\\n   *  ()()()\\n   */\\n  const dfs = (str, open, close) => {\\n    // Close parentheses can not be more than open parentheses at any \\n    // given time to stay valid.\\n    if (open > close) {\\n      return;\\n    }\\n    // Base case. We now have n pairs of parentheses\\n    if (open === 0 && close === 0) {\\n      output.push(str);\\n      return;\\n    }\\n    // Insert open parenthsis and search for the next valid insertion.\\n    if (open > 0) {\\n      dfs(`${str}(`, open - 1, close);\\n    }\\n    // Insert close parenthsis and search for the next valid insertion.\\n    if (close > 0) {\\n      dfs(`${str})`, open, close - 1);\\n    }\\n  };\\n  dfs(\\'\\', n, n);\\n  return output;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1338278,
                "title": "c-easy-to-understand-fast-and-efficient-recursion",
                "content": "**Please upvote to motivate me in my quest of documenting all leetcode solutions. HAPPY CODING:)\\nAny suggestions and improvements are always welcome**\\n```\\nclass Solution {\\npublic:\\n    vector<string> generateParenthesis(int n) {\\n        vector<string> ans;\\n        helper(ans,\"\",n,0);\\n        return ans;\\n    }\\n    void helper(vector<string> &v,string s,int n,int m)\\n    {\\n     if(n==0&&m==0)\\n     {\\n      v.push_back(s);\\n      return;\\n     }\\n      if(n>0)\\n      helper(v,s+\"(\",n-1,m+1);\\n      if(m>0)\\n       helper(v,s+\")\",n,m-1);   \\n    }\\n};",
                "solutionTags": [
                    "C",
                    "Recursion"
                ],
                "code": "class Solution {\\npublic:\\n    vector<string> generateParenthesis(int n) {\\n        vector<string> ans;\\n        helper(ans,\"\",n,0);\\n        return ans;\\n    }",
                "codeTag": "Java"
            },
            {
                "id": 10269,
                "title": "2ms-ac-java-solution-using-recursive-call",
                "content": "    public class Solution {\\n        public List<String> generateParenthesis(int n) {\\n            ArrayList<String> m=new ArrayList<>();\\n            generate(m, \"\", n, n);\\n            return m;\\n        }\\n        public void generate(ArrayList m, String s, int l, int r){\\n            if(l==0 && r==0){ \\n                m.add(s);\\n                return;\\n            }\\n            if(l>0) generate(m, s+\"(\",  l-1,  r);\\n            if(r>l) generate(m, s+\")\",  l,  r-1);\\n        }\\n        \\n        \\n    }",
                "solutionTags": [],
                "code": "class Solution {\\n        public List<String> generateParenthesis(int n) {\\n            ArrayList<String> m=new ArrayList<>();\\n            generate(m, \"\", n, n);\\n            return m;\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 3512769,
                "title": "c-java-python-javascript-using-recursion-with-explanation",
                "content": "# Intuition:\\nThe problem requires generating all possible combinations of well-formed parentheses of length 2n. To solve this, we can use a recursive approach. At each step, we have two choices: either add an opening parenthesis \"(\" or add a closing parenthesis \")\". However, we need to make sure that the number of opening parentheses is always greater than or equal to the number of closing parentheses, so that the parentheses remain well-formed.\\n\\n# Approach:\\n1. We define a helper function, `generateParentheses`, that takes the following parameters:\\n   - `result`: a reference to the vector of strings where we store the generated combinations.\\n   - `current`: the current combination being generated.\\n   - `open`: the count of opening parentheses \"(\" included in the current combination.\\n   - `close`: the count of closing parentheses \")\" included in the current combination.\\n   - `n`: the total number of pairs of parentheses to be included.\\n\\n2. In the `generateParentheses` function, we first check if the length of the `current` string is equal to 2n. If it is, we have generated a valid combination, so we add it to the `result` vector and return.\\n\\n3. If the length of `current` is not equal to 2n, we have two choices:\\n   - If the count of opening parentheses `open` is less than n, we can add an opening parenthesis to the current combination and make a recursive call to `generateParentheses`, incrementing the `open` count by 1.\\n   - If the count of closing parentheses `close` is less than the `open` count, we can add a closing parenthesis to the current combination and make a recursive call to `generateParentheses`, incrementing the `close` count by 1.\\n\\n4. In the `generateParenthesis` function, we initialize an empty `result` vector and call the `generateParentheses` function with the initial values of `current` as an empty string, `open` and `close` counts as 0, and `n` as the input value.\\n\\n5. Finally, we return the `result` vector containing all the generated combinations of well-formed parentheses.\\n\\n# Complexity:\\nThe time complexity of this solution is O(4^n / sqrt(n)), where n is the input number of pairs of parentheses.\\nThe space complexity of this solution is O(n). \\n\\n---\\n# C++\\n```\\nclass Solution {\\npublic:\\n    void generateParentheses(vector<string>& result, string current, int open, int close, int n) {\\n        if (current.size() == 2 * n) {\\n            result.push_back(current);\\n            return;\\n        }\\n        if (open < n) {\\n            generateParentheses(result, current + \\'(\\', open + 1, close, n);\\n        }\\n        if (close < open) {\\n            generateParentheses(result, current + \\')\\', open, close + 1, n);\\n        }\\n    }\\n    vector<string> generateParenthesis(int n) {\\n        vector<string> result;\\n        generateParentheses(result, \"\", 0, 0, n);\\n        return result;\\n    }\\n};\\n```\\n---\\n# JAVA\\n```\\nclass Solution {\\n    public List<String> generateParenthesis(int n) {\\n        List<String> result = new ArrayList<>();\\n        generateParentheses(result, \"\", 0, 0, n);\\n        return result;\\n    }\\n\\n    private void generateParentheses(List<String> result, String current, int open, int close, int n) {\\n        if (current.length() == 2 * n) {\\n            result.add(current);\\n            return;\\n        }\\n        if (open < n) {\\n            generateParentheses(result, current + \\'(\\', open + 1, close, n);\\n        }\\n        if (close < open) {\\n            generateParentheses(result, current + \\')\\', open, close + 1, n);\\n        }\\n    }\\n}\\n\\n```\\n\\n---\\n# Python\\n```\\nclass Solution(object):\\n    def generateParenthesis(self, n):\\n        result = []\\n        self.generateParentheses(result, \"\", 0, 0, n)\\n        return result\\n\\n    def generateParentheses(self, result, current, open, close, n):\\n        if len(current) == 2 * n:\\n            result.append(current)\\n            return\\n        if open < n:\\n            self.generateParentheses(result, current + \\'(\\', open + 1, close, n)\\n        if close < open:\\n            self.generateParentheses(result, current + \\')\\', open, close + 1, n)\\n\\n```\\n\\n---\\n# JavaScript\\n```\\nvar generateParenthesis = function(n) {\\n  const result = [];\\n  generateParentheses(result, \\'\\', 0, 0, n);\\n  return result;\\n};\\n\\nconst generateParentheses = (result, current, open, close, n) => {\\n  if (current.length === 2 * n) {\\n    result.push(current);\\n    return;\\n  }\\n  if (open < n) {\\n    generateParentheses(result, current + \\'(\\', open + 1, close, n);\\n  }\\n  if (close < open) {\\n    generateParentheses(result, current + \\')\\', open, close + 1, n);\\n  }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Java",
                    "Python",
                    "JavaScript",
                    "Recursion"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    void generateParentheses(vector<string>& result, string current, int open, int close, int n) {\\n        if (current.size() == 2 * n) {\\n            result.push_back(current);\\n            return;\\n        }\\n        if (open < n) {\\n            generateParentheses(result, current + \\'(\\', open + 1, close, n);\\n        }\\n        if (close < open) {\\n            generateParentheses(result, current + \\')\\', open, close + 1, n);\\n        }\\n    }\\n    vector<string> generateParenthesis(int n) {\\n        vector<string> result;\\n        generateParentheses(result, \"\", 0, 0, n);\\n        return result;\\n    }\\n};\\n```\n```\\nclass Solution {\\n    public List<String> generateParenthesis(int n) {\\n        List<String> result = new ArrayList<>();\\n        generateParentheses(result, \"\", 0, 0, n);\\n        return result;\\n    }\\n\\n    private void generateParentheses(List<String> result, String current, int open, int close, int n) {\\n        if (current.length() == 2 * n) {\\n            result.add(current);\\n            return;\\n        }\\n        if (open < n) {\\n            generateParentheses(result, current + \\'(\\', open + 1, close, n);\\n        }\\n        if (close < open) {\\n            generateParentheses(result, current + \\')\\', open, close + 1, n);\\n        }\\n    }\\n}\\n\\n```\n```\\nclass Solution(object):\\n    def generateParenthesis(self, n):\\n        result = []\\n        self.generateParentheses(result, \"\", 0, 0, n)\\n        return result\\n\\n    def generateParentheses(self, result, current, open, close, n):\\n        if len(current) == 2 * n:\\n            result.append(current)\\n            return\\n        if open < n:\\n            self.generateParentheses(result, current + \\'(\\', open + 1, close, n)\\n        if close < open:\\n            self.generateParentheses(result, current + \\')\\', open, close + 1, n)\\n\\n```\n```\\nvar generateParenthesis = function(n) {\\n  const result = [];\\n  generateParentheses(result, \\'\\', 0, 0, n);\\n  return result;\\n};\\n\\nconst generateParentheses = (result, current, open, close, n) => {\\n  if (current.length === 2 * n) {\\n    result.push(current);\\n    return;\\n  }\\n  if (open < n) {\\n    generateParentheses(result, current + \\'(\\', open + 1, close, n);\\n  }\\n  if (close < open) {\\n    generateParentheses(result, current + \\')\\', open, close + 1, n);\\n  }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3440974,
                "title": "easy-to-understand-concise-c",
                "content": "\\n# Code\\n```\\nclass Solution {\\npublic:\\n    void solve(string op, int open, int close, vector<string> &ans){\\n        if(open == 0 && close == 0){\\n            ans.push_back(op);\\n            return;\\n        }\\n        //when count of open and close brackets are same then \\n        //we have only one choice to put open bracket \\n        if(open == close){\\n            string op1 = op;\\n            op1.push_back(\\'(\\');\\n            solve(op1, open-1, close, ans);\\n        }\\n        else if(open == 0){\\n            //only choice is to put close brackets \\n            string op1 = op;\\n            op1.push_back(\\')\\');\\n            solve(op1, open, close-1, ans);\\n        }\\n        else if(close == 0){\\n            //only choise is to use open bracket \\n            string op1 = op;\\n            op1.push_back(\\'(\\');\\n            solve(op1, open-1, close, ans);\\n        }\\n        else{\\n            string op1 = op;\\n            string op2 = op;\\n            op1.push_back(\\'(\\');\\n            op2.push_back(\\')\\');\\n            solve(op1, open-1, close, ans);\\n            solve(op2, open, close-1, ans);\\n        }\\n    }\\n    vector<string> generateParenthesis(int n) {\\n        int open = n;\\n        int close = n;\\n        vector<string> ans;\\n        string op = \"\";\\n        solve(op, open, close, ans);\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    void solve(string op, int open, int close, vector<string> &ans){\\n        if(open == 0 && close == 0){\\n            ans.push_back(op);\\n            return;\\n        }\\n        //when count of open and close brackets are same then \\n        //we have only one choice to put open bracket \\n        if(open == close){\\n            string op1 = op;\\n            op1.push_back(\\'(\\');\\n            solve(op1, open-1, close, ans);\\n        }\\n        else if(open == 0){\\n            //only choice is to put close brackets \\n            string op1 = op;\\n            op1.push_back(\\')\\');\\n            solve(op1, open, close-1, ans);\\n        }\\n        else if(close == 0){\\n            //only choise is to use open bracket \\n            string op1 = op;\\n            op1.push_back(\\'(\\');\\n            solve(op1, open-1, close, ans);\\n        }\\n        else{\\n            string op1 = op;\\n            string op2 = op;\\n            op1.push_back(\\'(\\');\\n            op2.push_back(\\')\\');\\n            solve(op1, open-1, close, ans);\\n            solve(op2, open, close-1, ans);\\n        }\\n    }\\n    vector<string> generateParenthesis(int n) {\\n        int open = n;\\n        int close = n;\\n        vector<string> ans;\\n        string op = \"\";\\n        solve(op, open, close, ans);\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1276139,
                "title": "js-python-java-c-easy-recursive-solution-w-explanation",
                "content": "*(Note: This is part of a series of Leetcode solution explanations. If you like this solution or find it useful,* ***please upvote*** *this post.)*\\n\\n---\\n\\n#### ***Idea:***\\n\\nWe can make short work of this problem with a basic branching **recursive** function (**dfs**). Our recursive function will iterate through the index positions (**pos**) of a possible result. At each **pos**, we can add an open parenthesis if there\\'s more remaining space than unclosed parentheses (**open**) and we can add a closed parenthesis if there are any unclosed parentheses. Once we reach the end of the result, we can add it to our answer array (**ans**).\\n\\nTo make things easier, we can use **bit manipulation** to pass the sequence of parentheses (**seq**) for our potential result as an integer to each new recursion level. Then we just have to translate **seq** to a parentheses string before adding it to **ans**.\\n\\nOnce we\\'re all done, we can just **return ans**.\\n\\n - _**Time Complexity: O((2 * N)!/(N! * N!)** reflecting the **2N choose N** possible arrangements of parentheses_\\n - _**Space Complexity: O(N)** for the recursion stack and **res**_\\n\\n---\\n\\n#### ***Javascript Code:***\\n\\nThe best result for the code below is **72ms / 40.4MB** (beats 96% / 25%).\\n```javascript\\nvar generateParenthesis = function(N) {\\n    let ans = [], m = 2 * N\\n    \\n    const dfs = (pos, open, seq) => {\\n        if (pos === m) {\\n            let res = new Array(m)\\n            for (let i = 0; i < m; i++)\\n                res[i] = seq & 1 << i ? \"(\" : \")\"\\n            ans.push(res.join(\"\"))\\n            return\\n        }\\n        if (open) dfs(pos+1, open-1, seq)\\n        if (m - pos > open) dfs(pos+1, open+1, seq | 1 << pos)\\n    }\\n    \\n    dfs(0, 0, 0)\\n    return ans\\n};\\n```\\n\\n---\\n\\n#### ***Python Code:***\\n\\nThe best result for the code below is **28ms / 14.3MB** (beats 96% / 96%).\\n```python\\nclass Solution:\\n    def generateParenthesis(self, N: int) -> List[str]:\\n        ans, m = [], 2 * N\\n        \\n        def dfs(pos: int, opn: int, seq: int) -> None:\\n            if pos == m:\\n                res = [0] * m\\n                for i in range(m):\\n                    res[i] = \"(\" if seq & 1 << i else \")\"\\n                ans.append(\"\".join(res))\\n                return\\n            if opn: dfs(pos+1, opn-1, seq)\\n            if m - pos > opn: dfs(pos+1, opn+1, seq | 1 << pos)\\n            \\n        dfs(0, 0, 0)\\n        return ans\\n```\\n\\n---\\n\\n#### ***Java Code:***\\n\\nThe best result for the code below is **0ms / 38.7MB** (beats 100% / 93%).\\n```java\\nclass Solution {\\n    public List<String> generateParenthesis(int N) {\\n        ans = new ArrayList<>();\\n        m = 2 * N;\\n        dfs(0, 0, 0);\\n        return ans;\\n    }\\n    \\n    private List<String> ans;\\n    private int m;\\n    \\n    private void dfs(int pos, int open, int seq) {\\n        if (pos == m) {\\n            StringBuilder res = new StringBuilder();\\n            for (int i = 0; i < m; i++)\\n                res.append((seq & 1 << i) > 0 ? \"(\" : \")\");\\n            ans.add(res.toString());\\n            return;\\n        }\\n        if (open > 0) dfs(pos+1, open-1, seq);\\n        if (m - pos > open) dfs(pos+1, open+1, seq | 1 << pos);\\n    }\\n}\\n```\\n\\n---\\n\\n#### ***C++ Code:***\\n\\nThe best result for the code below is **0ms / 13.7MB** (beats 100% / 57%).\\n```c++\\nclass Solution {\\npublic:\\n    vector<string> generateParenthesis(int N) {\\n        m = 2 * N;\\n        dfs(0, 0, 0);\\n        return ans;\\n    }\\n    \\nprivate:\\n    vector<string> ans;\\n    int m;\\n    \\n    void dfs(int pos, int open, int seq) {\\n        if (pos == m) {\\n            string res = \"\";\\n            for (int i = 0; i < m; i++)\\n                res += seq & 1 << i ? \"(\" : \")\";\\n            ans.push_back(res);\\n            return;\\n        }\\n        if (open) dfs(pos+1, open-1, seq);\\n        if (m - pos > open) dfs(pos+1, open+1, seq | 1 << pos);\\n    }\\n};\\n```",
                "solutionTags": [
                    "Java",
                    "Python",
                    "C",
                    "JavaScript"
                ],
                "code": "```javascript\\nvar generateParenthesis = function(N) {\\n    let ans = [], m = 2 * N\\n    \\n    const dfs = (pos, open, seq) => {\\n        if (pos === m) {\\n            let res = new Array(m)\\n            for (let i = 0; i < m; i++)\\n                res[i] = seq & 1 << i ? \"(\" : \")\"\\n            ans.push(res.join(\"\"))\\n            return\\n        }\\n        if (open) dfs(pos+1, open-1, seq)\\n        if (m - pos > open) dfs(pos+1, open+1, seq | 1 << pos)\\n    }\\n    \\n    dfs(0, 0, 0)\\n    return ans\\n};\\n```\n```python\\nclass Solution:\\n    def generateParenthesis(self, N: int) -> List[str]:\\n        ans, m = [], 2 * N\\n        \\n        def dfs(pos: int, opn: int, seq: int) -> None:\\n            if pos == m:\\n                res = [0] * m\\n                for i in range(m):\\n                    res[i] = \"(\" if seq & 1 << i else \")\"\\n                ans.append(\"\".join(res))\\n                return\\n            if opn: dfs(pos+1, opn-1, seq)\\n            if m - pos > opn: dfs(pos+1, opn+1, seq | 1 << pos)\\n            \\n        dfs(0, 0, 0)\\n        return ans\\n```\n```java\\nclass Solution {\\n    public List<String> generateParenthesis(int N) {\\n        ans = new ArrayList<>();\\n        m = 2 * N;\\n        dfs(0, 0, 0);\\n        return ans;\\n    }\\n    \\n    private List<String> ans;\\n    private int m;\\n    \\n    private void dfs(int pos, int open, int seq) {\\n        if (pos == m) {\\n            StringBuilder res = new StringBuilder();\\n            for (int i = 0; i < m; i++)\\n                res.append((seq & 1 << i) > 0 ? \"(\" : \")\");\\n            ans.add(res.toString());\\n            return;\\n        }\\n        if (open > 0) dfs(pos+1, open-1, seq);\\n        if (m - pos > open) dfs(pos+1, open+1, seq | 1 << pos);\\n    }\\n}\\n```\n```c++\\nclass Solution {\\npublic:\\n    vector<string> generateParenthesis(int N) {\\n        m = 2 * N;\\n        dfs(0, 0, 0);\\n        return ans;\\n    }\\n    \\nprivate:\\n    vector<string> ans;\\n    int m;\\n    \\n    void dfs(int pos, int open, int seq) {\\n        if (pos == m) {\\n            string res = \"\";\\n            for (int i = 0; i < m; i++)\\n                res += seq & 1 << i ? \"(\" : \")\";\\n            ans.push_back(res);\\n            return;\\n        }\\n        if (open) dfs(pos+1, open-1, seq);\\n        if (m - pos > open) dfs(pos+1, open+1, seq | 1 << pos);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 656411,
                "title": "c-simple-solution-beats-88",
                "content": "Runtime: 232 ms, faster than 88.71% of C# online submissions for Generate Parentheses.\\nMemory Usage: 32.8 MB, less than 12.50% of C# online submissions for Generate Parentheses.\\n```\\npublic class Solution \\n{\\n    List<string> result = new List<string>();\\n    int maxLen;\\n    \\n    public IList<string> GenerateParenthesis(int n) {\\n        maxLen = n;\\n        GenerateAndCheck(\"\", 0, 0);\\n        return result;\\n    }\\n    \\n    private void GenerateAndCheck(string str, int opened, int closed)\\n    {\\n        if(opened == closed && opened == maxLen)\\n        {\\n            result.Add(str);\\n            return;\\n        }\\n        \\n        if(opened < maxLen)\\n            GenerateAndCheck(str + \"(\", opened + 1, closed);\\n        if(closed < opened)\\n            GenerateAndCheck(str + \")\", opened, closed + 1);\\n    }\\n}\\n```\\n\\nInspired by: https://youtu.be/qBbZ3tS0McI",
                "solutionTags": [
                    "C#"
                ],
                "code": "```\\npublic class Solution \\n{\\n    List<string> result = new List<string>();\\n    int maxLen;\\n    \\n    public IList<string> GenerateParenthesis(int n) {\\n        maxLen = n;\\n        GenerateAndCheck(\"\", 0, 0);\\n        return result;\\n    }\\n    \\n    private void GenerateAndCheck(string str, int opened, int closed)\\n    {\\n        if(opened == closed && opened == maxLen)\\n        {\\n            result.Add(str);\\n            return;\\n        }\\n        \\n        if(opened < maxLen)\\n            GenerateAndCheck(str + \"(\", opened + 1, closed);\\n        if(closed < opened)\\n            GenerateAndCheck(str + \")\", opened, closed + 1);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 601816,
                "title": "javascript-intuitive-code-with-detailed-explanation",
                "content": "The intuition for many explanations and code is actually the same:\\n- Backtracking and keep track of number of opening and closing brackets have been used either by incrementing or decrementing.\\n- You know you can only start with an opening: `(`\\n- At this point, you have 2 options: add more `(` or now you can add `)` to close it.\\n- When can you add more `(`? Whenever you haven\\'t used up all the `n` openings. `n` pairs = `n` openings and `n` closings. \\n- When can you add more `)`? Whenever you have more openings than closings.\\n- When can you add the combination to the list? When the string you\\'ve generated hits `2*n` length or there\\'s no more opening or closing left.\\n- If you just do it by hands, you\\'ll have something like this:\\n```\\n// Remember: you can either add more closing or opening if you\\'re still within the constraints:\\n\\'(\\'->\\'()\\'->\\'()(\\'->\\'()()\\'->\\'()()(\\'=>\\'()()()\\'\\n                ->\\'()((\\'->\\'()(()\\'=>\\'()(())\\'\\n   ->\\'((\\'->\\'(()\\'->\\'(()(\\'->\\'(()()\\'=>\\'(())())\\'\\n                ->\\'(())\\'->\\'(())(\\'=>\\'(())()\\'\\n         ->\\'(((\\'=>\\'((()))\\'\\n```\\n\\nThe code:\\n```javascript\\n/**\\n * Backtracking solution.\\n * Note: Time and Space complexity is complicated. Catalan number: 4^n/(n*sqrt(n))\\n * Time = O(n*Catalan) because we generat combinations through n steps, each\\n * step takes a Catalan number to backtrack.\\n * Time = O(4^n/(sqrt(n)))\\n * Space = O(4^n/(sqrt(n))) because we need n space to store the sequence.\\n * @param {number} n\\n * @return {string[]}\\n */\\nvar generateParenthesis = function(n) {\\n    const combinations = [];\\n    // Here we know we can only start with an opening bracket => use 1 open:\\n    // but we can also start with an empty string and 0 like so:\\n    // buildCombinationFrom(\\'\\', 0, 0, n, combinations);\\n    buildCombinationFrom(\\'(\\', 1, 0, n, combinations);\\n    return combinations;\\n};\\n\\n/**\\n * Helper method generates combinations uses backtracking.\\n * @param {string} string \\n * @param {number} openUsed \\n * @param {number} closeUsed \\n * @param {number} n \\n * @param {string[]} combinations \\n */\\nfunction buildCombinationFrom(string, openUsed, closeUsed, n, combinations) {\\n    // Base case: when we reach 2n length\\n    if (string.length === 2*n) {\\n        // Add the string to the list of combination:\\n        combinations.push(string);\\n        // Exit from this recursive call.\\n        return;\\n    }\\n    // Case: when we can add more opening bracket:\\n    // If we haven\\'t used all opening bracket (n pairs = n opens)\\n    if (openUsed < n) {\\n        // Add 1 opening, update opening used:\\n        buildCombinationFrom(string + \\'(\\', openUsed + 1, closeUsed, n, combinations);\\n    }\\n    // Case: when we can add more closing bracket:\\n    // If we have more opening than closing:\\n    if (openUsed > closeUsed) {\\n        // Add 1 closing, update closing used:\\n        buildCombinationFrom(string + \\')\\', openUsed, closeUsed + 1, n, combinations);\\n    }\\n}\\n```",
                "solutionTags": [
                    "JavaScript",
                    "Backtracking"
                ],
                "code": "```\\n// Remember: you can either add more closing or opening if you\\'re still within the constraints:\\n\\'(\\'->\\'()\\'->\\'()(\\'->\\'()()\\'->\\'()()(\\'=>\\'()()()\\'\\n                ->\\'()((\\'->\\'()(()\\'=>\\'()(())\\'\\n   ->\\'((\\'->\\'(()\\'->\\'(()(\\'->\\'(()()\\'=>\\'(())())\\'\\n                ->\\'(())\\'->\\'(())(\\'=>\\'(())()\\'\\n         ->\\'(((\\'=>\\'((()))\\'\\n```\n```javascript\\n/**\\n * Backtracking solution.\\n * Note: Time and Space complexity is complicated. Catalan number: 4^n/(n*sqrt(n))\\n * Time = O(n*Catalan) because we generat combinations through n steps, each\\n * step takes a Catalan number to backtrack.\\n * Time = O(4^n/(sqrt(n)))\\n * Space = O(4^n/(sqrt(n))) because we need n space to store the sequence.\\n * @param {number} n\\n * @return {string[]}\\n */\\nvar generateParenthesis = function(n) {\\n    const combinations = [];\\n    // Here we know we can only start with an opening bracket => use 1 open:\\n    // but we can also start with an empty string and 0 like so:\\n    // buildCombinationFrom(\\'\\', 0, 0, n, combinations);\\n    buildCombinationFrom(\\'(\\', 1, 0, n, combinations);\\n    return combinations;\\n};\\n\\n/**\\n * Helper method generates combinations uses backtracking.\\n * @param {string} string \\n * @param {number} openUsed \\n * @param {number} closeUsed \\n * @param {number} n \\n * @param {string[]} combinations \\n */\\nfunction buildCombinationFrom(string, openUsed, closeUsed, n, combinations) {\\n    // Base case: when we reach 2n length\\n    if (string.length === 2*n) {\\n        // Add the string to the list of combination:\\n        combinations.push(string);\\n        // Exit from this recursive call.\\n        return;\\n    }\\n    // Case: when we can add more opening bracket:\\n    // If we haven\\'t used all opening bracket (n pairs = n opens)\\n    if (openUsed < n) {\\n        // Add 1 opening, update opening used:\\n        buildCombinationFrom(string + \\'(\\', openUsed + 1, closeUsed, n, combinations);\\n    }\\n    // Case: when we can add more closing bracket:\\n    // If we have more opening than closing:\\n    if (openUsed > closeUsed) {\\n        // Add 1 closing, update closing used:\\n        buildCombinationFrom(string + \\')\\', openUsed, closeUsed + 1, n, combinations);\\n    }\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 919932,
                "title": "easy-java-backtracking-explained-in-comments-1-ms",
                "content": "```\\nclass Solution {\\n    public List<String> generateParenthesis(int n) {\\n        String combination = \"\";    //declare and initialize an empty string to hold each valid combination\\n        List<String> listOfValidCombinations = new ArrayList<String>(); //ArrayList to store all the valid combinations\\n        int countOfOpen = 0;    //counter to keep track of no. of open (left) parentheses\\n        int countOfClose = 0;   // counter to keep track of no. of close(right) parentheses\\n        backtrack(listOfValidCombinations, combination, countOfOpen, countOfClose, n); //calling the backtracking method\\n        return listOfValidCombinations; //return the final list of valid combinations computed by the backtacking method\\n    }\\n    \\n    public void backtrack(List<String> listOfValidCombinations, String combination, int countOfOpen, int countOfClose, int maxCount){\\n        /* The main idea here is:\\n        1.  In order to generate valid combinations of parentheses, we need to make sure that\\n            there is a closing parentheses for every open parentheses. This can be achieved by\\n            taking care of the following points:\\n            a.  At any point, no. of open parentheses > no. of closing parentheses\\n            b.  If no. of open parentheses == no. of closing parentheses, we have obtained a valid pattern\\n                (this will be our terminating condition for recursion)\\n            \\n        2.  We can repeat the process in point 1, until we have obatained all the possible combinations.\\n        \\n        */\\n        \\n        /*if no. of open and closing parentheses is equal to n, add the  \\n        combination to the list and return (and thus end the recursion)*/\\n        \\n        if((countOfOpen == maxCount) && (countOfClose == maxCount)){    //terminating condition\\n            listOfValidCombinations.add(combination);   \\n            return;\\n        }\\n        \\n        /*If no. of open parentheses is equal to n, it means we can add\\n        another \\'(\\' to the exisiting pattern and increase the value of countOfOpen by 1*/\\n        \\n        if(countOfOpen < maxCount){\\n            backtrack(listOfValidCombinations, combination + \"(\", countOfOpen + 1, countOfClose, maxCount);\\n        }\\n        \\n        /*If no. of closing parentheses is less than the no. of \\n        open parentheses is equal to n, it means we can add another \\')\\' \\n        to the exisiting pattern and increase the value of countOfClose by 1.\\n        We need to understand here that the second if block will be executed\\n        after the recursion from the first if block ends. In this way, we would\\n        have tried all possible combinations possible at this stage by BACKTRACKING.\\n        This is how backtracking is implemented here.*/\\n        \\n        if(countOfClose < countOfOpen){\\n            backtrack(listOfValidCombinations, combination + \")\", countOfOpen, countOfClose + 1, maxCount);\\n        }\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Backtracking"
                ],
                "code": "```\\nclass Solution {\\n    public List<String> generateParenthesis(int n) {\\n        String combination = \"\";    //declare and initialize an empty string to hold each valid combination\\n        List<String> listOfValidCombinations = new ArrayList<String>(); //ArrayList to store all the valid combinations\\n        int countOfOpen = 0;    //counter to keep track of no. of open (left) parentheses\\n        int countOfClose = 0;   // counter to keep track of no. of close(right) parentheses\\n        backtrack(listOfValidCombinations, combination, countOfOpen, countOfClose, n); //calling the backtracking method\\n        return listOfValidCombinations; //return the final list of valid combinations computed by the backtacking method\\n    }\\n    \\n    public void backtrack(List<String> listOfValidCombinations, String combination, int countOfOpen, int countOfClose, int maxCount){\\n        /* The main idea here is:\\n        1.  In order to generate valid combinations of parentheses, we need to make sure that\\n            there is a closing parentheses for every open parentheses. This can be achieved by\\n            taking care of the following points:\\n            a.  At any point, no. of open parentheses > no. of closing parentheses\\n            b.  If no. of open parentheses == no. of closing parentheses, we have obtained a valid pattern\\n                (this will be our terminating condition for recursion)\\n            \\n        2.  We can repeat the process in point 1, until we have obatained all the possible combinations.\\n        \\n        */\\n        \\n        /*if no. of open and closing parentheses is equal to n, add the  \\n        combination to the list and return (and thus end the recursion)*/\\n        \\n        if((countOfOpen == maxCount) && (countOfClose == maxCount)){    //terminating condition\\n            listOfValidCombinations.add(combination);   \\n            return;\\n        }\\n        \\n        /*If no. of open parentheses is equal to n, it means we can add\\n        another \\'(\\' to the exisiting pattern and increase the value of countOfOpen by 1*/\\n        \\n        if(countOfOpen < maxCount){\\n            backtrack(listOfValidCombinations, combination + \"(\", countOfOpen + 1, countOfClose, maxCount);\\n        }\\n        \\n        /*If no. of closing parentheses is less than the no. of \\n        open parentheses is equal to n, it means we can add another \\')\\' \\n        to the exisiting pattern and increase the value of countOfClose by 1.\\n        We need to understand here that the second if block will be executed\\n        after the recursion from the first if block ends. In this way, we would\\n        have tried all possible combinations possible at this stage by BACKTRACKING.\\n        This is how backtracking is implemented here.*/\\n        \\n        if(countOfClose < countOfOpen){\\n            backtrack(listOfValidCombinations, combination + \")\", countOfOpen, countOfClose + 1, maxCount);\\n        }\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 10403,
                "title": "a-simplified-c-dp-solution-4ms-8-lines",
                "content": "    //dp[0] = \"\"\\n    //dp[i]='('+ dp[k]+')'+dp[i-1-k],k=0..i-i\\n    class Solution {\\n    public:\\n        vector<string> generateParenthesis(int n) {\\n            vector< vector<string> > dp(n+1, vector<string>());\\n            dp[0].push_back(\"\");\\n            for(int i=1; i<=n; ++i){\\n                for(int k=0; k<i; ++k){\\n                    for(string s1: dp[k]){\\n                        for(string s2: dp[i-1-k])\\n                            dp[i].push_back(\"(\"+s1+\")\"+s2);\\n                    }\\n                }\\n            }\\n            return dp[n];\\n        }\\n    };",
                "solutionTags": [
                    "C++",
                    "Dynamic Programming"
                ],
                "code": "class Solution {\\n    public:\\n        vector<string> generateParenthesis(int n) {\\n            vector< vector<string> > dp(n+1, vector<string>());\\n            dp[0].push_back(\"\");\\n            for(int i=1; i<=n; ++i){\\n                for(int k=0; k<i; ++k){\\n                    for(string s1: dp[k]){\\n                        for(string s2: dp[i-1-k])\\n                            dp[i].push_back(\"(\"+s1+\")\"+s2);\\n                    }",
                "codeTag": "Java"
            },
            {
                "id": 683890,
                "title": "c-backtracking-10-lines-easy-to-understand",
                "content": "```\\nclass Solution {\\npublic:\\n    vector<string> ans;\\n    void f(string s,int open,int close){        //open => \\'(\\' count remaining\\n        if(open==0&&close==0){                  //close=> \\')\\' count remaining\\n            ans.push_back(s);\\n            return;\\n        }\\n        if(open>0)f(s+\"(\",open-1,close);\\n        if(open<close)f(s+\")\",open,close-1);    //\\'(\\' must be placed before \\')\\'\\n    }\\n    vector<string> generateParenthesis(int n) {\\n        ans.clear();\\n        f(\"\",n,n);                              //Balanced string will have\\n        return ans;                             //n-open and n-closing brackets\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Backtracking"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<string> ans;\\n    void f(string s,int open,int close){        //open => \\'(\\' count remaining\\n        if(open==0&&close==0){                  //close=> \\')\\' count remaining\\n            ans.push_back(s);\\n            return;\\n        }\\n        if(open>0)f(s+\"(\",open-1,close);\\n        if(open<close)f(s+\")\",open,close-1);    //\\'(\\' must be placed before \\')\\'\\n    }\\n    vector<string> generateParenthesis(int n) {\\n        ans.clear();\\n        f(\"\",n,n);                              //Balanced string will have\\n        return ans;                             //n-open and n-closing brackets\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3450759,
                "title": "0-ms-java-recursive-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nThe time complexity of this solution is O(4^n / sqrt(n)) because there are 2n steps in the backtracking process, and in each step, we can choose to either open or close a bracket. This gives us a total of 2^n possibilities at each step. However, not all of these possibilities are valid since we must ensure that the number of closing brackets is less than or equal to the number of opening brackets at each step. Therefore, we can eliminate half of the possibilities at each step, giving us a total of 2^n / 2 possibilities per step or 2^(2n) / 2^n = 4^n / 2^n = 4^n / (2^(2 * sqrt(n))) = O(4^n / sqrt(n)) possibilities in total.\\n\\nThe space complexity is also O(4^n / sqrt(n)) because this is the maximum number of solutions that we could generate. Since each solution has a length of 2n, the maximum amount of space required to store all solutions is O(2n * 4^n / sqrt(n)) = O(4^n / sqrt(n)).\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ --> O(4^n / sqrt(n))\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->O(4^n / sqrt(n))\\n![Screenshot_20230205_171246.png](https://assets.leetcode.com/users/images/f30b6fb7-d111-4bb1-8f38-6591b7482293_1682345447.5071316.png)\\n\\n# Code\\n```\\nclass Solution {\\n    public List<String> generateParenthesis(int n) {\\n        List<String> result = new ArrayList<>(); // initialize the result list\\n        generate(result, \"\", n, n); // call the recursive helper function\\n        return result; // return the result list\\n    }\\n    \\n    public void generate(List<String> result, String s, int left, int right){\\n        if(left == 0 && right == 0){ // base case: no more parentheses to add\\n            result.add(s); // add the generated string to the result list\\n            return; // exit the current recursive call\\n        }\\n        if(left > 0){ // if there are still left parentheses to add\\n            generate(result, s + \"(\", left - 1, right); // add a left parenthesis and recursively call the function\\n        }\\n        if(right > left){ // if there are still right parentheses to add and there are more left parentheses than right parentheses in the current string\\n            generate(result, s + \")\", left, right - 1); // add a right parenthesis and recursively call the function\\n        }\\n    }\\n}\\n\\n```",
                "solutionTags": [
                    "Java",
                    "String",
                    "Recursion"
                ],
                "code": "```\\nclass Solution {\\n    public List<String> generateParenthesis(int n) {\\n        List<String> result = new ArrayList<>(); // initialize the result list\\n        generate(result, \"\", n, n); // call the recursive helper function\\n        return result; // return the result list\\n    }\\n    \\n    public void generate(List<String> result, String s, int left, int right){\\n        if(left == 0 && right == 0){ // base case: no more parentheses to add\\n            result.add(s); // add the generated string to the result list\\n            return; // exit the current recursive call\\n        }\\n        if(left > 0){ // if there are still left parentheses to add\\n            generate(result, s + \"(\", left - 1, right); // add a left parenthesis and recursively call the function\\n        }\\n        if(right > left){ // if there are still right parentheses to add and there are more left parentheses than right parentheses in the current string\\n            generate(result, s + \")\", left, right - 1); // add a right parenthesis and recursively call the function\\n        }\\n    }\\n}\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1694091,
                "title": "golang-0ms-100",
                "content": "```\\nfunc generateParenthesis(n int) []string {\\n\\tans := make([]string, 0)\\n\\tcurrent := make([]byte, n*2)\\n\\trec22(&ans, n, 0, 0, current)\\n\\treturn ans\\n}\\n```\\n\\n```\\nfunc rec22(ans *[]string, n int, left int, right int, current []byte) {\\n\\tif left+right == n*2 {\\n\\t\\t*ans = append(*ans, string(current))\\n\\t\\treturn\\n\\t}\\n\\n\\tif left < n {\\n\\t\\tcurrent[left+right] = \\'(\\'\\n\\t\\trec22(ans, n, left+1, right, current)\\n\\t}\\n\\n\\tif right < left {\\n\\t\\tcurrent[left+right] = \\')\\'\\n\\t\\trec22(ans, n, left, right+1, current)\\n\\t}\\n}\\n```",
                "solutionTags": [
                    "Go"
                ],
                "code": "```\\nfunc generateParenthesis(n int) []string {\\n\\tans := make([]string, 0)\\n\\tcurrent := make([]byte, n*2)\\n\\trec22(&ans, n, 0, 0, current)\\n\\treturn ans\\n}\\n```\n```\\nfunc rec22(ans *[]string, n int, left int, right int, current []byte) {\\n\\tif left+right == n*2 {\\n\\t\\t*ans = append(*ans, string(current))\\n\\t\\treturn\\n\\t}\\n\\n\\tif left < n {\\n\\t\\tcurrent[left+right] = \\'(\\'\\n\\t\\trec22(ans, n, left+1, right, current)\\n\\t}\\n\\n\\tif right < left {\\n\\t\\tcurrent[left+right] = \\')\\'\\n\\t\\trec22(ans, n, left, right+1, current)\\n\\t}\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 916464,
                "title": "python-backtracking-faster-than-98",
                "content": "```\\n# Note: these codes are a python version of this youtube video\\n# https://www.youtube.com/watch?v=qBbZ3tS0McI\\n\\nclass Solution:\\n    def generateParenthesis(self, n: int) -> List[str]:\\n        \\n        def backtrack(ans, curr, openp, closep, maxp):\\n            if len(curr) == 2*maxp:\\n                ans.append(curr)\\n            if openp < maxp:\\n                backtrack(ans, curr+\\'(\\', openp+1, closep, maxp)\\n            if closep < openp:\\n                backtrack(ans, curr+\\')\\', openp, closep+1, maxp)\\n        \\n        ans = []\\n        openp, closep = 0, 0\\n        curr = \\'\\'\\n        backtrack(ans, curr, openp, closep, n)\\n        return ans",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Backtracking"
                ],
                "code": "```\\n# Note: these codes are a python version of this youtube video\\n# https://www.youtube.com/watch?v=qBbZ3tS0McI\\n\\nclass Solution:\\n    def generateParenthesis(self, n: int) -> List[str]:\\n        \\n        def backtrack(ans, curr, openp, closep, maxp):\\n            if len(curr) == 2*maxp:\\n                ans.append(curr)\\n            if openp < maxp:\\n                backtrack(ans, curr+\\'(\\', openp+1, closep, maxp)\\n            if closep < openp:\\n                backtrack(ans, curr+\\')\\', openp, closep+1, maxp)\\n        \\n        ans = []\\n        openp, closep = 0, 0\\n        curr = \\'\\'\\n        backtrack(ans, curr, openp, closep, n)\\n        return ans",
                "codeTag": "Java"
            },
            {
                "id": 10312,
                "title": "python-dfs-easy-to-understand",
                "content": "The idea is at every step, check if the current path is a valid path (base case 1) and whether the path has reached the end (base case 2). \\n\\nValid is defined as:\\n\\n 1. Number of left parentheses >= Number of right parentheses\\n 2. Number of left parentheses <= n\\n 3. Number of right parentheses <= n\\n\\nReaching the end is defined as:\\n\\n 1. Total number of parentheses = n*2 (every left parenthesis has to be matched with a right parenthesis)\\n\\nIf the current path is valid and has not reached the end yet, try adding another parenthesis (left and right), respectively) and do this recursively until the path is no longer valid or reached the end. Once we've exhausted all possible options, we can return all valid paths that has reached the end.\\n\\n----------\\n\\n    def generateParenthesis(self, n):\\n        result = []\\n        self.dfs(n,result,'',0,0)\\n        return result\\n    \\n    def dfs(self,n,result,path,left,right):\\n        # check if the current path is valid\\n        if not self.isValid(left,right,n):\\n            return\\n        # check we are at the right length\\n        if len(path) == n*2:\\n            result.append(path)\\n            return\\n        self.dfs(n,result,path+'(',left+1,right)\\n        self.dfs(n,result,path+')',left,right+1)\\n        \\n    def isValid(self,left,right,n):\\n        # left paren <= right paren\\n        # left paren <= n\\n        # right paren >= n\\n        return left >= right and left <= n and right <= n",
                "solutionTags": [
                    "Python",
                    "Backtracking",
                    "Depth-First Search",
                    "Recursion"
                ],
                "code": "The idea is at every step, check if the current path is a valid path (base case 1) and whether the path has reached the end (base case 2). \\n\\nValid is defined as:\\n\\n 1. Number of left parentheses >= Number of right parentheses\\n 2. Number of left parentheses <= n\\n 3. Number of right parentheses <= n\\n\\nReaching the end is defined as:\\n\\n 1. Total number of parentheses = n*2 (every left parenthesis has to be matched with a right parenthesis)\\n\\nIf the current path is valid and has not reached the end yet, try adding another parenthesis (left and right), respectively) and do this recursively until the path is no longer valid or reached the end. Once we've exhausted all possible options, we can return all valid paths that has reached the end.\\n\\n----------\\n\\n    def generateParenthesis(self, n):\\n        result = []\\n        self.dfs(n,result,'',0,0)\\n        return result\\n    \\n    def dfs(self,n,result,path,left,right):\\n        # check if the current path is valid\\n        if not self.isValid(left,right,n):\\n            return\\n        # check we are at the right length\\n        if len(path) == n*2:\\n            result.append(path)\\n            return\\n        self.dfs(n,result,path+'(',left+1,right)\\n        self.dfs(n,result,path+')',left,right+1)\\n        \\n    def isValid(self,left,right,n):\\n        # left paren <= right paren\\n        # left paren <= n\\n        # right paren >= n\\n        return left >= right and left <= n and right <= n",
                "codeTag": "Python3"
            },
            {
                "id": 10425,
                "title": "javascript-solution-in-124ms",
                "content": "    var generateParenthesis = function(n) {\\n      var arr = [];\\n      compose(n, n, '');\\n      return arr;\\n    \\n      function compose(left, right, str) {\\n        if (!left && !right && str.length) return arr.push(str);\\n        if (left) compose(left - 1, right, str + '(');\\n        if (right > left) compose(left, right - 1, str + ')');\\n      }\\n    };",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "    var generateParenthesis = function(n) {\\n      var arr = [];\\n      compose(n, n, '');\\n      return arr;\\n    \\n      function compose(left, right, str) {\\n        if (!left && !right && str.length) return arr.push(str);\\n        if (left) compose(left - 1, right, str + '(');\\n        if (right > left) compose(left, right - 1, str + ')');\\n      }\\n    };",
                "codeTag": "Unknown"
            },
            {
                "id": 3064146,
                "title": "easy-c-recursive-and-back-tracking-solutions",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nDo recursion and genrate all the possible sequences and also keep checking if open == close and when size of string becomes 2*n then push that string in answer vector.\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n1. Recusrive \\n2. Backtracking\\n# Complexity\\n- Time complexity:O(4^n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:$$O(4^n)$$ recusirve stack + $$O(n)$$ for storing sequences \\n- actually it will be $$4^n/sqrt(n)$$ (it need some calculation but roughly we can take $$4^n$$)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n**Recursive Approach**\\n```\\nclass Solution {\\npublic:\\nvector<string>ans;\\n   void generate (int open,int close ,int n,string s){\\n       if(s.size()==2*n)ans.push_back(s);\\n       if(open<n)generate(open+1,close,n,s+\"(\");\\n       if(close<open)generate(open,close+1,n,s+\")\");\\n   }\\n    vector<string> generateParenthesis(int n) {\\n        generate(0,0,n,\"\");\\n        return ans;\\n    }\\n};\\n```\\n**Back tracking Approach**\\n```\\nclass Solution {\\npublic:\\nvector<string>ans;\\n   void generate (int open,int close ,int n,string s){\\n       if(s.size()==2*n)ans.push_back(s);\\n       if(open<n){\\n           s+=\"(\";\\n           generate(open+1,close,n,s);\\n           s.pop_back();\\n       }\\n       if(close<open){\\n       s+=\")\";\\n       generate(open,close+1,n,s);\\n       s.pop_back();\\n       }\\n   }\\n    vector<string> generateParenthesis(int n) {\\n        generate(0,0,n,\"\");\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Dynamic Programming",
                    "Backtracking",
                    "Recursion"
                ],
                "code": "```\\nclass Solution {\\npublic:\\nvector<string>ans;\\n   void generate (int open,int close ,int n,string s){\\n       if(s.size()==2*n)ans.push_back(s);\\n       if(open<n)generate(open+1,close,n,s+\"(\");\\n       if(close<open)generate(open,close+1,n,s+\")\");\\n   }\\n    vector<string> generateParenthesis(int n) {\\n        generate(0,0,n,\"\");\\n        return ans;\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\nvector<string>ans;\\n   void generate (int open,int close ,int n,string s){\\n       if(s.size()==2*n)ans.push_back(s);\\n       if(open<n){\\n           s+=\"(\";\\n           generate(open+1,close,n,s);\\n           s.pop_back();\\n       }\\n       if(close<open){\\n       s+=\")\";\\n       generate(open,close+1,n,s);\\n       s.pop_back();\\n       }\\n   }\\n    vector<string> generateParenthesis(int n) {\\n        generate(0,0,n,\"\");\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2712761,
                "title": "beautiful-iterative-python-solution-with-stack",
                "content": "The stack holds all subproblems. The stack gets popped every loop and the possible children of the popped item get appended back on. \\nThe items in the stack are tuples with the following makeup: [parenthesis string, open remaining, closed remaining]. \\nWe initialize the stack with [\"(\",n-1,n] because every valid parenthesis combination starts with \"(\". \\nOnce an item x is popped from the stack, we check if it is complete by checking if the number of open remaining and closed remaining are zero. If it is complete, we append the string stored in x[0] to the return array. \\nIf not, we move to the next step. In the next step, we check if the number of open remaining (x[1]) is less than n. If so, we can append an open parenthesis to x[1], decrement the number of open parentheses remaining, and push it back on the stack. \\nThen, we can check x again to see if the number of closed parentheses remaining (x[2]) is greater than the number of open parentheses remaining (x[1]). If it is, we append a closed parenthesis to x[0], decrement the closed parenthesis counter, then push it back on the stack.\\nOur program finishes when the stack is empty. We return the array of finished strings.\\n\\n```\\nclass Solution:\\n    def generateParenthesis(self, n: int) -> List[str]:\\n        rv = []\\n        stack = [(\"(\",n-1,n)]\\n        \\n        while stack:\\n            item = stack.pop()\\n            \\n            s = item[0]\\n            o = item[1]\\n            c = item[2]\\n            \\n            if o == 0 and c == 0:\\n                rv.append(s)\\n            else:\\n                if o != 0:\\n                    stack.append([s+\"(\",o-1,c])\\n                \\n                if o < c:\\n                    stack.append([s+\")\",o,c-1])\\n\\n        return rv\\n```",
                "solutionTags": [
                    "Python",
                    "Stack",
                    "Iterator"
                ],
                "code": "```\\nclass Solution:\\n    def generateParenthesis(self, n: int) -> List[str]:\\n        rv = []\\n        stack = [(\"(\",n-1,n)]\\n        \\n        while stack:\\n            item = stack.pop()\\n            \\n            s = item[0]\\n            o = item[1]\\n            c = item[2]\\n            \\n            if o == 0 and c == 0:\\n                rv.append(s)\\n            else:\\n                if o != 0:\\n                    stack.append([s+\"(\",o-1,c])\\n                \\n                if o < c:\\n                    stack.append([s+\")\",o,c-1])\\n\\n        return rv\\n```",
                "codeTag": "Java"
            },
            {
                "id": 842989,
                "title": "easy-to-understand-time-complexity-analysis-with-pictures",
                "content": "Here is a quick explanation why the time cost to generate all parentheses is `O(nCn)`, where `Cn` is the n-th Catalan number, `n` is the cost to add results.\\n\\nThis problem is very similar with the [95. unique binary search tree II](https://leetcode.com/problems/unique-binary-search-trees-ii/) problem. Let\\'s say `n = 3` and we generated unique binary tree having 3 nodes:\\n```\\nA:          B:              C:       D:        E:\\no            o               o       o          o\\n \\\\         /   \\\\           /          \\\\        /                              \\n  o       o     o         o            o      o             \\n   \\\\                     /            /        \\\\                    \\n    o                   o            o          o \\n```\\n\\nTo convert the unique tree structure to unique parentheses, we just need to apply following rules recursively:\\n* each node corresponds to a pair of parentheses `()`\\n* root node\\'s parentheses will encompass its left child\\'s parenthese (or right, its the same)\\n\\nUsing this rule, we can convert the 5 unique tree structures to unique parentheses:\\nA: `\"()()()\"`; B: `\"(())()\"`; C: `\"((()))\"`; D: `\"()(())\"`; E: `\"(()())\"`\\n\\nNow the question becomes: what is the time complexity of getting all the unique binary tree structure? For a tree with `n` nodes, it\\'s left tree can have `0` to `n - 1` nodes, and its right tree can also have `0` to `n - 1` nodes. So if we know `T(0)` to `T(n - 1)`, then `T(n) = sum_{i = 0}^{n - 1}T[i] * T[n - i - 1]`. This recurrence describes the Catalan number. Let `T[0] = 1` and we can calculate `T[n]` using this recurrence.\\n\\nCheck [problem 95](https://leetcode.com/problems/unique-binary-search-trees-ii/) and [problem 96](https://leetcode.com/problems/unique-binary-search-trees/) for more details!\\n",
                "solutionTags": [],
                "code": "```\\nA:          B:              C:       D:        E:\\no            o               o       o          o\\n \\\\         /   \\\\           /          \\\\        /                              \\n  o       o     o         o            o      o             \\n   \\\\                     /            /        \\\\                    \\n    o                   o            o          o \\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 327106,
                "title": "easy-to-understand-with-diagram",
                "content": "```\\n public List<String> generateParenthesis(int n) {\\n        List<String> list = new ArrayList<String>();\\n        backtrack(list, \"\", 0, 0, n);\\n        return list;\\n    }\\n```\\n    \\n    public void backtrack(List<String> list, String str, int open, int close, int max){\\n        \\n        if(str.length() == max*2){\\n            list.add(str);\\n            return;\\n        }\\n        \\n        if(open < max)\\n            backtrack(list, str+\"(\", open+1, close, max);\\n        if(close < open)\\n            backtrack(list, str+\")\", open, close+1, max);\\n    }\\n\\nThis is very easy to understand by first getting all permutations of perenthesis and eliminating based on case 1 and case 2\\n\\n![image](https://assets.leetcode.com/users/raghur/image_1562256962.png)\\n\\n![image](https://assets.leetcode.com/users/raghur/image_1562257162.png)\\n\\n![image](https://assets.leetcode.com/users/raghur/image_1562257179.png)\\n\\n\\n\\n",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\n public List<String> generateParenthesis(int n) {\\n        List<String> list = new ArrayList<String>();\\n        backtrack(list, \"\", 0, 0, n);\\n        return list;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 10250,
                "title": "simple-recursive-solution-0ms-in-c",
                "content": "```\\nclass Solution {\\nprivate:\\n    void search(int left, int right, string path, vector<string>& v) {\\n        if(!left && !right) { v.push_back(path); return ; }\\n        if(left > 0) search(left-1, right, path+\"(\", v);\\n        if(left < right) search(left, right-1, path+\")\", v);\\n    }\\npublic:\\n    vector<string> generateParenthesis(int n) {\\n        vector<string> v;\\n        search(n, n, \"\", v);\\n        return v;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\nprivate:\\n    void search(int left, int right, string path, vector<string>& v) {\\n        if(!left && !right) { v.push_back(path); return ; }\\n        if(left > 0) search(left-1, right, path+\"(\", v);\\n        if(left < right) search(left, right-1, path+\")\", v);\\n    }\\npublic:\\n    vector<string> generateParenthesis(int n) {\\n        vector<string> v;\\n        search(n, n, \"\", v);\\n        return v;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3235446,
                "title": "c-simple-very-easy",
                "content": "The idea is intuitive. Use two integers to count the remaining left parenthesis (left) and the right parenthesis (right) to be added.\\n**At each function call add a left parenthesis and add a right parenthesis if right>left. Add the result if left==0 and right==0.**\\n\\n```\\nclass Solution {\\npublic:\\n    vector<string> ans;\\n    \\n    void fun(int left,int right,string s)\\n    {\\n        if(left<0||right<0)\\n        {\\n          return;\\n        }\\n        if(left==0 and right==0)\\n        {\\n          ans.push_back(s);\\n          return;\\n        }\\n      \\n       fun(left-1,right,s+\"(\");\\n\\t   \\n       if(right>left)\\n\\t   {\\n\\t   fun(left,right-1,s+\")\");\\n\\t   }\\n    }\\n    \\n    vector<string> generateParenthesis(int n) {\\n        fun(n,n,\"\");\\n        return ans;\\n    }\\n};",
                "solutionTags": [
                    "C",
                    "Recursion"
                ],
                "code": "class Solution {\\npublic:\\n    vector<string> ans;\\n    \\n    void fun(int left,int right,string s)\\n    {\\n        if(left<0||right<0)\\n        {\\n          return;\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 1599246,
                "title": "python-with-detailed-explanation-faster-than-96-54-recursive-iterative-backtracking",
                "content": "##### Lets define our goal, choise and constraints\\n##### Goal (base case) (when to return from the recurresion) --> generate nx2 valid parentheses \\n\\t- to put n*2 valid parentheses\\n\\n##### Choise : (what to do at each recurssion)\\n\\tDo I open a bracket or do I close a bracket\\n\\n##### Constraints (guide the recurssion)\\n\\t- I can\\'t open a braket more than what I\\'ve given --> left < n\\n\\t- I can\\'t close bracket more than what I\\'ve opened --> right < left\\n\\n### Approach as shown in the figure --> this can easily be solved using DFS approach or backtracking\\n\\n### #Then build a recurssion tree using either\\n*  recursive (option 1)\\n* Iterative (option 2)\\n\\n![image](https://assets.leetcode.com/users/images/1e331a2b-7082-46fd-ab41-843d3065e72b_1638037786.9646535.png)\\n\\n#### Option -1 (Recursive)\\n```\\nclass Solution(object):\\n    def generateParenthesis(self, n):\\n        \"\"\"\\n        :type n: int\\n        :rtype: List[str]\\n        \"\"\"        \\n        out = []\\n        def back_track(par=\\'\\', left=0,right=0):\\n            #base case --> if we generate parthenis with len 2*n we hit our goal\\n            if len(par) == 2*n:\\n                out.append(par)            \\n            if left < n: # if we still have less opened bracket than the allowed n value --> we can still open more\\n                back_track(par+\\'(\\', left+1,right)\\n            if right < left: # we can only close the opened brackets\\n                back_track(par+\\')\\', left, right+1)\\n                \\n        back_track()\\n        return out\\n```\\n\\n#### Option -2 (Iterative)\\n```\\nclass Solution(object):\\n    def generateParenthesis(self, n):\\n        \"\"\"\\n        :type n: int\\n        :rtype: List[str]\\n        \"\"\"\\n\\n        out = []\\n        stack = []\\n        stack.append([\\'(\\',1,0])\\n        while stack:\\n            val, left, right = stack.pop()\\n            if len(val) == 2*n:\\n                out.append(val)                \\n            if left < n:\\n                stack.append([val+\\'(\\', left+1,right])\\n            if right < left:\\n                stack.append([val+\\')\\', left, right+1])                \\n        return out\\n```\\n\\n### If this solution/explanation helps you, don\\'t forget to upvote as a sign of appreciation",
                "solutionTags": [
                    "Python",
                    "Backtracking",
                    "Depth-First Search",
                    "Recursion",
                    "Iterator"
                ],
                "code": "```\\nclass Solution(object):\\n    def generateParenthesis(self, n):\\n        \"\"\"\\n        :type n: int\\n        :rtype: List[str]\\n        \"\"\"        \\n        out = []\\n        def back_track(par=\\'\\', left=0,right=0):\\n            #base case --> if we generate parthenis with len 2*n we hit our goal\\n            if len(par) == 2*n:\\n                out.append(par)            \\n            if left < n: # if we still have less opened bracket than the allowed n value --> we can still open more\\n                back_track(par+\\'(\\', left+1,right)\\n            if right < left: # we can only close the opened brackets\\n                back_track(par+\\')\\', left, right+1)\\n                \\n        back_track()\\n        return out\\n```\n```\\nclass Solution(object):\\n    def generateParenthesis(self, n):\\n        \"\"\"\\n        :type n: int\\n        :rtype: List[str]\\n        \"\"\"\\n\\n        out = []\\n        stack = []\\n        stack.append([\\'(\\',1,0])\\n        while stack:\\n            val, left, right = stack.pop()\\n            if len(val) == 2*n:\\n                out.append(val)                \\n            if left < n:\\n                stack.append([val+\\'(\\', left+1,right])\\n            if right < left:\\n                stack.append([val+\\')\\', left, right+1])                \\n        return out\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1545154,
                "title": "java-tc-o-4-n-sqrt-n-sc-o-n-backtracking-iterative-solutions",
                "content": "**Backtracking solution**\\n```\\n/**\\n * Backtracking solution\\n *\\n * Time Complexity: Very loose Upper Bound O(2N * 2^(2N)). As each place has only 2 options.\\n *\\n * Since number of valid combinations is equal to n-th Catalan number. n-th\\n * Catalan number = 1/(n+1) * C(2n, n) which is bounded asymptotically by 4^N /\\n * (N * sqrt(N)). Thus time complexity will be O(4^N / sqrt(N)).\\n *\\n * Space Complexity: O(N) -> Recursion stack size. O(4^N / sqrt(N)) to save the\\n * valid combinations in result list.\\n *\\n * N = Input number.\\n */\\nclass Solution {\\n    public List<String> generateParenthesis(int n) {\\n        List<String> result = new ArrayList<>();\\n        if (n < 0) {\\n            return result;\\n        }\\n        generateParenthesisHelper(result, n, n, new StringBuilder());\\n        return result;\\n    }\\n\\n    private void generateParenthesisHelper(List<String> result, int open, int close, StringBuilder sb) {\\n        if (open == 0 && close == 0) {\\n            result.add(sb.toString());\\n            return;\\n        }\\n\\n        if (open > 0) {\\n            sb.append(\"(\");\\n            generateParenthesisHelper(result, open - 1, close, sb);\\n            sb.setLength(sb.length() - 1);\\n        }\\n        if (open < close) {\\n            sb.append(\")\");\\n            generateParenthesisHelper(result, open, close - 1, sb);\\n            sb.setLength(sb.length() - 1);\\n        }\\n    }\\n}\\n```\\n\\n---\\n**Iterative Solution**\\n\\n```java\\n/**\\n * Iterative Solution\\n *\\n * Time and Space Complexity\\n *      = C0 + 2 (1*C1 + 2*C2 + 3*C3 + 4*C4 + ... + N*CN)\\n *\\n * Where, C0 -> 0th Catalan Number\\n *        C1 -> 1st Catalan Number\\n *        ...\\n *        CN -> Nth Catalan Number = 1/(n+1) * C(2n, n)\\n *              Nth Catalan Number is bounded asymptotically by 4^N / (N * sqrt(N))\\n *\\n * N = Input number\\n */\\nclass Solution {\\n    public List<String> generateParenthesis(int n) {\\n        if (n < 0) {\\n            return new ArrayList<>();\\n        }\\n\\n        List<List<String>> lists = new ArrayList<>();\\n        lists.add(Collections.singletonList(\"\"));\\n\\n        for (int i = 1; i <= n; i++) {\\n            List<String> list = new ArrayList<>();\\n            for (int j = 0; j < i; j++) {\\n                for (String first : lists.get(j)) {\\n                    for (String second : lists.get(i - 1 - j)) {\\n                        StringBuilder sb = new StringBuilder(\"(\");\\n                        sb.append(first).append(\")\").append(second);\\n                        list.add(sb.toString());\\n                    }\\n                }\\n            }\\n            lists.add(list);\\n        }\\n\\n        return lists.get(n);\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Backtracking",
                    "Recursion"
                ],
                "code": "```\\n/**\\n * Backtracking solution\\n *\\n * Time Complexity: Very loose Upper Bound O(2N * 2^(2N)). As each place has only 2 options.\\n *\\n * Since number of valid combinations is equal to n-th Catalan number. n-th\\n * Catalan number = 1/(n+1) * C(2n, n) which is bounded asymptotically by 4^N /\\n * (N * sqrt(N)). Thus time complexity will be O(4^N / sqrt(N)).\\n *\\n * Space Complexity: O(N) -> Recursion stack size. O(4^N / sqrt(N)) to save the\\n * valid combinations in result list.\\n *\\n * N = Input number.\\n */\\nclass Solution {\\n    public List<String> generateParenthesis(int n) {\\n        List<String> result = new ArrayList<>();\\n        if (n < 0) {\\n            return result;\\n        }\\n        generateParenthesisHelper(result, n, n, new StringBuilder());\\n        return result;\\n    }\\n\\n    private void generateParenthesisHelper(List<String> result, int open, int close, StringBuilder sb) {\\n        if (open == 0 && close == 0) {\\n            result.add(sb.toString());\\n            return;\\n        }\\n\\n        if (open > 0) {\\n            sb.append(\"(\");\\n            generateParenthesisHelper(result, open - 1, close, sb);\\n            sb.setLength(sb.length() - 1);\\n        }\\n        if (open < close) {\\n            sb.append(\")\");\\n            generateParenthesisHelper(result, open, close - 1, sb);\\n            sb.setLength(sb.length() - 1);\\n        }\\n    }\\n}\\n```\n```java\\n/**\\n * Iterative Solution\\n *\\n * Time and Space Complexity\\n *      = C0 + 2 (1*C1 + 2*C2 + 3*C3 + 4*C4 + ... + N*CN)\\n *\\n * Where, C0 -> 0th Catalan Number\\n *        C1 -> 1st Catalan Number\\n *        ...\\n *        CN -> Nth Catalan Number = 1/(n+1) * C(2n, n)\\n *              Nth Catalan Number is bounded asymptotically by 4^N / (N * sqrt(N))\\n *\\n * N = Input number\\n */\\nclass Solution {\\n    public List<String> generateParenthesis(int n) {\\n        if (n < 0) {\\n            return new ArrayList<>();\\n        }\\n\\n        List<List<String>> lists = new ArrayList<>();\\n        lists.add(Collections.singletonList(\"\"));\\n\\n        for (int i = 1; i <= n; i++) {\\n            List<String> list = new ArrayList<>();\\n            for (int j = 0; j < i; j++) {\\n                for (String first : lists.get(j)) {\\n                    for (String second : lists.get(i - 1 - j)) {\\n                        StringBuilder sb = new StringBuilder(\"(\");\\n                        sb.append(first).append(\")\").append(second);\\n                        list.add(sb.toString());\\n                    }\\n                }\\n            }\\n            lists.add(list);\\n        }\\n\\n        return lists.get(n);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1276140,
                "title": "generate-parentheses-js-python-java-c-easy-recursive-solution-w-explanation",
                "content": "*(Note: This is part of a series of Leetcode solution explanations. If you like this solution or find it useful,* ***please upvote*** *this post.)*\\n\\n---\\n\\n#### ***Idea:***\\n\\nWe can make short work of this problem with a basic branching **recursive** function (**dfs**). Our recursive function will iterate through the index positions (**pos**) of a possible result. At each **pos**, we can add an open parenthesis if there\\'s more remaining space than unclosed parentheses (**open**) and we can add a closed parenthesis if there are any unclosed parentheses. Once we reach the end of the result, we can add it to our answer array (**ans**).\\n\\nTo make things easier, we can use **bit manipulation** to pass the sequence of parentheses (**seq**) for our potential result as an integer to each new recursion level. Then we just have to translate **seq** to a parentheses string before adding it to **ans**.\\n\\nOnce we\\'re all done, we can just **return ans**.\\n\\n - _**Time Complexity: O((2 * N)!/(N! * N!)** reflecting the **2N choose N** possible arrangements of parentheses_\\n - _**Space Complexity: O(N)** for the recursion stack and **res**_\\n\\n---\\n\\n#### ***Javascript Code:***\\n\\nThe best result for the code below is **72ms / 40.4MB** (beats 96% / 25%).\\n```javascript\\nvar generateParenthesis = function(N) {\\n    let ans = [], m = 2 * N\\n    \\n    const dfs = (pos, open, seq) => {\\n        if (pos === m) {\\n            let res = new Array(m)\\n            for (let i = 0; i < m; i++)\\n                res[i] = seq & 1 << i ? \"(\" : \")\"\\n            ans.push(res.join(\"\"))\\n            return\\n        }\\n        if (open) dfs(pos+1, open-1, seq)\\n        if (m - pos > open) dfs(pos+1, open+1, seq | 1 << pos)\\n    }\\n    \\n    dfs(0, 0, 0)\\n    return ans\\n};\\n```\\n\\n---\\n\\n#### ***Python Code:***\\n\\nThe best result for the code below is **28ms / 14.3MB** (beats 96% / 96%).\\n```python\\nclass Solution:\\n    def generateParenthesis(self, N: int) -> List[str]:\\n        ans, m = [], 2 * N\\n        \\n        def dfs(pos: int, opn: int, seq: int) -> None:\\n            if pos == m:\\n                res = [0] * m\\n                for i in range(m):\\n                    res[i] = \"(\" if seq & 1 << i else \")\"\\n                ans.append(\"\".join(res))\\n                return\\n            if opn: dfs(pos+1, opn-1, seq)\\n            if m - pos > opn: dfs(pos+1, opn+1, seq | 1 << pos)\\n            \\n        dfs(0, 0, 0)\\n        return ans\\n```\\n\\n---\\n\\n#### ***Java Code:***\\n\\nThe best result for the code below is **0ms / 38.7MB** (beats 100% / 93%).\\n```java\\nclass Solution {\\n    public List<String> generateParenthesis(int N) {\\n        ans = new ArrayList<>();\\n        m = 2 * N;\\n        dfs(0, 0, 0);\\n        return ans;\\n    }\\n    \\n    private List<String> ans;\\n    private int m;\\n    \\n    private void dfs(int pos, int open, int seq) {\\n        if (pos == m) {\\n            StringBuilder res = new StringBuilder();\\n            for (int i = 0; i < m; i++)\\n                res.append((seq & 1 << i) > 0 ? \"(\" : \")\");\\n            ans.add(res.toString());\\n            return;\\n        }\\n        if (open > 0) dfs(pos+1, open-1, seq);\\n        if (m - pos > open) dfs(pos+1, open+1, seq | 1 << pos);\\n    }\\n}\\n```\\n\\n---\\n\\n#### ***C++ Code:***\\n\\nThe best result for the code below is **0ms / 13.7MB** (beats 100% / 57%).\\n```c++\\nclass Solution {\\npublic:\\n    vector<string> generateParenthesis(int N) {\\n        m = 2 * N;\\n        dfs(0, 0, 0);\\n        return ans;\\n    }\\n    \\nprivate:\\n    vector<string> ans;\\n    int m;\\n    \\n    void dfs(int pos, int open, int seq) {\\n        if (pos == m) {\\n            string res = \"\";\\n            for (int i = 0; i < m; i++)\\n                res += seq & 1 << i ? \"(\" : \")\";\\n            ans.push_back(res);\\n            return;\\n        }\\n        if (open) dfs(pos+1, open-1, seq);\\n        if (m - pos > open) dfs(pos+1, open+1, seq | 1 << pos);\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```javascript\\nvar generateParenthesis = function(N) {\\n    let ans = [], m = 2 * N\\n    \\n    const dfs = (pos, open, seq) => {\\n        if (pos === m) {\\n            let res = new Array(m)\\n            for (let i = 0; i < m; i++)\\n                res[i] = seq & 1 << i ? \"(\" : \")\"\\n            ans.push(res.join(\"\"))\\n            return\\n        }\\n        if (open) dfs(pos+1, open-1, seq)\\n        if (m - pos > open) dfs(pos+1, open+1, seq | 1 << pos)\\n    }\\n    \\n    dfs(0, 0, 0)\\n    return ans\\n};\\n```\n```python\\nclass Solution:\\n    def generateParenthesis(self, N: int) -> List[str]:\\n        ans, m = [], 2 * N\\n        \\n        def dfs(pos: int, opn: int, seq: int) -> None:\\n            if pos == m:\\n                res = [0] * m\\n                for i in range(m):\\n                    res[i] = \"(\" if seq & 1 << i else \")\"\\n                ans.append(\"\".join(res))\\n                return\\n            if opn: dfs(pos+1, opn-1, seq)\\n            if m - pos > opn: dfs(pos+1, opn+1, seq | 1 << pos)\\n            \\n        dfs(0, 0, 0)\\n        return ans\\n```\n```java\\nclass Solution {\\n    public List<String> generateParenthesis(int N) {\\n        ans = new ArrayList<>();\\n        m = 2 * N;\\n        dfs(0, 0, 0);\\n        return ans;\\n    }\\n    \\n    private List<String> ans;\\n    private int m;\\n    \\n    private void dfs(int pos, int open, int seq) {\\n        if (pos == m) {\\n            StringBuilder res = new StringBuilder();\\n            for (int i = 0; i < m; i++)\\n                res.append((seq & 1 << i) > 0 ? \"(\" : \")\");\\n            ans.add(res.toString());\\n            return;\\n        }\\n        if (open > 0) dfs(pos+1, open-1, seq);\\n        if (m - pos > open) dfs(pos+1, open+1, seq | 1 << pos);\\n    }\\n}\\n```\n```c++\\nclass Solution {\\npublic:\\n    vector<string> generateParenthesis(int N) {\\n        m = 2 * N;\\n        dfs(0, 0, 0);\\n        return ans;\\n    }\\n    \\nprivate:\\n    vector<string> ans;\\n    int m;\\n    \\n    void dfs(int pos, int open, int seq) {\\n        if (pos == m) {\\n            string res = \"\";\\n            for (int i = 0; i < m; i++)\\n                res += seq & 1 << i ? \"(\" : \")\";\\n            ans.push_back(res);\\n            return;\\n        }\\n        if (open) dfs(pos+1, open-1, seq);\\n        if (m - pos > open) dfs(pos+1, open+1, seq | 1 << pos);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 942530,
                "title": "from-naive-solution-to-optimal-using-dfs",
                "content": "To start, I wanted to use DFS to generate all combinations of parentheses, and then validate them after. Note for the DFS part, this does not generate **vaild parentheses**, just all combinations. Using DFS is pretty easy to generate them here.\\n\\n```\\n/**\\n * @param {number} n\\n * @return {string[]}\\n */\\nvar generateParenthesis = function(n) {\\n    let res = [];\\n    const dfs = (str, n) => {\\n        if(n == 0) {\\n            res.push(str);\\n            return;\\n        }\\n        dfs(str+\"(\", n-1)\\n        dfs(str+\")\", n-1)\\n    }\\n    dfs(\"\", 2*n)\\n\\t// validate the combinations in the res array\\n    \\n    // ... some code to validate them, remove those that are invalid. \\n    // the solution to https://leetcode.com/problems/valid-parentheses/\\n\\n    // res contains valid combinations now\\n    return res\\n};\\n```\\n\\nWhile this is ok, we can do better. I started to think about the graph that was being genearted by DFS and where I could reduce further recursive calls and found some \\'base\\' cases.\\n\\n![image](https://assets.leetcode.com/users/images/563022d4-95f3-48d8-b30f-f81e5033a244_1605860755.9753644.png)\\n\\nWith this, I knew I could cut down on recursive calls for DFS with better base cases, esentially checking for the valid combinations as I generate them. I needed to translate my base cases into code.\\n\\nBefore, I was using `n` as my depth in DFS, terminating if n reached 0. I knew that the depth was correct for `n`, but I realized that I could keep better track of the number of `(` and `)` by using `n` for `(` and for `)` yeilding the same `2*n` I was using before. We can use those to track how many `(` and `)` have been used in any given call.\\n\\nKnowing this, I was able to translate my 2 additional base cases here, given that I can track the number of `(` and `)` current in use. For the left sub tree, since Its always possible to open with `(` the base case was to stop if the number of `(` exceeded 3. For the right sub tree, if there are more `)` than there currently are `(`, then it would not be possible to have a valid combination from this branch.\\n\\nWith this, we can write optimal code that validates combinations while using DFS\\n\\n```\\n/**\\n * @param {number} n\\n * @return {string[]}\\n */\\nvar generateParenthesis = function(n) {\\n    let res = [];\\n    const dfs = (str, left, right) => {\\n        if(left === 0 && right === 0) {\\n            res.push(str);\\n            return;\\n        }\\n        if(right < left) return\\n        if(left < 0) return\\n        dfs(str+\"(\", left - 1, right)\\n        dfs(str+\")\", left, right - 1)\\n    }\\n    dfs(\"\", n, n)\\n    return res\\n};\\n",
                "solutionTags": [
                    "JavaScript",
                    "Depth-First Search"
                ],
                "code": "```\\n/**\\n * @param {number} n\\n * @return {string[]}\\n */\\nvar generateParenthesis = function(n) {\\n    let res = [];\\n    const dfs = (str, n) => {\\n        if(n == 0) {\\n            res.push(str);\\n            return;\\n        }\\n        dfs(str+\"(\", n-1)\\n        dfs(str+\")\", n-1)\\n    }\\n    dfs(\"\", 2*n)\\n\\t// validate the combinations in the res array\\n    \\n    // ... some code to validate them, remove those that are invalid. \\n    // the solution to https://leetcode.com/problems/valid-parentheses/\\n\\n    // res contains valid combinations now\\n    return res\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 925723,
                "title": "rust-backtracking-solution",
                "content": "Runtime: 0 ms, faster than 100.00% of Rust online submissions for Generate Parentheses.\\nMemory Usage: 2.4 MB, less than 100.00% of Rust online submissions for Generate Parentheses.\\n```\\nimpl Solution {\\n    pub fn generate_parenthesis(n: i32) -> Vec<String> {\\n        fn back_track(s: String, open: i32, close: i32) -> Vec<String> {\\n            let mut res = vec![];\\n            if open == 0 && close == 0 {\\n                return vec![s];\\n            }\\n            if open > 0 {\\n                res.append(&mut back_track(s.clone()+\"(\", open-1, close+1));\\n            }\\n            if close > 0 {\\n                res.append(&mut back_track(s.clone()+\")\", open, close-1));\\n            }\\n            res\\n        }\\n        back_track(\"\".to_string(), n, 0)\\n    }\\n}\\n```",
                "solutionTags": [
                    "Rust"
                ],
                "code": "```\\nimpl Solution {\\n    pub fn generate_parenthesis(n: i32) -> Vec<String> {\\n        fn back_track(s: String, open: i32, close: i32) -> Vec<String> {\\n            let mut res = vec![];\\n            if open == 0 && close == 0 {\\n                return vec![s];\\n            }\\n            if open > 0 {\\n                res.append(&mut back_track(s.clone()+\"(\", open-1, close+1));\\n            }\\n            if close > 0 {\\n                res.append(&mut back_track(s.clone()+\")\", open, close-1));\\n            }\\n            res\\n        }\\n        back_track(\"\".to_string(), n, 0)\\n    }\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 10296,
                "title": "share-my-c-solution-easy-to-understand",
                "content": "    class Solution {\\n    public:\\n        vector<string> generateParenthesis(int n) {\\n            vector<string> ret;\\n            string s = \"\";\\n            if (n <= 0)\\n                return ret;\\n                \\n            recurParenthesis(n, n, ret, s);\\n        }\\n        \\n        void recurParenthesis(int leftNum, int rightNum, vector<string> &ret, string temp)\\n        {\\n            //leftNum means the number of open parenthesis available,rightNum means the number of close parenthesis available\\n            if (leftNum == 0 && rightNum == 0)\\n            {\\n                ret.push_back(temp);\\n                return;\\n            }\\n                \\n            if (leftNum > 0)\\n                recurParenthesis(leftNum-1, rightNum, ret, temp+'(');\\n            \\n            if (rightNum > 0)\\n            {\\n                if (leftNum < rightNum)\\n                    recurParenthesis(leftNum, rightNum-1, ret, temp+')');\\n            }\\n        }\\n    };",
                "solutionTags": [
                    "C++"
                ],
                "code": "class Solution {\\n    public:\\n        vector<string> generateParenthesis(int n) {\\n            vector<string> ret;\\n            string s = \"\";\\n            if (n <= 0)\\n                return ret;\\n                \\n            recurParenthesis(n, n, ret, s);\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 3674015,
                "title": "cpp-solution-100-faster",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\ninitially we have number of open bracket is n and closed is also n.\\n\\nnow we can add \\'(\\' in the resultant string(i.e s) without any condition and Decrease the count for this and make the recursive call.\\n\\nbut to add \\')\\' in the resultant string there is a condition. the condition is  we can  add \\')\\'  only when the no of open bracket (i.e noOfOpenBracket) is less then the no of closed bracket\\n (i.e noOfCloseBracket) because all the closed bracket should make  pair with corresponding open bracket.\\n\\nmeans  for n=3 the string \"( ) ****)**** ( ( )\" is not valid beacuse  the 2nd closed bracket doesn\\'t have the corresponding open bracket before it\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    vector<string> ans;\\n    void workfunc(int noOfOpenBracket,int noOfCloseBracket,string s)\\n    {\\n        if(noOfOpenBracket==0 && noOfCloseBracket==0)\\n        {\\n            ans.push_back(s);\\n            return;\\n        }\\n        if(noOfOpenBracket<noOfCloseBracket)\\n        {\\n            workfunc(noOfOpenBracket,noOfCloseBracket-1,s+\\')\\');\\n        }\\n        if(noOfOpenBracket>0)\\n        workfunc(noOfOpenBracket-1,noOfCloseBracket,s+\\'(\\');\\n    }\\n    \\npublic:\\n    vector<string> generateParenthesis(int n) {\\n        workfunc(n,n,\"\");\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\n    vector<string> ans;\\n    void workfunc(int noOfOpenBracket,int noOfCloseBracket,string s)\\n    {\\n        if(noOfOpenBracket==0 && noOfCloseBracket==0)\\n        {\\n            ans.push_back(s);\\n            return;\\n        }\\n        if(noOfOpenBracket<noOfCloseBracket)\\n        {\\n            workfunc(noOfOpenBracket,noOfCloseBracket-1,s+\\')\\');\\n        }\\n        if(noOfOpenBracket>0)\\n        workfunc(noOfOpenBracket-1,noOfCloseBracket,s+\\'(\\');\\n    }\\n    \\npublic:\\n    vector<string> generateParenthesis(int n) {\\n        workfunc(n,n,\"\");\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1945298,
                "title": "java-backtracking-with-recursive-tree",
                "content": "**Steps**\\n\\n\\t\\t\\t\\u26ABMake a List ans to add valid strings.\\n\\t\\t\\t\\u26ABMake a recursive function for generating all the possible parentheses.\\n\\t\\t\\t\\u26ABif  String.lengh() == n*2, add the string to the ans list ans return.\\n\\n![image](https://assets.leetcode.com/users/images/b6ae94c1-f29b-46a0-9817-d07778b5b105_1649914093.6822052.jpeg)\\n\\n```\\n public List<String> generateParenthesis(int n) {\\n        ArrayList<String> ans = new ArrayList<>();\\n            bt(ans, \"\", 0, 0, n);\\n        return ans;\\n    }\\n    \\n    public void bt(ArrayList<String> ans, String p, int open, int close, int n){\\n        if(p.length() == n*2){\\n            ans.add(p);\\n            return;\\n        }\\n        \\n        if(open < n){\\n            bt(ans, p + \"(\", open + 1, close, n);\\n        }\\n        \\n        if(close < open){\\n            bt(ans, p + \")\", open, close + 1, n);\\n        }\\n    }\\n```\\n",
                "solutionTags": [
                    "Java",
                    "Backtracking",
                    "Recursion"
                ],
                "code": "```\\n public List<String> generateParenthesis(int n) {\\n        ArrayList<String> ans = new ArrayList<>();\\n            bt(ans, \"\", 0, 0, n);\\n        return ans;\\n    }\\n    \\n    public void bt(ArrayList<String> ans, String p, int open, int close, int n){\\n        if(p.length() == n*2){\\n            ans.add(p);\\n            return;\\n        }\\n        \\n        if(open < n){\\n            bt(ans, p + \"(\", open + 1, close, n);\\n        }\\n        \\n        if(close < open){\\n            bt(ans, p + \")\", open, close + 1, n);\\n        }\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1899635,
                "title": "100-fastest-swift-solution",
                "content": "```\\nclass Solution {\\n    func generateParenthesis(_ n: Int) -> [String] {\\n        var res: [String] = []\\n\\n\\n        func backtrack(_ path: [String], _ target: Int) {\\n            var path = path\\n            var count = 0\\n\\n            if path.count == n * 2 {\\n                var string = \"\"\\n                for s in path { string += s }\\n                res.append(string)\\n                return\\n            }\\n\\n            for c in path where c == \"(\" { count += 1 }\\n            for c in [\"(\", \")\"] {\\n                if (c == \"(\" && count >= n) || (c == \")\" && path.count - count >= count)  { continue }\\n                path.append(c)\\n                backtrack(path, target - 1)\\n                path.remove(at: path.count - 1)\\n            }\\n        }\\n\\n        backtrack([], n * 2)\\n        return res\\n    }\\n\\n}\\n```\\n\\nLet me know in comments if you have any doubts. I will be happy to answer.\\n\\nPlease upvote if you found the solution useful.",
                "solutionTags": [
                    "Swift"
                ],
                "code": "```\\nclass Solution {\\n    func generateParenthesis(_ n: Int) -> [String] {\\n        var res: [String] = []\\n\\n\\n        func backtrack(_ path: [String], _ target: Int) {\\n            var path = path\\n            var count = 0\\n\\n            if path.count == n * 2 {\\n                var string = \"\"\\n                for s in path { string += s }\\n                res.append(string)\\n                return\\n            }\\n\\n            for c in path where c == \"(\" { count += 1 }\\n            for c in [\"(\", \")\"] {\\n                if (c == \"(\" && count >= n) || (c == \")\" && path.count - count >= count)  { continue }\\n                path.append(c)\\n                backtrack(path, target - 1)\\n                path.remove(at: path.count - 1)\\n            }\\n        }\\n\\n        backtrack([], n * 2)\\n        return res\\n    }\\n\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1177483,
                "title": "dfs",
                "content": "**Recursive procedural helper**\\n```\\nclass Solution \\n{\\n    vector<string> out;\\n    \\n    void dfs(string s, int x, int y)\\n    {\\n        if(!y)  out.push_back(s);\\n        if(x)   dfs(s+\\'(\\', x-1, y);\\n        if(x<y) dfs(s+\\')\\', x,   y-1);\\n    }        \\npublic:\\n    vector<string> generateParenthesis(int n) \\n    {\\n        dfs(\"\"s, n, n);\\n        return out;\\n    }\\n};\\n```\\n![image](https://assets.leetcode.com/users/images/0c8c9134-caf3-4ff5-996b-4ad1c2e696de_1619440710.3991406.png)\\n",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nclass Solution \\n{\\n    vector<string> out;\\n    \\n    void dfs(string s, int x, int y)\\n    {\\n        if(!y)  out.push_back(s);\\n        if(x)   dfs(s+\\'(\\', x-1, y);\\n        if(x<y) dfs(s+\\')\\', x,   y-1);\\n    }        \\npublic:\\n    vector<string> generateParenthesis(int n) \\n    {\\n        dfs(\"\"s, n, n);\\n        return out;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1034005,
                "title": "python-6-approches-visuals-iterative-recursive-dfs-bfs",
                "content": "\\n------------------------------\\n**Approach 1 : Brute-force : Iterative DFS with an explicit stack**\\n- Generate all combinations (geerate recursive tree)\\n- Test each combo (aka path in the space-tree) to see if it\\'s valid -> If yes, add to results\\n- ---------------------------\\n\\n**Idea:**\\n![image](https://assets.leetcode.com/users/images/ef4dec06-d495-4650-a97a-538c63f0db54_1611524590.783094.png)\\n\\n\\n**Big-O:**\\n* **Time**: `O(2^2n) + (4n^2)` \\n\\n\\t* Explanation:\\n\\t\\t* DFS traversal of the space-tree takes `O(E+V)`\\n\\t\\t* space-tree is a binary tree => number of edges is constant and is equal 2 => `E = 2`\\n\\t\\t* `V = number of verticies = (number of paths(leaves) in the space-tree)  * (number of nodes along each path )`  -- See NOTE [1] - choosing and counting\\n\\t\\t* ` V = 2^(2n) * (2n)` for the main logic\\n\\t\\t* Helper is invoked only at the leaves\\n\\t\\t\\t* There are `2n` leaves\\n\\t\\t\\t* A single invokation of `isValid()` costs `O(2n)`\\n\\t\\t\\t* Total cost for helper => `2n*2n` => `4n^2`\\n\\t\\t\\n\\t\\t* Overall big-O main: `O(2^2n)` + helper: `(4n^2)` \\n\\t\\t* **NOTE [1]**\\n\\t\\t![image](https://assets.leetcode.com/users/images/cc712e5e-c3a9-4d59-a7e2-7183d33d50bd_1611524625.0196075.png)\\n\\n\\t\\t\\n* **Space**:  `O(2n)`\\n\\t* Explanation: \\n\\t\\t* Stack contains max of 2n nodes at any given time => thus\\n\\n**Code:**\\n```\\ndef generateParenthesis(self, n: int) -> List[str]:\\n\\n\\t# ---- helper to check validity ----\\n\\t# Big-O: O(2n) \\n\\t# this isValid function needs to have the complete path/combination as an input in order to check validity\\n\\tdef isValid(combo):\\n\\t\\tstack = []\\n\\t\\tfor br in combo:\\n\\t\\t\\tif stack:\\n\\t\\t\\t\\tprev = stack[-1]\\n\\t\\t\\t\\tif prev == \"(\" and br == \")\":\\n\\t\\t\\t\\t\\tstack.pop()\\n\\t\\t\\t\\telse:\\n\\t\\t\\t\\t\\tstack.append(br)\\n\\t\\t\\telse:\\n\\t\\t\\t\\tstack.append(br)\\n\\t\\tif not stack: # brackets have canceled each other out (aka balanced)\\n\\t\\t\\treturn True\\n\\t\\treturn False\\n\\n\\t# ---- main logic -----\\n\\tif not n:\\n\\t\\treturn []\\n\\tres = []\\n\\tstack = [(n*2, \"\")]\\n\\twhile stack:\\n\\t\\tbrackets, path = stack.pop()\\n\\t\\t# print(brackets, path)\\n\\t\\tif not brackets:\\n\\t\\t\\tif isValid(path):\\n\\t\\t\\t\\tres.append(path)\\n\\t\\telse:\\n\\t\\t\\t# decrement number od brackets by 1\\n\\t\\t\\t# stack the two options\\n\\t\\t\\tstack.append((brackets-1, path+\")\"))\\n\\t\\t\\tstack.append((brackets-1, path+\"(\"))  \\n\\treturn res\\n```\\n\\n------------------------------\\n**Approach 2 : Brute-force : Iterative BFS with an queue**\\n- Generate all combinations (geerate recursive tree)\\n- Test each combo (aka path in the space-tree) to see if it\\'s valid -> If yes, add to results\\n- ---------------------------\\n**Idea:**\\n* Exactly the same idea as in `Approach 1` except the traversal is BFS using a queue\\n\\n**Big-O:**\\n* Time: `O(2^2n) + (4n^2)` \\n* Space:  `O(2n)`\\n\\n**Code:**\\n```\\ndef generateParenthesis(self, n: int) -> List[str]:\\n\\n\\t# ---- helper to check validity ----\\n\\t# Big-O: O(2n) \\n\\t# this isValid function needs to have the complete path/combination as an input in order to check validity\\n\\tdef isValid(combo):\\n\\t\\tstack = []\\n\\t\\tfor br in combo:\\n\\t\\t\\tif stack:\\n\\t\\t\\t\\tprev = stack[-1]\\n\\t\\t\\t\\tif prev == \"(\" and br == \")\":\\n\\t\\t\\t\\t\\tstack.pop()\\n\\t\\t\\t\\telse:\\n\\t\\t\\t\\t\\tstack.append(br)\\n\\t\\t\\telse:\\n\\t\\t\\t\\tstack.append(br)\\n\\t\\tif not stack: # brackets have canceled each other out (aka balanced)\\n\\t\\t\\treturn True\\n\\t\\treturn False\\n\\n\\t# ---- main logic -----\\n\\tif not n:\\n\\t\\treturn []\\n\\tres = []\\n\\tfrom collections import deque\\n\\tq = deque()\\n\\tq.append((n*2, \"\"))\\n\\twhile q:\\n\\t\\tbrackets, path = q.popleft()\\n\\t\\tif not brackets:\\n\\t\\t\\tif isValid(path):\\n\\t\\t\\t\\tres.append(path)\\n\\t\\telse:\\n\\t\\t\\t# decrement number od brackets by 1\\n\\t\\t\\t# stack the two options\\n\\t\\t\\tq.append((brackets-1, path+\"(\")) \\n\\t\\t\\tq.append((brackets-1, path+\")\"))\\t\\n\\treturn res\\n```\\n------------------------------\\n**Approach 3 : Brute-force : Recursive : Implicit Stack**\\n- Generate all combinations (geerate recursive tree)\\n- Test each combo (aka path in the space-tree) to see if it\\'s valid -> If yes, add to results\\n- ---------------------------\\n\\n**Idea:**\\n* Exactly the same idea as in `Approach 1` except the traversal is done recursively using an implicit stack\\n\\n**Big-O:**\\n* Time: `O(2^2n) + (4n^2)` \\n* Space: `O(2n)` - length of `path`\\n\\n**Code:**\\n\\n```\\ndef generateParenthesis(self, n: int) -> List[str]:\\n\\t\\t# isValid helper:\\n        def isValid(combo):\\n            stack = []\\n            for br in combo:\\n                if stack:\\n                    prev = stack[-1]\\n                    if prev == \"(\" and br == \")\":\\n                        stack.pop()\\n                    else:\\n                        stack.append(br)\\n                else:\\n                    stack.append(br)\\n            if not stack:\\n                return True\\n            return False\\n        \\n        # recursive helper\\n        def recursive(n, path=\"\", res=[]):\\n            if not n:\\n                if isValid(path):\\n                    res.append(path)\\n            else:\\n                recursive(n-1, path+\"(\", res)\\n                recursive(n-1, path+\")\", res)\\n                \\n            return res\\n            \\n        # main\\n        return recursive(2*n, \"\", [])\\n```\\n\\n\\n------------------------------\\n**Approach 4 : Prune and Search : Discard path As Soon As Possible : Iterative DFS with explicit stack** \\n- ---------------------------\\n**Idea:**\\n![image](https://assets.leetcode.com/users/images/2714606e-9558-48b9-a322-70702a0cb8e6_1611544722.8530722.png)\\n\\n* Don\\'t wait until an entrie combination/path is fully generated only to discard it at the end if proves to be invalid\\n* Instead, only generate comboniations that we know are valid and prune the ones that are invalid\\n\\t* \\tEverytime we add a bracket -> decrement n \\n\\t* \\tOnly add open bracket if open < n\\n\\t* \\tOny add close-bracket if does not exceed number of open-bracket\\n\\t* \\tn here is half the combo/path (aka number of pairs)\\n\\n* **This is Prunning, not backtracking**\\n\\t* For some reason, Leetcode posts insist on using the term \"backtracking\" when describing anything related to a recursive algorithm.\\n\\t* Backtracking is when you have to remove/delete a previous step to reach an earlier state of a solution. Period.\\n\\n**Big-O:**\\n* Time: `<` `O(2^2n * 2n)` - Since many branches will be pruned\\n* Space: `O(2n)` - size of the explicit stack (or, length of `path`)\\n\\n**Code:**\\n```\\ndef generateParenthesis(self, n: int) -> List[str]:\\n\\tif not n:\\n\\t\\treturn []\\n\\tres = []\\n\\t\\tstack = [(2*n,\"\", 0, 0)] # since out isValid function onlu needs to operate on the basis of (num of pairs / aka half the path) - as opposed to approach 2\\n\\n\\twhile stack:\\n\\t\\tbrackets, path, closeBr, openBr = stack.pop()\\n\\t\\tif not brackets:\\n\\t\\t\\tres.append(path)\\n\\n\\t\\telse:\\n\\t\\t\\tif closeBr < openBr:\\n\\t\\t\\t\\tstack.append((brackets-1, path + \")\", closeBr+1, openBr))\\n\\n\\t\\t\\tif openBr < n: # -- SEE NOTE [2]\\n\\t\\t\\t\\tstack.append((brackets-1, path + \"(\", closeBr, openBr+1))\\n\\n\\treturn res\\n```\\n\\n------------------------------\\n**Approach 5 : Prune and Search : Discard path As Soon As Possible : Iterative BFS with queue** \\n- ---------------------------\\n\\n**Idea:**\\n\\n**Big-O:**\\n* Time: `<` `O(2^2n * 2n)` - Since many branches will be pruned\\n* Space: `O(2n)` - size of the queue (or, length of `path`)\\n\\n**Code:**\\n```\\ndef generateParenthesis(self, n: int) -> List[str]:\\n\\tif not n:\\n\\t\\treturn []\\n\\tres = []\\n\\tfrom collections import deque\\n\\tq = deque()\\n\\tq.append((2*n,\"\", 0, 0)) \\n\\nwhile q:\\n\\tbrackets, path, closeBr, openBr = q.popleft()\\n\\tif not brackets:\\n\\t\\tres.append(path)\\n\\n\\telse:\\n\\t\\tif closeBr < openBr:\\n\\t\\t\\tq.append((brackets-1, path + \")\", closeBr+1, openBr))\\n\\n\\t\\tif openBr < n: # -- SEE NOTE [2]\\n\\t\\t\\tq.append((brackets-1, path + \"(\", closeBr, openBr+1))\\n\\nreturn res\\n```\\n\\n------------------------------\\n**Approach 6 : Prune and Search : Discard path As Soon As Possible : Recursive DFS with Implicit Stack**\\n- ---------------------------\\n\\n**Idea:**\\n* Exactly like `Approach 4` except the traversal is done recursively using an implicit stack\\n\\n**Big-O:**\\n* Time: `<` `O(2^2n * 2n)` - Since many branches will be pruned\\n* Space: `O(2n)` - length of `path`\\n\\n**Code:**\\n```\\ndef generateParenthesis(self, n: int) -> List[str]:\\n\\t\\n\\t# --- recursive helper --- :\\n\\tdef recursive(brackets, path=\"\", res=[], left=0, right=0):\\n            # print(brackets, path, brackets//2, left, right)\\n            if not brackets:\\n                res.append(path)\\n            else:\\n                if right < left:\\n                    recursive(brackets-1, path+\")\", res, left, right+1)\\n                if left < n: # n should not be decremented as we decrement the number of brackets \\n                    recursive(brackets-1, path+\"(\", res, left+1, right)\\n                \\n            return res\\n        \\n\\t# --- main logic ---\\n\\treturn recursive(2*n, \"\", [], 0, 0)\\n```",
                "solutionTags": [
                    "Python",
                    "Depth-First Search",
                    "Breadth-First Search",
                    "Recursion",
                    "Queue",
                    "Iterator"
                ],
                "code": "```\\ndef generateParenthesis(self, n: int) -> List[str]:\\n\\n\\t# ---- helper to check validity ----\\n\\t# Big-O: O(2n) \\n\\t# this isValid function needs to have the complete path/combination as an input in order to check validity\\n\\tdef isValid(combo):\\n\\t\\tstack = []\\n\\t\\tfor br in combo:\\n\\t\\t\\tif stack:\\n\\t\\t\\t\\tprev = stack[-1]\\n\\t\\t\\t\\tif prev == \"(\" and br == \")\":\\n\\t\\t\\t\\t\\tstack.pop()\\n\\t\\t\\t\\telse:\\n\\t\\t\\t\\t\\tstack.append(br)\\n\\t\\t\\telse:\\n\\t\\t\\t\\tstack.append(br)\\n\\t\\tif not stack: # brackets have canceled each other out (aka balanced)\\n\\t\\t\\treturn True\\n\\t\\treturn False\\n\\n\\t# ---- main logic -----\\n\\tif not n:\\n\\t\\treturn []\\n\\tres = []\\n\\tstack = [(n*2, \"\")]\\n\\twhile stack:\\n\\t\\tbrackets, path = stack.pop()\\n\\t\\t# print(brackets, path)\\n\\t\\tif not brackets:\\n\\t\\t\\tif isValid(path):\\n\\t\\t\\t\\tres.append(path)\\n\\t\\telse:\\n\\t\\t\\t# decrement number od brackets by 1\\n\\t\\t\\t# stack the two options\\n\\t\\t\\tstack.append((brackets-1, path+\")\"))\\n\\t\\t\\tstack.append((brackets-1, path+\"(\"))  \\n\\treturn res\\n```\n```\\ndef generateParenthesis(self, n: int) -> List[str]:\\n\\n\\t# ---- helper to check validity ----\\n\\t# Big-O: O(2n) \\n\\t# this isValid function needs to have the complete path/combination as an input in order to check validity\\n\\tdef isValid(combo):\\n\\t\\tstack = []\\n\\t\\tfor br in combo:\\n\\t\\t\\tif stack:\\n\\t\\t\\t\\tprev = stack[-1]\\n\\t\\t\\t\\tif prev == \"(\" and br == \")\":\\n\\t\\t\\t\\t\\tstack.pop()\\n\\t\\t\\t\\telse:\\n\\t\\t\\t\\t\\tstack.append(br)\\n\\t\\t\\telse:\\n\\t\\t\\t\\tstack.append(br)\\n\\t\\tif not stack: # brackets have canceled each other out (aka balanced)\\n\\t\\t\\treturn True\\n\\t\\treturn False\\n\\n\\t# ---- main logic -----\\n\\tif not n:\\n\\t\\treturn []\\n\\tres = []\\n\\tfrom collections import deque\\n\\tq = deque()\\n\\tq.append((n*2, \"\"))\\n\\twhile q:\\n\\t\\tbrackets, path = q.popleft()\\n\\t\\tif not brackets:\\n\\t\\t\\tif isValid(path):\\n\\t\\t\\t\\tres.append(path)\\n\\t\\telse:\\n\\t\\t\\t# decrement number od brackets by 1\\n\\t\\t\\t# stack the two options\\n\\t\\t\\tq.append((brackets-1, path+\"(\")) \\n\\t\\t\\tq.append((brackets-1, path+\")\"))\\t\\n\\treturn res\\n```\n```\\ndef generateParenthesis(self, n: int) -> List[str]:\\n\\t\\t# isValid helper:\\n        def isValid(combo):\\n            stack = []\\n            for br in combo:\\n                if stack:\\n                    prev = stack[-1]\\n                    if prev == \"(\" and br == \")\":\\n                        stack.pop()\\n                    else:\\n                        stack.append(br)\\n                else:\\n                    stack.append(br)\\n            if not stack:\\n                return True\\n            return False\\n        \\n        # recursive helper\\n        def recursive(n, path=\"\", res=[]):\\n            if not n:\\n                if isValid(path):\\n                    res.append(path)\\n            else:\\n                recursive(n-1, path+\"(\", res)\\n                recursive(n-1, path+\")\", res)\\n                \\n            return res\\n            \\n        # main\\n        return recursive(2*n, \"\", [])\\n```\n```\\ndef generateParenthesis(self, n: int) -> List[str]:\\n\\tif not n:\\n\\t\\treturn []\\n\\tres = []\\n\\t\\tstack = [(2*n,\"\", 0, 0)] # since out isValid function onlu needs to operate on the basis of (num of pairs / aka half the path) - as opposed to approach 2\\n\\n\\twhile stack:\\n\\t\\tbrackets, path, closeBr, openBr = stack.pop()\\n\\t\\tif not brackets:\\n\\t\\t\\tres.append(path)\\n\\n\\t\\telse:\\n\\t\\t\\tif closeBr < openBr:\\n\\t\\t\\t\\tstack.append((brackets-1, path + \")\", closeBr+1, openBr))\\n\\n\\t\\t\\tif openBr < n: # -- SEE NOTE [2]\\n\\t\\t\\t\\tstack.append((brackets-1, path + \"(\", closeBr, openBr+1))\\n\\n\\treturn res\\n```\n```\\ndef generateParenthesis(self, n: int) -> List[str]:\\n\\tif not n:\\n\\t\\treturn []\\n\\tres = []\\n\\tfrom collections import deque\\n\\tq = deque()\\n\\tq.append((2*n,\"\", 0, 0)) \\n\\nwhile q:\\n\\tbrackets, path, closeBr, openBr = q.popleft()\\n\\tif not brackets:\\n\\t\\tres.append(path)\\n\\n\\telse:\\n\\t\\tif closeBr < openBr:\\n\\t\\t\\tq.append((brackets-1, path + \")\", closeBr+1, openBr))\\n\\n\\t\\tif openBr < n: # -- SEE NOTE [2]\\n\\t\\t\\tq.append((brackets-1, path + \"(\", closeBr, openBr+1))\\n\\nreturn res\\n```\n```\\ndef generateParenthesis(self, n: int) -> List[str]:\\n\\t\\n\\t# --- recursive helper --- :\\n\\tdef recursive(brackets, path=\"\", res=[], left=0, right=0):\\n            # print(brackets, path, brackets//2, left, right)\\n            if not brackets:\\n                res.append(path)\\n            else:\\n                if right < left:\\n                    recursive(brackets-1, path+\")\", res, left, right+1)\\n                if left < n: # n should not be decremented as we decrement the number of brackets \\n                    recursive(brackets-1, path+\"(\", res, left+1, right)\\n                \\n            return res\\n        \\n\\t# --- main logic ---\\n\\treturn recursive(2*n, \"\", [], 0, 0)\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 817715,
                "title": "easy-optimized-concise-and-faster-than-100-00-of-c-submissions",
                "content": "simple backtracking :\\n\\njust adding one by one opening and closing by generating all the combinations\\n\\nif (cur.size()==2*max )   :  we got one combination completely \\n\\n\\n```\\nvector<string> generateParenthesis(int n) {\\n\\n        vector<string> v;  \\n        ok(v,\"\",0,0,n);\\n        return v;\\n\\t\\t\\n    }\\n    \\n    void ok(vector<string> &v,string cur,int open,int close,int max)\\n    {\\n        if(cur.size()==max*2) // we got the complete combination\\n        {\\n            v.push_back(cur);\\n            return ;\\n        }\\n        \\n        if(open<max) ok(v,cur+\\'(\\',open+1,close,max);     // add opening\\n        if(close<open) ok (v,cur+\\')\\',open,close+1,max);  //add closing\\n        \\n    }",
                "solutionTags": [],
                "code": "simple backtracking :\\n\\njust adding one by one opening and closing by generating all the combinations\\n\\nif (cur.size()==2*max )   :  we got one combination completely \\n\\n\\n```\\nvector<string> generateParenthesis(int n) {\\n\\n        vector<string> v;  \\n        ok(v,\"\",0,0,n);\\n        return v;\\n\\t\\t\\n    }\\n    \\n    void ok(vector<string> &v,string cur,int open,int close,int max)\\n    {\\n        if(cur.size()==max*2) // we got the complete combination\\n        {\\n            v.push_back(cur);\\n            return ;\\n        }\\n        \\n        if(open<max) ok(v,cur+\\'(\\',open+1,close,max);     // add opening\\n        if(close<open) ok (v,cur+\\')\\',open,close+1,max);  //add closing\\n        \\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 10351,
                "title": "1-ms-beats-92-of-submissions-easy-java-space-optimized-solution",
                "content": "    public List<String> generateParenthesis(int n) {\\n        List<String> res = new ArrayList<>();\\n        char[] perm = new char[n*2];\\n        perms(n, n, perm, 0, res);\\n        return res;\\n    }\\n    \\n    private void perms(int open, int close, char[] perm, int i, List<String> res) {\\n        if (i == perm.length) {\\n            res.add(new String(perm));\\n            return;\\n        }\\n        if (open > 0 && close >= open) {\\n            perm[i] = '(';\\n            perms(open - 1, close, perm, i+1, res);\\n        }\\n        if (close > 0) {\\n            perm[i] = ')';\\n            perms(open, close - 1, perm, i+1, res);\\n        }\\n    }",
                "solutionTags": [],
                "code": "    public List<String> generateParenthesis(int n) {\\n        List<String> res = new ArrayList<>();\\n        char[] perm = new char[n*2];\\n        perms(n, n, perm, 0, res);\\n        return res;\\n    }\\n    \\n    private void perms(int open, int close, char[] perm, int i, List<String> res) {\\n        if (i == perm.length) {\\n            res.add(new String(perm));\\n            return;\\n        }\\n        if (open > 0 && close >= open) {\\n            perm[i] = '(';\\n            perms(open - 1, close, perm, i+1, res);\\n        }\\n        if (close > 0) {\\n            perm[i] = ')';\\n            perms(open, close - 1, perm, i+1, res);\\n        }\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 10393,
                "title": "7-lines-in-python-44-ms",
                "content": "n - how many parenthesis can still be opened\\nopen - how many parenthesis are opened\\n\\n    class Solution:\\n        def generateParenthesis(self, n, open=0):\\n            if n == 0: return [')'*open]\\n            if open == 0:\\n                return ['('+x for x in self.generateParenthesis(n-1, 1)]\\n            else:\\n                return [')'+x for x in self.generateParenthesis(n, open-1)] + ['('+x for x in self.generateParenthesis(n-1, open+1)]",
                "solutionTags": [],
                "code": "n - how many parenthesis can still be opened\\nopen - how many parenthesis are opened\\n\\n    class Solution:\\n        def generateParenthesis(self, n, open=0):\\n            if n == 0: return [')'*open]\\n            if open == 0:\\n                return ['('+x for x in self.generateParenthesis(n-1, 1)]\\n            else:\\n                return [')'+x for x in self.generateParenthesis(n, open-1)] + ['('+x for x in self.generateParenthesis(n-1, open+1)]",
                "codeTag": "Java"
            },
            {
                "id": 10198,
                "title": "does-anyone-come-up-with-a-non-recursion-solution",
                "content": "I used recursion as below:\\n\\n    class Solution:\\n    \\n        def generateParenthesis(self, n):\\n            if (n == 0):\\n                return []\\n            string = \"(\"\\n            result = []\\n            left_number = 1\\n            right_number = 0\\n            self.solve(left_number, right_number, string, n, result)\\n            return result\\n            \\n        def solve(self, l_n, r_n, string, n, result):\\n            if (l_n == r_n and r_n == n):\\n                result.append(string)\\n                return\\n            \\n            if (l_n < n):\\n                self.solve(l_n+1, r_n, string+'(', n, result)\\n                \\n            if (r_n < l_n):\\n                self.solve(l_n, r_n+1, string+')', n, result)\\n\\nI am trying to get an iteration solution but haven't got a clue yet.",
                "solutionTags": [],
                "code": "I used recursion as below:\\n\\n    class Solution:\\n    \\n        def generateParenthesis(self, n):\\n            if (n == 0):\\n                return []\\n            string = \"(\"\\n            result = []\\n            left_number = 1\\n            right_number = 0\\n            self.solve(left_number, right_number, string, n, result)\\n            return result\\n            \\n        def solve(self, l_n, r_n, string, n, result):\\n            if (l_n == r_n and r_n == n):\\n                result.append(string)\\n                return\\n            \\n            if (l_n < n):\\n                self.solve(l_n+1, r_n, string+'(', n, result)\\n                \\n            if (r_n < l_n):\\n                self.solve(l_n, r_n+1, string+')', n, result)\\n\\nI am trying to get an iteration solution but haven't got a clue yet.",
                "codeTag": "Java"
            },
            {
                "id": 2422357,
                "title": "everything-explained-using-comment-backtracking-recursion-c-java",
                "content": "```\\n// STEPS TO SOLVE THE PROBLEM:\\n\\n// Create a vector that will store the result.\\n// Call our backtracking function with empty string and initial number of opening and closing parentheses.\\n// Check the base case. If number of opening and closing parentheses are equal to n then we will add the string to the vector and return.\\n// If the base case does not meet then we will check if number of opening parentheses is less than n, If true, then we will add ( to the current string and increment the count of opening parenthesis.\\n// Check if number of closing parentheses is less than open parentheses then we will add ) to the current string and increment the count of closing parentheses.\\n\\n\\n// C++ Solution:\\nclass Solution {\\npublic:\\n    vector<string> generateParenthesis(int n) {\\n        \\n        // Resultant vector\\n        vector<string> ans; \\n        /// Recursively generate parentheses\\n        generateParenthesis(ans, \"\", 0, 0, n);\\n        return ans;\\n    }\\nprivate:\\n    void generateParenthesis(vector<string> &ans,string s,int open, int close,int n){\\n    // Base case\\n        if (open == n && close == n) {\\n            ans.push_back(s);\\n            return;\\n        }\\n        // If the number of open parentheses is less than the given n\\n        if (open < n) {\\n            generateParenthesis(ans, s + \"(\", open + 1, close, n);\\n        }\\n        // If we need more close parentheses to balance\\n        if (close < open) {\\n            generateParenthesis(ans, s + \")\", open, close + 1, n);\\n        }\\n    }\\n};\\n\\n\\n\\n// JAVA Solution:\\nclass Solution {\\n    public List<String> generateParenthesis(int n) {\\n        \\n        // Resultant list\\n        List<String> result = new ArrayList<>();\\n        \\n        /// Recursively generate parentheses\\n        generateParenthesis(result, \"\", 0, 0, n);\\n        \\n        return result;\\n    }\\n    private void generateParenthesis(List<String> result, String s, int open, int close, int n) {\\n        // Base case\\n        if (open == n && close == n) {\\n            result.add(s);\\n            return;\\n        }\\n        // If the number of open parentheses is less than the given n\\n        if (open < n) {\\n            generateParenthesis(result, s + \"(\", open + 1, close, n);\\n        }\\n        // If we need more close parentheses to balance\\n        if (close < open) {\\n            generateParenthesis(result, s + \")\", open, close + 1, n);\\n        }\\n    }\\n}\\n\\n\\n/* \\n\\tif(you like)\\n\\t\\tplease upvote;\\n*/\\n```",
                "solutionTags": [
                    "C++",
                    "Java",
                    "C",
                    "Backtracking",
                    "Recursion"
                ],
                "code": "```\\n// STEPS TO SOLVE THE PROBLEM:\\n\\n// Create a vector that will store the result.\\n// Call our backtracking function with empty string and initial number of opening and closing parentheses.\\n// Check the base case. If number of opening and closing parentheses are equal to n then we will add the string to the vector and return.\\n// If the base case does not meet then we will check if number of opening parentheses is less than n, If true, then we will add ( to the current string and increment the count of opening parenthesis.\\n// Check if number of closing parentheses is less than open parentheses then we will add ) to the current string and increment the count of closing parentheses.\\n\\n\\n// C++ Solution:\\nclass Solution {\\npublic:\\n    vector<string> generateParenthesis(int n) {\\n        \\n        // Resultant vector\\n        vector<string> ans; \\n        /// Recursively generate parentheses\\n        generateParenthesis(ans, \"\", 0, 0, n);\\n        return ans;\\n    }\\nprivate:\\n    void generateParenthesis(vector<string> &ans,string s,int open, int close,int n){\\n    // Base case\\n        if (open == n && close == n) {\\n            ans.push_back(s);\\n            return;\\n        }\\n        // If the number of open parentheses is less than the given n\\n        if (open < n) {\\n            generateParenthesis(ans, s + \"(\", open + 1, close, n);\\n        }\\n        // If we need more close parentheses to balance\\n        if (close < open) {\\n            generateParenthesis(ans, s + \")\", open, close + 1, n);\\n        }\\n    }\\n};\\n\\n\\n\\n// JAVA Solution:\\nclass Solution {\\n    public List<String> generateParenthesis(int n) {\\n        \\n        // Resultant list\\n        List<String> result = new ArrayList<>();\\n        \\n        /// Recursively generate parentheses\\n        generateParenthesis(result, \"\", 0, 0, n);\\n        \\n        return result;\\n    }\\n    private void generateParenthesis(List<String> result, String s, int open, int close, int n) {\\n        // Base case\\n        if (open == n && close == n) {\\n            result.add(s);\\n            return;\\n        }\\n        // If the number of open parentheses is less than the given n\\n        if (open < n) {\\n            generateParenthesis(result, s + \"(\", open + 1, close, n);\\n        }\\n        // If we need more close parentheses to balance\\n        if (close < open) {\\n            generateParenthesis(result, s + \")\", open, close + 1, n);\\n        }\\n    }\\n}\\n\\n\\n/* \\n\\tif(you like)\\n\\t\\tplease upvote;\\n*/\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1737086,
                "title": "backtracking-solution-with-explanations-in-c",
                "content": "> **If you\\u2019re interested in coding you can join my Discord Server, link in the comment section. Also if you find any mistake please let me know. Thank you!\\u2764\\uFE0F**\\n> \\n\\n---\\n\\n## Explanation:\\n\\n### Solution 01\\n\\n- Solve this using ***Backtracking***.\\n- We\\u2019ll have 2*n characters, including n open and n close bracket if it is a valid parenthesis.\\n- We\\u2019ll pass an empty string & open, close tag numbers left.\\n- Base condition: if both open & close equals 0, means we can\\u2019t add any more parenthesis.\\n- if **`open > 0`** means we can add an opening bracket, so add it and decrease its size by 1, **`help(s+\"(\", open-1, close)`.**\\n- if **`open < close`** means we already added 1 or more opening brackets, so now we can add closing one and decrease its size by 1, **`help(s+\")\", open, close-1)`.**\\n- **Time complexity:** O(n).\\n\\n---\\n\\n## Code:\\n\\n```cpp\\n//Solution 01:\\nclass Solution {\\npublic:\\n    vector<string>ans;\\n    vector<string>generateParenthesis(int n) {\\n        help(\"\",n,n);\\n        return ans;\\n    }\\n    void help(string s, int open, int close){\\n        if(open==0 && close==0){\\n            ans.push_back(s);\\n            return;\\n        }\\n        if(open > 0) help(s+\"(\", open-1, close);\\n        if(open < close) help(s+\")\", open, close-1);\\n    }\\n};\\n```\\n\\n---\\n\\n> **Please upvote this solution**\\n>",
                "solutionTags": [
                    "C++",
                    "C",
                    "Backtracking"
                ],
                "code": "```cpp\\n//Solution 01:\\nclass Solution {\\npublic:\\n    vector<string>ans;\\n    vector<string>generateParenthesis(int n) {\\n        help(\"\",n,n);\\n        return ans;\\n    }\\n    void help(string s, int open, int close){\\n        if(open==0 && close==0){\\n            ans.push_back(s);\\n            return;\\n        }\\n        if(open > 0) help(s+\"(\", open-1, close);\\n        if(open < close) help(s+\")\", open, close-1);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1276582,
                "title": "generate-parentheses-short-easy-solution-w-explanation-beats-100",
                "content": "\\u2714\\uFE0F ***Solution - I (Brute - Force)***\\n\\nWe have `n` pair of parenthesis which means we are required to form a valid parenthesis string of `length == 2*n`. Let\\'s start with the brute-force way. At each position of the string, we can insert **`(`** or **`)`** brackets and so we will try both the options. Atlast, when the length of string becomes `2*n`, we will perform a check and insert into `ans` array if it is valid.\\n\\n```\\nvector<string> ans;\\nvector<string> generateParenthesis(int n) {\\n\\tsolve(\"\", 2*n);\\n\\treturn ans;\\n}\\nvoid solve(string s, int N){\\n\\tif(size(s) == N){\\n\\t\\tif(valid(s)) ans.push_back(s);\\n\\t\\treturn;\\n\\t}\\n\\tsolve(s + \\'(\\', N);\\n\\tsolve(s + \\')\\', N);\\n}\\nbool valid(string& s, int diff = 0) {\\n\\tfor(auto& ch: s) {\\n\\t\\tdiff += (ch == \\'(\\' ? 1 : -1);\\n\\t\\tif(diff < 0) return false;\\n\\t}\\n\\treturn !diff;\\n}\\n```\\n\\n***Time Complexity :*** **<code>O(4<sup>n</sup> * n)</code>**, for each index in string, we try both the parenthesis which is <code>2`*`2`*`2...2n times = O(2<sup>2n</sup>) = O(4<sup>n</sup>) </code> and lastly, we spend an `O(n)` time to check for the formed string\\'s validity. \\n**Space Complexity :** **<code>O(4<sup>n</sup>)</code>** (A tighter bound exists)\\n\\n---\\n\\n\\u2714\\uFE0F ***Solution - II (Optimized Approach)***\\n\\nInstead of trying out both the brackets at each index of the string, we only try them at places which won\\'t outright invalidate the string. For eg. In the previous approach, we were trying to insert `)` even at the start which would surely not have generated a valid parenthesis. Here, we avoid that. We have 2 cases:\\n\\n* **`(`** can be inserted anywhere till its count is less than `n`\\n* **`)`** can be inserted whenever its count is less than `start` (number of openinig parenthesis)\\n\\nFinally, we will insert the string when its length reaches `2*n`.\\n\\n```\\nvector<string> generateParenthesis(int n) {\\n\\tvector<string> ans;\\n\\tsolve(0, 0, n, \"\", ans);\\n\\treturn ans;\\n}\\nvoid solve(int start, int close, int n, string s, vector<string>& ans) {\\n\\tif(size(s) == 2*n) ans.push_back(move(s));  // use move to directly push the constructed string into vector instead of creating a copy\\n\\tif(start < n) solve(start + 1, close, n, s + \\'(\\', ans);\\n\\tif(close < start) solve(start, close + 1, n, s + \\')\\', ans);\\n}\\n```\\n\\n***Time Complexity :*** **<code>O(4<sup>n</sup>)</code>** Here we save the time for string validation at the end and also avoid the extra recursive calls which we know are invalid anyway. \\n**Note**: There exists a tighter bound - <code>O(4<sup>n</sup> / &radic;n)</code>  but without deep analysis of the recursion structure, it\\'s very hard to arrive at it. So, <code>O(4<sup>n</sup>)</code> is good enough for quick estimations\\n**Space Complexity :** **<code>O(4<sup>n</sup>)</code>**, Tighter bound - **<code>O(4<sup>n</sup> / &radic;n)</code>**\\n\\n---\\n\\n*Best Runtime -*\\n\\n<table><tr><td><img src=https://assets.leetcode.com/users/images/001e3d19-b69f-4c1b-96c9-f760343aef54_1623844459.7738905.png  /></td></tr></table>\\n\\n\\n\\n---\\n---\\n\\n\\uD83D\\uDCBB\\uD83D\\uDC31\\u200D\\uD83D\\uDCBBIf there are any suggestions / questions / mistakes in my post, please do comment below \\uD83D\\uDC47 \\n\\n---\\n---",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nvector<string> ans;\\nvector<string> generateParenthesis(int n) {\\n\\tsolve(\"\", 2*n);\\n\\treturn ans;\\n}\\nvoid solve(string s, int N){\\n\\tif(size(s) == N){\\n\\t\\tif(valid(s)) ans.push_back(s);\\n\\t\\treturn;\\n\\t}\\n\\tsolve(s + \\'(\\', N);\\n\\tsolve(s + \\')\\', N);\\n}\\nbool valid(string& s, int diff = 0) {\\n\\tfor(auto& ch: s) {\\n\\t\\tdiff += (ch == \\'(\\' ? 1 : -1);\\n\\t\\tif(diff < 0) return false;\\n\\t}\\n\\treturn !diff;\\n}\\n```\n```\\nvector<string> generateParenthesis(int n) {\\n\\tvector<string> ans;\\n\\tsolve(0, 0, n, \"\", ans);\\n\\treturn ans;\\n}\\nvoid solve(int start, int close, int n, string s, vector<string>& ans) {\\n\\tif(size(s) == 2*n) ans.push_back(move(s));  // use move to directly push the constructed string into vector instead of creating a copy\\n\\tif(start < n) solve(start + 1, close, n, s + \\'(\\', ans);\\n\\tif(close < start) solve(start, close + 1, n, s + \\')\\', ans);\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 729851,
                "title": "no-backtracking-no-recursion-bfs-based-approach-with-explanation",
                "content": "```\\nclass Solution {\\npublic:\\n    vector<string> generateParenthesis(int n) {\\n        //pair of pair, <current_buffer,<open count,closed count>>\\n        queue<pair<string,pair<int,int>>>q;\\n        q.push({\"\",{0,0}});\\n        vector<string>ans;\\n        while(!q.empty())\\n        {\\n            pair<string,pair<int,int>>p = q.front();\\n            q.pop();\\n            //if count of both open and closed parenthesis count is n, we found one permutation, add it to ans;\\n            if(p.second.first==n&&p.second.second==n){\\n                ans.push_back(p.first);\\n            }\\n            else\\n            {\\n                //add open parenthesis if open parenthesis count<n;\\n                if(p.second.first<n){\\n                    q.push({p.first+\"(\",{p.second.first+1,p.second.second}});\\n                }\\n                // add closing parenthesis if closedparenthesis count < open parenthesis count  \\n                if(p.second.second<p.second.first){\\n                    q.push({p.first+\")\",{p.second.first,p.second.second+1}});\\n                }\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```\\nThumbs up if you like it. Thanks!",
                "solutionTags": [
                    "C++",
                    "Breadth-First Search"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<string> generateParenthesis(int n) {\\n        //pair of pair, <current_buffer,<open count,closed count>>\\n        queue<pair<string,pair<int,int>>>q;\\n        q.push({\"\",{0,0}});\\n        vector<string>ans;\\n        while(!q.empty())\\n        {\\n            pair<string,pair<int,int>>p = q.front();\\n            q.pop();\\n            //if count of both open and closed parenthesis count is n, we found one permutation, add it to ans;\\n            if(p.second.first==n&&p.second.second==n){\\n                ans.push_back(p.first);\\n            }\\n            else\\n            {\\n                //add open parenthesis if open parenthesis count<n;\\n                if(p.second.first<n){\\n                    q.push({p.first+\"(\",{p.second.first+1,p.second.second}});\\n                }\\n                // add closing parenthesis if closedparenthesis count < open parenthesis count  \\n                if(p.second.second<p.second.first){\\n                    q.push({p.first+\")\",{p.second.first,p.second.second+1}});\\n                }\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 248359,
                "title": "extremely-simple-java-dfs-beats-100",
                "content": "```\\nclass Solution {\\n    public List<String> generateParenthesis(int n) {\\n        List<String> output = new ArrayList<>();\\n        build(n, \"\", output, n, n);\\n        return output;\\n    }\\n    \\n    \\n    public void build(int n, String cur, List output, int left, int right) {\\n        if(left > right) return;\\n        \\n        if((left == 0 && right == 0)) {\\n            output.add(cur);\\n            return;\\n        }\\n        \\n        if(left > 0) {\\n            build(n, cur + \"(\", output, left - 1, right);\\n        }\\n        \\n        \\n        if(right > 0) {\\n            build(n, cur + \")\", output, left, right - 1);\\n        }\\n    }\\n}\\n``",
                "solutionTags": [
                    "Java",
                    "Backtracking",
                    "Depth-First Search"
                ],
                "code": "class Solution {\\n    public List<String> generateParenthesis(int n) {\\n        List<String> output = new ArrayList<>();\\n        build(n, \"\", output, n, n);\\n        return output;\\n    }",
                "codeTag": "Java"
            },
            {
                "id": 1471383,
                "title": "c-100-faster-than-others",
                "content": "**Please Upvote if like the Solution !**\\n\\n      vector<string> ans;\\n\\n    // Recursive function to generate valid parentheses combinations\\n     void Solve(int open, int close, string curr, int n) {\\n    // Base case: If the current combination\\'s length reaches 2*n, add it to the answer vector\\n    if (curr.size() == 2 * n) {\\n        ans.push_back(curr);\\n        return;\\n    }\\n    \\n    // If we can still add more opening parentheses, do so\\n    if (open < n) {\\n        Solve(open + 1, close, curr + \"(\", n);\\n    }\\n    \\n    // If we have more open parentheses than closing parentheses, add a closing parenthesis\\n    if (close < open) {\\n        Solve(open, close + 1, curr + \")\", n);\\n    }\\n    }\\n\\n    // Function to generate all valid combinations of parentheses\\n    vector<string> generateParenthesis(int n) {\\n    // Clear the answer vector and start generating combinations\\n    ans.clear();\\n    Solve(0, 0, \"\", n);\\n    return ans;\\n\\t}",
                "solutionTags": [
                    "C++",
                    "C",
                    "Backtracking",
                    "Recursion"
                ],
                "code": "**Please Upvote if like the Solution !**\\n\\n      vector<string> ans;\\n\\n    // Recursive function to generate valid parentheses combinations\\n     void Solve(int open, int close, string curr, int n) {\\n    // Base case: If the current combination\\'s length reaches 2*n, add it to the answer vector\\n    if (curr.size() == 2 * n) {\\n        ans.push_back(curr);\\n        return;\\n    }\\n    \\n    // If we can still add more opening parentheses, do so\\n    if (open < n) {\\n        Solve(open + 1, close, curr + \"(\", n);\\n    }\\n    \\n    // If we have more open parentheses than closing parentheses, add a closing parenthesis\\n    if (close < open) {\\n        Solve(open, close + 1, curr + \")\", n);\\n    }\\n    }\\n\\n    // Function to generate all valid combinations of parentheses\\n    vector<string> generateParenthesis(int n) {\\n    // Clear the answer vector and start generating combinations\\n    ans.clear();\\n    Solve(0, 0, \"\", n);\\n    return ans;\\n\\t}",
                "codeTag": "Unknown"
            },
            {
                "id": 1400055,
                "title": "generate-parentheses-java-recursive-solution",
                "content": "```\\nclass Solution {\\n    public List<String> generateParenthesis(int n) {\\n        List<String> output = new ArrayList<>();\\n        permutationBalancedParenthesis(n, n, \"\", output);\\n        return output;\\n    }\\n    \\n    public void permutationBalancedParenthesis(int open, int close, String balancedParentheses, List<String> output) {\\n        /* leaf node in recursive tree */\\n        if(open == 0 && close == 0){\\n            output.add(balancedParentheses);\\n            return;\\n        } \\n        \\n        /* If there is an opening bracket then it is always a choice */\\n        if(open > 0){\\n            String openingBracket = balancedParentheses + \"(\";\\n            permutationBalancedParenthesis(open - 1, close, openingBracket, output);\\n        } \\n        \\n        /* There must be an opening bracket previously, which is yet to be closed. */\\n        if(close > open){\\n            String closingBracket = balancedParentheses + \")\";\\n            permutationBalancedParenthesis(open, close - 1, closingBracket, output);\\n        }\\n    }\\n}\\n```\\n\\nIf it helped, please UPVOTE .\\nHappy Coding and keep up the good work :)",
                "solutionTags": [
                    "Java",
                    "Recursion"
                ],
                "code": "```\\nclass Solution {\\n    public List<String> generateParenthesis(int n) {\\n        List<String> output = new ArrayList<>();\\n        permutationBalancedParenthesis(n, n, \"\", output);\\n        return output;\\n    }\\n    \\n    public void permutationBalancedParenthesis(int open, int close, String balancedParentheses, List<String> output) {\\n        /* leaf node in recursive tree */\\n        if(open == 0 && close == 0){\\n            output.add(balancedParentheses);\\n            return;\\n        } \\n        \\n        /* If there is an opening bracket then it is always a choice */\\n        if(open > 0){\\n            String openingBracket = balancedParentheses + \"(\";\\n            permutationBalancedParenthesis(open - 1, close, openingBracket, output);\\n        } \\n        \\n        /* There must be an opening bracket previously, which is yet to be closed. */\\n        if(close > open){\\n            String closingBracket = balancedParentheses + \")\";\\n            permutationBalancedParenthesis(open, close - 1, closingBracket, output);\\n        }\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1368413,
                "title": "simple-python-backtracking",
                "content": "The idea is that we keep track of a \"sum\" for the current string as we build up towards a valid combination and we enforce \"add 1\" whenever we add a \"(\" and \"minus 1\" whenver we add a \")\". Clearly, with this design, we only need to make sure that 1) \"sum\" never goes to negative and 2)we are not using up available parenthesis to reach valid solution. \\n```\\ndef generateParenthesis(self, n: int) -> List[str]:\\n        ret=[]\\n        def dfs(s,r_l,r_r,cur):\\n            if s<0 or r_l<0 or r_r<0:\\n                return\\n            if r_l ==0 and r_r==0:\\n                ret.append(cur)\\n            dfs(s+1,r_l-1,r_r,cur+\\'(\\')\\n            dfs(s-1,r_l,r_r-1,cur+\\')\\')\\n        \\n        \\n        dfs(0,n,n,\\'\\')\\n        return ret\\n```",
                "solutionTags": [
                    "Python",
                    "Dynamic Programming"
                ],
                "code": "```\\ndef generateParenthesis(self, n: int) -> List[str]:\\n        ret=[]\\n        def dfs(s,r_l,r_r,cur):\\n            if s<0 or r_l<0 or r_r<0:\\n                return\\n            if r_l ==0 and r_r==0:\\n                ret.append(cur)\\n            dfs(s+1,r_l-1,r_r,cur+\\'(\\')\\n            dfs(s-1,r_l,r_r-1,cur+\\')\\')\\n        \\n        \\n        dfs(0,n,n,\\'\\')\\n        return ret\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 1181112,
                "title": "easy-to-understand-python-no-recursion",
                "content": "```\\n\"\"\"\\n. represents occurrence of () in new n\\nn = 1, () \\nn = 2, (.), (). = ()(), (())\\nn = 3, .()(), (.)(), ().(), ()(.), ()()., .(()), (.()), ((.)), (().), (()).\\n\\nAvoid duplicates by using a set\\n\"\"\"\\nclass Solution:\\n    def generateParenthesis(self, n: int) -> List[str]:\\n        if n == 1:\\n            return [\"()\"]\\n        syms = {\"()\"}\\n        for j in range(n-1):\\n            new_syms = set()\\n            for sym in syms:\\n                for i in range(len(sym)):\\n                    new_syms.add(sym[:i] + \"()\" + sym[i:])\\n            syms = new_syms\\n        return syms",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "class Solution:\\n    def generateParenthesis(self, n: int) -> List[str]:\\n        if n == 1:\\n            return [\"()\"]\\n        syms = {\"()\"}",
                "codeTag": "Java"
            },
            {
                "id": 304042,
                "title": "c-100-91-85-beats-using-c",
                "content": "Beated 100% / 91.85% (0ms / 7.8MB) of C submissions on runtime / memory.\\n\\nIn my solution, there\\'re two highlight points:\\n1. Calculate the returnsize precisely, in order to save memory.\\n1. Use bitwise operation to make my code a beautiful art.\\n\\nTip: I calculate the returnSize by finding the pattern among n=1,2,3,4,5... with the help of OEIS. You can find the integer sequent at here: https://oeis.org/A000108\\n\\nAnd Here\\'s my code:\\n\\n```\\nint size(int);\\n\\nchar ** generateParenthesis(int n, int* returnSize) {\\n    // Calculate the returnSize first for memory saving\\n    *returnSize = size(n);\\n    \\n    // Initiate the answer\\'s memory\\n    char** ans = (char**)malloc(sizeof(char*) * (*returnSize));\\n    memset(ans, 0, sizeof(char*) * (*returnSize));\\n    \\n    // [Explain about each Variable]\\n    // \"sum\" | Checking whether the present result is valide\\n    //\\n    //   \"i\" | Whether every digit is \\'(\\' or \\')\\'\\n    //       | \"i\" can be understood in binary way:\\n    //       | E.g. When n=2 and i=3, then i=0b0011\\n    //       |      Let\\'s define \\'(\\' as 1 and \\')\\' as 0, then:\\n    //       |      0b0011 reverse => 1 1 0 0\\n    //       |                        \\u2193 \\u2193 \\u2193 \\u2193\\n    //       |                        ( ( ) )\\n    //\\n    //   \"j\" | Searching in the sequence\\n    //\\n    //   \"k\" | Count the present index of answer string\\n    int sum, j, k = 0;\\n    \\n    for(int i = 0; i < (1 << (2 * n)); i++) {\\n        // Check Validity\\n        sum = 0;\\n        for(j = 0; j < 2 * n; j++) {\\n            sum += (i&(1<<j)) ? 1 : -1;\\n            if(sum < 0)\\n                break;\\n        }\\n        \\n        // If Valid then Output\\n        if(!sum) {\\n            ans[k] = (char*)malloc(sizeof(char) * 2 * n + 1);\\n            for(j = 0; j < 2 * n; j++)\\n                ans[k][j] = ((i&(1<<j)) ? \\'(\\' : \\')\\');\\n            ans[k][j] = 0;\\n            k++;\\n        }\\n    }\\n    \\n    return ans;\\n}\\n\\n// You can calculate the size by integer sequence A000108 on OEIS \\n// refrence to https://oeis.org/A000108\\nint size(int n) {\\n    int ans = 1;\\n    for(int i = 0; i < n; i++)\\n        ans *= (2 * n - i);\\n    for(int i = 0; i < n; i++)\\n        ans /= (n + 1 - i);\\n    return ans;\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nint size(int);\\n\\nchar ** generateParenthesis(int n, int* returnSize) {\\n    // Calculate the returnSize first for memory saving\\n    *returnSize = size(n);\\n    \\n    // Initiate the answer\\'s memory\\n    char** ans = (char**)malloc(sizeof(char*) * (*returnSize));\\n    memset(ans, 0, sizeof(char*) * (*returnSize));\\n    \\n    // [Explain about each Variable]\\n    // \"sum\" | Checking whether the present result is valide\\n    //\\n    //   \"i\" | Whether every digit is \\'(\\' or \\')\\'\\n    //       | \"i\" can be understood in binary way:\\n    //       | E.g. When n=2 and i=3, then i=0b0011\\n    //       |      Let\\'s define \\'(\\' as 1 and \\')\\' as 0, then:\\n    //       |      0b0011 reverse => 1 1 0 0\\n    //       |                        \\u2193 \\u2193 \\u2193 \\u2193\\n    //       |                        ( ( ) )\\n    //\\n    //   \"j\" | Searching in the sequence\\n    //\\n    //   \"k\" | Count the present index of answer string\\n    int sum, j, k = 0;\\n    \\n    for(int i = 0; i < (1 << (2 * n)); i++) {\\n        // Check Validity\\n        sum = 0;\\n        for(j = 0; j < 2 * n; j++) {\\n            sum += (i&(1<<j)) ? 1 : -1;\\n            if(sum < 0)\\n                break;\\n        }\\n        \\n        // If Valid then Output\\n        if(!sum) {\\n            ans[k] = (char*)malloc(sizeof(char) * 2 * n + 1);\\n            for(j = 0; j < 2 * n; j++)\\n                ans[k][j] = ((i&(1<<j)) ? \\'(\\' : \\')\\');\\n            ans[k][j] = 0;\\n            k++;\\n        }\\n    }\\n    \\n    return ans;\\n}\\n\\n// You can calculate the size by integer sequence A000108 on OEIS \\n// refrence to https://oeis.org/A000108\\nint size(int n) {\\n    int ans = 1;\\n    for(int i = 0; i < n; i++)\\n        ans *= (2 * n - i);\\n    for(int i = 0; i < n; i++)\\n        ans /= (n + 1 - i);\\n    return ans;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3116283,
                "title": "easily-understandable-solution-beats-99-30",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    void fnc(vector<string> &ans,int n,int open,int close,string curr_str){\\n        if(curr_str.size()==n*2){\\n            ans.push_back(curr_str);\\n            return;\\n        }\\n        if(open<n){\\n            fnc(ans,n,open+1,close,curr_str +\\'(\\');\\n        }\\n         if(close<open){\\n            fnc(ans,n,open,close+1,curr_str +\\')\\');\\n        }\\n    }\\npublic:\\n    vector<string> generateParenthesis(int n) {\\n        vector<string> ans;\\n        fnc(ans,n,0,0,\"\");\\n        return ans;\\n    }\\n};\\n```\\nPlease upvote to motivate me to write more solutions\\n\\n",
                "solutionTags": [
                    "C++",
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    void fnc(vector<string> &ans,int n,int open,int close,string curr_str){\\n        if(curr_str.size()==n*2){\\n            ans.push_back(curr_str);\\n            return;\\n        }\\n        if(open<n){\\n            fnc(ans,n,open+1,close,curr_str +\\'(\\');\\n        }\\n         if(close<open){\\n            fnc(ans,n,open,close+1,curr_str +\\')\\');\\n        }\\n    }\\npublic:\\n    vector<string> generateParenthesis(int n) {\\n        vector<string> ans;\\n        fnc(ans,n,0,0,\"\");\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3066382,
                "title": "99-72-javascript-very-easy-to-understand-solution-with-video-explanation",
                "content": "Here is video for explain if it is helpful please subscribe! :\\n\\nhttps://youtu.be/8sZI4b0tlkc\\n\\n# Code\\n```\\n/**\\n * @param {number} n\\n * @return {string[]}\\n */\\nvar generateParenthesis = function(n) {\\n    let res = []\\n\\n    let iterate = (str, open, close) =>{\\n        if(open > n || close >n || close >open) return;\\n        if(str.length == n *2 && open ==close){\\n            res.push(str)\\n            return;\\n        }\\n        iterate(str +\\'(\\',open+1,close)\\n        iterate(str + \\')\\', open, close+1)\\n    }\\n\\n    iterate(\\'\\',0,0)\\n    return res;\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {number} n\\n * @return {string[]}\\n */\\nvar generateParenthesis = function(n) {\\n    let res = []\\n\\n    let iterate = (str, open, close) =>{\\n        if(open > n || close >n || close >open) return;\\n        if(str.length == n *2 && open ==close){\\n            res.push(str)\\n            return;\\n        }\\n        iterate(str +\\'(\\',open+1,close)\\n        iterate(str + \\')\\', open, close+1)\\n    }\\n\\n    iterate(\\'\\',0,0)\\n    return res;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2246389,
                "title": "c-backtracking-methods-with-recursive-tree",
                "content": "RECURSIVE TREE :\\n   for n=3:\\n   ![image](https://assets.leetcode.com/users/images/0a1dbcd3-89d8-4e77-8e7b-610e86c937f4_1657112179.3003967.jpeg)\\n\\nMETHOD_1\\nbacktraking is not invloved \\n```\\nclass Solution {\\npublic:\\n    void solve(int n, int openings , int closings , string temp, vector<string> &ans){\\n        if(temp.size()==2*n){\\n            ans.push_back(temp);\\n            return ;\\n        }\\n        \\n        if(openings<n){\\n           \\n            solve(n,openings+1,closings,temp+\\'(\\',ans);\\n        }\\n        \\n        if(closings<openings){\\n            \\n            solve(n,openings,closings+1,temp+\\')\\',ans);\\n        }\\n          return ;\\n    }\\n    vector<string> generateParenthesis(int n) {\\n        vector<string> ans;\\n        solve(n,0,0,\"\",ans);\\n        return ans;\\n    }\\n};\\n```\\n\\nMETHOD_2\\nbacktracking \\n```\\nclass Solution {\\npublic:\\n    void solve(int n, int openings , int closings , string temp, vector<string> &ans){\\n        if(temp.size()==2*n){\\n            ans.push_back(temp);\\n            return ;\\n        }\\n        \\n        if(openings<n){\\n             temp+=\\'(\\';\\n            solve(n,openings+1,closings,temp,ans);\\n            temp.pop_back();\\n        }\\n        \\n        if(closings<openings){\\n             temp+=\\')\\';\\n            solve(n,openings,closings+1,temp,ans);\\n            temp.pop_back();\\n        }\\n        \\n        \\n          return ;\\n    }\\n    vector<string> generateParenthesis(int n) {\\n        vector<string> ans;\\n        solve(n,0,0,\"\",ans);\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Backtracking",
                    "Recursion"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    void solve(int n, int openings , int closings , string temp, vector<string> &ans){\\n        if(temp.size()==2*n){\\n            ans.push_back(temp);\\n            return ;\\n        }\\n        \\n        if(openings<n){\\n           \\n            solve(n,openings+1,closings,temp+\\'(\\',ans);\\n        }\\n        \\n        if(closings<openings){\\n            \\n            solve(n,openings,closings+1,temp+\\')\\',ans);\\n        }\\n          return ;\\n    }\\n    vector<string> generateParenthesis(int n) {\\n        vector<string> ans;\\n        solve(n,0,0,\"\",ans);\\n        return ans;\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    void solve(int n, int openings , int closings , string temp, vector<string> &ans){\\n        if(temp.size()==2*n){\\n            ans.push_back(temp);\\n            return ;\\n        }\\n        \\n        if(openings<n){\\n             temp+=\\'(\\';\\n            solve(n,openings+1,closings,temp,ans);\\n            temp.pop_back();\\n        }\\n        \\n        if(closings<openings){\\n             temp+=\\')\\';\\n            solve(n,openings,closings+1,temp,ans);\\n            temp.pop_back();\\n        }\\n        \\n        \\n          return ;\\n    }\\n    vector<string> generateParenthesis(int n) {\\n        vector<string> ans;\\n        solve(n,0,0,\"\",ans);\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2043913,
                "title": "c-easy-solution-using-recursion",
                "content": "**[C++] Easy Solution Using Recursion**\\n**For Better Understanding take n=3 and dry run it and draw tree, using recursion**\\n\\n```\\nclass Solution {\\npublic:\\n    void solve(vector<string>&ss,string s,int o,int c)\\n    {\\n\\t    if(o==0 && c==0)\\n\\t    {\\n            ss.push_back(s);\\n\\t\\t    return;\\n    \\t}\\n\\t    if(o==c)\\n\\t        solve(ss,s+\"(\",o-1,c);\\n    \\telse if(o==0)\\n    \\t\\tsolve(ss,s+\")\",o,c-1);\\n    \\telse if(c>1)\\n    \\t{   \\n\\t    \\tsolve(ss,s+\"(\",o-1,c);\\t\\n\\t    \\tsolve(ss,s+\")\",o,c-1);\\t    \\n    \\t}\\n    \\telse if(c==1)\\n    \\t\\tsolve(ss,s+\")\",o,c-1);\\n    }\\n    vector<string> generateParenthesis(int n) {\\n        vector<string> s;\\n        solve(s,\"(\",n-1,n);\\n        return s;\\n    }\\n};\\n```\\n**If you find it helpful kindly UPVOTE**",
                "solutionTags": [
                    "C++",
                    "C",
                    "Recursion"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    void solve(vector<string>&ss,string s,int o,int c)\\n    {\\n\\t    if(o==0 && c==0)\\n\\t    {\\n            ss.push_back(s);\\n\\t\\t    return;\\n    \\t}\\n\\t    if(o==c)\\n\\t        solve(ss,s+\"(\",o-1,c);\\n    \\telse if(o==0)\\n    \\t\\tsolve(ss,s+\")\",o,c-1);\\n    \\telse if(c>1)\\n    \\t{   \\n\\t    \\tsolve(ss,s+\"(\",o-1,c);\\t\\n\\t    \\tsolve(ss,s+\")\",o,c-1);\\t    \\n    \\t}\\n    \\telse if(c==1)\\n    \\t\\tsolve(ss,s+\")\",o,c-1);\\n    }\\n    vector<string> generateParenthesis(int n) {\\n        vector<string> s;\\n        solve(s,\"(\",n-1,n);\\n        return s;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 446245,
                "title": "python3-backtracking-dp",
                "content": "Algorithm: \\nTo clarify, backtracking solves problems recursively by building solutions incrementally and removing those failing to satisfy constraints. For this problem, backtracking is implicitly taken care of by recursion. \\n\\nHere, we define a function `backtrack` which keeps track of remaining number of open & closing parenthesis (denoted as `m` and `n` respectively). If `m == n  == 0`, add the string to answer. If there are open parenthesis left (i.e. `m > 0`), it is possible to append an open parenthesis; if there are more closing parenthesis than open parenthesis (i.e. `n > m`), it is possible to append a closing parenthesis. \\n\\nImplementation (32ms, 90.57%):\\n```\\nclass Solution:\\n    def generateParenthesis(self, n: int) -> List[str]:\\n        \\n        def fn(s, op, cl):\\n            \"\"\"Backtracking to collect parentheses\"\"\"\\n            if cl == n: return ans.append(s)\\n            if op <  n: fn(s+\"(\", op+1, cl)\\n            if cl < op: fn(s+\")\", op, cl+1)\\n                \\n        ans = []\\n        fn(\"\", 0, 0)\\n        return ans \\n```\\n\\nAnalysis:\\nTime complexity `O(4^n/n^1.5)` per [Wikipedia](https://en.wikipedia.org/wiki/Catalan_number) \\nSpace complexity `O(4^n/n^1.5)`\\n\\n+dynamic programming \\n\\nIt is also possible to solve the problem explicitly using dynamic programming. Define `f(n)` as the set of all valid parentheses when there are `n` opening parentheses. Then symbolically, `f(n+1)` follows below recursive equation, \\n`f(n+1) = (f(0))f(n) + (f(1))f(n-1) + ... + (f(n-1))f(1) + (f(n))f(0)` \\n(`(f(i))f(j)` means that the valid parentheses of `f(i)` added by a pair of parentheses outside concatenated with the valid parentheses of `f(j)`, i.e. this is a loop.) \\n\\nTop-down implementation\\n```\\nclass Solution:\\n    def generateParenthesis(self, n: int) -> List[str]:\\n        \\n        @lru_cache(None)\\n        def fn(k):\\n            \"\"\"Return k pairs of parentheses\"\"\"\\n            if k == 0: return [\"\"]\\n            ans = []\\n            for i in range(k): ans.extend([f\\'({x}){y}\\' for x in fn(k-i-1) for y in fn(i)])\\n            return ans \\n        \\n        return fn(n)\\n```\\n\\nBottom-up implementation\\n```\\nclass Solution:\\n    def generateParenthesis(self, n: int) -> List[str]:\\n        ans = [[\"\"]]\\n        for i in range(1, n+1): \\n            tmp = []\\n            for j in range(i):\\n                for x in ans[j]:\\n                    for y in ans[~j]: \\n                        tmp.append(f\"({x}){y}\")\\n            ans.append(tmp)\\n        return ans[-1]\\n```\\n\\nEdited on 10/31/2021\\n```\\nclass Solution:\\n    @cache\\n    def generateParenthesis(self, n: int) -> List[str]:\\n        if n == 0: return [\"\"]\\n        ans = []\\n        for i in range(n):\\n            for x in self.generateParenthesis(n-1-i): \\n                for y in self.generateParenthesis(i): \\n                    ans.append(f\"({x}){y}\")\\n        return ans \\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def generateParenthesis(self, n: int) -> List[str]:\\n        \\n        def fn(s, op, cl):\\n            \"\"\"Backtracking to collect parentheses\"\"\"\\n            if cl == n: return ans.append(s)\\n            if op <  n: fn(s+\"(\", op+1, cl)\\n            if cl < op: fn(s+\")\", op, cl+1)\\n                \\n        ans = []\\n        fn(\"\", 0, 0)\\n        return ans \\n```\n```\\nclass Solution:\\n    def generateParenthesis(self, n: int) -> List[str]:\\n        \\n        @lru_cache(None)\\n        def fn(k):\\n            \"\"\"Return k pairs of parentheses\"\"\"\\n            if k == 0: return [\"\"]\\n            ans = []\\n            for i in range(k): ans.extend([f\\'({x}){y}\\' for x in fn(k-i-1) for y in fn(i)])\\n            return ans \\n        \\n        return fn(n)\\n```\n```\\nclass Solution:\\n    def generateParenthesis(self, n: int) -> List[str]:\\n        ans = [[\"\"]]\\n        for i in range(1, n+1): \\n            tmp = []\\n            for j in range(i):\\n                for x in ans[j]:\\n                    for y in ans[~j]: \\n                        tmp.append(f\"({x}){y}\")\\n            ans.append(tmp)\\n        return ans[-1]\\n```\n```\\nclass Solution:\\n    @cache\\n    def generateParenthesis(self, n: int) -> List[str]:\\n        if n == 0: return [\"\"]\\n        ans = []\\n        for i in range(n):\\n            for x in self.generateParenthesis(n-1-i): \\n                for y in self.generateParenthesis(i): \\n                    ans.append(f\"({x}){y}\")\\n        return ans \\n```",
                "codeTag": "Java"
            },
            {
                "id": 296338,
                "title": "python-recursive-solution",
                "content": "This is a Python solution based on ideas from other people\\'s solutions. Basically we rely on recursion to populate all the possible strings and add them to the \"results\" parameter, then return the \"results\" at the end after all the recursions. At each recursive step, we have a \"sofar\" parameter that keeps track of the string we have constructed so far. We add it to the \"results\" in the base case. Otherwise we make 2 recursive calls, with one appending an open paranthesis and the other appending a closing paranthesis.\\n```\\nclass Solution(object):\\n    def generateParenthesis(self, n):\\n        results = []\\n        def helper(sofar, results, left, right):\\n            if left == 0 and right == 0:\\n                results.append(sofar)\\n            if left > 0:\\n                helper(sofar + \"(\", results, left-1, right)\\n            if right > left:\\n                helper(sofar + \")\", results, left, right-1)\\n        helper(\\'\\', results, n, n)\\n        return results\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution(object):\\n    def generateParenthesis(self, n):\\n        results = []\\n        def helper(sofar, results, left, right):\\n            if left == 0 and right == 0:\\n                results.append(sofar)\\n            if left > 0:\\n                helper(sofar + \"(\", results, left-1, right)\\n            if right > left:\\n                helper(sofar + \")\", results, left, right-1)\\n        helper(\\'\\', results, n, n)\\n        return results\\n```",
                "codeTag": "Java"
            },
            {
                "id": 222304,
                "title": "simple-java-dfs-solution",
                "content": "A simple Java DFS solution:\\n\\n\\tpublic List<String> generateParenthesis(int n) {\\n        List<String> result = new ArrayList<>();\\n        dfs(n, n, result, \"\");\\n        return result;\\n    }\\n\\n    private void dfs(int left, int right, List<String> result, String s) {\\n        if (left == 0 && right == 0) result.add(s);\\n        else {\\n            if (left > 0) dfs(left - 1, right, result, s + \"(\");\\n            if (right > left) dfs(left, right - 1, result, s + \")\");\\n        }\\n    }",
                "solutionTags": [],
                "code": "A simple Java DFS solution:\\n\\n\\tpublic List<String> generateParenthesis(int n) {\\n        List<String> result = new ArrayList<>();\\n        dfs(n, n, result, \"\");\\n        return result;\\n    }\\n\\n    private void dfs(int left, int right, List<String> result, String s) {\\n        if (left == 0 && right == 0) result.add(s);\\n        else {\\n            if (left > 0) dfs(left - 1, right, result, s + \"(\");\\n            if (right > left) dfs(left, right - 1, result, s + \")\");\\n        }\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 10185,
                "title": "3-lines-recursion-solution-beats-90",
                "content": "Welcome to tell me if anywhere is not clear and I will add some explanations.\\n```\\n def generateParenthesis(self, n, left=0, right=0, cur=\\'\\'):\\n        if left == n: return [cur + \\')\\' * (n - right)]\\n        if left == right: return self.generateParenthesis(n, left + 1, right, cur + \\'(\\')\\n        return self.generateParenthesis(n, left + 1, right, cur + \\'(\\') \\\\\\n            + self.generateParenthesis(n, left, right + 1, cur + \\')\\')\\n````",
                "solutionTags": [],
                "code": "```\\n def generateParenthesis(self, n, left=0, right=0, cur=\\'\\'):\\n        if left == n: return [cur + \\')\\' * (n - right)]\\n        if left == right: return self.generateParenthesis(n, left + 1, right, cur + \\'(\\')\\n        return self.generateParenthesis(n, left + 1, right, cur + \\'(\\') \\\\\\n            + self.generateParenthesis(n, left, right + 1, cur + \\')\\')\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 10202,
                "title": "detailed-explanation-from-the-view-of-recursion-tree",
                "content": "Re: [Easy to understand Java backtracking solution](/topic/8724/easy-to-understand-java-backtracking-solution)\\n\\nI checked out several solutions. They're very nice and seems like a magic of recursion which I cannot understand and make me upset.\\nThen I try to dig into this problem and see how can I come up nice solution like them.\\n\\nFor this kind of combinatorial problem, typically we use Tree to represent the search space and generate all possible solutions by search.\\nTree is so powerful which is able to represent efficient dicitionary (BST), prefix compression (Trie) or recursion.\\nEssentially, it is **the representation of execution of program**. (In Theory of Computation, it's called Configuration Graph.)\\nTherefore, recursion tree is just a special case but sufficient for analyzing and solving this problem.\\n\\nSo we use Tree to represent the entire search space. Each node is the state of program at that point. What's the state of this problem?\\nSince we'd like to generate all valid parenthesis, **the state we concern is just the String we concat by now**.\\nThen each edge is the choice (precisely, one transition from Transition Function). We only have two options: concat '('' or ')'.\\nThus we can draw the entire tree as follows (which is unique, right?).\\n\\n![0_1482412702046_Untitled Diagram (1).png](/uploads/files/1482412702445-untitled-diagram-1.png) \\n\\nThe characteristic of the Tree is due to that of the problem: \\n\\n + We can choose '(' only if we didn't exceed the max limit\\n + We can choose ')' only if there aren't more )' than '(' by now (otherwise we cannot fix this no matter how we iterate in the following).  \\n\\nNow all those nice solutions seem to be very clear. They're different just because **they use different search technique on this unique tree**.\\nThe first and natural searching approach is DFS which is the green arrow in the diagram above. \\nSince this is not a Complete Tree, we need variables (left/right or open/close) to control.\\nThey help us not to reach non-existing node on the Tree which means syntax wrong state such as ')((())'.\\n\\n```\\n    public List<String> generateParenthesis(int n) {\\n        List<String> ret = new ArrayList<>();\\n        generate(ret, new char[n * 2], 0, 0, n, 0);\\n        return ret;\\n    }\\n    \\n    private void generate(List<String> ret, char[] str, int left, int right, int max, int i) {\\n        if (left == max && right == left) {\\n            ret.add(String.valueOf(str));\\n            return;\\n        }\\n        \\n        if (left < max) {\\n            str[i] = '(';\\n            generate(ret, str, left + 1, right, max, i + 1);\\n        }\\n        if (right < left) {\\n            str[i] = ')';\\n            generate(ret, str, left, right + 1, max, i + 1);\\n        }\\n    }\\n```\\n\\nAt last, let's review the most upvoted solution and see if we can understand now.\\nhttps://discuss.leetcode.com/topic/4485/concise-recursive-c-solution\\n\\n```\\nclass Solution {\\npublic:\\n    vector<string> generateParenthesis(int n) {\\n        vector<string> res;\\n        addingpar(res, \"\", n, 0);\\n        return res;\\n    }\\n    void addingpar(vector<string> &v, string str, int n, int m){\\n        if(n==0 && m==0) {\\n            v.push_back(str);\\n            return;\\n        }\\n        if(m > 0){ addingpar(v, str+\")\", n, m-1); }\\n        if(n > 0){ addingpar(v, str+\"(\", n-1, m+1); }\\n    }\\n};\\n```\\n\\nSee? They turn out to be the same. We start off with left(n)=n, right(m=0).\\nThen if right > 0, we go right. If left > 0, we go left meanwhile increase right by 1.\\nThe blue arrow show the order of this program.",
                "solutionTags": [],
                "code": "```\\n    public List<String> generateParenthesis(int n) {\\n        List<String> ret = new ArrayList<>();\\n        generate(ret, new char[n * 2], 0, 0, n, 0);\\n        return ret;\\n    }\\n    \\n    private void generate(List<String> ret, char[] str, int left, int right, int max, int i) {\\n        if (left == max && right == left) {\\n            ret.add(String.valueOf(str));\\n            return;\\n        }\\n        \\n        if (left < max) {\\n            str[i] = '(';\\n            generate(ret, str, left + 1, right, max, i + 1);\\n        }\\n        if (right < left) {\\n            str[i] = ')';\\n            generate(ret, str, left, right + 1, max, i + 1);\\n        }\\n    }\\n```\n```\\nclass Solution {\\npublic:\\n    vector<string> generateParenthesis(int n) {\\n        vector<string> res;\\n        addingpar(res, \"\", n, 0);\\n        return res;\\n    }\\n    void addingpar(vector<string> &v, string str, int n, int m){\\n        if(n==0 && m==0) {\\n            v.push_back(str);\\n            return;\\n        }\\n        if(m > 0){ addingpar(v, str+\")\", n, m-1); }\\n        if(n > 0){ addingpar(v, str+\"(\", n-1, m+1); }\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2307006,
                "title": "dfs-with-go",
                "content": "```\\nfunc generateParenthesis(n int) []string {\\n    var res []string\\n    \\n    helper(n, 0, 0, \"\", &res)\\n    \\n    return res\\n}\\n\\nfunc helper(n int, openCount int, closeCount int, currentStr string, result *[]string) {\\n    if openCount == n && closeCount == n {\\n        *result = append(*result, currentStr)\\n        return\\n    }\\n    \\n    if openCount < n {\\n        helper(n, openCount + 1, closeCount, currentStr + \"(\", result)\\n    }\\n    \\n    if openCount > closeCount {\\n        helper(n, openCount, closeCount + 1, currentStr + \")\", result)\\n    }\\n}\\n```",
                "solutionTags": [
                    "Go",
                    "Breadth-First Search"
                ],
                "code": "```\\nfunc generateParenthesis(n int) []string {\\n    var res []string\\n    \\n    helper(n, 0, 0, \"\", &res)\\n    \\n    return res\\n}\\n\\nfunc helper(n int, openCount int, closeCount int, currentStr string, result *[]string) {\\n    if openCount == n && closeCount == n {\\n        *result = append(*result, currentStr)\\n        return\\n    }\\n    \\n    if openCount < n {\\n        helper(n, openCount + 1, closeCount, currentStr + \"(\", result)\\n    }\\n    \\n    if openCount > closeCount {\\n        helper(n, openCount, closeCount + 1, currentStr + \")\", result)\\n    }\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1787441,
                "title": "c-backtracking-simple-logic-explain",
                "content": "Here are few step need to follow\\n* **Till (open < N) We can put \\'(\\'**\\n* **If (Open>end) We can put \\')\\'**\\n\\n**\\u2B06\\uFE0F Please Upvote**\\n\\n```\\nclass Solution {\\n    vector<string>ans;\\n    void backTrack(int n, int open, int end, string s){\\n        if(open == n && end ==  n) {\\n            ans.push_back(s);\\n            return;\\n        }\\n        \\n        if(open<n) {\\n            s.push_back(\\'(\\');\\n            backTrack(n, open+1, end, s);\\n            s.pop_back();\\n        }\\n        if(end<open) {\\n            s.push_back(\\')\\');\\n            backTrack(n, open, end+1, s);\\n        }\\n    }\\npublic:\\n    vector<string> generateParenthesis(int n) {\\n        ans.clear();\\n        backTrack(n, 0, 0, \"\");\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\n    vector<string>ans;\\n    void backTrack(int n, int open, int end, string s){\\n        if(open == n && end ==  n) {\\n            ans.push_back(s);\\n            return;\\n        }\\n        \\n        if(open<n) {\\n            s.push_back(\\'(\\');\\n            backTrack(n, open+1, end, s);\\n            s.pop_back();\\n        }\\n        if(end<open) {\\n            s.push_back(\\')\\');\\n            backTrack(n, open, end+1, s);\\n        }\\n    }\\npublic:\\n    vector<string> generateParenthesis(int n) {\\n        ans.clear();\\n        backTrack(n, 0, 0, \"\");\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1754291,
                "title": "js-easy-heavily-commented-solution-using-backtracking-dfs",
                "content": "```\\n/**\\n * @param {number} n\\n * @return {string[]}\\n */\\nvar generateParenthesis = function(n) {\\n    // Using backtracking and DFS\\n    let res = [];\\n    \\n    const dfs = (str, open, close) => {\\n        // Backtracking case: number of \\')\\' can\\'t be more than number of \\'(\\'\\n        if (open < close) return;\\n        \\n        // Base case: there are n number of open and close parenthesis\\n        if (open === n && close === n) {\\n            res.push(str);\\n            return;\\n        }\\n        \\n        // DFS traversal\\n        if (open < n) dfs(str + \\'(\\', open + 1, close);\\n        if (close < n) dfs(str + \\')\\', open, close + 1);\\n    }\\n    \\n    dfs(\\'\\', 0, 0);\\n    return res;\\n};\\n```",
                "solutionTags": [
                    "JavaScript",
                    "Backtracking",
                    "Depth-First Search",
                    "Recursion"
                ],
                "code": "```\\n/**\\n * @param {number} n\\n * @return {string[]}\\n */\\nvar generateParenthesis = function(n) {\\n    // Using backtracking and DFS\\n    let res = [];\\n    \\n    const dfs = (str, open, close) => {\\n        // Backtracking case: number of \\')\\' can\\'t be more than number of \\'(\\'\\n        if (open < close) return;\\n        \\n        // Base case: there are n number of open and close parenthesis\\n        if (open === n && close === n) {\\n            res.push(str);\\n            return;\\n        }\\n        \\n        // DFS traversal\\n        if (open < n) dfs(str + \\'(\\', open + 1, close);\\n        if (close < n) dfs(str + \\')\\', open, close + 1);\\n    }\\n    \\n    dfs(\\'\\', 0, 0);\\n    return res;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1687595,
                "title": "c-beats-85-backtracking-easy-solution",
                "content": "Please Upvote if it helps you\\n```\\nclass Solution {\\npublic:\\n    void generateAll(vector<string> &ans,int n, int open,int close,string s){\\n\\t\\t// the number of close backets can never be greater than open Brackets as - \"( ) )\" is not valid string \\n        if(open < close || close> n || open>n){\\n            return;\\n        }\\n        if(close==n){\\n            ans.push_back(s);\\n            return;\\n        }\\n        \\n        s+=\\'(\\';\\n        generateAll(ans,n,open+1,close,s);\\n        s.pop_back(); //backtrack\\n        \\n        s+=\\')\\';\\n        generateAll(ans,n,open,close+1,s);\\n        \\n    }\\n    vector<string> generateParenthesis(int n) {\\n        \\n        vector<string> ans;\\n        \\n        generateAll(ans,n,0,0,\"\");\\n        \\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Backtracking"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    void generateAll(vector<string> &ans,int n, int open,int close,string s){\\n\\t\\t// the number of close backets can never be greater than open Brackets as - \"( ) )\" is not valid string \\n        if(open < close || close> n || open>n){\\n            return;\\n        }\\n        if(close==n){\\n            ans.push_back(s);\\n            return;\\n        }\\n        \\n        s+=\\'(\\';\\n        generateAll(ans,n,open+1,close,s);\\n        s.pop_back(); //backtrack\\n        \\n        s+=\\')\\';\\n        generateAll(ans,n,open,close+1,s);\\n        \\n    }\\n    vector<string> generateParenthesis(int n) {\\n        \\n        vector<string> ans;\\n        \\n        generateAll(ans,n,0,0,\"\");\\n        \\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1402549,
                "title": "very-easy-recursion-aditya-verma",
                "content": "**Upvote,if you like it**\\n\\tclass Solution {\\n\\tpublic:\\n\\n\\tvoid solve(int open,int close,string &op,vector<string> &ans)\\n    {\\n        if(open == 0 and close == 0)\\n        {\\n            ans.push_back(op);\\n            return;\\n        }\\n        \\n        if(open != 0)\\n        {\\n            string op1 = op;\\n            op1.push_back(\\'(\\');\\n            solve(open - 1,close,op1,ans);\\n        }\\n        \\n        if(close > open)\\n        {\\n            string op2 = op;\\n            op2.push_back(\\')\\');\\n            solve(open,close-1,op2,ans);\\n        }\\n        return;\\n    }\\n    \\n    vector<string> generateParenthesis(int n) {\\n        \\n        vector<string> ans;\\n        string op = \"\";\\n        int close = n;\\n        int open = n;\\n        solve(open,close,op,ans);\\n        return ans;\\n    }\\n};",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "class Solution {\\n\\tpublic:\\n\\n\\tvoid solve(int open,int close,string &op,vector<string> &ans)\\n    {\\n        if(open == 0 and close == 0)\\n        {\\n            ans.push_back(op);\\n            return;\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 1276105,
                "title": "c-simple-and-clean-recursive-solution-0-ms-faster-than-100",
                "content": "```\\nclass Solution {\\npublic:\\n    void rec(string curr, int open, int close) {\\n        if (open == 0 && close == 0) {\\n            res.push_back(curr);\\n            return;\\n        }\\n        \\n        if (open > 0) rec(curr + \"(\", open-1, close+1);\\n        if (close > 0) rec(curr + \")\", open, close-1);\\n    }\\n    \\n    vector<string> generateParenthesis(int n) {\\n        rec(\"\", n, 0);\\n        return res;\\n    }\\n    \\nprivate:\\n    vector<string> res;\\n};\\n```\\n**Like it? please upvote!**",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    void rec(string curr, int open, int close) {\\n        if (open == 0 && close == 0) {\\n            res.push_back(curr);\\n            return;\\n        }\\n        \\n        if (open > 0) rec(curr + \"(\", open-1, close+1);\\n        if (close > 0) rec(curr + \")\", open, close-1);\\n    }\\n    \\n    vector<string> generateParenthesis(int n) {\\n        rec(\"\", n, 0);\\n        return res;\\n    }\\n    \\nprivate:\\n    vector<string> res;\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1166698,
                "title": "python-well-explained",
                "content": "In backtracking we use depth-first search to traverse the solution space. We undo previous actions in order to revert back to the state that we branch off from so that we can explore other branches coming from that state.\\n\\nWe backtrack when:\\n- we find a a valid solution (a goal state).\\n- when we find an invalid state.\\n\\nThe two main advantages of backtracking method are:\\n- It prevents us from branching off from invalid/unpromising states.\\n- It is typically space efficient.\\n\\n```\\ndef generateParenthesis(self, n: int) -> List[str]:\\n\\t# Store the valid solutions we encounter\\n\\toutput = []\\n        \\n\\tdef dfs(open_brackets=0, closed_brackets=0, s=\\'\\'):\\n\\t    # If there are n opened and closed brackets\\n\\t    if open_brackets == n and closed_brackets == n:\\n\\t        # Append the valid solution to the output array\\n\\t        output.append(curr)\\n\\t        # Do not continue searching from this state\\n\\t        return\\n            \\n        # If we can place an open bracket\\n        if open_brackets < n:\\n            # Add an open bracket\\n            curr += \\'(\\'\\n            # Explore states based on this one\\n            dfs(open_brackets + 1, closed_brackets, curr)\\n            # Backtrack by removing the open bracket we placed\\n            curr = curr[:-1]\\n                \\n        # If we haven\\'t closed all open brackets\\n        if closed_brackets < open_brackets:\\n            # Add a close bracket\\n            curr += \\')\\'\\n            # Explore states based on this one\\n            dfs(open_brackets, closed_brackets + 1, curr)\\n            # Backtrack by removing the closed bracket\\n            curr = curr[:-1]\\n\\n    # Begin the depth-first search\\n    dfs()\\n        \\n    # Return the array of valid solutions\\n    return output\\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\ndef generateParenthesis(self, n: int) -> List[str]:\\n\\t# Store the valid solutions we encounter\\n\\toutput = []\\n        \\n\\tdef dfs(open_brackets=0, closed_brackets=0, s=\\'\\'):\\n\\t    # If there are n opened and closed brackets\\n\\t    if open_brackets == n and closed_brackets == n:\\n\\t        # Append the valid solution to the output array\\n\\t        output.append(curr)\\n\\t        # Do not continue searching from this state\\n\\t        return\\n            \\n        # If we can place an open bracket\\n        if open_brackets < n:\\n            # Add an open bracket\\n            curr += \\'(\\'\\n            # Explore states based on this one\\n            dfs(open_brackets + 1, closed_brackets, curr)\\n            # Backtrack by removing the open bracket we placed\\n            curr = curr[:-1]\\n                \\n        # If we haven\\'t closed all open brackets\\n        if closed_brackets < open_brackets:\\n            # Add a close bracket\\n            curr += \\')\\'\\n            # Explore states based on this one\\n            dfs(open_brackets, closed_brackets + 1, curr)\\n            # Backtrack by removing the closed bracket\\n            curr = curr[:-1]\\n\\n    # Begin the depth-first search\\n    dfs()\\n        \\n    # Return the array of valid solutions\\n    return output\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 413718,
                "title": "simple-ruby-solution-using-backtracking",
                "content": "```\\ndef generate_parenthesis(n)\\n  @res = []\\n  backtrack(\"\", 0, 0, n)\\n  @res\\nend\\n\\ndef backtrack(curr, open, close, n)\\n  @res << curr and return if curr.length == n*2\\n  backtrack(curr+\\'(\\', open+1, close, n) if open < n\\n  backtrack(curr+\\')\\', open, close+1, n) if close < open\\nend\\n```",
                "solutionTags": [
                    "Ruby",
                    "Backtracking"
                ],
                "code": "```\\ndef generate_parenthesis(n)\\n  @res = []\\n  backtrack(\"\", 0, 0, n)\\n  @res\\nend\\n\\ndef backtrack(curr, open, close, n)\\n  @res << curr and return if curr.length == n*2\\n  backtrack(curr+\\'(\\', open+1, close, n) if open < n\\n  backtrack(curr+\\')\\', open, close+1, n) if close < open\\nend\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 3906758,
                "title": "recurison-solution",
                "content": "# **PLS UPVOTE IF YOU LIKE MY SOLUTION AND COMMENT FOR ANY DISCUSSION **\\n# Approach\\nFunction solve: This is a recursive helper function that generates all valid combinations of parentheses.\\n\\nThe base case is when the length of the temp string becomes equal to 2 * n. At this point, you\\'ve formed a valid combination, so you add it to the result vector and return.\\n\\nIf you can still add an opening parenthesis ( (i.e., if start < n), you recursively call solve with an incremented start and append an opening parenthesis to the temp string.\\n\\nIf you can add a closing parenthesis ) without making the combination invalid (i.e., if close < start), you recursively call solve with an incremented close and append a closing parenthesis to the temp string.\\n\\nFunction generateParenthesis: This is the main function that initializes the result vector and starts the recursion by calling the solve function.\\n\\nThe initial call to solve has start and close both set to 0, and an empty temp string.\\nThe idea behind this approach is to generate all possible combinations of parentheses by recursively adding an opening parenthesis when possible and a closing parenthesis when it won\\'t lead to an invalid combination. The recursion explores all possible paths of forming valid combinations.\\n\\nThe result will be a vector of strings containing all the valid combinations of parentheses for the given n\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:O(2^(2n))\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:0(n)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\nvoid solve(int n , int start , int close, string temp ,vector<string>&result)\\n{\\n    if(temp.size()==n*2)\\n    {\\n        result.push_back(temp);\\n        return ; \\n    }\\n    if(start < n)\\n    {\\n        solve(n,start + 1, close,temp + \"(\", result);\\n    }\\n     if(close < start )\\n    {\\n        solve(n,start, close + 1,temp + \")\", result);\\n    }\\n }\\n    vector<string> generateParenthesis(int n) {\\n        vector<string>result;\\n        solve(n,0, 0,\"\", result);\\n        return result;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "String",
                    "Recursion"
                ],
                "code": "```\\nclass Solution {\\npublic:\\nvoid solve(int n , int start , int close, string temp ,vector<string>&result)\\n{\\n    if(temp.size()==n*2)\\n    {\\n        result.push_back(temp);\\n        return ; \\n    }\\n    if(start < n)\\n    {\\n        solve(n,start + 1, close,temp + \"(\", result);\\n    }\\n     if(close < start )\\n    {\\n        solve(n,start, close + 1,temp + \")\", result);\\n    }\\n }\\n    vector<string> generateParenthesis(int n) {\\n        vector<string>result;\\n        solve(n,0, 0,\"\", result);\\n        return result;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3855246,
                "title": "beginner-friendly-different-way-of-approach-using-recursion-and-stack",
                "content": "# Intuition\\nGenerate every possible string using recursion and check each string is valid or not.\\n\\n# Complexity\\n- Time complexity:\\nO(2^(2n)*2n).\\n# Code\\n```\\nclass Solution {\\npublic:\\n    bool isvalid(string &s){\\n        stack<char> st;\\n        for(int i=0;i<s.length();i++){\\n            if(s[i]==\\'(\\') st.push(\\'(\\');\\n            else {\\n                if(!st.empty()) st.pop();\\n                 else return false;\\n                }\\n        }\\n        if(st.size()==0) return true;\\n        return false;\\n        \\n    }\\n    \\n   void solve(int n1,int n2,string s,vector<string> &ans){\\n        if(n1==0 && n2==0){\\n            if(isvalid(s)){\\n                ans.push_back(s);\\n            }\\n            return;\\n        }\\n        if(n1!=0) {s.push_back(\\'(\\');  solve(n1-1,n2,s,ans); s.pop_back();}\\n       \\n        if(n2!=0) {s.push_back(\\')\\'); solve(n1,n2-1,s,ans);}\\n       \\n   \\n        \\n}\\n\\n    vector<string> generateParenthesis(int n) {\\n\\n        vector<string> ans;\\n        solve(n,n,\"\",ans);\\n        return ans;\\n        \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Stack",
                    "Recursion"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool isvalid(string &s){\\n        stack<char> st;\\n        for(int i=0;i<s.length();i++){\\n            if(s[i]==\\'(\\') st.push(\\'(\\');\\n            else {\\n                if(!st.empty()) st.pop();\\n                 else return false;\\n                }\\n        }\\n        if(st.size()==0) return true;\\n        return false;\\n        \\n    }\\n    \\n   void solve(int n1,int n2,string s,vector<string> &ans){\\n        if(n1==0 && n2==0){\\n            if(isvalid(s)){\\n                ans.push_back(s);\\n            }\\n            return;\\n        }\\n        if(n1!=0) {s.push_back(\\'(\\');  solve(n1-1,n2,s,ans); s.pop_back();}\\n       \\n        if(n2!=0) {s.push_back(\\')\\'); solve(n1,n2-1,s,ans);}\\n       \\n   \\n        \\n}\\n\\n    vector<string> generateParenthesis(int n) {\\n\\n        vector<string> ans;\\n        solve(n,n,\"\",ans);\\n        return ans;\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3772106,
                "title": "easy-solution-using-recursion-with-100-beats",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    void gp(int left,int right,string &s,vector<string> &ans){\\n        if(left==0 && right==0)\\n        ans.push_back(s);\\n\\n        if(left>right || left<0 || right<0){\\n            return ;\\n        }\\n        s.push_back(\\'(\\');\\n        gp(left-1,right,s,ans);\\n        s.pop_back();\\n\\n        s.push_back(\\')\\');\\n        gp(left,right-1,s,ans);\\n        s.pop_back();\\n    }\\n    vector<string> generateParenthesis(int n) {\\n        vector<string> ans;\\n        string s;\\n        gp(n,n,s,ans);\\n        return ans;\\n    }\\n};\\n/*UPVOTE IF THE SOLUTION WAS HELPFUL FOR YOU.*/\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    void gp(int left,int right,string &s,vector<string> &ans){\\n        if(left==0 && right==0)\\n        ans.push_back(s);\\n\\n        if(left>right || left<0 || right<0){\\n            return ;\\n        }\\n        s.push_back(\\'(\\');\\n        gp(left-1,right,s,ans);\\n        s.pop_back();\\n\\n        s.push_back(\\')\\');\\n        gp(left,right-1,s,ans);\\n        s.pop_back();\\n    }\\n    vector<string> generateParenthesis(int n) {\\n        vector<string> ans;\\n        string s;\\n        gp(n,n,s,ans);\\n        return ans;\\n    }\\n};\\n/*UPVOTE IF THE SOLUTION WAS HELPFUL FOR YOU.*/\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3613202,
                "title": "valid-parentheses-easy-hai-samjh-aa-jaega",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nKch ni krna hai, ye socho ki obviously open bracket close bracket se pehle aaega, to condition open bracket ka lekr chalna hai, or bs code kr dena hai\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nOpen bracket daalo, close bracket daalo, jb open N se aage jae ya close open se aage jae to ruk jaana hai, ni to 3 condition likha hai, dekho samjh aa jaega\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nNI PTA, SAARA TEST CASE PASS HO GAYA HAI\\n<!-- Contact : c0deblooded   telegram username -->\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nAB RETURN KRNA HAI TO ANS STRING TO BNANA PADEGA NA BHAI\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<string>ans;\\n\\n    void solve(int n, string &str, int open, int close){\\n        if(open == close and open == n - 1){\\n            ans.push_back(str);\\n            return;\\n        }\\n        if(open < n){\\n            str.push_back(\\'(\\');\\n            solve(n, str, open + 1, close);\\n            str.pop_back();\\n\\n        }\\n        if(open > close){\\n            str.push_back(\\')\\');\\n            solve(n, str, open, close + 1);\\n            str.pop_back();\\n        }\\n    }\\n\\n    vector<string> generateParenthesis(int n) {\\n        ans.clear();\\n        ans.resize(0);\\n        string str;\\n        solve(n+1, str, 0, 0);\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<string>ans;\\n\\n    void solve(int n, string &str, int open, int close){\\n        if(open == close and open == n - 1){\\n            ans.push_back(str);\\n            return;\\n        }\\n        if(open < n){\\n            str.push_back(\\'(\\');\\n            solve(n, str, open + 1, close);\\n            str.pop_back();\\n\\n        }\\n        if(open > close){\\n            str.push_back(\\')\\');\\n            solve(n, str, open, close + 1);\\n            str.pop_back();\\n        }\\n    }\\n\\n    vector<string> generateParenthesis(int n) {\\n        ans.clear();\\n        ans.resize(0);\\n        string str;\\n        solve(n+1, str, 0, 0);\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3401851,
                "title": "100-detailed-explaination-with-pictures-in-c-java-python-recursion",
                "content": "\\n# Approach\\n- Here the approach is pretty simple Always the number of Open brackets must be Greater than or equal to the closed ones and in the end we must have a balanced parantheses.\\n>- The Decision tree of this approach would be like as shown below in the picture.\\n\\n![pic1.png](https://assets.leetcode.com/users/images/9ca0631b-cc21-4ebc-b3e8-d91f71cf61e8_1681154610.15714.png)\\n\\n- As Above we can observe how the recursion tree is constructed now we push the end product $i.e$ when `open == close == n` we would push the string into the vector of string and `return` the function.\\n\\n>This would be the most obvious way to solve these type of question and also there are some solution of a type where bitmasking is used in common but currently we stick on to this type of solution which is enough in most of the interviews.\\n\\n# Complexity\\n>- Time complexity: Here the Time complexity would be $$O(2^n)$$ and this is because we cannot optimise the recursion call via Creating a Dp array or something so we have to try all the possiblities which results in Exponential complexity i.e $$(2^n)$$.\\n\\n>- Space complexity:Here the Space complexity would Just be storage space complexity of $$O(n)$$ due to stack space and vector of string storage space.\\n\\n# Code\\n```C++ []\\nclass Solution {\\npublic:\\n    void gen(vector<string>&vs , string &s , int n , int open  , int close)\\n    {\\n        if(open == close && open == n-1)\\n        {\\n            vs.push_back(s);\\n            return;\\n        }\\n        if(open < n)\\n        {\\n            s.push_back(\\'(\\');\\n            gen(vs, s , n , open + 1 ,close);\\n            s.pop_back();\\n        }\\n        if(close < open)\\n        {\\n            s.push_back(\\')\\');\\n            gen(vs,  s,  n , open , close + 1);\\n            s.pop_back();\\n        }\\n    }\\n    vector<string> generateParenthesis(int n) {\\n        vector<string>vs;\\n        string s;\\n        gen(vs , s , n+1 , 0 , 0);\\n        return vs;\\n    }\\n};\\n```\\n```java []\\nclass Solution {\\n    public List<String> generateParenthesis(int n) {\\n        List<String> result = new ArrayList<>();\\n        StringBuilder sb = new StringBuilder();\\n        dfs (n, 0, 0, 0, sb, result);\\n        return result;\\n    }\\n    private void dfs (int n, int left, int right, int index, StringBuilder sb, List<String> result) {\\n        if (left == n && right == n) {\\n            result.add (sb.toString());\\n            return;\\n        }\\n        if (left < n) {\\n            sb.append (\\'(\\');\\n            dfs (n, left + 1, right, index + 1, sb, result);\\n            sb.deleteCharAt (sb.length() -1);\\n        }\\n\\n        if (right < left) {\\n            sb.append (\\')\\');\\n            dfs (n, left, right + 1, index + 1, sb, result);\\n            sb.deleteCharAt (sb.length() -1);\\n        }\\n    }\\n}\\n```\\n```python []\\nclass Solution:\\n    def generateParenthesis(self, n: int) -> List[str]:\\n\\n        def dfs(left, right, s):\\n            if len(s) == n * 2:\\n                res.append(s)\\n                return \\n\\n            if left < n:\\n                dfs(left + 1, right, s + \\'(\\')\\n\\n            if right < left:\\n                dfs(left, right + 1, s + \\')\\')\\n\\n        res = []\\n        dfs(0, 0, \\'\\')\\n        return res\\n```\\n\\n\\n---\\n\\n\\n\\nIF YOU LIKE THE SOLUTION THEN PLEASE UPVOTE MY SOLUTION BECAUSE IT GIVES ME MOTIVATION TO REGULARLY POST THE SOLUTION.\\n\\n![UPVOTE.jpg](https://assets.leetcode.com/users/images/fd222420-993e-4879-87e3-68e203f44d2d_1681153859.3552585.jpeg)\\n",
                "solutionTags": [
                    "C++"
                ],
                "code": "```C++ []\\nclass Solution {\\npublic:\\n    void gen(vector<string>&vs , string &s , int n , int open  , int close)\\n    {\\n        if(open == close && open == n-1)\\n        {\\n            vs.push_back(s);\\n            return;\\n        }\\n        if(open < n)\\n        {\\n            s.push_back(\\'(\\');\\n            gen(vs, s , n , open + 1 ,close);\\n            s.pop_back();\\n        }\\n        if(close < open)\\n        {\\n            s.push_back(\\')\\');\\n            gen(vs,  s,  n , open , close + 1);\\n            s.pop_back();\\n        }\\n    }\\n    vector<string> generateParenthesis(int n) {\\n        vector<string>vs;\\n        string s;\\n        gen(vs , s , n+1 , 0 , 0);\\n        return vs;\\n    }\\n};\\n```\n```java []\\nclass Solution {\\n    public List<String> generateParenthesis(int n) {\\n        List<String> result = new ArrayList<>();\\n        StringBuilder sb = new StringBuilder();\\n        dfs (n, 0, 0, 0, sb, result);\\n        return result;\\n    }\\n    private void dfs (int n, int left, int right, int index, StringBuilder sb, List<String> result) {\\n        if (left == n && right == n) {\\n            result.add (sb.toString());\\n            return;\\n        }\\n        if (left < n) {\\n            sb.append (\\'(\\');\\n            dfs (n, left + 1, right, index + 1, sb, result);\\n            sb.deleteCharAt (sb.length() -1);\\n        }\\n\\n        if (right < left) {\\n            sb.append (\\')\\');\\n            dfs (n, left, right + 1, index + 1, sb, result);\\n            sb.deleteCharAt (sb.length() -1);\\n        }\\n    }\\n}\\n```\n```python []\\nclass Solution:\\n    def generateParenthesis(self, n: int) -> List[str]:\\n\\n        def dfs(left, right, s):\\n            if len(s) == n * 2:\\n                res.append(s)\\n                return \\n\\n            if left < n:\\n                dfs(left + 1, right, s + \\'(\\')\\n\\n            if right < left:\\n                dfs(left, right + 1, s + \\')\\')\\n\\n        res = []\\n        dfs(0, 0, \\'\\')\\n        return res\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3400123,
                "title": "shortest-c-solution-using-recursion",
                "content": "# Complexity\\n- Time complexity: O(4^n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(4^n*n)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    void solve(int open, int close, vector<string>& ans, string s) {\\n        if (open == 0 && close == 0) {\\n            ans.push_back(s);\\n            return;\\n        }\\n        if (open > 0) solve(open - 1, close, ans, s + \\'(\\');\\n        if (close > 0 && close > open) solve(open, close - 1, ans, s + \\')\\');\\n    }\\n    vector<string> generateParenthesis(int n) {\\n        vector<string> ans;\\n        solve(n, n, ans, \"\");\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Recursion"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    void solve(int open, int close, vector<string>& ans, string s) {\\n        if (open == 0 && close == 0) {\\n            ans.push_back(s);\\n            return;\\n        }\\n        if (open > 0) solve(open - 1, close, ans, s + \\'(\\');\\n        if (close > 0 && close > open) solve(open, close - 1, ans, s + \\')\\');\\n    }\\n    vector<string> generateParenthesis(int n) {\\n        vector<string> ans;\\n        solve(n, n, ans, \"\");\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3152520,
                "title": "python-code-using-dp",
                "content": "# Intuition\\nwe can find all the elements which will come for n using the values of previous elements in n-1.\\neg. if we have [\"(())\",\"()()\"] for n == 2\\nand [\"()\"] for n == 1\\nthe we can find answer for n == 3 using the previous values.\\n\\n# Approach\\nfor n == 3 we can add the \"()\" in any place in elements belonging to n == 2\\neg. taking first value in n == 2 we have \"(())\"\\nnow we add the \"()\" in each index of \"(())\" we get \"()(())\",\"(()())\", and so on ,resulting in a valid parenthesis of n == 3 similarly we can do same for next elements.\\n\\n\\n# Code\\n```\\nclass Solution:\\n    def generateParenthesis(self, n: int) -> List[str]:\\n        dp ={}\\n        dp[1] = [\"()\"]\\n        dp[2] = [\"(())\",\"()()\"]\\n        for i in range(3,n+1):\\n            d = {}\\n            arr = []\\n            for st in dp[i-1]:\\n                for j in range(0,len(st)):\\n                    new = st[0:j]+\"()\"+st[j:len(st)]\\n                    if new not in d:\\n                        d[new] = 1\\n                        arr.append(new)\\n            dp[i] = arr\\n        # print(dp[n])\\n        return dp[n]\\n\\n\\n```",
                "solutionTags": [
                    "Python3",
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution:\\n    def generateParenthesis(self, n: int) -> List[str]:\\n        dp ={}\\n        dp[1] = [\"()\"]\\n        dp[2] = [\"(())\",\"()()\"]\\n        for i in range(3,n+1):\\n            d = {}\\n            arr = []\\n            for st in dp[i-1]:\\n                for j in range(0,len(st)):\\n                    new = st[0:j]+\"()\"+st[j:len(st)]\\n                    if new not in d:\\n                        d[new] = 1\\n                        arr.append(new)\\n            dp[i] = arr\\n        # print(dp[n])\\n        return dp[n]\\n\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2777911,
                "title": "c-solution",
                "content": "# Approach\\n<!-- Describe your approach to solving the problem. -->\\n    Backtracking\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<string> ans;\\n    void solve(string &st, int fb, int sb, int mx) {\\n        if(st.size() == 2 * mx) {\\n            ans.push_back(st);\\n            return;\\n        }\\n        if(fb < mx) {\\n            st.push_back(\\'(\\');\\n            solve(st, fb+1, sb, mx);\\n            st.pop_back();\\n        }\\n        if(sb < fb) {\\n            st.push_back(\\')\\');\\n            solve(st, fb, sb+1, mx);\\n            st.pop_back();\\n        }\\n    }\\n\\n    vector<string> generateParenthesis(int n) {\\n        string st;\\n        solve(st, 0, 0, n);\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<string> ans;\\n    void solve(string &st, int fb, int sb, int mx) {\\n        if(st.size() == 2 * mx) {\\n            ans.push_back(st);\\n            return;\\n        }\\n        if(fb < mx) {\\n            st.push_back(\\'(\\');\\n            solve(st, fb+1, sb, mx);\\n            st.pop_back();\\n        }\\n        if(sb < fb) {\\n            st.push_back(\\')\\');\\n            solve(st, fb, sb+1, mx);\\n            st.pop_back();\\n        }\\n    }\\n\\n    vector<string> generateParenthesis(int n) {\\n        string st;\\n        solve(st, 0, 0, n);\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2352433,
                "title": "recursive-c-solution-include-or-exclude",
                "content": "```\\nvoid generateParenthesis(int open, int close, string op, vector<string>& ans) {\\n        if(open == 0 && close == 0) {\\n            ans.push_back(op);\\n            return;\\n        }\\n        \\n        if(open > 0) generateParenthesis(open-1, close, op+\"(\", ans);\\n        \\n        if(close > open) generateParenthesis(open, close-1, op+\")\", ans);\\n        \\n    }\\n    \\n    vector<string> generateParenthesis(int n) {\\n         vector<string> ans;\\n        int open = n;\\n        int close = n;\\n        string op = \"\";\\n        generateParenthesis(open, close, op, ans);\\n        \\n        return ans;\\n    }\\n```",
                "solutionTags": [
                    "C",
                    "Recursion"
                ],
                "code": "```\\nvoid generateParenthesis(int open, int close, string op, vector<string>& ans) {\\n        if(open == 0 && close == 0) {\\n            ans.push_back(op);\\n            return;\\n        }\\n        \\n        if(open > 0) generateParenthesis(open-1, close, op+\"(\", ans);\\n        \\n        if(close > open) generateParenthesis(open, close-1, op+\")\", ans);\\n        \\n    }\\n    \\n    vector<string> generateParenthesis(int n) {\\n         vector<string> ans;\\n        int open = n;\\n        int close = n;\\n        string op = \"\";\\n        generateParenthesis(open, close, op, ans);\\n        \\n        return ans;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2136726,
                "title": "aditya-verma-s-solution",
                "content": "```\\n//GOD ADITYA VERMA\\nclass Solution {\\npublic:\\n    vector<string> generateParenthesis(int n) {\\n        string op=\"\";\\n        vector<string> v;\\n        int o=n,c=n;\\n        solve(o,c,op,v);\\n        return v;\\n    }\\n    void solve(int open,int close,string &op,vector<string> &v)\\n    {\\n        if(open==0 && close==0)\\n        {\\n            v.push_back(op);\\n            return;\\n        }\\n        if(open!=0)\\n        {\\n            string op1=op;\\n            op1.push_back(\\'(\\');\\n            solve(open-1,close,op1,v);\\n            \\n        }\\n        if(close>open)\\n        {\\n            string op2=op;\\n            op2.push_back(\\')\\');\\n            solve(open,close-1,op2,v);\\n            \\n        }\\n    }\\n};\\n```\\n\\nPlease upvote!!",
                "solutionTags": [
                    "C",
                    "Recursion"
                ],
                "code": "```\\n//GOD ADITYA VERMA\\nclass Solution {\\npublic:\\n    vector<string> generateParenthesis(int n) {\\n        string op=\"\";\\n        vector<string> v;\\n        int o=n,c=n;\\n        solve(o,c,op,v);\\n        return v;\\n    }\\n    void solve(int open,int close,string &op,vector<string> &v)\\n    {\\n        if(open==0 && close==0)\\n        {\\n            v.push_back(op);\\n            return;\\n        }\\n        if(open!=0)\\n        {\\n            string op1=op;\\n            op1.push_back(\\'(\\');\\n            solve(open-1,close,op1,v);\\n            \\n        }\\n        if(close>open)\\n        {\\n            string op2=op;\\n            op2.push_back(\\')\\');\\n            solve(open,close-1,op2,v);\\n            \\n        }\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1806995,
                "title": "using-recursion-backtracking-with-comments-c",
                "content": "**Using Recursion & Backtracking\\nTime Complexity = O(2^N)\\nSpace Complexity = O(1), not considering the ans vector, bcz its a part of output**\\n```\\nclass Solution {\\npublic:\\n    void solve(int open, int close, string output, vector<string> &ans){\\n        \\n        // base case\\n        if(open == 0 && close == 0){\\n            ans.push_back(output);\\n            return;\\n        }\\n        \\n        // always takes open, until & unless its 0\\n        // inside this just append the open bracket and decrease open by 1\\n        if(open != 0){\\n            string openOutput = output + \"(\";\\n            solve(open-1, close, openOutput, ans);    \\n        }\\n        \\n        // take close when close is greater than open, bcz when we will use open, then only we can use close\\n        // inside this just append the close bracket and decrease close by 1\\n        if(close > open){\\n            string closeOutput = output + \")\";\\n            solve(open, close-1, closeOutput, ans);\\n        }\\n    }\\n    \\n    vector<string> generateParenthesis(int n) {\\n        \\n        // to store ans\\n        vector<string> ans;\\n        \\n        // we will be having n open & close brackets\\n        int open = n, close = n;\\n        \\n        // will store the combination into this\\n        string output = \"\";\\n        \\n        // helper function to solve the problem\\n        solve(open, close, output, ans);\\n        \\n        return ans;\\n    }\\n};\\n```\\nIf you find any issue in understanding the solution then comment below, will try to help you.\\nIf you found my solution useful.\\nSo **please do upvote and encourage me** to document all leetcode problems\\uD83D\\uDE03\\nHappy Coding :)",
                "solutionTags": [
                    "C",
                    "String",
                    "Backtracking",
                    "Depth-First Search",
                    "Recursion",
                    "Combinatorics"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    void solve(int open, int close, string output, vector<string> &ans){\\n        \\n        // base case\\n        if(open == 0 && close == 0){\\n            ans.push_back(output);\\n            return;\\n        }\\n        \\n        // always takes open, until & unless its 0\\n        // inside this just append the open bracket and decrease open by 1\\n        if(open != 0){\\n            string openOutput = output + \"(\";\\n            solve(open-1, close, openOutput, ans);    \\n        }\\n        \\n        // take close when close is greater than open, bcz when we will use open, then only we can use close\\n        // inside this just append the close bracket and decrease close by 1\\n        if(close > open){\\n            string closeOutput = output + \")\";\\n            solve(open, close-1, closeOutput, ans);\\n        }\\n    }\\n    \\n    vector<string> generateParenthesis(int n) {\\n        \\n        // to store ans\\n        vector<string> ans;\\n        \\n        // we will be having n open & close brackets\\n        int open = n, close = n;\\n        \\n        // will store the combination into this\\n        string output = \"\";\\n        \\n        // helper function to solve the problem\\n        solve(open, close, output, ans);\\n        \\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1688977,
                "title": "c-short-clean-easy-to-understand",
                "content": "**Please upvote if you find helpful:)**\\n\\n```\\nclass Solution {\\npublic:\\n    void generateAll(int n, int open, int close, vector<string>&v, string s)\\n    {\\n        if(open>n || close>n || close>open)\\n            return;\\n        if(open==n && close==n)\\n        {\\n            v.push_back(s);\\n            return;\\n        }\\n        generateAll(n, open+1, close, v, s+\\'(\\');\\n        generateAll(n, open, close+1, v, s+\\')\\');\\n        return;\\n    }\\n    vector<string> generateParenthesis(int n) {\\n        vector<string>v;\\n        generateAll(n, 0, 0, v, \"\");\\n        return v;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "String"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    void generateAll(int n, int open, int close, vector<string>&v, string s)\\n    {\\n        if(open>n || close>n || close>open)\\n            return;\\n        if(open==n && close==n)\\n        {\\n            v.push_back(s);\\n            return;\\n        }\\n        generateAll(n, open+1, close, v, s+\\'(\\');\\n        generateAll(n, open, close+1, v, s+\\')\\');\\n        return;\\n    }\\n    vector<string> generateParenthesis(int n) {\\n        vector<string>v;\\n        generateAll(n, 0, 0, v, \"\");\\n        return v;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1318087,
                "title": "easiest-solution-a-using-queue-beats-100-solves-5-problems",
                "content": "For questions like Generate paranthesis, Generate Permutations, Generate Subsets, Generate all bitstrings, Generate all strings without concecutive vowels, Queue approach will easily do the good. Same approach, but just changing the if conditions for adding children should be done relevantly to the question.\\n\\n**1. For Generate-Paranthesis**,\\nMaintain a Queue with [(str, opencount, closecount))] initially, front=0, qlength=1,\\nwhile front<qlength, peek the first element and add two children of it, (str+\\'(\\', opencount+1, closecount) and (str+\\')\\', opencount, closecount+1), increment front pointer. That\\'s all :)\\n```\\ndef generateParenthesis(self, n: int) -> List[str]:\\n    ans = []\\n    queue = [(\\'(\\', 1,0)]  # Item will contain (str, open_nos, close_nos)\\n    f = 0             # front_index\\n    l = 1            # queue_length\\n    while f<l:\\n        cur = queue[f]\\n        if cur[1]+cur[2]==2*n:\\n            ans.append(cur[0])\\n            f+=1\\n            continue\\n        if cur[1] < n:\\n            queue.append((cur[0]+\\'(\\', cur[1]+1, cur[2]))\\n            l+=1\\n        if cur[2] < cur[1]:\\n            queue.append((cur[0]+\\')\\', cur[1], cur[2]+1))\\n            l+=1\\n        f+=1\\n    return ans\\n```\\n\\n**2. For Generate-Permutations**,\\nHaving [(str, visitedchars, len)] as the Queue, its same like previous except that while adding the children to Queue we check if we\\'ve already used the character. \\n```\\ndef permute(self, nums: List[int]) -> List[List[int]]:\\n    n=len(nums)\\n    ans=[]\\n\\n    queue = []\\n    f = 0     # Queue front\\n    for i in nums:\\n        queue.append(([i], set([i]), 1))   # (str, visited_chars, len)\\n    l = len(queue)  # Queue length\\n\\t\\n    while f < l:\\n        cur = queue[f]\\n        if cur[2] == n:\\n            ans.append(cur[0])\\n        else:\\n            for i in nums:\\n                if i not in cur[1]:\\n                    queue.append((cur[0]+[i], cur[1].union([i]), cur[2]+1))\\n                    l += 1\\n        f+=1\\n\\t\\t\\n    return ans\\n```\\n\\n**3. For generating bitstrings of length n** Like n=3 -> 001, 010, 011, 100, 101, 110, 111\\nWe\\'ll have [(str, len)] in queue. Add [(str+\\'0\\', len+1)] and [(str+\\'1\\', len+1)] to the queue until len+1 not greater than n.\\n\\n**4. For generating subsets**, \\nGenerating binary bitstrings and appending the set bits to the ans is one solution. But again, in Queue approach, we\\'ll have [(set, len)] in Queue. Starting from [{}, 0] -> [[{1}, 1], [{2}, 1], ...]] -> [powerset, n] While going all the way to the powerset, we\\'ll add the intermediaries (\"cur\" in code) to the ans array.\\n\\n**5. For generating strings without consecutive vowels**, Like, for n=3, **Valid** strings are aba, abz, zzz, jka, eba. **Invalid** strings = aeb, poi, aaa, ..etc. because there are consecutive vowels\\nSame queue approach, but while adding children to the queue we need to make sure that we are **not** attaching a vowel after a vowel.\\n\\nThank youu :) Happy coding friends!",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Queue"
                ],
                "code": "```\\ndef generateParenthesis(self, n: int) -> List[str]:\\n    ans = []\\n    queue = [(\\'(\\', 1,0)]  # Item will contain (str, open_nos, close_nos)\\n    f = 0             # front_index\\n    l = 1            # queue_length\\n    while f<l:\\n        cur = queue[f]\\n        if cur[1]+cur[2]==2*n:\\n            ans.append(cur[0])\\n            f+=1\\n            continue\\n        if cur[1] < n:\\n            queue.append((cur[0]+\\'(\\', cur[1]+1, cur[2]))\\n            l+=1\\n        if cur[2] < cur[1]:\\n            queue.append((cur[0]+\\')\\', cur[1], cur[2]+1))\\n            l+=1\\n        f+=1\\n    return ans\\n```\n```\\ndef permute(self, nums: List[int]) -> List[List[int]]:\\n    n=len(nums)\\n    ans=[]\\n\\n    queue = []\\n    f = 0     # Queue front\\n    for i in nums:\\n        queue.append(([i], set([i]), 1))   # (str, visited_chars, len)\\n    l = len(queue)  # Queue length\\n\\t\\n    while f < l:\\n        cur = queue[f]\\n        if cur[2] == n:\\n            ans.append(cur[0])\\n        else:\\n            for i in nums:\\n                if i not in cur[1]:\\n                    queue.append((cur[0]+[i], cur[1].union([i]), cur[2]+1))\\n                    l += 1\\n        f+=1\\n\\t\\t\\n    return ans\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 1222114,
                "title": "java-clean-concise-optimal-code-backtracking-approach-easy-to-understand",
                "content": "```\\nclass Solution {\\n    \\n    public void generateAll (String s, int max, int openBracket, int closeBracket, List<String> answer) {\\n        \\n        if (s.length () == 2 * max) {\\n            answer.add (s);\\n        }\\n        if (openBracket < max) {\\n            generateAll (s + \\'(\\', max, openBracket + 1, closeBracket, answer);\\n        }\\n        if (closeBracket < openBracket) {\\n            generateAll (s + \\')\\', max, openBracket, closeBracket + 1, answer);\\n        }\\n    }\\n    \\n    public List<String> generateParenthesis(int n) {\\n        \\n        List<String> answer = new ArrayList<> ();\\n        \\n        generateAll (\"\", n, 0, 0, answer);\\n        return answer;\\n    }\\n}\\n```\\n\\nPlease help to **UPVOTE** if this post is useful for you.\\nIf you have any questions, feel free to comment below.\\n\\n**LOVE CODING :)\\nHAPPY CODING :)\\nHAPPY LEARNING :)**",
                "solutionTags": [
                    "Java",
                    "Backtracking",
                    "Recursion"
                ],
                "code": "```\\nclass Solution {\\n    \\n    public void generateAll (String s, int max, int openBracket, int closeBracket, List<String> answer) {\\n        \\n        if (s.length () == 2 * max) {\\n            answer.add (s);\\n        }\\n        if (openBracket < max) {\\n            generateAll (s + \\'(\\', max, openBracket + 1, closeBracket, answer);\\n        }\\n        if (closeBracket < openBracket) {\\n            generateAll (s + \\')\\', max, openBracket, closeBracket + 1, answer);\\n        }\\n    }\\n    \\n    public List<String> generateParenthesis(int n) {\\n        \\n        List<String> answer = new ArrayList<> ();\\n        \\n        generateAll (\"\", n, 0, 0, answer);\\n        return answer;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 441884,
                "title": "8-lines-recursive-solution-in-scala",
                "content": "```\\ndef generateParenthesis(n: Int): List[String] = n match {\\n\\tcase 0 => List(\"\")\\n\\tcase n =>\\n\\t\\tfor {\\n\\t\\t\\tm <- (0 to n - 1).toList\\n\\t\\t\\tx <- generateParenthesis(m)\\n\\t\\t\\ty <- generateParenthesis(n-1-m)\\n\\t\\t} yield (\"(\" ++ x ++ \")\" ++ y)\\n}\\n```",
                "solutionTags": [],
                "code": "```\\ndef generateParenthesis(n: Int): List[String] = n match {\\n\\tcase 0 => List(\"\")\\n\\tcase n =>\\n\\t\\tfor {\\n\\t\\t\\tm <- (0 to n - 1).toList\\n\\t\\t\\tx <- generateParenthesis(m)\\n\\t\\t\\ty <- generateParenthesis(n-1-m)\\n\\t\\t} yield (\"(\" ++ x ++ \")\" ++ y)\\n}\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 248837,
                "title": "python-dfs-short-and-easy-to-understand",
                "content": "```\\nclass Solution:\\n    def generateParenthesis(self, n: int) -> List[str]:\\n        return self.dfs(n, n, \"\", [])\\n\\n    def dfs(self, l, r, s, res):\\n        if l:\\n            self.dfs(l-1, r, s + \"(\", res)\\n        if r and l < r:          # l < r is important. \\n            self.dfs(l, r-1, s + \")\", res)\\n        if not r:\\n            res.append(s)\\n        return res\\n\\t",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Depth-First Search"
                ],
                "code": "```\\nclass Solution:\\n    def generateParenthesis(self, n: int) -> List[str]:\\n        return self.dfs(n, n, \"\", [])\\n\\n    def dfs(self, l, r, s, res):\\n        if l:\\n            self.dfs(l-1, r, s + \"(\", res)\\n        if r and l < r:          # l < r is important. \\n            self.dfs(l, r-1, s + \")\", res)\\n        if not r:\\n            res.append(s)\\n        return res\\n\\t",
                "codeTag": "Java"
            },
            {
                "id": 139825,
                "title": "valid-parenthesis-invariant",
                "content": "Let\\'s define cntLeft as the number of \\'(\\' met so far, cntRight as the number of  \\')\\' met so far.\\n\\nThere is an **invariant** that a valid combination of parenthesis alwas hold **cntLeft >= cntRight**.\\n\\n```\\n    public List<String> generateParenthesis(int n) {\\n        \\n        List<String> result = new LinkedList<>();\\n        generateParenthesisFrom(n, 0, 0, new StringBuilder(), result);\\n        \\n        return result;\\n    }\\n    \\n    private void generateParenthesisFrom(int n, int cntLeft, int cntRight, StringBuilder temp, List<String> result) {\\n        \\n        if (cntLeft > n || cntRight > n || cntLeft < cntRight) {\\n            return;\\n        }       \\n        if ((cntLeft == n) && (cntRight == n)) {\\n            result.add(temp.toString());\\n            return;\\n        }\\n\\n        temp.append(\"(\");\\n        generateParenthesisFrom(n, cntLeft + 1, cntRight, temp, result);\\n        temp.deleteCharAt(temp.length() - 1);      \\n        \\n        temp.append(\")\");\\n        generateParenthesisFrom(n, cntLeft, cntRight + 1, temp, result);\\n        temp.deleteCharAt(temp.length() - 1);\\n    }\\n```\\nThanks for **VOTE UP** (\\u02CAo\\u0334\\u0336\\u0337\\u0324\\u2304o\\u0334\\u0336\\u0337\\u0324\\u02CB)",
                "solutionTags": [],
                "code": "```\\n    public List<String> generateParenthesis(int n) {\\n        \\n        List<String> result = new LinkedList<>();\\n        generateParenthesisFrom(n, 0, 0, new StringBuilder(), result);\\n        \\n        return result;\\n    }\\n    \\n    private void generateParenthesisFrom(int n, int cntLeft, int cntRight, StringBuilder temp, List<String> result) {\\n        \\n        if (cntLeft > n || cntRight > n || cntLeft < cntRight) {\\n            return;\\n        }       \\n        if ((cntLeft == n) && (cntRight == n)) {\\n            result.add(temp.toString());\\n            return;\\n        }\\n\\n        temp.append(\"(\");\\n        generateParenthesisFrom(n, cntLeft + 1, cntRight, temp, result);\\n        temp.deleteCharAt(temp.length() - 1);      \\n        \\n        temp.append(\")\");\\n        generateParenthesisFrom(n, cntLeft, cntRight + 1, temp, result);\\n        temp.deleteCharAt(temp.length() - 1);\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 133250,
                "title": "backtracking-with-stringbuilder",
                "content": "```\\npublic List<String> generateParenthesis(int n) {\\n        List<String> res = new ArrayList<>();\\n        generate(0, 0, new StringBuilder(), res, n);\\n        return res;\\n    }\\n    private void generate(int open, int closed, StringBuilder sb, List<String> res, int n){\\n        if(closed > open || open > n || closed > n) return;\\n        if(open == closed && open == n){\\n            res.add(new String(sb));\\n            return;\\n        }\\n        sb.append(\"(\");\\n        generate(open+1, closed, sb, res, n);\\n        sb.setLength(sb.length()-1);\\n        sb.append(\")\");\\n        generate(open, closed+1, sb, res, n);\\n        sb.setLength(sb.length()-1);\\n    }\\n```",
                "solutionTags": [],
                "code": "```\\npublic List<String> generateParenthesis(int n) {\\n        List<String> res = new ArrayList<>();\\n        generate(0, 0, new StringBuilder(), res, n);\\n        return res;\\n    }\\n    private void generate(int open, int closed, StringBuilder sb, List<String> res, int n){\\n        if(closed > open || open > n || closed > n) return;\\n        if(open == closed && open == n){\\n            res.add(new String(sb));\\n            return;\\n        }\\n        sb.append(\"(\");\\n        generate(open+1, closed, sb, res, n);\\n        sb.setLength(sb.length()-1);\\n        sb.append(\")\");\\n        generate(open, closed+1, sb, res, n);\\n        sb.setLength(sb.length()-1);\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 10341,
                "title": "simple-c-sol-backtracking",
                "content": "\\n\\nclass Solution {\\n\\nprivate:\\n    \\nvector<string> res;\\n\\npublic:\\n\\n    void genP(int lc, int rc, string s){\\n        if(lc == 0 && rc ==0){\\n            res.push_back(s);\\n            return;\\n        }\\n        if(lc>0)\\n            genP(lc-1,rc,s+'(');\\n        if(rc>lc)\\n            genP(lc,rc-1,s+')');\\n    }\\n    vector<string> generateParenthesis(int n) {\\n        genP(n,n,\"\");\\n        return res;\\n    }\\n};",
                "solutionTags": [
                    "C++"
                ],
                "code": "class Solution {\\n\\nprivate:\\n    \\nvector<string> res;\\n\\npublic:\\n\\n    void genP(int lc, int rc, string s){\\n        if(lc == 0 && rc ==0){\\n            res.push_back(s);\\n            return;\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 10385,
                "title": "an-easy-c-solution-using-recursion",
                "content": "    \\n\\n    class Solution {\\n    public:\\n        #include<vector>\\n        vector <string> ans;\\n        \\n        void para(int i,int open,int n,string s)\\n        {\\n            if(open < 0)    return;\\n            if(i==n)\\n            {\\n                if(open==0)\\n                    ans.push_back(s);\\n                return;\\n            }\\n            para(i+1,open+1,n,s+\"(\");   \\n            para(i+1,open-1,n,s+\")\");\\n        }\\n    \\n        vector<string> generateParenthesis(int n) {\\n            \\n            string s = \"\";\\n            para(0,0,2*n,s);\\n            return ans;\\n        }\\n    };",
                "solutionTags": [
                    "Recursion"
                ],
                "code": "class Solution {\\n    public:\\n        #include<vector>\\n        vector <string> ans;\\n        \\n        void para(int i,int open,int n,string s)\\n        {\\n            if(open < 0)    return;\\n            if(i==n)\\n            {\\n                if(open==0)\\n                    ans.push_back(s);\\n                return;\\n            }",
                "codeTag": "C++"
            },
            {
                "id": 10459,
                "title": "my-java-solution-using-recursive",
                "content": "    public class Solution {\\n    public List<String> generateParenthesis(int n) {\\n        List<String> res = new ArrayList<String>();\\n        if(0 == n)\\n            return res;\\n        int l = n;\\n        int r = n;\\n        String item = new String();\\n        putIn(l,r,item,res);\\n        return res;\\n    }\\n    public void putIn(int l, int r, String item, List<String> res)\\n    {\\n        if(l==0 && r==0)\\n        {\\n            res.add(item);\\n            return;\\n        }\\n        if(l>0)\\n            putIn(l-1,r,item+\"(\",res);\\n        if(r>l)\\n            putIn(l,r-1,item+\")\",res);\\n    }\\n}\\n\\nThis is based on recursive thought, we can regard the Parenthesis in a set, when the set is empty, we add the string into result list, otherwise, we get a \"(\" from set and add it to the string, and get \")\" from set, add it to the string. Is this thinking better for us to understand?",
                "solutionTags": [],
                "code": "class Solution {\\n    public List<String> generateParenthesis(int n) {\\n        List<String> res = new ArrayList<String>();\\n        if(0 == n)\\n            return res;\\n        int l = n;\\n        int r = n;\\n        String item = new String();\\n        putIn(l,r,item,res);\\n        return res;\\n    }",
                "codeTag": "Java"
            },
            {
                "id": 10352,
                "title": "the-most-concise-solution-i-know-ever",
                "content": "    class Solution {\\n    public:\\n        vector<string> generateParenthesis(int n) {\\n            if(n==0) return vector<string>(1,\"\") ;\\n            if(n==1) return vector<string>(1,\"()\") ;\\n            vector<string> result;\\n            for(int i=0;i!=n;i++)\\n                for(auto inner: generateParenthesis(i))\\n                    for(auto outter:  generateParenthesis(n-i-1))\\n                        result.push_back(\"(\"+inner+\")\"+outter);\\n            return result;\\n        }\\n    };\\n\\nI think this solution must be the most concise one. The idea is very clear. \\n\\nPS: The author is not me. Just share it with you.",
                "solutionTags": [],
                "code": "class Solution {\\n    public:\\n        vector<string> generateParenthesis(int n) {\\n            if(n==0) return vector<string>(1,\"\") ;\\n            if(n==1) return vector<string>(1,\"()\") ;\\n            vector<string> result;\\n            for(int i=0;i!=n;i++)\\n                for(auto inner: generateParenthesis(i))\\n                    for(auto outter:  generateParenthesis(n-i-1))\\n                        result.push_back(\"(\"+inner+\")\"+outter);\\n            return result;\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 3567408,
                "title": "generate-all-valid-parentheses-combinations-backtracking",
                "content": "# Intuition\\nAt first I thought about using part of the paranthesis checker from the last problem but I quickly realized that I needed a new algorithm for this, but I had no clue how to start. I was reading the discussion when I saw someone post a tree graph of the possibilities of one of the samples and I thought, okay, it\\'s possible with backtracking.\\n\\n# Approach\\n1. Create a helper function called **backtrack** that takes the following parameters: **result** (a vector of strings to store valid parentheses combinations), **current** (a string representing the current combination of parentheses), **open** (the count of open parentheses), **close** (the count of close parentheses), and **n** (the desired number of pairs of parentheses).\\n2. The base case of the recursion is when the length of the **current** string is equal to **2 * n**. In this case, all open and close parentheses have been used, so the **current** string represents a valid combination of parentheses. Add the **current** string to the **result** vector and return.\\n3. If the count of open parentheses (**open**) is less than **n**, it means there are still available open parentheses. Append an opening parenthesis \\'(\\' to the **current** string and make a recursive call to **backtrack**, incrementing **open** by 1. This explores the possibility of using an open parenthesis at this position.\\n4. If the count of close parentheses (**close**) is less than **open**, it means there are more open parentheses than close parentheses in the **current** string. Append a closing parenthesis \\')\\' to the **current** string and make a recursive call to **backtrack**, incrementing close by 1. This explores the possibility of using a **close** parenthesis to match an existing open parenthesis.\\n5. After each recursive call, remove the last character from the **current** string to revert it back to the previous state. This is necessary to explore other possibilities and combinations.\\n6. Call the **backtrack** function initially with an empty **current** string, and both **open** and **close** counts set to 0.\\n7. Finally, return the **result** vector containing all valid combinations of parentheses.\\n\\nThe backtracking algorithm explores all possible combinations of parentheses by making recursive calls, adding opening parentheses when there are still available, and adding closing parentheses when there are more openings than closings. This guarantees that all valid combinations of parentheses of length 2 * n are generated.\\n\\n# Complexity\\n- Time complexity:\\n$$O(C(n))$$, where $$C(n)$$ is the Catalan number, which is approximately $$4^n/n^{3/2}$$\\n\\n- Space complexity:\\n$$O(C(n))$$, where $$C(n)$$ is the Catalan number, which is approximately $$4^n/n^{3/2}$$\\n# Code\\n```c++\\nclass Solution {\\npublic:\\n    void backtrack(vector<string>& result, string& current, int open, int close, int n) {\\n        if (current.length() == 2 * n) {\\n            result.push_back(current);\\n            return;\\n        }\\n        \\n        if (open < n) {\\n            current.push_back(\\'(\\');\\n            backtrack(result, current, open + 1, close, n);\\n            current.pop_back();\\n        }\\n        \\n        if (close < open) {\\n            current.push_back(\\')\\');\\n            backtrack(result, current, open, close + 1, n);\\n            current.pop_back();\\n        }\\n    }\\n\\n    vector<string> generateParenthesis(int n) {\\n        vector<string> result;\\n        string current;\\n        \\n        backtrack(result, current, 0, 0, n);\\n        \\n        return result;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "String",
                    "Backtracking",
                    "Depth-First Search",
                    "Recursion"
                ],
                "code": "```c++\\nclass Solution {\\npublic:\\n    void backtrack(vector<string>& result, string& current, int open, int close, int n) {\\n        if (current.length() == 2 * n) {\\n            result.push_back(current);\\n            return;\\n        }\\n        \\n        if (open < n) {\\n            current.push_back(\\'(\\');\\n            backtrack(result, current, open + 1, close, n);\\n            current.pop_back();\\n        }\\n        \\n        if (close < open) {\\n            current.push_back(\\')\\');\\n            backtrack(result, current, open, close + 1, n);\\n            current.pop_back();\\n        }\\n    }\\n\\n    vector<string> generateParenthesis(int n) {\\n        vector<string> result;\\n        string current;\\n        \\n        backtrack(result, current, 0, 0, n);\\n        \\n        return result;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3375419,
                "title": "typescript-javascript-recursive-approach-to-generate-valid-parens",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nAt first i generated all combinations of parens and then filtered them down based on if it was valid\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nBetter (this) approach is to add an open or closed paren if either one is a valid option. \\n\\nIf there are any open parens left to add, you can always add an open paren. \\n\\nif there are more open parens then closed ones, you can add a closed paren.\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nO (n)\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nfunction generateParenthesis(n: number): string[] {\\n    /*\\n        create all possible valid combinations\\n        at each \\n    */\\n    const allCombos = []\\n\\n    function recurse(\\n        openParens: number, closedParens: number, combo: string\\n    ) {\\n        if (openParens === 0 && closedParens === 0) {\\n            allCombos.push(combo)\\n            return\\n        }\\n        \\n        // if there are open parens to close\\n        if (openParens < closedParens) {\\n            recurse(openParens, closedParens - 1, combo + \\')\\')\\n        }\\n\\n        // if there are open parens left to use\\n        if (openParens > 0) {\\n            recurse(openParens - 1, closedParens, combo + \\'(\\')\\n        }\\n    }\\n\\n    recurse(n, n, \\'\\')\\n\\n    return allCombos\\n}\\n```",
                "solutionTags": [
                    "TypeScript"
                ],
                "code": "```\\nfunction generateParenthesis(n: number): string[] {\\n    /*\\n        create all possible valid combinations\\n        at each \\n    */\\n    const allCombos = []\\n\\n    function recurse(\\n        openParens: number, closedParens: number, combo: string\\n    ) {\\n        if (openParens === 0 && closedParens === 0) {\\n            allCombos.push(combo)\\n            return\\n        }\\n        \\n        // if there are open parens to close\\n        if (openParens < closedParens) {\\n            recurse(openParens, closedParens - 1, combo + \\')\\')\\n        }\\n\\n        // if there are open parens left to use\\n        if (openParens > 0) {\\n            recurse(openParens - 1, closedParens, combo + \\'(\\')\\n        }\\n    }\\n\\n    recurse(n, n, \\'\\')\\n\\n    return allCombos\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3164881,
                "title": "easy-c-solution",
                "content": "# Intuition\\n \\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n     void helper(vector<string> &v, int n, int oc, int cc, string s)\\n     {\\n         if(oc==n && cc==n){\\n             v.push_back(s);\\n             return ;\\n         }\\n         if(oc<n){\\n             helper(v,n,oc+1,cc,s+\"(\");\\n         }\\n         if(cc < oc){\\n             helper(v,n,oc, cc+1, s+\")\");\\n         }\\n\\n     }\\n    vector<string> generateParenthesis(int n) {\\n        vector<string> v;\\n        int oc=0, cc=0;\\n        helper(v,n,oc,cc,\"\");\\n        return v;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n     void helper(vector<string> &v, int n, int oc, int cc, string s)\\n     {\\n         if(oc==n && cc==n){\\n             v.push_back(s);\\n             return ;\\n         }\\n         if(oc<n){\\n             helper(v,n,oc+1,cc,s+\"(\");\\n         }\\n         if(cc < oc){\\n             helper(v,n,oc, cc+1, s+\")\");\\n         }\\n\\n     }\\n    vector<string> generateParenthesis(int n) {\\n        vector<string> v;\\n        int oc=0, cc=0;\\n        helper(v,n,oc,cc,\"\");\\n        return v;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3035511,
                "title": "easiest-faang-method-ever",
                "content": "---\\n# \\uD83D\\uDE03***Please do Upvote if it helps \\u2764\\uFE0F***\\n\\n---\\n\\n\\n# Complexity\\n- Time complexity: O(2^n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(2^n + n)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    void parentheses(int open, int closed, string &s, vector<string> &ans){\\n        if(open == 0 && closed == 0){\\n            ans.emplace_back(s);\\n            return;\\n        }\\n        if(open>0){\\n            s+=\"(\";\\n            parentheses(open-1, closed, s, ans);\\n            s.pop_back();\\n        }\\n        if(closed>0 && closed>open){\\n            s+=\")\";\\n            parentheses(open, closed-1, s, ans);\\n            s.pop_back();\\n        }\\n    }\\n    vector<string> generateParenthesis(int n) {\\n        vector<string> ans;\\n        string s=\"(\";\\n        int open = n-1;\\n        int closed = n;\\n        parentheses(open, closed, s, ans); \\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Java",
                    "String",
                    "Dynamic Programming",
                    "Backtracking"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    void parentheses(int open, int closed, string &s, vector<string> &ans){\\n        if(open == 0 && closed == 0){\\n            ans.emplace_back(s);\\n            return;\\n        }\\n        if(open>0){\\n            s+=\"(\";\\n            parentheses(open-1, closed, s, ans);\\n            s.pop_back();\\n        }\\n        if(closed>0 && closed>open){\\n            s+=\")\";\\n            parentheses(open, closed-1, s, ans);\\n            s.pop_back();\\n        }\\n    }\\n    vector<string> generateParenthesis(int n) {\\n        vector<string> ans;\\n        string s=\"(\";\\n        int open = n-1;\\n        int closed = n;\\n        parentheses(open, closed, s, ans); \\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2841085,
                "title": "simple-java-recursion-and-backtracking",
                "content": "\\nIdea is to recursively explore all valid combinations.\\n    There are 2 options in every step.\\n        \\n1. Open: if there are more paranthesis to open. if there is an open paranthesis, there must be a close paranthesis too. So increment closable by 1.\\n1. Cose: recursively do this iff there are any closable paranthesis left.\\n\\n```\\n\\nclass Solution {\\n    \\n    private List<String> res = new ArrayList<>();\\n    \\n    public List<String> generateParenthesis(int n) {\\n         rec(n,0,\"\");\\n        return res;\\n    }\\n\\t\\n    void rec(int rem, int closable, String cur){\\n        \\n        if(rem==0 && closable==0){\\n            res.add(cur);\\n            return;\\n        }\\n        \\n        if(rem>0)\\n            rec(rem-1, closable+1, cur+\"(\");\\n        \\n        if(closable>0)\\n            rec(rem,closable-1,cur+\")\");\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Backtracking",
                    "Recursion"
                ],
                "code": "```\\n\\nclass Solution {\\n    \\n    private List<String> res = new ArrayList<>();\\n    \\n    public List<String> generateParenthesis(int n) {\\n         rec(n,0,\"\");\\n        return res;\\n    }\\n\\t\\n    void rec(int rem, int closable, String cur){\\n        \\n        if(rem==0 && closable==0){\\n            res.add(cur);\\n            return;\\n        }\\n        \\n        if(rem>0)\\n            rec(rem-1, closable+1, cur+\"(\");\\n        \\n        if(closable>0)\\n            rec(rem,closable-1,cur+\")\");\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2518802,
                "title": "simple-solution-explained",
                "content": "```\\nclass Solution:\\n    def generateParenthesis(self, n: int) -> List[str]:\\n        #Answer will be returned in this result array.\\n        result = []\\n        \\n        #openCount: How many open parentheses ie how many \"(\" are there in the string\\n        #closeCount: How many close parentheses ie how many \")\" are there in the string\\n        def generateSequence(string, openCount, closeCount):\\n            #if string length is 2n ie you have generated the required sequence. \\n            #Now you can add this to the result.\\n            if len(string) == 2*n:\\n                result.append(string)\\n                return\\n            \\n            #Add open parentheses only if openCount is less than 0\\n            #remember open and close count start from 0 and not from 1.\\n            if openCount < n:\\n                generateSequence(string+\"(\", openCount+1, closeCount)\\n            #Add close parentheses only if closeCount is less than 0 and also \\n            #close count is less than open count.\\n            #you cant have close parentheses before you have an open parenteses\\n            #This condition takes care of that. \\n            if closeCount < n and closeCount < openCount:\\n                generateSequence(string+\")\", openCount, closeCount+1)\\n            \\n        #Initially string is empty\\n        #and counts are both 0\\n        generateSequence(\"\", 0, 0)\\n        return result",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nclass Solution:\\n    def generateParenthesis(self, n: int) -> List[str]:\\n        #Answer will be returned in this result array.\\n        result = []\\n        \\n        #openCount: How many open parentheses ie how many \"(\" are there in the string\\n        #closeCount: How many close parentheses ie how many \")\" are there in the string\\n        def generateSequence(string, openCount, closeCount):\\n            #if string length is 2n ie you have generated the required sequence. \\n            #Now you can add this to the result.\\n            if len(string) == 2*n:\\n                result.append(string)\\n                return\\n            \\n            #Add open parentheses only if openCount is less than 0\\n            #remember open and close count start from 0 and not from 1.\\n            if openCount < n:\\n                generateSequence(string+\"(\", openCount+1, closeCount)\\n            #Add close parentheses only if closeCount is less than 0 and also \\n            #close count is less than open count.\\n            #you cant have close parentheses before you have an open parenteses\\n            #This condition takes care of that. \\n            if closeCount < n and closeCount < openCount:\\n                generateSequence(string+\")\", openCount, closeCount+1)\\n            \\n        #Initially string is empty\\n        #and counts are both 0\\n        generateSequence(\"\", 0, 0)\\n        return result",
                "codeTag": "Java"
            },
            {
                "id": 2299428,
                "title": "java-c-javascript-100-fully-explained-with-comments-very-easy",
                "content": "# **Java Solution:**\\n```\\nclass Solution {\\n    public List<String> generateParenthesis(int n) {\\n        //Create a list that will store the solution\\n        List<String> sol = new ArrayList<>();\\n        //Recursively call backtracking function\\n        generator(0, 0, \"\", sol, n);\\n        return sol;\\n    }\\n    \\n    private void generator(int op, int cl, String str, List<String> sol, int n) {\\n        //Check the base case.\\n        //If number of opening and closing parentheses are equal to n..\\n        if(op == n && cl == n) {\\n            //add the string(str) to the list\\n            sol.add(str);\\n            return;\\n        }\\n        //if no. of opening parentheses(op) is less than n...\\n        if(op < n) {\\n            //add \\'(\\' to the current string and increment the count of opening parenthesis(op)\\n            generator(op + 1, cl, str + \\'(\\', sol, n);\\n        }\\n        //if no. of closing parentheses is less than open parentheses...\\n        if(cl < n && op > cl) {\\n            //add \\')\\' to the current string and increment the count of closing parentheses(cl)\\n            generator(op, cl + 1, str + \\')\\', sol, n);\\n        }\\n    }\\n}\\n```\\n\\n# **C++ Solution:**\\n```\\nclass Solution {\\npublic:\\n    //Create a list that will store the solution\\n    vector<string> sol;\\n    \\n    void generator(int op, int cl, string str, int n) {\\n        //Check the base case.\\n        //If number of opening and closing parentheses are equal to n..\\n        if(op == n && cl == n) {\\n            //add the string(str) to the list\\n            sol.push_back(str);\\n            return;\\n        }\\n        //if no. of opening parentheses(op) is less than n...\\n        if(op < n)\\n            //add \\'(\\' to the current string and increment the count of opening parenthesis(op)\\n            generator(op + 1, cl, str + \\'(\\', n);\\n        //if no. of closing parentheses is less than open parentheses...\\n        if(cl < n && op > cl)\\n            //add \\')\\' to the current string and increment the count of closing parentheses(cl)\\n            generator(op, cl + 1, str + \\')\\', n);\\n    }\\n    vector<string> generateParenthesis(int n) {\\n        //Recursively call backtracking function\\n        generator(0, 0, \"\", n);\\n        return sol;   \\n    }\\n};\\n```\\n\\n# **Javascript Solution:**\\n```\\nvar generateParenthesis = function(n) {\\n    //Create a list that will store the solution\\n    const sol = [];\\n    //Recursively call backtracking function\\n    generator(0, 0, \"\", sol, n);\\n    return sol;\\n};\\n\\nfunction generator(op, cl, str, sol, n) {\\n        //Check the base case.\\n        //If number of opening and closing parentheses are equal to n..\\n        if(op === n && cl === n) {\\n            //add the string(str) to the list\\n            sol.push(str);\\n            return;\\n        }\\n        //if no. of opening parentheses(op) is less than n...\\n        if(op < n) {\\n            //add \\'(\\' to the current string and increment the count of opening parenthesis(op)\\n            generator(op + 1, cl, str + \\'(\\', sol, n);\\n        }\\n        //if no. of closing parentheses is less than open parentheses...\\n        if(cl < n && op > cl) {\\n            //add \\')\\' to the current string and increment the count of closing parentheses(cl)\\n            generator(op, cl + 1, str + \\')\\', sol, n);\\n        }\\n};\\n```",
                "solutionTags": [
                    "Java",
                    "C",
                    "JavaScript"
                ],
                "code": "```\\nclass Solution {\\n    public List<String> generateParenthesis(int n) {\\n        //Create a list that will store the solution\\n        List<String> sol = new ArrayList<>();\\n        //Recursively call backtracking function\\n        generator(0, 0, \"\", sol, n);\\n        return sol;\\n    }\\n    \\n    private void generator(int op, int cl, String str, List<String> sol, int n) {\\n        //Check the base case.\\n        //If number of opening and closing parentheses are equal to n..\\n        if(op == n && cl == n) {\\n            //add the string(str) to the list\\n            sol.add(str);\\n            return;\\n        }\\n        //if no. of opening parentheses(op) is less than n...\\n        if(op < n) {\\n            //add \\'(\\' to the current string and increment the count of opening parenthesis(op)\\n            generator(op + 1, cl, str + \\'(\\', sol, n);\\n        }\\n        //if no. of closing parentheses is less than open parentheses...\\n        if(cl < n && op > cl) {\\n            //add \\')\\' to the current string and increment the count of closing parentheses(cl)\\n            generator(op, cl + 1, str + \\')\\', sol, n);\\n        }\\n    }\\n}\\n```\n```\\nclass Solution {\\npublic:\\n    //Create a list that will store the solution\\n    vector<string> sol;\\n    \\n    void generator(int op, int cl, string str, int n) {\\n        //Check the base case.\\n        //If number of opening and closing parentheses are equal to n..\\n        if(op == n && cl == n) {\\n            //add the string(str) to the list\\n            sol.push_back(str);\\n            return;\\n        }\\n        //if no. of opening parentheses(op) is less than n...\\n        if(op < n)\\n            //add \\'(\\' to the current string and increment the count of opening parenthesis(op)\\n            generator(op + 1, cl, str + \\'(\\', n);\\n        //if no. of closing parentheses is less than open parentheses...\\n        if(cl < n && op > cl)\\n            //add \\')\\' to the current string and increment the count of closing parentheses(cl)\\n            generator(op, cl + 1, str + \\')\\', n);\\n    }\\n    vector<string> generateParenthesis(int n) {\\n        //Recursively call backtracking function\\n        generator(0, 0, \"\", n);\\n        return sol;   \\n    }\\n};\\n```\n```\\nvar generateParenthesis = function(n) {\\n    //Create a list that will store the solution\\n    const sol = [];\\n    //Recursively call backtracking function\\n    generator(0, 0, \"\", sol, n);\\n    return sol;\\n};\\n\\nfunction generator(op, cl, str, sol, n) {\\n        //Check the base case.\\n        //If number of opening and closing parentheses are equal to n..\\n        if(op === n && cl === n) {\\n            //add the string(str) to the list\\n            sol.push(str);\\n            return;\\n        }\\n        //if no. of opening parentheses(op) is less than n...\\n        if(op < n) {\\n            //add \\'(\\' to the current string and increment the count of opening parenthesis(op)\\n            generator(op + 1, cl, str + \\'(\\', sol, n);\\n        }\\n        //if no. of closing parentheses is less than open parentheses...\\n        if(cl < n && op > cl) {\\n            //add \\')\\' to the current string and increment the count of closing parentheses(cl)\\n            generator(op, cl + 1, str + \\')\\', sol, n);\\n        }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2140410,
                "title": "java-backtracking-detailed-explanation",
                "content": "```\\n/*\\nClassic Backtracking Problem\\nFor a Backtracking Problem : Remember the 3 Parts\\n1. Choices\\n2. Constraints\\n3. Goal Condition\\n\\n1. The Choices in this case is to either put a \"(\" or \")\"\\n2. The Constraints are\\n   (a) -> The number of openBrackets or ClosedBrackets cannot be more than n\\n   (b) -> A ClosedBracket cannot be added to an empty string, i.e. a corresponding open bracket is needed\\n   (c) -> The count of closedBracket cannot be more than that of OpenBracket at any given time\\n3. The Goal Condition is when the length of the string becomes 2*n\\n\\n*/\\n\\nclass Solution {\\n    public List<String> generateParenthesis(int n) {\\n        List<String> res = new ArrayList<String>();\\n        backTrack(\"\",res,0,0,n);\\n        return res;\\n    }\\n    \\n    public void backTrack(String currWord, List<String> res,int openCount, int closedCount, int n){\\n        //If the Goal Condition is reached\\n        if(currWord.length()==n*2){\\n            res.add(currWord);\\n            return;\\n        }\\n        \\n        //If the number of openBrackets are less than n, keeping recursively calling\\n        if(openCount<n){\\n            backTrack(currWord + \"(\", res, openCount+1, closedCount, n);\\n        }\\n        \\n        //If the count of closedBrackets is less than openCount -> It is valid to add\\n        if(closedCount<openCount){\\n            backTrack(currWord + \")\", res, openCount, closedCount+1, n);\\n        }\\n        \\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Backtracking"
                ],
                "code": "```\\n/*\\nClassic Backtracking Problem\\nFor a Backtracking Problem : Remember the 3 Parts\\n1. Choices\\n2. Constraints\\n3. Goal Condition\\n\\n1. The Choices in this case is to either put a \"(\" or \")\"\\n2. The Constraints are\\n   (a) -> The number of openBrackets or ClosedBrackets cannot be more than n\\n   (b) -> A ClosedBracket cannot be added to an empty string, i.e. a corresponding open bracket is needed\\n   (c) -> The count of closedBracket cannot be more than that of OpenBracket at any given time\\n3. The Goal Condition is when the length of the string becomes 2*n\\n\\n*/\\n\\nclass Solution {\\n    public List<String> generateParenthesis(int n) {\\n        List<String> res = new ArrayList<String>();\\n        backTrack(\"\",res,0,0,n);\\n        return res;\\n    }\\n    \\n    public void backTrack(String currWord, List<String> res,int openCount, int closedCount, int n){\\n        //If the Goal Condition is reached\\n        if(currWord.length()==n*2){\\n            res.add(currWord);\\n            return;\\n        }\\n        \\n        //If the number of openBrackets are less than n, keeping recursively calling\\n        if(openCount<n){\\n            backTrack(currWord + \"(\", res, openCount+1, closedCount, n);\\n        }\\n        \\n        //If the count of closedBrackets is less than openCount -> It is valid to add\\n        if(closedCount<openCount){\\n            backTrack(currWord + \")\", res, openCount, closedCount+1, n);\\n        }\\n        \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1519267,
                "title": "brute-force-to-optimized-approach-c",
                "content": "# **Brute Force**\\n\\n```\\nclass Solution {\\nprivate:\\n    int solve(int n,vector<string>&res,int open=0,int close=0,string str=\"\"){\\n        if(open>n || close>n){\\n            return 0;\\n        }\\n        if(open+close==2*n){\\n            res.push_back(str);\\n            return 1;\\n        }\\n        int o=0,c=0;\\n        o=solve(n,res,open+1,close,str+\"(\");\\n        if(open>close){\\n            =solve(n,res,open,close+1,str+\")\");\\n        }\\n        \\n    }\\npublic:\\n    vector<string> generateParenthesis(int n) {\\n        vector<string>res;\\n        solve(n,res);\\n        return res;\\n    }\\n};\\n```\\n**Time Complexity is O(2^(2*N))** \\n**Space Complexity is O(2*N) (due to stack)**\\nNow this will pass because the constraint n is very small.\\nBut in case of larger n we will have to resort to Some other approach.\\n\\n# **Optimized approach**\\nWhen we look into the pattern we see that it forms overlaping subproblems.\\nSuppose dp[i] contains all the valid parentheses possible of length 2*i. \\nSuppose you got dp[2] which is { (()) , ()() }. Now what will be dp[3]? It can be written as -\\n\\n( + dp[0] + ) + dp[2] = ()(()) and ()()()\\n( + dp[1] + ) + dp[1] = (())()\\n( + dp[2] + ) + dp[0] = ((())) and (()())\\n\\nhere we see that instead of doing the recusion of we store these values \\n**Using Bottom Up DP**\\n```\\nclass Solution {\\npublic:\\n    vector<string> generateParenthesis(int n) {\\n        vector<vector<string>>dp(n+1);\\n        dp[0]={\"\"};\\n        \\n        for(int i=1;i<=n;i++){\\n            for(int j=0;j<i;j++){\\n                vector<string>left=dp[j];\\n                vector<string>right=dp[i-j-1];\\n                for(auto &l:left){\\n                    for(auto &r:right){\\n                        dp[i].push_back(\"(\"+l+\")\"+r);\\n                    }\\n                }\\n            }\\n        }\\n        return dp[n];\\n    }\\n};\\n```\\n**Time Complexity O(N^4)**\\n**Space Complexity O(N*N)**\\n\\n\\n# **Futher Optimization**\\nnow we can decalrte a global variable and checking in the first loop if that had been covered in previous iteration then skip it.\\nThus further reducing time complexity though it increases space complexity.\\n```\\nclass Solution {\\nvector<vector<string>>dp;\\npublic:\\n    vector<string> generateParenthesis(int n) {\\n        dp.resize(n+1);\\n        dp[0]={\"\"};\\n        for(int i=1;i<=n;i++){\\n            if(dp[i].size()){\\n                continue;\\n            }\\n            for(int j=0;j<i;j++){\\n                vector<string>left=dp[j];\\n                vector<string>right=dp[i-j-1];\\n                for(auto &l:left){\\n                    for(auto &r:right){\\n                        dp[i].push_back(\"(\"+l+\")\"+r);\\n                    }\\n                }\\n            }\\n        }\\n        return dp[n];\\n    }\\n};\\n```",
                "solutionTags": [
                    "Dynamic Programming",
                    "Recursion",
                    "Memoization"
                ],
                "code": "```\\nclass Solution {\\nprivate:\\n    int solve(int n,vector<string>&res,int open=0,int close=0,string str=\"\"){\\n        if(open>n || close>n){\\n            return 0;\\n        }\\n        if(open+close==2*n){\\n            res.push_back(str);\\n            return 1;\\n        }\\n        int o=0,c=0;\\n        o=solve(n,res,open+1,close,str+\"(\");\\n        if(open>close){\\n            =solve(n,res,open,close+1,str+\")\");\\n        }\\n        \\n    }\\npublic:\\n    vector<string> generateParenthesis(int n) {\\n        vector<string>res;\\n        solve(n,res);\\n        return res;\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    vector<string> generateParenthesis(int n) {\\n        vector<vector<string>>dp(n+1);\\n        dp[0]={\"\"};\\n        \\n        for(int i=1;i<=n;i++){\\n            for(int j=0;j<i;j++){\\n                vector<string>left=dp[j];\\n                vector<string>right=dp[i-j-1];\\n                for(auto &l:left){\\n                    for(auto &r:right){\\n                        dp[i].push_back(\"(\"+l+\")\"+r);\\n                    }\\n                }\\n            }\\n        }\\n        return dp[n];\\n    }\\n};\\n```\n```\\nclass Solution {\\nvector<vector<string>>dp;\\npublic:\\n    vector<string> generateParenthesis(int n) {\\n        dp.resize(n+1);\\n        dp[0]={\"\"};\\n        for(int i=1;i<=n;i++){\\n            if(dp[i].size()){\\n                continue;\\n            }\\n            for(int j=0;j<i;j++){\\n                vector<string>left=dp[j];\\n                vector<string>right=dp[i-j-1];\\n                for(auto &l:left){\\n                    for(auto &r:right){\\n                        dp[i].push_back(\"(\"+l+\")\"+r);\\n                    }\\n                }\\n            }\\n        }\\n        return dp[n];\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1462096,
                "title": "dynamic-programming-java-memory-beats-85",
                "content": "Instead of using backtrack - which is a little bit hard to handle - I used a Dynamic Programming method that does not involve recursion. \\n\\nThe gist is as such:\\n\\nWe create the parenthesis array for n by adding \"()\" inside of, and in parallel with, another \"()\" for every string element in the \"n-1\" parenthesis array. \\n\\nThis may look a bit confusing. Let me explain using an example. \\n\\nThe \"n=1\" array is a single \"( )\".\\n\\nTo create the \"n=2\" array, we add another \"()\" both inside of, and in parrallel with the existing \"()\". Therefore we have such: [ \"( )( )\", \"(( ))\"]\\n\\nTo create the \"n=3\" array, we do the above operation to each and every element in the \"n=2\" array. \\n\\nSo, for \"( ) ( )\", we have \"( ) ( ) ( )\" , \"( ( ) ) ( )\", and \"( ) ( ( ) )\". \\nAnd for \"( ( ) ) \", we have \" ( ( ) ( ) ) \"and \"( ( ( ) ) )\".\\n\\nTherefore, for n=3 we have an array that reads :\\n\\n[\"( ) ( ) ( )\",  \"( ( ) ) ( )\", \"( ) ( ( ) )\",  \"( ( ) ) \", \" ( ( ) ( ) ) \", \"( ( ( ) ) )\"]\\n\\nNote that sometimes, you may end up creating duplicate entries. Luckily we can use a hashset to remove them automatically.\\n\\nwhen n =4, we repeat the same operation to EACH AND EVERY element in the n=3 array.\\n\\n```\\n  public List<String> generateParenthesis(int n) {\\n        List<String> first = Arrays.asList(\"()\");\\n        if (n == 1) return first;\\n        for (int i = 1; i < n; i++) {\\n            HashSet<String> set = this.processStrings(first);\\n            first = new ArrayList<>();\\n            for (String ss : set) {\\n//                System.out.println(ss);\\n                first.add(ss);\\n            }\\n        }\\n        for (String s : first) {\\n            System.out.println(s);\\n        }\\n\\n        return first;\\n    }\\n\\n\\n    private HashSet<String> processStrings(List<String> strings) {\\n\\n        HashSet<String> set = new HashSet<>();\\n\\n        for (String s : strings) {\\n            this.processString(s, set);\\n        }\\n        return set;\\n    }\\n\\n    private void processString(String s, HashSet<String> set) {\\n        int index = 0;\\n        while (s.indexOf(\"()\", index) != -1) {\\n\\n            index = s.indexOf(\"()\", index) + 1;\\n\\n            String newString;\\n            String newString2;\\n            if (index < s.length() - 1) {\\n\\n                s.substring(0, index);\\n                s.substring(index + 2);\\n                newString = s.substring(0, index - 1) + \"()()\" + s.substring(index + 1);\\n                newString2 = s.substring(0, index - 1) + \"(())\" + s.substring(index + 1);\\n\\n                set.add(newString);\\n                set.add(newString2);\\n\\n            } else if (index == s.length() - 1) {\\n                newString = s.substring(0, index - 1) + \"()()\";\\n                newString2 = s.substring(0, index - 1) + \"(())\";\\n\\n                set.add(newString);\\n                set.add(newString2);\\n            }\\n        }\\n    }\\n```\\n",
                "solutionTags": [],
                "code": "```\\n  public List<String> generateParenthesis(int n) {\\n        List<String> first = Arrays.asList(\"()\");\\n        if (n == 1) return first;\\n        for (int i = 1; i < n; i++) {\\n            HashSet<String> set = this.processStrings(first);\\n            first = new ArrayList<>();\\n            for (String ss : set) {\\n//                System.out.println(ss);\\n                first.add(ss);\\n            }\\n        }\\n        for (String s : first) {\\n            System.out.println(s);\\n        }\\n\\n        return first;\\n    }\\n\\n\\n    private HashSet<String> processStrings(List<String> strings) {\\n\\n        HashSet<String> set = new HashSet<>();\\n\\n        for (String s : strings) {\\n            this.processString(s, set);\\n        }\\n        return set;\\n    }\\n\\n    private void processString(String s, HashSet<String> set) {\\n        int index = 0;\\n        while (s.indexOf(\"()\", index) != -1) {\\n\\n            index = s.indexOf(\"()\", index) + 1;\\n\\n            String newString;\\n            String newString2;\\n            if (index < s.length() - 1) {\\n\\n                s.substring(0, index);\\n                s.substring(index + 2);\\n                newString = s.substring(0, index - 1) + \"()()\" + s.substring(index + 1);\\n                newString2 = s.substring(0, index - 1) + \"(())\" + s.substring(index + 1);\\n\\n                set.add(newString);\\n                set.add(newString2);\\n\\n            } else if (index == s.length() - 1) {\\n                newString = s.substring(0, index - 1) + \"()()\";\\n                newString2 = s.substring(0, index - 1) + \"(())\";\\n\\n                set.add(newString);\\n                set.add(newString2);\\n            }\\n        }\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1361937,
                "title": "recursive-tree-and-implementation",
                "content": "![image](https://assets.leetcode.com/users/images/d795b906-b24a-4a0a-9297-11c542243397_1627219155.438998.png)\\n```\\nclass Solution {\\npublic:\\n    vector<string> ans;\\n    void func(string &s , int open , int close){\\n        if (open == 0 and close == 0){\\n            ans.push_back(s);\\n            return;\\n        }\\n        if (open > close or open < 0 or close < 0)\\n            return;\\n        s.push_back(\\'(\\');\\n        func(s , open-1 , close);\\n        s.pop_back();\\n        s.push_back(\\')\\');\\n        func(s , open , close-1);\\n        s.pop_back();\\n        return;\\n    }\\n    \\n    vector<string> generateParenthesis(int n) {\\n        string s;\\n        func(s , n , n);\\n        return ans;\\n    }\\n};\\n```\\n",
                "solutionTags": [
                    "Backtracking",
                    "Recursion"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<string> ans;\\n    void func(string &s , int open , int close){\\n        if (open == 0 and close == 0){\\n            ans.push_back(s);\\n            return;\\n        }\\n        if (open > close or open < 0 or close < 0)\\n            return;\\n        s.push_back(\\'(\\');\\n        func(s , open-1 , close);\\n        s.pop_back();\\n        s.push_back(\\')\\');\\n        func(s , open , close-1);\\n        s.pop_back();\\n        return;\\n    }\\n    \\n    vector<string> generateParenthesis(int n) {\\n        string s;\\n        func(s , n , n);\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1322204,
                "title": "c-solution-using-stack-easy-to-understand",
                "content": "```\\nclass Solution {\\npublic:\\n   static bool isValid(string m)\\n    {\\n        if(m[0]==\\')\\')\\n            return false;\\n        stack<string> s;\\n        for(int i =0;i<m.length();i++)\\n        {\\n            if(m[i]==\\'(\\')\\n                s.push(\"(\");\\n            else if(s.empty()&&m[i]==\\')\\')\\n                    return false;\\n            else if(m[i]==\\')\\')\\n                s.pop();\\n        }\\n        if(s.empty())\\n            return true;\\n        else\\n            return false;\\n    }\\n    vector<string> generateParenthesis(int n) {\\n        string s;\\n        vector<string> v;\\n        for(int i =0;i<n;i++)\\n        {\\n            s+=\"(\";\\n        }\\n        for(int i =0;i<n;i++)\\n        {\\n            s+=\")\";\\n        }\\n        v.push_back(s);\\n        while(next_permutation(s.begin(),s.end()))\\n        {\\n            if(isValid(s))\\n                v.push_back(s);\\n        }      \\n        return v;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Stack"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n   static bool isValid(string m)\\n    {\\n        if(m[0]==\\')\\')\\n            return false;\\n        stack<string> s;\\n        for(int i =0;i<m.length();i++)\\n        {\\n            if(m[i]==\\'(\\')\\n                s.push(\"(\");\\n            else if(s.empty()&&m[i]==\\')\\')\\n                    return false;\\n            else if(m[i]==\\')\\')\\n                s.pop();\\n        }\\n        if(s.empty())\\n            return true;\\n        else\\n            return false;\\n    }\\n    vector<string> generateParenthesis(int n) {\\n        string s;\\n        vector<string> v;\\n        for(int i =0;i<n;i++)\\n        {\\n            s+=\"(\";\\n        }\\n        for(int i =0;i<n;i++)\\n        {\\n            s+=\")\";\\n        }\\n        v.push_back(s);\\n        while(next_permutation(s.begin(),s.end()))\\n        {\\n            if(isValid(s))\\n                v.push_back(s);\\n        }      \\n        return v;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1295346,
                "title": "100-faster-c-i-e-0ms-with-explanation",
                "content": "\\n    vector<string> ans; //container of  all possible answers\\n    void dfs(string& path, int open, int close){\\n        if(open==0 and close==0){  // here we donot have either of the bracket so add it to our answer\\n            ans.push_back(path);\\n            return ;\\n        }\\n        if(open>0){ // here we still can add more open brackets in out answers\\n            path.push_back(\\'(\\');\\n            dfs(path, open-1, close); // now update the open \\n            path.pop_back(); // yes we did the backtrack here to try out all possibility\\n        }\\n        if(close>0 and open < close){ // if and only if we have close brackets and at this current sopt we have more number of open brackets than close ones.\\n            path.push_back(\\')\\');\\n            dfs(path,open,close-1);\\n            path.pop_back(); // here also we need to backtrack\\n        }\\n    }\\n    vector<string> generateParenthesis(int n) {\\n        string s; // initial path ie. blank\\n        // in starting we have n number of open and n number of close brackets \\n        dfs(s,n,n); // ran a sort of dfs tried out all possibility\\n        return ans; // return the ans at last when we are done\\n    }",
                "solutionTags": [],
                "code": "\\n    vector<string> ans; //container of  all possible answers\\n    void dfs(string& path, int open, int close){\\n        if(open==0 and close==0){  // here we donot have either of the bracket so add it to our answer\\n            ans.push_back(path);\\n            return ;\\n        }\\n        if(open>0){ // here we still can add more open brackets in out answers\\n            path.push_back(\\'(\\');\\n            dfs(path, open-1, close); // now update the open \\n            path.pop_back(); // yes we did the backtrack here to try out all possibility\\n        }\\n        if(close>0 and open < close){ // if and only if we have close brackets and at this current sopt we have more number of open brackets than close ones.\\n            path.push_back(\\')\\');\\n            dfs(path,open,close-1);\\n            path.pop_back(); // here also we need to backtrack\\n        }\\n    }\\n    vector<string> generateParenthesis(int n) {\\n        string s; // initial path ie. blank\\n        // in starting we have n number of open and n number of close brackets \\n        dfs(s,n,n); // ran a sort of dfs tried out all possibility\\n        return ans; // return the ans at last when we are done\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 1191129,
                "title": "c-recursive-solution-with-detailed-explanation",
                "content": "An integer value N is given as input. Total number of opening brackets = Total number of closing brackets = N. A recursive function solve is called with parameters open(no. of opening brackets), close(no. of closing brackets), current string and final answer res which is passed by reference.\\n\\nIf number of opening brackets = number of closing brackets = n, this implies leaf node has been reached in recursion tree and thus it is added to the res. If no. of opening brackets is not equal to 0 add an opening bracket to the current string and decrement the count of open and recursively call the function for new values.\\n\\nIf no. of closing brackets is greater than number of opening brackets then a closing bracket is added to the current string and count of close is decremented by 1 and the function is recursively called for new values.\\n\\n\\n    void solve(int open, int close, string str, vector<string>& res)\\n    {\\n        if(open == 0 && close == 0)\\n        {\\n            res.push_back(str);\\n            return;\\n        }\\n        \\n        if(open != 0)\\n        {\\n            string str1 = str;\\n            str1.push_back(\\'(\\');\\n            solve(open - 1, close, str1, res);\\n        }\\n        \\n        if(close > open)\\n        {\\n            string str2 = str;\\n            str2.push_back(\\')\\');\\n            solve(open, close - 1, str2, res);\\n        }\\n        \\n        return;\\n    }\\n    \\n    vector<string> generateParenthesis(int n) \\n    {\\n        vector<string> res;\\n        int open = n;\\n        int close = n;\\n        \\n        string str = \"\";\\n        \\n        solve(open, close, str, res);\\n        return res;\\n    }\\n",
                "solutionTags": [
                    "C++",
                    "C",
                    "Recursion"
                ],
                "code": "An integer value N is given as input. Total number of opening brackets = Total number of closing brackets = N. A recursive function solve is called with parameters open(no. of opening brackets), close(no. of closing brackets), current string and final answer res which is passed by reference.\\n\\nIf number of opening brackets = number of closing brackets = n, this implies leaf node has been reached in recursion tree and thus it is added to the res. If no. of opening brackets is not equal to 0 add an opening bracket to the current string and decrement the count of open and recursively call the function for new values.\\n\\nIf no. of closing brackets is greater than number of opening brackets then a closing bracket is added to the current string and count of close is decremented by 1 and the function is recursively called for new values.\\n\\n\\n    void solve(int open, int close, string str, vector<string>& res)\\n    {\\n        if(open == 0 && close == 0)\\n        {\\n            res.push_back(str);\\n            return;\\n        }\\n        \\n        if(open != 0)\\n        {\\n            string str1 = str;\\n            str1.push_back(\\'(\\');\\n            solve(open - 1, close, str1, res);\\n        }\\n        \\n        if(close > open)\\n        {\\n            string str2 = str;\\n            str2.push_back(\\')\\');\\n            solve(open, close - 1, str2, res);\\n        }\\n        \\n        return;\\n    }\\n    \\n    vector<string> generateParenthesis(int n) \\n    {\\n        vector<string> res;\\n        int open = n;\\n        int close = n;\\n        \\n        string str = \"\";\\n        \\n        solve(open, close, str, res);\\n        return res;\\n    }\\n",
                "codeTag": "Unknown"
            },
            {
                "id": 1134167,
                "title": "60ms-faster-than-100-of-js-submissions",
                "content": "```\\nvar generateParenthesis = function(n) {\\n    let res = [];\\n    const go = (s=\"\",l=0,r=0)=>{\\n        if(s.length===2*n){\\n            res.push(s);\\n            return;\\n        }\\n        if(l<n) go(s+\\'(\\',l+1,r);\\n        if(r<l) go(s+\\')\\',l,r+1);\\n    }\\n    go();\\n    return res;\\n};",
                "solutionTags": [
                    "JavaScript",
                    "Backtracking"
                ],
                "code": "```\\nvar generateParenthesis = function(n) {\\n    let res = [];\\n    const go = (s=\"\",l=0,r=0)=>{\\n        if(s.length===2*n){\\n            res.push(s);\\n            return;\\n        }\\n        if(l<n) go(s+\\'(\\',l+1,r);\\n        if(r<l) go(s+\\')\\',l,r+1);\\n    }\\n    go();\\n    return res;\\n};",
                "codeTag": "Unknown"
            },
            {
                "id": 1056871,
                "title": "java-brute-force",
                "content": "```\\nclass Solution {\\n    \\n    List<String> arr = new ArrayList<String>();\\n    int finalLength;\\n    public List<String> generateParenthesis(int n) {\\n        this.finalLength = 2* n;\\n        helper(2*n, \"\");\\n        \\n        List<String> ans = new ArrayList<String>();\\n        for(String str: arr)\\n        {\\n            //System.out.println(str);\\n            if(check(str))\\n                ans.add(str);\\n        }\\n        \\n        return ans;\\n    }\\n    \\n    \\n    public void helper(int n, String str)\\n    {\\n        if(str.length() == finalLength)\\n            arr.add(str);\\n        if(n <= 0)\\n            return;\\n        \\n        String str1 = new String(str + \"(\");\\n        String str2 = new String(str + \")\");\\n        helper(n-1, str1);\\n        helper(n-1, str2);\\n        \\n    }\\n    \\n    \\n    public boolean check(String str)\\n    {\\n        Stack<Character> stack = new Stack<Character>();\\n        for(char ch: str.toCharArray())\\n        {\\n            if(ch == \\'(\\')\\n                stack.push(ch);\\n            else if(ch == \\')\\')\\n            {\\n                if(stack.isEmpty() || stack.peek()!=\\'(\\')\\n                    return false;\\n                stack.pop();\\n            }\\n        }\\n        if(!stack.isEmpty())\\n            return false;\\n        \\n        return true;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    \\n    List<String> arr = new ArrayList<String>();\\n    int finalLength;\\n    public List<String> generateParenthesis(int n) {\\n        this.finalLength = 2* n;\\n        helper(2*n, \"\");\\n        \\n        List<String> ans = new ArrayList<String>();\\n        for(String str: arr)\\n        {\\n            //System.out.println(str);\\n            if(check(str))\\n                ans.add(str);\\n        }\\n        \\n        return ans;\\n    }\\n    \\n    \\n    public void helper(int n, String str)\\n    {\\n        if(str.length() == finalLength)\\n            arr.add(str);\\n        if(n <= 0)\\n            return;\\n        \\n        String str1 = new String(str + \"(\");\\n        String str2 = new String(str + \")\");\\n        helper(n-1, str1);\\n        helper(n-1, str2);\\n        \\n    }\\n    \\n    \\n    public boolean check(String str)\\n    {\\n        Stack<Character> stack = new Stack<Character>();\\n        for(char ch: str.toCharArray())\\n        {\\n            if(ch == \\'(\\')\\n                stack.push(ch);\\n            else if(ch == \\')\\')\\n            {\\n                if(stack.isEmpty() || stack.peek()!=\\'(\\')\\n                    return false;\\n                stack.pop();\\n            }\\n        }\\n        if(!stack.isEmpty())\\n            return false;\\n        \\n        return true;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 996790,
                "title": "this-c-solution-is-very-easy-to-understand-beats-100-illustration",
                "content": "From the recusrive tree its very easy to find the base cases and operation, Hope it help a lot. (vote - up)\\n```\\nclass Solution {\\n    vector<string> s;\\npublic:\\n    \\n    void solve(string combi, int n, int mimicStack) {\\n        if(n == 0 && mimicStack == 0)\\n            s.push_back(combi);\\n        \\n        if(n > 0)\\n            solve(combi + \\'(\\', n-1, mimicStack+1);\\n\\n        if(mimicStack > 0)\\n            solve(combi + \\')\\', n, mimicStack-1);\\n    }\\n    \\n    vector<string> generateParenthesis(int n) {\\n        solve(\"\", n, 0);\\n        return s;\\n    }\\n};\\n```\\n![image](https://assets.leetcode.com/users/images/df18629d-7750-4d86-9dcb-793a36046dfe_1609517768.9531047.png)\\n",
                "solutionTags": [
                    "C++",
                    "C",
                    "Backtracking"
                ],
                "code": "```\\nclass Solution {\\n    vector<string> s;\\npublic:\\n    \\n    void solve(string combi, int n, int mimicStack) {\\n        if(n == 0 && mimicStack == 0)\\n            s.push_back(combi);\\n        \\n        if(n > 0)\\n            solve(combi + \\'(\\', n-1, mimicStack+1);\\n\\n        if(mimicStack > 0)\\n            solve(combi + \\')\\', n, mimicStack-1);\\n    }\\n    \\n    vector<string> generateParenthesis(int n) {\\n        solve(\"\", n, 0);\\n        return s;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 960608,
                "title": "c-simple-and-easy-to-understand-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    void solve(string &str,int open_count,int close_count,vector<string> &ans){\\n        if(open_count==0 && close_count==0){\\n            ans.push_back(str);\\n            return;\\n        }\\n        if(open_count>0){\\n            str.push_back(\\'(\\');\\n            solve(str,open_count-1,close_count,ans);\\n            str.pop_back();\\n        }\\n        \\n        if(close_count>open_count){\\n            str.push_back(\\')\\');\\n            solve(str,open_count,close_count-1,ans);\\n            str.pop_back();\\n        }\\n    }\\n    vector<string> generateParenthesis(int n) {\\n        vector<string> ans;\\n        string str;\\n        solve(str,n,n,ans);\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Backtracking"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    void solve(string &str,int open_count,int close_count,vector<string> &ans){\\n        if(open_count==0 && close_count==0){\\n            ans.push_back(str);\\n            return;\\n        }\\n        if(open_count>0){\\n            str.push_back(\\'(\\');\\n            solve(str,open_count-1,close_count,ans);\\n            str.pop_back();\\n        }\\n        \\n        if(close_count>open_count){\\n            str.push_back(\\')\\');\\n            solve(str,open_count,close_count-1,ans);\\n            str.pop_back();\\n        }\\n    }\\n    vector<string> generateParenthesis(int n) {\\n        vector<string> ans;\\n        string str;\\n        solve(str,n,n,ans);\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 796042,
                "title": "simple-python-solution",
                "content": "Simple python solution\\n\\n``` python\\n    def generateParenthesis(self, n: int) -> List[str]:\\n        allOutput = set([])\\n        def dfs(output, numOfLeft, numOfRight, n):\\n            if len(output) == n * 2:\\n                allOutput.add(output)\\n                return\\n            if numOfLeft < n:\\n                dfs(output + \\'(\\', numOfLeft + 1, numOfRight, n)\\n            if numOfLeft > numOfRight and numOfRight < n:\\n                dfs(output + \\')\\', numOfLeft, numOfRight + 1, n)\\n        dfs(\\'(\\', 1, 0, n)\\n        return allOutput\\n```",
                "solutionTags": [],
                "code": "``` python\\n    def generateParenthesis(self, n: int) -> List[str]:\\n        allOutput = set([])\\n        def dfs(output, numOfLeft, numOfRight, n):\\n            if len(output) == n * 2:\\n                allOutput.add(output)\\n                return\\n            if numOfLeft < n:\\n                dfs(output + \\'(\\', numOfLeft + 1, numOfRight, n)\\n            if numOfLeft > numOfRight and numOfRight < n:\\n                dfs(output + \\')\\', numOfLeft, numOfRight + 1, n)\\n        dfs(\\'(\\', 1, 0, n)\\n        return allOutput\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 653526,
                "title": "java-dfs",
                "content": "![image](https://assets.leetcode.com/users/chuanqiu/image_1590767732.png)\\n\\n```\\nclass Solution {\\n    public List<String> generateParenthesis(int n) {\\n        List<String> res = new LinkedList<>();\\n        if(n == 0) return res;\\n        dfs(\"\",0,0,n,res);\\n        return res;        \\n    }\\n    \\n     /**\\n     * @param curStr       The result of the current recursion\\n     * @param left          How much left bracket has been used\\n     * @param right  \\n     * @param n      \\n     * @param res         result set\\n     */\\n    \\n    public void dfs(String curstr, int left, int right, int n, List<String> res){\\n        if(left ==n && right ==n){\\n            res.add(curstr);\\n            return;\\n        }\\n        //unsatisfied condition, cut off\\n        if(left < right){\\n            return;\\n        }\\n        \\n        if(left<n){\\n            dfs(curstr+\"(\",left+1,right,n,res);\\n        }\\n        \\n         if(right<n){\\n            dfs(curstr+\")\",left,right+1,n,res);\\n        }\\n        \\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public List<String> generateParenthesis(int n) {\\n        List<String> res = new LinkedList<>();\\n        if(n == 0) return res;\\n        dfs(\"\",0,0,n,res);\\n        return res;        \\n    }\\n    \\n     /**\\n     * @param curStr       The result of the current recursion\\n     * @param left          How much left bracket has been used\\n     * @param right  \\n     * @param n      \\n     * @param res         result set\\n     */\\n    \\n    public void dfs(String curstr, int left, int right, int n, List<String> res){\\n        if(left ==n && right ==n){\\n            res.add(curstr);\\n            return;\\n        }\\n        //unsatisfied condition, cut off\\n        if(left < right){\\n            return;\\n        }\\n        \\n        if(left<n){\\n            dfs(curstr+\"(\",left+1,right,n,res);\\n        }\\n        \\n         if(right<n){\\n            dfs(curstr+\")\",left,right+1,n,res);\\n        }\\n        \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 607754,
                "title": "c-backtracking",
                "content": "```\\nclass Solution {\\n    vector<string>res;\\n    void dfs(int n, string curr, int left, int right) {\\n        if (left + right == 2*n)\\n            res.push_back(curr);\\n        \\n        if (left < n) dfs(n, curr + \\'(\\', left+1, right);\\n        if (left > right) dfs(n, curr + \\')\\', left, right+1);\\n    }\\npublic:\\n    vector<string> generateParenthesis(int n) {\\n        string curr;\\n        dfs(n, curr, 0, 0);\\n        return res;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    vector<string>res;\\n    void dfs(int n, string curr, int left, int right) {\\n        if (left + right == 2*n)\\n            res.push_back(curr);\\n        \\n        if (left < n) dfs(n, curr + \\'(\\', left+1, right);\\n        if (left > right) dfs(n, curr + \\')\\', left, right+1);\\n    }\\npublic:\\n    vector<string> generateParenthesis(int n) {\\n        string curr;\\n        dfs(n, curr, 0, 0);\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 575711,
                "title": "c-easy-understand-dfs-solution-both-recursive-iterative-version",
                "content": "Sol1 & Sol2 have the same idea.\\n**Sol1: Recursive version**\\n```\\nclass Solution {\\npublic:\\n    vector<string> result;\\n    vector<string> generateParenthesis(int n) {\\n        helper(\"\", n, 0, 0);\\n        return result;\\n    }\\n    void helper(string s, int n, int l, int r){\\n        if (l < r || l > n || r > n) return;  // exceed the bundary -> return\\n\\t    if (l == n && r == n){\\n\\t        result.push_back(s);\\n\\t        return;\\n\\t    }\\n\\t\\thelper(s + \"(\", n, l+1, r);\\n\\t\\thelper(s + \")\", n, l, r+1);\\n    }\\n};\\n```\\n**Sol2: Iterative version**\\n```\\nclass Solution {\\npublic:\\n    vector<string> generateParenthesis(int n) {\\n        vector<string> result;\\n        stack<pair<string, pair<int, int>>> st;\\n        st.push({\"\", {0, 0}});\\n        int l, r;\\n        string s;\\n        while (!st.empty()){\\n            pair<string, pair<int, int>> p;\\n            p = st.top();\\n            st.pop();\\n            l = p.second.first;\\n            r = p.second.second;\\n            s = p.first;\\n            if (l < r || l > n || r > n) continue;    // exceed the bundary -> skip the process below\\n            if (l == n && r == n) result.push_back(s);\\n            st.push({s+\"(\", {l+1, r}});\\n            st.push({s+\")\", {l, r+1}});\\n        }\\n        return result;\\n    } \\n};\\n```\\nTime & Space complexity: Pls refer to the official solution. (It is complex...)",
                "solutionTags": [
                    "C",
                    "Depth-First Search"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<string> result;\\n    vector<string> generateParenthesis(int n) {\\n        helper(\"\", n, 0, 0);\\n        return result;\\n    }\\n    void helper(string s, int n, int l, int r){\\n        if (l < r || l > n || r > n) return;  // exceed the bundary -> return\\n\\t    if (l == n && r == n){\\n\\t        result.push_back(s);\\n\\t        return;\\n\\t    }\\n\\t\\thelper(s + \"(\", n, l+1, r);\\n\\t\\thelper(s + \")\", n, l, r+1);\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    vector<string> generateParenthesis(int n) {\\n        vector<string> result;\\n        stack<pair<string, pair<int, int>>> st;\\n        st.push({\"\", {0, 0}});\\n        int l, r;\\n        string s;\\n        while (!st.empty()){\\n            pair<string, pair<int, int>> p;\\n            p = st.top();\\n            st.pop();\\n            l = p.second.first;\\n            r = p.second.second;\\n            s = p.first;\\n            if (l < r || l > n || r > n) continue;    // exceed the bundary -> skip the process below\\n            if (l == n && r == n) result.push_back(s);\\n            st.push({s+\"(\", {l+1, r}});\\n            st.push({s+\")\", {l, r+1}});\\n        }\\n        return result;\\n    } \\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 504773,
                "title": "swift-closure",
                "content": "Rather than passing inout array inside the backtrack method, I use closure to pass the values over here.\\n\\n``` swift\\nclass Solution {\\n    func generateParenthesis(_ n: Int) -> [String] {\\n        var result = [String]()\\n        backtrack(\"\", 0, 0, n) { result.append($0) }\\n        return result\\n    }\\n\\n    func backtrack(_ current: String,_ open: Int,_ end: Int,_ max: Int, _ result: (String)->Void) {\\n        if current.count == max * 2 {\\n            result(current)\\n            return\\n        }\\n        \\n        if open < max { backtrack(current + \"(\", open + 1, end, max, result) }\\n        if end < open  { backtrack(current + \")\", open, end + 1, max, result) }\\n    }\\n}\\n```",
                "solutionTags": [
                    "Swift"
                ],
                "code": "``` swift\\nclass Solution {\\n    func generateParenthesis(_ n: Int) -> [String] {\\n        var result = [String]()\\n        backtrack(\"\", 0, 0, n) { result.append($0) }\\n        return result\\n    }\\n\\n    func backtrack(_ current: String,_ open: Int,_ end: Int,_ max: Int, _ result: (String)->Void) {\\n        if current.count == max * 2 {\\n            result(current)\\n            return\\n        }\\n        \\n        if open < max { backtrack(current + \"(\", open + 1, end, max, result) }\\n        if end < open  { backtrack(current + \")\", open, end + 1, max, result) }\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 503352,
                "title": "javascript",
                "content": "```\\n/**\\n * @param {number} n\\n * @return {string[]}\\n */\\nvar generateParenthesis = function(n) {\\n    let result = [];\\n    \\n    function go(str, closedLeft, openLeft) {\\n        if (str.length === n*2) {\\n            result.push(str);\\n        }\\n        if (openLeft > 0) {\\n            go(str + \\'(\\', closedLeft + 1, openLeft - 1);\\n        }\\n        if (closedLeft > 0) {\\n            go(str + \\')\\', closedLeft - 1, openLeft);\\n        }\\n    }\\n   \\n    go(\"\", 0, n);\\n    return result;\\n};\\n```",
                "solutionTags": [],
                "code": "```\\n/**\\n * @param {number} n\\n * @return {string[]}\\n */\\nvar generateParenthesis = function(n) {\\n    let result = [];\\n    \\n    function go(str, closedLeft, openLeft) {\\n        if (str.length === n*2) {\\n            result.push(str);\\n        }\\n        if (openLeft > 0) {\\n            go(str + \\'(\\', closedLeft + 1, openLeft - 1);\\n        }\\n        if (closedLeft > 0) {\\n            go(str + \\')\\', closedLeft - 1, openLeft);\\n        }\\n    }\\n   \\n    go(\"\", 0, n);\\n    return result;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 375856,
                "title": "simple-python-solution-without-recursion",
                "content": "```\\n    def generateParenthesis(self, N):\\n        answer, last_results = [], [(\\'(\\', 1, 0)]\\n        while last_results:\\n            new_results = []\\n            for _ in range(len(last_results)):\\n                (result, left, right) = last_results.pop()  # popping is not required, but it saves memory\\n                if right == N and left == N:\\n                    answer.append(result)\\n                else:\\n                    if left < N:\\n                        new_results.append((result + \\'(\\', left+1, right))\\n                    if right < left:\\n                        new_results.append((result + \\')\\', left, right+1))\\n            last_results = new_results\\n        return answer\\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\n    def generateParenthesis(self, N):\\n        answer, last_results = [], [(\\'(\\', 1, 0)]\\n        while last_results:\\n            new_results = []\\n            for _ in range(len(last_results)):\\n                (result, left, right) = last_results.pop()  # popping is not required, but it saves memory\\n                if right == N and left == N:\\n                    answer.append(result)\\n                else:\\n                    if left < N:\\n                        new_results.append((result + \\'(\\', left+1, right))\\n                    if right < left:\\n                        new_results.append((result + \\')\\', left, right+1))\\n            last_results = new_results\\n        return answer\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 297416,
                "title": "rust-0ms-solution",
                "content": "```\\nimpl Solution {\\n    pub fn generate_parenthesis(n: i32) -> Vec<String> {\\n        let mut result: Vec<String> = vec![];\\n        Self::_gen(&mut result, n, n, \"\".to_string());\\n        result\\n    }\\n    pub fn _gen(result: &mut Vec<String>, left: i32, right: i32, sublist: String) {\\n        if left == 0 && right == 0 {\\n            result.push(sublist);\\n            return;\\n        }\\n        if left > 0 {\\n            Self::_gen(result, left - 1, right, sublist.clone() + \"(\");\\n        }\\n        if right > left {\\n            Self::_gen(result, left, right - 1, sublist.clone() + \")\");\\n        }\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nimpl Solution {\\n    pub fn generate_parenthesis(n: i32) -> Vec<String> {\\n        let mut result: Vec<String> = vec![];\\n        Self::_gen(&mut result, n, n, \"\".to_string());\\n        result\\n    }\\n    pub fn _gen(result: &mut Vec<String>, left: i32, right: i32, sublist: String) {\\n        if left == 0 && right == 0 {\\n            result.push(sublist);\\n            return;\\n        }\\n        if left > 0 {\\n            Self::_gen(result, left - 1, right, sublist.clone() + \"(\");\\n        }\\n        if right > left {\\n            Self::_gen(result, left, right - 1, sublist.clone() + \")\");\\n        }\\n    }\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 253175,
                "title": "sweet-old-ruby-solution",
                "content": "```\\ndef generate_parenthesis(n)\\n  recurse(n, 0, 0, \\'\\', [])\\nend\\n\\ndef recurse(n, o, c, cur, res)\\n  res << cur if o + c == 2 * n\\n\\n  recurse(n, o + 1, c, cur + \\'(\\', res) if o < n\\n  recurse(n, o, c + 1, cur + \\')\\', res) if c < o\\n\\n  res\\nend\\n```",
                "solutionTags": [],
                "code": "```\\ndef generate_parenthesis(n)\\n  recurse(n, 0, 0, \\'\\', [])\\nend\\n\\ndef recurse(n, o, c, cur, res)\\n  res << cur if o + c == 2 * n\\n\\n  recurse(n, o + 1, c, cur + \\'(\\', res) if o < n\\n  recurse(n, o, c + 1, cur + \\')\\', res) if c < o\\n\\n  res\\nend\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 222314,
                "title": "javascript",
                "content": "```\\nvar generateParenthesis = function(n) {\\n  const r = [];\\n  const gen = (left, right, _r) => {\\n    if (left === n && right === n) {\\n      r.push(_r);\\n      return;\\n    }\\n    if (left < n) gen(left + 1, right, `${_r}(`);\\n    if (left > right && right < n) gen(left, right + 1, `${_r})`);\\n  }\\n  \\n  gen(0, 0, \\'\\');\\n  \\n  return r;\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nvar generateParenthesis = function(n) {\\n  const r = [];\\n  const gen = (left, right, _r) => {\\n    if (left === n && right === n) {\\n      r.push(_r);\\n      return;\\n    }\\n    if (left < n) gen(left + 1, right, `${_r}(`);\\n    if (left > right && right < n) gen(left, right + 1, `${_r})`);\\n  }\\n  \\n  gen(0, 0, \\'\\');\\n  \\n  return r;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 203137,
                "title": "ruby-backtracking-with-example-and-diagram",
                "content": "```ruby\\n# @param {Integer} n\\n# @return {String[]}\\ndef generate_parenthesis(n)\\n    backtrack(n)\\nend\\n\\ndef backtrack(n, s = \"\", l = 0, r = 0, result = [])\\n    if s.size == 2 * n\\n        result.push(s)\\n        return\\n    end\\n\\n    backtrack(n, s + \"(\", l + 1, r, result) if l < n\\n    backtrack(n, s + \")\", l, r + 1, result) if r < l\\n\\n    result\\nend\\n\\n\\n# 22. Generate Parentheses\\n# https://leetcode.com/problems/generate-parentheses/description/\\n\\n# Complexity Analysis\\n# Our complexity analysis rests on understanding how many elements there are in generateParenthesis(n).\\n# This analysis is outside the scope of this article,\\n# but it turns out this is the n-th Catalan number 1/ (n + 1) * (2nCn), which is bounded asymptotically by 4^n / n * sqrt(n).\\n\\n# Time: O(4^n/sqrt(n), Each valid sequence has at most n steps during the backtracking procedure.\\n# Space: O(4^n/sqrt(n), as described above, and using O(n) space to store the sequence.\\n\\n# *** Example: n = 3 *** Space after each DFS instance\\n# backtrack called with  0 0 []\\n#   backtrack called with ( 1 0 []\\n#     backtrack called with (( 2 0 []\\n#       backtrack called with ((( 3 0 []\\n#         backtrack called with ((() 3 1 []\\n#           backtrack called with ((()) 3 2 []\\n#             backtrack called with ((())) 3 3 []\\n#           backtrack return with ((()) 3 2 [\"((()))\"]\\n#         backtrack return with ((() 3 1 [\"((()))\"]\\n#       backtrack return with ((( 3 0 [\"((()))\"]\\n#       backtrack called with (() 2 1 [\"((()))\"]\\n#         backtrack called with (()( 3 1 [\"((()))\"]\\n#           backtrack called with (()() 3 2 [\"((()))\"]\\n#             backtrack called with (()()) 3 3 [\"((()))\"]\\n#           backtrack return with (()() 3 2 [\"((()))\", \"(()())\"]\\n#         backtrack return with (()( 3 1 [\"((()))\", \"(()())\"]\\n#         backtrack called with (()) 2 2 [\"((()))\", \"(()())\"]\\n#           backtrack called with (())( 3 2 [\"((()))\", \"(()())\"]\\n#             backtrack called with (())() 3 3 [\"((()))\", \"(()())\"]\\n#           backtrack return with (())( 3 2 [\"((()))\", \"(()())\", \"(())()\"]\\n#         backtrack return with (()) 2 2 [\"((()))\", \"(()())\", \"(())()\"]\\n#       backtrack return with (() 2 1 [\"((()))\", \"(()())\", \"(())()\"]\\n#     backtrack return with (( 2 0 [\"((()))\", \"(()())\", \"(())()\"]\\n#     backtrack called with () 1 1 [\"((()))\", \"(()())\", \"(())()\"]\\n#       backtrack called with ()( 2 1 [\"((()))\", \"(()())\", \"(())()\"]\\n#         backtrack called with ()(( 3 1 [\"((()))\", \"(()())\", \"(())()\"]\\n#           backtrack called with ()(() 3 2 [\"((()))\", \"(()())\", \"(())()\"]\\n#             backtrack called with ()(()) 3 3 [\"((()))\", \"(()())\", \"(())()\"]\\n#           backtrack return with ()(() 3 2 [\"((()))\", \"(()())\", \"(())()\", \"()(())\"]\\n#         backtrack return with ()(( 3 1 [\"((()))\", \"(()())\", \"(())()\", \"()(())\"]\\n#         backtrack called with ()() 2 2 [\"((()))\", \"(()())\", \"(())()\", \"()(())\"]\\n#           backtrack called with ()()( 3 2 [\"((()))\", \"(()())\", \"(())()\", \"()(())\"]\\n#             backtrack called with ()()() 3 3 [\"((()))\", \"(()())\", \"(())()\", \"()(())\"]\\n#           backtrack return with ()()( 3 2 [\"((()))\", \"(()())\", \"(())()\", \"()(())\", \"()()()\"]\\n#         backtrack return with ()() 2 2 [\"((()))\", \"(()())\", \"(())()\", \"()(())\", \"()()()\"]\\n#       backtrack return with ()( 2 1 [\"((()))\", \"(()())\", \"(())()\", \"()(())\", \"()()()\"]\\n#     backtrack return with () 1 1 [\"((()))\", \"(()())\", \"(())()\", \"()(())\", \"()()()\"]\\n#   backtrack return with ( 1 0 [\"((()))\", \"(()())\", \"(())()\", \"()(())\", \"()()()\"]\\n# backtrack return with  0 0 [\"((()))\", \"(()())\", \"(())()\", \"()(())\", \"()()()\"]\\n\\n# Refer to the attached diagram for recursion,\\n# The numbers next to each node are the counts of left and right parantheses\\n\\n```\\n![image](https://assets.leetcode.com/users/vkommi2/image_1544322836.png)\\n",
                "solutionTags": [],
                "code": "```ruby\\n# @param {Integer} n\\n# @return {String[]}\\ndef generate_parenthesis(n)\\n    backtrack(n)\\nend\\n\\ndef backtrack(n, s = \"\", l = 0, r = 0, result = [])\\n    if s.size == 2 * n\\n        result.push(s)\\n        return\\n    end\\n\\n    backtrack(n, s + \"(\", l + 1, r, result) if l < n\\n    backtrack(n, s + \")\", l, r + 1, result) if r < l\\n\\n    result\\nend\\n\\n\\n# 22. Generate Parentheses\\n# https://leetcode.com/problems/generate-parentheses/description/\\n\\n# Complexity Analysis\\n# Our complexity analysis rests on understanding how many elements there are in generateParenthesis(n).\\n# This analysis is outside the scope of this article,\\n# but it turns out this is the n-th Catalan number 1/ (n + 1) * (2nCn), which is bounded asymptotically by 4^n / n * sqrt(n).\\n\\n# Time: O(4^n/sqrt(n), Each valid sequence has at most n steps during the backtracking procedure.\\n# Space: O(4^n/sqrt(n), as described above, and using O(n) space to store the sequence.\\n\\n# *** Example: n = 3 *** Space after each DFS instance\\n# backtrack called with  0 0 []\\n#   backtrack called with ( 1 0 []\\n#     backtrack called with (( 2 0 []\\n#       backtrack called with ((( 3 0 []\\n#         backtrack called with ((() 3 1 []\\n#           backtrack called with ((()) 3 2 []\\n#             backtrack called with ((())) 3 3 []\\n#           backtrack return with ((()) 3 2 [\"((()))\"]\\n#         backtrack return with ((() 3 1 [\"((()))\"]\\n#       backtrack return with ((( 3 0 [\"((()))\"]\\n#       backtrack called with (() 2 1 [\"((()))\"]\\n#         backtrack called with (()( 3 1 [\"((()))\"]\\n#           backtrack called with (()() 3 2 [\"((()))\"]\\n#             backtrack called with (()()) 3 3 [\"((()))\"]\\n#           backtrack return with (()() 3 2 [\"((()))\", \"(()())\"]\\n#         backtrack return with (()( 3 1 [\"((()))\", \"(()())\"]\\n#         backtrack called with (()) 2 2 [\"((()))\", \"(()())\"]\\n#           backtrack called with (())( 3 2 [\"((()))\", \"(()())\"]\\n#             backtrack called with (())() 3 3 [\"((()))\", \"(()())\"]\\n#           backtrack return with (())( 3 2 [\"((()))\", \"(()())\", \"(())()\"]\\n#         backtrack return with (()) 2 2 [\"((()))\", \"(()())\", \"(())()\"]\\n#       backtrack return with (() 2 1 [\"((()))\", \"(()())\", \"(())()\"]\\n#     backtrack return with (( 2 0 [\"((()))\", \"(()())\", \"(())()\"]\\n#     backtrack called with () 1 1 [\"((()))\", \"(()())\", \"(())()\"]\\n#       backtrack called with ()( 2 1 [\"((()))\", \"(()())\", \"(())()\"]\\n#         backtrack called with ()(( 3 1 [\"((()))\", \"(()())\", \"(())()\"]\\n#           backtrack called with ()(() 3 2 [\"((()))\", \"(()())\", \"(())()\"]\\n#             backtrack called with ()(()) 3 3 [\"((()))\", \"(()())\", \"(())()\"]\\n#           backtrack return with ()(() 3 2 [\"((()))\", \"(()())\", \"(())()\", \"()(())\"]\\n#         backtrack return with ()(( 3 1 [\"((()))\", \"(()())\", \"(())()\", \"()(())\"]\\n#         backtrack called with ()() 2 2 [\"((()))\", \"(()())\", \"(())()\", \"()(())\"]\\n#           backtrack called with ()()( 3 2 [\"((()))\", \"(()())\", \"(())()\", \"()(())\"]\\n#             backtrack called with ()()() 3 3 [\"((()))\", \"(()())\", \"(())()\", \"()(())\"]\\n#           backtrack return with ()()( 3 2 [\"((()))\", \"(()())\", \"(())()\", \"()(())\", \"()()()\"]\\n#         backtrack return with ()() 2 2 [\"((()))\", \"(()())\", \"(())()\", \"()(())\", \"()()()\"]\\n#       backtrack return with ()( 2 1 [\"((()))\", \"(()())\", \"(())()\", \"()(())\", \"()()()\"]\\n#     backtrack return with () 1 1 [\"((()))\", \"(()())\", \"(())()\", \"()(())\", \"()()()\"]\\n#   backtrack return with ( 1 0 [\"((()))\", \"(()())\", \"(())()\", \"()(())\", \"()()()\"]\\n# backtrack return with  0 0 [\"((()))\", \"(()())\", \"(())()\", \"()(())\", \"()()()\"]\\n\\n# Refer to the attached diagram for recursion,\\n# The numbers next to each node are the counts of left and right parantheses\\n\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 10173,
                "title": "my-0ms-c-solution-without-recursion-and-dfs",
                "content": "    class Solution {\\n        //\\u8fd9\\u4e00\\u7248\\u4e0d\\u4f7f\\u7528\\u9012\\u5f52\\uff0c\\u901f\\u5ea6\\u66f4\\u5feb\\u3002\\n        //\\u9996\\u5148\\u662f\\u6700\\u539a\\u7684\\u62ec\\u53f7\\u5305\\u88f9\\u72b6\\u6001\\uff0c\\u5373\\u4e00\\u5f00\\u59cb\\u5de6\\u8fb9\\u662f\\u8fde\\u7eed\\u7684\\u5de6\\u62ec\\u53f7\\uff0c\\u53f3\\u8fb9\\u662f\\u8fde\\u7eed\\u7684\\u53f3\\u62ec\\u53f7\\uff0c\\u7136\\u540e\\u6267\\u884c\\u4ee5\\u4e0b\\u903b\\u8f91\\uff1a\\n        //1\\u3001\\u53f3\\u62ec\\u53f7\\u4e0d\\u80fd\\u6bd4\\u5de6\\u62ec\\u53f7\\u591a\\uff1b\\n        //2\\u3001\\u5f39\\u51fa\\u53f3\\u62ec\\u53f7\\uff0c\\u76f4\\u5230\\u9047\\u5230\\u7b2c\\u4e00\\u4e2a\\u5de6\\u62ec\\u53f7\\uff0c\\u5982\\u679c\\u5de6\\u62ec\\u53f7\\u6539\\u6210\\u53f3\\u62ec\\u53f7\\u4ecd\\u7136\\u5408\\u6cd5\\uff0c\\u5219\\u628a\\u5b83\\u6539\\u6210\\u53f3\\u62ec\\u53f7\\uff1b\\u5426\\u5219\\uff0c\\u5de6\\u62ec\\u53f7\\u7ee7\\u7eed\\u5f39\\u51fa\\uff1b\\n        //3\\u3001\\u6539\\u5b8c\\u4e4b\\u540e\\u4e00\\u4e2a\\u52b2\\u52a0\\u5de6\\u62ec\\u53f7\\uff0c\\u76f4\\u5230\\u6240\\u6709\\u53ef\\u4ee5\\u7528\\u7684\\u5de6\\u62ec\\u53f7\\u90fd\\u52a0\\u5b8c\\u4e3a\\u6b62\\u3002\\n        //4\\u3001\\u5faa\\u73af\\u4e00\\u76f4\\u6267\\u884c\\u5230\\u4e00\\u5f00\\u59cb\\u7684\\u8fde\\u7eed\\u5de6\\u62ec\\u53f7\\u6ca1\\u6709\\u4e3a\\u6b62\\u3002\\n        //\\u8be5\\u7a0b\\u5e8f\\u662f\\u4e0a\\u4e00\\u7248\\u9012\\u5f52\\u7a0b\\u5e8f\\u7684\\u7b49\\u4ef7\\u7248\\u3002\\n    public:\\n        vector<string> generateParenthesis(int n) \\n        {\\n            vector<string> result;\\n            if(n==0)\\n                return result;\\n            string s;\\n            for(int i=0;i<n;i++)\\n                s+=\"(\";\\n            for(int i=0;i<n;i++)\\n                s+=\")\";\\n            int left=n;\\n            int right=n;\\n            do\\n            {\\n                result.push_back(s);\\n                while(s!=\"\"&&(s.back()==')'||left-1<right+1))\\n                {\\n                    if(s.back()==')')\\n                        right--;\\n                    else\\n                        left--;\\n                    s.pop_back();\\n                }\\n                if(s!=\"\")\\n                {\\n                    s.back()=')';\\n                    left--;\\n                    right++;\\n                    while(left<n)\\n                    {\\n                        s+=\"(\";\\n                        left++;\\n                    }\\n                    while(right<n)\\n                    {\\n                        s+=\")\";\\n                        right++;\\n                    }\\n                }\\n            }while(s!=\"\");\\n            return result;\\n        }\\n    };",
                "solutionTags": [],
                "code": "class Solution {\\n        //\\u8fd9\\u4e00\\u7248\\u4e0d\\u4f7f\\u7528\\u9012\\u5f52\\uff0c\\u901f\\u5ea6\\u66f4\\u5feb\\u3002\\n        //\\u9996\\u5148\\u662f\\u6700\\u539a\\u7684\\u62ec\\u53f7\\u5305\\u88f9\\u72b6\\u6001\\uff0c\\u5373\\u4e00\\u5f00\\u59cb\\u5de6\\u8fb9\\u662f\\u8fde\\u7eed\\u7684\\u5de6\\u62ec\\u53f7\\uff0c\\u53f3\\u8fb9\\u662f\\u8fde\\u7eed\\u7684\\u53f3\\u62ec\\u53f7\\uff0c\\u7136\\u540e\\u6267\\u884c\\u4ee5\\u4e0b\\u903b\\u8f91\\uff1a\\n        //1\\u3001\\u53f3\\u62ec\\u53f7\\u4e0d\\u80fd\\u6bd4\\u5de6\\u62ec\\u53f7\\u591a\\uff1b\\n        //2\\u3001\\u5f39\\u51fa\\u53f3\\u62ec\\u53f7\\uff0c\\u76f4\\u5230\\u9047\\u5230\\u7b2c\\u4e00\\u4e2a\\u5de6\\u62ec\\u53f7\\uff0c\\u5982\\u679c\\u5de6\\u62ec\\u53f7\\u6539\\u6210\\u53f3\\u62ec\\u53f7\\u4ecd\\u7136\\u5408\\u6cd5\\uff0c\\u5219\\u628a\\u5b83\\u6539\\u6210\\u53f3\\u62ec\\u53f7\\uff1b\\u5426\\u5219\\uff0c\\u5de6\\u62ec\\u53f7\\u7ee7\\u7eed\\u5f39\\u51fa\\uff1b\\n        //3\\u3001\\u6539\\u5b8c\\u4e4b\\u540e\\u4e00\\u4e2a\\u52b2\\u52a0\\u5de6\\u62ec\\u53f7\\uff0c\\u76f4\\u5230\\u6240\\u6709\\u53ef\\u4ee5\\u7528\\u7684\\u5de6\\u62ec\\u53f7\\u90fd\\u52a0\\u5b8c\\u4e3a\\u6b62\\u3002\\n        //4\\u3001\\u5faa\\u73af\\u4e00\\u76f4\\u6267\\u884c\\u5230\\u4e00\\u5f00\\u59cb\\u7684\\u8fde\\u7eed\\u5de6\\u62ec\\u53f7\\u6ca1\\u6709\\u4e3a\\u6b62\\u3002\\n        //\\u8be5\\u7a0b\\u5e8f\\u662f\\u4e0a\\u4e00\\u7248\\u9012\\u5f52\\u7a0b\\u5e8f\\u7684\\u7b49\\u4ef7\\u7248\\u3002\\n    public:\\n        vector<string> generateParenthesis(int n) \\n        {\\n            vector<string> result;\\n            if(n==0)\\n                return result;\\n            string s;\\n            for(int i=0;i<n;i++)\\n                s+=\"(\";\\n            for(int i=0;i<n;i++)\\n                s+=\")\";\\n            int left=n;\\n            int right=n;\\n            do\\n            {\\n                result.push_back(s);\\n                while(s!=\"\"&&(s.back()==')'||left-1<right+1))\\n                {\\n                    if(s.back()==')')\\n                        right--;\\n                    else\\n                        left--;\\n                    s.pop_back();\\n                }",
                "codeTag": "Java"
            },
            {
                "id": 10349,
                "title": "my-java-code-using-dp",
                "content": "The idea is clear. Use cache to store the already calculated results, from f(0) to f(n). For each f(i), get f(j) and f(i - j - 1) from cache, 0 <= j < = j-1.\\n\\n    public static List<String> generateParenthesis(int n) {\\n        List<List<String>> cache = new LinkedList<>();\\n        cache.add(Arrays.asList(\"\"));\\n\\n        for (int i = 1; i <= n; i++) {\\n            List<String> nList = new LinkedList<>();\\n            for (int j = 0; j < i; j++) {\\n                List<String> inside = cache.get(j);\\n                List<String> tail = cache.get(i - j - 1);\\n                for (int k = 0; k < inside.size(); k++) {\\n                    for (int l = 0; l < tail.size(); l++) {\\n                        nList.add(\"(\" + inside.get(k) + \")\" + tail.get(l));\\n                    }\\n                }\\n            }\\n            cache.add(nList);\\n        }\\n        return cache.get(n);\\n    }",
                "solutionTags": [
                    "Java"
                ],
                "code": "The idea is clear. Use cache to store the already calculated results, from f(0) to f(n). For each f(i), get f(j) and f(i - j - 1) from cache, 0 <= j < = j-1.\\n\\n    public static List<String> generateParenthesis(int n) {\\n        List<List<String>> cache = new LinkedList<>();\\n        cache.add(Arrays.asList(\"\"));\\n\\n        for (int i = 1; i <= n; i++) {\\n            List<String> nList = new LinkedList<>();\\n            for (int j = 0; j < i; j++) {\\n                List<String> inside = cache.get(j);\\n                List<String> tail = cache.get(i - j - 1);\\n                for (int k = 0; k < inside.size(); k++) {\\n                    for (int l = 0; l < tail.size(); l++) {\\n                        nList.add(\"(\" + inside.get(k) + \")\" + tail.get(l));\\n                    }\\n                }\\n            }\\n            cache.add(nList);\\n        }\\n        return cache.get(n);\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 10423,
                "title": "java-recursive-simple-with-8-lines",
                "content": "    List<String> list = new ArrayList<String>();\\n    \\tpublic List<String> generateParenthesis(int n) {\\n        \\tloop(\"(\",n-1,1);\\n        \\treturn list;\\n        }\\n        private void loop(String s, int n, int o){\\n        \\tif (n==0 && o==0) list.add(s);\\n        \\tif (n>0) loop(s+\"(\", n-1, o+1);\\n        \\tif (o>0) loop(s+\")\", n, o-1);\\n        }",
                "solutionTags": [],
                "code": "    List<String> list = new ArrayList<String>();\\n    \\tpublic List<String> generateParenthesis(int n) {\\n        \\tloop(\"(\",n-1,1);\\n        \\treturn list;\\n        }\\n        private void loop(String s, int n, int o){\\n        \\tif (n==0 && o==0) list.add(s);\\n        \\tif (n>0) loop(s+\"(\", n-1, o+1);\\n        \\tif (o>0) loop(s+\")\", n, o-1);\\n        }",
                "codeTag": "Unknown"
            }
        ],
        "discussions": [
            {
                "id": 1564779,
                "content": [
                    {
                        "username": "bonson",
                        "content": "Using different implmentation,the elements will be in different orders. e.g. n = 3.\\nIt can be\\n[\"((()))\",\"(())()\",\"()(())\",\"(()())\",\"()()()\"]\\nwhile the expected answer is\\n[\"((()))\",\"(()())\",\"(())()\",\"()(())\",\"()()()\"]\\n\\nBoth are correct answers. However, the difference of ordering is reckoned as \"wrong answer\". "
                    },
                    {
                        "username": "theashggl",
                        "content": "It accepts all ordering but that should be specified in the question."
                    },
                    {
                        "username": "gmarus",
                        "content": "still does not"
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# \\u26A0\\uFE0FEasiest \\uD83D\\uDE0E FAANG Method Ever !!! \\uD83D\\uDCA5\\nhttps://leetcode.com/problems/generate-parentheses/solutions/3035511/easiest-faang-method-ever/?orderBy=newest_to_oldest"
                    },
                    {
                        "username": "NicholasCG",
                        "content": "January 2023, it accepted different ordered answers for me."
                    },
                    {
                        "username": "barrybecker4",
                        "content": "[@satbekmyrza](/satbekmyrza) Still does not"
                    },
                    {
                        "username": "angelopoulos",
                        "content": "[@4m4nd33p_51ngh](/4m4nd33p_51ngh) I can confirm it still doesn\\'t"
                    },
                    {
                        "username": "4m4nd33p_51ngh",
                        "content": "[@satbekmyrza](/satbekmyrza) no it doesn\\'t"
                    },
                    {
                        "username": "satbekmyrza",
                        "content": "I think it accepts different ordered answers, as of 2022"
                    },
                    {
                        "username": "tejavenkatlanka",
                        "content": "![image](https://assets.leetcode.com/users/images/dabefcea-2a30-4a0a-81c4-b2dafcf9dce0_1599242411.2652733.png)\\nclick for view \\n[https://embed.creately.com/cclS6u7Upy3?type=svg] \\n\\nleft path represent possible one parentheses and right represent possible of right parentheses.\\n\\nleaf node contains answer.\\n\\nhope it will help.\\n\\n"
                    },
                    {
                        "username": "leetnote_io",
                        "content": "Thanks, the pic is very intuitive"
                    },
                    {
                        "username": "dominic89231",
                        "content": "Very helpful!"
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# \\u26A0\\uFE0FEasiest \\uD83D\\uDE0E FAANG Method Ever !!! \\uD83D\\uDCA5\\nhttps://leetcode.com/problems/generate-parentheses/solutions/3035511/easiest-faang-method-ever/?orderBy=newest_to_oldest"
                    },
                    {
                        "username": "drvnprgrmr",
                        "content": "Literally spent about 2hrs on this and came up with a different, more complex (I think) solution that uses recursion. "
                    },
                    {
                        "username": "ChrisMiaoMiao",
                        "content": "Thx, It\\'s very helpful!"
                    },
                    {
                        "username": "aln4739",
                        "content": "very helpful!"
                    },
                    {
                        "username": "KalRadikov",
                        "content": "![image](https://assets.leetcode.com/users/images/40f0296a-7b58-49fb-a72e-e5d8eacf94a4_1604461937.5052783.png)\\n\\nProof:\\n\\n![image](https://assets.leetcode.com/users/images/4bcd2dba-e170-4799-91ae-3e4a1de32731_1605116132.2703443.png)\\n\\n"
                    },
                    {
                        "username": "BREATHTAKER200",
                        "content": "You sneaky bastard!!!!!\\uD83E\\uDD23\\uD83E\\uDD23"
                    },
                    {
                        "username": "alex_malevinsky",
                        "content": "Lots of lines of code, without loops or recursion. Really legend!"
                    },
                    {
                        "username": "Demaxl",
                        "content": "You\\'re hired"
                    },
                    {
                        "username": "codebuster_",
                        "content": "Habibi, this is a dream come true moment"
                    },
                    {
                        "username": "drMystico",
                        "content": "genius guy downright there! "
                    },
                    {
                        "username": "Cripton",
                        "content": "bros dad works at microsoft"
                    },
                    {
                        "username": "RashCode",
                        "content": "Legend\\uD83E\\uDEE1"
                    },
                    {
                        "username": "milespossing",
                        "content": "Strong hire"
                    },
                    {
                        "username": "sunlins",
                        "content": "I was sure of finding this in the comment section"
                    },
                    {
                        "username": "tanmayyyj",
                        "content": "Bro is a hacker"
                    },
                    {
                        "username": "ktranada1403",
                        "content": "bro beat the system..."
                    },
                    {
                        "username": "rsharvesh16",
                        "content": "Bro is from another world!"
                    },
                    {
                        "username": "buzz_shocker",
                        "content": "This is some big brain stuff"
                    },
                    {
                        "username": "Prasanth2021",
                        "content": "[@kzlatt](/kzlatt) \\uD83D\\uDE02\\uD83D\\uDE02\\uD83D\\uDE02"
                    },
                    {
                        "username": "AdilARahman",
                        "content": "Use switch case to go even faster XD"
                    },
                    {
                        "username": "mdmasidulhasan27",
                        "content": "perfect solution for this problem. it\\'s kind a static problem. "
                    },
                    {
                        "username": "Crispy_coffee",
                        "content": "Testcase Oriented Programming \\uD83D\\uDE02"
                    },
                    {
                        "username": "guneetd",
                        "content": "[@ashok0](/ashok0) then you can use Abstract Factory to generate strings :) "
                    },
                    {
                        "username": "kzlatt",
                        "content": "Leetcode :  Choose!!!!  step up or step down\\nKalRadikov:   S.....i......d......e......w......a......y"
                    },
                    {
                        "username": "District_12",
                        "content": "that\\'s what we call to be creative!"
                    },
                    {
                        "username": "a_s_h_o_k",
                        "content": "what if n=100 \\uD83D\\uDE02"
                    },
                    {
                        "username": "aln4739",
                        "content": "chad"
                    },
                    {
                        "username": "leetcodesquad",
                        "content": "No one can beat you since you already had the answer. LOL"
                    },
                    {
                        "username": "undi69",
                        "content": "Dude you are a god"
                    },
                    {
                        "username": "khanuja05",
                        "content": "My solution generates the same set of outputs but the ordering is different. The question should be edited and they should mention that the order matters."
                    },
                    {
                        "username": "Nemo-7777",
                        "content": "It seems that problem author expects a sorted array of strings. So if you struggle with incorrect order, just sort the array and it should work fine."
                    },
                    {
                        "username": "fillipe",
                        "content": "[@krjukov](/krjukov) My solution fails at the test case with 6 pairs. I have verified exactly why now. It is for not generating certain patterns. The system considers your solution correct regardless of the order in which the patterns are saved in your solution."
                    },
                    {
                        "username": "krjukov",
                        "content": "It\\'s senseless to demand preserved order in this type of problems. All the strings are of the same length. It is the validation of the solutions to be amended, not the description. Just accept any order "
                    },
                    {
                        "username": "noisrucer",
                        "content": "I solved this problem with 60m/s by generating permutations with duplicates and for each permutation result I used stack to check if it\\'s valid parenthesis and now I came here and ppl post simple/mind-blowing solutions that I never expected and A LOT OF people be like \"yeah~nice solution~i thought kinda the same way~\". WTH!!!!!\\n\\nI started algorithm roughly 3 months ago and I\\'ve been studying 12-14 hrs a day til now and solved probably 200 questions so far. I\\'m kinda confident in BFS DFS DP and some general algorithm but totally new to combinatorics. What should I focus more on? I haven\\'t studied Greedy yet. Can you guys recommend me how I study Greedy? cuz its so vague I\\'ve looked up so much\\n\\nBless to y\\'all\\n\\n- Non-smart Asian sophomore kid-"
                    },
                    {
                        "username": "Haseeeb1",
                        "content": "whats your github and linkedin?"
                    },
                    {
                        "username": "baseballCode",
                        "content": "[@blsd-rus](/blsd-rus) I use the neetcode roadmap, ordering is important and since I started doing the questions in order im starting to get better. "
                    },
                    {
                        "username": "blsd-rus",
                        "content": "[@vishesh014](/vishesh014) i\\'ll recommend neetcode"
                    },
                    {
                        "username": "vishesh014",
                        "content": "bro can you tell me the roadmap how you studied algorithms"
                    },
                    {
                        "username": "andy_r_s",
                        "content": "For n = 4 is following one of the valid combinations?\\n(())(())\\n\\nMy code has this but the leetcode says it\\'s not valid. I don\\'t understand why is it invalid?"
                    },
                    {
                        "username": "fffccc",
                        "content": "I also generated this and the test case doesn\\'t generate this one."
                    },
                    {
                        "username": "charonme",
                        "content": "it\\'s valid, but maybe you generated it twice?"
                    },
                    {
                        "username": "chiragrajput245",
                        "content": "Draw the recursive tree and think about the conditions when an opening/closing bracket can be appended\\n\\n         (\\n        / \\\\\\n       ((  ()\\n      / \\\\   |\\n    ((( (() ()(\\n     .   .   .\\n     .   .   .\\n\\n... and so on"
                    },
                    {
                        "username": "JenZ",
                        "content": "Is it 2^n? \\nIs any method better than it ?Thank you."
                    },
                    {
                        "username": "panwu5588",
                        "content": "BAD test cases. The order should not matter.\\nFor example, the following should be the same:\\n[\"(())\",\"()()\"]\\n[\"()()\",\"(())\"]"
                    },
                    {
                        "username": "satta_sunder",
                        "content": "I applied recursion and got 55% faster only. I\\'d love to see if there is any more efficient method."
                    },
                    {
                        "username": "Puja__Singh",
                        "content": "check mine it beats 97%"
                    },
                    {
                        "username": "noob-pika",
                        "content": "The system for calculating time complexity is broken for a solution after a certain number of submissions"
                    }
                ]
            },
            {
                "id": 1574327,
                "content": [
                    {
                        "username": "bonson",
                        "content": "Using different implmentation,the elements will be in different orders. e.g. n = 3.\\nIt can be\\n[\"((()))\",\"(())()\",\"()(())\",\"(()())\",\"()()()\"]\\nwhile the expected answer is\\n[\"((()))\",\"(()())\",\"(())()\",\"()(())\",\"()()()\"]\\n\\nBoth are correct answers. However, the difference of ordering is reckoned as \"wrong answer\". "
                    },
                    {
                        "username": "theashggl",
                        "content": "It accepts all ordering but that should be specified in the question."
                    },
                    {
                        "username": "gmarus",
                        "content": "still does not"
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# \\u26A0\\uFE0FEasiest \\uD83D\\uDE0E FAANG Method Ever !!! \\uD83D\\uDCA5\\nhttps://leetcode.com/problems/generate-parentheses/solutions/3035511/easiest-faang-method-ever/?orderBy=newest_to_oldest"
                    },
                    {
                        "username": "NicholasCG",
                        "content": "January 2023, it accepted different ordered answers for me."
                    },
                    {
                        "username": "barrybecker4",
                        "content": "[@satbekmyrza](/satbekmyrza) Still does not"
                    },
                    {
                        "username": "angelopoulos",
                        "content": "[@4m4nd33p_51ngh](/4m4nd33p_51ngh) I can confirm it still doesn\\'t"
                    },
                    {
                        "username": "4m4nd33p_51ngh",
                        "content": "[@satbekmyrza](/satbekmyrza) no it doesn\\'t"
                    },
                    {
                        "username": "satbekmyrza",
                        "content": "I think it accepts different ordered answers, as of 2022"
                    },
                    {
                        "username": "tejavenkatlanka",
                        "content": "![image](https://assets.leetcode.com/users/images/dabefcea-2a30-4a0a-81c4-b2dafcf9dce0_1599242411.2652733.png)\\nclick for view \\n[https://embed.creately.com/cclS6u7Upy3?type=svg] \\n\\nleft path represent possible one parentheses and right represent possible of right parentheses.\\n\\nleaf node contains answer.\\n\\nhope it will help.\\n\\n"
                    },
                    {
                        "username": "leetnote_io",
                        "content": "Thanks, the pic is very intuitive"
                    },
                    {
                        "username": "dominic89231",
                        "content": "Very helpful!"
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# \\u26A0\\uFE0FEasiest \\uD83D\\uDE0E FAANG Method Ever !!! \\uD83D\\uDCA5\\nhttps://leetcode.com/problems/generate-parentheses/solutions/3035511/easiest-faang-method-ever/?orderBy=newest_to_oldest"
                    },
                    {
                        "username": "drvnprgrmr",
                        "content": "Literally spent about 2hrs on this and came up with a different, more complex (I think) solution that uses recursion. "
                    },
                    {
                        "username": "ChrisMiaoMiao",
                        "content": "Thx, It\\'s very helpful!"
                    },
                    {
                        "username": "aln4739",
                        "content": "very helpful!"
                    },
                    {
                        "username": "KalRadikov",
                        "content": "![image](https://assets.leetcode.com/users/images/40f0296a-7b58-49fb-a72e-e5d8eacf94a4_1604461937.5052783.png)\\n\\nProof:\\n\\n![image](https://assets.leetcode.com/users/images/4bcd2dba-e170-4799-91ae-3e4a1de32731_1605116132.2703443.png)\\n\\n"
                    },
                    {
                        "username": "BREATHTAKER200",
                        "content": "You sneaky bastard!!!!!\\uD83E\\uDD23\\uD83E\\uDD23"
                    },
                    {
                        "username": "alex_malevinsky",
                        "content": "Lots of lines of code, without loops or recursion. Really legend!"
                    },
                    {
                        "username": "Demaxl",
                        "content": "You\\'re hired"
                    },
                    {
                        "username": "codebuster_",
                        "content": "Habibi, this is a dream come true moment"
                    },
                    {
                        "username": "drMystico",
                        "content": "genius guy downright there! "
                    },
                    {
                        "username": "Cripton",
                        "content": "bros dad works at microsoft"
                    },
                    {
                        "username": "RashCode",
                        "content": "Legend\\uD83E\\uDEE1"
                    },
                    {
                        "username": "milespossing",
                        "content": "Strong hire"
                    },
                    {
                        "username": "sunlins",
                        "content": "I was sure of finding this in the comment section"
                    },
                    {
                        "username": "tanmayyyj",
                        "content": "Bro is a hacker"
                    },
                    {
                        "username": "ktranada1403",
                        "content": "bro beat the system..."
                    },
                    {
                        "username": "rsharvesh16",
                        "content": "Bro is from another world!"
                    },
                    {
                        "username": "buzz_shocker",
                        "content": "This is some big brain stuff"
                    },
                    {
                        "username": "Prasanth2021",
                        "content": "[@kzlatt](/kzlatt) \\uD83D\\uDE02\\uD83D\\uDE02\\uD83D\\uDE02"
                    },
                    {
                        "username": "AdilARahman",
                        "content": "Use switch case to go even faster XD"
                    },
                    {
                        "username": "mdmasidulhasan27",
                        "content": "perfect solution for this problem. it\\'s kind a static problem. "
                    },
                    {
                        "username": "Crispy_coffee",
                        "content": "Testcase Oriented Programming \\uD83D\\uDE02"
                    },
                    {
                        "username": "guneetd",
                        "content": "[@ashok0](/ashok0) then you can use Abstract Factory to generate strings :) "
                    },
                    {
                        "username": "kzlatt",
                        "content": "Leetcode :  Choose!!!!  step up or step down\\nKalRadikov:   S.....i......d......e......w......a......y"
                    },
                    {
                        "username": "District_12",
                        "content": "that\\'s what we call to be creative!"
                    },
                    {
                        "username": "a_s_h_o_k",
                        "content": "what if n=100 \\uD83D\\uDE02"
                    },
                    {
                        "username": "aln4739",
                        "content": "chad"
                    },
                    {
                        "username": "leetcodesquad",
                        "content": "No one can beat you since you already had the answer. LOL"
                    },
                    {
                        "username": "undi69",
                        "content": "Dude you are a god"
                    },
                    {
                        "username": "khanuja05",
                        "content": "My solution generates the same set of outputs but the ordering is different. The question should be edited and they should mention that the order matters."
                    },
                    {
                        "username": "Nemo-7777",
                        "content": "It seems that problem author expects a sorted array of strings. So if you struggle with incorrect order, just sort the array and it should work fine."
                    },
                    {
                        "username": "fillipe",
                        "content": "[@krjukov](/krjukov) My solution fails at the test case with 6 pairs. I have verified exactly why now. It is for not generating certain patterns. The system considers your solution correct regardless of the order in which the patterns are saved in your solution."
                    },
                    {
                        "username": "krjukov",
                        "content": "It\\'s senseless to demand preserved order in this type of problems. All the strings are of the same length. It is the validation of the solutions to be amended, not the description. Just accept any order "
                    },
                    {
                        "username": "noisrucer",
                        "content": "I solved this problem with 60m/s by generating permutations with duplicates and for each permutation result I used stack to check if it\\'s valid parenthesis and now I came here and ppl post simple/mind-blowing solutions that I never expected and A LOT OF people be like \"yeah~nice solution~i thought kinda the same way~\". WTH!!!!!\\n\\nI started algorithm roughly 3 months ago and I\\'ve been studying 12-14 hrs a day til now and solved probably 200 questions so far. I\\'m kinda confident in BFS DFS DP and some general algorithm but totally new to combinatorics. What should I focus more on? I haven\\'t studied Greedy yet. Can you guys recommend me how I study Greedy? cuz its so vague I\\'ve looked up so much\\n\\nBless to y\\'all\\n\\n- Non-smart Asian sophomore kid-"
                    },
                    {
                        "username": "Haseeeb1",
                        "content": "whats your github and linkedin?"
                    },
                    {
                        "username": "baseballCode",
                        "content": "[@blsd-rus](/blsd-rus) I use the neetcode roadmap, ordering is important and since I started doing the questions in order im starting to get better. "
                    },
                    {
                        "username": "blsd-rus",
                        "content": "[@vishesh014](/vishesh014) i\\'ll recommend neetcode"
                    },
                    {
                        "username": "vishesh014",
                        "content": "bro can you tell me the roadmap how you studied algorithms"
                    },
                    {
                        "username": "andy_r_s",
                        "content": "For n = 4 is following one of the valid combinations?\\n(())(())\\n\\nMy code has this but the leetcode says it\\'s not valid. I don\\'t understand why is it invalid?"
                    },
                    {
                        "username": "fffccc",
                        "content": "I also generated this and the test case doesn\\'t generate this one."
                    },
                    {
                        "username": "charonme",
                        "content": "it\\'s valid, but maybe you generated it twice?"
                    },
                    {
                        "username": "chiragrajput245",
                        "content": "Draw the recursive tree and think about the conditions when an opening/closing bracket can be appended\\n\\n         (\\n        / \\\\\\n       ((  ()\\n      / \\\\   |\\n    ((( (() ()(\\n     .   .   .\\n     .   .   .\\n\\n... and so on"
                    },
                    {
                        "username": "JenZ",
                        "content": "Is it 2^n? \\nIs any method better than it ?Thank you."
                    },
                    {
                        "username": "panwu5588",
                        "content": "BAD test cases. The order should not matter.\\nFor example, the following should be the same:\\n[\"(())\",\"()()\"]\\n[\"()()\",\"(())\"]"
                    },
                    {
                        "username": "satta_sunder",
                        "content": "I applied recursion and got 55% faster only. I\\'d love to see if there is any more efficient method."
                    },
                    {
                        "username": "Puja__Singh",
                        "content": "check mine it beats 97%"
                    },
                    {
                        "username": "noob-pika",
                        "content": "The system for calculating time complexity is broken for a solution after a certain number of submissions"
                    }
                ]
            },
            {
                "id": 1566162,
                "content": [
                    {
                        "username": "bonson",
                        "content": "Using different implmentation,the elements will be in different orders. e.g. n = 3.\\nIt can be\\n[\"((()))\",\"(())()\",\"()(())\",\"(()())\",\"()()()\"]\\nwhile the expected answer is\\n[\"((()))\",\"(()())\",\"(())()\",\"()(())\",\"()()()\"]\\n\\nBoth are correct answers. However, the difference of ordering is reckoned as \"wrong answer\". "
                    },
                    {
                        "username": "theashggl",
                        "content": "It accepts all ordering but that should be specified in the question."
                    },
                    {
                        "username": "gmarus",
                        "content": "still does not"
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# \\u26A0\\uFE0FEasiest \\uD83D\\uDE0E FAANG Method Ever !!! \\uD83D\\uDCA5\\nhttps://leetcode.com/problems/generate-parentheses/solutions/3035511/easiest-faang-method-ever/?orderBy=newest_to_oldest"
                    },
                    {
                        "username": "NicholasCG",
                        "content": "January 2023, it accepted different ordered answers for me."
                    },
                    {
                        "username": "barrybecker4",
                        "content": "[@satbekmyrza](/satbekmyrza) Still does not"
                    },
                    {
                        "username": "angelopoulos",
                        "content": "[@4m4nd33p_51ngh](/4m4nd33p_51ngh) I can confirm it still doesn\\'t"
                    },
                    {
                        "username": "4m4nd33p_51ngh",
                        "content": "[@satbekmyrza](/satbekmyrza) no it doesn\\'t"
                    },
                    {
                        "username": "satbekmyrza",
                        "content": "I think it accepts different ordered answers, as of 2022"
                    },
                    {
                        "username": "tejavenkatlanka",
                        "content": "![image](https://assets.leetcode.com/users/images/dabefcea-2a30-4a0a-81c4-b2dafcf9dce0_1599242411.2652733.png)\\nclick for view \\n[https://embed.creately.com/cclS6u7Upy3?type=svg] \\n\\nleft path represent possible one parentheses and right represent possible of right parentheses.\\n\\nleaf node contains answer.\\n\\nhope it will help.\\n\\n"
                    },
                    {
                        "username": "leetnote_io",
                        "content": "Thanks, the pic is very intuitive"
                    },
                    {
                        "username": "dominic89231",
                        "content": "Very helpful!"
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# \\u26A0\\uFE0FEasiest \\uD83D\\uDE0E FAANG Method Ever !!! \\uD83D\\uDCA5\\nhttps://leetcode.com/problems/generate-parentheses/solutions/3035511/easiest-faang-method-ever/?orderBy=newest_to_oldest"
                    },
                    {
                        "username": "drvnprgrmr",
                        "content": "Literally spent about 2hrs on this and came up with a different, more complex (I think) solution that uses recursion. "
                    },
                    {
                        "username": "ChrisMiaoMiao",
                        "content": "Thx, It\\'s very helpful!"
                    },
                    {
                        "username": "aln4739",
                        "content": "very helpful!"
                    },
                    {
                        "username": "KalRadikov",
                        "content": "![image](https://assets.leetcode.com/users/images/40f0296a-7b58-49fb-a72e-e5d8eacf94a4_1604461937.5052783.png)\\n\\nProof:\\n\\n![image](https://assets.leetcode.com/users/images/4bcd2dba-e170-4799-91ae-3e4a1de32731_1605116132.2703443.png)\\n\\n"
                    },
                    {
                        "username": "BREATHTAKER200",
                        "content": "You sneaky bastard!!!!!\\uD83E\\uDD23\\uD83E\\uDD23"
                    },
                    {
                        "username": "alex_malevinsky",
                        "content": "Lots of lines of code, without loops or recursion. Really legend!"
                    },
                    {
                        "username": "Demaxl",
                        "content": "You\\'re hired"
                    },
                    {
                        "username": "codebuster_",
                        "content": "Habibi, this is a dream come true moment"
                    },
                    {
                        "username": "drMystico",
                        "content": "genius guy downright there! "
                    },
                    {
                        "username": "Cripton",
                        "content": "bros dad works at microsoft"
                    },
                    {
                        "username": "RashCode",
                        "content": "Legend\\uD83E\\uDEE1"
                    },
                    {
                        "username": "milespossing",
                        "content": "Strong hire"
                    },
                    {
                        "username": "sunlins",
                        "content": "I was sure of finding this in the comment section"
                    },
                    {
                        "username": "tanmayyyj",
                        "content": "Bro is a hacker"
                    },
                    {
                        "username": "ktranada1403",
                        "content": "bro beat the system..."
                    },
                    {
                        "username": "rsharvesh16",
                        "content": "Bro is from another world!"
                    },
                    {
                        "username": "buzz_shocker",
                        "content": "This is some big brain stuff"
                    },
                    {
                        "username": "Prasanth2021",
                        "content": "[@kzlatt](/kzlatt) \\uD83D\\uDE02\\uD83D\\uDE02\\uD83D\\uDE02"
                    },
                    {
                        "username": "AdilARahman",
                        "content": "Use switch case to go even faster XD"
                    },
                    {
                        "username": "mdmasidulhasan27",
                        "content": "perfect solution for this problem. it\\'s kind a static problem. "
                    },
                    {
                        "username": "Crispy_coffee",
                        "content": "Testcase Oriented Programming \\uD83D\\uDE02"
                    },
                    {
                        "username": "guneetd",
                        "content": "[@ashok0](/ashok0) then you can use Abstract Factory to generate strings :) "
                    },
                    {
                        "username": "kzlatt",
                        "content": "Leetcode :  Choose!!!!  step up or step down\\nKalRadikov:   S.....i......d......e......w......a......y"
                    },
                    {
                        "username": "District_12",
                        "content": "that\\'s what we call to be creative!"
                    },
                    {
                        "username": "a_s_h_o_k",
                        "content": "what if n=100 \\uD83D\\uDE02"
                    },
                    {
                        "username": "aln4739",
                        "content": "chad"
                    },
                    {
                        "username": "leetcodesquad",
                        "content": "No one can beat you since you already had the answer. LOL"
                    },
                    {
                        "username": "undi69",
                        "content": "Dude you are a god"
                    },
                    {
                        "username": "khanuja05",
                        "content": "My solution generates the same set of outputs but the ordering is different. The question should be edited and they should mention that the order matters."
                    },
                    {
                        "username": "Nemo-7777",
                        "content": "It seems that problem author expects a sorted array of strings. So if you struggle with incorrect order, just sort the array and it should work fine."
                    },
                    {
                        "username": "fillipe",
                        "content": "[@krjukov](/krjukov) My solution fails at the test case with 6 pairs. I have verified exactly why now. It is for not generating certain patterns. The system considers your solution correct regardless of the order in which the patterns are saved in your solution."
                    },
                    {
                        "username": "krjukov",
                        "content": "It\\'s senseless to demand preserved order in this type of problems. All the strings are of the same length. It is the validation of the solutions to be amended, not the description. Just accept any order "
                    },
                    {
                        "username": "noisrucer",
                        "content": "I solved this problem with 60m/s by generating permutations with duplicates and for each permutation result I used stack to check if it\\'s valid parenthesis and now I came here and ppl post simple/mind-blowing solutions that I never expected and A LOT OF people be like \"yeah~nice solution~i thought kinda the same way~\". WTH!!!!!\\n\\nI started algorithm roughly 3 months ago and I\\'ve been studying 12-14 hrs a day til now and solved probably 200 questions so far. I\\'m kinda confident in BFS DFS DP and some general algorithm but totally new to combinatorics. What should I focus more on? I haven\\'t studied Greedy yet. Can you guys recommend me how I study Greedy? cuz its so vague I\\'ve looked up so much\\n\\nBless to y\\'all\\n\\n- Non-smart Asian sophomore kid-"
                    },
                    {
                        "username": "Haseeeb1",
                        "content": "whats your github and linkedin?"
                    },
                    {
                        "username": "baseballCode",
                        "content": "[@blsd-rus](/blsd-rus) I use the neetcode roadmap, ordering is important and since I started doing the questions in order im starting to get better. "
                    },
                    {
                        "username": "blsd-rus",
                        "content": "[@vishesh014](/vishesh014) i\\'ll recommend neetcode"
                    },
                    {
                        "username": "vishesh014",
                        "content": "bro can you tell me the roadmap how you studied algorithms"
                    },
                    {
                        "username": "andy_r_s",
                        "content": "For n = 4 is following one of the valid combinations?\\n(())(())\\n\\nMy code has this but the leetcode says it\\'s not valid. I don\\'t understand why is it invalid?"
                    },
                    {
                        "username": "fffccc",
                        "content": "I also generated this and the test case doesn\\'t generate this one."
                    },
                    {
                        "username": "charonme",
                        "content": "it\\'s valid, but maybe you generated it twice?"
                    },
                    {
                        "username": "chiragrajput245",
                        "content": "Draw the recursive tree and think about the conditions when an opening/closing bracket can be appended\\n\\n         (\\n        / \\\\\\n       ((  ()\\n      / \\\\   |\\n    ((( (() ()(\\n     .   .   .\\n     .   .   .\\n\\n... and so on"
                    },
                    {
                        "username": "JenZ",
                        "content": "Is it 2^n? \\nIs any method better than it ?Thank you."
                    },
                    {
                        "username": "panwu5588",
                        "content": "BAD test cases. The order should not matter.\\nFor example, the following should be the same:\\n[\"(())\",\"()()\"]\\n[\"()()\",\"(())\"]"
                    },
                    {
                        "username": "satta_sunder",
                        "content": "I applied recursion and got 55% faster only. I\\'d love to see if there is any more efficient method."
                    },
                    {
                        "username": "Puja__Singh",
                        "content": "check mine it beats 97%"
                    },
                    {
                        "username": "noob-pika",
                        "content": "The system for calculating time complexity is broken for a solution after a certain number of submissions"
                    }
                ]
            },
            {
                "id": 1565657,
                "content": [
                    {
                        "username": "bonson",
                        "content": "Using different implmentation,the elements will be in different orders. e.g. n = 3.\\nIt can be\\n[\"((()))\",\"(())()\",\"()(())\",\"(()())\",\"()()()\"]\\nwhile the expected answer is\\n[\"((()))\",\"(()())\",\"(())()\",\"()(())\",\"()()()\"]\\n\\nBoth are correct answers. However, the difference of ordering is reckoned as \"wrong answer\". "
                    },
                    {
                        "username": "theashggl",
                        "content": "It accepts all ordering but that should be specified in the question."
                    },
                    {
                        "username": "gmarus",
                        "content": "still does not"
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# \\u26A0\\uFE0FEasiest \\uD83D\\uDE0E FAANG Method Ever !!! \\uD83D\\uDCA5\\nhttps://leetcode.com/problems/generate-parentheses/solutions/3035511/easiest-faang-method-ever/?orderBy=newest_to_oldest"
                    },
                    {
                        "username": "NicholasCG",
                        "content": "January 2023, it accepted different ordered answers for me."
                    },
                    {
                        "username": "barrybecker4",
                        "content": "[@satbekmyrza](/satbekmyrza) Still does not"
                    },
                    {
                        "username": "angelopoulos",
                        "content": "[@4m4nd33p_51ngh](/4m4nd33p_51ngh) I can confirm it still doesn\\'t"
                    },
                    {
                        "username": "4m4nd33p_51ngh",
                        "content": "[@satbekmyrza](/satbekmyrza) no it doesn\\'t"
                    },
                    {
                        "username": "satbekmyrza",
                        "content": "I think it accepts different ordered answers, as of 2022"
                    },
                    {
                        "username": "tejavenkatlanka",
                        "content": "![image](https://assets.leetcode.com/users/images/dabefcea-2a30-4a0a-81c4-b2dafcf9dce0_1599242411.2652733.png)\\nclick for view \\n[https://embed.creately.com/cclS6u7Upy3?type=svg] \\n\\nleft path represent possible one parentheses and right represent possible of right parentheses.\\n\\nleaf node contains answer.\\n\\nhope it will help.\\n\\n"
                    },
                    {
                        "username": "leetnote_io",
                        "content": "Thanks, the pic is very intuitive"
                    },
                    {
                        "username": "dominic89231",
                        "content": "Very helpful!"
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# \\u26A0\\uFE0FEasiest \\uD83D\\uDE0E FAANG Method Ever !!! \\uD83D\\uDCA5\\nhttps://leetcode.com/problems/generate-parentheses/solutions/3035511/easiest-faang-method-ever/?orderBy=newest_to_oldest"
                    },
                    {
                        "username": "drvnprgrmr",
                        "content": "Literally spent about 2hrs on this and came up with a different, more complex (I think) solution that uses recursion. "
                    },
                    {
                        "username": "ChrisMiaoMiao",
                        "content": "Thx, It\\'s very helpful!"
                    },
                    {
                        "username": "aln4739",
                        "content": "very helpful!"
                    },
                    {
                        "username": "KalRadikov",
                        "content": "![image](https://assets.leetcode.com/users/images/40f0296a-7b58-49fb-a72e-e5d8eacf94a4_1604461937.5052783.png)\\n\\nProof:\\n\\n![image](https://assets.leetcode.com/users/images/4bcd2dba-e170-4799-91ae-3e4a1de32731_1605116132.2703443.png)\\n\\n"
                    },
                    {
                        "username": "BREATHTAKER200",
                        "content": "You sneaky bastard!!!!!\\uD83E\\uDD23\\uD83E\\uDD23"
                    },
                    {
                        "username": "alex_malevinsky",
                        "content": "Lots of lines of code, without loops or recursion. Really legend!"
                    },
                    {
                        "username": "Demaxl",
                        "content": "You\\'re hired"
                    },
                    {
                        "username": "codebuster_",
                        "content": "Habibi, this is a dream come true moment"
                    },
                    {
                        "username": "drMystico",
                        "content": "genius guy downright there! "
                    },
                    {
                        "username": "Cripton",
                        "content": "bros dad works at microsoft"
                    },
                    {
                        "username": "RashCode",
                        "content": "Legend\\uD83E\\uDEE1"
                    },
                    {
                        "username": "milespossing",
                        "content": "Strong hire"
                    },
                    {
                        "username": "sunlins",
                        "content": "I was sure of finding this in the comment section"
                    },
                    {
                        "username": "tanmayyyj",
                        "content": "Bro is a hacker"
                    },
                    {
                        "username": "ktranada1403",
                        "content": "bro beat the system..."
                    },
                    {
                        "username": "rsharvesh16",
                        "content": "Bro is from another world!"
                    },
                    {
                        "username": "buzz_shocker",
                        "content": "This is some big brain stuff"
                    },
                    {
                        "username": "Prasanth2021",
                        "content": "[@kzlatt](/kzlatt) \\uD83D\\uDE02\\uD83D\\uDE02\\uD83D\\uDE02"
                    },
                    {
                        "username": "AdilARahman",
                        "content": "Use switch case to go even faster XD"
                    },
                    {
                        "username": "mdmasidulhasan27",
                        "content": "perfect solution for this problem. it\\'s kind a static problem. "
                    },
                    {
                        "username": "Crispy_coffee",
                        "content": "Testcase Oriented Programming \\uD83D\\uDE02"
                    },
                    {
                        "username": "guneetd",
                        "content": "[@ashok0](/ashok0) then you can use Abstract Factory to generate strings :) "
                    },
                    {
                        "username": "kzlatt",
                        "content": "Leetcode :  Choose!!!!  step up or step down\\nKalRadikov:   S.....i......d......e......w......a......y"
                    },
                    {
                        "username": "District_12",
                        "content": "that\\'s what we call to be creative!"
                    },
                    {
                        "username": "a_s_h_o_k",
                        "content": "what if n=100 \\uD83D\\uDE02"
                    },
                    {
                        "username": "aln4739",
                        "content": "chad"
                    },
                    {
                        "username": "leetcodesquad",
                        "content": "No one can beat you since you already had the answer. LOL"
                    },
                    {
                        "username": "undi69",
                        "content": "Dude you are a god"
                    },
                    {
                        "username": "khanuja05",
                        "content": "My solution generates the same set of outputs but the ordering is different. The question should be edited and they should mention that the order matters."
                    },
                    {
                        "username": "Nemo-7777",
                        "content": "It seems that problem author expects a sorted array of strings. So if you struggle with incorrect order, just sort the array and it should work fine."
                    },
                    {
                        "username": "fillipe",
                        "content": "[@krjukov](/krjukov) My solution fails at the test case with 6 pairs. I have verified exactly why now. It is for not generating certain patterns. The system considers your solution correct regardless of the order in which the patterns are saved in your solution."
                    },
                    {
                        "username": "krjukov",
                        "content": "It\\'s senseless to demand preserved order in this type of problems. All the strings are of the same length. It is the validation of the solutions to be amended, not the description. Just accept any order "
                    },
                    {
                        "username": "noisrucer",
                        "content": "I solved this problem with 60m/s by generating permutations with duplicates and for each permutation result I used stack to check if it\\'s valid parenthesis and now I came here and ppl post simple/mind-blowing solutions that I never expected and A LOT OF people be like \"yeah~nice solution~i thought kinda the same way~\". WTH!!!!!\\n\\nI started algorithm roughly 3 months ago and I\\'ve been studying 12-14 hrs a day til now and solved probably 200 questions so far. I\\'m kinda confident in BFS DFS DP and some general algorithm but totally new to combinatorics. What should I focus more on? I haven\\'t studied Greedy yet. Can you guys recommend me how I study Greedy? cuz its so vague I\\'ve looked up so much\\n\\nBless to y\\'all\\n\\n- Non-smart Asian sophomore kid-"
                    },
                    {
                        "username": "Haseeeb1",
                        "content": "whats your github and linkedin?"
                    },
                    {
                        "username": "baseballCode",
                        "content": "[@blsd-rus](/blsd-rus) I use the neetcode roadmap, ordering is important and since I started doing the questions in order im starting to get better. "
                    },
                    {
                        "username": "blsd-rus",
                        "content": "[@vishesh014](/vishesh014) i\\'ll recommend neetcode"
                    },
                    {
                        "username": "vishesh014",
                        "content": "bro can you tell me the roadmap how you studied algorithms"
                    },
                    {
                        "username": "andy_r_s",
                        "content": "For n = 4 is following one of the valid combinations?\\n(())(())\\n\\nMy code has this but the leetcode says it\\'s not valid. I don\\'t understand why is it invalid?"
                    },
                    {
                        "username": "fffccc",
                        "content": "I also generated this and the test case doesn\\'t generate this one."
                    },
                    {
                        "username": "charonme",
                        "content": "it\\'s valid, but maybe you generated it twice?"
                    },
                    {
                        "username": "chiragrajput245",
                        "content": "Draw the recursive tree and think about the conditions when an opening/closing bracket can be appended\\n\\n         (\\n        / \\\\\\n       ((  ()\\n      / \\\\   |\\n    ((( (() ()(\\n     .   .   .\\n     .   .   .\\n\\n... and so on"
                    },
                    {
                        "username": "JenZ",
                        "content": "Is it 2^n? \\nIs any method better than it ?Thank you."
                    },
                    {
                        "username": "panwu5588",
                        "content": "BAD test cases. The order should not matter.\\nFor example, the following should be the same:\\n[\"(())\",\"()()\"]\\n[\"()()\",\"(())\"]"
                    },
                    {
                        "username": "satta_sunder",
                        "content": "I applied recursion and got 55% faster only. I\\'d love to see if there is any more efficient method."
                    },
                    {
                        "username": "Puja__Singh",
                        "content": "check mine it beats 97%"
                    },
                    {
                        "username": "noob-pika",
                        "content": "The system for calculating time complexity is broken for a solution after a certain number of submissions"
                    }
                ]
            },
            {
                "id": 1574405,
                "content": [
                    {
                        "username": "bonson",
                        "content": "Using different implmentation,the elements will be in different orders. e.g. n = 3.\\nIt can be\\n[\"((()))\",\"(())()\",\"()(())\",\"(()())\",\"()()()\"]\\nwhile the expected answer is\\n[\"((()))\",\"(()())\",\"(())()\",\"()(())\",\"()()()\"]\\n\\nBoth are correct answers. However, the difference of ordering is reckoned as \"wrong answer\". "
                    },
                    {
                        "username": "theashggl",
                        "content": "It accepts all ordering but that should be specified in the question."
                    },
                    {
                        "username": "gmarus",
                        "content": "still does not"
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# \\u26A0\\uFE0FEasiest \\uD83D\\uDE0E FAANG Method Ever !!! \\uD83D\\uDCA5\\nhttps://leetcode.com/problems/generate-parentheses/solutions/3035511/easiest-faang-method-ever/?orderBy=newest_to_oldest"
                    },
                    {
                        "username": "NicholasCG",
                        "content": "January 2023, it accepted different ordered answers for me."
                    },
                    {
                        "username": "barrybecker4",
                        "content": "[@satbekmyrza](/satbekmyrza) Still does not"
                    },
                    {
                        "username": "angelopoulos",
                        "content": "[@4m4nd33p_51ngh](/4m4nd33p_51ngh) I can confirm it still doesn\\'t"
                    },
                    {
                        "username": "4m4nd33p_51ngh",
                        "content": "[@satbekmyrza](/satbekmyrza) no it doesn\\'t"
                    },
                    {
                        "username": "satbekmyrza",
                        "content": "I think it accepts different ordered answers, as of 2022"
                    },
                    {
                        "username": "tejavenkatlanka",
                        "content": "![image](https://assets.leetcode.com/users/images/dabefcea-2a30-4a0a-81c4-b2dafcf9dce0_1599242411.2652733.png)\\nclick for view \\n[https://embed.creately.com/cclS6u7Upy3?type=svg] \\n\\nleft path represent possible one parentheses and right represent possible of right parentheses.\\n\\nleaf node contains answer.\\n\\nhope it will help.\\n\\n"
                    },
                    {
                        "username": "leetnote_io",
                        "content": "Thanks, the pic is very intuitive"
                    },
                    {
                        "username": "dominic89231",
                        "content": "Very helpful!"
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# \\u26A0\\uFE0FEasiest \\uD83D\\uDE0E FAANG Method Ever !!! \\uD83D\\uDCA5\\nhttps://leetcode.com/problems/generate-parentheses/solutions/3035511/easiest-faang-method-ever/?orderBy=newest_to_oldest"
                    },
                    {
                        "username": "drvnprgrmr",
                        "content": "Literally spent about 2hrs on this and came up with a different, more complex (I think) solution that uses recursion. "
                    },
                    {
                        "username": "ChrisMiaoMiao",
                        "content": "Thx, It\\'s very helpful!"
                    },
                    {
                        "username": "aln4739",
                        "content": "very helpful!"
                    },
                    {
                        "username": "KalRadikov",
                        "content": "![image](https://assets.leetcode.com/users/images/40f0296a-7b58-49fb-a72e-e5d8eacf94a4_1604461937.5052783.png)\\n\\nProof:\\n\\n![image](https://assets.leetcode.com/users/images/4bcd2dba-e170-4799-91ae-3e4a1de32731_1605116132.2703443.png)\\n\\n"
                    },
                    {
                        "username": "BREATHTAKER200",
                        "content": "You sneaky bastard!!!!!\\uD83E\\uDD23\\uD83E\\uDD23"
                    },
                    {
                        "username": "alex_malevinsky",
                        "content": "Lots of lines of code, without loops or recursion. Really legend!"
                    },
                    {
                        "username": "Demaxl",
                        "content": "You\\'re hired"
                    },
                    {
                        "username": "codebuster_",
                        "content": "Habibi, this is a dream come true moment"
                    },
                    {
                        "username": "drMystico",
                        "content": "genius guy downright there! "
                    },
                    {
                        "username": "Cripton",
                        "content": "bros dad works at microsoft"
                    },
                    {
                        "username": "RashCode",
                        "content": "Legend\\uD83E\\uDEE1"
                    },
                    {
                        "username": "milespossing",
                        "content": "Strong hire"
                    },
                    {
                        "username": "sunlins",
                        "content": "I was sure of finding this in the comment section"
                    },
                    {
                        "username": "tanmayyyj",
                        "content": "Bro is a hacker"
                    },
                    {
                        "username": "ktranada1403",
                        "content": "bro beat the system..."
                    },
                    {
                        "username": "rsharvesh16",
                        "content": "Bro is from another world!"
                    },
                    {
                        "username": "buzz_shocker",
                        "content": "This is some big brain stuff"
                    },
                    {
                        "username": "Prasanth2021",
                        "content": "[@kzlatt](/kzlatt) \\uD83D\\uDE02\\uD83D\\uDE02\\uD83D\\uDE02"
                    },
                    {
                        "username": "AdilARahman",
                        "content": "Use switch case to go even faster XD"
                    },
                    {
                        "username": "mdmasidulhasan27",
                        "content": "perfect solution for this problem. it\\'s kind a static problem. "
                    },
                    {
                        "username": "Crispy_coffee",
                        "content": "Testcase Oriented Programming \\uD83D\\uDE02"
                    },
                    {
                        "username": "guneetd",
                        "content": "[@ashok0](/ashok0) then you can use Abstract Factory to generate strings :) "
                    },
                    {
                        "username": "kzlatt",
                        "content": "Leetcode :  Choose!!!!  step up or step down\\nKalRadikov:   S.....i......d......e......w......a......y"
                    },
                    {
                        "username": "District_12",
                        "content": "that\\'s what we call to be creative!"
                    },
                    {
                        "username": "a_s_h_o_k",
                        "content": "what if n=100 \\uD83D\\uDE02"
                    },
                    {
                        "username": "aln4739",
                        "content": "chad"
                    },
                    {
                        "username": "leetcodesquad",
                        "content": "No one can beat you since you already had the answer. LOL"
                    },
                    {
                        "username": "undi69",
                        "content": "Dude you are a god"
                    },
                    {
                        "username": "khanuja05",
                        "content": "My solution generates the same set of outputs but the ordering is different. The question should be edited and they should mention that the order matters."
                    },
                    {
                        "username": "Nemo-7777",
                        "content": "It seems that problem author expects a sorted array of strings. So if you struggle with incorrect order, just sort the array and it should work fine."
                    },
                    {
                        "username": "fillipe",
                        "content": "[@krjukov](/krjukov) My solution fails at the test case with 6 pairs. I have verified exactly why now. It is for not generating certain patterns. The system considers your solution correct regardless of the order in which the patterns are saved in your solution."
                    },
                    {
                        "username": "krjukov",
                        "content": "It\\'s senseless to demand preserved order in this type of problems. All the strings are of the same length. It is the validation of the solutions to be amended, not the description. Just accept any order "
                    },
                    {
                        "username": "noisrucer",
                        "content": "I solved this problem with 60m/s by generating permutations with duplicates and for each permutation result I used stack to check if it\\'s valid parenthesis and now I came here and ppl post simple/mind-blowing solutions that I never expected and A LOT OF people be like \"yeah~nice solution~i thought kinda the same way~\". WTH!!!!!\\n\\nI started algorithm roughly 3 months ago and I\\'ve been studying 12-14 hrs a day til now and solved probably 200 questions so far. I\\'m kinda confident in BFS DFS DP and some general algorithm but totally new to combinatorics. What should I focus more on? I haven\\'t studied Greedy yet. Can you guys recommend me how I study Greedy? cuz its so vague I\\'ve looked up so much\\n\\nBless to y\\'all\\n\\n- Non-smart Asian sophomore kid-"
                    },
                    {
                        "username": "Haseeeb1",
                        "content": "whats your github and linkedin?"
                    },
                    {
                        "username": "baseballCode",
                        "content": "[@blsd-rus](/blsd-rus) I use the neetcode roadmap, ordering is important and since I started doing the questions in order im starting to get better. "
                    },
                    {
                        "username": "blsd-rus",
                        "content": "[@vishesh014](/vishesh014) i\\'ll recommend neetcode"
                    },
                    {
                        "username": "vishesh014",
                        "content": "bro can you tell me the roadmap how you studied algorithms"
                    },
                    {
                        "username": "andy_r_s",
                        "content": "For n = 4 is following one of the valid combinations?\\n(())(())\\n\\nMy code has this but the leetcode says it\\'s not valid. I don\\'t understand why is it invalid?"
                    },
                    {
                        "username": "fffccc",
                        "content": "I also generated this and the test case doesn\\'t generate this one."
                    },
                    {
                        "username": "charonme",
                        "content": "it\\'s valid, but maybe you generated it twice?"
                    },
                    {
                        "username": "chiragrajput245",
                        "content": "Draw the recursive tree and think about the conditions when an opening/closing bracket can be appended\\n\\n         (\\n        / \\\\\\n       ((  ()\\n      / \\\\   |\\n    ((( (() ()(\\n     .   .   .\\n     .   .   .\\n\\n... and so on"
                    },
                    {
                        "username": "JenZ",
                        "content": "Is it 2^n? \\nIs any method better than it ?Thank you."
                    },
                    {
                        "username": "panwu5588",
                        "content": "BAD test cases. The order should not matter.\\nFor example, the following should be the same:\\n[\"(())\",\"()()\"]\\n[\"()()\",\"(())\"]"
                    },
                    {
                        "username": "satta_sunder",
                        "content": "I applied recursion and got 55% faster only. I\\'d love to see if there is any more efficient method."
                    },
                    {
                        "username": "Puja__Singh",
                        "content": "check mine it beats 97%"
                    },
                    {
                        "username": "noob-pika",
                        "content": "The system for calculating time complexity is broken for a solution after a certain number of submissions"
                    }
                ]
            },
            {
                "id": 1568042,
                "content": [
                    {
                        "username": "bonson",
                        "content": "Using different implmentation,the elements will be in different orders. e.g. n = 3.\\nIt can be\\n[\"((()))\",\"(())()\",\"()(())\",\"(()())\",\"()()()\"]\\nwhile the expected answer is\\n[\"((()))\",\"(()())\",\"(())()\",\"()(())\",\"()()()\"]\\n\\nBoth are correct answers. However, the difference of ordering is reckoned as \"wrong answer\". "
                    },
                    {
                        "username": "theashggl",
                        "content": "It accepts all ordering but that should be specified in the question."
                    },
                    {
                        "username": "gmarus",
                        "content": "still does not"
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# \\u26A0\\uFE0FEasiest \\uD83D\\uDE0E FAANG Method Ever !!! \\uD83D\\uDCA5\\nhttps://leetcode.com/problems/generate-parentheses/solutions/3035511/easiest-faang-method-ever/?orderBy=newest_to_oldest"
                    },
                    {
                        "username": "NicholasCG",
                        "content": "January 2023, it accepted different ordered answers for me."
                    },
                    {
                        "username": "barrybecker4",
                        "content": "[@satbekmyrza](/satbekmyrza) Still does not"
                    },
                    {
                        "username": "angelopoulos",
                        "content": "[@4m4nd33p_51ngh](/4m4nd33p_51ngh) I can confirm it still doesn\\'t"
                    },
                    {
                        "username": "4m4nd33p_51ngh",
                        "content": "[@satbekmyrza](/satbekmyrza) no it doesn\\'t"
                    },
                    {
                        "username": "satbekmyrza",
                        "content": "I think it accepts different ordered answers, as of 2022"
                    },
                    {
                        "username": "tejavenkatlanka",
                        "content": "![image](https://assets.leetcode.com/users/images/dabefcea-2a30-4a0a-81c4-b2dafcf9dce0_1599242411.2652733.png)\\nclick for view \\n[https://embed.creately.com/cclS6u7Upy3?type=svg] \\n\\nleft path represent possible one parentheses and right represent possible of right parentheses.\\n\\nleaf node contains answer.\\n\\nhope it will help.\\n\\n"
                    },
                    {
                        "username": "leetnote_io",
                        "content": "Thanks, the pic is very intuitive"
                    },
                    {
                        "username": "dominic89231",
                        "content": "Very helpful!"
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# \\u26A0\\uFE0FEasiest \\uD83D\\uDE0E FAANG Method Ever !!! \\uD83D\\uDCA5\\nhttps://leetcode.com/problems/generate-parentheses/solutions/3035511/easiest-faang-method-ever/?orderBy=newest_to_oldest"
                    },
                    {
                        "username": "drvnprgrmr",
                        "content": "Literally spent about 2hrs on this and came up with a different, more complex (I think) solution that uses recursion. "
                    },
                    {
                        "username": "ChrisMiaoMiao",
                        "content": "Thx, It\\'s very helpful!"
                    },
                    {
                        "username": "aln4739",
                        "content": "very helpful!"
                    },
                    {
                        "username": "KalRadikov",
                        "content": "![image](https://assets.leetcode.com/users/images/40f0296a-7b58-49fb-a72e-e5d8eacf94a4_1604461937.5052783.png)\\n\\nProof:\\n\\n![image](https://assets.leetcode.com/users/images/4bcd2dba-e170-4799-91ae-3e4a1de32731_1605116132.2703443.png)\\n\\n"
                    },
                    {
                        "username": "BREATHTAKER200",
                        "content": "You sneaky bastard!!!!!\\uD83E\\uDD23\\uD83E\\uDD23"
                    },
                    {
                        "username": "alex_malevinsky",
                        "content": "Lots of lines of code, without loops or recursion. Really legend!"
                    },
                    {
                        "username": "Demaxl",
                        "content": "You\\'re hired"
                    },
                    {
                        "username": "codebuster_",
                        "content": "Habibi, this is a dream come true moment"
                    },
                    {
                        "username": "drMystico",
                        "content": "genius guy downright there! "
                    },
                    {
                        "username": "Cripton",
                        "content": "bros dad works at microsoft"
                    },
                    {
                        "username": "RashCode",
                        "content": "Legend\\uD83E\\uDEE1"
                    },
                    {
                        "username": "milespossing",
                        "content": "Strong hire"
                    },
                    {
                        "username": "sunlins",
                        "content": "I was sure of finding this in the comment section"
                    },
                    {
                        "username": "tanmayyyj",
                        "content": "Bro is a hacker"
                    },
                    {
                        "username": "ktranada1403",
                        "content": "bro beat the system..."
                    },
                    {
                        "username": "rsharvesh16",
                        "content": "Bro is from another world!"
                    },
                    {
                        "username": "buzz_shocker",
                        "content": "This is some big brain stuff"
                    },
                    {
                        "username": "Prasanth2021",
                        "content": "[@kzlatt](/kzlatt) \\uD83D\\uDE02\\uD83D\\uDE02\\uD83D\\uDE02"
                    },
                    {
                        "username": "AdilARahman",
                        "content": "Use switch case to go even faster XD"
                    },
                    {
                        "username": "mdmasidulhasan27",
                        "content": "perfect solution for this problem. it\\'s kind a static problem. "
                    },
                    {
                        "username": "Crispy_coffee",
                        "content": "Testcase Oriented Programming \\uD83D\\uDE02"
                    },
                    {
                        "username": "guneetd",
                        "content": "[@ashok0](/ashok0) then you can use Abstract Factory to generate strings :) "
                    },
                    {
                        "username": "kzlatt",
                        "content": "Leetcode :  Choose!!!!  step up or step down\\nKalRadikov:   S.....i......d......e......w......a......y"
                    },
                    {
                        "username": "District_12",
                        "content": "that\\'s what we call to be creative!"
                    },
                    {
                        "username": "a_s_h_o_k",
                        "content": "what if n=100 \\uD83D\\uDE02"
                    },
                    {
                        "username": "aln4739",
                        "content": "chad"
                    },
                    {
                        "username": "leetcodesquad",
                        "content": "No one can beat you since you already had the answer. LOL"
                    },
                    {
                        "username": "undi69",
                        "content": "Dude you are a god"
                    },
                    {
                        "username": "khanuja05",
                        "content": "My solution generates the same set of outputs but the ordering is different. The question should be edited and they should mention that the order matters."
                    },
                    {
                        "username": "Nemo-7777",
                        "content": "It seems that problem author expects a sorted array of strings. So if you struggle with incorrect order, just sort the array and it should work fine."
                    },
                    {
                        "username": "fillipe",
                        "content": "[@krjukov](/krjukov) My solution fails at the test case with 6 pairs. I have verified exactly why now. It is for not generating certain patterns. The system considers your solution correct regardless of the order in which the patterns are saved in your solution."
                    },
                    {
                        "username": "krjukov",
                        "content": "It\\'s senseless to demand preserved order in this type of problems. All the strings are of the same length. It is the validation of the solutions to be amended, not the description. Just accept any order "
                    },
                    {
                        "username": "noisrucer",
                        "content": "I solved this problem with 60m/s by generating permutations with duplicates and for each permutation result I used stack to check if it\\'s valid parenthesis and now I came here and ppl post simple/mind-blowing solutions that I never expected and A LOT OF people be like \"yeah~nice solution~i thought kinda the same way~\". WTH!!!!!\\n\\nI started algorithm roughly 3 months ago and I\\'ve been studying 12-14 hrs a day til now and solved probably 200 questions so far. I\\'m kinda confident in BFS DFS DP and some general algorithm but totally new to combinatorics. What should I focus more on? I haven\\'t studied Greedy yet. Can you guys recommend me how I study Greedy? cuz its so vague I\\'ve looked up so much\\n\\nBless to y\\'all\\n\\n- Non-smart Asian sophomore kid-"
                    },
                    {
                        "username": "Haseeeb1",
                        "content": "whats your github and linkedin?"
                    },
                    {
                        "username": "baseballCode",
                        "content": "[@blsd-rus](/blsd-rus) I use the neetcode roadmap, ordering is important and since I started doing the questions in order im starting to get better. "
                    },
                    {
                        "username": "blsd-rus",
                        "content": "[@vishesh014](/vishesh014) i\\'ll recommend neetcode"
                    },
                    {
                        "username": "vishesh014",
                        "content": "bro can you tell me the roadmap how you studied algorithms"
                    },
                    {
                        "username": "andy_r_s",
                        "content": "For n = 4 is following one of the valid combinations?\\n(())(())\\n\\nMy code has this but the leetcode says it\\'s not valid. I don\\'t understand why is it invalid?"
                    },
                    {
                        "username": "fffccc",
                        "content": "I also generated this and the test case doesn\\'t generate this one."
                    },
                    {
                        "username": "charonme",
                        "content": "it\\'s valid, but maybe you generated it twice?"
                    },
                    {
                        "username": "chiragrajput245",
                        "content": "Draw the recursive tree and think about the conditions when an opening/closing bracket can be appended\\n\\n         (\\n        / \\\\\\n       ((  ()\\n      / \\\\   |\\n    ((( (() ()(\\n     .   .   .\\n     .   .   .\\n\\n... and so on"
                    },
                    {
                        "username": "JenZ",
                        "content": "Is it 2^n? \\nIs any method better than it ?Thank you."
                    },
                    {
                        "username": "panwu5588",
                        "content": "BAD test cases. The order should not matter.\\nFor example, the following should be the same:\\n[\"(())\",\"()()\"]\\n[\"()()\",\"(())\"]"
                    },
                    {
                        "username": "satta_sunder",
                        "content": "I applied recursion and got 55% faster only. I\\'d love to see if there is any more efficient method."
                    },
                    {
                        "username": "Puja__Singh",
                        "content": "check mine it beats 97%"
                    },
                    {
                        "username": "noob-pika",
                        "content": "The system for calculating time complexity is broken for a solution after a certain number of submissions"
                    }
                ]
            },
            {
                "id": 1980901,
                "content": [
                    {
                        "username": "bonson",
                        "content": "Using different implmentation,the elements will be in different orders. e.g. n = 3.\\nIt can be\\n[\"((()))\",\"(())()\",\"()(())\",\"(()())\",\"()()()\"]\\nwhile the expected answer is\\n[\"((()))\",\"(()())\",\"(())()\",\"()(())\",\"()()()\"]\\n\\nBoth are correct answers. However, the difference of ordering is reckoned as \"wrong answer\". "
                    },
                    {
                        "username": "theashggl",
                        "content": "It accepts all ordering but that should be specified in the question."
                    },
                    {
                        "username": "gmarus",
                        "content": "still does not"
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# \\u26A0\\uFE0FEasiest \\uD83D\\uDE0E FAANG Method Ever !!! \\uD83D\\uDCA5\\nhttps://leetcode.com/problems/generate-parentheses/solutions/3035511/easiest-faang-method-ever/?orderBy=newest_to_oldest"
                    },
                    {
                        "username": "NicholasCG",
                        "content": "January 2023, it accepted different ordered answers for me."
                    },
                    {
                        "username": "barrybecker4",
                        "content": "[@satbekmyrza](/satbekmyrza) Still does not"
                    },
                    {
                        "username": "angelopoulos",
                        "content": "[@4m4nd33p_51ngh](/4m4nd33p_51ngh) I can confirm it still doesn\\'t"
                    },
                    {
                        "username": "4m4nd33p_51ngh",
                        "content": "[@satbekmyrza](/satbekmyrza) no it doesn\\'t"
                    },
                    {
                        "username": "satbekmyrza",
                        "content": "I think it accepts different ordered answers, as of 2022"
                    },
                    {
                        "username": "tejavenkatlanka",
                        "content": "![image](https://assets.leetcode.com/users/images/dabefcea-2a30-4a0a-81c4-b2dafcf9dce0_1599242411.2652733.png)\\nclick for view \\n[https://embed.creately.com/cclS6u7Upy3?type=svg] \\n\\nleft path represent possible one parentheses and right represent possible of right parentheses.\\n\\nleaf node contains answer.\\n\\nhope it will help.\\n\\n"
                    },
                    {
                        "username": "leetnote_io",
                        "content": "Thanks, the pic is very intuitive"
                    },
                    {
                        "username": "dominic89231",
                        "content": "Very helpful!"
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# \\u26A0\\uFE0FEasiest \\uD83D\\uDE0E FAANG Method Ever !!! \\uD83D\\uDCA5\\nhttps://leetcode.com/problems/generate-parentheses/solutions/3035511/easiest-faang-method-ever/?orderBy=newest_to_oldest"
                    },
                    {
                        "username": "drvnprgrmr",
                        "content": "Literally spent about 2hrs on this and came up with a different, more complex (I think) solution that uses recursion. "
                    },
                    {
                        "username": "ChrisMiaoMiao",
                        "content": "Thx, It\\'s very helpful!"
                    },
                    {
                        "username": "aln4739",
                        "content": "very helpful!"
                    },
                    {
                        "username": "KalRadikov",
                        "content": "![image](https://assets.leetcode.com/users/images/40f0296a-7b58-49fb-a72e-e5d8eacf94a4_1604461937.5052783.png)\\n\\nProof:\\n\\n![image](https://assets.leetcode.com/users/images/4bcd2dba-e170-4799-91ae-3e4a1de32731_1605116132.2703443.png)\\n\\n"
                    },
                    {
                        "username": "BREATHTAKER200",
                        "content": "You sneaky bastard!!!!!\\uD83E\\uDD23\\uD83E\\uDD23"
                    },
                    {
                        "username": "alex_malevinsky",
                        "content": "Lots of lines of code, without loops or recursion. Really legend!"
                    },
                    {
                        "username": "Demaxl",
                        "content": "You\\'re hired"
                    },
                    {
                        "username": "codebuster_",
                        "content": "Habibi, this is a dream come true moment"
                    },
                    {
                        "username": "drMystico",
                        "content": "genius guy downright there! "
                    },
                    {
                        "username": "Cripton",
                        "content": "bros dad works at microsoft"
                    },
                    {
                        "username": "RashCode",
                        "content": "Legend\\uD83E\\uDEE1"
                    },
                    {
                        "username": "milespossing",
                        "content": "Strong hire"
                    },
                    {
                        "username": "sunlins",
                        "content": "I was sure of finding this in the comment section"
                    },
                    {
                        "username": "tanmayyyj",
                        "content": "Bro is a hacker"
                    },
                    {
                        "username": "ktranada1403",
                        "content": "bro beat the system..."
                    },
                    {
                        "username": "rsharvesh16",
                        "content": "Bro is from another world!"
                    },
                    {
                        "username": "buzz_shocker",
                        "content": "This is some big brain stuff"
                    },
                    {
                        "username": "Prasanth2021",
                        "content": "[@kzlatt](/kzlatt) \\uD83D\\uDE02\\uD83D\\uDE02\\uD83D\\uDE02"
                    },
                    {
                        "username": "AdilARahman",
                        "content": "Use switch case to go even faster XD"
                    },
                    {
                        "username": "mdmasidulhasan27",
                        "content": "perfect solution for this problem. it\\'s kind a static problem. "
                    },
                    {
                        "username": "Crispy_coffee",
                        "content": "Testcase Oriented Programming \\uD83D\\uDE02"
                    },
                    {
                        "username": "guneetd",
                        "content": "[@ashok0](/ashok0) then you can use Abstract Factory to generate strings :) "
                    },
                    {
                        "username": "kzlatt",
                        "content": "Leetcode :  Choose!!!!  step up or step down\\nKalRadikov:   S.....i......d......e......w......a......y"
                    },
                    {
                        "username": "District_12",
                        "content": "that\\'s what we call to be creative!"
                    },
                    {
                        "username": "a_s_h_o_k",
                        "content": "what if n=100 \\uD83D\\uDE02"
                    },
                    {
                        "username": "aln4739",
                        "content": "chad"
                    },
                    {
                        "username": "leetcodesquad",
                        "content": "No one can beat you since you already had the answer. LOL"
                    },
                    {
                        "username": "undi69",
                        "content": "Dude you are a god"
                    },
                    {
                        "username": "khanuja05",
                        "content": "My solution generates the same set of outputs but the ordering is different. The question should be edited and they should mention that the order matters."
                    },
                    {
                        "username": "Nemo-7777",
                        "content": "It seems that problem author expects a sorted array of strings. So if you struggle with incorrect order, just sort the array and it should work fine."
                    },
                    {
                        "username": "fillipe",
                        "content": "[@krjukov](/krjukov) My solution fails at the test case with 6 pairs. I have verified exactly why now. It is for not generating certain patterns. The system considers your solution correct regardless of the order in which the patterns are saved in your solution."
                    },
                    {
                        "username": "krjukov",
                        "content": "It\\'s senseless to demand preserved order in this type of problems. All the strings are of the same length. It is the validation of the solutions to be amended, not the description. Just accept any order "
                    },
                    {
                        "username": "noisrucer",
                        "content": "I solved this problem with 60m/s by generating permutations with duplicates and for each permutation result I used stack to check if it\\'s valid parenthesis and now I came here and ppl post simple/mind-blowing solutions that I never expected and A LOT OF people be like \"yeah~nice solution~i thought kinda the same way~\". WTH!!!!!\\n\\nI started algorithm roughly 3 months ago and I\\'ve been studying 12-14 hrs a day til now and solved probably 200 questions so far. I\\'m kinda confident in BFS DFS DP and some general algorithm but totally new to combinatorics. What should I focus more on? I haven\\'t studied Greedy yet. Can you guys recommend me how I study Greedy? cuz its so vague I\\'ve looked up so much\\n\\nBless to y\\'all\\n\\n- Non-smart Asian sophomore kid-"
                    },
                    {
                        "username": "Haseeeb1",
                        "content": "whats your github and linkedin?"
                    },
                    {
                        "username": "baseballCode",
                        "content": "[@blsd-rus](/blsd-rus) I use the neetcode roadmap, ordering is important and since I started doing the questions in order im starting to get better. "
                    },
                    {
                        "username": "blsd-rus",
                        "content": "[@vishesh014](/vishesh014) i\\'ll recommend neetcode"
                    },
                    {
                        "username": "vishesh014",
                        "content": "bro can you tell me the roadmap how you studied algorithms"
                    },
                    {
                        "username": "andy_r_s",
                        "content": "For n = 4 is following one of the valid combinations?\\n(())(())\\n\\nMy code has this but the leetcode says it\\'s not valid. I don\\'t understand why is it invalid?"
                    },
                    {
                        "username": "fffccc",
                        "content": "I also generated this and the test case doesn\\'t generate this one."
                    },
                    {
                        "username": "charonme",
                        "content": "it\\'s valid, but maybe you generated it twice?"
                    },
                    {
                        "username": "chiragrajput245",
                        "content": "Draw the recursive tree and think about the conditions when an opening/closing bracket can be appended\\n\\n         (\\n        / \\\\\\n       ((  ()\\n      / \\\\   |\\n    ((( (() ()(\\n     .   .   .\\n     .   .   .\\n\\n... and so on"
                    },
                    {
                        "username": "JenZ",
                        "content": "Is it 2^n? \\nIs any method better than it ?Thank you."
                    },
                    {
                        "username": "panwu5588",
                        "content": "BAD test cases. The order should not matter.\\nFor example, the following should be the same:\\n[\"(())\",\"()()\"]\\n[\"()()\",\"(())\"]"
                    },
                    {
                        "username": "satta_sunder",
                        "content": "I applied recursion and got 55% faster only. I\\'d love to see if there is any more efficient method."
                    },
                    {
                        "username": "Puja__Singh",
                        "content": "check mine it beats 97%"
                    },
                    {
                        "username": "noob-pika",
                        "content": "The system for calculating time complexity is broken for a solution after a certain number of submissions"
                    }
                ]
            },
            {
                "id": 1568840,
                "content": [
                    {
                        "username": "bonson",
                        "content": "Using different implmentation,the elements will be in different orders. e.g. n = 3.\\nIt can be\\n[\"((()))\",\"(())()\",\"()(())\",\"(()())\",\"()()()\"]\\nwhile the expected answer is\\n[\"((()))\",\"(()())\",\"(())()\",\"()(())\",\"()()()\"]\\n\\nBoth are correct answers. However, the difference of ordering is reckoned as \"wrong answer\". "
                    },
                    {
                        "username": "theashggl",
                        "content": "It accepts all ordering but that should be specified in the question."
                    },
                    {
                        "username": "gmarus",
                        "content": "still does not"
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# \\u26A0\\uFE0FEasiest \\uD83D\\uDE0E FAANG Method Ever !!! \\uD83D\\uDCA5\\nhttps://leetcode.com/problems/generate-parentheses/solutions/3035511/easiest-faang-method-ever/?orderBy=newest_to_oldest"
                    },
                    {
                        "username": "NicholasCG",
                        "content": "January 2023, it accepted different ordered answers for me."
                    },
                    {
                        "username": "barrybecker4",
                        "content": "[@satbekmyrza](/satbekmyrza) Still does not"
                    },
                    {
                        "username": "angelopoulos",
                        "content": "[@4m4nd33p_51ngh](/4m4nd33p_51ngh) I can confirm it still doesn\\'t"
                    },
                    {
                        "username": "4m4nd33p_51ngh",
                        "content": "[@satbekmyrza](/satbekmyrza) no it doesn\\'t"
                    },
                    {
                        "username": "satbekmyrza",
                        "content": "I think it accepts different ordered answers, as of 2022"
                    },
                    {
                        "username": "tejavenkatlanka",
                        "content": "![image](https://assets.leetcode.com/users/images/dabefcea-2a30-4a0a-81c4-b2dafcf9dce0_1599242411.2652733.png)\\nclick for view \\n[https://embed.creately.com/cclS6u7Upy3?type=svg] \\n\\nleft path represent possible one parentheses and right represent possible of right parentheses.\\n\\nleaf node contains answer.\\n\\nhope it will help.\\n\\n"
                    },
                    {
                        "username": "leetnote_io",
                        "content": "Thanks, the pic is very intuitive"
                    },
                    {
                        "username": "dominic89231",
                        "content": "Very helpful!"
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# \\u26A0\\uFE0FEasiest \\uD83D\\uDE0E FAANG Method Ever !!! \\uD83D\\uDCA5\\nhttps://leetcode.com/problems/generate-parentheses/solutions/3035511/easiest-faang-method-ever/?orderBy=newest_to_oldest"
                    },
                    {
                        "username": "drvnprgrmr",
                        "content": "Literally spent about 2hrs on this and came up with a different, more complex (I think) solution that uses recursion. "
                    },
                    {
                        "username": "ChrisMiaoMiao",
                        "content": "Thx, It\\'s very helpful!"
                    },
                    {
                        "username": "aln4739",
                        "content": "very helpful!"
                    },
                    {
                        "username": "KalRadikov",
                        "content": "![image](https://assets.leetcode.com/users/images/40f0296a-7b58-49fb-a72e-e5d8eacf94a4_1604461937.5052783.png)\\n\\nProof:\\n\\n![image](https://assets.leetcode.com/users/images/4bcd2dba-e170-4799-91ae-3e4a1de32731_1605116132.2703443.png)\\n\\n"
                    },
                    {
                        "username": "BREATHTAKER200",
                        "content": "You sneaky bastard!!!!!\\uD83E\\uDD23\\uD83E\\uDD23"
                    },
                    {
                        "username": "alex_malevinsky",
                        "content": "Lots of lines of code, without loops or recursion. Really legend!"
                    },
                    {
                        "username": "Demaxl",
                        "content": "You\\'re hired"
                    },
                    {
                        "username": "codebuster_",
                        "content": "Habibi, this is a dream come true moment"
                    },
                    {
                        "username": "drMystico",
                        "content": "genius guy downright there! "
                    },
                    {
                        "username": "Cripton",
                        "content": "bros dad works at microsoft"
                    },
                    {
                        "username": "RashCode",
                        "content": "Legend\\uD83E\\uDEE1"
                    },
                    {
                        "username": "milespossing",
                        "content": "Strong hire"
                    },
                    {
                        "username": "sunlins",
                        "content": "I was sure of finding this in the comment section"
                    },
                    {
                        "username": "tanmayyyj",
                        "content": "Bro is a hacker"
                    },
                    {
                        "username": "ktranada1403",
                        "content": "bro beat the system..."
                    },
                    {
                        "username": "rsharvesh16",
                        "content": "Bro is from another world!"
                    },
                    {
                        "username": "buzz_shocker",
                        "content": "This is some big brain stuff"
                    },
                    {
                        "username": "Prasanth2021",
                        "content": "[@kzlatt](/kzlatt) \\uD83D\\uDE02\\uD83D\\uDE02\\uD83D\\uDE02"
                    },
                    {
                        "username": "AdilARahman",
                        "content": "Use switch case to go even faster XD"
                    },
                    {
                        "username": "mdmasidulhasan27",
                        "content": "perfect solution for this problem. it\\'s kind a static problem. "
                    },
                    {
                        "username": "Crispy_coffee",
                        "content": "Testcase Oriented Programming \\uD83D\\uDE02"
                    },
                    {
                        "username": "guneetd",
                        "content": "[@ashok0](/ashok0) then you can use Abstract Factory to generate strings :) "
                    },
                    {
                        "username": "kzlatt",
                        "content": "Leetcode :  Choose!!!!  step up or step down\\nKalRadikov:   S.....i......d......e......w......a......y"
                    },
                    {
                        "username": "District_12",
                        "content": "that\\'s what we call to be creative!"
                    },
                    {
                        "username": "a_s_h_o_k",
                        "content": "what if n=100 \\uD83D\\uDE02"
                    },
                    {
                        "username": "aln4739",
                        "content": "chad"
                    },
                    {
                        "username": "leetcodesquad",
                        "content": "No one can beat you since you already had the answer. LOL"
                    },
                    {
                        "username": "undi69",
                        "content": "Dude you are a god"
                    },
                    {
                        "username": "khanuja05",
                        "content": "My solution generates the same set of outputs but the ordering is different. The question should be edited and they should mention that the order matters."
                    },
                    {
                        "username": "Nemo-7777",
                        "content": "It seems that problem author expects a sorted array of strings. So if you struggle with incorrect order, just sort the array and it should work fine."
                    },
                    {
                        "username": "fillipe",
                        "content": "[@krjukov](/krjukov) My solution fails at the test case with 6 pairs. I have verified exactly why now. It is for not generating certain patterns. The system considers your solution correct regardless of the order in which the patterns are saved in your solution."
                    },
                    {
                        "username": "krjukov",
                        "content": "It\\'s senseless to demand preserved order in this type of problems. All the strings are of the same length. It is the validation of the solutions to be amended, not the description. Just accept any order "
                    },
                    {
                        "username": "noisrucer",
                        "content": "I solved this problem with 60m/s by generating permutations with duplicates and for each permutation result I used stack to check if it\\'s valid parenthesis and now I came here and ppl post simple/mind-blowing solutions that I never expected and A LOT OF people be like \"yeah~nice solution~i thought kinda the same way~\". WTH!!!!!\\n\\nI started algorithm roughly 3 months ago and I\\'ve been studying 12-14 hrs a day til now and solved probably 200 questions so far. I\\'m kinda confident in BFS DFS DP and some general algorithm but totally new to combinatorics. What should I focus more on? I haven\\'t studied Greedy yet. Can you guys recommend me how I study Greedy? cuz its so vague I\\'ve looked up so much\\n\\nBless to y\\'all\\n\\n- Non-smart Asian sophomore kid-"
                    },
                    {
                        "username": "Haseeeb1",
                        "content": "whats your github and linkedin?"
                    },
                    {
                        "username": "baseballCode",
                        "content": "[@blsd-rus](/blsd-rus) I use the neetcode roadmap, ordering is important and since I started doing the questions in order im starting to get better. "
                    },
                    {
                        "username": "blsd-rus",
                        "content": "[@vishesh014](/vishesh014) i\\'ll recommend neetcode"
                    },
                    {
                        "username": "vishesh014",
                        "content": "bro can you tell me the roadmap how you studied algorithms"
                    },
                    {
                        "username": "andy_r_s",
                        "content": "For n = 4 is following one of the valid combinations?\\n(())(())\\n\\nMy code has this but the leetcode says it\\'s not valid. I don\\'t understand why is it invalid?"
                    },
                    {
                        "username": "fffccc",
                        "content": "I also generated this and the test case doesn\\'t generate this one."
                    },
                    {
                        "username": "charonme",
                        "content": "it\\'s valid, but maybe you generated it twice?"
                    },
                    {
                        "username": "chiragrajput245",
                        "content": "Draw the recursive tree and think about the conditions when an opening/closing bracket can be appended\\n\\n         (\\n        / \\\\\\n       ((  ()\\n      / \\\\   |\\n    ((( (() ()(\\n     .   .   .\\n     .   .   .\\n\\n... and so on"
                    },
                    {
                        "username": "JenZ",
                        "content": "Is it 2^n? \\nIs any method better than it ?Thank you."
                    },
                    {
                        "username": "panwu5588",
                        "content": "BAD test cases. The order should not matter.\\nFor example, the following should be the same:\\n[\"(())\",\"()()\"]\\n[\"()()\",\"(())\"]"
                    },
                    {
                        "username": "satta_sunder",
                        "content": "I applied recursion and got 55% faster only. I\\'d love to see if there is any more efficient method."
                    },
                    {
                        "username": "Puja__Singh",
                        "content": "check mine it beats 97%"
                    },
                    {
                        "username": "noob-pika",
                        "content": "The system for calculating time complexity is broken for a solution after a certain number of submissions"
                    }
                ]
            },
            {
                "id": 1568013,
                "content": [
                    {
                        "username": "bonson",
                        "content": "Using different implmentation,the elements will be in different orders. e.g. n = 3.\\nIt can be\\n[\"((()))\",\"(())()\",\"()(())\",\"(()())\",\"()()()\"]\\nwhile the expected answer is\\n[\"((()))\",\"(()())\",\"(())()\",\"()(())\",\"()()()\"]\\n\\nBoth are correct answers. However, the difference of ordering is reckoned as \"wrong answer\". "
                    },
                    {
                        "username": "theashggl",
                        "content": "It accepts all ordering but that should be specified in the question."
                    },
                    {
                        "username": "gmarus",
                        "content": "still does not"
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# \\u26A0\\uFE0FEasiest \\uD83D\\uDE0E FAANG Method Ever !!! \\uD83D\\uDCA5\\nhttps://leetcode.com/problems/generate-parentheses/solutions/3035511/easiest-faang-method-ever/?orderBy=newest_to_oldest"
                    },
                    {
                        "username": "NicholasCG",
                        "content": "January 2023, it accepted different ordered answers for me."
                    },
                    {
                        "username": "barrybecker4",
                        "content": "[@satbekmyrza](/satbekmyrza) Still does not"
                    },
                    {
                        "username": "angelopoulos",
                        "content": "[@4m4nd33p_51ngh](/4m4nd33p_51ngh) I can confirm it still doesn\\'t"
                    },
                    {
                        "username": "4m4nd33p_51ngh",
                        "content": "[@satbekmyrza](/satbekmyrza) no it doesn\\'t"
                    },
                    {
                        "username": "satbekmyrza",
                        "content": "I think it accepts different ordered answers, as of 2022"
                    },
                    {
                        "username": "tejavenkatlanka",
                        "content": "![image](https://assets.leetcode.com/users/images/dabefcea-2a30-4a0a-81c4-b2dafcf9dce0_1599242411.2652733.png)\\nclick for view \\n[https://embed.creately.com/cclS6u7Upy3?type=svg] \\n\\nleft path represent possible one parentheses and right represent possible of right parentheses.\\n\\nleaf node contains answer.\\n\\nhope it will help.\\n\\n"
                    },
                    {
                        "username": "leetnote_io",
                        "content": "Thanks, the pic is very intuitive"
                    },
                    {
                        "username": "dominic89231",
                        "content": "Very helpful!"
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# \\u26A0\\uFE0FEasiest \\uD83D\\uDE0E FAANG Method Ever !!! \\uD83D\\uDCA5\\nhttps://leetcode.com/problems/generate-parentheses/solutions/3035511/easiest-faang-method-ever/?orderBy=newest_to_oldest"
                    },
                    {
                        "username": "drvnprgrmr",
                        "content": "Literally spent about 2hrs on this and came up with a different, more complex (I think) solution that uses recursion. "
                    },
                    {
                        "username": "ChrisMiaoMiao",
                        "content": "Thx, It\\'s very helpful!"
                    },
                    {
                        "username": "aln4739",
                        "content": "very helpful!"
                    },
                    {
                        "username": "KalRadikov",
                        "content": "![image](https://assets.leetcode.com/users/images/40f0296a-7b58-49fb-a72e-e5d8eacf94a4_1604461937.5052783.png)\\n\\nProof:\\n\\n![image](https://assets.leetcode.com/users/images/4bcd2dba-e170-4799-91ae-3e4a1de32731_1605116132.2703443.png)\\n\\n"
                    },
                    {
                        "username": "BREATHTAKER200",
                        "content": "You sneaky bastard!!!!!\\uD83E\\uDD23\\uD83E\\uDD23"
                    },
                    {
                        "username": "alex_malevinsky",
                        "content": "Lots of lines of code, without loops or recursion. Really legend!"
                    },
                    {
                        "username": "Demaxl",
                        "content": "You\\'re hired"
                    },
                    {
                        "username": "codebuster_",
                        "content": "Habibi, this is a dream come true moment"
                    },
                    {
                        "username": "drMystico",
                        "content": "genius guy downright there! "
                    },
                    {
                        "username": "Cripton",
                        "content": "bros dad works at microsoft"
                    },
                    {
                        "username": "RashCode",
                        "content": "Legend\\uD83E\\uDEE1"
                    },
                    {
                        "username": "milespossing",
                        "content": "Strong hire"
                    },
                    {
                        "username": "sunlins",
                        "content": "I was sure of finding this in the comment section"
                    },
                    {
                        "username": "tanmayyyj",
                        "content": "Bro is a hacker"
                    },
                    {
                        "username": "ktranada1403",
                        "content": "bro beat the system..."
                    },
                    {
                        "username": "rsharvesh16",
                        "content": "Bro is from another world!"
                    },
                    {
                        "username": "buzz_shocker",
                        "content": "This is some big brain stuff"
                    },
                    {
                        "username": "Prasanth2021",
                        "content": "[@kzlatt](/kzlatt) \\uD83D\\uDE02\\uD83D\\uDE02\\uD83D\\uDE02"
                    },
                    {
                        "username": "AdilARahman",
                        "content": "Use switch case to go even faster XD"
                    },
                    {
                        "username": "mdmasidulhasan27",
                        "content": "perfect solution for this problem. it\\'s kind a static problem. "
                    },
                    {
                        "username": "Crispy_coffee",
                        "content": "Testcase Oriented Programming \\uD83D\\uDE02"
                    },
                    {
                        "username": "guneetd",
                        "content": "[@ashok0](/ashok0) then you can use Abstract Factory to generate strings :) "
                    },
                    {
                        "username": "kzlatt",
                        "content": "Leetcode :  Choose!!!!  step up or step down\\nKalRadikov:   S.....i......d......e......w......a......y"
                    },
                    {
                        "username": "District_12",
                        "content": "that\\'s what we call to be creative!"
                    },
                    {
                        "username": "a_s_h_o_k",
                        "content": "what if n=100 \\uD83D\\uDE02"
                    },
                    {
                        "username": "aln4739",
                        "content": "chad"
                    },
                    {
                        "username": "leetcodesquad",
                        "content": "No one can beat you since you already had the answer. LOL"
                    },
                    {
                        "username": "undi69",
                        "content": "Dude you are a god"
                    },
                    {
                        "username": "khanuja05",
                        "content": "My solution generates the same set of outputs but the ordering is different. The question should be edited and they should mention that the order matters."
                    },
                    {
                        "username": "Nemo-7777",
                        "content": "It seems that problem author expects a sorted array of strings. So if you struggle with incorrect order, just sort the array and it should work fine."
                    },
                    {
                        "username": "fillipe",
                        "content": "[@krjukov](/krjukov) My solution fails at the test case with 6 pairs. I have verified exactly why now. It is for not generating certain patterns. The system considers your solution correct regardless of the order in which the patterns are saved in your solution."
                    },
                    {
                        "username": "krjukov",
                        "content": "It\\'s senseless to demand preserved order in this type of problems. All the strings are of the same length. It is the validation of the solutions to be amended, not the description. Just accept any order "
                    },
                    {
                        "username": "noisrucer",
                        "content": "I solved this problem with 60m/s by generating permutations with duplicates and for each permutation result I used stack to check if it\\'s valid parenthesis and now I came here and ppl post simple/mind-blowing solutions that I never expected and A LOT OF people be like \"yeah~nice solution~i thought kinda the same way~\". WTH!!!!!\\n\\nI started algorithm roughly 3 months ago and I\\'ve been studying 12-14 hrs a day til now and solved probably 200 questions so far. I\\'m kinda confident in BFS DFS DP and some general algorithm but totally new to combinatorics. What should I focus more on? I haven\\'t studied Greedy yet. Can you guys recommend me how I study Greedy? cuz its so vague I\\'ve looked up so much\\n\\nBless to y\\'all\\n\\n- Non-smart Asian sophomore kid-"
                    },
                    {
                        "username": "Haseeeb1",
                        "content": "whats your github and linkedin?"
                    },
                    {
                        "username": "baseballCode",
                        "content": "[@blsd-rus](/blsd-rus) I use the neetcode roadmap, ordering is important and since I started doing the questions in order im starting to get better. "
                    },
                    {
                        "username": "blsd-rus",
                        "content": "[@vishesh014](/vishesh014) i\\'ll recommend neetcode"
                    },
                    {
                        "username": "vishesh014",
                        "content": "bro can you tell me the roadmap how you studied algorithms"
                    },
                    {
                        "username": "andy_r_s",
                        "content": "For n = 4 is following one of the valid combinations?\\n(())(())\\n\\nMy code has this but the leetcode says it\\'s not valid. I don\\'t understand why is it invalid?"
                    },
                    {
                        "username": "fffccc",
                        "content": "I also generated this and the test case doesn\\'t generate this one."
                    },
                    {
                        "username": "charonme",
                        "content": "it\\'s valid, but maybe you generated it twice?"
                    },
                    {
                        "username": "chiragrajput245",
                        "content": "Draw the recursive tree and think about the conditions when an opening/closing bracket can be appended\\n\\n         (\\n        / \\\\\\n       ((  ()\\n      / \\\\   |\\n    ((( (() ()(\\n     .   .   .\\n     .   .   .\\n\\n... and so on"
                    },
                    {
                        "username": "JenZ",
                        "content": "Is it 2^n? \\nIs any method better than it ?Thank you."
                    },
                    {
                        "username": "panwu5588",
                        "content": "BAD test cases. The order should not matter.\\nFor example, the following should be the same:\\n[\"(())\",\"()()\"]\\n[\"()()\",\"(())\"]"
                    },
                    {
                        "username": "satta_sunder",
                        "content": "I applied recursion and got 55% faster only. I\\'d love to see if there is any more efficient method."
                    },
                    {
                        "username": "Puja__Singh",
                        "content": "check mine it beats 97%"
                    },
                    {
                        "username": "noob-pika",
                        "content": "The system for calculating time complexity is broken for a solution after a certain number of submissions"
                    }
                ]
            },
            {
                "id": 1575229,
                "content": [
                    {
                        "username": "bonson",
                        "content": "Using different implmentation,the elements will be in different orders. e.g. n = 3.\\nIt can be\\n[\"((()))\",\"(())()\",\"()(())\",\"(()())\",\"()()()\"]\\nwhile the expected answer is\\n[\"((()))\",\"(()())\",\"(())()\",\"()(())\",\"()()()\"]\\n\\nBoth are correct answers. However, the difference of ordering is reckoned as \"wrong answer\". "
                    },
                    {
                        "username": "theashggl",
                        "content": "It accepts all ordering but that should be specified in the question."
                    },
                    {
                        "username": "gmarus",
                        "content": "still does not"
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# \\u26A0\\uFE0FEasiest \\uD83D\\uDE0E FAANG Method Ever !!! \\uD83D\\uDCA5\\nhttps://leetcode.com/problems/generate-parentheses/solutions/3035511/easiest-faang-method-ever/?orderBy=newest_to_oldest"
                    },
                    {
                        "username": "NicholasCG",
                        "content": "January 2023, it accepted different ordered answers for me."
                    },
                    {
                        "username": "barrybecker4",
                        "content": "[@satbekmyrza](/satbekmyrza) Still does not"
                    },
                    {
                        "username": "angelopoulos",
                        "content": "[@4m4nd33p_51ngh](/4m4nd33p_51ngh) I can confirm it still doesn\\'t"
                    },
                    {
                        "username": "4m4nd33p_51ngh",
                        "content": "[@satbekmyrza](/satbekmyrza) no it doesn\\'t"
                    },
                    {
                        "username": "satbekmyrza",
                        "content": "I think it accepts different ordered answers, as of 2022"
                    },
                    {
                        "username": "tejavenkatlanka",
                        "content": "![image](https://assets.leetcode.com/users/images/dabefcea-2a30-4a0a-81c4-b2dafcf9dce0_1599242411.2652733.png)\\nclick for view \\n[https://embed.creately.com/cclS6u7Upy3?type=svg] \\n\\nleft path represent possible one parentheses and right represent possible of right parentheses.\\n\\nleaf node contains answer.\\n\\nhope it will help.\\n\\n"
                    },
                    {
                        "username": "leetnote_io",
                        "content": "Thanks, the pic is very intuitive"
                    },
                    {
                        "username": "dominic89231",
                        "content": "Very helpful!"
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# \\u26A0\\uFE0FEasiest \\uD83D\\uDE0E FAANG Method Ever !!! \\uD83D\\uDCA5\\nhttps://leetcode.com/problems/generate-parentheses/solutions/3035511/easiest-faang-method-ever/?orderBy=newest_to_oldest"
                    },
                    {
                        "username": "drvnprgrmr",
                        "content": "Literally spent about 2hrs on this and came up with a different, more complex (I think) solution that uses recursion. "
                    },
                    {
                        "username": "ChrisMiaoMiao",
                        "content": "Thx, It\\'s very helpful!"
                    },
                    {
                        "username": "aln4739",
                        "content": "very helpful!"
                    },
                    {
                        "username": "KalRadikov",
                        "content": "![image](https://assets.leetcode.com/users/images/40f0296a-7b58-49fb-a72e-e5d8eacf94a4_1604461937.5052783.png)\\n\\nProof:\\n\\n![image](https://assets.leetcode.com/users/images/4bcd2dba-e170-4799-91ae-3e4a1de32731_1605116132.2703443.png)\\n\\n"
                    },
                    {
                        "username": "BREATHTAKER200",
                        "content": "You sneaky bastard!!!!!\\uD83E\\uDD23\\uD83E\\uDD23"
                    },
                    {
                        "username": "alex_malevinsky",
                        "content": "Lots of lines of code, without loops or recursion. Really legend!"
                    },
                    {
                        "username": "Demaxl",
                        "content": "You\\'re hired"
                    },
                    {
                        "username": "codebuster_",
                        "content": "Habibi, this is a dream come true moment"
                    },
                    {
                        "username": "drMystico",
                        "content": "genius guy downright there! "
                    },
                    {
                        "username": "Cripton",
                        "content": "bros dad works at microsoft"
                    },
                    {
                        "username": "RashCode",
                        "content": "Legend\\uD83E\\uDEE1"
                    },
                    {
                        "username": "milespossing",
                        "content": "Strong hire"
                    },
                    {
                        "username": "sunlins",
                        "content": "I was sure of finding this in the comment section"
                    },
                    {
                        "username": "tanmayyyj",
                        "content": "Bro is a hacker"
                    },
                    {
                        "username": "ktranada1403",
                        "content": "bro beat the system..."
                    },
                    {
                        "username": "rsharvesh16",
                        "content": "Bro is from another world!"
                    },
                    {
                        "username": "buzz_shocker",
                        "content": "This is some big brain stuff"
                    },
                    {
                        "username": "Prasanth2021",
                        "content": "[@kzlatt](/kzlatt) \\uD83D\\uDE02\\uD83D\\uDE02\\uD83D\\uDE02"
                    },
                    {
                        "username": "AdilARahman",
                        "content": "Use switch case to go even faster XD"
                    },
                    {
                        "username": "mdmasidulhasan27",
                        "content": "perfect solution for this problem. it\\'s kind a static problem. "
                    },
                    {
                        "username": "Crispy_coffee",
                        "content": "Testcase Oriented Programming \\uD83D\\uDE02"
                    },
                    {
                        "username": "guneetd",
                        "content": "[@ashok0](/ashok0) then you can use Abstract Factory to generate strings :) "
                    },
                    {
                        "username": "kzlatt",
                        "content": "Leetcode :  Choose!!!!  step up or step down\\nKalRadikov:   S.....i......d......e......w......a......y"
                    },
                    {
                        "username": "District_12",
                        "content": "that\\'s what we call to be creative!"
                    },
                    {
                        "username": "a_s_h_o_k",
                        "content": "what if n=100 \\uD83D\\uDE02"
                    },
                    {
                        "username": "aln4739",
                        "content": "chad"
                    },
                    {
                        "username": "leetcodesquad",
                        "content": "No one can beat you since you already had the answer. LOL"
                    },
                    {
                        "username": "undi69",
                        "content": "Dude you are a god"
                    },
                    {
                        "username": "khanuja05",
                        "content": "My solution generates the same set of outputs but the ordering is different. The question should be edited and they should mention that the order matters."
                    },
                    {
                        "username": "Nemo-7777",
                        "content": "It seems that problem author expects a sorted array of strings. So if you struggle with incorrect order, just sort the array and it should work fine."
                    },
                    {
                        "username": "fillipe",
                        "content": "[@krjukov](/krjukov) My solution fails at the test case with 6 pairs. I have verified exactly why now. It is for not generating certain patterns. The system considers your solution correct regardless of the order in which the patterns are saved in your solution."
                    },
                    {
                        "username": "krjukov",
                        "content": "It\\'s senseless to demand preserved order in this type of problems. All the strings are of the same length. It is the validation of the solutions to be amended, not the description. Just accept any order "
                    },
                    {
                        "username": "noisrucer",
                        "content": "I solved this problem with 60m/s by generating permutations with duplicates and for each permutation result I used stack to check if it\\'s valid parenthesis and now I came here and ppl post simple/mind-blowing solutions that I never expected and A LOT OF people be like \"yeah~nice solution~i thought kinda the same way~\". WTH!!!!!\\n\\nI started algorithm roughly 3 months ago and I\\'ve been studying 12-14 hrs a day til now and solved probably 200 questions so far. I\\'m kinda confident in BFS DFS DP and some general algorithm but totally new to combinatorics. What should I focus more on? I haven\\'t studied Greedy yet. Can you guys recommend me how I study Greedy? cuz its so vague I\\'ve looked up so much\\n\\nBless to y\\'all\\n\\n- Non-smart Asian sophomore kid-"
                    },
                    {
                        "username": "Haseeeb1",
                        "content": "whats your github and linkedin?"
                    },
                    {
                        "username": "baseballCode",
                        "content": "[@blsd-rus](/blsd-rus) I use the neetcode roadmap, ordering is important and since I started doing the questions in order im starting to get better. "
                    },
                    {
                        "username": "blsd-rus",
                        "content": "[@vishesh014](/vishesh014) i\\'ll recommend neetcode"
                    },
                    {
                        "username": "vishesh014",
                        "content": "bro can you tell me the roadmap how you studied algorithms"
                    },
                    {
                        "username": "andy_r_s",
                        "content": "For n = 4 is following one of the valid combinations?\\n(())(())\\n\\nMy code has this but the leetcode says it\\'s not valid. I don\\'t understand why is it invalid?"
                    },
                    {
                        "username": "fffccc",
                        "content": "I also generated this and the test case doesn\\'t generate this one."
                    },
                    {
                        "username": "charonme",
                        "content": "it\\'s valid, but maybe you generated it twice?"
                    },
                    {
                        "username": "chiragrajput245",
                        "content": "Draw the recursive tree and think about the conditions when an opening/closing bracket can be appended\\n\\n         (\\n        / \\\\\\n       ((  ()\\n      / \\\\   |\\n    ((( (() ()(\\n     .   .   .\\n     .   .   .\\n\\n... and so on"
                    },
                    {
                        "username": "JenZ",
                        "content": "Is it 2^n? \\nIs any method better than it ?Thank you."
                    },
                    {
                        "username": "panwu5588",
                        "content": "BAD test cases. The order should not matter.\\nFor example, the following should be the same:\\n[\"(())\",\"()()\"]\\n[\"()()\",\"(())\"]"
                    },
                    {
                        "username": "satta_sunder",
                        "content": "I applied recursion and got 55% faster only. I\\'d love to see if there is any more efficient method."
                    },
                    {
                        "username": "Puja__Singh",
                        "content": "check mine it beats 97%"
                    },
                    {
                        "username": "noob-pika",
                        "content": "The system for calculating time complexity is broken for a solution after a certain number of submissions"
                    }
                ]
            },
            {
                "id": 1564779,
                "content": [
                    {
                        "username": "bonson",
                        "content": "Using different implmentation,the elements will be in different orders. e.g. n = 3.\\nIt can be\\n[\"((()))\",\"(())()\",\"()(())\",\"(()())\",\"()()()\"]\\nwhile the expected answer is\\n[\"((()))\",\"(()())\",\"(())()\",\"()(())\",\"()()()\"]\\n\\nBoth are correct answers. However, the difference of ordering is reckoned as \"wrong answer\". "
                    },
                    {
                        "username": "theashggl",
                        "content": "It accepts all ordering but that should be specified in the question."
                    },
                    {
                        "username": "gmarus",
                        "content": "still does not"
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# \\u26A0\\uFE0FEasiest \\uD83D\\uDE0E FAANG Method Ever !!! \\uD83D\\uDCA5\\nhttps://leetcode.com/problems/generate-parentheses/solutions/3035511/easiest-faang-method-ever/?orderBy=newest_to_oldest"
                    },
                    {
                        "username": "NicholasCG",
                        "content": "January 2023, it accepted different ordered answers for me."
                    },
                    {
                        "username": "barrybecker4",
                        "content": "[@satbekmyrza](/satbekmyrza) Still does not"
                    },
                    {
                        "username": "angelopoulos",
                        "content": "[@4m4nd33p_51ngh](/4m4nd33p_51ngh) I can confirm it still doesn\\'t"
                    },
                    {
                        "username": "4m4nd33p_51ngh",
                        "content": "[@satbekmyrza](/satbekmyrza) no it doesn\\'t"
                    },
                    {
                        "username": "satbekmyrza",
                        "content": "I think it accepts different ordered answers, as of 2022"
                    },
                    {
                        "username": "tejavenkatlanka",
                        "content": "![image](https://assets.leetcode.com/users/images/dabefcea-2a30-4a0a-81c4-b2dafcf9dce0_1599242411.2652733.png)\\nclick for view \\n[https://embed.creately.com/cclS6u7Upy3?type=svg] \\n\\nleft path represent possible one parentheses and right represent possible of right parentheses.\\n\\nleaf node contains answer.\\n\\nhope it will help.\\n\\n"
                    },
                    {
                        "username": "leetnote_io",
                        "content": "Thanks, the pic is very intuitive"
                    },
                    {
                        "username": "dominic89231",
                        "content": "Very helpful!"
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# \\u26A0\\uFE0FEasiest \\uD83D\\uDE0E FAANG Method Ever !!! \\uD83D\\uDCA5\\nhttps://leetcode.com/problems/generate-parentheses/solutions/3035511/easiest-faang-method-ever/?orderBy=newest_to_oldest"
                    },
                    {
                        "username": "drvnprgrmr",
                        "content": "Literally spent about 2hrs on this and came up with a different, more complex (I think) solution that uses recursion. "
                    },
                    {
                        "username": "ChrisMiaoMiao",
                        "content": "Thx, It\\'s very helpful!"
                    },
                    {
                        "username": "aln4739",
                        "content": "very helpful!"
                    },
                    {
                        "username": "KalRadikov",
                        "content": "![image](https://assets.leetcode.com/users/images/40f0296a-7b58-49fb-a72e-e5d8eacf94a4_1604461937.5052783.png)\\n\\nProof:\\n\\n![image](https://assets.leetcode.com/users/images/4bcd2dba-e170-4799-91ae-3e4a1de32731_1605116132.2703443.png)\\n\\n"
                    },
                    {
                        "username": "BREATHTAKER200",
                        "content": "You sneaky bastard!!!!!\\uD83E\\uDD23\\uD83E\\uDD23"
                    },
                    {
                        "username": "alex_malevinsky",
                        "content": "Lots of lines of code, without loops or recursion. Really legend!"
                    },
                    {
                        "username": "Demaxl",
                        "content": "You\\'re hired"
                    },
                    {
                        "username": "codebuster_",
                        "content": "Habibi, this is a dream come true moment"
                    },
                    {
                        "username": "drMystico",
                        "content": "genius guy downright there! "
                    },
                    {
                        "username": "Cripton",
                        "content": "bros dad works at microsoft"
                    },
                    {
                        "username": "RashCode",
                        "content": "Legend\\uD83E\\uDEE1"
                    },
                    {
                        "username": "milespossing",
                        "content": "Strong hire"
                    },
                    {
                        "username": "sunlins",
                        "content": "I was sure of finding this in the comment section"
                    },
                    {
                        "username": "tanmayyyj",
                        "content": "Bro is a hacker"
                    },
                    {
                        "username": "ktranada1403",
                        "content": "bro beat the system..."
                    },
                    {
                        "username": "rsharvesh16",
                        "content": "Bro is from another world!"
                    },
                    {
                        "username": "buzz_shocker",
                        "content": "This is some big brain stuff"
                    },
                    {
                        "username": "Prasanth2021",
                        "content": "[@kzlatt](/kzlatt) \\uD83D\\uDE02\\uD83D\\uDE02\\uD83D\\uDE02"
                    },
                    {
                        "username": "AdilARahman",
                        "content": "Use switch case to go even faster XD"
                    },
                    {
                        "username": "mdmasidulhasan27",
                        "content": "perfect solution for this problem. it\\'s kind a static problem. "
                    },
                    {
                        "username": "Crispy_coffee",
                        "content": "Testcase Oriented Programming \\uD83D\\uDE02"
                    },
                    {
                        "username": "guneetd",
                        "content": "[@ashok0](/ashok0) then you can use Abstract Factory to generate strings :) "
                    },
                    {
                        "username": "kzlatt",
                        "content": "Leetcode :  Choose!!!!  step up or step down\\nKalRadikov:   S.....i......d......e......w......a......y"
                    },
                    {
                        "username": "District_12",
                        "content": "that\\'s what we call to be creative!"
                    },
                    {
                        "username": "a_s_h_o_k",
                        "content": "what if n=100 \\uD83D\\uDE02"
                    },
                    {
                        "username": "aln4739",
                        "content": "chad"
                    },
                    {
                        "username": "leetcodesquad",
                        "content": "No one can beat you since you already had the answer. LOL"
                    },
                    {
                        "username": "undi69",
                        "content": "Dude you are a god"
                    },
                    {
                        "username": "khanuja05",
                        "content": "My solution generates the same set of outputs but the ordering is different. The question should be edited and they should mention that the order matters."
                    },
                    {
                        "username": "Nemo-7777",
                        "content": "It seems that problem author expects a sorted array of strings. So if you struggle with incorrect order, just sort the array and it should work fine."
                    },
                    {
                        "username": "fillipe",
                        "content": "[@krjukov](/krjukov) My solution fails at the test case with 6 pairs. I have verified exactly why now. It is for not generating certain patterns. The system considers your solution correct regardless of the order in which the patterns are saved in your solution."
                    },
                    {
                        "username": "krjukov",
                        "content": "It\\'s senseless to demand preserved order in this type of problems. All the strings are of the same length. It is the validation of the solutions to be amended, not the description. Just accept any order "
                    },
                    {
                        "username": "noisrucer",
                        "content": "I solved this problem with 60m/s by generating permutations with duplicates and for each permutation result I used stack to check if it\\'s valid parenthesis and now I came here and ppl post simple/mind-blowing solutions that I never expected and A LOT OF people be like \"yeah~nice solution~i thought kinda the same way~\". WTH!!!!!\\n\\nI started algorithm roughly 3 months ago and I\\'ve been studying 12-14 hrs a day til now and solved probably 200 questions so far. I\\'m kinda confident in BFS DFS DP and some general algorithm but totally new to combinatorics. What should I focus more on? I haven\\'t studied Greedy yet. Can you guys recommend me how I study Greedy? cuz its so vague I\\'ve looked up so much\\n\\nBless to y\\'all\\n\\n- Non-smart Asian sophomore kid-"
                    },
                    {
                        "username": "Haseeeb1",
                        "content": "whats your github and linkedin?"
                    },
                    {
                        "username": "baseballCode",
                        "content": "[@blsd-rus](/blsd-rus) I use the neetcode roadmap, ordering is important and since I started doing the questions in order im starting to get better. "
                    },
                    {
                        "username": "blsd-rus",
                        "content": "[@vishesh014](/vishesh014) i\\'ll recommend neetcode"
                    },
                    {
                        "username": "vishesh014",
                        "content": "bro can you tell me the roadmap how you studied algorithms"
                    },
                    {
                        "username": "andy_r_s",
                        "content": "For n = 4 is following one of the valid combinations?\\n(())(())\\n\\nMy code has this but the leetcode says it\\'s not valid. I don\\'t understand why is it invalid?"
                    },
                    {
                        "username": "fffccc",
                        "content": "I also generated this and the test case doesn\\'t generate this one."
                    },
                    {
                        "username": "charonme",
                        "content": "it\\'s valid, but maybe you generated it twice?"
                    },
                    {
                        "username": "chiragrajput245",
                        "content": "Draw the recursive tree and think about the conditions when an opening/closing bracket can be appended\\n\\n         (\\n        / \\\\\\n       ((  ()\\n      / \\\\   |\\n    ((( (() ()(\\n     .   .   .\\n     .   .   .\\n\\n... and so on"
                    },
                    {
                        "username": "JenZ",
                        "content": "Is it 2^n? \\nIs any method better than it ?Thank you."
                    },
                    {
                        "username": "panwu5588",
                        "content": "BAD test cases. The order should not matter.\\nFor example, the following should be the same:\\n[\"(())\",\"()()\"]\\n[\"()()\",\"(())\"]"
                    },
                    {
                        "username": "satta_sunder",
                        "content": "I applied recursion and got 55% faster only. I\\'d love to see if there is any more efficient method."
                    },
                    {
                        "username": "Puja__Singh",
                        "content": "check mine it beats 97%"
                    },
                    {
                        "username": "noob-pika",
                        "content": "The system for calculating time complexity is broken for a solution after a certain number of submissions"
                    }
                ]
            },
            {
                "id": 1574327,
                "content": [
                    {
                        "username": "bonson",
                        "content": "Using different implmentation,the elements will be in different orders. e.g. n = 3.\\nIt can be\\n[\"((()))\",\"(())()\",\"()(())\",\"(()())\",\"()()()\"]\\nwhile the expected answer is\\n[\"((()))\",\"(()())\",\"(())()\",\"()(())\",\"()()()\"]\\n\\nBoth are correct answers. However, the difference of ordering is reckoned as \"wrong answer\". "
                    },
                    {
                        "username": "theashggl",
                        "content": "It accepts all ordering but that should be specified in the question."
                    },
                    {
                        "username": "gmarus",
                        "content": "still does not"
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# \\u26A0\\uFE0FEasiest \\uD83D\\uDE0E FAANG Method Ever !!! \\uD83D\\uDCA5\\nhttps://leetcode.com/problems/generate-parentheses/solutions/3035511/easiest-faang-method-ever/?orderBy=newest_to_oldest"
                    },
                    {
                        "username": "NicholasCG",
                        "content": "January 2023, it accepted different ordered answers for me."
                    },
                    {
                        "username": "barrybecker4",
                        "content": "[@satbekmyrza](/satbekmyrza) Still does not"
                    },
                    {
                        "username": "angelopoulos",
                        "content": "[@4m4nd33p_51ngh](/4m4nd33p_51ngh) I can confirm it still doesn\\'t"
                    },
                    {
                        "username": "4m4nd33p_51ngh",
                        "content": "[@satbekmyrza](/satbekmyrza) no it doesn\\'t"
                    },
                    {
                        "username": "satbekmyrza",
                        "content": "I think it accepts different ordered answers, as of 2022"
                    },
                    {
                        "username": "tejavenkatlanka",
                        "content": "![image](https://assets.leetcode.com/users/images/dabefcea-2a30-4a0a-81c4-b2dafcf9dce0_1599242411.2652733.png)\\nclick for view \\n[https://embed.creately.com/cclS6u7Upy3?type=svg] \\n\\nleft path represent possible one parentheses and right represent possible of right parentheses.\\n\\nleaf node contains answer.\\n\\nhope it will help.\\n\\n"
                    },
                    {
                        "username": "leetnote_io",
                        "content": "Thanks, the pic is very intuitive"
                    },
                    {
                        "username": "dominic89231",
                        "content": "Very helpful!"
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# \\u26A0\\uFE0FEasiest \\uD83D\\uDE0E FAANG Method Ever !!! \\uD83D\\uDCA5\\nhttps://leetcode.com/problems/generate-parentheses/solutions/3035511/easiest-faang-method-ever/?orderBy=newest_to_oldest"
                    },
                    {
                        "username": "drvnprgrmr",
                        "content": "Literally spent about 2hrs on this and came up with a different, more complex (I think) solution that uses recursion. "
                    },
                    {
                        "username": "ChrisMiaoMiao",
                        "content": "Thx, It\\'s very helpful!"
                    },
                    {
                        "username": "aln4739",
                        "content": "very helpful!"
                    },
                    {
                        "username": "KalRadikov",
                        "content": "![image](https://assets.leetcode.com/users/images/40f0296a-7b58-49fb-a72e-e5d8eacf94a4_1604461937.5052783.png)\\n\\nProof:\\n\\n![image](https://assets.leetcode.com/users/images/4bcd2dba-e170-4799-91ae-3e4a1de32731_1605116132.2703443.png)\\n\\n"
                    },
                    {
                        "username": "BREATHTAKER200",
                        "content": "You sneaky bastard!!!!!\\uD83E\\uDD23\\uD83E\\uDD23"
                    },
                    {
                        "username": "alex_malevinsky",
                        "content": "Lots of lines of code, without loops or recursion. Really legend!"
                    },
                    {
                        "username": "Demaxl",
                        "content": "You\\'re hired"
                    },
                    {
                        "username": "codebuster_",
                        "content": "Habibi, this is a dream come true moment"
                    },
                    {
                        "username": "drMystico",
                        "content": "genius guy downright there! "
                    },
                    {
                        "username": "Cripton",
                        "content": "bros dad works at microsoft"
                    },
                    {
                        "username": "RashCode",
                        "content": "Legend\\uD83E\\uDEE1"
                    },
                    {
                        "username": "milespossing",
                        "content": "Strong hire"
                    },
                    {
                        "username": "sunlins",
                        "content": "I was sure of finding this in the comment section"
                    },
                    {
                        "username": "tanmayyyj",
                        "content": "Bro is a hacker"
                    },
                    {
                        "username": "ktranada1403",
                        "content": "bro beat the system..."
                    },
                    {
                        "username": "rsharvesh16",
                        "content": "Bro is from another world!"
                    },
                    {
                        "username": "buzz_shocker",
                        "content": "This is some big brain stuff"
                    },
                    {
                        "username": "Prasanth2021",
                        "content": "[@kzlatt](/kzlatt) \\uD83D\\uDE02\\uD83D\\uDE02\\uD83D\\uDE02"
                    },
                    {
                        "username": "AdilARahman",
                        "content": "Use switch case to go even faster XD"
                    },
                    {
                        "username": "mdmasidulhasan27",
                        "content": "perfect solution for this problem. it\\'s kind a static problem. "
                    },
                    {
                        "username": "Crispy_coffee",
                        "content": "Testcase Oriented Programming \\uD83D\\uDE02"
                    },
                    {
                        "username": "guneetd",
                        "content": "[@ashok0](/ashok0) then you can use Abstract Factory to generate strings :) "
                    },
                    {
                        "username": "kzlatt",
                        "content": "Leetcode :  Choose!!!!  step up or step down\\nKalRadikov:   S.....i......d......e......w......a......y"
                    },
                    {
                        "username": "District_12",
                        "content": "that\\'s what we call to be creative!"
                    },
                    {
                        "username": "a_s_h_o_k",
                        "content": "what if n=100 \\uD83D\\uDE02"
                    },
                    {
                        "username": "aln4739",
                        "content": "chad"
                    },
                    {
                        "username": "leetcodesquad",
                        "content": "No one can beat you since you already had the answer. LOL"
                    },
                    {
                        "username": "undi69",
                        "content": "Dude you are a god"
                    },
                    {
                        "username": "khanuja05",
                        "content": "My solution generates the same set of outputs but the ordering is different. The question should be edited and they should mention that the order matters."
                    },
                    {
                        "username": "Nemo-7777",
                        "content": "It seems that problem author expects a sorted array of strings. So if you struggle with incorrect order, just sort the array and it should work fine."
                    },
                    {
                        "username": "fillipe",
                        "content": "[@krjukov](/krjukov) My solution fails at the test case with 6 pairs. I have verified exactly why now. It is for not generating certain patterns. The system considers your solution correct regardless of the order in which the patterns are saved in your solution."
                    },
                    {
                        "username": "krjukov",
                        "content": "It\\'s senseless to demand preserved order in this type of problems. All the strings are of the same length. It is the validation of the solutions to be amended, not the description. Just accept any order "
                    },
                    {
                        "username": "noisrucer",
                        "content": "I solved this problem with 60m/s by generating permutations with duplicates and for each permutation result I used stack to check if it\\'s valid parenthesis and now I came here and ppl post simple/mind-blowing solutions that I never expected and A LOT OF people be like \"yeah~nice solution~i thought kinda the same way~\". WTH!!!!!\\n\\nI started algorithm roughly 3 months ago and I\\'ve been studying 12-14 hrs a day til now and solved probably 200 questions so far. I\\'m kinda confident in BFS DFS DP and some general algorithm but totally new to combinatorics. What should I focus more on? I haven\\'t studied Greedy yet. Can you guys recommend me how I study Greedy? cuz its so vague I\\'ve looked up so much\\n\\nBless to y\\'all\\n\\n- Non-smart Asian sophomore kid-"
                    },
                    {
                        "username": "Haseeeb1",
                        "content": "whats your github and linkedin?"
                    },
                    {
                        "username": "baseballCode",
                        "content": "[@blsd-rus](/blsd-rus) I use the neetcode roadmap, ordering is important and since I started doing the questions in order im starting to get better. "
                    },
                    {
                        "username": "blsd-rus",
                        "content": "[@vishesh014](/vishesh014) i\\'ll recommend neetcode"
                    },
                    {
                        "username": "vishesh014",
                        "content": "bro can you tell me the roadmap how you studied algorithms"
                    },
                    {
                        "username": "andy_r_s",
                        "content": "For n = 4 is following one of the valid combinations?\\n(())(())\\n\\nMy code has this but the leetcode says it\\'s not valid. I don\\'t understand why is it invalid?"
                    },
                    {
                        "username": "fffccc",
                        "content": "I also generated this and the test case doesn\\'t generate this one."
                    },
                    {
                        "username": "charonme",
                        "content": "it\\'s valid, but maybe you generated it twice?"
                    },
                    {
                        "username": "chiragrajput245",
                        "content": "Draw the recursive tree and think about the conditions when an opening/closing bracket can be appended\\n\\n         (\\n        / \\\\\\n       ((  ()\\n      / \\\\   |\\n    ((( (() ()(\\n     .   .   .\\n     .   .   .\\n\\n... and so on"
                    },
                    {
                        "username": "JenZ",
                        "content": "Is it 2^n? \\nIs any method better than it ?Thank you."
                    },
                    {
                        "username": "panwu5588",
                        "content": "BAD test cases. The order should not matter.\\nFor example, the following should be the same:\\n[\"(())\",\"()()\"]\\n[\"()()\",\"(())\"]"
                    },
                    {
                        "username": "satta_sunder",
                        "content": "I applied recursion and got 55% faster only. I\\'d love to see if there is any more efficient method."
                    },
                    {
                        "username": "Puja__Singh",
                        "content": "check mine it beats 97%"
                    },
                    {
                        "username": "noob-pika",
                        "content": "The system for calculating time complexity is broken for a solution after a certain number of submissions"
                    }
                ]
            },
            {
                "id": 1566162,
                "content": [
                    {
                        "username": "bonson",
                        "content": "Using different implmentation,the elements will be in different orders. e.g. n = 3.\\nIt can be\\n[\"((()))\",\"(())()\",\"()(())\",\"(()())\",\"()()()\"]\\nwhile the expected answer is\\n[\"((()))\",\"(()())\",\"(())()\",\"()(())\",\"()()()\"]\\n\\nBoth are correct answers. However, the difference of ordering is reckoned as \"wrong answer\". "
                    },
                    {
                        "username": "theashggl",
                        "content": "It accepts all ordering but that should be specified in the question."
                    },
                    {
                        "username": "gmarus",
                        "content": "still does not"
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# \\u26A0\\uFE0FEasiest \\uD83D\\uDE0E FAANG Method Ever !!! \\uD83D\\uDCA5\\nhttps://leetcode.com/problems/generate-parentheses/solutions/3035511/easiest-faang-method-ever/?orderBy=newest_to_oldest"
                    },
                    {
                        "username": "NicholasCG",
                        "content": "January 2023, it accepted different ordered answers for me."
                    },
                    {
                        "username": "barrybecker4",
                        "content": "[@satbekmyrza](/satbekmyrza) Still does not"
                    },
                    {
                        "username": "angelopoulos",
                        "content": "[@4m4nd33p_51ngh](/4m4nd33p_51ngh) I can confirm it still doesn\\'t"
                    },
                    {
                        "username": "4m4nd33p_51ngh",
                        "content": "[@satbekmyrza](/satbekmyrza) no it doesn\\'t"
                    },
                    {
                        "username": "satbekmyrza",
                        "content": "I think it accepts different ordered answers, as of 2022"
                    },
                    {
                        "username": "tejavenkatlanka",
                        "content": "![image](https://assets.leetcode.com/users/images/dabefcea-2a30-4a0a-81c4-b2dafcf9dce0_1599242411.2652733.png)\\nclick for view \\n[https://embed.creately.com/cclS6u7Upy3?type=svg] \\n\\nleft path represent possible one parentheses and right represent possible of right parentheses.\\n\\nleaf node contains answer.\\n\\nhope it will help.\\n\\n"
                    },
                    {
                        "username": "leetnote_io",
                        "content": "Thanks, the pic is very intuitive"
                    },
                    {
                        "username": "dominic89231",
                        "content": "Very helpful!"
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# \\u26A0\\uFE0FEasiest \\uD83D\\uDE0E FAANG Method Ever !!! \\uD83D\\uDCA5\\nhttps://leetcode.com/problems/generate-parentheses/solutions/3035511/easiest-faang-method-ever/?orderBy=newest_to_oldest"
                    },
                    {
                        "username": "drvnprgrmr",
                        "content": "Literally spent about 2hrs on this and came up with a different, more complex (I think) solution that uses recursion. "
                    },
                    {
                        "username": "ChrisMiaoMiao",
                        "content": "Thx, It\\'s very helpful!"
                    },
                    {
                        "username": "aln4739",
                        "content": "very helpful!"
                    },
                    {
                        "username": "KalRadikov",
                        "content": "![image](https://assets.leetcode.com/users/images/40f0296a-7b58-49fb-a72e-e5d8eacf94a4_1604461937.5052783.png)\\n\\nProof:\\n\\n![image](https://assets.leetcode.com/users/images/4bcd2dba-e170-4799-91ae-3e4a1de32731_1605116132.2703443.png)\\n\\n"
                    },
                    {
                        "username": "BREATHTAKER200",
                        "content": "You sneaky bastard!!!!!\\uD83E\\uDD23\\uD83E\\uDD23"
                    },
                    {
                        "username": "alex_malevinsky",
                        "content": "Lots of lines of code, without loops or recursion. Really legend!"
                    },
                    {
                        "username": "Demaxl",
                        "content": "You\\'re hired"
                    },
                    {
                        "username": "codebuster_",
                        "content": "Habibi, this is a dream come true moment"
                    },
                    {
                        "username": "drMystico",
                        "content": "genius guy downright there! "
                    },
                    {
                        "username": "Cripton",
                        "content": "bros dad works at microsoft"
                    },
                    {
                        "username": "RashCode",
                        "content": "Legend\\uD83E\\uDEE1"
                    },
                    {
                        "username": "milespossing",
                        "content": "Strong hire"
                    },
                    {
                        "username": "sunlins",
                        "content": "I was sure of finding this in the comment section"
                    },
                    {
                        "username": "tanmayyyj",
                        "content": "Bro is a hacker"
                    },
                    {
                        "username": "ktranada1403",
                        "content": "bro beat the system..."
                    },
                    {
                        "username": "rsharvesh16",
                        "content": "Bro is from another world!"
                    },
                    {
                        "username": "buzz_shocker",
                        "content": "This is some big brain stuff"
                    },
                    {
                        "username": "Prasanth2021",
                        "content": "[@kzlatt](/kzlatt) \\uD83D\\uDE02\\uD83D\\uDE02\\uD83D\\uDE02"
                    },
                    {
                        "username": "AdilARahman",
                        "content": "Use switch case to go even faster XD"
                    },
                    {
                        "username": "mdmasidulhasan27",
                        "content": "perfect solution for this problem. it\\'s kind a static problem. "
                    },
                    {
                        "username": "Crispy_coffee",
                        "content": "Testcase Oriented Programming \\uD83D\\uDE02"
                    },
                    {
                        "username": "guneetd",
                        "content": "[@ashok0](/ashok0) then you can use Abstract Factory to generate strings :) "
                    },
                    {
                        "username": "kzlatt",
                        "content": "Leetcode :  Choose!!!!  step up or step down\\nKalRadikov:   S.....i......d......e......w......a......y"
                    },
                    {
                        "username": "District_12",
                        "content": "that\\'s what we call to be creative!"
                    },
                    {
                        "username": "a_s_h_o_k",
                        "content": "what if n=100 \\uD83D\\uDE02"
                    },
                    {
                        "username": "aln4739",
                        "content": "chad"
                    },
                    {
                        "username": "leetcodesquad",
                        "content": "No one can beat you since you already had the answer. LOL"
                    },
                    {
                        "username": "undi69",
                        "content": "Dude you are a god"
                    },
                    {
                        "username": "khanuja05",
                        "content": "My solution generates the same set of outputs but the ordering is different. The question should be edited and they should mention that the order matters."
                    },
                    {
                        "username": "Nemo-7777",
                        "content": "It seems that problem author expects a sorted array of strings. So if you struggle with incorrect order, just sort the array and it should work fine."
                    },
                    {
                        "username": "fillipe",
                        "content": "[@krjukov](/krjukov) My solution fails at the test case with 6 pairs. I have verified exactly why now. It is for not generating certain patterns. The system considers your solution correct regardless of the order in which the patterns are saved in your solution."
                    },
                    {
                        "username": "krjukov",
                        "content": "It\\'s senseless to demand preserved order in this type of problems. All the strings are of the same length. It is the validation of the solutions to be amended, not the description. Just accept any order "
                    },
                    {
                        "username": "noisrucer",
                        "content": "I solved this problem with 60m/s by generating permutations with duplicates and for each permutation result I used stack to check if it\\'s valid parenthesis and now I came here and ppl post simple/mind-blowing solutions that I never expected and A LOT OF people be like \"yeah~nice solution~i thought kinda the same way~\". WTH!!!!!\\n\\nI started algorithm roughly 3 months ago and I\\'ve been studying 12-14 hrs a day til now and solved probably 200 questions so far. I\\'m kinda confident in BFS DFS DP and some general algorithm but totally new to combinatorics. What should I focus more on? I haven\\'t studied Greedy yet. Can you guys recommend me how I study Greedy? cuz its so vague I\\'ve looked up so much\\n\\nBless to y\\'all\\n\\n- Non-smart Asian sophomore kid-"
                    },
                    {
                        "username": "Haseeeb1",
                        "content": "whats your github and linkedin?"
                    },
                    {
                        "username": "baseballCode",
                        "content": "[@blsd-rus](/blsd-rus) I use the neetcode roadmap, ordering is important and since I started doing the questions in order im starting to get better. "
                    },
                    {
                        "username": "blsd-rus",
                        "content": "[@vishesh014](/vishesh014) i\\'ll recommend neetcode"
                    },
                    {
                        "username": "vishesh014",
                        "content": "bro can you tell me the roadmap how you studied algorithms"
                    },
                    {
                        "username": "andy_r_s",
                        "content": "For n = 4 is following one of the valid combinations?\\n(())(())\\n\\nMy code has this but the leetcode says it\\'s not valid. I don\\'t understand why is it invalid?"
                    },
                    {
                        "username": "fffccc",
                        "content": "I also generated this and the test case doesn\\'t generate this one."
                    },
                    {
                        "username": "charonme",
                        "content": "it\\'s valid, but maybe you generated it twice?"
                    },
                    {
                        "username": "chiragrajput245",
                        "content": "Draw the recursive tree and think about the conditions when an opening/closing bracket can be appended\\n\\n         (\\n        / \\\\\\n       ((  ()\\n      / \\\\   |\\n    ((( (() ()(\\n     .   .   .\\n     .   .   .\\n\\n... and so on"
                    },
                    {
                        "username": "JenZ",
                        "content": "Is it 2^n? \\nIs any method better than it ?Thank you."
                    },
                    {
                        "username": "panwu5588",
                        "content": "BAD test cases. The order should not matter.\\nFor example, the following should be the same:\\n[\"(())\",\"()()\"]\\n[\"()()\",\"(())\"]"
                    },
                    {
                        "username": "satta_sunder",
                        "content": "I applied recursion and got 55% faster only. I\\'d love to see if there is any more efficient method."
                    },
                    {
                        "username": "Puja__Singh",
                        "content": "check mine it beats 97%"
                    },
                    {
                        "username": "noob-pika",
                        "content": "The system for calculating time complexity is broken for a solution after a certain number of submissions"
                    }
                ]
            },
            {
                "id": 1565657,
                "content": [
                    {
                        "username": "bonson",
                        "content": "Using different implmentation,the elements will be in different orders. e.g. n = 3.\\nIt can be\\n[\"((()))\",\"(())()\",\"()(())\",\"(()())\",\"()()()\"]\\nwhile the expected answer is\\n[\"((()))\",\"(()())\",\"(())()\",\"()(())\",\"()()()\"]\\n\\nBoth are correct answers. However, the difference of ordering is reckoned as \"wrong answer\". "
                    },
                    {
                        "username": "theashggl",
                        "content": "It accepts all ordering but that should be specified in the question."
                    },
                    {
                        "username": "gmarus",
                        "content": "still does not"
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# \\u26A0\\uFE0FEasiest \\uD83D\\uDE0E FAANG Method Ever !!! \\uD83D\\uDCA5\\nhttps://leetcode.com/problems/generate-parentheses/solutions/3035511/easiest-faang-method-ever/?orderBy=newest_to_oldest"
                    },
                    {
                        "username": "NicholasCG",
                        "content": "January 2023, it accepted different ordered answers for me."
                    },
                    {
                        "username": "barrybecker4",
                        "content": "[@satbekmyrza](/satbekmyrza) Still does not"
                    },
                    {
                        "username": "angelopoulos",
                        "content": "[@4m4nd33p_51ngh](/4m4nd33p_51ngh) I can confirm it still doesn\\'t"
                    },
                    {
                        "username": "4m4nd33p_51ngh",
                        "content": "[@satbekmyrza](/satbekmyrza) no it doesn\\'t"
                    },
                    {
                        "username": "satbekmyrza",
                        "content": "I think it accepts different ordered answers, as of 2022"
                    },
                    {
                        "username": "tejavenkatlanka",
                        "content": "![image](https://assets.leetcode.com/users/images/dabefcea-2a30-4a0a-81c4-b2dafcf9dce0_1599242411.2652733.png)\\nclick for view \\n[https://embed.creately.com/cclS6u7Upy3?type=svg] \\n\\nleft path represent possible one parentheses and right represent possible of right parentheses.\\n\\nleaf node contains answer.\\n\\nhope it will help.\\n\\n"
                    },
                    {
                        "username": "leetnote_io",
                        "content": "Thanks, the pic is very intuitive"
                    },
                    {
                        "username": "dominic89231",
                        "content": "Very helpful!"
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# \\u26A0\\uFE0FEasiest \\uD83D\\uDE0E FAANG Method Ever !!! \\uD83D\\uDCA5\\nhttps://leetcode.com/problems/generate-parentheses/solutions/3035511/easiest-faang-method-ever/?orderBy=newest_to_oldest"
                    },
                    {
                        "username": "drvnprgrmr",
                        "content": "Literally spent about 2hrs on this and came up with a different, more complex (I think) solution that uses recursion. "
                    },
                    {
                        "username": "ChrisMiaoMiao",
                        "content": "Thx, It\\'s very helpful!"
                    },
                    {
                        "username": "aln4739",
                        "content": "very helpful!"
                    },
                    {
                        "username": "KalRadikov",
                        "content": "![image](https://assets.leetcode.com/users/images/40f0296a-7b58-49fb-a72e-e5d8eacf94a4_1604461937.5052783.png)\\n\\nProof:\\n\\n![image](https://assets.leetcode.com/users/images/4bcd2dba-e170-4799-91ae-3e4a1de32731_1605116132.2703443.png)\\n\\n"
                    },
                    {
                        "username": "BREATHTAKER200",
                        "content": "You sneaky bastard!!!!!\\uD83E\\uDD23\\uD83E\\uDD23"
                    },
                    {
                        "username": "alex_malevinsky",
                        "content": "Lots of lines of code, without loops or recursion. Really legend!"
                    },
                    {
                        "username": "Demaxl",
                        "content": "You\\'re hired"
                    },
                    {
                        "username": "codebuster_",
                        "content": "Habibi, this is a dream come true moment"
                    },
                    {
                        "username": "drMystico",
                        "content": "genius guy downright there! "
                    },
                    {
                        "username": "Cripton",
                        "content": "bros dad works at microsoft"
                    },
                    {
                        "username": "RashCode",
                        "content": "Legend\\uD83E\\uDEE1"
                    },
                    {
                        "username": "milespossing",
                        "content": "Strong hire"
                    },
                    {
                        "username": "sunlins",
                        "content": "I was sure of finding this in the comment section"
                    },
                    {
                        "username": "tanmayyyj",
                        "content": "Bro is a hacker"
                    },
                    {
                        "username": "ktranada1403",
                        "content": "bro beat the system..."
                    },
                    {
                        "username": "rsharvesh16",
                        "content": "Bro is from another world!"
                    },
                    {
                        "username": "buzz_shocker",
                        "content": "This is some big brain stuff"
                    },
                    {
                        "username": "Prasanth2021",
                        "content": "[@kzlatt](/kzlatt) \\uD83D\\uDE02\\uD83D\\uDE02\\uD83D\\uDE02"
                    },
                    {
                        "username": "AdilARahman",
                        "content": "Use switch case to go even faster XD"
                    },
                    {
                        "username": "mdmasidulhasan27",
                        "content": "perfect solution for this problem. it\\'s kind a static problem. "
                    },
                    {
                        "username": "Crispy_coffee",
                        "content": "Testcase Oriented Programming \\uD83D\\uDE02"
                    },
                    {
                        "username": "guneetd",
                        "content": "[@ashok0](/ashok0) then you can use Abstract Factory to generate strings :) "
                    },
                    {
                        "username": "kzlatt",
                        "content": "Leetcode :  Choose!!!!  step up or step down\\nKalRadikov:   S.....i......d......e......w......a......y"
                    },
                    {
                        "username": "District_12",
                        "content": "that\\'s what we call to be creative!"
                    },
                    {
                        "username": "a_s_h_o_k",
                        "content": "what if n=100 \\uD83D\\uDE02"
                    },
                    {
                        "username": "aln4739",
                        "content": "chad"
                    },
                    {
                        "username": "leetcodesquad",
                        "content": "No one can beat you since you already had the answer. LOL"
                    },
                    {
                        "username": "undi69",
                        "content": "Dude you are a god"
                    },
                    {
                        "username": "khanuja05",
                        "content": "My solution generates the same set of outputs but the ordering is different. The question should be edited and they should mention that the order matters."
                    },
                    {
                        "username": "Nemo-7777",
                        "content": "It seems that problem author expects a sorted array of strings. So if you struggle with incorrect order, just sort the array and it should work fine."
                    },
                    {
                        "username": "fillipe",
                        "content": "[@krjukov](/krjukov) My solution fails at the test case with 6 pairs. I have verified exactly why now. It is for not generating certain patterns. The system considers your solution correct regardless of the order in which the patterns are saved in your solution."
                    },
                    {
                        "username": "krjukov",
                        "content": "It\\'s senseless to demand preserved order in this type of problems. All the strings are of the same length. It is the validation of the solutions to be amended, not the description. Just accept any order "
                    },
                    {
                        "username": "noisrucer",
                        "content": "I solved this problem with 60m/s by generating permutations with duplicates and for each permutation result I used stack to check if it\\'s valid parenthesis and now I came here and ppl post simple/mind-blowing solutions that I never expected and A LOT OF people be like \"yeah~nice solution~i thought kinda the same way~\". WTH!!!!!\\n\\nI started algorithm roughly 3 months ago and I\\'ve been studying 12-14 hrs a day til now and solved probably 200 questions so far. I\\'m kinda confident in BFS DFS DP and some general algorithm but totally new to combinatorics. What should I focus more on? I haven\\'t studied Greedy yet. Can you guys recommend me how I study Greedy? cuz its so vague I\\'ve looked up so much\\n\\nBless to y\\'all\\n\\n- Non-smart Asian sophomore kid-"
                    },
                    {
                        "username": "Haseeeb1",
                        "content": "whats your github and linkedin?"
                    },
                    {
                        "username": "baseballCode",
                        "content": "[@blsd-rus](/blsd-rus) I use the neetcode roadmap, ordering is important and since I started doing the questions in order im starting to get better. "
                    },
                    {
                        "username": "blsd-rus",
                        "content": "[@vishesh014](/vishesh014) i\\'ll recommend neetcode"
                    },
                    {
                        "username": "vishesh014",
                        "content": "bro can you tell me the roadmap how you studied algorithms"
                    },
                    {
                        "username": "andy_r_s",
                        "content": "For n = 4 is following one of the valid combinations?\\n(())(())\\n\\nMy code has this but the leetcode says it\\'s not valid. I don\\'t understand why is it invalid?"
                    },
                    {
                        "username": "fffccc",
                        "content": "I also generated this and the test case doesn\\'t generate this one."
                    },
                    {
                        "username": "charonme",
                        "content": "it\\'s valid, but maybe you generated it twice?"
                    },
                    {
                        "username": "chiragrajput245",
                        "content": "Draw the recursive tree and think about the conditions when an opening/closing bracket can be appended\\n\\n         (\\n        / \\\\\\n       ((  ()\\n      / \\\\   |\\n    ((( (() ()(\\n     .   .   .\\n     .   .   .\\n\\n... and so on"
                    },
                    {
                        "username": "JenZ",
                        "content": "Is it 2^n? \\nIs any method better than it ?Thank you."
                    },
                    {
                        "username": "panwu5588",
                        "content": "BAD test cases. The order should not matter.\\nFor example, the following should be the same:\\n[\"(())\",\"()()\"]\\n[\"()()\",\"(())\"]"
                    },
                    {
                        "username": "satta_sunder",
                        "content": "I applied recursion and got 55% faster only. I\\'d love to see if there is any more efficient method."
                    },
                    {
                        "username": "Puja__Singh",
                        "content": "check mine it beats 97%"
                    },
                    {
                        "username": "noob-pika",
                        "content": "The system for calculating time complexity is broken for a solution after a certain number of submissions"
                    }
                ]
            },
            {
                "id": 1574405,
                "content": [
                    {
                        "username": "bonson",
                        "content": "Using different implmentation,the elements will be in different orders. e.g. n = 3.\\nIt can be\\n[\"((()))\",\"(())()\",\"()(())\",\"(()())\",\"()()()\"]\\nwhile the expected answer is\\n[\"((()))\",\"(()())\",\"(())()\",\"()(())\",\"()()()\"]\\n\\nBoth are correct answers. However, the difference of ordering is reckoned as \"wrong answer\". "
                    },
                    {
                        "username": "theashggl",
                        "content": "It accepts all ordering but that should be specified in the question."
                    },
                    {
                        "username": "gmarus",
                        "content": "still does not"
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# \\u26A0\\uFE0FEasiest \\uD83D\\uDE0E FAANG Method Ever !!! \\uD83D\\uDCA5\\nhttps://leetcode.com/problems/generate-parentheses/solutions/3035511/easiest-faang-method-ever/?orderBy=newest_to_oldest"
                    },
                    {
                        "username": "NicholasCG",
                        "content": "January 2023, it accepted different ordered answers for me."
                    },
                    {
                        "username": "barrybecker4",
                        "content": "[@satbekmyrza](/satbekmyrza) Still does not"
                    },
                    {
                        "username": "angelopoulos",
                        "content": "[@4m4nd33p_51ngh](/4m4nd33p_51ngh) I can confirm it still doesn\\'t"
                    },
                    {
                        "username": "4m4nd33p_51ngh",
                        "content": "[@satbekmyrza](/satbekmyrza) no it doesn\\'t"
                    },
                    {
                        "username": "satbekmyrza",
                        "content": "I think it accepts different ordered answers, as of 2022"
                    },
                    {
                        "username": "tejavenkatlanka",
                        "content": "![image](https://assets.leetcode.com/users/images/dabefcea-2a30-4a0a-81c4-b2dafcf9dce0_1599242411.2652733.png)\\nclick for view \\n[https://embed.creately.com/cclS6u7Upy3?type=svg] \\n\\nleft path represent possible one parentheses and right represent possible of right parentheses.\\n\\nleaf node contains answer.\\n\\nhope it will help.\\n\\n"
                    },
                    {
                        "username": "leetnote_io",
                        "content": "Thanks, the pic is very intuitive"
                    },
                    {
                        "username": "dominic89231",
                        "content": "Very helpful!"
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# \\u26A0\\uFE0FEasiest \\uD83D\\uDE0E FAANG Method Ever !!! \\uD83D\\uDCA5\\nhttps://leetcode.com/problems/generate-parentheses/solutions/3035511/easiest-faang-method-ever/?orderBy=newest_to_oldest"
                    },
                    {
                        "username": "drvnprgrmr",
                        "content": "Literally spent about 2hrs on this and came up with a different, more complex (I think) solution that uses recursion. "
                    },
                    {
                        "username": "ChrisMiaoMiao",
                        "content": "Thx, It\\'s very helpful!"
                    },
                    {
                        "username": "aln4739",
                        "content": "very helpful!"
                    },
                    {
                        "username": "KalRadikov",
                        "content": "![image](https://assets.leetcode.com/users/images/40f0296a-7b58-49fb-a72e-e5d8eacf94a4_1604461937.5052783.png)\\n\\nProof:\\n\\n![image](https://assets.leetcode.com/users/images/4bcd2dba-e170-4799-91ae-3e4a1de32731_1605116132.2703443.png)\\n\\n"
                    },
                    {
                        "username": "BREATHTAKER200",
                        "content": "You sneaky bastard!!!!!\\uD83E\\uDD23\\uD83E\\uDD23"
                    },
                    {
                        "username": "alex_malevinsky",
                        "content": "Lots of lines of code, without loops or recursion. Really legend!"
                    },
                    {
                        "username": "Demaxl",
                        "content": "You\\'re hired"
                    },
                    {
                        "username": "codebuster_",
                        "content": "Habibi, this is a dream come true moment"
                    },
                    {
                        "username": "drMystico",
                        "content": "genius guy downright there! "
                    },
                    {
                        "username": "Cripton",
                        "content": "bros dad works at microsoft"
                    },
                    {
                        "username": "RashCode",
                        "content": "Legend\\uD83E\\uDEE1"
                    },
                    {
                        "username": "milespossing",
                        "content": "Strong hire"
                    },
                    {
                        "username": "sunlins",
                        "content": "I was sure of finding this in the comment section"
                    },
                    {
                        "username": "tanmayyyj",
                        "content": "Bro is a hacker"
                    },
                    {
                        "username": "ktranada1403",
                        "content": "bro beat the system..."
                    },
                    {
                        "username": "rsharvesh16",
                        "content": "Bro is from another world!"
                    },
                    {
                        "username": "buzz_shocker",
                        "content": "This is some big brain stuff"
                    },
                    {
                        "username": "Prasanth2021",
                        "content": "[@kzlatt](/kzlatt) \\uD83D\\uDE02\\uD83D\\uDE02\\uD83D\\uDE02"
                    },
                    {
                        "username": "AdilARahman",
                        "content": "Use switch case to go even faster XD"
                    },
                    {
                        "username": "mdmasidulhasan27",
                        "content": "perfect solution for this problem. it\\'s kind a static problem. "
                    },
                    {
                        "username": "Crispy_coffee",
                        "content": "Testcase Oriented Programming \\uD83D\\uDE02"
                    },
                    {
                        "username": "guneetd",
                        "content": "[@ashok0](/ashok0) then you can use Abstract Factory to generate strings :) "
                    },
                    {
                        "username": "kzlatt",
                        "content": "Leetcode :  Choose!!!!  step up or step down\\nKalRadikov:   S.....i......d......e......w......a......y"
                    },
                    {
                        "username": "District_12",
                        "content": "that\\'s what we call to be creative!"
                    },
                    {
                        "username": "a_s_h_o_k",
                        "content": "what if n=100 \\uD83D\\uDE02"
                    },
                    {
                        "username": "aln4739",
                        "content": "chad"
                    },
                    {
                        "username": "leetcodesquad",
                        "content": "No one can beat you since you already had the answer. LOL"
                    },
                    {
                        "username": "undi69",
                        "content": "Dude you are a god"
                    },
                    {
                        "username": "khanuja05",
                        "content": "My solution generates the same set of outputs but the ordering is different. The question should be edited and they should mention that the order matters."
                    },
                    {
                        "username": "Nemo-7777",
                        "content": "It seems that problem author expects a sorted array of strings. So if you struggle with incorrect order, just sort the array and it should work fine."
                    },
                    {
                        "username": "fillipe",
                        "content": "[@krjukov](/krjukov) My solution fails at the test case with 6 pairs. I have verified exactly why now. It is for not generating certain patterns. The system considers your solution correct regardless of the order in which the patterns are saved in your solution."
                    },
                    {
                        "username": "krjukov",
                        "content": "It\\'s senseless to demand preserved order in this type of problems. All the strings are of the same length. It is the validation of the solutions to be amended, not the description. Just accept any order "
                    },
                    {
                        "username": "noisrucer",
                        "content": "I solved this problem with 60m/s by generating permutations with duplicates and for each permutation result I used stack to check if it\\'s valid parenthesis and now I came here and ppl post simple/mind-blowing solutions that I never expected and A LOT OF people be like \"yeah~nice solution~i thought kinda the same way~\". WTH!!!!!\\n\\nI started algorithm roughly 3 months ago and I\\'ve been studying 12-14 hrs a day til now and solved probably 200 questions so far. I\\'m kinda confident in BFS DFS DP and some general algorithm but totally new to combinatorics. What should I focus more on? I haven\\'t studied Greedy yet. Can you guys recommend me how I study Greedy? cuz its so vague I\\'ve looked up so much\\n\\nBless to y\\'all\\n\\n- Non-smart Asian sophomore kid-"
                    },
                    {
                        "username": "Haseeeb1",
                        "content": "whats your github and linkedin?"
                    },
                    {
                        "username": "baseballCode",
                        "content": "[@blsd-rus](/blsd-rus) I use the neetcode roadmap, ordering is important and since I started doing the questions in order im starting to get better. "
                    },
                    {
                        "username": "blsd-rus",
                        "content": "[@vishesh014](/vishesh014) i\\'ll recommend neetcode"
                    },
                    {
                        "username": "vishesh014",
                        "content": "bro can you tell me the roadmap how you studied algorithms"
                    },
                    {
                        "username": "andy_r_s",
                        "content": "For n = 4 is following one of the valid combinations?\\n(())(())\\n\\nMy code has this but the leetcode says it\\'s not valid. I don\\'t understand why is it invalid?"
                    },
                    {
                        "username": "fffccc",
                        "content": "I also generated this and the test case doesn\\'t generate this one."
                    },
                    {
                        "username": "charonme",
                        "content": "it\\'s valid, but maybe you generated it twice?"
                    },
                    {
                        "username": "chiragrajput245",
                        "content": "Draw the recursive tree and think about the conditions when an opening/closing bracket can be appended\\n\\n         (\\n        / \\\\\\n       ((  ()\\n      / \\\\   |\\n    ((( (() ()(\\n     .   .   .\\n     .   .   .\\n\\n... and so on"
                    },
                    {
                        "username": "JenZ",
                        "content": "Is it 2^n? \\nIs any method better than it ?Thank you."
                    },
                    {
                        "username": "panwu5588",
                        "content": "BAD test cases. The order should not matter.\\nFor example, the following should be the same:\\n[\"(())\",\"()()\"]\\n[\"()()\",\"(())\"]"
                    },
                    {
                        "username": "satta_sunder",
                        "content": "I applied recursion and got 55% faster only. I\\'d love to see if there is any more efficient method."
                    },
                    {
                        "username": "Puja__Singh",
                        "content": "check mine it beats 97%"
                    },
                    {
                        "username": "noob-pika",
                        "content": "The system for calculating time complexity is broken for a solution after a certain number of submissions"
                    }
                ]
            },
            {
                "id": 1568042,
                "content": [
                    {
                        "username": "bonson",
                        "content": "Using different implmentation,the elements will be in different orders. e.g. n = 3.\\nIt can be\\n[\"((()))\",\"(())()\",\"()(())\",\"(()())\",\"()()()\"]\\nwhile the expected answer is\\n[\"((()))\",\"(()())\",\"(())()\",\"()(())\",\"()()()\"]\\n\\nBoth are correct answers. However, the difference of ordering is reckoned as \"wrong answer\". "
                    },
                    {
                        "username": "theashggl",
                        "content": "It accepts all ordering but that should be specified in the question."
                    },
                    {
                        "username": "gmarus",
                        "content": "still does not"
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# \\u26A0\\uFE0FEasiest \\uD83D\\uDE0E FAANG Method Ever !!! \\uD83D\\uDCA5\\nhttps://leetcode.com/problems/generate-parentheses/solutions/3035511/easiest-faang-method-ever/?orderBy=newest_to_oldest"
                    },
                    {
                        "username": "NicholasCG",
                        "content": "January 2023, it accepted different ordered answers for me."
                    },
                    {
                        "username": "barrybecker4",
                        "content": "[@satbekmyrza](/satbekmyrza) Still does not"
                    },
                    {
                        "username": "angelopoulos",
                        "content": "[@4m4nd33p_51ngh](/4m4nd33p_51ngh) I can confirm it still doesn\\'t"
                    },
                    {
                        "username": "4m4nd33p_51ngh",
                        "content": "[@satbekmyrza](/satbekmyrza) no it doesn\\'t"
                    },
                    {
                        "username": "satbekmyrza",
                        "content": "I think it accepts different ordered answers, as of 2022"
                    },
                    {
                        "username": "tejavenkatlanka",
                        "content": "![image](https://assets.leetcode.com/users/images/dabefcea-2a30-4a0a-81c4-b2dafcf9dce0_1599242411.2652733.png)\\nclick for view \\n[https://embed.creately.com/cclS6u7Upy3?type=svg] \\n\\nleft path represent possible one parentheses and right represent possible of right parentheses.\\n\\nleaf node contains answer.\\n\\nhope it will help.\\n\\n"
                    },
                    {
                        "username": "leetnote_io",
                        "content": "Thanks, the pic is very intuitive"
                    },
                    {
                        "username": "dominic89231",
                        "content": "Very helpful!"
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# \\u26A0\\uFE0FEasiest \\uD83D\\uDE0E FAANG Method Ever !!! \\uD83D\\uDCA5\\nhttps://leetcode.com/problems/generate-parentheses/solutions/3035511/easiest-faang-method-ever/?orderBy=newest_to_oldest"
                    },
                    {
                        "username": "drvnprgrmr",
                        "content": "Literally spent about 2hrs on this and came up with a different, more complex (I think) solution that uses recursion. "
                    },
                    {
                        "username": "ChrisMiaoMiao",
                        "content": "Thx, It\\'s very helpful!"
                    },
                    {
                        "username": "aln4739",
                        "content": "very helpful!"
                    },
                    {
                        "username": "KalRadikov",
                        "content": "![image](https://assets.leetcode.com/users/images/40f0296a-7b58-49fb-a72e-e5d8eacf94a4_1604461937.5052783.png)\\n\\nProof:\\n\\n![image](https://assets.leetcode.com/users/images/4bcd2dba-e170-4799-91ae-3e4a1de32731_1605116132.2703443.png)\\n\\n"
                    },
                    {
                        "username": "BREATHTAKER200",
                        "content": "You sneaky bastard!!!!!\\uD83E\\uDD23\\uD83E\\uDD23"
                    },
                    {
                        "username": "alex_malevinsky",
                        "content": "Lots of lines of code, without loops or recursion. Really legend!"
                    },
                    {
                        "username": "Demaxl",
                        "content": "You\\'re hired"
                    },
                    {
                        "username": "codebuster_",
                        "content": "Habibi, this is a dream come true moment"
                    },
                    {
                        "username": "drMystico",
                        "content": "genius guy downright there! "
                    },
                    {
                        "username": "Cripton",
                        "content": "bros dad works at microsoft"
                    },
                    {
                        "username": "RashCode",
                        "content": "Legend\\uD83E\\uDEE1"
                    },
                    {
                        "username": "milespossing",
                        "content": "Strong hire"
                    },
                    {
                        "username": "sunlins",
                        "content": "I was sure of finding this in the comment section"
                    },
                    {
                        "username": "tanmayyyj",
                        "content": "Bro is a hacker"
                    },
                    {
                        "username": "ktranada1403",
                        "content": "bro beat the system..."
                    },
                    {
                        "username": "rsharvesh16",
                        "content": "Bro is from another world!"
                    },
                    {
                        "username": "buzz_shocker",
                        "content": "This is some big brain stuff"
                    },
                    {
                        "username": "Prasanth2021",
                        "content": "[@kzlatt](/kzlatt) \\uD83D\\uDE02\\uD83D\\uDE02\\uD83D\\uDE02"
                    },
                    {
                        "username": "AdilARahman",
                        "content": "Use switch case to go even faster XD"
                    },
                    {
                        "username": "mdmasidulhasan27",
                        "content": "perfect solution for this problem. it\\'s kind a static problem. "
                    },
                    {
                        "username": "Crispy_coffee",
                        "content": "Testcase Oriented Programming \\uD83D\\uDE02"
                    },
                    {
                        "username": "guneetd",
                        "content": "[@ashok0](/ashok0) then you can use Abstract Factory to generate strings :) "
                    },
                    {
                        "username": "kzlatt",
                        "content": "Leetcode :  Choose!!!!  step up or step down\\nKalRadikov:   S.....i......d......e......w......a......y"
                    },
                    {
                        "username": "District_12",
                        "content": "that\\'s what we call to be creative!"
                    },
                    {
                        "username": "a_s_h_o_k",
                        "content": "what if n=100 \\uD83D\\uDE02"
                    },
                    {
                        "username": "aln4739",
                        "content": "chad"
                    },
                    {
                        "username": "leetcodesquad",
                        "content": "No one can beat you since you already had the answer. LOL"
                    },
                    {
                        "username": "undi69",
                        "content": "Dude you are a god"
                    },
                    {
                        "username": "khanuja05",
                        "content": "My solution generates the same set of outputs but the ordering is different. The question should be edited and they should mention that the order matters."
                    },
                    {
                        "username": "Nemo-7777",
                        "content": "It seems that problem author expects a sorted array of strings. So if you struggle with incorrect order, just sort the array and it should work fine."
                    },
                    {
                        "username": "fillipe",
                        "content": "[@krjukov](/krjukov) My solution fails at the test case with 6 pairs. I have verified exactly why now. It is for not generating certain patterns. The system considers your solution correct regardless of the order in which the patterns are saved in your solution."
                    },
                    {
                        "username": "krjukov",
                        "content": "It\\'s senseless to demand preserved order in this type of problems. All the strings are of the same length. It is the validation of the solutions to be amended, not the description. Just accept any order "
                    },
                    {
                        "username": "noisrucer",
                        "content": "I solved this problem with 60m/s by generating permutations with duplicates and for each permutation result I used stack to check if it\\'s valid parenthesis and now I came here and ppl post simple/mind-blowing solutions that I never expected and A LOT OF people be like \"yeah~nice solution~i thought kinda the same way~\". WTH!!!!!\\n\\nI started algorithm roughly 3 months ago and I\\'ve been studying 12-14 hrs a day til now and solved probably 200 questions so far. I\\'m kinda confident in BFS DFS DP and some general algorithm but totally new to combinatorics. What should I focus more on? I haven\\'t studied Greedy yet. Can you guys recommend me how I study Greedy? cuz its so vague I\\'ve looked up so much\\n\\nBless to y\\'all\\n\\n- Non-smart Asian sophomore kid-"
                    },
                    {
                        "username": "Haseeeb1",
                        "content": "whats your github and linkedin?"
                    },
                    {
                        "username": "baseballCode",
                        "content": "[@blsd-rus](/blsd-rus) I use the neetcode roadmap, ordering is important and since I started doing the questions in order im starting to get better. "
                    },
                    {
                        "username": "blsd-rus",
                        "content": "[@vishesh014](/vishesh014) i\\'ll recommend neetcode"
                    },
                    {
                        "username": "vishesh014",
                        "content": "bro can you tell me the roadmap how you studied algorithms"
                    },
                    {
                        "username": "andy_r_s",
                        "content": "For n = 4 is following one of the valid combinations?\\n(())(())\\n\\nMy code has this but the leetcode says it\\'s not valid. I don\\'t understand why is it invalid?"
                    },
                    {
                        "username": "fffccc",
                        "content": "I also generated this and the test case doesn\\'t generate this one."
                    },
                    {
                        "username": "charonme",
                        "content": "it\\'s valid, but maybe you generated it twice?"
                    },
                    {
                        "username": "chiragrajput245",
                        "content": "Draw the recursive tree and think about the conditions when an opening/closing bracket can be appended\\n\\n         (\\n        / \\\\\\n       ((  ()\\n      / \\\\   |\\n    ((( (() ()(\\n     .   .   .\\n     .   .   .\\n\\n... and so on"
                    },
                    {
                        "username": "JenZ",
                        "content": "Is it 2^n? \\nIs any method better than it ?Thank you."
                    },
                    {
                        "username": "panwu5588",
                        "content": "BAD test cases. The order should not matter.\\nFor example, the following should be the same:\\n[\"(())\",\"()()\"]\\n[\"()()\",\"(())\"]"
                    },
                    {
                        "username": "satta_sunder",
                        "content": "I applied recursion and got 55% faster only. I\\'d love to see if there is any more efficient method."
                    },
                    {
                        "username": "Puja__Singh",
                        "content": "check mine it beats 97%"
                    },
                    {
                        "username": "noob-pika",
                        "content": "The system for calculating time complexity is broken for a solution after a certain number of submissions"
                    }
                ]
            },
            {
                "id": 1980901,
                "content": [
                    {
                        "username": "bonson",
                        "content": "Using different implmentation,the elements will be in different orders. e.g. n = 3.\\nIt can be\\n[\"((()))\",\"(())()\",\"()(())\",\"(()())\",\"()()()\"]\\nwhile the expected answer is\\n[\"((()))\",\"(()())\",\"(())()\",\"()(())\",\"()()()\"]\\n\\nBoth are correct answers. However, the difference of ordering is reckoned as \"wrong answer\". "
                    },
                    {
                        "username": "theashggl",
                        "content": "It accepts all ordering but that should be specified in the question."
                    },
                    {
                        "username": "gmarus",
                        "content": "still does not"
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# \\u26A0\\uFE0FEasiest \\uD83D\\uDE0E FAANG Method Ever !!! \\uD83D\\uDCA5\\nhttps://leetcode.com/problems/generate-parentheses/solutions/3035511/easiest-faang-method-ever/?orderBy=newest_to_oldest"
                    },
                    {
                        "username": "NicholasCG",
                        "content": "January 2023, it accepted different ordered answers for me."
                    },
                    {
                        "username": "barrybecker4",
                        "content": "[@satbekmyrza](/satbekmyrza) Still does not"
                    },
                    {
                        "username": "angelopoulos",
                        "content": "[@4m4nd33p_51ngh](/4m4nd33p_51ngh) I can confirm it still doesn\\'t"
                    },
                    {
                        "username": "4m4nd33p_51ngh",
                        "content": "[@satbekmyrza](/satbekmyrza) no it doesn\\'t"
                    },
                    {
                        "username": "satbekmyrza",
                        "content": "I think it accepts different ordered answers, as of 2022"
                    },
                    {
                        "username": "tejavenkatlanka",
                        "content": "![image](https://assets.leetcode.com/users/images/dabefcea-2a30-4a0a-81c4-b2dafcf9dce0_1599242411.2652733.png)\\nclick for view \\n[https://embed.creately.com/cclS6u7Upy3?type=svg] \\n\\nleft path represent possible one parentheses and right represent possible of right parentheses.\\n\\nleaf node contains answer.\\n\\nhope it will help.\\n\\n"
                    },
                    {
                        "username": "leetnote_io",
                        "content": "Thanks, the pic is very intuitive"
                    },
                    {
                        "username": "dominic89231",
                        "content": "Very helpful!"
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# \\u26A0\\uFE0FEasiest \\uD83D\\uDE0E FAANG Method Ever !!! \\uD83D\\uDCA5\\nhttps://leetcode.com/problems/generate-parentheses/solutions/3035511/easiest-faang-method-ever/?orderBy=newest_to_oldest"
                    },
                    {
                        "username": "drvnprgrmr",
                        "content": "Literally spent about 2hrs on this and came up with a different, more complex (I think) solution that uses recursion. "
                    },
                    {
                        "username": "ChrisMiaoMiao",
                        "content": "Thx, It\\'s very helpful!"
                    },
                    {
                        "username": "aln4739",
                        "content": "very helpful!"
                    },
                    {
                        "username": "KalRadikov",
                        "content": "![image](https://assets.leetcode.com/users/images/40f0296a-7b58-49fb-a72e-e5d8eacf94a4_1604461937.5052783.png)\\n\\nProof:\\n\\n![image](https://assets.leetcode.com/users/images/4bcd2dba-e170-4799-91ae-3e4a1de32731_1605116132.2703443.png)\\n\\n"
                    },
                    {
                        "username": "BREATHTAKER200",
                        "content": "You sneaky bastard!!!!!\\uD83E\\uDD23\\uD83E\\uDD23"
                    },
                    {
                        "username": "alex_malevinsky",
                        "content": "Lots of lines of code, without loops or recursion. Really legend!"
                    },
                    {
                        "username": "Demaxl",
                        "content": "You\\'re hired"
                    },
                    {
                        "username": "codebuster_",
                        "content": "Habibi, this is a dream come true moment"
                    },
                    {
                        "username": "drMystico",
                        "content": "genius guy downright there! "
                    },
                    {
                        "username": "Cripton",
                        "content": "bros dad works at microsoft"
                    },
                    {
                        "username": "RashCode",
                        "content": "Legend\\uD83E\\uDEE1"
                    },
                    {
                        "username": "milespossing",
                        "content": "Strong hire"
                    },
                    {
                        "username": "sunlins",
                        "content": "I was sure of finding this in the comment section"
                    },
                    {
                        "username": "tanmayyyj",
                        "content": "Bro is a hacker"
                    },
                    {
                        "username": "ktranada1403",
                        "content": "bro beat the system..."
                    },
                    {
                        "username": "rsharvesh16",
                        "content": "Bro is from another world!"
                    },
                    {
                        "username": "buzz_shocker",
                        "content": "This is some big brain stuff"
                    },
                    {
                        "username": "Prasanth2021",
                        "content": "[@kzlatt](/kzlatt) \\uD83D\\uDE02\\uD83D\\uDE02\\uD83D\\uDE02"
                    },
                    {
                        "username": "AdilARahman",
                        "content": "Use switch case to go even faster XD"
                    },
                    {
                        "username": "mdmasidulhasan27",
                        "content": "perfect solution for this problem. it\\'s kind a static problem. "
                    },
                    {
                        "username": "Crispy_coffee",
                        "content": "Testcase Oriented Programming \\uD83D\\uDE02"
                    },
                    {
                        "username": "guneetd",
                        "content": "[@ashok0](/ashok0) then you can use Abstract Factory to generate strings :) "
                    },
                    {
                        "username": "kzlatt",
                        "content": "Leetcode :  Choose!!!!  step up or step down\\nKalRadikov:   S.....i......d......e......w......a......y"
                    },
                    {
                        "username": "District_12",
                        "content": "that\\'s what we call to be creative!"
                    },
                    {
                        "username": "a_s_h_o_k",
                        "content": "what if n=100 \\uD83D\\uDE02"
                    },
                    {
                        "username": "aln4739",
                        "content": "chad"
                    },
                    {
                        "username": "leetcodesquad",
                        "content": "No one can beat you since you already had the answer. LOL"
                    },
                    {
                        "username": "undi69",
                        "content": "Dude you are a god"
                    },
                    {
                        "username": "khanuja05",
                        "content": "My solution generates the same set of outputs but the ordering is different. The question should be edited and they should mention that the order matters."
                    },
                    {
                        "username": "Nemo-7777",
                        "content": "It seems that problem author expects a sorted array of strings. So if you struggle with incorrect order, just sort the array and it should work fine."
                    },
                    {
                        "username": "fillipe",
                        "content": "[@krjukov](/krjukov) My solution fails at the test case with 6 pairs. I have verified exactly why now. It is for not generating certain patterns. The system considers your solution correct regardless of the order in which the patterns are saved in your solution."
                    },
                    {
                        "username": "krjukov",
                        "content": "It\\'s senseless to demand preserved order in this type of problems. All the strings are of the same length. It is the validation of the solutions to be amended, not the description. Just accept any order "
                    },
                    {
                        "username": "noisrucer",
                        "content": "I solved this problem with 60m/s by generating permutations with duplicates and for each permutation result I used stack to check if it\\'s valid parenthesis and now I came here and ppl post simple/mind-blowing solutions that I never expected and A LOT OF people be like \"yeah~nice solution~i thought kinda the same way~\". WTH!!!!!\\n\\nI started algorithm roughly 3 months ago and I\\'ve been studying 12-14 hrs a day til now and solved probably 200 questions so far. I\\'m kinda confident in BFS DFS DP and some general algorithm but totally new to combinatorics. What should I focus more on? I haven\\'t studied Greedy yet. Can you guys recommend me how I study Greedy? cuz its so vague I\\'ve looked up so much\\n\\nBless to y\\'all\\n\\n- Non-smart Asian sophomore kid-"
                    },
                    {
                        "username": "Haseeeb1",
                        "content": "whats your github and linkedin?"
                    },
                    {
                        "username": "baseballCode",
                        "content": "[@blsd-rus](/blsd-rus) I use the neetcode roadmap, ordering is important and since I started doing the questions in order im starting to get better. "
                    },
                    {
                        "username": "blsd-rus",
                        "content": "[@vishesh014](/vishesh014) i\\'ll recommend neetcode"
                    },
                    {
                        "username": "vishesh014",
                        "content": "bro can you tell me the roadmap how you studied algorithms"
                    },
                    {
                        "username": "andy_r_s",
                        "content": "For n = 4 is following one of the valid combinations?\\n(())(())\\n\\nMy code has this but the leetcode says it\\'s not valid. I don\\'t understand why is it invalid?"
                    },
                    {
                        "username": "fffccc",
                        "content": "I also generated this and the test case doesn\\'t generate this one."
                    },
                    {
                        "username": "charonme",
                        "content": "it\\'s valid, but maybe you generated it twice?"
                    },
                    {
                        "username": "chiragrajput245",
                        "content": "Draw the recursive tree and think about the conditions when an opening/closing bracket can be appended\\n\\n         (\\n        / \\\\\\n       ((  ()\\n      / \\\\   |\\n    ((( (() ()(\\n     .   .   .\\n     .   .   .\\n\\n... and so on"
                    },
                    {
                        "username": "JenZ",
                        "content": "Is it 2^n? \\nIs any method better than it ?Thank you."
                    },
                    {
                        "username": "panwu5588",
                        "content": "BAD test cases. The order should not matter.\\nFor example, the following should be the same:\\n[\"(())\",\"()()\"]\\n[\"()()\",\"(())\"]"
                    },
                    {
                        "username": "satta_sunder",
                        "content": "I applied recursion and got 55% faster only. I\\'d love to see if there is any more efficient method."
                    },
                    {
                        "username": "Puja__Singh",
                        "content": "check mine it beats 97%"
                    },
                    {
                        "username": "noob-pika",
                        "content": "The system for calculating time complexity is broken for a solution after a certain number of submissions"
                    }
                ]
            },
            {
                "id": 1568840,
                "content": [
                    {
                        "username": "bonson",
                        "content": "Using different implmentation,the elements will be in different orders. e.g. n = 3.\\nIt can be\\n[\"((()))\",\"(())()\",\"()(())\",\"(()())\",\"()()()\"]\\nwhile the expected answer is\\n[\"((()))\",\"(()())\",\"(())()\",\"()(())\",\"()()()\"]\\n\\nBoth are correct answers. However, the difference of ordering is reckoned as \"wrong answer\". "
                    },
                    {
                        "username": "theashggl",
                        "content": "It accepts all ordering but that should be specified in the question."
                    },
                    {
                        "username": "gmarus",
                        "content": "still does not"
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# \\u26A0\\uFE0FEasiest \\uD83D\\uDE0E FAANG Method Ever !!! \\uD83D\\uDCA5\\nhttps://leetcode.com/problems/generate-parentheses/solutions/3035511/easiest-faang-method-ever/?orderBy=newest_to_oldest"
                    },
                    {
                        "username": "NicholasCG",
                        "content": "January 2023, it accepted different ordered answers for me."
                    },
                    {
                        "username": "barrybecker4",
                        "content": "[@satbekmyrza](/satbekmyrza) Still does not"
                    },
                    {
                        "username": "angelopoulos",
                        "content": "[@4m4nd33p_51ngh](/4m4nd33p_51ngh) I can confirm it still doesn\\'t"
                    },
                    {
                        "username": "4m4nd33p_51ngh",
                        "content": "[@satbekmyrza](/satbekmyrza) no it doesn\\'t"
                    },
                    {
                        "username": "satbekmyrza",
                        "content": "I think it accepts different ordered answers, as of 2022"
                    },
                    {
                        "username": "tejavenkatlanka",
                        "content": "![image](https://assets.leetcode.com/users/images/dabefcea-2a30-4a0a-81c4-b2dafcf9dce0_1599242411.2652733.png)\\nclick for view \\n[https://embed.creately.com/cclS6u7Upy3?type=svg] \\n\\nleft path represent possible one parentheses and right represent possible of right parentheses.\\n\\nleaf node contains answer.\\n\\nhope it will help.\\n\\n"
                    },
                    {
                        "username": "leetnote_io",
                        "content": "Thanks, the pic is very intuitive"
                    },
                    {
                        "username": "dominic89231",
                        "content": "Very helpful!"
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# \\u26A0\\uFE0FEasiest \\uD83D\\uDE0E FAANG Method Ever !!! \\uD83D\\uDCA5\\nhttps://leetcode.com/problems/generate-parentheses/solutions/3035511/easiest-faang-method-ever/?orderBy=newest_to_oldest"
                    },
                    {
                        "username": "drvnprgrmr",
                        "content": "Literally spent about 2hrs on this and came up with a different, more complex (I think) solution that uses recursion. "
                    },
                    {
                        "username": "ChrisMiaoMiao",
                        "content": "Thx, It\\'s very helpful!"
                    },
                    {
                        "username": "aln4739",
                        "content": "very helpful!"
                    },
                    {
                        "username": "KalRadikov",
                        "content": "![image](https://assets.leetcode.com/users/images/40f0296a-7b58-49fb-a72e-e5d8eacf94a4_1604461937.5052783.png)\\n\\nProof:\\n\\n![image](https://assets.leetcode.com/users/images/4bcd2dba-e170-4799-91ae-3e4a1de32731_1605116132.2703443.png)\\n\\n"
                    },
                    {
                        "username": "BREATHTAKER200",
                        "content": "You sneaky bastard!!!!!\\uD83E\\uDD23\\uD83E\\uDD23"
                    },
                    {
                        "username": "alex_malevinsky",
                        "content": "Lots of lines of code, without loops or recursion. Really legend!"
                    },
                    {
                        "username": "Demaxl",
                        "content": "You\\'re hired"
                    },
                    {
                        "username": "codebuster_",
                        "content": "Habibi, this is a dream come true moment"
                    },
                    {
                        "username": "drMystico",
                        "content": "genius guy downright there! "
                    },
                    {
                        "username": "Cripton",
                        "content": "bros dad works at microsoft"
                    },
                    {
                        "username": "RashCode",
                        "content": "Legend\\uD83E\\uDEE1"
                    },
                    {
                        "username": "milespossing",
                        "content": "Strong hire"
                    },
                    {
                        "username": "sunlins",
                        "content": "I was sure of finding this in the comment section"
                    },
                    {
                        "username": "tanmayyyj",
                        "content": "Bro is a hacker"
                    },
                    {
                        "username": "ktranada1403",
                        "content": "bro beat the system..."
                    },
                    {
                        "username": "rsharvesh16",
                        "content": "Bro is from another world!"
                    },
                    {
                        "username": "buzz_shocker",
                        "content": "This is some big brain stuff"
                    },
                    {
                        "username": "Prasanth2021",
                        "content": "[@kzlatt](/kzlatt) \\uD83D\\uDE02\\uD83D\\uDE02\\uD83D\\uDE02"
                    },
                    {
                        "username": "AdilARahman",
                        "content": "Use switch case to go even faster XD"
                    },
                    {
                        "username": "mdmasidulhasan27",
                        "content": "perfect solution for this problem. it\\'s kind a static problem. "
                    },
                    {
                        "username": "Crispy_coffee",
                        "content": "Testcase Oriented Programming \\uD83D\\uDE02"
                    },
                    {
                        "username": "guneetd",
                        "content": "[@ashok0](/ashok0) then you can use Abstract Factory to generate strings :) "
                    },
                    {
                        "username": "kzlatt",
                        "content": "Leetcode :  Choose!!!!  step up or step down\\nKalRadikov:   S.....i......d......e......w......a......y"
                    },
                    {
                        "username": "District_12",
                        "content": "that\\'s what we call to be creative!"
                    },
                    {
                        "username": "a_s_h_o_k",
                        "content": "what if n=100 \\uD83D\\uDE02"
                    },
                    {
                        "username": "aln4739",
                        "content": "chad"
                    },
                    {
                        "username": "leetcodesquad",
                        "content": "No one can beat you since you already had the answer. LOL"
                    },
                    {
                        "username": "undi69",
                        "content": "Dude you are a god"
                    },
                    {
                        "username": "khanuja05",
                        "content": "My solution generates the same set of outputs but the ordering is different. The question should be edited and they should mention that the order matters."
                    },
                    {
                        "username": "Nemo-7777",
                        "content": "It seems that problem author expects a sorted array of strings. So if you struggle with incorrect order, just sort the array and it should work fine."
                    },
                    {
                        "username": "fillipe",
                        "content": "[@krjukov](/krjukov) My solution fails at the test case with 6 pairs. I have verified exactly why now. It is for not generating certain patterns. The system considers your solution correct regardless of the order in which the patterns are saved in your solution."
                    },
                    {
                        "username": "krjukov",
                        "content": "It\\'s senseless to demand preserved order in this type of problems. All the strings are of the same length. It is the validation of the solutions to be amended, not the description. Just accept any order "
                    },
                    {
                        "username": "noisrucer",
                        "content": "I solved this problem with 60m/s by generating permutations with duplicates and for each permutation result I used stack to check if it\\'s valid parenthesis and now I came here and ppl post simple/mind-blowing solutions that I never expected and A LOT OF people be like \"yeah~nice solution~i thought kinda the same way~\". WTH!!!!!\\n\\nI started algorithm roughly 3 months ago and I\\'ve been studying 12-14 hrs a day til now and solved probably 200 questions so far. I\\'m kinda confident in BFS DFS DP and some general algorithm but totally new to combinatorics. What should I focus more on? I haven\\'t studied Greedy yet. Can you guys recommend me how I study Greedy? cuz its so vague I\\'ve looked up so much\\n\\nBless to y\\'all\\n\\n- Non-smart Asian sophomore kid-"
                    },
                    {
                        "username": "Haseeeb1",
                        "content": "whats your github and linkedin?"
                    },
                    {
                        "username": "baseballCode",
                        "content": "[@blsd-rus](/blsd-rus) I use the neetcode roadmap, ordering is important and since I started doing the questions in order im starting to get better. "
                    },
                    {
                        "username": "blsd-rus",
                        "content": "[@vishesh014](/vishesh014) i\\'ll recommend neetcode"
                    },
                    {
                        "username": "vishesh014",
                        "content": "bro can you tell me the roadmap how you studied algorithms"
                    },
                    {
                        "username": "andy_r_s",
                        "content": "For n = 4 is following one of the valid combinations?\\n(())(())\\n\\nMy code has this but the leetcode says it\\'s not valid. I don\\'t understand why is it invalid?"
                    },
                    {
                        "username": "fffccc",
                        "content": "I also generated this and the test case doesn\\'t generate this one."
                    },
                    {
                        "username": "charonme",
                        "content": "it\\'s valid, but maybe you generated it twice?"
                    },
                    {
                        "username": "chiragrajput245",
                        "content": "Draw the recursive tree and think about the conditions when an opening/closing bracket can be appended\\n\\n         (\\n        / \\\\\\n       ((  ()\\n      / \\\\   |\\n    ((( (() ()(\\n     .   .   .\\n     .   .   .\\n\\n... and so on"
                    },
                    {
                        "username": "JenZ",
                        "content": "Is it 2^n? \\nIs any method better than it ?Thank you."
                    },
                    {
                        "username": "panwu5588",
                        "content": "BAD test cases. The order should not matter.\\nFor example, the following should be the same:\\n[\"(())\",\"()()\"]\\n[\"()()\",\"(())\"]"
                    },
                    {
                        "username": "satta_sunder",
                        "content": "I applied recursion and got 55% faster only. I\\'d love to see if there is any more efficient method."
                    },
                    {
                        "username": "Puja__Singh",
                        "content": "check mine it beats 97%"
                    },
                    {
                        "username": "noob-pika",
                        "content": "The system for calculating time complexity is broken for a solution after a certain number of submissions"
                    }
                ]
            },
            {
                "id": 1568013,
                "content": [
                    {
                        "username": "bonson",
                        "content": "Using different implmentation,the elements will be in different orders. e.g. n = 3.\\nIt can be\\n[\"((()))\",\"(())()\",\"()(())\",\"(()())\",\"()()()\"]\\nwhile the expected answer is\\n[\"((()))\",\"(()())\",\"(())()\",\"()(())\",\"()()()\"]\\n\\nBoth are correct answers. However, the difference of ordering is reckoned as \"wrong answer\". "
                    },
                    {
                        "username": "theashggl",
                        "content": "It accepts all ordering but that should be specified in the question."
                    },
                    {
                        "username": "gmarus",
                        "content": "still does not"
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# \\u26A0\\uFE0FEasiest \\uD83D\\uDE0E FAANG Method Ever !!! \\uD83D\\uDCA5\\nhttps://leetcode.com/problems/generate-parentheses/solutions/3035511/easiest-faang-method-ever/?orderBy=newest_to_oldest"
                    },
                    {
                        "username": "NicholasCG",
                        "content": "January 2023, it accepted different ordered answers for me."
                    },
                    {
                        "username": "barrybecker4",
                        "content": "[@satbekmyrza](/satbekmyrza) Still does not"
                    },
                    {
                        "username": "angelopoulos",
                        "content": "[@4m4nd33p_51ngh](/4m4nd33p_51ngh) I can confirm it still doesn\\'t"
                    },
                    {
                        "username": "4m4nd33p_51ngh",
                        "content": "[@satbekmyrza](/satbekmyrza) no it doesn\\'t"
                    },
                    {
                        "username": "satbekmyrza",
                        "content": "I think it accepts different ordered answers, as of 2022"
                    },
                    {
                        "username": "tejavenkatlanka",
                        "content": "![image](https://assets.leetcode.com/users/images/dabefcea-2a30-4a0a-81c4-b2dafcf9dce0_1599242411.2652733.png)\\nclick for view \\n[https://embed.creately.com/cclS6u7Upy3?type=svg] \\n\\nleft path represent possible one parentheses and right represent possible of right parentheses.\\n\\nleaf node contains answer.\\n\\nhope it will help.\\n\\n"
                    },
                    {
                        "username": "leetnote_io",
                        "content": "Thanks, the pic is very intuitive"
                    },
                    {
                        "username": "dominic89231",
                        "content": "Very helpful!"
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# \\u26A0\\uFE0FEasiest \\uD83D\\uDE0E FAANG Method Ever !!! \\uD83D\\uDCA5\\nhttps://leetcode.com/problems/generate-parentheses/solutions/3035511/easiest-faang-method-ever/?orderBy=newest_to_oldest"
                    },
                    {
                        "username": "drvnprgrmr",
                        "content": "Literally spent about 2hrs on this and came up with a different, more complex (I think) solution that uses recursion. "
                    },
                    {
                        "username": "ChrisMiaoMiao",
                        "content": "Thx, It\\'s very helpful!"
                    },
                    {
                        "username": "aln4739",
                        "content": "very helpful!"
                    },
                    {
                        "username": "KalRadikov",
                        "content": "![image](https://assets.leetcode.com/users/images/40f0296a-7b58-49fb-a72e-e5d8eacf94a4_1604461937.5052783.png)\\n\\nProof:\\n\\n![image](https://assets.leetcode.com/users/images/4bcd2dba-e170-4799-91ae-3e4a1de32731_1605116132.2703443.png)\\n\\n"
                    },
                    {
                        "username": "BREATHTAKER200",
                        "content": "You sneaky bastard!!!!!\\uD83E\\uDD23\\uD83E\\uDD23"
                    },
                    {
                        "username": "alex_malevinsky",
                        "content": "Lots of lines of code, without loops or recursion. Really legend!"
                    },
                    {
                        "username": "Demaxl",
                        "content": "You\\'re hired"
                    },
                    {
                        "username": "codebuster_",
                        "content": "Habibi, this is a dream come true moment"
                    },
                    {
                        "username": "drMystico",
                        "content": "genius guy downright there! "
                    },
                    {
                        "username": "Cripton",
                        "content": "bros dad works at microsoft"
                    },
                    {
                        "username": "RashCode",
                        "content": "Legend\\uD83E\\uDEE1"
                    },
                    {
                        "username": "milespossing",
                        "content": "Strong hire"
                    },
                    {
                        "username": "sunlins",
                        "content": "I was sure of finding this in the comment section"
                    },
                    {
                        "username": "tanmayyyj",
                        "content": "Bro is a hacker"
                    },
                    {
                        "username": "ktranada1403",
                        "content": "bro beat the system..."
                    },
                    {
                        "username": "rsharvesh16",
                        "content": "Bro is from another world!"
                    },
                    {
                        "username": "buzz_shocker",
                        "content": "This is some big brain stuff"
                    },
                    {
                        "username": "Prasanth2021",
                        "content": "[@kzlatt](/kzlatt) \\uD83D\\uDE02\\uD83D\\uDE02\\uD83D\\uDE02"
                    },
                    {
                        "username": "AdilARahman",
                        "content": "Use switch case to go even faster XD"
                    },
                    {
                        "username": "mdmasidulhasan27",
                        "content": "perfect solution for this problem. it\\'s kind a static problem. "
                    },
                    {
                        "username": "Crispy_coffee",
                        "content": "Testcase Oriented Programming \\uD83D\\uDE02"
                    },
                    {
                        "username": "guneetd",
                        "content": "[@ashok0](/ashok0) then you can use Abstract Factory to generate strings :) "
                    },
                    {
                        "username": "kzlatt",
                        "content": "Leetcode :  Choose!!!!  step up or step down\\nKalRadikov:   S.....i......d......e......w......a......y"
                    },
                    {
                        "username": "District_12",
                        "content": "that\\'s what we call to be creative!"
                    },
                    {
                        "username": "a_s_h_o_k",
                        "content": "what if n=100 \\uD83D\\uDE02"
                    },
                    {
                        "username": "aln4739",
                        "content": "chad"
                    },
                    {
                        "username": "leetcodesquad",
                        "content": "No one can beat you since you already had the answer. LOL"
                    },
                    {
                        "username": "undi69",
                        "content": "Dude you are a god"
                    },
                    {
                        "username": "khanuja05",
                        "content": "My solution generates the same set of outputs but the ordering is different. The question should be edited and they should mention that the order matters."
                    },
                    {
                        "username": "Nemo-7777",
                        "content": "It seems that problem author expects a sorted array of strings. So if you struggle with incorrect order, just sort the array and it should work fine."
                    },
                    {
                        "username": "fillipe",
                        "content": "[@krjukov](/krjukov) My solution fails at the test case with 6 pairs. I have verified exactly why now. It is for not generating certain patterns. The system considers your solution correct regardless of the order in which the patterns are saved in your solution."
                    },
                    {
                        "username": "krjukov",
                        "content": "It\\'s senseless to demand preserved order in this type of problems. All the strings are of the same length. It is the validation of the solutions to be amended, not the description. Just accept any order "
                    },
                    {
                        "username": "noisrucer",
                        "content": "I solved this problem with 60m/s by generating permutations with duplicates and for each permutation result I used stack to check if it\\'s valid parenthesis and now I came here and ppl post simple/mind-blowing solutions that I never expected and A LOT OF people be like \"yeah~nice solution~i thought kinda the same way~\". WTH!!!!!\\n\\nI started algorithm roughly 3 months ago and I\\'ve been studying 12-14 hrs a day til now and solved probably 200 questions so far. I\\'m kinda confident in BFS DFS DP and some general algorithm but totally new to combinatorics. What should I focus more on? I haven\\'t studied Greedy yet. Can you guys recommend me how I study Greedy? cuz its so vague I\\'ve looked up so much\\n\\nBless to y\\'all\\n\\n- Non-smart Asian sophomore kid-"
                    },
                    {
                        "username": "Haseeeb1",
                        "content": "whats your github and linkedin?"
                    },
                    {
                        "username": "baseballCode",
                        "content": "[@blsd-rus](/blsd-rus) I use the neetcode roadmap, ordering is important and since I started doing the questions in order im starting to get better. "
                    },
                    {
                        "username": "blsd-rus",
                        "content": "[@vishesh014](/vishesh014) i\\'ll recommend neetcode"
                    },
                    {
                        "username": "vishesh014",
                        "content": "bro can you tell me the roadmap how you studied algorithms"
                    },
                    {
                        "username": "andy_r_s",
                        "content": "For n = 4 is following one of the valid combinations?\\n(())(())\\n\\nMy code has this but the leetcode says it\\'s not valid. I don\\'t understand why is it invalid?"
                    },
                    {
                        "username": "fffccc",
                        "content": "I also generated this and the test case doesn\\'t generate this one."
                    },
                    {
                        "username": "charonme",
                        "content": "it\\'s valid, but maybe you generated it twice?"
                    },
                    {
                        "username": "chiragrajput245",
                        "content": "Draw the recursive tree and think about the conditions when an opening/closing bracket can be appended\\n\\n         (\\n        / \\\\\\n       ((  ()\\n      / \\\\   |\\n    ((( (() ()(\\n     .   .   .\\n     .   .   .\\n\\n... and so on"
                    },
                    {
                        "username": "JenZ",
                        "content": "Is it 2^n? \\nIs any method better than it ?Thank you."
                    },
                    {
                        "username": "panwu5588",
                        "content": "BAD test cases. The order should not matter.\\nFor example, the following should be the same:\\n[\"(())\",\"()()\"]\\n[\"()()\",\"(())\"]"
                    },
                    {
                        "username": "satta_sunder",
                        "content": "I applied recursion and got 55% faster only. I\\'d love to see if there is any more efficient method."
                    },
                    {
                        "username": "Puja__Singh",
                        "content": "check mine it beats 97%"
                    },
                    {
                        "username": "noob-pika",
                        "content": "The system for calculating time complexity is broken for a solution after a certain number of submissions"
                    }
                ]
            },
            {
                "id": 1575229,
                "content": [
                    {
                        "username": "bonson",
                        "content": "Using different implmentation,the elements will be in different orders. e.g. n = 3.\\nIt can be\\n[\"((()))\",\"(())()\",\"()(())\",\"(()())\",\"()()()\"]\\nwhile the expected answer is\\n[\"((()))\",\"(()())\",\"(())()\",\"()(())\",\"()()()\"]\\n\\nBoth are correct answers. However, the difference of ordering is reckoned as \"wrong answer\". "
                    },
                    {
                        "username": "theashggl",
                        "content": "It accepts all ordering but that should be specified in the question."
                    },
                    {
                        "username": "gmarus",
                        "content": "still does not"
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# \\u26A0\\uFE0FEasiest \\uD83D\\uDE0E FAANG Method Ever !!! \\uD83D\\uDCA5\\nhttps://leetcode.com/problems/generate-parentheses/solutions/3035511/easiest-faang-method-ever/?orderBy=newest_to_oldest"
                    },
                    {
                        "username": "NicholasCG",
                        "content": "January 2023, it accepted different ordered answers for me."
                    },
                    {
                        "username": "barrybecker4",
                        "content": "[@satbekmyrza](/satbekmyrza) Still does not"
                    },
                    {
                        "username": "angelopoulos",
                        "content": "[@4m4nd33p_51ngh](/4m4nd33p_51ngh) I can confirm it still doesn\\'t"
                    },
                    {
                        "username": "4m4nd33p_51ngh",
                        "content": "[@satbekmyrza](/satbekmyrza) no it doesn\\'t"
                    },
                    {
                        "username": "satbekmyrza",
                        "content": "I think it accepts different ordered answers, as of 2022"
                    },
                    {
                        "username": "tejavenkatlanka",
                        "content": "![image](https://assets.leetcode.com/users/images/dabefcea-2a30-4a0a-81c4-b2dafcf9dce0_1599242411.2652733.png)\\nclick for view \\n[https://embed.creately.com/cclS6u7Upy3?type=svg] \\n\\nleft path represent possible one parentheses and right represent possible of right parentheses.\\n\\nleaf node contains answer.\\n\\nhope it will help.\\n\\n"
                    },
                    {
                        "username": "leetnote_io",
                        "content": "Thanks, the pic is very intuitive"
                    },
                    {
                        "username": "dominic89231",
                        "content": "Very helpful!"
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# \\u26A0\\uFE0FEasiest \\uD83D\\uDE0E FAANG Method Ever !!! \\uD83D\\uDCA5\\nhttps://leetcode.com/problems/generate-parentheses/solutions/3035511/easiest-faang-method-ever/?orderBy=newest_to_oldest"
                    },
                    {
                        "username": "drvnprgrmr",
                        "content": "Literally spent about 2hrs on this and came up with a different, more complex (I think) solution that uses recursion. "
                    },
                    {
                        "username": "ChrisMiaoMiao",
                        "content": "Thx, It\\'s very helpful!"
                    },
                    {
                        "username": "aln4739",
                        "content": "very helpful!"
                    },
                    {
                        "username": "KalRadikov",
                        "content": "![image](https://assets.leetcode.com/users/images/40f0296a-7b58-49fb-a72e-e5d8eacf94a4_1604461937.5052783.png)\\n\\nProof:\\n\\n![image](https://assets.leetcode.com/users/images/4bcd2dba-e170-4799-91ae-3e4a1de32731_1605116132.2703443.png)\\n\\n"
                    },
                    {
                        "username": "BREATHTAKER200",
                        "content": "You sneaky bastard!!!!!\\uD83E\\uDD23\\uD83E\\uDD23"
                    },
                    {
                        "username": "alex_malevinsky",
                        "content": "Lots of lines of code, without loops or recursion. Really legend!"
                    },
                    {
                        "username": "Demaxl",
                        "content": "You\\'re hired"
                    },
                    {
                        "username": "codebuster_",
                        "content": "Habibi, this is a dream come true moment"
                    },
                    {
                        "username": "drMystico",
                        "content": "genius guy downright there! "
                    },
                    {
                        "username": "Cripton",
                        "content": "bros dad works at microsoft"
                    },
                    {
                        "username": "RashCode",
                        "content": "Legend\\uD83E\\uDEE1"
                    },
                    {
                        "username": "milespossing",
                        "content": "Strong hire"
                    },
                    {
                        "username": "sunlins",
                        "content": "I was sure of finding this in the comment section"
                    },
                    {
                        "username": "tanmayyyj",
                        "content": "Bro is a hacker"
                    },
                    {
                        "username": "ktranada1403",
                        "content": "bro beat the system..."
                    },
                    {
                        "username": "rsharvesh16",
                        "content": "Bro is from another world!"
                    },
                    {
                        "username": "buzz_shocker",
                        "content": "This is some big brain stuff"
                    },
                    {
                        "username": "Prasanth2021",
                        "content": "[@kzlatt](/kzlatt) \\uD83D\\uDE02\\uD83D\\uDE02\\uD83D\\uDE02"
                    },
                    {
                        "username": "AdilARahman",
                        "content": "Use switch case to go even faster XD"
                    },
                    {
                        "username": "mdmasidulhasan27",
                        "content": "perfect solution for this problem. it\\'s kind a static problem. "
                    },
                    {
                        "username": "Crispy_coffee",
                        "content": "Testcase Oriented Programming \\uD83D\\uDE02"
                    },
                    {
                        "username": "guneetd",
                        "content": "[@ashok0](/ashok0) then you can use Abstract Factory to generate strings :) "
                    },
                    {
                        "username": "kzlatt",
                        "content": "Leetcode :  Choose!!!!  step up or step down\\nKalRadikov:   S.....i......d......e......w......a......y"
                    },
                    {
                        "username": "District_12",
                        "content": "that\\'s what we call to be creative!"
                    },
                    {
                        "username": "a_s_h_o_k",
                        "content": "what if n=100 \\uD83D\\uDE02"
                    },
                    {
                        "username": "aln4739",
                        "content": "chad"
                    },
                    {
                        "username": "leetcodesquad",
                        "content": "No one can beat you since you already had the answer. LOL"
                    },
                    {
                        "username": "undi69",
                        "content": "Dude you are a god"
                    },
                    {
                        "username": "khanuja05",
                        "content": "My solution generates the same set of outputs but the ordering is different. The question should be edited and they should mention that the order matters."
                    },
                    {
                        "username": "Nemo-7777",
                        "content": "It seems that problem author expects a sorted array of strings. So if you struggle with incorrect order, just sort the array and it should work fine."
                    },
                    {
                        "username": "fillipe",
                        "content": "[@krjukov](/krjukov) My solution fails at the test case with 6 pairs. I have verified exactly why now. It is for not generating certain patterns. The system considers your solution correct regardless of the order in which the patterns are saved in your solution."
                    },
                    {
                        "username": "krjukov",
                        "content": "It\\'s senseless to demand preserved order in this type of problems. All the strings are of the same length. It is the validation of the solutions to be amended, not the description. Just accept any order "
                    },
                    {
                        "username": "noisrucer",
                        "content": "I solved this problem with 60m/s by generating permutations with duplicates and for each permutation result I used stack to check if it\\'s valid parenthesis and now I came here and ppl post simple/mind-blowing solutions that I never expected and A LOT OF people be like \"yeah~nice solution~i thought kinda the same way~\". WTH!!!!!\\n\\nI started algorithm roughly 3 months ago and I\\'ve been studying 12-14 hrs a day til now and solved probably 200 questions so far. I\\'m kinda confident in BFS DFS DP and some general algorithm but totally new to combinatorics. What should I focus more on? I haven\\'t studied Greedy yet. Can you guys recommend me how I study Greedy? cuz its so vague I\\'ve looked up so much\\n\\nBless to y\\'all\\n\\n- Non-smart Asian sophomore kid-"
                    },
                    {
                        "username": "Haseeeb1",
                        "content": "whats your github and linkedin?"
                    },
                    {
                        "username": "baseballCode",
                        "content": "[@blsd-rus](/blsd-rus) I use the neetcode roadmap, ordering is important and since I started doing the questions in order im starting to get better. "
                    },
                    {
                        "username": "blsd-rus",
                        "content": "[@vishesh014](/vishesh014) i\\'ll recommend neetcode"
                    },
                    {
                        "username": "vishesh014",
                        "content": "bro can you tell me the roadmap how you studied algorithms"
                    },
                    {
                        "username": "andy_r_s",
                        "content": "For n = 4 is following one of the valid combinations?\\n(())(())\\n\\nMy code has this but the leetcode says it\\'s not valid. I don\\'t understand why is it invalid?"
                    },
                    {
                        "username": "fffccc",
                        "content": "I also generated this and the test case doesn\\'t generate this one."
                    },
                    {
                        "username": "charonme",
                        "content": "it\\'s valid, but maybe you generated it twice?"
                    },
                    {
                        "username": "chiragrajput245",
                        "content": "Draw the recursive tree and think about the conditions when an opening/closing bracket can be appended\\n\\n         (\\n        / \\\\\\n       ((  ()\\n      / \\\\   |\\n    ((( (() ()(\\n     .   .   .\\n     .   .   .\\n\\n... and so on"
                    },
                    {
                        "username": "JenZ",
                        "content": "Is it 2^n? \\nIs any method better than it ?Thank you."
                    },
                    {
                        "username": "panwu5588",
                        "content": "BAD test cases. The order should not matter.\\nFor example, the following should be the same:\\n[\"(())\",\"()()\"]\\n[\"()()\",\"(())\"]"
                    },
                    {
                        "username": "satta_sunder",
                        "content": "I applied recursion and got 55% faster only. I\\'d love to see if there is any more efficient method."
                    },
                    {
                        "username": "Puja__Singh",
                        "content": "check mine it beats 97%"
                    },
                    {
                        "username": "noob-pika",
                        "content": "The system for calculating time complexity is broken for a solution after a certain number of submissions"
                    }
                ]
            },
            {
                "id": 1571058,
                "content": [
                    {
                        "username": "billupus",
                        "content": "I got rejected because:\\n\\n    Input:\\t4\\n    Output: \\t[\"()()()()\",\"(()()())\",\"()(()())\",\"((()()))\",\"(()())()\",\"()()(())\",\"(()(()))\",\"()(())()\",\"()((()))\",\"(((())))\",\"((()))()\",\"()(())()\",\"((())())\",\"(())()()\"]\\n    Expected:   [\"(((())))\",\"((()()))\",\"((())())\",\"((()))()\",\"(()(()))\",\"(()()())\",\"(()())()\",\"(())(())\",\"(())()()\",\"()((()))\",\"()(()())\",\"()(())()\",\"()()(())\",\"()()()()\"]\\n\\nEverything (except for the order) looks fine to me? I don't think that a certain order is necessary at all."
                    },
                    {
                        "username": "fffccc",
                        "content": "I got this error, too. \"(())(())\" is not included in the answer which is weird to me."
                    },
                    {
                        "username": "fillipe",
                        "content": "Your solution allowed a duplicate for the pattern \"()(())()\". Your algorithm is not generate all patterns. \\nI found that my solution starts to fail at test case n=6 for not generating all patterns. \\nMy first solution consisted of generating patterns based on to building blocks: 1) enclose the input pattern with brackets, and if the pattern is formed of with a chain of brackets subpatterns, then generate new patterns by enclosing each brackets subpattern of the input pattern. Right after forming each of the individual patterns, as they are generated, check if they have already been seen, if not, then generate deeper derivates of the newly generated pattern until it runs out of pairs of brackets. 2) For each newly generated pattern, add a new pair of brackets to the right or to the left of the pattern. I thought this was supposed to work but it doesn\\'t solve for all possible test cases. In the end, I had to resort to the solution where patterns are formed by adding a bracket at a time, to the left or to the right."
                    },
                    {
                        "username": "mabingteng",
                        "content": "![image](https://s3-lc-upload.s3.amazonaws.com/users/mabingteng/image_1529838101.png)\\n"
                    },
                    {
                        "username": "TGBBSZWHWDLANZP",
                        "content": "[@Crispy_coffee](/Crispy_coffee) seems to be performing depth first search recursively, with one more \"(\" or \")\" depending on if its searching left or right."
                    },
                    {
                        "username": "Crispy_coffee",
                        "content": "Can you explain it please."
                    },
                    {
                        "username": "codepiyush1",
                        "content": "Logic:\\nAdd open bracket upto open is less than n given.\\nAdd close bracket upto close is less than open.\\nBy this way close bracket will never come in befor start bracket.\\ni.e )(.\\n\\nTime complexity:\\nT.C=O(2^n) used recursion.\\n\\nSpace complexity:\\nS.C=O(n)\\n------------------------\\nPlease upvote. If Understand the concept...\\nSolution Link:\\nhttps://leetcode.com/problems/generate-parentheses/solutions/3636240/c-python-java-understand-the-concept/"
                    },
                    {
                        "username": "mohmedelngar200211",
                        "content": "not accepted cuz diffierence in the order"
                    },
                    {
                        "username": "divi13",
                        "content": "There seems to be a problem with the grader.\\n\\nIt is saying this:\\n\\n**Input:\\n1\\nOutput:\\n[\"((()))\",\"(()())\",\"(())()\",\"()(())\",\"()()()\",\"()\"]\\nExpected:\\n[\"()\"]**\\n\\nBut when I run the code with input 1, I am getting the expected [\"()\"] as result. What is the problem?\\n\\n\\n"
                    },
                    {
                        "username": "leetpen",
                        "content": "reminder for people with same situation:\\nprobably because you use a global variable to store the list. The system will run test case n = 1 after n = 3, so those strings of the previous test case (n=3) are still in your list"
                    },
                    {
                        "username": "pandabearnow",
                        "content": "I have a solution that lists all the combinations but my submission fails because it is not in the order that the leetcode answer generates them. Why is that order important?"
                    },
                    {
                        "username": "ab1533489",
                        "content": "I\\'m not able to think of iterative DP solution for this problem, if you know please do share."
                    },
                    {
                        "username": "Demaxl",
                        "content": "I feel so happy that i was able to solve this problem. This is the first backtracking I solved by myself. I feel more motivated to tackle others now"
                    },
                    {
                        "username": "AnthonyR21",
                        "content": "To solve this problem, you can use a recursive approach. Here\\'s how you can approach the task and put your mind in the right direction:\\n\\n1. Base Case: Start by identifying the base case. When n is 0, there\\'s only one possible combination: an empty string.\\n\\n2. Recursive Case: For each pair of parentheses, you have two options: open a new parenthesis or close an existing open parenthesis. So, you\\'ll recursively generate combinations by trying both options for each parenthesis.\\n\\n3. Recursion with Backtracking: Use recursion to explore all possibilities. When adding an open parenthesis, decrement n by 1 to indicate that one opening parenthesis has been used. When adding a closing parenthesis, make sure there\\'s a matching open parenthesis available (meaning n hasn\\'t reached 0 yet).\\n\\n4. Build and Return the Combinations: As you explore the possibilities, build and store the combinations in a list. Once you\\'ve exhausted all possibilities for a given state, return the list of combinations.\\n\\n5. Edge Cases: Handle edge cases like if n is negative or zero, and set up the initial call to the recursive function.\\n\\nIn terms of algorithm, the key idea is to generate all possible combinations while ensuring that they\\'re well-formed parentheses. The recursive approach allows you to explore these combinations in a structured manner. Remember to think about the base case, the recursive cases, and how to build and return the combinations as you traverse the recursion tree.\\n\\nIn terms of implementation, you can create a recursive function that takes parameters such as the current combination being built, the remaining open and close parentheses, and the list to store combinations. Each recursive call will decide whether to add an open or close parenthesis, and the parameters will be updated accordingly.\\n\\nRemember that recursive problems often involve thinking about how to break down the problem into smaller, more manageable subproblems, and how to combine the results of those subproblems to get the final solution.\\n\\n "
                    },
                    {
                        "username": "Prakhar2909",
                        "content": "How this question uses dp, I have solved using backtracking"
                    }
                ]
            },
            {
                "id": 1569242,
                "content": [
                    {
                        "username": "billupus",
                        "content": "I got rejected because:\\n\\n    Input:\\t4\\n    Output: \\t[\"()()()()\",\"(()()())\",\"()(()())\",\"((()()))\",\"(()())()\",\"()()(())\",\"(()(()))\",\"()(())()\",\"()((()))\",\"(((())))\",\"((()))()\",\"()(())()\",\"((())())\",\"(())()()\"]\\n    Expected:   [\"(((())))\",\"((()()))\",\"((())())\",\"((()))()\",\"(()(()))\",\"(()()())\",\"(()())()\",\"(())(())\",\"(())()()\",\"()((()))\",\"()(()())\",\"()(())()\",\"()()(())\",\"()()()()\"]\\n\\nEverything (except for the order) looks fine to me? I don't think that a certain order is necessary at all."
                    },
                    {
                        "username": "fffccc",
                        "content": "I got this error, too. \"(())(())\" is not included in the answer which is weird to me."
                    },
                    {
                        "username": "fillipe",
                        "content": "Your solution allowed a duplicate for the pattern \"()(())()\". Your algorithm is not generate all patterns. \\nI found that my solution starts to fail at test case n=6 for not generating all patterns. \\nMy first solution consisted of generating patterns based on to building blocks: 1) enclose the input pattern with brackets, and if the pattern is formed of with a chain of brackets subpatterns, then generate new patterns by enclosing each brackets subpattern of the input pattern. Right after forming each of the individual patterns, as they are generated, check if they have already been seen, if not, then generate deeper derivates of the newly generated pattern until it runs out of pairs of brackets. 2) For each newly generated pattern, add a new pair of brackets to the right or to the left of the pattern. I thought this was supposed to work but it doesn\\'t solve for all possible test cases. In the end, I had to resort to the solution where patterns are formed by adding a bracket at a time, to the left or to the right."
                    },
                    {
                        "username": "mabingteng",
                        "content": "![image](https://s3-lc-upload.s3.amazonaws.com/users/mabingteng/image_1529838101.png)\\n"
                    },
                    {
                        "username": "TGBBSZWHWDLANZP",
                        "content": "[@Crispy_coffee](/Crispy_coffee) seems to be performing depth first search recursively, with one more \"(\" or \")\" depending on if its searching left or right."
                    },
                    {
                        "username": "Crispy_coffee",
                        "content": "Can you explain it please."
                    },
                    {
                        "username": "codepiyush1",
                        "content": "Logic:\\nAdd open bracket upto open is less than n given.\\nAdd close bracket upto close is less than open.\\nBy this way close bracket will never come in befor start bracket.\\ni.e )(.\\n\\nTime complexity:\\nT.C=O(2^n) used recursion.\\n\\nSpace complexity:\\nS.C=O(n)\\n------------------------\\nPlease upvote. If Understand the concept...\\nSolution Link:\\nhttps://leetcode.com/problems/generate-parentheses/solutions/3636240/c-python-java-understand-the-concept/"
                    },
                    {
                        "username": "mohmedelngar200211",
                        "content": "not accepted cuz diffierence in the order"
                    },
                    {
                        "username": "divi13",
                        "content": "There seems to be a problem with the grader.\\n\\nIt is saying this:\\n\\n**Input:\\n1\\nOutput:\\n[\"((()))\",\"(()())\",\"(())()\",\"()(())\",\"()()()\",\"()\"]\\nExpected:\\n[\"()\"]**\\n\\nBut when I run the code with input 1, I am getting the expected [\"()\"] as result. What is the problem?\\n\\n\\n"
                    },
                    {
                        "username": "leetpen",
                        "content": "reminder for people with same situation:\\nprobably because you use a global variable to store the list. The system will run test case n = 1 after n = 3, so those strings of the previous test case (n=3) are still in your list"
                    },
                    {
                        "username": "pandabearnow",
                        "content": "I have a solution that lists all the combinations but my submission fails because it is not in the order that the leetcode answer generates them. Why is that order important?"
                    },
                    {
                        "username": "ab1533489",
                        "content": "I\\'m not able to think of iterative DP solution for this problem, if you know please do share."
                    },
                    {
                        "username": "Demaxl",
                        "content": "I feel so happy that i was able to solve this problem. This is the first backtracking I solved by myself. I feel more motivated to tackle others now"
                    },
                    {
                        "username": "AnthonyR21",
                        "content": "To solve this problem, you can use a recursive approach. Here\\'s how you can approach the task and put your mind in the right direction:\\n\\n1. Base Case: Start by identifying the base case. When n is 0, there\\'s only one possible combination: an empty string.\\n\\n2. Recursive Case: For each pair of parentheses, you have two options: open a new parenthesis or close an existing open parenthesis. So, you\\'ll recursively generate combinations by trying both options for each parenthesis.\\n\\n3. Recursion with Backtracking: Use recursion to explore all possibilities. When adding an open parenthesis, decrement n by 1 to indicate that one opening parenthesis has been used. When adding a closing parenthesis, make sure there\\'s a matching open parenthesis available (meaning n hasn\\'t reached 0 yet).\\n\\n4. Build and Return the Combinations: As you explore the possibilities, build and store the combinations in a list. Once you\\'ve exhausted all possibilities for a given state, return the list of combinations.\\n\\n5. Edge Cases: Handle edge cases like if n is negative or zero, and set up the initial call to the recursive function.\\n\\nIn terms of algorithm, the key idea is to generate all possible combinations while ensuring that they\\'re well-formed parentheses. The recursive approach allows you to explore these combinations in a structured manner. Remember to think about the base case, the recursive cases, and how to build and return the combinations as you traverse the recursion tree.\\n\\nIn terms of implementation, you can create a recursive function that takes parameters such as the current combination being built, the remaining open and close parentheses, and the list to store combinations. Each recursive call will decide whether to add an open or close parenthesis, and the parameters will be updated accordingly.\\n\\nRemember that recursive problems often involve thinking about how to break down the problem into smaller, more manageable subproblems, and how to combine the results of those subproblems to get the final solution.\\n\\n "
                    },
                    {
                        "username": "Prakhar2909",
                        "content": "How this question uses dp, I have solved using backtracking"
                    }
                ]
            },
            {
                "id": 1928921,
                "content": [
                    {
                        "username": "billupus",
                        "content": "I got rejected because:\\n\\n    Input:\\t4\\n    Output: \\t[\"()()()()\",\"(()()())\",\"()(()())\",\"((()()))\",\"(()())()\",\"()()(())\",\"(()(()))\",\"()(())()\",\"()((()))\",\"(((())))\",\"((()))()\",\"()(())()\",\"((())())\",\"(())()()\"]\\n    Expected:   [\"(((())))\",\"((()()))\",\"((())())\",\"((()))()\",\"(()(()))\",\"(()()())\",\"(()())()\",\"(())(())\",\"(())()()\",\"()((()))\",\"()(()())\",\"()(())()\",\"()()(())\",\"()()()()\"]\\n\\nEverything (except for the order) looks fine to me? I don't think that a certain order is necessary at all."
                    },
                    {
                        "username": "fffccc",
                        "content": "I got this error, too. \"(())(())\" is not included in the answer which is weird to me."
                    },
                    {
                        "username": "fillipe",
                        "content": "Your solution allowed a duplicate for the pattern \"()(())()\". Your algorithm is not generate all patterns. \\nI found that my solution starts to fail at test case n=6 for not generating all patterns. \\nMy first solution consisted of generating patterns based on to building blocks: 1) enclose the input pattern with brackets, and if the pattern is formed of with a chain of brackets subpatterns, then generate new patterns by enclosing each brackets subpattern of the input pattern. Right after forming each of the individual patterns, as they are generated, check if they have already been seen, if not, then generate deeper derivates of the newly generated pattern until it runs out of pairs of brackets. 2) For each newly generated pattern, add a new pair of brackets to the right or to the left of the pattern. I thought this was supposed to work but it doesn\\'t solve for all possible test cases. In the end, I had to resort to the solution where patterns are formed by adding a bracket at a time, to the left or to the right."
                    },
                    {
                        "username": "mabingteng",
                        "content": "![image](https://s3-lc-upload.s3.amazonaws.com/users/mabingteng/image_1529838101.png)\\n"
                    },
                    {
                        "username": "TGBBSZWHWDLANZP",
                        "content": "[@Crispy_coffee](/Crispy_coffee) seems to be performing depth first search recursively, with one more \"(\" or \")\" depending on if its searching left or right."
                    },
                    {
                        "username": "Crispy_coffee",
                        "content": "Can you explain it please."
                    },
                    {
                        "username": "codepiyush1",
                        "content": "Logic:\\nAdd open bracket upto open is less than n given.\\nAdd close bracket upto close is less than open.\\nBy this way close bracket will never come in befor start bracket.\\ni.e )(.\\n\\nTime complexity:\\nT.C=O(2^n) used recursion.\\n\\nSpace complexity:\\nS.C=O(n)\\n------------------------\\nPlease upvote. If Understand the concept...\\nSolution Link:\\nhttps://leetcode.com/problems/generate-parentheses/solutions/3636240/c-python-java-understand-the-concept/"
                    },
                    {
                        "username": "mohmedelngar200211",
                        "content": "not accepted cuz diffierence in the order"
                    },
                    {
                        "username": "divi13",
                        "content": "There seems to be a problem with the grader.\\n\\nIt is saying this:\\n\\n**Input:\\n1\\nOutput:\\n[\"((()))\",\"(()())\",\"(())()\",\"()(())\",\"()()()\",\"()\"]\\nExpected:\\n[\"()\"]**\\n\\nBut when I run the code with input 1, I am getting the expected [\"()\"] as result. What is the problem?\\n\\n\\n"
                    },
                    {
                        "username": "leetpen",
                        "content": "reminder for people with same situation:\\nprobably because you use a global variable to store the list. The system will run test case n = 1 after n = 3, so those strings of the previous test case (n=3) are still in your list"
                    },
                    {
                        "username": "pandabearnow",
                        "content": "I have a solution that lists all the combinations but my submission fails because it is not in the order that the leetcode answer generates them. Why is that order important?"
                    },
                    {
                        "username": "ab1533489",
                        "content": "I\\'m not able to think of iterative DP solution for this problem, if you know please do share."
                    },
                    {
                        "username": "Demaxl",
                        "content": "I feel so happy that i was able to solve this problem. This is the first backtracking I solved by myself. I feel more motivated to tackle others now"
                    },
                    {
                        "username": "AnthonyR21",
                        "content": "To solve this problem, you can use a recursive approach. Here\\'s how you can approach the task and put your mind in the right direction:\\n\\n1. Base Case: Start by identifying the base case. When n is 0, there\\'s only one possible combination: an empty string.\\n\\n2. Recursive Case: For each pair of parentheses, you have two options: open a new parenthesis or close an existing open parenthesis. So, you\\'ll recursively generate combinations by trying both options for each parenthesis.\\n\\n3. Recursion with Backtracking: Use recursion to explore all possibilities. When adding an open parenthesis, decrement n by 1 to indicate that one opening parenthesis has been used. When adding a closing parenthesis, make sure there\\'s a matching open parenthesis available (meaning n hasn\\'t reached 0 yet).\\n\\n4. Build and Return the Combinations: As you explore the possibilities, build and store the combinations in a list. Once you\\'ve exhausted all possibilities for a given state, return the list of combinations.\\n\\n5. Edge Cases: Handle edge cases like if n is negative or zero, and set up the initial call to the recursive function.\\n\\nIn terms of algorithm, the key idea is to generate all possible combinations while ensuring that they\\'re well-formed parentheses. The recursive approach allows you to explore these combinations in a structured manner. Remember to think about the base case, the recursive cases, and how to build and return the combinations as you traverse the recursion tree.\\n\\nIn terms of implementation, you can create a recursive function that takes parameters such as the current combination being built, the remaining open and close parentheses, and the list to store combinations. Each recursive call will decide whether to add an open or close parenthesis, and the parameters will be updated accordingly.\\n\\nRemember that recursive problems often involve thinking about how to break down the problem into smaller, more manageable subproblems, and how to combine the results of those subproblems to get the final solution.\\n\\n "
                    },
                    {
                        "username": "Prakhar2909",
                        "content": "How this question uses dp, I have solved using backtracking"
                    }
                ]
            },
            {
                "id": 1826653,
                "content": [
                    {
                        "username": "billupus",
                        "content": "I got rejected because:\\n\\n    Input:\\t4\\n    Output: \\t[\"()()()()\",\"(()()())\",\"()(()())\",\"((()()))\",\"(()())()\",\"()()(())\",\"(()(()))\",\"()(())()\",\"()((()))\",\"(((())))\",\"((()))()\",\"()(())()\",\"((())())\",\"(())()()\"]\\n    Expected:   [\"(((())))\",\"((()()))\",\"((())())\",\"((()))()\",\"(()(()))\",\"(()()())\",\"(()())()\",\"(())(())\",\"(())()()\",\"()((()))\",\"()(()())\",\"()(())()\",\"()()(())\",\"()()()()\"]\\n\\nEverything (except for the order) looks fine to me? I don't think that a certain order is necessary at all."
                    },
                    {
                        "username": "fffccc",
                        "content": "I got this error, too. \"(())(())\" is not included in the answer which is weird to me."
                    },
                    {
                        "username": "fillipe",
                        "content": "Your solution allowed a duplicate for the pattern \"()(())()\". Your algorithm is not generate all patterns. \\nI found that my solution starts to fail at test case n=6 for not generating all patterns. \\nMy first solution consisted of generating patterns based on to building blocks: 1) enclose the input pattern with brackets, and if the pattern is formed of with a chain of brackets subpatterns, then generate new patterns by enclosing each brackets subpattern of the input pattern. Right after forming each of the individual patterns, as they are generated, check if they have already been seen, if not, then generate deeper derivates of the newly generated pattern until it runs out of pairs of brackets. 2) For each newly generated pattern, add a new pair of brackets to the right or to the left of the pattern. I thought this was supposed to work but it doesn\\'t solve for all possible test cases. In the end, I had to resort to the solution where patterns are formed by adding a bracket at a time, to the left or to the right."
                    },
                    {
                        "username": "mabingteng",
                        "content": "![image](https://s3-lc-upload.s3.amazonaws.com/users/mabingteng/image_1529838101.png)\\n"
                    },
                    {
                        "username": "TGBBSZWHWDLANZP",
                        "content": "[@Crispy_coffee](/Crispy_coffee) seems to be performing depth first search recursively, with one more \"(\" or \")\" depending on if its searching left or right."
                    },
                    {
                        "username": "Crispy_coffee",
                        "content": "Can you explain it please."
                    },
                    {
                        "username": "codepiyush1",
                        "content": "Logic:\\nAdd open bracket upto open is less than n given.\\nAdd close bracket upto close is less than open.\\nBy this way close bracket will never come in befor start bracket.\\ni.e )(.\\n\\nTime complexity:\\nT.C=O(2^n) used recursion.\\n\\nSpace complexity:\\nS.C=O(n)\\n------------------------\\nPlease upvote. If Understand the concept...\\nSolution Link:\\nhttps://leetcode.com/problems/generate-parentheses/solutions/3636240/c-python-java-understand-the-concept/"
                    },
                    {
                        "username": "mohmedelngar200211",
                        "content": "not accepted cuz diffierence in the order"
                    },
                    {
                        "username": "divi13",
                        "content": "There seems to be a problem with the grader.\\n\\nIt is saying this:\\n\\n**Input:\\n1\\nOutput:\\n[\"((()))\",\"(()())\",\"(())()\",\"()(())\",\"()()()\",\"()\"]\\nExpected:\\n[\"()\"]**\\n\\nBut when I run the code with input 1, I am getting the expected [\"()\"] as result. What is the problem?\\n\\n\\n"
                    },
                    {
                        "username": "leetpen",
                        "content": "reminder for people with same situation:\\nprobably because you use a global variable to store the list. The system will run test case n = 1 after n = 3, so those strings of the previous test case (n=3) are still in your list"
                    },
                    {
                        "username": "pandabearnow",
                        "content": "I have a solution that lists all the combinations but my submission fails because it is not in the order that the leetcode answer generates them. Why is that order important?"
                    },
                    {
                        "username": "ab1533489",
                        "content": "I\\'m not able to think of iterative DP solution for this problem, if you know please do share."
                    },
                    {
                        "username": "Demaxl",
                        "content": "I feel so happy that i was able to solve this problem. This is the first backtracking I solved by myself. I feel more motivated to tackle others now"
                    },
                    {
                        "username": "AnthonyR21",
                        "content": "To solve this problem, you can use a recursive approach. Here\\'s how you can approach the task and put your mind in the right direction:\\n\\n1. Base Case: Start by identifying the base case. When n is 0, there\\'s only one possible combination: an empty string.\\n\\n2. Recursive Case: For each pair of parentheses, you have two options: open a new parenthesis or close an existing open parenthesis. So, you\\'ll recursively generate combinations by trying both options for each parenthesis.\\n\\n3. Recursion with Backtracking: Use recursion to explore all possibilities. When adding an open parenthesis, decrement n by 1 to indicate that one opening parenthesis has been used. When adding a closing parenthesis, make sure there\\'s a matching open parenthesis available (meaning n hasn\\'t reached 0 yet).\\n\\n4. Build and Return the Combinations: As you explore the possibilities, build and store the combinations in a list. Once you\\'ve exhausted all possibilities for a given state, return the list of combinations.\\n\\n5. Edge Cases: Handle edge cases like if n is negative or zero, and set up the initial call to the recursive function.\\n\\nIn terms of algorithm, the key idea is to generate all possible combinations while ensuring that they\\'re well-formed parentheses. The recursive approach allows you to explore these combinations in a structured manner. Remember to think about the base case, the recursive cases, and how to build and return the combinations as you traverse the recursion tree.\\n\\nIn terms of implementation, you can create a recursive function that takes parameters such as the current combination being built, the remaining open and close parentheses, and the list to store combinations. Each recursive call will decide whether to add an open or close parenthesis, and the parameters will be updated accordingly.\\n\\nRemember that recursive problems often involve thinking about how to break down the problem into smaller, more manageable subproblems, and how to combine the results of those subproblems to get the final solution.\\n\\n "
                    },
                    {
                        "username": "Prakhar2909",
                        "content": "How this question uses dp, I have solved using backtracking"
                    }
                ]
            },
            {
                "id": 1573015,
                "content": [
                    {
                        "username": "billupus",
                        "content": "I got rejected because:\\n\\n    Input:\\t4\\n    Output: \\t[\"()()()()\",\"(()()())\",\"()(()())\",\"((()()))\",\"(()())()\",\"()()(())\",\"(()(()))\",\"()(())()\",\"()((()))\",\"(((())))\",\"((()))()\",\"()(())()\",\"((())())\",\"(())()()\"]\\n    Expected:   [\"(((())))\",\"((()()))\",\"((())())\",\"((()))()\",\"(()(()))\",\"(()()())\",\"(()())()\",\"(())(())\",\"(())()()\",\"()((()))\",\"()(()())\",\"()(())()\",\"()()(())\",\"()()()()\"]\\n\\nEverything (except for the order) looks fine to me? I don't think that a certain order is necessary at all."
                    },
                    {
                        "username": "fffccc",
                        "content": "I got this error, too. \"(())(())\" is not included in the answer which is weird to me."
                    },
                    {
                        "username": "fillipe",
                        "content": "Your solution allowed a duplicate for the pattern \"()(())()\". Your algorithm is not generate all patterns. \\nI found that my solution starts to fail at test case n=6 for not generating all patterns. \\nMy first solution consisted of generating patterns based on to building blocks: 1) enclose the input pattern with brackets, and if the pattern is formed of with a chain of brackets subpatterns, then generate new patterns by enclosing each brackets subpattern of the input pattern. Right after forming each of the individual patterns, as they are generated, check if they have already been seen, if not, then generate deeper derivates of the newly generated pattern until it runs out of pairs of brackets. 2) For each newly generated pattern, add a new pair of brackets to the right or to the left of the pattern. I thought this was supposed to work but it doesn\\'t solve for all possible test cases. In the end, I had to resort to the solution where patterns are formed by adding a bracket at a time, to the left or to the right."
                    },
                    {
                        "username": "mabingteng",
                        "content": "![image](https://s3-lc-upload.s3.amazonaws.com/users/mabingteng/image_1529838101.png)\\n"
                    },
                    {
                        "username": "TGBBSZWHWDLANZP",
                        "content": "[@Crispy_coffee](/Crispy_coffee) seems to be performing depth first search recursively, with one more \"(\" or \")\" depending on if its searching left or right."
                    },
                    {
                        "username": "Crispy_coffee",
                        "content": "Can you explain it please."
                    },
                    {
                        "username": "codepiyush1",
                        "content": "Logic:\\nAdd open bracket upto open is less than n given.\\nAdd close bracket upto close is less than open.\\nBy this way close bracket will never come in befor start bracket.\\ni.e )(.\\n\\nTime complexity:\\nT.C=O(2^n) used recursion.\\n\\nSpace complexity:\\nS.C=O(n)\\n------------------------\\nPlease upvote. If Understand the concept...\\nSolution Link:\\nhttps://leetcode.com/problems/generate-parentheses/solutions/3636240/c-python-java-understand-the-concept/"
                    },
                    {
                        "username": "mohmedelngar200211",
                        "content": "not accepted cuz diffierence in the order"
                    },
                    {
                        "username": "divi13",
                        "content": "There seems to be a problem with the grader.\\n\\nIt is saying this:\\n\\n**Input:\\n1\\nOutput:\\n[\"((()))\",\"(()())\",\"(())()\",\"()(())\",\"()()()\",\"()\"]\\nExpected:\\n[\"()\"]**\\n\\nBut when I run the code with input 1, I am getting the expected [\"()\"] as result. What is the problem?\\n\\n\\n"
                    },
                    {
                        "username": "leetpen",
                        "content": "reminder for people with same situation:\\nprobably because you use a global variable to store the list. The system will run test case n = 1 after n = 3, so those strings of the previous test case (n=3) are still in your list"
                    },
                    {
                        "username": "pandabearnow",
                        "content": "I have a solution that lists all the combinations but my submission fails because it is not in the order that the leetcode answer generates them. Why is that order important?"
                    },
                    {
                        "username": "ab1533489",
                        "content": "I\\'m not able to think of iterative DP solution for this problem, if you know please do share."
                    },
                    {
                        "username": "Demaxl",
                        "content": "I feel so happy that i was able to solve this problem. This is the first backtracking I solved by myself. I feel more motivated to tackle others now"
                    },
                    {
                        "username": "AnthonyR21",
                        "content": "To solve this problem, you can use a recursive approach. Here\\'s how you can approach the task and put your mind in the right direction:\\n\\n1. Base Case: Start by identifying the base case. When n is 0, there\\'s only one possible combination: an empty string.\\n\\n2. Recursive Case: For each pair of parentheses, you have two options: open a new parenthesis or close an existing open parenthesis. So, you\\'ll recursively generate combinations by trying both options for each parenthesis.\\n\\n3. Recursion with Backtracking: Use recursion to explore all possibilities. When adding an open parenthesis, decrement n by 1 to indicate that one opening parenthesis has been used. When adding a closing parenthesis, make sure there\\'s a matching open parenthesis available (meaning n hasn\\'t reached 0 yet).\\n\\n4. Build and Return the Combinations: As you explore the possibilities, build and store the combinations in a list. Once you\\'ve exhausted all possibilities for a given state, return the list of combinations.\\n\\n5. Edge Cases: Handle edge cases like if n is negative or zero, and set up the initial call to the recursive function.\\n\\nIn terms of algorithm, the key idea is to generate all possible combinations while ensuring that they\\'re well-formed parentheses. The recursive approach allows you to explore these combinations in a structured manner. Remember to think about the base case, the recursive cases, and how to build and return the combinations as you traverse the recursion tree.\\n\\nIn terms of implementation, you can create a recursive function that takes parameters such as the current combination being built, the remaining open and close parentheses, and the list to store combinations. Each recursive call will decide whether to add an open or close parenthesis, and the parameters will be updated accordingly.\\n\\nRemember that recursive problems often involve thinking about how to break down the problem into smaller, more manageable subproblems, and how to combine the results of those subproblems to get the final solution.\\n\\n "
                    },
                    {
                        "username": "Prakhar2909",
                        "content": "How this question uses dp, I have solved using backtracking"
                    }
                ]
            },
            {
                "id": 1571057,
                "content": [
                    {
                        "username": "billupus",
                        "content": "I got rejected because:\\n\\n    Input:\\t4\\n    Output: \\t[\"()()()()\",\"(()()())\",\"()(()())\",\"((()()))\",\"(()())()\",\"()()(())\",\"(()(()))\",\"()(())()\",\"()((()))\",\"(((())))\",\"((()))()\",\"()(())()\",\"((())())\",\"(())()()\"]\\n    Expected:   [\"(((())))\",\"((()()))\",\"((())())\",\"((()))()\",\"(()(()))\",\"(()()())\",\"(()())()\",\"(())(())\",\"(())()()\",\"()((()))\",\"()(()())\",\"()(())()\",\"()()(())\",\"()()()()\"]\\n\\nEverything (except for the order) looks fine to me? I don't think that a certain order is necessary at all."
                    },
                    {
                        "username": "fffccc",
                        "content": "I got this error, too. \"(())(())\" is not included in the answer which is weird to me."
                    },
                    {
                        "username": "fillipe",
                        "content": "Your solution allowed a duplicate for the pattern \"()(())()\". Your algorithm is not generate all patterns. \\nI found that my solution starts to fail at test case n=6 for not generating all patterns. \\nMy first solution consisted of generating patterns based on to building blocks: 1) enclose the input pattern with brackets, and if the pattern is formed of with a chain of brackets subpatterns, then generate new patterns by enclosing each brackets subpattern of the input pattern. Right after forming each of the individual patterns, as they are generated, check if they have already been seen, if not, then generate deeper derivates of the newly generated pattern until it runs out of pairs of brackets. 2) For each newly generated pattern, add a new pair of brackets to the right or to the left of the pattern. I thought this was supposed to work but it doesn\\'t solve for all possible test cases. In the end, I had to resort to the solution where patterns are formed by adding a bracket at a time, to the left or to the right."
                    },
                    {
                        "username": "mabingteng",
                        "content": "![image](https://s3-lc-upload.s3.amazonaws.com/users/mabingteng/image_1529838101.png)\\n"
                    },
                    {
                        "username": "TGBBSZWHWDLANZP",
                        "content": "[@Crispy_coffee](/Crispy_coffee) seems to be performing depth first search recursively, with one more \"(\" or \")\" depending on if its searching left or right."
                    },
                    {
                        "username": "Crispy_coffee",
                        "content": "Can you explain it please."
                    },
                    {
                        "username": "codepiyush1",
                        "content": "Logic:\\nAdd open bracket upto open is less than n given.\\nAdd close bracket upto close is less than open.\\nBy this way close bracket will never come in befor start bracket.\\ni.e )(.\\n\\nTime complexity:\\nT.C=O(2^n) used recursion.\\n\\nSpace complexity:\\nS.C=O(n)\\n------------------------\\nPlease upvote. If Understand the concept...\\nSolution Link:\\nhttps://leetcode.com/problems/generate-parentheses/solutions/3636240/c-python-java-understand-the-concept/"
                    },
                    {
                        "username": "mohmedelngar200211",
                        "content": "not accepted cuz diffierence in the order"
                    },
                    {
                        "username": "divi13",
                        "content": "There seems to be a problem with the grader.\\n\\nIt is saying this:\\n\\n**Input:\\n1\\nOutput:\\n[\"((()))\",\"(()())\",\"(())()\",\"()(())\",\"()()()\",\"()\"]\\nExpected:\\n[\"()\"]**\\n\\nBut when I run the code with input 1, I am getting the expected [\"()\"] as result. What is the problem?\\n\\n\\n"
                    },
                    {
                        "username": "leetpen",
                        "content": "reminder for people with same situation:\\nprobably because you use a global variable to store the list. The system will run test case n = 1 after n = 3, so those strings of the previous test case (n=3) are still in your list"
                    },
                    {
                        "username": "pandabearnow",
                        "content": "I have a solution that lists all the combinations but my submission fails because it is not in the order that the leetcode answer generates them. Why is that order important?"
                    },
                    {
                        "username": "ab1533489",
                        "content": "I\\'m not able to think of iterative DP solution for this problem, if you know please do share."
                    },
                    {
                        "username": "Demaxl",
                        "content": "I feel so happy that i was able to solve this problem. This is the first backtracking I solved by myself. I feel more motivated to tackle others now"
                    },
                    {
                        "username": "AnthonyR21",
                        "content": "To solve this problem, you can use a recursive approach. Here\\'s how you can approach the task and put your mind in the right direction:\\n\\n1. Base Case: Start by identifying the base case. When n is 0, there\\'s only one possible combination: an empty string.\\n\\n2. Recursive Case: For each pair of parentheses, you have two options: open a new parenthesis or close an existing open parenthesis. So, you\\'ll recursively generate combinations by trying both options for each parenthesis.\\n\\n3. Recursion with Backtracking: Use recursion to explore all possibilities. When adding an open parenthesis, decrement n by 1 to indicate that one opening parenthesis has been used. When adding a closing parenthesis, make sure there\\'s a matching open parenthesis available (meaning n hasn\\'t reached 0 yet).\\n\\n4. Build and Return the Combinations: As you explore the possibilities, build and store the combinations in a list. Once you\\'ve exhausted all possibilities for a given state, return the list of combinations.\\n\\n5. Edge Cases: Handle edge cases like if n is negative or zero, and set up the initial call to the recursive function.\\n\\nIn terms of algorithm, the key idea is to generate all possible combinations while ensuring that they\\'re well-formed parentheses. The recursive approach allows you to explore these combinations in a structured manner. Remember to think about the base case, the recursive cases, and how to build and return the combinations as you traverse the recursion tree.\\n\\nIn terms of implementation, you can create a recursive function that takes parameters such as the current combination being built, the remaining open and close parentheses, and the list to store combinations. Each recursive call will decide whether to add an open or close parenthesis, and the parameters will be updated accordingly.\\n\\nRemember that recursive problems often involve thinking about how to break down the problem into smaller, more manageable subproblems, and how to combine the results of those subproblems to get the final solution.\\n\\n "
                    },
                    {
                        "username": "Prakhar2909",
                        "content": "How this question uses dp, I have solved using backtracking"
                    }
                ]
            },
            {
                "id": 1576172,
                "content": [
                    {
                        "username": "billupus",
                        "content": "I got rejected because:\\n\\n    Input:\\t4\\n    Output: \\t[\"()()()()\",\"(()()())\",\"()(()())\",\"((()()))\",\"(()())()\",\"()()(())\",\"(()(()))\",\"()(())()\",\"()((()))\",\"(((())))\",\"((()))()\",\"()(())()\",\"((())())\",\"(())()()\"]\\n    Expected:   [\"(((())))\",\"((()()))\",\"((())())\",\"((()))()\",\"(()(()))\",\"(()()())\",\"(()())()\",\"(())(())\",\"(())()()\",\"()((()))\",\"()(()())\",\"()(())()\",\"()()(())\",\"()()()()\"]\\n\\nEverything (except for the order) looks fine to me? I don't think that a certain order is necessary at all."
                    },
                    {
                        "username": "fffccc",
                        "content": "I got this error, too. \"(())(())\" is not included in the answer which is weird to me."
                    },
                    {
                        "username": "fillipe",
                        "content": "Your solution allowed a duplicate for the pattern \"()(())()\". Your algorithm is not generate all patterns. \\nI found that my solution starts to fail at test case n=6 for not generating all patterns. \\nMy first solution consisted of generating patterns based on to building blocks: 1) enclose the input pattern with brackets, and if the pattern is formed of with a chain of brackets subpatterns, then generate new patterns by enclosing each brackets subpattern of the input pattern. Right after forming each of the individual patterns, as they are generated, check if they have already been seen, if not, then generate deeper derivates of the newly generated pattern until it runs out of pairs of brackets. 2) For each newly generated pattern, add a new pair of brackets to the right or to the left of the pattern. I thought this was supposed to work but it doesn\\'t solve for all possible test cases. In the end, I had to resort to the solution where patterns are formed by adding a bracket at a time, to the left or to the right."
                    },
                    {
                        "username": "mabingteng",
                        "content": "![image](https://s3-lc-upload.s3.amazonaws.com/users/mabingteng/image_1529838101.png)\\n"
                    },
                    {
                        "username": "TGBBSZWHWDLANZP",
                        "content": "[@Crispy_coffee](/Crispy_coffee) seems to be performing depth first search recursively, with one more \"(\" or \")\" depending on if its searching left or right."
                    },
                    {
                        "username": "Crispy_coffee",
                        "content": "Can you explain it please."
                    },
                    {
                        "username": "codepiyush1",
                        "content": "Logic:\\nAdd open bracket upto open is less than n given.\\nAdd close bracket upto close is less than open.\\nBy this way close bracket will never come in befor start bracket.\\ni.e )(.\\n\\nTime complexity:\\nT.C=O(2^n) used recursion.\\n\\nSpace complexity:\\nS.C=O(n)\\n------------------------\\nPlease upvote. If Understand the concept...\\nSolution Link:\\nhttps://leetcode.com/problems/generate-parentheses/solutions/3636240/c-python-java-understand-the-concept/"
                    },
                    {
                        "username": "mohmedelngar200211",
                        "content": "not accepted cuz diffierence in the order"
                    },
                    {
                        "username": "divi13",
                        "content": "There seems to be a problem with the grader.\\n\\nIt is saying this:\\n\\n**Input:\\n1\\nOutput:\\n[\"((()))\",\"(()())\",\"(())()\",\"()(())\",\"()()()\",\"()\"]\\nExpected:\\n[\"()\"]**\\n\\nBut when I run the code with input 1, I am getting the expected [\"()\"] as result. What is the problem?\\n\\n\\n"
                    },
                    {
                        "username": "leetpen",
                        "content": "reminder for people with same situation:\\nprobably because you use a global variable to store the list. The system will run test case n = 1 after n = 3, so those strings of the previous test case (n=3) are still in your list"
                    },
                    {
                        "username": "pandabearnow",
                        "content": "I have a solution that lists all the combinations but my submission fails because it is not in the order that the leetcode answer generates them. Why is that order important?"
                    },
                    {
                        "username": "ab1533489",
                        "content": "I\\'m not able to think of iterative DP solution for this problem, if you know please do share."
                    },
                    {
                        "username": "Demaxl",
                        "content": "I feel so happy that i was able to solve this problem. This is the first backtracking I solved by myself. I feel more motivated to tackle others now"
                    },
                    {
                        "username": "AnthonyR21",
                        "content": "To solve this problem, you can use a recursive approach. Here\\'s how you can approach the task and put your mind in the right direction:\\n\\n1. Base Case: Start by identifying the base case. When n is 0, there\\'s only one possible combination: an empty string.\\n\\n2. Recursive Case: For each pair of parentheses, you have two options: open a new parenthesis or close an existing open parenthesis. So, you\\'ll recursively generate combinations by trying both options for each parenthesis.\\n\\n3. Recursion with Backtracking: Use recursion to explore all possibilities. When adding an open parenthesis, decrement n by 1 to indicate that one opening parenthesis has been used. When adding a closing parenthesis, make sure there\\'s a matching open parenthesis available (meaning n hasn\\'t reached 0 yet).\\n\\n4. Build and Return the Combinations: As you explore the possibilities, build and store the combinations in a list. Once you\\'ve exhausted all possibilities for a given state, return the list of combinations.\\n\\n5. Edge Cases: Handle edge cases like if n is negative or zero, and set up the initial call to the recursive function.\\n\\nIn terms of algorithm, the key idea is to generate all possible combinations while ensuring that they\\'re well-formed parentheses. The recursive approach allows you to explore these combinations in a structured manner. Remember to think about the base case, the recursive cases, and how to build and return the combinations as you traverse the recursion tree.\\n\\nIn terms of implementation, you can create a recursive function that takes parameters such as the current combination being built, the remaining open and close parentheses, and the list to store combinations. Each recursive call will decide whether to add an open or close parenthesis, and the parameters will be updated accordingly.\\n\\nRemember that recursive problems often involve thinking about how to break down the problem into smaller, more manageable subproblems, and how to combine the results of those subproblems to get the final solution.\\n\\n "
                    },
                    {
                        "username": "Prakhar2909",
                        "content": "How this question uses dp, I have solved using backtracking"
                    }
                ]
            },
            {
                "id": 2053376,
                "content": [
                    {
                        "username": "billupus",
                        "content": "I got rejected because:\\n\\n    Input:\\t4\\n    Output: \\t[\"()()()()\",\"(()()())\",\"()(()())\",\"((()()))\",\"(()())()\",\"()()(())\",\"(()(()))\",\"()(())()\",\"()((()))\",\"(((())))\",\"((()))()\",\"()(())()\",\"((())())\",\"(())()()\"]\\n    Expected:   [\"(((())))\",\"((()()))\",\"((())())\",\"((()))()\",\"(()(()))\",\"(()()())\",\"(()())()\",\"(())(())\",\"(())()()\",\"()((()))\",\"()(()())\",\"()(())()\",\"()()(())\",\"()()()()\"]\\n\\nEverything (except for the order) looks fine to me? I don't think that a certain order is necessary at all."
                    },
                    {
                        "username": "fffccc",
                        "content": "I got this error, too. \"(())(())\" is not included in the answer which is weird to me."
                    },
                    {
                        "username": "fillipe",
                        "content": "Your solution allowed a duplicate for the pattern \"()(())()\". Your algorithm is not generate all patterns. \\nI found that my solution starts to fail at test case n=6 for not generating all patterns. \\nMy first solution consisted of generating patterns based on to building blocks: 1) enclose the input pattern with brackets, and if the pattern is formed of with a chain of brackets subpatterns, then generate new patterns by enclosing each brackets subpattern of the input pattern. Right after forming each of the individual patterns, as they are generated, check if they have already been seen, if not, then generate deeper derivates of the newly generated pattern until it runs out of pairs of brackets. 2) For each newly generated pattern, add a new pair of brackets to the right or to the left of the pattern. I thought this was supposed to work but it doesn\\'t solve for all possible test cases. In the end, I had to resort to the solution where patterns are formed by adding a bracket at a time, to the left or to the right."
                    },
                    {
                        "username": "mabingteng",
                        "content": "![image](https://s3-lc-upload.s3.amazonaws.com/users/mabingteng/image_1529838101.png)\\n"
                    },
                    {
                        "username": "TGBBSZWHWDLANZP",
                        "content": "[@Crispy_coffee](/Crispy_coffee) seems to be performing depth first search recursively, with one more \"(\" or \")\" depending on if its searching left or right."
                    },
                    {
                        "username": "Crispy_coffee",
                        "content": "Can you explain it please."
                    },
                    {
                        "username": "codepiyush1",
                        "content": "Logic:\\nAdd open bracket upto open is less than n given.\\nAdd close bracket upto close is less than open.\\nBy this way close bracket will never come in befor start bracket.\\ni.e )(.\\n\\nTime complexity:\\nT.C=O(2^n) used recursion.\\n\\nSpace complexity:\\nS.C=O(n)\\n------------------------\\nPlease upvote. If Understand the concept...\\nSolution Link:\\nhttps://leetcode.com/problems/generate-parentheses/solutions/3636240/c-python-java-understand-the-concept/"
                    },
                    {
                        "username": "mohmedelngar200211",
                        "content": "not accepted cuz diffierence in the order"
                    },
                    {
                        "username": "divi13",
                        "content": "There seems to be a problem with the grader.\\n\\nIt is saying this:\\n\\n**Input:\\n1\\nOutput:\\n[\"((()))\",\"(()())\",\"(())()\",\"()(())\",\"()()()\",\"()\"]\\nExpected:\\n[\"()\"]**\\n\\nBut when I run the code with input 1, I am getting the expected [\"()\"] as result. What is the problem?\\n\\n\\n"
                    },
                    {
                        "username": "leetpen",
                        "content": "reminder for people with same situation:\\nprobably because you use a global variable to store the list. The system will run test case n = 1 after n = 3, so those strings of the previous test case (n=3) are still in your list"
                    },
                    {
                        "username": "pandabearnow",
                        "content": "I have a solution that lists all the combinations but my submission fails because it is not in the order that the leetcode answer generates them. Why is that order important?"
                    },
                    {
                        "username": "ab1533489",
                        "content": "I\\'m not able to think of iterative DP solution for this problem, if you know please do share."
                    },
                    {
                        "username": "Demaxl",
                        "content": "I feel so happy that i was able to solve this problem. This is the first backtracking I solved by myself. I feel more motivated to tackle others now"
                    },
                    {
                        "username": "AnthonyR21",
                        "content": "To solve this problem, you can use a recursive approach. Here\\'s how you can approach the task and put your mind in the right direction:\\n\\n1. Base Case: Start by identifying the base case. When n is 0, there\\'s only one possible combination: an empty string.\\n\\n2. Recursive Case: For each pair of parentheses, you have two options: open a new parenthesis or close an existing open parenthesis. So, you\\'ll recursively generate combinations by trying both options for each parenthesis.\\n\\n3. Recursion with Backtracking: Use recursion to explore all possibilities. When adding an open parenthesis, decrement n by 1 to indicate that one opening parenthesis has been used. When adding a closing parenthesis, make sure there\\'s a matching open parenthesis available (meaning n hasn\\'t reached 0 yet).\\n\\n4. Build and Return the Combinations: As you explore the possibilities, build and store the combinations in a list. Once you\\'ve exhausted all possibilities for a given state, return the list of combinations.\\n\\n5. Edge Cases: Handle edge cases like if n is negative or zero, and set up the initial call to the recursive function.\\n\\nIn terms of algorithm, the key idea is to generate all possible combinations while ensuring that they\\'re well-formed parentheses. The recursive approach allows you to explore these combinations in a structured manner. Remember to think about the base case, the recursive cases, and how to build and return the combinations as you traverse the recursion tree.\\n\\nIn terms of implementation, you can create a recursive function that takes parameters such as the current combination being built, the remaining open and close parentheses, and the list to store combinations. Each recursive call will decide whether to add an open or close parenthesis, and the parameters will be updated accordingly.\\n\\nRemember that recursive problems often involve thinking about how to break down the problem into smaller, more manageable subproblems, and how to combine the results of those subproblems to get the final solution.\\n\\n "
                    },
                    {
                        "username": "Prakhar2909",
                        "content": "How this question uses dp, I have solved using backtracking"
                    }
                ]
            },
            {
                "id": 2037019,
                "content": [
                    {
                        "username": "billupus",
                        "content": "I got rejected because:\\n\\n    Input:\\t4\\n    Output: \\t[\"()()()()\",\"(()()())\",\"()(()())\",\"((()()))\",\"(()())()\",\"()()(())\",\"(()(()))\",\"()(())()\",\"()((()))\",\"(((())))\",\"((()))()\",\"()(())()\",\"((())())\",\"(())()()\"]\\n    Expected:   [\"(((())))\",\"((()()))\",\"((())())\",\"((()))()\",\"(()(()))\",\"(()()())\",\"(()())()\",\"(())(())\",\"(())()()\",\"()((()))\",\"()(()())\",\"()(())()\",\"()()(())\",\"()()()()\"]\\n\\nEverything (except for the order) looks fine to me? I don't think that a certain order is necessary at all."
                    },
                    {
                        "username": "fffccc",
                        "content": "I got this error, too. \"(())(())\" is not included in the answer which is weird to me."
                    },
                    {
                        "username": "fillipe",
                        "content": "Your solution allowed a duplicate for the pattern \"()(())()\". Your algorithm is not generate all patterns. \\nI found that my solution starts to fail at test case n=6 for not generating all patterns. \\nMy first solution consisted of generating patterns based on to building blocks: 1) enclose the input pattern with brackets, and if the pattern is formed of with a chain of brackets subpatterns, then generate new patterns by enclosing each brackets subpattern of the input pattern. Right after forming each of the individual patterns, as they are generated, check if they have already been seen, if not, then generate deeper derivates of the newly generated pattern until it runs out of pairs of brackets. 2) For each newly generated pattern, add a new pair of brackets to the right or to the left of the pattern. I thought this was supposed to work but it doesn\\'t solve for all possible test cases. In the end, I had to resort to the solution where patterns are formed by adding a bracket at a time, to the left or to the right."
                    },
                    {
                        "username": "mabingteng",
                        "content": "![image](https://s3-lc-upload.s3.amazonaws.com/users/mabingteng/image_1529838101.png)\\n"
                    },
                    {
                        "username": "TGBBSZWHWDLANZP",
                        "content": "[@Crispy_coffee](/Crispy_coffee) seems to be performing depth first search recursively, with one more \"(\" or \")\" depending on if its searching left or right."
                    },
                    {
                        "username": "Crispy_coffee",
                        "content": "Can you explain it please."
                    },
                    {
                        "username": "codepiyush1",
                        "content": "Logic:\\nAdd open bracket upto open is less than n given.\\nAdd close bracket upto close is less than open.\\nBy this way close bracket will never come in befor start bracket.\\ni.e )(.\\n\\nTime complexity:\\nT.C=O(2^n) used recursion.\\n\\nSpace complexity:\\nS.C=O(n)\\n------------------------\\nPlease upvote. If Understand the concept...\\nSolution Link:\\nhttps://leetcode.com/problems/generate-parentheses/solutions/3636240/c-python-java-understand-the-concept/"
                    },
                    {
                        "username": "mohmedelngar200211",
                        "content": "not accepted cuz diffierence in the order"
                    },
                    {
                        "username": "divi13",
                        "content": "There seems to be a problem with the grader.\\n\\nIt is saying this:\\n\\n**Input:\\n1\\nOutput:\\n[\"((()))\",\"(()())\",\"(())()\",\"()(())\",\"()()()\",\"()\"]\\nExpected:\\n[\"()\"]**\\n\\nBut when I run the code with input 1, I am getting the expected [\"()\"] as result. What is the problem?\\n\\n\\n"
                    },
                    {
                        "username": "leetpen",
                        "content": "reminder for people with same situation:\\nprobably because you use a global variable to store the list. The system will run test case n = 1 after n = 3, so those strings of the previous test case (n=3) are still in your list"
                    },
                    {
                        "username": "pandabearnow",
                        "content": "I have a solution that lists all the combinations but my submission fails because it is not in the order that the leetcode answer generates them. Why is that order important?"
                    },
                    {
                        "username": "ab1533489",
                        "content": "I\\'m not able to think of iterative DP solution for this problem, if you know please do share."
                    },
                    {
                        "username": "Demaxl",
                        "content": "I feel so happy that i was able to solve this problem. This is the first backtracking I solved by myself. I feel more motivated to tackle others now"
                    },
                    {
                        "username": "AnthonyR21",
                        "content": "To solve this problem, you can use a recursive approach. Here\\'s how you can approach the task and put your mind in the right direction:\\n\\n1. Base Case: Start by identifying the base case. When n is 0, there\\'s only one possible combination: an empty string.\\n\\n2. Recursive Case: For each pair of parentheses, you have two options: open a new parenthesis or close an existing open parenthesis. So, you\\'ll recursively generate combinations by trying both options for each parenthesis.\\n\\n3. Recursion with Backtracking: Use recursion to explore all possibilities. When adding an open parenthesis, decrement n by 1 to indicate that one opening parenthesis has been used. When adding a closing parenthesis, make sure there\\'s a matching open parenthesis available (meaning n hasn\\'t reached 0 yet).\\n\\n4. Build and Return the Combinations: As you explore the possibilities, build and store the combinations in a list. Once you\\'ve exhausted all possibilities for a given state, return the list of combinations.\\n\\n5. Edge Cases: Handle edge cases like if n is negative or zero, and set up the initial call to the recursive function.\\n\\nIn terms of algorithm, the key idea is to generate all possible combinations while ensuring that they\\'re well-formed parentheses. The recursive approach allows you to explore these combinations in a structured manner. Remember to think about the base case, the recursive cases, and how to build and return the combinations as you traverse the recursion tree.\\n\\nIn terms of implementation, you can create a recursive function that takes parameters such as the current combination being built, the remaining open and close parentheses, and the list to store combinations. Each recursive call will decide whether to add an open or close parenthesis, and the parameters will be updated accordingly.\\n\\nRemember that recursive problems often involve thinking about how to break down the problem into smaller, more manageable subproblems, and how to combine the results of those subproblems to get the final solution.\\n\\n "
                    },
                    {
                        "username": "Prakhar2909",
                        "content": "How this question uses dp, I have solved using backtracking"
                    }
                ]
            },
            {
                "id": 1983146,
                "content": [
                    {
                        "username": "billupus",
                        "content": "I got rejected because:\\n\\n    Input:\\t4\\n    Output: \\t[\"()()()()\",\"(()()())\",\"()(()())\",\"((()()))\",\"(()())()\",\"()()(())\",\"(()(()))\",\"()(())()\",\"()((()))\",\"(((())))\",\"((()))()\",\"()(())()\",\"((())())\",\"(())()()\"]\\n    Expected:   [\"(((())))\",\"((()()))\",\"((())())\",\"((()))()\",\"(()(()))\",\"(()()())\",\"(()())()\",\"(())(())\",\"(())()()\",\"()((()))\",\"()(()())\",\"()(())()\",\"()()(())\",\"()()()()\"]\\n\\nEverything (except for the order) looks fine to me? I don't think that a certain order is necessary at all."
                    },
                    {
                        "username": "fffccc",
                        "content": "I got this error, too. \"(())(())\" is not included in the answer which is weird to me."
                    },
                    {
                        "username": "fillipe",
                        "content": "Your solution allowed a duplicate for the pattern \"()(())()\". Your algorithm is not generate all patterns. \\nI found that my solution starts to fail at test case n=6 for not generating all patterns. \\nMy first solution consisted of generating patterns based on to building blocks: 1) enclose the input pattern with brackets, and if the pattern is formed of with a chain of brackets subpatterns, then generate new patterns by enclosing each brackets subpattern of the input pattern. Right after forming each of the individual patterns, as they are generated, check if they have already been seen, if not, then generate deeper derivates of the newly generated pattern until it runs out of pairs of brackets. 2) For each newly generated pattern, add a new pair of brackets to the right or to the left of the pattern. I thought this was supposed to work but it doesn\\'t solve for all possible test cases. In the end, I had to resort to the solution where patterns are formed by adding a bracket at a time, to the left or to the right."
                    },
                    {
                        "username": "mabingteng",
                        "content": "![image](https://s3-lc-upload.s3.amazonaws.com/users/mabingteng/image_1529838101.png)\\n"
                    },
                    {
                        "username": "TGBBSZWHWDLANZP",
                        "content": "[@Crispy_coffee](/Crispy_coffee) seems to be performing depth first search recursively, with one more \"(\" or \")\" depending on if its searching left or right."
                    },
                    {
                        "username": "Crispy_coffee",
                        "content": "Can you explain it please."
                    },
                    {
                        "username": "codepiyush1",
                        "content": "Logic:\\nAdd open bracket upto open is less than n given.\\nAdd close bracket upto close is less than open.\\nBy this way close bracket will never come in befor start bracket.\\ni.e )(.\\n\\nTime complexity:\\nT.C=O(2^n) used recursion.\\n\\nSpace complexity:\\nS.C=O(n)\\n------------------------\\nPlease upvote. If Understand the concept...\\nSolution Link:\\nhttps://leetcode.com/problems/generate-parentheses/solutions/3636240/c-python-java-understand-the-concept/"
                    },
                    {
                        "username": "mohmedelngar200211",
                        "content": "not accepted cuz diffierence in the order"
                    },
                    {
                        "username": "divi13",
                        "content": "There seems to be a problem with the grader.\\n\\nIt is saying this:\\n\\n**Input:\\n1\\nOutput:\\n[\"((()))\",\"(()())\",\"(())()\",\"()(())\",\"()()()\",\"()\"]\\nExpected:\\n[\"()\"]**\\n\\nBut when I run the code with input 1, I am getting the expected [\"()\"] as result. What is the problem?\\n\\n\\n"
                    },
                    {
                        "username": "leetpen",
                        "content": "reminder for people with same situation:\\nprobably because you use a global variable to store the list. The system will run test case n = 1 after n = 3, so those strings of the previous test case (n=3) are still in your list"
                    },
                    {
                        "username": "pandabearnow",
                        "content": "I have a solution that lists all the combinations but my submission fails because it is not in the order that the leetcode answer generates them. Why is that order important?"
                    },
                    {
                        "username": "ab1533489",
                        "content": "I\\'m not able to think of iterative DP solution for this problem, if you know please do share."
                    },
                    {
                        "username": "Demaxl",
                        "content": "I feel so happy that i was able to solve this problem. This is the first backtracking I solved by myself. I feel more motivated to tackle others now"
                    },
                    {
                        "username": "AnthonyR21",
                        "content": "To solve this problem, you can use a recursive approach. Here\\'s how you can approach the task and put your mind in the right direction:\\n\\n1. Base Case: Start by identifying the base case. When n is 0, there\\'s only one possible combination: an empty string.\\n\\n2. Recursive Case: For each pair of parentheses, you have two options: open a new parenthesis or close an existing open parenthesis. So, you\\'ll recursively generate combinations by trying both options for each parenthesis.\\n\\n3. Recursion with Backtracking: Use recursion to explore all possibilities. When adding an open parenthesis, decrement n by 1 to indicate that one opening parenthesis has been used. When adding a closing parenthesis, make sure there\\'s a matching open parenthesis available (meaning n hasn\\'t reached 0 yet).\\n\\n4. Build and Return the Combinations: As you explore the possibilities, build and store the combinations in a list. Once you\\'ve exhausted all possibilities for a given state, return the list of combinations.\\n\\n5. Edge Cases: Handle edge cases like if n is negative or zero, and set up the initial call to the recursive function.\\n\\nIn terms of algorithm, the key idea is to generate all possible combinations while ensuring that they\\'re well-formed parentheses. The recursive approach allows you to explore these combinations in a structured manner. Remember to think about the base case, the recursive cases, and how to build and return the combinations as you traverse the recursion tree.\\n\\nIn terms of implementation, you can create a recursive function that takes parameters such as the current combination being built, the remaining open and close parentheses, and the list to store combinations. Each recursive call will decide whether to add an open or close parenthesis, and the parameters will be updated accordingly.\\n\\nRemember that recursive problems often involve thinking about how to break down the problem into smaller, more manageable subproblems, and how to combine the results of those subproblems to get the final solution.\\n\\n "
                    },
                    {
                        "username": "Prakhar2909",
                        "content": "How this question uses dp, I have solved using backtracking"
                    }
                ]
            },
            {
                "id": 1963949,
                "content": [
                    {
                        "username": "Dhruv_Khanna123",
                        "content": "classic backtracking"
                    },
                    {
                        "username": "jayantee_12",
                        "content": "Does order of solution matter in this problem?"
                    },
                    {
                        "username": "Naumel",
                        "content": "The code works on my machine, but something seems wrongly cached in the browser (as in the result I get from a local run is different than the result from here). Is this some known behaviour? "
                    },
                    {
                        "username": "easycheese",
                        "content": "# Very simple python\\n\\nInsert \"()\" between each character for each i to n \\n\\n```python\\ndef generateParenthesis(self, n: int):\\n        aws = {\"()\"}\\n        for _ in range(n-1):\\n            tmp = set()\\n            for j in aws:\\n                for k in range(len(j)+1):\\n                    tmp.add(j[:k]+\"()\"+j[k:])\\n            aws = tmp\\n        return [i for i in aws]\\n"
                    },
                    {
                        "username": "rajanpupa",
                        "content": "I saw some backtracking algorithm so solve this problem. What is the runtime complexity of the algorithm?"
                    },
                    {
                        "username": "Hoaibao_21520628",
                        "content": "My code is wrong on `n = 4` and I don\\'t know why? Help me pls!\\n```\\nvoid solver(int n, string str, vector<string> &answer, map<string, bool> &check)\\n    {\\n        if(n == 0)\\n        {\\n            if(check[str] == false)\\n            {\\n                answer.push_back(str);\\n                check[str] = true;\\n            }\\n            else\\n                return;\\n        }\\n        else\\n        {\\n            solver(n-1, \"(\" + str + \")\", answer, check);\\n            solver(n-1, str + \"()\", answer, check);\\n            solver(n-1, \"()\" + str, answer, check);\\n            \\n        }\\n    }\\n```"
                    },
                    {
                        "username": "adi29raj",
                        "content": "I was also doing something similar..let me know if you were able to solve llike this,"
                    },
                    {
                        "username": "SleepNotFound",
                        "content": "it would be missing \"(())(())\""
                    },
                    {
                        "username": "ahcox",
                        "content": "Let\\'s compare timings for the largest problem size that Leetcode will accept (**`11`**). Instructions to take part:\\n1. Go to test cases.\\n1. Delete everything.\\n1. Type `11` in there\\n1. Hit the \\'Run Code\\' button. (repeat a few time to get the best result)\\n1. Add your number as a comment here.\\n\\nMention your language and implementation approach if you like. This is just for fun! :-D\\n"
                    },
                    {
                        "username": "securityma",
                        "content": "Who can tell me the difference of add1 inside of the funtion of dfs  and add1 outside of the function\\n   if(m1<n){\\n       // m1++;\\n       // tmp+=\\'(\\';\\n        dfs(ans,n,m1+1,m2,tmp+\\'(\\');\\n    }\\n    if(m2<m1){\\n   // tmp+=\\')\\';\\n   //m2+=1;\\n    dfs(ans,n,m1,m2+1,tmp+\\')\\');}\\nIt\\'s completely different answer.I\\'ll appreciate it for your answer.  "
                    },
                    {
                        "username": "29ayush",
                        "content": "Consider below 2 codes:\\n\\nIn Code1, I use local vector for a test case, and in case 2 I use a global vector, leet code says 2 code is slower why ?\\n\\nCode1\\nclass Solution {\\npublic:\\n\\n    void refgen(string &s, int open, int close, vector<string> &allPara) {\\n        if (close == 0) {\\n            allPara.push_back(s);\\n        }\\n        if (open > 0 ) {\\n            s.push_back(\\'(\\');\\n            refgen(s, open - 1, close, allPara);\\n            s.pop_back();\\n        }\\n\\n        if (close > open) {\\n            s.push_back(\\')\\');\\n            refgen(s, open, close - 1, allPara);\\n            s.pop_back();\\n        }\\n    }\\n\\n    vector<string> generateParenthesis(int n) {\\n        vector<string> newVec;\\n        string s = \"\";\\n        refgen(s, n, n, newVec);\\n        return newVec;\\n    }\\n};\\n\\nCode 2:\\nclass Solution {\\npublic:\\n\\n    vector<string> allPara;\\n    string s;\\n    void refgen(int open, int close)  {\\n        if (close == 0) {\\n            allPara.push_back(s);\\n        }\\n        if (open > 0 ) {\\n            s.push_back(\\'(\\');\\n            refgen(open - 1, close);\\n            s.pop_back();\\n        }\\n\\n        if (close > open) {\\n            s.push_back(\\')\\');\\n            refgen(open, close - 1);\\n            s.pop_back();\\n        }\\n    }\\n\\n    vector<string> generateParenthesis(int n) {\\n        refgen(n, n);\\n        return allPara;\\n    }\\n};\\n\\n\\n\\n"
                    },
                    {
                        "username": "imguptaharsh",
                        "content": "count left \"(\" and right \")\" if count of left is less than \"n\" add \"(\" and also if  count \"(\" > \")\"  add \")\" or else if right< n add \")\",\nadd string to ans vector if sizeof string == 2*n"
                    }
                ]
            },
            {
                "id": 1901261,
                "content": [
                    {
                        "username": "Dhruv_Khanna123",
                        "content": "classic backtracking"
                    },
                    {
                        "username": "jayantee_12",
                        "content": "Does order of solution matter in this problem?"
                    },
                    {
                        "username": "Naumel",
                        "content": "The code works on my machine, but something seems wrongly cached in the browser (as in the result I get from a local run is different than the result from here). Is this some known behaviour? "
                    },
                    {
                        "username": "easycheese",
                        "content": "# Very simple python\\n\\nInsert \"()\" between each character for each i to n \\n\\n```python\\ndef generateParenthesis(self, n: int):\\n        aws = {\"()\"}\\n        for _ in range(n-1):\\n            tmp = set()\\n            for j in aws:\\n                for k in range(len(j)+1):\\n                    tmp.add(j[:k]+\"()\"+j[k:])\\n            aws = tmp\\n        return [i for i in aws]\\n"
                    },
                    {
                        "username": "rajanpupa",
                        "content": "I saw some backtracking algorithm so solve this problem. What is the runtime complexity of the algorithm?"
                    },
                    {
                        "username": "Hoaibao_21520628",
                        "content": "My code is wrong on `n = 4` and I don\\'t know why? Help me pls!\\n```\\nvoid solver(int n, string str, vector<string> &answer, map<string, bool> &check)\\n    {\\n        if(n == 0)\\n        {\\n            if(check[str] == false)\\n            {\\n                answer.push_back(str);\\n                check[str] = true;\\n            }\\n            else\\n                return;\\n        }\\n        else\\n        {\\n            solver(n-1, \"(\" + str + \")\", answer, check);\\n            solver(n-1, str + \"()\", answer, check);\\n            solver(n-1, \"()\" + str, answer, check);\\n            \\n        }\\n    }\\n```"
                    },
                    {
                        "username": "adi29raj",
                        "content": "I was also doing something similar..let me know if you were able to solve llike this,"
                    },
                    {
                        "username": "SleepNotFound",
                        "content": "it would be missing \"(())(())\""
                    },
                    {
                        "username": "ahcox",
                        "content": "Let\\'s compare timings for the largest problem size that Leetcode will accept (**`11`**). Instructions to take part:\\n1. Go to test cases.\\n1. Delete everything.\\n1. Type `11` in there\\n1. Hit the \\'Run Code\\' button. (repeat a few time to get the best result)\\n1. Add your number as a comment here.\\n\\nMention your language and implementation approach if you like. This is just for fun! :-D\\n"
                    },
                    {
                        "username": "securityma",
                        "content": "Who can tell me the difference of add1 inside of the funtion of dfs  and add1 outside of the function\\n   if(m1<n){\\n       // m1++;\\n       // tmp+=\\'(\\';\\n        dfs(ans,n,m1+1,m2,tmp+\\'(\\');\\n    }\\n    if(m2<m1){\\n   // tmp+=\\')\\';\\n   //m2+=1;\\n    dfs(ans,n,m1,m2+1,tmp+\\')\\');}\\nIt\\'s completely different answer.I\\'ll appreciate it for your answer.  "
                    },
                    {
                        "username": "29ayush",
                        "content": "Consider below 2 codes:\\n\\nIn Code1, I use local vector for a test case, and in case 2 I use a global vector, leet code says 2 code is slower why ?\\n\\nCode1\\nclass Solution {\\npublic:\\n\\n    void refgen(string &s, int open, int close, vector<string> &allPara) {\\n        if (close == 0) {\\n            allPara.push_back(s);\\n        }\\n        if (open > 0 ) {\\n            s.push_back(\\'(\\');\\n            refgen(s, open - 1, close, allPara);\\n            s.pop_back();\\n        }\\n\\n        if (close > open) {\\n            s.push_back(\\')\\');\\n            refgen(s, open, close - 1, allPara);\\n            s.pop_back();\\n        }\\n    }\\n\\n    vector<string> generateParenthesis(int n) {\\n        vector<string> newVec;\\n        string s = \"\";\\n        refgen(s, n, n, newVec);\\n        return newVec;\\n    }\\n};\\n\\nCode 2:\\nclass Solution {\\npublic:\\n\\n    vector<string> allPara;\\n    string s;\\n    void refgen(int open, int close)  {\\n        if (close == 0) {\\n            allPara.push_back(s);\\n        }\\n        if (open > 0 ) {\\n            s.push_back(\\'(\\');\\n            refgen(open - 1, close);\\n            s.pop_back();\\n        }\\n\\n        if (close > open) {\\n            s.push_back(\\')\\');\\n            refgen(open, close - 1);\\n            s.pop_back();\\n        }\\n    }\\n\\n    vector<string> generateParenthesis(int n) {\\n        refgen(n, n);\\n        return allPara;\\n    }\\n};\\n\\n\\n\\n"
                    },
                    {
                        "username": "imguptaharsh",
                        "content": "count left \"(\" and right \")\" if count of left is less than \"n\" add \"(\" and also if  count \"(\" > \")\"  add \")\" or else if right< n add \")\",\nadd string to ans vector if sizeof string == 2*n"
                    }
                ]
            },
            {
                "id": 1861473,
                "content": [
                    {
                        "username": "Dhruv_Khanna123",
                        "content": "classic backtracking"
                    },
                    {
                        "username": "jayantee_12",
                        "content": "Does order of solution matter in this problem?"
                    },
                    {
                        "username": "Naumel",
                        "content": "The code works on my machine, but something seems wrongly cached in the browser (as in the result I get from a local run is different than the result from here). Is this some known behaviour? "
                    },
                    {
                        "username": "easycheese",
                        "content": "# Very simple python\\n\\nInsert \"()\" between each character for each i to n \\n\\n```python\\ndef generateParenthesis(self, n: int):\\n        aws = {\"()\"}\\n        for _ in range(n-1):\\n            tmp = set()\\n            for j in aws:\\n                for k in range(len(j)+1):\\n                    tmp.add(j[:k]+\"()\"+j[k:])\\n            aws = tmp\\n        return [i for i in aws]\\n"
                    },
                    {
                        "username": "rajanpupa",
                        "content": "I saw some backtracking algorithm so solve this problem. What is the runtime complexity of the algorithm?"
                    },
                    {
                        "username": "Hoaibao_21520628",
                        "content": "My code is wrong on `n = 4` and I don\\'t know why? Help me pls!\\n```\\nvoid solver(int n, string str, vector<string> &answer, map<string, bool> &check)\\n    {\\n        if(n == 0)\\n        {\\n            if(check[str] == false)\\n            {\\n                answer.push_back(str);\\n                check[str] = true;\\n            }\\n            else\\n                return;\\n        }\\n        else\\n        {\\n            solver(n-1, \"(\" + str + \")\", answer, check);\\n            solver(n-1, str + \"()\", answer, check);\\n            solver(n-1, \"()\" + str, answer, check);\\n            \\n        }\\n    }\\n```"
                    },
                    {
                        "username": "adi29raj",
                        "content": "I was also doing something similar..let me know if you were able to solve llike this,"
                    },
                    {
                        "username": "SleepNotFound",
                        "content": "it would be missing \"(())(())\""
                    },
                    {
                        "username": "ahcox",
                        "content": "Let\\'s compare timings for the largest problem size that Leetcode will accept (**`11`**). Instructions to take part:\\n1. Go to test cases.\\n1. Delete everything.\\n1. Type `11` in there\\n1. Hit the \\'Run Code\\' button. (repeat a few time to get the best result)\\n1. Add your number as a comment here.\\n\\nMention your language and implementation approach if you like. This is just for fun! :-D\\n"
                    },
                    {
                        "username": "securityma",
                        "content": "Who can tell me the difference of add1 inside of the funtion of dfs  and add1 outside of the function\\n   if(m1<n){\\n       // m1++;\\n       // tmp+=\\'(\\';\\n        dfs(ans,n,m1+1,m2,tmp+\\'(\\');\\n    }\\n    if(m2<m1){\\n   // tmp+=\\')\\';\\n   //m2+=1;\\n    dfs(ans,n,m1,m2+1,tmp+\\')\\');}\\nIt\\'s completely different answer.I\\'ll appreciate it for your answer.  "
                    },
                    {
                        "username": "29ayush",
                        "content": "Consider below 2 codes:\\n\\nIn Code1, I use local vector for a test case, and in case 2 I use a global vector, leet code says 2 code is slower why ?\\n\\nCode1\\nclass Solution {\\npublic:\\n\\n    void refgen(string &s, int open, int close, vector<string> &allPara) {\\n        if (close == 0) {\\n            allPara.push_back(s);\\n        }\\n        if (open > 0 ) {\\n            s.push_back(\\'(\\');\\n            refgen(s, open - 1, close, allPara);\\n            s.pop_back();\\n        }\\n\\n        if (close > open) {\\n            s.push_back(\\')\\');\\n            refgen(s, open, close - 1, allPara);\\n            s.pop_back();\\n        }\\n    }\\n\\n    vector<string> generateParenthesis(int n) {\\n        vector<string> newVec;\\n        string s = \"\";\\n        refgen(s, n, n, newVec);\\n        return newVec;\\n    }\\n};\\n\\nCode 2:\\nclass Solution {\\npublic:\\n\\n    vector<string> allPara;\\n    string s;\\n    void refgen(int open, int close)  {\\n        if (close == 0) {\\n            allPara.push_back(s);\\n        }\\n        if (open > 0 ) {\\n            s.push_back(\\'(\\');\\n            refgen(open - 1, close);\\n            s.pop_back();\\n        }\\n\\n        if (close > open) {\\n            s.push_back(\\')\\');\\n            refgen(open, close - 1);\\n            s.pop_back();\\n        }\\n    }\\n\\n    vector<string> generateParenthesis(int n) {\\n        refgen(n, n);\\n        return allPara;\\n    }\\n};\\n\\n\\n\\n"
                    },
                    {
                        "username": "imguptaharsh",
                        "content": "count left \"(\" and right \")\" if count of left is less than \"n\" add \"(\" and also if  count \"(\" > \")\"  add \")\" or else if right< n add \")\",\nadd string to ans vector if sizeof string == 2*n"
                    }
                ]
            },
            {
                "id": 1763055,
                "content": [
                    {
                        "username": "Dhruv_Khanna123",
                        "content": "classic backtracking"
                    },
                    {
                        "username": "jayantee_12",
                        "content": "Does order of solution matter in this problem?"
                    },
                    {
                        "username": "Naumel",
                        "content": "The code works on my machine, but something seems wrongly cached in the browser (as in the result I get from a local run is different than the result from here). Is this some known behaviour? "
                    },
                    {
                        "username": "easycheese",
                        "content": "# Very simple python\\n\\nInsert \"()\" between each character for each i to n \\n\\n```python\\ndef generateParenthesis(self, n: int):\\n        aws = {\"()\"}\\n        for _ in range(n-1):\\n            tmp = set()\\n            for j in aws:\\n                for k in range(len(j)+1):\\n                    tmp.add(j[:k]+\"()\"+j[k:])\\n            aws = tmp\\n        return [i for i in aws]\\n"
                    },
                    {
                        "username": "rajanpupa",
                        "content": "I saw some backtracking algorithm so solve this problem. What is the runtime complexity of the algorithm?"
                    },
                    {
                        "username": "Hoaibao_21520628",
                        "content": "My code is wrong on `n = 4` and I don\\'t know why? Help me pls!\\n```\\nvoid solver(int n, string str, vector<string> &answer, map<string, bool> &check)\\n    {\\n        if(n == 0)\\n        {\\n            if(check[str] == false)\\n            {\\n                answer.push_back(str);\\n                check[str] = true;\\n            }\\n            else\\n                return;\\n        }\\n        else\\n        {\\n            solver(n-1, \"(\" + str + \")\", answer, check);\\n            solver(n-1, str + \"()\", answer, check);\\n            solver(n-1, \"()\" + str, answer, check);\\n            \\n        }\\n    }\\n```"
                    },
                    {
                        "username": "adi29raj",
                        "content": "I was also doing something similar..let me know if you were able to solve llike this,"
                    },
                    {
                        "username": "SleepNotFound",
                        "content": "it would be missing \"(())(())\""
                    },
                    {
                        "username": "ahcox",
                        "content": "Let\\'s compare timings for the largest problem size that Leetcode will accept (**`11`**). Instructions to take part:\\n1. Go to test cases.\\n1. Delete everything.\\n1. Type `11` in there\\n1. Hit the \\'Run Code\\' button. (repeat a few time to get the best result)\\n1. Add your number as a comment here.\\n\\nMention your language and implementation approach if you like. This is just for fun! :-D\\n"
                    },
                    {
                        "username": "securityma",
                        "content": "Who can tell me the difference of add1 inside of the funtion of dfs  and add1 outside of the function\\n   if(m1<n){\\n       // m1++;\\n       // tmp+=\\'(\\';\\n        dfs(ans,n,m1+1,m2,tmp+\\'(\\');\\n    }\\n    if(m2<m1){\\n   // tmp+=\\')\\';\\n   //m2+=1;\\n    dfs(ans,n,m1,m2+1,tmp+\\')\\');}\\nIt\\'s completely different answer.I\\'ll appreciate it for your answer.  "
                    },
                    {
                        "username": "29ayush",
                        "content": "Consider below 2 codes:\\n\\nIn Code1, I use local vector for a test case, and in case 2 I use a global vector, leet code says 2 code is slower why ?\\n\\nCode1\\nclass Solution {\\npublic:\\n\\n    void refgen(string &s, int open, int close, vector<string> &allPara) {\\n        if (close == 0) {\\n            allPara.push_back(s);\\n        }\\n        if (open > 0 ) {\\n            s.push_back(\\'(\\');\\n            refgen(s, open - 1, close, allPara);\\n            s.pop_back();\\n        }\\n\\n        if (close > open) {\\n            s.push_back(\\')\\');\\n            refgen(s, open, close - 1, allPara);\\n            s.pop_back();\\n        }\\n    }\\n\\n    vector<string> generateParenthesis(int n) {\\n        vector<string> newVec;\\n        string s = \"\";\\n        refgen(s, n, n, newVec);\\n        return newVec;\\n    }\\n};\\n\\nCode 2:\\nclass Solution {\\npublic:\\n\\n    vector<string> allPara;\\n    string s;\\n    void refgen(int open, int close)  {\\n        if (close == 0) {\\n            allPara.push_back(s);\\n        }\\n        if (open > 0 ) {\\n            s.push_back(\\'(\\');\\n            refgen(open - 1, close);\\n            s.pop_back();\\n        }\\n\\n        if (close > open) {\\n            s.push_back(\\')\\');\\n            refgen(open, close - 1);\\n            s.pop_back();\\n        }\\n    }\\n\\n    vector<string> generateParenthesis(int n) {\\n        refgen(n, n);\\n        return allPara;\\n    }\\n};\\n\\n\\n\\n"
                    },
                    {
                        "username": "imguptaharsh",
                        "content": "count left \"(\" and right \")\" if count of left is less than \"n\" add \"(\" and also if  count \"(\" > \")\"  add \")\" or else if right< n add \")\",\nadd string to ans vector if sizeof string == 2*n"
                    }
                ]
            },
            {
                "id": 1572241,
                "content": [
                    {
                        "username": "Dhruv_Khanna123",
                        "content": "classic backtracking"
                    },
                    {
                        "username": "jayantee_12",
                        "content": "Does order of solution matter in this problem?"
                    },
                    {
                        "username": "Naumel",
                        "content": "The code works on my machine, but something seems wrongly cached in the browser (as in the result I get from a local run is different than the result from here). Is this some known behaviour? "
                    },
                    {
                        "username": "easycheese",
                        "content": "# Very simple python\\n\\nInsert \"()\" between each character for each i to n \\n\\n```python\\ndef generateParenthesis(self, n: int):\\n        aws = {\"()\"}\\n        for _ in range(n-1):\\n            tmp = set()\\n            for j in aws:\\n                for k in range(len(j)+1):\\n                    tmp.add(j[:k]+\"()\"+j[k:])\\n            aws = tmp\\n        return [i for i in aws]\\n"
                    },
                    {
                        "username": "rajanpupa",
                        "content": "I saw some backtracking algorithm so solve this problem. What is the runtime complexity of the algorithm?"
                    },
                    {
                        "username": "Hoaibao_21520628",
                        "content": "My code is wrong on `n = 4` and I don\\'t know why? Help me pls!\\n```\\nvoid solver(int n, string str, vector<string> &answer, map<string, bool> &check)\\n    {\\n        if(n == 0)\\n        {\\n            if(check[str] == false)\\n            {\\n                answer.push_back(str);\\n                check[str] = true;\\n            }\\n            else\\n                return;\\n        }\\n        else\\n        {\\n            solver(n-1, \"(\" + str + \")\", answer, check);\\n            solver(n-1, str + \"()\", answer, check);\\n            solver(n-1, \"()\" + str, answer, check);\\n            \\n        }\\n    }\\n```"
                    },
                    {
                        "username": "adi29raj",
                        "content": "I was also doing something similar..let me know if you were able to solve llike this,"
                    },
                    {
                        "username": "SleepNotFound",
                        "content": "it would be missing \"(())(())\""
                    },
                    {
                        "username": "ahcox",
                        "content": "Let\\'s compare timings for the largest problem size that Leetcode will accept (**`11`**). Instructions to take part:\\n1. Go to test cases.\\n1. Delete everything.\\n1. Type `11` in there\\n1. Hit the \\'Run Code\\' button. (repeat a few time to get the best result)\\n1. Add your number as a comment here.\\n\\nMention your language and implementation approach if you like. This is just for fun! :-D\\n"
                    },
                    {
                        "username": "securityma",
                        "content": "Who can tell me the difference of add1 inside of the funtion of dfs  and add1 outside of the function\\n   if(m1<n){\\n       // m1++;\\n       // tmp+=\\'(\\';\\n        dfs(ans,n,m1+1,m2,tmp+\\'(\\');\\n    }\\n    if(m2<m1){\\n   // tmp+=\\')\\';\\n   //m2+=1;\\n    dfs(ans,n,m1,m2+1,tmp+\\')\\');}\\nIt\\'s completely different answer.I\\'ll appreciate it for your answer.  "
                    },
                    {
                        "username": "29ayush",
                        "content": "Consider below 2 codes:\\n\\nIn Code1, I use local vector for a test case, and in case 2 I use a global vector, leet code says 2 code is slower why ?\\n\\nCode1\\nclass Solution {\\npublic:\\n\\n    void refgen(string &s, int open, int close, vector<string> &allPara) {\\n        if (close == 0) {\\n            allPara.push_back(s);\\n        }\\n        if (open > 0 ) {\\n            s.push_back(\\'(\\');\\n            refgen(s, open - 1, close, allPara);\\n            s.pop_back();\\n        }\\n\\n        if (close > open) {\\n            s.push_back(\\')\\');\\n            refgen(s, open, close - 1, allPara);\\n            s.pop_back();\\n        }\\n    }\\n\\n    vector<string> generateParenthesis(int n) {\\n        vector<string> newVec;\\n        string s = \"\";\\n        refgen(s, n, n, newVec);\\n        return newVec;\\n    }\\n};\\n\\nCode 2:\\nclass Solution {\\npublic:\\n\\n    vector<string> allPara;\\n    string s;\\n    void refgen(int open, int close)  {\\n        if (close == 0) {\\n            allPara.push_back(s);\\n        }\\n        if (open > 0 ) {\\n            s.push_back(\\'(\\');\\n            refgen(open - 1, close);\\n            s.pop_back();\\n        }\\n\\n        if (close > open) {\\n            s.push_back(\\')\\');\\n            refgen(open, close - 1);\\n            s.pop_back();\\n        }\\n    }\\n\\n    vector<string> generateParenthesis(int n) {\\n        refgen(n, n);\\n        return allPara;\\n    }\\n};\\n\\n\\n\\n"
                    },
                    {
                        "username": "imguptaharsh",
                        "content": "count left \"(\" and right \")\" if count of left is less than \"n\" add \"(\" and also if  count \"(\" > \")\"  add \")\" or else if right< n add \")\",\nadd string to ans vector if sizeof string == 2*n"
                    }
                ]
            },
            {
                "id": 1832940,
                "content": [
                    {
                        "username": "Dhruv_Khanna123",
                        "content": "classic backtracking"
                    },
                    {
                        "username": "jayantee_12",
                        "content": "Does order of solution matter in this problem?"
                    },
                    {
                        "username": "Naumel",
                        "content": "The code works on my machine, but something seems wrongly cached in the browser (as in the result I get from a local run is different than the result from here). Is this some known behaviour? "
                    },
                    {
                        "username": "easycheese",
                        "content": "# Very simple python\\n\\nInsert \"()\" between each character for each i to n \\n\\n```python\\ndef generateParenthesis(self, n: int):\\n        aws = {\"()\"}\\n        for _ in range(n-1):\\n            tmp = set()\\n            for j in aws:\\n                for k in range(len(j)+1):\\n                    tmp.add(j[:k]+\"()\"+j[k:])\\n            aws = tmp\\n        return [i for i in aws]\\n"
                    },
                    {
                        "username": "rajanpupa",
                        "content": "I saw some backtracking algorithm so solve this problem. What is the runtime complexity of the algorithm?"
                    },
                    {
                        "username": "Hoaibao_21520628",
                        "content": "My code is wrong on `n = 4` and I don\\'t know why? Help me pls!\\n```\\nvoid solver(int n, string str, vector<string> &answer, map<string, bool> &check)\\n    {\\n        if(n == 0)\\n        {\\n            if(check[str] == false)\\n            {\\n                answer.push_back(str);\\n                check[str] = true;\\n            }\\n            else\\n                return;\\n        }\\n        else\\n        {\\n            solver(n-1, \"(\" + str + \")\", answer, check);\\n            solver(n-1, str + \"()\", answer, check);\\n            solver(n-1, \"()\" + str, answer, check);\\n            \\n        }\\n    }\\n```"
                    },
                    {
                        "username": "adi29raj",
                        "content": "I was also doing something similar..let me know if you were able to solve llike this,"
                    },
                    {
                        "username": "SleepNotFound",
                        "content": "it would be missing \"(())(())\""
                    },
                    {
                        "username": "ahcox",
                        "content": "Let\\'s compare timings for the largest problem size that Leetcode will accept (**`11`**). Instructions to take part:\\n1. Go to test cases.\\n1. Delete everything.\\n1. Type `11` in there\\n1. Hit the \\'Run Code\\' button. (repeat a few time to get the best result)\\n1. Add your number as a comment here.\\n\\nMention your language and implementation approach if you like. This is just for fun! :-D\\n"
                    },
                    {
                        "username": "securityma",
                        "content": "Who can tell me the difference of add1 inside of the funtion of dfs  and add1 outside of the function\\n   if(m1<n){\\n       // m1++;\\n       // tmp+=\\'(\\';\\n        dfs(ans,n,m1+1,m2,tmp+\\'(\\');\\n    }\\n    if(m2<m1){\\n   // tmp+=\\')\\';\\n   //m2+=1;\\n    dfs(ans,n,m1,m2+1,tmp+\\')\\');}\\nIt\\'s completely different answer.I\\'ll appreciate it for your answer.  "
                    },
                    {
                        "username": "29ayush",
                        "content": "Consider below 2 codes:\\n\\nIn Code1, I use local vector for a test case, and in case 2 I use a global vector, leet code says 2 code is slower why ?\\n\\nCode1\\nclass Solution {\\npublic:\\n\\n    void refgen(string &s, int open, int close, vector<string> &allPara) {\\n        if (close == 0) {\\n            allPara.push_back(s);\\n        }\\n        if (open > 0 ) {\\n            s.push_back(\\'(\\');\\n            refgen(s, open - 1, close, allPara);\\n            s.pop_back();\\n        }\\n\\n        if (close > open) {\\n            s.push_back(\\')\\');\\n            refgen(s, open, close - 1, allPara);\\n            s.pop_back();\\n        }\\n    }\\n\\n    vector<string> generateParenthesis(int n) {\\n        vector<string> newVec;\\n        string s = \"\";\\n        refgen(s, n, n, newVec);\\n        return newVec;\\n    }\\n};\\n\\nCode 2:\\nclass Solution {\\npublic:\\n\\n    vector<string> allPara;\\n    string s;\\n    void refgen(int open, int close)  {\\n        if (close == 0) {\\n            allPara.push_back(s);\\n        }\\n        if (open > 0 ) {\\n            s.push_back(\\'(\\');\\n            refgen(open - 1, close);\\n            s.pop_back();\\n        }\\n\\n        if (close > open) {\\n            s.push_back(\\')\\');\\n            refgen(open, close - 1);\\n            s.pop_back();\\n        }\\n    }\\n\\n    vector<string> generateParenthesis(int n) {\\n        refgen(n, n);\\n        return allPara;\\n    }\\n};\\n\\n\\n\\n"
                    },
                    {
                        "username": "imguptaharsh",
                        "content": "count left \"(\" and right \")\" if count of left is less than \"n\" add \"(\" and also if  count \"(\" > \")\"  add \")\" or else if right< n add \")\",\nadd string to ans vector if sizeof string == 2*n"
                    }
                ]
            },
            {
                "id": 1573326,
                "content": [
                    {
                        "username": "Dhruv_Khanna123",
                        "content": "classic backtracking"
                    },
                    {
                        "username": "jayantee_12",
                        "content": "Does order of solution matter in this problem?"
                    },
                    {
                        "username": "Naumel",
                        "content": "The code works on my machine, but something seems wrongly cached in the browser (as in the result I get from a local run is different than the result from here). Is this some known behaviour? "
                    },
                    {
                        "username": "easycheese",
                        "content": "# Very simple python\\n\\nInsert \"()\" between each character for each i to n \\n\\n```python\\ndef generateParenthesis(self, n: int):\\n        aws = {\"()\"}\\n        for _ in range(n-1):\\n            tmp = set()\\n            for j in aws:\\n                for k in range(len(j)+1):\\n                    tmp.add(j[:k]+\"()\"+j[k:])\\n            aws = tmp\\n        return [i for i in aws]\\n"
                    },
                    {
                        "username": "rajanpupa",
                        "content": "I saw some backtracking algorithm so solve this problem. What is the runtime complexity of the algorithm?"
                    },
                    {
                        "username": "Hoaibao_21520628",
                        "content": "My code is wrong on `n = 4` and I don\\'t know why? Help me pls!\\n```\\nvoid solver(int n, string str, vector<string> &answer, map<string, bool> &check)\\n    {\\n        if(n == 0)\\n        {\\n            if(check[str] == false)\\n            {\\n                answer.push_back(str);\\n                check[str] = true;\\n            }\\n            else\\n                return;\\n        }\\n        else\\n        {\\n            solver(n-1, \"(\" + str + \")\", answer, check);\\n            solver(n-1, str + \"()\", answer, check);\\n            solver(n-1, \"()\" + str, answer, check);\\n            \\n        }\\n    }\\n```"
                    },
                    {
                        "username": "adi29raj",
                        "content": "I was also doing something similar..let me know if you were able to solve llike this,"
                    },
                    {
                        "username": "SleepNotFound",
                        "content": "it would be missing \"(())(())\""
                    },
                    {
                        "username": "ahcox",
                        "content": "Let\\'s compare timings for the largest problem size that Leetcode will accept (**`11`**). Instructions to take part:\\n1. Go to test cases.\\n1. Delete everything.\\n1. Type `11` in there\\n1. Hit the \\'Run Code\\' button. (repeat a few time to get the best result)\\n1. Add your number as a comment here.\\n\\nMention your language and implementation approach if you like. This is just for fun! :-D\\n"
                    },
                    {
                        "username": "securityma",
                        "content": "Who can tell me the difference of add1 inside of the funtion of dfs  and add1 outside of the function\\n   if(m1<n){\\n       // m1++;\\n       // tmp+=\\'(\\';\\n        dfs(ans,n,m1+1,m2,tmp+\\'(\\');\\n    }\\n    if(m2<m1){\\n   // tmp+=\\')\\';\\n   //m2+=1;\\n    dfs(ans,n,m1,m2+1,tmp+\\')\\');}\\nIt\\'s completely different answer.I\\'ll appreciate it for your answer.  "
                    },
                    {
                        "username": "29ayush",
                        "content": "Consider below 2 codes:\\n\\nIn Code1, I use local vector for a test case, and in case 2 I use a global vector, leet code says 2 code is slower why ?\\n\\nCode1\\nclass Solution {\\npublic:\\n\\n    void refgen(string &s, int open, int close, vector<string> &allPara) {\\n        if (close == 0) {\\n            allPara.push_back(s);\\n        }\\n        if (open > 0 ) {\\n            s.push_back(\\'(\\');\\n            refgen(s, open - 1, close, allPara);\\n            s.pop_back();\\n        }\\n\\n        if (close > open) {\\n            s.push_back(\\')\\');\\n            refgen(s, open, close - 1, allPara);\\n            s.pop_back();\\n        }\\n    }\\n\\n    vector<string> generateParenthesis(int n) {\\n        vector<string> newVec;\\n        string s = \"\";\\n        refgen(s, n, n, newVec);\\n        return newVec;\\n    }\\n};\\n\\nCode 2:\\nclass Solution {\\npublic:\\n\\n    vector<string> allPara;\\n    string s;\\n    void refgen(int open, int close)  {\\n        if (close == 0) {\\n            allPara.push_back(s);\\n        }\\n        if (open > 0 ) {\\n            s.push_back(\\'(\\');\\n            refgen(open - 1, close);\\n            s.pop_back();\\n        }\\n\\n        if (close > open) {\\n            s.push_back(\\')\\');\\n            refgen(open, close - 1);\\n            s.pop_back();\\n        }\\n    }\\n\\n    vector<string> generateParenthesis(int n) {\\n        refgen(n, n);\\n        return allPara;\\n    }\\n};\\n\\n\\n\\n"
                    },
                    {
                        "username": "imguptaharsh",
                        "content": "count left \"(\" and right \")\" if count of left is less than \"n\" add \"(\" and also if  count \"(\" > \")\"  add \")\" or else if right< n add \")\",\nadd string to ans vector if sizeof string == 2*n"
                    }
                ]
            },
            {
                "id": 2072646,
                "content": [
                    {
                        "username": "Dhruv_Khanna123",
                        "content": "classic backtracking"
                    },
                    {
                        "username": "jayantee_12",
                        "content": "Does order of solution matter in this problem?"
                    },
                    {
                        "username": "Naumel",
                        "content": "The code works on my machine, but something seems wrongly cached in the browser (as in the result I get from a local run is different than the result from here). Is this some known behaviour? "
                    },
                    {
                        "username": "easycheese",
                        "content": "# Very simple python\\n\\nInsert \"()\" between each character for each i to n \\n\\n```python\\ndef generateParenthesis(self, n: int):\\n        aws = {\"()\"}\\n        for _ in range(n-1):\\n            tmp = set()\\n            for j in aws:\\n                for k in range(len(j)+1):\\n                    tmp.add(j[:k]+\"()\"+j[k:])\\n            aws = tmp\\n        return [i for i in aws]\\n"
                    },
                    {
                        "username": "rajanpupa",
                        "content": "I saw some backtracking algorithm so solve this problem. What is the runtime complexity of the algorithm?"
                    },
                    {
                        "username": "Hoaibao_21520628",
                        "content": "My code is wrong on `n = 4` and I don\\'t know why? Help me pls!\\n```\\nvoid solver(int n, string str, vector<string> &answer, map<string, bool> &check)\\n    {\\n        if(n == 0)\\n        {\\n            if(check[str] == false)\\n            {\\n                answer.push_back(str);\\n                check[str] = true;\\n            }\\n            else\\n                return;\\n        }\\n        else\\n        {\\n            solver(n-1, \"(\" + str + \")\", answer, check);\\n            solver(n-1, str + \"()\", answer, check);\\n            solver(n-1, \"()\" + str, answer, check);\\n            \\n        }\\n    }\\n```"
                    },
                    {
                        "username": "adi29raj",
                        "content": "I was also doing something similar..let me know if you were able to solve llike this,"
                    },
                    {
                        "username": "SleepNotFound",
                        "content": "it would be missing \"(())(())\""
                    },
                    {
                        "username": "ahcox",
                        "content": "Let\\'s compare timings for the largest problem size that Leetcode will accept (**`11`**). Instructions to take part:\\n1. Go to test cases.\\n1. Delete everything.\\n1. Type `11` in there\\n1. Hit the \\'Run Code\\' button. (repeat a few time to get the best result)\\n1. Add your number as a comment here.\\n\\nMention your language and implementation approach if you like. This is just for fun! :-D\\n"
                    },
                    {
                        "username": "securityma",
                        "content": "Who can tell me the difference of add1 inside of the funtion of dfs  and add1 outside of the function\\n   if(m1<n){\\n       // m1++;\\n       // tmp+=\\'(\\';\\n        dfs(ans,n,m1+1,m2,tmp+\\'(\\');\\n    }\\n    if(m2<m1){\\n   // tmp+=\\')\\';\\n   //m2+=1;\\n    dfs(ans,n,m1,m2+1,tmp+\\')\\');}\\nIt\\'s completely different answer.I\\'ll appreciate it for your answer.  "
                    },
                    {
                        "username": "29ayush",
                        "content": "Consider below 2 codes:\\n\\nIn Code1, I use local vector for a test case, and in case 2 I use a global vector, leet code says 2 code is slower why ?\\n\\nCode1\\nclass Solution {\\npublic:\\n\\n    void refgen(string &s, int open, int close, vector<string> &allPara) {\\n        if (close == 0) {\\n            allPara.push_back(s);\\n        }\\n        if (open > 0 ) {\\n            s.push_back(\\'(\\');\\n            refgen(s, open - 1, close, allPara);\\n            s.pop_back();\\n        }\\n\\n        if (close > open) {\\n            s.push_back(\\')\\');\\n            refgen(s, open, close - 1, allPara);\\n            s.pop_back();\\n        }\\n    }\\n\\n    vector<string> generateParenthesis(int n) {\\n        vector<string> newVec;\\n        string s = \"\";\\n        refgen(s, n, n, newVec);\\n        return newVec;\\n    }\\n};\\n\\nCode 2:\\nclass Solution {\\npublic:\\n\\n    vector<string> allPara;\\n    string s;\\n    void refgen(int open, int close)  {\\n        if (close == 0) {\\n            allPara.push_back(s);\\n        }\\n        if (open > 0 ) {\\n            s.push_back(\\'(\\');\\n            refgen(open - 1, close);\\n            s.pop_back();\\n        }\\n\\n        if (close > open) {\\n            s.push_back(\\')\\');\\n            refgen(open, close - 1);\\n            s.pop_back();\\n        }\\n    }\\n\\n    vector<string> generateParenthesis(int n) {\\n        refgen(n, n);\\n        return allPara;\\n    }\\n};\\n\\n\\n\\n"
                    },
                    {
                        "username": "imguptaharsh",
                        "content": "count left \"(\" and right \")\" if count of left is less than \"n\" add \"(\" and also if  count \"(\" > \")\"  add \")\" or else if right< n add \")\",\nadd string to ans vector if sizeof string == 2*n"
                    }
                ]
            },
            {
                "id": 2049319,
                "content": [
                    {
                        "username": "Dhruv_Khanna123",
                        "content": "classic backtracking"
                    },
                    {
                        "username": "jayantee_12",
                        "content": "Does order of solution matter in this problem?"
                    },
                    {
                        "username": "Naumel",
                        "content": "The code works on my machine, but something seems wrongly cached in the browser (as in the result I get from a local run is different than the result from here). Is this some known behaviour? "
                    },
                    {
                        "username": "easycheese",
                        "content": "# Very simple python\\n\\nInsert \"()\" between each character for each i to n \\n\\n```python\\ndef generateParenthesis(self, n: int):\\n        aws = {\"()\"}\\n        for _ in range(n-1):\\n            tmp = set()\\n            for j in aws:\\n                for k in range(len(j)+1):\\n                    tmp.add(j[:k]+\"()\"+j[k:])\\n            aws = tmp\\n        return [i for i in aws]\\n"
                    },
                    {
                        "username": "rajanpupa",
                        "content": "I saw some backtracking algorithm so solve this problem. What is the runtime complexity of the algorithm?"
                    },
                    {
                        "username": "Hoaibao_21520628",
                        "content": "My code is wrong on `n = 4` and I don\\'t know why? Help me pls!\\n```\\nvoid solver(int n, string str, vector<string> &answer, map<string, bool> &check)\\n    {\\n        if(n == 0)\\n        {\\n            if(check[str] == false)\\n            {\\n                answer.push_back(str);\\n                check[str] = true;\\n            }\\n            else\\n                return;\\n        }\\n        else\\n        {\\n            solver(n-1, \"(\" + str + \")\", answer, check);\\n            solver(n-1, str + \"()\", answer, check);\\n            solver(n-1, \"()\" + str, answer, check);\\n            \\n        }\\n    }\\n```"
                    },
                    {
                        "username": "adi29raj",
                        "content": "I was also doing something similar..let me know if you were able to solve llike this,"
                    },
                    {
                        "username": "SleepNotFound",
                        "content": "it would be missing \"(())(())\""
                    },
                    {
                        "username": "ahcox",
                        "content": "Let\\'s compare timings for the largest problem size that Leetcode will accept (**`11`**). Instructions to take part:\\n1. Go to test cases.\\n1. Delete everything.\\n1. Type `11` in there\\n1. Hit the \\'Run Code\\' button. (repeat a few time to get the best result)\\n1. Add your number as a comment here.\\n\\nMention your language and implementation approach if you like. This is just for fun! :-D\\n"
                    },
                    {
                        "username": "securityma",
                        "content": "Who can tell me the difference of add1 inside of the funtion of dfs  and add1 outside of the function\\n   if(m1<n){\\n       // m1++;\\n       // tmp+=\\'(\\';\\n        dfs(ans,n,m1+1,m2,tmp+\\'(\\');\\n    }\\n    if(m2<m1){\\n   // tmp+=\\')\\';\\n   //m2+=1;\\n    dfs(ans,n,m1,m2+1,tmp+\\')\\');}\\nIt\\'s completely different answer.I\\'ll appreciate it for your answer.  "
                    },
                    {
                        "username": "29ayush",
                        "content": "Consider below 2 codes:\\n\\nIn Code1, I use local vector for a test case, and in case 2 I use a global vector, leet code says 2 code is slower why ?\\n\\nCode1\\nclass Solution {\\npublic:\\n\\n    void refgen(string &s, int open, int close, vector<string> &allPara) {\\n        if (close == 0) {\\n            allPara.push_back(s);\\n        }\\n        if (open > 0 ) {\\n            s.push_back(\\'(\\');\\n            refgen(s, open - 1, close, allPara);\\n            s.pop_back();\\n        }\\n\\n        if (close > open) {\\n            s.push_back(\\')\\');\\n            refgen(s, open, close - 1, allPara);\\n            s.pop_back();\\n        }\\n    }\\n\\n    vector<string> generateParenthesis(int n) {\\n        vector<string> newVec;\\n        string s = \"\";\\n        refgen(s, n, n, newVec);\\n        return newVec;\\n    }\\n};\\n\\nCode 2:\\nclass Solution {\\npublic:\\n\\n    vector<string> allPara;\\n    string s;\\n    void refgen(int open, int close)  {\\n        if (close == 0) {\\n            allPara.push_back(s);\\n        }\\n        if (open > 0 ) {\\n            s.push_back(\\'(\\');\\n            refgen(open - 1, close);\\n            s.pop_back();\\n        }\\n\\n        if (close > open) {\\n            s.push_back(\\')\\');\\n            refgen(open, close - 1);\\n            s.pop_back();\\n        }\\n    }\\n\\n    vector<string> generateParenthesis(int n) {\\n        refgen(n, n);\\n        return allPara;\\n    }\\n};\\n\\n\\n\\n"
                    },
                    {
                        "username": "imguptaharsh",
                        "content": "count left \"(\" and right \")\" if count of left is less than \"n\" add \"(\" and also if  count \"(\" > \")\"  add \")\" or else if right< n add \")\",\nadd string to ans vector if sizeof string == 2*n"
                    }
                ]
            },
            {
                "id": 2034589,
                "content": [
                    {
                        "username": "Dhruv_Khanna123",
                        "content": "classic backtracking"
                    },
                    {
                        "username": "jayantee_12",
                        "content": "Does order of solution matter in this problem?"
                    },
                    {
                        "username": "Naumel",
                        "content": "The code works on my machine, but something seems wrongly cached in the browser (as in the result I get from a local run is different than the result from here). Is this some known behaviour? "
                    },
                    {
                        "username": "easycheese",
                        "content": "# Very simple python\\n\\nInsert \"()\" between each character for each i to n \\n\\n```python\\ndef generateParenthesis(self, n: int):\\n        aws = {\"()\"}\\n        for _ in range(n-1):\\n            tmp = set()\\n            for j in aws:\\n                for k in range(len(j)+1):\\n                    tmp.add(j[:k]+\"()\"+j[k:])\\n            aws = tmp\\n        return [i for i in aws]\\n"
                    },
                    {
                        "username": "rajanpupa",
                        "content": "I saw some backtracking algorithm so solve this problem. What is the runtime complexity of the algorithm?"
                    },
                    {
                        "username": "Hoaibao_21520628",
                        "content": "My code is wrong on `n = 4` and I don\\'t know why? Help me pls!\\n```\\nvoid solver(int n, string str, vector<string> &answer, map<string, bool> &check)\\n    {\\n        if(n == 0)\\n        {\\n            if(check[str] == false)\\n            {\\n                answer.push_back(str);\\n                check[str] = true;\\n            }\\n            else\\n                return;\\n        }\\n        else\\n        {\\n            solver(n-1, \"(\" + str + \")\", answer, check);\\n            solver(n-1, str + \"()\", answer, check);\\n            solver(n-1, \"()\" + str, answer, check);\\n            \\n        }\\n    }\\n```"
                    },
                    {
                        "username": "adi29raj",
                        "content": "I was also doing something similar..let me know if you were able to solve llike this,"
                    },
                    {
                        "username": "SleepNotFound",
                        "content": "it would be missing \"(())(())\""
                    },
                    {
                        "username": "ahcox",
                        "content": "Let\\'s compare timings for the largest problem size that Leetcode will accept (**`11`**). Instructions to take part:\\n1. Go to test cases.\\n1. Delete everything.\\n1. Type `11` in there\\n1. Hit the \\'Run Code\\' button. (repeat a few time to get the best result)\\n1. Add your number as a comment here.\\n\\nMention your language and implementation approach if you like. This is just for fun! :-D\\n"
                    },
                    {
                        "username": "securityma",
                        "content": "Who can tell me the difference of add1 inside of the funtion of dfs  and add1 outside of the function\\n   if(m1<n){\\n       // m1++;\\n       // tmp+=\\'(\\';\\n        dfs(ans,n,m1+1,m2,tmp+\\'(\\');\\n    }\\n    if(m2<m1){\\n   // tmp+=\\')\\';\\n   //m2+=1;\\n    dfs(ans,n,m1,m2+1,tmp+\\')\\');}\\nIt\\'s completely different answer.I\\'ll appreciate it for your answer.  "
                    },
                    {
                        "username": "29ayush",
                        "content": "Consider below 2 codes:\\n\\nIn Code1, I use local vector for a test case, and in case 2 I use a global vector, leet code says 2 code is slower why ?\\n\\nCode1\\nclass Solution {\\npublic:\\n\\n    void refgen(string &s, int open, int close, vector<string> &allPara) {\\n        if (close == 0) {\\n            allPara.push_back(s);\\n        }\\n        if (open > 0 ) {\\n            s.push_back(\\'(\\');\\n            refgen(s, open - 1, close, allPara);\\n            s.pop_back();\\n        }\\n\\n        if (close > open) {\\n            s.push_back(\\')\\');\\n            refgen(s, open, close - 1, allPara);\\n            s.pop_back();\\n        }\\n    }\\n\\n    vector<string> generateParenthesis(int n) {\\n        vector<string> newVec;\\n        string s = \"\";\\n        refgen(s, n, n, newVec);\\n        return newVec;\\n    }\\n};\\n\\nCode 2:\\nclass Solution {\\npublic:\\n\\n    vector<string> allPara;\\n    string s;\\n    void refgen(int open, int close)  {\\n        if (close == 0) {\\n            allPara.push_back(s);\\n        }\\n        if (open > 0 ) {\\n            s.push_back(\\'(\\');\\n            refgen(open - 1, close);\\n            s.pop_back();\\n        }\\n\\n        if (close > open) {\\n            s.push_back(\\')\\');\\n            refgen(open, close - 1);\\n            s.pop_back();\\n        }\\n    }\\n\\n    vector<string> generateParenthesis(int n) {\\n        refgen(n, n);\\n        return allPara;\\n    }\\n};\\n\\n\\n\\n"
                    },
                    {
                        "username": "imguptaharsh",
                        "content": "count left \"(\" and right \")\" if count of left is less than \"n\" add \"(\" and also if  count \"(\" > \")\"  add \")\" or else if right< n add \")\",\nadd string to ans vector if sizeof string == 2*n"
                    }
                ]
            },
            {
                "id": 2030949,
                "content": [
                    {
                        "username": "mayursonowal7",
                        "content": "leetcode getting naughtier day by day"
                    },
                    {
                        "username": "layyy",
                        "content": "keep the condition open brackets<n and close brackets<open brackets and recurse accordingly"
                    },
                    {
                        "username": "atharva2406",
                        "content": "Hi can anyone explain to me why my solution is not working\\nclass Solution {\\npublic:\\n    void backtrack(int open, int closed, int n, vector<string> res, stack<char> &st){\\n        if(open == closed and open == n && st.size() == n*2){\\n            string t = \" \";\\n            while(!st.empty()){\\n                t += st.top();\\n                st.pop();\\n            }\\n            reverse(t.begin(), t.end());\\n            res.push_back(t);\\n            return;\\n        }\\n        if(open < n){\\n            st.push(\\'(\\');\\n            backtrack(open+1, closed, n, res, st);\\n            st.pop();\\n        }\\n        if(closed < open){\\n            st.push(\\')\\');\\n            backtrack(open, closed+1, n, res, st);\\n            st.pop();\\n        }\\n        return;\\n    }\\n    vector<string> generateParenthesis(int n) {\\n        vector<string> ans;\\n        int open = 0, closed = 0;\\n        stack<char> st;\\n        backtrack(open, closed, n, ans, st);\\n        return ans;\\n    }\\n};"
                    },
                    {
                        "username": "Shiv_1203",
                        "content": "just count opening brackets and closing bracket \\nthere are two conditions \\nif opening brackets are less than n then string+\\'(\\' and increase opening bracket count\\nif closing brackets are less than opening brackets then string+\\')\\' and increase closing bracket count\\nbase condition =  if both are equal store teh string in vector and return"
                    },
                    {
                        "username": "RK_9097",
                        "content": "class Solution {\\n    private boolean isValid(String pString) {\\n        int leftCount = 0;\\n        for (char p : pString.toCharArray()) {\\n            if (p == \\'(\\') {\\n                leftCount++;\\n            } else {\\n                leftCount--;\\n            } \\n\\n            if (leftCount < 0) {\\n                return false;\\n            }\\n        }\\n        return leftCount == 0;\\n    }\\n    \\n    public List<String> generateParenthesis(int n) {\\n        List<String> answer = new ArrayList<>();\\n        Queue<String> queue = new LinkedList<>(Arrays.asList(\"\"));\\n\\n        while (!queue.isEmpty()) {\\n            String curString = queue.poll();\\n\\n            // If the length of curString is 2 * n, add it to `answer` if\\n            // it is valid. \\n            if (curString.length() == 2 * n) {\\n                if (isValid(curString)) {\\n                    answer.add(curString);\\n                }\\n                continue;\\n            }\\n            queue.offer(curString + \")\");\\n            queue.offer(curString + \"(\");\\n        }\\n\\n        return answer;\\n    }\\n}"
                    },
                    {
                        "username": "Divyam6969",
                        "content": "How can  we solve this iteratively?\n"
                    },
                    {
                        "username": "maurei",
                        "content": "I think in my solution the recursive call be converted to a while loop pretty straightforwardly: https://leetcode.com/problems/generate-parentheses/description/comments/1870152"
                    },
                    {
                        "username": "saurabhDtu15",
                        "content": "Can someone help me with the time and space complexity for the following?\\nMy logic: Keeping count of opening brackets and closing brackets. Opening brackets cannot be more than n in any case and closing brackets should always be less than opening.\\n\\n`class Solution {\\n    List<String> res;\\n    public List<String> generateParenthesis(int n) {\\n        res = new ArrayList<>();\\n        brackets(n*2, 0, 0, \"\", 0);\\n        return res;\\n    }\\n\\n    private void brackets(int n, int strl, int strr, String str, int count) {\\n        if(str.length() == n) {\\n            res.add(str);\\n            return;\\n        }\\n        if(strl < n/2)\\n            brackets(n, strl + 1, strr, str + \\'(\\', count + 1);\\n        if(strr < strl) {\\n            brackets(n, strl, strr + 1, str + \\')\\', count + 1);\\n        }\\n    }\\n}`"
                    },
                    {
                        "username": "ideintTe",
                        "content": "For n =4;\\nOutput : [\"(((())))\",\"((()))()\",\"()((()))\",\"((())())\",\"(())()()\",\"()(())()\",\"(()(()))\",\"()(())()\",\"()()(())\",\"((()()))\",\"(()())()\",\"()(()())\",\"(()()())\",\"()()()()\"]\\nExpected : [\"(((())))\",\"((()()))\",\"((())())\",\"((()))()\",\"(()(()))\",\"(()()())\",\"(()())()\",\"(())(())\",\"(())()()\",\"()((()))\",\"()(()())\",\"()(())()\",\"()()(())\",\"()()()()\"]\\nI\\'m not using recursion, how can I change the order ?\\nHere\\'s my solution:\\npublic List<String> generateParenthesis(int n) {\\n        List<String> combinations = new ArrayList<String>();\\n        List<String> combinations1 = new ArrayList<String>();\\n        if(n == 0)\\n            return combinations;\\n        combinations.add(\"()\");\\n        if(n == 1) {\\n            return combinations;\\n        }\\n        for( int i = 2; i <= n; i++) {   \\n            combinations1.clear();      \\n            for(String j : combinations) {\\n                String temp1 = j.concat(\"()\");\\n                String temp2 = \"()\".concat(j);\\n                combinations1.add(\"(\" + j + \")\");\\n                if(!temp1.equals(temp2)) {\\n                    combinations1.add(temp1);\\n                    combinations1.add(temp2);\\n                }  \\n                else {\\n                    combinations1.add(temp1);           \\n            }\\n            combinations.clear();\\n            combinations.addAll(combinations1);           \\n        }\\n        return combinations;\\n    }\\n"
                    },
                    {
                        "username": "maurei",
                        "content": "My solution is also recursive but pretty different from keeping track of `openCount` and `closeCount`. I don\\'t really know how my solution relates. Does anyone have a better idea on this?\\n\\n I wrote down the first few cases and observed how I could eg obtain n=3 from n=2. The trick is to iterate over the combinations of n=2 and insert a `()` left and right of every opening `()` UNTIl you run into the first closing bracket `(`.\\n\\nLet me write that out with an example. I use `_()_` to denote which pair of brackets was newly introduced.\\n\\ntake `n=2`. (A)`(())` and (B) `()()`.\\n\\n(A) becomes: `_()_(())`,  `(_()_())` and `((_()_))`. Thats where we stop because after the last insertion, we run into the first closing bracket\\n(B) becomes: `_()_()()` and `(_()_)()`. Thats where we stop, again, because there is a closing bracket next.\\n\\nIt runs pretty damn fast. The code is here (can be written for better space but wanted to keep it readable for discussion here).\\n\\nIt works, but im not sure why.\\n\\n```c#\\npublic class Solution\\n{\\n    public IList<string> GenerateParenthesis(int n) \\n    {\\n        if (n == 0)\\n        {\\n            return Array.Empty<string>();\\n        }\\n\\n        if (n == 1)\\n        {\\n            return new List<string> { \"()\" };\\n        }\\n\\n        List<string> combinations = new List<string>();\\n\\n        IList<string> previousCombinations = GenerateParenthesis(n - 1);\\n\\n        foreach (string previous in previousCombinations)\\n        {\\n            List<string> current = GetCurrentConfig(previous);\\n            combinations.AddRange(current);\\n        }\\n\\n        return combinations;\\n    }\\n\\n    private List<string> GetCurrentConfig(string previous)\\n    {\\n        List<char> characters = previous.ToCharArray().ToList();\\n\\n        List<string> result = new();\\n        \\n        for (int i = 0; i < characters.Count; i++)\\n        {\\n            List<char> clone = new List<char>(characters);\\n            clone.Insert(i, \\')\\');\\n            clone.Insert(i, \\'(\\');\\n            result.Add(new string(clone.ToArray()));\\n            \\n            if (characters[i] == \\')\\')\\n            {\\n                break;\\n            }\\n        }\\n\\n        return result;\\n    }\\n}\\n```\\n"
                    },
                    {
                        "username": "zalars",
                        "content": "I found that the number of all combinations with N parenthesis pairs consists of two groups:\\n1. \"(\"+C(N-1)+\")\", where C(N-1) - all combiantions with N-1 parenthesis pairs;\\n2. All suitable concatenated sequences of all lower N\\'s combinations.\\n\\nAnd the second group is difficult to program for me even using a hash table. Besides time complexity doesn\\'t seem to be improved as well."
                    }
                ]
            },
            {
                "id": 2026050,
                "content": [
                    {
                        "username": "mayursonowal7",
                        "content": "leetcode getting naughtier day by day"
                    },
                    {
                        "username": "layyy",
                        "content": "keep the condition open brackets<n and close brackets<open brackets and recurse accordingly"
                    },
                    {
                        "username": "atharva2406",
                        "content": "Hi can anyone explain to me why my solution is not working\\nclass Solution {\\npublic:\\n    void backtrack(int open, int closed, int n, vector<string> res, stack<char> &st){\\n        if(open == closed and open == n && st.size() == n*2){\\n            string t = \" \";\\n            while(!st.empty()){\\n                t += st.top();\\n                st.pop();\\n            }\\n            reverse(t.begin(), t.end());\\n            res.push_back(t);\\n            return;\\n        }\\n        if(open < n){\\n            st.push(\\'(\\');\\n            backtrack(open+1, closed, n, res, st);\\n            st.pop();\\n        }\\n        if(closed < open){\\n            st.push(\\')\\');\\n            backtrack(open, closed+1, n, res, st);\\n            st.pop();\\n        }\\n        return;\\n    }\\n    vector<string> generateParenthesis(int n) {\\n        vector<string> ans;\\n        int open = 0, closed = 0;\\n        stack<char> st;\\n        backtrack(open, closed, n, ans, st);\\n        return ans;\\n    }\\n};"
                    },
                    {
                        "username": "Shiv_1203",
                        "content": "just count opening brackets and closing bracket \\nthere are two conditions \\nif opening brackets are less than n then string+\\'(\\' and increase opening bracket count\\nif closing brackets are less than opening brackets then string+\\')\\' and increase closing bracket count\\nbase condition =  if both are equal store teh string in vector and return"
                    },
                    {
                        "username": "RK_9097",
                        "content": "class Solution {\\n    private boolean isValid(String pString) {\\n        int leftCount = 0;\\n        for (char p : pString.toCharArray()) {\\n            if (p == \\'(\\') {\\n                leftCount++;\\n            } else {\\n                leftCount--;\\n            } \\n\\n            if (leftCount < 0) {\\n                return false;\\n            }\\n        }\\n        return leftCount == 0;\\n    }\\n    \\n    public List<String> generateParenthesis(int n) {\\n        List<String> answer = new ArrayList<>();\\n        Queue<String> queue = new LinkedList<>(Arrays.asList(\"\"));\\n\\n        while (!queue.isEmpty()) {\\n            String curString = queue.poll();\\n\\n            // If the length of curString is 2 * n, add it to `answer` if\\n            // it is valid. \\n            if (curString.length() == 2 * n) {\\n                if (isValid(curString)) {\\n                    answer.add(curString);\\n                }\\n                continue;\\n            }\\n            queue.offer(curString + \")\");\\n            queue.offer(curString + \"(\");\\n        }\\n\\n        return answer;\\n    }\\n}"
                    },
                    {
                        "username": "Divyam6969",
                        "content": "How can  we solve this iteratively?\n"
                    },
                    {
                        "username": "maurei",
                        "content": "I think in my solution the recursive call be converted to a while loop pretty straightforwardly: https://leetcode.com/problems/generate-parentheses/description/comments/1870152"
                    },
                    {
                        "username": "saurabhDtu15",
                        "content": "Can someone help me with the time and space complexity for the following?\\nMy logic: Keeping count of opening brackets and closing brackets. Opening brackets cannot be more than n in any case and closing brackets should always be less than opening.\\n\\n`class Solution {\\n    List<String> res;\\n    public List<String> generateParenthesis(int n) {\\n        res = new ArrayList<>();\\n        brackets(n*2, 0, 0, \"\", 0);\\n        return res;\\n    }\\n\\n    private void brackets(int n, int strl, int strr, String str, int count) {\\n        if(str.length() == n) {\\n            res.add(str);\\n            return;\\n        }\\n        if(strl < n/2)\\n            brackets(n, strl + 1, strr, str + \\'(\\', count + 1);\\n        if(strr < strl) {\\n            brackets(n, strl, strr + 1, str + \\')\\', count + 1);\\n        }\\n    }\\n}`"
                    },
                    {
                        "username": "ideintTe",
                        "content": "For n =4;\\nOutput : [\"(((())))\",\"((()))()\",\"()((()))\",\"((())())\",\"(())()()\",\"()(())()\",\"(()(()))\",\"()(())()\",\"()()(())\",\"((()()))\",\"(()())()\",\"()(()())\",\"(()()())\",\"()()()()\"]\\nExpected : [\"(((())))\",\"((()()))\",\"((())())\",\"((()))()\",\"(()(()))\",\"(()()())\",\"(()())()\",\"(())(())\",\"(())()()\",\"()((()))\",\"()(()())\",\"()(())()\",\"()()(())\",\"()()()()\"]\\nI\\'m not using recursion, how can I change the order ?\\nHere\\'s my solution:\\npublic List<String> generateParenthesis(int n) {\\n        List<String> combinations = new ArrayList<String>();\\n        List<String> combinations1 = new ArrayList<String>();\\n        if(n == 0)\\n            return combinations;\\n        combinations.add(\"()\");\\n        if(n == 1) {\\n            return combinations;\\n        }\\n        for( int i = 2; i <= n; i++) {   \\n            combinations1.clear();      \\n            for(String j : combinations) {\\n                String temp1 = j.concat(\"()\");\\n                String temp2 = \"()\".concat(j);\\n                combinations1.add(\"(\" + j + \")\");\\n                if(!temp1.equals(temp2)) {\\n                    combinations1.add(temp1);\\n                    combinations1.add(temp2);\\n                }  \\n                else {\\n                    combinations1.add(temp1);           \\n            }\\n            combinations.clear();\\n            combinations.addAll(combinations1);           \\n        }\\n        return combinations;\\n    }\\n"
                    },
                    {
                        "username": "maurei",
                        "content": "My solution is also recursive but pretty different from keeping track of `openCount` and `closeCount`. I don\\'t really know how my solution relates. Does anyone have a better idea on this?\\n\\n I wrote down the first few cases and observed how I could eg obtain n=3 from n=2. The trick is to iterate over the combinations of n=2 and insert a `()` left and right of every opening `()` UNTIl you run into the first closing bracket `(`.\\n\\nLet me write that out with an example. I use `_()_` to denote which pair of brackets was newly introduced.\\n\\ntake `n=2`. (A)`(())` and (B) `()()`.\\n\\n(A) becomes: `_()_(())`,  `(_()_())` and `((_()_))`. Thats where we stop because after the last insertion, we run into the first closing bracket\\n(B) becomes: `_()_()()` and `(_()_)()`. Thats where we stop, again, because there is a closing bracket next.\\n\\nIt runs pretty damn fast. The code is here (can be written for better space but wanted to keep it readable for discussion here).\\n\\nIt works, but im not sure why.\\n\\n```c#\\npublic class Solution\\n{\\n    public IList<string> GenerateParenthesis(int n) \\n    {\\n        if (n == 0)\\n        {\\n            return Array.Empty<string>();\\n        }\\n\\n        if (n == 1)\\n        {\\n            return new List<string> { \"()\" };\\n        }\\n\\n        List<string> combinations = new List<string>();\\n\\n        IList<string> previousCombinations = GenerateParenthesis(n - 1);\\n\\n        foreach (string previous in previousCombinations)\\n        {\\n            List<string> current = GetCurrentConfig(previous);\\n            combinations.AddRange(current);\\n        }\\n\\n        return combinations;\\n    }\\n\\n    private List<string> GetCurrentConfig(string previous)\\n    {\\n        List<char> characters = previous.ToCharArray().ToList();\\n\\n        List<string> result = new();\\n        \\n        for (int i = 0; i < characters.Count; i++)\\n        {\\n            List<char> clone = new List<char>(characters);\\n            clone.Insert(i, \\')\\');\\n            clone.Insert(i, \\'(\\');\\n            result.Add(new string(clone.ToArray()));\\n            \\n            if (characters[i] == \\')\\')\\n            {\\n                break;\\n            }\\n        }\\n\\n        return result;\\n    }\\n}\\n```\\n"
                    },
                    {
                        "username": "zalars",
                        "content": "I found that the number of all combinations with N parenthesis pairs consists of two groups:\\n1. \"(\"+C(N-1)+\")\", where C(N-1) - all combiantions with N-1 parenthesis pairs;\\n2. All suitable concatenated sequences of all lower N\\'s combinations.\\n\\nAnd the second group is difficult to program for me even using a hash table. Besides time complexity doesn\\'t seem to be improved as well."
                    }
                ]
            },
            {
                "id": 2013656,
                "content": [
                    {
                        "username": "mayursonowal7",
                        "content": "leetcode getting naughtier day by day"
                    },
                    {
                        "username": "layyy",
                        "content": "keep the condition open brackets<n and close brackets<open brackets and recurse accordingly"
                    },
                    {
                        "username": "atharva2406",
                        "content": "Hi can anyone explain to me why my solution is not working\\nclass Solution {\\npublic:\\n    void backtrack(int open, int closed, int n, vector<string> res, stack<char> &st){\\n        if(open == closed and open == n && st.size() == n*2){\\n            string t = \" \";\\n            while(!st.empty()){\\n                t += st.top();\\n                st.pop();\\n            }\\n            reverse(t.begin(), t.end());\\n            res.push_back(t);\\n            return;\\n        }\\n        if(open < n){\\n            st.push(\\'(\\');\\n            backtrack(open+1, closed, n, res, st);\\n            st.pop();\\n        }\\n        if(closed < open){\\n            st.push(\\')\\');\\n            backtrack(open, closed+1, n, res, st);\\n            st.pop();\\n        }\\n        return;\\n    }\\n    vector<string> generateParenthesis(int n) {\\n        vector<string> ans;\\n        int open = 0, closed = 0;\\n        stack<char> st;\\n        backtrack(open, closed, n, ans, st);\\n        return ans;\\n    }\\n};"
                    },
                    {
                        "username": "Shiv_1203",
                        "content": "just count opening brackets and closing bracket \\nthere are two conditions \\nif opening brackets are less than n then string+\\'(\\' and increase opening bracket count\\nif closing brackets are less than opening brackets then string+\\')\\' and increase closing bracket count\\nbase condition =  if both are equal store teh string in vector and return"
                    },
                    {
                        "username": "RK_9097",
                        "content": "class Solution {\\n    private boolean isValid(String pString) {\\n        int leftCount = 0;\\n        for (char p : pString.toCharArray()) {\\n            if (p == \\'(\\') {\\n                leftCount++;\\n            } else {\\n                leftCount--;\\n            } \\n\\n            if (leftCount < 0) {\\n                return false;\\n            }\\n        }\\n        return leftCount == 0;\\n    }\\n    \\n    public List<String> generateParenthesis(int n) {\\n        List<String> answer = new ArrayList<>();\\n        Queue<String> queue = new LinkedList<>(Arrays.asList(\"\"));\\n\\n        while (!queue.isEmpty()) {\\n            String curString = queue.poll();\\n\\n            // If the length of curString is 2 * n, add it to `answer` if\\n            // it is valid. \\n            if (curString.length() == 2 * n) {\\n                if (isValid(curString)) {\\n                    answer.add(curString);\\n                }\\n                continue;\\n            }\\n            queue.offer(curString + \")\");\\n            queue.offer(curString + \"(\");\\n        }\\n\\n        return answer;\\n    }\\n}"
                    },
                    {
                        "username": "Divyam6969",
                        "content": "How can  we solve this iteratively?\n"
                    },
                    {
                        "username": "maurei",
                        "content": "I think in my solution the recursive call be converted to a while loop pretty straightforwardly: https://leetcode.com/problems/generate-parentheses/description/comments/1870152"
                    },
                    {
                        "username": "saurabhDtu15",
                        "content": "Can someone help me with the time and space complexity for the following?\\nMy logic: Keeping count of opening brackets and closing brackets. Opening brackets cannot be more than n in any case and closing brackets should always be less than opening.\\n\\n`class Solution {\\n    List<String> res;\\n    public List<String> generateParenthesis(int n) {\\n        res = new ArrayList<>();\\n        brackets(n*2, 0, 0, \"\", 0);\\n        return res;\\n    }\\n\\n    private void brackets(int n, int strl, int strr, String str, int count) {\\n        if(str.length() == n) {\\n            res.add(str);\\n            return;\\n        }\\n        if(strl < n/2)\\n            brackets(n, strl + 1, strr, str + \\'(\\', count + 1);\\n        if(strr < strl) {\\n            brackets(n, strl, strr + 1, str + \\')\\', count + 1);\\n        }\\n    }\\n}`"
                    },
                    {
                        "username": "ideintTe",
                        "content": "For n =4;\\nOutput : [\"(((())))\",\"((()))()\",\"()((()))\",\"((())())\",\"(())()()\",\"()(())()\",\"(()(()))\",\"()(())()\",\"()()(())\",\"((()()))\",\"(()())()\",\"()(()())\",\"(()()())\",\"()()()()\"]\\nExpected : [\"(((())))\",\"((()()))\",\"((())())\",\"((()))()\",\"(()(()))\",\"(()()())\",\"(()())()\",\"(())(())\",\"(())()()\",\"()((()))\",\"()(()())\",\"()(())()\",\"()()(())\",\"()()()()\"]\\nI\\'m not using recursion, how can I change the order ?\\nHere\\'s my solution:\\npublic List<String> generateParenthesis(int n) {\\n        List<String> combinations = new ArrayList<String>();\\n        List<String> combinations1 = new ArrayList<String>();\\n        if(n == 0)\\n            return combinations;\\n        combinations.add(\"()\");\\n        if(n == 1) {\\n            return combinations;\\n        }\\n        for( int i = 2; i <= n; i++) {   \\n            combinations1.clear();      \\n            for(String j : combinations) {\\n                String temp1 = j.concat(\"()\");\\n                String temp2 = \"()\".concat(j);\\n                combinations1.add(\"(\" + j + \")\");\\n                if(!temp1.equals(temp2)) {\\n                    combinations1.add(temp1);\\n                    combinations1.add(temp2);\\n                }  \\n                else {\\n                    combinations1.add(temp1);           \\n            }\\n            combinations.clear();\\n            combinations.addAll(combinations1);           \\n        }\\n        return combinations;\\n    }\\n"
                    },
                    {
                        "username": "maurei",
                        "content": "My solution is also recursive but pretty different from keeping track of `openCount` and `closeCount`. I don\\'t really know how my solution relates. Does anyone have a better idea on this?\\n\\n I wrote down the first few cases and observed how I could eg obtain n=3 from n=2. The trick is to iterate over the combinations of n=2 and insert a `()` left and right of every opening `()` UNTIl you run into the first closing bracket `(`.\\n\\nLet me write that out with an example. I use `_()_` to denote which pair of brackets was newly introduced.\\n\\ntake `n=2`. (A)`(())` and (B) `()()`.\\n\\n(A) becomes: `_()_(())`,  `(_()_())` and `((_()_))`. Thats where we stop because after the last insertion, we run into the first closing bracket\\n(B) becomes: `_()_()()` and `(_()_)()`. Thats where we stop, again, because there is a closing bracket next.\\n\\nIt runs pretty damn fast. The code is here (can be written for better space but wanted to keep it readable for discussion here).\\n\\nIt works, but im not sure why.\\n\\n```c#\\npublic class Solution\\n{\\n    public IList<string> GenerateParenthesis(int n) \\n    {\\n        if (n == 0)\\n        {\\n            return Array.Empty<string>();\\n        }\\n\\n        if (n == 1)\\n        {\\n            return new List<string> { \"()\" };\\n        }\\n\\n        List<string> combinations = new List<string>();\\n\\n        IList<string> previousCombinations = GenerateParenthesis(n - 1);\\n\\n        foreach (string previous in previousCombinations)\\n        {\\n            List<string> current = GetCurrentConfig(previous);\\n            combinations.AddRange(current);\\n        }\\n\\n        return combinations;\\n    }\\n\\n    private List<string> GetCurrentConfig(string previous)\\n    {\\n        List<char> characters = previous.ToCharArray().ToList();\\n\\n        List<string> result = new();\\n        \\n        for (int i = 0; i < characters.Count; i++)\\n        {\\n            List<char> clone = new List<char>(characters);\\n            clone.Insert(i, \\')\\');\\n            clone.Insert(i, \\'(\\');\\n            result.Add(new string(clone.ToArray()));\\n            \\n            if (characters[i] == \\')\\')\\n            {\\n                break;\\n            }\\n        }\\n\\n        return result;\\n    }\\n}\\n```\\n"
                    },
                    {
                        "username": "zalars",
                        "content": "I found that the number of all combinations with N parenthesis pairs consists of two groups:\\n1. \"(\"+C(N-1)+\")\", where C(N-1) - all combiantions with N-1 parenthesis pairs;\\n2. All suitable concatenated sequences of all lower N\\'s combinations.\\n\\nAnd the second group is difficult to program for me even using a hash table. Besides time complexity doesn\\'t seem to be improved as well."
                    }
                ]
            },
            {
                "id": 1991502,
                "content": [
                    {
                        "username": "mayursonowal7",
                        "content": "leetcode getting naughtier day by day"
                    },
                    {
                        "username": "layyy",
                        "content": "keep the condition open brackets<n and close brackets<open brackets and recurse accordingly"
                    },
                    {
                        "username": "atharva2406",
                        "content": "Hi can anyone explain to me why my solution is not working\\nclass Solution {\\npublic:\\n    void backtrack(int open, int closed, int n, vector<string> res, stack<char> &st){\\n        if(open == closed and open == n && st.size() == n*2){\\n            string t = \" \";\\n            while(!st.empty()){\\n                t += st.top();\\n                st.pop();\\n            }\\n            reverse(t.begin(), t.end());\\n            res.push_back(t);\\n            return;\\n        }\\n        if(open < n){\\n            st.push(\\'(\\');\\n            backtrack(open+1, closed, n, res, st);\\n            st.pop();\\n        }\\n        if(closed < open){\\n            st.push(\\')\\');\\n            backtrack(open, closed+1, n, res, st);\\n            st.pop();\\n        }\\n        return;\\n    }\\n    vector<string> generateParenthesis(int n) {\\n        vector<string> ans;\\n        int open = 0, closed = 0;\\n        stack<char> st;\\n        backtrack(open, closed, n, ans, st);\\n        return ans;\\n    }\\n};"
                    },
                    {
                        "username": "Shiv_1203",
                        "content": "just count opening brackets and closing bracket \\nthere are two conditions \\nif opening brackets are less than n then string+\\'(\\' and increase opening bracket count\\nif closing brackets are less than opening brackets then string+\\')\\' and increase closing bracket count\\nbase condition =  if both are equal store teh string in vector and return"
                    },
                    {
                        "username": "RK_9097",
                        "content": "class Solution {\\n    private boolean isValid(String pString) {\\n        int leftCount = 0;\\n        for (char p : pString.toCharArray()) {\\n            if (p == \\'(\\') {\\n                leftCount++;\\n            } else {\\n                leftCount--;\\n            } \\n\\n            if (leftCount < 0) {\\n                return false;\\n            }\\n        }\\n        return leftCount == 0;\\n    }\\n    \\n    public List<String> generateParenthesis(int n) {\\n        List<String> answer = new ArrayList<>();\\n        Queue<String> queue = new LinkedList<>(Arrays.asList(\"\"));\\n\\n        while (!queue.isEmpty()) {\\n            String curString = queue.poll();\\n\\n            // If the length of curString is 2 * n, add it to `answer` if\\n            // it is valid. \\n            if (curString.length() == 2 * n) {\\n                if (isValid(curString)) {\\n                    answer.add(curString);\\n                }\\n                continue;\\n            }\\n            queue.offer(curString + \")\");\\n            queue.offer(curString + \"(\");\\n        }\\n\\n        return answer;\\n    }\\n}"
                    },
                    {
                        "username": "Divyam6969",
                        "content": "How can  we solve this iteratively?\n"
                    },
                    {
                        "username": "maurei",
                        "content": "I think in my solution the recursive call be converted to a while loop pretty straightforwardly: https://leetcode.com/problems/generate-parentheses/description/comments/1870152"
                    },
                    {
                        "username": "saurabhDtu15",
                        "content": "Can someone help me with the time and space complexity for the following?\\nMy logic: Keeping count of opening brackets and closing brackets. Opening brackets cannot be more than n in any case and closing brackets should always be less than opening.\\n\\n`class Solution {\\n    List<String> res;\\n    public List<String> generateParenthesis(int n) {\\n        res = new ArrayList<>();\\n        brackets(n*2, 0, 0, \"\", 0);\\n        return res;\\n    }\\n\\n    private void brackets(int n, int strl, int strr, String str, int count) {\\n        if(str.length() == n) {\\n            res.add(str);\\n            return;\\n        }\\n        if(strl < n/2)\\n            brackets(n, strl + 1, strr, str + \\'(\\', count + 1);\\n        if(strr < strl) {\\n            brackets(n, strl, strr + 1, str + \\')\\', count + 1);\\n        }\\n    }\\n}`"
                    },
                    {
                        "username": "ideintTe",
                        "content": "For n =4;\\nOutput : [\"(((())))\",\"((()))()\",\"()((()))\",\"((())())\",\"(())()()\",\"()(())()\",\"(()(()))\",\"()(())()\",\"()()(())\",\"((()()))\",\"(()())()\",\"()(()())\",\"(()()())\",\"()()()()\"]\\nExpected : [\"(((())))\",\"((()()))\",\"((())())\",\"((()))()\",\"(()(()))\",\"(()()())\",\"(()())()\",\"(())(())\",\"(())()()\",\"()((()))\",\"()(()())\",\"()(())()\",\"()()(())\",\"()()()()\"]\\nI\\'m not using recursion, how can I change the order ?\\nHere\\'s my solution:\\npublic List<String> generateParenthesis(int n) {\\n        List<String> combinations = new ArrayList<String>();\\n        List<String> combinations1 = new ArrayList<String>();\\n        if(n == 0)\\n            return combinations;\\n        combinations.add(\"()\");\\n        if(n == 1) {\\n            return combinations;\\n        }\\n        for( int i = 2; i <= n; i++) {   \\n            combinations1.clear();      \\n            for(String j : combinations) {\\n                String temp1 = j.concat(\"()\");\\n                String temp2 = \"()\".concat(j);\\n                combinations1.add(\"(\" + j + \")\");\\n                if(!temp1.equals(temp2)) {\\n                    combinations1.add(temp1);\\n                    combinations1.add(temp2);\\n                }  \\n                else {\\n                    combinations1.add(temp1);           \\n            }\\n            combinations.clear();\\n            combinations.addAll(combinations1);           \\n        }\\n        return combinations;\\n    }\\n"
                    },
                    {
                        "username": "maurei",
                        "content": "My solution is also recursive but pretty different from keeping track of `openCount` and `closeCount`. I don\\'t really know how my solution relates. Does anyone have a better idea on this?\\n\\n I wrote down the first few cases and observed how I could eg obtain n=3 from n=2. The trick is to iterate over the combinations of n=2 and insert a `()` left and right of every opening `()` UNTIl you run into the first closing bracket `(`.\\n\\nLet me write that out with an example. I use `_()_` to denote which pair of brackets was newly introduced.\\n\\ntake `n=2`. (A)`(())` and (B) `()()`.\\n\\n(A) becomes: `_()_(())`,  `(_()_())` and `((_()_))`. Thats where we stop because after the last insertion, we run into the first closing bracket\\n(B) becomes: `_()_()()` and `(_()_)()`. Thats where we stop, again, because there is a closing bracket next.\\n\\nIt runs pretty damn fast. The code is here (can be written for better space but wanted to keep it readable for discussion here).\\n\\nIt works, but im not sure why.\\n\\n```c#\\npublic class Solution\\n{\\n    public IList<string> GenerateParenthesis(int n) \\n    {\\n        if (n == 0)\\n        {\\n            return Array.Empty<string>();\\n        }\\n\\n        if (n == 1)\\n        {\\n            return new List<string> { \"()\" };\\n        }\\n\\n        List<string> combinations = new List<string>();\\n\\n        IList<string> previousCombinations = GenerateParenthesis(n - 1);\\n\\n        foreach (string previous in previousCombinations)\\n        {\\n            List<string> current = GetCurrentConfig(previous);\\n            combinations.AddRange(current);\\n        }\\n\\n        return combinations;\\n    }\\n\\n    private List<string> GetCurrentConfig(string previous)\\n    {\\n        List<char> characters = previous.ToCharArray().ToList();\\n\\n        List<string> result = new();\\n        \\n        for (int i = 0; i < characters.Count; i++)\\n        {\\n            List<char> clone = new List<char>(characters);\\n            clone.Insert(i, \\')\\');\\n            clone.Insert(i, \\'(\\');\\n            result.Add(new string(clone.ToArray()));\\n            \\n            if (characters[i] == \\')\\')\\n            {\\n                break;\\n            }\\n        }\\n\\n        return result;\\n    }\\n}\\n```\\n"
                    },
                    {
                        "username": "zalars",
                        "content": "I found that the number of all combinations with N parenthesis pairs consists of two groups:\\n1. \"(\"+C(N-1)+\")\", where C(N-1) - all combiantions with N-1 parenthesis pairs;\\n2. All suitable concatenated sequences of all lower N\\'s combinations.\\n\\nAnd the second group is difficult to program for me even using a hash table. Besides time complexity doesn\\'t seem to be improved as well."
                    }
                ]
            },
            {
                "id": 1967225,
                "content": [
                    {
                        "username": "mayursonowal7",
                        "content": "leetcode getting naughtier day by day"
                    },
                    {
                        "username": "layyy",
                        "content": "keep the condition open brackets<n and close brackets<open brackets and recurse accordingly"
                    },
                    {
                        "username": "atharva2406",
                        "content": "Hi can anyone explain to me why my solution is not working\\nclass Solution {\\npublic:\\n    void backtrack(int open, int closed, int n, vector<string> res, stack<char> &st){\\n        if(open == closed and open == n && st.size() == n*2){\\n            string t = \" \";\\n            while(!st.empty()){\\n                t += st.top();\\n                st.pop();\\n            }\\n            reverse(t.begin(), t.end());\\n            res.push_back(t);\\n            return;\\n        }\\n        if(open < n){\\n            st.push(\\'(\\');\\n            backtrack(open+1, closed, n, res, st);\\n            st.pop();\\n        }\\n        if(closed < open){\\n            st.push(\\')\\');\\n            backtrack(open, closed+1, n, res, st);\\n            st.pop();\\n        }\\n        return;\\n    }\\n    vector<string> generateParenthesis(int n) {\\n        vector<string> ans;\\n        int open = 0, closed = 0;\\n        stack<char> st;\\n        backtrack(open, closed, n, ans, st);\\n        return ans;\\n    }\\n};"
                    },
                    {
                        "username": "Shiv_1203",
                        "content": "just count opening brackets and closing bracket \\nthere are two conditions \\nif opening brackets are less than n then string+\\'(\\' and increase opening bracket count\\nif closing brackets are less than opening brackets then string+\\')\\' and increase closing bracket count\\nbase condition =  if both are equal store teh string in vector and return"
                    },
                    {
                        "username": "RK_9097",
                        "content": "class Solution {\\n    private boolean isValid(String pString) {\\n        int leftCount = 0;\\n        for (char p : pString.toCharArray()) {\\n            if (p == \\'(\\') {\\n                leftCount++;\\n            } else {\\n                leftCount--;\\n            } \\n\\n            if (leftCount < 0) {\\n                return false;\\n            }\\n        }\\n        return leftCount == 0;\\n    }\\n    \\n    public List<String> generateParenthesis(int n) {\\n        List<String> answer = new ArrayList<>();\\n        Queue<String> queue = new LinkedList<>(Arrays.asList(\"\"));\\n\\n        while (!queue.isEmpty()) {\\n            String curString = queue.poll();\\n\\n            // If the length of curString is 2 * n, add it to `answer` if\\n            // it is valid. \\n            if (curString.length() == 2 * n) {\\n                if (isValid(curString)) {\\n                    answer.add(curString);\\n                }\\n                continue;\\n            }\\n            queue.offer(curString + \")\");\\n            queue.offer(curString + \"(\");\\n        }\\n\\n        return answer;\\n    }\\n}"
                    },
                    {
                        "username": "Divyam6969",
                        "content": "How can  we solve this iteratively?\n"
                    },
                    {
                        "username": "maurei",
                        "content": "I think in my solution the recursive call be converted to a while loop pretty straightforwardly: https://leetcode.com/problems/generate-parentheses/description/comments/1870152"
                    },
                    {
                        "username": "saurabhDtu15",
                        "content": "Can someone help me with the time and space complexity for the following?\\nMy logic: Keeping count of opening brackets and closing brackets. Opening brackets cannot be more than n in any case and closing brackets should always be less than opening.\\n\\n`class Solution {\\n    List<String> res;\\n    public List<String> generateParenthesis(int n) {\\n        res = new ArrayList<>();\\n        brackets(n*2, 0, 0, \"\", 0);\\n        return res;\\n    }\\n\\n    private void brackets(int n, int strl, int strr, String str, int count) {\\n        if(str.length() == n) {\\n            res.add(str);\\n            return;\\n        }\\n        if(strl < n/2)\\n            brackets(n, strl + 1, strr, str + \\'(\\', count + 1);\\n        if(strr < strl) {\\n            brackets(n, strl, strr + 1, str + \\')\\', count + 1);\\n        }\\n    }\\n}`"
                    },
                    {
                        "username": "ideintTe",
                        "content": "For n =4;\\nOutput : [\"(((())))\",\"((()))()\",\"()((()))\",\"((())())\",\"(())()()\",\"()(())()\",\"(()(()))\",\"()(())()\",\"()()(())\",\"((()()))\",\"(()())()\",\"()(()())\",\"(()()())\",\"()()()()\"]\\nExpected : [\"(((())))\",\"((()()))\",\"((())())\",\"((()))()\",\"(()(()))\",\"(()()())\",\"(()())()\",\"(())(())\",\"(())()()\",\"()((()))\",\"()(()())\",\"()(())()\",\"()()(())\",\"()()()()\"]\\nI\\'m not using recursion, how can I change the order ?\\nHere\\'s my solution:\\npublic List<String> generateParenthesis(int n) {\\n        List<String> combinations = new ArrayList<String>();\\n        List<String> combinations1 = new ArrayList<String>();\\n        if(n == 0)\\n            return combinations;\\n        combinations.add(\"()\");\\n        if(n == 1) {\\n            return combinations;\\n        }\\n        for( int i = 2; i <= n; i++) {   \\n            combinations1.clear();      \\n            for(String j : combinations) {\\n                String temp1 = j.concat(\"()\");\\n                String temp2 = \"()\".concat(j);\\n                combinations1.add(\"(\" + j + \")\");\\n                if(!temp1.equals(temp2)) {\\n                    combinations1.add(temp1);\\n                    combinations1.add(temp2);\\n                }  \\n                else {\\n                    combinations1.add(temp1);           \\n            }\\n            combinations.clear();\\n            combinations.addAll(combinations1);           \\n        }\\n        return combinations;\\n    }\\n"
                    },
                    {
                        "username": "maurei",
                        "content": "My solution is also recursive but pretty different from keeping track of `openCount` and `closeCount`. I don\\'t really know how my solution relates. Does anyone have a better idea on this?\\n\\n I wrote down the first few cases and observed how I could eg obtain n=3 from n=2. The trick is to iterate over the combinations of n=2 and insert a `()` left and right of every opening `()` UNTIl you run into the first closing bracket `(`.\\n\\nLet me write that out with an example. I use `_()_` to denote which pair of brackets was newly introduced.\\n\\ntake `n=2`. (A)`(())` and (B) `()()`.\\n\\n(A) becomes: `_()_(())`,  `(_()_())` and `((_()_))`. Thats where we stop because after the last insertion, we run into the first closing bracket\\n(B) becomes: `_()_()()` and `(_()_)()`. Thats where we stop, again, because there is a closing bracket next.\\n\\nIt runs pretty damn fast. The code is here (can be written for better space but wanted to keep it readable for discussion here).\\n\\nIt works, but im not sure why.\\n\\n```c#\\npublic class Solution\\n{\\n    public IList<string> GenerateParenthesis(int n) \\n    {\\n        if (n == 0)\\n        {\\n            return Array.Empty<string>();\\n        }\\n\\n        if (n == 1)\\n        {\\n            return new List<string> { \"()\" };\\n        }\\n\\n        List<string> combinations = new List<string>();\\n\\n        IList<string> previousCombinations = GenerateParenthesis(n - 1);\\n\\n        foreach (string previous in previousCombinations)\\n        {\\n            List<string> current = GetCurrentConfig(previous);\\n            combinations.AddRange(current);\\n        }\\n\\n        return combinations;\\n    }\\n\\n    private List<string> GetCurrentConfig(string previous)\\n    {\\n        List<char> characters = previous.ToCharArray().ToList();\\n\\n        List<string> result = new();\\n        \\n        for (int i = 0; i < characters.Count; i++)\\n        {\\n            List<char> clone = new List<char>(characters);\\n            clone.Insert(i, \\')\\');\\n            clone.Insert(i, \\'(\\');\\n            result.Add(new string(clone.ToArray()));\\n            \\n            if (characters[i] == \\')\\')\\n            {\\n                break;\\n            }\\n        }\\n\\n        return result;\\n    }\\n}\\n```\\n"
                    },
                    {
                        "username": "zalars",
                        "content": "I found that the number of all combinations with N parenthesis pairs consists of two groups:\\n1. \"(\"+C(N-1)+\")\", where C(N-1) - all combiantions with N-1 parenthesis pairs;\\n2. All suitable concatenated sequences of all lower N\\'s combinations.\\n\\nAnd the second group is difficult to program for me even using a hash table. Besides time complexity doesn\\'t seem to be improved as well."
                    }
                ]
            },
            {
                "id": 1928158,
                "content": [
                    {
                        "username": "mayursonowal7",
                        "content": "leetcode getting naughtier day by day"
                    },
                    {
                        "username": "layyy",
                        "content": "keep the condition open brackets<n and close brackets<open brackets and recurse accordingly"
                    },
                    {
                        "username": "atharva2406",
                        "content": "Hi can anyone explain to me why my solution is not working\\nclass Solution {\\npublic:\\n    void backtrack(int open, int closed, int n, vector<string> res, stack<char> &st){\\n        if(open == closed and open == n && st.size() == n*2){\\n            string t = \" \";\\n            while(!st.empty()){\\n                t += st.top();\\n                st.pop();\\n            }\\n            reverse(t.begin(), t.end());\\n            res.push_back(t);\\n            return;\\n        }\\n        if(open < n){\\n            st.push(\\'(\\');\\n            backtrack(open+1, closed, n, res, st);\\n            st.pop();\\n        }\\n        if(closed < open){\\n            st.push(\\')\\');\\n            backtrack(open, closed+1, n, res, st);\\n            st.pop();\\n        }\\n        return;\\n    }\\n    vector<string> generateParenthesis(int n) {\\n        vector<string> ans;\\n        int open = 0, closed = 0;\\n        stack<char> st;\\n        backtrack(open, closed, n, ans, st);\\n        return ans;\\n    }\\n};"
                    },
                    {
                        "username": "Shiv_1203",
                        "content": "just count opening brackets and closing bracket \\nthere are two conditions \\nif opening brackets are less than n then string+\\'(\\' and increase opening bracket count\\nif closing brackets are less than opening brackets then string+\\')\\' and increase closing bracket count\\nbase condition =  if both are equal store teh string in vector and return"
                    },
                    {
                        "username": "RK_9097",
                        "content": "class Solution {\\n    private boolean isValid(String pString) {\\n        int leftCount = 0;\\n        for (char p : pString.toCharArray()) {\\n            if (p == \\'(\\') {\\n                leftCount++;\\n            } else {\\n                leftCount--;\\n            } \\n\\n            if (leftCount < 0) {\\n                return false;\\n            }\\n        }\\n        return leftCount == 0;\\n    }\\n    \\n    public List<String> generateParenthesis(int n) {\\n        List<String> answer = new ArrayList<>();\\n        Queue<String> queue = new LinkedList<>(Arrays.asList(\"\"));\\n\\n        while (!queue.isEmpty()) {\\n            String curString = queue.poll();\\n\\n            // If the length of curString is 2 * n, add it to `answer` if\\n            // it is valid. \\n            if (curString.length() == 2 * n) {\\n                if (isValid(curString)) {\\n                    answer.add(curString);\\n                }\\n                continue;\\n            }\\n            queue.offer(curString + \")\");\\n            queue.offer(curString + \"(\");\\n        }\\n\\n        return answer;\\n    }\\n}"
                    },
                    {
                        "username": "Divyam6969",
                        "content": "How can  we solve this iteratively?\n"
                    },
                    {
                        "username": "maurei",
                        "content": "I think in my solution the recursive call be converted to a while loop pretty straightforwardly: https://leetcode.com/problems/generate-parentheses/description/comments/1870152"
                    },
                    {
                        "username": "saurabhDtu15",
                        "content": "Can someone help me with the time and space complexity for the following?\\nMy logic: Keeping count of opening brackets and closing brackets. Opening brackets cannot be more than n in any case and closing brackets should always be less than opening.\\n\\n`class Solution {\\n    List<String> res;\\n    public List<String> generateParenthesis(int n) {\\n        res = new ArrayList<>();\\n        brackets(n*2, 0, 0, \"\", 0);\\n        return res;\\n    }\\n\\n    private void brackets(int n, int strl, int strr, String str, int count) {\\n        if(str.length() == n) {\\n            res.add(str);\\n            return;\\n        }\\n        if(strl < n/2)\\n            brackets(n, strl + 1, strr, str + \\'(\\', count + 1);\\n        if(strr < strl) {\\n            brackets(n, strl, strr + 1, str + \\')\\', count + 1);\\n        }\\n    }\\n}`"
                    },
                    {
                        "username": "ideintTe",
                        "content": "For n =4;\\nOutput : [\"(((())))\",\"((()))()\",\"()((()))\",\"((())())\",\"(())()()\",\"()(())()\",\"(()(()))\",\"()(())()\",\"()()(())\",\"((()()))\",\"(()())()\",\"()(()())\",\"(()()())\",\"()()()()\"]\\nExpected : [\"(((())))\",\"((()()))\",\"((())())\",\"((()))()\",\"(()(()))\",\"(()()())\",\"(()())()\",\"(())(())\",\"(())()()\",\"()((()))\",\"()(()())\",\"()(())()\",\"()()(())\",\"()()()()\"]\\nI\\'m not using recursion, how can I change the order ?\\nHere\\'s my solution:\\npublic List<String> generateParenthesis(int n) {\\n        List<String> combinations = new ArrayList<String>();\\n        List<String> combinations1 = new ArrayList<String>();\\n        if(n == 0)\\n            return combinations;\\n        combinations.add(\"()\");\\n        if(n == 1) {\\n            return combinations;\\n        }\\n        for( int i = 2; i <= n; i++) {   \\n            combinations1.clear();      \\n            for(String j : combinations) {\\n                String temp1 = j.concat(\"()\");\\n                String temp2 = \"()\".concat(j);\\n                combinations1.add(\"(\" + j + \")\");\\n                if(!temp1.equals(temp2)) {\\n                    combinations1.add(temp1);\\n                    combinations1.add(temp2);\\n                }  \\n                else {\\n                    combinations1.add(temp1);           \\n            }\\n            combinations.clear();\\n            combinations.addAll(combinations1);           \\n        }\\n        return combinations;\\n    }\\n"
                    },
                    {
                        "username": "maurei",
                        "content": "My solution is also recursive but pretty different from keeping track of `openCount` and `closeCount`. I don\\'t really know how my solution relates. Does anyone have a better idea on this?\\n\\n I wrote down the first few cases and observed how I could eg obtain n=3 from n=2. The trick is to iterate over the combinations of n=2 and insert a `()` left and right of every opening `()` UNTIl you run into the first closing bracket `(`.\\n\\nLet me write that out with an example. I use `_()_` to denote which pair of brackets was newly introduced.\\n\\ntake `n=2`. (A)`(())` and (B) `()()`.\\n\\n(A) becomes: `_()_(())`,  `(_()_())` and `((_()_))`. Thats where we stop because after the last insertion, we run into the first closing bracket\\n(B) becomes: `_()_()()` and `(_()_)()`. Thats where we stop, again, because there is a closing bracket next.\\n\\nIt runs pretty damn fast. The code is here (can be written for better space but wanted to keep it readable for discussion here).\\n\\nIt works, but im not sure why.\\n\\n```c#\\npublic class Solution\\n{\\n    public IList<string> GenerateParenthesis(int n) \\n    {\\n        if (n == 0)\\n        {\\n            return Array.Empty<string>();\\n        }\\n\\n        if (n == 1)\\n        {\\n            return new List<string> { \"()\" };\\n        }\\n\\n        List<string> combinations = new List<string>();\\n\\n        IList<string> previousCombinations = GenerateParenthesis(n - 1);\\n\\n        foreach (string previous in previousCombinations)\\n        {\\n            List<string> current = GetCurrentConfig(previous);\\n            combinations.AddRange(current);\\n        }\\n\\n        return combinations;\\n    }\\n\\n    private List<string> GetCurrentConfig(string previous)\\n    {\\n        List<char> characters = previous.ToCharArray().ToList();\\n\\n        List<string> result = new();\\n        \\n        for (int i = 0; i < characters.Count; i++)\\n        {\\n            List<char> clone = new List<char>(characters);\\n            clone.Insert(i, \\')\\');\\n            clone.Insert(i, \\'(\\');\\n            result.Add(new string(clone.ToArray()));\\n            \\n            if (characters[i] == \\')\\')\\n            {\\n                break;\\n            }\\n        }\\n\\n        return result;\\n    }\\n}\\n```\\n"
                    },
                    {
                        "username": "zalars",
                        "content": "I found that the number of all combinations with N parenthesis pairs consists of two groups:\\n1. \"(\"+C(N-1)+\")\", where C(N-1) - all combiantions with N-1 parenthesis pairs;\\n2. All suitable concatenated sequences of all lower N\\'s combinations.\\n\\nAnd the second group is difficult to program for me even using a hash table. Besides time complexity doesn\\'t seem to be improved as well."
                    }
                ]
            },
            {
                "id": 1891528,
                "content": [
                    {
                        "username": "mayursonowal7",
                        "content": "leetcode getting naughtier day by day"
                    },
                    {
                        "username": "layyy",
                        "content": "keep the condition open brackets<n and close brackets<open brackets and recurse accordingly"
                    },
                    {
                        "username": "atharva2406",
                        "content": "Hi can anyone explain to me why my solution is not working\\nclass Solution {\\npublic:\\n    void backtrack(int open, int closed, int n, vector<string> res, stack<char> &st){\\n        if(open == closed and open == n && st.size() == n*2){\\n            string t = \" \";\\n            while(!st.empty()){\\n                t += st.top();\\n                st.pop();\\n            }\\n            reverse(t.begin(), t.end());\\n            res.push_back(t);\\n            return;\\n        }\\n        if(open < n){\\n            st.push(\\'(\\');\\n            backtrack(open+1, closed, n, res, st);\\n            st.pop();\\n        }\\n        if(closed < open){\\n            st.push(\\')\\');\\n            backtrack(open, closed+1, n, res, st);\\n            st.pop();\\n        }\\n        return;\\n    }\\n    vector<string> generateParenthesis(int n) {\\n        vector<string> ans;\\n        int open = 0, closed = 0;\\n        stack<char> st;\\n        backtrack(open, closed, n, ans, st);\\n        return ans;\\n    }\\n};"
                    },
                    {
                        "username": "Shiv_1203",
                        "content": "just count opening brackets and closing bracket \\nthere are two conditions \\nif opening brackets are less than n then string+\\'(\\' and increase opening bracket count\\nif closing brackets are less than opening brackets then string+\\')\\' and increase closing bracket count\\nbase condition =  if both are equal store teh string in vector and return"
                    },
                    {
                        "username": "RK_9097",
                        "content": "class Solution {\\n    private boolean isValid(String pString) {\\n        int leftCount = 0;\\n        for (char p : pString.toCharArray()) {\\n            if (p == \\'(\\') {\\n                leftCount++;\\n            } else {\\n                leftCount--;\\n            } \\n\\n            if (leftCount < 0) {\\n                return false;\\n            }\\n        }\\n        return leftCount == 0;\\n    }\\n    \\n    public List<String> generateParenthesis(int n) {\\n        List<String> answer = new ArrayList<>();\\n        Queue<String> queue = new LinkedList<>(Arrays.asList(\"\"));\\n\\n        while (!queue.isEmpty()) {\\n            String curString = queue.poll();\\n\\n            // If the length of curString is 2 * n, add it to `answer` if\\n            // it is valid. \\n            if (curString.length() == 2 * n) {\\n                if (isValid(curString)) {\\n                    answer.add(curString);\\n                }\\n                continue;\\n            }\\n            queue.offer(curString + \")\");\\n            queue.offer(curString + \"(\");\\n        }\\n\\n        return answer;\\n    }\\n}"
                    },
                    {
                        "username": "Divyam6969",
                        "content": "How can  we solve this iteratively?\n"
                    },
                    {
                        "username": "maurei",
                        "content": "I think in my solution the recursive call be converted to a while loop pretty straightforwardly: https://leetcode.com/problems/generate-parentheses/description/comments/1870152"
                    },
                    {
                        "username": "saurabhDtu15",
                        "content": "Can someone help me with the time and space complexity for the following?\\nMy logic: Keeping count of opening brackets and closing brackets. Opening brackets cannot be more than n in any case and closing brackets should always be less than opening.\\n\\n`class Solution {\\n    List<String> res;\\n    public List<String> generateParenthesis(int n) {\\n        res = new ArrayList<>();\\n        brackets(n*2, 0, 0, \"\", 0);\\n        return res;\\n    }\\n\\n    private void brackets(int n, int strl, int strr, String str, int count) {\\n        if(str.length() == n) {\\n            res.add(str);\\n            return;\\n        }\\n        if(strl < n/2)\\n            brackets(n, strl + 1, strr, str + \\'(\\', count + 1);\\n        if(strr < strl) {\\n            brackets(n, strl, strr + 1, str + \\')\\', count + 1);\\n        }\\n    }\\n}`"
                    },
                    {
                        "username": "ideintTe",
                        "content": "For n =4;\\nOutput : [\"(((())))\",\"((()))()\",\"()((()))\",\"((())())\",\"(())()()\",\"()(())()\",\"(()(()))\",\"()(())()\",\"()()(())\",\"((()()))\",\"(()())()\",\"()(()())\",\"(()()())\",\"()()()()\"]\\nExpected : [\"(((())))\",\"((()()))\",\"((())())\",\"((()))()\",\"(()(()))\",\"(()()())\",\"(()())()\",\"(())(())\",\"(())()()\",\"()((()))\",\"()(()())\",\"()(())()\",\"()()(())\",\"()()()()\"]\\nI\\'m not using recursion, how can I change the order ?\\nHere\\'s my solution:\\npublic List<String> generateParenthesis(int n) {\\n        List<String> combinations = new ArrayList<String>();\\n        List<String> combinations1 = new ArrayList<String>();\\n        if(n == 0)\\n            return combinations;\\n        combinations.add(\"()\");\\n        if(n == 1) {\\n            return combinations;\\n        }\\n        for( int i = 2; i <= n; i++) {   \\n            combinations1.clear();      \\n            for(String j : combinations) {\\n                String temp1 = j.concat(\"()\");\\n                String temp2 = \"()\".concat(j);\\n                combinations1.add(\"(\" + j + \")\");\\n                if(!temp1.equals(temp2)) {\\n                    combinations1.add(temp1);\\n                    combinations1.add(temp2);\\n                }  \\n                else {\\n                    combinations1.add(temp1);           \\n            }\\n            combinations.clear();\\n            combinations.addAll(combinations1);           \\n        }\\n        return combinations;\\n    }\\n"
                    },
                    {
                        "username": "maurei",
                        "content": "My solution is also recursive but pretty different from keeping track of `openCount` and `closeCount`. I don\\'t really know how my solution relates. Does anyone have a better idea on this?\\n\\n I wrote down the first few cases and observed how I could eg obtain n=3 from n=2. The trick is to iterate over the combinations of n=2 and insert a `()` left and right of every opening `()` UNTIl you run into the first closing bracket `(`.\\n\\nLet me write that out with an example. I use `_()_` to denote which pair of brackets was newly introduced.\\n\\ntake `n=2`. (A)`(())` and (B) `()()`.\\n\\n(A) becomes: `_()_(())`,  `(_()_())` and `((_()_))`. Thats where we stop because after the last insertion, we run into the first closing bracket\\n(B) becomes: `_()_()()` and `(_()_)()`. Thats where we stop, again, because there is a closing bracket next.\\n\\nIt runs pretty damn fast. The code is here (can be written for better space but wanted to keep it readable for discussion here).\\n\\nIt works, but im not sure why.\\n\\n```c#\\npublic class Solution\\n{\\n    public IList<string> GenerateParenthesis(int n) \\n    {\\n        if (n == 0)\\n        {\\n            return Array.Empty<string>();\\n        }\\n\\n        if (n == 1)\\n        {\\n            return new List<string> { \"()\" };\\n        }\\n\\n        List<string> combinations = new List<string>();\\n\\n        IList<string> previousCombinations = GenerateParenthesis(n - 1);\\n\\n        foreach (string previous in previousCombinations)\\n        {\\n            List<string> current = GetCurrentConfig(previous);\\n            combinations.AddRange(current);\\n        }\\n\\n        return combinations;\\n    }\\n\\n    private List<string> GetCurrentConfig(string previous)\\n    {\\n        List<char> characters = previous.ToCharArray().ToList();\\n\\n        List<string> result = new();\\n        \\n        for (int i = 0; i < characters.Count; i++)\\n        {\\n            List<char> clone = new List<char>(characters);\\n            clone.Insert(i, \\')\\');\\n            clone.Insert(i, \\'(\\');\\n            result.Add(new string(clone.ToArray()));\\n            \\n            if (characters[i] == \\')\\')\\n            {\\n                break;\\n            }\\n        }\\n\\n        return result;\\n    }\\n}\\n```\\n"
                    },
                    {
                        "username": "zalars",
                        "content": "I found that the number of all combinations with N parenthesis pairs consists of two groups:\\n1. \"(\"+C(N-1)+\")\", where C(N-1) - all combiantions with N-1 parenthesis pairs;\\n2. All suitable concatenated sequences of all lower N\\'s combinations.\\n\\nAnd the second group is difficult to program for me even using a hash table. Besides time complexity doesn\\'t seem to be improved as well."
                    }
                ]
            },
            {
                "id": 1872258,
                "content": [
                    {
                        "username": "mayursonowal7",
                        "content": "leetcode getting naughtier day by day"
                    },
                    {
                        "username": "layyy",
                        "content": "keep the condition open brackets<n and close brackets<open brackets and recurse accordingly"
                    },
                    {
                        "username": "atharva2406",
                        "content": "Hi can anyone explain to me why my solution is not working\\nclass Solution {\\npublic:\\n    void backtrack(int open, int closed, int n, vector<string> res, stack<char> &st){\\n        if(open == closed and open == n && st.size() == n*2){\\n            string t = \" \";\\n            while(!st.empty()){\\n                t += st.top();\\n                st.pop();\\n            }\\n            reverse(t.begin(), t.end());\\n            res.push_back(t);\\n            return;\\n        }\\n        if(open < n){\\n            st.push(\\'(\\');\\n            backtrack(open+1, closed, n, res, st);\\n            st.pop();\\n        }\\n        if(closed < open){\\n            st.push(\\')\\');\\n            backtrack(open, closed+1, n, res, st);\\n            st.pop();\\n        }\\n        return;\\n    }\\n    vector<string> generateParenthesis(int n) {\\n        vector<string> ans;\\n        int open = 0, closed = 0;\\n        stack<char> st;\\n        backtrack(open, closed, n, ans, st);\\n        return ans;\\n    }\\n};"
                    },
                    {
                        "username": "Shiv_1203",
                        "content": "just count opening brackets and closing bracket \\nthere are two conditions \\nif opening brackets are less than n then string+\\'(\\' and increase opening bracket count\\nif closing brackets are less than opening brackets then string+\\')\\' and increase closing bracket count\\nbase condition =  if both are equal store teh string in vector and return"
                    },
                    {
                        "username": "RK_9097",
                        "content": "class Solution {\\n    private boolean isValid(String pString) {\\n        int leftCount = 0;\\n        for (char p : pString.toCharArray()) {\\n            if (p == \\'(\\') {\\n                leftCount++;\\n            } else {\\n                leftCount--;\\n            } \\n\\n            if (leftCount < 0) {\\n                return false;\\n            }\\n        }\\n        return leftCount == 0;\\n    }\\n    \\n    public List<String> generateParenthesis(int n) {\\n        List<String> answer = new ArrayList<>();\\n        Queue<String> queue = new LinkedList<>(Arrays.asList(\"\"));\\n\\n        while (!queue.isEmpty()) {\\n            String curString = queue.poll();\\n\\n            // If the length of curString is 2 * n, add it to `answer` if\\n            // it is valid. \\n            if (curString.length() == 2 * n) {\\n                if (isValid(curString)) {\\n                    answer.add(curString);\\n                }\\n                continue;\\n            }\\n            queue.offer(curString + \")\");\\n            queue.offer(curString + \"(\");\\n        }\\n\\n        return answer;\\n    }\\n}"
                    },
                    {
                        "username": "Divyam6969",
                        "content": "How can  we solve this iteratively?\n"
                    },
                    {
                        "username": "maurei",
                        "content": "I think in my solution the recursive call be converted to a while loop pretty straightforwardly: https://leetcode.com/problems/generate-parentheses/description/comments/1870152"
                    },
                    {
                        "username": "saurabhDtu15",
                        "content": "Can someone help me with the time and space complexity for the following?\\nMy logic: Keeping count of opening brackets and closing brackets. Opening brackets cannot be more than n in any case and closing brackets should always be less than opening.\\n\\n`class Solution {\\n    List<String> res;\\n    public List<String> generateParenthesis(int n) {\\n        res = new ArrayList<>();\\n        brackets(n*2, 0, 0, \"\", 0);\\n        return res;\\n    }\\n\\n    private void brackets(int n, int strl, int strr, String str, int count) {\\n        if(str.length() == n) {\\n            res.add(str);\\n            return;\\n        }\\n        if(strl < n/2)\\n            brackets(n, strl + 1, strr, str + \\'(\\', count + 1);\\n        if(strr < strl) {\\n            brackets(n, strl, strr + 1, str + \\')\\', count + 1);\\n        }\\n    }\\n}`"
                    },
                    {
                        "username": "ideintTe",
                        "content": "For n =4;\\nOutput : [\"(((())))\",\"((()))()\",\"()((()))\",\"((())())\",\"(())()()\",\"()(())()\",\"(()(()))\",\"()(())()\",\"()()(())\",\"((()()))\",\"(()())()\",\"()(()())\",\"(()()())\",\"()()()()\"]\\nExpected : [\"(((())))\",\"((()()))\",\"((())())\",\"((()))()\",\"(()(()))\",\"(()()())\",\"(()())()\",\"(())(())\",\"(())()()\",\"()((()))\",\"()(()())\",\"()(())()\",\"()()(())\",\"()()()()\"]\\nI\\'m not using recursion, how can I change the order ?\\nHere\\'s my solution:\\npublic List<String> generateParenthesis(int n) {\\n        List<String> combinations = new ArrayList<String>();\\n        List<String> combinations1 = new ArrayList<String>();\\n        if(n == 0)\\n            return combinations;\\n        combinations.add(\"()\");\\n        if(n == 1) {\\n            return combinations;\\n        }\\n        for( int i = 2; i <= n; i++) {   \\n            combinations1.clear();      \\n            for(String j : combinations) {\\n                String temp1 = j.concat(\"()\");\\n                String temp2 = \"()\".concat(j);\\n                combinations1.add(\"(\" + j + \")\");\\n                if(!temp1.equals(temp2)) {\\n                    combinations1.add(temp1);\\n                    combinations1.add(temp2);\\n                }  \\n                else {\\n                    combinations1.add(temp1);           \\n            }\\n            combinations.clear();\\n            combinations.addAll(combinations1);           \\n        }\\n        return combinations;\\n    }\\n"
                    },
                    {
                        "username": "maurei",
                        "content": "My solution is also recursive but pretty different from keeping track of `openCount` and `closeCount`. I don\\'t really know how my solution relates. Does anyone have a better idea on this?\\n\\n I wrote down the first few cases and observed how I could eg obtain n=3 from n=2. The trick is to iterate over the combinations of n=2 and insert a `()` left and right of every opening `()` UNTIl you run into the first closing bracket `(`.\\n\\nLet me write that out with an example. I use `_()_` to denote which pair of brackets was newly introduced.\\n\\ntake `n=2`. (A)`(())` and (B) `()()`.\\n\\n(A) becomes: `_()_(())`,  `(_()_())` and `((_()_))`. Thats where we stop because after the last insertion, we run into the first closing bracket\\n(B) becomes: `_()_()()` and `(_()_)()`. Thats where we stop, again, because there is a closing bracket next.\\n\\nIt runs pretty damn fast. The code is here (can be written for better space but wanted to keep it readable for discussion here).\\n\\nIt works, but im not sure why.\\n\\n```c#\\npublic class Solution\\n{\\n    public IList<string> GenerateParenthesis(int n) \\n    {\\n        if (n == 0)\\n        {\\n            return Array.Empty<string>();\\n        }\\n\\n        if (n == 1)\\n        {\\n            return new List<string> { \"()\" };\\n        }\\n\\n        List<string> combinations = new List<string>();\\n\\n        IList<string> previousCombinations = GenerateParenthesis(n - 1);\\n\\n        foreach (string previous in previousCombinations)\\n        {\\n            List<string> current = GetCurrentConfig(previous);\\n            combinations.AddRange(current);\\n        }\\n\\n        return combinations;\\n    }\\n\\n    private List<string> GetCurrentConfig(string previous)\\n    {\\n        List<char> characters = previous.ToCharArray().ToList();\\n\\n        List<string> result = new();\\n        \\n        for (int i = 0; i < characters.Count; i++)\\n        {\\n            List<char> clone = new List<char>(characters);\\n            clone.Insert(i, \\')\\');\\n            clone.Insert(i, \\'(\\');\\n            result.Add(new string(clone.ToArray()));\\n            \\n            if (characters[i] == \\')\\')\\n            {\\n                break;\\n            }\\n        }\\n\\n        return result;\\n    }\\n}\\n```\\n"
                    },
                    {
                        "username": "zalars",
                        "content": "I found that the number of all combinations with N parenthesis pairs consists of two groups:\\n1. \"(\"+C(N-1)+\")\", where C(N-1) - all combiantions with N-1 parenthesis pairs;\\n2. All suitable concatenated sequences of all lower N\\'s combinations.\\n\\nAnd the second group is difficult to program for me even using a hash table. Besides time complexity doesn\\'t seem to be improved as well."
                    }
                ]
            },
            {
                "id": 1870152,
                "content": [
                    {
                        "username": "mayursonowal7",
                        "content": "leetcode getting naughtier day by day"
                    },
                    {
                        "username": "layyy",
                        "content": "keep the condition open brackets<n and close brackets<open brackets and recurse accordingly"
                    },
                    {
                        "username": "atharva2406",
                        "content": "Hi can anyone explain to me why my solution is not working\\nclass Solution {\\npublic:\\n    void backtrack(int open, int closed, int n, vector<string> res, stack<char> &st){\\n        if(open == closed and open == n && st.size() == n*2){\\n            string t = \" \";\\n            while(!st.empty()){\\n                t += st.top();\\n                st.pop();\\n            }\\n            reverse(t.begin(), t.end());\\n            res.push_back(t);\\n            return;\\n        }\\n        if(open < n){\\n            st.push(\\'(\\');\\n            backtrack(open+1, closed, n, res, st);\\n            st.pop();\\n        }\\n        if(closed < open){\\n            st.push(\\')\\');\\n            backtrack(open, closed+1, n, res, st);\\n            st.pop();\\n        }\\n        return;\\n    }\\n    vector<string> generateParenthesis(int n) {\\n        vector<string> ans;\\n        int open = 0, closed = 0;\\n        stack<char> st;\\n        backtrack(open, closed, n, ans, st);\\n        return ans;\\n    }\\n};"
                    },
                    {
                        "username": "Shiv_1203",
                        "content": "just count opening brackets and closing bracket \\nthere are two conditions \\nif opening brackets are less than n then string+\\'(\\' and increase opening bracket count\\nif closing brackets are less than opening brackets then string+\\')\\' and increase closing bracket count\\nbase condition =  if both are equal store teh string in vector and return"
                    },
                    {
                        "username": "RK_9097",
                        "content": "class Solution {\\n    private boolean isValid(String pString) {\\n        int leftCount = 0;\\n        for (char p : pString.toCharArray()) {\\n            if (p == \\'(\\') {\\n                leftCount++;\\n            } else {\\n                leftCount--;\\n            } \\n\\n            if (leftCount < 0) {\\n                return false;\\n            }\\n        }\\n        return leftCount == 0;\\n    }\\n    \\n    public List<String> generateParenthesis(int n) {\\n        List<String> answer = new ArrayList<>();\\n        Queue<String> queue = new LinkedList<>(Arrays.asList(\"\"));\\n\\n        while (!queue.isEmpty()) {\\n            String curString = queue.poll();\\n\\n            // If the length of curString is 2 * n, add it to `answer` if\\n            // it is valid. \\n            if (curString.length() == 2 * n) {\\n                if (isValid(curString)) {\\n                    answer.add(curString);\\n                }\\n                continue;\\n            }\\n            queue.offer(curString + \")\");\\n            queue.offer(curString + \"(\");\\n        }\\n\\n        return answer;\\n    }\\n}"
                    },
                    {
                        "username": "Divyam6969",
                        "content": "How can  we solve this iteratively?\n"
                    },
                    {
                        "username": "maurei",
                        "content": "I think in my solution the recursive call be converted to a while loop pretty straightforwardly: https://leetcode.com/problems/generate-parentheses/description/comments/1870152"
                    },
                    {
                        "username": "saurabhDtu15",
                        "content": "Can someone help me with the time and space complexity for the following?\\nMy logic: Keeping count of opening brackets and closing brackets. Opening brackets cannot be more than n in any case and closing brackets should always be less than opening.\\n\\n`class Solution {\\n    List<String> res;\\n    public List<String> generateParenthesis(int n) {\\n        res = new ArrayList<>();\\n        brackets(n*2, 0, 0, \"\", 0);\\n        return res;\\n    }\\n\\n    private void brackets(int n, int strl, int strr, String str, int count) {\\n        if(str.length() == n) {\\n            res.add(str);\\n            return;\\n        }\\n        if(strl < n/2)\\n            brackets(n, strl + 1, strr, str + \\'(\\', count + 1);\\n        if(strr < strl) {\\n            brackets(n, strl, strr + 1, str + \\')\\', count + 1);\\n        }\\n    }\\n}`"
                    },
                    {
                        "username": "ideintTe",
                        "content": "For n =4;\\nOutput : [\"(((())))\",\"((()))()\",\"()((()))\",\"((())())\",\"(())()()\",\"()(())()\",\"(()(()))\",\"()(())()\",\"()()(())\",\"((()()))\",\"(()())()\",\"()(()())\",\"(()()())\",\"()()()()\"]\\nExpected : [\"(((())))\",\"((()()))\",\"((())())\",\"((()))()\",\"(()(()))\",\"(()()())\",\"(()())()\",\"(())(())\",\"(())()()\",\"()((()))\",\"()(()())\",\"()(())()\",\"()()(())\",\"()()()()\"]\\nI\\'m not using recursion, how can I change the order ?\\nHere\\'s my solution:\\npublic List<String> generateParenthesis(int n) {\\n        List<String> combinations = new ArrayList<String>();\\n        List<String> combinations1 = new ArrayList<String>();\\n        if(n == 0)\\n            return combinations;\\n        combinations.add(\"()\");\\n        if(n == 1) {\\n            return combinations;\\n        }\\n        for( int i = 2; i <= n; i++) {   \\n            combinations1.clear();      \\n            for(String j : combinations) {\\n                String temp1 = j.concat(\"()\");\\n                String temp2 = \"()\".concat(j);\\n                combinations1.add(\"(\" + j + \")\");\\n                if(!temp1.equals(temp2)) {\\n                    combinations1.add(temp1);\\n                    combinations1.add(temp2);\\n                }  \\n                else {\\n                    combinations1.add(temp1);           \\n            }\\n            combinations.clear();\\n            combinations.addAll(combinations1);           \\n        }\\n        return combinations;\\n    }\\n"
                    },
                    {
                        "username": "maurei",
                        "content": "My solution is also recursive but pretty different from keeping track of `openCount` and `closeCount`. I don\\'t really know how my solution relates. Does anyone have a better idea on this?\\n\\n I wrote down the first few cases and observed how I could eg obtain n=3 from n=2. The trick is to iterate over the combinations of n=2 and insert a `()` left and right of every opening `()` UNTIl you run into the first closing bracket `(`.\\n\\nLet me write that out with an example. I use `_()_` to denote which pair of brackets was newly introduced.\\n\\ntake `n=2`. (A)`(())` and (B) `()()`.\\n\\n(A) becomes: `_()_(())`,  `(_()_())` and `((_()_))`. Thats where we stop because after the last insertion, we run into the first closing bracket\\n(B) becomes: `_()_()()` and `(_()_)()`. Thats where we stop, again, because there is a closing bracket next.\\n\\nIt runs pretty damn fast. The code is here (can be written for better space but wanted to keep it readable for discussion here).\\n\\nIt works, but im not sure why.\\n\\n```c#\\npublic class Solution\\n{\\n    public IList<string> GenerateParenthesis(int n) \\n    {\\n        if (n == 0)\\n        {\\n            return Array.Empty<string>();\\n        }\\n\\n        if (n == 1)\\n        {\\n            return new List<string> { \"()\" };\\n        }\\n\\n        List<string> combinations = new List<string>();\\n\\n        IList<string> previousCombinations = GenerateParenthesis(n - 1);\\n\\n        foreach (string previous in previousCombinations)\\n        {\\n            List<string> current = GetCurrentConfig(previous);\\n            combinations.AddRange(current);\\n        }\\n\\n        return combinations;\\n    }\\n\\n    private List<string> GetCurrentConfig(string previous)\\n    {\\n        List<char> characters = previous.ToCharArray().ToList();\\n\\n        List<string> result = new();\\n        \\n        for (int i = 0; i < characters.Count; i++)\\n        {\\n            List<char> clone = new List<char>(characters);\\n            clone.Insert(i, \\')\\');\\n            clone.Insert(i, \\'(\\');\\n            result.Add(new string(clone.ToArray()));\\n            \\n            if (characters[i] == \\')\\')\\n            {\\n                break;\\n            }\\n        }\\n\\n        return result;\\n    }\\n}\\n```\\n"
                    },
                    {
                        "username": "zalars",
                        "content": "I found that the number of all combinations with N parenthesis pairs consists of two groups:\\n1. \"(\"+C(N-1)+\")\", where C(N-1) - all combiantions with N-1 parenthesis pairs;\\n2. All suitable concatenated sequences of all lower N\\'s combinations.\\n\\nAnd the second group is difficult to program for me even using a hash table. Besides time complexity doesn\\'t seem to be improved as well."
                    }
                ]
            },
            {
                "id": 1852609,
                "content": [
                    {
                        "username": "mayursonowal7",
                        "content": "leetcode getting naughtier day by day"
                    },
                    {
                        "username": "layyy",
                        "content": "keep the condition open brackets<n and close brackets<open brackets and recurse accordingly"
                    },
                    {
                        "username": "atharva2406",
                        "content": "Hi can anyone explain to me why my solution is not working\\nclass Solution {\\npublic:\\n    void backtrack(int open, int closed, int n, vector<string> res, stack<char> &st){\\n        if(open == closed and open == n && st.size() == n*2){\\n            string t = \" \";\\n            while(!st.empty()){\\n                t += st.top();\\n                st.pop();\\n            }\\n            reverse(t.begin(), t.end());\\n            res.push_back(t);\\n            return;\\n        }\\n        if(open < n){\\n            st.push(\\'(\\');\\n            backtrack(open+1, closed, n, res, st);\\n            st.pop();\\n        }\\n        if(closed < open){\\n            st.push(\\')\\');\\n            backtrack(open, closed+1, n, res, st);\\n            st.pop();\\n        }\\n        return;\\n    }\\n    vector<string> generateParenthesis(int n) {\\n        vector<string> ans;\\n        int open = 0, closed = 0;\\n        stack<char> st;\\n        backtrack(open, closed, n, ans, st);\\n        return ans;\\n    }\\n};"
                    },
                    {
                        "username": "Shiv_1203",
                        "content": "just count opening brackets and closing bracket \\nthere are two conditions \\nif opening brackets are less than n then string+\\'(\\' and increase opening bracket count\\nif closing brackets are less than opening brackets then string+\\')\\' and increase closing bracket count\\nbase condition =  if both are equal store teh string in vector and return"
                    },
                    {
                        "username": "RK_9097",
                        "content": "class Solution {\\n    private boolean isValid(String pString) {\\n        int leftCount = 0;\\n        for (char p : pString.toCharArray()) {\\n            if (p == \\'(\\') {\\n                leftCount++;\\n            } else {\\n                leftCount--;\\n            } \\n\\n            if (leftCount < 0) {\\n                return false;\\n            }\\n        }\\n        return leftCount == 0;\\n    }\\n    \\n    public List<String> generateParenthesis(int n) {\\n        List<String> answer = new ArrayList<>();\\n        Queue<String> queue = new LinkedList<>(Arrays.asList(\"\"));\\n\\n        while (!queue.isEmpty()) {\\n            String curString = queue.poll();\\n\\n            // If the length of curString is 2 * n, add it to `answer` if\\n            // it is valid. \\n            if (curString.length() == 2 * n) {\\n                if (isValid(curString)) {\\n                    answer.add(curString);\\n                }\\n                continue;\\n            }\\n            queue.offer(curString + \")\");\\n            queue.offer(curString + \"(\");\\n        }\\n\\n        return answer;\\n    }\\n}"
                    },
                    {
                        "username": "Divyam6969",
                        "content": "How can  we solve this iteratively?\n"
                    },
                    {
                        "username": "maurei",
                        "content": "I think in my solution the recursive call be converted to a while loop pretty straightforwardly: https://leetcode.com/problems/generate-parentheses/description/comments/1870152"
                    },
                    {
                        "username": "saurabhDtu15",
                        "content": "Can someone help me with the time and space complexity for the following?\\nMy logic: Keeping count of opening brackets and closing brackets. Opening brackets cannot be more than n in any case and closing brackets should always be less than opening.\\n\\n`class Solution {\\n    List<String> res;\\n    public List<String> generateParenthesis(int n) {\\n        res = new ArrayList<>();\\n        brackets(n*2, 0, 0, \"\", 0);\\n        return res;\\n    }\\n\\n    private void brackets(int n, int strl, int strr, String str, int count) {\\n        if(str.length() == n) {\\n            res.add(str);\\n            return;\\n        }\\n        if(strl < n/2)\\n            brackets(n, strl + 1, strr, str + \\'(\\', count + 1);\\n        if(strr < strl) {\\n            brackets(n, strl, strr + 1, str + \\')\\', count + 1);\\n        }\\n    }\\n}`"
                    },
                    {
                        "username": "ideintTe",
                        "content": "For n =4;\\nOutput : [\"(((())))\",\"((()))()\",\"()((()))\",\"((())())\",\"(())()()\",\"()(())()\",\"(()(()))\",\"()(())()\",\"()()(())\",\"((()()))\",\"(()())()\",\"()(()())\",\"(()()())\",\"()()()()\"]\\nExpected : [\"(((())))\",\"((()()))\",\"((())())\",\"((()))()\",\"(()(()))\",\"(()()())\",\"(()())()\",\"(())(())\",\"(())()()\",\"()((()))\",\"()(()())\",\"()(())()\",\"()()(())\",\"()()()()\"]\\nI\\'m not using recursion, how can I change the order ?\\nHere\\'s my solution:\\npublic List<String> generateParenthesis(int n) {\\n        List<String> combinations = new ArrayList<String>();\\n        List<String> combinations1 = new ArrayList<String>();\\n        if(n == 0)\\n            return combinations;\\n        combinations.add(\"()\");\\n        if(n == 1) {\\n            return combinations;\\n        }\\n        for( int i = 2; i <= n; i++) {   \\n            combinations1.clear();      \\n            for(String j : combinations) {\\n                String temp1 = j.concat(\"()\");\\n                String temp2 = \"()\".concat(j);\\n                combinations1.add(\"(\" + j + \")\");\\n                if(!temp1.equals(temp2)) {\\n                    combinations1.add(temp1);\\n                    combinations1.add(temp2);\\n                }  \\n                else {\\n                    combinations1.add(temp1);           \\n            }\\n            combinations.clear();\\n            combinations.addAll(combinations1);           \\n        }\\n        return combinations;\\n    }\\n"
                    },
                    {
                        "username": "maurei",
                        "content": "My solution is also recursive but pretty different from keeping track of `openCount` and `closeCount`. I don\\'t really know how my solution relates. Does anyone have a better idea on this?\\n\\n I wrote down the first few cases and observed how I could eg obtain n=3 from n=2. The trick is to iterate over the combinations of n=2 and insert a `()` left and right of every opening `()` UNTIl you run into the first closing bracket `(`.\\n\\nLet me write that out with an example. I use `_()_` to denote which pair of brackets was newly introduced.\\n\\ntake `n=2`. (A)`(())` and (B) `()()`.\\n\\n(A) becomes: `_()_(())`,  `(_()_())` and `((_()_))`. Thats where we stop because after the last insertion, we run into the first closing bracket\\n(B) becomes: `_()_()()` and `(_()_)()`. Thats where we stop, again, because there is a closing bracket next.\\n\\nIt runs pretty damn fast. The code is here (can be written for better space but wanted to keep it readable for discussion here).\\n\\nIt works, but im not sure why.\\n\\n```c#\\npublic class Solution\\n{\\n    public IList<string> GenerateParenthesis(int n) \\n    {\\n        if (n == 0)\\n        {\\n            return Array.Empty<string>();\\n        }\\n\\n        if (n == 1)\\n        {\\n            return new List<string> { \"()\" };\\n        }\\n\\n        List<string> combinations = new List<string>();\\n\\n        IList<string> previousCombinations = GenerateParenthesis(n - 1);\\n\\n        foreach (string previous in previousCombinations)\\n        {\\n            List<string> current = GetCurrentConfig(previous);\\n            combinations.AddRange(current);\\n        }\\n\\n        return combinations;\\n    }\\n\\n    private List<string> GetCurrentConfig(string previous)\\n    {\\n        List<char> characters = previous.ToCharArray().ToList();\\n\\n        List<string> result = new();\\n        \\n        for (int i = 0; i < characters.Count; i++)\\n        {\\n            List<char> clone = new List<char>(characters);\\n            clone.Insert(i, \\')\\');\\n            clone.Insert(i, \\'(\\');\\n            result.Add(new string(clone.ToArray()));\\n            \\n            if (characters[i] == \\')\\')\\n            {\\n                break;\\n            }\\n        }\\n\\n        return result;\\n    }\\n}\\n```\\n"
                    },
                    {
                        "username": "zalars",
                        "content": "I found that the number of all combinations with N parenthesis pairs consists of two groups:\\n1. \"(\"+C(N-1)+\")\", where C(N-1) - all combiantions with N-1 parenthesis pairs;\\n2. All suitable concatenated sequences of all lower N\\'s combinations.\\n\\nAnd the second group is difficult to program for me even using a hash table. Besides time complexity doesn\\'t seem to be improved as well."
                    }
                ]
            },
            {
                "id": 1844051,
                "content": [
                    {
                        "username": "muan22",
                        "content": "Hi. I don\\'t know how in backtracking approach when we generate one of the combinations, the next combination start?"
                    },
                    {
                        "username": "aswatha",
                        "content": " void solve(string &s,vector<string>&res,int o,int c, int n){\\n        if(o<=0 && c<=0){\\n            res.push_back(s);\\n            return;\\n        }\\n        if(o>0){\\n            s.push_back(\\'(\\');\\n            solve(s,res,o--,c,n);\\n            s.pop_back();\\n        }\\n        if(c>o){\\n            s.push_back(\\')\\');\\n            solve(s,res,o,c--,n);\\n            s.pop_back();\\n        }\\n    }\\n\\nthis is my function but i am getting\\n\\n AddressSanitizer:DEADLYSIGNAL\\n=================================================================\\n==34==ERROR: AddressSanitizer: stack-overflow on address 0x7ffeb839aff8 (pc 0x000000344937 bp 0x7ffeb839b030 sp 0x7ffeb839b000 T0)\\n==34==ABORTING\\n\\nCan someone tell me why??"
                    },
                    {
                        "username": "hienlemanh2002",
                        "content": "Ti u y\n```\nfunction generateParenthesis(n) {\n    const results = []; // khi to mng kt qu cha cc chui ngoc ng nh dng\n\n    function generate(str, left, right) { // khai bo hm  quy generate vi 3 tham s\n        if (left === 0 && right === 0) { // nu s lng du ngoc m v ng bng 0\n            results.push(str); // thm chui str vo mng kt qu\n            return; // thot khi hm\n        }\n        if (left > 0) { // nu cn du ngoc m cha s dng ht\n            generate(str + \"(\", left - 1, right); // thm du ngoc m vo chui str v gim s lng du ngoc m cn li i 1\n        }\n        if (right > left) { // nu s lng du ngoc ng cn li nhiu hn du ngoc m\n            generate(str + \")\", left, right - 1); // thm du ngoc ng vo chui str v gim s lng du ngoc ng cn li i 1\n        }\n    }\n\n    generate(\"\", n, n); // bt u chy hm generate vi chui rng v s lng du ngoc m v ng bng n\n    return results; // tr v mng kt qu\n}\n```"
                    },
                    {
                        "username": "hawkpie69",
                        "content": "question can be broken down very easily just by understanding the solution set the primary observation is all the brackets are balanced what we get from this if u are making a call for opening bracket then u have to make a call for \\nclosing bracket and the second point from balanced parenthesis is call for closing bracket can never be applied before the opening bracket call and the base case for this  question will be like all the opening and closing brackets are balanced."
                    },
                    {
                        "username": "hawkpie69",
                        "content": "the most simple way to understand the flow of the question is using bruteforce approach i think the complexity will be around 2*2n but the flow is too easy \\nclass Solution {\\n    public List<String> generateParenthesis(int n) {\\n       List<String> ans=new ArrayList<>();\\n\\n       helper(n*2,\"\",0,0,ans,0);\\n\\n       return ans;\\n    }\\n\\n    public void helper(int n,String asf,int oc,int nc,List<String> ans,int idx)\\n    {\\n        if(idx==n)\\n        {\\n            if(isValid(asf))\\n            {\\n                ans.add(asf);\\n            }\\n            return;\\n        }\\n\\n        helper(n,asf+\"(\",oc+1,nc,ans,idx+1);\\n         helper(n,asf+\")\",oc,nc+1,ans,idx+1);\\n    }\\n     public static boolean isValid(String s) {\\n    // Inilization of Stack\\n        Stack<Character> st = new Stack<>();\\n    // Iterating through the given String\\n        for (int i = 0; i < s.length(); i++) {\\n    // Push Open Brackets in the Stack\\n            if (s.charAt(i) == \\'{\\' || s.charAt(i) == \\'(\\' || s.charAt(i) == \\'[\\') {\\n                st.push(s.charAt(i));\\n            }\\n    // checking for the empty stack because if empty this means there is no open bracket at the start which is an invaild string.\\n            else if(st.empty()){\\n                return false;\\n            }\\n    // Check for the close brackets pair on the top and pop them\\n            else if (st.peek() == \\'{\\' && s.charAt(i) == \\'}\\' ) {\\n                st.pop();\\n            } else if (st.peek() == \\'(\\' && s.charAt(i) == \\')\\' ) {\\n                st.pop();\\n            } else if (st.peek() == \\'[\\' && s.charAt(i) == \\']\\' ) {\\n                st.pop();\\n            }else{\\n                return false;\\n            }\\n\\n        }\\n        return st.empty();\\n\\n\\n    }\\n\\n\\n}"
                    },
                    {
                        "username": "abhishekgoklani0",
                        "content": "The function generateParenthesis returns a vector<string> that contains all the valid combinations, and the helper function backtrack uses a backtracking approach to construct the combinations.\\n\\nIn backtrack, the function adds an open parenthesis to the current combination (temp+\"(\") and continues the backtracking process if the number of open parentheses is less than max. Similarly, it adds a close parenthesis to the current combination (temp+\")\") and continues the backtracking process if the number of close parentheses is less than the number of open parentheses. When the length of the current combination (temp) is equal to 2 * max, it means that a valid combination has been found, so it is added to the result vector ans."
                    },
                    {
                        "username": "charbino",
                        "content": "My solution is getting marked wrong for n=4 due to including `\\'(())(())\\'` in the results. How is this not valid? It\\'s not included in the expected answer"
                    },
                    {
                        "username": "piratedjesus",
                        "content": "C++\\n\\nclass Solution {\\npublic:\\n    vector<string> generateParenthesis(int n) {\\n       //vector to store all possible combinations\\n        vector<string> res;\\n        //string to store current combination\\n        string s;\\n        //recursive function to generate all combinations\\n        dfs(n,n,s,res);\\n        return res;  \\n    }\\n    void dfs(int left,int right,string s,vector<string> &res){\\n        //base case, when there are no more left or right parentheses to place\\n        if(left==0 && right==0){\\n            //add current combination to result vector\\n            res.push_back(s);\\n            return;\\n        }\\n        //if there are still left parentheses to place, add one to the current combination\\n        if(left>0) dfs(left-1,right,s+\\'(\\',res);\\n        //if there are more right parentheses to place than left, add one to the current combination\\n        if(right>left) dfs(left,right-1,s+\\')\\',res);\\n    }\\n};"
                    },
                    {
                        "username": "wodxuming",
                        "content": "```\\nclass Solution {\\n\\npublic:\\n    vector<string> generateParenthesis(int n) {\\n        if (n == 0) return {};\\n\\n        vector<string> res;\\n\\n        string track;\\n\\n        backtrack(n, n, track, res);\\n        return res;       \\n    }\\n\\n    void backtrack(int left, int right, string& track, vector<string>& res) {\\n        if (right < left) return;\\n        if (left < 0 || right < 0) return;\\n        if (left == 0 && right == 0) {\\n            res.push_back(track);\\n            return;\\n        }\\n        \\n        track.push_back(\\'(\\'); \\n        backtrack(left - 1, right, track, res);\\n        track.pop_back(); \\n\\n        track.push_back(\\')\\'); \\n        backtrack(left, right - 1, track, res);\\n        track.pop_back(); \\n    }\\n};\\n```"
                    },
                    {
                        "username": "jarvis_413",
                        "content": "I think the best approach on solving problem is using catlan\\n"
                    }
                ]
            },
            {
                "id": 1817918,
                "content": [
                    {
                        "username": "muan22",
                        "content": "Hi. I don\\'t know how in backtracking approach when we generate one of the combinations, the next combination start?"
                    },
                    {
                        "username": "aswatha",
                        "content": " void solve(string &s,vector<string>&res,int o,int c, int n){\\n        if(o<=0 && c<=0){\\n            res.push_back(s);\\n            return;\\n        }\\n        if(o>0){\\n            s.push_back(\\'(\\');\\n            solve(s,res,o--,c,n);\\n            s.pop_back();\\n        }\\n        if(c>o){\\n            s.push_back(\\')\\');\\n            solve(s,res,o,c--,n);\\n            s.pop_back();\\n        }\\n    }\\n\\nthis is my function but i am getting\\n\\n AddressSanitizer:DEADLYSIGNAL\\n=================================================================\\n==34==ERROR: AddressSanitizer: stack-overflow on address 0x7ffeb839aff8 (pc 0x000000344937 bp 0x7ffeb839b030 sp 0x7ffeb839b000 T0)\\n==34==ABORTING\\n\\nCan someone tell me why??"
                    },
                    {
                        "username": "hienlemanh2002",
                        "content": "Ti u y\n```\nfunction generateParenthesis(n) {\n    const results = []; // khi to mng kt qu cha cc chui ngoc ng nh dng\n\n    function generate(str, left, right) { // khai bo hm  quy generate vi 3 tham s\n        if (left === 0 && right === 0) { // nu s lng du ngoc m v ng bng 0\n            results.push(str); // thm chui str vo mng kt qu\n            return; // thot khi hm\n        }\n        if (left > 0) { // nu cn du ngoc m cha s dng ht\n            generate(str + \"(\", left - 1, right); // thm du ngoc m vo chui str v gim s lng du ngoc m cn li i 1\n        }\n        if (right > left) { // nu s lng du ngoc ng cn li nhiu hn du ngoc m\n            generate(str + \")\", left, right - 1); // thm du ngoc ng vo chui str v gim s lng du ngoc ng cn li i 1\n        }\n    }\n\n    generate(\"\", n, n); // bt u chy hm generate vi chui rng v s lng du ngoc m v ng bng n\n    return results; // tr v mng kt qu\n}\n```"
                    },
                    {
                        "username": "hawkpie69",
                        "content": "question can be broken down very easily just by understanding the solution set the primary observation is all the brackets are balanced what we get from this if u are making a call for opening bracket then u have to make a call for \\nclosing bracket and the second point from balanced parenthesis is call for closing bracket can never be applied before the opening bracket call and the base case for this  question will be like all the opening and closing brackets are balanced."
                    },
                    {
                        "username": "hawkpie69",
                        "content": "the most simple way to understand the flow of the question is using bruteforce approach i think the complexity will be around 2*2n but the flow is too easy \\nclass Solution {\\n    public List<String> generateParenthesis(int n) {\\n       List<String> ans=new ArrayList<>();\\n\\n       helper(n*2,\"\",0,0,ans,0);\\n\\n       return ans;\\n    }\\n\\n    public void helper(int n,String asf,int oc,int nc,List<String> ans,int idx)\\n    {\\n        if(idx==n)\\n        {\\n            if(isValid(asf))\\n            {\\n                ans.add(asf);\\n            }\\n            return;\\n        }\\n\\n        helper(n,asf+\"(\",oc+1,nc,ans,idx+1);\\n         helper(n,asf+\")\",oc,nc+1,ans,idx+1);\\n    }\\n     public static boolean isValid(String s) {\\n    // Inilization of Stack\\n        Stack<Character> st = new Stack<>();\\n    // Iterating through the given String\\n        for (int i = 0; i < s.length(); i++) {\\n    // Push Open Brackets in the Stack\\n            if (s.charAt(i) == \\'{\\' || s.charAt(i) == \\'(\\' || s.charAt(i) == \\'[\\') {\\n                st.push(s.charAt(i));\\n            }\\n    // checking for the empty stack because if empty this means there is no open bracket at the start which is an invaild string.\\n            else if(st.empty()){\\n                return false;\\n            }\\n    // Check for the close brackets pair on the top and pop them\\n            else if (st.peek() == \\'{\\' && s.charAt(i) == \\'}\\' ) {\\n                st.pop();\\n            } else if (st.peek() == \\'(\\' && s.charAt(i) == \\')\\' ) {\\n                st.pop();\\n            } else if (st.peek() == \\'[\\' && s.charAt(i) == \\']\\' ) {\\n                st.pop();\\n            }else{\\n                return false;\\n            }\\n\\n        }\\n        return st.empty();\\n\\n\\n    }\\n\\n\\n}"
                    },
                    {
                        "username": "abhishekgoklani0",
                        "content": "The function generateParenthesis returns a vector<string> that contains all the valid combinations, and the helper function backtrack uses a backtracking approach to construct the combinations.\\n\\nIn backtrack, the function adds an open parenthesis to the current combination (temp+\"(\") and continues the backtracking process if the number of open parentheses is less than max. Similarly, it adds a close parenthesis to the current combination (temp+\")\") and continues the backtracking process if the number of close parentheses is less than the number of open parentheses. When the length of the current combination (temp) is equal to 2 * max, it means that a valid combination has been found, so it is added to the result vector ans."
                    },
                    {
                        "username": "charbino",
                        "content": "My solution is getting marked wrong for n=4 due to including `\\'(())(())\\'` in the results. How is this not valid? It\\'s not included in the expected answer"
                    },
                    {
                        "username": "piratedjesus",
                        "content": "C++\\n\\nclass Solution {\\npublic:\\n    vector<string> generateParenthesis(int n) {\\n       //vector to store all possible combinations\\n        vector<string> res;\\n        //string to store current combination\\n        string s;\\n        //recursive function to generate all combinations\\n        dfs(n,n,s,res);\\n        return res;  \\n    }\\n    void dfs(int left,int right,string s,vector<string> &res){\\n        //base case, when there are no more left or right parentheses to place\\n        if(left==0 && right==0){\\n            //add current combination to result vector\\n            res.push_back(s);\\n            return;\\n        }\\n        //if there are still left parentheses to place, add one to the current combination\\n        if(left>0) dfs(left-1,right,s+\\'(\\',res);\\n        //if there are more right parentheses to place than left, add one to the current combination\\n        if(right>left) dfs(left,right-1,s+\\')\\',res);\\n    }\\n};"
                    },
                    {
                        "username": "wodxuming",
                        "content": "```\\nclass Solution {\\n\\npublic:\\n    vector<string> generateParenthesis(int n) {\\n        if (n == 0) return {};\\n\\n        vector<string> res;\\n\\n        string track;\\n\\n        backtrack(n, n, track, res);\\n        return res;       \\n    }\\n\\n    void backtrack(int left, int right, string& track, vector<string>& res) {\\n        if (right < left) return;\\n        if (left < 0 || right < 0) return;\\n        if (left == 0 && right == 0) {\\n            res.push_back(track);\\n            return;\\n        }\\n        \\n        track.push_back(\\'(\\'); \\n        backtrack(left - 1, right, track, res);\\n        track.pop_back(); \\n\\n        track.push_back(\\')\\'); \\n        backtrack(left, right - 1, track, res);\\n        track.pop_back(); \\n    }\\n};\\n```"
                    },
                    {
                        "username": "jarvis_413",
                        "content": "I think the best approach on solving problem is using catlan\\n"
                    }
                ]
            },
            {
                "id": 1814298,
                "content": [
                    {
                        "username": "muan22",
                        "content": "Hi. I don\\'t know how in backtracking approach when we generate one of the combinations, the next combination start?"
                    },
                    {
                        "username": "aswatha",
                        "content": " void solve(string &s,vector<string>&res,int o,int c, int n){\\n        if(o<=0 && c<=0){\\n            res.push_back(s);\\n            return;\\n        }\\n        if(o>0){\\n            s.push_back(\\'(\\');\\n            solve(s,res,o--,c,n);\\n            s.pop_back();\\n        }\\n        if(c>o){\\n            s.push_back(\\')\\');\\n            solve(s,res,o,c--,n);\\n            s.pop_back();\\n        }\\n    }\\n\\nthis is my function but i am getting\\n\\n AddressSanitizer:DEADLYSIGNAL\\n=================================================================\\n==34==ERROR: AddressSanitizer: stack-overflow on address 0x7ffeb839aff8 (pc 0x000000344937 bp 0x7ffeb839b030 sp 0x7ffeb839b000 T0)\\n==34==ABORTING\\n\\nCan someone tell me why??"
                    },
                    {
                        "username": "hienlemanh2002",
                        "content": "Ti u y\n```\nfunction generateParenthesis(n) {\n    const results = []; // khi to mng kt qu cha cc chui ngoc ng nh dng\n\n    function generate(str, left, right) { // khai bo hm  quy generate vi 3 tham s\n        if (left === 0 && right === 0) { // nu s lng du ngoc m v ng bng 0\n            results.push(str); // thm chui str vo mng kt qu\n            return; // thot khi hm\n        }\n        if (left > 0) { // nu cn du ngoc m cha s dng ht\n            generate(str + \"(\", left - 1, right); // thm du ngoc m vo chui str v gim s lng du ngoc m cn li i 1\n        }\n        if (right > left) { // nu s lng du ngoc ng cn li nhiu hn du ngoc m\n            generate(str + \")\", left, right - 1); // thm du ngoc ng vo chui str v gim s lng du ngoc ng cn li i 1\n        }\n    }\n\n    generate(\"\", n, n); // bt u chy hm generate vi chui rng v s lng du ngoc m v ng bng n\n    return results; // tr v mng kt qu\n}\n```"
                    },
                    {
                        "username": "hawkpie69",
                        "content": "question can be broken down very easily just by understanding the solution set the primary observation is all the brackets are balanced what we get from this if u are making a call for opening bracket then u have to make a call for \\nclosing bracket and the second point from balanced parenthesis is call for closing bracket can never be applied before the opening bracket call and the base case for this  question will be like all the opening and closing brackets are balanced."
                    },
                    {
                        "username": "hawkpie69",
                        "content": "the most simple way to understand the flow of the question is using bruteforce approach i think the complexity will be around 2*2n but the flow is too easy \\nclass Solution {\\n    public List<String> generateParenthesis(int n) {\\n       List<String> ans=new ArrayList<>();\\n\\n       helper(n*2,\"\",0,0,ans,0);\\n\\n       return ans;\\n    }\\n\\n    public void helper(int n,String asf,int oc,int nc,List<String> ans,int idx)\\n    {\\n        if(idx==n)\\n        {\\n            if(isValid(asf))\\n            {\\n                ans.add(asf);\\n            }\\n            return;\\n        }\\n\\n        helper(n,asf+\"(\",oc+1,nc,ans,idx+1);\\n         helper(n,asf+\")\",oc,nc+1,ans,idx+1);\\n    }\\n     public static boolean isValid(String s) {\\n    // Inilization of Stack\\n        Stack<Character> st = new Stack<>();\\n    // Iterating through the given String\\n        for (int i = 0; i < s.length(); i++) {\\n    // Push Open Brackets in the Stack\\n            if (s.charAt(i) == \\'{\\' || s.charAt(i) == \\'(\\' || s.charAt(i) == \\'[\\') {\\n                st.push(s.charAt(i));\\n            }\\n    // checking for the empty stack because if empty this means there is no open bracket at the start which is an invaild string.\\n            else if(st.empty()){\\n                return false;\\n            }\\n    // Check for the close brackets pair on the top and pop them\\n            else if (st.peek() == \\'{\\' && s.charAt(i) == \\'}\\' ) {\\n                st.pop();\\n            } else if (st.peek() == \\'(\\' && s.charAt(i) == \\')\\' ) {\\n                st.pop();\\n            } else if (st.peek() == \\'[\\' && s.charAt(i) == \\']\\' ) {\\n                st.pop();\\n            }else{\\n                return false;\\n            }\\n\\n        }\\n        return st.empty();\\n\\n\\n    }\\n\\n\\n}"
                    },
                    {
                        "username": "abhishekgoklani0",
                        "content": "The function generateParenthesis returns a vector<string> that contains all the valid combinations, and the helper function backtrack uses a backtracking approach to construct the combinations.\\n\\nIn backtrack, the function adds an open parenthesis to the current combination (temp+\"(\") and continues the backtracking process if the number of open parentheses is less than max. Similarly, it adds a close parenthesis to the current combination (temp+\")\") and continues the backtracking process if the number of close parentheses is less than the number of open parentheses. When the length of the current combination (temp) is equal to 2 * max, it means that a valid combination has been found, so it is added to the result vector ans."
                    },
                    {
                        "username": "charbino",
                        "content": "My solution is getting marked wrong for n=4 due to including `\\'(())(())\\'` in the results. How is this not valid? It\\'s not included in the expected answer"
                    },
                    {
                        "username": "piratedjesus",
                        "content": "C++\\n\\nclass Solution {\\npublic:\\n    vector<string> generateParenthesis(int n) {\\n       //vector to store all possible combinations\\n        vector<string> res;\\n        //string to store current combination\\n        string s;\\n        //recursive function to generate all combinations\\n        dfs(n,n,s,res);\\n        return res;  \\n    }\\n    void dfs(int left,int right,string s,vector<string> &res){\\n        //base case, when there are no more left or right parentheses to place\\n        if(left==0 && right==0){\\n            //add current combination to result vector\\n            res.push_back(s);\\n            return;\\n        }\\n        //if there are still left parentheses to place, add one to the current combination\\n        if(left>0) dfs(left-1,right,s+\\'(\\',res);\\n        //if there are more right parentheses to place than left, add one to the current combination\\n        if(right>left) dfs(left,right-1,s+\\')\\',res);\\n    }\\n};"
                    },
                    {
                        "username": "wodxuming",
                        "content": "```\\nclass Solution {\\n\\npublic:\\n    vector<string> generateParenthesis(int n) {\\n        if (n == 0) return {};\\n\\n        vector<string> res;\\n\\n        string track;\\n\\n        backtrack(n, n, track, res);\\n        return res;       \\n    }\\n\\n    void backtrack(int left, int right, string& track, vector<string>& res) {\\n        if (right < left) return;\\n        if (left < 0 || right < 0) return;\\n        if (left == 0 && right == 0) {\\n            res.push_back(track);\\n            return;\\n        }\\n        \\n        track.push_back(\\'(\\'); \\n        backtrack(left - 1, right, track, res);\\n        track.pop_back(); \\n\\n        track.push_back(\\')\\'); \\n        backtrack(left, right - 1, track, res);\\n        track.pop_back(); \\n    }\\n};\\n```"
                    },
                    {
                        "username": "jarvis_413",
                        "content": "I think the best approach on solving problem is using catlan\\n"
                    }
                ]
            },
            {
                "id": 1803751,
                "content": [
                    {
                        "username": "muan22",
                        "content": "Hi. I don\\'t know how in backtracking approach when we generate one of the combinations, the next combination start?"
                    },
                    {
                        "username": "aswatha",
                        "content": " void solve(string &s,vector<string>&res,int o,int c, int n){\\n        if(o<=0 && c<=0){\\n            res.push_back(s);\\n            return;\\n        }\\n        if(o>0){\\n            s.push_back(\\'(\\');\\n            solve(s,res,o--,c,n);\\n            s.pop_back();\\n        }\\n        if(c>o){\\n            s.push_back(\\')\\');\\n            solve(s,res,o,c--,n);\\n            s.pop_back();\\n        }\\n    }\\n\\nthis is my function but i am getting\\n\\n AddressSanitizer:DEADLYSIGNAL\\n=================================================================\\n==34==ERROR: AddressSanitizer: stack-overflow on address 0x7ffeb839aff8 (pc 0x000000344937 bp 0x7ffeb839b030 sp 0x7ffeb839b000 T0)\\n==34==ABORTING\\n\\nCan someone tell me why??"
                    },
                    {
                        "username": "hienlemanh2002",
                        "content": "Ti u y\n```\nfunction generateParenthesis(n) {\n    const results = []; // khi to mng kt qu cha cc chui ngoc ng nh dng\n\n    function generate(str, left, right) { // khai bo hm  quy generate vi 3 tham s\n        if (left === 0 && right === 0) { // nu s lng du ngoc m v ng bng 0\n            results.push(str); // thm chui str vo mng kt qu\n            return; // thot khi hm\n        }\n        if (left > 0) { // nu cn du ngoc m cha s dng ht\n            generate(str + \"(\", left - 1, right); // thm du ngoc m vo chui str v gim s lng du ngoc m cn li i 1\n        }\n        if (right > left) { // nu s lng du ngoc ng cn li nhiu hn du ngoc m\n            generate(str + \")\", left, right - 1); // thm du ngoc ng vo chui str v gim s lng du ngoc ng cn li i 1\n        }\n    }\n\n    generate(\"\", n, n); // bt u chy hm generate vi chui rng v s lng du ngoc m v ng bng n\n    return results; // tr v mng kt qu\n}\n```"
                    },
                    {
                        "username": "hawkpie69",
                        "content": "question can be broken down very easily just by understanding the solution set the primary observation is all the brackets are balanced what we get from this if u are making a call for opening bracket then u have to make a call for \\nclosing bracket and the second point from balanced parenthesis is call for closing bracket can never be applied before the opening bracket call and the base case for this  question will be like all the opening and closing brackets are balanced."
                    },
                    {
                        "username": "hawkpie69",
                        "content": "the most simple way to understand the flow of the question is using bruteforce approach i think the complexity will be around 2*2n but the flow is too easy \\nclass Solution {\\n    public List<String> generateParenthesis(int n) {\\n       List<String> ans=new ArrayList<>();\\n\\n       helper(n*2,\"\",0,0,ans,0);\\n\\n       return ans;\\n    }\\n\\n    public void helper(int n,String asf,int oc,int nc,List<String> ans,int idx)\\n    {\\n        if(idx==n)\\n        {\\n            if(isValid(asf))\\n            {\\n                ans.add(asf);\\n            }\\n            return;\\n        }\\n\\n        helper(n,asf+\"(\",oc+1,nc,ans,idx+1);\\n         helper(n,asf+\")\",oc,nc+1,ans,idx+1);\\n    }\\n     public static boolean isValid(String s) {\\n    // Inilization of Stack\\n        Stack<Character> st = new Stack<>();\\n    // Iterating through the given String\\n        for (int i = 0; i < s.length(); i++) {\\n    // Push Open Brackets in the Stack\\n            if (s.charAt(i) == \\'{\\' || s.charAt(i) == \\'(\\' || s.charAt(i) == \\'[\\') {\\n                st.push(s.charAt(i));\\n            }\\n    // checking for the empty stack because if empty this means there is no open bracket at the start which is an invaild string.\\n            else if(st.empty()){\\n                return false;\\n            }\\n    // Check for the close brackets pair on the top and pop them\\n            else if (st.peek() == \\'{\\' && s.charAt(i) == \\'}\\' ) {\\n                st.pop();\\n            } else if (st.peek() == \\'(\\' && s.charAt(i) == \\')\\' ) {\\n                st.pop();\\n            } else if (st.peek() == \\'[\\' && s.charAt(i) == \\']\\' ) {\\n                st.pop();\\n            }else{\\n                return false;\\n            }\\n\\n        }\\n        return st.empty();\\n\\n\\n    }\\n\\n\\n}"
                    },
                    {
                        "username": "abhishekgoklani0",
                        "content": "The function generateParenthesis returns a vector<string> that contains all the valid combinations, and the helper function backtrack uses a backtracking approach to construct the combinations.\\n\\nIn backtrack, the function adds an open parenthesis to the current combination (temp+\"(\") and continues the backtracking process if the number of open parentheses is less than max. Similarly, it adds a close parenthesis to the current combination (temp+\")\") and continues the backtracking process if the number of close parentheses is less than the number of open parentheses. When the length of the current combination (temp) is equal to 2 * max, it means that a valid combination has been found, so it is added to the result vector ans."
                    },
                    {
                        "username": "charbino",
                        "content": "My solution is getting marked wrong for n=4 due to including `\\'(())(())\\'` in the results. How is this not valid? It\\'s not included in the expected answer"
                    },
                    {
                        "username": "piratedjesus",
                        "content": "C++\\n\\nclass Solution {\\npublic:\\n    vector<string> generateParenthesis(int n) {\\n       //vector to store all possible combinations\\n        vector<string> res;\\n        //string to store current combination\\n        string s;\\n        //recursive function to generate all combinations\\n        dfs(n,n,s,res);\\n        return res;  \\n    }\\n    void dfs(int left,int right,string s,vector<string> &res){\\n        //base case, when there are no more left or right parentheses to place\\n        if(left==0 && right==0){\\n            //add current combination to result vector\\n            res.push_back(s);\\n            return;\\n        }\\n        //if there are still left parentheses to place, add one to the current combination\\n        if(left>0) dfs(left-1,right,s+\\'(\\',res);\\n        //if there are more right parentheses to place than left, add one to the current combination\\n        if(right>left) dfs(left,right-1,s+\\')\\',res);\\n    }\\n};"
                    },
                    {
                        "username": "wodxuming",
                        "content": "```\\nclass Solution {\\n\\npublic:\\n    vector<string> generateParenthesis(int n) {\\n        if (n == 0) return {};\\n\\n        vector<string> res;\\n\\n        string track;\\n\\n        backtrack(n, n, track, res);\\n        return res;       \\n    }\\n\\n    void backtrack(int left, int right, string& track, vector<string>& res) {\\n        if (right < left) return;\\n        if (left < 0 || right < 0) return;\\n        if (left == 0 && right == 0) {\\n            res.push_back(track);\\n            return;\\n        }\\n        \\n        track.push_back(\\'(\\'); \\n        backtrack(left - 1, right, track, res);\\n        track.pop_back(); \\n\\n        track.push_back(\\')\\'); \\n        backtrack(left, right - 1, track, res);\\n        track.pop_back(); \\n    }\\n};\\n```"
                    },
                    {
                        "username": "jarvis_413",
                        "content": "I think the best approach on solving problem is using catlan\\n"
                    }
                ]
            },
            {
                "id": 1803743,
                "content": [
                    {
                        "username": "muan22",
                        "content": "Hi. I don\\'t know how in backtracking approach when we generate one of the combinations, the next combination start?"
                    },
                    {
                        "username": "aswatha",
                        "content": " void solve(string &s,vector<string>&res,int o,int c, int n){\\n        if(o<=0 && c<=0){\\n            res.push_back(s);\\n            return;\\n        }\\n        if(o>0){\\n            s.push_back(\\'(\\');\\n            solve(s,res,o--,c,n);\\n            s.pop_back();\\n        }\\n        if(c>o){\\n            s.push_back(\\')\\');\\n            solve(s,res,o,c--,n);\\n            s.pop_back();\\n        }\\n    }\\n\\nthis is my function but i am getting\\n\\n AddressSanitizer:DEADLYSIGNAL\\n=================================================================\\n==34==ERROR: AddressSanitizer: stack-overflow on address 0x7ffeb839aff8 (pc 0x000000344937 bp 0x7ffeb839b030 sp 0x7ffeb839b000 T0)\\n==34==ABORTING\\n\\nCan someone tell me why??"
                    },
                    {
                        "username": "hienlemanh2002",
                        "content": "Ti u y\n```\nfunction generateParenthesis(n) {\n    const results = []; // khi to mng kt qu cha cc chui ngoc ng nh dng\n\n    function generate(str, left, right) { // khai bo hm  quy generate vi 3 tham s\n        if (left === 0 && right === 0) { // nu s lng du ngoc m v ng bng 0\n            results.push(str); // thm chui str vo mng kt qu\n            return; // thot khi hm\n        }\n        if (left > 0) { // nu cn du ngoc m cha s dng ht\n            generate(str + \"(\", left - 1, right); // thm du ngoc m vo chui str v gim s lng du ngoc m cn li i 1\n        }\n        if (right > left) { // nu s lng du ngoc ng cn li nhiu hn du ngoc m\n            generate(str + \")\", left, right - 1); // thm du ngoc ng vo chui str v gim s lng du ngoc ng cn li i 1\n        }\n    }\n\n    generate(\"\", n, n); // bt u chy hm generate vi chui rng v s lng du ngoc m v ng bng n\n    return results; // tr v mng kt qu\n}\n```"
                    },
                    {
                        "username": "hawkpie69",
                        "content": "question can be broken down very easily just by understanding the solution set the primary observation is all the brackets are balanced what we get from this if u are making a call for opening bracket then u have to make a call for \\nclosing bracket and the second point from balanced parenthesis is call for closing bracket can never be applied before the opening bracket call and the base case for this  question will be like all the opening and closing brackets are balanced."
                    },
                    {
                        "username": "hawkpie69",
                        "content": "the most simple way to understand the flow of the question is using bruteforce approach i think the complexity will be around 2*2n but the flow is too easy \\nclass Solution {\\n    public List<String> generateParenthesis(int n) {\\n       List<String> ans=new ArrayList<>();\\n\\n       helper(n*2,\"\",0,0,ans,0);\\n\\n       return ans;\\n    }\\n\\n    public void helper(int n,String asf,int oc,int nc,List<String> ans,int idx)\\n    {\\n        if(idx==n)\\n        {\\n            if(isValid(asf))\\n            {\\n                ans.add(asf);\\n            }\\n            return;\\n        }\\n\\n        helper(n,asf+\"(\",oc+1,nc,ans,idx+1);\\n         helper(n,asf+\")\",oc,nc+1,ans,idx+1);\\n    }\\n     public static boolean isValid(String s) {\\n    // Inilization of Stack\\n        Stack<Character> st = new Stack<>();\\n    // Iterating through the given String\\n        for (int i = 0; i < s.length(); i++) {\\n    // Push Open Brackets in the Stack\\n            if (s.charAt(i) == \\'{\\' || s.charAt(i) == \\'(\\' || s.charAt(i) == \\'[\\') {\\n                st.push(s.charAt(i));\\n            }\\n    // checking for the empty stack because if empty this means there is no open bracket at the start which is an invaild string.\\n            else if(st.empty()){\\n                return false;\\n            }\\n    // Check for the close brackets pair on the top and pop them\\n            else if (st.peek() == \\'{\\' && s.charAt(i) == \\'}\\' ) {\\n                st.pop();\\n            } else if (st.peek() == \\'(\\' && s.charAt(i) == \\')\\' ) {\\n                st.pop();\\n            } else if (st.peek() == \\'[\\' && s.charAt(i) == \\']\\' ) {\\n                st.pop();\\n            }else{\\n                return false;\\n            }\\n\\n        }\\n        return st.empty();\\n\\n\\n    }\\n\\n\\n}"
                    },
                    {
                        "username": "abhishekgoklani0",
                        "content": "The function generateParenthesis returns a vector<string> that contains all the valid combinations, and the helper function backtrack uses a backtracking approach to construct the combinations.\\n\\nIn backtrack, the function adds an open parenthesis to the current combination (temp+\"(\") and continues the backtracking process if the number of open parentheses is less than max. Similarly, it adds a close parenthesis to the current combination (temp+\")\") and continues the backtracking process if the number of close parentheses is less than the number of open parentheses. When the length of the current combination (temp) is equal to 2 * max, it means that a valid combination has been found, so it is added to the result vector ans."
                    },
                    {
                        "username": "charbino",
                        "content": "My solution is getting marked wrong for n=4 due to including `\\'(())(())\\'` in the results. How is this not valid? It\\'s not included in the expected answer"
                    },
                    {
                        "username": "piratedjesus",
                        "content": "C++\\n\\nclass Solution {\\npublic:\\n    vector<string> generateParenthesis(int n) {\\n       //vector to store all possible combinations\\n        vector<string> res;\\n        //string to store current combination\\n        string s;\\n        //recursive function to generate all combinations\\n        dfs(n,n,s,res);\\n        return res;  \\n    }\\n    void dfs(int left,int right,string s,vector<string> &res){\\n        //base case, when there are no more left or right parentheses to place\\n        if(left==0 && right==0){\\n            //add current combination to result vector\\n            res.push_back(s);\\n            return;\\n        }\\n        //if there are still left parentheses to place, add one to the current combination\\n        if(left>0) dfs(left-1,right,s+\\'(\\',res);\\n        //if there are more right parentheses to place than left, add one to the current combination\\n        if(right>left) dfs(left,right-1,s+\\')\\',res);\\n    }\\n};"
                    },
                    {
                        "username": "wodxuming",
                        "content": "```\\nclass Solution {\\n\\npublic:\\n    vector<string> generateParenthesis(int n) {\\n        if (n == 0) return {};\\n\\n        vector<string> res;\\n\\n        string track;\\n\\n        backtrack(n, n, track, res);\\n        return res;       \\n    }\\n\\n    void backtrack(int left, int right, string& track, vector<string>& res) {\\n        if (right < left) return;\\n        if (left < 0 || right < 0) return;\\n        if (left == 0 && right == 0) {\\n            res.push_back(track);\\n            return;\\n        }\\n        \\n        track.push_back(\\'(\\'); \\n        backtrack(left - 1, right, track, res);\\n        track.pop_back(); \\n\\n        track.push_back(\\')\\'); \\n        backtrack(left, right - 1, track, res);\\n        track.pop_back(); \\n    }\\n};\\n```"
                    },
                    {
                        "username": "jarvis_413",
                        "content": "I think the best approach on solving problem is using catlan\\n"
                    }
                ]
            },
            {
                "id": 1793042,
                "content": [
                    {
                        "username": "muan22",
                        "content": "Hi. I don\\'t know how in backtracking approach when we generate one of the combinations, the next combination start?"
                    },
                    {
                        "username": "aswatha",
                        "content": " void solve(string &s,vector<string>&res,int o,int c, int n){\\n        if(o<=0 && c<=0){\\n            res.push_back(s);\\n            return;\\n        }\\n        if(o>0){\\n            s.push_back(\\'(\\');\\n            solve(s,res,o--,c,n);\\n            s.pop_back();\\n        }\\n        if(c>o){\\n            s.push_back(\\')\\');\\n            solve(s,res,o,c--,n);\\n            s.pop_back();\\n        }\\n    }\\n\\nthis is my function but i am getting\\n\\n AddressSanitizer:DEADLYSIGNAL\\n=================================================================\\n==34==ERROR: AddressSanitizer: stack-overflow on address 0x7ffeb839aff8 (pc 0x000000344937 bp 0x7ffeb839b030 sp 0x7ffeb839b000 T0)\\n==34==ABORTING\\n\\nCan someone tell me why??"
                    },
                    {
                        "username": "hienlemanh2002",
                        "content": "Ti u y\n```\nfunction generateParenthesis(n) {\n    const results = []; // khi to mng kt qu cha cc chui ngoc ng nh dng\n\n    function generate(str, left, right) { // khai bo hm  quy generate vi 3 tham s\n        if (left === 0 && right === 0) { // nu s lng du ngoc m v ng bng 0\n            results.push(str); // thm chui str vo mng kt qu\n            return; // thot khi hm\n        }\n        if (left > 0) { // nu cn du ngoc m cha s dng ht\n            generate(str + \"(\", left - 1, right); // thm du ngoc m vo chui str v gim s lng du ngoc m cn li i 1\n        }\n        if (right > left) { // nu s lng du ngoc ng cn li nhiu hn du ngoc m\n            generate(str + \")\", left, right - 1); // thm du ngoc ng vo chui str v gim s lng du ngoc ng cn li i 1\n        }\n    }\n\n    generate(\"\", n, n); // bt u chy hm generate vi chui rng v s lng du ngoc m v ng bng n\n    return results; // tr v mng kt qu\n}\n```"
                    },
                    {
                        "username": "hawkpie69",
                        "content": "question can be broken down very easily just by understanding the solution set the primary observation is all the brackets are balanced what we get from this if u are making a call for opening bracket then u have to make a call for \\nclosing bracket and the second point from balanced parenthesis is call for closing bracket can never be applied before the opening bracket call and the base case for this  question will be like all the opening and closing brackets are balanced."
                    },
                    {
                        "username": "hawkpie69",
                        "content": "the most simple way to understand the flow of the question is using bruteforce approach i think the complexity will be around 2*2n but the flow is too easy \\nclass Solution {\\n    public List<String> generateParenthesis(int n) {\\n       List<String> ans=new ArrayList<>();\\n\\n       helper(n*2,\"\",0,0,ans,0);\\n\\n       return ans;\\n    }\\n\\n    public void helper(int n,String asf,int oc,int nc,List<String> ans,int idx)\\n    {\\n        if(idx==n)\\n        {\\n            if(isValid(asf))\\n            {\\n                ans.add(asf);\\n            }\\n            return;\\n        }\\n\\n        helper(n,asf+\"(\",oc+1,nc,ans,idx+1);\\n         helper(n,asf+\")\",oc,nc+1,ans,idx+1);\\n    }\\n     public static boolean isValid(String s) {\\n    // Inilization of Stack\\n        Stack<Character> st = new Stack<>();\\n    // Iterating through the given String\\n        for (int i = 0; i < s.length(); i++) {\\n    // Push Open Brackets in the Stack\\n            if (s.charAt(i) == \\'{\\' || s.charAt(i) == \\'(\\' || s.charAt(i) == \\'[\\') {\\n                st.push(s.charAt(i));\\n            }\\n    // checking for the empty stack because if empty this means there is no open bracket at the start which is an invaild string.\\n            else if(st.empty()){\\n                return false;\\n            }\\n    // Check for the close brackets pair on the top and pop them\\n            else if (st.peek() == \\'{\\' && s.charAt(i) == \\'}\\' ) {\\n                st.pop();\\n            } else if (st.peek() == \\'(\\' && s.charAt(i) == \\')\\' ) {\\n                st.pop();\\n            } else if (st.peek() == \\'[\\' && s.charAt(i) == \\']\\' ) {\\n                st.pop();\\n            }else{\\n                return false;\\n            }\\n\\n        }\\n        return st.empty();\\n\\n\\n    }\\n\\n\\n}"
                    },
                    {
                        "username": "abhishekgoklani0",
                        "content": "The function generateParenthesis returns a vector<string> that contains all the valid combinations, and the helper function backtrack uses a backtracking approach to construct the combinations.\\n\\nIn backtrack, the function adds an open parenthesis to the current combination (temp+\"(\") and continues the backtracking process if the number of open parentheses is less than max. Similarly, it adds a close parenthesis to the current combination (temp+\")\") and continues the backtracking process if the number of close parentheses is less than the number of open parentheses. When the length of the current combination (temp) is equal to 2 * max, it means that a valid combination has been found, so it is added to the result vector ans."
                    },
                    {
                        "username": "charbino",
                        "content": "My solution is getting marked wrong for n=4 due to including `\\'(())(())\\'` in the results. How is this not valid? It\\'s not included in the expected answer"
                    },
                    {
                        "username": "piratedjesus",
                        "content": "C++\\n\\nclass Solution {\\npublic:\\n    vector<string> generateParenthesis(int n) {\\n       //vector to store all possible combinations\\n        vector<string> res;\\n        //string to store current combination\\n        string s;\\n        //recursive function to generate all combinations\\n        dfs(n,n,s,res);\\n        return res;  \\n    }\\n    void dfs(int left,int right,string s,vector<string> &res){\\n        //base case, when there are no more left or right parentheses to place\\n        if(left==0 && right==0){\\n            //add current combination to result vector\\n            res.push_back(s);\\n            return;\\n        }\\n        //if there are still left parentheses to place, add one to the current combination\\n        if(left>0) dfs(left-1,right,s+\\'(\\',res);\\n        //if there are more right parentheses to place than left, add one to the current combination\\n        if(right>left) dfs(left,right-1,s+\\')\\',res);\\n    }\\n};"
                    },
                    {
                        "username": "wodxuming",
                        "content": "```\\nclass Solution {\\n\\npublic:\\n    vector<string> generateParenthesis(int n) {\\n        if (n == 0) return {};\\n\\n        vector<string> res;\\n\\n        string track;\\n\\n        backtrack(n, n, track, res);\\n        return res;       \\n    }\\n\\n    void backtrack(int left, int right, string& track, vector<string>& res) {\\n        if (right < left) return;\\n        if (left < 0 || right < 0) return;\\n        if (left == 0 && right == 0) {\\n            res.push_back(track);\\n            return;\\n        }\\n        \\n        track.push_back(\\'(\\'); \\n        backtrack(left - 1, right, track, res);\\n        track.pop_back(); \\n\\n        track.push_back(\\')\\'); \\n        backtrack(left, right - 1, track, res);\\n        track.pop_back(); \\n    }\\n};\\n```"
                    },
                    {
                        "username": "jarvis_413",
                        "content": "I think the best approach on solving problem is using catlan\\n"
                    }
                ]
            },
            {
                "id": 1777093,
                "content": [
                    {
                        "username": "muan22",
                        "content": "Hi. I don\\'t know how in backtracking approach when we generate one of the combinations, the next combination start?"
                    },
                    {
                        "username": "aswatha",
                        "content": " void solve(string &s,vector<string>&res,int o,int c, int n){\\n        if(o<=0 && c<=0){\\n            res.push_back(s);\\n            return;\\n        }\\n        if(o>0){\\n            s.push_back(\\'(\\');\\n            solve(s,res,o--,c,n);\\n            s.pop_back();\\n        }\\n        if(c>o){\\n            s.push_back(\\')\\');\\n            solve(s,res,o,c--,n);\\n            s.pop_back();\\n        }\\n    }\\n\\nthis is my function but i am getting\\n\\n AddressSanitizer:DEADLYSIGNAL\\n=================================================================\\n==34==ERROR: AddressSanitizer: stack-overflow on address 0x7ffeb839aff8 (pc 0x000000344937 bp 0x7ffeb839b030 sp 0x7ffeb839b000 T0)\\n==34==ABORTING\\n\\nCan someone tell me why??"
                    },
                    {
                        "username": "hienlemanh2002",
                        "content": "Ti u y\n```\nfunction generateParenthesis(n) {\n    const results = []; // khi to mng kt qu cha cc chui ngoc ng nh dng\n\n    function generate(str, left, right) { // khai bo hm  quy generate vi 3 tham s\n        if (left === 0 && right === 0) { // nu s lng du ngoc m v ng bng 0\n            results.push(str); // thm chui str vo mng kt qu\n            return; // thot khi hm\n        }\n        if (left > 0) { // nu cn du ngoc m cha s dng ht\n            generate(str + \"(\", left - 1, right); // thm du ngoc m vo chui str v gim s lng du ngoc m cn li i 1\n        }\n        if (right > left) { // nu s lng du ngoc ng cn li nhiu hn du ngoc m\n            generate(str + \")\", left, right - 1); // thm du ngoc ng vo chui str v gim s lng du ngoc ng cn li i 1\n        }\n    }\n\n    generate(\"\", n, n); // bt u chy hm generate vi chui rng v s lng du ngoc m v ng bng n\n    return results; // tr v mng kt qu\n}\n```"
                    },
                    {
                        "username": "hawkpie69",
                        "content": "question can be broken down very easily just by understanding the solution set the primary observation is all the brackets are balanced what we get from this if u are making a call for opening bracket then u have to make a call for \\nclosing bracket and the second point from balanced parenthesis is call for closing bracket can never be applied before the opening bracket call and the base case for this  question will be like all the opening and closing brackets are balanced."
                    },
                    {
                        "username": "hawkpie69",
                        "content": "the most simple way to understand the flow of the question is using bruteforce approach i think the complexity will be around 2*2n but the flow is too easy \\nclass Solution {\\n    public List<String> generateParenthesis(int n) {\\n       List<String> ans=new ArrayList<>();\\n\\n       helper(n*2,\"\",0,0,ans,0);\\n\\n       return ans;\\n    }\\n\\n    public void helper(int n,String asf,int oc,int nc,List<String> ans,int idx)\\n    {\\n        if(idx==n)\\n        {\\n            if(isValid(asf))\\n            {\\n                ans.add(asf);\\n            }\\n            return;\\n        }\\n\\n        helper(n,asf+\"(\",oc+1,nc,ans,idx+1);\\n         helper(n,asf+\")\",oc,nc+1,ans,idx+1);\\n    }\\n     public static boolean isValid(String s) {\\n    // Inilization of Stack\\n        Stack<Character> st = new Stack<>();\\n    // Iterating through the given String\\n        for (int i = 0; i < s.length(); i++) {\\n    // Push Open Brackets in the Stack\\n            if (s.charAt(i) == \\'{\\' || s.charAt(i) == \\'(\\' || s.charAt(i) == \\'[\\') {\\n                st.push(s.charAt(i));\\n            }\\n    // checking for the empty stack because if empty this means there is no open bracket at the start which is an invaild string.\\n            else if(st.empty()){\\n                return false;\\n            }\\n    // Check for the close brackets pair on the top and pop them\\n            else if (st.peek() == \\'{\\' && s.charAt(i) == \\'}\\' ) {\\n                st.pop();\\n            } else if (st.peek() == \\'(\\' && s.charAt(i) == \\')\\' ) {\\n                st.pop();\\n            } else if (st.peek() == \\'[\\' && s.charAt(i) == \\']\\' ) {\\n                st.pop();\\n            }else{\\n                return false;\\n            }\\n\\n        }\\n        return st.empty();\\n\\n\\n    }\\n\\n\\n}"
                    },
                    {
                        "username": "abhishekgoklani0",
                        "content": "The function generateParenthesis returns a vector<string> that contains all the valid combinations, and the helper function backtrack uses a backtracking approach to construct the combinations.\\n\\nIn backtrack, the function adds an open parenthesis to the current combination (temp+\"(\") and continues the backtracking process if the number of open parentheses is less than max. Similarly, it adds a close parenthesis to the current combination (temp+\")\") and continues the backtracking process if the number of close parentheses is less than the number of open parentheses. When the length of the current combination (temp) is equal to 2 * max, it means that a valid combination has been found, so it is added to the result vector ans."
                    },
                    {
                        "username": "charbino",
                        "content": "My solution is getting marked wrong for n=4 due to including `\\'(())(())\\'` in the results. How is this not valid? It\\'s not included in the expected answer"
                    },
                    {
                        "username": "piratedjesus",
                        "content": "C++\\n\\nclass Solution {\\npublic:\\n    vector<string> generateParenthesis(int n) {\\n       //vector to store all possible combinations\\n        vector<string> res;\\n        //string to store current combination\\n        string s;\\n        //recursive function to generate all combinations\\n        dfs(n,n,s,res);\\n        return res;  \\n    }\\n    void dfs(int left,int right,string s,vector<string> &res){\\n        //base case, when there are no more left or right parentheses to place\\n        if(left==0 && right==0){\\n            //add current combination to result vector\\n            res.push_back(s);\\n            return;\\n        }\\n        //if there are still left parentheses to place, add one to the current combination\\n        if(left>0) dfs(left-1,right,s+\\'(\\',res);\\n        //if there are more right parentheses to place than left, add one to the current combination\\n        if(right>left) dfs(left,right-1,s+\\')\\',res);\\n    }\\n};"
                    },
                    {
                        "username": "wodxuming",
                        "content": "```\\nclass Solution {\\n\\npublic:\\n    vector<string> generateParenthesis(int n) {\\n        if (n == 0) return {};\\n\\n        vector<string> res;\\n\\n        string track;\\n\\n        backtrack(n, n, track, res);\\n        return res;       \\n    }\\n\\n    void backtrack(int left, int right, string& track, vector<string>& res) {\\n        if (right < left) return;\\n        if (left < 0 || right < 0) return;\\n        if (left == 0 && right == 0) {\\n            res.push_back(track);\\n            return;\\n        }\\n        \\n        track.push_back(\\'(\\'); \\n        backtrack(left - 1, right, track, res);\\n        track.pop_back(); \\n\\n        track.push_back(\\')\\'); \\n        backtrack(left, right - 1, track, res);\\n        track.pop_back(); \\n    }\\n};\\n```"
                    },
                    {
                        "username": "jarvis_413",
                        "content": "I think the best approach on solving problem is using catlan\\n"
                    }
                ]
            },
            {
                "id": 1767681,
                "content": [
                    {
                        "username": "muan22",
                        "content": "Hi. I don\\'t know how in backtracking approach when we generate one of the combinations, the next combination start?"
                    },
                    {
                        "username": "aswatha",
                        "content": " void solve(string &s,vector<string>&res,int o,int c, int n){\\n        if(o<=0 && c<=0){\\n            res.push_back(s);\\n            return;\\n        }\\n        if(o>0){\\n            s.push_back(\\'(\\');\\n            solve(s,res,o--,c,n);\\n            s.pop_back();\\n        }\\n        if(c>o){\\n            s.push_back(\\')\\');\\n            solve(s,res,o,c--,n);\\n            s.pop_back();\\n        }\\n    }\\n\\nthis is my function but i am getting\\n\\n AddressSanitizer:DEADLYSIGNAL\\n=================================================================\\n==34==ERROR: AddressSanitizer: stack-overflow on address 0x7ffeb839aff8 (pc 0x000000344937 bp 0x7ffeb839b030 sp 0x7ffeb839b000 T0)\\n==34==ABORTING\\n\\nCan someone tell me why??"
                    },
                    {
                        "username": "hienlemanh2002",
                        "content": "Ti u y\n```\nfunction generateParenthesis(n) {\n    const results = []; // khi to mng kt qu cha cc chui ngoc ng nh dng\n\n    function generate(str, left, right) { // khai bo hm  quy generate vi 3 tham s\n        if (left === 0 && right === 0) { // nu s lng du ngoc m v ng bng 0\n            results.push(str); // thm chui str vo mng kt qu\n            return; // thot khi hm\n        }\n        if (left > 0) { // nu cn du ngoc m cha s dng ht\n            generate(str + \"(\", left - 1, right); // thm du ngoc m vo chui str v gim s lng du ngoc m cn li i 1\n        }\n        if (right > left) { // nu s lng du ngoc ng cn li nhiu hn du ngoc m\n            generate(str + \")\", left, right - 1); // thm du ngoc ng vo chui str v gim s lng du ngoc ng cn li i 1\n        }\n    }\n\n    generate(\"\", n, n); // bt u chy hm generate vi chui rng v s lng du ngoc m v ng bng n\n    return results; // tr v mng kt qu\n}\n```"
                    },
                    {
                        "username": "hawkpie69",
                        "content": "question can be broken down very easily just by understanding the solution set the primary observation is all the brackets are balanced what we get from this if u are making a call for opening bracket then u have to make a call for \\nclosing bracket and the second point from balanced parenthesis is call for closing bracket can never be applied before the opening bracket call and the base case for this  question will be like all the opening and closing brackets are balanced."
                    },
                    {
                        "username": "hawkpie69",
                        "content": "the most simple way to understand the flow of the question is using bruteforce approach i think the complexity will be around 2*2n but the flow is too easy \\nclass Solution {\\n    public List<String> generateParenthesis(int n) {\\n       List<String> ans=new ArrayList<>();\\n\\n       helper(n*2,\"\",0,0,ans,0);\\n\\n       return ans;\\n    }\\n\\n    public void helper(int n,String asf,int oc,int nc,List<String> ans,int idx)\\n    {\\n        if(idx==n)\\n        {\\n            if(isValid(asf))\\n            {\\n                ans.add(asf);\\n            }\\n            return;\\n        }\\n\\n        helper(n,asf+\"(\",oc+1,nc,ans,idx+1);\\n         helper(n,asf+\")\",oc,nc+1,ans,idx+1);\\n    }\\n     public static boolean isValid(String s) {\\n    // Inilization of Stack\\n        Stack<Character> st = new Stack<>();\\n    // Iterating through the given String\\n        for (int i = 0; i < s.length(); i++) {\\n    // Push Open Brackets in the Stack\\n            if (s.charAt(i) == \\'{\\' || s.charAt(i) == \\'(\\' || s.charAt(i) == \\'[\\') {\\n                st.push(s.charAt(i));\\n            }\\n    // checking for the empty stack because if empty this means there is no open bracket at the start which is an invaild string.\\n            else if(st.empty()){\\n                return false;\\n            }\\n    // Check for the close brackets pair on the top and pop them\\n            else if (st.peek() == \\'{\\' && s.charAt(i) == \\'}\\' ) {\\n                st.pop();\\n            } else if (st.peek() == \\'(\\' && s.charAt(i) == \\')\\' ) {\\n                st.pop();\\n            } else if (st.peek() == \\'[\\' && s.charAt(i) == \\']\\' ) {\\n                st.pop();\\n            }else{\\n                return false;\\n            }\\n\\n        }\\n        return st.empty();\\n\\n\\n    }\\n\\n\\n}"
                    },
                    {
                        "username": "abhishekgoklani0",
                        "content": "The function generateParenthesis returns a vector<string> that contains all the valid combinations, and the helper function backtrack uses a backtracking approach to construct the combinations.\\n\\nIn backtrack, the function adds an open parenthesis to the current combination (temp+\"(\") and continues the backtracking process if the number of open parentheses is less than max. Similarly, it adds a close parenthesis to the current combination (temp+\")\") and continues the backtracking process if the number of close parentheses is less than the number of open parentheses. When the length of the current combination (temp) is equal to 2 * max, it means that a valid combination has been found, so it is added to the result vector ans."
                    },
                    {
                        "username": "charbino",
                        "content": "My solution is getting marked wrong for n=4 due to including `\\'(())(())\\'` in the results. How is this not valid? It\\'s not included in the expected answer"
                    },
                    {
                        "username": "piratedjesus",
                        "content": "C++\\n\\nclass Solution {\\npublic:\\n    vector<string> generateParenthesis(int n) {\\n       //vector to store all possible combinations\\n        vector<string> res;\\n        //string to store current combination\\n        string s;\\n        //recursive function to generate all combinations\\n        dfs(n,n,s,res);\\n        return res;  \\n    }\\n    void dfs(int left,int right,string s,vector<string> &res){\\n        //base case, when there are no more left or right parentheses to place\\n        if(left==0 && right==0){\\n            //add current combination to result vector\\n            res.push_back(s);\\n            return;\\n        }\\n        //if there are still left parentheses to place, add one to the current combination\\n        if(left>0) dfs(left-1,right,s+\\'(\\',res);\\n        //if there are more right parentheses to place than left, add one to the current combination\\n        if(right>left) dfs(left,right-1,s+\\')\\',res);\\n    }\\n};"
                    },
                    {
                        "username": "wodxuming",
                        "content": "```\\nclass Solution {\\n\\npublic:\\n    vector<string> generateParenthesis(int n) {\\n        if (n == 0) return {};\\n\\n        vector<string> res;\\n\\n        string track;\\n\\n        backtrack(n, n, track, res);\\n        return res;       \\n    }\\n\\n    void backtrack(int left, int right, string& track, vector<string>& res) {\\n        if (right < left) return;\\n        if (left < 0 || right < 0) return;\\n        if (left == 0 && right == 0) {\\n            res.push_back(track);\\n            return;\\n        }\\n        \\n        track.push_back(\\'(\\'); \\n        backtrack(left - 1, right, track, res);\\n        track.pop_back(); \\n\\n        track.push_back(\\')\\'); \\n        backtrack(left, right - 1, track, res);\\n        track.pop_back(); \\n    }\\n};\\n```"
                    },
                    {
                        "username": "jarvis_413",
                        "content": "I think the best approach on solving problem is using catlan\\n"
                    }
                ]
            },
            {
                "id": 1764232,
                "content": [
                    {
                        "username": "muan22",
                        "content": "Hi. I don\\'t know how in backtracking approach when we generate one of the combinations, the next combination start?"
                    },
                    {
                        "username": "aswatha",
                        "content": " void solve(string &s,vector<string>&res,int o,int c, int n){\\n        if(o<=0 && c<=0){\\n            res.push_back(s);\\n            return;\\n        }\\n        if(o>0){\\n            s.push_back(\\'(\\');\\n            solve(s,res,o--,c,n);\\n            s.pop_back();\\n        }\\n        if(c>o){\\n            s.push_back(\\')\\');\\n            solve(s,res,o,c--,n);\\n            s.pop_back();\\n        }\\n    }\\n\\nthis is my function but i am getting\\n\\n AddressSanitizer:DEADLYSIGNAL\\n=================================================================\\n==34==ERROR: AddressSanitizer: stack-overflow on address 0x7ffeb839aff8 (pc 0x000000344937 bp 0x7ffeb839b030 sp 0x7ffeb839b000 T0)\\n==34==ABORTING\\n\\nCan someone tell me why??"
                    },
                    {
                        "username": "hienlemanh2002",
                        "content": "Ti u y\n```\nfunction generateParenthesis(n) {\n    const results = []; // khi to mng kt qu cha cc chui ngoc ng nh dng\n\n    function generate(str, left, right) { // khai bo hm  quy generate vi 3 tham s\n        if (left === 0 && right === 0) { // nu s lng du ngoc m v ng bng 0\n            results.push(str); // thm chui str vo mng kt qu\n            return; // thot khi hm\n        }\n        if (left > 0) { // nu cn du ngoc m cha s dng ht\n            generate(str + \"(\", left - 1, right); // thm du ngoc m vo chui str v gim s lng du ngoc m cn li i 1\n        }\n        if (right > left) { // nu s lng du ngoc ng cn li nhiu hn du ngoc m\n            generate(str + \")\", left, right - 1); // thm du ngoc ng vo chui str v gim s lng du ngoc ng cn li i 1\n        }\n    }\n\n    generate(\"\", n, n); // bt u chy hm generate vi chui rng v s lng du ngoc m v ng bng n\n    return results; // tr v mng kt qu\n}\n```"
                    },
                    {
                        "username": "hawkpie69",
                        "content": "question can be broken down very easily just by understanding the solution set the primary observation is all the brackets are balanced what we get from this if u are making a call for opening bracket then u have to make a call for \\nclosing bracket and the second point from balanced parenthesis is call for closing bracket can never be applied before the opening bracket call and the base case for this  question will be like all the opening and closing brackets are balanced."
                    },
                    {
                        "username": "hawkpie69",
                        "content": "the most simple way to understand the flow of the question is using bruteforce approach i think the complexity will be around 2*2n but the flow is too easy \\nclass Solution {\\n    public List<String> generateParenthesis(int n) {\\n       List<String> ans=new ArrayList<>();\\n\\n       helper(n*2,\"\",0,0,ans,0);\\n\\n       return ans;\\n    }\\n\\n    public void helper(int n,String asf,int oc,int nc,List<String> ans,int idx)\\n    {\\n        if(idx==n)\\n        {\\n            if(isValid(asf))\\n            {\\n                ans.add(asf);\\n            }\\n            return;\\n        }\\n\\n        helper(n,asf+\"(\",oc+1,nc,ans,idx+1);\\n         helper(n,asf+\")\",oc,nc+1,ans,idx+1);\\n    }\\n     public static boolean isValid(String s) {\\n    // Inilization of Stack\\n        Stack<Character> st = new Stack<>();\\n    // Iterating through the given String\\n        for (int i = 0; i < s.length(); i++) {\\n    // Push Open Brackets in the Stack\\n            if (s.charAt(i) == \\'{\\' || s.charAt(i) == \\'(\\' || s.charAt(i) == \\'[\\') {\\n                st.push(s.charAt(i));\\n            }\\n    // checking for the empty stack because if empty this means there is no open bracket at the start which is an invaild string.\\n            else if(st.empty()){\\n                return false;\\n            }\\n    // Check for the close brackets pair on the top and pop them\\n            else if (st.peek() == \\'{\\' && s.charAt(i) == \\'}\\' ) {\\n                st.pop();\\n            } else if (st.peek() == \\'(\\' && s.charAt(i) == \\')\\' ) {\\n                st.pop();\\n            } else if (st.peek() == \\'[\\' && s.charAt(i) == \\']\\' ) {\\n                st.pop();\\n            }else{\\n                return false;\\n            }\\n\\n        }\\n        return st.empty();\\n\\n\\n    }\\n\\n\\n}"
                    },
                    {
                        "username": "abhishekgoklani0",
                        "content": "The function generateParenthesis returns a vector<string> that contains all the valid combinations, and the helper function backtrack uses a backtracking approach to construct the combinations.\\n\\nIn backtrack, the function adds an open parenthesis to the current combination (temp+\"(\") and continues the backtracking process if the number of open parentheses is less than max. Similarly, it adds a close parenthesis to the current combination (temp+\")\") and continues the backtracking process if the number of close parentheses is less than the number of open parentheses. When the length of the current combination (temp) is equal to 2 * max, it means that a valid combination has been found, so it is added to the result vector ans."
                    },
                    {
                        "username": "charbino",
                        "content": "My solution is getting marked wrong for n=4 due to including `\\'(())(())\\'` in the results. How is this not valid? It\\'s not included in the expected answer"
                    },
                    {
                        "username": "piratedjesus",
                        "content": "C++\\n\\nclass Solution {\\npublic:\\n    vector<string> generateParenthesis(int n) {\\n       //vector to store all possible combinations\\n        vector<string> res;\\n        //string to store current combination\\n        string s;\\n        //recursive function to generate all combinations\\n        dfs(n,n,s,res);\\n        return res;  \\n    }\\n    void dfs(int left,int right,string s,vector<string> &res){\\n        //base case, when there are no more left or right parentheses to place\\n        if(left==0 && right==0){\\n            //add current combination to result vector\\n            res.push_back(s);\\n            return;\\n        }\\n        //if there are still left parentheses to place, add one to the current combination\\n        if(left>0) dfs(left-1,right,s+\\'(\\',res);\\n        //if there are more right parentheses to place than left, add one to the current combination\\n        if(right>left) dfs(left,right-1,s+\\')\\',res);\\n    }\\n};"
                    },
                    {
                        "username": "wodxuming",
                        "content": "```\\nclass Solution {\\n\\npublic:\\n    vector<string> generateParenthesis(int n) {\\n        if (n == 0) return {};\\n\\n        vector<string> res;\\n\\n        string track;\\n\\n        backtrack(n, n, track, res);\\n        return res;       \\n    }\\n\\n    void backtrack(int left, int right, string& track, vector<string>& res) {\\n        if (right < left) return;\\n        if (left < 0 || right < 0) return;\\n        if (left == 0 && right == 0) {\\n            res.push_back(track);\\n            return;\\n        }\\n        \\n        track.push_back(\\'(\\'); \\n        backtrack(left - 1, right, track, res);\\n        track.pop_back(); \\n\\n        track.push_back(\\')\\'); \\n        backtrack(left, right - 1, track, res);\\n        track.pop_back(); \\n    }\\n};\\n```"
                    },
                    {
                        "username": "jarvis_413",
                        "content": "I think the best approach on solving problem is using catlan\\n"
                    }
                ]
            },
            {
                "id": 1754546,
                "content": [
                    {
                        "username": "muan22",
                        "content": "Hi. I don\\'t know how in backtracking approach when we generate one of the combinations, the next combination start?"
                    },
                    {
                        "username": "aswatha",
                        "content": " void solve(string &s,vector<string>&res,int o,int c, int n){\\n        if(o<=0 && c<=0){\\n            res.push_back(s);\\n            return;\\n        }\\n        if(o>0){\\n            s.push_back(\\'(\\');\\n            solve(s,res,o--,c,n);\\n            s.pop_back();\\n        }\\n        if(c>o){\\n            s.push_back(\\')\\');\\n            solve(s,res,o,c--,n);\\n            s.pop_back();\\n        }\\n    }\\n\\nthis is my function but i am getting\\n\\n AddressSanitizer:DEADLYSIGNAL\\n=================================================================\\n==34==ERROR: AddressSanitizer: stack-overflow on address 0x7ffeb839aff8 (pc 0x000000344937 bp 0x7ffeb839b030 sp 0x7ffeb839b000 T0)\\n==34==ABORTING\\n\\nCan someone tell me why??"
                    },
                    {
                        "username": "hienlemanh2002",
                        "content": "Ti u y\n```\nfunction generateParenthesis(n) {\n    const results = []; // khi to mng kt qu cha cc chui ngoc ng nh dng\n\n    function generate(str, left, right) { // khai bo hm  quy generate vi 3 tham s\n        if (left === 0 && right === 0) { // nu s lng du ngoc m v ng bng 0\n            results.push(str); // thm chui str vo mng kt qu\n            return; // thot khi hm\n        }\n        if (left > 0) { // nu cn du ngoc m cha s dng ht\n            generate(str + \"(\", left - 1, right); // thm du ngoc m vo chui str v gim s lng du ngoc m cn li i 1\n        }\n        if (right > left) { // nu s lng du ngoc ng cn li nhiu hn du ngoc m\n            generate(str + \")\", left, right - 1); // thm du ngoc ng vo chui str v gim s lng du ngoc ng cn li i 1\n        }\n    }\n\n    generate(\"\", n, n); // bt u chy hm generate vi chui rng v s lng du ngoc m v ng bng n\n    return results; // tr v mng kt qu\n}\n```"
                    },
                    {
                        "username": "hawkpie69",
                        "content": "question can be broken down very easily just by understanding the solution set the primary observation is all the brackets are balanced what we get from this if u are making a call for opening bracket then u have to make a call for \\nclosing bracket and the second point from balanced parenthesis is call for closing bracket can never be applied before the opening bracket call and the base case for this  question will be like all the opening and closing brackets are balanced."
                    },
                    {
                        "username": "hawkpie69",
                        "content": "the most simple way to understand the flow of the question is using bruteforce approach i think the complexity will be around 2*2n but the flow is too easy \\nclass Solution {\\n    public List<String> generateParenthesis(int n) {\\n       List<String> ans=new ArrayList<>();\\n\\n       helper(n*2,\"\",0,0,ans,0);\\n\\n       return ans;\\n    }\\n\\n    public void helper(int n,String asf,int oc,int nc,List<String> ans,int idx)\\n    {\\n        if(idx==n)\\n        {\\n            if(isValid(asf))\\n            {\\n                ans.add(asf);\\n            }\\n            return;\\n        }\\n\\n        helper(n,asf+\"(\",oc+1,nc,ans,idx+1);\\n         helper(n,asf+\")\",oc,nc+1,ans,idx+1);\\n    }\\n     public static boolean isValid(String s) {\\n    // Inilization of Stack\\n        Stack<Character> st = new Stack<>();\\n    // Iterating through the given String\\n        for (int i = 0; i < s.length(); i++) {\\n    // Push Open Brackets in the Stack\\n            if (s.charAt(i) == \\'{\\' || s.charAt(i) == \\'(\\' || s.charAt(i) == \\'[\\') {\\n                st.push(s.charAt(i));\\n            }\\n    // checking for the empty stack because if empty this means there is no open bracket at the start which is an invaild string.\\n            else if(st.empty()){\\n                return false;\\n            }\\n    // Check for the close brackets pair on the top and pop them\\n            else if (st.peek() == \\'{\\' && s.charAt(i) == \\'}\\' ) {\\n                st.pop();\\n            } else if (st.peek() == \\'(\\' && s.charAt(i) == \\')\\' ) {\\n                st.pop();\\n            } else if (st.peek() == \\'[\\' && s.charAt(i) == \\']\\' ) {\\n                st.pop();\\n            }else{\\n                return false;\\n            }\\n\\n        }\\n        return st.empty();\\n\\n\\n    }\\n\\n\\n}"
                    },
                    {
                        "username": "abhishekgoklani0",
                        "content": "The function generateParenthesis returns a vector<string> that contains all the valid combinations, and the helper function backtrack uses a backtracking approach to construct the combinations.\\n\\nIn backtrack, the function adds an open parenthesis to the current combination (temp+\"(\") and continues the backtracking process if the number of open parentheses is less than max. Similarly, it adds a close parenthesis to the current combination (temp+\")\") and continues the backtracking process if the number of close parentheses is less than the number of open parentheses. When the length of the current combination (temp) is equal to 2 * max, it means that a valid combination has been found, so it is added to the result vector ans."
                    },
                    {
                        "username": "charbino",
                        "content": "My solution is getting marked wrong for n=4 due to including `\\'(())(())\\'` in the results. How is this not valid? It\\'s not included in the expected answer"
                    },
                    {
                        "username": "piratedjesus",
                        "content": "C++\\n\\nclass Solution {\\npublic:\\n    vector<string> generateParenthesis(int n) {\\n       //vector to store all possible combinations\\n        vector<string> res;\\n        //string to store current combination\\n        string s;\\n        //recursive function to generate all combinations\\n        dfs(n,n,s,res);\\n        return res;  \\n    }\\n    void dfs(int left,int right,string s,vector<string> &res){\\n        //base case, when there are no more left or right parentheses to place\\n        if(left==0 && right==0){\\n            //add current combination to result vector\\n            res.push_back(s);\\n            return;\\n        }\\n        //if there are still left parentheses to place, add one to the current combination\\n        if(left>0) dfs(left-1,right,s+\\'(\\',res);\\n        //if there are more right parentheses to place than left, add one to the current combination\\n        if(right>left) dfs(left,right-1,s+\\')\\',res);\\n    }\\n};"
                    },
                    {
                        "username": "wodxuming",
                        "content": "```\\nclass Solution {\\n\\npublic:\\n    vector<string> generateParenthesis(int n) {\\n        if (n == 0) return {};\\n\\n        vector<string> res;\\n\\n        string track;\\n\\n        backtrack(n, n, track, res);\\n        return res;       \\n    }\\n\\n    void backtrack(int left, int right, string& track, vector<string>& res) {\\n        if (right < left) return;\\n        if (left < 0 || right < 0) return;\\n        if (left == 0 && right == 0) {\\n            res.push_back(track);\\n            return;\\n        }\\n        \\n        track.push_back(\\'(\\'); \\n        backtrack(left - 1, right, track, res);\\n        track.pop_back(); \\n\\n        track.push_back(\\')\\'); \\n        backtrack(left, right - 1, track, res);\\n        track.pop_back(); \\n    }\\n};\\n```"
                    },
                    {
                        "username": "jarvis_413",
                        "content": "I think the best approach on solving problem is using catlan\\n"
                    }
                ]
            },
            {
                "id": 1742960,
                "content": [
                    {
                        "username": "runtime_terror_04",
                        "content": "plzzz help not working this recursive code\\n\\nclass Solution {\\n    private:\\n    void gen(string ans,set<string>&st,int n){\\n   if(n==0){\\n    string k=\"\";\\n    st.insert(ans);\\n    return ;\\n\\n   }\\n   gen(ans+\"()\",st,n-1);\\n   gen(\"()\"+ans,st,n-1);\\n   gen(\"(\"+ans+\")\",st,n-1);\\n\\n}\\npublic:\\n    vector<string> generateParenthesis(int n) {\\n        set<string>st;\\n        vector<string>ss;\\n        string k=\"(()())\";\\n        gen(\"\",st,n);\\n        for(auto it:st){\\n            ss.push_back(it);\\n        }\\n        if(n==4){\\n            ss.push_back(k);\\n        }\\n       return ss;\\n\\n\\n    }\\n};"
                    },
                    {
                        "username": "smanjot444",
                        "content": "My code doesn\\'t seem to work\\nPlease HELP\\nclass Solution {\\npublic:\\n    vector<string> generateParenthesis(int n) {\\n        string ds;\\n        vector<string> res; \\n        generator(n, res, ds, 0, 0);\\n        return res;\\n    }\\n\\n    void generator(int n, vector<string> &res, string ds, int open, int close){\\n        if(close>open || open>n || close>n)\\n            return;\\n        if(open==close==n){\\n            res.push_back(ds);\\n            return;\\n        }\\n        generator(n, res, ds + \\'(\\', open + 1, close);\\n        generator(n, res, ds + \\')\\', open, close + 1);\\n    }\\n};"
                    },
                    {
                        "username": "wodxuming",
                        "content": "\\xB7\\xB7\\xB7\\nclass Solution {\\n\\npublic:\\n    vector<string> generateParenthesis(int n) {\\n        if (n == 0) return {};\\n\\n        vector<string> res;\\n\\n        string track;\\n\\n        backtrack(n, n, track, res);\\n        return res;       \\n    }\\n\\n    void backtrack(int left, int right, string& track, vector<string>& res) {\\n        if (right < left) return;\\n        if (left < 0 || right < 0) return;\\n        if (left == 0 && right == 0) {\\n            res.push_back(track);\\n            return;\\n        }\\n        \\n        track.push_back(\\'(\\'); \\n        backtrack(left - 1, right, track, res);\\n        track.pop_back(); \\n\\n        track.push_back(\\')\\'); \\n        backtrack(left, right - 1, track, res);\\n        track.pop_back(); \\n    }\\n};\\n\\xB7\\xB7\\xB7"
                    },
                    {
                        "username": "Bg21460",
                        "content": "Java DFS\\nhttps://leetcode.com/problems/generate-parentheses/submissions/856905486/"
                    },
                    {
                        "username": "wikyyuen",
                        "content": " `var resList []string\\n\\nfunc generateParenthesis(n int) []string {\\n\\tresList = []string{}\\n\\ttraverse(\"(\", 1, n-1, n)\\n\\treturn resList\\n}\\n\\nfunc traverse(s string, need int, left int, right int) {\\n\\tif right == 0 && left == 0 {\\n\\t\\tresList = append(resList, s)\\n\\t}\\n\\tif need > 0 && right > 0 {\\n\\t\\ttraverse(s+\")\", need-1, left, right-1)\\n\\t}\\n\\tif left > 0 {\\n\\t\\ttraverse(s+\"(\", need+1, left-1, right)\\n\\t}\\n}`"
                    },
                    {
                        "username": "sagarbalyan",
                        "content": "Why one works but other doesn\\'t?\\n\\nWhy does this not work?\\n\\n`        if(open<n) {\\n            open++;\\n            helper(result,open,close,str+\"(\",n);\\n        }`\\n\\nBut this does?\\n\\n`        if(open<n) {\\n            helper(result,open+1,close,str+\"(\",n);\\n        }`"
                    },
                    {
                        "username": "ayush1018",
                        "content": "Can someone help what is the error in this solution:\\nIt is showing\\nAddressSanitizer:DEADLYSIGNAL\\n\\n\\nclass Solution {\\npublic:\\n\\nvoid solve(int n, int open, int close, string currComb, vector<string>& ans)\\n{\\n    if(open == n && close == n)\\n    {\\n        ans.push_back(currComb);\\n        return;\\n    }\\n\\n    if(open<n)\\n    {\\n        currComb = currComb + \"(\";\\n        solve(n,open+1,close,currComb,ans);\\n    }\\n\\n    if(close<open)\\n    \\n        currComb = currComb + \")\";\\n        solve(n,open,close+1,currComb,ans);\\n    }\\n\\n    vector<string> generateParenthesis(int n) {\\n        int open=0, close=0;\\n        vector<string>ans;\\n        string currComb =\"\";\\n        solve(n,open,close,currComb,ans);\\n\\n        return ans;\\n    }\\n}; "
                    },
                    {
                        "username": "yashdeora",
                        "content": "Here is problem solution in Python, C++, JAVA and C Programming.\\n[https://www.gyangav.com/2022/11/leetcode-generate-parenthese-problem-solution.html](https://www.gyangav.com/2022/11/leetcode-generate-parenthese-problem-solution.html)"
                    },
                    {
                        "username": "Shubham_Awasthi__07",
                        "content": " `class Solution {\\n    public void backTrack(List<String> res ,String s, int n , int left , int right){\\n        if(s.length() == 2 * n){\\n            res.add(s);\\n            return ;\\n        }\\n        if (left < n)\\n            backTrack(res , s + \\'(\\' , n , left + 1 , right);\\n        if (right < left)\\n            backTrack(res , s + \\')\\' , n , left , right + 1);\\n\\n    }\\n    public List<String> generateParenthesis(int n) {\\n        List<String> ans = new ArrayList<>();\\n        backTrack(ans , \"\" , n , 0 , 0);\\n        return ans;\\n    }\\n}`"
                    },
                    {
                        "username": "Harshleen_Kaur",
                        "content": "What is the time complexity ?"
                    }
                ]
            },
            {
                "id": 1741168,
                "content": [
                    {
                        "username": "runtime_terror_04",
                        "content": "plzzz help not working this recursive code\\n\\nclass Solution {\\n    private:\\n    void gen(string ans,set<string>&st,int n){\\n   if(n==0){\\n    string k=\"\";\\n    st.insert(ans);\\n    return ;\\n\\n   }\\n   gen(ans+\"()\",st,n-1);\\n   gen(\"()\"+ans,st,n-1);\\n   gen(\"(\"+ans+\")\",st,n-1);\\n\\n}\\npublic:\\n    vector<string> generateParenthesis(int n) {\\n        set<string>st;\\n        vector<string>ss;\\n        string k=\"(()())\";\\n        gen(\"\",st,n);\\n        for(auto it:st){\\n            ss.push_back(it);\\n        }\\n        if(n==4){\\n            ss.push_back(k);\\n        }\\n       return ss;\\n\\n\\n    }\\n};"
                    },
                    {
                        "username": "smanjot444",
                        "content": "My code doesn\\'t seem to work\\nPlease HELP\\nclass Solution {\\npublic:\\n    vector<string> generateParenthesis(int n) {\\n        string ds;\\n        vector<string> res; \\n        generator(n, res, ds, 0, 0);\\n        return res;\\n    }\\n\\n    void generator(int n, vector<string> &res, string ds, int open, int close){\\n        if(close>open || open>n || close>n)\\n            return;\\n        if(open==close==n){\\n            res.push_back(ds);\\n            return;\\n        }\\n        generator(n, res, ds + \\'(\\', open + 1, close);\\n        generator(n, res, ds + \\')\\', open, close + 1);\\n    }\\n};"
                    },
                    {
                        "username": "wodxuming",
                        "content": "\\xB7\\xB7\\xB7\\nclass Solution {\\n\\npublic:\\n    vector<string> generateParenthesis(int n) {\\n        if (n == 0) return {};\\n\\n        vector<string> res;\\n\\n        string track;\\n\\n        backtrack(n, n, track, res);\\n        return res;       \\n    }\\n\\n    void backtrack(int left, int right, string& track, vector<string>& res) {\\n        if (right < left) return;\\n        if (left < 0 || right < 0) return;\\n        if (left == 0 && right == 0) {\\n            res.push_back(track);\\n            return;\\n        }\\n        \\n        track.push_back(\\'(\\'); \\n        backtrack(left - 1, right, track, res);\\n        track.pop_back(); \\n\\n        track.push_back(\\')\\'); \\n        backtrack(left, right - 1, track, res);\\n        track.pop_back(); \\n    }\\n};\\n\\xB7\\xB7\\xB7"
                    },
                    {
                        "username": "Bg21460",
                        "content": "Java DFS\\nhttps://leetcode.com/problems/generate-parentheses/submissions/856905486/"
                    },
                    {
                        "username": "wikyyuen",
                        "content": " `var resList []string\\n\\nfunc generateParenthesis(n int) []string {\\n\\tresList = []string{}\\n\\ttraverse(\"(\", 1, n-1, n)\\n\\treturn resList\\n}\\n\\nfunc traverse(s string, need int, left int, right int) {\\n\\tif right == 0 && left == 0 {\\n\\t\\tresList = append(resList, s)\\n\\t}\\n\\tif need > 0 && right > 0 {\\n\\t\\ttraverse(s+\")\", need-1, left, right-1)\\n\\t}\\n\\tif left > 0 {\\n\\t\\ttraverse(s+\"(\", need+1, left-1, right)\\n\\t}\\n}`"
                    },
                    {
                        "username": "sagarbalyan",
                        "content": "Why one works but other doesn\\'t?\\n\\nWhy does this not work?\\n\\n`        if(open<n) {\\n            open++;\\n            helper(result,open,close,str+\"(\",n);\\n        }`\\n\\nBut this does?\\n\\n`        if(open<n) {\\n            helper(result,open+1,close,str+\"(\",n);\\n        }`"
                    },
                    {
                        "username": "ayush1018",
                        "content": "Can someone help what is the error in this solution:\\nIt is showing\\nAddressSanitizer:DEADLYSIGNAL\\n\\n\\nclass Solution {\\npublic:\\n\\nvoid solve(int n, int open, int close, string currComb, vector<string>& ans)\\n{\\n    if(open == n && close == n)\\n    {\\n        ans.push_back(currComb);\\n        return;\\n    }\\n\\n    if(open<n)\\n    {\\n        currComb = currComb + \"(\";\\n        solve(n,open+1,close,currComb,ans);\\n    }\\n\\n    if(close<open)\\n    \\n        currComb = currComb + \")\";\\n        solve(n,open,close+1,currComb,ans);\\n    }\\n\\n    vector<string> generateParenthesis(int n) {\\n        int open=0, close=0;\\n        vector<string>ans;\\n        string currComb =\"\";\\n        solve(n,open,close,currComb,ans);\\n\\n        return ans;\\n    }\\n}; "
                    },
                    {
                        "username": "yashdeora",
                        "content": "Here is problem solution in Python, C++, JAVA and C Programming.\\n[https://www.gyangav.com/2022/11/leetcode-generate-parenthese-problem-solution.html](https://www.gyangav.com/2022/11/leetcode-generate-parenthese-problem-solution.html)"
                    },
                    {
                        "username": "Shubham_Awasthi__07",
                        "content": " `class Solution {\\n    public void backTrack(List<String> res ,String s, int n , int left , int right){\\n        if(s.length() == 2 * n){\\n            res.add(s);\\n            return ;\\n        }\\n        if (left < n)\\n            backTrack(res , s + \\'(\\' , n , left + 1 , right);\\n        if (right < left)\\n            backTrack(res , s + \\')\\' , n , left , right + 1);\\n\\n    }\\n    public List<String> generateParenthesis(int n) {\\n        List<String> ans = new ArrayList<>();\\n        backTrack(ans , \"\" , n , 0 , 0);\\n        return ans;\\n    }\\n}`"
                    },
                    {
                        "username": "Harshleen_Kaur",
                        "content": "What is the time complexity ?"
                    }
                ]
            },
            {
                "id": 1710452,
                "content": [
                    {
                        "username": "runtime_terror_04",
                        "content": "plzzz help not working this recursive code\\n\\nclass Solution {\\n    private:\\n    void gen(string ans,set<string>&st,int n){\\n   if(n==0){\\n    string k=\"\";\\n    st.insert(ans);\\n    return ;\\n\\n   }\\n   gen(ans+\"()\",st,n-1);\\n   gen(\"()\"+ans,st,n-1);\\n   gen(\"(\"+ans+\")\",st,n-1);\\n\\n}\\npublic:\\n    vector<string> generateParenthesis(int n) {\\n        set<string>st;\\n        vector<string>ss;\\n        string k=\"(()())\";\\n        gen(\"\",st,n);\\n        for(auto it:st){\\n            ss.push_back(it);\\n        }\\n        if(n==4){\\n            ss.push_back(k);\\n        }\\n       return ss;\\n\\n\\n    }\\n};"
                    },
                    {
                        "username": "smanjot444",
                        "content": "My code doesn\\'t seem to work\\nPlease HELP\\nclass Solution {\\npublic:\\n    vector<string> generateParenthesis(int n) {\\n        string ds;\\n        vector<string> res; \\n        generator(n, res, ds, 0, 0);\\n        return res;\\n    }\\n\\n    void generator(int n, vector<string> &res, string ds, int open, int close){\\n        if(close>open || open>n || close>n)\\n            return;\\n        if(open==close==n){\\n            res.push_back(ds);\\n            return;\\n        }\\n        generator(n, res, ds + \\'(\\', open + 1, close);\\n        generator(n, res, ds + \\')\\', open, close + 1);\\n    }\\n};"
                    },
                    {
                        "username": "wodxuming",
                        "content": "\\xB7\\xB7\\xB7\\nclass Solution {\\n\\npublic:\\n    vector<string> generateParenthesis(int n) {\\n        if (n == 0) return {};\\n\\n        vector<string> res;\\n\\n        string track;\\n\\n        backtrack(n, n, track, res);\\n        return res;       \\n    }\\n\\n    void backtrack(int left, int right, string& track, vector<string>& res) {\\n        if (right < left) return;\\n        if (left < 0 || right < 0) return;\\n        if (left == 0 && right == 0) {\\n            res.push_back(track);\\n            return;\\n        }\\n        \\n        track.push_back(\\'(\\'); \\n        backtrack(left - 1, right, track, res);\\n        track.pop_back(); \\n\\n        track.push_back(\\')\\'); \\n        backtrack(left, right - 1, track, res);\\n        track.pop_back(); \\n    }\\n};\\n\\xB7\\xB7\\xB7"
                    },
                    {
                        "username": "Bg21460",
                        "content": "Java DFS\\nhttps://leetcode.com/problems/generate-parentheses/submissions/856905486/"
                    },
                    {
                        "username": "wikyyuen",
                        "content": " `var resList []string\\n\\nfunc generateParenthesis(n int) []string {\\n\\tresList = []string{}\\n\\ttraverse(\"(\", 1, n-1, n)\\n\\treturn resList\\n}\\n\\nfunc traverse(s string, need int, left int, right int) {\\n\\tif right == 0 && left == 0 {\\n\\t\\tresList = append(resList, s)\\n\\t}\\n\\tif need > 0 && right > 0 {\\n\\t\\ttraverse(s+\")\", need-1, left, right-1)\\n\\t}\\n\\tif left > 0 {\\n\\t\\ttraverse(s+\"(\", need+1, left-1, right)\\n\\t}\\n}`"
                    },
                    {
                        "username": "sagarbalyan",
                        "content": "Why one works but other doesn\\'t?\\n\\nWhy does this not work?\\n\\n`        if(open<n) {\\n            open++;\\n            helper(result,open,close,str+\"(\",n);\\n        }`\\n\\nBut this does?\\n\\n`        if(open<n) {\\n            helper(result,open+1,close,str+\"(\",n);\\n        }`"
                    },
                    {
                        "username": "ayush1018",
                        "content": "Can someone help what is the error in this solution:\\nIt is showing\\nAddressSanitizer:DEADLYSIGNAL\\n\\n\\nclass Solution {\\npublic:\\n\\nvoid solve(int n, int open, int close, string currComb, vector<string>& ans)\\n{\\n    if(open == n && close == n)\\n    {\\n        ans.push_back(currComb);\\n        return;\\n    }\\n\\n    if(open<n)\\n    {\\n        currComb = currComb + \"(\";\\n        solve(n,open+1,close,currComb,ans);\\n    }\\n\\n    if(close<open)\\n    \\n        currComb = currComb + \")\";\\n        solve(n,open,close+1,currComb,ans);\\n    }\\n\\n    vector<string> generateParenthesis(int n) {\\n        int open=0, close=0;\\n        vector<string>ans;\\n        string currComb =\"\";\\n        solve(n,open,close,currComb,ans);\\n\\n        return ans;\\n    }\\n}; "
                    },
                    {
                        "username": "yashdeora",
                        "content": "Here is problem solution in Python, C++, JAVA and C Programming.\\n[https://www.gyangav.com/2022/11/leetcode-generate-parenthese-problem-solution.html](https://www.gyangav.com/2022/11/leetcode-generate-parenthese-problem-solution.html)"
                    },
                    {
                        "username": "Shubham_Awasthi__07",
                        "content": " `class Solution {\\n    public void backTrack(List<String> res ,String s, int n , int left , int right){\\n        if(s.length() == 2 * n){\\n            res.add(s);\\n            return ;\\n        }\\n        if (left < n)\\n            backTrack(res , s + \\'(\\' , n , left + 1 , right);\\n        if (right < left)\\n            backTrack(res , s + \\')\\' , n , left , right + 1);\\n\\n    }\\n    public List<String> generateParenthesis(int n) {\\n        List<String> ans = new ArrayList<>();\\n        backTrack(ans , \"\" , n , 0 , 0);\\n        return ans;\\n    }\\n}`"
                    },
                    {
                        "username": "Harshleen_Kaur",
                        "content": "What is the time complexity ?"
                    }
                ]
            },
            {
                "id": 1710412,
                "content": [
                    {
                        "username": "runtime_terror_04",
                        "content": "plzzz help not working this recursive code\\n\\nclass Solution {\\n    private:\\n    void gen(string ans,set<string>&st,int n){\\n   if(n==0){\\n    string k=\"\";\\n    st.insert(ans);\\n    return ;\\n\\n   }\\n   gen(ans+\"()\",st,n-1);\\n   gen(\"()\"+ans,st,n-1);\\n   gen(\"(\"+ans+\")\",st,n-1);\\n\\n}\\npublic:\\n    vector<string> generateParenthesis(int n) {\\n        set<string>st;\\n        vector<string>ss;\\n        string k=\"(()())\";\\n        gen(\"\",st,n);\\n        for(auto it:st){\\n            ss.push_back(it);\\n        }\\n        if(n==4){\\n            ss.push_back(k);\\n        }\\n       return ss;\\n\\n\\n    }\\n};"
                    },
                    {
                        "username": "smanjot444",
                        "content": "My code doesn\\'t seem to work\\nPlease HELP\\nclass Solution {\\npublic:\\n    vector<string> generateParenthesis(int n) {\\n        string ds;\\n        vector<string> res; \\n        generator(n, res, ds, 0, 0);\\n        return res;\\n    }\\n\\n    void generator(int n, vector<string> &res, string ds, int open, int close){\\n        if(close>open || open>n || close>n)\\n            return;\\n        if(open==close==n){\\n            res.push_back(ds);\\n            return;\\n        }\\n        generator(n, res, ds + \\'(\\', open + 1, close);\\n        generator(n, res, ds + \\')\\', open, close + 1);\\n    }\\n};"
                    },
                    {
                        "username": "wodxuming",
                        "content": "\\xB7\\xB7\\xB7\\nclass Solution {\\n\\npublic:\\n    vector<string> generateParenthesis(int n) {\\n        if (n == 0) return {};\\n\\n        vector<string> res;\\n\\n        string track;\\n\\n        backtrack(n, n, track, res);\\n        return res;       \\n    }\\n\\n    void backtrack(int left, int right, string& track, vector<string>& res) {\\n        if (right < left) return;\\n        if (left < 0 || right < 0) return;\\n        if (left == 0 && right == 0) {\\n            res.push_back(track);\\n            return;\\n        }\\n        \\n        track.push_back(\\'(\\'); \\n        backtrack(left - 1, right, track, res);\\n        track.pop_back(); \\n\\n        track.push_back(\\')\\'); \\n        backtrack(left, right - 1, track, res);\\n        track.pop_back(); \\n    }\\n};\\n\\xB7\\xB7\\xB7"
                    },
                    {
                        "username": "Bg21460",
                        "content": "Java DFS\\nhttps://leetcode.com/problems/generate-parentheses/submissions/856905486/"
                    },
                    {
                        "username": "wikyyuen",
                        "content": " `var resList []string\\n\\nfunc generateParenthesis(n int) []string {\\n\\tresList = []string{}\\n\\ttraverse(\"(\", 1, n-1, n)\\n\\treturn resList\\n}\\n\\nfunc traverse(s string, need int, left int, right int) {\\n\\tif right == 0 && left == 0 {\\n\\t\\tresList = append(resList, s)\\n\\t}\\n\\tif need > 0 && right > 0 {\\n\\t\\ttraverse(s+\")\", need-1, left, right-1)\\n\\t}\\n\\tif left > 0 {\\n\\t\\ttraverse(s+\"(\", need+1, left-1, right)\\n\\t}\\n}`"
                    },
                    {
                        "username": "sagarbalyan",
                        "content": "Why one works but other doesn\\'t?\\n\\nWhy does this not work?\\n\\n`        if(open<n) {\\n            open++;\\n            helper(result,open,close,str+\"(\",n);\\n        }`\\n\\nBut this does?\\n\\n`        if(open<n) {\\n            helper(result,open+1,close,str+\"(\",n);\\n        }`"
                    },
                    {
                        "username": "ayush1018",
                        "content": "Can someone help what is the error in this solution:\\nIt is showing\\nAddressSanitizer:DEADLYSIGNAL\\n\\n\\nclass Solution {\\npublic:\\n\\nvoid solve(int n, int open, int close, string currComb, vector<string>& ans)\\n{\\n    if(open == n && close == n)\\n    {\\n        ans.push_back(currComb);\\n        return;\\n    }\\n\\n    if(open<n)\\n    {\\n        currComb = currComb + \"(\";\\n        solve(n,open+1,close,currComb,ans);\\n    }\\n\\n    if(close<open)\\n    \\n        currComb = currComb + \")\";\\n        solve(n,open,close+1,currComb,ans);\\n    }\\n\\n    vector<string> generateParenthesis(int n) {\\n        int open=0, close=0;\\n        vector<string>ans;\\n        string currComb =\"\";\\n        solve(n,open,close,currComb,ans);\\n\\n        return ans;\\n    }\\n}; "
                    },
                    {
                        "username": "yashdeora",
                        "content": "Here is problem solution in Python, C++, JAVA and C Programming.\\n[https://www.gyangav.com/2022/11/leetcode-generate-parenthese-problem-solution.html](https://www.gyangav.com/2022/11/leetcode-generate-parenthese-problem-solution.html)"
                    },
                    {
                        "username": "Shubham_Awasthi__07",
                        "content": " `class Solution {\\n    public void backTrack(List<String> res ,String s, int n , int left , int right){\\n        if(s.length() == 2 * n){\\n            res.add(s);\\n            return ;\\n        }\\n        if (left < n)\\n            backTrack(res , s + \\'(\\' , n , left + 1 , right);\\n        if (right < left)\\n            backTrack(res , s + \\')\\' , n , left , right + 1);\\n\\n    }\\n    public List<String> generateParenthesis(int n) {\\n        List<String> ans = new ArrayList<>();\\n        backTrack(ans , \"\" , n , 0 , 0);\\n        return ans;\\n    }\\n}`"
                    },
                    {
                        "username": "Harshleen_Kaur",
                        "content": "What is the time complexity ?"
                    }
                ]
            },
            {
                "id": 1709243,
                "content": [
                    {
                        "username": "runtime_terror_04",
                        "content": "plzzz help not working this recursive code\\n\\nclass Solution {\\n    private:\\n    void gen(string ans,set<string>&st,int n){\\n   if(n==0){\\n    string k=\"\";\\n    st.insert(ans);\\n    return ;\\n\\n   }\\n   gen(ans+\"()\",st,n-1);\\n   gen(\"()\"+ans,st,n-1);\\n   gen(\"(\"+ans+\")\",st,n-1);\\n\\n}\\npublic:\\n    vector<string> generateParenthesis(int n) {\\n        set<string>st;\\n        vector<string>ss;\\n        string k=\"(()())\";\\n        gen(\"\",st,n);\\n        for(auto it:st){\\n            ss.push_back(it);\\n        }\\n        if(n==4){\\n            ss.push_back(k);\\n        }\\n       return ss;\\n\\n\\n    }\\n};"
                    },
                    {
                        "username": "smanjot444",
                        "content": "My code doesn\\'t seem to work\\nPlease HELP\\nclass Solution {\\npublic:\\n    vector<string> generateParenthesis(int n) {\\n        string ds;\\n        vector<string> res; \\n        generator(n, res, ds, 0, 0);\\n        return res;\\n    }\\n\\n    void generator(int n, vector<string> &res, string ds, int open, int close){\\n        if(close>open || open>n || close>n)\\n            return;\\n        if(open==close==n){\\n            res.push_back(ds);\\n            return;\\n        }\\n        generator(n, res, ds + \\'(\\', open + 1, close);\\n        generator(n, res, ds + \\')\\', open, close + 1);\\n    }\\n};"
                    },
                    {
                        "username": "wodxuming",
                        "content": "\\xB7\\xB7\\xB7\\nclass Solution {\\n\\npublic:\\n    vector<string> generateParenthesis(int n) {\\n        if (n == 0) return {};\\n\\n        vector<string> res;\\n\\n        string track;\\n\\n        backtrack(n, n, track, res);\\n        return res;       \\n    }\\n\\n    void backtrack(int left, int right, string& track, vector<string>& res) {\\n        if (right < left) return;\\n        if (left < 0 || right < 0) return;\\n        if (left == 0 && right == 0) {\\n            res.push_back(track);\\n            return;\\n        }\\n        \\n        track.push_back(\\'(\\'); \\n        backtrack(left - 1, right, track, res);\\n        track.pop_back(); \\n\\n        track.push_back(\\')\\'); \\n        backtrack(left, right - 1, track, res);\\n        track.pop_back(); \\n    }\\n};\\n\\xB7\\xB7\\xB7"
                    },
                    {
                        "username": "Bg21460",
                        "content": "Java DFS\\nhttps://leetcode.com/problems/generate-parentheses/submissions/856905486/"
                    },
                    {
                        "username": "wikyyuen",
                        "content": " `var resList []string\\n\\nfunc generateParenthesis(n int) []string {\\n\\tresList = []string{}\\n\\ttraverse(\"(\", 1, n-1, n)\\n\\treturn resList\\n}\\n\\nfunc traverse(s string, need int, left int, right int) {\\n\\tif right == 0 && left == 0 {\\n\\t\\tresList = append(resList, s)\\n\\t}\\n\\tif need > 0 && right > 0 {\\n\\t\\ttraverse(s+\")\", need-1, left, right-1)\\n\\t}\\n\\tif left > 0 {\\n\\t\\ttraverse(s+\"(\", need+1, left-1, right)\\n\\t}\\n}`"
                    },
                    {
                        "username": "sagarbalyan",
                        "content": "Why one works but other doesn\\'t?\\n\\nWhy does this not work?\\n\\n`        if(open<n) {\\n            open++;\\n            helper(result,open,close,str+\"(\",n);\\n        }`\\n\\nBut this does?\\n\\n`        if(open<n) {\\n            helper(result,open+1,close,str+\"(\",n);\\n        }`"
                    },
                    {
                        "username": "ayush1018",
                        "content": "Can someone help what is the error in this solution:\\nIt is showing\\nAddressSanitizer:DEADLYSIGNAL\\n\\n\\nclass Solution {\\npublic:\\n\\nvoid solve(int n, int open, int close, string currComb, vector<string>& ans)\\n{\\n    if(open == n && close == n)\\n    {\\n        ans.push_back(currComb);\\n        return;\\n    }\\n\\n    if(open<n)\\n    {\\n        currComb = currComb + \"(\";\\n        solve(n,open+1,close,currComb,ans);\\n    }\\n\\n    if(close<open)\\n    \\n        currComb = currComb + \")\";\\n        solve(n,open,close+1,currComb,ans);\\n    }\\n\\n    vector<string> generateParenthesis(int n) {\\n        int open=0, close=0;\\n        vector<string>ans;\\n        string currComb =\"\";\\n        solve(n,open,close,currComb,ans);\\n\\n        return ans;\\n    }\\n}; "
                    },
                    {
                        "username": "yashdeora",
                        "content": "Here is problem solution in Python, C++, JAVA and C Programming.\\n[https://www.gyangav.com/2022/11/leetcode-generate-parenthese-problem-solution.html](https://www.gyangav.com/2022/11/leetcode-generate-parenthese-problem-solution.html)"
                    },
                    {
                        "username": "Shubham_Awasthi__07",
                        "content": " `class Solution {\\n    public void backTrack(List<String> res ,String s, int n , int left , int right){\\n        if(s.length() == 2 * n){\\n            res.add(s);\\n            return ;\\n        }\\n        if (left < n)\\n            backTrack(res , s + \\'(\\' , n , left + 1 , right);\\n        if (right < left)\\n            backTrack(res , s + \\')\\' , n , left , right + 1);\\n\\n    }\\n    public List<String> generateParenthesis(int n) {\\n        List<String> ans = new ArrayList<>();\\n        backTrack(ans , \"\" , n , 0 , 0);\\n        return ans;\\n    }\\n}`"
                    },
                    {
                        "username": "Harshleen_Kaur",
                        "content": "What is the time complexity ?"
                    }
                ]
            },
            {
                "id": 1694707,
                "content": [
                    {
                        "username": "runtime_terror_04",
                        "content": "plzzz help not working this recursive code\\n\\nclass Solution {\\n    private:\\n    void gen(string ans,set<string>&st,int n){\\n   if(n==0){\\n    string k=\"\";\\n    st.insert(ans);\\n    return ;\\n\\n   }\\n   gen(ans+\"()\",st,n-1);\\n   gen(\"()\"+ans,st,n-1);\\n   gen(\"(\"+ans+\")\",st,n-1);\\n\\n}\\npublic:\\n    vector<string> generateParenthesis(int n) {\\n        set<string>st;\\n        vector<string>ss;\\n        string k=\"(()())\";\\n        gen(\"\",st,n);\\n        for(auto it:st){\\n            ss.push_back(it);\\n        }\\n        if(n==4){\\n            ss.push_back(k);\\n        }\\n       return ss;\\n\\n\\n    }\\n};"
                    },
                    {
                        "username": "smanjot444",
                        "content": "My code doesn\\'t seem to work\\nPlease HELP\\nclass Solution {\\npublic:\\n    vector<string> generateParenthesis(int n) {\\n        string ds;\\n        vector<string> res; \\n        generator(n, res, ds, 0, 0);\\n        return res;\\n    }\\n\\n    void generator(int n, vector<string> &res, string ds, int open, int close){\\n        if(close>open || open>n || close>n)\\n            return;\\n        if(open==close==n){\\n            res.push_back(ds);\\n            return;\\n        }\\n        generator(n, res, ds + \\'(\\', open + 1, close);\\n        generator(n, res, ds + \\')\\', open, close + 1);\\n    }\\n};"
                    },
                    {
                        "username": "wodxuming",
                        "content": "\\xB7\\xB7\\xB7\\nclass Solution {\\n\\npublic:\\n    vector<string> generateParenthesis(int n) {\\n        if (n == 0) return {};\\n\\n        vector<string> res;\\n\\n        string track;\\n\\n        backtrack(n, n, track, res);\\n        return res;       \\n    }\\n\\n    void backtrack(int left, int right, string& track, vector<string>& res) {\\n        if (right < left) return;\\n        if (left < 0 || right < 0) return;\\n        if (left == 0 && right == 0) {\\n            res.push_back(track);\\n            return;\\n        }\\n        \\n        track.push_back(\\'(\\'); \\n        backtrack(left - 1, right, track, res);\\n        track.pop_back(); \\n\\n        track.push_back(\\')\\'); \\n        backtrack(left, right - 1, track, res);\\n        track.pop_back(); \\n    }\\n};\\n\\xB7\\xB7\\xB7"
                    },
                    {
                        "username": "Bg21460",
                        "content": "Java DFS\\nhttps://leetcode.com/problems/generate-parentheses/submissions/856905486/"
                    },
                    {
                        "username": "wikyyuen",
                        "content": " `var resList []string\\n\\nfunc generateParenthesis(n int) []string {\\n\\tresList = []string{}\\n\\ttraverse(\"(\", 1, n-1, n)\\n\\treturn resList\\n}\\n\\nfunc traverse(s string, need int, left int, right int) {\\n\\tif right == 0 && left == 0 {\\n\\t\\tresList = append(resList, s)\\n\\t}\\n\\tif need > 0 && right > 0 {\\n\\t\\ttraverse(s+\")\", need-1, left, right-1)\\n\\t}\\n\\tif left > 0 {\\n\\t\\ttraverse(s+\"(\", need+1, left-1, right)\\n\\t}\\n}`"
                    },
                    {
                        "username": "sagarbalyan",
                        "content": "Why one works but other doesn\\'t?\\n\\nWhy does this not work?\\n\\n`        if(open<n) {\\n            open++;\\n            helper(result,open,close,str+\"(\",n);\\n        }`\\n\\nBut this does?\\n\\n`        if(open<n) {\\n            helper(result,open+1,close,str+\"(\",n);\\n        }`"
                    },
                    {
                        "username": "ayush1018",
                        "content": "Can someone help what is the error in this solution:\\nIt is showing\\nAddressSanitizer:DEADLYSIGNAL\\n\\n\\nclass Solution {\\npublic:\\n\\nvoid solve(int n, int open, int close, string currComb, vector<string>& ans)\\n{\\n    if(open == n && close == n)\\n    {\\n        ans.push_back(currComb);\\n        return;\\n    }\\n\\n    if(open<n)\\n    {\\n        currComb = currComb + \"(\";\\n        solve(n,open+1,close,currComb,ans);\\n    }\\n\\n    if(close<open)\\n    \\n        currComb = currComb + \")\";\\n        solve(n,open,close+1,currComb,ans);\\n    }\\n\\n    vector<string> generateParenthesis(int n) {\\n        int open=0, close=0;\\n        vector<string>ans;\\n        string currComb =\"\";\\n        solve(n,open,close,currComb,ans);\\n\\n        return ans;\\n    }\\n}; "
                    },
                    {
                        "username": "yashdeora",
                        "content": "Here is problem solution in Python, C++, JAVA and C Programming.\\n[https://www.gyangav.com/2022/11/leetcode-generate-parenthese-problem-solution.html](https://www.gyangav.com/2022/11/leetcode-generate-parenthese-problem-solution.html)"
                    },
                    {
                        "username": "Shubham_Awasthi__07",
                        "content": " `class Solution {\\n    public void backTrack(List<String> res ,String s, int n , int left , int right){\\n        if(s.length() == 2 * n){\\n            res.add(s);\\n            return ;\\n        }\\n        if (left < n)\\n            backTrack(res , s + \\'(\\' , n , left + 1 , right);\\n        if (right < left)\\n            backTrack(res , s + \\')\\' , n , left , right + 1);\\n\\n    }\\n    public List<String> generateParenthesis(int n) {\\n        List<String> ans = new ArrayList<>();\\n        backTrack(ans , \"\" , n , 0 , 0);\\n        return ans;\\n    }\\n}`"
                    },
                    {
                        "username": "Harshleen_Kaur",
                        "content": "What is the time complexity ?"
                    }
                ]
            },
            {
                "id": 1690739,
                "content": [
                    {
                        "username": "runtime_terror_04",
                        "content": "plzzz help not working this recursive code\\n\\nclass Solution {\\n    private:\\n    void gen(string ans,set<string>&st,int n){\\n   if(n==0){\\n    string k=\"\";\\n    st.insert(ans);\\n    return ;\\n\\n   }\\n   gen(ans+\"()\",st,n-1);\\n   gen(\"()\"+ans,st,n-1);\\n   gen(\"(\"+ans+\")\",st,n-1);\\n\\n}\\npublic:\\n    vector<string> generateParenthesis(int n) {\\n        set<string>st;\\n        vector<string>ss;\\n        string k=\"(()())\";\\n        gen(\"\",st,n);\\n        for(auto it:st){\\n            ss.push_back(it);\\n        }\\n        if(n==4){\\n            ss.push_back(k);\\n        }\\n       return ss;\\n\\n\\n    }\\n};"
                    },
                    {
                        "username": "smanjot444",
                        "content": "My code doesn\\'t seem to work\\nPlease HELP\\nclass Solution {\\npublic:\\n    vector<string> generateParenthesis(int n) {\\n        string ds;\\n        vector<string> res; \\n        generator(n, res, ds, 0, 0);\\n        return res;\\n    }\\n\\n    void generator(int n, vector<string> &res, string ds, int open, int close){\\n        if(close>open || open>n || close>n)\\n            return;\\n        if(open==close==n){\\n            res.push_back(ds);\\n            return;\\n        }\\n        generator(n, res, ds + \\'(\\', open + 1, close);\\n        generator(n, res, ds + \\')\\', open, close + 1);\\n    }\\n};"
                    },
                    {
                        "username": "wodxuming",
                        "content": "\\xB7\\xB7\\xB7\\nclass Solution {\\n\\npublic:\\n    vector<string> generateParenthesis(int n) {\\n        if (n == 0) return {};\\n\\n        vector<string> res;\\n\\n        string track;\\n\\n        backtrack(n, n, track, res);\\n        return res;       \\n    }\\n\\n    void backtrack(int left, int right, string& track, vector<string>& res) {\\n        if (right < left) return;\\n        if (left < 0 || right < 0) return;\\n        if (left == 0 && right == 0) {\\n            res.push_back(track);\\n            return;\\n        }\\n        \\n        track.push_back(\\'(\\'); \\n        backtrack(left - 1, right, track, res);\\n        track.pop_back(); \\n\\n        track.push_back(\\')\\'); \\n        backtrack(left, right - 1, track, res);\\n        track.pop_back(); \\n    }\\n};\\n\\xB7\\xB7\\xB7"
                    },
                    {
                        "username": "Bg21460",
                        "content": "Java DFS\\nhttps://leetcode.com/problems/generate-parentheses/submissions/856905486/"
                    },
                    {
                        "username": "wikyyuen",
                        "content": " `var resList []string\\n\\nfunc generateParenthesis(n int) []string {\\n\\tresList = []string{}\\n\\ttraverse(\"(\", 1, n-1, n)\\n\\treturn resList\\n}\\n\\nfunc traverse(s string, need int, left int, right int) {\\n\\tif right == 0 && left == 0 {\\n\\t\\tresList = append(resList, s)\\n\\t}\\n\\tif need > 0 && right > 0 {\\n\\t\\ttraverse(s+\")\", need-1, left, right-1)\\n\\t}\\n\\tif left > 0 {\\n\\t\\ttraverse(s+\"(\", need+1, left-1, right)\\n\\t}\\n}`"
                    },
                    {
                        "username": "sagarbalyan",
                        "content": "Why one works but other doesn\\'t?\\n\\nWhy does this not work?\\n\\n`        if(open<n) {\\n            open++;\\n            helper(result,open,close,str+\"(\",n);\\n        }`\\n\\nBut this does?\\n\\n`        if(open<n) {\\n            helper(result,open+1,close,str+\"(\",n);\\n        }`"
                    },
                    {
                        "username": "ayush1018",
                        "content": "Can someone help what is the error in this solution:\\nIt is showing\\nAddressSanitizer:DEADLYSIGNAL\\n\\n\\nclass Solution {\\npublic:\\n\\nvoid solve(int n, int open, int close, string currComb, vector<string>& ans)\\n{\\n    if(open == n && close == n)\\n    {\\n        ans.push_back(currComb);\\n        return;\\n    }\\n\\n    if(open<n)\\n    {\\n        currComb = currComb + \"(\";\\n        solve(n,open+1,close,currComb,ans);\\n    }\\n\\n    if(close<open)\\n    \\n        currComb = currComb + \")\";\\n        solve(n,open,close+1,currComb,ans);\\n    }\\n\\n    vector<string> generateParenthesis(int n) {\\n        int open=0, close=0;\\n        vector<string>ans;\\n        string currComb =\"\";\\n        solve(n,open,close,currComb,ans);\\n\\n        return ans;\\n    }\\n}; "
                    },
                    {
                        "username": "yashdeora",
                        "content": "Here is problem solution in Python, C++, JAVA and C Programming.\\n[https://www.gyangav.com/2022/11/leetcode-generate-parenthese-problem-solution.html](https://www.gyangav.com/2022/11/leetcode-generate-parenthese-problem-solution.html)"
                    },
                    {
                        "username": "Shubham_Awasthi__07",
                        "content": " `class Solution {\\n    public void backTrack(List<String> res ,String s, int n , int left , int right){\\n        if(s.length() == 2 * n){\\n            res.add(s);\\n            return ;\\n        }\\n        if (left < n)\\n            backTrack(res , s + \\'(\\' , n , left + 1 , right);\\n        if (right < left)\\n            backTrack(res , s + \\')\\' , n , left , right + 1);\\n\\n    }\\n    public List<String> generateParenthesis(int n) {\\n        List<String> ans = new ArrayList<>();\\n        backTrack(ans , \"\" , n , 0 , 0);\\n        return ans;\\n    }\\n}`"
                    },
                    {
                        "username": "Harshleen_Kaur",
                        "content": "What is the time complexity ?"
                    }
                ]
            },
            {
                "id": 1671277,
                "content": [
                    {
                        "username": "runtime_terror_04",
                        "content": "plzzz help not working this recursive code\\n\\nclass Solution {\\n    private:\\n    void gen(string ans,set<string>&st,int n){\\n   if(n==0){\\n    string k=\"\";\\n    st.insert(ans);\\n    return ;\\n\\n   }\\n   gen(ans+\"()\",st,n-1);\\n   gen(\"()\"+ans,st,n-1);\\n   gen(\"(\"+ans+\")\",st,n-1);\\n\\n}\\npublic:\\n    vector<string> generateParenthesis(int n) {\\n        set<string>st;\\n        vector<string>ss;\\n        string k=\"(()())\";\\n        gen(\"\",st,n);\\n        for(auto it:st){\\n            ss.push_back(it);\\n        }\\n        if(n==4){\\n            ss.push_back(k);\\n        }\\n       return ss;\\n\\n\\n    }\\n};"
                    },
                    {
                        "username": "smanjot444",
                        "content": "My code doesn\\'t seem to work\\nPlease HELP\\nclass Solution {\\npublic:\\n    vector<string> generateParenthesis(int n) {\\n        string ds;\\n        vector<string> res; \\n        generator(n, res, ds, 0, 0);\\n        return res;\\n    }\\n\\n    void generator(int n, vector<string> &res, string ds, int open, int close){\\n        if(close>open || open>n || close>n)\\n            return;\\n        if(open==close==n){\\n            res.push_back(ds);\\n            return;\\n        }\\n        generator(n, res, ds + \\'(\\', open + 1, close);\\n        generator(n, res, ds + \\')\\', open, close + 1);\\n    }\\n};"
                    },
                    {
                        "username": "wodxuming",
                        "content": "\\xB7\\xB7\\xB7\\nclass Solution {\\n\\npublic:\\n    vector<string> generateParenthesis(int n) {\\n        if (n == 0) return {};\\n\\n        vector<string> res;\\n\\n        string track;\\n\\n        backtrack(n, n, track, res);\\n        return res;       \\n    }\\n\\n    void backtrack(int left, int right, string& track, vector<string>& res) {\\n        if (right < left) return;\\n        if (left < 0 || right < 0) return;\\n        if (left == 0 && right == 0) {\\n            res.push_back(track);\\n            return;\\n        }\\n        \\n        track.push_back(\\'(\\'); \\n        backtrack(left - 1, right, track, res);\\n        track.pop_back(); \\n\\n        track.push_back(\\')\\'); \\n        backtrack(left, right - 1, track, res);\\n        track.pop_back(); \\n    }\\n};\\n\\xB7\\xB7\\xB7"
                    },
                    {
                        "username": "Bg21460",
                        "content": "Java DFS\\nhttps://leetcode.com/problems/generate-parentheses/submissions/856905486/"
                    },
                    {
                        "username": "wikyyuen",
                        "content": " `var resList []string\\n\\nfunc generateParenthesis(n int) []string {\\n\\tresList = []string{}\\n\\ttraverse(\"(\", 1, n-1, n)\\n\\treturn resList\\n}\\n\\nfunc traverse(s string, need int, left int, right int) {\\n\\tif right == 0 && left == 0 {\\n\\t\\tresList = append(resList, s)\\n\\t}\\n\\tif need > 0 && right > 0 {\\n\\t\\ttraverse(s+\")\", need-1, left, right-1)\\n\\t}\\n\\tif left > 0 {\\n\\t\\ttraverse(s+\"(\", need+1, left-1, right)\\n\\t}\\n}`"
                    },
                    {
                        "username": "sagarbalyan",
                        "content": "Why one works but other doesn\\'t?\\n\\nWhy does this not work?\\n\\n`        if(open<n) {\\n            open++;\\n            helper(result,open,close,str+\"(\",n);\\n        }`\\n\\nBut this does?\\n\\n`        if(open<n) {\\n            helper(result,open+1,close,str+\"(\",n);\\n        }`"
                    },
                    {
                        "username": "ayush1018",
                        "content": "Can someone help what is the error in this solution:\\nIt is showing\\nAddressSanitizer:DEADLYSIGNAL\\n\\n\\nclass Solution {\\npublic:\\n\\nvoid solve(int n, int open, int close, string currComb, vector<string>& ans)\\n{\\n    if(open == n && close == n)\\n    {\\n        ans.push_back(currComb);\\n        return;\\n    }\\n\\n    if(open<n)\\n    {\\n        currComb = currComb + \"(\";\\n        solve(n,open+1,close,currComb,ans);\\n    }\\n\\n    if(close<open)\\n    \\n        currComb = currComb + \")\";\\n        solve(n,open,close+1,currComb,ans);\\n    }\\n\\n    vector<string> generateParenthesis(int n) {\\n        int open=0, close=0;\\n        vector<string>ans;\\n        string currComb =\"\";\\n        solve(n,open,close,currComb,ans);\\n\\n        return ans;\\n    }\\n}; "
                    },
                    {
                        "username": "yashdeora",
                        "content": "Here is problem solution in Python, C++, JAVA and C Programming.\\n[https://www.gyangav.com/2022/11/leetcode-generate-parenthese-problem-solution.html](https://www.gyangav.com/2022/11/leetcode-generate-parenthese-problem-solution.html)"
                    },
                    {
                        "username": "Shubham_Awasthi__07",
                        "content": " `class Solution {\\n    public void backTrack(List<String> res ,String s, int n , int left , int right){\\n        if(s.length() == 2 * n){\\n            res.add(s);\\n            return ;\\n        }\\n        if (left < n)\\n            backTrack(res , s + \\'(\\' , n , left + 1 , right);\\n        if (right < left)\\n            backTrack(res , s + \\')\\' , n , left , right + 1);\\n\\n    }\\n    public List<String> generateParenthesis(int n) {\\n        List<String> ans = new ArrayList<>();\\n        backTrack(ans , \"\" , n , 0 , 0);\\n        return ans;\\n    }\\n}`"
                    },
                    {
                        "username": "Harshleen_Kaur",
                        "content": "What is the time complexity ?"
                    }
                ]
            },
            {
                "id": 1670975,
                "content": [
                    {
                        "username": "runtime_terror_04",
                        "content": "plzzz help not working this recursive code\\n\\nclass Solution {\\n    private:\\n    void gen(string ans,set<string>&st,int n){\\n   if(n==0){\\n    string k=\"\";\\n    st.insert(ans);\\n    return ;\\n\\n   }\\n   gen(ans+\"()\",st,n-1);\\n   gen(\"()\"+ans,st,n-1);\\n   gen(\"(\"+ans+\")\",st,n-1);\\n\\n}\\npublic:\\n    vector<string> generateParenthesis(int n) {\\n        set<string>st;\\n        vector<string>ss;\\n        string k=\"(()())\";\\n        gen(\"\",st,n);\\n        for(auto it:st){\\n            ss.push_back(it);\\n        }\\n        if(n==4){\\n            ss.push_back(k);\\n        }\\n       return ss;\\n\\n\\n    }\\n};"
                    },
                    {
                        "username": "smanjot444",
                        "content": "My code doesn\\'t seem to work\\nPlease HELP\\nclass Solution {\\npublic:\\n    vector<string> generateParenthesis(int n) {\\n        string ds;\\n        vector<string> res; \\n        generator(n, res, ds, 0, 0);\\n        return res;\\n    }\\n\\n    void generator(int n, vector<string> &res, string ds, int open, int close){\\n        if(close>open || open>n || close>n)\\n            return;\\n        if(open==close==n){\\n            res.push_back(ds);\\n            return;\\n        }\\n        generator(n, res, ds + \\'(\\', open + 1, close);\\n        generator(n, res, ds + \\')\\', open, close + 1);\\n    }\\n};"
                    },
                    {
                        "username": "wodxuming",
                        "content": "\\xB7\\xB7\\xB7\\nclass Solution {\\n\\npublic:\\n    vector<string> generateParenthesis(int n) {\\n        if (n == 0) return {};\\n\\n        vector<string> res;\\n\\n        string track;\\n\\n        backtrack(n, n, track, res);\\n        return res;       \\n    }\\n\\n    void backtrack(int left, int right, string& track, vector<string>& res) {\\n        if (right < left) return;\\n        if (left < 0 || right < 0) return;\\n        if (left == 0 && right == 0) {\\n            res.push_back(track);\\n            return;\\n        }\\n        \\n        track.push_back(\\'(\\'); \\n        backtrack(left - 1, right, track, res);\\n        track.pop_back(); \\n\\n        track.push_back(\\')\\'); \\n        backtrack(left, right - 1, track, res);\\n        track.pop_back(); \\n    }\\n};\\n\\xB7\\xB7\\xB7"
                    },
                    {
                        "username": "Bg21460",
                        "content": "Java DFS\\nhttps://leetcode.com/problems/generate-parentheses/submissions/856905486/"
                    },
                    {
                        "username": "wikyyuen",
                        "content": " `var resList []string\\n\\nfunc generateParenthesis(n int) []string {\\n\\tresList = []string{}\\n\\ttraverse(\"(\", 1, n-1, n)\\n\\treturn resList\\n}\\n\\nfunc traverse(s string, need int, left int, right int) {\\n\\tif right == 0 && left == 0 {\\n\\t\\tresList = append(resList, s)\\n\\t}\\n\\tif need > 0 && right > 0 {\\n\\t\\ttraverse(s+\")\", need-1, left, right-1)\\n\\t}\\n\\tif left > 0 {\\n\\t\\ttraverse(s+\"(\", need+1, left-1, right)\\n\\t}\\n}`"
                    },
                    {
                        "username": "sagarbalyan",
                        "content": "Why one works but other doesn\\'t?\\n\\nWhy does this not work?\\n\\n`        if(open<n) {\\n            open++;\\n            helper(result,open,close,str+\"(\",n);\\n        }`\\n\\nBut this does?\\n\\n`        if(open<n) {\\n            helper(result,open+1,close,str+\"(\",n);\\n        }`"
                    },
                    {
                        "username": "ayush1018",
                        "content": "Can someone help what is the error in this solution:\\nIt is showing\\nAddressSanitizer:DEADLYSIGNAL\\n\\n\\nclass Solution {\\npublic:\\n\\nvoid solve(int n, int open, int close, string currComb, vector<string>& ans)\\n{\\n    if(open == n && close == n)\\n    {\\n        ans.push_back(currComb);\\n        return;\\n    }\\n\\n    if(open<n)\\n    {\\n        currComb = currComb + \"(\";\\n        solve(n,open+1,close,currComb,ans);\\n    }\\n\\n    if(close<open)\\n    \\n        currComb = currComb + \")\";\\n        solve(n,open,close+1,currComb,ans);\\n    }\\n\\n    vector<string> generateParenthesis(int n) {\\n        int open=0, close=0;\\n        vector<string>ans;\\n        string currComb =\"\";\\n        solve(n,open,close,currComb,ans);\\n\\n        return ans;\\n    }\\n}; "
                    },
                    {
                        "username": "yashdeora",
                        "content": "Here is problem solution in Python, C++, JAVA and C Programming.\\n[https://www.gyangav.com/2022/11/leetcode-generate-parenthese-problem-solution.html](https://www.gyangav.com/2022/11/leetcode-generate-parenthese-problem-solution.html)"
                    },
                    {
                        "username": "Shubham_Awasthi__07",
                        "content": " `class Solution {\\n    public void backTrack(List<String> res ,String s, int n , int left , int right){\\n        if(s.length() == 2 * n){\\n            res.add(s);\\n            return ;\\n        }\\n        if (left < n)\\n            backTrack(res , s + \\'(\\' , n , left + 1 , right);\\n        if (right < left)\\n            backTrack(res , s + \\')\\' , n , left , right + 1);\\n\\n    }\\n    public List<String> generateParenthesis(int n) {\\n        List<String> ans = new ArrayList<>();\\n        backTrack(ans , \"\" , n , 0 , 0);\\n        return ans;\\n    }\\n}`"
                    },
                    {
                        "username": "Harshleen_Kaur",
                        "content": "What is the time complexity ?"
                    }
                ]
            },
            {
                "id": 1653635,
                "content": [
                    {
                        "username": "runtime_terror_04",
                        "content": "plzzz help not working this recursive code\\n\\nclass Solution {\\n    private:\\n    void gen(string ans,set<string>&st,int n){\\n   if(n==0){\\n    string k=\"\";\\n    st.insert(ans);\\n    return ;\\n\\n   }\\n   gen(ans+\"()\",st,n-1);\\n   gen(\"()\"+ans,st,n-1);\\n   gen(\"(\"+ans+\")\",st,n-1);\\n\\n}\\npublic:\\n    vector<string> generateParenthesis(int n) {\\n        set<string>st;\\n        vector<string>ss;\\n        string k=\"(()())\";\\n        gen(\"\",st,n);\\n        for(auto it:st){\\n            ss.push_back(it);\\n        }\\n        if(n==4){\\n            ss.push_back(k);\\n        }\\n       return ss;\\n\\n\\n    }\\n};"
                    },
                    {
                        "username": "smanjot444",
                        "content": "My code doesn\\'t seem to work\\nPlease HELP\\nclass Solution {\\npublic:\\n    vector<string> generateParenthesis(int n) {\\n        string ds;\\n        vector<string> res; \\n        generator(n, res, ds, 0, 0);\\n        return res;\\n    }\\n\\n    void generator(int n, vector<string> &res, string ds, int open, int close){\\n        if(close>open || open>n || close>n)\\n            return;\\n        if(open==close==n){\\n            res.push_back(ds);\\n            return;\\n        }\\n        generator(n, res, ds + \\'(\\', open + 1, close);\\n        generator(n, res, ds + \\')\\', open, close + 1);\\n    }\\n};"
                    },
                    {
                        "username": "wodxuming",
                        "content": "\\xB7\\xB7\\xB7\\nclass Solution {\\n\\npublic:\\n    vector<string> generateParenthesis(int n) {\\n        if (n == 0) return {};\\n\\n        vector<string> res;\\n\\n        string track;\\n\\n        backtrack(n, n, track, res);\\n        return res;       \\n    }\\n\\n    void backtrack(int left, int right, string& track, vector<string>& res) {\\n        if (right < left) return;\\n        if (left < 0 || right < 0) return;\\n        if (left == 0 && right == 0) {\\n            res.push_back(track);\\n            return;\\n        }\\n        \\n        track.push_back(\\'(\\'); \\n        backtrack(left - 1, right, track, res);\\n        track.pop_back(); \\n\\n        track.push_back(\\')\\'); \\n        backtrack(left, right - 1, track, res);\\n        track.pop_back(); \\n    }\\n};\\n\\xB7\\xB7\\xB7"
                    },
                    {
                        "username": "Bg21460",
                        "content": "Java DFS\\nhttps://leetcode.com/problems/generate-parentheses/submissions/856905486/"
                    },
                    {
                        "username": "wikyyuen",
                        "content": " `var resList []string\\n\\nfunc generateParenthesis(n int) []string {\\n\\tresList = []string{}\\n\\ttraverse(\"(\", 1, n-1, n)\\n\\treturn resList\\n}\\n\\nfunc traverse(s string, need int, left int, right int) {\\n\\tif right == 0 && left == 0 {\\n\\t\\tresList = append(resList, s)\\n\\t}\\n\\tif need > 0 && right > 0 {\\n\\t\\ttraverse(s+\")\", need-1, left, right-1)\\n\\t}\\n\\tif left > 0 {\\n\\t\\ttraverse(s+\"(\", need+1, left-1, right)\\n\\t}\\n}`"
                    },
                    {
                        "username": "sagarbalyan",
                        "content": "Why one works but other doesn\\'t?\\n\\nWhy does this not work?\\n\\n`        if(open<n) {\\n            open++;\\n            helper(result,open,close,str+\"(\",n);\\n        }`\\n\\nBut this does?\\n\\n`        if(open<n) {\\n            helper(result,open+1,close,str+\"(\",n);\\n        }`"
                    },
                    {
                        "username": "ayush1018",
                        "content": "Can someone help what is the error in this solution:\\nIt is showing\\nAddressSanitizer:DEADLYSIGNAL\\n\\n\\nclass Solution {\\npublic:\\n\\nvoid solve(int n, int open, int close, string currComb, vector<string>& ans)\\n{\\n    if(open == n && close == n)\\n    {\\n        ans.push_back(currComb);\\n        return;\\n    }\\n\\n    if(open<n)\\n    {\\n        currComb = currComb + \"(\";\\n        solve(n,open+1,close,currComb,ans);\\n    }\\n\\n    if(close<open)\\n    \\n        currComb = currComb + \")\";\\n        solve(n,open,close+1,currComb,ans);\\n    }\\n\\n    vector<string> generateParenthesis(int n) {\\n        int open=0, close=0;\\n        vector<string>ans;\\n        string currComb =\"\";\\n        solve(n,open,close,currComb,ans);\\n\\n        return ans;\\n    }\\n}; "
                    },
                    {
                        "username": "yashdeora",
                        "content": "Here is problem solution in Python, C++, JAVA and C Programming.\\n[https://www.gyangav.com/2022/11/leetcode-generate-parenthese-problem-solution.html](https://www.gyangav.com/2022/11/leetcode-generate-parenthese-problem-solution.html)"
                    },
                    {
                        "username": "Shubham_Awasthi__07",
                        "content": " `class Solution {\\n    public void backTrack(List<String> res ,String s, int n , int left , int right){\\n        if(s.length() == 2 * n){\\n            res.add(s);\\n            return ;\\n        }\\n        if (left < n)\\n            backTrack(res , s + \\'(\\' , n , left + 1 , right);\\n        if (right < left)\\n            backTrack(res , s + \\')\\' , n , left , right + 1);\\n\\n    }\\n    public List<String> generateParenthesis(int n) {\\n        List<String> ans = new ArrayList<>();\\n        backTrack(ans , \"\" , n , 0 , 0);\\n        return ans;\\n    }\\n}`"
                    },
                    {
                        "username": "Harshleen_Kaur",
                        "content": "What is the time complexity ?"
                    }
                ]
            }
        ]
    },
    {
        "title": "Best Time to Buy and Sell Stock II",
        "question_content": "<p>You are given an integer array <code>prices</code> where <code>prices[i]</code> is the price of a given stock on the <code>i<sup>th</sup></code> day.</p>\n\n<p>On each day, you may decide to buy and/or sell the stock. You can only hold <strong>at most one</strong> share of the stock at any time. However, you can buy it then immediately sell it on the <strong>same day</strong>.</p>\n\n<p>Find and return <em>the <strong>maximum</strong> profit you can achieve</em>.</p>\n\n<p>&nbsp;</p>\n<p><strong class=\"example\">Example 1:</strong></p>\n\n<pre>\n<strong>Input:</strong> prices = [7,1,5,3,6,4]\n<strong>Output:</strong> 7\n<strong>Explanation:</strong> Buy on day 2 (price = 1) and sell on day 3 (price = 5), profit = 5-1 = 4.\nThen buy on day 4 (price = 3) and sell on day 5 (price = 6), profit = 6-3 = 3.\nTotal profit is 4 + 3 = 7.\n</pre>\n\n<p><strong class=\"example\">Example 2:</strong></p>\n\n<pre>\n<strong>Input:</strong> prices = [1,2,3,4,5]\n<strong>Output:</strong> 4\n<strong>Explanation:</strong> Buy on day 1 (price = 1) and sell on day 5 (price = 5), profit = 5-1 = 4.\nTotal profit is 4.\n</pre>\n\n<p><strong class=\"example\">Example 3:</strong></p>\n\n<pre>\n<strong>Input:</strong> prices = [7,6,4,3,1]\n<strong>Output:</strong> 0\n<strong>Explanation:</strong> There is no way to make a positive profit, so we never buy the stock to achieve the maximum profit of 0.\n</pre>\n\n<p>&nbsp;</p>\n<p><strong>Constraints:</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= prices.length &lt;= 3 * 10<sup>4</sup></code></li>\n\t<li><code>0 &lt;= prices[i] &lt;= 10<sup>4</sup></code></li>\n</ul>\n",
        "solutions": [
            {
                "id": 208241,
                "title": "explanation-for-the-dummy-like-me",
                "content": "The profit is the sum of sub-profits. Each sub-profit is the difference between selling at day ```j```, and buying at day ```i``` (with ```j > i```). The range ```[i, j]``` should be chosen so that the sub-profit is **maximum**:\\n\\n```sub-profit = prices[j] - prices[i]```\\n\\nWe should choose ```j``` that ```prices[j]``` is as **big** as possible, and choose ```i``` that ```prices[i]``` is as **small** as possible (of course in their local range).\\n\\nLet\\'s say, we have a range ```[3, 2, 5]```, we will choose ```(2,5)``` instead of ```(3,5)```, because ```2<3```.\\nNow, if we add ```8``` into this range: ```[3, 2, 5, 8]```, we will choose ```(2, 8)``` instead of ```(2,5)``` because ```8>5```.\\n\\nFrom this observation, from day ```X```, the buying day will be the last **continuous** day that the price is smallest. Then, the selling day will be the last **continuous** day that the price is biggest.\\n\\nTake another range ```[3, 2, 5, 8, 1, 9]```, though ```1``` is the smallest, but ```2``` is chosen, because ```2``` is the smallest in a consecutive decreasing prices starting from ```3```.\\nSimilarly, ```9``` is the biggest, but ```8``` is chosen, because ```8``` is the biggest in a consecutive increasing prices starting from ```2``` (the buying price). \\nActually, the range ```[3, 2, 5, 8, 1, 9]``` will be splitted into 2 sub-ranges ```[3, 2, 5, 8]``` and ```[1, 9]```.\\n\\nWe come up with the following code:\\n```\\npublic int maxProfit(int[] prices) {\\n        int i = 0, buy, sell, profit = 0, N = prices.length - 1;\\n        while (i < N) {\\n            while (i < N && prices[i + 1] <= prices[i]) i++;\\n            buy = prices[i];\\n\\n            while (i < N && prices[i + 1] > prices[i]) i++;\\n            sell = prices[i];\\n\\n            profit += sell - buy;\\n        }\\n        return profit;\\n}\\n```\\n\\nThe time complexity is ```O(N)```, space complexity is ```O(5)```\\n\\n### **BONUS**: \\nWith this approach, we still can calculate on which buying days and selling days, we reach the max profit:\\n\\n```\\npublic Pair<List<Pair<Integer, Integer>>, Integer> buysAndSells(int[] prices) {\\n        int i = 0, iBuy, iSell, profit = 0, N = prices.length - 1;\\n        List<Pair<Integer, Integer>> buysAndSells = new ArrayList<Pair<Integer, Integer>>();\\n        while (i < N) {\\n            while (i < N && prices[i + 1] <= prices[i]) i++;\\n            iBuy = i;\\n\\n            while (i < N && prices[i + 1] > prices[i]) i++;\\n            iSell = i;\\n\\n            profit += prices[iSell] - prices[iBuy];\\n            Pair<Integer, Integer> bs = new Pair<Integer, Integer>(iBuy, iSell);\\n            buysAndSells.add(bs);\\n        }\\n        return new Pair<List<Pair<Integer, Integer>>, Integer>(buysAndSells, profit);\\n}\\n\\t\\npublic class Pair<T1, T2> {\\n    public T1 fst;\\n    public T2 snd;\\n    public Pair(T1 f, T2 s) {\\n        fst = f;\\n        snd = s;\\n    }\\n}\\n```\\n\\nP.S: After a long time, this problem came back to me again, and I forgot what I solved :) . I came up with [different approach](https://leetcode.com/problems/best-time-to-buy-and-sell-stock-ii/discuss/564729/Java-Simple-Code-DP)",
                "solutionTags": [],
                "code": "```j```\n```i```\n```j > i```\n```[i, j]```\n```sub-profit = prices[j] - prices[i]```\n```j```\n```prices[j]```\n```i```\n```prices[i]```\n```[3, 2, 5]```\n```(2,5)```\n```(3,5)```\n```2<3```\n```8```\n```[3, 2, 5, 8]```\n```(2, 8)```\n```(2,5)```\n```8>5```\n```X```\n```[3, 2, 5, 8, 1, 9]```\n```1```\n```2```\n```2```\n```3```\n```9```\n```8```\n```8```\n```2```\n```[3, 2, 5, 8, 1, 9]```\n```[3, 2, 5, 8]```\n```[1, 9]```\n```\\npublic int maxProfit(int[] prices) {\\n        int i = 0, buy, sell, profit = 0, N = prices.length - 1;\\n        while (i < N) {\\n            while (i < N && prices[i + 1] <= prices[i]) i++;\\n            buy = prices[i];\\n\\n            while (i < N && prices[i + 1] > prices[i]) i++;\\n            sell = prices[i];\\n\\n            profit += sell - buy;\\n        }\\n        return profit;\\n}\\n```\n```O(N)```\n```O(5)```\n```\\npublic Pair<List<Pair<Integer, Integer>>, Integer> buysAndSells(int[] prices) {\\n        int i = 0, iBuy, iSell, profit = 0, N = prices.length - 1;\\n        List<Pair<Integer, Integer>> buysAndSells = new ArrayList<Pair<Integer, Integer>>();\\n        while (i < N) {\\n            while (i < N && prices[i + 1] <= prices[i]) i++;\\n            iBuy = i;\\n\\n            while (i < N && prices[i + 1] > prices[i]) i++;\\n            iSell = i;\\n\\n            profit += prices[iSell] - prices[iBuy];\\n            Pair<Integer, Integer> bs = new Pair<Integer, Integer>(iBuy, iSell);\\n            buysAndSells.add(bs);\\n        }\\n        return new Pair<List<Pair<Integer, Integer>>, Integer>(buysAndSells, profit);\\n}\\n\\t\\npublic class Pair<T1, T2> {\\n    public T1 fst;\\n    public T2 snd;\\n    public Pair(T1 f, T2 s) {\\n        fst = f;\\n        snd = s;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 803206,
                "title": "python-js-java-go-c-o-n-by-dp-greedy-visualization",
                "content": "Method_#1\\nO(n) sol by DP + state machine\\n\\nDefine \"**Hold**\" as the state of **holding stock**. (\\u6301\\u6709\\u80A1\\u7968)\\nDefine \"**NotHold**\" as the state of **keep cash**. (\\u6301\\u6709\\u73FE\\u91D1)\\n\\nGeneral rule aka recursive relationship.\\n\\n```\\nDP[Hold] \\n= max(keep holding stock, or just buy stock & hold today)\\n= max( DP[Previous Hold], DP[previous NotHold] - stock price)\\n```\\n---\\n\\n```\\nDP[NotHold] \\n= max(keep cash, or just sell out stock today)\\n= max( DP[Previous NotHold], DP[previous Hold] + stock price)\\n```\\n\\n---\\n\\n**State machine diagram**:\\n\\n<img src=\"https://assets.leetcode.com/users/images/62d26ff8-bba1-497c-b429-702e002a05d1_1684081274.8362317.png\" width=\"1000\" height=\"600\">\\n\\n---\\n\\n**Implementation** by botoom-up DP + iteration:\\n<iframe src=\"https://leetcode.com/playground/J7fnkkAb/shared\" frameBorder=\"0\" width=\"1000\" height=\"600\"></iframe>\\n\\nTime Complexity: O(n), for single level for loop\\nSpace Complexity: O(1), for fixed size of temporary variables\\n\\n---\\n\\n**Implementation** with Top down DP + recursion \\n<iframe src=\"https://leetcode.com/playground/2zaLvs2H/shared\" frameBorder=\"0\" width=\"1000\" height=\"600\"></iframe>\\n\\nTime Complexity: O(n), for single level for loop\\nSpace Complexity: O(n), for 1D DP recursion call depth\\n\\n---\\n\\nMethod_#2\\nO(n) sol by Greedy\\n\\nShare another O(n) solution by price gain collection with **greedy** value taking concept.\\n\\nMax profit with [long position](https://en.wikipedia.org/wiki/Long_(finance)) ,\\'\\u505A\\u591A\\' in chinese, is met by **collecting all price gain** in the stock price sequence.\\n\\nTake care that holding **multiple position at the same time is NOT allowed** by [description](https://leetcode.com/problems/best-time-to-buy-and-sell-stock-ii/).\\n\\n---\\n\\n**Visualization**:\\n\\n![image](https://assets.leetcode.com/users/brianchiang_tw/image_1586173126.png)\\n\\n---\\n\\n**Implementation** based on container and summation function:\\n\\n\\n```python []\\nclass Solution:\\n    def maxProfit(self, prices: List[int]) -> int:\\n\\n        price_gain = []\\n        \\n        for idx in range( len(prices)-1 ):\\n            \\n            if prices[idx] < prices[idx+1]:\\n                \\n                price_gain.append( prices[idx+1]- prices[idx])\\n                \\n        return sum( price_gain )\\n```\\n```Java []\\nclass Solution {\\n    \\n    \\n    public int maxProfit(int[] prices) {\\n\\n        ArrayList<Integer> priceGain = new ArrayList<Integer>();\\n        \\n        for(int idx = 0 ; idx < prices.length-1; idx++){\\n            \\n            if( prices[idx] < prices[idx+1] ){\\n                priceGain.add( prices[idx+1]- prices[idx]);\\n            }\\n                \\n        }\\n        return priceGain.stream().mapToInt(n->n).sum();\\n        \\n    }\\n}\\n```\\n```Javascript []\\nconst accumulate = ( (prev, cur) => (prev + cur) );\\n\\nvar maxProfit = function(prices) {\\n    \\n    let profit = new Array();\\n    \\n    for( let i = 0 ; i < prices.length-1 ; i++ ){\\n        \\n        if( prices[i] < prices[i+1] ){\\n            profit.push(  prices[i+1] - prices[i] );\\n        }\\n    }\\n    return profit.reduce(accumulate, 0);\\n}\\n```\\n```Go []\\nfunc Accumulate(elements ...int) int {  \\n     sum := 0  \\n     for _, elem := range elements {  \\n          sum += elem  \\n     }  \\n     return sum  \\n} \\n\\n\\nfunc maxProfit(prices []int) int {\\n    \\n    profit := make([]int, 0)\\n    \\n    for i := 0 ; i < len(prices)-1 ; i++{\\n        \\n        if( prices[i] < prices[i+1] ){\\n            profit = append(profit, ( prices[i+1] - prices[i] ))\\n        }\\n    }\\n\\n    return Accumulate(profit...)\\n}\\n```\\n```C++ []\\nclass Solution {\\npublic:\\n    int maxProfit(vector<int>& prices) {\\n        \\n        vector<int> profit;\\n        \\n        for( size_t i = 0 ; i < prices.size()-1 ; i++ ){\\n            \\n            if( prices[i] < prices[i+1] ){\\n                profit.push_back( prices[i+1] - prices[i] );\\n            }\\n            \\n        }\\n        return accumulate( profit.begin(), profit.end(), 0);\\n    }\\n};\\n```\\n\\nTime Complexity: O(n), for single level for loop\\nSpace Complexity: O(n), for array storage sapce\\n\\n\\n---\\n\\n**Implementation** based on generator expression and sum( ... ):\\n\\n```\\nclass Solution:\\n    def maxProfit(self, prices: List[int]) -> int:\\n\\n        return sum( ( prices[idx+1]-prices[idx] ) for idx in range(len(prices)-1) if prices[idx] < prices[idx+1] )\\n```\\n\\n---\\n\\n**Implementation** based on O(1) aux space:\\n\\n```python []\\nclass Solution:\\n    def maxProfit(self, prices: List[int]) -> int:\\n        \\n        profit_from_price_gain = 0\\n        for idx in range( len(prices)-1 ):\\n            \\n            if prices[idx] < prices[idx+1]:\\n                profit_from_price_gain += ( prices[idx+1] - prices[idx])\\n                \\n        return profit_from_price_gain\\n```\\n```Javascript []\\nvar maxProfit = function(prices) {\\n    \\n    let profitFromPriceGain = 0;\\n    \\n    for( let i = 0 ; i < prices.length-1 ; i++ ){\\n        \\n        if( prices[i] < prices[i+1] ){\\n            profitFromPriceGain += (  prices[i+1] - prices[i] );\\n        }\\n    }\\n    \\n    return profitFromPriceGain;\\n}\\n```\\n```Java []\\nclass Solution {\\n    public int maxProfit(int[] prices) {      \\n        int profitFromPriceGain = 0;\\n        \\n        for( int i = 0 ; i < prices.length-1 ; i++ ){\\n            \\n            if( prices[i] < prices[i+1] ){\\n                profitFromPriceGain += ( prices[i+1] - prices[i] );\\n            }\\n        }\\n        \\n        return profitFromPriceGain;\\n    }\\n}\\n```\\n```Go []\\nfunc maxProfit(prices []int) int {\\n    \\n    profitFromPriceGain := 0\\n    \\n    for i := 0 ; i < len(prices)-1 ; i++{\\n        \\n        if( prices[i] < prices[i+1] ){\\n            profitFromPriceGain += ( prices[i+1] - prices[i] )\\n        }\\n    }\\n\\n    return profitFromPriceGain\\n}\\n```\\n```C++ []\\nclass Solution {\\npublic:\\n    int maxProfit(vector<int>& prices) {\\n        \\n        int profitFromPriceGain = 0;\\n        \\n        for( size_t i = 0 ; i < prices.size()-1 ; i++ ){\\n            \\n            if( prices[i] < prices[i+1] ){\\n                profitFromPriceGain += ( prices[i+1] - prices[i] );\\n            }\\n            \\n        }\\n        return profitFromPriceGain;\\n    }\\n};\\n```\\n\\nTime Complexity: O(n), for single level for loop\\nSpace Complexity: O(1), for fixed size of temporary variables\\n\\n\\n---\\n\\nRelated leetcode challenge:\\n\\n[Leetcode #121 Best Time to Buy and Sell Stock](https://leetcode.com/problems/best-time-to-buy-and-sell-stock)\\n\\n[Leetcode #123 Best Time to Buy and Sell Stock III ](https://leetcode.com/problems/best-time-to-buy-and-sell-stock-iii)\\n\\n[Leetcode #188 Best Time to Buy and Sell Stock IV  ](https://leetcode.com/problems/best-time-to-buy-and-sell-stock-iv)\\n\\n[Leetcode #309 Best Time to Buy and Sell Stock with Cooldown](https://leetcode.com/problems/best-time-to-buy-and-sell-stock-with-cooldown)\\n\\n[Leetcode #714 Best Time to Buy and Sell Stock with Transaction Fee  ](https://leetcode.com/problems/best-time-to-buy-and-sell-stock-with-transaction-fee) \\n\\n---\\n\\nReference:\\n\\n[1] [Python official docs about generator expression](https://www.python.org/dev/peps/pep-0289/)\\n\\n[2] [Python official docs about sum( ... )](https://docs.python.org/3/library/functions.html#sum)",
                "solutionTags": [
                    "Java",
                    "Python",
                    "Python3",
                    "C",
                    "JavaScript",
                    "Go",
                    "Dynamic Programming",
                    "Greedy"
                ],
                "code": "```\\nDP[Hold] \\n= max(keep holding stock, or just buy stock & hold today)\\n= max( DP[Previous Hold], DP[previous NotHold] - stock price)\\n```\n```\\nDP[NotHold] \\n= max(keep cash, or just sell out stock today)\\n= max( DP[Previous NotHold], DP[previous Hold] + stock price)\\n```\n```python []\\nclass Solution:\\n    def maxProfit(self, prices: List[int]) -> int:\\n\\n        price_gain = []\\n        \\n        for idx in range( len(prices)-1 ):\\n            \\n            if prices[idx] < prices[idx+1]:\\n                \\n                price_gain.append( prices[idx+1]- prices[idx])\\n                \\n        return sum( price_gain )\\n```\n```Java []\\nclass Solution {\\n    \\n    \\n    public int maxProfit(int[] prices) {\\n\\n        ArrayList<Integer> priceGain = new ArrayList<Integer>();\\n        \\n        for(int idx = 0 ; idx < prices.length-1; idx++){\\n            \\n            if( prices[idx] < prices[idx+1] ){\\n                priceGain.add( prices[idx+1]- prices[idx]);\\n            }\\n                \\n        }\\n        return priceGain.stream().mapToInt(n->n).sum();\\n        \\n    }\\n}\\n```\n```Javascript []\\nconst accumulate = ( (prev, cur) => (prev + cur) );\\n\\nvar maxProfit = function(prices) {\\n    \\n    let profit = new Array();\\n    \\n    for( let i = 0 ; i < prices.length-1 ; i++ ){\\n        \\n        if( prices[i] < prices[i+1] ){\\n            profit.push(  prices[i+1] - prices[i] );\\n        }\\n    }\\n    return profit.reduce(accumulate, 0);\\n}\\n```\n```Go []\\nfunc Accumulate(elements ...int) int {  \\n     sum := 0  \\n     for _, elem := range elements {  \\n          sum += elem  \\n     }  \\n     return sum  \\n} \\n\\n\\nfunc maxProfit(prices []int) int {\\n    \\n    profit := make([]int, 0)\\n    \\n    for i := 0 ; i < len(prices)-1 ; i++{\\n        \\n        if( prices[i] < prices[i+1] ){\\n            profit = append(profit, ( prices[i+1] - prices[i] ))\\n        }\\n    }\\n\\n    return Accumulate(profit...)\\n}\\n```\n```C++ []\\nclass Solution {\\npublic:\\n    int maxProfit(vector<int>& prices) {\\n        \\n        vector<int> profit;\\n        \\n        for( size_t i = 0 ; i < prices.size()-1 ; i++ ){\\n            \\n            if( prices[i] < prices[i+1] ){\\n                profit.push_back( prices[i+1] - prices[i] );\\n            }\\n            \\n        }\\n        return accumulate( profit.begin(), profit.end(), 0);\\n    }\\n};\\n```\n```\\nclass Solution:\\n    def maxProfit(self, prices: List[int]) -> int:\\n\\n        return sum( ( prices[idx+1]-prices[idx] ) for idx in range(len(prices)-1) if prices[idx] < prices[idx+1] )\\n```\n```python []\\nclass Solution:\\n    def maxProfit(self, prices: List[int]) -> int:\\n        \\n        profit_from_price_gain = 0\\n        for idx in range( len(prices)-1 ):\\n            \\n            if prices[idx] < prices[idx+1]:\\n                profit_from_price_gain += ( prices[idx+1] - prices[idx])\\n                \\n        return profit_from_price_gain\\n```\n```Javascript []\\nvar maxProfit = function(prices) {\\n    \\n    let profitFromPriceGain = 0;\\n    \\n    for( let i = 0 ; i < prices.length-1 ; i++ ){\\n        \\n        if( prices[i] < prices[i+1] ){\\n            profitFromPriceGain += (  prices[i+1] - prices[i] );\\n        }\\n    }\\n    \\n    return profitFromPriceGain;\\n}\\n```\n```Java []\\nclass Solution {\\n    public int maxProfit(int[] prices) {      \\n        int profitFromPriceGain = 0;\\n        \\n        for( int i = 0 ; i < prices.length-1 ; i++ ){\\n            \\n            if( prices[i] < prices[i+1] ){\\n                profitFromPriceGain += ( prices[i+1] - prices[i] );\\n            }\\n        }\\n        \\n        return profitFromPriceGain;\\n    }\\n}\\n```\n```Go []\\nfunc maxProfit(prices []int) int {\\n    \\n    profitFromPriceGain := 0\\n    \\n    for i := 0 ; i < len(prices)-1 ; i++{\\n        \\n        if( prices[i] < prices[i+1] ){\\n            profitFromPriceGain += ( prices[i+1] - prices[i] )\\n        }\\n    }\\n\\n    return profitFromPriceGain\\n}\\n```\n```C++ []\\nclass Solution {\\npublic:\\n    int maxProfit(vector<int>& prices) {\\n        \\n        int profitFromPriceGain = 0;\\n        \\n        for( size_t i = 0 ; i < prices.size()-1 ; i++ ){\\n            \\n            if( prices[i] < prices[i+1] ){\\n                profitFromPriceGain += ( prices[i+1] - prices[i] );\\n            }\\n            \\n        }\\n        return profitFromPriceGain;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 39420,
                "title": "three-lines-in-c-with-explanation",
                "content": "  First we post the code here.\\n\\n    int maxProfit(vector<int> &prices) {\\n        int ret = 0;\\n        for (size_t p = 1; p < prices.size(); ++p) \\n          ret += max(prices[p] - prices[p - 1], 0);    \\n        return ret;\\n    }\\n\\nSecond, suppose the first sequence is \"a <= b <= c <= d\", the profit is \"d - a = (b - a) + (c - b) + (d - c)\" without a doubt.  And suppose another one is \"a <= b >= b' <= c <= d\", the profit is not difficult to be figured out as \"(b - a) + (d - b')\". So you just target at monotone sequences.",
                "solutionTags": [],
                "code": "  First we post the code here.\\n\\n    int maxProfit(vector<int> &prices) {\\n        int ret = 0;\\n        for (size_t p = 1; p < prices.size(); ++p) \\n          ret += max(prices[p] - prices[p - 1], 0);    \\n        return ret;\\n    }\\n\\nSecond, suppose the first sequence is \"a <= b <= c <= d\", the profit is \"d - a = (b - a) + (c - b) + (d - c)\" without a doubt.  And suppose another one is \"a <= b >= b' <= c <= d\", the profit is not difficult to be figured out as \"(b - a) + (d - b')\". So you just target at monotone sequences.",
                "codeTag": "Unknown"
            },
            {
                "id": 1569081,
                "title": "java-simple-clean-dp-solutions-for-all-6-buy-sell-stock-questions-on-leetcode",
                "content": "*<ins>Note:</ins> Kindly upvote if you find this article helpful. Thanks for reading!*\\n\\n**\\u2714\\uFE0F Solution & Explanation for - [122. Best Time to Buy and Sell Stock II](https://leetcode.com/problems/best-time-to-buy-and-sell-stock-ii/)**\\n\\nThere are multiple ways to solve this question, but the most optimal one is this one-pass solution.\\n\\nIn this solution, we are trying to buy the stock if the previous day\\'s price is lower than the current price. We will buy the stock at the previous price and sell it today to make a profit. If we repeat this for all such days (where the current price is higher than the previous day\\'s price), we can add all the profits to get the total profit.\\n\\n**For example:**\\nIf Input is `prices = [7,1,5,3,6,4]`\\nLet us assume the day is represented by the array indexes.\\nThen on `day 2`, the `current price is 5` and on the `previous day (day 1)` the `price is 1`. This matches our criteria. `Profit will be 5-1 = 4`.\\nThen on `day 4`, the `current price is 6` and on the `previous day (day 3)` the `price is 3`. This matches our criteria. `Profit will be 6-3 = 3`.\\nNo other pair of consecuitive days match the our crtiteria `prices[i - 1] < prices[i]`\\n`Total Profit = 4 + 3 = 7`.\\n\\n**Time Complexity:** `O(N)` --> `N` is length of the input price array\\n**Space Complexity:** `O(1)` --> Constant Space\\n\\n```java\\nclass Solution {\\n    public int maxProfit(int[] prices) {\\n\\t\\t// We need prices for 2 days at least to find the profit.\\n        if (prices == null || prices.length <= 1) {\\n            return 0;\\n        }\\n\\n        int totalProfit = 0;\\n        for (int i = 1; i < prices.length; i++) {\\n            // Checking if we can profit with previous day\\'s price.\\n            // If yes, then we buy on previous day and sell on current day.\\n            // Add all such profits to get the total profit.\\n            if (prices[i - 1] < prices[i]) {\\n                totalProfit += prices[i] - prices[i - 1];\\n            }\\n        }\\n\\n        return totalProfit;\\n    }\\n}\\n```\\n\\n---\\n\\n**<ins>Solutions to other Buy and Sell Stock questions on Leetcode:</ins>**\\n\\n**\\u2714\\uFE0F Solution for - [121. Best Time to Buy and Sell Stock](https://leetcode.com/problems/best-time-to-buy-and-sell-stock/)**\\n\\n**Time Complexity:** `O(N)` --> `N` is length of the input price array\\n**Space Complexity:** `O(1)` --> Constant Space\\n\\n```java\\nclass Solution {\\n    public int maxProfit(int[] prices) {\\n        if (prices == null || prices.length <= 1) {\\n            return 0;\\n        }\\n\\n        int maxProfitHere = 0;\\n        int maxProfitSoFar = 0;\\n        for (int i = 1; i < prices.length; i++) {\\n            maxProfitHere = Math.max(0, maxProfitHere + prices[i] - prices[i - 1]);\\n            maxProfitSoFar = Math.max(maxProfitSoFar, maxProfitHere);\\n        }\\n\\n        return maxProfitSoFar;\\n    }\\n}\\n```\\n\\n---\\n\\n**\\u2714\\uFE0F Solution for - [123. Best Time to Buy and Sell Stock III](https://leetcode.com/problems/best-time-to-buy-and-sell-stock-iii/)**\\n\\n**Time Complexity:** `O(N)` --> `N` is length of the input price array\\n**Space Complexity:** `O(1)` --> Constant Space\\n\\n```java\\nclass Solution {\\n    public int maxProfit(int[] prices) {\\n        if (prices == null || prices.length <= 1) {\\n            return 0;\\n        }\\n\\n        int buy1 = -prices[0];\\n        int sell1 = buy1 + prices[0];\\n        int buy2 = sell1 - prices[0];\\n        int sell2 = buy2 + prices[0];\\n\\n        for (int i = 1; i < prices.length; i++) {\\n            // The maximum money left after buying 1st stock.\\n            buy1 = Math.max(buy1, -prices[i]);\\n\\n            // The maximum money left after selling 1st stock.\\n            sell1 = Math.max(sell1, buy1 + prices[i]);\\n\\n            // The maximum money left after buying 2nd stock.\\n            buy2 = Math.max(buy2, sell1 - prices[i]);\\n\\n            // The maximum money left after selling 2nd stock.\\n            sell2 = Math.max(sell2, buy2 + prices[i]);\\n        }\\n\\n        return Math.max(sell1, sell2);\\n    }\\n}\\n```\\n\\n---\\n\\n**\\u2714\\uFE0F Solution for - [188. Best Time to Buy and Sell Stock IV](https://leetcode.com/problems/best-time-to-buy-and-sell-stock-iv/)**\\n\\n**Time Complexity:** `O(N * k)`\\n**Space Complexity:** `O(N)` --> Space required for `dp1` and `dp2` arrays.\\nWhere: \\n--> `N` is length of the input price array. \\n--> `k` is the input number representing maximum number of transactions.\\n\\n```java\\nclass Solution {\\n    public int maxProfit(int k, int[] prices) {\\n        if (prices == null || prices.length <= 1 || k <= 0) {\\n            return 0;\\n        }\\n        if (k >= prices.length / 2) {\\n            return quickSolve(prices);\\n        }\\n\\n        int len = prices.length;\\n        int[] dp1 = new int[len];\\n        int[] dp2 = new int[len];\\n        for (int i = 0; i < k; i++) {\\n            int tempMax = -prices[0];\\n            for (int j = 1; j < len; j++) {\\n                dp2[j] = Math.max(dp2[j - 1], prices[j] + tempMax);\\n                tempMax = Math.max(tempMax, dp1[j] - prices[j]);\\n            }\\n            dp1 = Arrays.copyOf(dp2, len);\\n        }\\n\\n        return dp2[len - 1];\\n    }\\n\\n    private int quickSolve(int[] prices) {\\n        int totalProfit = 0;\\n        for (int i = 1; i < prices.length; i++) {\\n            if (prices[i - 1] < prices[i]) {\\n                totalProfit += prices[i] - prices[i - 1];\\n            }\\n        }\\n        return totalProfit;\\n    }\\n}\\n```\\n\\n---\\n\\n**\\u2714\\uFE0F Solution for - [309. Best Time to Buy and Sell Stock with Cooldown](https://leetcode.com/problems/best-time-to-buy-and-sell-stock-with-cooldown/)**\\n\\n**Time Complexity:** `O(N)` --> `N` is length of the input price array\\n**Space Complexity:** `O(1)` --> Constant Space\\n\\n```java\\nclass Solution {\\n    public int maxProfit(int[] prices) {\\n        if (prices == null || prices.length <= 1) {\\n            return 0;\\n        }\\n\\n        int buy = -prices[0];\\n        int sell = 0;\\n        int prevSell = 0;\\n\\n        for (int i = 1; i < prices.length; i++) {\\n            // buy[i] = Math.max(sell[i-2]-prices[i], buy[i-1])\\n            // sell[i-2]-prices[i] -> Buy after a 1 day cooldown\\n            // buy[i-1] -> cooldown\\n            buy = Math.max(prevSell - prices[i], buy);\\n\\n            // sell[i-1];\\n            prevSell = sell;\\n\\n            // sell[i] = Math.max(buy[i]+prices, sell[i-1])\\n            // buy[i]+prices -> sell the stock.\\n            // sell[i-1] -> cooldown\\n            sell = Math.max(buy + prices[i], sell);\\n        }\\n\\n        return sell;\\n    }\\n}\\n```\\n\\n---\\n\\n**\\u2714\\uFE0F Solution for - [714. Best Time to Buy and Sell Stock with Transaction Fee](https://leetcode.com/problems/best-time-to-buy-and-sell-stock-with-transaction-fee/)**\\n\\n**Time Complexity:** `O(N)` --> `N` is length of the input price array\\n**Space Complexity:** `O(1)` --> Constant Space\\n\\n```java\\nclass Solution {\\n    public int maxProfit(int[] prices, int fee) {\\n        if (prices == null || prices.length < 2) {\\n            return 0;\\n        }\\n\\n        int buy = -prices[0];\\n        int sell = 0;\\n\\n        for (int i = 1; i < prices.length; i++) {\\n\\n            // buy[i] = Math.max(buy[i - 1], sell[i - 1] - prices[i])\\n            buy = Math.max(sell - prices[i], buy);\\n\\n            // sell[i] = Math.max(sell[i - 1], buy[i] + prices[i])\\n            sell = Math.max(buy + prices[i] - fee, sell);\\n        }\\n\\n        return sell;\\n    }\\n}\\n```\\n\\n---\\n\\n**<ins>Time & Space complexity Cheatsheet for all Buy & Sell Stock questions on Leetcode:</ins>**\\n\\n| Buy & Sell Stock Question                                                                                                                        | Time Complexity | Space Complexity |\\n|--------------------------------------------------------------------------------------------------------------------------------------------------|:---------------:|:----------------:|\\n| [121. Best Time to Buy and Sell Stock](https://leetcode.com/problems/best-time-to-buy-and-sell-stock/)                                           |       O(N)      |       O(1)       |\\n| [122. Best Time to Buy and Sell Stock II](https://leetcode.com/problems/best-time-to-buy-and-sell-stock-ii/)                                     |       O(N)      |       O(1)       |\\n| [123. Best Time to Buy and Sell Stock III](https://leetcode.com/problems/best-time-to-buy-and-sell-stock-iii/)                                   |       O(N)      |       O(1)       |\\n| [188. Best Time to Buy and Sell Stock IV](https://leetcode.com/problems/best-time-to-buy-and-sell-stock-iv/)                                     |     O(N * k)    |       O(N)       |\\n| [309. Best Time to Buy and Sell Stock with Cooldown](https://leetcode.com/problems/best-time-to-buy-and-sell-stock-with-cooldown/)               |       O(N)      |       O(1)       |\\n| [714. Best Time to Buy and Sell Stock with Transaction Fee](https://leetcode.com/problems/best-time-to-buy-and-sell-stock-with-transaction-fee/) |       O(N)      |       O(1)       |\\n\\n---\\n",
                "solutionTags": [
                    "Java"
                ],
                "code": "```java\\nclass Solution {\\n    public int maxProfit(int[] prices) {\\n\\t\\t// We need prices for 2 days at least to find the profit.\\n        if (prices == null || prices.length <= 1) {\\n            return 0;\\n        }\\n\\n        int totalProfit = 0;\\n        for (int i = 1; i < prices.length; i++) {\\n            // Checking if we can profit with previous day\\'s price.\\n            // If yes, then we buy on previous day and sell on current day.\\n            // Add all such profits to get the total profit.\\n            if (prices[i - 1] < prices[i]) {\\n                totalProfit += prices[i] - prices[i - 1];\\n            }\\n        }\\n\\n        return totalProfit;\\n    }\\n}\\n```\n```java\\nclass Solution {\\n    public int maxProfit(int[] prices) {\\n        if (prices == null || prices.length <= 1) {\\n            return 0;\\n        }\\n\\n        int maxProfitHere = 0;\\n        int maxProfitSoFar = 0;\\n        for (int i = 1; i < prices.length; i++) {\\n            maxProfitHere = Math.max(0, maxProfitHere + prices[i] - prices[i - 1]);\\n            maxProfitSoFar = Math.max(maxProfitSoFar, maxProfitHere);\\n        }\\n\\n        return maxProfitSoFar;\\n    }\\n}\\n```\n```java\\nclass Solution {\\n    public int maxProfit(int[] prices) {\\n        if (prices == null || prices.length <= 1) {\\n            return 0;\\n        }\\n\\n        int buy1 = -prices[0];\\n        int sell1 = buy1 + prices[0];\\n        int buy2 = sell1 - prices[0];\\n        int sell2 = buy2 + prices[0];\\n\\n        for (int i = 1; i < prices.length; i++) {\\n            // The maximum money left after buying 1st stock.\\n            buy1 = Math.max(buy1, -prices[i]);\\n\\n            // The maximum money left after selling 1st stock.\\n            sell1 = Math.max(sell1, buy1 + prices[i]);\\n\\n            // The maximum money left after buying 2nd stock.\\n            buy2 = Math.max(buy2, sell1 - prices[i]);\\n\\n            // The maximum money left after selling 2nd stock.\\n            sell2 = Math.max(sell2, buy2 + prices[i]);\\n        }\\n\\n        return Math.max(sell1, sell2);\\n    }\\n}\\n```\n```java\\nclass Solution {\\n    public int maxProfit(int k, int[] prices) {\\n        if (prices == null || prices.length <= 1 || k <= 0) {\\n            return 0;\\n        }\\n        if (k >= prices.length / 2) {\\n            return quickSolve(prices);\\n        }\\n\\n        int len = prices.length;\\n        int[] dp1 = new int[len];\\n        int[] dp2 = new int[len];\\n        for (int i = 0; i < k; i++) {\\n            int tempMax = -prices[0];\\n            for (int j = 1; j < len; j++) {\\n                dp2[j] = Math.max(dp2[j - 1], prices[j] + tempMax);\\n                tempMax = Math.max(tempMax, dp1[j] - prices[j]);\\n            }\\n            dp1 = Arrays.copyOf(dp2, len);\\n        }\\n\\n        return dp2[len - 1];\\n    }\\n\\n    private int quickSolve(int[] prices) {\\n        int totalProfit = 0;\\n        for (int i = 1; i < prices.length; i++) {\\n            if (prices[i - 1] < prices[i]) {\\n                totalProfit += prices[i] - prices[i - 1];\\n            }\\n        }\\n        return totalProfit;\\n    }\\n}\\n```\n```java\\nclass Solution {\\n    public int maxProfit(int[] prices) {\\n        if (prices == null || prices.length <= 1) {\\n            return 0;\\n        }\\n\\n        int buy = -prices[0];\\n        int sell = 0;\\n        int prevSell = 0;\\n\\n        for (int i = 1; i < prices.length; i++) {\\n            // buy[i] = Math.max(sell[i-2]-prices[i], buy[i-1])\\n            // sell[i-2]-prices[i] -> Buy after a 1 day cooldown\\n            // buy[i-1] -> cooldown\\n            buy = Math.max(prevSell - prices[i], buy);\\n\\n            // sell[i-1];\\n            prevSell = sell;\\n\\n            // sell[i] = Math.max(buy[i]+prices, sell[i-1])\\n            // buy[i]+prices -> sell the stock.\\n            // sell[i-1] -> cooldown\\n            sell = Math.max(buy + prices[i], sell);\\n        }\\n\\n        return sell;\\n    }\\n}\\n```\n```java\\nclass Solution {\\n    public int maxProfit(int[] prices, int fee) {\\n        if (prices == null || prices.length < 2) {\\n            return 0;\\n        }\\n\\n        int buy = -prices[0];\\n        int sell = 0;\\n\\n        for (int i = 1; i < prices.length; i++) {\\n\\n            // buy[i] = Math.max(buy[i - 1], sell[i - 1] - prices[i])\\n            buy = Math.max(sell - prices[i], buy);\\n\\n            // sell[i] = Math.max(sell[i - 1], buy[i] + prices[i])\\n            sell = Math.max(buy + prices[i] - fee, sell);\\n        }\\n\\n        return sell;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 564729,
                "title": "java-simple-code-dp",
                "content": "The action we can do on `ith` day is either `buy` (if last action is sell), or `sell` (if last action is buy), or do nothing (not buy, not sell).\\n\\n```\\npublic int maxProfit(int[] A) {                        \\n        int n = A.length, lastBuy = -A[0], lastSold = 0;\\n        if (n == 0) return 0;\\n                                \\n        for (int i = 1; i < n; i++) {\\n            int curBuy = Math.max(lastBuy, lastSold - A[i]);\\n            int curSold = Math.max(lastSold, lastBuy + A[i]);\\n            lastBuy = curBuy;\\n            lastSold = curSold;\\n        }\\n        \\n        return lastSold;\\n    }\\n```",
                "solutionTags": [],
                "code": "```\\npublic int maxProfit(int[] A) {                        \\n        int n = A.length, lastBuy = -A[0], lastSold = 0;\\n        if (n == 0) return 0;\\n                                \\n        for (int i = 1; i < n; i++) {\\n            int curBuy = Math.max(lastBuy, lastSold - A[i]);\\n            int curSold = Math.max(lastSold, lastBuy + A[i]);\\n            lastBuy = curBuy;\\n            lastSold = curSold;\\n        }\\n        \\n        return lastSold;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1569093,
                "title": "c-python-clean-and-simple-solution-w-detailed-explanation-images-buy-low-sell-high",
                "content": "\\u2714\\uFE0F ***Solution - I (Buy Low, Sell High)***\\n\\nThis solution just uses simple approach of trading - **buy low, sell high**. Think about how you could maximize your profits if you knew prices of stocks on each day with only 1 stock allowed at hand? You would of-course buy on the day where price was **lowest in the local range** and sell when it was **highest in local range** and perform as many trades as you can since you are allowed only 1 stock.\\n\\nIt\\'s always better to consider every low & highs and trade between them and not skip any low/highs or not just consider the global minimum and maximum because it is always equal or more profitable to buy and sell at every local *valleys* (lowest) and *peaks* (highest) and trade multiple times in between if there are multiple valleys and peaks. This is best illustrated by LeetCode\\'s official solution diagram (allow me to borrow it for educational purpose \\uD83D\\uDE05) - \\n\\n<table>\\n<tr>\\n<td><img  src=\"https://leetcode.com/media/original_images/122_maxprofit_1.PNG\" width=800 /></td>\\n<td>\\nWe can see that we have choices to either perform two trades -</br></br>\\n&emsp;&emsp;&emsp;1. Buy at valley<sub>2</sub>, sell at peak<sub>3</sub> and again buy at valley<sub>4</sub>, sell at peak<sub>5</sub>. </br>&emsp;&emsp;&emsp;&emsp;<b>Profit = A+B</b></br>\\n&emsp;&emsp;&emsp;2. Buy at valley<sub>2</sub>, sell at peak<sub>5</sub>. <b>Profit = C</b></br></br>\\nIn any case, we have <b>A + B > C</b> because if A+B == C, then valley<sub>4</sub> can\\'t exist.\\n</td>\\n</tr>\\n<tr>\\n<td><img src=\"https://leetcode.com/media/original_images/122_maxprofit_2.PNG\" width=800 /></td>\\n<td>\\nWe can see that we will buy at valley<sub>3</sub> and sell at peak<sub>6</sub>. </br></br>As you will see later on in solution, this is simulated as <b>buy<sub>3</sub>, sell <sub>4</sub>+buy<sub>4</sub>, sell <sub>5</sub>+buy<sub>5</sub>, sell <sub>6</sub></b> which is nothing but equivalent to <b>buy<sub>3</sub> and sell<sub>6</sub></b>\\n</td>\\n</tr>\\n</table>\\n\\nFrom above, we can see that we need to perform multiple trades buying at valley, selling at peak every time possible. Whenever we find that **today\\'s price is higher than yesterday**, we know we should have **bought yesterday and sold today**. It can be implemented in a naive way as below - \\n\\n```cpp\\nclass Solution {\\npublic:\\n    int maxProfit(vector<int>& P) {\\n        int n = size(P), i = 1, profit = 0, buy, sell;\\n        while(i < n) {\\n            // find lowest price to buy - local valley \\uD83D\\uDCC9\\n            for(buy = P[i-1]; i < n && P[i] < buy; i++) \\n                buy = P[i];    \\n            if(i >= n) break;      // break if no more days remaining\\n            // find highest price to sell - local peak  \\uD83D\\uDCC8 \\n            for(sell = P[i]; i < n && sell <= P[i]; i++)\\n                sell = P[i];    \\n            profit += sell - buy; // keep adding the \\uD83D\\uDCB8\\n            i++;\\n        }\\n        return profit;\\n    }\\n};\\n```\\n\\nThe above code can be simplified by considering every day when price is greater than yesterday and trading that day (buying at yesterday\\'s low price and selling at today\\'s high price).\\n\\nThe first case of finding local valley will be handled in this case as well since we only engage in trade when yesterday\\'s price was lower than today meaning we bought at local valley.\\n\\nBut what if there are consecutive days where we find today was higher price than yesterday? That cases would be handled as well because it will be simulated as buy yesterday and sell today for multiple times and that eventually sums out to buying at every valley and selling at peak as we saw in the diagram-2 above.\\n\\nThe above also means that our answer remains same with or without this allowed - **`However, you can buy it then immediately sell it on the same day.`**\\n\\n**C++**\\n```cpp\\nclass Solution {\\npublic:\\n    int maxProfit(vector<int>& P) {\\n        int profit = 0;\\n        for(int i = 1; i < size(P); i++)\\n            if(P[i] > P[i-1])              // yesterday was valley, today is peak\\n                profit += P[i] - P[i-1];   // buy yesterday, sell today\\n        return profit;\\n    }\\n};\\n```\\n\\n**Python**\\n\\n```python\\nclass Solution:\\n    def maxProfit(self, P: List[int]) -> int:\\n        return sum(P[i]-P[i-1] if P[i] > P[i-1] else 0 for i in range(1, len(P)))\\n```\\n\\n***Time Complexity :*** **<code>O(N)</code>** where `N` is the size of `P` array.\\n***Space Complexity :*** **`O(1)`**\\n\\n---\\n---\\n\\n\\uD83D\\uDCBBIf there are any suggestions / questions / mistakes in my post, comment below \\uD83D\\uDC47 \\n\\n---\\n---\\n",
                "solutionTags": [],
                "code": "```cpp\\nclass Solution {\\npublic:\\n    int maxProfit(vector<int>& P) {\\n        int n = size(P), i = 1, profit = 0, buy, sell;\\n        while(i < n) {\\n            // find lowest price to buy - local valley \\uD83D\\uDCC9\\n            for(buy = P[i-1]; i < n && P[i] < buy; i++) \\n                buy = P[i];    \\n            if(i >= n) break;      // break if no more days remaining\\n            // find highest price to sell - local peak  \\uD83D\\uDCC8 \\n            for(sell = P[i]; i < n && sell <= P[i]; i++)\\n                sell = P[i];    \\n            profit += sell - buy; // keep adding the \\uD83D\\uDCB8\\n            i++;\\n        }\\n        return profit;\\n    }\\n};\\n```\n```cpp\\nclass Solution {\\npublic:\\n    int maxProfit(vector<int>& P) {\\n        int profit = 0;\\n        for(int i = 1; i < size(P); i++)\\n            if(P[i] > P[i-1])              // yesterday was valley, today is peak\\n                profit += P[i] - P[i-1];   // buy yesterday, sell today\\n        return profit;\\n    }\\n};\\n```\n```python\\nclass Solution:\\n    def maxProfit(self, P: List[int]) -> int:\\n        return sum(P[i]-P[i-1] if P[i] > P[i-1] else 0 for i in range(1, len(P)))\\n```",
                "codeTag": "Java"
            },
            {
                "id": 39531,
                "title": "java-o-n-solution-if-we-re-not-greedy",
                "content": "Hi guys!\\n\\nThe greedy pair-wise approach mentioned in other posts is great for this problem indeed, but if we're not allowed to buy and sell stocks within the same day it can't be applied (logically, of course; the answer will be the same). Actually, the straight-forward way of finding next local minimum and next local maximum is not much more complicated, so, just for the sake of having an alternative I share the code in Java for such case.\\n\\n    public int maxProfit(int[] prices) {\\n        int profit = 0, i = 0;\\n        while (i < prices.length) {\\n            // find next local minimum\\n            while (i < prices.length-1 && prices[i+1] <= prices[i]) i++;\\n            int min = prices[i++]; // need increment to avoid infinite loop for \"[1]\"\\n            // find next local maximum\\n            while (i < prices.length-1 && prices[i+1] >= prices[i]) i++;\\n            profit += i < prices.length ? prices[i++] - min : 0;\\n        }\\n        return profit;\\n    }\\n\\nHappy coding!",
                "solutionTags": [
                    "Java"
                ],
                "code": "Hi guys!\\n\\nThe greedy pair-wise approach mentioned in other posts is great for this problem indeed, but if we're not allowed to buy and sell stocks within the same day it can't be applied (logically, of course; the answer will be the same). Actually, the straight-forward way of finding next local minimum and next local maximum is not much more complicated, so, just for the sake of having an alternative I share the code in Java for such case.\\n\\n    public int maxProfit(int[] prices) {\\n        int profit = 0, i = 0;\\n        while (i < prices.length) {\\n            // find next local minimum\\n            while (i < prices.length-1 && prices[i+1] <= prices[i]) i++;\\n            int min = prices[i++]; // need increment to avoid infinite loop for \"[1]\"\\n            // find next local maximum\\n            while (i < prices.length-1 && prices[i+1] >= prices[i]) i++;\\n            profit += i < prices.length ? prices[i++] - min : 0;\\n        }\\n        return profit;\\n    }\\n\\nHappy coding!",
                "codeTag": "Unknown"
            },
            {
                "id": 900051,
                "title": "fully-explained-all-buy-and-sell-problems-c-recursive-memoization-minor-difference",
                "content": "***Resources: https://github.com/AJAYKR00KJ/LeetCode_Solution***\\n\\n**To solve this problem just start from basic similar problem. After solving these peoblems we wil reach at final this problem.**\\n\\n``` I have discussed all the problems by recursive and memoization approach , so that everyone can figure out minor differences between the questions :)```\\n\\n---------------------------------------------------------------------------------------------------------------\\n---------------------------------------------------------------------------------------------------------------\\n**Recursive Solution and memoize solutions:**\\n\\n1. https://leetcode.com/problems/best-time-to-buy-and-sell-stock/\\n\\n   **You can do at most one transaction**\\n\\n\\n```\\nclass Solution {\\npublic:\\n    int find(vector<int> &prices, int i,int k,bool buy,vector<vector<int>> &v)\\n    {\\n        //if we have no stock or we have no chance of transaction(k=0)\\n        if(i>=prices.size()||k<=0) return 0;\\n        if(v[i][buy]!=-1) return v[i][buy];\\n        \\n        if(buy)  //if we are buying then next time we will sell else next time we will buy\\n        {        //-prices[i], because bought stock of prices[i], expend money\\n            \\n           return v[i][buy]=max(-prices[i]+find(prices,i+1,k,!buy,v),find(prices,i+1,k,buy,v)); \\n        }\\n        else    //it\\'s time to sell , now decrease k, we have done 1 transaction\\n        {       //+prices[i], because we now gain (i.e) sell our stock at rate of prices[i]\\n           return v[i][buy]=max( prices[i]+find(prices,i+1,k-1,!buy,v),find(prices,i+1,k,buy,v)); \\n        }\\n    }\\n    int maxProfit(vector<int>& prices) {\\n        \\n        int n=prices.size(); \\n        vector<vector<int>> v(n,vector<int> (2,-1));\\n        //passing here buy=1 because we will first buy then sell\\n        //we can do atmost k=1 transaction\\n        return find(prices,0,1,1,v);\\n    }\\n};\\n```\\n\\n---------------------------------------------------------------------------------------------------------------\\n---------------------------------------------------------------------------------------------------------------\\n2. https://leetcode.com/problems/best-time-to-buy-and-sell-stock-ii/\\n\\n    **You can do as many transactions as you like**\\n\\n```\\nclass Solution {\\npublic:\\nint find(int ind,vector<int> &v,bool buy,vector<vector<int>> &memo)\\n{    \\n    if(ind>=v.size()) return 0;\\n    if(memo[ind][buy]!=-1) return memo[ind][buy];\\n    \\n    if(buy) //if we are buying then next time we will sell else next time we will buy\\n    {      //-prices[i], because bought stock of prices[i], expend money, !buy because next time sell\\n        \\n       return memo[ind][buy]=max(-v[ind]+find(ind+1,v,!buy,memo),find(ind+1,v,buy,memo));  \\n    }\\n    else   //it\\'s time to sell \\n    {      //+prices[i], because we now gain (i.e) sell our stock at rate of prices[i]\\n        \\n       return memo[ind][buy]=max(v[ind]+find(ind+1,v,!buy,memo),find(ind+1,v,buy,memo));  \\n    }\\n     \\n}\\n    int maxProfit(vector<int>& prices) {\\n        \\n        int n=prices.size();\\n        if(n<2) return 0;\\n        vector<vector<int>> v(n+1,vector<int>(2,-1));\\n        //passing here buy=1 because we will first buy then sell \\n        return find(0,prices,1,v); \\n    }\\n};\\n```\\n \\n---------------------------------------------------------------------------------------------------------------\\n---------------------------------------------------------------------------------------------------------------\\n 3.  https://leetcode.com/problems/best-time-to-buy-and-sell-stock-iii/\\n\\n      **You may complete at most two transactions.**\\n\\n```\\nclass Solution {\\npublic:\\n    int find(vector<int> &prices,int ind,bool buy,int c,vector<vector<vector<int>>> &memo)\\n    {   \\n        //if buy =1 means we have to buy now\\n        //else we have to sell now\\n        if(ind>=prices.size()||c>=2) return 0; //counter\\n        if(memo[ind][buy][c]!=-1) return memo[ind][buy][c];\\n        if(buy) //now we can either buy prices[i] or we can skip it and try next to buy\\n        {\\n            return memo[ind][buy][c]=max(-prices[ind]+find(prices,ind+1,!buy,c,memo),find(prices,ind+1,buy,c,memo));\\n        }\\n        else  //now we can either sell prices[i] or we can skip it and try next to sell\\n        {\\n            return memo[ind][buy][c]=max(prices[ind]+find(prices,ind+1,!buy,c+1,memo),find(prices,ind+1,buy,c,memo));\\n        }\\n        \\n    }\\n    int maxProfit(vector<int>& prices) {\\n        //here we can do maximum two transaction\\n        //Use 3-D vector because here three states i,k,buy/sell\\n        vector<vector<vector<int>>> memo(prices.size(),vector<vector<int>>(2,vector<int>(2,-1)));\\n          \\n       return find(prices,0,1,0,memo); \\n    }\\n};\\n \\n```\\n\\n---------------------------------------------------------------------------------------------------------------\\n---------------------------------------------------------------------------------------------------------------\\n4. https://leetcode.com/problems/best-time-to-buy-and-sell-stock-iv/\\n\\n     **You may complete at most k transactions.**\\n\\n```\\nclass Solution {\\npublic:\\n    int find(vector<int> &prices,int ind,bool buy,int c,int k,vector<vector<vector<int>>> &memo)\\n    {   //if buy =1 means we have to buy now\\n        //else we have to sell now\\n        if(ind>=prices.size()||c>=k) return 0; //counter\\n        \\n        else if(memo[ind][buy][c]!=-1) return memo[ind][buy][c];\\n         \\n        if(buy) //now we can either buy prices[i] or we can skip it and try next to buy\\n        {\\n        return memo[ind][buy][c]=max(-prices[ind]+find(prices,ind+1,!buy,c,k,memo),find(prices,ind+1,buy,c,k,memo));\\n        }\\n        else  //now we can either sell prices[i] or we can skip it and try next to sell\\n        {\\n        return memo[ind][buy][c]=max(prices[ind]+find(prices,ind+1,!buy,c+1,k,memo),find(prices,ind+1,buy,c,k,memo));\\n        }\\n        \\n    }\\n    int maxProfit(int k, vector<int>& prices) {\\n        \\n        //edge case we are not able to pick 2k points from n points, which means \\n        //we will not reach the limit no matter how we try. \\n        //if the price of day i arise, buy the stock in i-1th day and sell it at ith day.\\n        if (2 * k > prices.size()) {\\n            int res = 0;\\n            for (int i = 1; i < prices.size(); i++) {\\n                res += max(0, prices[i] - prices[i - 1]);\\n            }\\n            return res;\\n        }\\n        \\n         //here we can do maximum k transaction\\n        vector<vector<vector<int>>> memo(prices.size()+1,vector<vector<int>>(2,vector<int>(k+1,-1)));\\n        return find(prices,0,1,0,k,memo); \\n    }\\n};\\n```\\n\\n---------------------------------------------------------------------------------------------------------------\\n---------------------------------------------------------------------------------------------------------------\\n\\n**Hit \\uD83D\\uDC4D if you like it :)**",
                "solutionTags": [
                    "C++",
                    "C",
                    "Dynamic Programming",
                    "Recursion",
                    "Memoization"
                ],
                "code": "``` I have discussed all the problems by recursive and memoization approach , so that everyone can figure out minor differences between the questions :)```\n```\\nclass Solution {\\npublic:\\n    int find(vector<int> &prices, int i,int k,bool buy,vector<vector<int>> &v)\\n    {\\n        //if we have no stock or we have no chance of transaction(k=0)\\n        if(i>=prices.size()||k<=0) return 0;\\n        if(v[i][buy]!=-1) return v[i][buy];\\n        \\n        if(buy)  //if we are buying then next time we will sell else next time we will buy\\n        {        //-prices[i], because bought stock of prices[i], expend money\\n            \\n           return v[i][buy]=max(-prices[i]+find(prices,i+1,k,!buy,v),find(prices,i+1,k,buy,v)); \\n        }\\n        else    //it\\'s time to sell , now decrease k, we have done 1 transaction\\n        {       //+prices[i], because we now gain (i.e) sell our stock at rate of prices[i]\\n           return v[i][buy]=max( prices[i]+find(prices,i+1,k-1,!buy,v),find(prices,i+1,k,buy,v)); \\n        }\\n    }\\n    int maxProfit(vector<int>& prices) {\\n        \\n        int n=prices.size(); \\n        vector<vector<int>> v(n,vector<int> (2,-1));\\n        //passing here buy=1 because we will first buy then sell\\n        //we can do atmost k=1 transaction\\n        return find(prices,0,1,1,v);\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\nint find(int ind,vector<int> &v,bool buy,vector<vector<int>> &memo)\\n{    \\n    if(ind>=v.size()) return 0;\\n    if(memo[ind][buy]!=-1) return memo[ind][buy];\\n    \\n    if(buy) //if we are buying then next time we will sell else next time we will buy\\n    {      //-prices[i], because bought stock of prices[i], expend money, !buy because next time sell\\n        \\n       return memo[ind][buy]=max(-v[ind]+find(ind+1,v,!buy,memo),find(ind+1,v,buy,memo));  \\n    }\\n    else   //it\\'s time to sell \\n    {      //+prices[i], because we now gain (i.e) sell our stock at rate of prices[i]\\n        \\n       return memo[ind][buy]=max(v[ind]+find(ind+1,v,!buy,memo),find(ind+1,v,buy,memo));  \\n    }\\n     \\n}\\n    int maxProfit(vector<int>& prices) {\\n        \\n        int n=prices.size();\\n        if(n<2) return 0;\\n        vector<vector<int>> v(n+1,vector<int>(2,-1));\\n        //passing here buy=1 because we will first buy then sell \\n        return find(0,prices,1,v); \\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    int find(vector<int> &prices,int ind,bool buy,int c,vector<vector<vector<int>>> &memo)\\n    {   \\n        //if buy =1 means we have to buy now\\n        //else we have to sell now\\n        if(ind>=prices.size()||c>=2) return 0; //counter\\n        if(memo[ind][buy][c]!=-1) return memo[ind][buy][c];\\n        if(buy) //now we can either buy prices[i] or we can skip it and try next to buy\\n        {\\n            return memo[ind][buy][c]=max(-prices[ind]+find(prices,ind+1,!buy,c,memo),find(prices,ind+1,buy,c,memo));\\n        }\\n        else  //now we can either sell prices[i] or we can skip it and try next to sell\\n        {\\n            return memo[ind][buy][c]=max(prices[ind]+find(prices,ind+1,!buy,c+1,memo),find(prices,ind+1,buy,c,memo));\\n        }\\n        \\n    }\\n    int maxProfit(vector<int>& prices) {\\n        //here we can do maximum two transaction\\n        //Use 3-D vector because here three states i,k,buy/sell\\n        vector<vector<vector<int>>> memo(prices.size(),vector<vector<int>>(2,vector<int>(2,-1)));\\n          \\n       return find(prices,0,1,0,memo); \\n    }\\n};\\n \\n```\n```\\nclass Solution {\\npublic:\\n    int find(vector<int> &prices,int ind,bool buy,int c,int k,vector<vector<vector<int>>> &memo)\\n    {   //if buy =1 means we have to buy now\\n        //else we have to sell now\\n        if(ind>=prices.size()||c>=k) return 0; //counter\\n        \\n        else if(memo[ind][buy][c]!=-1) return memo[ind][buy][c];\\n         \\n        if(buy) //now we can either buy prices[i] or we can skip it and try next to buy\\n        {\\n        return memo[ind][buy][c]=max(-prices[ind]+find(prices,ind+1,!buy,c,k,memo),find(prices,ind+1,buy,c,k,memo));\\n        }\\n        else  //now we can either sell prices[i] or we can skip it and try next to sell\\n        {\\n        return memo[ind][buy][c]=max(prices[ind]+find(prices,ind+1,!buy,c+1,k,memo),find(prices,ind+1,buy,c,k,memo));\\n        }\\n        \\n    }\\n    int maxProfit(int k, vector<int>& prices) {\\n        \\n        //edge case we are not able to pick 2k points from n points, which means \\n        //we will not reach the limit no matter how we try. \\n        //if the price of day i arise, buy the stock in i-1th day and sell it at ith day.\\n        if (2 * k > prices.size()) {\\n            int res = 0;\\n            for (int i = 1; i < prices.size(); i++) {\\n                res += max(0, prices[i] - prices[i - 1]);\\n            }\\n            return res;\\n        }\\n        \\n         //here we can do maximum k transaction\\n        vector<vector<vector<int>>> memo(prices.size()+1,vector<vector<int>>(2,vector<int>(k+1,-1)));\\n        return find(prices,0,1,0,k,memo); \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 39406,
                "title": "clear-1-line-python-solution",
                "content": "Basically, if tomorrow's price is higher than today's, we buy it today and sell tomorrow. Otherwise, we don't. Here is the code:\\n\\n    class Solution(object):\\n        def maxProfit(self, prices):\\n            return sum(max(prices[i + 1] - prices[i], 0) for i in range(len(prices) - 1))",
                "solutionTags": [],
                "code": "Basically, if tomorrow's price is higher than today's, we buy it today and sell tomorrow. Otherwise, we don't. Here is the code:\\n\\n    class Solution(object):\\n        def maxProfit(self, prices):\\n            return sum(max(prices[i + 1] - prices[i], 0) for i in range(len(prices) - 1))",
                "codeTag": "Java"
            },
            {
                "id": 1569156,
                "title": "c-easy-intuitive-solutions-with-explanation",
                "content": "Firstly, thanks for refering to my solution, in advance :)\\n\\n **Valley Peak approach :** \\nWe buy the stock on the day with least local rate and sell it when we find a peak that is raise in prices again. i.e; we just need to find the next greater element and subtract it from the current element so that the difference keeps increasing and so does the profit.\\nIf the sequence is decreasing sequence then, no profit can be made because no matter on which day we buy the stock, we would have to sell it incurring a loss. So then we don\\'t buy and make \\'0\\' profit rather than negative. \\nWe can just understand which day we buy and sell the stock, by simply using a peak Valley Diagram.\\n\\nFor instance, \\n![image](https://assets.leetcode.com/users/images/8a071173-ac5b-4bda-97a9-74da3637398d_1636509428.7270691.png)\\n* Here, the first valley is seen on day-2, we buy the stock on day2 and sell when the prices raise the next day, i.e on day-3 - Profit+=A\\n* Then again, we buy on the day the next valley is seen on day-4, so we buy on day-4 and sell on the day, the next peak is seen i.e; on day-5 - Profit+=B\\nThus, the max-profit we can make with this sequence of stock-rates is A+B.\\n\\n![image](https://assets.leetcode.com/users/images/47631773-0c33-4080-ac31-1e8942f64b2b_1636509698.8262544.png) In this graph, we see the first valley on day-3, we buy on day-3, sell on day-4. \\nThen again, the price on day-5 is less than that on day-4, So we buy again on day-4 and sell on day-5. \\nSimilarly, we buy on day-5 again and sell on day-6.\\nThe Valley-Peak graph is known in advance to us. So, we can see the future prices and make decision accordingly.\\n\\n**Time and Space Complexity**\\n* Time Complexity - O(n) - We traverse through the array of stock-rates only once\\n* Auxiliary Space - O(1)\\n\\n**Code**\\n```\\nclass Solution {\\npublic:\\n    int maxProfit(vector<int>& prices) {\\n        int i=0, profit=0, buy, sell;\\n        while(i < prices.size()-1){\\n            while(i < prices.size()-1 && prices[i+1] <= prices[i]){\\n                i++;\\n            }\\n            buy = prices[i];\\n            while(i < prices.size()-1 && prices[i+1] > prices[i]){\\n                i++;\\n            }\\n            sell = prices[i];\\n            profit += sell - buy;\\n        }\\n        return profit;\\n    }\\n};\\n```\\n\\nA faster approach would be :\\n\\n**Code :**\\n```\\nclass Solution {\\npublic:\\n    int maxProfit(vector<int>& prices) {\\n        int maxProfit=0;\\n        \\n        for(int i=1; i<prices.size(); ++i) \\n            maxProfit += max(prices[i] - prices[i-1], 0);\\n   \\n        return maxProfit;\\n    }\\n};\\n```\\n\\nIf you like my solution, please upvote! It will keep me motivated and consistent.\\n\\n\\n\\n",
                "solutionTags": [
                    "C++",
                    "C",
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int maxProfit(vector<int>& prices) {\\n        int i=0, profit=0, buy, sell;\\n        while(i < prices.size()-1){\\n            while(i < prices.size()-1 && prices[i+1] <= prices[i]){\\n                i++;\\n            }\\n            buy = prices[i];\\n            while(i < prices.size()-1 && prices[i+1] > prices[i]){\\n                i++;\\n            }\\n            sell = prices[i];\\n            profit += sell - buy;\\n        }\\n        return profit;\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    int maxProfit(vector<int>& prices) {\\n        int maxProfit=0;\\n        \\n        for(int i=1; i<prices.size(); ++i) \\n            maxProfit += max(prices[i] - prices[i-1], 0);\\n   \\n        return maxProfit;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 39564,
                "title": "another-accepted-java-solution",
                "content": "    public class Solution {\\n        public int maxProfit(int[] prices) {\\n            int profit = 0;\\n            \\n            for (int i = 1; i < prices.length; i++) \\n                profit += Math.max(0, prices[i] - prices[i - 1]);\\n            \\n            return profit;\\n        }\\n    }",
                "solutionTags": [
                    "Java"
                ],
                "code": "class Solution {\\n        public int maxProfit(int[] prices) {\\n            int profit = 0;\\n            \\n            for (int i = 1; i < prices.length; i++) \\n                profit += Math.max(0, prices[i] - prices[i - 1]);\\n            \\n            return profit;\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 39407,
                "title": "an-iterative-python-solution-greedy",
                "content": "    class Solution:\\n        # @param prices, a list of integer\\n        # @return an integer\\n        def maxProfit(self, prices):\\n            if not prices or len(prices) is 1:\\n                return 0\\n            \\n            profit = 0\\n            \\n            for i in range(1, len(prices)):\\n                if prices[i] > prices[i-1]:\\n                    profit += prices[i] - prices[i-1]\\n    \\n            return profit",
                "solutionTags": [
                    "Python"
                ],
                "code": "    class Solution:\\n        # @param prices, a list of integer\\n        # @return an integer\\n        def maxProfit(self, prices):\\n            if not prices or len(prices) is 1:\\n                return 0\\n            \\n            profit = 0\\n            \\n            for i in range(1, len(prices)):\\n                if prices[i] > prices[i-1]:\\n                    profit += prices[i] - prices[i-1]\\n    \\n            return profit",
                "codeTag": "Java"
            },
            {
                "id": 39404,
                "title": "shortest-and-fastest-solution-with-explanation-you-can-never-beat-this",
                "content": "For Buy and Sell 1, we were limited to 1 transaction, so we had to find the largest sum of contiguous ints in an array of price differences. \\n\\nQ: Why does finding the most profitable transaction boils down to finding the largest sum of contiguous ints in the array of price differences?\\n\\nA: Define D[i] = Prices[i] - Prices[i-1] (difference between 2 consecutive prices)\\n\\nD[i] is essentially a \"delta\" trade. \\n\\nA transaction is defined as buying at Prices[X] and selling at Prices[Y], \\n\\n    the profit of the transaction\\n    = Prices[Y] - Prices[X] \\n    = Prices[Y] - Prices[Y-1] +\\n       Prices[Y-1] - Prices[Y-2] ...\\n        ....\\n       Prices[X+1] - Prices[X] \\n    = D[Y] + D[Y-1] + ... + D[X+1]\\n    = sum of D from X+1 to Y\\n   \\nThe problem is to find max(Prices[Y] - Prices[X]) which is equivalent to finding the largest sum of contiguous D's.\\n\\nTo illustrate, if D[Y+1] is positive, it means  Prices[Y+1] > Prices[Y], which implies I should sell at Prices[Y+1] instead of Prices[Y]. Basically it means I just add D[Y+1] to D[Y] + ... + D[X+1].  \\n\\nNote that there could be a negative or zero D in the best running sequence. It doesn't matter so long the  sum of the sequence is the largest.\\n\\nNow we are allowed unlimited transactions. So if there is a negative D, we could just break the sequence into 2, that is, into 2 transactions so as to avoid the negative element. \\n\\nThis boils the whole problem down to adding up all positive sums of contiguous ints in D, which simplifies to  just adding up all the positive ints.\\n\\n    class Solution {\\n    public:\\n        int maxProfit(vector<int>& prices) {\\n            const size_t n = prices.size();\\n            int ans = 0;\\n            for (size_t i=1;i<n;i++)\\n                ans += max(0,prices[i]-prices[i-1]);\\n            return ans;\\n        }\\n    };",
                "solutionTags": [],
                "code": "class Solution {\\n    public:\\n        int maxProfit(vector<int>& prices) {\\n            const size_t n = prices.size();\\n            int ans = 0;\\n            for (size_t i=1;i<n;i++)\\n                ans += max(0,prices[i]-prices[i-1]);\\n            return ans;\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 306427,
                "title": "different-python-solutions-with-thinking-process",
                "content": "Please see and vote for my different solutions with thinking process.\\n[121. Best Time to Buy and Sell Stock](https://leetcode.com/problems/best-time-to-buy-and-sell-stock/discuss/306438/Python-O(n)-solution-with-thinking-process)\\n[122. Best Time to Buy and Sell Stock II](https://leetcode.com/problems/best-time-to-buy-and-sell-stock-ii/discuss/306427/Different-O(n)-Python-solutions-with-thinking-process)\\n[309. Best Time to Buy and Sell Stock with Cooldown](https://leetcode.com/problems/best-time-to-buy-and-sell-stock-with-cooldown/discuss/306235/Different-DP-Python-solutions-with-thinking-process)\\n[188. Best Time to Buy and Sell Stock IV](https://leetcode.com/problems/best-time-to-buy-and-sell-stock-iv/discuss/306282/Different-DP-Python-solutions-with-thinking-process)\\n[714. Best Time to Buy and Sell Stock with Transaction Fee](https://leetcode.com/problems/best-time-to-buy-and-sell-stock-with-transaction-fee/discuss/444413/Different-Python-solutions-with-thinking-process-to-solve-the-series-of-stock-problems)\\n\\n**Method 1: straightforward algorithm with O(n) time and O(1) space**\\nFor each day, there are 3 possible actions: buy, sell, nothing. \\nThe action nothing can be interpreted at \"sell then immediately buy\". \\nSo positive changes of prices are profitable.\\n```\\n    def maxProfit(self, prices: List[int]) -> int:\\n        max_profit = 0\\n        for i in range(len(prices) - 1):\\n            max_profit += max(prices[i+1] - prices[i], 0)\\n        return max_profit\\n```\\n\\n**Method 2: DP algorithm with O(n) time and O(1) space**\\nFor each day, there are 3 possible actions: buy, sell, nothing. Let us define\\nbuy[i] = maxProfit of prices[:i+1] with the action buy at day i,\\nsell[i] = maxProfit of prices[:i+1] with the action sell at day i,\\nnothing[i] = maxProfit of prices[:i+1] with the action nothing at day i.\\n\\nThe base cases are buy[0] = -prices[0], sell[0] = nothing[0] = 0. The recursive relationships are\\nbuy[i] = max(max(sell[i-1], nothing[i-1]) - prices[i], buy[i-1]) # no cool down\\nsell[i] = max(buy[i-1] + prices[i], sell[i-1])\\nnothing[i] = max(sell[i-1], buy[i-1], nothing[i-1]).\\n```\\n    def maxProfit(self, prices: List[int]) -> int:\\n        n = len(prices)\\n        if n < 2: \\n            return 0\\n        prev_buy, prev_sell, prev_nothing = -prices[0], 0, 0\\n        for i in range(1, n):\\n            buy  = max(max(prev_sell, prev_nothing) - prices[i], prev_buy) \\n            sell = max(prev_buy + prices[i], prev_sell)\\n            nothing = max(prev_sell, prev_buy, prev_nothing)\\n            prev_buy, prev_sell, prev_nothing = buy, sell, nothing\\n        return max(sell, nothing)\\n```\\n\\n**Method 3: naive DP algorithm with O(n^2) time and O(n) space**\\nLet dp[i] = maxProfit of prices[:i+1], the base cases and recursive relationship are\\n(i) dp[i] = 0 if i <= 0\\n(ii) dp[i] = max(dp[i-1], prices[i] - prices[j] + dp[j-1] for j from 0 to i-1)\\nBecause we have two choices at day i: (1) do nothing at day i, (2) maxProfit of prices[:j], buy at day j, sell at day i.\\n\\nSolution 3: bottom-up approach with a table (Time Limit Exceeded, 200 / 201 test cases passed.)\\n```\\n    def maxProfit(self, prices: List[int]) -> int:\\n        n = len(prices)\\n        if n < 2: \\n            return 0\\n        dp = [0 for _ in range(n)]\\n        for i in range(1, n):\\n            dp[i] = dp[i-1]\\n            for j in range(i):\\n                tmp = prices[i] - prices[j]\\n                tmp += dp[j-1] if j > 0 else 0\\n                dp[i] = max(dp[i], tmp)\\n        return dp[n-1]\\n```\\n\\nSolution 4: top-down approach with memoization (Time Limit Exceeded, 200 / 201 test cases passed.)\\n```\\n    def maxProfit(self, prices: List[int]) -> int:\\n        def recursive(i):\\n            if i <= 0:\\n                return 0\\n            if i in mp:\\n                return mp[i]\\n            max_profit = recursive(i - 1)\\n            for j in range(i):\\n                tmp = prices[i] - prices[j] + recursive(j - 1)\\n                max_profit = max(max_profit, tmp)\\n            mp[i] = max_profit\\n            return mp[i]\\n        \\n        mp = {}\\n        return recursive(len(prices) - 1)\\n```\\n\\n**Method 4: DP algorithm with O(n) time and O(n) space** (Beat 27.94%)\\nLet dp[i] = maxProfit of prices[:i+1], the base cases and recursive relationship are\\n(i) dp[i] = 0 if i <= 0\\n(ii) dp[i] = max(dp[i-1], prices[i] - prices[j] + dp[j-1] for j from 0 to i-1)\\n**We can further use DP to get local_max = - prices[j] + dp[j-1] for j from 0 to i-1.**\\n```\\n    def maxProfit(self, prices: List[int]) -> int:\\n        n = len(prices)\\n        if n < 2: \\n            return 0\\n        dp = [0 for _ in range(n)]\\n        local_max = -prices[0]\\n        for i in range(1, n):\\n            dp[i] = max(dp[i-1], prices[i] + local_max)\\n            local_max = max(local_max, dp[i-1] - prices[i])\\n        return dp[n-1]\\n```\\n",
                "solutionTags": [],
                "code": "```\\n    def maxProfit(self, prices: List[int]) -> int:\\n        max_profit = 0\\n        for i in range(len(prices) - 1):\\n            max_profit += max(prices[i+1] - prices[i], 0)\\n        return max_profit\\n```\n```\\n    def maxProfit(self, prices: List[int]) -> int:\\n        n = len(prices)\\n        if n < 2: \\n            return 0\\n        prev_buy, prev_sell, prev_nothing = -prices[0], 0, 0\\n        for i in range(1, n):\\n            buy  = max(max(prev_sell, prev_nothing) - prices[i], prev_buy) \\n            sell = max(prev_buy + prices[i], prev_sell)\\n            nothing = max(prev_sell, prev_buy, prev_nothing)\\n            prev_buy, prev_sell, prev_nothing = buy, sell, nothing\\n        return max(sell, nothing)\\n```\n```\\n    def maxProfit(self, prices: List[int]) -> int:\\n        n = len(prices)\\n        if n < 2: \\n            return 0\\n        dp = [0 for _ in range(n)]\\n        for i in range(1, n):\\n            dp[i] = dp[i-1]\\n            for j in range(i):\\n                tmp = prices[i] - prices[j]\\n                tmp += dp[j-1] if j > 0 else 0\\n                dp[i] = max(dp[i], tmp)\\n        return dp[n-1]\\n```\n```\\n    def maxProfit(self, prices: List[int]) -> int:\\n        def recursive(i):\\n            if i <= 0:\\n                return 0\\n            if i in mp:\\n                return mp[i]\\n            max_profit = recursive(i - 1)\\n            for j in range(i):\\n                tmp = prices[i] - prices[j] + recursive(j - 1)\\n                max_profit = max(max_profit, tmp)\\n            mp[i] = max_profit\\n            return mp[i]\\n        \\n        mp = {}\\n        return recursive(len(prices) - 1)\\n```\n```\\n    def maxProfit(self, prices: List[int]) -> int:\\n        n = len(prices)\\n        if n < 2: \\n            return 0\\n        dp = [0 for _ in range(n)]\\n        local_max = -prices[0]\\n        for i in range(1, n):\\n            dp[i] = max(dp[i-1], prices[i] + local_max)\\n            local_max = max(local_max, dp[i-1] - prices[i])\\n        return dp[n-1]\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 590168,
                "title": "easy-python-solution-faster-than-98-39",
                "content": "The key idea is to take down all daily returns and sum up all positive returns. This works because we can break every trade down to several overnigt trades. For example, considering [1, 2, 3], buy 1 sell 3 is equivalent to buy 1 sell 2 + buy 2 sell 3.\\n\\n```\\nclass Solution:\\n    def maxProfit(self, prices: List[int]) -> int:\\n        if len(prices) == 1: # edge case\\n            return 0\\n        \\n        # take down positive daily return only\\n        profit = [] \\n        for i in range(1, len(prices)):\\n            profit.append(max(0, prices[i] - prices[i-1])) \\n        return sum(profit)\\n```",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def maxProfit(self, prices: List[int]) -> int:\\n        if len(prices) == 1: # edge case\\n            return 0\\n        \\n        # take down positive daily return only\\n        profit = [] \\n        for i in range(1, len(prices)):\\n            profit.append(max(0, prices[i] - prices[i-1])) \\n        return sum(profit)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 259375,
                "title": "python-2-solutions-top-down-dp-greedy-clean-concise",
                "content": "**Solution 1: Top down DP**\\n```python\\nclass Solution:\\n    def maxProfit(self, prices: List[int]) -> int:\\n        n = len(prices)\\n        \\n        @lru_cache(None)\\n        def dp(i, canBuy):\\n            if i == n:\\n                return 0\\n            ans = dp(i+1, canBuy)  # Skip\\n            if canBuy:\\n                ans = max(ans, dp(i+1, False) - prices[i])  # Buy\\n            else:\\n                ans = max(ans, dp(i+1, True) + prices[i])  # Sell\\n            return ans\\n        \\n        return dp(0, True)\\n```\\nComplexity:\\n- Time: `O(N)`\\n- Space: `O(N)`\\n\\n---\\n**Solution 2: Greedy**\\n```python\\nclass Solution:\\n    def maxProfit(self, prices: List[int]) -> int:\\n        n = len(prices)\\n        maxProfit = 0\\n        for i in range(n-1):\\n            if prices[i+1] > prices[i]:\\n                maxProfit += prices[i+1] - prices[i]\\n        return maxProfit\\n```\\nComplexity:\\n- Time: `O(N)`\\n- Space: `O(1)`",
                "solutionTags": [],
                "code": "```python\\nclass Solution:\\n    def maxProfit(self, prices: List[int]) -> int:\\n        n = len(prices)\\n        \\n        @lru_cache(None)\\n        def dp(i, canBuy):\\n            if i == n:\\n                return 0\\n            ans = dp(i+1, canBuy)  # Skip\\n            if canBuy:\\n                ans = max(ans, dp(i+1, False) - prices[i])  # Buy\\n            else:\\n                ans = max(ans, dp(i+1, True) + prices[i])  # Sell\\n            return ans\\n        \\n        return dp(0, True)\\n```\n```python\\nclass Solution:\\n    def maxProfit(self, prices: List[int]) -> int:\\n        n = len(prices)\\n        maxProfit = 0\\n        for i in range(n-1):\\n            if prices[i+1] > prices[i]:\\n                maxProfit += prices[i+1] - prices[i]\\n        return maxProfit\\n```",
                "codeTag": "Java"
            },
            {
                "id": 376873,
                "title": "javascript-easy-understand",
                "content": "```\\nvar maxProfit = function (prices) {\\n    let profit = 0;\\n\\n    for (let i = 1; i < prices.length; i++) {\\n        let prev = prices[i - 1];\\n        let current = prices[i];\\n\\n        if (prev < current) {\\n            profit += current - prev;\\n        }\\n    }\\n    \\n    return profit;\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\nvar maxProfit = function (prices) {\\n    let profit = 0;\\n\\n    for (let i = 1; i < prices.length; i++) {\\n        let prev = prices[i - 1];\\n        let current = prices[i];\\n\\n        if (prev < current) {\\n            profit += current - prev;\\n        }\\n    }\\n    \\n    return profit;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1569060,
                "title": "daily-leetcoding-challenge-november-day-10",
                "content": "This problem is the Daily LeetCoding Challenge for November, Day 10.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  ** Do you want to learn the problem thoroughly?**\n  Read [**  LeetCode Official Solution**](https://leetcode.com/problems/best-time-to-buy-and-sell-stock-ii/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 3 approaches in the official solution</summary>\n\n  \n**Approach 1:** Brute Force\n\n  \n**Approach 2:** Peak Valley Approach\n\n  \n**Approach 3:** Simple One Pass\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>",
                "solutionTags": [],
                "code": "  Read [**  LeetCode Official Solution**](https://leetcode.com/problems/best-time-to-buy-and-sell-stock-ii/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />",
                "codeTag": "Unknown"
            },
            {
                "id": 39507,
                "title": "8ms-c-solution-with-only-6-lines-of-code",
                "content": "    int maxProfit(vector<int>& prices) {\\n      if(prices.size() <= 1) return 0;\\n\\n      int res = 0;\\n\\n      for( size_t i = 1; i < prices.size(); i++)\\n        if( prices[i] - prices[i-1] > 0 ) \\n          res += prices[i] - prices[i-1];\\n      \\n      return res;\\n    }",
                "solutionTags": [
                    "C++",
                    "Dynamic Programming"
                ],
                "code": "    int maxProfit(vector<int>& prices) {\\n      if(prices.size() <= 1) return 0;\\n\\n      int res = 0;\\n\\n      for( size_t i = 1; i < prices.size(); i++)\\n        if( prices[i] - prices[i-1] > 0 ) \\n          res += prices[i] - prices[i-1];\\n      \\n      return res;\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 596502,
                "title": "c-with-diagram-explaination-100-speed-and-100-space",
                "content": "```\\n/*\\nHere the way to tackle this problem is to visualize it.\\nIf I were to buy the data at every small value and sell it at the immediate biggest value i can get the answer.\\nLet me demonstrate:\\n \\t\\t\\t\\t   7\\n \\t\\t\\t\\t\\t\\\\     5    6 \\n \\t\\t\\t\\t\\t \\\\    /\\\\  /\\\\\\n \\t\\t\\t\\t\\t  \\\\  /  \\\\/  4 --------->[7,1,5,3,6,4]\\n \\t\\t\\t\\t\\t   \\\\/\\t3\\t\\t  \\n                       1\\nSo if we were to buy at every valley and sell at evry peak we can acheive the goal given in this q.\\n      buy-1,3,4\\n      sell-5,6\\n      but as 4 doesnt have a pair we discard it\\n      profit = (sum of peaks) - (sum of valleys)\\n                11 - 4 = 7\\n*/\\n     int maxProfit(vector<int>& prices) {\\n        int ans=0,profit=0;\\n        int valley,peak;\\n        for(int i=0;i<prices.size();i++)\\n        {\\n            while(i<prices.size()-1 && prices[i]>=prices[i+1])i++;\\n            valley = prices[i];\\n            while(i<prices.size()-1 && prices[i]<=prices[i+1])i++;\\n            peak = prices[i];\\n            profit += peak-valley;\\n        }\\n        return profit;\\n    }\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Dynamic Programming"
                ],
                "code": "```\\n/*\\nHere the way to tackle this problem is to visualize it.\\nIf I were to buy the data at every small value and sell it at the immediate biggest value i can get the answer.\\nLet me demonstrate:\\n \\t\\t\\t\\t   7\\n \\t\\t\\t\\t\\t\\\\     5    6 \\n \\t\\t\\t\\t\\t \\\\    /\\\\  /\\\\\\n \\t\\t\\t\\t\\t  \\\\  /  \\\\/  4 --------->[7,1,5,3,6,4]\\n \\t\\t\\t\\t\\t   \\\\/\\t3\\t\\t  \\n                       1\\nSo if we were to buy at every valley and sell at evry peak we can acheive the goal given in this q.\\n      buy-1,3,4\\n      sell-5,6\\n      but as 4 doesnt have a pair we discard it\\n      profit = (sum of peaks) - (sum of valleys)\\n                11 - 4 = 7\\n*/\\n     int maxProfit(vector<int>& prices) {\\n        int ans=0,profit=0;\\n        int valley,peak;\\n        for(int i=0;i<prices.size();i++)\\n        {\\n            while(i<prices.size()-1 && prices[i]>=prices[i+1])i++;\\n            valley = prices[i];\\n            while(i<prices.size()-1 && prices[i]<=prices[i+1])i++;\\n            peak = prices[i];\\n            profit += peak-valley;\\n        }\\n        return profit;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3343376,
                "title": "python3-greedy",
                "content": "# Please Upvote \\uD83D\\uDE07\\n\\n## Python3\\n```\\nclass Solution:\\n    def maxProfit(self, a: List[int]) -> int:\\n        ans=0\\n        x=a[0]\\n        for i in range(1,len(a)):\\n            if(x>a[i]):\\n                x=a[i]\\n            else:\\n                ans+=a[i]-x\\n                x=a[i]\\n        return ans\\n\\n        \\n```",
                "solutionTags": [
                    "Python3",
                    "Greedy"
                ],
                "code": "```\\nclass Solution:\\n    def maxProfit(self, a: List[int]) -> int:\\n        ans=0\\n        x=a[0]\\n        for i in range(1,len(a)):\\n            if(x>a[i]):\\n                x=a[i]\\n            else:\\n                ans+=a[i]-x\\n                x=a[i]\\n        return ans\\n\\n        \\n```",
                "codeTag": "Java"
            },
            {
                "id": 2423189,
                "title": "c-intuition-memoization-tabulation-1d-array",
                "content": "***PLEASE UPVOTE IF YOU LIKE :)***\\n\\nIntuition - ***When we are at (i) th stock, we have 2 states possible*** - \\n\\n* We have bought a stock before and have not sold it. {We cannot buy a new stock right now, we can only sell or not sell today}. -> **2 options -> [ sell, not sell]**\\n\\n* We have no stock bought right now.  {We can buy a new stock right now. we may or may not buy today}. -> **2 options -> [buy, not buy]**\\n\\n* We can keep a boolean variable ```buy```, which will track ***whether we can buy on (i)th day or not.*** \\n\\n* When ```buy = true```, we can buy or not buy a new stock. \\n\\n* When ```buy = false```, we can sell or not sell the current stock we have.\\n\\n* We also have an integer variable - ```idx``` to ***track which day we\\'re at***. If ```idx == prices.size()```, we will earn 0 profit on that day, as we can neither buy nor sell.\\n\\n* When we ***buy*** a new stock on day ```idx``` - our ***net profit decreases by ```prices[idx]```*** , as the **price of the stock on this day will be deducted from the net profit earned.**\\n\\n* Similarily, when we ***sell*** a new stock on day ```idx``` - our ***net profit increases by ```prices[idx]```*** , as the **price of the stock on this day will be added to the net profit earned.**\\n\\nLet\\'s look at the code -\\n\\nNote -\\n* nb = net profit earned if we don\\'t buy on day ```idx```.\\n* ns = net profit earned if we don\\'t sell on day ```idx```.\\n* b = net profit earned if we buy on day ```idx```.\\n* s = net profit earned if we sell on day ```idx```.\\n\\nRecursion\\n```\\nclass Solution {\\npublic:\\n    int f(vector<int> &p, int idx, bool buy){\\n        int n = p.size();\\n        if(idx == n) return 0; // end of days. Can\\'t buy or sell\\n        \\n        int ans = 0;\\n        if(buy){\\n\\t\\t\\t// either buy or don\\'t buy\\n            int b = -p[idx] + f(p, idx+1, 0);\\n            int nb = 0 + f(p, idx+1, 1);\\n            ans = max(b, nb);\\n        }\\n        else{\\n\\t\\t\\t// either sell or don\\'t sell\\n            int s = p[idx] + f(p, idx+1, 1);\\n            int ns = 0 + f(p, idx+1, 0);\\n            ans = max(s, ns);\\n        }\\n        return ans;\\n        \\n    }\\n    int maxProfit(vector<int>& prices) {\\n\\t\\t// Initially, we are at day 0 and we can buy a stock. \\n        return f(prices, 0, 1);\\n    }\\n};\\n```\\n\\nTC -> O(2 ^ N) where N - number of days\\nSC -> O(N)\\n\\nWe can ***reduce time complexity***, as there are overlapping subproblems that can be ***memoized***.\\n\\nMemoization -\\n```\\nclass Solution {\\npublic:\\n    int f(vector<int> &p, int idx, bool buy, vector<vector<int>> &dp){\\n        int n = p.size();\\n        if(idx == n) return 0;\\n        \\n        if(dp[idx][buy] != -1) return dp[idx][buy];\\n        \\n        int ans = 0;\\n        if(buy){\\n            int b = -p[idx] + f(p, idx+1, 0, dp);\\n            int nb = 0 + f(p, idx+1, 1, dp);\\n            ans = max(b, nb);\\n        }\\n        else{\\n            int s = p[idx] + f(p, idx+1, 1, dp);\\n            int ns = 0 + f(p, idx+1, 0, dp);\\n            ans = max(s, ns);\\n        }\\n        return dp[idx][buy] = ans;\\n        \\n    }\\n    int maxProfit(vector<int>& prices) {\\n        vector<vector<int>> dp(prices.size(), vector<int>(2, -1));\\n        return f(prices, 0, 1,dp);\\n    }\\n};\\n```\\n\\nTC -> O(2 * N)\\nSC -> O(2 * N) + O(N)\\n\\nThis ***extra O(N) stack space*** can be avoided by tabulating the above code.\\n\\nTabulation( Top - Down) -\\n```\\nclass Solution {\\npublic:\\n    int maxProfit(vector<int>& p) {\\n        int n = p.size();\\n        vector<vector<int>> dp(n+1, vector<int>(2, 0));\\n        for(int idx = n-1; idx >= 0; idx--){\\n\\n            int b = -p[idx] + dp[idx+1][0];\\n\\n            int nb = 0 + dp[idx+1][1];\\n\\n            int s = p[idx] + dp[idx+1][1];\\n\\n            int ns = 0 + dp[idx+1][0];\\n\\n            dp[idx][0] = max(s, ns);\\n\\n            dp[idx][1] = max(b, nb);\\n        }\\n        return dp[0][1];\\n    }\\n};\\n```\\n\\nTC -> O( N )\\nSC -> O(2 * N)\\n\\nNow, note that we just need 2 info , to calculate max profit for each day ```idx``` -> max profit if we buy/not buy on ```idx+1``` day and max profit if we sell/not sell on ```idx + 1``` day.\\n\\nSo , we just need 2 array -> curr and next. ```next``` stores the 2 profits( can buy , can sell) for the ```idx + 1``` day and ```curr``` stores the 2 profits for ```idx``` day.\\n\\n1D array Optimized Code - \\n```\\nclass Solution {\\npublic:\\n    int maxProfit(vector<int>& p) {\\n        int n = p.size();\\n        vector<int> next(2, 0), curr(2, 0);\\n        for(int idx = n-1; idx >= 0; idx--){\\n\\n            int b = -p[idx] + next[0];\\n\\n            int nb = 0 + next[1];\\n\\n            int s = p[idx] + next[1];\\n\\n            int ns = 0 + next[0];\\n\\n            curr[0] = max(s, ns);\\n\\n            curr[1] = max(b, nb);\\n            \\n            next = curr;\\n        }\\n        return curr[1];\\n    }\\n};\\n```\\n\\nTC -> O( N )\\nSC -> O(1)\\n\\n***PLEASE UPVOTE IF YOU LIKE :)***\\n\\n\\n\\n",
                "solutionTags": [
                    "C",
                    "Dynamic Programming",
                    "Recursion",
                    "Memoization"
                ],
                "code": "```buy```\n```buy = true```\n```buy = false```\n```idx```\n```idx == prices.size()```\n```idx```\n```prices[idx]```\n```idx```\n```prices[idx]```\n```idx```\n```idx```\n```idx```\n```idx```\n```\\nclass Solution {\\npublic:\\n    int f(vector<int> &p, int idx, bool buy){\\n        int n = p.size();\\n        if(idx == n) return 0; // end of days. Can\\'t buy or sell\\n        \\n        int ans = 0;\\n        if(buy){\\n\\t\\t\\t// either buy or don\\'t buy\\n            int b = -p[idx] + f(p, idx+1, 0);\\n            int nb = 0 + f(p, idx+1, 1);\\n            ans = max(b, nb);\\n        }\\n        else{\\n\\t\\t\\t// either sell or don\\'t sell\\n            int s = p[idx] + f(p, idx+1, 1);\\n            int ns = 0 + f(p, idx+1, 0);\\n            ans = max(s, ns);\\n        }\\n        return ans;\\n        \\n    }\\n    int maxProfit(vector<int>& prices) {\\n\\t\\t// Initially, we are at day 0 and we can buy a stock. \\n        return f(prices, 0, 1);\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    int f(vector<int> &p, int idx, bool buy, vector<vector<int>> &dp){\\n        int n = p.size();\\n        if(idx == n) return 0;\\n        \\n        if(dp[idx][buy] != -1) return dp[idx][buy];\\n        \\n        int ans = 0;\\n        if(buy){\\n            int b = -p[idx] + f(p, idx+1, 0, dp);\\n            int nb = 0 + f(p, idx+1, 1, dp);\\n            ans = max(b, nb);\\n        }\\n        else{\\n            int s = p[idx] + f(p, idx+1, 1, dp);\\n            int ns = 0 + f(p, idx+1, 0, dp);\\n            ans = max(s, ns);\\n        }\\n        return dp[idx][buy] = ans;\\n        \\n    }\\n    int maxProfit(vector<int>& prices) {\\n        vector<vector<int>> dp(prices.size(), vector<int>(2, -1));\\n        return f(prices, 0, 1,dp);\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    int maxProfit(vector<int>& p) {\\n        int n = p.size();\\n        vector<vector<int>> dp(n+1, vector<int>(2, 0));\\n        for(int idx = n-1; idx >= 0; idx--){\\n\\n            int b = -p[idx] + dp[idx+1][0];\\n\\n            int nb = 0 + dp[idx+1][1];\\n\\n            int s = p[idx] + dp[idx+1][1];\\n\\n            int ns = 0 + dp[idx+1][0];\\n\\n            dp[idx][0] = max(s, ns);\\n\\n            dp[idx][1] = max(b, nb);\\n        }\\n        return dp[0][1];\\n    }\\n};\\n```\n```idx```\n```idx+1```\n```idx + 1```\n```next```\n```idx + 1```\n```curr```\n```idx```\n```\\nclass Solution {\\npublic:\\n    int maxProfit(vector<int>& p) {\\n        int n = p.size();\\n        vector<int> next(2, 0), curr(2, 0);\\n        for(int idx = n-1; idx >= 0; idx--){\\n\\n            int b = -p[idx] + next[0];\\n\\n            int nb = 0 + next[1];\\n\\n            int s = p[idx] + next[1];\\n\\n            int ns = 0 + next[0];\\n\\n            curr[0] = max(s, ns);\\n\\n            curr[1] = max(b, nb);\\n            \\n            next = curr;\\n        }\\n        return curr[1];\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1298585,
                "title": "java-c-python-easy-and-concise",
                "content": "# **Intuition**\\nWe don\\'t want miss any increase value of the stock.\\n<br>\\n\\n# **Explanation**\\nSo we compare each neighbour,\\nif `A[i] < A[i + 1]`, we add this value to our result `res`\\n<br>\\n\\n# **Complexity**\\nTime `O(N)`\\nSpace `O(1)`\\n<br>\\n\\n**Java:**\\n```java\\n    public int maxProfit(int[] A) {\\n        int res = 0;\\n        for (int i = 1; i < A.length; ++i)\\n            res += Math.max(A[i] - A[i - 1], 0);\\n        return res;\\n    }\\n```\\n**C++:**\\n```cpp\\n    int maxProfit(vector<int>& A) {\\n        int res = 0;\\n        for (int i = 1; i < A.size(); ++i)\\n            res += max(A[i] - A[i - 1], 0);\\n        return res;\\n    }\\n```\\n**Python:**\\n```py\\n    def maxProfit(self, A):\\n        return sum(A[i] - A[i - 1] for i in xrange(1, len(A)) if A[i] > A[i - 1])\\n\\n```\\n",
                "solutionTags": [],
                "code": "```java\\n    public int maxProfit(int[] A) {\\n        int res = 0;\\n        for (int i = 1; i < A.length; ++i)\\n            res += Math.max(A[i] - A[i - 1], 0);\\n        return res;\\n    }\\n```\n```cpp\\n    int maxProfit(vector<int>& A) {\\n        int res = 0;\\n        for (int i = 1; i < A.size(); ++i)\\n            res += max(A[i] - A[i - 1], 0);\\n        return res;\\n    }\\n```\n```py\\n    def maxProfit(self, A):\\n        return sum(A[i] - A[i - 1] for i in xrange(1, len(A)) if A[i] > A[i - 1])\\n\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 3307280,
                "title": "fantastic-logic-python3",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def maxProfit(self, prices: List[int]) -> int:\\n        maxprofit=0\\n        for i in range(len(prices)-1):\\n            if prices[i+1]>prices[i]:\\n                maxprofit+=prices[i+1]-prices[i]\\n        return maxprofit\\n    #please upvote me it would encourage me alot\\n\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def maxProfit(self, prices: List[int]) -> int:\\n        maxprofit=0\\n        for i in range(len(prices)-1):\\n            if prices[i+1]>prices[i]:\\n                maxprofit+=prices[i+1]-prices[i]\\n        return maxprofit\\n    #please upvote me it would encourage me alot\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1264604,
                "title": "c-recursion-memoisation-simple-solution-with-comments",
                "content": "```\\nclass Solution {\\npublic:\\n    \\n    int dp[30001][2];\\n    \\n    int recurs(int i,bool hold,vector<int>& prices)\\n    {\\n        if(i>=prices.size())\\n            return 0;\\n        \\n        if(dp[i][hold]!=-1)\\n            return dp[i][hold];\\n        \\n        // 1 indicates we have stock currently\\n        // 0 indicates no stock is possesed currently\\n        \\n        if(hold==1)//sell or do nothing\\n        {\\n            return dp[i][hold]=max(recurs(i+1,0,prices)+prices[i],recurs(i+1,1,prices));\\n        }\\n        if(hold==0)//buy or do nothing\\n        {\\n            return dp[i][hold]=max(recurs(i+1,1,prices)-prices[i],recurs(i+1,0,prices));\\n        }\\n        \\n        return 0;\\n    }\\n    \\n    int maxProfit(vector<int>& prices) {\\n        memset(dp,-1,sizeof(dp));\\n        return recurs(0,0,prices);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    \\n    int dp[30001][2];\\n    \\n    int recurs(int i,bool hold,vector<int>& prices)\\n    {\\n        if(i>=prices.size())\\n            return 0;\\n        \\n        if(dp[i][hold]!=-1)\\n            return dp[i][hold];\\n        \\n        // 1 indicates we have stock currently\\n        // 0 indicates no stock is possesed currently\\n        \\n        if(hold==1)//sell or do nothing\\n        {\\n            return dp[i][hold]=max(recurs(i+1,0,prices)+prices[i],recurs(i+1,1,prices));\\n        }\\n        if(hold==0)//buy or do nothing\\n        {\\n            return dp[i][hold]=max(recurs(i+1,1,prices)-prices[i],recurs(i+1,0,prices));\\n        }\\n        \\n        return 0;\\n    }\\n    \\n    int maxProfit(vector<int>& prices) {\\n        memset(dp,-1,sizeof(dp));\\n        return recurs(0,0,prices);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 39441,
                "title": "a-simple-solution-with-o-n-time-and-o-1-space",
                "content": " //now we try to improve the solution above.\\n        //(a[i]-a[i-1])+(a[i-1]-a[i-2])=a[i]-a[i-2] which is the profits created by i and i-2\\n        //so we travel from the end of the array and continually calculate the differece of i and i-1,\\n        //we only sum those positive profits then the final results is the maximum profits\\n\\n        if(prices.size()==0|| prices.size()==1) return 0;\\n        int max_pro=0;\\n        for(int i=prices.size()-1;i>0;i--){\\n            if(prices[i]-prices[i-1]>0) max_pro+=prices[i]-prices[i-1];\\n        }\\n        return max_pro;",
                "solutionTags": [],
                "code": " //now we try to improve the solution above.\\n        //(a[i]-a[i-1])+(a[i-1]-a[i-2])=a[i]-a[i-2] which is the profits created by i and i-2\\n        //so we travel from the end of the array and continually calculate the differece of i and i-1,\\n        //we only sum those positive profits then the final results is the maximum profits\\n\\n        if(prices.size()==0|| prices.size()==1) return 0;\\n        int max_pro=0;\\n        for(int i=prices.size()-1;i>0;i--){\\n            if(prices[i]-prices[i-1]>0) max_pro+=prices[i]-prices[i-1];\\n        }\\n        return max_pro;",
                "codeTag": "Unknown"
            },
            {
                "id": 2966220,
                "title": "2-solutions-0-ms-1ms-2-different-approaches-explained-super-easy-java",
                "content": "# Explaination for Approach 2 : (Peak Valley Approach)\\n```\\nSay the given array is:\\n\\n[7, 1, 5, 3, 6, 4].\\n\\nIf we plot the numbers of the given array on a graph, we get:\\n```\\n![122_maxprofit_1.png](https://assets.leetcode.com/users/images/7521e81c-818b-4eab-8a4c-b544838ffb13_1672298793.4726715.png)\\n# Mathematically speaking:\\n```\\nTotalProfit =\\u2211i(height(peaki)\\u2212height(valleyi)).\\n```\\n---\\n\\n```\\nThe key point is we need to consider every peak immediately \\nfollowing a valley to maximize the profit. In case we skip one \\nof the peaks (trying to obtain more profit), we will end up \\nlosing the profit over one of the transactions leading to an overall \\nlesser profit.\\n\\nFor example, in the above case, if we skip peakipeaki\\u200B and valleyj\\n trying to obtain more profit by considering points with more \\ndifference in heights, the net profit obtained will always be \\nlesser than the one obtained by including them, since C will \\nalways be lesser than A+B.\\n```\\n\\n\\n# Request \\uD83D\\uDE0A :\\n```\\nIf you find these solutions easy to understand and helpful, then\\nPlease Upvote\\uD83D\\uDC4D\\uD83D\\uDC4D (Scroll Down for fastest [0 ms] approach).\\n```\\n\\n# Approach 1 : 1ms Solution\\n```\\nclass Solution \\n{\\n\\tint maxProfit(int[] prices) //basic approach\\n    {\\n        int maximumProfit = 0;\\n        for (int i = 1; i < prices.length; i++) \\n        {\\n            if (prices[i] > prices[i - 1])\\n                maximumProfit += prices[i] - prices[i - 1];\\n        }\\n        return maximumProfit;\\n\\t}\\n}\\n```\\n# Approach 2 : 0ms Solution [Fastest]\\n```\\nclass Solution \\n{\\n\\tint maxProfit(int[] prices) //peak valley approach\\n    {\\n        int i=0;\\n        int peak=prices[0];\\n        int valley=prices[0];\\n        int maxProfit=0;\\n        while(i<prices.length-1)\\n        {\\n            while(i<prices.length-1 && prices[i]>=prices[i+1])\\n                i++;\\n            valley=prices[i];\\n            while(i<prices.length-1 && prices[i+1]>=prices[i])\\n                i++;//post fix use \\n            peak=prices[i];\\n            maxProfit+=peak-valley;\\n        }\\n        return maxProfit;\\n\\t}\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Array",
                    "Greedy"
                ],
                "code": "```\\nSay the given array is:\\n\\n[7, 1, 5, 3, 6, 4].\\n\\nIf we plot the numbers of the given array on a graph, we get:\\n```\n```\\nTotalProfit =\\u2211i(height(peaki)\\u2212height(valleyi)).\\n```\n```\\nThe key point is we need to consider every peak immediately \\nfollowing a valley to maximize the profit. In case we skip one \\nof the peaks (trying to obtain more profit), we will end up \\nlosing the profit over one of the transactions leading to an overall \\nlesser profit.\\n\\nFor example, in the above case, if we skip peakipeaki\\u200B and valleyj\\n trying to obtain more profit by considering points with more \\ndifference in heights, the net profit obtained will always be \\nlesser than the one obtained by including them, since C will \\nalways be lesser than A+B.\\n```\n```\\nIf you find these solutions easy to understand and helpful, then\\nPlease Upvote\\uD83D\\uDC4D\\uD83D\\uDC4D (Scroll Down for fastest [0 ms] approach).\\n```\n```\\nclass Solution \\n{\\n\\tint maxProfit(int[] prices) //basic approach\\n    {\\n        int maximumProfit = 0;\\n        for (int i = 1; i < prices.length; i++) \\n        {\\n            if (prices[i] > prices[i - 1])\\n                maximumProfit += prices[i] - prices[i - 1];\\n        }\\n        return maximumProfit;\\n\\t}\\n}\\n```\n```\\nclass Solution \\n{\\n\\tint maxProfit(int[] prices) //peak valley approach\\n    {\\n        int i=0;\\n        int peak=prices[0];\\n        int valley=prices[0];\\n        int maxProfit=0;\\n        while(i<prices.length-1)\\n        {\\n            while(i<prices.length-1 && prices[i]>=prices[i+1])\\n                i++;\\n            valley=prices[i];\\n            while(i<prices.length-1 && prices[i+1]>=prices[i])\\n                i++;//post fix use \\n            peak=prices[i];\\n            maxProfit+=peak-valley;\\n        }\\n        return maxProfit;\\n\\t}\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1542036,
                "title": "c-solution-in-easy-way-valley-peak-approach-explained",
                "content": "\\n\\n> **If you\\u2019re interested in coding you can join my Discord Server, link in the comment section. Also if you find any mistake please let me know. Thank you!\\u2764\\uFE0F**\\n> \\n\\n---\\n\\n## Explanation:\\n\\n### Solution 01\\n\\n- Using ***Valley Peak Approach.***\\n- As we need maximum profit so we can compare prices between 2 days!\\n- If the next day price is greater than the current day, we\\'ll buy it and sell it the next day!\\n- **Time complexity:** O(n).\\n\\n### Solution 02\\n\\n- Same as 1, but here we\\u2019ll store previous value in ***mn***.\\n- **Time complexity:** O(n).\\n\\n---\\n\\n## Code:\\n\\n```cpp\\n//Solution 01:\\nclass Solution {\\npublic:\\n    int maxProfit(vector<int>& prices) {\\n        int n= prices.size(), profit=0;\\n        for(int i=1; i<n; i++){\\n            if(prices[i]>prices[i-1])\\n                profit += prices[i]-prices[i-1];\\n        }\\n        return profit;\\n    }\\n};\\n\\n//Solution 02: \\nclass Solution {\\npublic:\\n    int maxProfit(vector<int>& prices) {\\n        int n=prices.size(), profit=0;\\n        int mn=prices[0];\\n        \\n        for(int i=1; i<n; i++){\\n            if(mn<prices[i]){\\n                profit += prices[i]-mn;\\n            }\\n            mn = prices[i];\\n        }\\n        return profit;\\n    }\\n};\\n```\\n\\n---\\n\\n> **Please upvote this solution**\\n>",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```cpp\\n//Solution 01:\\nclass Solution {\\npublic:\\n    int maxProfit(vector<int>& prices) {\\n        int n= prices.size(), profit=0;\\n        for(int i=1; i<n; i++){\\n            if(prices[i]>prices[i-1])\\n                profit += prices[i]-prices[i-1];\\n        }\\n        return profit;\\n    }\\n};\\n\\n//Solution 02: \\nclass Solution {\\npublic:\\n    int maxProfit(vector<int>& prices) {\\n        int n=prices.size(), profit=0;\\n        int mn=prices[0];\\n        \\n        for(int i=1; i<n; i++){\\n            if(mn<prices[i]){\\n                profit += prices[i]-mn;\\n            }\\n            mn = prices[i];\\n        }\\n        return profit;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 39565,
                "title": "shortest-one-liners-in-ruby-python",
                "content": "**Idea**\\n\\nYou can do it on a day-to-day basis. If buying on day 1 and selling on day 2 is profitable, do it. If buying on day 2 and selling on day 3 is profitable, do it. And so on. Yes, you can do **both** day1-to-day2 **and** day2-to-day3, even though there are multiple transactions on day 2. Either think of it as selling first and then buying later on that day, or think of it as **keeping** instead of selling+buying.\\n\\n---\\n\\n**Ruby**\\n\\nRuby has the fabulicious `each_cons` and doesn't need a `return`.\\n\\n    def max_profit(prices)\\n        s=0;prices.each_cons(2){|a,b|b>a&&s+=b-a};s\\n    end\\n\\nOr as a single expression:\\n\\n    def max_profit(prices)\\n        prices.each_cons(2).reduce(0){|s,(a,b)|s+[b-a,0].max}\\n    end\\n\\nOr:\\n\\n    def max_profit(prices)\\n        prices.each_cons(2).reduce(0){|s,(a,b)|b>a ?s+b-a :s}\\n    end\\n\\n---\\n\\n**Python**\\n\\nPython's `zip` is also quite nice, and you can give it lists of different sizes, which none of the similar solutions I've seen from others exploited.\\n\\n    def maxProfit(self, prices):\\n        return sum(b-a for a,b in zip(prices,prices[1:])if b>a)\\n\\nOr:\\n\\n    def maxProfit(self, prices):\\n        return sum(max(b-a,0)for a,b in zip(prices,prices[1:]))",
                "solutionTags": [
                    "Python",
                    "Ruby"
                ],
                "code": "**Idea**\\n\\nYou can do it on a day-to-day basis. If buying on day 1 and selling on day 2 is profitable, do it. If buying on day 2 and selling on day 3 is profitable, do it. And so on. Yes, you can do **both** day1-to-day2 **and** day2-to-day3, even though there are multiple transactions on day 2. Either think of it as selling first and then buying later on that day, or think of it as **keeping** instead of selling+buying.\\n\\n---\\n\\n**Ruby**\\n\\nRuby has the fabulicious `each_cons` and doesn't need a `return`.\\n\\n    def max_profit(prices)\\n        s=0;prices.each_cons(2){|a,b|b>a&&s+=b-a};s\\n    end\\n\\nOr as a single expression:\\n\\n    def max_profit(prices)\\n        prices.each_cons(2).reduce(0){|s,(a,b)|s+[b-a,0].max}\\n    end\\n\\nOr:\\n\\n    def max_profit(prices)\\n        prices.each_cons(2).reduce(0){|s,(a,b)|b>a ?s+b-a :s}\\n    end\\n\\n---\\n\\n**Python**\\n\\nPython's `zip` is also quite nice, and you can give it lists of different sizes, which none of the similar solutions I've seen from others exploited.\\n\\n    def maxProfit(self, prices):\\n        return sum(b-a for a,b in zip(prices,prices[1:])if b>a)\\n\\nOr:\\n\\n    def maxProfit(self, prices):\\n        return sum(max(b-a,0)for a,b in zip(prices,prices[1:]))",
                "codeTag": "Python3"
            },
            {
                "id": 564672,
                "title": "python-time-o-n-space-o-1-easy-to-understand-solutions",
                "content": "```\\nclass Solution:\\n    def maxProfit(self, prices: List[int]) -> int:\\n        profit = 0\\n        for i in range(1, len(prices)):\\n            profit += max(prices[i]-prices[i-1], 0)\\n        return profit\\n```\\nOne-liner for fun\\n```\\nclass Solution:\\n    def maxProfit(self, prices: List[int]) -> int:\\n        return sum(max(prices[i]-prices[i-1], 0) for i in range(1, len(prices)))\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def maxProfit(self, prices: List[int]) -> int:\\n        profit = 0\\n        for i in range(1, len(prices)):\\n            profit += max(prices[i]-prices[i-1], 0)\\n        return profit\\n```\n```\\nclass Solution:\\n    def maxProfit(self, prices: List[int]) -> int:\\n        return sum(max(prices[i]-prices[i-1], 0) for i in range(1, len(prices)))\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1354753,
                "title": "dp-bottom-up-o-n",
                "content": "This approach involves solving subproblems from length 1 to length n. Here we represent subproblem as dp(i) which indicates maximum profit made till ith day. \\nResults for subproblem is based on following recurrence.\\n\\n`dp(i) = dp(i-1) + price(i) - price(i-1)`\\n`dp(0) = 0,  zero profit for first day (this is a base case)`\\n```\\nclass Solution {\\n    public int maxProfit(int[] prices) {\\n        int n = prices.length;\\n        int[] dp = new int[n];\\n        dp[0]=0;\\n        for(int i=1;i<n;i++){\\n            dp[i] = dp[i-1] + Math.max(0,prices[i]-prices[i-1]);\\n        }\\n        return dp[n-1];\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution {\\n    public int maxProfit(int[] prices) {\\n        int n = prices.length;\\n        int[] dp = new int[n];\\n        dp[0]=0;\\n        for(int i=1;i<n;i++){\\n            dp[i] = dp[i-1] + Math.max(0,prices[i]-prices[i-1]);\\n        }\\n        return dp[n-1];\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 278953,
                "title": "another-view-to-the-problem-in-a-dp-way",
                "content": "If we want to get max profit on day N, it can be broken down into two cases:\\n1. if the last operation during day 1 to day N - 1 is sell, we keep current profit and do nothing, then max_profit on day N = max profit on day N - 1\\n2. if the last operation during day 1 to day N - 1 is buy, we sell it on day N to maximize profit, then max_profit on day N = max profit on day N - 1 + prices[N]\\n3. Hence, max_profit on day N = max(answers of #1 and #2)\\n\\nSo this can form a recursive structure that can be solved using DP.\\n\\n```\\n    int maxProfit(vector<int>& prices) {\\n        if(prices.empty()) return 0;\\n        // dynamic programing tables (The arrays are not really necessary. just keep them so the original DP is easier to understand)\\n        vector<int> max_profit_last_op_is_sell(prices.size());\\n        vector<int> max_profit_last_op_is_buy(prices.size());\\n\\n        // boundary condition on the first day\\n        max_profit_last_op_is_sell[0] = 0;\\n        max_profit_last_op_is_buy[0] = -prices[0];\\n        for(int i = 1; i < prices.size(); ++i) {\\n\\n            // max profit we can get on day i if the last operation during day 0 to i - 1 is sell\\n            max_profit_last_op_is_sell[i] = max(\\n                max_profit_last_op_is_sell[i - 1],  // do nothing on day i and keep current profit\\n                max_profit_last_op_is_buy[i - 1] + prices[i]  // sell on day i\\n            );\\n\\n            // max profit we can get on day i if the last operation during day 0 to i - 1 is buy\\n            max_profit_last_op_is_buy[i] = max(\\n                max_profit_last_op_is_buy[i - 1], // do nothing on day i and keep current profit\\n                max_profit_last_op_is_sell[i - 1] - prices[i] // buy on day i\\n            );\\n        }\\n\\n        return max(\\n            // if the last operation before day N is buy, then we sell on day N to get max profit\\n            max_profit_last_op_is_buy[prices.size() - 1] + prices[prices.size() - 1],\\n            // if the last operation before day N is sell, then we do nothing to keep current profit\\n            max_profit_last_op_is_sell[prices.size() - 1]\\n        );\\n    }\\n```",
                "solutionTags": [
                    "Dynamic Programming"
                ],
                "code": "```\\n    int maxProfit(vector<int>& prices) {\\n        if(prices.empty()) return 0;\\n        // dynamic programing tables (The arrays are not really necessary. just keep them so the original DP is easier to understand)\\n        vector<int> max_profit_last_op_is_sell(prices.size());\\n        vector<int> max_profit_last_op_is_buy(prices.size());\\n\\n        // boundary condition on the first day\\n        max_profit_last_op_is_sell[0] = 0;\\n        max_profit_last_op_is_buy[0] = -prices[0];\\n        for(int i = 1; i < prices.size(); ++i) {\\n\\n            // max profit we can get on day i if the last operation during day 0 to i - 1 is sell\\n            max_profit_last_op_is_sell[i] = max(\\n                max_profit_last_op_is_sell[i - 1],  // do nothing on day i and keep current profit\\n                max_profit_last_op_is_buy[i - 1] + prices[i]  // sell on day i\\n            );\\n\\n            // max profit we can get on day i if the last operation during day 0 to i - 1 is buy\\n            max_profit_last_op_is_buy[i] = max(\\n                max_profit_last_op_is_buy[i - 1], // do nothing on day i and keep current profit\\n                max_profit_last_op_is_sell[i - 1] - prices[i] // buy on day i\\n            );\\n        }\\n\\n        return max(\\n            // if the last operation before day N is buy, then we sell on day N to get max profit\\n            max_profit_last_op_is_buy[prices.size() - 1] + prices[prices.size() - 1],\\n            // if the last operation before day N is sell, then we do nothing to keep current profit\\n            max_profit_last_op_is_sell[prices.size() - 1]\\n        );\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1336030,
                "title": "c-optimal-solution-time-o-n-auxiliary-space-o-1",
                "content": "\\t\\t\\t\\t   7\\n \\t\\t\\t\\t\\t\\\\     5    6 \\n \\t\\t\\t\\t\\t \\\\    /\\\\  /\\\\\\n \\t\\t\\t\\t\\t  \\\\  /  \\\\/  4 --------->[7,1,5,3,6,4]\\n \\t\\t\\t\\t\\t   \\\\/\\t3\\t\\t  \\n                       1\\n\\t\\t\\t\\t\\t   \\n**Valley to Peak approach : Add all gains from positive slopes i.e. profit = (5-1) + (6-3) = 7**\\n\\n```\\nclass Solution {\\npublic:\\n    int maxProfit(vector<int>& prices) {\\n\\t\\t// Optimal Solution Time O(N) & Auxiliary Space O(1)\\n        int res = 0;\\n        for (int i = 1; i < prices.size(); ++i)\\n            res += max(prices[i] - prices[i - 1], 0);\\n        return res;\\n    }\\n};\\n```\\n**All suggestions are welcome. Please upvote if you like it. Thank you for reading the post.**",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int maxProfit(vector<int>& prices) {\\n\\t\\t// Optimal Solution Time O(N) & Auxiliary Space O(1)\\n        int res = 0;\\n        for (int i = 1; i < prices.size(); ++i)\\n            res += max(prices[i] - prices[i - 1], 0);\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 39479,
                "title": "reduction-to-greedy-from-dp",
                "content": "This is not the canonical solution, but just wanted to post a DP to greedy reduction since we are always making the greedy choice. At any given day, the max gain includes the current day or it is the gain from the previous day. If it includes the current day `i` (i.e., sell) then identify a `j` such that we make a profit between `j` and `i` in addition to profit at `j`.\\n\\n```\\nclass Solution {\\npublic:\\n    int maxProfit(vector<int>& prices) {\\n        if (prices.size() <= 1) return 0;\\n        vector<int> G(prices.size(), 0);\\n        for (int i = 1; i < prices.size(); ++i) {\\n            int g = G[i - 1];\\n            for (int j = 0; j < i; ++j) {\\n                if (prices[i] > prices[j]) {\\n                    g = max(g, G[j] + prices[i] - prices[j]);\\n                }\\n            }\\n            G[i] = g;\\n        }\\n        return G[prices.size() - 1];\\n    }\\n};\\n```\\n\\nAfter eliminating the greedy choice... i.e., inner loop is making the greedy choice.\\n\\n```\\nclass Solution {\\npublic:\\n    int maxProfit(vector<int>& prices) {\\n        if (prices.size() <= 1) return 0;\\n        vector<int> G(prices.size(), 0);\\n        int maxM = -prices[0];\\n        for (int i = 1; i < prices.size(); ++i) {\\n            G[i] = max(G[i - 1], maxM + prices[i]);\\n            maxM = max(G[i] - prices[i], maxM);\\n        }\\n        return G[prices.size() - 1];\\n    }\\n};\\n```\\n\\nAfter reducing the space on G.\\n\\n```\\nclass Solution {\\npublic:\\n    int maxProfit(vector<int>& prices) {\\n        if (prices.size() <= 1) return 0;\\n        int maxM = -prices[0];\\n        int gi = 0;\\n        for (int i = 1; i < prices.size(); ++i) {\\n            gi = max(gi, maxM + prices[i]);\\n            maxM = max(gi - prices[i], maxM);\\n        }\\n        return gi;\\n    }\\n};\\n```",
                "solutionTags": [
                    "Dynamic Programming",
                    "Greedy"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int maxProfit(vector<int>& prices) {\\n        if (prices.size() <= 1) return 0;\\n        vector<int> G(prices.size(), 0);\\n        for (int i = 1; i < prices.size(); ++i) {\\n            int g = G[i - 1];\\n            for (int j = 0; j < i; ++j) {\\n                if (prices[i] > prices[j]) {\\n                    g = max(g, G[j] + prices[i] - prices[j]);\\n                }\\n            }\\n            G[i] = g;\\n        }\\n        return G[prices.size() - 1];\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    int maxProfit(vector<int>& prices) {\\n        if (prices.size() <= 1) return 0;\\n        vector<int> G(prices.size(), 0);\\n        int maxM = -prices[0];\\n        for (int i = 1; i < prices.size(); ++i) {\\n            G[i] = max(G[i - 1], maxM + prices[i]);\\n            maxM = max(G[i] - prices[i], maxM);\\n        }\\n        return G[prices.size() - 1];\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    int maxProfit(vector<int>& prices) {\\n        if (prices.size() <= 1) return 0;\\n        int maxM = -prices[0];\\n        int gi = 0;\\n        for (int i = 1; i < prices.size(); ++i) {\\n            gi = max(gi, maxM + prices[i]);\\n            maxM = max(gi - prices[i], maxM);\\n        }\\n        return gi;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 39582,
                "title": "quite-easy-share-my-c-code-with-explanation",
                "content": "###1. Calculate `prices[i+1]-prices[i]`\\n\\n###2. Turn the array `prices[] = [1,2,4,2,5,7,2,4,9,0]` into \\n`difference[] = [+1,+2,-2,+3,+2,-5,+2,+5,-9]`\\n\\n###3. Then add all positive numbers `sum = 1+2+3+2+2+5 = 15` in difference\\n###4. Return `15`\\n\\n\\n*The code is a simplified and optimized version.*\\n\\n#Code:\\n\\n    int maxProfit(int prices[], int n){\\n        int profit = 0;\\n        for(int i=0;i<n-1;i++){\\n            int temp = prices[i+1]-prices[i];\\n            if(temp>0)\\n                profit += temp;\\n        }\\n        return profit;\\n    }",
                "solutionTags": [],
                "code": "###1. Calculate `prices[i+1]-prices[i]`\\n\\n###2. Turn the array `prices[] = [1,2,4,2,5,7,2,4,9,0]` into \\n`difference[] = [+1,+2,-2,+3,+2,-5,+2,+5,-9]`\\n\\n###3. Then add all positive numbers `sum = 1+2+3+2+2+5 = 15` in difference\\n###4. Return `15`\\n\\n\\n*The code is a simplified and optimized version.*\\n\\n#Code:\\n\\n    int maxProfit(int prices[], int n){\\n        int profit = 0;\\n        for(int i=0;i<n-1;i++){\\n            int temp = prices[i+1]-prices[i];\\n            if(temp>0)\\n                profit += temp;\\n        }\\n        return profit;\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 582462,
                "title": "122-javascript-solution-explained-with-time-travel",
                "content": "This is the best way I could think of to make it easy to understand.\\nI think meaningful variable names are important for easy understanding.\\nAnd I think \"yesterday and today\" is easier to understand than \"today and tomorrow\".\\nBecause time travel is something we all dream about.\\n\\n> Runtime: **68 ms**, faster than *32.11%* of JavaScript online submissions\\n> Memory Usage: **36.6 MB**, less than *23.81%* of JavaScript online submissions\\n\\n```javascript\\n/**\\n * You have a time travel machine that can only go back 1 day.\\n * You will use it to exploit the stock market.\\n * But somehow had infinite money to start with. (Whatever.)\\n *\\n * @param {number[]} prices\\n * @return {number}\\n */\\nconst maxProfit = prices => {\\n  // Start with nothing and take every profitable opportunity from time travel\\n  let profit = 0;\\n  // Start from the second day (because that is the first day you could sell)\\n  for (let i = 1; i < prices.length; i++) {\\n    // Our Delorean only goes back 1 day, but that is all we need\\n    const [priceYesterday, priceToday] = [prices[i - 1], prices[i]];\\n    // Whenever there is profit, engage that Flux Capacitor!\\n    if (priceYesterday < priceToday) profit += priceToday - priceYesterday;\\n    // Buy yesterday; sell today\\n  }\\n  // Take every Monday off!\\n  return profit;\\n  // Time travel trading makes every weekend is a three-day weekend!\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```javascript\\n/**\\n * You have a time travel machine that can only go back 1 day.\\n * You will use it to exploit the stock market.\\n * But somehow had infinite money to start with. (Whatever.)\\n *\\n * @param {number[]} prices\\n * @return {number}\\n */\\nconst maxProfit = prices => {\\n  // Start with nothing and take every profitable opportunity from time travel\\n  let profit = 0;\\n  // Start from the second day (because that is the first day you could sell)\\n  for (let i = 1; i < prices.length; i++) {\\n    // Our Delorean only goes back 1 day, but that is all we need\\n    const [priceYesterday, priceToday] = [prices[i - 1], prices[i]];\\n    // Whenever there is profit, engage that Flux Capacitor!\\n    if (priceYesterday < priceToday) profit += priceToday - priceYesterday;\\n    // Buy yesterday; sell today\\n  }\\n  // Take every Monday off!\\n  return profit;\\n  // Time travel trading makes every weekend is a three-day weekend!\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3524020,
                "title": "c-java-python-javascript-simple-code-easy-to-understand",
                "content": "# Intuition:\\nThe intuition behind this approach is to find all the local minima and maxima in the given array of prices. We buy the stock at the local minima and sell it at the corresponding local maxima. By doing this, we can accumulate the maximum profit.\\n\\n# Approach:\\n1. Initialize the variables `profit` and `minPrice` to 0 and `INT_MAX` respectively.\\n2. Iterate through the prices array using a for loop.\\n3. For each price at index `i`:\\n   a. Update the `minPrice` by taking the minimum of the current `minPrice` and `prices[i]`.\\n   b. If the difference between `prices[i]` and `minPrice` is greater than 0, it means there is a profit to be made.\\n      - Add this profit to the `profit` variable.\\n      - Update the `minPrice` to `prices[i]` since we have sold the stock at this price.\\n4. Return the `profit`.\\n\\n# Complexity:\\n- The time complexity of this approach is O(n), where n is the size of the prices array, since we iterate through the array once.\\n- The space complexity is O(1) as we are using a constant amount of extra space to store the `profit` and `minPrice` variables.\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int maxProfit(vector<int>& prices) {\\n        int profit=0;\\n        int minPrice=INT_MAX;\\n        for(int i=0;i<prices.size();i++){\\n            minPrice = min(minPrice,prices[i]);\\n                if((prices[i]-minPrice)>0){\\n                    profit=profit+(prices[i]-minPrice);\\n                    minPrice=prices[i];\\n                }\\n        }\\n        return profit;\\n    }\\n};\\n```\\n\\n---\\n# Java\\n```\\nclass Solution {\\n    public int maxProfit(int[] prices) {\\n        int profit = 0;\\n        int minPrice = Integer.MAX_VALUE;\\n        for (int i = 0; i < prices.length; i++) {\\n            minPrice = Math.min(minPrice, prices[i]);\\n            if (prices[i] - minPrice > 0) {\\n                profit += prices[i] - minPrice;\\n                minPrice = prices[i];\\n            }\\n        }\\n        return profit;\\n    }\\n}\\n\\n```\\n---\\n# Python\\n```\\nclass Solution(object):\\n    def maxProfit(self, prices):\\n        profit = 0\\n        minPrice = float(\\'inf\\')\\n        for price in prices:\\n            minPrice = min(minPrice, price)\\n            if price - minPrice > 0:\\n                profit += price - minPrice\\n                minPrice = price\\n        return profit\\n\\n```\\n\\n---\\n# JavaScript\\n```\\nvar maxProfit = function(prices){\\n    let profit = 0;\\n    let minPrice = Infinity;\\n    for (let i = 0; i < prices.length; i++) {\\n        minPrice = Math.min(minPrice, prices[i]);\\n        if (prices[i] - minPrice > 0) {\\n            profit += prices[i] - minPrice;\\n            minPrice = prices[i];\\n        }\\n    }\\n    return profit;\\n}\\n\\n```",
                "solutionTags": [
                    "C++",
                    "Java",
                    "Python",
                    "JavaScript",
                    "Array"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int maxProfit(vector<int>& prices) {\\n        int profit=0;\\n        int minPrice=INT_MAX;\\n        for(int i=0;i<prices.size();i++){\\n            minPrice = min(minPrice,prices[i]);\\n                if((prices[i]-minPrice)>0){\\n                    profit=profit+(prices[i]-minPrice);\\n                    minPrice=prices[i];\\n                }\\n        }\\n        return profit;\\n    }\\n};\\n```\n```\\nclass Solution {\\n    public int maxProfit(int[] prices) {\\n        int profit = 0;\\n        int minPrice = Integer.MAX_VALUE;\\n        for (int i = 0; i < prices.length; i++) {\\n            minPrice = Math.min(minPrice, prices[i]);\\n            if (prices[i] - minPrice > 0) {\\n                profit += prices[i] - minPrice;\\n                minPrice = prices[i];\\n            }\\n        }\\n        return profit;\\n    }\\n}\\n\\n```\n```\\nclass Solution(object):\\n    def maxProfit(self, prices):\\n        profit = 0\\n        minPrice = float(\\'inf\\')\\n        for price in prices:\\n            minPrice = min(minPrice, price)\\n            if price - minPrice > 0:\\n                profit += price - minPrice\\n                minPrice = price\\n        return profit\\n\\n```\n```\\nvar maxProfit = function(prices){\\n    let profit = 0;\\n    let minPrice = Infinity;\\n    for (let i = 0; i < prices.length; i++) {\\n        minPrice = Math.min(minPrice, prices[i]);\\n        if (prices[i] - minPrice > 0) {\\n            profit += prices[i] - minPrice;\\n            minPrice = prices[i];\\n        }\\n    }\\n    return profit;\\n}\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3437135,
                "title": "c-easy-to-understand-recursion-memoization-tabulation-space-optimization",
                "content": "\\u27A1\\uFE0F Recursion\\n```\\n     int solve(vector<int>& prices,int index,int buy){\\n        if(index==prices.size()) return 0;\\n        int profit=0;\\n        if(buy){\\n            int buykaro=(-prices[index])+solve(prices,index+1,0);\\n            int skipkaro= 0 + solve(prices,index+1,1);\\n            profit=max(buykaro,skipkaro);\\n        }else{\\n            int sellkaro=(prices[index])+solve(prices,index+1,1);\\n            int skipkaro= 0 + solve(prices,index+1,0);\\n            profit=max(sellkaro,skipkaro);\\n        }\\n        return profit;\\n    }\\n\\tint maxProfit(vector<int>& prices) {\\n         return solve(prices,0,1);\\n    }\\n```\\n\\u27A1\\uFE0F Memoization\\n\\n```\\n    int solveMem(vector<int>&prices,int index,int buy,vector<vector<int>>&dp){\\n        if(index==prices.size()) return 0;\\n        if(dp[index][buy]!=-1) return dp[index][buy];\\n        int profit=0;\\n        if(buy){\\n            int buykaro=(-prices[index])+solveMem(prices,index+1,0,dp);\\n            int skipkaro= 0 + solveMem(prices,index+1,1,dp);\\n            profit=max(buykaro,skipkaro);\\n        }else{\\n            int sellkaro=(prices[index])+solveMem(prices,index+1,1,dp);\\n            int skipkaro= 0 + solveMem(prices,index+1,0,dp);\\n            profit=max(sellkaro,skipkaro);\\n        }\\n        return dp[index][buy]=profit;\\n    }\\n\\tint maxProfit(vector<int>& prices) {\\n         int n=prices.size();\\n         vector<vector<int>>dp(n,vector<int>(2,-1));\\n         return solveMem(prices,0,1,dp);\\n    }\\n```\\n\\u27A1\\uFE0F Tabulation\\n\\n```\\n        int solveTab(vector<int>&prices){\\n        int n=prices.size();\\n        vector<vector<int>>dp(n+1,vector<int>(2,0));\\n        for(int index=n-1;index>=0;index--){\\n            for(int buy=0;buy<=1;buy++){\\n           int profit=0;\\n           if(buy){\\n            int buykaro=(-prices[index])+dp[index+1][0];\\n            int skipkaro= 0 + dp[index+1][1];\\n            profit=max(buykaro,skipkaro);\\n           }else{\\n            int sellkaro=(prices[index])+dp[index+1][1];\\n            int skipkaro= 0 + dp[index+1][0];\\n            profit=max(sellkaro,skipkaro);\\n            }\\n             dp[index][buy]=profit;\\n           }\\n        }\\n        return dp[0][1];\\n    }\\n\\tint maxProfit(vector<int>& prices) {\\n        return solveTab(prices);\\n    }\\n```\\n\\u27A1\\uFE0F Space Optimization\\n\\n```\\nint solveOpt(vector<int>& prices){\\n        int n=prices.size();\\n        vector<int>curr(2,0);\\n        vector<int>next(2,0);\\n        for(int index=n-1;index>=0;index--){\\n            for(int buy=0;buy<=1;buy++){\\n           int profit=0;\\n           if(buy){\\n            int buykaro=(-prices[index])+next[0];\\n            int skipkaro= 0 + next[1];\\n            profit=max(buykaro,skipkaro);\\n           }else{\\n            int sellkaro=(prices[index])+next[1];\\n            int skipkaro= 0 + next[0];\\n            profit=max(sellkaro,skipkaro);\\n            }\\n             curr[buy]=profit;\\n           }\\n           next=curr;\\n        }\\n        return next[1];\\n    }\\n\\tint maxProfit(vector<int>& prices) {\\n        return solveOpt(prices);\\n    }\\n```\\n**Don\\'t forget to upvote this post if it has helped you!!!**",
                "solutionTags": [],
                "code": "```\\n     int solve(vector<int>& prices,int index,int buy){\\n        if(index==prices.size()) return 0;\\n        int profit=0;\\n        if(buy){\\n            int buykaro=(-prices[index])+solve(prices,index+1,0);\\n            int skipkaro= 0 + solve(prices,index+1,1);\\n            profit=max(buykaro,skipkaro);\\n        }else{\\n            int sellkaro=(prices[index])+solve(prices,index+1,1);\\n            int skipkaro= 0 + solve(prices,index+1,0);\\n            profit=max(sellkaro,skipkaro);\\n        }\\n        return profit;\\n    }\\n\\tint maxProfit(vector<int>& prices) {\\n         return solve(prices,0,1);\\n    }\\n```\n```\\n    int solveMem(vector<int>&prices,int index,int buy,vector<vector<int>>&dp){\\n        if(index==prices.size()) return 0;\\n        if(dp[index][buy]!=-1) return dp[index][buy];\\n        int profit=0;\\n        if(buy){\\n            int buykaro=(-prices[index])+solveMem(prices,index+1,0,dp);\\n            int skipkaro= 0 + solveMem(prices,index+1,1,dp);\\n            profit=max(buykaro,skipkaro);\\n        }else{\\n            int sellkaro=(prices[index])+solveMem(prices,index+1,1,dp);\\n            int skipkaro= 0 + solveMem(prices,index+1,0,dp);\\n            profit=max(sellkaro,skipkaro);\\n        }\\n        return dp[index][buy]=profit;\\n    }\\n\\tint maxProfit(vector<int>& prices) {\\n         int n=prices.size();\\n         vector<vector<int>>dp(n,vector<int>(2,-1));\\n         return solveMem(prices,0,1,dp);\\n    }\\n```\n```\\n        int solveTab(vector<int>&prices){\\n        int n=prices.size();\\n        vector<vector<int>>dp(n+1,vector<int>(2,0));\\n        for(int index=n-1;index>=0;index--){\\n            for(int buy=0;buy<=1;buy++){\\n           int profit=0;\\n           if(buy){\\n            int buykaro=(-prices[index])+dp[index+1][0];\\n            int skipkaro= 0 + dp[index+1][1];\\n            profit=max(buykaro,skipkaro);\\n           }else{\\n            int sellkaro=(prices[index])+dp[index+1][1];\\n            int skipkaro= 0 + dp[index+1][0];\\n            profit=max(sellkaro,skipkaro);\\n            }\\n             dp[index][buy]=profit;\\n           }\\n        }\\n        return dp[0][1];\\n    }\\n\\tint maxProfit(vector<int>& prices) {\\n        return solveTab(prices);\\n    }\\n```\n```\\nint solveOpt(vector<int>& prices){\\n        int n=prices.size();\\n        vector<int>curr(2,0);\\n        vector<int>next(2,0);\\n        for(int index=n-1;index>=0;index--){\\n            for(int buy=0;buy<=1;buy++){\\n           int profit=0;\\n           if(buy){\\n            int buykaro=(-prices[index])+next[0];\\n            int skipkaro= 0 + next[1];\\n            profit=max(buykaro,skipkaro);\\n           }else{\\n            int sellkaro=(prices[index])+next[1];\\n            int skipkaro= 0 + next[0];\\n            profit=max(sellkaro,skipkaro);\\n            }\\n             curr[buy]=profit;\\n           }\\n           next=curr;\\n        }\\n        return next[1];\\n    }\\n\\tint maxProfit(vector<int>& prices) {\\n        return solveOpt(prices);\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3258316,
                "title": "best-3-lines-of-code-easiest-solution-in-o-n",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity: O(n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int maxProfit(int[] prices) {\\n        int maxprofit = 0;\\n        for (int i = 1; i < prices.length; i++) {\\n            if (prices[i] > prices[i - 1])\\n                maxprofit += prices[i] - prices[i - 1];\\n        } return maxprofit;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int maxProfit(int[] prices) {\\n        int maxprofit = 0;\\n        for (int i = 1; i < prices.length; i++) {\\n            if (prices[i] > prices[i - 1])\\n                maxprofit += prices[i] - prices[i - 1];\\n        } return maxprofit;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2040292,
                "title": "o-n-time-beats-99-97-memory-speed-0ms-may-2022",
                "content": "```\\n```\\n\\n(Note: This is part of a series of Leetcode solution explanations. If you like this solution or find it useful, ***please upvote*** this post.)\\n***Take care brother, peace, love!***\\n\\n```\\n```\\n\\n```\\n```\\n\\n```\\n```\\n\\nThe best result for the code below is ***0ms / 38.2MB*** (beats 92.04% / 24.00%).\\n* ***Java***\\n```\\nclass Solution {\\n    public int maxProfit(int[] prices) {\\n        int n = prices.length;\\n        int[] dp = new int[n];\\n        dp[0]=0;\\n        for(int i=1;i<n;i++){\\n            dp[i] = dp[i-1] + Math.max(0,prices[i]-prices[i-1]);\\n        }\\n        return dp[n-1];\\n    }\\n}\\n```\\n\\n```\\n```\\n\\n```\\n```\\n\\nThe best result for the code below is ***0ms / 7.0MB*** (beats 100.00% / 100.00%).\\n* ***C++***\\n```\\n\\n\\nclass Solution {\\npublic:\\n    int maxProfit(vector<int>& prices) {\\n        \\n        auto [_, finalNotHold] = trade( prices.size()-1, prices );\\n        \\n        // Max profit must come from notHold state finally.\\n        return finalNotHold;\\n    }\\n    \\n    tuple<int, int> trade(int day, vector<int>& prices){\\n        \\n        if( day == 0 ){\\n            \\n            // Hold on day_0 = buy at day_#0 = -prices[0]\\n            // Not hold on day_0 = do nothing = 0            \\n            return tuple<int, int>{ -prices[0], 0};\\n        }\\n        \\n        auto [prevHold, prevNotHold] = trade( day - 1, prices );\\n        \\n        // either keep hold, or buy in stock today at stock price\\n        int curHold = max( prevHold, prevNotHold - prices[ day ] );\\n\\n        // either keep not-hold, or sell out stock today at stock price\\n        int curNotHold = max( prevNotHold, prevHold + prices[ day ] );        \\n        \\n        return tuple<int, int>{ curHold, curNotHold};\\n    }\\n};\\n```\\n\\n```\\n```\\n\\n```\\n```\\n\\n\\nThe best result for the code below is ***26ms / 12.2MB*** (beats 95.42% / 82.32%).\\n* ***Python***\\n```\\nclass Solution:\\n    def maxProfit(self, prices: List[int]) -> int:\\n        \\n        @cache\\n        def trade(day_d):\\n            \\n            if day_d == 0:\\n                \\n                # Hold on day_#0 = buy stock at the price of day_#0\\n                # Not-hold on day_#0 = doing nothing on day_#0\\n                return -prices[day_d], 0\\n            \\n            prev_hold, prev_not_hold = trade(day_d-1)\\n            \\n            hold = max(prev_hold, prev_not_hold - prices[day_d] )\\n            not_hold = max(prev_not_hold, prev_hold + prices[day_d] )\\n            \\n            return hold, not_hold\\n        \\n        # --------------------------------------------------\\n        last_day= len(prices)-1\\n        \\n        # Max profit must come from not_hold state (i.e., no stock position) on last day\\n        return trade(last_day)[1]\\n```\\n\\n```\\n```\\n\\n```\\n```\\n\\nThe best result for the code below is ***51ms / 34.2MB*** (beats 100.00% / 84.12%).\\n* ***JavaScript***\\n```\\nvar maxProfit = function (prices) {\\n    let profit = 0;\\n\\n    for (let i = 1; i < prices.length; i++) {\\n        let prev = prices[i - 1];\\n        let current = prices[i];\\n\\n        if (prev < current) {\\n            profit += current - prev;\\n        }\\n    }\\n    \\n    return profit;\\n};\\n```\\n\\n```\\n```\\n\\n```\\n```\\n\\nThe best result for the code below is ***68ms / 44.2MB*** (beats 100.00% / 45.25%).\\n* ***Kotlin***\\n```\\nfun maxProfit(prices: IntArray): Int {\\n        var localMin = -1\\n        var localMax = -1\\n        var result = 0\\n        \\n        prices.forEach{\\n            if(localMin == -1 || (localMax == -1 && it < localMin)){\\n                localMin = it\\n            } else if(it > localMax){\\n                localMax = it\\n            } else {\\n                result += localMax - localMin\\n                localMin = it\\n                localMax = -1\\n            }\\n        }\\n        \\n        if(localMax > 0){\\n            result += localMax - localMin\\n        }\\n        \\n        return result\\n    }\\n```\\n\\n```\\n```\\n\\n```\\n```\\n\\nThe best result for the code below is ***12ms / 32.2MB*** (beats 95% / 84%).\\n* ***Swift***\\n```\\nclass Solution {\\n    func maxProfit(_ prices: [Int]) -> Int {\\n        var maxProfit = 0\\n        \\n        for i in prices.indices.dropFirst() { \\n            let priceChange = prices[i] - prices[i-1]\\n            if priceChange > 0 { \\n                maxProfit += priceChange\\n            }\\n        }\\n        return maxProfit\\n    }\\n}\\n```\\n\\n```\\n```\\n\\n```\\n```\\n\\n***\"Open your eyes. Expect us.\" - \\uD835\\uDCD0\\uD835\\uDCF7\\uD835\\uDCF8\\uD835\\uDCF7\\uD835\\uDD02\\uD835\\uDCF6\\uD835\\uDCF8\\uD835\\uDCFE\\uD835\\uDCFC***",
                "solutionTags": [
                    "C++",
                    "Java",
                    "Python",
                    "Python3",
                    "C",
                    "JavaScript",
                    "Swift",
                    "Kotlin"
                ],
                "code": "```\\n```\n```\\n```\n```\\n```\n```\\n```\n```\\nclass Solution {\\n    public int maxProfit(int[] prices) {\\n        int n = prices.length;\\n        int[] dp = new int[n];\\n        dp[0]=0;\\n        for(int i=1;i<n;i++){\\n            dp[i] = dp[i-1] + Math.max(0,prices[i]-prices[i-1]);\\n        }\\n        return dp[n-1];\\n    }\\n}\\n```\n```\\n```\n```\\n```\n```\\n\\n\\nclass Solution {\\npublic:\\n    int maxProfit(vector<int>& prices) {\\n        \\n        auto [_, finalNotHold] = trade( prices.size()-1, prices );\\n        \\n        // Max profit must come from notHold state finally.\\n        return finalNotHold;\\n    }\\n    \\n    tuple<int, int> trade(int day, vector<int>& prices){\\n        \\n        if( day == 0 ){\\n            \\n            // Hold on day_0 = buy at day_#0 = -prices[0]\\n            // Not hold on day_0 = do nothing = 0            \\n            return tuple<int, int>{ -prices[0], 0};\\n        }\\n        \\n        auto [prevHold, prevNotHold] = trade( day - 1, prices );\\n        \\n        // either keep hold, or buy in stock today at stock price\\n        int curHold = max( prevHold, prevNotHold - prices[ day ] );\\n\\n        // either keep not-hold, or sell out stock today at stock price\\n        int curNotHold = max( prevNotHold, prevHold + prices[ day ] );        \\n        \\n        return tuple<int, int>{ curHold, curNotHold};\\n    }\\n};\\n```\n```\\n```\n```\\n```\n```\\nclass Solution:\\n    def maxProfit(self, prices: List[int]) -> int:\\n        \\n        @cache\\n        def trade(day_d):\\n            \\n            if day_d == 0:\\n                \\n                # Hold on day_#0 = buy stock at the price of day_#0\\n                # Not-hold on day_#0 = doing nothing on day_#0\\n                return -prices[day_d], 0\\n            \\n            prev_hold, prev_not_hold = trade(day_d-1)\\n            \\n            hold = max(prev_hold, prev_not_hold - prices[day_d] )\\n            not_hold = max(prev_not_hold, prev_hold + prices[day_d] )\\n            \\n            return hold, not_hold\\n        \\n        # --------------------------------------------------\\n        last_day= len(prices)-1\\n        \\n        # Max profit must come from not_hold state (i.e., no stock position) on last day\\n        return trade(last_day)[1]\\n```\n```\\n```\n```\\n```\n```\\nvar maxProfit = function (prices) {\\n    let profit = 0;\\n\\n    for (let i = 1; i < prices.length; i++) {\\n        let prev = prices[i - 1];\\n        let current = prices[i];\\n\\n        if (prev < current) {\\n            profit += current - prev;\\n        }\\n    }\\n    \\n    return profit;\\n};\\n```\n```\\n```\n```\\n```\n```\\nfun maxProfit(prices: IntArray): Int {\\n        var localMin = -1\\n        var localMax = -1\\n        var result = 0\\n        \\n        prices.forEach{\\n            if(localMin == -1 || (localMax == -1 && it < localMin)){\\n                localMin = it\\n            } else if(it > localMax){\\n                localMax = it\\n            } else {\\n                result += localMax - localMin\\n                localMin = it\\n                localMax = -1\\n            }\\n        }\\n        \\n        if(localMax > 0){\\n            result += localMax - localMin\\n        }\\n        \\n        return result\\n    }\\n```\n```\\n```\n```\\n```\n```\\nclass Solution {\\n    func maxProfit(_ prices: [Int]) -> Int {\\n        var maxProfit = 0\\n        \\n        for i in prices.indices.dropFirst() { \\n            let priceChange = prices[i] - prices[i-1]\\n            if priceChange > 0 { \\n                maxProfit += priceChange\\n            }\\n        }\\n        return maxProfit\\n    }\\n}\\n```\n```\\n```\n```\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1326823,
                "title": "complete-explanation-of-the-buy-and-sell-stock-problems-using-dp",
                "content": "I will be going over what I have learned while trying to solve these problems. I was initially using `Kadane\\'s algorithm` to do these problems. Infact, completed the first, second, and third **Buy and Sell Stock problems** using Kadane\\'s but the fourth problem gave me a concussion so, I embarked on a journey to learn a framework using which I can solve the complete set of these problems and handle any tweaks that an interviewer might throw at me in the future. I visited a number of resources, watched a number of videos and here is the culmination of everything I have picked so far.\\n\\nThese are all the problems we have in the Buy and Sell Stock set.\\n1. [Best Time to Buy and Sell Stock](https://leetcode.com/problems/best-time-to-buy-and-sell-stock/)\\n2. [Best Time to Buy and Sell Stock II](https://leetcode.com/problems/best-time-to-buy-and-sell-stock-ii/)\\n3. [Best Time to Buy and Sell Stock III](https://leetcode.com/problems/best-time-to-buy-and-sell-stock-iii/)\\n4. [Best Time to Buy and Sell Stock IV](https://leetcode.com/problems/best-time-to-buy-and-sell-stock-iv/)\\n5. [Best Time to Buy and Sell Stock with Cooldown](https://leetcode.com/problems/best-time-to-buy-and-sell-stock-with-cooldown/)\\n6. [Best Time to Buy and Sell Stock with Transaction Fee](https://leetcode.com/problems/best-time-to-buy-and-sell-stock-with-transaction-fee/)\\n\\nFirst, we will see how we can come up with a framework which we can apply for all the above problems. A framework which is flexible enough to accomodate any tweaks an interviewer might throw at us in the future. *A framework which exhausts all the possible outcomes and then come up with the best solution*. A recursive solution would be exhaustive but we will use \"states\" for exhaustion in these problems. **We will consider each day and see how many possible \"states\" do we have for each day and then find \"choices\" corresponding to each state.**\\n\\n**Let\\'s talk about the constraints first.**\\n1. `Sell` must be after `Buy`.\\n2. `Buy` must be after `Sell`.\\n3.  Limit on the number of transaction(k), `k>0`.\\n\\n**For each day we have three choices.**\\n1. `Buy`.\\n2. `Sell`.\\n3. `Rest`. Which further has two states.\\n\\t a. `Rest after buy`. Here we are holding the stock. We are not selling or buying. We are just resting.\\n\\t b. `Rest after selling`. Here we are not holding any stocks. We are not selling or buying. We are just resting.\\n\\n**Let\\'s talk about the states now.**\\n1. The day we are on i.e `i`.\\n2. The maximum number of allowed transactions i.e `k`.\\n3. The holding state i.e the resting state we talked about before. This is either `1(holding stock)` or `0(not holding stock)`.\\n\\nNow, we can put all the combinations of these states in a 3D matrix like so :\\n\\n```\\nfor 0 <= i <= n:             // n is the number of days\\n\\tfor i <= k <= k:        // k is the maximum number of transactions\\n\\t\\tfor s in {1,0}:    // s is the rest state\\n\\t\\t\\t\\tdp[i][k][s] = max(buy,sell,rest)\\n```\\n\\n\\n***For every problem we have to find the `dp[n-1][k][0]`, which is the maximum profit for the maximum number of transactions allowed on the last day.***\\n\\nOne important observation. Why didn\\'t we say **`dp[n-1][k][1]`** instead of saying **`dp[n-1][k][0]`**? because if the resting state `S` is 1, it means we are still holding a stock and the profit cannot be maximum until and unless we are done selling all the stocks we have.\\n\\n\\n\\n\\nNow, let\\'s think about what choices do we have for each state and how we can update the \"state\". Let\\'s write our state transition equations. They will be something like this.\\n\\n`dp[i][k][0] = Max(dp[i-1][k][0], dp[i-1][k][1] + prices[i]) // prices is the array of stocks`\\n\\n***This equation corresponds to when you are not holding a stock. You are not holding a stock today because perhaps you didn\\'t have any stocks yesterday which we could sell today or maybe you have stocks that you want to sell today, so at the end of the day we will not be holding any stocks.***\\n\\n`dp[i][k][1] = Max(dp[i-1][k][1], dp[i-1][k-1][0] - prices[i])`\\n\\n***This equation corresponds to when you are holding a stock. You are holding a stock today because perhaps you had stocks yesterday or maybe you want to buy stocks today, so at the end of the day we will be holding stocks.***\\n\\n***This explanation should be clear. If you buy, you need to subtract prices[i] from the profit, and if you sell, you need to increase prices[i] to the profit.***\\n\\n\\nNow, let\\'s talk about the base cases.\\n\\n1. `dp[-1][k][0]  = 0`     **// Because the day starts with 0 and here i is -1**\\n2. `dp[-1][k][1] = -Infinity`  **// Because we can\\'t hold any stocks before the first day**\\n3. `dp[i][0][0] = 0`  **// Because k = 0. There won\\'t be any transactions so the profit will be zero** \\n4. `dp[i][0][1] = -Infinity`  **// Because k = 0. We can\\'t hold any stocks without starting a transaction** \\n\\n\\nSo, to summarize the above base conditions and state transition equations\\n\\n```\\nbase case\\uFF1A\\ndp[-1][k][0] = dp[i][0][0] = 0\\ndp[-1][k][1] = dp[i][0][1] = -infinity\\n\\nstate transition equation\\uFF1A\\ndp[i][k][0] = max(dp[i-1][k][0], dp[i-1][k][1] + prices[i])\\ndp[i][k][1] = max(dp[i-1][k][1], dp[i-1][k-1][0] - prices[i])\\n```\\n\\n\\nNow, let\\'s begin with the problems.\\n\\n1. ***When k = 1***\\n\\nWe will put k = 1 directly in the state transition equations and see for ourselves.\\n\\n```\\ndp[i][1][0] = Max(dp[i-1][1][0], dp[i-1][1][1] + prices[i];\\ndp[i][1][1] = Max(dp[i-1][1][1], dp[i-1][0][0] - prices[i];\\n\\t        = Max(dp[i-1][1][1], 0 - prices[i];  // from the above base case when k is 0\\n```\\n\\nWe can also see that the presence of k when it is 1 does not change the state in any way so, we can simply ignore it.\\n\\n```\\ndp[i][0] = max(dp[i-1][0], dp[i-1][1] + prices[i])\\ndp[i][1] = max(dp[i-1][1], -prices[i])\\n```\\n\\nWe can write the solution for it like so:\\n\\n```\\nvar maxProfit = function(prices){\\n  let n = prices.length;\\n  let dp = [];\\n  \\n  for(let i=0; i<n; i++){\\n    dp[i] = [];\\n    if(i-1 === -1){\\n      dp[i][0] = 0; \\n        // Explanation\\uFF1A\\n        //   dp[i][0] \\n        // = max(dp[-1][0], dp[-1][1] + prices[i])\\n        // = max(0, -infinity + prices[i]) = 0\\n      dp[i][1] = -prices[i];\\n        // Explanation\\uFF1A\\n        //   dp[i][1] \\n        // = max(dp[-1][1], dp[-1][0] - prices[i])\\n        // = max(-infinity, 0 - prices[i]) \\n        // = -prices[i]\\n      continue;\\n    }\\n    dp[i][0] = Math.max(dp[i-1][0], dp[i-1][1] + prices[i]);\\n    dp[i][1] = Math.max(dp[i-1][1],  -prices[i])\\n  }\\n  return dp[n-1][0];\\n}\\n```\\n\\n***We can reduce the Space complexity to 0(1) by not constructing the DP matrix as the new state is only related to an adjacent state. So, instead of the DP matrix we can store the states in a single variable. One variable for not holding and one for holding.***\\n\\nCode for that would look something like :\\n\\n```\\nvar maxProfit = function(prices){\\n  let d_i10 = 0;\\n  let d_i11 = -Infinity;\\n  \\n  for(let i=0; i<prices.length;i++){\\n    d_i10 = Math.max(d_i10, d_i11 + prices[i]);\\n    d_i11 = Math.max(d_i11, 0 - prices[i]);\\n  }\\n  return d_i10;\\n}\\n```\\n\\n2. ***When k = + Infinity***\\n\\nWhen k is Infinity, k and k-1 are practically the same. We will use that in our state transition equations.\\n\\n\\n```\\ndp[i][k][0] = max(dp[i-1][k][0], dp[i-1][k][1] + prices[i])\\ndp[i][k][1] = max(dp[i-1][k][1], dp[i-1][k-1][0] - prices[i])\\n            = max(dp[i-1][k][1], dp[i-1][k][0] - prices[i]) // k and k-1 are the same\\n```\\n\\nSince, the presence of k is not really impacting the states, we will ignore it.\\n\\n```\\ndp[i][0] = max(dp[i-1][0], dp[i-1][1] + prices[i])\\ndp[i][1] = max(dp[i-1][1], dp[i-1][0] - prices[i])\\n```\\n\\nAnd the solution would look like this : \\n\\n```\\nvar maxProfit = function(prices){\\n  let d_ik0 = 0;\\n  let d_ik1 = -Infinity;\\n  \\n  for(let i=0;i<prices.length;i++){\\n    d_ik0 = Math.max(d_ik0 , d_ik1 + prices[i]);\\n    d_ik1 = Math.max(d_ik1, d_ik0 - prices[i]);\\n  }\\n  return d_ik0;\\n}\\n```\\n\\n\\n3. ***When k = 2***\\n\\nNow, we need to exhaust the value of k as well. Before this we were ignoring k because it was not impacting our states. We need to hold the states for the second transaction as well along with the first transaction. \\n\\n```\\ndp[i][2][0] = max(dp[i-1][2][0], dp[i-1][2][1] + prices[i])\\ndp[i][2][1] = max(dp[i-1][2][1], dp[i-1][1][0] - prices[i])\\ndp[i][1][0] = max(dp[i-1][1][0], dp[i-1][1][1] + prices[i])\\ndp[i][1][1] = max(dp[i-1][1][1], -prices[i])\\n```\\n\\nThe solution would look like this :\\n\\n```\\nvar maxProfit = function(prices){\\n  let d_i20 = 0;\\n  let d_i21 = -Infinity; // base case for second transaction\\n  let d_i10 = 0;\\n  let d_i11 = -Infinity; //base case for second transaction\\n  \\n  for(let i=0; i<prices.length; i++){\\n    d_i10 = Math.max(d_i10, d_i11 + prices[i]);\\n    d_i11 = Math.max(d_i11,  0 - prices[i]);\\n    d_i20 = Math.max(d_i20, d_i21 + prices[i]);\\n    d_i21 = Math.max(d_i21, d_i10 - prices[i]);\\n   \\n  }\\n  return d_i20\\n}\\n```\\n\\n\\n4. ***When k = + interger***\\n\\n**Important observation** : A transaction consists of buying and selling, which takes atleast 2 days. Therefore, the effective limit k should not exceed n/2( n is the number of days). If it exceeds, there is no contraint effect which makes k equivalent to +Infinity.\\n\\nThis is the only problem from this set which is a little difficult.\\n\\nSolution would look like this \\n```\\nvar maxProfit = function(k, prices) {\\n    if(prices.length == 0) return 0;\\n    \\n    // When k becomes so much larger than the number of prices we can make transactions whenever.\\n    if(k > (prices.length / 2) ){\\n      let d_ik0 = 0;\\n      let d_ik1 =  -Infinity;\\n      for(let i =0; i<prices.length;i++){\\n        d_ik0 = Math.max(d_ik0, d_ik1 + prices[i]);\\n        d_ik1 = Math.max(d_ik1, d_ik0 - prices[i]);\\n      }\\n      return d_ik0\\n    }\\n    else{\\n        let dp = [];\\n        let size = prices.length;\\n        for(let i=0; i<size; i++){\\n          dp[i] = [];\\n          for(let j=0; j<=k; j++){\\n            dp[i][j] = []\\n            if(i-1 === -1 || j-1 === -1){\\n              dp[i][j][0] = 0;\\n              dp[i][j][1] = -prices[i];\\n              continue;\\n            }\\n            dp[i][j][0] = Math.max(dp[i-1][j][0], dp[i-1][j][1] + prices[i]);\\n            dp[i][j][1] = Math.max(dp[i-1][j][1], dp[i-1][j-1][0] - prices[i])\\n          }\\n        }\\n      return dp[size-1][k][0]\\n    }\\n};\\n```\\n\\n5. ***When k = +Infinity with cooldown***\\n\\nWe must wait one day after selling a stock to continue trading. We can write the state transition equations as :\\n\\n```\\ndp[i][0] = max(dp[i-1][0], dp[i-1][1] + prices[i])\\ndp[i][1] = max(dp[i-1][1], dp[i-2][0] - prices[i])\\nExplanation: When we choose to buy on day i, the state of i-2 should be transferred instead of i-1\\n```\\n\\nCode would look like \\n\\n```\\nvar maxProfit = function(prices){\\n  let d_ik0 = 0;\\n  let d_ik1 = -Infinity;\\n  let d_ik0_pre = 0;\\n  \\n  for(let i=0;i<prices.length;i++){\\n    let d_ik0_old = d_ik0; \\n    d_ik0 = Math.max(d_ik0 , d_ik1 + prices[i]);\\n    d_ik1 = Math.max(d_ik1, d_ik0_pre - prices[i]);\\n    d_ik0_pre = d_ik0_old;\\n  }\\n  return d_ik0;\\n}\\n```\\n\\n\\n\\n6. ***When k = +Infinity with transaction fee***\\n\\nSince now we need to pay some fee for each transaction made, the profit after buying or selling the stock on the i-th day should be subtracted by this amount, therefore the new recurrence relations will be either\\n\\n```\\ndp[i][k][0] = max(dp[i-1][k][0], dp[i-1][k][1] + prices[i])\\ndp[i][k][1] = max(dp[i-1][k][1], dp[i-1][k][0] - prices[i] - fee)\\n\\nor\\n\\ndp[i][k][0] = max(dp[i-1][k][0], dp[i-1][k][1] + prices[i] - fee)\\ndp[i][k][1] = max(dp[i-1][k][1], dp[i-1][k][0] - prices[i])\\n```\\n\\nCode can we written as  :\\n\\n```\\nvar maxProfit = function(prices, fee){\\n  let d_ik0 = 0;\\n  let d_ik1 = -Infinity;\\n  \\n  for(let i=0;i<prices.length;i++){\\n    d_ik0 = Math.max(d_ik0 , d_ik1 + prices[i]);\\n    d_ik1 = Math.max(d_ik1, d_ik0 - prices[i] - fee);\\n  }\\n  return d_ik0;\\n}\\n```\\n\\n\\nI hope you enjoyed this post.",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\nfor 0 <= i <= n:             // n is the number of days\\n\\tfor i <= k <= k:        // k is the maximum number of transactions\\n\\t\\tfor s in {1,0}:    // s is the rest state\\n\\t\\t\\t\\tdp[i][k][s] = max(buy,sell,rest)\\n```\n```\\nbase case\\uFF1A\\ndp[-1][k][0] = dp[i][0][0] = 0\\ndp[-1][k][1] = dp[i][0][1] = -infinity\\n\\nstate transition equation\\uFF1A\\ndp[i][k][0] = max(dp[i-1][k][0], dp[i-1][k][1] + prices[i])\\ndp[i][k][1] = max(dp[i-1][k][1], dp[i-1][k-1][0] - prices[i])\\n```\n```\\ndp[i][1][0] = Max(dp[i-1][1][0], dp[i-1][1][1] + prices[i];\\ndp[i][1][1] = Max(dp[i-1][1][1], dp[i-1][0][0] - prices[i];\\n\\t        = Max(dp[i-1][1][1], 0 - prices[i];  // from the above base case when k is 0\\n```\n```\\ndp[i][0] = max(dp[i-1][0], dp[i-1][1] + prices[i])\\ndp[i][1] = max(dp[i-1][1], -prices[i])\\n```\n```\\nvar maxProfit = function(prices){\\n  let n = prices.length;\\n  let dp = [];\\n  \\n  for(let i=0; i<n; i++){\\n    dp[i] = [];\\n    if(i-1 === -1){\\n      dp[i][0] = 0; \\n        // Explanation\\uFF1A\\n        //   dp[i][0] \\n        // = max(dp[-1][0], dp[-1][1] + prices[i])\\n        // = max(0, -infinity + prices[i]) = 0\\n      dp[i][1] = -prices[i];\\n        // Explanation\\uFF1A\\n        //   dp[i][1] \\n        // = max(dp[-1][1], dp[-1][0] - prices[i])\\n        // = max(-infinity, 0 - prices[i]) \\n        // = -prices[i]\\n      continue;\\n    }\\n    dp[i][0] = Math.max(dp[i-1][0], dp[i-1][1] + prices[i]);\\n    dp[i][1] = Math.max(dp[i-1][1],  -prices[i])\\n  }\\n  return dp[n-1][0];\\n}\\n```\n```\\nvar maxProfit = function(prices){\\n  let d_i10 = 0;\\n  let d_i11 = -Infinity;\\n  \\n  for(let i=0; i<prices.length;i++){\\n    d_i10 = Math.max(d_i10, d_i11 + prices[i]);\\n    d_i11 = Math.max(d_i11, 0 - prices[i]);\\n  }\\n  return d_i10;\\n}\\n```\n```\\ndp[i][k][0] = max(dp[i-1][k][0], dp[i-1][k][1] + prices[i])\\ndp[i][k][1] = max(dp[i-1][k][1], dp[i-1][k-1][0] - prices[i])\\n            = max(dp[i-1][k][1], dp[i-1][k][0] - prices[i]) // k and k-1 are the same\\n```\n```\\ndp[i][0] = max(dp[i-1][0], dp[i-1][1] + prices[i])\\ndp[i][1] = max(dp[i-1][1], dp[i-1][0] - prices[i])\\n```\n```\\nvar maxProfit = function(prices){\\n  let d_ik0 = 0;\\n  let d_ik1 = -Infinity;\\n  \\n  for(let i=0;i<prices.length;i++){\\n    d_ik0 = Math.max(d_ik0 , d_ik1 + prices[i]);\\n    d_ik1 = Math.max(d_ik1, d_ik0 - prices[i]);\\n  }\\n  return d_ik0;\\n}\\n```\n```\\ndp[i][2][0] = max(dp[i-1][2][0], dp[i-1][2][1] + prices[i])\\ndp[i][2][1] = max(dp[i-1][2][1], dp[i-1][1][0] - prices[i])\\ndp[i][1][0] = max(dp[i-1][1][0], dp[i-1][1][1] + prices[i])\\ndp[i][1][1] = max(dp[i-1][1][1], -prices[i])\\n```\n```\\nvar maxProfit = function(prices){\\n  let d_i20 = 0;\\n  let d_i21 = -Infinity; // base case for second transaction\\n  let d_i10 = 0;\\n  let d_i11 = -Infinity; //base case for second transaction\\n  \\n  for(let i=0; i<prices.length; i++){\\n    d_i10 = Math.max(d_i10, d_i11 + prices[i]);\\n    d_i11 = Math.max(d_i11,  0 - prices[i]);\\n    d_i20 = Math.max(d_i20, d_i21 + prices[i]);\\n    d_i21 = Math.max(d_i21, d_i10 - prices[i]);\\n   \\n  }\\n  return d_i20\\n}\\n```\n```\\nvar maxProfit = function(k, prices) {\\n    if(prices.length == 0) return 0;\\n    \\n    // When k becomes so much larger than the number of prices we can make transactions whenever.\\n    if(k > (prices.length / 2) ){\\n      let d_ik0 = 0;\\n      let d_ik1 =  -Infinity;\\n      for(let i =0; i<prices.length;i++){\\n        d_ik0 = Math.max(d_ik0, d_ik1 + prices[i]);\\n        d_ik1 = Math.max(d_ik1, d_ik0 - prices[i]);\\n      }\\n      return d_ik0\\n    }\\n    else{\\n        let dp = [];\\n        let size = prices.length;\\n        for(let i=0; i<size; i++){\\n          dp[i] = [];\\n          for(let j=0; j<=k; j++){\\n            dp[i][j] = []\\n            if(i-1 === -1 || j-1 === -1){\\n              dp[i][j][0] = 0;\\n              dp[i][j][1] = -prices[i];\\n              continue;\\n            }\\n            dp[i][j][0] = Math.max(dp[i-1][j][0], dp[i-1][j][1] + prices[i]);\\n            dp[i][j][1] = Math.max(dp[i-1][j][1], dp[i-1][j-1][0] - prices[i])\\n          }\\n        }\\n      return dp[size-1][k][0]\\n    }\\n};\\n```\n```\\ndp[i][0] = max(dp[i-1][0], dp[i-1][1] + prices[i])\\ndp[i][1] = max(dp[i-1][1], dp[i-2][0] - prices[i])\\nExplanation: When we choose to buy on day i, the state of i-2 should be transferred instead of i-1\\n```\n```\\nvar maxProfit = function(prices){\\n  let d_ik0 = 0;\\n  let d_ik1 = -Infinity;\\n  let d_ik0_pre = 0;\\n  \\n  for(let i=0;i<prices.length;i++){\\n    let d_ik0_old = d_ik0; \\n    d_ik0 = Math.max(d_ik0 , d_ik1 + prices[i]);\\n    d_ik1 = Math.max(d_ik1, d_ik0_pre - prices[i]);\\n    d_ik0_pre = d_ik0_old;\\n  }\\n  return d_ik0;\\n}\\n```\n```\\ndp[i][k][0] = max(dp[i-1][k][0], dp[i-1][k][1] + prices[i])\\ndp[i][k][1] = max(dp[i-1][k][1], dp[i-1][k][0] - prices[i] - fee)\\n\\nor\\n\\ndp[i][k][0] = max(dp[i-1][k][0], dp[i-1][k][1] + prices[i] - fee)\\ndp[i][k][1] = max(dp[i-1][k][1], dp[i-1][k][0] - prices[i])\\n```\n```\\nvar maxProfit = function(prices, fee){\\n  let d_ik0 = 0;\\n  let d_ik1 = -Infinity;\\n  \\n  for(let i=0;i<prices.length;i++){\\n    d_ik0 = Math.max(d_ik0 , d_ik1 + prices[i]);\\n    d_ik1 = Math.max(d_ik1, d_ik0 - prices[i] - fee);\\n  }\\n  return d_ik0;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 948090,
                "title": "java-very-simple-solution-with-explaination",
                "content": "For any given day, if the price is greater than the previous day, we sell it. If the price rises consecutively, then the cumulative addition will automatically reflect in the profit.\\nFor example, 5, 6, 7: The first purchase at 5, and then selling at 7 is equivalent to purchase at 5 and selling at 6, and buying at 6 and again selling at 7. So, 1+1=2 will be the profit. You can take more examples to verify this.\\nNow in case of a dip, we already sold off our stock at the previous high since we use the greedy approach. Now, as the price has dropped, we again consider the latest price as the purchase price to check for profit later. If there is a rise, we sell again. If there is another drop, we didn\\'t buy at the first drop, and are buying at the latest dip.\\n```\\nclass Solution {\\n    public int maxProfit(int[] prices) {\\n        if(prices == null || prices.length < 2) return 0;\\n        int profit = 0;\\n        for(int i = 1; i < prices.length; i++){\\n            if(prices[i-1] < prices[i]){\\n                profit += prices[i] - prices[i-1];\\n            }\\n        }\\n        return profit;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Greedy"
                ],
                "code": "```\\nclass Solution {\\n    public int maxProfit(int[] prices) {\\n        if(prices == null || prices.length < 2) return 0;\\n        int profit = 0;\\n        for(int i = 1; i < prices.length; i++){\\n            if(prices[i-1] < prices[i]){\\n                profit += prices[i] - prices[i-1];\\n            }\\n        }\\n        return profit;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2490167,
                "title": "c-recursion-memoization-tabulation-spaceoptimization",
                "content": "\\n# Method -1 [Recursion]\\n![image](https://assets.leetcode.com/users/images/5c2c132a-e540-4a18-a577-6797fbe4a44e_1661600269.7165196.png)\\n\\n**T->O(2^n) && S->O(n) [Recursion Stack Space]**\\n\\n\\tclass Solution {\\n\\tpublic:\\n\\t\\tint f(int i,int buy,vector<int>& p,int n){\\n\\t\\t\\tif(i==n) return 0;\\n\\t\\t\\tif(buy){\\n\\t\\t\\t\\tint buy=-p[i]+f(i+1,0,p,n);\\n\\t\\t\\t\\tint notbuy=f(i+1,1,p,n);\\n\\t\\t\\t\\treturn max(buy,notbuy);\\n\\t\\t\\t}\\n\\t\\t\\telse{\\n\\t\\t\\t\\tint sell= p[i]+f(i+1,1,p,n);\\n\\t\\t\\t\\tint notsell=f(i+1,0,p,n);\\n\\t\\t\\t\\treturn max(sell,notsell);\\n\\t\\t\\t}\\n\\t\\t}\\n\\n\\t\\tint maxProfit(vector<int>& p){\\n\\t\\t\\tint n=p.size();\\n\\t\\t\\treturn f(0,1,p,n);\\n\\t\\t}\\n\\t};\\n\\t\\n# Method -2 [Memoization]\\t\\n\\n![image](https://assets.leetcode.com/users/images/06275f0c-6fe8-4f3f-b1b0-3b59e3827b04_1661601266.508214.png)\\n\\n**T->O(2 * n) && S->O(2 * n) + O(n) [Recursion Stack Space]**\\n\\n\\tclass Solution {\\n\\tpublic:\\n\\t\\tint f(int i,int buy,vector<int>& p,int n,vector<vector<int>>& dp){\\n\\t\\t\\tif(i==n) return 0;\\n\\t\\t\\tif(dp[i][buy]!=-1) return dp[i][buy];\\n\\t\\t\\tint pro1=INT_MIN,pro2=INT_MIN;\\n\\t\\t\\tif(buy){\\n\\t\\t\\t\\tint buy=-p[i]+f(i+1,0,p,n,dp);\\n\\t\\t\\t\\tint notbuy=f(i+1,1,p,n,dp);\\n\\t\\t\\t\\tpro1=max(buy,notbuy);\\n\\t\\t\\t}\\n\\t\\t\\telse{\\n\\t\\t\\t\\tint sell= p[i]+f(i+1,1,p,n,dp);\\n\\t\\t\\t\\tint notsell=f(i+1,0,p,n,dp);\\n\\t\\t\\t\\tpro2=max(sell,notsell);\\n\\t\\t\\t}\\n\\t\\t\\treturn dp[i][buy]=max(pro1,pro2);\\n\\t\\t}\\n\\n\\t\\tint maxProfit(vector<int>& p){\\n\\t\\t\\tint n=p.size();\\n\\t\\t\\tvector<vector<int>> dp(n,vector<int>(2,-1));\\n\\t\\t\\treturn f(0,1,p,n,dp);\\n\\t\\t}\\n\\t};\\n\\t\\n# Method - 3 [Tabulation]\\n![image](https://assets.leetcode.com/users/images/feae764c-e600-4e17-9bd9-009d414230bf_1661603061.6112258.png)\\n\\n**T->O(2 * n) && S->O(2 * n)**\\n\\n\\tclass Solution {\\n\\tpublic:\\n\\t\\tint maxProfit(vector<int>& p){\\n\\t\\t\\tint n=p.size();\\n\\t\\t\\tvector<vector<int>> dp(n+1,vector<int>(2,0));\\n\\t\\t\\tfor(int i=n-1;i>=0;i--){\\n\\t\\t\\t\\tfor(int buy=0;buy<=1;buy++){\\n\\t\\t\\t\\t\\tint profit;\\n\\t\\t\\t\\t\\tif(buy){\\n\\t\\t\\t\\t\\t\\tint buy=-p[i]+dp[i+1][0];\\n\\t\\t\\t\\t\\t\\tint notbuy=dp[i+1][1];\\n\\t\\t\\t\\t\\t\\tprofit=max(buy,notbuy);\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\telse{\\n\\t\\t\\t\\t\\t\\tint sell= p[i]+dp[i+1][1];\\n\\t\\t\\t\\t\\t\\tint notsell=dp[i+1][0];\\n\\t\\t\\t\\t\\t\\tprofit=max(sell,notsell);\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\tdp[i][buy]=profit;\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t\\treturn dp[0][1];\\n\\t\\t}\\n\\t};\\n\\t\\n# Method  - 4 [SpaceOptimization]\\n\\n![image](https://assets.leetcode.com/users/images/b0b417fe-4d84-4007-a2e6-e413b1277446_1661603341.085726.png)\\n\\n**T->O(2 X n) && S->O(2 X 2)**\\n\\n\\tclass Solution {\\n\\tpublic:\\n\\t\\tint maxProfit(vector<int>& p){\\n\\t\\t\\tint n=p.size();\\n\\t\\t\\tvector<int> prev(2,0),curr(2,0);\\n\\t\\t\\tfor(int i=n-1;i>=0;i--){\\n\\t\\t\\t\\tfor(int buy=0;buy<=1;buy++){\\n\\t\\t\\t\\t\\tint profit;\\n\\t\\t\\t\\t\\tif(buy){\\n\\t\\t\\t\\t\\t\\tint buy=-p[i]+prev[0];\\n\\t\\t\\t\\t\\t\\tint notbuy=prev[1];\\n\\t\\t\\t\\t\\t\\tprofit=max(buy,notbuy);\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\telse{\\n\\t\\t\\t\\t\\t\\tint sell= p[i]+prev[1];\\n\\t\\t\\t\\t\\t\\tint notsell=prev[0];\\n\\t\\t\\t\\t\\t\\tprofit=max(sell,notsell);\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\tcurr[buy]=profit;\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\tprev=curr;\\n\\t\\t\\t}\\n\\t\\t\\treturn prev[1];\\n\\t\\t}\\n\\t};",
                "solutionTags": [
                    "C++",
                    "C",
                    "Dynamic Programming",
                    "Recursion",
                    "Memoization"
                ],
                "code": "class Solution {\\n\\tpublic:\\n\\t\\tint f(int i,int buy,vector<int>& p,int n){\\n\\t\\t\\tif(i==n) return 0;\\n\\t\\t\\tif(buy){\\n\\t\\t\\t\\tint buy=-p[i]+f(i+1,0,p,n);\\n\\t\\t\\t\\tint notbuy=f(i+1,1,p,n);\\n\\t\\t\\t\\treturn max(buy,notbuy);\\n\\t\\t\\t}",
                "codeTag": "Java"
            },
            {
                "id": 1569789,
                "title": "python-oneliner-solution-explained",
                "content": "Let us first evaluate differences between all adjacent pairs. We are allowed to do as much transactions as we need, it can be seen as if we do as many one day buy/sells as we want. We want to have the biggest profit, so we will choose only positive gains.\\n\\n#### Complexity\\nIt is `O(n)` for time and space. Space can be made `O(1)`.\\n\\n#### Code\\n```python\\nclass Solution:\\n    def maxProfit(self, nums):\\n        return sum(max(0, x) for x in (y - x for x, y in zip(nums, nums[1:])))\\n```\\n\\nIf you have any questoins, feel free to ask. If you like the solution and explanation, please **upvote!**\\n\\n",
                "solutionTags": [],
                "code": "```python\\nclass Solution:\\n    def maxProfit(self, nums):\\n        return sum(max(0, x) for x in (y - x for x, y in zip(nums, nums[1:])))\\n```",
                "codeTag": "Java"
            },
            {
                "id": 739723,
                "title": "python-one-liner-top-100-speed",
                "content": "**Python |  Clean Code + One Liner | Top 100% Speed**\\n\\n**A) Clean Code**\\n\\nThe Solution below is based on the idea that we can buy and sell stocks every time we notice a higher price on the next day. We can see how this works by analyzing different cases:\\n\\n1. **Rising Slope a<b<c:** Here, the optimal solution is to buy stock at price \"a\", and sell it at price \"c\". This solution is respected by our algorithm, since we can see that our transactions would be:  (b-a)+(c-b) = c-a\\n2. **Descending Slope a>b>c:** Here, purchasing (a,b) is never a good idea, since price \"c\" is the best buying point for a new transaction. Our algorithm avoids making transactions that buy at prices (a,b).\\n3. **Equal price a=b=c:** Here, buying or selling has no effect whatsoever, so our algorithm saves system resources by avoiding trades.\\n\\n\\n```\\n# A.1: Clearest Logic\\nclass Solution:\\n    def maxProfit(self, prices):\\n        best = 0\\n        for i in range(1,len(prices)):\\n            if prices[i] > prices[i-1]:\\n                best += prices[i] - prices[i-1]\\n        return best\\n```\\n\\n```\\n# A.2: High Performance (less array accessing)\\nclass Solution:\\n    def maxProfit(self, prices):\\n        best = 0\\n        if prices:\\n            a = prices[0] # last price\\n            for b in prices[1:]:\\n                if b>a:\\n                    best += b - a\\n                a = b\\n        return best\\n```\\n\\n**B) One-Liner**\\nThis version has O(n) space complexity, since an array of micro-transactions is created, but it\\'s highly efficient nonetheless.\\n```\\nclass Solution(object):\\n    def maxProfit(self, prices):\\n        return sum([ prices[i]-prices[i-1] for i in range(1,len(prices)) if prices[i]>prices[i-1] ])\\n```",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\n# A.1: Clearest Logic\\nclass Solution:\\n    def maxProfit(self, prices):\\n        best = 0\\n        for i in range(1,len(prices)):\\n            if prices[i] > prices[i-1]:\\n                best += prices[i] - prices[i-1]\\n        return best\\n```\n```\\n# A.2: High Performance (less array accessing)\\nclass Solution:\\n    def maxProfit(self, prices):\\n        best = 0\\n        if prices:\\n            a = prices[0] # last price\\n            for b in prices[1:]:\\n                if b>a:\\n                    best += b - a\\n                a = b\\n        return best\\n```\n```\\nclass Solution(object):\\n    def maxProfit(self, prices):\\n        return sum([ prices[i]-prices[i-1] for i in range(1,len(prices)) if prices[i]>prices[i-1] ])\\n```",
                "codeTag": "Java"
            },
            {
                "id": 39571,
                "title": "my-1-line-python-solution",
                "content": "The logic is pretty straight, we find all peaks and related bottom elements, then sum all peaks minus all bottoms.\\n\\n\\n    class Solution:\\n        # @param prices, a list of integer\\n        # @return an integer\\n        def maxProfit(self, prices):\\n            return sum([y for x, y, z in zip(prices[0:-1], prices[1:], prices[2:] + [prices[-1]]) if y > x and y >= z]) - sum([y for x, y, z in zip([prices[0]] + prices[0:-2], prices[0:-1], prices[1:]) if y <= x and y < z]) if len(prices) > 0 else 0\\n\\n\\nUPDATE:\\n\\nthis version is more clear and simpler.\\n\\n    class Solution:\\n        # @param prices, a list of integer\\n        # @return an integer\\n        def maxProfit(self, prices):\\n            return sum([y - x for x, y in zip(prices[:-1], prices[1:]) if x < y])",
                "solutionTags": [
                    "Python"
                ],
                "code": "The logic is pretty straight, we find all peaks and related bottom elements, then sum all peaks minus all bottoms.\\n\\n\\n    class Solution:\\n        # @param prices, a list of integer\\n        # @return an integer\\n        def maxProfit(self, prices):\\n            return sum([y for x, y, z in zip(prices[0:-1], prices[1:], prices[2:] + [prices[-1]]) if y > x and y >= z]) - sum([y for x, y, z in zip([prices[0]] + prices[0:-2], prices[0:-1], prices[1:]) if y <= x and y < z]) if len(prices) > 0 else 0\\n\\n\\nUPDATE:\\n\\nthis version is more clear and simpler.\\n\\n    class Solution:\\n        # @param prices, a list of integer\\n        # @return an integer\\n        def maxProfit(self, prices):\\n            return sum([y - x for x, y in zip(prices[:-1], prices[1:]) if x < y])",
                "codeTag": "Java"
            },
            {
                "id": 4053621,
                "title": "beginner-friendly-solution-beats-100",
                "content": "\\n```\\nclass Solution {\\n    public int maxProfit(int[] prices) {\\n        int profit = 0;\\n        for(int i=1;i<prices.length;i++) {\\n            if(prices[i] > prices[i-1]) {\\n                profit += prices[i] - prices[i-1];\\n            }\\n        }\\n        return profit;\\n    }\\n}\\n```\\n![1271c6fe-345b-4f3d-959e-d13e791111d7_1677726484.8832572.jpeg](https://assets.leetcode.com/users/images/97c10291-2a91-4cc9-b269-93e1b045825b_1694915509.132186.jpeg)\\n",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int maxProfit(int[] prices) {\\n        int profit = 0;\\n        for(int i=1;i<prices.length;i++) {\\n            if(prices[i] > prices[i-1]) {\\n                profit += prices[i] - prices[i-1];\\n            }\\n        }\\n        return profit;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1932152,
                "title": "100-fastest-swift-solution-time-o-n-space-o-1",
                "content": "```\\nclass Solution {\\n    // - Complexity:\\n    //   - time: O(n), where n is the length of the prices.\\n    //   - space: O(1), only constant space is used.\\n    \\n    func maxProfit(_ prices: [Int]) -> Int {\\n        guard !prices.isEmpty else { return 0 }\\n        \\n        var ans = 0\\n        \\n        for i in 1..<prices.count {\\n            guard prices[i] > prices[i - 1] else { continue }\\n            ans += prices[i] - prices[i - 1]\\n        }\\n        \\n        return ans\\n    }\\n\\n}\\n```\\n\\nLet me know in comments if you have any doubts. I will be happy to answer.\\n\\nPlease upvote if you found the solution useful.",
                "solutionTags": [
                    "Swift"
                ],
                "code": "```\\nclass Solution {\\n    // - Complexity:\\n    //   - time: O(n), where n is the length of the prices.\\n    //   - space: O(1), only constant space is used.\\n    \\n    func maxProfit(_ prices: [Int]) -> Int {\\n        guard !prices.isEmpty else { return 0 }\\n        \\n        var ans = 0\\n        \\n        for i in 1..<prices.count {\\n            guard prices[i] > prices[i - 1] else { continue }\\n            ans += prices[i] - prices[i - 1]\\n        }\\n        \\n        return ans\\n    }\\n\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3109361,
                "title": "c-very-simple-beats-100-one-pass",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nSimply go through the array and check if next day stock price is high than previous add it your answer .Since we have choice that we can buy or sell at the same day immedaitely as well so we can do that for  all the days where this condition holds ,beacuse in this way we are getting all the profit that can be achieved .\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:$$O(N)$$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:$$O(1)$$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int maxProfit(vector<int>& arr) {\\n        int profit=0;\\n        for(int i=0;i<arr.size()-1;i++){\\n            if(arr[i]<arr[i+1])\\n                profit+=(arr[i+1]-arr[i]);\\n        }\\n        return profit;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Array",
                    "Dynamic Programming",
                    "Greedy"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int maxProfit(vector<int>& arr) {\\n        int profit=0;\\n        for(int i=0;i<arr.size()-1;i++){\\n            if(arr[i]<arr[i+1])\\n                profit+=(arr[i+1]-arr[i]);\\n        }\\n        return profit;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2148469,
                "title": "java-solution-easy-to-understand-as-simple-as-it-should-be-o-n",
                "content": "This question may have different approaches, but i am going to explain it in the simplest possible way!!!\\nWe can buy any number of stocks and sell them and also on the same day so, we actually only need to know if the just previous price is lower than the current price, if yes then upgrade the maxProfit , or continue.\\nFor example, if prices=[2,5,1,9,7,8], then,\\nwe will just add the values of (5-2)+(9-1)+(8-7)=3+8+1=12, which is the maximum possible profit, as we have added all possible positive profits...\\nHope this will help you, as I know when explanation is simple to understand sometimes it becomes our motivation...\\n\\n```\\nclass Solution {\\n    public int maxProfit(int[] prices) {\\n        int maxProfit=0;\\n        for(int i=1;i<prices.length;i++){\\n            if(prices[i-1]<prices[i]){\\n                maxProfit+=prices[i]-prices[i-1];\\n            }\\n        }\\n        return maxProfit;\\n    }\\n}\\n```\\nIf you liked my explanation, please upvote...\\n",
                "solutionTags": [
                    "Java",
                    "Array"
                ],
                "code": "```\\nclass Solution {\\n    public int maxProfit(int[] prices) {\\n        int maxProfit=0;\\n        for(int i=1;i<prices.length;i++){\\n            if(prices[i-1]<prices[i]){\\n                maxProfit+=prices[i]-prices[i-1];\\n            }\\n        }\\n        return maxProfit;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1569298,
                "title": "very-easy-to-understand-c-with-explanation-and-examples-with-proof",
                "content": "Thanks in advance for reading.\\n\\nAn Important point to note here in the question is: \"**However, you can buy it then immediately sell it on the same day**.\"\\n\\n\\nso let\\'s see different trends in the prices vector.\\nThe whole prices vector can be divided into segments where each of those segments falls under any one of the below categories.\\nCase 1: it is decreasing (or non-increasing)\\n* Eg : 9 , 5 , 4 , 4, 2 , 1\\n\\n Case 2 : if it is increasing (or non decreasing)\\n*  Eg : 1, 2, 3, 4, 6, 6, 8, 10\\n\\nCase 3: constant (this case can be considered as a part of case 1 or case 2. It doesn\\'t affect the solution). So we don\\'t talk about case 3 separately\\n* Eg : 1, 1, 1, 1, 1, 1\\n\\n\\n# Assumption (let\\'s prove it)\\nNow I propose my assumption that I always sell the stock on (i+1)th day if I buy it on i-th day.\\nAs of now, it\\'s just an assumption. Let\\'s prove it.\\n \\n Case 1:\\n * Eg : 9 , 5 , 4 , 4, 2 , 1\\n Here the best way is not to buy at all. So optimal net profit is zero.\\n So, what if I tell it is equivalent to buy on i-th day  and sell on (i+1)th day if prices[i+1] > prices[i].\\n Since that condition won\\'t be satisfied in this type of segment. Net profit will be zero. \\n (*So Assumption is true for Case 1*)\\n \\n Case 2 :\\n *  Eg : 1, 2, 3, 4, 6, 6, 8, 10\\n Here the optimal way is to buy at 1 and sell at 10. So net profit will be 9.\\n According to my assumption,\\n buy at 1, sell at 2, profit = 1\\n buy at  2, sell at 3, profit = 1.\\n buy at 3, sell at 4, profit = 1\\n buy at 4, sell at 6, profit = 2\\n buy at 6, sell at 8, profit = 2\\n buy at 8, sell at 10, profit = 2\\n So net profit = 9\\n (*So Assumption is true for Case 2*)\\n \\n **Assumption Proved**\\n So my assumption gives the right answer.\\n \\n **Dividing into segments**\\n let the array be [7,1,5,3,6,4]\\n segments will be [7,1] , [1,5] , [5,3] , [3,6] , [6,4] (other ways also possible)\\n \\n \\n if we divide [5, 3, 2, 1, 3, 5] into [5, 3, 2, 1] and [3, 5].\\n Then we will miss the profit that we can get by buying at price 1 and selling at price 3. As they both are in different segments.\\n \\n This is the reason why the last element of the previous segment should be the first element in the next segment, without considering the increasing/decreasing conditions.\\n \\n So best way(for easy implementation) to divide any prices array into segments is dividing into segments of 2 consecutive elements\\n Eg :  let the array be [7,1,5,3,6,4]\\n segments will be [7,1] , [1,5] , [5,3] , [3,6] , [6,4]\\n \\n **Implementation explanation**\\n Traverse through the prices vector from prices[0] to prices[n-2]\\n ```\\n if (prices[i+1] > prices[i])\\n      buy at prices[i], sell at prices[i+1]\\n\\t  ans+=prices[i+1] - prices[i]\\n else\\n\\t do nothing.\\n```\\n which can also be written as ans+=max(prices[i+1]-prices[i],0) ;\\n \\n Below is the code\\n \\n \\n \\n```\\n\\nclass Solution {\\npublic:\\n    int maxProfit(vector<int>& prices)\\n    {\\n        int n = prices.size() , ans = 0 ;\\n\\t\\t\\n        for(int i=0;i<n-1;i++)\\n        {\\n            ans+=(max(prices[i+1]-prices[i],0)) ;\\n        }\\n        \\n        return ans ;\\n    }\\n};\\n\\n```\\n\\nupvote if this is helpful.",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\n if (prices[i+1] > prices[i])\\n      buy at prices[i], sell at prices[i+1]\\n\\t  ans+=prices[i+1] - prices[i]\\n else\\n\\t do nothing.\\n```\n```\\n\\nclass Solution {\\npublic:\\n    int maxProfit(vector<int>& prices)\\n    {\\n        int n = prices.size() , ans = 0 ;\\n\\t\\t\\n        for(int i=0;i<n-1;i++)\\n        {\\n            ans+=(max(prices[i+1]-prices[i],0)) ;\\n        }\\n        \\n        return ans ;\\n    }\\n};\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 39536,
                "title": "simple-4-line-solution-sorry-angie-yunqi-d",
                "content": "    public int maxProfit(int[] prices) {\\n        int result = 0;\\n        for (int i = 1; i < prices.length; i++)\\n            result += Math.max(prices[i] - prices[i - 1], 0);\\n        return result;\\n    }",
                "solutionTags": [
                    "Java"
                ],
                "code": "    public int maxProfit(int[] prices) {\\n        int result = 0;\\n        for (int i = 1; i < prices.length; i++)\\n            result += Math.max(prices[i] - prices[i - 1], 0);\\n        return result;\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 3671515,
                "title": "one-single-c-for-loop-solution-beats-100",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nIt needs only to sum up differences incr=prices[i]-prices[i-1] if incr>0 for i=1,...\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nUse one single for-loop to sum up max(prices[i]-prices[i-1], 0). Mathematically speaking\\n$$\\\\sum_{i=1}^{s-1} \\\\max(0,prices[i]-prices[i-1]) $$\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n$$O(n)$$\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n$$O(1)$$\\n[https://www.youtube.com/watch?v=sJd7Q0HyyRg](https://www.youtube.com/watch?v=sJd7Q0HyyRg)\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int maxProfit(vector<int>& prices) {\\n        int profit=0, len=prices.size();\\n        for(int i=1; i<len; i++)\\n        {\\n            profit+=max(prices[i]-prices[i-1],0);\\n        }\\n        return profit;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int maxProfit(vector<int>& prices) {\\n        int profit=0, len=prices.size();\\n        for(int i=1; i<len; i++)\\n        {\\n            profit+=max(prices[i]-prices[i-1],0);\\n        }\\n        return profit;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1569135,
                "title": "explanation-from-brute-force-dp-greedy",
                "content": "***Recursive Approach :***\\nThe question says we can buy and sell as many stocks we want, on a condition that we have to sell after each buy.\\n\\n***We have 2 choices at each index:***\\nIf we haven\\'t bought any stock then we have to buy:\\n```\\nWe can either buy or leave that stock i.e. ans = max ( buy, not-buy);\\n```\\nIf we have to sell a stock we can,\\n```\\nans = max (sell, not-sell);\\n```\\n\\n**Recursion Tree**\\n```\\nLet curr be final sum\\n\\n        [7,1,5,3,6,4]\\n\\t\\t  /        \\\\\\n    \\tBuy         Not Buy\\n     (Curr=-7)     (Curr=0)\\n\\t /       \\\\ \\n Sell\\t   Not Sell \\nCurr=-6     Curr=-7\\n\\nII\\'ly the recursion tree will grow\\n```\\n\\nConditions :- We will have a variable for index and buy,\\n```\\nif( buy) ans = max (-nums[i] + solve ( for sell), solve ( forbuy));\\nif( !buy) ans = max (nums[i] + solve (for buy), solve (sell)); \\n```\\n\\n```\\nclass Solution {\\npublic:\\n    \\n    int solve(vector<int>&nums,int i,bool buy){   \\n        \\n        if(i>=nums.size()) return 0;\\n        if(buy){   // we can buy at curr index or not buy   \\n            return dp[i][buy]=max(-nums[i]+solve(nums,i+1,!buy),solve(nums,i+1,buy));  \\n        }\\n        else{     //we can sell at curr index or not sell\\n            return dp[i][buy]=max(nums[i]+solve(nums,i+1,!buy),solve(nums,i+1,buy));  \\n        }\\n    }\\n    \\n    int maxProfit(vector<int>& prices) {\\n        int n=prices.size();\\n        if(n<2) return 0;\\n        return solve(prices,0,true); \\n    }\\n};\\n```\\n\\n**Complxeity**\\n```\\nTime : O(2^N) // we have two choices at n steps\\nSpace : O(2^N)\\n```\\n\\n***MEMOIZATION***\\n*We can observe repeated number of same recursive calls in this questions, \\nWe can observe two variables in our recursion calls, so we will use memoization with the help of 2-D matrix*\\n\\n```\\nclass Solution {\\npublic:\\n    vector<vector<int>>dp;\\n    \\n    int solve(vector<int>&nums,int i,bool buy){   \\n        \\n        if(i>=nums.size()) return 0;\\n        if(dp[i][buy]!=-1) return dp[i][buy];\\n        if(buy){      \\n            return dp[i][buy]=max(-nums[i]+solve(nums,i+1,!buy),solve(nums,i+1,buy));  \\n        }\\n        else{\\n            return dp[i][buy]=max(nums[i]+solve(nums,i+1,!buy),solve(nums,i+1,buy));  \\n        }\\n    }\\n    \\n    int maxProfit(vector<int>& prices) {\\n        int n=prices.size();\\n        if(n<2) return 0;\\n        dp.resize(n+1,vector<int>(2,-1));\\n        return solve(prices,0,true); \\n    }\\n};\\n```\\n\\n**Complxeity**\\n```\\nTime : O(N)\\nSpace : O(N)\\n```\\n\\n***Peak Valley Solution (Greedy)***\\nAnother intelligent solution is greedy solution which will solve this question in `O(n) time and O(1) space`\\nAs we know that we can only buy or sell at a certain index (As it is saying that be maximum productive or profitable in current time, don\\'t care about future)\\n\\nWe can vizualize the current stock prices in the form of a graph\\n\\n```\\n[7,1,5,3,6,4]\\n\\n7\\n\\\\               6\\n \\\\       5     /\\\\\\n  \\\\     / \\\\   /  \\\\\\n   \\\\   /   \\\\ /    4\\n    \\\\ /     3\\n\\t 1\\n```\\nAs we can see, if we calculate the maximum profit for every local maxima we observe we can have the maximum profit, eg : `[1->5] [3->6]`\\nSo, in this approach we have simply calculated profit at every local maixima we observe\\n\\n```\\nclass Solution {\\npublic:\\n    int maxProfit(vector<int>& nums) {\\n        int ans=0;\\n        for(int i=1;i<nums.size();i++){\\n            if(nums[i]>nums[i-1]){\\n                ans+=nums[i]-nums[i-1];\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```\\n**Complxeity**\\n```\\nTime : O(N)\\nSpace : O(1)\\n```",
                "solutionTags": [],
                "code": "```\\nWe can either buy or leave that stock i.e. ans = max ( buy, not-buy);\\n```\n```\\nans = max (sell, not-sell);\\n```\n```\\nLet curr be final sum\\n\\n        [7,1,5,3,6,4]\\n\\t\\t  /        \\\\\\n    \\tBuy         Not Buy\\n     (Curr=-7)     (Curr=0)\\n\\t /       \\\\ \\n Sell\\t   Not Sell \\nCurr=-6     Curr=-7\\n\\nII\\'ly the recursion tree will grow\\n```\n```\\nif( buy) ans = max (-nums[i] + solve ( for sell), solve ( forbuy));\\nif( !buy) ans = max (nums[i] + solve (for buy), solve (sell)); \\n```\n```\\nclass Solution {\\npublic:\\n    \\n    int solve(vector<int>&nums,int i,bool buy){   \\n        \\n        if(i>=nums.size()) return 0;\\n        if(buy){   // we can buy at curr index or not buy   \\n            return dp[i][buy]=max(-nums[i]+solve(nums,i+1,!buy),solve(nums,i+1,buy));  \\n        }\\n        else{     //we can sell at curr index or not sell\\n            return dp[i][buy]=max(nums[i]+solve(nums,i+1,!buy),solve(nums,i+1,buy));  \\n        }\\n    }\\n    \\n    int maxProfit(vector<int>& prices) {\\n        int n=prices.size();\\n        if(n<2) return 0;\\n        return solve(prices,0,true); \\n    }\\n};\\n```\n```\\nTime : O(2^N) // we have two choices at n steps\\nSpace : O(2^N)\\n```\n```\\nclass Solution {\\npublic:\\n    vector<vector<int>>dp;\\n    \\n    int solve(vector<int>&nums,int i,bool buy){   \\n        \\n        if(i>=nums.size()) return 0;\\n        if(dp[i][buy]!=-1) return dp[i][buy];\\n        if(buy){      \\n            return dp[i][buy]=max(-nums[i]+solve(nums,i+1,!buy),solve(nums,i+1,buy));  \\n        }\\n        else{\\n            return dp[i][buy]=max(nums[i]+solve(nums,i+1,!buy),solve(nums,i+1,buy));  \\n        }\\n    }\\n    \\n    int maxProfit(vector<int>& prices) {\\n        int n=prices.size();\\n        if(n<2) return 0;\\n        dp.resize(n+1,vector<int>(2,-1));\\n        return solve(prices,0,true); \\n    }\\n};\\n```\n```\\nTime : O(N)\\nSpace : O(N)\\n```\n```\\n[7,1,5,3,6,4]\\n\\n7\\n\\\\               6\\n \\\\       5     /\\\\\\n  \\\\     / \\\\   /  \\\\\\n   \\\\   /   \\\\ /    4\\n    \\\\ /     3\\n\\t 1\\n```\n```\\nclass Solution {\\npublic:\\n    int maxProfit(vector<int>& nums) {\\n        int ans=0;\\n        for(int i=1;i<nums.size();i++){\\n            if(nums[i]>nums[i-1]){\\n                ans+=nums[i]-nums[i-1];\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```\n```\\nTime : O(N)\\nSpace : O(1)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 214014,
                "title": "python-solution-with-detailed-explanation-why-it-works",
                "content": "```\\n\\nclass Solution:\\n    def maxProfit(self, prices):\\n\\n        # By drawing out the prices as y, and days as x,\\n        # the graph suggests that we should maximize the profit\\n        # by buying and selling and the two end points of a continuously\\n        # non-decreasing price sequence. But I had trouble proving it.\\n        # NOTE, after doing the proof I realized that the same proof could\\n        # be done on prices. No need to construct a new array\\n\\n        # However, by converting this problem to an equivalent, yet different one,\\n        # I will prove that the above approach is correct.\\n\\n        # Construct an array S with length = len(prices) - 1\\n        # S[i] = prices[i+1] - prices[i].\\n        # Ex: for prices = [7, 1, 5, 3, 6], S = [-6, 4, -2, 3]\\n        # Consider each buy-sell pair (b, s) -- one buys on day \\'b\\', sells on day \\'s\\'\\n        # one obtains a net profit prices[b] - prices[s].\\n        # By definition of S, that is just sum(S[s:b-1])\\n\\n        # The original problem, is looking for a set of buy-sell pairs\\n        # {p1, p2, ..., pn} s.t. pi = (bi, si), and bi < si < bi+1 for i \\u2208 [1, n)\\n        # that maximizes sum(prices[si] - prices[bi] for i \\u2208 [1, n))\\n        \\n        # can be converted into using the same pairs to maximize\\n        # sum(S[si:bi - 1] for i \\u2208 [1, n)).\\n        # Conceptually, this is simply looking for a set of non-overlapping sub-arrays\\n        # from S whose entry sums are maximized.\\n\\n        # We prove that we should simply select all the non-negative entries, and\\n        # combine them with adjacent selected entries into such sub-arrays.\\n\\n        # Proof by contradiction: if there exists any negative entries in the a set of optimal subarrays\\n        # we can simply exclude that entry, and break the subarray in half if necessary.\\n        # The total sum will be higher, since we excluded a negative number. The total sum\\n        # increases. This cannot be an optimal answer.\\n\\n        # Back to the original problem. Selecting positive entries and forming subarrays, \\n        # results in buy-sell pairs (b, s) s.t. prices[b:s] is non-decreasing, \\n        # as the array S represents the difference between adjacent entries.\\n\\n\\n        profit = 0\\n        for i in range(1, len(prices)):\\n            if prices[i] > prices[i-1]:\\n                profit += prices[i] - prices[i-1]\\n\\n        return profit\\n```",
                "solutionTags": [],
                "code": "```\\n\\nclass Solution:\\n    def maxProfit(self, prices):\\n\\n        # By drawing out the prices as y, and days as x,\\n        # the graph suggests that we should maximize the profit\\n        # by buying and selling and the two end points of a continuously\\n        # non-decreasing price sequence. But I had trouble proving it.\\n        # NOTE, after doing the proof I realized that the same proof could\\n        # be done on prices. No need to construct a new array\\n\\n        # However, by converting this problem to an equivalent, yet different one,\\n        # I will prove that the above approach is correct.\\n\\n        # Construct an array S with length = len(prices) - 1\\n        # S[i] = prices[i+1] - prices[i].\\n        # Ex: for prices = [7, 1, 5, 3, 6], S = [-6, 4, -2, 3]\\n        # Consider each buy-sell pair (b, s) -- one buys on day \\'b\\', sells on day \\'s\\'\\n        # one obtains a net profit prices[b] - prices[s].\\n        # By definition of S, that is just sum(S[s:b-1])\\n\\n        # The original problem, is looking for a set of buy-sell pairs\\n        # {p1, p2, ..., pn} s.t. pi = (bi, si), and bi < si < bi+1 for i \\u2208 [1, n)\\n        # that maximizes sum(prices[si] - prices[bi] for i \\u2208 [1, n))\\n        \\n        # can be converted into using the same pairs to maximize\\n        # sum(S[si:bi - 1] for i \\u2208 [1, n)).\\n        # Conceptually, this is simply looking for a set of non-overlapping sub-arrays\\n        # from S whose entry sums are maximized.\\n\\n        # We prove that we should simply select all the non-negative entries, and\\n        # combine them with adjacent selected entries into such sub-arrays.\\n\\n        # Proof by contradiction: if there exists any negative entries in the a set of optimal subarrays\\n        # we can simply exclude that entry, and break the subarray in half if necessary.\\n        # The total sum will be higher, since we excluded a negative number. The total sum\\n        # increases. This cannot be an optimal answer.\\n\\n        # Back to the original problem. Selecting positive entries and forming subarrays, \\n        # results in buy-sell pairs (b, s) s.t. prices[b:s] is non-decreasing, \\n        # as the array S represents the difference between adjacent entries.\\n\\n\\n        profit = 0\\n        for i in range(1, len(prices)):\\n            if prices[i] > prices[i-1]:\\n                profit += prices[i] - prices[i-1]\\n\\n        return profit\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3592060,
                "title": "c-simple",
                "content": "# Code\\n```\\nclass Solution {\\npublic:\\n    int maxProfit(vector<int>& prices) {\\n        int ans = 0,n=prices.size();\\n        for(int i = 1; i < n; i++){\\n            if(prices[i]>prices[i-1])ans += prices[i]-prices[i-1];\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Array",
                    "Dynamic Programming",
                    "Greedy"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int maxProfit(vector<int>& prices) {\\n        int ans = 0,n=prices.size();\\n        for(int i = 1; i < n; i++){\\n            if(prices[i]>prices[i-1])ans += prices[i]-prices[i-1];\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3214590,
                "title": "2-line-c-time-o-n-space-o-1-code",
                "content": "```\\nclass Solution {\\npublic:\\n    int maxProfit(vector<int>& prices) {\\n       int ans = 0, i = 0, n = prices.size()-1;\\n        for(; i < n; i++){\\n            ans += max(prices[i+1]-prices[i],0);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Greedy"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int maxProfit(vector<int>& prices) {\\n       int ans = 0, i = 0, n = prices.size()-1;\\n        for(; i < n; i++){\\n            ans += max(prices[i+1]-prices[i],0);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2434293,
                "title": "easy-100-4-line-fully-explained-java-c-python-js-c-python3",
                "content": "Given an integer array prices where prices[i] is the price of a given stock on the ith day.\\nOn each day, decide to buy and/or sell the stock and one can only hold at most one share of the stock at any time. However, buy it then immediately sell it on the same day.\\nFind and return the maximum profit achieve.\\n**Example:**\\n\\t\\t\\t\\t\\t\\tInput: prices = [7,1,5,3,6,4]\\n\\t\\t\\t\\t\\t\\tOutput: 7\\n**Explanation**: \\n\\t\\t\\t\\t\\t\\t\\tBuy on day 2 (price = 1) and sell on day 3 (price = 5), profit = 5-1 = 4.\\n\\t\\t\\t\\t\\t\\t\\tThen buy on day 4 (price = 3) and sell on day 5 (price = 6), profit = 6-3 = 3.\\n\\t\\t\\t\\t\\t\\t\\tTotal profit is 4 + 3 = 7.\\n\\n# **Java Solution:**\\nRuntime: 0 ms, faster than 100.00% of Java online submissions for Best Time to Buy and Sell Stock II.\\nMemory Usage: 42.1 MB, less than 96.76% of Java online submissions for Best Time to Buy and Sell Stock II.\\n```\\nclass Solution {\\n    public int maxProfit(int[] prices) {\\n        // Initialize the max profit...\\n        int maximumProfit = 0;\\n        // Traverse all the element through loop...\\n        for(int i=1; i<prices.length; i++) {\\n            // Set the difference so that we can get the max profit...\\n            int diff = prices[i]-prices[i-1];\\n            // If the difference is positive value, add to profit and increse it...\\n            if(diff > 0){\\n                maximumProfit += diff;\\n            }\\n        }\\n        return maximumProfit;      // Return the max profit...\\n    }\\n}\\n```\\n\\n# **C++ Solution:**\\n```\\nclass Solution {\\npublic:\\n    int maxProfit(vector<int>& prices) {\\n        // Initialize the max profit...\\n        int maximumProfit = 0;\\n        // Traverse all the element through loop...\\n        for (int i = 1; i < prices.size(); i++) {\\n            // check if the price is greater at i...\\n            if (prices[i] > prices[i - 1])\\n                // Add the difference to profit and increse it...\\n                maximumProfit += prices[i] - prices[i - 1];\\n        }\\n        return maximumProfit;      // Return the meximum profit...\\n    }\\n};\\n```\\n\\n# **Python Solution:**\\n```\\nclass Solution(object):\\n    def maxProfit(self, prices):\\n        # Initialize the max profit...\\n        maximumProfit = 0\\n        # Traverse all the element through loop...\\n        for i in range(1, len(prices)):\\n            # check if the price is greater at i...\\n            if prices[i] > prices[i-1]:\\n                # Add the difference to profit and increse it...\\n                maximumProfit += prices[i] - prices[i-1]\\n        return maximumProfit        # Return the max profit...\\n```\\n                    \\n# **JavaScript Solution:**\\n```\\nvar maxProfit = function(prices) {\\n    // Initialize the max profit...\\n    let maximumProfit = 0;\\n    // Traverse all the element through loop...\\n    for (let i = 1; i < prices.length; i++) {\\n        // check if the price is greater at i...\\n        if (prices[i] > prices[i - 1])\\n            // Add the difference to profit and increse it...\\n            maximumProfit += prices[i] - prices[i - 1];\\n    }\\n    return maximumProfit;      // Return the meximum profit...\\n};\\n```\\n\\n# **Python3 Solution:**\\n```\\nclass Solution:\\n    def maxProfit(self, prices: List[int]) -> int:\\n        # Initialize the max profit...\\n        maximumProfit = 0\\n        # Traverse all the element through loop...\\n        for i in range(1, len(prices)):\\n            # check if the price is greater at i...\\n            if prices[i] > prices[i-1]:\\n                # Add the difference to profit and increse it...\\n                maximumProfit += prices[i] - prices[i-1]\\n        return maximumProfit        # Return the max profit...\\n```\\n\\n# **C Language:**\\n```\\nint maxProfit(int* prices, int pricesSize){\\n    // Initialize the max profit...\\n    int maximumProfit = 0;\\n    // Traverse all the element through loop...\\n    for (int i = 1; i < pricesSize; i++) {\\n        // check if the price is greater at i...\\n        if (prices[i] > prices[i - 1])\\n            // Add the difference to profit and increse it...\\n            maximumProfit += prices[i] - prices[i - 1];\\n    }\\n    return maximumProfit;      // Return the meximum profit...\\n}\\n```\\n**I am working hard for you guys...\\nPlease upvote if you found any help with this code...**",
                "solutionTags": [
                    "Java",
                    "Python",
                    "Python3",
                    "C",
                    "JavaScript"
                ],
                "code": "```\\nclass Solution {\\n    public int maxProfit(int[] prices) {\\n        // Initialize the max profit...\\n        int maximumProfit = 0;\\n        // Traverse all the element through loop...\\n        for(int i=1; i<prices.length; i++) {\\n            // Set the difference so that we can get the max profit...\\n            int diff = prices[i]-prices[i-1];\\n            // If the difference is positive value, add to profit and increse it...\\n            if(diff > 0){\\n                maximumProfit += diff;\\n            }\\n        }\\n        return maximumProfit;      // Return the max profit...\\n    }\\n}\\n```\n```\\nclass Solution {\\npublic:\\n    int maxProfit(vector<int>& prices) {\\n        // Initialize the max profit...\\n        int maximumProfit = 0;\\n        // Traverse all the element through loop...\\n        for (int i = 1; i < prices.size(); i++) {\\n            // check if the price is greater at i...\\n            if (prices[i] > prices[i - 1])\\n                // Add the difference to profit and increse it...\\n                maximumProfit += prices[i] - prices[i - 1];\\n        }\\n        return maximumProfit;      // Return the meximum profit...\\n    }\\n};\\n```\n```\\nclass Solution(object):\\n    def maxProfit(self, prices):\\n        # Initialize the max profit...\\n        maximumProfit = 0\\n        # Traverse all the element through loop...\\n        for i in range(1, len(prices)):\\n            # check if the price is greater at i...\\n            if prices[i] > prices[i-1]:\\n                # Add the difference to profit and increse it...\\n                maximumProfit += prices[i] - prices[i-1]\\n        return maximumProfit        # Return the max profit...\\n```\n```\\nvar maxProfit = function(prices) {\\n    // Initialize the max profit...\\n    let maximumProfit = 0;\\n    // Traverse all the element through loop...\\n    for (let i = 1; i < prices.length; i++) {\\n        // check if the price is greater at i...\\n        if (prices[i] > prices[i - 1])\\n            // Add the difference to profit and increse it...\\n            maximumProfit += prices[i] - prices[i - 1];\\n    }\\n    return maximumProfit;      // Return the meximum profit...\\n};\\n```\n```\\nclass Solution:\\n    def maxProfit(self, prices: List[int]) -> int:\\n        # Initialize the max profit...\\n        maximumProfit = 0\\n        # Traverse all the element through loop...\\n        for i in range(1, len(prices)):\\n            # check if the price is greater at i...\\n            if prices[i] > prices[i-1]:\\n                # Add the difference to profit and increse it...\\n                maximumProfit += prices[i] - prices[i-1]\\n        return maximumProfit        # Return the max profit...\\n```\n```\\nint maxProfit(int* prices, int pricesSize){\\n    // Initialize the max profit...\\n    int maximumProfit = 0;\\n    // Traverse all the element through loop...\\n    for (int i = 1; i < pricesSize; i++) {\\n        // check if the price is greater at i...\\n        if (prices[i] > prices[i - 1])\\n            // Add the difference to profit and increse it...\\n            maximumProfit += prices[i] - prices[i - 1];\\n    }\\n    return maximumProfit;      // Return the meximum profit...\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1569071,
                "title": "c-simple-and-clean-one-pass-solution-brief-explanation",
                "content": "**Idea:**\\nThe main idea is that we want to buy when the price is the lowest, and sell when it\\'s the highest.\\nSo we loop while the next stock price is lower - `prices[i] >= prices[i+1]`. When we reach a valley - a local minimum - we buy.\\nNow, we loop while the next stock price is higher, to get to the peak - a local maximum - and then we want to buy.\\n\\n**Time Complexity:** O(n)\\n**Space Complexity:** O(1)\\n```\\nclass Solution {\\npublic:\\n    int maxProfit(vector<int>& prices) {\\n        int profit = 0, i = 0, n = prices.size();\\n        \\n        while (i < n - 1) {\\n            while ((i+1 != n) && (prices[i] >= prices[i+1])) i++;\\n            profit -= prices[i];\\n\\n            while ((i+1 != n) && (prices[i] < prices[i+1])) i++;\\n            profit += prices[i];\\n        }\\n        \\n        return profit;\\n    }\\n};\\n```\\n**Like it? please upvote!**",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int maxProfit(vector<int>& prices) {\\n        int profit = 0, i = 0, n = prices.size();\\n        \\n        while (i < n - 1) {\\n            while ((i+1 != n) && (prices[i] >= prices[i+1])) i++;\\n            profit -= prices[i];\\n\\n            while ((i+1 != n) && (prices[i] < prices[i+1])) i++;\\n            profit += prices[i];\\n        }\\n        \\n        return profit;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3930074,
                "title": "java-easy-to-understand-t-o-n",
                "content": "# Complexity\\n- Time complexity: O(n)\\n\\n- Space complexity: O(1)\\n\\n# Code\\n```\\nclass Solution {\\n    public int maxProfit(int[] prices) {\\n        int profit=0;\\n        for(int i=1; i<prices.length; i++){\\n            if(prices[i]>prices[i-1]){\\n                profit+=prices[i]-prices[i-1];\\n            }\\n        }\\n        return profit;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Array"
                ],
                "code": "```\\nclass Solution {\\n    public int maxProfit(int[] prices) {\\n        int profit=0;\\n        for(int i=1; i<prices.length; i++){\\n            if(prices[i]>prices[i-1]){\\n                profit+=prices[i]-prices[i-1];\\n            }\\n        }\\n        return profit;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3426192,
                "title": "c-dp-recursive-memoization",
                "content": "# Code\\n```\\nclass Solution {\\npublic:\\n    int c(int i,int buy,vector<int>&prices,vector<vector<int>>&dp){\\n        if(i>=prices.size())return 0;\\n        int ans;\\n        if(dp[i][buy]!=-1)return dp[i][buy];\\n        if(buy){\\n         ans=max(-1*prices[i]+c(i+1,0,prices,dp), c(i+1,1,prices,dp));\\n        }\\n        else {\\n            ans=max(prices[i] + c(i+1,1,prices,dp),c(i+1,0,prices,dp));\\n        }\\n        dp[i][buy]=ans;\\n        return ans;\\n    }\\n    int maxProfit(vector<int>& prices) {\\n        vector<vector<int>>dp(prices.size(),vector<int>(2,-1));\\n        return c(0,1,prices,dp);\\n    }\\n};\\n```\\n![upvote (3).jpg](https://assets.leetcode.com/users/images/2620af2b-36ef-4fff-9380-6acad68acba1_1681716576.5439.jpeg)\\n",
                "solutionTags": [
                    "C++",
                    "Dynamic Programming",
                    "Greedy"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int c(int i,int buy,vector<int>&prices,vector<vector<int>>&dp){\\n        if(i>=prices.size())return 0;\\n        int ans;\\n        if(dp[i][buy]!=-1)return dp[i][buy];\\n        if(buy){\\n         ans=max(-1*prices[i]+c(i+1,0,prices,dp), c(i+1,1,prices,dp));\\n        }\\n        else {\\n            ans=max(prices[i] + c(i+1,1,prices,dp),c(i+1,0,prices,dp));\\n        }\\n        dp[i][buy]=ans;\\n        return ans;\\n    }\\n    int maxProfit(vector<int>& prices) {\\n        vector<vector<int>>dp(prices.size(),vector<int>(2,-1));\\n        return c(0,1,prices,dp);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2772169,
                "title": "c-solutions",
                "content": "```\\nclass Solution {\\npublic:\\n    \\n    int dp[30001][2];\\n    \\n    int recurs(int i,bool hold,vector<int>& prices)\\n    {\\n        if(i>=prices.size())\\n            return 0;\\n        \\n        if(dp[i][hold]!=-1)\\n            return dp[i][hold];\\n        \\n        // 1 indicates we have stock currently\\n        // 0 indicates no stock is possesed currently\\n        \\n        if(hold==1)//sell or do nothing\\n        {\\n            return dp[i][hold]=max(recurs(i+1,0,prices)+prices[i],recurs(i+1,1,prices));\\n        }\\n        if(hold==0)//buy or do nothing\\n        {\\n            return dp[i][hold]=max(recurs(i+1,1,prices)-prices[i],recurs(i+1,0,prices));\\n        }\\n        \\n        return 0;\\n    }\\n    \\n    int maxProfit(vector<int>& prices) {\\n        memset(dp,-1,sizeof(dp));\\n        return recurs(0,0,prices);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    \\n    int dp[30001][2];\\n    \\n    int recurs(int i,bool hold,vector<int>& prices)\\n    {\\n        if(i>=prices.size())\\n            return 0;\\n        \\n        if(dp[i][hold]!=-1)\\n            return dp[i][hold];\\n        \\n        // 1 indicates we have stock currently\\n        // 0 indicates no stock is possesed currently\\n        \\n        if(hold==1)//sell or do nothing\\n        {\\n            return dp[i][hold]=max(recurs(i+1,0,prices)+prices[i],recurs(i+1,1,prices));\\n        }\\n        if(hold==0)//buy or do nothing\\n        {\\n            return dp[i][hold]=max(recurs(i+1,1,prices)-prices[i],recurs(i+1,0,prices));\\n        }\\n        \\n        return 0;\\n    }\\n    \\n    int maxProfit(vector<int>& prices) {\\n        memset(dp,-1,sizeof(dp));\\n        return recurs(0,0,prices);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 39444,
                "title": "intuitive-javascript-solution",
                "content": "This solution is based on @jyan 's [post](https://discuss.leetcode.com/topic/726/is-this-question-a-joke).\\n```\\nvar maxProfit = function(prices) {\\n    // sell immediately when it's profitable\\n    return prices.reduce((profit, price, i, prices) => \\n        i > 0 && price > prices[i-1] ? profit + price - prices[i-1] : profit, 0);\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\nvar maxProfit = function(prices) {\\n    // sell immediately when it's profitable\\n    return prices.reduce((profit, price, i, prices) => \\n        i > 0 && price > prices[i-1] ? profit + price - prices[i-1] : profit, 0);\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 39579,
                "title": "89ms-javascript-solution-js-is-much-faster-than-java",
                "content": "    var maxProfit = function(prices) {\\n        var len = prices.length;\\n        if(len <= 1) return 0;\\n        var ret = 0;\\n        for(var i = 1; i < len; i++) {\\n            ret += Math.max(0, prices[i] - prices[i-1]);\\n        }\\n        return ret;\\n    };",
                "solutionTags": [],
                "code": "    var maxProfit = function(prices) {\\n        var len = prices.length;\\n        if(len <= 1) return 0;\\n        var ret = 0;\\n        for(var i = 1; i < len; i++) {\\n            ret += Math.max(0, prices[i] - prices[i-1]);\\n        }\\n        return ret;\\n    };",
                "codeTag": "Unknown"
            },
            {
                "id": 1888672,
                "title": "4-solutions-recursion-to-memoization-peak-valley-simple-explanation",
                "content": "# **Recursive Solution (TLE)**\\n\\n-   For current index If we can buy stock, we choose to buy it or not buy it.\\n-   Similarly if we can sell stock, we choose to sell it or not sell it.\\n-   In both cases we choose action which gives maximum profit to us.\\n-   The base case arises when index goes out of bound of array.\\n-   **TC: O(2^n)**\\n-   **SC: O(1)**\\n\\n```cpp\\nclass Solution {\\nprivate:\\n    int maxProfitRec(vector<int>& prices, int i, bool canBuy)\\n    {\\n        if (i >= prices.size())\\n            return 0;\\n\\n        if (canBuy) {\\n            int notBuy = maxProfitRec(prices, i + 1, canBuy);\\n            int buy = maxProfitRec(prices, i + 1, !canBuy) - prices[i];\\n            return max(notBuy, buy);\\n        } else {\\n            int notSell = maxProfitRec(prices, i + 1, canBuy);\\n            int sell = maxProfitRec(prices, i + 1, !canBuy) + prices[i];\\n            return max(notSell, sell);\\n        }\\n    }\\n\\npublic:\\n    int maxProfit(vector<int>& prices)\\n    {\\n        int n = prices.size();\\n        if (n <= 1)\\n            return 0;\\n        return maxProfitRec(prices, 0, true);\\n    }\\n};\\n```\\n**Note:** `canBuy` represents `Can we buy the stock?`\\n\\n# **Memoization**\\n\\n-   The recursive solution is exponential in time complexity so gives TLE.\\n-   We can use extra space to store the computation of subproblems.(memoization)\\n-   If we have calculated the subproblem before, we can directly return the result else store new result.\\n-   **TC: O(n)**\\n-   **SC: O(n)**\\n\\n```cpp\\nclass Solution {\\nprivate:\\n    int maxProfitRec(vector<int>& prices, int i, bool canBuy, vector<vector<int>>& memo)\\n    {\\n        if (i >= prices.size())\\n            return 0;\\n\\n        if (memo[i][canBuy] != -1)\\n            return memo[i][canBuy];\\n\\n        if (canBuy) {\\n            int notBuy = maxProfitRec(prices, i + 1, canBuy, memo);\\n            int buy = maxProfitRec(prices, i + 1, !canBuy, memo) - prices[i];\\n            return memo[i][canBuy] = max(notBuy, buy);\\n        } else {\\n            int notSell = maxProfitRec(prices, i + 1, canBuy, memo);\\n            int sell = maxProfitRec(prices, i + 1, !canBuy, memo) + prices[i];\\n            return memo[i][canBuy] = max(notSell, sell);\\n        }\\n    }\\n\\npublic:\\n    int maxProfit(vector<int>& prices)\\n    {\\n        int n = prices.size();\\n        if (n <= 1)\\n            return 0;\\n        vector<vector<int>> memo(n + 1, vector<int>(2, -1));\\n        return maxProfitRec(prices, 0, true, memo);\\n    }\\n};\\n```\\n\\n# **Valley-peak approach**\\n\\n-   For each time at lowest cost(valley) we buy stock and at highest cost(peak) we sell stock.\\n-   **TC: O(N)**\\n-   **SC: O(1)**\\n\\n```cpp\\nclass Solution {\\npublic:\\n    int maxProfit(vector<int>& prices)\\n    {\\n        int n = prices.size();\\n        int buy = 0, sell = 0;\\n        int i = 0,profit = 0;\\n        while (i < n - 1) {\\n            // valley\\n            while (i < n - 1 && prices[i] >= prices[i + 1])\\n                i++;\\n            buy = prices[i];\\n\\n            // peak\\n            while (i < n - 1 && prices[i] < prices[i + 1])\\n                i++;\\n            sell = prices[i];\\n\\n            profit += sell - buy;\\n        }\\n        return profit;\\n    }\\n};\\n```\\n\\n## **Greedy Solution**\\n\\n-   for each day we buy and on next day we sell, **If it is profitable**\\n-   **TC: O(N)**\\n-   **SC: O(1)**\\n\\n\\n```cpp\\nclass Solution {\\npublic:\\n    int maxProfit(vector<int>& prices)\\n    {\\n        int profit = 0;\\n        int n = prices.size();\\n        for (int i = 1; i < n; i++) {\\n            if (prices[i - 1] < prices[i])\\n                profit += prices[i] - prices[i - 1];\\n        }\\n        return profit;\\n    }\\n};\\n```\\n\\n**If you like it then please upvote !**\\n",
                "solutionTags": [
                    "Dynamic Programming",
                    "Recursion",
                    "Memoization"
                ],
                "code": "```cpp\\nclass Solution {\\nprivate:\\n    int maxProfitRec(vector<int>& prices, int i, bool canBuy)\\n    {\\n        if (i >= prices.size())\\n            return 0;\\n\\n        if (canBuy) {\\n            int notBuy = maxProfitRec(prices, i + 1, canBuy);\\n            int buy = maxProfitRec(prices, i + 1, !canBuy) - prices[i];\\n            return max(notBuy, buy);\\n        } else {\\n            int notSell = maxProfitRec(prices, i + 1, canBuy);\\n            int sell = maxProfitRec(prices, i + 1, !canBuy) + prices[i];\\n            return max(notSell, sell);\\n        }\\n    }\\n\\npublic:\\n    int maxProfit(vector<int>& prices)\\n    {\\n        int n = prices.size();\\n        if (n <= 1)\\n            return 0;\\n        return maxProfitRec(prices, 0, true);\\n    }\\n};\\n```\n```cpp\\nclass Solution {\\nprivate:\\n    int maxProfitRec(vector<int>& prices, int i, bool canBuy, vector<vector<int>>& memo)\\n    {\\n        if (i >= prices.size())\\n            return 0;\\n\\n        if (memo[i][canBuy] != -1)\\n            return memo[i][canBuy];\\n\\n        if (canBuy) {\\n            int notBuy = maxProfitRec(prices, i + 1, canBuy, memo);\\n            int buy = maxProfitRec(prices, i + 1, !canBuy, memo) - prices[i];\\n            return memo[i][canBuy] = max(notBuy, buy);\\n        } else {\\n            int notSell = maxProfitRec(prices, i + 1, canBuy, memo);\\n            int sell = maxProfitRec(prices, i + 1, !canBuy, memo) + prices[i];\\n            return memo[i][canBuy] = max(notSell, sell);\\n        }\\n    }\\n\\npublic:\\n    int maxProfit(vector<int>& prices)\\n    {\\n        int n = prices.size();\\n        if (n <= 1)\\n            return 0;\\n        vector<vector<int>> memo(n + 1, vector<int>(2, -1));\\n        return maxProfitRec(prices, 0, true, memo);\\n    }\\n};\\n```\n```cpp\\nclass Solution {\\npublic:\\n    int maxProfit(vector<int>& prices)\\n    {\\n        int n = prices.size();\\n        int buy = 0, sell = 0;\\n        int i = 0,profit = 0;\\n        while (i < n - 1) {\\n            // valley\\n            while (i < n - 1 && prices[i] >= prices[i + 1])\\n                i++;\\n            buy = prices[i];\\n\\n            // peak\\n            while (i < n - 1 && prices[i] < prices[i + 1])\\n                i++;\\n            sell = prices[i];\\n\\n            profit += sell - buy;\\n        }\\n        return profit;\\n    }\\n};\\n```\n```cpp\\nclass Solution {\\npublic:\\n    int maxProfit(vector<int>& prices)\\n    {\\n        int profit = 0;\\n        int n = prices.size();\\n        for (int i = 1; i < n; i++) {\\n            if (prices[i - 1] < prices[i])\\n                profit += prices[i] - prices[i - 1];\\n        }\\n        return profit;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1569085,
                "title": "c-easy-intuitive-solution-straight-forward-approach-dp",
                "content": "Hello everyone, first of all thanks a lot for reading in advance!\\n\\n**My Approach:**\\n1. Since, we want to maximize our profit then, I claim that we should take consecutive profit of (high - low) where we buy at low and sell at high.\\n\\n2. Like, if our sequence is somewhat like this: `a <= b <= c <= d`, the profit is `d - a = (b - a) + (c - b) + (d - c)` without a doubt.\\n\\n3. And, if our sequence is somewhat like this: `a <= b >= b\\' <= c <= d`, the profit is `(b - a) + (d - b)`.\\n\\n4. So we just target at monotonously increasing sequences, i.e., we need to consider every high immediately following a low to maximize the profit.\\n\\n5. Below is the graph for more intuition:\\n\\n![image](https://assets.leetcode.com/users/images/fa480019-a7db-4b28-a0ab-19fe757402e3_1636504280.3363073.png)\\nIn the above graph, if we skip peaki and valleyj, then trying to obtain more profit by considering points with more difference in heights, the net profit obtained will always be lesser than the one obtained by including them, since `C` will always be lesser than `A+B`.\\n\\n**Time Complexity:** `O(N)`\\n**Space Complexity:** `O(1)`\\n \\nBelow is the code for my approach mentioned above:\\n```\\nclass Solution {\\npublic:\\n    int maxProfit(vector<int>& prices) {\\n        int profit{};\\n        \\n        for(int i{1}; i<prices.size(); ++i) \\n            profit += max(prices[i] - prices[i-1], 0);\\n        \\n        return profit;\\n    }\\n};\\n```\\n\\n`Please Do Upvote \\uD83D\\uDD3C if this post helped you, it keeps me motivated to write more such posts.`",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int maxProfit(vector<int>& prices) {\\n        int profit{};\\n        \\n        for(int i{1}; i<prices.size(); ++i) \\n            profit += max(prices[i] - prices[i-1], 0);\\n        \\n        return profit;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1523377,
                "title": "c-recursive-memoization-dp",
                "content": "*   **Here is an observation,** it is given then you can buy a stock if you hold at most one stock but you have to sell the hold stock on the same day of purchasing the second stock. It means your profit is zero or you can say you don\\'t have profit on second stock.\\n\\n*  **Proof :-** let say, on day 1 you buy a stock1 = 1, here your profit = -1;\\n   on day 3 you buy stock2 = 5, then your profit = -6, then immediately sell stock1 = 5, then your profit = -1;\\n\\t   on day 7 you sell your stock2 = 9, then your profit = 8; \\n\\t   It is same as you buy a stock on day 1 and sell it on day 7\\n   \\n*  Now, you can observe that on day 3 your profit = 0, as you buy a stock at 5 and sell previous stock at 5;\\nso this statement `(You can only hold at most one share of the stock at any time. However, you can buy it then immediately sell it on the same day)` is **absolutly worthless**. and **the question reduced to just \"buy and sell stock\" with condition you have to sell a stock before you buy another.**\\n\\t\\n```\\nclass Solution {\\npublic:\\n    int dp[30003][2];\\n    int solve(vector<int>& prices, int pos, bool hold){\\n        if(pos==prices.size()) return 0;\\n        if(dp[pos][hold]!=-1) return dp[pos][hold];\\n        int buy=0, notbuy=0, sell=0, notsell=0;\\n        //if you want to buy \\n        if(!hold) buy = solve(prices,pos+1,!hold) - prices[pos];\\n        //if you don\\'t want to buy \\n        notbuy = solve(prices,pos+1,hold);\\n        // if you want to sell the stock\\n        if(hold) sell = solve(prices,pos+1,!hold) + prices[pos];\\n        // if you don\\'t want to sell the stock\\n        notsell = solve(prices,pos+1,hold);\\n        return dp[pos][hold] = max(max(buy,notbuy),max(sell,notsell));\\n    }\\n    \\n    int maxProfit(vector<int>& prices) {\\n        memset(dp,-1,sizeof(dp));\\n        return solve(prices,0,false);\\n    }\\n};\\n```\\nPlease **UPVOTE**",
                "solutionTags": [
                    "C++",
                    "C",
                    "Dynamic Programming",
                    "Recursion",
                    "Memoization"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int dp[30003][2];\\n    int solve(vector<int>& prices, int pos, bool hold){\\n        if(pos==prices.size()) return 0;\\n        if(dp[pos][hold]!=-1) return dp[pos][hold];\\n        int buy=0, notbuy=0, sell=0, notsell=0;\\n        //if you want to buy \\n        if(!hold) buy = solve(prices,pos+1,!hold) - prices[pos];\\n        //if you don\\'t want to buy \\n        notbuy = solve(prices,pos+1,hold);\\n        // if you want to sell the stock\\n        if(hold) sell = solve(prices,pos+1,!hold) + prices[pos];\\n        // if you don\\'t want to sell the stock\\n        notsell = solve(prices,pos+1,hold);\\n        return dp[pos][hold] = max(max(buy,notbuy),max(sell,notsell));\\n    }\\n    \\n    int maxProfit(vector<int>& prices) {\\n        memset(dp,-1,sizeof(dp));\\n        return solve(prices,0,false);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1167130,
                "title": "c-solution-to-all-the-stock-problems-using-dynamic-programming",
                "content": "## Related Questions\\n\\n1. [Best Time to Buy and Sell Stock](https://leetcode.com/problems/best-time-to-buy-and-sell-stock/)\\n2. [Best Time to Buy and Sell Stock II](https://leetcode.com/problems/best-time-to-buy-and-sell-stock-ii/)\\n3. [Best Time to Buy and Sell Stock with Transaction Fee](https://leetcode.com/problems/best-time-to-buy-and-sell-stock-with-transaction-fee/)\\n4. [Best Time to Buy and Sell Stock with Cooldown](https://leetcode.com/problems/best-time-to-buy-and-sell-stock-with-cooldown/)\\n5. [Best Time to Buy and Sell Stock III](https://leetcode.com/problems/best-time-to-buy-and-sell-stock-iii/)\\n6. [Best Time to Buy and Sell Stock IV](https://leetcode.com/problems/best-time-to-buy-and-sell-stock-iv/)\\n\\n#### Best Time to Buy and Sell Stock\\nO(N) Time, O(N) Space ( Can be made O(1) Space by tracking only the previous buy sell values )\\n```\\nclass Solution {\\npublic:\\n    int maxProfit(vector<int>& prices) {\\n        int buy[prices.size()], sell[prices.size()];\\n        memset(buy,0,sizeof(buy));\\n        memset(sell,0,sizeof(sell));\\n        buy[0] = -prices[0];\\n        for(int i=1; i<prices.size(); i++) {\\n            buy[i] = max(buy[i-1],-prices[i]);\\n            sell[i] = max(sell[i-1],prices[i] + buy[i-1]);\\n        }\\n        return max(buy[prices.size()-1],sell[prices.size()-1]);\\n    }\\n};\\n```\\n\\n#### Best Time to Buy and Sell Stock II\\nO(N) Time, O(N) Space ( Can be made O(1) Space by tracking only the previous buy sell values )\\n```\\nclass Solution {\\npublic:\\n    int maxProfit(vector<int>& prices) {\\n        int sell[prices.size()];\\n        int buy[prices.size()];\\n        memset(sell,0,sizeof(sell));\\n        memset(buy,0,sizeof(buy));\\n        buy[0] = -prices[0];\\n        for(int i=1; i<prices.size();i++) {\\n            buy[i] = max(buy[i-1], sell[i-1] - prices[i]);\\n            sell[i] = max(sell[i-1],prices[i] + buy[i-1]);\\n        }\\n        return max(buy[prices.size()-1],sell[prices.size()-1]);\\n    }\\n};\\n```\\n\\n#### Best Time to Buy and Sell Stock with Transaction Fee\\nO(N) Time, O(N) Space ( Can be made O(1) Space by tracking only the previous buy sell values )\\n```\\nclass Solution {\\npublic:\\n    int maxProfit(vector<int>& prices, int fee) {\\n        int sell[prices.size()];\\n        int buy[prices.size()];\\n        memset(sell,0,sizeof(sell));\\n        memset(buy,0,sizeof(buy));\\n        buy[0] = -prices[0];\\n        for(int i=1; i<prices.size();i++) {\\n            buy[i] = max(buy[i-1], sell[i-1] - prices[i]);\\n            sell[i] = max(sell[i-1],prices[i] + buy[i-1] - fee);\\n        }\\n        return max(buy[prices.size()-1],sell[prices.size()-1]);\\n    }\\n};\\n```\\n\\n#### Best Time to Buy and Sell Stock with Cooldown ( Generalised for k cooldown period )\\nO(N) Time, O(N) Space\\n\\n```\\nclass Solution {\\npublic:\\n    int maxProfit(vector<int>& prices, int cooldown = 1) {\\n        int buy[prices.size()];\\n        int sell[prices.size()];\\n        memset(buy, 0, sizeof(buy));\\n        memset(sell, 0, sizeof(sell));\\n        buy[0] = -prices[0];\\n        for(int i=1; i<prices.size(); i++) {\\n            buy[i] = max(buy[i-1], (i-cooldown-1 >= 0 ? sell[i-cooldown-1] : 0) - prices[i]);\\n            sell[i] = max(sell[i-1],prices[i] + buy[i-1]);\\n        }\\n        return max(sell[prices.size()-1], buy[prices.size()-1]);\\n    }\\n};\\n```\\n\\n#### Best Time to Buy and Sell Stock III ( Generalised for atmost k transactions )\\nO(Nk) Time, O(Nk) Space ( Can be made O(k) Space by tracking only the previous buy sell values )\\n```\\nclass Solution {\\npublic:\\n    int maxProfit(vector<int>& prices, int transactions = 2) {\\n        if(transactions == 0) return 0;\\n        int buy[transactions][prices.size()];\\n        int sell[transactions][prices.size()];\\n        memset(buy,0,sizeof(buy));\\n        memset(sell,0,sizeof(sell));\\n        for(int i=0; i<transactions;i++) buy[i][0] = -prices[0];\\n        for(int i=1; i<prices.size(); i++) {\\n            int prevInvestment = 0;\\n            for(int j=0; j<transactions; j++) {\\n                buy[j][i] = max(buy[j][i-1], -prices[i] + prevInvestment);\\n                sell[j][i] = max(sell[j][i-1], buy[j][i-1] + prices[i]);\\n                prevInvestment = sell[j][i];\\n            }\\n        }\\n        int ret = 0;\\n        for(int i=0; i<transactions; i++) {\\n            ret = max(ret,sell[i][prices.size()-1]);\\n        }\\n        return ret;\\n    }\\n};\\n```\\n\\n#### Best Time to Buy and Sell Stock IV\\nO(Nk) Time, O(Nk) Space ( Can be made O(k) Space by tracking only the previous buy sell values )\\n\\n```\\nclass Solution {\\npublic:\\n    int maxProfit(int transactions, vector<int>& prices) {\\n        if(transactions == 0 || prices.size() <= 1) return 0;\\n        int buy[transactions][prices.size()];\\n        int sell[transactions][prices.size()];\\n        memset(buy,0,sizeof(buy));\\n        memset(sell,0,sizeof(sell));\\n        for(int i=0; i<transactions;i++) buy[i][0] = -prices[0];\\n        for(int i=1; i<prices.size(); i++) {\\n            int prevInvestment = 0;\\n            for(int j=0; j<transactions; j++) {\\n                buy[j][i] = max(buy[j][i-1], -prices[i] + prevInvestment);\\n                sell[j][i] = max(sell[j][i-1], buy[j][i-1] + prices[i]);\\n                prevInvestment = sell[j][i];\\n            }\\n        }\\n        int ret = 0;\\n        for(int i=0; i<transactions; i++) {\\n            ret = max(ret,sell[i][prices.size()-1]);\\n        }\\n        return ret;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int maxProfit(vector<int>& prices) {\\n        int buy[prices.size()], sell[prices.size()];\\n        memset(buy,0,sizeof(buy));\\n        memset(sell,0,sizeof(sell));\\n        buy[0] = -prices[0];\\n        for(int i=1; i<prices.size(); i++) {\\n            buy[i] = max(buy[i-1],-prices[i]);\\n            sell[i] = max(sell[i-1],prices[i] + buy[i-1]);\\n        }\\n        return max(buy[prices.size()-1],sell[prices.size()-1]);\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    int maxProfit(vector<int>& prices) {\\n        int sell[prices.size()];\\n        int buy[prices.size()];\\n        memset(sell,0,sizeof(sell));\\n        memset(buy,0,sizeof(buy));\\n        buy[0] = -prices[0];\\n        for(int i=1; i<prices.size();i++) {\\n            buy[i] = max(buy[i-1], sell[i-1] - prices[i]);\\n            sell[i] = max(sell[i-1],prices[i] + buy[i-1]);\\n        }\\n        return max(buy[prices.size()-1],sell[prices.size()-1]);\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    int maxProfit(vector<int>& prices, int fee) {\\n        int sell[prices.size()];\\n        int buy[prices.size()];\\n        memset(sell,0,sizeof(sell));\\n        memset(buy,0,sizeof(buy));\\n        buy[0] = -prices[0];\\n        for(int i=1; i<prices.size();i++) {\\n            buy[i] = max(buy[i-1], sell[i-1] - prices[i]);\\n            sell[i] = max(sell[i-1],prices[i] + buy[i-1] - fee);\\n        }\\n        return max(buy[prices.size()-1],sell[prices.size()-1]);\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    int maxProfit(vector<int>& prices, int cooldown = 1) {\\n        int buy[prices.size()];\\n        int sell[prices.size()];\\n        memset(buy, 0, sizeof(buy));\\n        memset(sell, 0, sizeof(sell));\\n        buy[0] = -prices[0];\\n        for(int i=1; i<prices.size(); i++) {\\n            buy[i] = max(buy[i-1], (i-cooldown-1 >= 0 ? sell[i-cooldown-1] : 0) - prices[i]);\\n            sell[i] = max(sell[i-1],prices[i] + buy[i-1]);\\n        }\\n        return max(sell[prices.size()-1], buy[prices.size()-1]);\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    int maxProfit(vector<int>& prices, int transactions = 2) {\\n        if(transactions == 0) return 0;\\n        int buy[transactions][prices.size()];\\n        int sell[transactions][prices.size()];\\n        memset(buy,0,sizeof(buy));\\n        memset(sell,0,sizeof(sell));\\n        for(int i=0; i<transactions;i++) buy[i][0] = -prices[0];\\n        for(int i=1; i<prices.size(); i++) {\\n            int prevInvestment = 0;\\n            for(int j=0; j<transactions; j++) {\\n                buy[j][i] = max(buy[j][i-1], -prices[i] + prevInvestment);\\n                sell[j][i] = max(sell[j][i-1], buy[j][i-1] + prices[i]);\\n                prevInvestment = sell[j][i];\\n            }\\n        }\\n        int ret = 0;\\n        for(int i=0; i<transactions; i++) {\\n            ret = max(ret,sell[i][prices.size()-1]);\\n        }\\n        return ret;\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    int maxProfit(int transactions, vector<int>& prices) {\\n        if(transactions == 0 || prices.size() <= 1) return 0;\\n        int buy[transactions][prices.size()];\\n        int sell[transactions][prices.size()];\\n        memset(buy,0,sizeof(buy));\\n        memset(sell,0,sizeof(sell));\\n        for(int i=0; i<transactions;i++) buy[i][0] = -prices[0];\\n        for(int i=1; i<prices.size(); i++) {\\n            int prevInvestment = 0;\\n            for(int j=0; j<transactions; j++) {\\n                buy[j][i] = max(buy[j][i-1], -prices[i] + prevInvestment);\\n                sell[j][i] = max(sell[j][i-1], buy[j][i-1] + prices[i]);\\n                prevInvestment = sell[j][i];\\n            }\\n        }\\n        int ret = 0;\\n        for(int i=0; i<transactions; i++) {\\n            ret = max(ret,sell[i][prices.size()-1]);\\n        }\\n        return ret;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 452422,
                "title": "easy-python-solution",
                "content": "```\\nclass Solution:\\n    def maxProfit(self, prices: List[int]) -> int:\\n        arr=[0 for i in range(len(prices))]\\n        for i in range(len(prices)-1):\\n            arr[i+1]=prices[i+1]-prices[i]\\n        \\n        maxProfit=0\\n        for i in range(len(arr)):\\n            if arr[i]>0:\\n                maxProfit+=arr[i]\\n        return maxProfit        \\n                \\n```",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def maxProfit(self, prices: List[int]) -> int:\\n        arr=[0 for i in range(len(prices))]\\n        for i in range(len(prices)-1):\\n            arr[i+1]=prices[i+1]-prices[i]\\n        \\n        maxProfit=0\\n        for i in range(len(arr)):\\n            if arr[i]>0:\\n                maxProfit+=arr[i]\\n        return maxProfit        \\n                \\n```",
                "codeTag": "Java"
            },
            {
                "id": 3235886,
                "title": "javascript-java-c-100-fast-o-n-time-best-time-to-buy-and-sell-stock-ii",
                "content": "# Intuition\\nTo solve this problem, we need to find all the points where the price is increasing and calculate the difference between each pair of adjacent points. This will give us the profit that can be made by buying at the lower price and selling at the higher price. We then add up all these profits to get the maximum profit that can be made.\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\nTo implement this approach, we can initialize a variable max_profit to 0 and loop through the array, checking each pair of adjacent points for a price increase. Whenever we find an increase, we add it to max_profit. At the end of the loop, we return max_profit.\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity: O(n), where n is the length of the input array prices. This is because we are looping through the input array once and doing a constant amount of work for each element.\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n\\n- Space complexity: O(1), because we are only using a constant amount of extra space to store the variables diff and max_profit, and we are not using any additional data structures. Therefore, the space used by the algorithm does not depend on the size of the input.\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n\\n# ***C++ Code***\\n``````\\nclass Solution {\\npublic:\\n    int maxProfit(vector<int>& prices) \\n    {\\n        int max=0,diff;\\n        for(int i=0;i<prices.size()-1;i++)\\n        {\\n            diff=prices[i+1]-prices[i];\\n            if(diff>0)\\n                max+=diff;\\n        }\\n        return max;\\n    }\\n};\\n\\n\\n``````\\n# ***Java Code***\\n``````\\nclass Solution {\\n    public int maxProfit(int[] prices) {\\n        int max=0,diff;\\n        for(int i=0;i<prices.length-1;i++)\\n        {\\n            diff=prices[i+1]-prices[i];\\n            if(diff>0)\\n                max+=diff;\\n        }\\n        return max;  \\n    }\\n}\\n\\n``````\\n# ***JavaScript Code***\\n``````\\nvar maxProfit = function(prices) {\\n    var max=0,diff;\\n    for(var i=0;i<prices.length-1;i++)\\n    {\\n        diff=prices[i+1]-prices[i];\\n        if(diff>0)\\n            max+=diff;\\n    }\\n    return max;\\n};\\n",
                "solutionTags": [
                    "C++",
                    "Java",
                    "JavaScript"
                ],
                "code": "``````\n``````\n``````\n``````\n``````",
                "codeTag": "Unknown"
            },
            {
                "id": 3195867,
                "title": "with-step-by-step-explanation",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\nExplanation:\\n\\nWe iterate through the array and check if the current price is greater than the previous price. If it is, we add the difference between the two prices to our max_profit variable.\\n\\nAt the end, we return the max_profit. This is because we can buy and sell multiple times, so we just add up the profits from all possible transactions.\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def maxProfit(self, prices: List[int]) -> int:\\n        max_profit = 0\\n        for i in range(1, len(prices)):\\n            if prices[i] > prices[i-1]:\\n                max_profit += prices[i] - prices[i-1]\\n        return max_profit\\n\\n```",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Array",
                    "Dynamic Programming",
                    "Greedy"
                ],
                "code": "```\\nclass Solution:\\n    def maxProfit(self, prices: List[int]) -> int:\\n        max_profit = 0\\n        for i in range(1, len(prices)):\\n            if prices[i] > prices[i-1]:\\n                max_profit += prices[i] - prices[i-1]\\n        return max_profit\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2986870,
                "title": "6-line-code-simple-greedy-easy-to-understand",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\nO(n)\\n\\n- Space complexity:\\nO(1)\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int maxProfit(vector<int>& a) {\\n        \\n        int sum=0;\\n        for(int i=1;i<a.size();i++){\\n            int t=a[i]-a[i-1];\\n            if(t>0)\\n            sum+=t;\\n        }\\n        return sum;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Array",
                    "Greedy"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int maxProfit(vector<int>& a) {\\n        \\n        int sum=0;\\n        for(int i=1;i<a.size();i++){\\n            int t=a[i]-a[i-1];\\n            if(t>0)\\n            sum+=t;\\n        }\\n        return sum;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2356923,
                "title": "simplest-solution-possible",
                "content": "I have seen a lot of solutions finding the best subarray, but the problem really boils down to wether the price is increasing or decreasing day over day. For example, if the prices are ```[1, 2, 3, 4, 5]```. Solving for the max profit by buying on Day 1 at $1 and selling on Day 5 at $5 for a profit of $4 is the same as buying and selling every day ($2-$1 + $3 - $2 + $4 - $3 + $5 -$4). For cases when the price goes down, there is no reason to track the price as it will either increase on the next iteration (in which case it will be added) or it will continue going down. Hope this helps!\\n\\n```\\nclass Solution:\\n    def maxProfit(self, prices: List[int]) -> int:\\n        \\n        total = 0\\n        for i in range(len(prices)-1):\\n            if prices[i] < prices[i+1]:\\n                total += (prices[i+1]-prices[i])\\n        \\n        return total\\n```",
                "solutionTags": [
                    "Python",
                    "Greedy"
                ],
                "code": "```[1, 2, 3, 4, 5]```\n```\\nclass Solution:\\n    def maxProfit(self, prices: List[int]) -> int:\\n        \\n        total = 0\\n        for i in range(len(prices)-1):\\n            if prices[i] < prices[i+1]:\\n                total += (prices[i+1]-prices[i])\\n        \\n        return total\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2271744,
                "title": "best-explanation-using-state-machine-with-diagram",
                "content": "The best way to solve any question related to buy and sell stock is by making state machines.\\nIt is very intuitive to draw the state machine for this question.\\nThere are three things we need to do\\n1) Buy\\n2) Hold\\n3) Sell\\n\\n![image](https://assets.leetcode.com/users/images/7d650a21-13c8-44d6-b88d-6f591b963c49_1657615804.1454897.png)\\n\\nWe have two states x and y.\\nIn state x we have to decide if we want to buy a stock or do nothing.\\nIn state y we have to decide if we want to sell a stock or do nothing.\\nTo move from state x to y we have to buy a stock, similarly from y to x we have to sell the stock.\\n\\nOur task is to maximize the profit hence in each state we take decision by looking at maximum profit.\\nTo write the state equation we look at the incoming edges on a given state.\\n\\nThe state equations are:\\n**x[i] = max( x[i-1] , y[i-1] + prices[i])\\ny[i]= max( y[i-1] , x[i-1] - prices[i])**\\n\\n**Note: Here we are deciding at current price we need to buy or sell or hold the stock, thats why we have to take prices[i] and not prices[i-1].**\\n\\n C++ code with O(n) space:\\n ```\\n int maxProfit(vector<int>& prices) {\\n\\t\\tint n=prices.size();\\n        vector<int> x(n,0),y(n);\\n\\t\\t// initially we dont have anything, so moving to state y requires prices[0]\\n        y[0]=-prices[0];\\n        for(int i=1;i<n;i++)\\n        {\\n            x[i]=max(x[i-1],y[i-1]+prices[i]);\\n            y[i]=max(x[i-1]-prices[i],y[i-1]); \\n            \\n        }\\n        return max(x[n-1],y[n-1]);\\n\\t\\t}\\n```\\n\\nAnd with little tweaking the space is optimized to O(1):\\n```\\nint maxProfit(vector<int>& prices) {\\n\\t\\tint y=-prices[0];\\n        int x=0,last_x=0;\\n        for(int i=1;i<n;i++)\\n        {\\n            x=max(last_x,y+prices[i]);\\n            y=max(last_x-prices[i],y);\\n            last_x=x;\\n        }\\n        \\n        return max(x,y);\\n\\t\\t}\\n```\\n\\n**Do post your doubts, and upvote if you like the explanation..happy coding**\\n\\n\\n\\n\\n",
                "solutionTags": [
                    "Dynamic Programming"
                ],
                "code": "```\\n int maxProfit(vector<int>& prices) {\\n\\t\\tint n=prices.size();\\n        vector<int> x(n,0),y(n);\\n\\t\\t// initially we dont have anything, so moving to state y requires prices[0]\\n        y[0]=-prices[0];\\n        for(int i=1;i<n;i++)\\n        {\\n            x[i]=max(x[i-1],y[i-1]+prices[i]);\\n            y[i]=max(x[i-1]-prices[i],y[i-1]); \\n            \\n        }\\n        return max(x[n-1],y[n-1]);\\n\\t\\t}\\n```\n```\\nint maxProfit(vector<int>& prices) {\\n\\t\\tint y=-prices[0];\\n        int x=0,last_x=0;\\n        for(int i=1;i<n;i++)\\n        {\\n            x=max(last_x,y+prices[i]);\\n            y=max(last_x-prices[i],y);\\n            last_x=x;\\n        }\\n        \\n        return max(x,y);\\n\\t\\t}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1661828,
                "title": "solution-swift-best-time-to-buy-and-sell-stock-ii-test-cases",
                "content": "```swift\\nclass Solution {\\n    func maxProfit(_ prices: [Int]) -> Int {\\n        var i = 1, profit = 0\\n        while i < prices.count {\\n            let cur = prices[i], last = prices[i-1]\\n            if cur > last { profit += cur - last }\\n            i += 1\\n        }\\n        return profit\\n    }\\n}\\n```\\n\\n---\\n\\n<p>\\n<details>\\n<summary>\\n<img src=\"https://git.io/JDblm\" height=\"24\">\\n<b>TEST CASES</b>\\n</summary>\\n\\n<p><pre>\\n<b>Result:</b> Executed 3 tests, with 0 failures (0 unexpected) in 0.007 (0.009) seconds\\n</pre></p>\\n\\n```swift\\nimport XCTest\\n\\nclass Tests: XCTestCase {\\n    \\n    private let solution = Solution()\\n    \\n    /// Buy on day 2 (price = 1) and sell on day 3 (price = 5), profit = 5-1 = 4.\\n    /// Then buy on day 4 (price = 3) and sell on day 5 (price = 6), profit = 6-3 = 3.\\n    /// Total profit is 4 + 3 = 7.\\n    func test0() {\\n        let value = solution.maxProfit([7,1,5,3,6,4])\\n        XCTAssertEqual(value, 7)\\n    }\\n    \\n    /// Buy on day 1 (price = 1) and sell on day 5 (price = 5), profit = 5-1 = 4.\\n    /// Total profit is 4.\\n    func test1() {\\n        let value = solution.maxProfit([1,2,3,4,5])\\n        XCTAssertEqual(value, 4)\\n    }\\n    \\n    /// There is no way to make a positive profit, so we never buy the stock to achieve the maximum profit of 0.\\n    func test2() {\\n        let value = solution.maxProfit([7,6,4,3,1])\\n        XCTAssertEqual(value, 0)\\n    }\\n}\\n\\nTests.defaultTestSuite.run()\\n```\\n\\n</details>\\n</p>",
                "solutionTags": [
                    "Swift"
                ],
                "code": "```swift\\nclass Solution {\\n    func maxProfit(_ prices: [Int]) -> Int {\\n        var i = 1, profit = 0\\n        while i < prices.count {\\n            let cur = prices[i], last = prices[i-1]\\n            if cur > last { profit += cur - last }\\n            i += 1\\n        }\\n        return profit\\n    }\\n}\\n```\n```swift\\nimport XCTest\\n\\nclass Tests: XCTestCase {\\n    \\n    private let solution = Solution()\\n    \\n    /// Buy on day 2 (price = 1) and sell on day 3 (price = 5), profit = 5-1 = 4.\\n    /// Then buy on day 4 (price = 3) and sell on day 5 (price = 6), profit = 6-3 = 3.\\n    /// Total profit is 4 + 3 = 7.\\n    func test0() {\\n        let value = solution.maxProfit([7,1,5,3,6,4])\\n        XCTAssertEqual(value, 7)\\n    }\\n    \\n    /// Buy on day 1 (price = 1) and sell on day 5 (price = 5), profit = 5-1 = 4.\\n    /// Total profit is 4.\\n    func test1() {\\n        let value = solution.maxProfit([1,2,3,4,5])\\n        XCTAssertEqual(value, 4)\\n    }\\n    \\n    /// There is no way to make a positive profit, so we never buy the stock to achieve the maximum profit of 0.\\n    func test2() {\\n        let value = solution.maxProfit([7,6,4,3,1])\\n        XCTAssertEqual(value, 0)\\n    }\\n}\\n\\nTests.defaultTestSuite.run()\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1635298,
                "title": "o-n-c-one-pass-iterative-solution-100-speed-and-space-with-explaination",
                "content": "We don\\u2019t have any restrictions on the number of deals so we will suppose of a greedy algorithm then. So every time we will buy a stock at a minimum price and sell it at a maximum price. We can observe it as, at each minimum we will buy a stock and at each maximum, we will sell a stock.\\nWe can make it simpler if we observe that a maximum is formed when small values are added to minimum. So instead of tracking every minimum and maximum to calculate the maximum profit, we can directly add those values to our profit for which we form a positive pitch that\\'s ``prices [i]> prices [i-1].`` The addition of all similar values will give us maximum profit. \\n\\n \\n```\\nclass Solution {\\npublic:\\n    int maxProfit(vector<int>& prices) {\\n         int n=prices.size();\\n        int ans = 0;\\n        for (int i = 1; i < n; i++) {\\n            if (prices[i] > prices[i - 1])\\n                ans += prices[i] - prices[i - 1];\\n        }\\n        return ans;\\n    }\\n};\\n```\\n\\n**Time Complexity:** O(n)\\n**Auxiliary Space:** O(1)\\n\\nHit \\uD83D\\uDC4D if you like it :)\\n",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int maxProfit(vector<int>& prices) {\\n         int n=prices.size();\\n        int ans = 0;\\n        for (int i = 1; i < n; i++) {\\n            if (prices[i] > prices[i - 1])\\n                ans += prices[i] - prices[i - 1];\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1539147,
                "title": "c-single-loop-o-n-time-and-o-1-space",
                "content": "# Code for learners who already know this\\n```\\npublic class Solution {\\n    public int MaxProfit(int[] prices) {\\n        \\n        int profit = 0;\\n        \\n        for(int i = 1; i < prices.Length; i++)\\n        {\\n            if(prices[i] > prices[i - 1])\\n                profit += prices[i] - prices[i - 1];\\n        }\\n        \\n        return profit;\\n        \\n    }\\n}\\n```\\n\\n\\n# TL;DR;\\n\\nKey here is you can buy and sell the stock at same day. only constraint is you can only hold 1 stock at a time. so you sell it when profit and buy it same again and sell it if tomorrow price is higher, the profit just cummulates\\n\\n# Details\\n\\nTake the example [8, 2, 5, 6, 3, 10, 1]\\n\\nTry to plot it in a paper as a graph\\nit looks like \\n\\n![image](https://assets.leetcode.com/users/images/610aecf9-fe3b-4d47-a41c-01982b353ae2_1635116844.8589506.png)\\n\\nNow the problem becomes very easy\\nyou just buy when you see low point and sell at high point\\nBut you may think: what if today is low (but you still get profit as the amout you got is lesser than todays market value) but tomorrow may be really high, should i hold onto the stock? \\nYes you can --> but the problem becomes very hard now that you have to know the values ahead and keep a state. \\ninstead --> you sell today, get a profit and store the profit, and then buy the stock back again, and hold the new one and sell it off tomorrow, again when the market is higher. \\n\\nthis is emulated in the code where i just sell and then rebuy. but in a code way where i just get the difference. \\n\\nlets take an example: \\n\\ni got a stock brought at Rs 1 (got yesterday -- say)\\ntoday value is Rs 5 ( if i sell today the profit is 4) but tomorrow the market is at 10\\nif i just hold on and sell the Rs 1 stock at 10 --> my profit is 9\\n\\nbut you still get same profit if  you sell today at 5 (profit 4) then rebuy same stock at 5 and sell tomorrow at 10 (profit 5) so total profit is (4+5) still 9\\n\\n\\n",
                "solutionTags": [
                    "C#"
                ],
                "code": "```\\npublic class Solution {\\n    public int MaxProfit(int[] prices) {\\n        \\n        int profit = 0;\\n        \\n        for(int i = 1; i < prices.Length; i++)\\n        {\\n            if(prices[i] > prices[i - 1])\\n                profit += prices[i] - prices[i - 1];\\n        }\\n        \\n        return profit;\\n        \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1010989,
                "title": "python-one-line",
                "content": "```\\ndef maxProfit(self, prices: List[int]) -> int:\\n        return sum(max(b-a,0) for a,b in zip(prices, prices[1:]))\\n```\\nYay! I got to use zip finally :) Would appreciate your feedback on improving my solution.",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\ndef maxProfit(self, prices: List[int]) -> int:\\n        return sum(max(b-a,0) for a,b in zip(prices, prices[1:]))\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 293113,
                "title": "javascript-solution",
                "content": "```\\nvar maxProfit = function(prices) {\\n    let profit = 0;\\n    for (let i = 0; i < prices.length - 1; i++) {\\n        const possibleProfit = prices[i + 1] - prices[i];\\n        profit = Math.max(profit + possibleProfit, profit);\\n    }\\n    return profit;\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nvar maxProfit = function(prices) {\\n    let profit = 0;\\n    for (let i = 0; i < prices.length - 1; i++) {\\n        const possibleProfit = prices[i + 1] - prices[i];\\n        profit = Math.max(profit + possibleProfit, profit);\\n    }\\n    return profit;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 39549,
                "title": "a-concise-solution-in-java",
                "content": "    public class Solution {\\n        public int maxProfit(int[] prices) {\\n            int len = prices.length;\\n            int profit = 0;\\n            for(int i = 1; i < len ; i++){\\n                if(prices[i]-prices[i-1] <= 0){\\n                    continue;\\n                }\\n                profit += prices[i]-prices[i-1];\\n            }\\n            return profit;\\n        }\\n    }",
                "solutionTags": [],
                "code": "class Solution {\\n        public int maxProfit(int[] prices) {\\n            int len = prices.length;\\n            int profit = 0;\\n            for(int i = 1; i < len ; i++){\\n                if(prices[i]-prices[i-1] <= 0){\\n                    continue;\\n                }",
                "codeTag": "Java"
            },
            {
                "id": 3821888,
                "title": "beats-100-0ms",
                "content": "git gud\\n```\\nclass Solution {\\n    public int maxProfit(int[] prices) {\\n        int profit = 0;\\n        for (int i = 1; i < prices.length; i++) {\\n            if (prices[i] > prices[i - 1]) {\\n                profit += prices[i] - prices[i - 1];\\n            } \\n        }\\n        return profit;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int maxProfit(int[] prices) {\\n        int profit = 0;\\n        for (int i = 1; i < prices.length; i++) {\\n            if (prices[i] > prices[i - 1]) {\\n                profit += prices[i] - prices[i - 1];\\n            } \\n        }\\n        return profit;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3665058,
                "title": "easiest-solution-for-beginners-c",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity: O(n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int maxProfit(vector<int>& prices) {\\n        int ans=0;\\n        for(int i=0;i<prices.size()-1;i++){\\n            if(prices[i+1]>prices[i]) ans=ans+(prices[i+1]-prices[i]);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int maxProfit(vector<int>& prices) {\\n        int ans=0;\\n        for(int i=0;i<prices.size()-1;i++){\\n            if(prices[i+1]>prices[i]) ans=ans+(prices[i+1]-prices[i]);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3364416,
                "title": "best-5-o-n-solution",
                "content": "# Approach 1\\nRecursion (TLE)\\n\\n# Complexity\\n- Time complexity:\\n$$O(2^n)$$\\n\\n- Space complexity:\\n$$O(n)$$\\n\\n# Code\\n```\\nclass Solution {\\nprivate:\\n    int solve(int idx, int buy, vector<int>& prices, int n) {\\n        if (idx == n)\\n            return 0;\\n        int profit;\\n        if (buy == 1) \\n            profit = max (-prices[idx] + solve(idx+1, 0, prices, n), 0 + solve(idx+1, 1, prices, n));\\n        else\\n            profit = max (prices[idx] + solve(idx+1, 1, prices, n), 0 + solve(idx+1, 0, prices, n));\\n        return profit;     \\n    }    \\npublic:\\n    int maxProfit(vector<int>& prices) {\\n        int n = prices.size();\\n        return solve(0, 1, prices, n);\\n    }\\n};\\n```\\n\\n# Approach 2\\nDP (Top Down Approach)\\n\\n# Complexity\\n- Time complexity:\\n$$O(n)$$\\n\\n- Space complexity:\\n$$O(n)$$\\n\\n# Code\\n```\\nclass Solution {\\nprivate:\\n    int solve(int idx, int buy, vector<int>& prices, vector<vector<int>>& dp, int n) {\\n        if (idx == n)\\n            return 0;\\n        if (dp[idx][buy] != -1)\\n            return dp[idx][buy];  \\n        int profit;\\n        if (buy == 1) \\n            profit = max (-prices[idx] + solve(idx+1, 0, prices, dp, n), 0 + solve(idx+1, 1, prices, dp, n));\\n        else\\n            profit = max (prices[idx] + solve(idx+1, 1, prices, dp, n), 0 + solve(idx+1, 0, prices, dp, n));\\n        return dp[idx][buy] = profit;     \\n    }    \\npublic:\\n    int maxProfit(vector<int>& prices) {\\n        int n = prices.size();\\n        vector<vector<int>> dp(n+1, vector<int>(2, -1));\\n        return solve(0, 1, prices, dp, n);\\n    }\\n};\\n```\\n\\n# Approach 3\\nDP (Bottom Up Approach)\\n\\n# Complexity\\n- Time complexity:\\n$$O(n)$$\\n\\n- Space complexity:\\n$$O(n)$$\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int maxProfit(vector<int>& prices) {\\n        int n = prices.size();\\n        vector<vector<int>> dp(n+1, vector<int>(2, 0));\\n        dp[n][0] = dp[n][1] = 0;\\n        for (int idx = n-1; idx >= 0; idx--) {\\n            for (int buy = 0; buy <= 1; buy++) {\\n                int profit;\\n                if (buy == 1) \\n                    profit = max (-prices[idx] + dp[idx+1][0], 0 + dp[idx+1][1]);\\n                else\\n                    profit = max (prices[idx] + dp[idx+1][1], 0 + dp[idx+1][0]);\\n                dp[idx][buy] = profit; \\n            }\\n        }\\n        return dp[0][1];\\n    }\\n};\\n```\\n\\n# Approach 4\\nDP (Bottom Up Approach) + Space Optimization\\n\\n# Complexity\\n- Time complexity:\\n$$O(n)$$\\n\\n- Space complexity:\\n$$O(1)$$\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int maxProfit(vector<int>& prices) {\\n        int n = prices.size();\\n        vector <int> ahead(2, 0), cur(2, 0);\\n        ahead[0] = ahead[1] = 0;\\n        for (int idx = n-1; idx >= 0; idx--) {\\n            for (int buy = 0; buy <= 1; buy++) {\\n                int profit;\\n                if (buy == 1) \\n                    profit = max (-prices[idx] + ahead[0], 0 + ahead[1]);\\n                else\\n                    profit = max (prices[idx] + ahead[1], 0 + ahead[0]);\\n                cur[buy] = profit; \\n            }\\n            ahead = cur;\\n        }\\n        return ahead[1];\\n    }\\n};\\n```\\n\\n# Approach 5\\nUsing 4 Variables\\n\\n# Complexity\\n- Time complexity:\\n$$O(n)$$\\n\\n- Space complexity:\\n$$O(1)$$\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int maxProfit(vector<int>& prices) {\\n        int n = prices.size();\\n        int aheadBuy, aheadNotBuy;\\n        aheadNotBuy = aheadBuy = 0;\\n        int curBuy, curNotBuy;\\n        for (int idx = n-1; idx >= 0; idx--) {\\n            curNotBuy = max (prices[idx] + aheadBuy, 0 + aheadNotBuy);\\n            curBuy = max (-prices[idx] + aheadNotBuy, 0 + aheadBuy);\\n            aheadNotBuy = curNotBuy;\\n            aheadBuy = curBuy;\\n        }\\n        return aheadBuy;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\nprivate:\\n    int solve(int idx, int buy, vector<int>& prices, int n) {\\n        if (idx == n)\\n            return 0;\\n        int profit;\\n        if (buy == 1) \\n            profit = max (-prices[idx] + solve(idx+1, 0, prices, n), 0 + solve(idx+1, 1, prices, n));\\n        else\\n            profit = max (prices[idx] + solve(idx+1, 1, prices, n), 0 + solve(idx+1, 0, prices, n));\\n        return profit;     \\n    }    \\npublic:\\n    int maxProfit(vector<int>& prices) {\\n        int n = prices.size();\\n        return solve(0, 1, prices, n);\\n    }\\n};\\n```\n```\\nclass Solution {\\nprivate:\\n    int solve(int idx, int buy, vector<int>& prices, vector<vector<int>>& dp, int n) {\\n        if (idx == n)\\n            return 0;\\n        if (dp[idx][buy] != -1)\\n            return dp[idx][buy];  \\n        int profit;\\n        if (buy == 1) \\n            profit = max (-prices[idx] + solve(idx+1, 0, prices, dp, n), 0 + solve(idx+1, 1, prices, dp, n));\\n        else\\n            profit = max (prices[idx] + solve(idx+1, 1, prices, dp, n), 0 + solve(idx+1, 0, prices, dp, n));\\n        return dp[idx][buy] = profit;     \\n    }    \\npublic:\\n    int maxProfit(vector<int>& prices) {\\n        int n = prices.size();\\n        vector<vector<int>> dp(n+1, vector<int>(2, -1));\\n        return solve(0, 1, prices, dp, n);\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    int maxProfit(vector<int>& prices) {\\n        int n = prices.size();\\n        vector<vector<int>> dp(n+1, vector<int>(2, 0));\\n        dp[n][0] = dp[n][1] = 0;\\n        for (int idx = n-1; idx >= 0; idx--) {\\n            for (int buy = 0; buy <= 1; buy++) {\\n                int profit;\\n                if (buy == 1) \\n                    profit = max (-prices[idx] + dp[idx+1][0], 0 + dp[idx+1][1]);\\n                else\\n                    profit = max (prices[idx] + dp[idx+1][1], 0 + dp[idx+1][0]);\\n                dp[idx][buy] = profit; \\n            }\\n        }\\n        return dp[0][1];\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    int maxProfit(vector<int>& prices) {\\n        int n = prices.size();\\n        vector <int> ahead(2, 0), cur(2, 0);\\n        ahead[0] = ahead[1] = 0;\\n        for (int idx = n-1; idx >= 0; idx--) {\\n            for (int buy = 0; buy <= 1; buy++) {\\n                int profit;\\n                if (buy == 1) \\n                    profit = max (-prices[idx] + ahead[0], 0 + ahead[1]);\\n                else\\n                    profit = max (prices[idx] + ahead[1], 0 + ahead[0]);\\n                cur[buy] = profit; \\n            }\\n            ahead = cur;\\n        }\\n        return ahead[1];\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    int maxProfit(vector<int>& prices) {\\n        int n = prices.size();\\n        int aheadBuy, aheadNotBuy;\\n        aheadNotBuy = aheadBuy = 0;\\n        int curBuy, curNotBuy;\\n        for (int idx = n-1; idx >= 0; idx--) {\\n            curNotBuy = max (prices[idx] + aheadBuy, 0 + aheadNotBuy);\\n            curBuy = max (-prices[idx] + aheadNotBuy, 0 + aheadBuy);\\n            aheadNotBuy = curNotBuy;\\n            aheadBuy = curBuy;\\n        }\\n        return aheadBuy;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3318165,
                "title": "easy-c-solution-using-stack",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this proble. -->\\nAny stock can buy or sell on same day.\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nUsing Stack to find the next greater element for the stack top.\\nOnce we get the greater element that stack top we store the difference in ans .\\nElse we just pop the stack element.\\nAlso push every element in stack.\\n\\n# Complexity\\n- Time complexity: O(n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(n)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int maxProfit(vector<int>& prices) {\\n        int n=prices.size();\\n        int ans=0;\\n        stack<int>st;\\n        \\n        for(int i=0;i<n;i++){\\n            if(st.empty())st.push(prices[i]);\\n            else{\\n                if(st.top()<prices[i])ans=ans+(prices[i]-st.top());\\n                else{            \\n                   st.pop();\\n                }\\n            }\\n            st.push(prices[i]);\\n        }\\n\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Stack",
                    "Monotonic Stack"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int maxProfit(vector<int>& prices) {\\n        int n=prices.size();\\n        int ans=0;\\n        stack<int>st;\\n        \\n        for(int i=0;i<n;i++){\\n            if(st.empty())st.push(prices[i]);\\n            else{\\n                if(st.top()<prices[i])ans=ans+(prices[i]-st.top());\\n                else{            \\n                   st.pop();\\n                }\\n            }\\n            st.push(prices[i]);\\n        }\\n\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3115181,
                "title": "tc-o-n-sc-const-recursive-memoization-tabulation-space-optimization",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity: O(n) For Space Optimized Method\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: Constant For Space Optimized Method\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n-> RECURSIVE SOLUTION\\n\\nclass Solution {\\npublic:\\n     int f(int ind,int buy,vector<int>&prices,int n)\\n    {\\n        if(ind==n) return 0;\\n        int profit=0;\\n        if(buy==1)\\n            profit=max(-prices[ind]+f(ind+1,0,prices,n),0+f(ind+1,1,prices,n));\\n        else\\n            profit=max(prices[ind]+f(ind+1,1,prices,n),f(ind+1,0,prices,n));\\n        return profit;\\n    }\\n    int maxProfit(vector<int>& prices) {\\n        int n=prices.size();\\n        return f(0,1,prices,n);\\n    }\\n};\\n\\n----------------------------------------------------------------------\\n-> MEMOIZATION METHOD\\n\\nclass Solution {\\npublic:\\n    int f(int ind,int buy,vector<int>&prices,int n,vector<vector<int>>&dp)\\n    {\\n        if(ind==n) return 0;\\n        int profit=0;\\n\\n        if(dp[ind][buy]!=-1) return dp[ind][buy];\\n        if(buy==1)\\n            profit=max(-prices[ind]+f(ind+1,0,prices,n,dp),0+f(ind+1,1,prices,n,dp));\\n        else\\n            profit=max(prices[ind]+f(ind+1,1,prices,n,dp),f(ind+1,0,prices,n,dp));\\n\\n        return dp[ind][buy]=profit;\\n    }\\n    int maxProfit(vector<int>& prices) {\\n        int n=prices.size();\\n        vector<vector<int>>dp(n+1,vector<int>(2,0));\\n        return f(0,1,prices,n,dp);\\n    }\\n};\\n\\n----------------------------------------------------------------------\\n-> TABULATION METHOD\\n\\nclass Solution {\\npublic:\\n    int maxProfit(vector<int>& prices) {\\n        int n=prices.size();\\n        dp[n][0]=dp[n][1]=0;\\n        int profit=0;\\n        for(int ind=n-1;ind>=0;ind--)\\n        {\\n            for(int buy=0;buy<=1;buy++)\\n            {\\n                if(buy==1)\\n                    profit=max(-prices[ind]+dp[ind+1][0],dp[ind+1][1]);\\n                else\\n                    profit=max(prices[ind]+dp[ind+1][1],dp[ind+1][0]);\\n\\n                dp[ind][buy]=profit;\\n            }\\n            \\n        }\\n        return dp[0][1];\\n    }\\n};\\n\\n----------------------------------------------------------------------\\n->SPACE OPTIMIZATION METHOD\\n\\nclass Solution {\\npublic:\\n    int maxProfit(vector<int>& prices) {\\n        int n=prices.size();\\n        vector<int>prev(2,0),curr(2,0);\\n        prev[0]=prev[1]=0;\\n        int profit=0;\\n        for(int ind=n-1;ind>=0;ind--)\\n        {\\n            for(int buy=0;buy<=1;buy++)\\n            {\\n                if(buy==1)\\n                    profit=max(-prices[ind]+prev[0],prev[1]);\\n                else\\n                    profit=max(prices[ind]+prev[1],prev[0]);\\n\\n                curr[buy]=profit;\\n            }\\n            prev=curr;\\n        }\\n        return prev[1];   \\n    }\\n};",
                "solutionTags": [
                    "C++",
                    "Array",
                    "Dynamic Programming",
                    "Recursion",
                    "Memoization"
                ],
                "code": "class Solution {\\npublic:\\n     int f(int ind,int buy,vector<int>&prices,int n)\\n    {\\n        if(ind==n) return 0;\\n        int profit=0;\\n        if(buy==1)\\n            profit=max(-prices[ind]+f(ind+1,0,prices,n),0+f(ind+1,1,prices,n));\\n        else\\n            profit=max(prices[ind]+f(ind+1,1,prices,n),f(ind+1,0,prices,n));\\n        return profit;\\n    }",
                "codeTag": "Java"
            },
            {
                "id": 2700891,
                "title": "c-easy-fast-short-dynamic-programming-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    int maxProfit(vector<int>& prices) {\\n        int profit = 0;\\n        int min = prices[0];\\n        \\n        for(int i=1;i<prices.size();i++)\\n        {\\n            if(prices[i]<prices[i-1])\\n            {\\n                min = prices[i];\\n                continue;\\n            }\\n            profit += prices[i] - min;\\n            min = prices[i];\\n        }\\n        \\n        return profit;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int maxProfit(vector<int>& prices) {\\n        int profit = 0;\\n        int min = prices[0];\\n        \\n        for(int i=1;i<prices.size();i++)\\n        {\\n            if(prices[i]<prices[i-1])\\n            {\\n                min = prices[i];\\n                continue;\\n            }\\n            profit += prices[i] - min;\\n            min = prices[i];\\n        }\\n        \\n        return profit;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2113567,
                "title": "python-4-approaches-entire-dp",
                "content": "\\n**Recursion -> TLE\\nTime Complexity: O(N*2)\\nSpace Complexity: O(N)**\\n\\n```\\ndef f(ind,buy,prices):\\n\\n    if(ind == len(prices)):\\n        return 0\\n    \\n    if(buy):\\n        profit = max(-prices[ind] + f(ind+1,0,prices), 0 + f(ind+1,1,prices))\\n\\t\\t\\n    else:\\n        profit = max(prices[ind] + f(ind+1,1,prices), 0 + f(ind+1,0,prices))\\n\\t\\t\\n    return profit    \\n\\t\\nclass Solution:\\n    def maxProfit(self, prices: List[int]) -> int:\\n        \\n        return f(0,1,prices)\\n```\\n\\n**Memoization**\\n**Time Complexity: O(N*2)**\\n**Space Complexity: O(N*2) + O(N)**\\n\\n```\\ndef f(ind,buy,prices,dp):\\n\\n    if(ind == len(prices)):\\n        return 0\\n    \\n    if(dp[ind][buy] != -1):\\n        return dp[ind][buy]\\n    \\n    if(buy):\\n        profit = max(-prices[ind] + f(ind+1,0,prices,dp), 0 + f(ind+1,1,prices,dp))\\n\\t\\t\\n    else:\\n        profit = max(prices[ind] + f(ind+1,1,prices,dp), 0 + f(ind+1,0,prices,dp))\\n        \\n    dp[ind][buy] = profit\\n    return dp[ind][buy]\\n\\t\\nclass Solution:\\n    def maxProfit(self, prices: List[int]) -> int:\\n\\t\\n        n = len(prices)\\n        dp = [[-1 for i in range(2)] for i in range(n)]\\n\\t\\t\\n        return f(0,1,prices,dp)\\n```\\n\\n**Tabulation**\\n**Time Complexity: O(N*2)**\\n**Space Complexity: O(N*2)**\\n\\n```\\nclass Solution:\\n    def maxProfit(self, prices: List[int]) -> int:\\n        \\n        n = len(prices)\\n        dp = [[-1 for i in range(2)] for i in range(n+1)]\\n        \\n        dp[n][0] = dp[n][1] = 0\\n            \\n        ind = n-1\\n        while(ind>=0):\\n\\t\\t\\n            for buy in range(2):\\n\\t\\t\\t\\tif(buy):\\n                    profit = max(-prices[ind] + dp[ind+1][0], 0 + dp[ind+1][1])\\n\\t\\t\\t\\t\\t\\n                else:\\n                    profit = max(prices[ind] + dp[ind+1][1], 0 + dp[ind+1][0])\\n                    \\n                dp[ind][buy] = profit\\n\\t\\t\\t\\t\\n            ind -= 1    \\n\\t\\t\\t\\n        return dp[0][1]\\n```\\n\\n**Tabulation with SPACE OPTIMIZED**\\n**Time Complexity: O(N*2)**\\n**Space Complexity: O(N)**\\n\\n```\\nclass Solution:\\n    def maxProfit(self, prices: List[int]) -> int:\\n        \\n        n = len(prices)\\n        \\n        ahead = [0 for i in range(2)]\\n        curr = [0 for i in range(2)]\\n        \\n        ahead[0] = ahead[1] = 0\\n            \\n        ind = n-1\\n        while(ind>=0):\\n\\t\\t\\n            for buy in range(2):\\n                if(buy):\\n                    profit = max(-prices[ind] + ahead[0], 0 + ahead[1])\\n\\t\\t\\t\\t\\t\\n                else:\\n                    profit = max(prices[ind] + ahead[1], 0 + ahead[0])\\n                    \\n                curr[buy] = profit\\n\\t\\t\\t\\t\\n            ahead = [x for x in curr]    \\n            ind -= 1    \\n\\t\\t\\t\\n        return ahead[1]\\n```\\n\\n**Please upvote if you find it useful !!!**",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Dynamic Programming",
                    "Recursion"
                ],
                "code": "```\\ndef f(ind,buy,prices):\\n\\n    if(ind == len(prices)):\\n        return 0\\n    \\n    if(buy):\\n        profit = max(-prices[ind] + f(ind+1,0,prices), 0 + f(ind+1,1,prices))\\n\\t\\t\\n    else:\\n        profit = max(prices[ind] + f(ind+1,1,prices), 0 + f(ind+1,0,prices))\\n\\t\\t\\n    return profit    \\n\\t\\nclass Solution:\\n    def maxProfit(self, prices: List[int]) -> int:\\n        \\n        return f(0,1,prices)\\n```\n```\\ndef f(ind,buy,prices,dp):\\n\\n    if(ind == len(prices)):\\n        return 0\\n    \\n    if(dp[ind][buy] != -1):\\n        return dp[ind][buy]\\n    \\n    if(buy):\\n        profit = max(-prices[ind] + f(ind+1,0,prices,dp), 0 + f(ind+1,1,prices,dp))\\n\\t\\t\\n    else:\\n        profit = max(prices[ind] + f(ind+1,1,prices,dp), 0 + f(ind+1,0,prices,dp))\\n        \\n    dp[ind][buy] = profit\\n    return dp[ind][buy]\\n\\t\\nclass Solution:\\n    def maxProfit(self, prices: List[int]) -> int:\\n\\t\\n        n = len(prices)\\n        dp = [[-1 for i in range(2)] for i in range(n)]\\n\\t\\t\\n        return f(0,1,prices,dp)\\n```\n```\\nclass Solution:\\n    def maxProfit(self, prices: List[int]) -> int:\\n        \\n        n = len(prices)\\n        dp = [[-1 for i in range(2)] for i in range(n+1)]\\n        \\n        dp[n][0] = dp[n][1] = 0\\n            \\n        ind = n-1\\n        while(ind>=0):\\n\\t\\t\\n            for buy in range(2):\\n\\t\\t\\t\\tif(buy):\\n                    profit = max(-prices[ind] + dp[ind+1][0], 0 + dp[ind+1][1])\\n\\t\\t\\t\\t\\t\\n                else:\\n                    profit = max(prices[ind] + dp[ind+1][1], 0 + dp[ind+1][0])\\n                    \\n                dp[ind][buy] = profit\\n\\t\\t\\t\\t\\n            ind -= 1    \\n\\t\\t\\t\\n        return dp[0][1]\\n```\n```\\nclass Solution:\\n    def maxProfit(self, prices: List[int]) -> int:\\n        \\n        n = len(prices)\\n        \\n        ahead = [0 for i in range(2)]\\n        curr = [0 for i in range(2)]\\n        \\n        ahead[0] = ahead[1] = 0\\n            \\n        ind = n-1\\n        while(ind>=0):\\n\\t\\t\\n            for buy in range(2):\\n                if(buy):\\n                    profit = max(-prices[ind] + ahead[0], 0 + ahead[1])\\n\\t\\t\\t\\t\\t\\n                else:\\n                    profit = max(prices[ind] + ahead[1], 0 + ahead[0])\\n                    \\n                curr[buy] = profit\\n\\t\\t\\t\\t\\n            ahead = [x for x in curr]    \\n            ind -= 1    \\n\\t\\t\\t\\n        return ahead[1]\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1540602,
                "title": "the-art-of-dynamic-programming",
                "content": "[\\uD83C\\uDFA8 The ART of Dynamic Programming:](https://leetcode.com/discuss/general-discussion/712010/The-ART-of-Dynamic-Programming-An-Intuitive-Approach%3A-from-Apprentice-to-Master)we can use [Kadane\\'s algorithm](https://en.wikipedia.org/wiki/Maximum_subarray_problem) to track the \"best ending here\" during a linear scan of the input array of prices `A`, ie. we greedily buy/sell when the prices are monotonically increasing, since this is the only time proft is made.\\n\\n---\\n\\n*Kotlin*\\n```\\nclass Solution {\\n    fun maxProfit(A: IntArray): Int {\\n        var best = 0\\n        for (i in 1 until A.size)\\n            best += Math.max(0, A[i] - A[i - 1])\\n        return best\\n    }\\n}\\n```\\n\\n*Javascript*\\n```\\nlet maxProfit = (A, best = 0) => {\\n    for (let i = 1; i < A.length; ++i)\\n        best += Math.max(0, A[i] - A[i - 1]);\\n    return best;\\n};\\n```\\n\\n*Python3*\\n```\\nclass Solution:\\n    def maxProfit(self, A: List[int], best = 0) -> int:\\n        for i in range(1, len(A)):\\n            best += max(0, A[i] - A[i - 1])\\n        return best\\n```\\n\\n*C++*\\n```\\nclass Solution {\\npublic:\\n    using VI = vector<int>;\\n    int maxProfit(VI& A, int best = 0) {\\n        for (auto i{ 1 }; i < A.size(); ++i)\\n            best += max(0, A[i] - A[i - 1]);\\n        return best;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    fun maxProfit(A: IntArray): Int {\\n        var best = 0\\n        for (i in 1 until A.size)\\n            best += Math.max(0, A[i] - A[i - 1])\\n        return best\\n    }\\n}\\n```\n```\\nlet maxProfit = (A, best = 0) => {\\n    for (let i = 1; i < A.length; ++i)\\n        best += Math.max(0, A[i] - A[i - 1]);\\n    return best;\\n};\\n```\n```\\nclass Solution:\\n    def maxProfit(self, A: List[int], best = 0) -> int:\\n        for i in range(1, len(A)):\\n            best += max(0, A[i] - A[i - 1])\\n        return best\\n```\n```\\nclass Solution {\\npublic:\\n    using VI = vector<int>;\\n    int maxProfit(VI& A, int best = 0) {\\n        for (auto i{ 1 }; i < A.size(); ++i)\\n            best += max(0, A[i] - A[i - 1]);\\n        return best;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1465876,
                "title": "java-both-greedy-and-dp-most-intuitive-dp-explanation-time-o-n-space-o-1",
                "content": "Greedy solution:\\n```\\n// 1) If there is any price increase p[i] > p[i-1], we can purchase at\\n// day[i-1] and see day[i] and make a profit.\\n// 2) If there is any price decrease, we would sell in the previous day\\n// and avoid that lost.\\n// So overall, the max will be sum(all_gain_delta).\\nclass Solution {\\n    public int maxProfit(int[] prices) {\\n        int result = 0;\\n        for (int i = 1; i < prices.length; i++) {\\n            int delta = prices[i] - prices[i - 1];\\n            result += delta > 0 ? delta : 0;\\n            // result += Math.max(delta, 0);  // Same as above.\\n        }\\n        return result;\\n    }\\n}\\n```\\n\\nDP solution:\\n```\\n// State machine:\\n// At each day i, there are two states: [have] / [don\\'t] have the stock.\\n// At each state, there are two moves one can do:\\n// 1) [i-1][have]: do_nothing -> [i][have], sell -> [i][don\\'t]; \\n// 2) [i-1][don\\'t]: do nothing -> [i][don\\'t], buy -> [i][have];\\n// Which gives us the following DP equation.\\n//    dp[i][have] = max(dp[i-1][don\\'t] - prices[i], dp[i-1][have])\\n//    dp[i][don\\'t] = max(dp[i-1][have] + prices[i], dp[i-1][don\\'t])\\n// Where:\\n//  1) dp[i][x] is at that state, the money one has. which means:\\n//  2) buying stock cause you lose money (- prices[i] above)\\n//  3) and selling stock cause you gain money (+ prices[i] above)\\nclass Solution {\\n    public int maxProfit(int[] prices) {\\n        // 0 have, 1 don\\'t.\\n        int[][] dp = new int[prices.length][2];\\n        dp[0][0] = - prices[0];  // Buy at prices[0] (1st day).\\n        dp[0][1] = 0; // Impossible to sell at day 1. Keep it 0.\\n        for (int i = 1; i < prices.length; i++) {\\n            dp[i][0] = Math.max(dp[i - 1][1] - prices[i], dp[i - 1][0]);\\n            dp[i][1] = Math.max(dp[i - 1][0] + prices[i], dp[i - 1][1]);\\n        }\\n        // Return the last day at the sell state.\\n        return dp[prices.length - 1][1];\\n    }\\n}\\n// Optimization:\\n// We don\\'t need a O(2n) size 2D arr to store every day.\\n// Just store the previous day\\'s sell or buy state is enough.\\n// Which makes the Space O(1).\\n```",
                "solutionTags": [
                    "Java",
                    "Dynamic Programming",
                    "Greedy"
                ],
                "code": "```\\n// 1) If there is any price increase p[i] > p[i-1], we can purchase at\\n// day[i-1] and see day[i] and make a profit.\\n// 2) If there is any price decrease, we would sell in the previous day\\n// and avoid that lost.\\n// So overall, the max will be sum(all_gain_delta).\\nclass Solution {\\n    public int maxProfit(int[] prices) {\\n        int result = 0;\\n        for (int i = 1; i < prices.length; i++) {\\n            int delta = prices[i] - prices[i - 1];\\n            result += delta > 0 ? delta : 0;\\n            // result += Math.max(delta, 0);  // Same as above.\\n        }\\n        return result;\\n    }\\n}\\n```\n```\\n// State machine:\\n// At each day i, there are two states: [have] / [don\\'t] have the stock.\\n// At each state, there are two moves one can do:\\n// 1) [i-1][have]: do_nothing -> [i][have], sell -> [i][don\\'t]; \\n// 2) [i-1][don\\'t]: do nothing -> [i][don\\'t], buy -> [i][have];\\n// Which gives us the following DP equation.\\n//    dp[i][have] = max(dp[i-1][don\\'t] - prices[i], dp[i-1][have])\\n//    dp[i][don\\'t] = max(dp[i-1][have] + prices[i], dp[i-1][don\\'t])\\n// Where:\\n//  1) dp[i][x] is at that state, the money one has. which means:\\n//  2) buying stock cause you lose money (- prices[i] above)\\n//  3) and selling stock cause you gain money (+ prices[i] above)\\nclass Solution {\\n    public int maxProfit(int[] prices) {\\n        // 0 have, 1 don\\'t.\\n        int[][] dp = new int[prices.length][2];\\n        dp[0][0] = - prices[0];  // Buy at prices[0] (1st day).\\n        dp[0][1] = 0; // Impossible to sell at day 1. Keep it 0.\\n        for (int i = 1; i < prices.length; i++) {\\n            dp[i][0] = Math.max(dp[i - 1][1] - prices[i], dp[i - 1][0]);\\n            dp[i][1] = Math.max(dp[i - 1][0] + prices[i], dp[i - 1][1]);\\n        }\\n        // Return the last day at the sell state.\\n        return dp[prices.length - 1][1];\\n    }\\n}\\n// Optimization:\\n// We don\\'t need a O(2n) size 2D arr to store every day.\\n// Just store the previous day\\'s sell or buy state is enough.\\n// Which makes the Space O(1).\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1428296,
                "title": "all-c-solutions-from-brute-force-to-simple-one-pass",
                "content": "***All possible solutions in C++. Please Upvote if found useful!*** \\n*Ask doubts in comment section.*\\n\\n1. Iterative Brute Force with O(1) space complexity\\n```\\n    int maxProfit(vector<int>& prices) {\\n        int n = prices.size();\\n        int maxProfit=0;\\n        int sum=0;\\n        for(int i=0; i<n; i++){\\n            for(int j=i+1; j<n && prices[j]>prices[i]; j++){\\n                sum += prices[j]-prices[i];\\n                if(sum>maxProfit)\\n                    maxProfit = sum;\\n                break;\\n            }\\n        }\\n        return maxProfit;\\n    }\\n```\\n2. Peak - Valley Approach: O(n) Single Pass Time and O(1) Space -> If we plot all the stock prices on graph, we can see this clearly that valleys and peaks(tips) of the graph are our only interest points.\\n```\\n    int maxProfit(vector<int>& prices) {\\n        int n = prices.size();\\n        int maxProfit=0;\\n        int valley = prices[0]; //Initialize valley\\n        int peak = prices[0];  //Initialize peak\\n        int i=0;\\n        while(i < n-1){\\n            //To find earliest valley\\n            while(i<n-1 && prices[i]>=prices[i+1])\\n                i++;\\n            valley = prices[i];\\n            \\n            //To find farthest peak\\n            while(i<n-1 && prices[i]<=prices[i+1])\\n                i++;\\n            peak = prices[i];\\n            maxProfit += peak - valley;            \\n        }\\n\\t\\t\\t\\treturn maxProfit\\n        \\n    }\\n```\\n3. Simple One Pass Approach (O(n) Time complexity and O(1) Space complexity)\\n\\t```\\t\\t\\n    int maxProfit(vector<int>& prices) {\\n        int max_profit = 0;\\n        for (int i = 1; i < prices.size(); i++) {\\n            if (prices[i] > prices[i - 1])\\n                max_profit += prices[i] - prices[i - 1];\\n        }\\n        return max_profit;\\n    }",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\n    int maxProfit(vector<int>& prices) {\\n        int n = prices.size();\\n        int maxProfit=0;\\n        int sum=0;\\n        for(int i=0; i<n; i++){\\n            for(int j=i+1; j<n && prices[j]>prices[i]; j++){\\n                sum += prices[j]-prices[i];\\n                if(sum>maxProfit)\\n                    maxProfit = sum;\\n                break;\\n            }\\n        }\\n        return maxProfit;\\n    }\\n```\n```\\n    int maxProfit(vector<int>& prices) {\\n        int n = prices.size();\\n        int maxProfit=0;\\n        int valley = prices[0]; //Initialize valley\\n        int peak = prices[0];  //Initialize peak\\n        int i=0;\\n        while(i < n-1){\\n            //To find earliest valley\\n            while(i<n-1 && prices[i]>=prices[i+1])\\n                i++;\\n            valley = prices[i];\\n            \\n            //To find farthest peak\\n            while(i<n-1 && prices[i]<=prices[i+1])\\n                i++;\\n            peak = prices[i];\\n            maxProfit += peak - valley;            \\n        }\\n\\t\\t\\t\\treturn maxProfit\\n        \\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 886074,
                "title": "beginner-friendly-solution-100-space-efficient-and-100-time-efficient",
                "content": "```\\nint maxProfit(vector<int>& prices) \\n    {\\n        int profit=0;\\n        for(int i=0;i<prices.size()-1;i++)\\n        {\\n            if(prices[i]<prices[i+1])\\n                profit += prices[i+1]-prices[i];            \\n        }\\n        return profit;\\n    }\\n```\\n\\nExplaination : \\nPrices will go up and down, hence it will form a zig-zag curve. Part of the curve will go from up to down and part of the curve will go down to up.\\n\\nWe have to consider the part when it goes down to up i.e prices[i] < prices[i+1]. If that\\'s the case then add to your profit else ignore.\\n\\nHope it\\'s clear if not please let me know.\\nWill be happy to help.\\n\\nP.S: If this helps you, Please upvote it. It will motivate me put good posts in discussion forum.",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nint maxProfit(vector<int>& prices) \\n    {\\n        int profit=0;\\n        for(int i=0;i<prices.size()-1;i++)\\n        {\\n            if(prices[i]<prices[i+1])\\n                profit += prices[i+1]-prices[i];            \\n        }\\n        return profit;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 320865,
                "title": "c-o-n-linear-solution-pretty-straight-forward",
                "content": "With as many buys and sells and you\\'d like, it\\'s a very easy solution. Any two days are either a positive gain or a loss. Add up all the gains. Ignore the losses.\\n\\n```\\nclass Solution {\\npublic:\\n    int maxProfit(vector<int>& prices) {\\n        int aResult = 0;\\n        for (int i=1;i<prices.size();i++) {\\n            aResult = max(aResult, aResult + (prices[i] - prices[i - 1]));\\n        }\\n        return aResult;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int maxProfit(vector<int>& prices) {\\n        int aResult = 0;\\n        for (int i=1;i<prices.size();i++) {\\n            aResult = max(aResult, aResult + (prices[i] - prices[i - 1]));\\n        }\\n        return aResult;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 240505,
                "title": "ruby-2-solutions-with-explanation",
                "content": "**Good Solution**\\nEssentially you want to find each peak and each valley, and every time you go from a peak to a valley, you\\'ll add the difference as profit. That would simulate buying at the valley, and selling at the peak. The first instance where the next price is higher, indicates a valley, so buy a share and indicate that you have a share. If you reach a peak, any point where the next price is lower, then if you have a share you can sell it and make your profit. Once you\\'ve reached the end, if you have a share, sell it off.\\n```\\ndef max_profit(prices)\\n     return 0 if prices.length < 2\\n    \\n     bought_share = false\\n     money = 0\\n     i = 0\\n    \\n     while i < prices.length - 1\\n         if prices[i] < prices[i + 1] && !bought_share\\n             bought_share = true\\n             money -= prices[i]\\n         end\\n         if prices[i] > prices[i + 1] && bought_share\\n             bought_share = false\\n             money += prices[i]\\n         end\\n         i += 1\\n     end\\n\\t \\n     money += prices[i] if bought_share\\n     money\\nend\\n```\\n\\n**Better Solution**\\nNow to show that you really know how to think beyond the obvious, you\\'ll want to answer this way. If you think about this question, all you really need to do is make profit anytime the next share price is higher than the current share price. You don\\'t need to reach the maximum price point on a run of shares that keep increasing, you can just calculate each step along the way, and put them together, and that\\'s the same as calculating the difference between the lowest point and the highest point. If the share prices are [1, 3, 9], 9 - 1 = 8. However, (3-1)+(9-3) = 8 as well. So just add profit for every little sub peak, and there you have it.\\n```\\ndef max_profit(prices)\\n    money = 0\\n    \\n    prices.each_with_index do |price, i|\\n        if prices[i + 1] && price < prices[i + 1]\\n            money += (prices[i + 1] - price)\\n        end\\n    end\\n    \\n    money \\nend\\n```",
                "solutionTags": [],
                "code": "```\\ndef max_profit(prices)\\n     return 0 if prices.length < 2\\n    \\n     bought_share = false\\n     money = 0\\n     i = 0\\n    \\n     while i < prices.length - 1\\n         if prices[i] < prices[i + 1] && !bought_share\\n             bought_share = true\\n             money -= prices[i]\\n         end\\n         if prices[i] > prices[i + 1] && bought_share\\n             bought_share = false\\n             money += prices[i]\\n         end\\n         i += 1\\n     end\\n\\t \\n     money += prices[i] if bought_share\\n     money\\nend\\n```\n```\\ndef max_profit(prices)\\n    money = 0\\n    \\n    prices.each_with_index do |price, i|\\n        if prices[i + 1] && price < prices[i + 1]\\n            money += (prices[i + 1] - price)\\n        end\\n    end\\n    \\n    money \\nend\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 159307,
                "title": "python-solution",
                "content": "```\\nclass Solution(object):\\n    def maxProfit(self, prices):\\n        \"\"\"\\n        :type prices: List[int]\\n        :rtype: int\\n        \"\"\"\\n        if len(prices) <= 1:\\n            return 0\\n        l = 0\\n        r = 1\\n        tot = 0\\n        while r < len(prices):\\n            while r < len(prices)-1 and prices[l] >= prices[r]:\\n                l += 1\\n                r += 1\\n            while r < len(prices)-1 and prices[r+1] >= prices[r]:\\n                r += 1\\n            if prices[r] > prices[l]:\\n                tot += prices[r] - prices[l]\\n            l = r\\n            r += 1\\n        return tot\\n```\\nA simpler solution implementing the same algorithm:\\n```\\nclass Solution(object):\\n    def maxProfit(self, prices):\\n        \"\"\"\\n        :type prices: List[int]\\n        :rtype: int\\n        \"\"\"\\n        if len(prices) <= 1:\\n            return 0\\n        tot = 0\\n        for i in range(1,len(prices)):\\n            if prices[i] > prices[i-1]:\\n                tot += prices[i] - prices[i-1]\\n        return tot\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution(object):\\n    def maxProfit(self, prices):\\n        \"\"\"\\n        :type prices: List[int]\\n        :rtype: int\\n        \"\"\"\\n        if len(prices) <= 1:\\n            return 0\\n        l = 0\\n        r = 1\\n        tot = 0\\n        while r < len(prices):\\n            while r < len(prices)-1 and prices[l] >= prices[r]:\\n                l += 1\\n                r += 1\\n            while r < len(prices)-1 and prices[r+1] >= prices[r]:\\n                r += 1\\n            if prices[r] > prices[l]:\\n                tot += prices[r] - prices[l]\\n            l = r\\n            r += 1\\n        return tot\\n```\n```\\nclass Solution(object):\\n    def maxProfit(self, prices):\\n        \"\"\"\\n        :type prices: List[int]\\n        :rtype: int\\n        \"\"\"\\n        if len(prices) <= 1:\\n            return 0\\n        tot = 0\\n        for i in range(1,len(prices)):\\n            if prices[i] > prices[i-1]:\\n                tot += prices[i] - prices[i-1]\\n        return tot\\n```",
                "codeTag": "Java"
            },
            {
                "id": 111149,
                "title": "clean-kotlin-solution",
                "content": "```\\nfun maxProfit(prices: IntArray): Int {\\n        return (1 until prices.size)\\n            .map {date -> prices[date] - prices[date - 1] }\\n            .sumBy { profit -> maxOf(profit, 0) }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nfun maxProfit(prices: IntArray): Int {\\n        return (1 until prices.size)\\n            .map {date -> prices[date] - prices[date - 1] }\\n            .sumBy { profit -> maxOf(profit, 0) }\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 39509,
                "title": "c-8ms-o-n-time-and-o-1-space",
                "content": "Actually it's much easier than the previous DP question. For this one, we just need to sum up all profits together.\\n\\n    int maxProfit(vector<int>& prices)\\n    {\\n\\t    int length = prices.size();\\n\\t    if (!length)\\n\\t    {\\n\\t\\t    return 0;\\n\\t    }\\n\\t    int profit = 0;\\n\\t    int temp = 0;\\n\\t    for (int i = length - 1; i > 0; i--)\\n\\t    {\\n\\t\\t    temp = prices[i] - prices[i-1];\\n\\t\\t    if (temp > 0)\\n\\t\\t    {\\n\\t\\t\\t    profit += temp;\\n\\t\\t    }\\n\\t    }\\n\\t\\n\\t    return profit;\\n    }",
                "solutionTags": [],
                "code": "Actually it's much easier than the previous DP question. For this one, we just need to sum up all profits together.\\n\\n    int maxProfit(vector<int>& prices)\\n    {\\n\\t    int length = prices.size();\\n\\t    if (!length)\\n\\t    {\\n\\t\\t    return 0;\\n\\t    }\\n\\t    int profit = 0;\\n\\t    int temp = 0;\\n\\t    for (int i = length - 1; i > 0; i--)\\n\\t    {\\n\\t\\t    temp = prices[i] - prices[i-1];\\n\\t\\t    if (temp > 0)\\n\\t\\t    {\\n\\t\\t\\t    profit += temp;\\n\\t\\t    }\\n\\t    }\\n\\t\\n\\t    return profit;\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 39558,
                "title": "8ms-easy-c-solution",
                "content": "This problem is similar to [Best Time to Buy and Sell Stock][1]. Given `prices`, we find the day (denoted as `buy`) of the first local minimum and the day (denoted as `sell`) of the first local maximum (note that we initialize `sell` to be `buy + 1` each time to guarantee the transaction is valid). Then we earn the profit `prices[sell] - prices[buy]`, after which we update `buy` to be `sell + 1` to check for the remaining `prices`.\\n\\nThe code is as follows.\\n\\n    class Solution {\\n    public: \\n        int maxProfit(vector<int>& prices) {\\n            int buy = 0, sell = 0, profit = 0, n = prices.size();\\n            while (buy < n && sell < n) {\\n                while (buy + 1 < n && prices[buy + 1] < prices[buy])\\n                    buy++; \\n                sell = buy; \\n                while (sell + 1 < n && prices[sell + 1] > prices[sell])\\n                    sell++;\\n                profit += prices[sell] - prices[buy];\\n                buy = sell + 1;\\n            }\\n            return profit;\\n        }\\n    };\\n\\n[1]: https://leetcode.com/problems/best-time-to-buy-and-sell-stock/",
                "solutionTags": [
                    "C++",
                    "Two Pointers",
                    "Greedy"
                ],
                "code": "class Solution {\\n    public: \\n        int maxProfit(vector<int>& prices) {\\n            int buy = 0, sell = 0, profit = 0, n = prices.size();\\n            while (buy < n && sell < n) {\\n                while (buy + 1 < n && prices[buy + 1] < prices[buy])\\n                    buy++; \\n                sell = buy; \\n                while (sell + 1 < n && prices[sell + 1] > prices[sell])\\n                    sell++;\\n                profit += prices[sell] - prices[buy];\\n                buy = sell + 1;\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 3990075,
                "title": "beats-with-100-c-solution-with-explanation",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\nwhen prices goes down buy the stock and if it goes up sell it...\\nIterate through all and sum up all profits!\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int maxProfit(vector<int>& prices) {\\n        int n=prices.size(),i,p;\\n        int profit=0,min=prices[0];\\n        for(i=1;i<n;i++) {\\n            if(prices[i]<min)\\n                min=prices[i];\\n            else if(prices[i]-min>0 )\\n            { \\n               profit+=prices[i]-min;\\n               min=prices[i];\\n            }\\n        }\\n        \\n        return profit;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int maxProfit(vector<int>& prices) {\\n        int n=prices.size(),i,p;\\n        int profit=0,min=prices[0];\\n        for(i=1;i<n;i++) {\\n            if(prices[i]<min)\\n                min=prices[i];\\n            else if(prices[i]-min>0 )\\n            { \\n               profit+=prices[i]-min;\\n               min=prices[i];\\n            }\\n        }\\n        \\n        return profit;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3774318,
                "title": "easy-to-understand-clear-code-c",
                "content": "\\n\\n# Intuition\\n\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n![image.png](https://assets.leetcode.com/users/images/b32a0e29-fd1f-4f59-bf43-cd16edcf31f6_1689521691.2615888.png)\\n\\n# Approach\\n- max_profit=max_profit+prices[i] - prices[i-1];\\n\\n- jaha jaha profit hota jai usko max_profit me add krte jaooooo.\\n\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity: O(N)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int maxProfit(vector<int>& prices) {\\n\\n    int max_profit=0;\\n\\n    for(int i=1;i<prices.size();i++){\\n        if(prices[i] > prices[i-1]){\\n            max_profit=max_profit+prices[i] - prices[i-1];\\n        }\\n    }\\n    return max_profit;   \\n    }\\n};\\n```\\n```\\nclass Solution {\\npublic:\\n    int maxProfit(vector<int>& prices) {\\n       \\n        int buy = prices[0];\\n        int max_profit = 0;\\n\\n        for(int i=1; i<prices.size(); i++){\\n            if(prices[i]<=buy){\\n                buy = prices[i];\\n            }\\n            else{\\n                max_profit += prices[i] - buy;\\n                //most imp step \\n                // buy ko update krna hogaaaaaa\\n                buy = prices[i];\\n            }\\n        }\\n\\n        return max_profit;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Array",
                    "Math",
                    "Dynamic Programming",
                    "Greedy"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int maxProfit(vector<int>& prices) {\\n\\n    int max_profit=0;\\n\\n    for(int i=1;i<prices.size();i++){\\n        if(prices[i] > prices[i-1]){\\n            max_profit=max_profit+prices[i] - prices[i-1];\\n        }\\n    }\\n    return max_profit;   \\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    int maxProfit(vector<int>& prices) {\\n       \\n        int buy = prices[0];\\n        int max_profit = 0;\\n\\n        for(int i=1; i<prices.size(); i++){\\n            if(prices[i]<=buy){\\n                buy = prices[i];\\n            }\\n            else{\\n                max_profit += prices[i] - buy;\\n                //most imp step \\n                // buy ko update krna hogaaaaaa\\n                buy = prices[i];\\n            }\\n        }\\n\\n        return max_profit;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3770405,
                "title": "c-easiest-solution-kaam-ki-baat-no-bakwaas",
                "content": "- Time complexity: O(N)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n- Space complexity: O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n![graph.webp](https://assets.leetcode.com/users/images/e8934b4f-88ab-4e64-a44a-1b64b7dd3738_1689450378.8204722.webp)\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int maxProfit(vector<int>& v) {\\n        int pro = 0;\\n        for(int i = 1;i < v.size();i++){\\n            if(v[i - 1] < v[i]) \\n                pro += (v[i] - v[i - 1]);\\n        }\\n        return pro;\\n    }\\n};\\n```\\n\\n",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int maxProfit(vector<int>& v) {\\n        int pro = 0;\\n        for(int i = 1;i < v.size();i++){\\n            if(v[i - 1] < v[i]) \\n                pro += (v[i] - v[i - 1]);\\n        }\\n        return pro;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3746496,
                "title": "easy-solution-in-java",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n$$O(n)$$\\n\\n- Space complexity:\\n$$O(1)$$\\n\\n# Code\\n```\\nclass Solution {\\n    public int maxProfit(int[] prices) {\\n        //General Approach\\n        int oldPrices = prices[0];\\n        int profit = 0;\\n        for(int i=1;i<prices.length;i++){\\n            if(prices[i]<oldPrices){\\n                //update the oldPrices\\n                oldPrices = prices[i];\\n            }\\n            else{\\n                //find Profit\\n                profit +=prices[i]-oldPrices;\\n                //update the oldPrices\\n                oldPrices = prices[i];\\n            }\\n        }\\n        return profit;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int maxProfit(int[] prices) {\\n        //General Approach\\n        int oldPrices = prices[0];\\n        int profit = 0;\\n        for(int i=1;i<prices.length;i++){\\n            if(prices[i]<oldPrices){\\n                //update the oldPrices\\n                oldPrices = prices[i];\\n            }\\n            else{\\n                //find Profit\\n                profit +=prices[i]-oldPrices;\\n                //update the oldPrices\\n                oldPrices = prices[i];\\n            }\\n        }\\n        return profit;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3668889,
                "title": "c-recurssive-memoization-dp",
                "content": "# Recursive approach will give TLE\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n#   Memoization Code\\n```\\n// class Solution {\\n//     private:\\n//     //recursive approach gives TLE in last 3 cases\\n//     int f(int index, int buy, vector<int>& prices){\\n//         if(index==prices.size()) return 0;\\n\\n//             int profit=0;\\n//             //ya to buy karega ya nhi karega(profit=sell-buy)\\n//         if(buy){\\n//             profit=max(-prices[index]+f(index+1, 0, prices), 0+f(index+1, 1, prices));\\n//         }\\n//         //ya to sell karega ya nhi karega\\n//         else{\\n//             profit=max(prices[index]+f(index+1, 1, prices), 0+f(index+1, 0, prices));\\n//          }\\n//          return profit;\\n//     }\\n// public:\\n//     int maxProfit(vector<int>& prices) {\\n//         return f(0,1,prices);\\n//     }\\n// };\\n\\nclass Solution {\\n    private:\\n    //MEMOIZATION approach(accepted)\\n    int f(int index, int buy, vector<int>& prices, vector<vector<int>>&dp){\\n        if(index==prices.size()) return 0;\\n\\n            int profit=0;\\n            //ya to buy karega ya nhi karega(profit=sell-buy)\\n            if(dp[index][buy]!=-1) return dp[index][buy];\\n        if(buy){\\n            profit=max(-prices[index]+f(index+1, 0, prices,dp), 0+f(index+1, 1, prices, dp));\\n        }\\n        //ya to sell karega ya nhi karega\\n        else{\\n            profit=max(prices[index]+f(index+1, 1, prices,dp), 0+f(index+1, 0, prices, dp));\\n         }\\n         return dp[index][buy] = profit;\\n    }\\npublic:\\n    int maxProfit(vector<int>& prices) {\\n        vector<vector<int>>dp(prices.size()+1, vector<int>(2,-1));\\n        return f(0,1,prices,dp);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\n// class Solution {\\n//     private:\\n//     //recursive approach gives TLE in last 3 cases\\n//     int f(int index, int buy, vector<int>& prices){\\n//         if(index==prices.size()) return 0;\\n\\n//             int profit=0;\\n//             //ya to buy karega ya nhi karega(profit=sell-buy)\\n//         if(buy){\\n//             profit=max(-prices[index]+f(index+1, 0, prices), 0+f(index+1, 1, prices));\\n//         }\\n//         //ya to sell karega ya nhi karega\\n//         else{\\n//             profit=max(prices[index]+f(index+1, 1, prices), 0+f(index+1, 0, prices));\\n//          }\\n//          return profit;\\n//     }\\n// public:\\n//     int maxProfit(vector<int>& prices) {\\n//         return f(0,1,prices);\\n//     }\\n// };\\n\\nclass Solution {\\n    private:\\n    //MEMOIZATION approach(accepted)\\n    int f(int index, int buy, vector<int>& prices, vector<vector<int>>&dp){\\n        if(index==prices.size()) return 0;\\n\\n            int profit=0;\\n            //ya to buy karega ya nhi karega(profit=sell-buy)\\n            if(dp[index][buy]!=-1) return dp[index][buy];\\n        if(buy){\\n            profit=max(-prices[index]+f(index+1, 0, prices,dp), 0+f(index+1, 1, prices, dp));\\n        }\\n        //ya to sell karega ya nhi karega\\n        else{\\n            profit=max(prices[index]+f(index+1, 1, prices,dp), 0+f(index+1, 0, prices, dp));\\n         }\\n         return dp[index][buy] = profit;\\n    }\\npublic:\\n    int maxProfit(vector<int>& prices) {\\n        vector<vector<int>>dp(prices.size()+1, vector<int>(2,-1));\\n        return f(0,1,prices,dp);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3667918,
                "title": "python-short-1-liner-functional-programming",
                "content": "# Approach\\n1. For every day $$d_i$$, if $$prices[d_i] < prices[d_{i + 1}]$$ then buy the stock on $$d_i$$ and sell it on $$d_{i + 1}$$ else do nothing.\\n\\n2. Continue this for each day and return the `sum` of all the profits.\\n\\n# Complexity\\n- Time complexity: $$O(n)$$\\n\\n- Space complexity: $$O(1)$$\\n\\nwhere, `n is length of prices`.\\n\\n# Code\\n```python\\nclass Solution:\\n    def maxProfit(self, prices: list[int]) -> int:\\n        return sum(max(b - a, 0) for a, b in pairwise(prices))\\n\\n\\n```",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Array",
                    "Dynamic Programming",
                    "Greedy"
                ],
                "code": "```python\\nclass Solution:\\n    def maxProfit(self, prices: list[int]) -> int:\\n        return sum(max(b - a, 0) for a, b in pairwise(prices))\\n\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3343157,
                "title": "go-greedy-solution",
                "content": "# Intuition\\n\\nBy greedily selling every time we see a value higher than the current minimum, we can ensure the maximum possible profit. \\n\\nWith this approach, the current minimum is always the previous day\\'s price (as long as it is lower than the current day\\'s price).\\n\\n# Approach\\n\\nThere are two cases to consider:\\n\\n1. `prices[i] < prices[i-1]`\\n    We set `prices[i]` as the current minimum, and __forget__ any previous values\\n2. `prices[i] > prices[i-1]`\\n    We sell greedily to record whatever profit is available, and __reset__ the minimum to `prices[i]`\\n\\nThe above two conditions mean the problem can be solved simply by comparing `prices[i]` and `prices[i-1]`. \\n\\n# Complexity\\n- Time complexity: $$O(n)$$ because we only scan the input array once.\\n\\n- Space complexity: $$O(1)$$ because we only store a local variables to track the result.\\n\\n# Code\\n```\\nfunc maxProfit(prices []int) int {\\n    profit := 0\\n    // no profit available at index 0, so start at index 1\\n    for i := 1; i < len(prices); i++ {\\n        // Only when the current price is higher than the previous\\n        // can we make a profitable sale.\\n        if prices[i] > prices[i-1] {\\n            profit += prices[i] - prices[i-1]\\n        }\\n        // The else case is handled implicitly by incrementing i.\\n        // When prices[i] is lower than prices[i-1], we just skip\\n        // the sale. \\n        //\\n        // If this is confusing, try keeping a `min` variable yourself,\\n        // and you\\'ll soon realise it\\'s redundant.\\n    }\\n    return profit\\n}\\n```",
                "solutionTags": [
                    "Go",
                    "Greedy"
                ],
                "code": "```\\nfunc maxProfit(prices []int) int {\\n    profit := 0\\n    // no profit available at index 0, so start at index 1\\n    for i := 1; i < len(prices); i++ {\\n        // Only when the current price is higher than the previous\\n        // can we make a profitable sale.\\n        if prices[i] > prices[i-1] {\\n            profit += prices[i] - prices[i-1]\\n        }\\n        // The else case is handled implicitly by incrementing i.\\n        // When prices[i] is lower than prices[i-1], we just skip\\n        // the sale. \\n        //\\n        // If this is confusing, try keeping a `min` variable yourself,\\n        // and you\\'ll soon realise it\\'s redundant.\\n    }\\n    return profit\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2986446,
                "title": "c-solution",
                "content": "# Code\\n```\\nclass Solution {\\npublic:\\n    int maxProfit(vector<int>& prices) {\\n        int n = prices.size();\\n        int ans = 0;\\n        for(int i=1; i<n; i++) {\\n            int dif = prices[i] - prices[i-1];\\n            if(dif > 0) ans += dif;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int maxProfit(vector<int>& prices) {\\n        int n = prices.size();\\n        int ans = 0;\\n        for(int i=1; i<n; i++) {\\n            int dif = prices[i] - prices[i-1];\\n            if(dif > 0) ans += dif;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2778944,
                "title": "java-100-faster-o-n",
                "content": "```\\nclass Solution {\\n    public int maxProfit(int[] prices) {\\n        int profit =0;\\n        for(int i =1;i<prices.length;i++)\\n        {\\n            if(prices[i]>prices[i-1])\\n            {\\n                profit=profit+(prices[i]-prices[i-1]);\\n            }\\n        }\\n        return profit;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int maxProfit(int[] prices) {\\n        int profit =0;\\n        for(int i =1;i<prices.length;i++)\\n        {\\n            if(prices[i]>prices[i-1])\\n            {\\n                profit=profit+(prices[i]-prices[i-1]);\\n            }\\n        }\\n        return profit;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2210061,
                "title": "java-in-depth-explanation-o-n-time-o-1-space",
                "content": "Actually, the problem is not that hard as it seems. In problem description, we can buy it then immediately sell it on the same day. That means **\"we can sell then buy the same stock on the same day\"**. That makes the problem surprisingly easier. \\n\\n  `profit = prices[i] - prices[i-1]` Whenever `profit > 0`, we update `max` as `max += profit`. That\\'s it ! We can achieve O(n) time | O(1) space w/ such a straightforward solution.\\n\\n```\\nclass Solution\\n{\\n    public int maxProfit(int[] prices) \\n    {\\n        // O(n) time | O(1) space\\n        \\n        int max = 0;\\n        \\n        for(int i = 1; i < prices.length; i++)\\n        {\\n            if(prices[i] > prices[i-1])\\n                max += prices[i] - prices[i-1];\\n        }\\n        return max;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution\\n{\\n    public int maxProfit(int[] prices) \\n    {\\n        // O(n) time | O(1) space\\n        \\n        int max = 0;\\n        \\n        for(int i = 1; i < prices.length; i++)\\n        {\\n            if(prices[i] > prices[i-1])\\n                max += prices[i] - prices[i-1];\\n        }\\n        return max;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2175471,
                "title": "buy-the-dip-cannot-get-easier-than-this",
                "content": "**There is a classical saying in the stock market - \"Buy the Dip\".\\nSame concept you need to apply here\\nCompare two consecutive days and if you are making a profit, just buy on 1st day and sell on 2nd day**\\n```\\nclass Solution {\\n    public int maxProfit(int[] prices) \\n    {\\n        int profit = 0;\\n        for(int i = 1 ; i < prices.length ; i++)\\n            profit += Math.max(0 , prices[i] - prices[i-1]);\\n        return profit;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int maxProfit(int[] prices) \\n    {\\n        int profit = 0;\\n        for(int i = 1 ; i < prices.length ; i++)\\n            profit += Math.max(0 , prices[i] - prices[i-1]);\\n        return profit;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2004963,
                "title": "c-o-n-time-o-1-space-one-pass-algorithm",
                "content": "\\nThe problem is simple and can be approached in a greedy way .If we look the values as points on a graph , we can say that we need to buy a stock at every minima and sell it at the next maxima whenever it comes . \\nE.g.\\n1 2 3 4 5 1 9 \\nLike ,\\nWe can buy it at 1 and the sell for 5 , then again buy it for 1 and sell for 9 making a total profit of 4+8 = 12 .\\n\\n# Time Complexity : O(n)\\n# Space Complexity : O(1)\\n\\n```\\n       int profit =0;  \\n        int buy = prices[0];  \\n        \\n        for(int i=0;i<prices.size();i++){\\n            if(i == prices.size()-1){\\n                \\n                profit += prices[i]-buy;\\n                break;\\n            }\\n            \\n            if(prices[i]> prices[i+1]){   \\n                //*** if we see that i+1 has lower price than i we sell it prices[i] and buy again for prices[i+1] \\n                \\n                profit += prices[i]-buy;\\n                buy = prices[i+1];\\n            }\\n            \\n         \\n            \\n            \\n        }\\n        \\n        \\n        \\n        return profit;\\n```\\n\\n",
                "solutionTags": [
                    "C",
                    "Greedy"
                ],
                "code": "```\\n       int profit =0;  \\n        int buy = prices[0];  \\n        \\n        for(int i=0;i<prices.size();i++){\\n            if(i == prices.size()-1){\\n                \\n                profit += prices[i]-buy;\\n                break;\\n            }\\n            \\n            if(prices[i]> prices[i+1]){   \\n                //*** if we see that i+1 has lower price than i we sell it prices[i] and buy again for prices[i+1] \\n                \\n                profit += prices[i]-buy;\\n                buy = prices[i+1];\\n            }\\n            \\n         \\n            \\n            \\n        }\\n        \\n        \\n        \\n        return profit;\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1915204,
                "title": "easy-dynamic-programming-solution-explained",
                "content": "Let\\'s assume `P(k)` is our max profit if we buy/sell stocks during `0..k` days.\\n`P(0) = 0` \\u2013 is our base case. We have 0 profit: if we only traded during 1 day, we bought 1 stock for `price[0]` and didn\\'t have the chance to sell for a higher price.\\n\\nHow do we determine `P(k)`?\\nOn day `k` we have several options:\\n1. do nothing\\n2. sell stock that we might have previously bought\\n\\nThe first case is simple. Since we do nothing on day `k`, our total max profit didn\\'t change and is the same as `P(k-1)`.\\n\\nLet\\'s now consider the second case. On day `k` we sell a stock that we previously bought on some day `j`. If we do that, we will potentially get profit or loss in this transaction: `prices[k] - prices[j]`. But our total profit/loss will be `P(j) + prices[k] - prices[j]`. We need to maximize the total profit, so we need to consider all `j` such that `j < k`. \\nIf we try to write it down mathematically, we will get:\\n`P(k) = max { P(j) + prices[k] - prices[j] } for j < k`.\\n\\nCoding according to this formula naively will produce `O(N^2)` algorithm. But it\\'s easy to optimize.\\nWe can see that in the formula, `k` is fixed, so `price[k]` is constant and we can move it out for `max { ... }`:\\n`P(k) = prices[k] + max { P(j) - prices[j] } for j < k`.\\n\\nNow let `T(k) = max { P(j) - prices[j] }  for j < k`, then `P(k) = prices[k] + T(k)`.\\n\\nCombining all this with our \"do nothing\" case, we get:\\n`P(k) = max { P(k-1), prices[k] + T(k) }`, where `T(k) = max { P(j) - prices[j] }  for j < k, P(0) = 0`.\\n\\nSince to compute `P(k)` we only need `P(k-1)` and `T(k)`, we don\\'t need to allocate array for it.\\n`T(k)` is just the current maximum of `P(j) - prices[j]` and can be computed as `T(k) = max { T(k-1),  P(k-1) - prices[k-1]`. We don\\'t need to allocate an array for it either.\\n\\n```\\nclass Solution {\\n    fun maxProfit(prices: IntArray): Int {\\n        if (prices.isEmpty()) return 0\\n        \\n        // p[k] = maxOf(prices[k]-prices[j] + p[j]) \\n        //      = prices[k] + maxOf(p[j] - prices[j])\\n        //      = prices[k] + t[k]\\n        var t = -prices[0] // t[0]\\n        var p = 0 // p[0]\\n        \\n\\t\\tfor (k in prices.indices) {\\n\\t\\t\\t// colculate next p[k]\\n            p = maxOf(p, prices[k] + t)\\n            t = maxOf(t, p - prices[k])\\n        } \\n        \\n        return p\\n    }\\n}\\n```",
                "solutionTags": [
                    "Kotlin",
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution {\\n    fun maxProfit(prices: IntArray): Int {\\n        if (prices.isEmpty()) return 0\\n        \\n        // p[k] = maxOf(prices[k]-prices[j] + p[j]) \\n        //      = prices[k] + maxOf(p[j] - prices[j])\\n        //      = prices[k] + t[k]\\n        var t = -prices[0] // t[0]\\n        var p = 0 // p[0]\\n        \\n\\t\\tfor (k in prices.indices) {\\n\\t\\t\\t// colculate next p[k]\\n            p = maxOf(p, prices[k] + t)\\n            t = maxOf(t, p - prices[k])\\n        } \\n        \\n        return p\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1819596,
                "title": "java-recursion-dynamic-programming-step-by-step",
                "content": "Well there are more efficient ways to solve this problem but I consider this code is helpful in understanding recursion+DP approach. Below is the recursive approach. I further memoise it. Through memoising it is able to pass all test cases.\\n\\nRecursion plays important role here. At any specific day we will have 3 options - \\n\\n1. Buy the stock\\n2. Sell the stock\\n3. Neither buy nor sell, move to next day\\n\\nNow for obvious reasons we cannot sell on the first day(as we will have no holdings). Similarly we cannot buy on the last day. It is also specified in the problem that we can sell the stock and buy it on the same day, so there is chance that we don\\'t move on the next day and remain there only. But for buy condition we need to move on next day because buying and selling on the same day will not affect aur answer (as net profit will be 0).\\n\\n```\\nclass Solution {\\n    public int maxProfit(int[] prices) {\\n        int n = prices.length;\\n        return helper(0, -1, n, prices);\\n    }\\n    \\n    public int helper(int day, int holding, int n, int[] arr){\\n        if(day>=n) return 0;\\n        int buy = day!=n-1 && holding==-1 ? helper(day+1, arr[day], n, arr) : 0;\\n        int sell = day!=0 && holding!=-1 ? arr[day]-holding + helper(day, -1, n, arr) : 0;\\n        int leave = helper(day+1, holding, n, arr);\\n        return Math.max(leave, Math.max(buy, sell));\\n    }\\n    \\n}\\n```\\n\\nAfter memoising (Top-Down Approach) - \\n\\n```\\nclass Solution {\\n    public int maxProfit(int[] prices) {\\n        int n = prices.length;\\n        int[] tp = new int[n];\\n        Arrays.fill(tp, -1);\\n        return helper(0, -1, n, prices, tp);\\n    }\\n    \\n    public int helper(int day, int holding, int n, int[] arr, int[] tp){\\n        if(day>=n) return 0;\\n        if(tp[day]!=-1) return tp[day];\\n        int buy = day!=n-1 && holding==-1 ? helper(day+1, arr[day], n, arr, tp) : 0;\\n        int sell = day!=0 && holding!=-1 ? arr[day]-holding + helper(day, -1, n, arr, tp) : 0;\\n        int leave = helper(day+1, holding, n, arr, tp);\\n        return tp[day] = Math.max(leave, Math.max(buy, sell));\\n    }\\n    \\n}\\n```\\n\\nThanks, you can suggest more optimisations to this approach (or even provide a better one in the comments!! :)).",
                "solutionTags": [
                    "Java",
                    "Dynamic Programming",
                    "Memoization"
                ],
                "code": "```\\nclass Solution {\\n    public int maxProfit(int[] prices) {\\n        int n = prices.length;\\n        return helper(0, -1, n, prices);\\n    }\\n    \\n    public int helper(int day, int holding, int n, int[] arr){\\n        if(day>=n) return 0;\\n        int buy = day!=n-1 && holding==-1 ? helper(day+1, arr[day], n, arr) : 0;\\n        int sell = day!=0 && holding!=-1 ? arr[day]-holding + helper(day, -1, n, arr) : 0;\\n        int leave = helper(day+1, holding, n, arr);\\n        return Math.max(leave, Math.max(buy, sell));\\n    }\\n    \\n}\\n```\n```\\nclass Solution {\\n    public int maxProfit(int[] prices) {\\n        int n = prices.length;\\n        int[] tp = new int[n];\\n        Arrays.fill(tp, -1);\\n        return helper(0, -1, n, prices, tp);\\n    }\\n    \\n    public int helper(int day, int holding, int n, int[] arr, int[] tp){\\n        if(day>=n) return 0;\\n        if(tp[day]!=-1) return tp[day];\\n        int buy = day!=n-1 && holding==-1 ? helper(day+1, arr[day], n, arr, tp) : 0;\\n        int sell = day!=0 && holding!=-1 ? arr[day]-holding + helper(day, -1, n, arr, tp) : 0;\\n        int leave = helper(day+1, holding, n, arr, tp);\\n        return tp[day] = Math.max(leave, Math.max(buy, sell));\\n    }\\n    \\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1074144,
                "title": "javascript-one-liner-faster-than-80-space-less-than-86",
                "content": "```\\nreturn prices.reduce((acc,curr,i)=>acc+Math.max(0,i && prices[i]-prices[i-1]),0);\\n```",
                "solutionTags": [],
                "code": "```\\nreturn prices.reduce((acc,curr,i)=>acc+Math.max(0,i && prices[i]-prices[i-1]),0);\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 832626,
                "title": "easy-js-solution",
                "content": "```\\n/*\\nSolution\\n\\nProfit from Buying - Selling - Re-buying Selling\\nand\\nProfit from Buying - Wait for Best price - Selling\\nare the same. That\\'s why the logic behind this solution.\\n*/\\nvar maxProfit = function(prices) {\\n    if (prices === null || prices.length === 0) {\\n        return 0;\\n    }\\n    let profit = 0;\\n    let buyingPrice = prices[0];\\n    for (let i = 1; i < prices.length; i++) {\\n        if (prices[i] > buyingPrice) {\\n            profit += prices[i] - buyingPrice;\\n            buyingPrice = prices[i]; // Re-buying \\n        } else if (prices[i] < buyingPrice) {\\n            buyingPrice = prices[i]; // Better price\\n        }\\n    }\\n    return profit;\\n    // T.C: O(N)\\n    // S.C: O(1)\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/*\\nSolution\\n\\nProfit from Buying - Selling - Re-buying Selling\\nand\\nProfit from Buying - Wait for Best price - Selling\\nare the same. That\\'s why the logic behind this solution.\\n*/\\nvar maxProfit = function(prices) {\\n    if (prices === null || prices.length === 0) {\\n        return 0;\\n    }\\n    let profit = 0;\\n    let buyingPrice = prices[0];\\n    for (let i = 1; i < prices.length; i++) {\\n        if (prices[i] > buyingPrice) {\\n            profit += prices[i] - buyingPrice;\\n            buyingPrice = prices[i]; // Re-buying \\n        } else if (prices[i] < buyingPrice) {\\n            buyingPrice = prices[i]; // Better price\\n        }\\n    }\\n    return profit;\\n    // T.C: O(N)\\n    // S.C: O(1)\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 788360,
                "title": "c-simple-solution-with-local-minima-and-maxima-explained-99-time-82-space",
                "content": "I approached this problem with a stock market perspective - what would you do if you were actually there, with a crystal ball.\\n\\nSo I decided to go hunting for local minima (because that is how you properly do the plural form of Latin *-um* words!) and local maxima, defined as numbers who are respectively lower or higher than their neighbours.\\n\\nI don\\'t even need to store the maxima, since every time I catch them, I can just increase my accumulator variable `res`  by a `n - lMin` amount and move on.\\n\\nOnce I parsed the whole vector, I return `res`.\\n\\nThe code:\\n\\n```cpp\\nclass Solution {\\npublic:\\n    int maxProfit(vector<int>& prices) {\\n        int lMin = prices[0], res = 0, lastValue = prices.size() - 1, n;\\n        for (int i = 0; i < prices.size(); i++) {\\n            n = prices[i];\\n            // checking if the value is a local min\\n            if ((!i || prices[i - 1] > n) && (i == lastValue || n <= prices[i + 1])) {\\n                lMin = n;\\n            }\\n            // checking if the value is a local max\\n            if ((!i || prices[i - 1] < n) && (i == lastValue || n >= prices[i + 1])) {\\n                res += n - lMin;\\n                lMin = n;\\n            }\\n        }\\n        return res;\\n    }\\n};\\n```\\n\\nThen I realised that unlike the real stock market, there are no transactions costs here, so I might as well think of selling and buying every single time the previous value suggest so and I got this more efficient solution:\\n\\n```cpp\\nclass Solution {\\npublic:\\n    int maxProfit(vector<int>& prices) {\\n        int prev = prices[0], res = 0;\\n        for (int curr: prices) {\\n            if (prev < curr) res += curr - prev;\\n            prev = curr;\\n        }\\n        return res;\\n    }\\n};\\n```\\n\\nI guess there are times in which too much domain knowledge is more of a burden than an asset.\\n\\nDiscussion of the most general case of `k` different sales [here](https://leetcode.com/problems/best-time-to-buy-and-sell-stock-iv/discuss/900061/).",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```cpp\\nclass Solution {\\npublic:\\n    int maxProfit(vector<int>& prices) {\\n        int lMin = prices[0], res = 0, lastValue = prices.size() - 1, n;\\n        for (int i = 0; i < prices.size(); i++) {\\n            n = prices[i];\\n            // checking if the value is a local min\\n            if ((!i || prices[i - 1] > n) && (i == lastValue || n <= prices[i + 1])) {\\n                lMin = n;\\n            }\\n            // checking if the value is a local max\\n            if ((!i || prices[i - 1] < n) && (i == lastValue || n >= prices[i + 1])) {\\n                res += n - lMin;\\n                lMin = n;\\n            }\\n        }\\n        return res;\\n    }\\n};\\n```\n```cpp\\nclass Solution {\\npublic:\\n    int maxProfit(vector<int>& prices) {\\n        int prev = prices[0], res = 0;\\n        for (int curr: prices) {\\n            if (prev < curr) res += curr - prev;\\n            prev = curr;\\n        }\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 564905,
                "title": "super-easy-cpp-solution",
                "content": "The basic idea is ->To get maximum profit we need to buy a share if it\\'s price is going to increase the next day \\n\\n```\\n int maxProfit(vector<int>& prices) {\\n       \\n        int maxProfit = 0;\\n        int n=prices.size();\\n        for(int i = 1; i < n; i++) {\\n            int j = i - 1;\\n            \\n            if(prices[i] - prices[j]>0) {\\n                maxProfit += (prices[i] - prices[j]);\\n            }\\n        }\\n        \\n        return maxProfit;\\n        \\n    }\\n```",
                "solutionTags": [],
                "code": "```\\n int maxProfit(vector<int>& prices) {\\n       \\n        int maxProfit = 0;\\n        int n=prices.size();\\n        for(int i = 1; i < n; i++) {\\n            int j = i - 1;\\n            \\n            if(prices[i] - prices[j]>0) {\\n                maxProfit += (prices[i] - prices[j]);\\n            }\\n        }\\n        \\n        return maxProfit;\\n        \\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 417536,
                "title": "python3-accepted-answer-simple-to-code-and-understand",
                "content": "```\\nclass Solution(object):\\n    def maxProfit(self, prices):\\n        \"\"\"\\n        :type prices: List[int]\\n        :rtype: int\\n        \"\"\"\\n        max_profit = 0\\n        for day in range(len(prices) - 1):\\n            # if profit would be negative max(profit, 0)\\n            max_profit += max(prices[day + 1] - prices[day], 0)\\n        return max_profit\\n```",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nclass Solution(object):\\n    def maxProfit(self, prices):\\n        \"\"\"\\n        :type prices: List[int]\\n        :rtype: int\\n        \"\"\"\\n        max_profit = 0\\n        for day in range(len(prices) - 1):\\n            # if profit would be negative max(profit, 0)\\n            max_profit += max(prices[day + 1] - prices[day], 0)\\n        return max_profit\\n```",
                "codeTag": "Java"
            },
            {
                "id": 382021,
                "title": "simple-c-solution",
                "content": "```\\n\\npublic class Solution {\\n    public int MaxProfit(int[] prices) {\\n        int total = 0;\\n        for(int i=0 ; i < prices.Length - 1; i++)\\n        {\\n            if(prices[i+1] > prices[i])\\n                total+= prices[i+1] - prices[i];\\n        }\\n        return total;\\n    }\\n}\\n\\n```",
                "solutionTags": [],
                "code": "```\\n\\npublic class Solution {\\n    public int MaxProfit(int[] prices) {\\n        int total = 0;\\n        for(int i=0 ; i < prices.Length - 1; i++)\\n        {\\n            if(prices[i+1] > prices[i])\\n                total+= prices[i+1] - prices[i];\\n        }\\n        return total;\\n    }\\n}\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 292619,
                "title": "javascript-reduce-solution-faster-than-97-29-less-than-93-19",
                "content": "Similar to [My post about Question 121.](https://leetcode.com/problems/best-time-to-buy-and-sell-stock/discuss/292608/javascript-reduce-solution-faster-than-9931-less-than-9371)\\n```\\nvar maxProfit = function(prices) {\\n    let diff = 0\\n    if (prices.length > 0) { // []\\n        prices.reduce((acc, next) => {\\n            if (next > acc) {\\n                diff += next - acc\\n            }\\n            return next\\n        })\\n    }\\n    return diff\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\nvar maxProfit = function(prices) {\\n    let diff = 0\\n    if (prices.length > 0) { // []\\n        prices.reduce((acc, next) => {\\n            if (next > acc) {\\n                diff += next - acc\\n            }\\n            return next\\n        })\\n    }\\n    return diff\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 271867,
                "title": "python-greedy",
                "content": "Since we can transaction as many as we want, we can gain profit from every stock price increase.\\nSuppose ```[xi,xi+1,...xj]``` is a range of increasing price, we can buy at ```i``` and sell at ```j```.\\nSo whenver ```prices[i] > prices[i-1]```, we add ```price[i]-price[i-1]``` to our profit.\\n```\\ndef maxProfit(prices):\\n\\treturn sum(prices[i+1]-prices[i] for i in range(len(prices)-1) if prices[i+1]>prices[i])\\n```",
                "solutionTags": [],
                "code": "```[xi,xi+1,...xj]```\n```i```\n```j```\n```prices[i] > prices[i-1]```\n```price[i]-price[i-1]```\n```\\ndef maxProfit(prices):\\n\\treturn sum(prices[i+1]-prices[i] for i in range(len(prices)-1) if prices[i+1]>prices[i])\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 231869,
                "title": "top-down-dp-logical-thinking",
                "content": "> we can decide 1st transaction as buy on prices[lo] and sell on prices[hi]\\n> the 2nd transaction may start at day hi + 1 or latter\\n> assume we know max profit from day hi + 1 (to prices.length - 1)\\n> `max profit from day i, state[i] = max(prices[hi] - prices[lo] + state[hi + 1])`\\n> we define `maxProfitFrom(start)` to represent `state[i]` and enumerate `lo, hi`\\n> we add memorization to avoid duplicate calls on maxProfitFrom\\n```\\n    private int[] memo; // Memorization to avoid duplicate calls on maxProfitFrom.\\n    \\n    public int maxProfit(int[] prices) {\\n        if (prices == null || prices.length == 0) return 0;\\n        \\n        memo = new int[prices.length];\\n        return maxProfitFrom(prices, 0);\\n    }\\n    \\n    private int maxProfitFrom(int[] prices, int start) {\\n        if (start == prices.length) return 0;\\n        if (memo[start] != 0) return memo[start];\\n        \\n        int maxProfit = 0;\\n        for (int lo = start; lo < prices.length - 1; lo++) {\\n            int maxProfitBuyOnLo = 0;\\n            for (int hi = lo + 1; hi < prices.length; hi++) {\\n                if (prices[hi] > prices[lo]) maxProfitBuyOnLo = Math.max(maxProfitBuyOnLo, prices[hi] - prices[lo] + maxProfitFrom(prices, hi + 1));\\n            }\\n            maxProfit = Math.max(maxProfit, maxProfitBuyOnLo);\\n        }\\n        \\n        memo[start] = maxProfit;\\n        return maxProfit;\\n    }\\n```\\n**(\\u4EBA \\u2022\\u0348\\u1D17\\u2022\\u0348)** Thanks for voting!",
                "solutionTags": [
                    "Dynamic Programming"
                ],
                "code": "```\\n    private int[] memo; // Memorization to avoid duplicate calls on maxProfitFrom.\\n    \\n    public int maxProfit(int[] prices) {\\n        if (prices == null || prices.length == 0) return 0;\\n        \\n        memo = new int[prices.length];\\n        return maxProfitFrom(prices, 0);\\n    }\\n    \\n    private int maxProfitFrom(int[] prices, int start) {\\n        if (start == prices.length) return 0;\\n        if (memo[start] != 0) return memo[start];\\n        \\n        int maxProfit = 0;\\n        for (int lo = start; lo < prices.length - 1; lo++) {\\n            int maxProfitBuyOnLo = 0;\\n            for (int hi = lo + 1; hi < prices.length; hi++) {\\n                if (prices[hi] > prices[lo]) maxProfitBuyOnLo = Math.max(maxProfitBuyOnLo, prices[hi] - prices[lo] + maxProfitFrom(prices, hi + 1));\\n            }\\n            maxProfit = Math.max(maxProfit, maxProfitBuyOnLo);\\n        }\\n        \\n        memo[start] = maxProfit;\\n        return maxProfit;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 118222,
                "title": "dp-version-solution",
                "content": "```\\nclass Solution(object):\\n    def maxProfitDP(self, prices):\\n        \"\"\"\\n        :type prices: List[int]\\n        :rtype: int\\n        \"\"\"\\n        n = len(prices)\\n        if len(prices) <= 1:\\n            return 0\\n        # We use a two dimensional array to represent states, 0 means sell, 1 means buy \\n        dp = [[0] * 2 for _ in xrange(n)]\\n        dp[0][1] = -prices[0]\\n        for i in xrange(1, n):\\n            dp[i][0] = max(dp[i-1][0], dp[i-1][1] + prices[i])\\n            dp[i][1] = max(dp[i-1][1], dp[i-1][0] - prices[i])\\n        return dp[n-1][0]\\n\\n    def maxProfitOptimizedDP(self, prices):\\n        n = len(prices)\\n        if len(prices) <= 1:\\n            return 0\\n        prev_sell = 0\\n        prev_buy = -prices[0]\\n        for i in xrange(1, n):\\n            curr_sell = max(prev_sell, prev_buy + prices[i])\\n            curr_buy = max(prev_buy, prev_sell - prices[i])         \\n            prev_sell = curr_sell\\n            prev_buy = curr_buy\\n        return prev_sell\\n\\n    def maxProfitGreedy(self, prices):\\n        max_profit = 0\\n        for i in xrange(1, len(prices)):\\n            if prices[i] > prices[i-1]:\\n                max_profit += prices[i] - prices[i-1]\\n        return max_profit\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution(object):\\n    def maxProfitDP(self, prices):\\n        \"\"\"\\n        :type prices: List[int]\\n        :rtype: int\\n        \"\"\"\\n        n = len(prices)\\n        if len(prices) <= 1:\\n            return 0\\n        # We use a two dimensional array to represent states, 0 means sell, 1 means buy \\n        dp = [[0] * 2 for _ in xrange(n)]\\n        dp[0][1] = -prices[0]\\n        for i in xrange(1, n):\\n            dp[i][0] = max(dp[i-1][0], dp[i-1][1] + prices[i])\\n            dp[i][1] = max(dp[i-1][1], dp[i-1][0] - prices[i])\\n        return dp[n-1][0]\\n\\n    def maxProfitOptimizedDP(self, prices):\\n        n = len(prices)\\n        if len(prices) <= 1:\\n            return 0\\n        prev_sell = 0\\n        prev_buy = -prices[0]\\n        for i in xrange(1, n):\\n            curr_sell = max(prev_sell, prev_buy + prices[i])\\n            curr_buy = max(prev_buy, prev_sell - prices[i])         \\n            prev_sell = curr_sell\\n            prev_buy = curr_buy\\n        return prev_sell\\n\\n    def maxProfitGreedy(self, prices):\\n        max_profit = 0\\n        for i in xrange(1, len(prices)):\\n            if prices[i] > prices[i-1]:\\n                max_profit += prices[i] - prices[i-1]\\n        return max_profit\\n```",
                "codeTag": "Java"
            },
            {
                "id": 39503,
                "title": "a-easy-understand-c-solution",
                "content": "    class Solution {\\n    public:\\n        int maxProfit(vector<int>& prices) {\\n            int maxProfit = 0;\\n            for( int i = 1; i < prices.size(); i++) {\\n                if(prices[i] > prices[i - 1]) maxProfit += (prices[i] - prices[i - 1]);\\n            }\\n            return maxProfit;\\n        }\\n    };",
                "solutionTags": [
                    "C++"
                ],
                "code": "class Solution {\\n    public:\\n        int maxProfit(vector<int>& prices) {\\n            int maxProfit = 0;\\n            for( int i = 1; i < prices.size(); i++) {\\n                if(prices[i] > prices[i - 1]) maxProfit += (prices[i] - prices[i - 1]);\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 39518,
                "title": "4-lines-java-solution-very-easy",
                "content": "    public class Solution {\\n    public int maxProfit(int[] prices) {\\n            \\n        int profit = 0;\\n        \\n        for(int i=1; i<prices.length; i++)\\n                profit += ( prices[i]>prices[i-1] ? prices[i]-prices[i-1] : 0);\\n             \\n        return profit;\\n    }\\n}",
                "solutionTags": [
                    "Java"
                ],
                "code": "class Solution {\\n    public int maxProfit(int[] prices) {\\n            \\n        int profit = 0;\\n        \\n        for(int i=1; i<prices.length; i++)\\n                profit += ( prices[i]>prices[i-1] ? prices[i]-prices[i-1] : 0);\\n             \\n        return profit;\\n    }",
                "codeTag": "Java"
            },
            {
                "id": 39521,
                "title": "simple-solution-with-concise-explanation",
                "content": "Assume we buy a stock yesterday, what will we do today? \\n\\n - If today's price is higher than yesterday, we can sell it right now and get profit.\\n - What's about tomorrow the price grows higher?We just buy today's stock, that's equal to that we buy yesterday and sell tomorrow. \\n - What if today's price is lower than yesterday's? We just pretend we buy today's stock but not yesterday's .\\n - In a word, what's we should do is compare today's price to yesterday's.If higher,we get profit,\\nset buy-in price to today's price.If lower, we don't get profit,and set buy-in price to today's price.\\n\\n\\n\\n  \\n\\n\\n \\n\\n  ` int res=0,buy_in=prices[0];`\\n  \\n ` for(int i=1;i<n;i++){`\\n     \\n  ` int profit = prices[i]-buy_in;`\\n\\n  `  if(profit>0)`\\n\\n   ` res += profit;`\\n        \\n    `buy_in = prices[i];`\\n    \\n    `}`\\n\\n    `return res;`",
                "solutionTags": [],
                "code": "Assume we buy a stock yesterday, what will we do today? \\n\\n - If today's price is higher than yesterday, we can sell it right now and get profit.\\n - What's about tomorrow the price grows higher?We just buy today's stock, that's equal to that we buy yesterday and sell tomorrow. \\n - What if today's price is lower than yesterday's? We just pretend we buy today's stock but not yesterday's .\\n - In a word, what's we should do is compare today's price to yesterday's.If higher,we get profit,\\nset buy-in price to today's price.If lower, we don't get profit,and set buy-in price to today's price.\\n\\n\\n\\n  \\n\\n\\n \\n\\n  ` int res=0,buy_in=prices[0];`\\n  \\n ` for(int i=1;i<n;i++){`\\n     \\n  ` int profit = prices[i]-buy_in;`\\n\\n  `  if(profit>0)`\\n\\n   ` res += profit;`\\n        \\n    `buy_in = prices[i];`\\n    \\n    `}`\\n\\n    `return res;`",
                "codeTag": "Unknown"
            },
            {
                "id": 39577,
                "title": "a-5ms-c-solution",
                "content": "This problem can be called \"cumulative gain\" instead. I hope this is clear enough.\\n\\n    int maxProfit(int* prices, int pricesSize) {\\n        int cumulativeGain = 0;\\n        int lastVal = prices[0];\\n        for (int i = 1; i < pricesSize; i++) {\\n            if (prices[i] > lastVal) {\\n                cumulativeGain += prices[i] - lastVal;\\n            }\\n            lastVal = prices[i];\\n        }\\n        return cumulativeGain;\\n    }",
                "solutionTags": [],
                "code": "This problem can be called \"cumulative gain\" instead. I hope this is clear enough.\\n\\n    int maxProfit(int* prices, int pricesSize) {\\n        int cumulativeGain = 0;\\n        int lastVal = prices[0];\\n        for (int i = 1; i < pricesSize; i++) {\\n            if (prices[i] > lastVal) {\\n                cumulativeGain += prices[i] - lastVal;\\n            }\\n            lastVal = prices[i];\\n        }\\n        return cumulativeGain;\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 3936284,
                "title": "beats-98-c-iterative-solution-o-n-with-explanation",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n// See firstly acc to question we can buy and sell stocks any number of times now the intuition is until the stock prices will be increasing we will not sell the stock and the index after  which the stocks are decreasing we will sell the stock and again start with the next index in order to get the maximum profit\\n\\n# Complexity\\n- Time complexity:\\n O(N)\\n\\n- Space complexity:\\n O(1)\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int maxProfit(vector<int>& prices) {\\n        //  base case\\n        if( prices.size() == 1)\\n        {\\n            return 0; // as no profit will come\\n        }\\n       \\n    int ans = 0;\\n    int startdayprice = prices[0];\\n    int index = 0;\\n    while(index < prices.size())\\n        {\\n            int profitgot = 0;\\n            while(index < prices.size() - 1 && prices[index] <= prices[index+1] )\\n            {\\n                index++;\\n            }\\n            if( index < prices.size()  )\\n            {\\n            // so we must got  the last increasing stock day so sell it\\n            profitgot = prices[index] - startdayprice;\\n            if( index < prices.size() - 1)\\n            {\\n            startdayprice = prices[index + 1];\\n            }\\n            index++;\\n            ans = ans + profitgot;\\n            }\\n            \\n        }\\n        return ans;\\n        }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int maxProfit(vector<int>& prices) {\\n        //  base case\\n        if( prices.size() == 1)\\n        {\\n            return 0; // as no profit will come\\n        }\\n       \\n    int ans = 0;\\n    int startdayprice = prices[0];\\n    int index = 0;\\n    while(index < prices.size())\\n        {\\n            int profitgot = 0;\\n            while(index < prices.size() - 1 && prices[index] <= prices[index+1] )\\n            {\\n                index++;\\n            }\\n            if( index < prices.size()  )\\n            {\\n            // so we must got  the last increasing stock day so sell it\\n            profitgot = prices[index] - startdayprice;\\n            if( index < prices.size() - 1)\\n            {\\n            startdayprice = prices[index + 1];\\n            }\\n            index++;\\n            ans = ans + profitgot;\\n            }\\n            \\n        }\\n        return ans;\\n        }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3922654,
                "title": "java-easiest-dp-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->O(N)\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->O(N)\\n![Screenshot_20230205_171246.png](https://assets.leetcode.com/users/images/d9a61fbd-5075-4cd0-9409-56f565bbdbaa_1692280264.2094002.png)\\n\\n\\n# Code\\n```\\nclass Solution {\\n    public int maxProfit(int[] prices) {\\n        int n = prices.length;\\n        int maxProfit[][] = new int[n][2];  // maxProfit[i][0] represents the maximum profit on day i when not holding a stock\\n                                           // maxProfit[i][1] represents the maximum profit on day i when holding a stock\\n\\n        maxProfit[0][0] = 0;  // Initial profit on the first day when not holding a stock is 0\\n        maxProfit[0][1] = -prices[0];  // Initial profit on the first day when holding a stock is the negative of its price\\n\\n        for (int i = 1; i < n; i++) {\\n            // Update the maximum profit on day i when not holding a stock\\n            maxProfit[i][0] = Math.max(maxProfit[i - 1][0], maxProfit[i - 1][1] + prices[i]);\\n            \\n            // Update the maximum profit on day i when holding a stock\\n            maxProfit[i][1] = Math.max(maxProfit[i - 1][1], maxProfit[i - 1][0] - prices[i]);\\n        }\\n        \\n        return maxProfit[n - 1][0];  // Return the maximum profit on the last day when not holding a stock\\n    }\\n}\\n\\n```",
                "solutionTags": [
                    "Java",
                    "Array",
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution {\\n    public int maxProfit(int[] prices) {\\n        int n = prices.length;\\n        int maxProfit[][] = new int[n][2];  // maxProfit[i][0] represents the maximum profit on day i when not holding a stock\\n                                           // maxProfit[i][1] represents the maximum profit on day i when holding a stock\\n\\n        maxProfit[0][0] = 0;  // Initial profit on the first day when not holding a stock is 0\\n        maxProfit[0][1] = -prices[0];  // Initial profit on the first day when holding a stock is the negative of its price\\n\\n        for (int i = 1; i < n; i++) {\\n            // Update the maximum profit on day i when not holding a stock\\n            maxProfit[i][0] = Math.max(maxProfit[i - 1][0], maxProfit[i - 1][1] + prices[i]);\\n            \\n            // Update the maximum profit on day i when holding a stock\\n            maxProfit[i][1] = Math.max(maxProfit[i - 1][1], maxProfit[i - 1][0] - prices[i]);\\n        }\\n        \\n        return maxProfit[n - 1][0];  // Return the maximum profit on the last day when not holding a stock\\n    }\\n}\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3856785,
                "title": "super-easy-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. --> Not the best solution but very easy to understand. Any improvements are welcome :)\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution(object):\\n    def maxProfit(self, prices):\\n        profit = 0\\n        for i in range(len(prices) - 1):\\n            if prices[i] < prices[i + 1]:\\n                profit += prices[i + 1] - prices[i]\\n\\n        return profit\\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nclass Solution(object):\\n    def maxProfit(self, prices):\\n        profit = 0\\n        for i in range(len(prices) - 1):\\n            if prices[i] < prices[i + 1]:\\n                profit += prices[i + 1] - prices[i]\\n\\n        return profit\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3808766,
                "title": "0-1-space-optimized-solution",
                "content": "# PLS UPVOTE IF YOU LIKE MY SOLUTION AND FEEL FREE TO ASK IN COMMENTS\\n# CODE WITH SPACE OPTIMIZATION\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\nThe function solvetab is used to find the maximum profit using the bottom-up dynamic programming approach with optimized space complexity.\\n\\nInstead of using a 2D vector dp, the function uses two 1D vectors curr and next to store the maximum profits for the current state and the next state, respectively. Each vector has two elements, one for the \"buy\" state and the other for the \"sell\" state.\\n\\nThe curr vector is initialized with zeros to represent the base case when there are no prices left (index n).\\n\\nThe outer loop iterates over the indices of the prices vector in reverse order (from n-1 to 0`). This order ensures that we are computing the maximum profit from the last index to the first index.\\n\\nThe inner loop iterates over the two possible states: \"buy\" (buy=1) and \"sell\" (buy=0).\\n\\nFor each index and state, the function calculates the maximum profit by considering two choices, similar to the previous approach:\\n\\nIf the current state is \"buy\" (buy == 1), the function calculates the profit from buying the stock at the current index (prices[index]) and adding the profit from the next state in the \"sell\" state (next[0]).\\nIf the current state is \"sell\" (buy == 0), the function calculates the profit from selling the stock at the current index (prices[index]) and adding the profit from the next state in the \"buy\" state (next[1]).\\nAfter calculating the profit for both choices at each index and state, the function updates the curr vector with the new maximum profit for the current state.\\n\\nThe next vector is then updated to be equal to the curr vector, which essentially moves to the next day for the next iteration.\\n\\nFinally, after the loop ends, the function returns the maximum profit that can be obtained from the initial state (state \"buy\" at index 0), which is stored in next[1].\\n\\nIn the maxProfit function, it calls the solvetab function to calculate and return the maximum profit using the tabulation approach with optimized space complexity.\\n\\n# Complexity\\n- Time complexity:0(N)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:0(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\nint solvetab(vector<int>& prices)\\n{\\n    int n = prices.size();\\n    vector<int>curr(2,0);\\n    vector<int>next(2,0);\\n    int profit=0;\\n    for(int index=n-1;index>=0;index--)\\n    {\\n        for(int buy=0;buy<=1;buy++)\\n        {\\n            if(buy==1)\\n            {\\n                profit=max(-prices[index]+ next[0] , 0 + next[1]); \\n            }\\n            else\\n            {\\n                profit=max(prices[index]+ next[1] , 0 + next[0]); \\n            }\\n            curr[buy]=profit;\\n        }\\n        next=curr;\\n    }\\n    return next[1];\\n}\\n\\n    int maxProfit(vector<int>& prices)\\n    {\\n        return solvetab(prices); \\n    }\\n};\\n```\\n# CODE WITH BOTTOM UP APPROACH\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\nThe function solvetab is used to find the maximum profit using the bottom-up dynamic programming approach.\\n\\nThe function initializes a 2D vector dp with dimensions (n+1) x 2, where n is the size of the prices vector. The dp table is used to store the maximum profit that can be obtained at each index with two states: \"buy\" (buying the stock) and \"sell\" (selling the stock). The first dimension of the table (n+1) accounts for the base case when there are no prices left (index n).\\n\\nThe outer loop iterates over the indices of the prices vector in reverse order (from n-1 to 0`). This order ensures that we are computing the maximum profit from the last index to the first index.\\n\\nThe inner loop iterates over the two possible states: \"buy\" (buy=1) and \"sell\" (buy=0).\\n\\nFor each index and state, the function calculates the maximum profit by considering two choices:\\n\\nIf the current state is \"buy\" (buy == 1), the function calculates the profit from buying the stock at the current index (prices[index]) and adding the profit from the next index in the \"sell\" state (dp[index+1][0]).\\nIf the current state is \"sell\" (buy == 0), the function calculates the profit from selling the stock at the current index (prices[index]) and adding the profit from the next index in the \"buy\" state (dp[index+1][1]).\\nAfter calculating the profit for both choices at each index and state, the function stores the result in the dp table.\\n\\nFinally, the function returns the maximum profit that can be obtained from the initial state (state \"buy\" at index 0), which is stored in dp[0][1].\\n\\nIn the maxProfit function, it calls the solvetab function to calculate and return the maximum profit using the tabulation approach.\\n\\n\\n# Complexity\\n- Time complexity:0(N)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:0(N)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n\\nint solvetab(vector<int>& prices)\\n{\\n    int n = prices.size();\\n    vector<vector<int>>dp(n+1,vector<int>(2,0));\\n    int profit=0;\\n    for(int index=n-1;index>=0;index--)\\n    {\\n        for(int buy=0;buy<=1;buy++)\\n        {\\n            if(buy==1)\\n            {\\n                profit=max(-prices[index]+ dp[index+1][0] , 0 + dp[index+1][1]); \\n            }\\n            else\\n            {\\n                profit=max(prices[index]+ dp[index+1][1] , 0 + dp[index+1][0]); \\n            }\\n            dp[index][buy]=profit;\\n        }\\n    }\\n    return dp[0][1];\\n}\\n\\n    int maxProfit(vector<int>& prices)\\n    {\\n        return solvetab(prices); \\n    }\\n};\\n```\\n\\n\\n\\n# CODE WITH MEMOISATION\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\nThe function solve is a recursive function that takes the following parameters:\\n\\nprices: The vector of stock prices.\\nbuy: A flag to indicate whether we are in the \"buy\" state (buying the stock) or \"sell\" state (selling the stock). It is represented as an integer where 1 indicates \"buy\" state, and 0 indicates \"sell\" state.\\nindex: The current index in the prices vector that we are considering.\\ndp: A 2D memoization table to store the results of subproblems. dp[index][buy] stores the maximum profit that can be obtained at the current index with the given \"buy\" state.\\nThe base case for the recursion is when the index is equal to or greater than the size of the prices vector. In this case, we cannot perform any more transactions, so the profit is 0.\\n\\nBefore starting any computation at a given index and state, the function checks if the result is already computed and stored in the dp table. If so, it returns the precomputed result to avoid redundant calculations.\\n\\nThe recursive approach simulates the decisions to buy or sell the stock at each index and calculates the profit for both scenarios. It then takes the maximum of the two options to determine the maximum profit at the current state.\\n\\nIf the current state is \"buy\" (buy == 1), the function has two choices:\\n\\nBuy the stock at the current index, which means we need to deduct the price of the stock from the profit, and then recursively call the function for the next index in \"sell\" state (buy=0).\\nDo not buy the stock at the current index, and directly move to the next index while staying in \"buy\" state (buy=1).\\nIf the current state is \"sell\" (buy == 0), the function has two choices:\\n\\nSell the stock at the current index, which means we need to add the price of the stock to the profit, and then recursively call the function for the next index in \"buy\" state (buy=1).\\nDo not sell the stock at the current index and directly move to the next index while staying in \"sell\" state (buy=0).\\nAfter calculating the profit for both choices at each index and state, the function stores the result in the dp table for future reference and returns the maximum profit for the current index and state.\\n\\nIn the maxProfit function, a memoization table (dp) is initialized with -1 to indicate that the results are not computed yet.\\n\\nThe maxProfit function calls the solve function with the initial state as \"buy\" (buy=1), starting from the first index (index 0) of the prices vector.\\n\\nThe solve function uses recursion with memoization to calculate and return the maximum profit.\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:0(N)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:0(N)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\nint solve(vector<int>& prices,int buy,int index , vector<vector<int>>&dp)\\n{\\n    int profit= 0;\\n    if(index>=prices.size())\\n    {\\n        return 0;\\n    }\\n    if(dp[index][buy]!=-1)\\n    {\\n        return dp[index][buy];\\n    }\\n    if(buy==1)\\n    {\\n        profit=max(-prices[index]+ solve(prices,0,index+1,dp) ,0 + solve(prices,1,index+1,dp) );\\n    }\\n    else\\n    {\\n         profit=max(prices[index]+ solve(prices,1,index+1,dp) , 0 + solve(prices,0,index+1,dp)); \\n    }\\n    return dp[index][buy] = profit;\\n}\\n    int maxProfit(vector<int>& prices) {\\n        int n = prices.size();\\n        vector<vector<int>>dp(n+1,vector<int>(2,-1));\\n        bool buy=1;\\n        return solve(prices,buy,0,dp); \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Array",
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution {\\npublic:\\nint solvetab(vector<int>& prices)\\n{\\n    int n = prices.size();\\n    vector<int>curr(2,0);\\n    vector<int>next(2,0);\\n    int profit=0;\\n    for(int index=n-1;index>=0;index--)\\n    {\\n        for(int buy=0;buy<=1;buy++)\\n        {\\n            if(buy==1)\\n            {\\n                profit=max(-prices[index]+ next[0] , 0 + next[1]); \\n            }\\n            else\\n            {\\n                profit=max(prices[index]+ next[1] , 0 + next[0]); \\n            }\\n            curr[buy]=profit;\\n        }\\n        next=curr;\\n    }\\n    return next[1];\\n}\\n\\n    int maxProfit(vector<int>& prices)\\n    {\\n        return solvetab(prices); \\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n\\nint solvetab(vector<int>& prices)\\n{\\n    int n = prices.size();\\n    vector<vector<int>>dp(n+1,vector<int>(2,0));\\n    int profit=0;\\n    for(int index=n-1;index>=0;index--)\\n    {\\n        for(int buy=0;buy<=1;buy++)\\n        {\\n            if(buy==1)\\n            {\\n                profit=max(-prices[index]+ dp[index+1][0] , 0 + dp[index+1][1]); \\n            }\\n            else\\n            {\\n                profit=max(prices[index]+ dp[index+1][1] , 0 + dp[index+1][0]); \\n            }\\n            dp[index][buy]=profit;\\n        }\\n    }\\n    return dp[0][1];\\n}\\n\\n    int maxProfit(vector<int>& prices)\\n    {\\n        return solvetab(prices); \\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\nint solve(vector<int>& prices,int buy,int index , vector<vector<int>>&dp)\\n{\\n    int profit= 0;\\n    if(index>=prices.size())\\n    {\\n        return 0;\\n    }\\n    if(dp[index][buy]!=-1)\\n    {\\n        return dp[index][buy];\\n    }\\n    if(buy==1)\\n    {\\n        profit=max(-prices[index]+ solve(prices,0,index+1,dp) ,0 + solve(prices,1,index+1,dp) );\\n    }\\n    else\\n    {\\n         profit=max(prices[index]+ solve(prices,1,index+1,dp) , 0 + solve(prices,0,index+1,dp)); \\n    }\\n    return dp[index][buy] = profit;\\n}\\n    int maxProfit(vector<int>& prices) {\\n        int n = prices.size();\\n        vector<vector<int>>dp(n+1,vector<int>(2,-1));\\n        bool buy=1;\\n        return solve(prices,buy,0,dp); \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3715824,
                "title": "easy-c-2-line-code-beats-100",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\nO(n)\\n\\n- Space complexity:\\nO(1)\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int maxProfit(vector<int>& prices) {\\n        int profit =0;\\n        for (int i=1; i<prices.size(); i++){\\n            profit+= max(0, prices[i]-prices[i-1]);\\n        }\\n        return profit;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int maxProfit(vector<int>& prices) {\\n        int profit =0;\\n        for (int i=1; i<prices.size(); i++){\\n            profit+= max(0, prices[i]-prices[i-1]);\\n        }\\n        return profit;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3689180,
                "title": "o-n-python-solution",
                "content": "# Intuition\\nThe meaning of the solution is that we buy as soon as the rate starts to rise and sell as soon as the rate starts to fall\\n\\n# Approach\\n![\\u0421\\u043D\\u0438\\u043C\\u043E\\u043A \\u044D\\u043A\\u0440\\u0430\\u043D\\u0430 2023-06-27 \\u0432 15.50.55.png](https://assets.leetcode.com/users/images/118dce43-205c-4675-98b4-847b486c5f80_1687871325.5935972.png)\\nFirst we check that there are at least 2 shares in the array, otherwise we will not get any benefit.\\n\\n---\\n\\nThe variable **flag** shows whether we have a stock now or not, **buy** shows at what price we bought the stock, we initialize it 10 ** 10 because in the start we didn\\'t buy any stock.\\nNext, we go through the array and at the extremes of the chart we buy or sell a stock\\n\\n---\\n```\\nans += (prices[i + 1] - buy > 0) * (prices[i + 1] - buy)\\n```\\nHere we take into account the boundary case when we bought a share and did not sell it until the end of the array, then we should fix the profit\\n# Complexity\\n- Time complexity:\\nO(N)\\n- Space complexity:\\nO(N)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def maxProfit(self, prices: List[int]) -> int:\\n        ans,flag,buy = 0, 0, 10 ** 10\\n        if len(prices) <= 1:\\n            return 0\\n        for i in range(len(prices) - 1):\\n            if prices[i + 1] > prices[i]:\\n                if not flag:\\n                    flag = 1\\n                    buy = prices[i]\\n            else:\\n                if flag:\\n                    flag = 0\\n                    ans += prices[i] - buy\\n                    buy = 10 **  10\\n        ans += (prices[i + 1] - buy > 0) * (prices[i + 1] - buy)\\n        return ans\\n                \\n```",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Array"
                ],
                "code": "```\\nans += (prices[i + 1] - buy > 0) * (prices[i + 1] - buy)\\n```\n```\\nclass Solution:\\n    def maxProfit(self, prices: List[int]) -> int:\\n        ans,flag,buy = 0, 0, 10 ** 10\\n        if len(prices) <= 1:\\n            return 0\\n        for i in range(len(prices) - 1):\\n            if prices[i + 1] > prices[i]:\\n                if not flag:\\n                    flag = 1\\n                    buy = prices[i]\\n            else:\\n                if flag:\\n                    flag = 0\\n                    ans += prices[i] - buy\\n                    buy = 10 **  10\\n        ans += (prices[i + 1] - buy > 0) * (prices[i + 1] - buy)\\n        return ans\\n                \\n```",
                "codeTag": "Java"
            },
            {
                "id": 3571488,
                "title": "easy-java-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int maxProfit(int[] prices) {\\n          int l= 0;\\n          int r =1;\\n          int k=0;\\n        int p=0;\\n        int max =0;\\n      while(r<prices.length){\\n      if(prices[l]<prices[r] && prices[k]<prices[r]){\\n       max = Math.max(max,(prices[r]- prices[l]));\\n       r++;\\n       k++;\\n     }\\n      else{ \\n      \\n         l=r;\\n          p+=max;\\n          max =0;\\n          r++;\\n          k++;\\n      }\\n      \\n      }\\n   p+= max;\\n    return p; }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int maxProfit(int[] prices) {\\n          int l= 0;\\n          int r =1;\\n          int k=0;\\n        int p=0;\\n        int max =0;\\n      while(r<prices.length){\\n      if(prices[l]<prices[r] && prices[k]<prices[r]){\\n       max = Math.max(max,(prices[r]- prices[l]));\\n       r++;\\n       k++;\\n     }\\n      else{ \\n      \\n         l=r;\\n          p+=max;\\n          max =0;\\n          r++;\\n          k++;\\n      }\\n      \\n      }\\n   p+= max;\\n    return p; }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3535712,
                "title": "single-for-loop-solution",
                "content": "# Intuition\\nLooking at the examples, it looks like making the sale just before the prices drops the first time since the buy day, ignoring there might be a higher price in the future and then repeat from the new, lower price.\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n1. three vars to keep track of buy price (min), highest price including buy day (max), and the total profit (sum).\\n2. Store day one prices in min and max\\n3. Loop through the prices. \\n3.1 if the price is higher than max, update max. \\n3.2 if the price is lower than max: 1) add diff(max-min) to sum. 2) update max and min with new day price. \\n4. When the loop finishes, add diff(max-min) to sum in case the last day was not a sell. \\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity: O(n) where n is size of the array\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(1) since only three variables is needed. \\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\npublic class Solution {\\n    public int MaxProfit(int[] prices) \\n    {\\n        if(prices.Length < 2) {return 0;}\\n        int min = prices[0];\\n        int max = prices[0];\\n        int sum = 0;\\n        for(int i = 1; i < prices.Length; i++)\\n        {\\n            if(prices[i] > max)\\n            {\\n                max = prices[i];\\n                continue;\\n            }\\n            if(prices[i] < max)\\n            {\\n                sum += max - min;\\n                min = prices[i];\\n                max = prices[i];\\n            }\\n        }\\n        sum+= max - min;\\n        \\n        return sum;\\n    }\\n}\\n```",
                "solutionTags": [
                    "C#"
                ],
                "code": "```\\npublic class Solution {\\n    public int MaxProfit(int[] prices) \\n    {\\n        if(prices.Length < 2) {return 0;}\\n        int min = prices[0];\\n        int max = prices[0];\\n        int sum = 0;\\n        for(int i = 1; i < prices.Length; i++)\\n        {\\n            if(prices[i] > max)\\n            {\\n                max = prices[i];\\n                continue;\\n            }\\n            if(prices[i] < max)\\n            {\\n                sum += max - min;\\n                min = prices[i];\\n                max = prices[i];\\n            }\\n        }\\n        sum+= max - min;\\n        \\n        return sum;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3401920,
                "title": "buy-only-if-next-price-is-higher-just-like-what-you-d-do-in-real-life",
                "content": "Imagin what life would be like if you already knew what the next day price is going be?\\nYou\\'d be able to trade everyday and make decisions which always result in profit.\\n\\nIf you knew next day price is going to be lower, you\\'d not buy the stock today.\\nIf you knew next day price is going to be higher, you\\'d buy the stock today and **sell it tomorrow**.\\n\\n**If you trade everyday, and everyday is resulting in maximum profit then your profit will obviously also be maxium through all of the day combined.**\\n\\n# Code\\n```\\nclass Solution {\\n    public int maxProfit(int[] prices) {\\n        int buy = 0;\\n        int to = prices.length - 2;\\n        for (int i = 0; i <= to; i++) {\\n            if (prices[i] < prices[i + 1])\\n                buy += prices[i + 1] - prices[i];\\n        }\\n        return buy;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int maxProfit(int[] prices) {\\n        int buy = 0;\\n        int to = prices.length - 2;\\n        for (int i = 0; i <= to; i++) {\\n            if (prices[i] < prices[i + 1])\\n                buy += prices[i + 1] - prices[i];\\n        }\\n        return buy;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3245585,
                "title": "c-easiest-intuitive-solution-beats-95",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nBuying and selling stock may feel like a complicated question, but when you break it down, the rules are very simple.\\n\\nThis problem boils down to buying stock at the local minima, and selling stock at the local maxima.\\n\\n![extremaPoints.png](https://assets.leetcode.com/users/images/e6610c4d-a07e-41de-8272-ab70fb517d59_1677716743.8909247.png)\\n(Taken from google)\\n\\nLogically, this makes sense, as you are buying when the stock is lowest and selling when the stock is highest.\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nThe implementation for this is very simple. For every point in time,\\n1. If you are buying, check if the price ahead in time is greater. If it is, buy.\\n2. If you are selling, check if the price ahead in time is lower. If it is, sell.\\n\\nThe algorithm only has 3 variables. The total profit, the price that you are buying at, and a boolean whether you are buying or not.\\n\\n# Complexity\\n- Time complexity: O(n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int maxProfit(vector<int>& prices) {\\n        int profit = 0;\\n        int buyPrice = 0;\\n        bool buying=true;\\n\\n        for (int i = 0; i < prices.size()-1; i++)\\n        {\\n            if (buying)\\n            {\\n                // If at local minima, buy stock\\n                if (prices[i+1]>prices[i]) { \\n                    buying = false;\\n                    buyPrice = prices[i];\\n                }\\n            }\\n            else {\\n                // If at local maxima, sell stock\\n                if (prices[i+1]<prices[i]) {\\n                    buying = true;\\n                    profit += prices[i]-buyPrice;\\n                }\\n            }\\n        }\\n        \\n        // Edge case for selling stock\\n        if (!buying && prices[prices.size()-2]<=prices[prices.size()-1]) profit += prices[prices.size()-1]-buyPrice; \\n\\n        return profit;\\n    }\\n};\\n```\\n\\nUpvote if this helps please \\uD83D\\uDE42",
                "solutionTags": [
                    "C++",
                    "Math"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int maxProfit(vector<int>& prices) {\\n        int profit = 0;\\n        int buyPrice = 0;\\n        bool buying=true;\\n\\n        for (int i = 0; i < prices.size()-1; i++)\\n        {\\n            if (buying)\\n            {\\n                // If at local minima, buy stock\\n                if (prices[i+1]>prices[i]) { \\n                    buying = false;\\n                    buyPrice = prices[i];\\n                }\\n            }\\n            else {\\n                // If at local maxima, sell stock\\n                if (prices[i+1]<prices[i]) {\\n                    buying = true;\\n                    profit += prices[i]-buyPrice;\\n                }\\n            }\\n        }\\n        \\n        // Edge case for selling stock\\n        if (!buying && prices[prices.size()-2]<=prices[prices.size()-1]) profit += prices[prices.size()-1]-buyPrice; \\n\\n        return profit;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3078266,
                "title": "memoization-tabulation-space-optimization-dp-greedy-c",
                "content": "# Memoization\\n```\\nclass Solution {\\n    int dfs(int i, int buy, int n, vector<int> &prices, vector<vector<int>> &dp) {\\n        if(i == n) return 0;\\n        if(dp[i][buy] != -1) return dp[i][buy];\\n\\n        int profit = 0;\\n        if(buy) {\\n            profit = max(-prices[i] + dfs(i + 1, 0, n, prices, dp), 0 + dfs(i + 1, 1, n, prices, dp));\\n        }\\n        else {\\n            profit = max(prices[i] + dfs(i + 1, 1, n, prices, dp), 0 + dfs(i + 1, 0, n, prices, dp));\\n        }\\n        return dp[i][buy] = profit;\\n    }\\npublic:\\n    int maxProfit(vector<int>& prices) {\\n        int n = prices.size();\\n        vector<vector<int>> dp(n, vector<int>(2, -1));\\n\\n        return dfs(0, 1, n, prices, dp);\\n    }\\n};\\n```\\n\\n# Tabulation\\n```\\nclass Solution {\\npublic:\\n    int maxProfit(vector<int>& prices) {\\n        int n = prices.size();\\n        vector<vector<int>> dp(n + 1, vector<int>(2));\\n\\n        for(int i=n-1; i>=0; i--) {\\n            for(int buy=0; buy<=1; buy++) {\\n                int profit = 0;\\n                if(buy) {\\n                    profit = max(-prices[i] + dp[i + 1][0], 0 + dp[i + 1][1]);\\n                }\\n                else {\\n                    profit = max(prices[i] + dp[i + 1][1], 0 + dp[i + 1][0]);\\n                }\\n                dp[i][buy] = profit;\\n            }\\n        }\\n        return dp[0][1];\\n    }\\n};\\n```\\n\\n# Space Optimization\\n```\\nclass Solution {\\npublic:\\n    int maxProfit(vector<int>& prices) {\\n        int n = prices.size();\\n        vector<int> dp(2), temp(2);\\n\\n        for(int i=n-1; i>=0; i--) {\\n            for(int buy=0; buy<=1; buy++) {\\n                int profit = 0;\\n                if(buy) {\\n                    profit = max(-prices[i] + dp[0], 0 + dp[1]);\\n                }\\n                else {\\n                    profit = max(prices[i] + dp[1], 0 + dp[0]);\\n                }\\n                temp[buy] = profit;\\n            }\\n            dp = temp;\\n        }\\n        return dp[1];\\n    }\\n};\\n```\\n\\n# Greedy\\n```\\nclass Solution {\\npublic:\\n    int maxProfit(vector<int>& prices) {\\n        int n = prices.size(), ans = 0;\\n        for(int i=1; i<n; i++) ans += max(0, prices[i] - prices[i - 1]);\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Dynamic Programming",
                    "Greedy"
                ],
                "code": "```\\nclass Solution {\\n    int dfs(int i, int buy, int n, vector<int> &prices, vector<vector<int>> &dp) {\\n        if(i == n) return 0;\\n        if(dp[i][buy] != -1) return dp[i][buy];\\n\\n        int profit = 0;\\n        if(buy) {\\n            profit = max(-prices[i] + dfs(i + 1, 0, n, prices, dp), 0 + dfs(i + 1, 1, n, prices, dp));\\n        }\\n        else {\\n            profit = max(prices[i] + dfs(i + 1, 1, n, prices, dp), 0 + dfs(i + 1, 0, n, prices, dp));\\n        }\\n        return dp[i][buy] = profit;\\n    }\\npublic:\\n    int maxProfit(vector<int>& prices) {\\n        int n = prices.size();\\n        vector<vector<int>> dp(n, vector<int>(2, -1));\\n\\n        return dfs(0, 1, n, prices, dp);\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    int maxProfit(vector<int>& prices) {\\n        int n = prices.size();\\n        vector<vector<int>> dp(n + 1, vector<int>(2));\\n\\n        for(int i=n-1; i>=0; i--) {\\n            for(int buy=0; buy<=1; buy++) {\\n                int profit = 0;\\n                if(buy) {\\n                    profit = max(-prices[i] + dp[i + 1][0], 0 + dp[i + 1][1]);\\n                }\\n                else {\\n                    profit = max(prices[i] + dp[i + 1][1], 0 + dp[i + 1][0]);\\n                }\\n                dp[i][buy] = profit;\\n            }\\n        }\\n        return dp[0][1];\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    int maxProfit(vector<int>& prices) {\\n        int n = prices.size();\\n        vector<int> dp(2), temp(2);\\n\\n        for(int i=n-1; i>=0; i--) {\\n            for(int buy=0; buy<=1; buy++) {\\n                int profit = 0;\\n                if(buy) {\\n                    profit = max(-prices[i] + dp[0], 0 + dp[1]);\\n                }\\n                else {\\n                    profit = max(prices[i] + dp[1], 0 + dp[0]);\\n                }\\n                temp[buy] = profit;\\n            }\\n            dp = temp;\\n        }\\n        return dp[1];\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    int maxProfit(vector<int>& prices) {\\n        int n = prices.size(), ans = 0;\\n        for(int i=1; i<n; i++) ans += max(0, prices[i] - prices[i - 1]);\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2955148,
                "title": "simple-java-solution-o-n-time-with-o-1-space-beats-100",
                "content": "# Intuition\\nIt was similar to [https://leetcode.com/problems/best-time-to-buy-and-sell-stock/](https://leetcode.com/problems/best-time-to-buy-and-sell-stock/), but with a improvised version.\\n\\n# Approach\\nThis was similar to Mountain valley approach. Simple loop over the array and remember that we need to find the higher grounded values not the lower. Once we start the loop find the least element and traverse trhough it. Two conditions to be remembered.\\n\\n1. If you find the number higher than the current stop the loop and start counting from it.\\n2. If you find smaller than current then count the profit from it until you drop the graph of increasing elements.\\n\\nOnce you find the decrease in the profit stop there note the profit and then add it to total profit then make the current element as min then again start the process.\\n\\n\\nThe below line was written to handle the last element \\n```\\n  if (pos<nums.length) min = nums[pos];\\n```\\n# Complexity\\n- Time complexity:\\n   $$O(n)$$\\n\\n- Space complexity:\\n   $$O(1)$$\\n\\n# Code\\n```\\nclass Solution {\\n    public int maxProfit(int[] nums) {\\n         int min = nums[0], totalProfit = 0;\\n        int pos = 1, max = -1;\\n        while (pos < nums.length) {\\n            // Track the Min of the list and start tracking it\\n            if (nums[pos] < min)\\n                min = nums[pos];\\n            // Track the valley until it reaches down \\n            while (pos < nums.length && max < nums[pos])\\n                max = nums[pos++];\\n\\n            totalProfit+=max-min;\\n            max = -1;\\n            if (pos<nums.length) min = nums[pos];\\n            pos++;\\n        }\\n\\n        return totalProfit;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\n  if (pos<nums.length) min = nums[pos];\\n```\n```\\nclass Solution {\\n    public int maxProfit(int[] nums) {\\n         int min = nums[0], totalProfit = 0;\\n        int pos = 1, max = -1;\\n        while (pos < nums.length) {\\n            // Track the Min of the list and start tracking it\\n            if (nums[pos] < min)\\n                min = nums[pos];\\n            // Track the valley until it reaches down \\n            while (pos < nums.length && max < nums[pos])\\n                max = nums[pos++];\\n\\n            totalProfit+=max-min;\\n            max = -1;\\n            if (pos<nums.length) min = nums[pos];\\n            pos++;\\n        }\\n\\n        return totalProfit;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2558077,
                "title": "7-approach-explained-greedy-recursion-memoization-tabulation-space-optimization",
                "content": "```\\nclass Solution {\\npublic:\\n    //APPROACH 1:-  PEAK VALLEY APPROACH (PEAK -> HIGHEST POINT) (VALLEY -> LOWEST POINT)\\n    // consider every peak immediately after a valley and take difference of peak and valley in profit \\n    int peakValley(vector<int>&prices){\\n       int n = prices.size();\\n       int peak = prices[0] ;\\n       int valley = prices[0] ; \\n       int profit=0;\\n\\n       // peak -> prices[i]>prices[i+1] \\n       // valley -> prices[i]<prices[i+1] \\n        \\n        int i=0;\\n      while(i<n-1){\\n         //for valley \\n          while(i<n-1 && prices[i]>=prices[i+1]) i++;\\n          valley = prices[i] ; \\n       \\n         //for peak \\n          while(i<n-1 && prices[i]<=prices[i+1]) i++;\\n          peak = prices[i] ; \\n       \\n          profit+=(peak-valley);\\n      }\\n      return profit;\\n    }\\n    //APPROACH 2:-  PEAK VALLEY APPROACH EXTENSION \\n    int peakValleyExtension(vector<int>&prices){\\n      int n = prices.size();\\n      int profit=0;\\n\\n      for(int i=0;i<n-1;i++){\\n          int currProfit = prices[i+1] - prices[i] ; \\n          int isProfitable = max(0,currProfit);\\n          profit+=isProfitable;\\n      }\\n      return profit;\\n    }\\n    //Approach-3 Recursion Time Complexity: O(2^N)[Take,notTake] Space Complexity: O(N)[Auxillary Stack Space]\\n    int solve(int ind,int buy,vector<int>&prices){\\n        int n = prices.size() , profit=0; \\n\\n        if(ind==n) return 0;\\n        \\n        //Buying Stock when buy = 1 \\n        if(buy){\\n            //take -> means we bought ind stock \\n            //now,we can\\'t buy untill we sell this stock. ThereFore, buy=0\\n            //notTake -> means we didn\\'t bought ind stock \\n            //now,we can buy other stock. ThereFore, buy=1\\n            int take = -prices[ind]+solve(ind+1,0,prices) ; \\n            int notTake = 0+solve(ind+1,1,prices) ;\\n            profit = max(take,notTake);\\n        }\\n        //Selling Stock when buy = 0 \\n        else if(buy==0){\\n            //take -> means we sold ind stock \\n            //now,we can buy stock. ThereFore, buy=1\\n            //notTake -> means we didn\\'t sold ind stock \\n            //now,we can\\'t buy other stock. ThereFore, buy=0\\n            int take = prices[ind]+solve(ind+1,1,prices) ; \\n            int notTake = 0+solve(ind+1,0,prices) ;\\n            profit = max(take,notTake);\\n        }\\n\\n        return profit;\\n    }\\n    //Approach-4 Memoization Time Complexity: O(N*2)[buy->0 or 1 --> 2 states] Space Complexity:O(N*2) + O(N) [O(N)[Auxillary Stack Space]]\\n    int solve2(int ind,int buy,vector<int>&prices,vector<vector<int>>&dp){\\n        int n = prices.size() , profit=0; \\n\\n        if(ind==n) return 0;\\n        \\n        if(dp[ind][buy]!=-1) return dp[ind][buy] ; \\n        //Buying Stock when buy = 1 \\n        if(buy){\\n            //take -> means we bought ind stock \\n            //now,we can\\'t buy untill we sell this stock. ThereFore, buy=0\\n            //notTake -> means we didn\\'t bought ind stock \\n            //now,we can buy other stock. ThereFore, buy=1\\n            int take = -prices[ind]+solve2(ind+1,0,prices,dp) ; \\n            int notTake = 0+solve2(ind+1,1,prices,dp) ;\\n            profit = max(take,notTake);\\n        }\\n        //Selling Stock when buy = 0 \\n        else if(buy==0){\\n            //take -> means we sold ind stock \\n            //now,we can buy stock. ThereFore, buy=1\\n            //notTake -> means we didn\\'t sold ind stock \\n            //now,we can\\'t buy other stock. ThereFore, buy=0\\n            int take = prices[ind]+solve2(ind+1,1,prices,dp) ; \\n            int notTake = 0+solve2(ind+1,0,prices,dp) ;\\n            profit = max(take,notTake);\\n        }\\n\\n        return dp[ind][buy] =  profit;\\n    }\\n    //Approach-5 Tabulation :- Time Complexity: O(N*2) Space Complexity: O(N*2)\\n    int tabulation(vector<int>& prices){\\n        int n = prices.size();\\n        vector<vector<int>>dp(n+1,vector<int>(2,0)) ; \\n        //for base case :- if(ind==n )return 0 ; -> buy can be 0 or 1\\n        dp[n][0] = dp[n][1] = 0 ;\\n\\n        //Changing states \\n        for(int ind=n-1;ind>=0;ind--){\\n            // buy = 0 to 1 or buy = 1 to 0 -> both correct\\n            //for(int buy=0;buy<=1;buy++){\\n                 for(int buy=1;buy>=0;buy--){\\n                int profit=0;\\n                if(buy==1){\\n                    int take = -prices[ind]+dp[ind+1][0] ; //buy \\n                    int notTake = 0+dp[ind+1][1]; //not buy -> buy further\\n                    profit = max(take,notTake);\\n                }\\n                else if(buy==0){\\n                    int take = prices[ind]+dp[ind+1][1] ; //sell -> now we can buy \\n                    int notTake = 0+dp[ind+1][0]; //not sell -> not buy\\n                    profit = max(take,notTake);\\n                }\\n                dp[ind][buy]=profit;\\n            }\\n        }\\n        return dp[0][1];//as Recursion Call from (0,1)\\n    }\\n    //Approach-6 tabulation With Space Optimization :- Time Complexity: O(N*2) Space Complexity: O(1)\\n    int tabulationWithSpaceOptimization(vector<int>& prices){\\n        int n = prices.size();\\n        //ind      n-1  n\\n        //(buy=0)  |    |\\n        //(buy=1)  |    |\\n        //        curr ahead\\n        vector<int>ahead(2,0),curr(2,0) ; \\n        //for base case :- if(ind==n )return 0 ; -> buy can be 0 or 1\\n        ahead[0] = ahead[1] = 0 ;\\n\\n        //Changing states \\n        for(int ind=n-1;ind>=0;ind--){\\n            for(int buy=0;buy<=1;buy++){\\n                int profit=0;\\n                if(buy==1){\\n                    //dp[ind+1][buy]-> ahead[buy]\\n                    //dp[ind][buy] -> curr[buy] \\n                    int take = -prices[ind]+ahead[0] ; //buy \\n                    int notTake = 0+ahead[1]; //not buy -> buy further\\n                    profit = max(take,notTake);\\n                }\\n                else if(buy==0){\\n                    int take = prices[ind]+ahead[1] ; //sell -> now we can buy \\n                    int notTake = 0+ahead[0]; //not sell -> not buy\\n                    profit = max(take,notTake);\\n                }\\n                curr[buy]=profit;\\n            }\\n            ahead=curr;//update\\n        }\\n        return ahead[1];//as Recursion Call from (0,1)\\n    }\\n     //Approach-7 tabulation With Space Optimization Using Variables :- Time Complexity: O(N*2) Space Complexity: O(1)\\n    int tabulationWithSpaceOptimization2(vector<int>& prices){\\n        int n = prices.size();\\n        \\n        //for base case :- if(ind==n )return 0 ; -> buy can be 0 or 1\\n        int aheadBuy = 0 ,  aheadNotBuy = 0 ;\\n         int currBuy ,  currNotBuy  ;\\n\\n        //Changing states \\n        for(int ind=n-1;ind>=0;ind--){\\n                      //ahead[0]-> aheadNotBuy\\n                    //ahead[1] -> aheadBuy \\n\\n                    //curr[0] -> currNotBuy\\n                    //curr[1] -> currBuy\\n\\n                    //CASE FOR BUY=1\\n                    int take = -prices[ind]+aheadNotBuy ; //buy \\n                    int notTake = 0+aheadBuy; //not buy -> buy further\\n                    currBuy =max(take,notTake);\\n\\n                    //CASE FOR BUY=0\\n                    int take2 = prices[ind]+aheadBuy ; //sell -> now we can buy \\n                    int notTake2 = 0+aheadNotBuy; //not sell -> not buy\\n                    currNotBuy =max(take2,notTake2);\\n\\n            //update step like ahead=curr one \\n            aheadBuy=currBuy;\\n            aheadNotBuy=currNotBuy;\\n         }\\n        return aheadBuy;//as Recursion Call from (0,1)\\n    }\\n    int maxProfit(vector<int>& prices) {\\n         int n = prices.size();\\n      // return peakValley(prices); //APPROACH 1:-  PEAK VALLEY APPROACH\\n     //  return peakValleyExtension(prices); //APPROACH 2:-  PEAK VALLEY APPROACH EXTENSION\\n     \\n     //START WITH BUY=1 AS FIRST WE WANT TO BUY A STOCK THAN ONLY SELL IT\\n     //    return solve(0,1,prices); //Approach-3 Recursion\\n        \\n       //  vector<vector<int>>dp(n,vector<int>(2,-1)); \\n       //  return solve2(0,1,prices,dp); //Approach-4 Memoization\\n       //return tabulation(prices); //Approach-5 Tabulation \\n      //return tabulationWithSpaceOptimization(prices); //Approach-6 tabulation With Space Optimization\\n      return tabulationWithSpaceOptimization2(prices); //Approach-7 tabulation With Space Optimization Using Variables\\n    }\\n};\\n\\n```\\nIf you find this solutions to be helpful do upvote..It keeps me motivated :)\\n```",
                "solutionTags": [
                    "C++",
                    "Dynamic Programming",
                    "Greedy",
                    "Recursion",
                    "Memoization"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    //APPROACH 1:-  PEAK VALLEY APPROACH (PEAK -> HIGHEST POINT) (VALLEY -> LOWEST POINT)\\n    // consider every peak immediately after a valley and take difference of peak and valley in profit \\n    int peakValley(vector<int>&prices){\\n       int n = prices.size();\\n       int peak = prices[0] ;\\n       int valley = prices[0] ; \\n       int profit=0;\\n\\n       // peak -> prices[i]>prices[i+1] \\n       // valley -> prices[i]<prices[i+1] \\n        \\n        int i=0;\\n      while(i<n-1){\\n         //for valley \\n          while(i<n-1 && prices[i]>=prices[i+1]) i++;\\n          valley = prices[i] ; \\n       \\n         //for peak \\n          while(i<n-1 && prices[i]<=prices[i+1]) i++;\\n          peak = prices[i] ; \\n       \\n          profit+=(peak-valley);\\n      }\\n      return profit;\\n    }\\n    //APPROACH 2:-  PEAK VALLEY APPROACH EXTENSION \\n    int peakValleyExtension(vector<int>&prices){\\n      int n = prices.size();\\n      int profit=0;\\n\\n      for(int i=0;i<n-1;i++){\\n          int currProfit = prices[i+1] - prices[i] ; \\n          int isProfitable = max(0,currProfit);\\n          profit+=isProfitable;\\n      }\\n      return profit;\\n    }\\n    //Approach-3 Recursion Time Complexity: O(2^N)[Take,notTake] Space Complexity: O(N)[Auxillary Stack Space]\\n    int solve(int ind,int buy,vector<int>&prices){\\n        int n = prices.size() , profit=0; \\n\\n        if(ind==n) return 0;\\n        \\n        //Buying Stock when buy = 1 \\n        if(buy){\\n            //take -> means we bought ind stock \\n            //now,we can\\'t buy untill we sell this stock. ThereFore, buy=0\\n            //notTake -> means we didn\\'t bought ind stock \\n            //now,we can buy other stock. ThereFore, buy=1\\n            int take = -prices[ind]+solve(ind+1,0,prices) ; \\n            int notTake = 0+solve(ind+1,1,prices) ;\\n            profit = max(take,notTake);\\n        }\\n        //Selling Stock when buy = 0 \\n        else if(buy==0){\\n            //take -> means we sold ind stock \\n            //now,we can buy stock. ThereFore, buy=1\\n            //notTake -> means we didn\\'t sold ind stock \\n            //now,we can\\'t buy other stock. ThereFore, buy=0\\n            int take = prices[ind]+solve(ind+1,1,prices) ; \\n            int notTake = 0+solve(ind+1,0,prices) ;\\n            profit = max(take,notTake);\\n        }\\n\\n        return profit;\\n    }\\n    //Approach-4 Memoization Time Complexity: O(N*2)[buy->0 or 1 --> 2 states] Space Complexity:O(N*2) + O(N) [O(N)[Auxillary Stack Space]]\\n    int solve2(int ind,int buy,vector<int>&prices,vector<vector<int>>&dp){\\n        int n = prices.size() , profit=0; \\n\\n        if(ind==n) return 0;\\n        \\n        if(dp[ind][buy]!=-1) return dp[ind][buy] ; \\n        //Buying Stock when buy = 1 \\n        if(buy){\\n            //take -> means we bought ind stock \\n            //now,we can\\'t buy untill we sell this stock. ThereFore, buy=0\\n            //notTake -> means we didn\\'t bought ind stock \\n            //now,we can buy other stock. ThereFore, buy=1\\n            int take = -prices[ind]+solve2(ind+1,0,prices,dp) ; \\n            int notTake = 0+solve2(ind+1,1,prices,dp) ;\\n            profit = max(take,notTake);\\n        }\\n        //Selling Stock when buy = 0 \\n        else if(buy==0){\\n            //take -> means we sold ind stock \\n            //now,we can buy stock. ThereFore, buy=1\\n            //notTake -> means we didn\\'t sold ind stock \\n            //now,we can\\'t buy other stock. ThereFore, buy=0\\n            int take = prices[ind]+solve2(ind+1,1,prices,dp) ; \\n            int notTake = 0+solve2(ind+1,0,prices,dp) ;\\n            profit = max(take,notTake);\\n        }\\n\\n        return dp[ind][buy] =  profit;\\n    }\\n    //Approach-5 Tabulation :- Time Complexity: O(N*2) Space Complexity: O(N*2)\\n    int tabulation(vector<int>& prices){\\n        int n = prices.size();\\n        vector<vector<int>>dp(n+1,vector<int>(2,0)) ; \\n        //for base case :- if(ind==n )return 0 ; -> buy can be 0 or 1\\n        dp[n][0] = dp[n][1] = 0 ;\\n\\n        //Changing states \\n        for(int ind=n-1;ind>=0;ind--){\\n            // buy = 0 to 1 or buy = 1 to 0 -> both correct\\n            //for(int buy=0;buy<=1;buy++){\\n                 for(int buy=1;buy>=0;buy--){\\n                int profit=0;\\n                if(buy==1){\\n                    int take = -prices[ind]+dp[ind+1][0] ; //buy \\n                    int notTake = 0+dp[ind+1][1]; //not buy -> buy further\\n                    profit = max(take,notTake);\\n                }\\n                else if(buy==0){\\n                    int take = prices[ind]+dp[ind+1][1] ; //sell -> now we can buy \\n                    int notTake = 0+dp[ind+1][0]; //not sell -> not buy\\n                    profit = max(take,notTake);\\n                }\\n                dp[ind][buy]=profit;\\n            }\\n        }\\n        return dp[0][1];//as Recursion Call from (0,1)\\n    }\\n    //Approach-6 tabulation With Space Optimization :- Time Complexity: O(N*2) Space Complexity: O(1)\\n    int tabulationWithSpaceOptimization(vector<int>& prices){\\n        int n = prices.size();\\n        //ind      n-1  n\\n        //(buy=0)  |    |\\n        //(buy=1)  |    |\\n        //        curr ahead\\n        vector<int>ahead(2,0),curr(2,0) ; \\n        //for base case :- if(ind==n )return 0 ; -> buy can be 0 or 1\\n        ahead[0] = ahead[1] = 0 ;\\n\\n        //Changing states \\n        for(int ind=n-1;ind>=0;ind--){\\n            for(int buy=0;buy<=1;buy++){\\n                int profit=0;\\n                if(buy==1){\\n                    //dp[ind+1][buy]-> ahead[buy]\\n                    //dp[ind][buy] -> curr[buy] \\n                    int take = -prices[ind]+ahead[0] ; //buy \\n                    int notTake = 0+ahead[1]; //not buy -> buy further\\n                    profit = max(take,notTake);\\n                }\\n                else if(buy==0){\\n                    int take = prices[ind]+ahead[1] ; //sell -> now we can buy \\n                    int notTake = 0+ahead[0]; //not sell -> not buy\\n                    profit = max(take,notTake);\\n                }\\n                curr[buy]=profit;\\n            }\\n            ahead=curr;//update\\n        }\\n        return ahead[1];//as Recursion Call from (0,1)\\n    }\\n     //Approach-7 tabulation With Space Optimization Using Variables :- Time Complexity: O(N*2) Space Complexity: O(1)\\n    int tabulationWithSpaceOptimization2(vector<int>& prices){\\n        int n = prices.size();\\n        \\n        //for base case :- if(ind==n )return 0 ; -> buy can be 0 or 1\\n        int aheadBuy = 0 ,  aheadNotBuy = 0 ;\\n         int currBuy ,  currNotBuy  ;\\n\\n        //Changing states \\n        for(int ind=n-1;ind>=0;ind--){\\n                      //ahead[0]-> aheadNotBuy\\n                    //ahead[1] -> aheadBuy \\n\\n                    //curr[0] -> currNotBuy\\n                    //curr[1] -> currBuy\\n\\n                    //CASE FOR BUY=1\\n                    int take = -prices[ind]+aheadNotBuy ; //buy \\n                    int notTake = 0+aheadBuy; //not buy -> buy further\\n                    currBuy =max(take,notTake);\\n\\n                    //CASE FOR BUY=0\\n                    int take2 = prices[ind]+aheadBuy ; //sell -> now we can buy \\n                    int notTake2 = 0+aheadNotBuy; //not sell -> not buy\\n                    currNotBuy =max(take2,notTake2);\\n\\n            //update step like ahead=curr one \\n            aheadBuy=currBuy;\\n            aheadNotBuy=currNotBuy;\\n         }\\n        return aheadBuy;//as Recursion Call from (0,1)\\n    }\\n    int maxProfit(vector<int>& prices) {\\n         int n = prices.size();\\n      // return peakValley(prices); //APPROACH 1:-  PEAK VALLEY APPROACH\\n     //  return peakValleyExtension(prices); //APPROACH 2:-  PEAK VALLEY APPROACH EXTENSION\\n     \\n     //START WITH BUY=1 AS FIRST WE WANT TO BUY A STOCK THAN ONLY SELL IT\\n     //    return solve(0,1,prices); //Approach-3 Recursion\\n        \\n       //  vector<vector<int>>dp(n,vector<int>(2,-1)); \\n       //  return solve2(0,1,prices,dp); //Approach-4 Memoization\\n       //return tabulation(prices); //Approach-5 Tabulation \\n      //return tabulationWithSpaceOptimization(prices); //Approach-6 tabulation With Space Optimization\\n      return tabulationWithSpaceOptimization2(prices); //Approach-7 tabulation With Space Optimization Using Variables\\n    }\\n};\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2219302,
                "title": "easy-c-solution",
                "content": "Easy C++ Solution\\n\\n```\\nclass Solution {\\npublic:\\n    int maxProfit(vector<int>& prices) {\\n        int profit=0;\\n        for(int i=1; i<prices.size(); i++){\\n            if(prices[i] > prices[i-1]){\\n                profit += (prices[i] - prices[i-1]);\\n            }\\n        }\\n        return profit;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int maxProfit(vector<int>& prices) {\\n        int profit=0;\\n        for(int i=1; i<prices.size(); i++){\\n            if(prices[i] > prices[i-1]){\\n                profit += (prices[i] - prices[i-1]);\\n            }\\n        }\\n        return profit;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2099424,
                "title": "122-best-time-to-buy-and-sell-stock-ii",
                "content": "```\\nint maxProfit(vector<int>& prices) {\\n        \\n        int profit = 0;\\n        \\n        for(int i = 1; i < prices.size(); i++)\\n        {\\n            profit += max(0, prices[i] - prices[i-1]);\\n        }\\n        return profit;\\n    }\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nint maxProfit(vector<int>& prices) {\\n        \\n        int profit = 0;\\n        \\n        for(int i = 1; i < prices.size(); i++)\\n        {\\n            profit += max(0, prices[i] - prices[i-1]);\\n        }\\n        return profit;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1854408,
                "title": "pyhton-c-greedy-no-dp-needed-time-o-n",
                "content": "Buy stock on Day 1 and store it in cur_buy\\n\\nNow to get max profit we need to buy stock at min possible cost befor selling it\\n<b>1st condition:</b>If we encounter a day where price of stock is less than cur_buy,we replace cur_buy with it\\n\\n<b>2nd condition:</b>If we encounter a day where price of stock is greater than curr_buy,we sell the stock,now there can be two conditions if we sell on this day:\\n1.We got max profit possible\\n2.There is another day where we can sell stock and get even greater profit\\n\\n<b>Eg: [4,5,7] <b> According to 2nd condition we need to buy at 4 and sell at 5 and profit = 1 but if we sell at 7 we will get profit = 3</b> </b>\\n\\n<b>Thus to get max profit after buying at 4 and selling at 5 we update our profit to 1 and than again buy at 5 and sell at 7,so profit = 1(profit till now) + 2(current profit) = 3 which is max profit we can get</b> \\n\\nAnd if there was 3 instead of 7 i.e. [4,5,3] than we already had max profit = 1 by buying at 4 and selling at 5\\n\\nPython\\n```\\nclass Solution:\\n    def maxProfit(self, prices: List[int]) -> int:\\n        profit = 0\\n        cur_buy = prices[0]\\n        for price in prices:\\n            if price<cur_buy:cur_buy = price  #As stated in Condition 1\\n            \\n            if price>cur_buy:  #As stated in Condition 2\\n                profit += (price-cur_buy)\\n                cur_buy = price\\n    \\n        return profit\\n```\\n\\nC++\\n```\\nclass Solution {\\npublic:\\n    int maxProfit(vector<int>& prices) {\\n        int profit = 0 , cur_buy = prices[0];\\n        for(int& price : prices){\\n            if(price<cur_buy) {\\n                cur_buy = price;  //As stated in Condition 1\\n            }\\n            if(price>cur_buy){  //As stated in Condition 2\\n                profit += (price-cur_buy);\\n                cur_buy = price;\\n            }\\n        }\\n        return profit;\\n    }\\n};\\n```\\n\\nP.S.:If you still have any doubts comment below,I will try my best to explain you",
                "solutionTags": [
                    "C++",
                    "Python",
                    "C",
                    "Greedy"
                ],
                "code": "```\\nclass Solution:\\n    def maxProfit(self, prices: List[int]) -> int:\\n        profit = 0\\n        cur_buy = prices[0]\\n        for price in prices:\\n            if price<cur_buy:cur_buy = price  #As stated in Condition 1\\n            \\n            if price>cur_buy:  #As stated in Condition 2\\n                profit += (price-cur_buy)\\n                cur_buy = price\\n    \\n        return profit\\n```\n```\\nclass Solution {\\npublic:\\n    int maxProfit(vector<int>& prices) {\\n        int profit = 0 , cur_buy = prices[0];\\n        for(int& price : prices){\\n            if(price<cur_buy) {\\n                cur_buy = price;  //As stated in Condition 1\\n            }\\n            if(price>cur_buy){  //As stated in Condition 2\\n                profit += (price-cur_buy);\\n                cur_buy = price;\\n            }\\n        }\\n        return profit;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1569301,
                "title": "c-solution-with-4ms-runtime",
                "content": "```\\nclass Solution {\\npublic:\\n    int maxProfit(vector<int> &prices) {\\n    int profit = 0;\\n    for (size_t p = 1; p < prices.size(); ++p) \\n      profit += max(prices[p] - prices[p - 1], 0);    \\n    return profit;\\n}\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int maxProfit(vector<int> &prices) {\\n    int profit = 0;\\n    for (size_t p = 1; p < prices.size(); ++p) \\n      profit += max(prices[p] - prices[p - 1], 0);    \\n    return profit;\\n}\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1569086,
                "title": "c-recursion-memoization-with-each-line-explanation",
                "content": "```\\nclass Solution {\\npublic:\\n      // we have created an dp array of size of array length \\n\\t  // here 2nd dimension of dp array we are using for toggling the buy and sell values\\n\\t  // 0 -  no stock on hold\\n\\t  // 1 - mean we have one stock we need to first sell it as given in question\\n    int dp[30000][2];\\n    int solve(vector<int>& v,int i,int flag=0){\\n        if(i>=v.size()) return 0;  // if index is out of bound no profit will be generated so return zero\\n        if(dp[i][flag]!=-1)\\n           return dp[i][flag]; // if this problem occured previously then we will directly return from here\\n        int profit=0; \\n        if(flag==0){   // if flag==0  which means we don\\'t have any stock\\n\\t\\t  // first we need to buy one\\n\\t\\t  // it implies two possibilities  either we buy or we dont\\'t buy \\n            int x=solve(v,i+1,1)-v[i];  // if we buy then this stock price is deducted from our overall profit\\n            int y=solve(v,i+1,0); // or we can also skip this day\\n\\t\\t\\t// now after recursively solving both the case we get the profit amount from both scenario\\n            profit=max(x,y); // we will choose maximum\\n// here thing to be noticed that if we buy the stock then flag value become 1 (as we considered above)\\n\\t\\t\\t// or if we don\\'t buy it remain as it is\\n        }\\n        else{\\n\\t\\t    // flag==1 \\n\\t\\t\\t// we again have two possibilities either we can sell the stock or we can skip this day\\n            int x=solve(v,i+1,0)+v[i];  // if we sell the stock we will get some profit which we will add in  overall profit ( flag will beome 0 )\\n            int y=solve(v,i+1,1); // we can also skip the day flag remain as it is\\n\\t\\t\\t//after taking both the cases and solving problem recursively we will take maximum profit\\n            profit=max(x,y);\\n        }\\n        return dp[i][flag]=profit; // for this particular day at this particular flag value we are storing our //answer for repeating sub problems\\n    }\\n    int maxProfit(vector<int>& prices) {\\n        memset(dp,-1,sizeof(dp));\\n        return solve(prices,0,0); // here we are passing flag value equal to zero which mean we don\\'t \\n\\t\\t// have any stock initially\\n    }\\n};",
                "solutionTags": [
                    "C",
                    "Recursion",
                    "Memoization"
                ],
                "code": "class Solution {\\npublic:\\n      // we have created an dp array of size of array length \\n\\t  // here 2nd dimension of dp array we are using for toggling the buy and sell values\\n\\t  // 0 -  no stock on hold\\n\\t  // 1 - mean we have one stock we need to first sell it as given in question\\n    int dp[30000][2];\\n    int solve(vector<int>& v,int i,int flag=0){\\n        if(i>=v.size()) return 0;  // if index is out of bound no profit will be generated so return zero\\n        if(dp[i][flag]!=-1)\\n           return dp[i][flag]; // if this problem occured previously then we will directly return from here\\n        int profit=0; \\n        if(flag==0){   // if flag==0  which means we don\\'t have any stock\\n\\t\\t  // first we need to buy one\\n\\t\\t  // it implies two possibilities  either we buy or we dont\\'t buy \\n            int x=solve(v,i+1,1)-v[i];  // if we buy then this stock price is deducted from our overall profit\\n            int y=solve(v,i+1,0); // or we can also skip this day\\n\\t\\t\\t// now after recursively solving both the case we get the profit amount from both scenario\\n            profit=max(x,y); // we will choose maximum\\n// here thing to be noticed that if we buy the stock then flag value become 1 (as we considered above)\\n\\t\\t\\t// or if we don\\'t buy it remain as it is\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 1526882,
                "title": "you-will-like-this-solution",
                "content": "```\\nclass Solution:\\n    def maxProfit(self, prices: List[int]) -> int:\\n        res=0\\n        for  p in range(len(prices)-1):\\n            if prices[p]<=prices[p+1]:\\n                res+=prices[p+1]-prices[p]    \\n        return res",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nclass Solution:\\n    def maxProfit(self, prices: List[int]) -> int:\\n        res=0\\n        for  p in range(len(prices)-1):\\n            if prices[p]<=prices[p+1]:\\n                res+=prices[p+1]-prices[p]    \\n        return res",
                "codeTag": "Java"
            },
            {
                "id": 1483621,
                "title": "easy-for-beginner-in-c-o-n",
                "content": "class Solution {\\npublic:\\n\\n\\n    int maxProfit(vector<int>& prices) {\\n        int profit=0;\\n        int n=prices.size();\\n        for(int i=1;i<n;i++){\\n            if(prices[i]>prices[i-1]){\\n                profit+=(prices[i]-prices[i-1]);\\n            }\\n        }\\n        return profit;\\n    }\\n};",
                "solutionTags": [],
                "code": "class Solution {\\npublic:\\n\\n\\n    int maxProfit(vector<int>& prices) {\\n        int profit=0;\\n        int n=prices.size();\\n        for(int i=1;i<n;i++){\\n            if(prices[i]>prices[i-1]){\\n                profit+=(prices[i]-prices[i-1]);\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 1204333,
                "title": "java-0ms-solution-beats-100-performance",
                "content": "```\\nclass Solution {\\n    public int maxProfit(int[] prices) {\\n        int profit = 0;\\n        for(int i = 1; i < prices.length; i++) {\\n            if(prices[i-1] < prices[i]) {\\n                profit = profit + prices[i] - prices[i-1];\\n            }\\n        }\\n        return profit;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int maxProfit(int[] prices) {\\n        int profit = 0;\\n        for(int i = 1; i < prices.length; i++) {\\n            if(prices[i-1] < prices[i]) {\\n                profit = profit + prices[i] - prices[i-1];\\n            }\\n        }\\n        return profit;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1127612,
                "title": "simple-c-solution-4-lines",
                "content": "```\\n    public int MaxProfit(int[] prices) {\\n        int max = 0;\\n        \\n        for(int i = 1; i < prices.Length; i++)\\n            max += (prices[i] - prices[i - 1]) > 0 ? (prices[i] - prices[i - 1]) : 0;\\n        \\n        return max;\\n    }\\n```",
                "solutionTags": [],
                "code": "```\\n    public int MaxProfit(int[] prices) {\\n        int max = 0;\\n        \\n        for(int i = 1; i < prices.Length; i++)\\n            max += (prices[i] - prices[i - 1]) > 0 ? (prices[i] - prices[i - 1]) : 0;\\n        \\n        return max;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1101371,
                "title": "oms-and-100-faster-easy-java-solution",
                "content": "```\\nclass Solution {\\n    public int maxProfit(int[] prices) {\\n        int profit = 0 ;\\n        for(int i = 1 ; i < prices.length ; i++){\\n            if(prices[i] > prices[i-1])\\n                profit += (prices[i] - prices[i-1]);\\n        }\\n        return profit ;\\n    }\\n}\\n```\\n\\n![image](https://assets.leetcode.com/users/images/6970e5b4-9da4-40b2-aab6-ad43773ece54_1615297299.8992136.png)\\n\\n",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int maxProfit(int[] prices) {\\n        int profit = 0 ;\\n        for(int i = 1 ; i < prices.length ; i++){\\n            if(prices[i] > prices[i-1])\\n                profit += (prices[i] - prices[i-1]);\\n        }\\n        return profit ;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1042025,
                "title": "c-very-easy-solution-using-explanantion",
                "content": "### T = O(N) where N is number of days\\n### S = O(1)\\n\\n```\\nint maxProfit(vector<int>& prices) {\\n          int sum = 0;  // to store result\\n        int minCost = prices[0];  // initialise minimum cost as first day price\\n        int maxProfit = 0;  // initially profit is zero\\n        for(int i = 1; i < prices.size(); i++) {    // Now check from day 2\\n            if(prices[i] > minCost && prices[i] > prices[i-1]) {  // if current day price is better than previous day price & also greater than minimum cost so that to get maximum profit till date\\n                maxProfit = max(maxProfit, prices[i] - minCost);\\n                cout << maxProfit << \" \";\\n            } else {      // since current day price is less as compared to previous also we have got maximum profit till date\\n                sum = sum + maxProfit;\\n                minCost = prices[i];   // Again we will set minimum cost as current day price\\n                maxProfit = 0;      // Now again from next day we will buy i.e maximum profit is now zero in hand\\n            }\\n        }\\n        sum = sum + maxProfit;\\n        return sum;\\n    }\\n```",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nint maxProfit(vector<int>& prices) {\\n          int sum = 0;  // to store result\\n        int minCost = prices[0];  // initialise minimum cost as first day price\\n        int maxProfit = 0;  // initially profit is zero\\n        for(int i = 1; i < prices.size(); i++) {    // Now check from day 2\\n            if(prices[i] > minCost && prices[i] > prices[i-1]) {  // if current day price is better than previous day price & also greater than minimum cost so that to get maximum profit till date\\n                maxProfit = max(maxProfit, prices[i] - minCost);\\n                cout << maxProfit << \" \";\\n            } else {      // since current day price is less as compared to previous also we have got maximum profit till date\\n                sum = sum + maxProfit;\\n                minCost = prices[i];   // Again we will set minimum cost as current day price\\n                maxProfit = 0;      // Now again from next day we will buy i.e maximum profit is now zero in hand\\n            }\\n        }\\n        sum = sum + maxProfit;\\n        return sum;\\n    }\\n```",
                "codeTag": "C++"
            },
            {
                "id": 941225,
                "title": "python-o-n-solution",
                "content": "Simple Python Logic\\n* If the price at 1 day is greater than the price of the previous day, buy the previous day and sell at the current day to get that profit, and do it for all the stocks in o(N) time and you\\'ll get the maximum profit.\\n\\n```\\ndef maxProfit(self, prices: List[int]) -> int:\\n    return sum([prices[i+1]-prices[i] for i in range(len(prices)-1) if prices[i+1]>prices[i]])\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\ndef maxProfit(self, prices: List[int]) -> int:\\n    return sum([prices[i+1]-prices[i] for i in range(len(prices)-1) if prices[i+1]>prices[i]])\\n```",
                "codeTag": "Python3"
            }
        ],
        "discussions": [
            {
                "id": 1566137,
                "content": [
                    {
                        "username": "hanseaston",
                        "content": "We want to buy all the stocks when the line is going up. And want to ignore all the lines when the line is going down.\\n\\nDo a for loop through the array and only count in the green line that is going up, by comparing the two adjacent elements in the array.\\n\\nMany solutions are already posted here. But I think a picture would make things clearer to see.\\n\\n![image](https://assets.leetcode.com/users/hans00/image_1586103419.png)\\n\\n"
                    },
                    {
                        "username": "shashi_singh_18",
                        "content": "I just read the 1st line and my code is accepted. Thanks!!!!!!!!!!!!!!!"
                    },
                    {
                        "username": "introvertCode",
                        "content": "Thank you!"
                    },
                    {
                        "username": "tanushjangid1234",
                        "content": "What a great intuation."
                    },
                    {
                        "username": "glaucusec",
                        "content": "Thanks man. This actually helped a lot"
                    },
                    {
                        "username": "meanup",
                        "content": "`Hint`\\nStill confuse, after seeing the above figure analyse the example 1 and example 2. And it will all make sense. \\nUpvoted! Thank you. "
                    },
                    {
                        "username": "shhung",
                        "content": "It\\'s really simplify the question"
                    },
                    {
                        "username": "mayank-01",
                        "content": "upvoted, thank you for keeping things simple\\uD83D\\uDC4D"
                    },
                    {
                        "username": "falgunitagadkar",
                        "content": "Thanks:)"
                    },
                    {
                        "username": "pranavrocksharma",
                        "content": "what is the meaning of this buying and selling on the same day, profit will be 0 right , so why they highligted in bold, if was selling and then buying on the same day then it would affect on the recurrence but this statement is just added for the sake.\\n\\nAm i wrong or it means something else , i solved assuming we cannot sell and then buy on the same day, we will buy on the next day ."
                    },
                    {
                        "username": "Shaik_Aman_Sayer",
                        "content": "[@Mee_eeM](/Mee_eeM) appreciated dude earned my respect "
                    },
                    {
                        "username": "falgunitagadkar",
                        "content": "[@Dipanshi_26](/Dipanshi_26) The pictorial representation in the above comment has an hint in itself and if you want you can check out my solution.It\\'s not DP solution neither uses Greedy."
                    },
                    {
                        "username": "Dipanshi_26",
                        "content": "I just wanted to ask if this problem can be solved without DP or greedy algorithm because I am new to DSA I have practiced array perfectly. \\nCan you please suggest any othe opproch (hint) without these two approch. "
                    },
                    {
                        "username": "Mee_eeM",
                        "content": "Since you are allow to hold at most one stock at a time it is best to sell it if a lower price comes around. For example on day 1 the price is 7 dollars and day 2 the price is 1 dollar. If you buy on day 1 and sell on 2 you lose money, and you can't buy on day 2 since you've bought on day 1. Allowing you to buy and sell on the same day free up your 1 stock so than you may buy on day 2. Hope this helps."
                    },
                    {
                        "username": "abhijeetkrsingh17",
                        "content": "It is pointless. Even if we think that you sold the stock at higher price and bought new stocks same day as there must be a more higher price than this dates price. then it won\\'t make any difference if you had sold the stocks the next higher day. the diff remains the same."
                    },
                    {
                        "username": "Jeetu_123",
                        "content": "[@godshiva](/godshiva) If u look it as a trader point of view then it is not pointless."
                    },
                    {
                        "username": "itsvishalcodes",
                        "content": "[@sivagowda](/sivagowda) What do you  mean different stock? We are only allowed to hold one stock at a time. So you can only buy on a certain day if you have no stock holdings."
                    },
                    {
                        "username": "sivagowda",
                        "content": "They mean you could sell a stock that you already bought and buy a stock on that day(you could perform buying and selling on the same day of different stocks)"
                    },
                    {
                        "username": "godshiva",
                        "content": "No you\\'re right. You are allowed to do it, but doing so is pointless"
                    },
                    {
                        "username": "Bulbasaur2000",
                        "content": "**Firstly, the second test case explaination might mislead you as it did to me. So, try to avoid that.**\\n\\nLogic: \\nIt is pretty clear that normal brute force approach will take two loops and complexity will become O(n^2). So our objective is to optimise it as far as possible. A **one-pass algorithm** could be used to achieve this optimisation.\\n\\nApproach: \\n1. Initialise a variable(like maxProfit or anything else) which will store the final profit as 0.\\n2. Under a single loop, check for the price which is greater than its previous price. That would be the time when we should sell the stock to earn maximum profit at that instance.\\n3. Add up the profit to the initial variable maxProfit.\\n4. Continue the loop untill it reaches end. Eventually on its way it will keep on checking the profit condition and add up it to your maxProfit.\\n5. Finally return maxProfit.\\n\\nThis approach will take just O(n) time, since only once the entire array is traversed.\\nTry to code it now. Happy Hunting!!! \\n\\n**Do upvote my solution if found useful. It would motivate me furthur and help others.**\\n\\n"
                    },
                    {
                        "username": "bhargav9427",
                        "content": "The most important aspect of any problem is how to arrive at a solution. What should be the thinking process behind it. Lets try to understand how can we reach upto the solution and most important how to convince ourselves that its optimal. Please watch the given solution for this problem as a prerequisite.\\n\\nThe first question after seeing the solution that comes to mind is why is it optimal. Why selecting the immediate peak is the optimal choice. Here is a mathematical understanding for that.\\n\\nConsider this input : [a, ......, b, ......., c....., d]. Where `...` refers to some input in between. a&c are valleys and b&d are peaks.\\n\\nPoints to understand. \\n1) If b&d both are peaks then there has to be some value in between them which is less than b. If not b could not have been a peak because the direct next peak immediate to a will be d.\\n2) If a&c are valleys then there has to be some value in between them which is greater than a. If not a could not have been a valley because the first valley will itself will be c.\\n3) Considering the first two points and assuming that not picking immediate next peak will lead to a better answer. Lets try to prove if we can do that.  \\n\\t\\nIf point 3 is true then we can say that \\n\\t d-a > (b-a) + (d-c)\\ni.e d > b+d-c               but as b-c > 0\\ni.e d > +ve + d            \\n\\nwhich is a false. So we can always say that picking up immediate next peak will always yeild a better result.\\n\\nHope this helps.\\n"
                    },
                    {
                        "username": "anurag_negi123",
                        "content": "nice mathematical proof bro loved it"
                    },
                    {
                        "username": "youssef",
                        "content": "Hello,\\n\\nI'd like to know why the greedy algorithm that takes pairwise profits if they are positive only?\\n\\nThanks"
                    },
                    {
                        "username": "dpeachpeach",
                        "content": "Hi youssef, I recall a greedy-stays-ahead proof similar to this q in one of my college courses but I forgot it so I'm going to try to lay out the logic as well as possible.\n\nLet there be two prices p_a and p_b in the array. where a < b\nLet us say that there is a distance of n => 1 between the two. (Multiple prices in between the two)\n\nThere are two possible cases for the values of p_a in relation to p_b. Either p_b > p_a, which means we would want to buy. or P_b < p_a, which means we wouldn't want to buy.\nLet's ignore the second case because it's trivial and focus on the first.\n\nOk! So we know that we want to buy p_1 so that we can sell at p_2, but there is a distance of n>= 1 between the two, so this leaves uncertainty.\n\nWell, we know for a fact that overall price change across this period in time is going to be p_2 - p_1 or dp\n\nWe also know that price changes are split by days, which means that there are 'positive days' and 'negative days'\n\nAs we stated earlier, p_b > p_a where the distance between the two is n >= 1. if the distance is 1 (they're right next to each other), in what case would you prefer to take a losing bet? :-)\n\nThis is kind of a clever trick (It's a very nonrigorous proof by induction) but here's also a shaky proof by contradiction to help visualize it.\n\nLet us assume that there is an optimal solution where we choose to take a pairwise loss between two prices as opposed to taking a pairwise gain whenever possible.\n\nThis would somehow imply that the pairwise loss allows us to gain more profit than if we had never taken it in the first place. However, due to the allowances of the challenge, we have perfect foresight of the markets. Whenever there is a 'loss' in price, and that price then goes up in the future, we can always profit by taking a profit between the price in the future and the previous price. (If there is a higher price at the end then it must have gotten to that price somehow in increments or totally between two days). By taking a pairwise loss, we are doing nothing but surrendering 'opportunity profit' that we could have made by just doing pairwise purchasing later.\n\nThat's all shaky, but it's been a few months since I've been in class. Good luck!"
                    },
                    {
                        "username": "rushzone",
                        "content": "Judging from my code that has been accepted by the system, I think the limitation of the question is you can only hold 1 stock at most for any time. Which has not been clarified in the question description.\\n\\nFor more complete question and answer to it, in fact case, the money in your account at the beginning is  determined. What you can do is to make maximum profit from this data. During the progress, you can use the profit you made to buy more stock next time."
                    },
                    {
                        "username": "arhankundu99",
                        "content": "I always feel like a noob while encountering these type of questions. I tried for an hour and all I could manage was brute force method optimised with dp. How do you guys come up with such ideas (Like plotting the points and doing summation of peaks(i)-valeys(i)) ?"
                    },
                    {
                        "username": "heyyyankit",
                        "content": "no need to dp or any thing, just iterate on  prices and if you have profit any day, you can sell.. \n............\ncode:-\n\n      int n=prices.size();\n        int ans=0;\n        for(int i=1; i<=n-1; ++i){\n            int diff=prices[i]-prices[i-1];\n            if(diff>0){ans+=diff;}\n        }\n        return ans;"
                    },
                    {
                        "username": "AdityaDipamanggala",
                        "content": "[@Dipanshi_26](/Dipanshi_26) I think the best approach is to realize sum of neighboring peak is >= global peak, so we dont need to do any brute force"
                    },
                    {
                        "username": "AdityaDipamanggala",
                        "content": "Hahah this also exactly what I\\'m facing, turns out I\\'m too over-complicated the logic behind it, once you realize that sum of neighboring peak is always higher than global peak it will be easy "
                    },
                    {
                        "username": "Dipanshi_26",
                        "content": "Can you please give me hint about the approch you mentioned about? I don\\'t know abhout DP still trying to solve thsi problem."
                    },
                    {
                        "username": "shad",
                        "content": "After reading the description I don't understand what a program is supposed to compute to be accepted.\\n\\nI understand the array of prices, but how do I know what the maximum profit is without  knowing how much I can invest initially?  What about selling short before buying any?\\n\\nI guess there aren't any transaction fees to consider, but I don't know why it says I have to sell before I buy - if I'm maximizing profit, aren't I buying as much as I can afford, then selling it all right before it goes down?"
                    },
                    {
                        "username": "Harshsharma12",
                        "content": "https://leetcode.com/problems/best-time-to-buy-and-sell-stock-ii/description/comments/1567200"
                    },
                    {
                        "username": "biller897",
                        "content": "i\\'ll tell you the most basic thing to understand before doing any \"Buy and Sell Stock\" problem :-\\n\\nTake ex :- [1,4,7,8,6,4]\\nif you take (1, 8) , diff = 7\\nor if you take (1, 4), (4, 7), (7, 8), diff = 3 + 3 + 1 = 7\\n\\nGoing directly to 8, or going to 8 by adding all differences in between is same in result, so rather than thinking to jump, think it in this way.\\n"
                    },
                    {
                        "username": "Novarg",
                        "content": "Imagine you were a stock trader and you know the future prices for a given stock (This is the problem input). Each day you would buy the stock if you knew you could sell it tomorrow for a profit (This is the greedy solution)."
                    }
                ]
            },
            {
                "id": 1576892,
                "content": [
                    {
                        "username": "hanseaston",
                        "content": "We want to buy all the stocks when the line is going up. And want to ignore all the lines when the line is going down.\\n\\nDo a for loop through the array and only count in the green line that is going up, by comparing the two adjacent elements in the array.\\n\\nMany solutions are already posted here. But I think a picture would make things clearer to see.\\n\\n![image](https://assets.leetcode.com/users/hans00/image_1586103419.png)\\n\\n"
                    },
                    {
                        "username": "shashi_singh_18",
                        "content": "I just read the 1st line and my code is accepted. Thanks!!!!!!!!!!!!!!!"
                    },
                    {
                        "username": "introvertCode",
                        "content": "Thank you!"
                    },
                    {
                        "username": "tanushjangid1234",
                        "content": "What a great intuation."
                    },
                    {
                        "username": "glaucusec",
                        "content": "Thanks man. This actually helped a lot"
                    },
                    {
                        "username": "meanup",
                        "content": "`Hint`\\nStill confuse, after seeing the above figure analyse the example 1 and example 2. And it will all make sense. \\nUpvoted! Thank you. "
                    },
                    {
                        "username": "shhung",
                        "content": "It\\'s really simplify the question"
                    },
                    {
                        "username": "mayank-01",
                        "content": "upvoted, thank you for keeping things simple\\uD83D\\uDC4D"
                    },
                    {
                        "username": "falgunitagadkar",
                        "content": "Thanks:)"
                    },
                    {
                        "username": "pranavrocksharma",
                        "content": "what is the meaning of this buying and selling on the same day, profit will be 0 right , so why they highligted in bold, if was selling and then buying on the same day then it would affect on the recurrence but this statement is just added for the sake.\\n\\nAm i wrong or it means something else , i solved assuming we cannot sell and then buy on the same day, we will buy on the next day ."
                    },
                    {
                        "username": "Shaik_Aman_Sayer",
                        "content": "[@Mee_eeM](/Mee_eeM) appreciated dude earned my respect "
                    },
                    {
                        "username": "falgunitagadkar",
                        "content": "[@Dipanshi_26](/Dipanshi_26) The pictorial representation in the above comment has an hint in itself and if you want you can check out my solution.It\\'s not DP solution neither uses Greedy."
                    },
                    {
                        "username": "Dipanshi_26",
                        "content": "I just wanted to ask if this problem can be solved without DP or greedy algorithm because I am new to DSA I have practiced array perfectly. \\nCan you please suggest any othe opproch (hint) without these two approch. "
                    },
                    {
                        "username": "Mee_eeM",
                        "content": "Since you are allow to hold at most one stock at a time it is best to sell it if a lower price comes around. For example on day 1 the price is 7 dollars and day 2 the price is 1 dollar. If you buy on day 1 and sell on 2 you lose money, and you can't buy on day 2 since you've bought on day 1. Allowing you to buy and sell on the same day free up your 1 stock so than you may buy on day 2. Hope this helps."
                    },
                    {
                        "username": "abhijeetkrsingh17",
                        "content": "It is pointless. Even if we think that you sold the stock at higher price and bought new stocks same day as there must be a more higher price than this dates price. then it won\\'t make any difference if you had sold the stocks the next higher day. the diff remains the same."
                    },
                    {
                        "username": "Jeetu_123",
                        "content": "[@godshiva](/godshiva) If u look it as a trader point of view then it is not pointless."
                    },
                    {
                        "username": "itsvishalcodes",
                        "content": "[@sivagowda](/sivagowda) What do you  mean different stock? We are only allowed to hold one stock at a time. So you can only buy on a certain day if you have no stock holdings."
                    },
                    {
                        "username": "sivagowda",
                        "content": "They mean you could sell a stock that you already bought and buy a stock on that day(you could perform buying and selling on the same day of different stocks)"
                    },
                    {
                        "username": "godshiva",
                        "content": "No you\\'re right. You are allowed to do it, but doing so is pointless"
                    },
                    {
                        "username": "Bulbasaur2000",
                        "content": "**Firstly, the second test case explaination might mislead you as it did to me. So, try to avoid that.**\\n\\nLogic: \\nIt is pretty clear that normal brute force approach will take two loops and complexity will become O(n^2). So our objective is to optimise it as far as possible. A **one-pass algorithm** could be used to achieve this optimisation.\\n\\nApproach: \\n1. Initialise a variable(like maxProfit or anything else) which will store the final profit as 0.\\n2. Under a single loop, check for the price which is greater than its previous price. That would be the time when we should sell the stock to earn maximum profit at that instance.\\n3. Add up the profit to the initial variable maxProfit.\\n4. Continue the loop untill it reaches end. Eventually on its way it will keep on checking the profit condition and add up it to your maxProfit.\\n5. Finally return maxProfit.\\n\\nThis approach will take just O(n) time, since only once the entire array is traversed.\\nTry to code it now. Happy Hunting!!! \\n\\n**Do upvote my solution if found useful. It would motivate me furthur and help others.**\\n\\n"
                    },
                    {
                        "username": "bhargav9427",
                        "content": "The most important aspect of any problem is how to arrive at a solution. What should be the thinking process behind it. Lets try to understand how can we reach upto the solution and most important how to convince ourselves that its optimal. Please watch the given solution for this problem as a prerequisite.\\n\\nThe first question after seeing the solution that comes to mind is why is it optimal. Why selecting the immediate peak is the optimal choice. Here is a mathematical understanding for that.\\n\\nConsider this input : [a, ......, b, ......., c....., d]. Where `...` refers to some input in between. a&c are valleys and b&d are peaks.\\n\\nPoints to understand. \\n1) If b&d both are peaks then there has to be some value in between them which is less than b. If not b could not have been a peak because the direct next peak immediate to a will be d.\\n2) If a&c are valleys then there has to be some value in between them which is greater than a. If not a could not have been a valley because the first valley will itself will be c.\\n3) Considering the first two points and assuming that not picking immediate next peak will lead to a better answer. Lets try to prove if we can do that.  \\n\\t\\nIf point 3 is true then we can say that \\n\\t d-a > (b-a) + (d-c)\\ni.e d > b+d-c               but as b-c > 0\\ni.e d > +ve + d            \\n\\nwhich is a false. So we can always say that picking up immediate next peak will always yeild a better result.\\n\\nHope this helps.\\n"
                    },
                    {
                        "username": "anurag_negi123",
                        "content": "nice mathematical proof bro loved it"
                    },
                    {
                        "username": "youssef",
                        "content": "Hello,\\n\\nI'd like to know why the greedy algorithm that takes pairwise profits if they are positive only?\\n\\nThanks"
                    },
                    {
                        "username": "dpeachpeach",
                        "content": "Hi youssef, I recall a greedy-stays-ahead proof similar to this q in one of my college courses but I forgot it so I'm going to try to lay out the logic as well as possible.\n\nLet there be two prices p_a and p_b in the array. where a < b\nLet us say that there is a distance of n => 1 between the two. (Multiple prices in between the two)\n\nThere are two possible cases for the values of p_a in relation to p_b. Either p_b > p_a, which means we would want to buy. or P_b < p_a, which means we wouldn't want to buy.\nLet's ignore the second case because it's trivial and focus on the first.\n\nOk! So we know that we want to buy p_1 so that we can sell at p_2, but there is a distance of n>= 1 between the two, so this leaves uncertainty.\n\nWell, we know for a fact that overall price change across this period in time is going to be p_2 - p_1 or dp\n\nWe also know that price changes are split by days, which means that there are 'positive days' and 'negative days'\n\nAs we stated earlier, p_b > p_a where the distance between the two is n >= 1. if the distance is 1 (they're right next to each other), in what case would you prefer to take a losing bet? :-)\n\nThis is kind of a clever trick (It's a very nonrigorous proof by induction) but here's also a shaky proof by contradiction to help visualize it.\n\nLet us assume that there is an optimal solution where we choose to take a pairwise loss between two prices as opposed to taking a pairwise gain whenever possible.\n\nThis would somehow imply that the pairwise loss allows us to gain more profit than if we had never taken it in the first place. However, due to the allowances of the challenge, we have perfect foresight of the markets. Whenever there is a 'loss' in price, and that price then goes up in the future, we can always profit by taking a profit between the price in the future and the previous price. (If there is a higher price at the end then it must have gotten to that price somehow in increments or totally between two days). By taking a pairwise loss, we are doing nothing but surrendering 'opportunity profit' that we could have made by just doing pairwise purchasing later.\n\nThat's all shaky, but it's been a few months since I've been in class. Good luck!"
                    },
                    {
                        "username": "rushzone",
                        "content": "Judging from my code that has been accepted by the system, I think the limitation of the question is you can only hold 1 stock at most for any time. Which has not been clarified in the question description.\\n\\nFor more complete question and answer to it, in fact case, the money in your account at the beginning is  determined. What you can do is to make maximum profit from this data. During the progress, you can use the profit you made to buy more stock next time."
                    },
                    {
                        "username": "arhankundu99",
                        "content": "I always feel like a noob while encountering these type of questions. I tried for an hour and all I could manage was brute force method optimised with dp. How do you guys come up with such ideas (Like plotting the points and doing summation of peaks(i)-valeys(i)) ?"
                    },
                    {
                        "username": "heyyyankit",
                        "content": "no need to dp or any thing, just iterate on  prices and if you have profit any day, you can sell.. \n............\ncode:-\n\n      int n=prices.size();\n        int ans=0;\n        for(int i=1; i<=n-1; ++i){\n            int diff=prices[i]-prices[i-1];\n            if(diff>0){ans+=diff;}\n        }\n        return ans;"
                    },
                    {
                        "username": "AdityaDipamanggala",
                        "content": "[@Dipanshi_26](/Dipanshi_26) I think the best approach is to realize sum of neighboring peak is >= global peak, so we dont need to do any brute force"
                    },
                    {
                        "username": "AdityaDipamanggala",
                        "content": "Hahah this also exactly what I\\'m facing, turns out I\\'m too over-complicated the logic behind it, once you realize that sum of neighboring peak is always higher than global peak it will be easy "
                    },
                    {
                        "username": "Dipanshi_26",
                        "content": "Can you please give me hint about the approch you mentioned about? I don\\'t know abhout DP still trying to solve thsi problem."
                    },
                    {
                        "username": "shad",
                        "content": "After reading the description I don't understand what a program is supposed to compute to be accepted.\\n\\nI understand the array of prices, but how do I know what the maximum profit is without  knowing how much I can invest initially?  What about selling short before buying any?\\n\\nI guess there aren't any transaction fees to consider, but I don't know why it says I have to sell before I buy - if I'm maximizing profit, aren't I buying as much as I can afford, then selling it all right before it goes down?"
                    },
                    {
                        "username": "Harshsharma12",
                        "content": "https://leetcode.com/problems/best-time-to-buy-and-sell-stock-ii/description/comments/1567200"
                    },
                    {
                        "username": "biller897",
                        "content": "i\\'ll tell you the most basic thing to understand before doing any \"Buy and Sell Stock\" problem :-\\n\\nTake ex :- [1,4,7,8,6,4]\\nif you take (1, 8) , diff = 7\\nor if you take (1, 4), (4, 7), (7, 8), diff = 3 + 3 + 1 = 7\\n\\nGoing directly to 8, or going to 8 by adding all differences in between is same in result, so rather than thinking to jump, think it in this way.\\n"
                    },
                    {
                        "username": "Novarg",
                        "content": "Imagine you were a stock trader and you know the future prices for a given stock (This is the problem input). Each day you would buy the stock if you knew you could sell it tomorrow for a profit (This is the greedy solution)."
                    }
                ]
            },
            {
                "id": 1575662,
                "content": [
                    {
                        "username": "hanseaston",
                        "content": "We want to buy all the stocks when the line is going up. And want to ignore all the lines when the line is going down.\\n\\nDo a for loop through the array and only count in the green line that is going up, by comparing the two adjacent elements in the array.\\n\\nMany solutions are already posted here. But I think a picture would make things clearer to see.\\n\\n![image](https://assets.leetcode.com/users/hans00/image_1586103419.png)\\n\\n"
                    },
                    {
                        "username": "shashi_singh_18",
                        "content": "I just read the 1st line and my code is accepted. Thanks!!!!!!!!!!!!!!!"
                    },
                    {
                        "username": "introvertCode",
                        "content": "Thank you!"
                    },
                    {
                        "username": "tanushjangid1234",
                        "content": "What a great intuation."
                    },
                    {
                        "username": "glaucusec",
                        "content": "Thanks man. This actually helped a lot"
                    },
                    {
                        "username": "meanup",
                        "content": "`Hint`\\nStill confuse, after seeing the above figure analyse the example 1 and example 2. And it will all make sense. \\nUpvoted! Thank you. "
                    },
                    {
                        "username": "shhung",
                        "content": "It\\'s really simplify the question"
                    },
                    {
                        "username": "mayank-01",
                        "content": "upvoted, thank you for keeping things simple\\uD83D\\uDC4D"
                    },
                    {
                        "username": "falgunitagadkar",
                        "content": "Thanks:)"
                    },
                    {
                        "username": "pranavrocksharma",
                        "content": "what is the meaning of this buying and selling on the same day, profit will be 0 right , so why they highligted in bold, if was selling and then buying on the same day then it would affect on the recurrence but this statement is just added for the sake.\\n\\nAm i wrong or it means something else , i solved assuming we cannot sell and then buy on the same day, we will buy on the next day ."
                    },
                    {
                        "username": "Shaik_Aman_Sayer",
                        "content": "[@Mee_eeM](/Mee_eeM) appreciated dude earned my respect "
                    },
                    {
                        "username": "falgunitagadkar",
                        "content": "[@Dipanshi_26](/Dipanshi_26) The pictorial representation in the above comment has an hint in itself and if you want you can check out my solution.It\\'s not DP solution neither uses Greedy."
                    },
                    {
                        "username": "Dipanshi_26",
                        "content": "I just wanted to ask if this problem can be solved without DP or greedy algorithm because I am new to DSA I have practiced array perfectly. \\nCan you please suggest any othe opproch (hint) without these two approch. "
                    },
                    {
                        "username": "Mee_eeM",
                        "content": "Since you are allow to hold at most one stock at a time it is best to sell it if a lower price comes around. For example on day 1 the price is 7 dollars and day 2 the price is 1 dollar. If you buy on day 1 and sell on 2 you lose money, and you can't buy on day 2 since you've bought on day 1. Allowing you to buy and sell on the same day free up your 1 stock so than you may buy on day 2. Hope this helps."
                    },
                    {
                        "username": "abhijeetkrsingh17",
                        "content": "It is pointless. Even if we think that you sold the stock at higher price and bought new stocks same day as there must be a more higher price than this dates price. then it won\\'t make any difference if you had sold the stocks the next higher day. the diff remains the same."
                    },
                    {
                        "username": "Jeetu_123",
                        "content": "[@godshiva](/godshiva) If u look it as a trader point of view then it is not pointless."
                    },
                    {
                        "username": "itsvishalcodes",
                        "content": "[@sivagowda](/sivagowda) What do you  mean different stock? We are only allowed to hold one stock at a time. So you can only buy on a certain day if you have no stock holdings."
                    },
                    {
                        "username": "sivagowda",
                        "content": "They mean you could sell a stock that you already bought and buy a stock on that day(you could perform buying and selling on the same day of different stocks)"
                    },
                    {
                        "username": "godshiva",
                        "content": "No you\\'re right. You are allowed to do it, but doing so is pointless"
                    },
                    {
                        "username": "Bulbasaur2000",
                        "content": "**Firstly, the second test case explaination might mislead you as it did to me. So, try to avoid that.**\\n\\nLogic: \\nIt is pretty clear that normal brute force approach will take two loops and complexity will become O(n^2). So our objective is to optimise it as far as possible. A **one-pass algorithm** could be used to achieve this optimisation.\\n\\nApproach: \\n1. Initialise a variable(like maxProfit or anything else) which will store the final profit as 0.\\n2. Under a single loop, check for the price which is greater than its previous price. That would be the time when we should sell the stock to earn maximum profit at that instance.\\n3. Add up the profit to the initial variable maxProfit.\\n4. Continue the loop untill it reaches end. Eventually on its way it will keep on checking the profit condition and add up it to your maxProfit.\\n5. Finally return maxProfit.\\n\\nThis approach will take just O(n) time, since only once the entire array is traversed.\\nTry to code it now. Happy Hunting!!! \\n\\n**Do upvote my solution if found useful. It would motivate me furthur and help others.**\\n\\n"
                    },
                    {
                        "username": "bhargav9427",
                        "content": "The most important aspect of any problem is how to arrive at a solution. What should be the thinking process behind it. Lets try to understand how can we reach upto the solution and most important how to convince ourselves that its optimal. Please watch the given solution for this problem as a prerequisite.\\n\\nThe first question after seeing the solution that comes to mind is why is it optimal. Why selecting the immediate peak is the optimal choice. Here is a mathematical understanding for that.\\n\\nConsider this input : [a, ......, b, ......., c....., d]. Where `...` refers to some input in between. a&c are valleys and b&d are peaks.\\n\\nPoints to understand. \\n1) If b&d both are peaks then there has to be some value in between them which is less than b. If not b could not have been a peak because the direct next peak immediate to a will be d.\\n2) If a&c are valleys then there has to be some value in between them which is greater than a. If not a could not have been a valley because the first valley will itself will be c.\\n3) Considering the first two points and assuming that not picking immediate next peak will lead to a better answer. Lets try to prove if we can do that.  \\n\\t\\nIf point 3 is true then we can say that \\n\\t d-a > (b-a) + (d-c)\\ni.e d > b+d-c               but as b-c > 0\\ni.e d > +ve + d            \\n\\nwhich is a false. So we can always say that picking up immediate next peak will always yeild a better result.\\n\\nHope this helps.\\n"
                    },
                    {
                        "username": "anurag_negi123",
                        "content": "nice mathematical proof bro loved it"
                    },
                    {
                        "username": "youssef",
                        "content": "Hello,\\n\\nI'd like to know why the greedy algorithm that takes pairwise profits if they are positive only?\\n\\nThanks"
                    },
                    {
                        "username": "dpeachpeach",
                        "content": "Hi youssef, I recall a greedy-stays-ahead proof similar to this q in one of my college courses but I forgot it so I'm going to try to lay out the logic as well as possible.\n\nLet there be two prices p_a and p_b in the array. where a < b\nLet us say that there is a distance of n => 1 between the two. (Multiple prices in between the two)\n\nThere are two possible cases for the values of p_a in relation to p_b. Either p_b > p_a, which means we would want to buy. or P_b < p_a, which means we wouldn't want to buy.\nLet's ignore the second case because it's trivial and focus on the first.\n\nOk! So we know that we want to buy p_1 so that we can sell at p_2, but there is a distance of n>= 1 between the two, so this leaves uncertainty.\n\nWell, we know for a fact that overall price change across this period in time is going to be p_2 - p_1 or dp\n\nWe also know that price changes are split by days, which means that there are 'positive days' and 'negative days'\n\nAs we stated earlier, p_b > p_a where the distance between the two is n >= 1. if the distance is 1 (they're right next to each other), in what case would you prefer to take a losing bet? :-)\n\nThis is kind of a clever trick (It's a very nonrigorous proof by induction) but here's also a shaky proof by contradiction to help visualize it.\n\nLet us assume that there is an optimal solution where we choose to take a pairwise loss between two prices as opposed to taking a pairwise gain whenever possible.\n\nThis would somehow imply that the pairwise loss allows us to gain more profit than if we had never taken it in the first place. However, due to the allowances of the challenge, we have perfect foresight of the markets. Whenever there is a 'loss' in price, and that price then goes up in the future, we can always profit by taking a profit between the price in the future and the previous price. (If there is a higher price at the end then it must have gotten to that price somehow in increments or totally between two days). By taking a pairwise loss, we are doing nothing but surrendering 'opportunity profit' that we could have made by just doing pairwise purchasing later.\n\nThat's all shaky, but it's been a few months since I've been in class. Good luck!"
                    },
                    {
                        "username": "rushzone",
                        "content": "Judging from my code that has been accepted by the system, I think the limitation of the question is you can only hold 1 stock at most for any time. Which has not been clarified in the question description.\\n\\nFor more complete question and answer to it, in fact case, the money in your account at the beginning is  determined. What you can do is to make maximum profit from this data. During the progress, you can use the profit you made to buy more stock next time."
                    },
                    {
                        "username": "arhankundu99",
                        "content": "I always feel like a noob while encountering these type of questions. I tried for an hour and all I could manage was brute force method optimised with dp. How do you guys come up with such ideas (Like plotting the points and doing summation of peaks(i)-valeys(i)) ?"
                    },
                    {
                        "username": "heyyyankit",
                        "content": "no need to dp or any thing, just iterate on  prices and if you have profit any day, you can sell.. \n............\ncode:-\n\n      int n=prices.size();\n        int ans=0;\n        for(int i=1; i<=n-1; ++i){\n            int diff=prices[i]-prices[i-1];\n            if(diff>0){ans+=diff;}\n        }\n        return ans;"
                    },
                    {
                        "username": "AdityaDipamanggala",
                        "content": "[@Dipanshi_26](/Dipanshi_26) I think the best approach is to realize sum of neighboring peak is >= global peak, so we dont need to do any brute force"
                    },
                    {
                        "username": "AdityaDipamanggala",
                        "content": "Hahah this also exactly what I\\'m facing, turns out I\\'m too over-complicated the logic behind it, once you realize that sum of neighboring peak is always higher than global peak it will be easy "
                    },
                    {
                        "username": "Dipanshi_26",
                        "content": "Can you please give me hint about the approch you mentioned about? I don\\'t know abhout DP still trying to solve thsi problem."
                    },
                    {
                        "username": "shad",
                        "content": "After reading the description I don't understand what a program is supposed to compute to be accepted.\\n\\nI understand the array of prices, but how do I know what the maximum profit is without  knowing how much I can invest initially?  What about selling short before buying any?\\n\\nI guess there aren't any transaction fees to consider, but I don't know why it says I have to sell before I buy - if I'm maximizing profit, aren't I buying as much as I can afford, then selling it all right before it goes down?"
                    },
                    {
                        "username": "Harshsharma12",
                        "content": "https://leetcode.com/problems/best-time-to-buy-and-sell-stock-ii/description/comments/1567200"
                    },
                    {
                        "username": "biller897",
                        "content": "i\\'ll tell you the most basic thing to understand before doing any \"Buy and Sell Stock\" problem :-\\n\\nTake ex :- [1,4,7,8,6,4]\\nif you take (1, 8) , diff = 7\\nor if you take (1, 4), (4, 7), (7, 8), diff = 3 + 3 + 1 = 7\\n\\nGoing directly to 8, or going to 8 by adding all differences in between is same in result, so rather than thinking to jump, think it in this way.\\n"
                    },
                    {
                        "username": "Novarg",
                        "content": "Imagine you were a stock trader and you know the future prices for a given stock (This is the problem input). Each day you would buy the stock if you knew you could sell it tomorrow for a profit (This is the greedy solution)."
                    }
                ]
            },
            {
                "id": 1570091,
                "content": [
                    {
                        "username": "hanseaston",
                        "content": "We want to buy all the stocks when the line is going up. And want to ignore all the lines when the line is going down.\\n\\nDo a for loop through the array and only count in the green line that is going up, by comparing the two adjacent elements in the array.\\n\\nMany solutions are already posted here. But I think a picture would make things clearer to see.\\n\\n![image](https://assets.leetcode.com/users/hans00/image_1586103419.png)\\n\\n"
                    },
                    {
                        "username": "shashi_singh_18",
                        "content": "I just read the 1st line and my code is accepted. Thanks!!!!!!!!!!!!!!!"
                    },
                    {
                        "username": "introvertCode",
                        "content": "Thank you!"
                    },
                    {
                        "username": "tanushjangid1234",
                        "content": "What a great intuation."
                    },
                    {
                        "username": "glaucusec",
                        "content": "Thanks man. This actually helped a lot"
                    },
                    {
                        "username": "meanup",
                        "content": "`Hint`\\nStill confuse, after seeing the above figure analyse the example 1 and example 2. And it will all make sense. \\nUpvoted! Thank you. "
                    },
                    {
                        "username": "shhung",
                        "content": "It\\'s really simplify the question"
                    },
                    {
                        "username": "mayank-01",
                        "content": "upvoted, thank you for keeping things simple\\uD83D\\uDC4D"
                    },
                    {
                        "username": "falgunitagadkar",
                        "content": "Thanks:)"
                    },
                    {
                        "username": "pranavrocksharma",
                        "content": "what is the meaning of this buying and selling on the same day, profit will be 0 right , so why they highligted in bold, if was selling and then buying on the same day then it would affect on the recurrence but this statement is just added for the sake.\\n\\nAm i wrong or it means something else , i solved assuming we cannot sell and then buy on the same day, we will buy on the next day ."
                    },
                    {
                        "username": "Shaik_Aman_Sayer",
                        "content": "[@Mee_eeM](/Mee_eeM) appreciated dude earned my respect "
                    },
                    {
                        "username": "falgunitagadkar",
                        "content": "[@Dipanshi_26](/Dipanshi_26) The pictorial representation in the above comment has an hint in itself and if you want you can check out my solution.It\\'s not DP solution neither uses Greedy."
                    },
                    {
                        "username": "Dipanshi_26",
                        "content": "I just wanted to ask if this problem can be solved without DP or greedy algorithm because I am new to DSA I have practiced array perfectly. \\nCan you please suggest any othe opproch (hint) without these two approch. "
                    },
                    {
                        "username": "Mee_eeM",
                        "content": "Since you are allow to hold at most one stock at a time it is best to sell it if a lower price comes around. For example on day 1 the price is 7 dollars and day 2 the price is 1 dollar. If you buy on day 1 and sell on 2 you lose money, and you can't buy on day 2 since you've bought on day 1. Allowing you to buy and sell on the same day free up your 1 stock so than you may buy on day 2. Hope this helps."
                    },
                    {
                        "username": "abhijeetkrsingh17",
                        "content": "It is pointless. Even if we think that you sold the stock at higher price and bought new stocks same day as there must be a more higher price than this dates price. then it won\\'t make any difference if you had sold the stocks the next higher day. the diff remains the same."
                    },
                    {
                        "username": "Jeetu_123",
                        "content": "[@godshiva](/godshiva) If u look it as a trader point of view then it is not pointless."
                    },
                    {
                        "username": "itsvishalcodes",
                        "content": "[@sivagowda](/sivagowda) What do you  mean different stock? We are only allowed to hold one stock at a time. So you can only buy on a certain day if you have no stock holdings."
                    },
                    {
                        "username": "sivagowda",
                        "content": "They mean you could sell a stock that you already bought and buy a stock on that day(you could perform buying and selling on the same day of different stocks)"
                    },
                    {
                        "username": "godshiva",
                        "content": "No you\\'re right. You are allowed to do it, but doing so is pointless"
                    },
                    {
                        "username": "Bulbasaur2000",
                        "content": "**Firstly, the second test case explaination might mislead you as it did to me. So, try to avoid that.**\\n\\nLogic: \\nIt is pretty clear that normal brute force approach will take two loops and complexity will become O(n^2). So our objective is to optimise it as far as possible. A **one-pass algorithm** could be used to achieve this optimisation.\\n\\nApproach: \\n1. Initialise a variable(like maxProfit or anything else) which will store the final profit as 0.\\n2. Under a single loop, check for the price which is greater than its previous price. That would be the time when we should sell the stock to earn maximum profit at that instance.\\n3. Add up the profit to the initial variable maxProfit.\\n4. Continue the loop untill it reaches end. Eventually on its way it will keep on checking the profit condition and add up it to your maxProfit.\\n5. Finally return maxProfit.\\n\\nThis approach will take just O(n) time, since only once the entire array is traversed.\\nTry to code it now. Happy Hunting!!! \\n\\n**Do upvote my solution if found useful. It would motivate me furthur and help others.**\\n\\n"
                    },
                    {
                        "username": "bhargav9427",
                        "content": "The most important aspect of any problem is how to arrive at a solution. What should be the thinking process behind it. Lets try to understand how can we reach upto the solution and most important how to convince ourselves that its optimal. Please watch the given solution for this problem as a prerequisite.\\n\\nThe first question after seeing the solution that comes to mind is why is it optimal. Why selecting the immediate peak is the optimal choice. Here is a mathematical understanding for that.\\n\\nConsider this input : [a, ......, b, ......., c....., d]. Where `...` refers to some input in between. a&c are valleys and b&d are peaks.\\n\\nPoints to understand. \\n1) If b&d both are peaks then there has to be some value in between them which is less than b. If not b could not have been a peak because the direct next peak immediate to a will be d.\\n2) If a&c are valleys then there has to be some value in between them which is greater than a. If not a could not have been a valley because the first valley will itself will be c.\\n3) Considering the first two points and assuming that not picking immediate next peak will lead to a better answer. Lets try to prove if we can do that.  \\n\\t\\nIf point 3 is true then we can say that \\n\\t d-a > (b-a) + (d-c)\\ni.e d > b+d-c               but as b-c > 0\\ni.e d > +ve + d            \\n\\nwhich is a false. So we can always say that picking up immediate next peak will always yeild a better result.\\n\\nHope this helps.\\n"
                    },
                    {
                        "username": "anurag_negi123",
                        "content": "nice mathematical proof bro loved it"
                    },
                    {
                        "username": "youssef",
                        "content": "Hello,\\n\\nI'd like to know why the greedy algorithm that takes pairwise profits if they are positive only?\\n\\nThanks"
                    },
                    {
                        "username": "dpeachpeach",
                        "content": "Hi youssef, I recall a greedy-stays-ahead proof similar to this q in one of my college courses but I forgot it so I'm going to try to lay out the logic as well as possible.\n\nLet there be two prices p_a and p_b in the array. where a < b\nLet us say that there is a distance of n => 1 between the two. (Multiple prices in between the two)\n\nThere are two possible cases for the values of p_a in relation to p_b. Either p_b > p_a, which means we would want to buy. or P_b < p_a, which means we wouldn't want to buy.\nLet's ignore the second case because it's trivial and focus on the first.\n\nOk! So we know that we want to buy p_1 so that we can sell at p_2, but there is a distance of n>= 1 between the two, so this leaves uncertainty.\n\nWell, we know for a fact that overall price change across this period in time is going to be p_2 - p_1 or dp\n\nWe also know that price changes are split by days, which means that there are 'positive days' and 'negative days'\n\nAs we stated earlier, p_b > p_a where the distance between the two is n >= 1. if the distance is 1 (they're right next to each other), in what case would you prefer to take a losing bet? :-)\n\nThis is kind of a clever trick (It's a very nonrigorous proof by induction) but here's also a shaky proof by contradiction to help visualize it.\n\nLet us assume that there is an optimal solution where we choose to take a pairwise loss between two prices as opposed to taking a pairwise gain whenever possible.\n\nThis would somehow imply that the pairwise loss allows us to gain more profit than if we had never taken it in the first place. However, due to the allowances of the challenge, we have perfect foresight of the markets. Whenever there is a 'loss' in price, and that price then goes up in the future, we can always profit by taking a profit between the price in the future and the previous price. (If there is a higher price at the end then it must have gotten to that price somehow in increments or totally between two days). By taking a pairwise loss, we are doing nothing but surrendering 'opportunity profit' that we could have made by just doing pairwise purchasing later.\n\nThat's all shaky, but it's been a few months since I've been in class. Good luck!"
                    },
                    {
                        "username": "rushzone",
                        "content": "Judging from my code that has been accepted by the system, I think the limitation of the question is you can only hold 1 stock at most for any time. Which has not been clarified in the question description.\\n\\nFor more complete question and answer to it, in fact case, the money in your account at the beginning is  determined. What you can do is to make maximum profit from this data. During the progress, you can use the profit you made to buy more stock next time."
                    },
                    {
                        "username": "arhankundu99",
                        "content": "I always feel like a noob while encountering these type of questions. I tried for an hour and all I could manage was brute force method optimised with dp. How do you guys come up with such ideas (Like plotting the points and doing summation of peaks(i)-valeys(i)) ?"
                    },
                    {
                        "username": "heyyyankit",
                        "content": "no need to dp or any thing, just iterate on  prices and if you have profit any day, you can sell.. \n............\ncode:-\n\n      int n=prices.size();\n        int ans=0;\n        for(int i=1; i<=n-1; ++i){\n            int diff=prices[i]-prices[i-1];\n            if(diff>0){ans+=diff;}\n        }\n        return ans;"
                    },
                    {
                        "username": "AdityaDipamanggala",
                        "content": "[@Dipanshi_26](/Dipanshi_26) I think the best approach is to realize sum of neighboring peak is >= global peak, so we dont need to do any brute force"
                    },
                    {
                        "username": "AdityaDipamanggala",
                        "content": "Hahah this also exactly what I\\'m facing, turns out I\\'m too over-complicated the logic behind it, once you realize that sum of neighboring peak is always higher than global peak it will be easy "
                    },
                    {
                        "username": "Dipanshi_26",
                        "content": "Can you please give me hint about the approch you mentioned about? I don\\'t know abhout DP still trying to solve thsi problem."
                    },
                    {
                        "username": "shad",
                        "content": "After reading the description I don't understand what a program is supposed to compute to be accepted.\\n\\nI understand the array of prices, but how do I know what the maximum profit is without  knowing how much I can invest initially?  What about selling short before buying any?\\n\\nI guess there aren't any transaction fees to consider, but I don't know why it says I have to sell before I buy - if I'm maximizing profit, aren't I buying as much as I can afford, then selling it all right before it goes down?"
                    },
                    {
                        "username": "Harshsharma12",
                        "content": "https://leetcode.com/problems/best-time-to-buy-and-sell-stock-ii/description/comments/1567200"
                    },
                    {
                        "username": "biller897",
                        "content": "i\\'ll tell you the most basic thing to understand before doing any \"Buy and Sell Stock\" problem :-\\n\\nTake ex :- [1,4,7,8,6,4]\\nif you take (1, 8) , diff = 7\\nor if you take (1, 4), (4, 7), (7, 8), diff = 3 + 3 + 1 = 7\\n\\nGoing directly to 8, or going to 8 by adding all differences in between is same in result, so rather than thinking to jump, think it in this way.\\n"
                    },
                    {
                        "username": "Novarg",
                        "content": "Imagine you were a stock trader and you know the future prices for a given stock (This is the problem input). Each day you would buy the stock if you knew you could sell it tomorrow for a profit (This is the greedy solution)."
                    }
                ]
            },
            {
                "id": 1565315,
                "content": [
                    {
                        "username": "hanseaston",
                        "content": "We want to buy all the stocks when the line is going up. And want to ignore all the lines when the line is going down.\\n\\nDo a for loop through the array and only count in the green line that is going up, by comparing the two adjacent elements in the array.\\n\\nMany solutions are already posted here. But I think a picture would make things clearer to see.\\n\\n![image](https://assets.leetcode.com/users/hans00/image_1586103419.png)\\n\\n"
                    },
                    {
                        "username": "shashi_singh_18",
                        "content": "I just read the 1st line and my code is accepted. Thanks!!!!!!!!!!!!!!!"
                    },
                    {
                        "username": "introvertCode",
                        "content": "Thank you!"
                    },
                    {
                        "username": "tanushjangid1234",
                        "content": "What a great intuation."
                    },
                    {
                        "username": "glaucusec",
                        "content": "Thanks man. This actually helped a lot"
                    },
                    {
                        "username": "meanup",
                        "content": "`Hint`\\nStill confuse, after seeing the above figure analyse the example 1 and example 2. And it will all make sense. \\nUpvoted! Thank you. "
                    },
                    {
                        "username": "shhung",
                        "content": "It\\'s really simplify the question"
                    },
                    {
                        "username": "mayank-01",
                        "content": "upvoted, thank you for keeping things simple\\uD83D\\uDC4D"
                    },
                    {
                        "username": "falgunitagadkar",
                        "content": "Thanks:)"
                    },
                    {
                        "username": "pranavrocksharma",
                        "content": "what is the meaning of this buying and selling on the same day, profit will be 0 right , so why they highligted in bold, if was selling and then buying on the same day then it would affect on the recurrence but this statement is just added for the sake.\\n\\nAm i wrong or it means something else , i solved assuming we cannot sell and then buy on the same day, we will buy on the next day ."
                    },
                    {
                        "username": "Shaik_Aman_Sayer",
                        "content": "[@Mee_eeM](/Mee_eeM) appreciated dude earned my respect "
                    },
                    {
                        "username": "falgunitagadkar",
                        "content": "[@Dipanshi_26](/Dipanshi_26) The pictorial representation in the above comment has an hint in itself and if you want you can check out my solution.It\\'s not DP solution neither uses Greedy."
                    },
                    {
                        "username": "Dipanshi_26",
                        "content": "I just wanted to ask if this problem can be solved without DP or greedy algorithm because I am new to DSA I have practiced array perfectly. \\nCan you please suggest any othe opproch (hint) without these two approch. "
                    },
                    {
                        "username": "Mee_eeM",
                        "content": "Since you are allow to hold at most one stock at a time it is best to sell it if a lower price comes around. For example on day 1 the price is 7 dollars and day 2 the price is 1 dollar. If you buy on day 1 and sell on 2 you lose money, and you can't buy on day 2 since you've bought on day 1. Allowing you to buy and sell on the same day free up your 1 stock so than you may buy on day 2. Hope this helps."
                    },
                    {
                        "username": "abhijeetkrsingh17",
                        "content": "It is pointless. Even if we think that you sold the stock at higher price and bought new stocks same day as there must be a more higher price than this dates price. then it won\\'t make any difference if you had sold the stocks the next higher day. the diff remains the same."
                    },
                    {
                        "username": "Jeetu_123",
                        "content": "[@godshiva](/godshiva) If u look it as a trader point of view then it is not pointless."
                    },
                    {
                        "username": "itsvishalcodes",
                        "content": "[@sivagowda](/sivagowda) What do you  mean different stock? We are only allowed to hold one stock at a time. So you can only buy on a certain day if you have no stock holdings."
                    },
                    {
                        "username": "sivagowda",
                        "content": "They mean you could sell a stock that you already bought and buy a stock on that day(you could perform buying and selling on the same day of different stocks)"
                    },
                    {
                        "username": "godshiva",
                        "content": "No you\\'re right. You are allowed to do it, but doing so is pointless"
                    },
                    {
                        "username": "Bulbasaur2000",
                        "content": "**Firstly, the second test case explaination might mislead you as it did to me. So, try to avoid that.**\\n\\nLogic: \\nIt is pretty clear that normal brute force approach will take two loops and complexity will become O(n^2). So our objective is to optimise it as far as possible. A **one-pass algorithm** could be used to achieve this optimisation.\\n\\nApproach: \\n1. Initialise a variable(like maxProfit or anything else) which will store the final profit as 0.\\n2. Under a single loop, check for the price which is greater than its previous price. That would be the time when we should sell the stock to earn maximum profit at that instance.\\n3. Add up the profit to the initial variable maxProfit.\\n4. Continue the loop untill it reaches end. Eventually on its way it will keep on checking the profit condition and add up it to your maxProfit.\\n5. Finally return maxProfit.\\n\\nThis approach will take just O(n) time, since only once the entire array is traversed.\\nTry to code it now. Happy Hunting!!! \\n\\n**Do upvote my solution if found useful. It would motivate me furthur and help others.**\\n\\n"
                    },
                    {
                        "username": "bhargav9427",
                        "content": "The most important aspect of any problem is how to arrive at a solution. What should be the thinking process behind it. Lets try to understand how can we reach upto the solution and most important how to convince ourselves that its optimal. Please watch the given solution for this problem as a prerequisite.\\n\\nThe first question after seeing the solution that comes to mind is why is it optimal. Why selecting the immediate peak is the optimal choice. Here is a mathematical understanding for that.\\n\\nConsider this input : [a, ......, b, ......., c....., d]. Where `...` refers to some input in between. a&c are valleys and b&d are peaks.\\n\\nPoints to understand. \\n1) If b&d both are peaks then there has to be some value in between them which is less than b. If not b could not have been a peak because the direct next peak immediate to a will be d.\\n2) If a&c are valleys then there has to be some value in between them which is greater than a. If not a could not have been a valley because the first valley will itself will be c.\\n3) Considering the first two points and assuming that not picking immediate next peak will lead to a better answer. Lets try to prove if we can do that.  \\n\\t\\nIf point 3 is true then we can say that \\n\\t d-a > (b-a) + (d-c)\\ni.e d > b+d-c               but as b-c > 0\\ni.e d > +ve + d            \\n\\nwhich is a false. So we can always say that picking up immediate next peak will always yeild a better result.\\n\\nHope this helps.\\n"
                    },
                    {
                        "username": "anurag_negi123",
                        "content": "nice mathematical proof bro loved it"
                    },
                    {
                        "username": "youssef",
                        "content": "Hello,\\n\\nI'd like to know why the greedy algorithm that takes pairwise profits if they are positive only?\\n\\nThanks"
                    },
                    {
                        "username": "dpeachpeach",
                        "content": "Hi youssef, I recall a greedy-stays-ahead proof similar to this q in one of my college courses but I forgot it so I'm going to try to lay out the logic as well as possible.\n\nLet there be two prices p_a and p_b in the array. where a < b\nLet us say that there is a distance of n => 1 between the two. (Multiple prices in between the two)\n\nThere are two possible cases for the values of p_a in relation to p_b. Either p_b > p_a, which means we would want to buy. or P_b < p_a, which means we wouldn't want to buy.\nLet's ignore the second case because it's trivial and focus on the first.\n\nOk! So we know that we want to buy p_1 so that we can sell at p_2, but there is a distance of n>= 1 between the two, so this leaves uncertainty.\n\nWell, we know for a fact that overall price change across this period in time is going to be p_2 - p_1 or dp\n\nWe also know that price changes are split by days, which means that there are 'positive days' and 'negative days'\n\nAs we stated earlier, p_b > p_a where the distance between the two is n >= 1. if the distance is 1 (they're right next to each other), in what case would you prefer to take a losing bet? :-)\n\nThis is kind of a clever trick (It's a very nonrigorous proof by induction) but here's also a shaky proof by contradiction to help visualize it.\n\nLet us assume that there is an optimal solution where we choose to take a pairwise loss between two prices as opposed to taking a pairwise gain whenever possible.\n\nThis would somehow imply that the pairwise loss allows us to gain more profit than if we had never taken it in the first place. However, due to the allowances of the challenge, we have perfect foresight of the markets. Whenever there is a 'loss' in price, and that price then goes up in the future, we can always profit by taking a profit between the price in the future and the previous price. (If there is a higher price at the end then it must have gotten to that price somehow in increments or totally between two days). By taking a pairwise loss, we are doing nothing but surrendering 'opportunity profit' that we could have made by just doing pairwise purchasing later.\n\nThat's all shaky, but it's been a few months since I've been in class. Good luck!"
                    },
                    {
                        "username": "rushzone",
                        "content": "Judging from my code that has been accepted by the system, I think the limitation of the question is you can only hold 1 stock at most for any time. Which has not been clarified in the question description.\\n\\nFor more complete question and answer to it, in fact case, the money in your account at the beginning is  determined. What you can do is to make maximum profit from this data. During the progress, you can use the profit you made to buy more stock next time."
                    },
                    {
                        "username": "arhankundu99",
                        "content": "I always feel like a noob while encountering these type of questions. I tried for an hour and all I could manage was brute force method optimised with dp. How do you guys come up with such ideas (Like plotting the points and doing summation of peaks(i)-valeys(i)) ?"
                    },
                    {
                        "username": "heyyyankit",
                        "content": "no need to dp or any thing, just iterate on  prices and if you have profit any day, you can sell.. \n............\ncode:-\n\n      int n=prices.size();\n        int ans=0;\n        for(int i=1; i<=n-1; ++i){\n            int diff=prices[i]-prices[i-1];\n            if(diff>0){ans+=diff;}\n        }\n        return ans;"
                    },
                    {
                        "username": "AdityaDipamanggala",
                        "content": "[@Dipanshi_26](/Dipanshi_26) I think the best approach is to realize sum of neighboring peak is >= global peak, so we dont need to do any brute force"
                    },
                    {
                        "username": "AdityaDipamanggala",
                        "content": "Hahah this also exactly what I\\'m facing, turns out I\\'m too over-complicated the logic behind it, once you realize that sum of neighboring peak is always higher than global peak it will be easy "
                    },
                    {
                        "username": "Dipanshi_26",
                        "content": "Can you please give me hint about the approch you mentioned about? I don\\'t know abhout DP still trying to solve thsi problem."
                    },
                    {
                        "username": "shad",
                        "content": "After reading the description I don't understand what a program is supposed to compute to be accepted.\\n\\nI understand the array of prices, but how do I know what the maximum profit is without  knowing how much I can invest initially?  What about selling short before buying any?\\n\\nI guess there aren't any transaction fees to consider, but I don't know why it says I have to sell before I buy - if I'm maximizing profit, aren't I buying as much as I can afford, then selling it all right before it goes down?"
                    },
                    {
                        "username": "Harshsharma12",
                        "content": "https://leetcode.com/problems/best-time-to-buy-and-sell-stock-ii/description/comments/1567200"
                    },
                    {
                        "username": "biller897",
                        "content": "i\\'ll tell you the most basic thing to understand before doing any \"Buy and Sell Stock\" problem :-\\n\\nTake ex :- [1,4,7,8,6,4]\\nif you take (1, 8) , diff = 7\\nor if you take (1, 4), (4, 7), (7, 8), diff = 3 + 3 + 1 = 7\\n\\nGoing directly to 8, or going to 8 by adding all differences in between is same in result, so rather than thinking to jump, think it in this way.\\n"
                    },
                    {
                        "username": "Novarg",
                        "content": "Imagine you were a stock trader and you know the future prices for a given stock (This is the problem input). Each day you would buy the stock if you knew you could sell it tomorrow for a profit (This is the greedy solution)."
                    }
                ]
            },
            {
                "id": 1566747,
                "content": [
                    {
                        "username": "hanseaston",
                        "content": "We want to buy all the stocks when the line is going up. And want to ignore all the lines when the line is going down.\\n\\nDo a for loop through the array and only count in the green line that is going up, by comparing the two adjacent elements in the array.\\n\\nMany solutions are already posted here. But I think a picture would make things clearer to see.\\n\\n![image](https://assets.leetcode.com/users/hans00/image_1586103419.png)\\n\\n"
                    },
                    {
                        "username": "shashi_singh_18",
                        "content": "I just read the 1st line and my code is accepted. Thanks!!!!!!!!!!!!!!!"
                    },
                    {
                        "username": "introvertCode",
                        "content": "Thank you!"
                    },
                    {
                        "username": "tanushjangid1234",
                        "content": "What a great intuation."
                    },
                    {
                        "username": "glaucusec",
                        "content": "Thanks man. This actually helped a lot"
                    },
                    {
                        "username": "meanup",
                        "content": "`Hint`\\nStill confuse, after seeing the above figure analyse the example 1 and example 2. And it will all make sense. \\nUpvoted! Thank you. "
                    },
                    {
                        "username": "shhung",
                        "content": "It\\'s really simplify the question"
                    },
                    {
                        "username": "mayank-01",
                        "content": "upvoted, thank you for keeping things simple\\uD83D\\uDC4D"
                    },
                    {
                        "username": "falgunitagadkar",
                        "content": "Thanks:)"
                    },
                    {
                        "username": "pranavrocksharma",
                        "content": "what is the meaning of this buying and selling on the same day, profit will be 0 right , so why they highligted in bold, if was selling and then buying on the same day then it would affect on the recurrence but this statement is just added for the sake.\\n\\nAm i wrong or it means something else , i solved assuming we cannot sell and then buy on the same day, we will buy on the next day ."
                    },
                    {
                        "username": "Shaik_Aman_Sayer",
                        "content": "[@Mee_eeM](/Mee_eeM) appreciated dude earned my respect "
                    },
                    {
                        "username": "falgunitagadkar",
                        "content": "[@Dipanshi_26](/Dipanshi_26) The pictorial representation in the above comment has an hint in itself and if you want you can check out my solution.It\\'s not DP solution neither uses Greedy."
                    },
                    {
                        "username": "Dipanshi_26",
                        "content": "I just wanted to ask if this problem can be solved without DP or greedy algorithm because I am new to DSA I have practiced array perfectly. \\nCan you please suggest any othe opproch (hint) without these two approch. "
                    },
                    {
                        "username": "Mee_eeM",
                        "content": "Since you are allow to hold at most one stock at a time it is best to sell it if a lower price comes around. For example on day 1 the price is 7 dollars and day 2 the price is 1 dollar. If you buy on day 1 and sell on 2 you lose money, and you can't buy on day 2 since you've bought on day 1. Allowing you to buy and sell on the same day free up your 1 stock so than you may buy on day 2. Hope this helps."
                    },
                    {
                        "username": "abhijeetkrsingh17",
                        "content": "It is pointless. Even if we think that you sold the stock at higher price and bought new stocks same day as there must be a more higher price than this dates price. then it won\\'t make any difference if you had sold the stocks the next higher day. the diff remains the same."
                    },
                    {
                        "username": "Jeetu_123",
                        "content": "[@godshiva](/godshiva) If u look it as a trader point of view then it is not pointless."
                    },
                    {
                        "username": "itsvishalcodes",
                        "content": "[@sivagowda](/sivagowda) What do you  mean different stock? We are only allowed to hold one stock at a time. So you can only buy on a certain day if you have no stock holdings."
                    },
                    {
                        "username": "sivagowda",
                        "content": "They mean you could sell a stock that you already bought and buy a stock on that day(you could perform buying and selling on the same day of different stocks)"
                    },
                    {
                        "username": "godshiva",
                        "content": "No you\\'re right. You are allowed to do it, but doing so is pointless"
                    },
                    {
                        "username": "Bulbasaur2000",
                        "content": "**Firstly, the second test case explaination might mislead you as it did to me. So, try to avoid that.**\\n\\nLogic: \\nIt is pretty clear that normal brute force approach will take two loops and complexity will become O(n^2). So our objective is to optimise it as far as possible. A **one-pass algorithm** could be used to achieve this optimisation.\\n\\nApproach: \\n1. Initialise a variable(like maxProfit or anything else) which will store the final profit as 0.\\n2. Under a single loop, check for the price which is greater than its previous price. That would be the time when we should sell the stock to earn maximum profit at that instance.\\n3. Add up the profit to the initial variable maxProfit.\\n4. Continue the loop untill it reaches end. Eventually on its way it will keep on checking the profit condition and add up it to your maxProfit.\\n5. Finally return maxProfit.\\n\\nThis approach will take just O(n) time, since only once the entire array is traversed.\\nTry to code it now. Happy Hunting!!! \\n\\n**Do upvote my solution if found useful. It would motivate me furthur and help others.**\\n\\n"
                    },
                    {
                        "username": "bhargav9427",
                        "content": "The most important aspect of any problem is how to arrive at a solution. What should be the thinking process behind it. Lets try to understand how can we reach upto the solution and most important how to convince ourselves that its optimal. Please watch the given solution for this problem as a prerequisite.\\n\\nThe first question after seeing the solution that comes to mind is why is it optimal. Why selecting the immediate peak is the optimal choice. Here is a mathematical understanding for that.\\n\\nConsider this input : [a, ......, b, ......., c....., d]. Where `...` refers to some input in between. a&c are valleys and b&d are peaks.\\n\\nPoints to understand. \\n1) If b&d both are peaks then there has to be some value in between them which is less than b. If not b could not have been a peak because the direct next peak immediate to a will be d.\\n2) If a&c are valleys then there has to be some value in between them which is greater than a. If not a could not have been a valley because the first valley will itself will be c.\\n3) Considering the first two points and assuming that not picking immediate next peak will lead to a better answer. Lets try to prove if we can do that.  \\n\\t\\nIf point 3 is true then we can say that \\n\\t d-a > (b-a) + (d-c)\\ni.e d > b+d-c               but as b-c > 0\\ni.e d > +ve + d            \\n\\nwhich is a false. So we can always say that picking up immediate next peak will always yeild a better result.\\n\\nHope this helps.\\n"
                    },
                    {
                        "username": "anurag_negi123",
                        "content": "nice mathematical proof bro loved it"
                    },
                    {
                        "username": "youssef",
                        "content": "Hello,\\n\\nI'd like to know why the greedy algorithm that takes pairwise profits if they are positive only?\\n\\nThanks"
                    },
                    {
                        "username": "dpeachpeach",
                        "content": "Hi youssef, I recall a greedy-stays-ahead proof similar to this q in one of my college courses but I forgot it so I'm going to try to lay out the logic as well as possible.\n\nLet there be two prices p_a and p_b in the array. where a < b\nLet us say that there is a distance of n => 1 between the two. (Multiple prices in between the two)\n\nThere are two possible cases for the values of p_a in relation to p_b. Either p_b > p_a, which means we would want to buy. or P_b < p_a, which means we wouldn't want to buy.\nLet's ignore the second case because it's trivial and focus on the first.\n\nOk! So we know that we want to buy p_1 so that we can sell at p_2, but there is a distance of n>= 1 between the two, so this leaves uncertainty.\n\nWell, we know for a fact that overall price change across this period in time is going to be p_2 - p_1 or dp\n\nWe also know that price changes are split by days, which means that there are 'positive days' and 'negative days'\n\nAs we stated earlier, p_b > p_a where the distance between the two is n >= 1. if the distance is 1 (they're right next to each other), in what case would you prefer to take a losing bet? :-)\n\nThis is kind of a clever trick (It's a very nonrigorous proof by induction) but here's also a shaky proof by contradiction to help visualize it.\n\nLet us assume that there is an optimal solution where we choose to take a pairwise loss between two prices as opposed to taking a pairwise gain whenever possible.\n\nThis would somehow imply that the pairwise loss allows us to gain more profit than if we had never taken it in the first place. However, due to the allowances of the challenge, we have perfect foresight of the markets. Whenever there is a 'loss' in price, and that price then goes up in the future, we can always profit by taking a profit between the price in the future and the previous price. (If there is a higher price at the end then it must have gotten to that price somehow in increments or totally between two days). By taking a pairwise loss, we are doing nothing but surrendering 'opportunity profit' that we could have made by just doing pairwise purchasing later.\n\nThat's all shaky, but it's been a few months since I've been in class. Good luck!"
                    },
                    {
                        "username": "rushzone",
                        "content": "Judging from my code that has been accepted by the system, I think the limitation of the question is you can only hold 1 stock at most for any time. Which has not been clarified in the question description.\\n\\nFor more complete question and answer to it, in fact case, the money in your account at the beginning is  determined. What you can do is to make maximum profit from this data. During the progress, you can use the profit you made to buy more stock next time."
                    },
                    {
                        "username": "arhankundu99",
                        "content": "I always feel like a noob while encountering these type of questions. I tried for an hour and all I could manage was brute force method optimised with dp. How do you guys come up with such ideas (Like plotting the points and doing summation of peaks(i)-valeys(i)) ?"
                    },
                    {
                        "username": "heyyyankit",
                        "content": "no need to dp or any thing, just iterate on  prices and if you have profit any day, you can sell.. \n............\ncode:-\n\n      int n=prices.size();\n        int ans=0;\n        for(int i=1; i<=n-1; ++i){\n            int diff=prices[i]-prices[i-1];\n            if(diff>0){ans+=diff;}\n        }\n        return ans;"
                    },
                    {
                        "username": "AdityaDipamanggala",
                        "content": "[@Dipanshi_26](/Dipanshi_26) I think the best approach is to realize sum of neighboring peak is >= global peak, so we dont need to do any brute force"
                    },
                    {
                        "username": "AdityaDipamanggala",
                        "content": "Hahah this also exactly what I\\'m facing, turns out I\\'m too over-complicated the logic behind it, once you realize that sum of neighboring peak is always higher than global peak it will be easy "
                    },
                    {
                        "username": "Dipanshi_26",
                        "content": "Can you please give me hint about the approch you mentioned about? I don\\'t know abhout DP still trying to solve thsi problem."
                    },
                    {
                        "username": "shad",
                        "content": "After reading the description I don't understand what a program is supposed to compute to be accepted.\\n\\nI understand the array of prices, but how do I know what the maximum profit is without  knowing how much I can invest initially?  What about selling short before buying any?\\n\\nI guess there aren't any transaction fees to consider, but I don't know why it says I have to sell before I buy - if I'm maximizing profit, aren't I buying as much as I can afford, then selling it all right before it goes down?"
                    },
                    {
                        "username": "Harshsharma12",
                        "content": "https://leetcode.com/problems/best-time-to-buy-and-sell-stock-ii/description/comments/1567200"
                    },
                    {
                        "username": "biller897",
                        "content": "i\\'ll tell you the most basic thing to understand before doing any \"Buy and Sell Stock\" problem :-\\n\\nTake ex :- [1,4,7,8,6,4]\\nif you take (1, 8) , diff = 7\\nor if you take (1, 4), (4, 7), (7, 8), diff = 3 + 3 + 1 = 7\\n\\nGoing directly to 8, or going to 8 by adding all differences in between is same in result, so rather than thinking to jump, think it in this way.\\n"
                    },
                    {
                        "username": "Novarg",
                        "content": "Imagine you were a stock trader and you know the future prices for a given stock (This is the problem input). Each day you would buy the stock if you knew you could sell it tomorrow for a profit (This is the greedy solution)."
                    }
                ]
            },
            {
                "id": 1568310,
                "content": [
                    {
                        "username": "hanseaston",
                        "content": "We want to buy all the stocks when the line is going up. And want to ignore all the lines when the line is going down.\\n\\nDo a for loop through the array and only count in the green line that is going up, by comparing the two adjacent elements in the array.\\n\\nMany solutions are already posted here. But I think a picture would make things clearer to see.\\n\\n![image](https://assets.leetcode.com/users/hans00/image_1586103419.png)\\n\\n"
                    },
                    {
                        "username": "shashi_singh_18",
                        "content": "I just read the 1st line and my code is accepted. Thanks!!!!!!!!!!!!!!!"
                    },
                    {
                        "username": "introvertCode",
                        "content": "Thank you!"
                    },
                    {
                        "username": "tanushjangid1234",
                        "content": "What a great intuation."
                    },
                    {
                        "username": "glaucusec",
                        "content": "Thanks man. This actually helped a lot"
                    },
                    {
                        "username": "meanup",
                        "content": "`Hint`\\nStill confuse, after seeing the above figure analyse the example 1 and example 2. And it will all make sense. \\nUpvoted! Thank you. "
                    },
                    {
                        "username": "shhung",
                        "content": "It\\'s really simplify the question"
                    },
                    {
                        "username": "mayank-01",
                        "content": "upvoted, thank you for keeping things simple\\uD83D\\uDC4D"
                    },
                    {
                        "username": "falgunitagadkar",
                        "content": "Thanks:)"
                    },
                    {
                        "username": "pranavrocksharma",
                        "content": "what is the meaning of this buying and selling on the same day, profit will be 0 right , so why they highligted in bold, if was selling and then buying on the same day then it would affect on the recurrence but this statement is just added for the sake.\\n\\nAm i wrong or it means something else , i solved assuming we cannot sell and then buy on the same day, we will buy on the next day ."
                    },
                    {
                        "username": "Shaik_Aman_Sayer",
                        "content": "[@Mee_eeM](/Mee_eeM) appreciated dude earned my respect "
                    },
                    {
                        "username": "falgunitagadkar",
                        "content": "[@Dipanshi_26](/Dipanshi_26) The pictorial representation in the above comment has an hint in itself and if you want you can check out my solution.It\\'s not DP solution neither uses Greedy."
                    },
                    {
                        "username": "Dipanshi_26",
                        "content": "I just wanted to ask if this problem can be solved without DP or greedy algorithm because I am new to DSA I have practiced array perfectly. \\nCan you please suggest any othe opproch (hint) without these two approch. "
                    },
                    {
                        "username": "Mee_eeM",
                        "content": "Since you are allow to hold at most one stock at a time it is best to sell it if a lower price comes around. For example on day 1 the price is 7 dollars and day 2 the price is 1 dollar. If you buy on day 1 and sell on 2 you lose money, and you can't buy on day 2 since you've bought on day 1. Allowing you to buy and sell on the same day free up your 1 stock so than you may buy on day 2. Hope this helps."
                    },
                    {
                        "username": "abhijeetkrsingh17",
                        "content": "It is pointless. Even if we think that you sold the stock at higher price and bought new stocks same day as there must be a more higher price than this dates price. then it won\\'t make any difference if you had sold the stocks the next higher day. the diff remains the same."
                    },
                    {
                        "username": "Jeetu_123",
                        "content": "[@godshiva](/godshiva) If u look it as a trader point of view then it is not pointless."
                    },
                    {
                        "username": "itsvishalcodes",
                        "content": "[@sivagowda](/sivagowda) What do you  mean different stock? We are only allowed to hold one stock at a time. So you can only buy on a certain day if you have no stock holdings."
                    },
                    {
                        "username": "sivagowda",
                        "content": "They mean you could sell a stock that you already bought and buy a stock on that day(you could perform buying and selling on the same day of different stocks)"
                    },
                    {
                        "username": "godshiva",
                        "content": "No you\\'re right. You are allowed to do it, but doing so is pointless"
                    },
                    {
                        "username": "Bulbasaur2000",
                        "content": "**Firstly, the second test case explaination might mislead you as it did to me. So, try to avoid that.**\\n\\nLogic: \\nIt is pretty clear that normal brute force approach will take two loops and complexity will become O(n^2). So our objective is to optimise it as far as possible. A **one-pass algorithm** could be used to achieve this optimisation.\\n\\nApproach: \\n1. Initialise a variable(like maxProfit or anything else) which will store the final profit as 0.\\n2. Under a single loop, check for the price which is greater than its previous price. That would be the time when we should sell the stock to earn maximum profit at that instance.\\n3. Add up the profit to the initial variable maxProfit.\\n4. Continue the loop untill it reaches end. Eventually on its way it will keep on checking the profit condition and add up it to your maxProfit.\\n5. Finally return maxProfit.\\n\\nThis approach will take just O(n) time, since only once the entire array is traversed.\\nTry to code it now. Happy Hunting!!! \\n\\n**Do upvote my solution if found useful. It would motivate me furthur and help others.**\\n\\n"
                    },
                    {
                        "username": "bhargav9427",
                        "content": "The most important aspect of any problem is how to arrive at a solution. What should be the thinking process behind it. Lets try to understand how can we reach upto the solution and most important how to convince ourselves that its optimal. Please watch the given solution for this problem as a prerequisite.\\n\\nThe first question after seeing the solution that comes to mind is why is it optimal. Why selecting the immediate peak is the optimal choice. Here is a mathematical understanding for that.\\n\\nConsider this input : [a, ......, b, ......., c....., d]. Where `...` refers to some input in between. a&c are valleys and b&d are peaks.\\n\\nPoints to understand. \\n1) If b&d both are peaks then there has to be some value in between them which is less than b. If not b could not have been a peak because the direct next peak immediate to a will be d.\\n2) If a&c are valleys then there has to be some value in between them which is greater than a. If not a could not have been a valley because the first valley will itself will be c.\\n3) Considering the first two points and assuming that not picking immediate next peak will lead to a better answer. Lets try to prove if we can do that.  \\n\\t\\nIf point 3 is true then we can say that \\n\\t d-a > (b-a) + (d-c)\\ni.e d > b+d-c               but as b-c > 0\\ni.e d > +ve + d            \\n\\nwhich is a false. So we can always say that picking up immediate next peak will always yeild a better result.\\n\\nHope this helps.\\n"
                    },
                    {
                        "username": "anurag_negi123",
                        "content": "nice mathematical proof bro loved it"
                    },
                    {
                        "username": "youssef",
                        "content": "Hello,\\n\\nI'd like to know why the greedy algorithm that takes pairwise profits if they are positive only?\\n\\nThanks"
                    },
                    {
                        "username": "dpeachpeach",
                        "content": "Hi youssef, I recall a greedy-stays-ahead proof similar to this q in one of my college courses but I forgot it so I'm going to try to lay out the logic as well as possible.\n\nLet there be two prices p_a and p_b in the array. where a < b\nLet us say that there is a distance of n => 1 between the two. (Multiple prices in between the two)\n\nThere are two possible cases for the values of p_a in relation to p_b. Either p_b > p_a, which means we would want to buy. or P_b < p_a, which means we wouldn't want to buy.\nLet's ignore the second case because it's trivial and focus on the first.\n\nOk! So we know that we want to buy p_1 so that we can sell at p_2, but there is a distance of n>= 1 between the two, so this leaves uncertainty.\n\nWell, we know for a fact that overall price change across this period in time is going to be p_2 - p_1 or dp\n\nWe also know that price changes are split by days, which means that there are 'positive days' and 'negative days'\n\nAs we stated earlier, p_b > p_a where the distance between the two is n >= 1. if the distance is 1 (they're right next to each other), in what case would you prefer to take a losing bet? :-)\n\nThis is kind of a clever trick (It's a very nonrigorous proof by induction) but here's also a shaky proof by contradiction to help visualize it.\n\nLet us assume that there is an optimal solution where we choose to take a pairwise loss between two prices as opposed to taking a pairwise gain whenever possible.\n\nThis would somehow imply that the pairwise loss allows us to gain more profit than if we had never taken it in the first place. However, due to the allowances of the challenge, we have perfect foresight of the markets. Whenever there is a 'loss' in price, and that price then goes up in the future, we can always profit by taking a profit between the price in the future and the previous price. (If there is a higher price at the end then it must have gotten to that price somehow in increments or totally between two days). By taking a pairwise loss, we are doing nothing but surrendering 'opportunity profit' that we could have made by just doing pairwise purchasing later.\n\nThat's all shaky, but it's been a few months since I've been in class. Good luck!"
                    },
                    {
                        "username": "rushzone",
                        "content": "Judging from my code that has been accepted by the system, I think the limitation of the question is you can only hold 1 stock at most for any time. Which has not been clarified in the question description.\\n\\nFor more complete question and answer to it, in fact case, the money in your account at the beginning is  determined. What you can do is to make maximum profit from this data. During the progress, you can use the profit you made to buy more stock next time."
                    },
                    {
                        "username": "arhankundu99",
                        "content": "I always feel like a noob while encountering these type of questions. I tried for an hour and all I could manage was brute force method optimised with dp. How do you guys come up with such ideas (Like plotting the points and doing summation of peaks(i)-valeys(i)) ?"
                    },
                    {
                        "username": "heyyyankit",
                        "content": "no need to dp or any thing, just iterate on  prices and if you have profit any day, you can sell.. \n............\ncode:-\n\n      int n=prices.size();\n        int ans=0;\n        for(int i=1; i<=n-1; ++i){\n            int diff=prices[i]-prices[i-1];\n            if(diff>0){ans+=diff;}\n        }\n        return ans;"
                    },
                    {
                        "username": "AdityaDipamanggala",
                        "content": "[@Dipanshi_26](/Dipanshi_26) I think the best approach is to realize sum of neighboring peak is >= global peak, so we dont need to do any brute force"
                    },
                    {
                        "username": "AdityaDipamanggala",
                        "content": "Hahah this also exactly what I\\'m facing, turns out I\\'m too over-complicated the logic behind it, once you realize that sum of neighboring peak is always higher than global peak it will be easy "
                    },
                    {
                        "username": "Dipanshi_26",
                        "content": "Can you please give me hint about the approch you mentioned about? I don\\'t know abhout DP still trying to solve thsi problem."
                    },
                    {
                        "username": "shad",
                        "content": "After reading the description I don't understand what a program is supposed to compute to be accepted.\\n\\nI understand the array of prices, but how do I know what the maximum profit is without  knowing how much I can invest initially?  What about selling short before buying any?\\n\\nI guess there aren't any transaction fees to consider, but I don't know why it says I have to sell before I buy - if I'm maximizing profit, aren't I buying as much as I can afford, then selling it all right before it goes down?"
                    },
                    {
                        "username": "Harshsharma12",
                        "content": "https://leetcode.com/problems/best-time-to-buy-and-sell-stock-ii/description/comments/1567200"
                    },
                    {
                        "username": "biller897",
                        "content": "i\\'ll tell you the most basic thing to understand before doing any \"Buy and Sell Stock\" problem :-\\n\\nTake ex :- [1,4,7,8,6,4]\\nif you take (1, 8) , diff = 7\\nor if you take (1, 4), (4, 7), (7, 8), diff = 3 + 3 + 1 = 7\\n\\nGoing directly to 8, or going to 8 by adding all differences in between is same in result, so rather than thinking to jump, think it in this way.\\n"
                    },
                    {
                        "username": "Novarg",
                        "content": "Imagine you were a stock trader and you know the future prices for a given stock (This is the problem input). Each day you would buy the stock if you knew you could sell it tomorrow for a profit (This is the greedy solution)."
                    }
                ]
            },
            {
                "id": 1567200,
                "content": [
                    {
                        "username": "hanseaston",
                        "content": "We want to buy all the stocks when the line is going up. And want to ignore all the lines when the line is going down.\\n\\nDo a for loop through the array and only count in the green line that is going up, by comparing the two adjacent elements in the array.\\n\\nMany solutions are already posted here. But I think a picture would make things clearer to see.\\n\\n![image](https://assets.leetcode.com/users/hans00/image_1586103419.png)\\n\\n"
                    },
                    {
                        "username": "shashi_singh_18",
                        "content": "I just read the 1st line and my code is accepted. Thanks!!!!!!!!!!!!!!!"
                    },
                    {
                        "username": "introvertCode",
                        "content": "Thank you!"
                    },
                    {
                        "username": "tanushjangid1234",
                        "content": "What a great intuation."
                    },
                    {
                        "username": "glaucusec",
                        "content": "Thanks man. This actually helped a lot"
                    },
                    {
                        "username": "meanup",
                        "content": "`Hint`\\nStill confuse, after seeing the above figure analyse the example 1 and example 2. And it will all make sense. \\nUpvoted! Thank you. "
                    },
                    {
                        "username": "shhung",
                        "content": "It\\'s really simplify the question"
                    },
                    {
                        "username": "mayank-01",
                        "content": "upvoted, thank you for keeping things simple\\uD83D\\uDC4D"
                    },
                    {
                        "username": "falgunitagadkar",
                        "content": "Thanks:)"
                    },
                    {
                        "username": "pranavrocksharma",
                        "content": "what is the meaning of this buying and selling on the same day, profit will be 0 right , so why they highligted in bold, if was selling and then buying on the same day then it would affect on the recurrence but this statement is just added for the sake.\\n\\nAm i wrong or it means something else , i solved assuming we cannot sell and then buy on the same day, we will buy on the next day ."
                    },
                    {
                        "username": "Shaik_Aman_Sayer",
                        "content": "[@Mee_eeM](/Mee_eeM) appreciated dude earned my respect "
                    },
                    {
                        "username": "falgunitagadkar",
                        "content": "[@Dipanshi_26](/Dipanshi_26) The pictorial representation in the above comment has an hint in itself and if you want you can check out my solution.It\\'s not DP solution neither uses Greedy."
                    },
                    {
                        "username": "Dipanshi_26",
                        "content": "I just wanted to ask if this problem can be solved without DP or greedy algorithm because I am new to DSA I have practiced array perfectly. \\nCan you please suggest any othe opproch (hint) without these two approch. "
                    },
                    {
                        "username": "Mee_eeM",
                        "content": "Since you are allow to hold at most one stock at a time it is best to sell it if a lower price comes around. For example on day 1 the price is 7 dollars and day 2 the price is 1 dollar. If you buy on day 1 and sell on 2 you lose money, and you can't buy on day 2 since you've bought on day 1. Allowing you to buy and sell on the same day free up your 1 stock so than you may buy on day 2. Hope this helps."
                    },
                    {
                        "username": "abhijeetkrsingh17",
                        "content": "It is pointless. Even if we think that you sold the stock at higher price and bought new stocks same day as there must be a more higher price than this dates price. then it won\\'t make any difference if you had sold the stocks the next higher day. the diff remains the same."
                    },
                    {
                        "username": "Jeetu_123",
                        "content": "[@godshiva](/godshiva) If u look it as a trader point of view then it is not pointless."
                    },
                    {
                        "username": "itsvishalcodes",
                        "content": "[@sivagowda](/sivagowda) What do you  mean different stock? We are only allowed to hold one stock at a time. So you can only buy on a certain day if you have no stock holdings."
                    },
                    {
                        "username": "sivagowda",
                        "content": "They mean you could sell a stock that you already bought and buy a stock on that day(you could perform buying and selling on the same day of different stocks)"
                    },
                    {
                        "username": "godshiva",
                        "content": "No you\\'re right. You are allowed to do it, but doing so is pointless"
                    },
                    {
                        "username": "Bulbasaur2000",
                        "content": "**Firstly, the second test case explaination might mislead you as it did to me. So, try to avoid that.**\\n\\nLogic: \\nIt is pretty clear that normal brute force approach will take two loops and complexity will become O(n^2). So our objective is to optimise it as far as possible. A **one-pass algorithm** could be used to achieve this optimisation.\\n\\nApproach: \\n1. Initialise a variable(like maxProfit or anything else) which will store the final profit as 0.\\n2. Under a single loop, check for the price which is greater than its previous price. That would be the time when we should sell the stock to earn maximum profit at that instance.\\n3. Add up the profit to the initial variable maxProfit.\\n4. Continue the loop untill it reaches end. Eventually on its way it will keep on checking the profit condition and add up it to your maxProfit.\\n5. Finally return maxProfit.\\n\\nThis approach will take just O(n) time, since only once the entire array is traversed.\\nTry to code it now. Happy Hunting!!! \\n\\n**Do upvote my solution if found useful. It would motivate me furthur and help others.**\\n\\n"
                    },
                    {
                        "username": "bhargav9427",
                        "content": "The most important aspect of any problem is how to arrive at a solution. What should be the thinking process behind it. Lets try to understand how can we reach upto the solution and most important how to convince ourselves that its optimal. Please watch the given solution for this problem as a prerequisite.\\n\\nThe first question after seeing the solution that comes to mind is why is it optimal. Why selecting the immediate peak is the optimal choice. Here is a mathematical understanding for that.\\n\\nConsider this input : [a, ......, b, ......., c....., d]. Where `...` refers to some input in between. a&c are valleys and b&d are peaks.\\n\\nPoints to understand. \\n1) If b&d both are peaks then there has to be some value in between them which is less than b. If not b could not have been a peak because the direct next peak immediate to a will be d.\\n2) If a&c are valleys then there has to be some value in between them which is greater than a. If not a could not have been a valley because the first valley will itself will be c.\\n3) Considering the first two points and assuming that not picking immediate next peak will lead to a better answer. Lets try to prove if we can do that.  \\n\\t\\nIf point 3 is true then we can say that \\n\\t d-a > (b-a) + (d-c)\\ni.e d > b+d-c               but as b-c > 0\\ni.e d > +ve + d            \\n\\nwhich is a false. So we can always say that picking up immediate next peak will always yeild a better result.\\n\\nHope this helps.\\n"
                    },
                    {
                        "username": "anurag_negi123",
                        "content": "nice mathematical proof bro loved it"
                    },
                    {
                        "username": "youssef",
                        "content": "Hello,\\n\\nI'd like to know why the greedy algorithm that takes pairwise profits if they are positive only?\\n\\nThanks"
                    },
                    {
                        "username": "dpeachpeach",
                        "content": "Hi youssef, I recall a greedy-stays-ahead proof similar to this q in one of my college courses but I forgot it so I'm going to try to lay out the logic as well as possible.\n\nLet there be two prices p_a and p_b in the array. where a < b\nLet us say that there is a distance of n => 1 between the two. (Multiple prices in between the two)\n\nThere are two possible cases for the values of p_a in relation to p_b. Either p_b > p_a, which means we would want to buy. or P_b < p_a, which means we wouldn't want to buy.\nLet's ignore the second case because it's trivial and focus on the first.\n\nOk! So we know that we want to buy p_1 so that we can sell at p_2, but there is a distance of n>= 1 between the two, so this leaves uncertainty.\n\nWell, we know for a fact that overall price change across this period in time is going to be p_2 - p_1 or dp\n\nWe also know that price changes are split by days, which means that there are 'positive days' and 'negative days'\n\nAs we stated earlier, p_b > p_a where the distance between the two is n >= 1. if the distance is 1 (they're right next to each other), in what case would you prefer to take a losing bet? :-)\n\nThis is kind of a clever trick (It's a very nonrigorous proof by induction) but here's also a shaky proof by contradiction to help visualize it.\n\nLet us assume that there is an optimal solution where we choose to take a pairwise loss between two prices as opposed to taking a pairwise gain whenever possible.\n\nThis would somehow imply that the pairwise loss allows us to gain more profit than if we had never taken it in the first place. However, due to the allowances of the challenge, we have perfect foresight of the markets. Whenever there is a 'loss' in price, and that price then goes up in the future, we can always profit by taking a profit between the price in the future and the previous price. (If there is a higher price at the end then it must have gotten to that price somehow in increments or totally between two days). By taking a pairwise loss, we are doing nothing but surrendering 'opportunity profit' that we could have made by just doing pairwise purchasing later.\n\nThat's all shaky, but it's been a few months since I've been in class. Good luck!"
                    },
                    {
                        "username": "rushzone",
                        "content": "Judging from my code that has been accepted by the system, I think the limitation of the question is you can only hold 1 stock at most for any time. Which has not been clarified in the question description.\\n\\nFor more complete question and answer to it, in fact case, the money in your account at the beginning is  determined. What you can do is to make maximum profit from this data. During the progress, you can use the profit you made to buy more stock next time."
                    },
                    {
                        "username": "arhankundu99",
                        "content": "I always feel like a noob while encountering these type of questions. I tried for an hour and all I could manage was brute force method optimised with dp. How do you guys come up with such ideas (Like plotting the points and doing summation of peaks(i)-valeys(i)) ?"
                    },
                    {
                        "username": "heyyyankit",
                        "content": "no need to dp or any thing, just iterate on  prices and if you have profit any day, you can sell.. \n............\ncode:-\n\n      int n=prices.size();\n        int ans=0;\n        for(int i=1; i<=n-1; ++i){\n            int diff=prices[i]-prices[i-1];\n            if(diff>0){ans+=diff;}\n        }\n        return ans;"
                    },
                    {
                        "username": "AdityaDipamanggala",
                        "content": "[@Dipanshi_26](/Dipanshi_26) I think the best approach is to realize sum of neighboring peak is >= global peak, so we dont need to do any brute force"
                    },
                    {
                        "username": "AdityaDipamanggala",
                        "content": "Hahah this also exactly what I\\'m facing, turns out I\\'m too over-complicated the logic behind it, once you realize that sum of neighboring peak is always higher than global peak it will be easy "
                    },
                    {
                        "username": "Dipanshi_26",
                        "content": "Can you please give me hint about the approch you mentioned about? I don\\'t know abhout DP still trying to solve thsi problem."
                    },
                    {
                        "username": "shad",
                        "content": "After reading the description I don't understand what a program is supposed to compute to be accepted.\\n\\nI understand the array of prices, but how do I know what the maximum profit is without  knowing how much I can invest initially?  What about selling short before buying any?\\n\\nI guess there aren't any transaction fees to consider, but I don't know why it says I have to sell before I buy - if I'm maximizing profit, aren't I buying as much as I can afford, then selling it all right before it goes down?"
                    },
                    {
                        "username": "Harshsharma12",
                        "content": "https://leetcode.com/problems/best-time-to-buy-and-sell-stock-ii/description/comments/1567200"
                    },
                    {
                        "username": "biller897",
                        "content": "i\\'ll tell you the most basic thing to understand before doing any \"Buy and Sell Stock\" problem :-\\n\\nTake ex :- [1,4,7,8,6,4]\\nif you take (1, 8) , diff = 7\\nor if you take (1, 4), (4, 7), (7, 8), diff = 3 + 3 + 1 = 7\\n\\nGoing directly to 8, or going to 8 by adding all differences in between is same in result, so rather than thinking to jump, think it in this way.\\n"
                    },
                    {
                        "username": "Novarg",
                        "content": "Imagine you were a stock trader and you know the future prices for a given stock (This is the problem input). Each day you would buy the stock if you knew you could sell it tomorrow for a profit (This is the greedy solution)."
                    }
                ]
            },
            {
                "id": 1956066,
                "content": [
                    {
                        "username": "hanseaston",
                        "content": "We want to buy all the stocks when the line is going up. And want to ignore all the lines when the line is going down.\\n\\nDo a for loop through the array and only count in the green line that is going up, by comparing the two adjacent elements in the array.\\n\\nMany solutions are already posted here. But I think a picture would make things clearer to see.\\n\\n![image](https://assets.leetcode.com/users/hans00/image_1586103419.png)\\n\\n"
                    },
                    {
                        "username": "shashi_singh_18",
                        "content": "I just read the 1st line and my code is accepted. Thanks!!!!!!!!!!!!!!!"
                    },
                    {
                        "username": "introvertCode",
                        "content": "Thank you!"
                    },
                    {
                        "username": "tanushjangid1234",
                        "content": "What a great intuation."
                    },
                    {
                        "username": "glaucusec",
                        "content": "Thanks man. This actually helped a lot"
                    },
                    {
                        "username": "meanup",
                        "content": "`Hint`\\nStill confuse, after seeing the above figure analyse the example 1 and example 2. And it will all make sense. \\nUpvoted! Thank you. "
                    },
                    {
                        "username": "shhung",
                        "content": "It\\'s really simplify the question"
                    },
                    {
                        "username": "mayank-01",
                        "content": "upvoted, thank you for keeping things simple\\uD83D\\uDC4D"
                    },
                    {
                        "username": "falgunitagadkar",
                        "content": "Thanks:)"
                    },
                    {
                        "username": "pranavrocksharma",
                        "content": "what is the meaning of this buying and selling on the same day, profit will be 0 right , so why they highligted in bold, if was selling and then buying on the same day then it would affect on the recurrence but this statement is just added for the sake.\\n\\nAm i wrong or it means something else , i solved assuming we cannot sell and then buy on the same day, we will buy on the next day ."
                    },
                    {
                        "username": "Shaik_Aman_Sayer",
                        "content": "[@Mee_eeM](/Mee_eeM) appreciated dude earned my respect "
                    },
                    {
                        "username": "falgunitagadkar",
                        "content": "[@Dipanshi_26](/Dipanshi_26) The pictorial representation in the above comment has an hint in itself and if you want you can check out my solution.It\\'s not DP solution neither uses Greedy."
                    },
                    {
                        "username": "Dipanshi_26",
                        "content": "I just wanted to ask if this problem can be solved without DP or greedy algorithm because I am new to DSA I have practiced array perfectly. \\nCan you please suggest any othe opproch (hint) without these two approch. "
                    },
                    {
                        "username": "Mee_eeM",
                        "content": "Since you are allow to hold at most one stock at a time it is best to sell it if a lower price comes around. For example on day 1 the price is 7 dollars and day 2 the price is 1 dollar. If you buy on day 1 and sell on 2 you lose money, and you can't buy on day 2 since you've bought on day 1. Allowing you to buy and sell on the same day free up your 1 stock so than you may buy on day 2. Hope this helps."
                    },
                    {
                        "username": "abhijeetkrsingh17",
                        "content": "It is pointless. Even if we think that you sold the stock at higher price and bought new stocks same day as there must be a more higher price than this dates price. then it won\\'t make any difference if you had sold the stocks the next higher day. the diff remains the same."
                    },
                    {
                        "username": "Jeetu_123",
                        "content": "[@godshiva](/godshiva) If u look it as a trader point of view then it is not pointless."
                    },
                    {
                        "username": "itsvishalcodes",
                        "content": "[@sivagowda](/sivagowda) What do you  mean different stock? We are only allowed to hold one stock at a time. So you can only buy on a certain day if you have no stock holdings."
                    },
                    {
                        "username": "sivagowda",
                        "content": "They mean you could sell a stock that you already bought and buy a stock on that day(you could perform buying and selling on the same day of different stocks)"
                    },
                    {
                        "username": "godshiva",
                        "content": "No you\\'re right. You are allowed to do it, but doing so is pointless"
                    },
                    {
                        "username": "Bulbasaur2000",
                        "content": "**Firstly, the second test case explaination might mislead you as it did to me. So, try to avoid that.**\\n\\nLogic: \\nIt is pretty clear that normal brute force approach will take two loops and complexity will become O(n^2). So our objective is to optimise it as far as possible. A **one-pass algorithm** could be used to achieve this optimisation.\\n\\nApproach: \\n1. Initialise a variable(like maxProfit or anything else) which will store the final profit as 0.\\n2. Under a single loop, check for the price which is greater than its previous price. That would be the time when we should sell the stock to earn maximum profit at that instance.\\n3. Add up the profit to the initial variable maxProfit.\\n4. Continue the loop untill it reaches end. Eventually on its way it will keep on checking the profit condition and add up it to your maxProfit.\\n5. Finally return maxProfit.\\n\\nThis approach will take just O(n) time, since only once the entire array is traversed.\\nTry to code it now. Happy Hunting!!! \\n\\n**Do upvote my solution if found useful. It would motivate me furthur and help others.**\\n\\n"
                    },
                    {
                        "username": "bhargav9427",
                        "content": "The most important aspect of any problem is how to arrive at a solution. What should be the thinking process behind it. Lets try to understand how can we reach upto the solution and most important how to convince ourselves that its optimal. Please watch the given solution for this problem as a prerequisite.\\n\\nThe first question after seeing the solution that comes to mind is why is it optimal. Why selecting the immediate peak is the optimal choice. Here is a mathematical understanding for that.\\n\\nConsider this input : [a, ......, b, ......., c....., d]. Where `...` refers to some input in between. a&c are valleys and b&d are peaks.\\n\\nPoints to understand. \\n1) If b&d both are peaks then there has to be some value in between them which is less than b. If not b could not have been a peak because the direct next peak immediate to a will be d.\\n2) If a&c are valleys then there has to be some value in between them which is greater than a. If not a could not have been a valley because the first valley will itself will be c.\\n3) Considering the first two points and assuming that not picking immediate next peak will lead to a better answer. Lets try to prove if we can do that.  \\n\\t\\nIf point 3 is true then we can say that \\n\\t d-a > (b-a) + (d-c)\\ni.e d > b+d-c               but as b-c > 0\\ni.e d > +ve + d            \\n\\nwhich is a false. So we can always say that picking up immediate next peak will always yeild a better result.\\n\\nHope this helps.\\n"
                    },
                    {
                        "username": "anurag_negi123",
                        "content": "nice mathematical proof bro loved it"
                    },
                    {
                        "username": "youssef",
                        "content": "Hello,\\n\\nI'd like to know why the greedy algorithm that takes pairwise profits if they are positive only?\\n\\nThanks"
                    },
                    {
                        "username": "dpeachpeach",
                        "content": "Hi youssef, I recall a greedy-stays-ahead proof similar to this q in one of my college courses but I forgot it so I'm going to try to lay out the logic as well as possible.\n\nLet there be two prices p_a and p_b in the array. where a < b\nLet us say that there is a distance of n => 1 between the two. (Multiple prices in between the two)\n\nThere are two possible cases for the values of p_a in relation to p_b. Either p_b > p_a, which means we would want to buy. or P_b < p_a, which means we wouldn't want to buy.\nLet's ignore the second case because it's trivial and focus on the first.\n\nOk! So we know that we want to buy p_1 so that we can sell at p_2, but there is a distance of n>= 1 between the two, so this leaves uncertainty.\n\nWell, we know for a fact that overall price change across this period in time is going to be p_2 - p_1 or dp\n\nWe also know that price changes are split by days, which means that there are 'positive days' and 'negative days'\n\nAs we stated earlier, p_b > p_a where the distance between the two is n >= 1. if the distance is 1 (they're right next to each other), in what case would you prefer to take a losing bet? :-)\n\nThis is kind of a clever trick (It's a very nonrigorous proof by induction) but here's also a shaky proof by contradiction to help visualize it.\n\nLet us assume that there is an optimal solution where we choose to take a pairwise loss between two prices as opposed to taking a pairwise gain whenever possible.\n\nThis would somehow imply that the pairwise loss allows us to gain more profit than if we had never taken it in the first place. However, due to the allowances of the challenge, we have perfect foresight of the markets. Whenever there is a 'loss' in price, and that price then goes up in the future, we can always profit by taking a profit between the price in the future and the previous price. (If there is a higher price at the end then it must have gotten to that price somehow in increments or totally between two days). By taking a pairwise loss, we are doing nothing but surrendering 'opportunity profit' that we could have made by just doing pairwise purchasing later.\n\nThat's all shaky, but it's been a few months since I've been in class. Good luck!"
                    },
                    {
                        "username": "rushzone",
                        "content": "Judging from my code that has been accepted by the system, I think the limitation of the question is you can only hold 1 stock at most for any time. Which has not been clarified in the question description.\\n\\nFor more complete question and answer to it, in fact case, the money in your account at the beginning is  determined. What you can do is to make maximum profit from this data. During the progress, you can use the profit you made to buy more stock next time."
                    },
                    {
                        "username": "arhankundu99",
                        "content": "I always feel like a noob while encountering these type of questions. I tried for an hour and all I could manage was brute force method optimised with dp. How do you guys come up with such ideas (Like plotting the points and doing summation of peaks(i)-valeys(i)) ?"
                    },
                    {
                        "username": "heyyyankit",
                        "content": "no need to dp or any thing, just iterate on  prices and if you have profit any day, you can sell.. \n............\ncode:-\n\n      int n=prices.size();\n        int ans=0;\n        for(int i=1; i<=n-1; ++i){\n            int diff=prices[i]-prices[i-1];\n            if(diff>0){ans+=diff;}\n        }\n        return ans;"
                    },
                    {
                        "username": "AdityaDipamanggala",
                        "content": "[@Dipanshi_26](/Dipanshi_26) I think the best approach is to realize sum of neighboring peak is >= global peak, so we dont need to do any brute force"
                    },
                    {
                        "username": "AdityaDipamanggala",
                        "content": "Hahah this also exactly what I\\'m facing, turns out I\\'m too over-complicated the logic behind it, once you realize that sum of neighboring peak is always higher than global peak it will be easy "
                    },
                    {
                        "username": "Dipanshi_26",
                        "content": "Can you please give me hint about the approch you mentioned about? I don\\'t know abhout DP still trying to solve thsi problem."
                    },
                    {
                        "username": "shad",
                        "content": "After reading the description I don't understand what a program is supposed to compute to be accepted.\\n\\nI understand the array of prices, but how do I know what the maximum profit is without  knowing how much I can invest initially?  What about selling short before buying any?\\n\\nI guess there aren't any transaction fees to consider, but I don't know why it says I have to sell before I buy - if I'm maximizing profit, aren't I buying as much as I can afford, then selling it all right before it goes down?"
                    },
                    {
                        "username": "Harshsharma12",
                        "content": "https://leetcode.com/problems/best-time-to-buy-and-sell-stock-ii/description/comments/1567200"
                    },
                    {
                        "username": "biller897",
                        "content": "i\\'ll tell you the most basic thing to understand before doing any \"Buy and Sell Stock\" problem :-\\n\\nTake ex :- [1,4,7,8,6,4]\\nif you take (1, 8) , diff = 7\\nor if you take (1, 4), (4, 7), (7, 8), diff = 3 + 3 + 1 = 7\\n\\nGoing directly to 8, or going to 8 by adding all differences in between is same in result, so rather than thinking to jump, think it in this way.\\n"
                    },
                    {
                        "username": "Novarg",
                        "content": "Imagine you were a stock trader and you know the future prices for a given stock (This is the problem input). Each day you would buy the stock if you knew you could sell it tomorrow for a profit (This is the greedy solution)."
                    }
                ]
            },
            {
                "id": 1568307,
                "content": [
                    {
                        "username": "hanseaston",
                        "content": "We want to buy all the stocks when the line is going up. And want to ignore all the lines when the line is going down.\\n\\nDo a for loop through the array and only count in the green line that is going up, by comparing the two adjacent elements in the array.\\n\\nMany solutions are already posted here. But I think a picture would make things clearer to see.\\n\\n![image](https://assets.leetcode.com/users/hans00/image_1586103419.png)\\n\\n"
                    },
                    {
                        "username": "shashi_singh_18",
                        "content": "I just read the 1st line and my code is accepted. Thanks!!!!!!!!!!!!!!!"
                    },
                    {
                        "username": "introvertCode",
                        "content": "Thank you!"
                    },
                    {
                        "username": "tanushjangid1234",
                        "content": "What a great intuation."
                    },
                    {
                        "username": "glaucusec",
                        "content": "Thanks man. This actually helped a lot"
                    },
                    {
                        "username": "meanup",
                        "content": "`Hint`\\nStill confuse, after seeing the above figure analyse the example 1 and example 2. And it will all make sense. \\nUpvoted! Thank you. "
                    },
                    {
                        "username": "shhung",
                        "content": "It\\'s really simplify the question"
                    },
                    {
                        "username": "mayank-01",
                        "content": "upvoted, thank you for keeping things simple\\uD83D\\uDC4D"
                    },
                    {
                        "username": "falgunitagadkar",
                        "content": "Thanks:)"
                    },
                    {
                        "username": "pranavrocksharma",
                        "content": "what is the meaning of this buying and selling on the same day, profit will be 0 right , so why they highligted in bold, if was selling and then buying on the same day then it would affect on the recurrence but this statement is just added for the sake.\\n\\nAm i wrong or it means something else , i solved assuming we cannot sell and then buy on the same day, we will buy on the next day ."
                    },
                    {
                        "username": "Shaik_Aman_Sayer",
                        "content": "[@Mee_eeM](/Mee_eeM) appreciated dude earned my respect "
                    },
                    {
                        "username": "falgunitagadkar",
                        "content": "[@Dipanshi_26](/Dipanshi_26) The pictorial representation in the above comment has an hint in itself and if you want you can check out my solution.It\\'s not DP solution neither uses Greedy."
                    },
                    {
                        "username": "Dipanshi_26",
                        "content": "I just wanted to ask if this problem can be solved without DP or greedy algorithm because I am new to DSA I have practiced array perfectly. \\nCan you please suggest any othe opproch (hint) without these two approch. "
                    },
                    {
                        "username": "Mee_eeM",
                        "content": "Since you are allow to hold at most one stock at a time it is best to sell it if a lower price comes around. For example on day 1 the price is 7 dollars and day 2 the price is 1 dollar. If you buy on day 1 and sell on 2 you lose money, and you can't buy on day 2 since you've bought on day 1. Allowing you to buy and sell on the same day free up your 1 stock so than you may buy on day 2. Hope this helps."
                    },
                    {
                        "username": "abhijeetkrsingh17",
                        "content": "It is pointless. Even if we think that you sold the stock at higher price and bought new stocks same day as there must be a more higher price than this dates price. then it won\\'t make any difference if you had sold the stocks the next higher day. the diff remains the same."
                    },
                    {
                        "username": "Jeetu_123",
                        "content": "[@godshiva](/godshiva) If u look it as a trader point of view then it is not pointless."
                    },
                    {
                        "username": "itsvishalcodes",
                        "content": "[@sivagowda](/sivagowda) What do you  mean different stock? We are only allowed to hold one stock at a time. So you can only buy on a certain day if you have no stock holdings."
                    },
                    {
                        "username": "sivagowda",
                        "content": "They mean you could sell a stock that you already bought and buy a stock on that day(you could perform buying and selling on the same day of different stocks)"
                    },
                    {
                        "username": "godshiva",
                        "content": "No you\\'re right. You are allowed to do it, but doing so is pointless"
                    },
                    {
                        "username": "Bulbasaur2000",
                        "content": "**Firstly, the second test case explaination might mislead you as it did to me. So, try to avoid that.**\\n\\nLogic: \\nIt is pretty clear that normal brute force approach will take two loops and complexity will become O(n^2). So our objective is to optimise it as far as possible. A **one-pass algorithm** could be used to achieve this optimisation.\\n\\nApproach: \\n1. Initialise a variable(like maxProfit or anything else) which will store the final profit as 0.\\n2. Under a single loop, check for the price which is greater than its previous price. That would be the time when we should sell the stock to earn maximum profit at that instance.\\n3. Add up the profit to the initial variable maxProfit.\\n4. Continue the loop untill it reaches end. Eventually on its way it will keep on checking the profit condition and add up it to your maxProfit.\\n5. Finally return maxProfit.\\n\\nThis approach will take just O(n) time, since only once the entire array is traversed.\\nTry to code it now. Happy Hunting!!! \\n\\n**Do upvote my solution if found useful. It would motivate me furthur and help others.**\\n\\n"
                    },
                    {
                        "username": "bhargav9427",
                        "content": "The most important aspect of any problem is how to arrive at a solution. What should be the thinking process behind it. Lets try to understand how can we reach upto the solution and most important how to convince ourselves that its optimal. Please watch the given solution for this problem as a prerequisite.\\n\\nThe first question after seeing the solution that comes to mind is why is it optimal. Why selecting the immediate peak is the optimal choice. Here is a mathematical understanding for that.\\n\\nConsider this input : [a, ......, b, ......., c....., d]. Where `...` refers to some input in between. a&c are valleys and b&d are peaks.\\n\\nPoints to understand. \\n1) If b&d both are peaks then there has to be some value in between them which is less than b. If not b could not have been a peak because the direct next peak immediate to a will be d.\\n2) If a&c are valleys then there has to be some value in between them which is greater than a. If not a could not have been a valley because the first valley will itself will be c.\\n3) Considering the first two points and assuming that not picking immediate next peak will lead to a better answer. Lets try to prove if we can do that.  \\n\\t\\nIf point 3 is true then we can say that \\n\\t d-a > (b-a) + (d-c)\\ni.e d > b+d-c               but as b-c > 0\\ni.e d > +ve + d            \\n\\nwhich is a false. So we can always say that picking up immediate next peak will always yeild a better result.\\n\\nHope this helps.\\n"
                    },
                    {
                        "username": "anurag_negi123",
                        "content": "nice mathematical proof bro loved it"
                    },
                    {
                        "username": "youssef",
                        "content": "Hello,\\n\\nI'd like to know why the greedy algorithm that takes pairwise profits if they are positive only?\\n\\nThanks"
                    },
                    {
                        "username": "dpeachpeach",
                        "content": "Hi youssef, I recall a greedy-stays-ahead proof similar to this q in one of my college courses but I forgot it so I'm going to try to lay out the logic as well as possible.\n\nLet there be two prices p_a and p_b in the array. where a < b\nLet us say that there is a distance of n => 1 between the two. (Multiple prices in between the two)\n\nThere are two possible cases for the values of p_a in relation to p_b. Either p_b > p_a, which means we would want to buy. or P_b < p_a, which means we wouldn't want to buy.\nLet's ignore the second case because it's trivial and focus on the first.\n\nOk! So we know that we want to buy p_1 so that we can sell at p_2, but there is a distance of n>= 1 between the two, so this leaves uncertainty.\n\nWell, we know for a fact that overall price change across this period in time is going to be p_2 - p_1 or dp\n\nWe also know that price changes are split by days, which means that there are 'positive days' and 'negative days'\n\nAs we stated earlier, p_b > p_a where the distance between the two is n >= 1. if the distance is 1 (they're right next to each other), in what case would you prefer to take a losing bet? :-)\n\nThis is kind of a clever trick (It's a very nonrigorous proof by induction) but here's also a shaky proof by contradiction to help visualize it.\n\nLet us assume that there is an optimal solution where we choose to take a pairwise loss between two prices as opposed to taking a pairwise gain whenever possible.\n\nThis would somehow imply that the pairwise loss allows us to gain more profit than if we had never taken it in the first place. However, due to the allowances of the challenge, we have perfect foresight of the markets. Whenever there is a 'loss' in price, and that price then goes up in the future, we can always profit by taking a profit between the price in the future and the previous price. (If there is a higher price at the end then it must have gotten to that price somehow in increments or totally between two days). By taking a pairwise loss, we are doing nothing but surrendering 'opportunity profit' that we could have made by just doing pairwise purchasing later.\n\nThat's all shaky, but it's been a few months since I've been in class. Good luck!"
                    },
                    {
                        "username": "rushzone",
                        "content": "Judging from my code that has been accepted by the system, I think the limitation of the question is you can only hold 1 stock at most for any time. Which has not been clarified in the question description.\\n\\nFor more complete question and answer to it, in fact case, the money in your account at the beginning is  determined. What you can do is to make maximum profit from this data. During the progress, you can use the profit you made to buy more stock next time."
                    },
                    {
                        "username": "arhankundu99",
                        "content": "I always feel like a noob while encountering these type of questions. I tried for an hour and all I could manage was brute force method optimised with dp. How do you guys come up with such ideas (Like plotting the points and doing summation of peaks(i)-valeys(i)) ?"
                    },
                    {
                        "username": "heyyyankit",
                        "content": "no need to dp or any thing, just iterate on  prices and if you have profit any day, you can sell.. \n............\ncode:-\n\n      int n=prices.size();\n        int ans=0;\n        for(int i=1; i<=n-1; ++i){\n            int diff=prices[i]-prices[i-1];\n            if(diff>0){ans+=diff;}\n        }\n        return ans;"
                    },
                    {
                        "username": "AdityaDipamanggala",
                        "content": "[@Dipanshi_26](/Dipanshi_26) I think the best approach is to realize sum of neighboring peak is >= global peak, so we dont need to do any brute force"
                    },
                    {
                        "username": "AdityaDipamanggala",
                        "content": "Hahah this also exactly what I\\'m facing, turns out I\\'m too over-complicated the logic behind it, once you realize that sum of neighboring peak is always higher than global peak it will be easy "
                    },
                    {
                        "username": "Dipanshi_26",
                        "content": "Can you please give me hint about the approch you mentioned about? I don\\'t know abhout DP still trying to solve thsi problem."
                    },
                    {
                        "username": "shad",
                        "content": "After reading the description I don't understand what a program is supposed to compute to be accepted.\\n\\nI understand the array of prices, but how do I know what the maximum profit is without  knowing how much I can invest initially?  What about selling short before buying any?\\n\\nI guess there aren't any transaction fees to consider, but I don't know why it says I have to sell before I buy - if I'm maximizing profit, aren't I buying as much as I can afford, then selling it all right before it goes down?"
                    },
                    {
                        "username": "Harshsharma12",
                        "content": "https://leetcode.com/problems/best-time-to-buy-and-sell-stock-ii/description/comments/1567200"
                    },
                    {
                        "username": "biller897",
                        "content": "i\\'ll tell you the most basic thing to understand before doing any \"Buy and Sell Stock\" problem :-\\n\\nTake ex :- [1,4,7,8,6,4]\\nif you take (1, 8) , diff = 7\\nor if you take (1, 4), (4, 7), (7, 8), diff = 3 + 3 + 1 = 7\\n\\nGoing directly to 8, or going to 8 by adding all differences in between is same in result, so rather than thinking to jump, think it in this way.\\n"
                    },
                    {
                        "username": "Novarg",
                        "content": "Imagine you were a stock trader and you know the future prices for a given stock (This is the problem input). Each day you would buy the stock if you knew you could sell it tomorrow for a profit (This is the greedy solution)."
                    }
                ]
            },
            {
                "id": 1566137,
                "content": [
                    {
                        "username": "hanseaston",
                        "content": "We want to buy all the stocks when the line is going up. And want to ignore all the lines when the line is going down.\\n\\nDo a for loop through the array and only count in the green line that is going up, by comparing the two adjacent elements in the array.\\n\\nMany solutions are already posted here. But I think a picture would make things clearer to see.\\n\\n![image](https://assets.leetcode.com/users/hans00/image_1586103419.png)\\n\\n"
                    },
                    {
                        "username": "shashi_singh_18",
                        "content": "I just read the 1st line and my code is accepted. Thanks!!!!!!!!!!!!!!!"
                    },
                    {
                        "username": "introvertCode",
                        "content": "Thank you!"
                    },
                    {
                        "username": "tanushjangid1234",
                        "content": "What a great intuation."
                    },
                    {
                        "username": "glaucusec",
                        "content": "Thanks man. This actually helped a lot"
                    },
                    {
                        "username": "meanup",
                        "content": "`Hint`\\nStill confuse, after seeing the above figure analyse the example 1 and example 2. And it will all make sense. \\nUpvoted! Thank you. "
                    },
                    {
                        "username": "shhung",
                        "content": "It\\'s really simplify the question"
                    },
                    {
                        "username": "mayank-01",
                        "content": "upvoted, thank you for keeping things simple\\uD83D\\uDC4D"
                    },
                    {
                        "username": "falgunitagadkar",
                        "content": "Thanks:)"
                    },
                    {
                        "username": "pranavrocksharma",
                        "content": "what is the meaning of this buying and selling on the same day, profit will be 0 right , so why they highligted in bold, if was selling and then buying on the same day then it would affect on the recurrence but this statement is just added for the sake.\\n\\nAm i wrong or it means something else , i solved assuming we cannot sell and then buy on the same day, we will buy on the next day ."
                    },
                    {
                        "username": "Shaik_Aman_Sayer",
                        "content": "[@Mee_eeM](/Mee_eeM) appreciated dude earned my respect "
                    },
                    {
                        "username": "falgunitagadkar",
                        "content": "[@Dipanshi_26](/Dipanshi_26) The pictorial representation in the above comment has an hint in itself and if you want you can check out my solution.It\\'s not DP solution neither uses Greedy."
                    },
                    {
                        "username": "Dipanshi_26",
                        "content": "I just wanted to ask if this problem can be solved without DP or greedy algorithm because I am new to DSA I have practiced array perfectly. \\nCan you please suggest any othe opproch (hint) without these two approch. "
                    },
                    {
                        "username": "Mee_eeM",
                        "content": "Since you are allow to hold at most one stock at a time it is best to sell it if a lower price comes around. For example on day 1 the price is 7 dollars and day 2 the price is 1 dollar. If you buy on day 1 and sell on 2 you lose money, and you can't buy on day 2 since you've bought on day 1. Allowing you to buy and sell on the same day free up your 1 stock so than you may buy on day 2. Hope this helps."
                    },
                    {
                        "username": "abhijeetkrsingh17",
                        "content": "It is pointless. Even if we think that you sold the stock at higher price and bought new stocks same day as there must be a more higher price than this dates price. then it won\\'t make any difference if you had sold the stocks the next higher day. the diff remains the same."
                    },
                    {
                        "username": "Jeetu_123",
                        "content": "[@godshiva](/godshiva) If u look it as a trader point of view then it is not pointless."
                    },
                    {
                        "username": "itsvishalcodes",
                        "content": "[@sivagowda](/sivagowda) What do you  mean different stock? We are only allowed to hold one stock at a time. So you can only buy on a certain day if you have no stock holdings."
                    },
                    {
                        "username": "sivagowda",
                        "content": "They mean you could sell a stock that you already bought and buy a stock on that day(you could perform buying and selling on the same day of different stocks)"
                    },
                    {
                        "username": "godshiva",
                        "content": "No you\\'re right. You are allowed to do it, but doing so is pointless"
                    },
                    {
                        "username": "Bulbasaur2000",
                        "content": "**Firstly, the second test case explaination might mislead you as it did to me. So, try to avoid that.**\\n\\nLogic: \\nIt is pretty clear that normal brute force approach will take two loops and complexity will become O(n^2). So our objective is to optimise it as far as possible. A **one-pass algorithm** could be used to achieve this optimisation.\\n\\nApproach: \\n1. Initialise a variable(like maxProfit or anything else) which will store the final profit as 0.\\n2. Under a single loop, check for the price which is greater than its previous price. That would be the time when we should sell the stock to earn maximum profit at that instance.\\n3. Add up the profit to the initial variable maxProfit.\\n4. Continue the loop untill it reaches end. Eventually on its way it will keep on checking the profit condition and add up it to your maxProfit.\\n5. Finally return maxProfit.\\n\\nThis approach will take just O(n) time, since only once the entire array is traversed.\\nTry to code it now. Happy Hunting!!! \\n\\n**Do upvote my solution if found useful. It would motivate me furthur and help others.**\\n\\n"
                    },
                    {
                        "username": "bhargav9427",
                        "content": "The most important aspect of any problem is how to arrive at a solution. What should be the thinking process behind it. Lets try to understand how can we reach upto the solution and most important how to convince ourselves that its optimal. Please watch the given solution for this problem as a prerequisite.\\n\\nThe first question after seeing the solution that comes to mind is why is it optimal. Why selecting the immediate peak is the optimal choice. Here is a mathematical understanding for that.\\n\\nConsider this input : [a, ......, b, ......., c....., d]. Where `...` refers to some input in between. a&c are valleys and b&d are peaks.\\n\\nPoints to understand. \\n1) If b&d both are peaks then there has to be some value in between them which is less than b. If not b could not have been a peak because the direct next peak immediate to a will be d.\\n2) If a&c are valleys then there has to be some value in between them which is greater than a. If not a could not have been a valley because the first valley will itself will be c.\\n3) Considering the first two points and assuming that not picking immediate next peak will lead to a better answer. Lets try to prove if we can do that.  \\n\\t\\nIf point 3 is true then we can say that \\n\\t d-a > (b-a) + (d-c)\\ni.e d > b+d-c               but as b-c > 0\\ni.e d > +ve + d            \\n\\nwhich is a false. So we can always say that picking up immediate next peak will always yeild a better result.\\n\\nHope this helps.\\n"
                    },
                    {
                        "username": "anurag_negi123",
                        "content": "nice mathematical proof bro loved it"
                    },
                    {
                        "username": "youssef",
                        "content": "Hello,\\n\\nI'd like to know why the greedy algorithm that takes pairwise profits if they are positive only?\\n\\nThanks"
                    },
                    {
                        "username": "dpeachpeach",
                        "content": "Hi youssef, I recall a greedy-stays-ahead proof similar to this q in one of my college courses but I forgot it so I'm going to try to lay out the logic as well as possible.\n\nLet there be two prices p_a and p_b in the array. where a < b\nLet us say that there is a distance of n => 1 between the two. (Multiple prices in between the two)\n\nThere are two possible cases for the values of p_a in relation to p_b. Either p_b > p_a, which means we would want to buy. or P_b < p_a, which means we wouldn't want to buy.\nLet's ignore the second case because it's trivial and focus on the first.\n\nOk! So we know that we want to buy p_1 so that we can sell at p_2, but there is a distance of n>= 1 between the two, so this leaves uncertainty.\n\nWell, we know for a fact that overall price change across this period in time is going to be p_2 - p_1 or dp\n\nWe also know that price changes are split by days, which means that there are 'positive days' and 'negative days'\n\nAs we stated earlier, p_b > p_a where the distance between the two is n >= 1. if the distance is 1 (they're right next to each other), in what case would you prefer to take a losing bet? :-)\n\nThis is kind of a clever trick (It's a very nonrigorous proof by induction) but here's also a shaky proof by contradiction to help visualize it.\n\nLet us assume that there is an optimal solution where we choose to take a pairwise loss between two prices as opposed to taking a pairwise gain whenever possible.\n\nThis would somehow imply that the pairwise loss allows us to gain more profit than if we had never taken it in the first place. However, due to the allowances of the challenge, we have perfect foresight of the markets. Whenever there is a 'loss' in price, and that price then goes up in the future, we can always profit by taking a profit between the price in the future and the previous price. (If there is a higher price at the end then it must have gotten to that price somehow in increments or totally between two days). By taking a pairwise loss, we are doing nothing but surrendering 'opportunity profit' that we could have made by just doing pairwise purchasing later.\n\nThat's all shaky, but it's been a few months since I've been in class. Good luck!"
                    },
                    {
                        "username": "rushzone",
                        "content": "Judging from my code that has been accepted by the system, I think the limitation of the question is you can only hold 1 stock at most for any time. Which has not been clarified in the question description.\\n\\nFor more complete question and answer to it, in fact case, the money in your account at the beginning is  determined. What you can do is to make maximum profit from this data. During the progress, you can use the profit you made to buy more stock next time."
                    },
                    {
                        "username": "arhankundu99",
                        "content": "I always feel like a noob while encountering these type of questions. I tried for an hour and all I could manage was brute force method optimised with dp. How do you guys come up with such ideas (Like plotting the points and doing summation of peaks(i)-valeys(i)) ?"
                    },
                    {
                        "username": "heyyyankit",
                        "content": "no need to dp or any thing, just iterate on  prices and if you have profit any day, you can sell.. \n............\ncode:-\n\n      int n=prices.size();\n        int ans=0;\n        for(int i=1; i<=n-1; ++i){\n            int diff=prices[i]-prices[i-1];\n            if(diff>0){ans+=diff;}\n        }\n        return ans;"
                    },
                    {
                        "username": "AdityaDipamanggala",
                        "content": "[@Dipanshi_26](/Dipanshi_26) I think the best approach is to realize sum of neighboring peak is >= global peak, so we dont need to do any brute force"
                    },
                    {
                        "username": "AdityaDipamanggala",
                        "content": "Hahah this also exactly what I\\'m facing, turns out I\\'m too over-complicated the logic behind it, once you realize that sum of neighboring peak is always higher than global peak it will be easy "
                    },
                    {
                        "username": "Dipanshi_26",
                        "content": "Can you please give me hint about the approch you mentioned about? I don\\'t know abhout DP still trying to solve thsi problem."
                    },
                    {
                        "username": "shad",
                        "content": "After reading the description I don't understand what a program is supposed to compute to be accepted.\\n\\nI understand the array of prices, but how do I know what the maximum profit is without  knowing how much I can invest initially?  What about selling short before buying any?\\n\\nI guess there aren't any transaction fees to consider, but I don't know why it says I have to sell before I buy - if I'm maximizing profit, aren't I buying as much as I can afford, then selling it all right before it goes down?"
                    },
                    {
                        "username": "Harshsharma12",
                        "content": "https://leetcode.com/problems/best-time-to-buy-and-sell-stock-ii/description/comments/1567200"
                    },
                    {
                        "username": "biller897",
                        "content": "i\\'ll tell you the most basic thing to understand before doing any \"Buy and Sell Stock\" problem :-\\n\\nTake ex :- [1,4,7,8,6,4]\\nif you take (1, 8) , diff = 7\\nor if you take (1, 4), (4, 7), (7, 8), diff = 3 + 3 + 1 = 7\\n\\nGoing directly to 8, or going to 8 by adding all differences in between is same in result, so rather than thinking to jump, think it in this way.\\n"
                    },
                    {
                        "username": "Novarg",
                        "content": "Imagine you were a stock trader and you know the future prices for a given stock (This is the problem input). Each day you would buy the stock if you knew you could sell it tomorrow for a profit (This is the greedy solution)."
                    }
                ]
            },
            {
                "id": 1576892,
                "content": [
                    {
                        "username": "hanseaston",
                        "content": "We want to buy all the stocks when the line is going up. And want to ignore all the lines when the line is going down.\\n\\nDo a for loop through the array and only count in the green line that is going up, by comparing the two adjacent elements in the array.\\n\\nMany solutions are already posted here. But I think a picture would make things clearer to see.\\n\\n![image](https://assets.leetcode.com/users/hans00/image_1586103419.png)\\n\\n"
                    },
                    {
                        "username": "shashi_singh_18",
                        "content": "I just read the 1st line and my code is accepted. Thanks!!!!!!!!!!!!!!!"
                    },
                    {
                        "username": "introvertCode",
                        "content": "Thank you!"
                    },
                    {
                        "username": "tanushjangid1234",
                        "content": "What a great intuation."
                    },
                    {
                        "username": "glaucusec",
                        "content": "Thanks man. This actually helped a lot"
                    },
                    {
                        "username": "meanup",
                        "content": "`Hint`\\nStill confuse, after seeing the above figure analyse the example 1 and example 2. And it will all make sense. \\nUpvoted! Thank you. "
                    },
                    {
                        "username": "shhung",
                        "content": "It\\'s really simplify the question"
                    },
                    {
                        "username": "mayank-01",
                        "content": "upvoted, thank you for keeping things simple\\uD83D\\uDC4D"
                    },
                    {
                        "username": "falgunitagadkar",
                        "content": "Thanks:)"
                    },
                    {
                        "username": "pranavrocksharma",
                        "content": "what is the meaning of this buying and selling on the same day, profit will be 0 right , so why they highligted in bold, if was selling and then buying on the same day then it would affect on the recurrence but this statement is just added for the sake.\\n\\nAm i wrong or it means something else , i solved assuming we cannot sell and then buy on the same day, we will buy on the next day ."
                    },
                    {
                        "username": "Shaik_Aman_Sayer",
                        "content": "[@Mee_eeM](/Mee_eeM) appreciated dude earned my respect "
                    },
                    {
                        "username": "falgunitagadkar",
                        "content": "[@Dipanshi_26](/Dipanshi_26) The pictorial representation in the above comment has an hint in itself and if you want you can check out my solution.It\\'s not DP solution neither uses Greedy."
                    },
                    {
                        "username": "Dipanshi_26",
                        "content": "I just wanted to ask if this problem can be solved without DP or greedy algorithm because I am new to DSA I have practiced array perfectly. \\nCan you please suggest any othe opproch (hint) without these two approch. "
                    },
                    {
                        "username": "Mee_eeM",
                        "content": "Since you are allow to hold at most one stock at a time it is best to sell it if a lower price comes around. For example on day 1 the price is 7 dollars and day 2 the price is 1 dollar. If you buy on day 1 and sell on 2 you lose money, and you can't buy on day 2 since you've bought on day 1. Allowing you to buy and sell on the same day free up your 1 stock so than you may buy on day 2. Hope this helps."
                    },
                    {
                        "username": "abhijeetkrsingh17",
                        "content": "It is pointless. Even if we think that you sold the stock at higher price and bought new stocks same day as there must be a more higher price than this dates price. then it won\\'t make any difference if you had sold the stocks the next higher day. the diff remains the same."
                    },
                    {
                        "username": "Jeetu_123",
                        "content": "[@godshiva](/godshiva) If u look it as a trader point of view then it is not pointless."
                    },
                    {
                        "username": "itsvishalcodes",
                        "content": "[@sivagowda](/sivagowda) What do you  mean different stock? We are only allowed to hold one stock at a time. So you can only buy on a certain day if you have no stock holdings."
                    },
                    {
                        "username": "sivagowda",
                        "content": "They mean you could sell a stock that you already bought and buy a stock on that day(you could perform buying and selling on the same day of different stocks)"
                    },
                    {
                        "username": "godshiva",
                        "content": "No you\\'re right. You are allowed to do it, but doing so is pointless"
                    },
                    {
                        "username": "Bulbasaur2000",
                        "content": "**Firstly, the second test case explaination might mislead you as it did to me. So, try to avoid that.**\\n\\nLogic: \\nIt is pretty clear that normal brute force approach will take two loops and complexity will become O(n^2). So our objective is to optimise it as far as possible. A **one-pass algorithm** could be used to achieve this optimisation.\\n\\nApproach: \\n1. Initialise a variable(like maxProfit or anything else) which will store the final profit as 0.\\n2. Under a single loop, check for the price which is greater than its previous price. That would be the time when we should sell the stock to earn maximum profit at that instance.\\n3. Add up the profit to the initial variable maxProfit.\\n4. Continue the loop untill it reaches end. Eventually on its way it will keep on checking the profit condition and add up it to your maxProfit.\\n5. Finally return maxProfit.\\n\\nThis approach will take just O(n) time, since only once the entire array is traversed.\\nTry to code it now. Happy Hunting!!! \\n\\n**Do upvote my solution if found useful. It would motivate me furthur and help others.**\\n\\n"
                    },
                    {
                        "username": "bhargav9427",
                        "content": "The most important aspect of any problem is how to arrive at a solution. What should be the thinking process behind it. Lets try to understand how can we reach upto the solution and most important how to convince ourselves that its optimal. Please watch the given solution for this problem as a prerequisite.\\n\\nThe first question after seeing the solution that comes to mind is why is it optimal. Why selecting the immediate peak is the optimal choice. Here is a mathematical understanding for that.\\n\\nConsider this input : [a, ......, b, ......., c....., d]. Where `...` refers to some input in between. a&c are valleys and b&d are peaks.\\n\\nPoints to understand. \\n1) If b&d both are peaks then there has to be some value in between them which is less than b. If not b could not have been a peak because the direct next peak immediate to a will be d.\\n2) If a&c are valleys then there has to be some value in between them which is greater than a. If not a could not have been a valley because the first valley will itself will be c.\\n3) Considering the first two points and assuming that not picking immediate next peak will lead to a better answer. Lets try to prove if we can do that.  \\n\\t\\nIf point 3 is true then we can say that \\n\\t d-a > (b-a) + (d-c)\\ni.e d > b+d-c               but as b-c > 0\\ni.e d > +ve + d            \\n\\nwhich is a false. So we can always say that picking up immediate next peak will always yeild a better result.\\n\\nHope this helps.\\n"
                    },
                    {
                        "username": "anurag_negi123",
                        "content": "nice mathematical proof bro loved it"
                    },
                    {
                        "username": "youssef",
                        "content": "Hello,\\n\\nI'd like to know why the greedy algorithm that takes pairwise profits if they are positive only?\\n\\nThanks"
                    },
                    {
                        "username": "dpeachpeach",
                        "content": "Hi youssef, I recall a greedy-stays-ahead proof similar to this q in one of my college courses but I forgot it so I'm going to try to lay out the logic as well as possible.\n\nLet there be two prices p_a and p_b in the array. where a < b\nLet us say that there is a distance of n => 1 between the two. (Multiple prices in between the two)\n\nThere are two possible cases for the values of p_a in relation to p_b. Either p_b > p_a, which means we would want to buy. or P_b < p_a, which means we wouldn't want to buy.\nLet's ignore the second case because it's trivial and focus on the first.\n\nOk! So we know that we want to buy p_1 so that we can sell at p_2, but there is a distance of n>= 1 between the two, so this leaves uncertainty.\n\nWell, we know for a fact that overall price change across this period in time is going to be p_2 - p_1 or dp\n\nWe also know that price changes are split by days, which means that there are 'positive days' and 'negative days'\n\nAs we stated earlier, p_b > p_a where the distance between the two is n >= 1. if the distance is 1 (they're right next to each other), in what case would you prefer to take a losing bet? :-)\n\nThis is kind of a clever trick (It's a very nonrigorous proof by induction) but here's also a shaky proof by contradiction to help visualize it.\n\nLet us assume that there is an optimal solution where we choose to take a pairwise loss between two prices as opposed to taking a pairwise gain whenever possible.\n\nThis would somehow imply that the pairwise loss allows us to gain more profit than if we had never taken it in the first place. However, due to the allowances of the challenge, we have perfect foresight of the markets. Whenever there is a 'loss' in price, and that price then goes up in the future, we can always profit by taking a profit between the price in the future and the previous price. (If there is a higher price at the end then it must have gotten to that price somehow in increments or totally between two days). By taking a pairwise loss, we are doing nothing but surrendering 'opportunity profit' that we could have made by just doing pairwise purchasing later.\n\nThat's all shaky, but it's been a few months since I've been in class. Good luck!"
                    },
                    {
                        "username": "rushzone",
                        "content": "Judging from my code that has been accepted by the system, I think the limitation of the question is you can only hold 1 stock at most for any time. Which has not been clarified in the question description.\\n\\nFor more complete question and answer to it, in fact case, the money in your account at the beginning is  determined. What you can do is to make maximum profit from this data. During the progress, you can use the profit you made to buy more stock next time."
                    },
                    {
                        "username": "arhankundu99",
                        "content": "I always feel like a noob while encountering these type of questions. I tried for an hour and all I could manage was brute force method optimised with dp. How do you guys come up with such ideas (Like plotting the points and doing summation of peaks(i)-valeys(i)) ?"
                    },
                    {
                        "username": "heyyyankit",
                        "content": "no need to dp or any thing, just iterate on  prices and if you have profit any day, you can sell.. \n............\ncode:-\n\n      int n=prices.size();\n        int ans=0;\n        for(int i=1; i<=n-1; ++i){\n            int diff=prices[i]-prices[i-1];\n            if(diff>0){ans+=diff;}\n        }\n        return ans;"
                    },
                    {
                        "username": "AdityaDipamanggala",
                        "content": "[@Dipanshi_26](/Dipanshi_26) I think the best approach is to realize sum of neighboring peak is >= global peak, so we dont need to do any brute force"
                    },
                    {
                        "username": "AdityaDipamanggala",
                        "content": "Hahah this also exactly what I\\'m facing, turns out I\\'m too over-complicated the logic behind it, once you realize that sum of neighboring peak is always higher than global peak it will be easy "
                    },
                    {
                        "username": "Dipanshi_26",
                        "content": "Can you please give me hint about the approch you mentioned about? I don\\'t know abhout DP still trying to solve thsi problem."
                    },
                    {
                        "username": "shad",
                        "content": "After reading the description I don't understand what a program is supposed to compute to be accepted.\\n\\nI understand the array of prices, but how do I know what the maximum profit is without  knowing how much I can invest initially?  What about selling short before buying any?\\n\\nI guess there aren't any transaction fees to consider, but I don't know why it says I have to sell before I buy - if I'm maximizing profit, aren't I buying as much as I can afford, then selling it all right before it goes down?"
                    },
                    {
                        "username": "Harshsharma12",
                        "content": "https://leetcode.com/problems/best-time-to-buy-and-sell-stock-ii/description/comments/1567200"
                    },
                    {
                        "username": "biller897",
                        "content": "i\\'ll tell you the most basic thing to understand before doing any \"Buy and Sell Stock\" problem :-\\n\\nTake ex :- [1,4,7,8,6,4]\\nif you take (1, 8) , diff = 7\\nor if you take (1, 4), (4, 7), (7, 8), diff = 3 + 3 + 1 = 7\\n\\nGoing directly to 8, or going to 8 by adding all differences in between is same in result, so rather than thinking to jump, think it in this way.\\n"
                    },
                    {
                        "username": "Novarg",
                        "content": "Imagine you were a stock trader and you know the future prices for a given stock (This is the problem input). Each day you would buy the stock if you knew you could sell it tomorrow for a profit (This is the greedy solution)."
                    }
                ]
            },
            {
                "id": 1575662,
                "content": [
                    {
                        "username": "hanseaston",
                        "content": "We want to buy all the stocks when the line is going up. And want to ignore all the lines when the line is going down.\\n\\nDo a for loop through the array and only count in the green line that is going up, by comparing the two adjacent elements in the array.\\n\\nMany solutions are already posted here. But I think a picture would make things clearer to see.\\n\\n![image](https://assets.leetcode.com/users/hans00/image_1586103419.png)\\n\\n"
                    },
                    {
                        "username": "shashi_singh_18",
                        "content": "I just read the 1st line and my code is accepted. Thanks!!!!!!!!!!!!!!!"
                    },
                    {
                        "username": "introvertCode",
                        "content": "Thank you!"
                    },
                    {
                        "username": "tanushjangid1234",
                        "content": "What a great intuation."
                    },
                    {
                        "username": "glaucusec",
                        "content": "Thanks man. This actually helped a lot"
                    },
                    {
                        "username": "meanup",
                        "content": "`Hint`\\nStill confuse, after seeing the above figure analyse the example 1 and example 2. And it will all make sense. \\nUpvoted! Thank you. "
                    },
                    {
                        "username": "shhung",
                        "content": "It\\'s really simplify the question"
                    },
                    {
                        "username": "mayank-01",
                        "content": "upvoted, thank you for keeping things simple\\uD83D\\uDC4D"
                    },
                    {
                        "username": "falgunitagadkar",
                        "content": "Thanks:)"
                    },
                    {
                        "username": "pranavrocksharma",
                        "content": "what is the meaning of this buying and selling on the same day, profit will be 0 right , so why they highligted in bold, if was selling and then buying on the same day then it would affect on the recurrence but this statement is just added for the sake.\\n\\nAm i wrong or it means something else , i solved assuming we cannot sell and then buy on the same day, we will buy on the next day ."
                    },
                    {
                        "username": "Shaik_Aman_Sayer",
                        "content": "[@Mee_eeM](/Mee_eeM) appreciated dude earned my respect "
                    },
                    {
                        "username": "falgunitagadkar",
                        "content": "[@Dipanshi_26](/Dipanshi_26) The pictorial representation in the above comment has an hint in itself and if you want you can check out my solution.It\\'s not DP solution neither uses Greedy."
                    },
                    {
                        "username": "Dipanshi_26",
                        "content": "I just wanted to ask if this problem can be solved without DP or greedy algorithm because I am new to DSA I have practiced array perfectly. \\nCan you please suggest any othe opproch (hint) without these two approch. "
                    },
                    {
                        "username": "Mee_eeM",
                        "content": "Since you are allow to hold at most one stock at a time it is best to sell it if a lower price comes around. For example on day 1 the price is 7 dollars and day 2 the price is 1 dollar. If you buy on day 1 and sell on 2 you lose money, and you can't buy on day 2 since you've bought on day 1. Allowing you to buy and sell on the same day free up your 1 stock so than you may buy on day 2. Hope this helps."
                    },
                    {
                        "username": "abhijeetkrsingh17",
                        "content": "It is pointless. Even if we think that you sold the stock at higher price and bought new stocks same day as there must be a more higher price than this dates price. then it won\\'t make any difference if you had sold the stocks the next higher day. the diff remains the same."
                    },
                    {
                        "username": "Jeetu_123",
                        "content": "[@godshiva](/godshiva) If u look it as a trader point of view then it is not pointless."
                    },
                    {
                        "username": "itsvishalcodes",
                        "content": "[@sivagowda](/sivagowda) What do you  mean different stock? We are only allowed to hold one stock at a time. So you can only buy on a certain day if you have no stock holdings."
                    },
                    {
                        "username": "sivagowda",
                        "content": "They mean you could sell a stock that you already bought and buy a stock on that day(you could perform buying and selling on the same day of different stocks)"
                    },
                    {
                        "username": "godshiva",
                        "content": "No you\\'re right. You are allowed to do it, but doing so is pointless"
                    },
                    {
                        "username": "Bulbasaur2000",
                        "content": "**Firstly, the second test case explaination might mislead you as it did to me. So, try to avoid that.**\\n\\nLogic: \\nIt is pretty clear that normal brute force approach will take two loops and complexity will become O(n^2). So our objective is to optimise it as far as possible. A **one-pass algorithm** could be used to achieve this optimisation.\\n\\nApproach: \\n1. Initialise a variable(like maxProfit or anything else) which will store the final profit as 0.\\n2. Under a single loop, check for the price which is greater than its previous price. That would be the time when we should sell the stock to earn maximum profit at that instance.\\n3. Add up the profit to the initial variable maxProfit.\\n4. Continue the loop untill it reaches end. Eventually on its way it will keep on checking the profit condition and add up it to your maxProfit.\\n5. Finally return maxProfit.\\n\\nThis approach will take just O(n) time, since only once the entire array is traversed.\\nTry to code it now. Happy Hunting!!! \\n\\n**Do upvote my solution if found useful. It would motivate me furthur and help others.**\\n\\n"
                    },
                    {
                        "username": "bhargav9427",
                        "content": "The most important aspect of any problem is how to arrive at a solution. What should be the thinking process behind it. Lets try to understand how can we reach upto the solution and most important how to convince ourselves that its optimal. Please watch the given solution for this problem as a prerequisite.\\n\\nThe first question after seeing the solution that comes to mind is why is it optimal. Why selecting the immediate peak is the optimal choice. Here is a mathematical understanding for that.\\n\\nConsider this input : [a, ......, b, ......., c....., d]. Where `...` refers to some input in between. a&c are valleys and b&d are peaks.\\n\\nPoints to understand. \\n1) If b&d both are peaks then there has to be some value in between them which is less than b. If not b could not have been a peak because the direct next peak immediate to a will be d.\\n2) If a&c are valleys then there has to be some value in between them which is greater than a. If not a could not have been a valley because the first valley will itself will be c.\\n3) Considering the first two points and assuming that not picking immediate next peak will lead to a better answer. Lets try to prove if we can do that.  \\n\\t\\nIf point 3 is true then we can say that \\n\\t d-a > (b-a) + (d-c)\\ni.e d > b+d-c               but as b-c > 0\\ni.e d > +ve + d            \\n\\nwhich is a false. So we can always say that picking up immediate next peak will always yeild a better result.\\n\\nHope this helps.\\n"
                    },
                    {
                        "username": "anurag_negi123",
                        "content": "nice mathematical proof bro loved it"
                    },
                    {
                        "username": "youssef",
                        "content": "Hello,\\n\\nI'd like to know why the greedy algorithm that takes pairwise profits if they are positive only?\\n\\nThanks"
                    },
                    {
                        "username": "dpeachpeach",
                        "content": "Hi youssef, I recall a greedy-stays-ahead proof similar to this q in one of my college courses but I forgot it so I'm going to try to lay out the logic as well as possible.\n\nLet there be two prices p_a and p_b in the array. where a < b\nLet us say that there is a distance of n => 1 between the two. (Multiple prices in between the two)\n\nThere are two possible cases for the values of p_a in relation to p_b. Either p_b > p_a, which means we would want to buy. or P_b < p_a, which means we wouldn't want to buy.\nLet's ignore the second case because it's trivial and focus on the first.\n\nOk! So we know that we want to buy p_1 so that we can sell at p_2, but there is a distance of n>= 1 between the two, so this leaves uncertainty.\n\nWell, we know for a fact that overall price change across this period in time is going to be p_2 - p_1 or dp\n\nWe also know that price changes are split by days, which means that there are 'positive days' and 'negative days'\n\nAs we stated earlier, p_b > p_a where the distance between the two is n >= 1. if the distance is 1 (they're right next to each other), in what case would you prefer to take a losing bet? :-)\n\nThis is kind of a clever trick (It's a very nonrigorous proof by induction) but here's also a shaky proof by contradiction to help visualize it.\n\nLet us assume that there is an optimal solution where we choose to take a pairwise loss between two prices as opposed to taking a pairwise gain whenever possible.\n\nThis would somehow imply that the pairwise loss allows us to gain more profit than if we had never taken it in the first place. However, due to the allowances of the challenge, we have perfect foresight of the markets. Whenever there is a 'loss' in price, and that price then goes up in the future, we can always profit by taking a profit between the price in the future and the previous price. (If there is a higher price at the end then it must have gotten to that price somehow in increments or totally between two days). By taking a pairwise loss, we are doing nothing but surrendering 'opportunity profit' that we could have made by just doing pairwise purchasing later.\n\nThat's all shaky, but it's been a few months since I've been in class. Good luck!"
                    },
                    {
                        "username": "rushzone",
                        "content": "Judging from my code that has been accepted by the system, I think the limitation of the question is you can only hold 1 stock at most for any time. Which has not been clarified in the question description.\\n\\nFor more complete question and answer to it, in fact case, the money in your account at the beginning is  determined. What you can do is to make maximum profit from this data. During the progress, you can use the profit you made to buy more stock next time."
                    },
                    {
                        "username": "arhankundu99",
                        "content": "I always feel like a noob while encountering these type of questions. I tried for an hour and all I could manage was brute force method optimised with dp. How do you guys come up with such ideas (Like plotting the points and doing summation of peaks(i)-valeys(i)) ?"
                    },
                    {
                        "username": "heyyyankit",
                        "content": "no need to dp or any thing, just iterate on  prices and if you have profit any day, you can sell.. \n............\ncode:-\n\n      int n=prices.size();\n        int ans=0;\n        for(int i=1; i<=n-1; ++i){\n            int diff=prices[i]-prices[i-1];\n            if(diff>0){ans+=diff;}\n        }\n        return ans;"
                    },
                    {
                        "username": "AdityaDipamanggala",
                        "content": "[@Dipanshi_26](/Dipanshi_26) I think the best approach is to realize sum of neighboring peak is >= global peak, so we dont need to do any brute force"
                    },
                    {
                        "username": "AdityaDipamanggala",
                        "content": "Hahah this also exactly what I\\'m facing, turns out I\\'m too over-complicated the logic behind it, once you realize that sum of neighboring peak is always higher than global peak it will be easy "
                    },
                    {
                        "username": "Dipanshi_26",
                        "content": "Can you please give me hint about the approch you mentioned about? I don\\'t know abhout DP still trying to solve thsi problem."
                    },
                    {
                        "username": "shad",
                        "content": "After reading the description I don't understand what a program is supposed to compute to be accepted.\\n\\nI understand the array of prices, but how do I know what the maximum profit is without  knowing how much I can invest initially?  What about selling short before buying any?\\n\\nI guess there aren't any transaction fees to consider, but I don't know why it says I have to sell before I buy - if I'm maximizing profit, aren't I buying as much as I can afford, then selling it all right before it goes down?"
                    },
                    {
                        "username": "Harshsharma12",
                        "content": "https://leetcode.com/problems/best-time-to-buy-and-sell-stock-ii/description/comments/1567200"
                    },
                    {
                        "username": "biller897",
                        "content": "i\\'ll tell you the most basic thing to understand before doing any \"Buy and Sell Stock\" problem :-\\n\\nTake ex :- [1,4,7,8,6,4]\\nif you take (1, 8) , diff = 7\\nor if you take (1, 4), (4, 7), (7, 8), diff = 3 + 3 + 1 = 7\\n\\nGoing directly to 8, or going to 8 by adding all differences in between is same in result, so rather than thinking to jump, think it in this way.\\n"
                    },
                    {
                        "username": "Novarg",
                        "content": "Imagine you were a stock trader and you know the future prices for a given stock (This is the problem input). Each day you would buy the stock if you knew you could sell it tomorrow for a profit (This is the greedy solution)."
                    }
                ]
            },
            {
                "id": 1570091,
                "content": [
                    {
                        "username": "hanseaston",
                        "content": "We want to buy all the stocks when the line is going up. And want to ignore all the lines when the line is going down.\\n\\nDo a for loop through the array and only count in the green line that is going up, by comparing the two adjacent elements in the array.\\n\\nMany solutions are already posted here. But I think a picture would make things clearer to see.\\n\\n![image](https://assets.leetcode.com/users/hans00/image_1586103419.png)\\n\\n"
                    },
                    {
                        "username": "shashi_singh_18",
                        "content": "I just read the 1st line and my code is accepted. Thanks!!!!!!!!!!!!!!!"
                    },
                    {
                        "username": "introvertCode",
                        "content": "Thank you!"
                    },
                    {
                        "username": "tanushjangid1234",
                        "content": "What a great intuation."
                    },
                    {
                        "username": "glaucusec",
                        "content": "Thanks man. This actually helped a lot"
                    },
                    {
                        "username": "meanup",
                        "content": "`Hint`\\nStill confuse, after seeing the above figure analyse the example 1 and example 2. And it will all make sense. \\nUpvoted! Thank you. "
                    },
                    {
                        "username": "shhung",
                        "content": "It\\'s really simplify the question"
                    },
                    {
                        "username": "mayank-01",
                        "content": "upvoted, thank you for keeping things simple\\uD83D\\uDC4D"
                    },
                    {
                        "username": "falgunitagadkar",
                        "content": "Thanks:)"
                    },
                    {
                        "username": "pranavrocksharma",
                        "content": "what is the meaning of this buying and selling on the same day, profit will be 0 right , so why they highligted in bold, if was selling and then buying on the same day then it would affect on the recurrence but this statement is just added for the sake.\\n\\nAm i wrong or it means something else , i solved assuming we cannot sell and then buy on the same day, we will buy on the next day ."
                    },
                    {
                        "username": "Shaik_Aman_Sayer",
                        "content": "[@Mee_eeM](/Mee_eeM) appreciated dude earned my respect "
                    },
                    {
                        "username": "falgunitagadkar",
                        "content": "[@Dipanshi_26](/Dipanshi_26) The pictorial representation in the above comment has an hint in itself and if you want you can check out my solution.It\\'s not DP solution neither uses Greedy."
                    },
                    {
                        "username": "Dipanshi_26",
                        "content": "I just wanted to ask if this problem can be solved without DP or greedy algorithm because I am new to DSA I have practiced array perfectly. \\nCan you please suggest any othe opproch (hint) without these two approch. "
                    },
                    {
                        "username": "Mee_eeM",
                        "content": "Since you are allow to hold at most one stock at a time it is best to sell it if a lower price comes around. For example on day 1 the price is 7 dollars and day 2 the price is 1 dollar. If you buy on day 1 and sell on 2 you lose money, and you can't buy on day 2 since you've bought on day 1. Allowing you to buy and sell on the same day free up your 1 stock so than you may buy on day 2. Hope this helps."
                    },
                    {
                        "username": "abhijeetkrsingh17",
                        "content": "It is pointless. Even if we think that you sold the stock at higher price and bought new stocks same day as there must be a more higher price than this dates price. then it won\\'t make any difference if you had sold the stocks the next higher day. the diff remains the same."
                    },
                    {
                        "username": "Jeetu_123",
                        "content": "[@godshiva](/godshiva) If u look it as a trader point of view then it is not pointless."
                    },
                    {
                        "username": "itsvishalcodes",
                        "content": "[@sivagowda](/sivagowda) What do you  mean different stock? We are only allowed to hold one stock at a time. So you can only buy on a certain day if you have no stock holdings."
                    },
                    {
                        "username": "sivagowda",
                        "content": "They mean you could sell a stock that you already bought and buy a stock on that day(you could perform buying and selling on the same day of different stocks)"
                    },
                    {
                        "username": "godshiva",
                        "content": "No you\\'re right. You are allowed to do it, but doing so is pointless"
                    },
                    {
                        "username": "Bulbasaur2000",
                        "content": "**Firstly, the second test case explaination might mislead you as it did to me. So, try to avoid that.**\\n\\nLogic: \\nIt is pretty clear that normal brute force approach will take two loops and complexity will become O(n^2). So our objective is to optimise it as far as possible. A **one-pass algorithm** could be used to achieve this optimisation.\\n\\nApproach: \\n1. Initialise a variable(like maxProfit or anything else) which will store the final profit as 0.\\n2. Under a single loop, check for the price which is greater than its previous price. That would be the time when we should sell the stock to earn maximum profit at that instance.\\n3. Add up the profit to the initial variable maxProfit.\\n4. Continue the loop untill it reaches end. Eventually on its way it will keep on checking the profit condition and add up it to your maxProfit.\\n5. Finally return maxProfit.\\n\\nThis approach will take just O(n) time, since only once the entire array is traversed.\\nTry to code it now. Happy Hunting!!! \\n\\n**Do upvote my solution if found useful. It would motivate me furthur and help others.**\\n\\n"
                    },
                    {
                        "username": "bhargav9427",
                        "content": "The most important aspect of any problem is how to arrive at a solution. What should be the thinking process behind it. Lets try to understand how can we reach upto the solution and most important how to convince ourselves that its optimal. Please watch the given solution for this problem as a prerequisite.\\n\\nThe first question after seeing the solution that comes to mind is why is it optimal. Why selecting the immediate peak is the optimal choice. Here is a mathematical understanding for that.\\n\\nConsider this input : [a, ......, b, ......., c....., d]. Where `...` refers to some input in between. a&c are valleys and b&d are peaks.\\n\\nPoints to understand. \\n1) If b&d both are peaks then there has to be some value in between them which is less than b. If not b could not have been a peak because the direct next peak immediate to a will be d.\\n2) If a&c are valleys then there has to be some value in between them which is greater than a. If not a could not have been a valley because the first valley will itself will be c.\\n3) Considering the first two points and assuming that not picking immediate next peak will lead to a better answer. Lets try to prove if we can do that.  \\n\\t\\nIf point 3 is true then we can say that \\n\\t d-a > (b-a) + (d-c)\\ni.e d > b+d-c               but as b-c > 0\\ni.e d > +ve + d            \\n\\nwhich is a false. So we can always say that picking up immediate next peak will always yeild a better result.\\n\\nHope this helps.\\n"
                    },
                    {
                        "username": "anurag_negi123",
                        "content": "nice mathematical proof bro loved it"
                    },
                    {
                        "username": "youssef",
                        "content": "Hello,\\n\\nI'd like to know why the greedy algorithm that takes pairwise profits if they are positive only?\\n\\nThanks"
                    },
                    {
                        "username": "dpeachpeach",
                        "content": "Hi youssef, I recall a greedy-stays-ahead proof similar to this q in one of my college courses but I forgot it so I'm going to try to lay out the logic as well as possible.\n\nLet there be two prices p_a and p_b in the array. where a < b\nLet us say that there is a distance of n => 1 between the two. (Multiple prices in between the two)\n\nThere are two possible cases for the values of p_a in relation to p_b. Either p_b > p_a, which means we would want to buy. or P_b < p_a, which means we wouldn't want to buy.\nLet's ignore the second case because it's trivial and focus on the first.\n\nOk! So we know that we want to buy p_1 so that we can sell at p_2, but there is a distance of n>= 1 between the two, so this leaves uncertainty.\n\nWell, we know for a fact that overall price change across this period in time is going to be p_2 - p_1 or dp\n\nWe also know that price changes are split by days, which means that there are 'positive days' and 'negative days'\n\nAs we stated earlier, p_b > p_a where the distance between the two is n >= 1. if the distance is 1 (they're right next to each other), in what case would you prefer to take a losing bet? :-)\n\nThis is kind of a clever trick (It's a very nonrigorous proof by induction) but here's also a shaky proof by contradiction to help visualize it.\n\nLet us assume that there is an optimal solution where we choose to take a pairwise loss between two prices as opposed to taking a pairwise gain whenever possible.\n\nThis would somehow imply that the pairwise loss allows us to gain more profit than if we had never taken it in the first place. However, due to the allowances of the challenge, we have perfect foresight of the markets. Whenever there is a 'loss' in price, and that price then goes up in the future, we can always profit by taking a profit between the price in the future and the previous price. (If there is a higher price at the end then it must have gotten to that price somehow in increments or totally between two days). By taking a pairwise loss, we are doing nothing but surrendering 'opportunity profit' that we could have made by just doing pairwise purchasing later.\n\nThat's all shaky, but it's been a few months since I've been in class. Good luck!"
                    },
                    {
                        "username": "rushzone",
                        "content": "Judging from my code that has been accepted by the system, I think the limitation of the question is you can only hold 1 stock at most for any time. Which has not been clarified in the question description.\\n\\nFor more complete question and answer to it, in fact case, the money in your account at the beginning is  determined. What you can do is to make maximum profit from this data. During the progress, you can use the profit you made to buy more stock next time."
                    },
                    {
                        "username": "arhankundu99",
                        "content": "I always feel like a noob while encountering these type of questions. I tried for an hour and all I could manage was brute force method optimised with dp. How do you guys come up with such ideas (Like plotting the points and doing summation of peaks(i)-valeys(i)) ?"
                    },
                    {
                        "username": "heyyyankit",
                        "content": "no need to dp or any thing, just iterate on  prices and if you have profit any day, you can sell.. \n............\ncode:-\n\n      int n=prices.size();\n        int ans=0;\n        for(int i=1; i<=n-1; ++i){\n            int diff=prices[i]-prices[i-1];\n            if(diff>0){ans+=diff;}\n        }\n        return ans;"
                    },
                    {
                        "username": "AdityaDipamanggala",
                        "content": "[@Dipanshi_26](/Dipanshi_26) I think the best approach is to realize sum of neighboring peak is >= global peak, so we dont need to do any brute force"
                    },
                    {
                        "username": "AdityaDipamanggala",
                        "content": "Hahah this also exactly what I\\'m facing, turns out I\\'m too over-complicated the logic behind it, once you realize that sum of neighboring peak is always higher than global peak it will be easy "
                    },
                    {
                        "username": "Dipanshi_26",
                        "content": "Can you please give me hint about the approch you mentioned about? I don\\'t know abhout DP still trying to solve thsi problem."
                    },
                    {
                        "username": "shad",
                        "content": "After reading the description I don't understand what a program is supposed to compute to be accepted.\\n\\nI understand the array of prices, but how do I know what the maximum profit is without  knowing how much I can invest initially?  What about selling short before buying any?\\n\\nI guess there aren't any transaction fees to consider, but I don't know why it says I have to sell before I buy - if I'm maximizing profit, aren't I buying as much as I can afford, then selling it all right before it goes down?"
                    },
                    {
                        "username": "Harshsharma12",
                        "content": "https://leetcode.com/problems/best-time-to-buy-and-sell-stock-ii/description/comments/1567200"
                    },
                    {
                        "username": "biller897",
                        "content": "i\\'ll tell you the most basic thing to understand before doing any \"Buy and Sell Stock\" problem :-\\n\\nTake ex :- [1,4,7,8,6,4]\\nif you take (1, 8) , diff = 7\\nor if you take (1, 4), (4, 7), (7, 8), diff = 3 + 3 + 1 = 7\\n\\nGoing directly to 8, or going to 8 by adding all differences in between is same in result, so rather than thinking to jump, think it in this way.\\n"
                    },
                    {
                        "username": "Novarg",
                        "content": "Imagine you were a stock trader and you know the future prices for a given stock (This is the problem input). Each day you would buy the stock if you knew you could sell it tomorrow for a profit (This is the greedy solution)."
                    }
                ]
            },
            {
                "id": 1565315,
                "content": [
                    {
                        "username": "hanseaston",
                        "content": "We want to buy all the stocks when the line is going up. And want to ignore all the lines when the line is going down.\\n\\nDo a for loop through the array and only count in the green line that is going up, by comparing the two adjacent elements in the array.\\n\\nMany solutions are already posted here. But I think a picture would make things clearer to see.\\n\\n![image](https://assets.leetcode.com/users/hans00/image_1586103419.png)\\n\\n"
                    },
                    {
                        "username": "shashi_singh_18",
                        "content": "I just read the 1st line and my code is accepted. Thanks!!!!!!!!!!!!!!!"
                    },
                    {
                        "username": "introvertCode",
                        "content": "Thank you!"
                    },
                    {
                        "username": "tanushjangid1234",
                        "content": "What a great intuation."
                    },
                    {
                        "username": "glaucusec",
                        "content": "Thanks man. This actually helped a lot"
                    },
                    {
                        "username": "meanup",
                        "content": "`Hint`\\nStill confuse, after seeing the above figure analyse the example 1 and example 2. And it will all make sense. \\nUpvoted! Thank you. "
                    },
                    {
                        "username": "shhung",
                        "content": "It\\'s really simplify the question"
                    },
                    {
                        "username": "mayank-01",
                        "content": "upvoted, thank you for keeping things simple\\uD83D\\uDC4D"
                    },
                    {
                        "username": "falgunitagadkar",
                        "content": "Thanks:)"
                    },
                    {
                        "username": "pranavrocksharma",
                        "content": "what is the meaning of this buying and selling on the same day, profit will be 0 right , so why they highligted in bold, if was selling and then buying on the same day then it would affect on the recurrence but this statement is just added for the sake.\\n\\nAm i wrong or it means something else , i solved assuming we cannot sell and then buy on the same day, we will buy on the next day ."
                    },
                    {
                        "username": "Shaik_Aman_Sayer",
                        "content": "[@Mee_eeM](/Mee_eeM) appreciated dude earned my respect "
                    },
                    {
                        "username": "falgunitagadkar",
                        "content": "[@Dipanshi_26](/Dipanshi_26) The pictorial representation in the above comment has an hint in itself and if you want you can check out my solution.It\\'s not DP solution neither uses Greedy."
                    },
                    {
                        "username": "Dipanshi_26",
                        "content": "I just wanted to ask if this problem can be solved without DP or greedy algorithm because I am new to DSA I have practiced array perfectly. \\nCan you please suggest any othe opproch (hint) without these two approch. "
                    },
                    {
                        "username": "Mee_eeM",
                        "content": "Since you are allow to hold at most one stock at a time it is best to sell it if a lower price comes around. For example on day 1 the price is 7 dollars and day 2 the price is 1 dollar. If you buy on day 1 and sell on 2 you lose money, and you can't buy on day 2 since you've bought on day 1. Allowing you to buy and sell on the same day free up your 1 stock so than you may buy on day 2. Hope this helps."
                    },
                    {
                        "username": "abhijeetkrsingh17",
                        "content": "It is pointless. Even if we think that you sold the stock at higher price and bought new stocks same day as there must be a more higher price than this dates price. then it won\\'t make any difference if you had sold the stocks the next higher day. the diff remains the same."
                    },
                    {
                        "username": "Jeetu_123",
                        "content": "[@godshiva](/godshiva) If u look it as a trader point of view then it is not pointless."
                    },
                    {
                        "username": "itsvishalcodes",
                        "content": "[@sivagowda](/sivagowda) What do you  mean different stock? We are only allowed to hold one stock at a time. So you can only buy on a certain day if you have no stock holdings."
                    },
                    {
                        "username": "sivagowda",
                        "content": "They mean you could sell a stock that you already bought and buy a stock on that day(you could perform buying and selling on the same day of different stocks)"
                    },
                    {
                        "username": "godshiva",
                        "content": "No you\\'re right. You are allowed to do it, but doing so is pointless"
                    },
                    {
                        "username": "Bulbasaur2000",
                        "content": "**Firstly, the second test case explaination might mislead you as it did to me. So, try to avoid that.**\\n\\nLogic: \\nIt is pretty clear that normal brute force approach will take two loops and complexity will become O(n^2). So our objective is to optimise it as far as possible. A **one-pass algorithm** could be used to achieve this optimisation.\\n\\nApproach: \\n1. Initialise a variable(like maxProfit or anything else) which will store the final profit as 0.\\n2. Under a single loop, check for the price which is greater than its previous price. That would be the time when we should sell the stock to earn maximum profit at that instance.\\n3. Add up the profit to the initial variable maxProfit.\\n4. Continue the loop untill it reaches end. Eventually on its way it will keep on checking the profit condition and add up it to your maxProfit.\\n5. Finally return maxProfit.\\n\\nThis approach will take just O(n) time, since only once the entire array is traversed.\\nTry to code it now. Happy Hunting!!! \\n\\n**Do upvote my solution if found useful. It would motivate me furthur and help others.**\\n\\n"
                    },
                    {
                        "username": "bhargav9427",
                        "content": "The most important aspect of any problem is how to arrive at a solution. What should be the thinking process behind it. Lets try to understand how can we reach upto the solution and most important how to convince ourselves that its optimal. Please watch the given solution for this problem as a prerequisite.\\n\\nThe first question after seeing the solution that comes to mind is why is it optimal. Why selecting the immediate peak is the optimal choice. Here is a mathematical understanding for that.\\n\\nConsider this input : [a, ......, b, ......., c....., d]. Where `...` refers to some input in between. a&c are valleys and b&d are peaks.\\n\\nPoints to understand. \\n1) If b&d both are peaks then there has to be some value in between them which is less than b. If not b could not have been a peak because the direct next peak immediate to a will be d.\\n2) If a&c are valleys then there has to be some value in between them which is greater than a. If not a could not have been a valley because the first valley will itself will be c.\\n3) Considering the first two points and assuming that not picking immediate next peak will lead to a better answer. Lets try to prove if we can do that.  \\n\\t\\nIf point 3 is true then we can say that \\n\\t d-a > (b-a) + (d-c)\\ni.e d > b+d-c               but as b-c > 0\\ni.e d > +ve + d            \\n\\nwhich is a false. So we can always say that picking up immediate next peak will always yeild a better result.\\n\\nHope this helps.\\n"
                    },
                    {
                        "username": "anurag_negi123",
                        "content": "nice mathematical proof bro loved it"
                    },
                    {
                        "username": "youssef",
                        "content": "Hello,\\n\\nI'd like to know why the greedy algorithm that takes pairwise profits if they are positive only?\\n\\nThanks"
                    },
                    {
                        "username": "dpeachpeach",
                        "content": "Hi youssef, I recall a greedy-stays-ahead proof similar to this q in one of my college courses but I forgot it so I'm going to try to lay out the logic as well as possible.\n\nLet there be two prices p_a and p_b in the array. where a < b\nLet us say that there is a distance of n => 1 between the two. (Multiple prices in between the two)\n\nThere are two possible cases for the values of p_a in relation to p_b. Either p_b > p_a, which means we would want to buy. or P_b < p_a, which means we wouldn't want to buy.\nLet's ignore the second case because it's trivial and focus on the first.\n\nOk! So we know that we want to buy p_1 so that we can sell at p_2, but there is a distance of n>= 1 between the two, so this leaves uncertainty.\n\nWell, we know for a fact that overall price change across this period in time is going to be p_2 - p_1 or dp\n\nWe also know that price changes are split by days, which means that there are 'positive days' and 'negative days'\n\nAs we stated earlier, p_b > p_a where the distance between the two is n >= 1. if the distance is 1 (they're right next to each other), in what case would you prefer to take a losing bet? :-)\n\nThis is kind of a clever trick (It's a very nonrigorous proof by induction) but here's also a shaky proof by contradiction to help visualize it.\n\nLet us assume that there is an optimal solution where we choose to take a pairwise loss between two prices as opposed to taking a pairwise gain whenever possible.\n\nThis would somehow imply that the pairwise loss allows us to gain more profit than if we had never taken it in the first place. However, due to the allowances of the challenge, we have perfect foresight of the markets. Whenever there is a 'loss' in price, and that price then goes up in the future, we can always profit by taking a profit between the price in the future and the previous price. (If there is a higher price at the end then it must have gotten to that price somehow in increments or totally between two days). By taking a pairwise loss, we are doing nothing but surrendering 'opportunity profit' that we could have made by just doing pairwise purchasing later.\n\nThat's all shaky, but it's been a few months since I've been in class. Good luck!"
                    },
                    {
                        "username": "rushzone",
                        "content": "Judging from my code that has been accepted by the system, I think the limitation of the question is you can only hold 1 stock at most for any time. Which has not been clarified in the question description.\\n\\nFor more complete question and answer to it, in fact case, the money in your account at the beginning is  determined. What you can do is to make maximum profit from this data. During the progress, you can use the profit you made to buy more stock next time."
                    },
                    {
                        "username": "arhankundu99",
                        "content": "I always feel like a noob while encountering these type of questions. I tried for an hour and all I could manage was brute force method optimised with dp. How do you guys come up with such ideas (Like plotting the points and doing summation of peaks(i)-valeys(i)) ?"
                    },
                    {
                        "username": "heyyyankit",
                        "content": "no need to dp or any thing, just iterate on  prices and if you have profit any day, you can sell.. \n............\ncode:-\n\n      int n=prices.size();\n        int ans=0;\n        for(int i=1; i<=n-1; ++i){\n            int diff=prices[i]-prices[i-1];\n            if(diff>0){ans+=diff;}\n        }\n        return ans;"
                    },
                    {
                        "username": "AdityaDipamanggala",
                        "content": "[@Dipanshi_26](/Dipanshi_26) I think the best approach is to realize sum of neighboring peak is >= global peak, so we dont need to do any brute force"
                    },
                    {
                        "username": "AdityaDipamanggala",
                        "content": "Hahah this also exactly what I\\'m facing, turns out I\\'m too over-complicated the logic behind it, once you realize that sum of neighboring peak is always higher than global peak it will be easy "
                    },
                    {
                        "username": "Dipanshi_26",
                        "content": "Can you please give me hint about the approch you mentioned about? I don\\'t know abhout DP still trying to solve thsi problem."
                    },
                    {
                        "username": "shad",
                        "content": "After reading the description I don't understand what a program is supposed to compute to be accepted.\\n\\nI understand the array of prices, but how do I know what the maximum profit is without  knowing how much I can invest initially?  What about selling short before buying any?\\n\\nI guess there aren't any transaction fees to consider, but I don't know why it says I have to sell before I buy - if I'm maximizing profit, aren't I buying as much as I can afford, then selling it all right before it goes down?"
                    },
                    {
                        "username": "Harshsharma12",
                        "content": "https://leetcode.com/problems/best-time-to-buy-and-sell-stock-ii/description/comments/1567200"
                    },
                    {
                        "username": "biller897",
                        "content": "i\\'ll tell you the most basic thing to understand before doing any \"Buy and Sell Stock\" problem :-\\n\\nTake ex :- [1,4,7,8,6,4]\\nif you take (1, 8) , diff = 7\\nor if you take (1, 4), (4, 7), (7, 8), diff = 3 + 3 + 1 = 7\\n\\nGoing directly to 8, or going to 8 by adding all differences in between is same in result, so rather than thinking to jump, think it in this way.\\n"
                    },
                    {
                        "username": "Novarg",
                        "content": "Imagine you were a stock trader and you know the future prices for a given stock (This is the problem input). Each day you would buy the stock if you knew you could sell it tomorrow for a profit (This is the greedy solution)."
                    }
                ]
            },
            {
                "id": 1566747,
                "content": [
                    {
                        "username": "hanseaston",
                        "content": "We want to buy all the stocks when the line is going up. And want to ignore all the lines when the line is going down.\\n\\nDo a for loop through the array and only count in the green line that is going up, by comparing the two adjacent elements in the array.\\n\\nMany solutions are already posted here. But I think a picture would make things clearer to see.\\n\\n![image](https://assets.leetcode.com/users/hans00/image_1586103419.png)\\n\\n"
                    },
                    {
                        "username": "shashi_singh_18",
                        "content": "I just read the 1st line and my code is accepted. Thanks!!!!!!!!!!!!!!!"
                    },
                    {
                        "username": "introvertCode",
                        "content": "Thank you!"
                    },
                    {
                        "username": "tanushjangid1234",
                        "content": "What a great intuation."
                    },
                    {
                        "username": "glaucusec",
                        "content": "Thanks man. This actually helped a lot"
                    },
                    {
                        "username": "meanup",
                        "content": "`Hint`\\nStill confuse, after seeing the above figure analyse the example 1 and example 2. And it will all make sense. \\nUpvoted! Thank you. "
                    },
                    {
                        "username": "shhung",
                        "content": "It\\'s really simplify the question"
                    },
                    {
                        "username": "mayank-01",
                        "content": "upvoted, thank you for keeping things simple\\uD83D\\uDC4D"
                    },
                    {
                        "username": "falgunitagadkar",
                        "content": "Thanks:)"
                    },
                    {
                        "username": "pranavrocksharma",
                        "content": "what is the meaning of this buying and selling on the same day, profit will be 0 right , so why they highligted in bold, if was selling and then buying on the same day then it would affect on the recurrence but this statement is just added for the sake.\\n\\nAm i wrong or it means something else , i solved assuming we cannot sell and then buy on the same day, we will buy on the next day ."
                    },
                    {
                        "username": "Shaik_Aman_Sayer",
                        "content": "[@Mee_eeM](/Mee_eeM) appreciated dude earned my respect "
                    },
                    {
                        "username": "falgunitagadkar",
                        "content": "[@Dipanshi_26](/Dipanshi_26) The pictorial representation in the above comment has an hint in itself and if you want you can check out my solution.It\\'s not DP solution neither uses Greedy."
                    },
                    {
                        "username": "Dipanshi_26",
                        "content": "I just wanted to ask if this problem can be solved without DP or greedy algorithm because I am new to DSA I have practiced array perfectly. \\nCan you please suggest any othe opproch (hint) without these two approch. "
                    },
                    {
                        "username": "Mee_eeM",
                        "content": "Since you are allow to hold at most one stock at a time it is best to sell it if a lower price comes around. For example on day 1 the price is 7 dollars and day 2 the price is 1 dollar. If you buy on day 1 and sell on 2 you lose money, and you can't buy on day 2 since you've bought on day 1. Allowing you to buy and sell on the same day free up your 1 stock so than you may buy on day 2. Hope this helps."
                    },
                    {
                        "username": "abhijeetkrsingh17",
                        "content": "It is pointless. Even if we think that you sold the stock at higher price and bought new stocks same day as there must be a more higher price than this dates price. then it won\\'t make any difference if you had sold the stocks the next higher day. the diff remains the same."
                    },
                    {
                        "username": "Jeetu_123",
                        "content": "[@godshiva](/godshiva) If u look it as a trader point of view then it is not pointless."
                    },
                    {
                        "username": "itsvishalcodes",
                        "content": "[@sivagowda](/sivagowda) What do you  mean different stock? We are only allowed to hold one stock at a time. So you can only buy on a certain day if you have no stock holdings."
                    },
                    {
                        "username": "sivagowda",
                        "content": "They mean you could sell a stock that you already bought and buy a stock on that day(you could perform buying and selling on the same day of different stocks)"
                    },
                    {
                        "username": "godshiva",
                        "content": "No you\\'re right. You are allowed to do it, but doing so is pointless"
                    },
                    {
                        "username": "Bulbasaur2000",
                        "content": "**Firstly, the second test case explaination might mislead you as it did to me. So, try to avoid that.**\\n\\nLogic: \\nIt is pretty clear that normal brute force approach will take two loops and complexity will become O(n^2). So our objective is to optimise it as far as possible. A **one-pass algorithm** could be used to achieve this optimisation.\\n\\nApproach: \\n1. Initialise a variable(like maxProfit or anything else) which will store the final profit as 0.\\n2. Under a single loop, check for the price which is greater than its previous price. That would be the time when we should sell the stock to earn maximum profit at that instance.\\n3. Add up the profit to the initial variable maxProfit.\\n4. Continue the loop untill it reaches end. Eventually on its way it will keep on checking the profit condition and add up it to your maxProfit.\\n5. Finally return maxProfit.\\n\\nThis approach will take just O(n) time, since only once the entire array is traversed.\\nTry to code it now. Happy Hunting!!! \\n\\n**Do upvote my solution if found useful. It would motivate me furthur and help others.**\\n\\n"
                    },
                    {
                        "username": "bhargav9427",
                        "content": "The most important aspect of any problem is how to arrive at a solution. What should be the thinking process behind it. Lets try to understand how can we reach upto the solution and most important how to convince ourselves that its optimal. Please watch the given solution for this problem as a prerequisite.\\n\\nThe first question after seeing the solution that comes to mind is why is it optimal. Why selecting the immediate peak is the optimal choice. Here is a mathematical understanding for that.\\n\\nConsider this input : [a, ......, b, ......., c....., d]. Where `...` refers to some input in between. a&c are valleys and b&d are peaks.\\n\\nPoints to understand. \\n1) If b&d both are peaks then there has to be some value in between them which is less than b. If not b could not have been a peak because the direct next peak immediate to a will be d.\\n2) If a&c are valleys then there has to be some value in between them which is greater than a. If not a could not have been a valley because the first valley will itself will be c.\\n3) Considering the first two points and assuming that not picking immediate next peak will lead to a better answer. Lets try to prove if we can do that.  \\n\\t\\nIf point 3 is true then we can say that \\n\\t d-a > (b-a) + (d-c)\\ni.e d > b+d-c               but as b-c > 0\\ni.e d > +ve + d            \\n\\nwhich is a false. So we can always say that picking up immediate next peak will always yeild a better result.\\n\\nHope this helps.\\n"
                    },
                    {
                        "username": "anurag_negi123",
                        "content": "nice mathematical proof bro loved it"
                    },
                    {
                        "username": "youssef",
                        "content": "Hello,\\n\\nI'd like to know why the greedy algorithm that takes pairwise profits if they are positive only?\\n\\nThanks"
                    },
                    {
                        "username": "dpeachpeach",
                        "content": "Hi youssef, I recall a greedy-stays-ahead proof similar to this q in one of my college courses but I forgot it so I'm going to try to lay out the logic as well as possible.\n\nLet there be two prices p_a and p_b in the array. where a < b\nLet us say that there is a distance of n => 1 between the two. (Multiple prices in between the two)\n\nThere are two possible cases for the values of p_a in relation to p_b. Either p_b > p_a, which means we would want to buy. or P_b < p_a, which means we wouldn't want to buy.\nLet's ignore the second case because it's trivial and focus on the first.\n\nOk! So we know that we want to buy p_1 so that we can sell at p_2, but there is a distance of n>= 1 between the two, so this leaves uncertainty.\n\nWell, we know for a fact that overall price change across this period in time is going to be p_2 - p_1 or dp\n\nWe also know that price changes are split by days, which means that there are 'positive days' and 'negative days'\n\nAs we stated earlier, p_b > p_a where the distance between the two is n >= 1. if the distance is 1 (they're right next to each other), in what case would you prefer to take a losing bet? :-)\n\nThis is kind of a clever trick (It's a very nonrigorous proof by induction) but here's also a shaky proof by contradiction to help visualize it.\n\nLet us assume that there is an optimal solution where we choose to take a pairwise loss between two prices as opposed to taking a pairwise gain whenever possible.\n\nThis would somehow imply that the pairwise loss allows us to gain more profit than if we had never taken it in the first place. However, due to the allowances of the challenge, we have perfect foresight of the markets. Whenever there is a 'loss' in price, and that price then goes up in the future, we can always profit by taking a profit between the price in the future and the previous price. (If there is a higher price at the end then it must have gotten to that price somehow in increments or totally between two days). By taking a pairwise loss, we are doing nothing but surrendering 'opportunity profit' that we could have made by just doing pairwise purchasing later.\n\nThat's all shaky, but it's been a few months since I've been in class. Good luck!"
                    },
                    {
                        "username": "rushzone",
                        "content": "Judging from my code that has been accepted by the system, I think the limitation of the question is you can only hold 1 stock at most for any time. Which has not been clarified in the question description.\\n\\nFor more complete question and answer to it, in fact case, the money in your account at the beginning is  determined. What you can do is to make maximum profit from this data. During the progress, you can use the profit you made to buy more stock next time."
                    },
                    {
                        "username": "arhankundu99",
                        "content": "I always feel like a noob while encountering these type of questions. I tried for an hour and all I could manage was brute force method optimised with dp. How do you guys come up with such ideas (Like plotting the points and doing summation of peaks(i)-valeys(i)) ?"
                    },
                    {
                        "username": "heyyyankit",
                        "content": "no need to dp or any thing, just iterate on  prices and if you have profit any day, you can sell.. \n............\ncode:-\n\n      int n=prices.size();\n        int ans=0;\n        for(int i=1; i<=n-1; ++i){\n            int diff=prices[i]-prices[i-1];\n            if(diff>0){ans+=diff;}\n        }\n        return ans;"
                    },
                    {
                        "username": "AdityaDipamanggala",
                        "content": "[@Dipanshi_26](/Dipanshi_26) I think the best approach is to realize sum of neighboring peak is >= global peak, so we dont need to do any brute force"
                    },
                    {
                        "username": "AdityaDipamanggala",
                        "content": "Hahah this also exactly what I\\'m facing, turns out I\\'m too over-complicated the logic behind it, once you realize that sum of neighboring peak is always higher than global peak it will be easy "
                    },
                    {
                        "username": "Dipanshi_26",
                        "content": "Can you please give me hint about the approch you mentioned about? I don\\'t know abhout DP still trying to solve thsi problem."
                    },
                    {
                        "username": "shad",
                        "content": "After reading the description I don't understand what a program is supposed to compute to be accepted.\\n\\nI understand the array of prices, but how do I know what the maximum profit is without  knowing how much I can invest initially?  What about selling short before buying any?\\n\\nI guess there aren't any transaction fees to consider, but I don't know why it says I have to sell before I buy - if I'm maximizing profit, aren't I buying as much as I can afford, then selling it all right before it goes down?"
                    },
                    {
                        "username": "Harshsharma12",
                        "content": "https://leetcode.com/problems/best-time-to-buy-and-sell-stock-ii/description/comments/1567200"
                    },
                    {
                        "username": "biller897",
                        "content": "i\\'ll tell you the most basic thing to understand before doing any \"Buy and Sell Stock\" problem :-\\n\\nTake ex :- [1,4,7,8,6,4]\\nif you take (1, 8) , diff = 7\\nor if you take (1, 4), (4, 7), (7, 8), diff = 3 + 3 + 1 = 7\\n\\nGoing directly to 8, or going to 8 by adding all differences in between is same in result, so rather than thinking to jump, think it in this way.\\n"
                    },
                    {
                        "username": "Novarg",
                        "content": "Imagine you were a stock trader and you know the future prices for a given stock (This is the problem input). Each day you would buy the stock if you knew you could sell it tomorrow for a profit (This is the greedy solution)."
                    }
                ]
            },
            {
                "id": 1568310,
                "content": [
                    {
                        "username": "hanseaston",
                        "content": "We want to buy all the stocks when the line is going up. And want to ignore all the lines when the line is going down.\\n\\nDo a for loop through the array and only count in the green line that is going up, by comparing the two adjacent elements in the array.\\n\\nMany solutions are already posted here. But I think a picture would make things clearer to see.\\n\\n![image](https://assets.leetcode.com/users/hans00/image_1586103419.png)\\n\\n"
                    },
                    {
                        "username": "shashi_singh_18",
                        "content": "I just read the 1st line and my code is accepted. Thanks!!!!!!!!!!!!!!!"
                    },
                    {
                        "username": "introvertCode",
                        "content": "Thank you!"
                    },
                    {
                        "username": "tanushjangid1234",
                        "content": "What a great intuation."
                    },
                    {
                        "username": "glaucusec",
                        "content": "Thanks man. This actually helped a lot"
                    },
                    {
                        "username": "meanup",
                        "content": "`Hint`\\nStill confuse, after seeing the above figure analyse the example 1 and example 2. And it will all make sense. \\nUpvoted! Thank you. "
                    },
                    {
                        "username": "shhung",
                        "content": "It\\'s really simplify the question"
                    },
                    {
                        "username": "mayank-01",
                        "content": "upvoted, thank you for keeping things simple\\uD83D\\uDC4D"
                    },
                    {
                        "username": "falgunitagadkar",
                        "content": "Thanks:)"
                    },
                    {
                        "username": "pranavrocksharma",
                        "content": "what is the meaning of this buying and selling on the same day, profit will be 0 right , so why they highligted in bold, if was selling and then buying on the same day then it would affect on the recurrence but this statement is just added for the sake.\\n\\nAm i wrong or it means something else , i solved assuming we cannot sell and then buy on the same day, we will buy on the next day ."
                    },
                    {
                        "username": "Shaik_Aman_Sayer",
                        "content": "[@Mee_eeM](/Mee_eeM) appreciated dude earned my respect "
                    },
                    {
                        "username": "falgunitagadkar",
                        "content": "[@Dipanshi_26](/Dipanshi_26) The pictorial representation in the above comment has an hint in itself and if you want you can check out my solution.It\\'s not DP solution neither uses Greedy."
                    },
                    {
                        "username": "Dipanshi_26",
                        "content": "I just wanted to ask if this problem can be solved without DP or greedy algorithm because I am new to DSA I have practiced array perfectly. \\nCan you please suggest any othe opproch (hint) without these two approch. "
                    },
                    {
                        "username": "Mee_eeM",
                        "content": "Since you are allow to hold at most one stock at a time it is best to sell it if a lower price comes around. For example on day 1 the price is 7 dollars and day 2 the price is 1 dollar. If you buy on day 1 and sell on 2 you lose money, and you can't buy on day 2 since you've bought on day 1. Allowing you to buy and sell on the same day free up your 1 stock so than you may buy on day 2. Hope this helps."
                    },
                    {
                        "username": "abhijeetkrsingh17",
                        "content": "It is pointless. Even if we think that you sold the stock at higher price and bought new stocks same day as there must be a more higher price than this dates price. then it won\\'t make any difference if you had sold the stocks the next higher day. the diff remains the same."
                    },
                    {
                        "username": "Jeetu_123",
                        "content": "[@godshiva](/godshiva) If u look it as a trader point of view then it is not pointless."
                    },
                    {
                        "username": "itsvishalcodes",
                        "content": "[@sivagowda](/sivagowda) What do you  mean different stock? We are only allowed to hold one stock at a time. So you can only buy on a certain day if you have no stock holdings."
                    },
                    {
                        "username": "sivagowda",
                        "content": "They mean you could sell a stock that you already bought and buy a stock on that day(you could perform buying and selling on the same day of different stocks)"
                    },
                    {
                        "username": "godshiva",
                        "content": "No you\\'re right. You are allowed to do it, but doing so is pointless"
                    },
                    {
                        "username": "Bulbasaur2000",
                        "content": "**Firstly, the second test case explaination might mislead you as it did to me. So, try to avoid that.**\\n\\nLogic: \\nIt is pretty clear that normal brute force approach will take two loops and complexity will become O(n^2). So our objective is to optimise it as far as possible. A **one-pass algorithm** could be used to achieve this optimisation.\\n\\nApproach: \\n1. Initialise a variable(like maxProfit or anything else) which will store the final profit as 0.\\n2. Under a single loop, check for the price which is greater than its previous price. That would be the time when we should sell the stock to earn maximum profit at that instance.\\n3. Add up the profit to the initial variable maxProfit.\\n4. Continue the loop untill it reaches end. Eventually on its way it will keep on checking the profit condition and add up it to your maxProfit.\\n5. Finally return maxProfit.\\n\\nThis approach will take just O(n) time, since only once the entire array is traversed.\\nTry to code it now. Happy Hunting!!! \\n\\n**Do upvote my solution if found useful. It would motivate me furthur and help others.**\\n\\n"
                    },
                    {
                        "username": "bhargav9427",
                        "content": "The most important aspect of any problem is how to arrive at a solution. What should be the thinking process behind it. Lets try to understand how can we reach upto the solution and most important how to convince ourselves that its optimal. Please watch the given solution for this problem as a prerequisite.\\n\\nThe first question after seeing the solution that comes to mind is why is it optimal. Why selecting the immediate peak is the optimal choice. Here is a mathematical understanding for that.\\n\\nConsider this input : [a, ......, b, ......., c....., d]. Where `...` refers to some input in between. a&c are valleys and b&d are peaks.\\n\\nPoints to understand. \\n1) If b&d both are peaks then there has to be some value in between them which is less than b. If not b could not have been a peak because the direct next peak immediate to a will be d.\\n2) If a&c are valleys then there has to be some value in between them which is greater than a. If not a could not have been a valley because the first valley will itself will be c.\\n3) Considering the first two points and assuming that not picking immediate next peak will lead to a better answer. Lets try to prove if we can do that.  \\n\\t\\nIf point 3 is true then we can say that \\n\\t d-a > (b-a) + (d-c)\\ni.e d > b+d-c               but as b-c > 0\\ni.e d > +ve + d            \\n\\nwhich is a false. So we can always say that picking up immediate next peak will always yeild a better result.\\n\\nHope this helps.\\n"
                    },
                    {
                        "username": "anurag_negi123",
                        "content": "nice mathematical proof bro loved it"
                    },
                    {
                        "username": "youssef",
                        "content": "Hello,\\n\\nI'd like to know why the greedy algorithm that takes pairwise profits if they are positive only?\\n\\nThanks"
                    },
                    {
                        "username": "dpeachpeach",
                        "content": "Hi youssef, I recall a greedy-stays-ahead proof similar to this q in one of my college courses but I forgot it so I'm going to try to lay out the logic as well as possible.\n\nLet there be two prices p_a and p_b in the array. where a < b\nLet us say that there is a distance of n => 1 between the two. (Multiple prices in between the two)\n\nThere are two possible cases for the values of p_a in relation to p_b. Either p_b > p_a, which means we would want to buy. or P_b < p_a, which means we wouldn't want to buy.\nLet's ignore the second case because it's trivial and focus on the first.\n\nOk! So we know that we want to buy p_1 so that we can sell at p_2, but there is a distance of n>= 1 between the two, so this leaves uncertainty.\n\nWell, we know for a fact that overall price change across this period in time is going to be p_2 - p_1 or dp\n\nWe also know that price changes are split by days, which means that there are 'positive days' and 'negative days'\n\nAs we stated earlier, p_b > p_a where the distance between the two is n >= 1. if the distance is 1 (they're right next to each other), in what case would you prefer to take a losing bet? :-)\n\nThis is kind of a clever trick (It's a very nonrigorous proof by induction) but here's also a shaky proof by contradiction to help visualize it.\n\nLet us assume that there is an optimal solution where we choose to take a pairwise loss between two prices as opposed to taking a pairwise gain whenever possible.\n\nThis would somehow imply that the pairwise loss allows us to gain more profit than if we had never taken it in the first place. However, due to the allowances of the challenge, we have perfect foresight of the markets. Whenever there is a 'loss' in price, and that price then goes up in the future, we can always profit by taking a profit between the price in the future and the previous price. (If there is a higher price at the end then it must have gotten to that price somehow in increments or totally between two days). By taking a pairwise loss, we are doing nothing but surrendering 'opportunity profit' that we could have made by just doing pairwise purchasing later.\n\nThat's all shaky, but it's been a few months since I've been in class. Good luck!"
                    },
                    {
                        "username": "rushzone",
                        "content": "Judging from my code that has been accepted by the system, I think the limitation of the question is you can only hold 1 stock at most for any time. Which has not been clarified in the question description.\\n\\nFor more complete question and answer to it, in fact case, the money in your account at the beginning is  determined. What you can do is to make maximum profit from this data. During the progress, you can use the profit you made to buy more stock next time."
                    },
                    {
                        "username": "arhankundu99",
                        "content": "I always feel like a noob while encountering these type of questions. I tried for an hour and all I could manage was brute force method optimised with dp. How do you guys come up with such ideas (Like plotting the points and doing summation of peaks(i)-valeys(i)) ?"
                    },
                    {
                        "username": "heyyyankit",
                        "content": "no need to dp or any thing, just iterate on  prices and if you have profit any day, you can sell.. \n............\ncode:-\n\n      int n=prices.size();\n        int ans=0;\n        for(int i=1; i<=n-1; ++i){\n            int diff=prices[i]-prices[i-1];\n            if(diff>0){ans+=diff;}\n        }\n        return ans;"
                    },
                    {
                        "username": "AdityaDipamanggala",
                        "content": "[@Dipanshi_26](/Dipanshi_26) I think the best approach is to realize sum of neighboring peak is >= global peak, so we dont need to do any brute force"
                    },
                    {
                        "username": "AdityaDipamanggala",
                        "content": "Hahah this also exactly what I\\'m facing, turns out I\\'m too over-complicated the logic behind it, once you realize that sum of neighboring peak is always higher than global peak it will be easy "
                    },
                    {
                        "username": "Dipanshi_26",
                        "content": "Can you please give me hint about the approch you mentioned about? I don\\'t know abhout DP still trying to solve thsi problem."
                    },
                    {
                        "username": "shad",
                        "content": "After reading the description I don't understand what a program is supposed to compute to be accepted.\\n\\nI understand the array of prices, but how do I know what the maximum profit is without  knowing how much I can invest initially?  What about selling short before buying any?\\n\\nI guess there aren't any transaction fees to consider, but I don't know why it says I have to sell before I buy - if I'm maximizing profit, aren't I buying as much as I can afford, then selling it all right before it goes down?"
                    },
                    {
                        "username": "Harshsharma12",
                        "content": "https://leetcode.com/problems/best-time-to-buy-and-sell-stock-ii/description/comments/1567200"
                    },
                    {
                        "username": "biller897",
                        "content": "i\\'ll tell you the most basic thing to understand before doing any \"Buy and Sell Stock\" problem :-\\n\\nTake ex :- [1,4,7,8,6,4]\\nif you take (1, 8) , diff = 7\\nor if you take (1, 4), (4, 7), (7, 8), diff = 3 + 3 + 1 = 7\\n\\nGoing directly to 8, or going to 8 by adding all differences in between is same in result, so rather than thinking to jump, think it in this way.\\n"
                    },
                    {
                        "username": "Novarg",
                        "content": "Imagine you were a stock trader and you know the future prices for a given stock (This is the problem input). Each day you would buy the stock if you knew you could sell it tomorrow for a profit (This is the greedy solution)."
                    }
                ]
            },
            {
                "id": 1567200,
                "content": [
                    {
                        "username": "hanseaston",
                        "content": "We want to buy all the stocks when the line is going up. And want to ignore all the lines when the line is going down.\\n\\nDo a for loop through the array and only count in the green line that is going up, by comparing the two adjacent elements in the array.\\n\\nMany solutions are already posted here. But I think a picture would make things clearer to see.\\n\\n![image](https://assets.leetcode.com/users/hans00/image_1586103419.png)\\n\\n"
                    },
                    {
                        "username": "shashi_singh_18",
                        "content": "I just read the 1st line and my code is accepted. Thanks!!!!!!!!!!!!!!!"
                    },
                    {
                        "username": "introvertCode",
                        "content": "Thank you!"
                    },
                    {
                        "username": "tanushjangid1234",
                        "content": "What a great intuation."
                    },
                    {
                        "username": "glaucusec",
                        "content": "Thanks man. This actually helped a lot"
                    },
                    {
                        "username": "meanup",
                        "content": "`Hint`\\nStill confuse, after seeing the above figure analyse the example 1 and example 2. And it will all make sense. \\nUpvoted! Thank you. "
                    },
                    {
                        "username": "shhung",
                        "content": "It\\'s really simplify the question"
                    },
                    {
                        "username": "mayank-01",
                        "content": "upvoted, thank you for keeping things simple\\uD83D\\uDC4D"
                    },
                    {
                        "username": "falgunitagadkar",
                        "content": "Thanks:)"
                    },
                    {
                        "username": "pranavrocksharma",
                        "content": "what is the meaning of this buying and selling on the same day, profit will be 0 right , so why they highligted in bold, if was selling and then buying on the same day then it would affect on the recurrence but this statement is just added for the sake.\\n\\nAm i wrong or it means something else , i solved assuming we cannot sell and then buy on the same day, we will buy on the next day ."
                    },
                    {
                        "username": "Shaik_Aman_Sayer",
                        "content": "[@Mee_eeM](/Mee_eeM) appreciated dude earned my respect "
                    },
                    {
                        "username": "falgunitagadkar",
                        "content": "[@Dipanshi_26](/Dipanshi_26) The pictorial representation in the above comment has an hint in itself and if you want you can check out my solution.It\\'s not DP solution neither uses Greedy."
                    },
                    {
                        "username": "Dipanshi_26",
                        "content": "I just wanted to ask if this problem can be solved without DP or greedy algorithm because I am new to DSA I have practiced array perfectly. \\nCan you please suggest any othe opproch (hint) without these two approch. "
                    },
                    {
                        "username": "Mee_eeM",
                        "content": "Since you are allow to hold at most one stock at a time it is best to sell it if a lower price comes around. For example on day 1 the price is 7 dollars and day 2 the price is 1 dollar. If you buy on day 1 and sell on 2 you lose money, and you can't buy on day 2 since you've bought on day 1. Allowing you to buy and sell on the same day free up your 1 stock so than you may buy on day 2. Hope this helps."
                    },
                    {
                        "username": "abhijeetkrsingh17",
                        "content": "It is pointless. Even if we think that you sold the stock at higher price and bought new stocks same day as there must be a more higher price than this dates price. then it won\\'t make any difference if you had sold the stocks the next higher day. the diff remains the same."
                    },
                    {
                        "username": "Jeetu_123",
                        "content": "[@godshiva](/godshiva) If u look it as a trader point of view then it is not pointless."
                    },
                    {
                        "username": "itsvishalcodes",
                        "content": "[@sivagowda](/sivagowda) What do you  mean different stock? We are only allowed to hold one stock at a time. So you can only buy on a certain day if you have no stock holdings."
                    },
                    {
                        "username": "sivagowda",
                        "content": "They mean you could sell a stock that you already bought and buy a stock on that day(you could perform buying and selling on the same day of different stocks)"
                    },
                    {
                        "username": "godshiva",
                        "content": "No you\\'re right. You are allowed to do it, but doing so is pointless"
                    },
                    {
                        "username": "Bulbasaur2000",
                        "content": "**Firstly, the second test case explaination might mislead you as it did to me. So, try to avoid that.**\\n\\nLogic: \\nIt is pretty clear that normal brute force approach will take two loops and complexity will become O(n^2). So our objective is to optimise it as far as possible. A **one-pass algorithm** could be used to achieve this optimisation.\\n\\nApproach: \\n1. Initialise a variable(like maxProfit or anything else) which will store the final profit as 0.\\n2. Under a single loop, check for the price which is greater than its previous price. That would be the time when we should sell the stock to earn maximum profit at that instance.\\n3. Add up the profit to the initial variable maxProfit.\\n4. Continue the loop untill it reaches end. Eventually on its way it will keep on checking the profit condition and add up it to your maxProfit.\\n5. Finally return maxProfit.\\n\\nThis approach will take just O(n) time, since only once the entire array is traversed.\\nTry to code it now. Happy Hunting!!! \\n\\n**Do upvote my solution if found useful. It would motivate me furthur and help others.**\\n\\n"
                    },
                    {
                        "username": "bhargav9427",
                        "content": "The most important aspect of any problem is how to arrive at a solution. What should be the thinking process behind it. Lets try to understand how can we reach upto the solution and most important how to convince ourselves that its optimal. Please watch the given solution for this problem as a prerequisite.\\n\\nThe first question after seeing the solution that comes to mind is why is it optimal. Why selecting the immediate peak is the optimal choice. Here is a mathematical understanding for that.\\n\\nConsider this input : [a, ......, b, ......., c....., d]. Where `...` refers to some input in between. a&c are valleys and b&d are peaks.\\n\\nPoints to understand. \\n1) If b&d both are peaks then there has to be some value in between them which is less than b. If not b could not have been a peak because the direct next peak immediate to a will be d.\\n2) If a&c are valleys then there has to be some value in between them which is greater than a. If not a could not have been a valley because the first valley will itself will be c.\\n3) Considering the first two points and assuming that not picking immediate next peak will lead to a better answer. Lets try to prove if we can do that.  \\n\\t\\nIf point 3 is true then we can say that \\n\\t d-a > (b-a) + (d-c)\\ni.e d > b+d-c               but as b-c > 0\\ni.e d > +ve + d            \\n\\nwhich is a false. So we can always say that picking up immediate next peak will always yeild a better result.\\n\\nHope this helps.\\n"
                    },
                    {
                        "username": "anurag_negi123",
                        "content": "nice mathematical proof bro loved it"
                    },
                    {
                        "username": "youssef",
                        "content": "Hello,\\n\\nI'd like to know why the greedy algorithm that takes pairwise profits if they are positive only?\\n\\nThanks"
                    },
                    {
                        "username": "dpeachpeach",
                        "content": "Hi youssef, I recall a greedy-stays-ahead proof similar to this q in one of my college courses but I forgot it so I'm going to try to lay out the logic as well as possible.\n\nLet there be two prices p_a and p_b in the array. where a < b\nLet us say that there is a distance of n => 1 between the two. (Multiple prices in between the two)\n\nThere are two possible cases for the values of p_a in relation to p_b. Either p_b > p_a, which means we would want to buy. or P_b < p_a, which means we wouldn't want to buy.\nLet's ignore the second case because it's trivial and focus on the first.\n\nOk! So we know that we want to buy p_1 so that we can sell at p_2, but there is a distance of n>= 1 between the two, so this leaves uncertainty.\n\nWell, we know for a fact that overall price change across this period in time is going to be p_2 - p_1 or dp\n\nWe also know that price changes are split by days, which means that there are 'positive days' and 'negative days'\n\nAs we stated earlier, p_b > p_a where the distance between the two is n >= 1. if the distance is 1 (they're right next to each other), in what case would you prefer to take a losing bet? :-)\n\nThis is kind of a clever trick (It's a very nonrigorous proof by induction) but here's also a shaky proof by contradiction to help visualize it.\n\nLet us assume that there is an optimal solution where we choose to take a pairwise loss between two prices as opposed to taking a pairwise gain whenever possible.\n\nThis would somehow imply that the pairwise loss allows us to gain more profit than if we had never taken it in the first place. However, due to the allowances of the challenge, we have perfect foresight of the markets. Whenever there is a 'loss' in price, and that price then goes up in the future, we can always profit by taking a profit between the price in the future and the previous price. (If there is a higher price at the end then it must have gotten to that price somehow in increments or totally between two days). By taking a pairwise loss, we are doing nothing but surrendering 'opportunity profit' that we could have made by just doing pairwise purchasing later.\n\nThat's all shaky, but it's been a few months since I've been in class. Good luck!"
                    },
                    {
                        "username": "rushzone",
                        "content": "Judging from my code that has been accepted by the system, I think the limitation of the question is you can only hold 1 stock at most for any time. Which has not been clarified in the question description.\\n\\nFor more complete question and answer to it, in fact case, the money in your account at the beginning is  determined. What you can do is to make maximum profit from this data. During the progress, you can use the profit you made to buy more stock next time."
                    },
                    {
                        "username": "arhankundu99",
                        "content": "I always feel like a noob while encountering these type of questions. I tried for an hour and all I could manage was brute force method optimised with dp. How do you guys come up with such ideas (Like plotting the points and doing summation of peaks(i)-valeys(i)) ?"
                    },
                    {
                        "username": "heyyyankit",
                        "content": "no need to dp or any thing, just iterate on  prices and if you have profit any day, you can sell.. \n............\ncode:-\n\n      int n=prices.size();\n        int ans=0;\n        for(int i=1; i<=n-1; ++i){\n            int diff=prices[i]-prices[i-1];\n            if(diff>0){ans+=diff;}\n        }\n        return ans;"
                    },
                    {
                        "username": "AdityaDipamanggala",
                        "content": "[@Dipanshi_26](/Dipanshi_26) I think the best approach is to realize sum of neighboring peak is >= global peak, so we dont need to do any brute force"
                    },
                    {
                        "username": "AdityaDipamanggala",
                        "content": "Hahah this also exactly what I\\'m facing, turns out I\\'m too over-complicated the logic behind it, once you realize that sum of neighboring peak is always higher than global peak it will be easy "
                    },
                    {
                        "username": "Dipanshi_26",
                        "content": "Can you please give me hint about the approch you mentioned about? I don\\'t know abhout DP still trying to solve thsi problem."
                    },
                    {
                        "username": "shad",
                        "content": "After reading the description I don't understand what a program is supposed to compute to be accepted.\\n\\nI understand the array of prices, but how do I know what the maximum profit is without  knowing how much I can invest initially?  What about selling short before buying any?\\n\\nI guess there aren't any transaction fees to consider, but I don't know why it says I have to sell before I buy - if I'm maximizing profit, aren't I buying as much as I can afford, then selling it all right before it goes down?"
                    },
                    {
                        "username": "Harshsharma12",
                        "content": "https://leetcode.com/problems/best-time-to-buy-and-sell-stock-ii/description/comments/1567200"
                    },
                    {
                        "username": "biller897",
                        "content": "i\\'ll tell you the most basic thing to understand before doing any \"Buy and Sell Stock\" problem :-\\n\\nTake ex :- [1,4,7,8,6,4]\\nif you take (1, 8) , diff = 7\\nor if you take (1, 4), (4, 7), (7, 8), diff = 3 + 3 + 1 = 7\\n\\nGoing directly to 8, or going to 8 by adding all differences in between is same in result, so rather than thinking to jump, think it in this way.\\n"
                    },
                    {
                        "username": "Novarg",
                        "content": "Imagine you were a stock trader and you know the future prices for a given stock (This is the problem input). Each day you would buy the stock if you knew you could sell it tomorrow for a profit (This is the greedy solution)."
                    }
                ]
            },
            {
                "id": 1956066,
                "content": [
                    {
                        "username": "hanseaston",
                        "content": "We want to buy all the stocks when the line is going up. And want to ignore all the lines when the line is going down.\\n\\nDo a for loop through the array and only count in the green line that is going up, by comparing the two adjacent elements in the array.\\n\\nMany solutions are already posted here. But I think a picture would make things clearer to see.\\n\\n![image](https://assets.leetcode.com/users/hans00/image_1586103419.png)\\n\\n"
                    },
                    {
                        "username": "shashi_singh_18",
                        "content": "I just read the 1st line and my code is accepted. Thanks!!!!!!!!!!!!!!!"
                    },
                    {
                        "username": "introvertCode",
                        "content": "Thank you!"
                    },
                    {
                        "username": "tanushjangid1234",
                        "content": "What a great intuation."
                    },
                    {
                        "username": "glaucusec",
                        "content": "Thanks man. This actually helped a lot"
                    },
                    {
                        "username": "meanup",
                        "content": "`Hint`\\nStill confuse, after seeing the above figure analyse the example 1 and example 2. And it will all make sense. \\nUpvoted! Thank you. "
                    },
                    {
                        "username": "shhung",
                        "content": "It\\'s really simplify the question"
                    },
                    {
                        "username": "mayank-01",
                        "content": "upvoted, thank you for keeping things simple\\uD83D\\uDC4D"
                    },
                    {
                        "username": "falgunitagadkar",
                        "content": "Thanks:)"
                    },
                    {
                        "username": "pranavrocksharma",
                        "content": "what is the meaning of this buying and selling on the same day, profit will be 0 right , so why they highligted in bold, if was selling and then buying on the same day then it would affect on the recurrence but this statement is just added for the sake.\\n\\nAm i wrong or it means something else , i solved assuming we cannot sell and then buy on the same day, we will buy on the next day ."
                    },
                    {
                        "username": "Shaik_Aman_Sayer",
                        "content": "[@Mee_eeM](/Mee_eeM) appreciated dude earned my respect "
                    },
                    {
                        "username": "falgunitagadkar",
                        "content": "[@Dipanshi_26](/Dipanshi_26) The pictorial representation in the above comment has an hint in itself and if you want you can check out my solution.It\\'s not DP solution neither uses Greedy."
                    },
                    {
                        "username": "Dipanshi_26",
                        "content": "I just wanted to ask if this problem can be solved without DP or greedy algorithm because I am new to DSA I have practiced array perfectly. \\nCan you please suggest any othe opproch (hint) without these two approch. "
                    },
                    {
                        "username": "Mee_eeM",
                        "content": "Since you are allow to hold at most one stock at a time it is best to sell it if a lower price comes around. For example on day 1 the price is 7 dollars and day 2 the price is 1 dollar. If you buy on day 1 and sell on 2 you lose money, and you can't buy on day 2 since you've bought on day 1. Allowing you to buy and sell on the same day free up your 1 stock so than you may buy on day 2. Hope this helps."
                    },
                    {
                        "username": "abhijeetkrsingh17",
                        "content": "It is pointless. Even if we think that you sold the stock at higher price and bought new stocks same day as there must be a more higher price than this dates price. then it won\\'t make any difference if you had sold the stocks the next higher day. the diff remains the same."
                    },
                    {
                        "username": "Jeetu_123",
                        "content": "[@godshiva](/godshiva) If u look it as a trader point of view then it is not pointless."
                    },
                    {
                        "username": "itsvishalcodes",
                        "content": "[@sivagowda](/sivagowda) What do you  mean different stock? We are only allowed to hold one stock at a time. So you can only buy on a certain day if you have no stock holdings."
                    },
                    {
                        "username": "sivagowda",
                        "content": "They mean you could sell a stock that you already bought and buy a stock on that day(you could perform buying and selling on the same day of different stocks)"
                    },
                    {
                        "username": "godshiva",
                        "content": "No you\\'re right. You are allowed to do it, but doing so is pointless"
                    },
                    {
                        "username": "Bulbasaur2000",
                        "content": "**Firstly, the second test case explaination might mislead you as it did to me. So, try to avoid that.**\\n\\nLogic: \\nIt is pretty clear that normal brute force approach will take two loops and complexity will become O(n^2). So our objective is to optimise it as far as possible. A **one-pass algorithm** could be used to achieve this optimisation.\\n\\nApproach: \\n1. Initialise a variable(like maxProfit or anything else) which will store the final profit as 0.\\n2. Under a single loop, check for the price which is greater than its previous price. That would be the time when we should sell the stock to earn maximum profit at that instance.\\n3. Add up the profit to the initial variable maxProfit.\\n4. Continue the loop untill it reaches end. Eventually on its way it will keep on checking the profit condition and add up it to your maxProfit.\\n5. Finally return maxProfit.\\n\\nThis approach will take just O(n) time, since only once the entire array is traversed.\\nTry to code it now. Happy Hunting!!! \\n\\n**Do upvote my solution if found useful. It would motivate me furthur and help others.**\\n\\n"
                    },
                    {
                        "username": "bhargav9427",
                        "content": "The most important aspect of any problem is how to arrive at a solution. What should be the thinking process behind it. Lets try to understand how can we reach upto the solution and most important how to convince ourselves that its optimal. Please watch the given solution for this problem as a prerequisite.\\n\\nThe first question after seeing the solution that comes to mind is why is it optimal. Why selecting the immediate peak is the optimal choice. Here is a mathematical understanding for that.\\n\\nConsider this input : [a, ......, b, ......., c....., d]. Where `...` refers to some input in between. a&c are valleys and b&d are peaks.\\n\\nPoints to understand. \\n1) If b&d both are peaks then there has to be some value in between them which is less than b. If not b could not have been a peak because the direct next peak immediate to a will be d.\\n2) If a&c are valleys then there has to be some value in between them which is greater than a. If not a could not have been a valley because the first valley will itself will be c.\\n3) Considering the first two points and assuming that not picking immediate next peak will lead to a better answer. Lets try to prove if we can do that.  \\n\\t\\nIf point 3 is true then we can say that \\n\\t d-a > (b-a) + (d-c)\\ni.e d > b+d-c               but as b-c > 0\\ni.e d > +ve + d            \\n\\nwhich is a false. So we can always say that picking up immediate next peak will always yeild a better result.\\n\\nHope this helps.\\n"
                    },
                    {
                        "username": "anurag_negi123",
                        "content": "nice mathematical proof bro loved it"
                    },
                    {
                        "username": "youssef",
                        "content": "Hello,\\n\\nI'd like to know why the greedy algorithm that takes pairwise profits if they are positive only?\\n\\nThanks"
                    },
                    {
                        "username": "dpeachpeach",
                        "content": "Hi youssef, I recall a greedy-stays-ahead proof similar to this q in one of my college courses but I forgot it so I'm going to try to lay out the logic as well as possible.\n\nLet there be two prices p_a and p_b in the array. where a < b\nLet us say that there is a distance of n => 1 between the two. (Multiple prices in between the two)\n\nThere are two possible cases for the values of p_a in relation to p_b. Either p_b > p_a, which means we would want to buy. or P_b < p_a, which means we wouldn't want to buy.\nLet's ignore the second case because it's trivial and focus on the first.\n\nOk! So we know that we want to buy p_1 so that we can sell at p_2, but there is a distance of n>= 1 between the two, so this leaves uncertainty.\n\nWell, we know for a fact that overall price change across this period in time is going to be p_2 - p_1 or dp\n\nWe also know that price changes are split by days, which means that there are 'positive days' and 'negative days'\n\nAs we stated earlier, p_b > p_a where the distance between the two is n >= 1. if the distance is 1 (they're right next to each other), in what case would you prefer to take a losing bet? :-)\n\nThis is kind of a clever trick (It's a very nonrigorous proof by induction) but here's also a shaky proof by contradiction to help visualize it.\n\nLet us assume that there is an optimal solution where we choose to take a pairwise loss between two prices as opposed to taking a pairwise gain whenever possible.\n\nThis would somehow imply that the pairwise loss allows us to gain more profit than if we had never taken it in the first place. However, due to the allowances of the challenge, we have perfect foresight of the markets. Whenever there is a 'loss' in price, and that price then goes up in the future, we can always profit by taking a profit between the price in the future and the previous price. (If there is a higher price at the end then it must have gotten to that price somehow in increments or totally between two days). By taking a pairwise loss, we are doing nothing but surrendering 'opportunity profit' that we could have made by just doing pairwise purchasing later.\n\nThat's all shaky, but it's been a few months since I've been in class. Good luck!"
                    },
                    {
                        "username": "rushzone",
                        "content": "Judging from my code that has been accepted by the system, I think the limitation of the question is you can only hold 1 stock at most for any time. Which has not been clarified in the question description.\\n\\nFor more complete question and answer to it, in fact case, the money in your account at the beginning is  determined. What you can do is to make maximum profit from this data. During the progress, you can use the profit you made to buy more stock next time."
                    },
                    {
                        "username": "arhankundu99",
                        "content": "I always feel like a noob while encountering these type of questions. I tried for an hour and all I could manage was brute force method optimised with dp. How do you guys come up with such ideas (Like plotting the points and doing summation of peaks(i)-valeys(i)) ?"
                    },
                    {
                        "username": "heyyyankit",
                        "content": "no need to dp or any thing, just iterate on  prices and if you have profit any day, you can sell.. \n............\ncode:-\n\n      int n=prices.size();\n        int ans=0;\n        for(int i=1; i<=n-1; ++i){\n            int diff=prices[i]-prices[i-1];\n            if(diff>0){ans+=diff;}\n        }\n        return ans;"
                    },
                    {
                        "username": "AdityaDipamanggala",
                        "content": "[@Dipanshi_26](/Dipanshi_26) I think the best approach is to realize sum of neighboring peak is >= global peak, so we dont need to do any brute force"
                    },
                    {
                        "username": "AdityaDipamanggala",
                        "content": "Hahah this also exactly what I\\'m facing, turns out I\\'m too over-complicated the logic behind it, once you realize that sum of neighboring peak is always higher than global peak it will be easy "
                    },
                    {
                        "username": "Dipanshi_26",
                        "content": "Can you please give me hint about the approch you mentioned about? I don\\'t know abhout DP still trying to solve thsi problem."
                    },
                    {
                        "username": "shad",
                        "content": "After reading the description I don't understand what a program is supposed to compute to be accepted.\\n\\nI understand the array of prices, but how do I know what the maximum profit is without  knowing how much I can invest initially?  What about selling short before buying any?\\n\\nI guess there aren't any transaction fees to consider, but I don't know why it says I have to sell before I buy - if I'm maximizing profit, aren't I buying as much as I can afford, then selling it all right before it goes down?"
                    },
                    {
                        "username": "Harshsharma12",
                        "content": "https://leetcode.com/problems/best-time-to-buy-and-sell-stock-ii/description/comments/1567200"
                    },
                    {
                        "username": "biller897",
                        "content": "i\\'ll tell you the most basic thing to understand before doing any \"Buy and Sell Stock\" problem :-\\n\\nTake ex :- [1,4,7,8,6,4]\\nif you take (1, 8) , diff = 7\\nor if you take (1, 4), (4, 7), (7, 8), diff = 3 + 3 + 1 = 7\\n\\nGoing directly to 8, or going to 8 by adding all differences in between is same in result, so rather than thinking to jump, think it in this way.\\n"
                    },
                    {
                        "username": "Novarg",
                        "content": "Imagine you were a stock trader and you know the future prices for a given stock (This is the problem input). Each day you would buy the stock if you knew you could sell it tomorrow for a profit (This is the greedy solution)."
                    }
                ]
            },
            {
                "id": 1568307,
                "content": [
                    {
                        "username": "hanseaston",
                        "content": "We want to buy all the stocks when the line is going up. And want to ignore all the lines when the line is going down.\\n\\nDo a for loop through the array and only count in the green line that is going up, by comparing the two adjacent elements in the array.\\n\\nMany solutions are already posted here. But I think a picture would make things clearer to see.\\n\\n![image](https://assets.leetcode.com/users/hans00/image_1586103419.png)\\n\\n"
                    },
                    {
                        "username": "shashi_singh_18",
                        "content": "I just read the 1st line and my code is accepted. Thanks!!!!!!!!!!!!!!!"
                    },
                    {
                        "username": "introvertCode",
                        "content": "Thank you!"
                    },
                    {
                        "username": "tanushjangid1234",
                        "content": "What a great intuation."
                    },
                    {
                        "username": "glaucusec",
                        "content": "Thanks man. This actually helped a lot"
                    },
                    {
                        "username": "meanup",
                        "content": "`Hint`\\nStill confuse, after seeing the above figure analyse the example 1 and example 2. And it will all make sense. \\nUpvoted! Thank you. "
                    },
                    {
                        "username": "shhung",
                        "content": "It\\'s really simplify the question"
                    },
                    {
                        "username": "mayank-01",
                        "content": "upvoted, thank you for keeping things simple\\uD83D\\uDC4D"
                    },
                    {
                        "username": "falgunitagadkar",
                        "content": "Thanks:)"
                    },
                    {
                        "username": "pranavrocksharma",
                        "content": "what is the meaning of this buying and selling on the same day, profit will be 0 right , so why they highligted in bold, if was selling and then buying on the same day then it would affect on the recurrence but this statement is just added for the sake.\\n\\nAm i wrong or it means something else , i solved assuming we cannot sell and then buy on the same day, we will buy on the next day ."
                    },
                    {
                        "username": "Shaik_Aman_Sayer",
                        "content": "[@Mee_eeM](/Mee_eeM) appreciated dude earned my respect "
                    },
                    {
                        "username": "falgunitagadkar",
                        "content": "[@Dipanshi_26](/Dipanshi_26) The pictorial representation in the above comment has an hint in itself and if you want you can check out my solution.It\\'s not DP solution neither uses Greedy."
                    },
                    {
                        "username": "Dipanshi_26",
                        "content": "I just wanted to ask if this problem can be solved without DP or greedy algorithm because I am new to DSA I have practiced array perfectly. \\nCan you please suggest any othe opproch (hint) without these two approch. "
                    },
                    {
                        "username": "Mee_eeM",
                        "content": "Since you are allow to hold at most one stock at a time it is best to sell it if a lower price comes around. For example on day 1 the price is 7 dollars and day 2 the price is 1 dollar. If you buy on day 1 and sell on 2 you lose money, and you can't buy on day 2 since you've bought on day 1. Allowing you to buy and sell on the same day free up your 1 stock so than you may buy on day 2. Hope this helps."
                    },
                    {
                        "username": "abhijeetkrsingh17",
                        "content": "It is pointless. Even if we think that you sold the stock at higher price and bought new stocks same day as there must be a more higher price than this dates price. then it won\\'t make any difference if you had sold the stocks the next higher day. the diff remains the same."
                    },
                    {
                        "username": "Jeetu_123",
                        "content": "[@godshiva](/godshiva) If u look it as a trader point of view then it is not pointless."
                    },
                    {
                        "username": "itsvishalcodes",
                        "content": "[@sivagowda](/sivagowda) What do you  mean different stock? We are only allowed to hold one stock at a time. So you can only buy on a certain day if you have no stock holdings."
                    },
                    {
                        "username": "sivagowda",
                        "content": "They mean you could sell a stock that you already bought and buy a stock on that day(you could perform buying and selling on the same day of different stocks)"
                    },
                    {
                        "username": "godshiva",
                        "content": "No you\\'re right. You are allowed to do it, but doing so is pointless"
                    },
                    {
                        "username": "Bulbasaur2000",
                        "content": "**Firstly, the second test case explaination might mislead you as it did to me. So, try to avoid that.**\\n\\nLogic: \\nIt is pretty clear that normal brute force approach will take two loops and complexity will become O(n^2). So our objective is to optimise it as far as possible. A **one-pass algorithm** could be used to achieve this optimisation.\\n\\nApproach: \\n1. Initialise a variable(like maxProfit or anything else) which will store the final profit as 0.\\n2. Under a single loop, check for the price which is greater than its previous price. That would be the time when we should sell the stock to earn maximum profit at that instance.\\n3. Add up the profit to the initial variable maxProfit.\\n4. Continue the loop untill it reaches end. Eventually on its way it will keep on checking the profit condition and add up it to your maxProfit.\\n5. Finally return maxProfit.\\n\\nThis approach will take just O(n) time, since only once the entire array is traversed.\\nTry to code it now. Happy Hunting!!! \\n\\n**Do upvote my solution if found useful. It would motivate me furthur and help others.**\\n\\n"
                    },
                    {
                        "username": "bhargav9427",
                        "content": "The most important aspect of any problem is how to arrive at a solution. What should be the thinking process behind it. Lets try to understand how can we reach upto the solution and most important how to convince ourselves that its optimal. Please watch the given solution for this problem as a prerequisite.\\n\\nThe first question after seeing the solution that comes to mind is why is it optimal. Why selecting the immediate peak is the optimal choice. Here is a mathematical understanding for that.\\n\\nConsider this input : [a, ......, b, ......., c....., d]. Where `...` refers to some input in between. a&c are valleys and b&d are peaks.\\n\\nPoints to understand. \\n1) If b&d both are peaks then there has to be some value in between them which is less than b. If not b could not have been a peak because the direct next peak immediate to a will be d.\\n2) If a&c are valleys then there has to be some value in between them which is greater than a. If not a could not have been a valley because the first valley will itself will be c.\\n3) Considering the first two points and assuming that not picking immediate next peak will lead to a better answer. Lets try to prove if we can do that.  \\n\\t\\nIf point 3 is true then we can say that \\n\\t d-a > (b-a) + (d-c)\\ni.e d > b+d-c               but as b-c > 0\\ni.e d > +ve + d            \\n\\nwhich is a false. So we can always say that picking up immediate next peak will always yeild a better result.\\n\\nHope this helps.\\n"
                    },
                    {
                        "username": "anurag_negi123",
                        "content": "nice mathematical proof bro loved it"
                    },
                    {
                        "username": "youssef",
                        "content": "Hello,\\n\\nI'd like to know why the greedy algorithm that takes pairwise profits if they are positive only?\\n\\nThanks"
                    },
                    {
                        "username": "dpeachpeach",
                        "content": "Hi youssef, I recall a greedy-stays-ahead proof similar to this q in one of my college courses but I forgot it so I'm going to try to lay out the logic as well as possible.\n\nLet there be two prices p_a and p_b in the array. where a < b\nLet us say that there is a distance of n => 1 between the two. (Multiple prices in between the two)\n\nThere are two possible cases for the values of p_a in relation to p_b. Either p_b > p_a, which means we would want to buy. or P_b < p_a, which means we wouldn't want to buy.\nLet's ignore the second case because it's trivial and focus on the first.\n\nOk! So we know that we want to buy p_1 so that we can sell at p_2, but there is a distance of n>= 1 between the two, so this leaves uncertainty.\n\nWell, we know for a fact that overall price change across this period in time is going to be p_2 - p_1 or dp\n\nWe also know that price changes are split by days, which means that there are 'positive days' and 'negative days'\n\nAs we stated earlier, p_b > p_a where the distance between the two is n >= 1. if the distance is 1 (they're right next to each other), in what case would you prefer to take a losing bet? :-)\n\nThis is kind of a clever trick (It's a very nonrigorous proof by induction) but here's also a shaky proof by contradiction to help visualize it.\n\nLet us assume that there is an optimal solution where we choose to take a pairwise loss between two prices as opposed to taking a pairwise gain whenever possible.\n\nThis would somehow imply that the pairwise loss allows us to gain more profit than if we had never taken it in the first place. However, due to the allowances of the challenge, we have perfect foresight of the markets. Whenever there is a 'loss' in price, and that price then goes up in the future, we can always profit by taking a profit between the price in the future and the previous price. (If there is a higher price at the end then it must have gotten to that price somehow in increments or totally between two days). By taking a pairwise loss, we are doing nothing but surrendering 'opportunity profit' that we could have made by just doing pairwise purchasing later.\n\nThat's all shaky, but it's been a few months since I've been in class. Good luck!"
                    },
                    {
                        "username": "rushzone",
                        "content": "Judging from my code that has been accepted by the system, I think the limitation of the question is you can only hold 1 stock at most for any time. Which has not been clarified in the question description.\\n\\nFor more complete question and answer to it, in fact case, the money in your account at the beginning is  determined. What you can do is to make maximum profit from this data. During the progress, you can use the profit you made to buy more stock next time."
                    },
                    {
                        "username": "arhankundu99",
                        "content": "I always feel like a noob while encountering these type of questions. I tried for an hour and all I could manage was brute force method optimised with dp. How do you guys come up with such ideas (Like plotting the points and doing summation of peaks(i)-valeys(i)) ?"
                    },
                    {
                        "username": "heyyyankit",
                        "content": "no need to dp or any thing, just iterate on  prices and if you have profit any day, you can sell.. \n............\ncode:-\n\n      int n=prices.size();\n        int ans=0;\n        for(int i=1; i<=n-1; ++i){\n            int diff=prices[i]-prices[i-1];\n            if(diff>0){ans+=diff;}\n        }\n        return ans;"
                    },
                    {
                        "username": "AdityaDipamanggala",
                        "content": "[@Dipanshi_26](/Dipanshi_26) I think the best approach is to realize sum of neighboring peak is >= global peak, so we dont need to do any brute force"
                    },
                    {
                        "username": "AdityaDipamanggala",
                        "content": "Hahah this also exactly what I\\'m facing, turns out I\\'m too over-complicated the logic behind it, once you realize that sum of neighboring peak is always higher than global peak it will be easy "
                    },
                    {
                        "username": "Dipanshi_26",
                        "content": "Can you please give me hint about the approch you mentioned about? I don\\'t know abhout DP still trying to solve thsi problem."
                    },
                    {
                        "username": "shad",
                        "content": "After reading the description I don't understand what a program is supposed to compute to be accepted.\\n\\nI understand the array of prices, but how do I know what the maximum profit is without  knowing how much I can invest initially?  What about selling short before buying any?\\n\\nI guess there aren't any transaction fees to consider, but I don't know why it says I have to sell before I buy - if I'm maximizing profit, aren't I buying as much as I can afford, then selling it all right before it goes down?"
                    },
                    {
                        "username": "Harshsharma12",
                        "content": "https://leetcode.com/problems/best-time-to-buy-and-sell-stock-ii/description/comments/1567200"
                    },
                    {
                        "username": "biller897",
                        "content": "i\\'ll tell you the most basic thing to understand before doing any \"Buy and Sell Stock\" problem :-\\n\\nTake ex :- [1,4,7,8,6,4]\\nif you take (1, 8) , diff = 7\\nor if you take (1, 4), (4, 7), (7, 8), diff = 3 + 3 + 1 = 7\\n\\nGoing directly to 8, or going to 8 by adding all differences in between is same in result, so rather than thinking to jump, think it in this way.\\n"
                    },
                    {
                        "username": "Novarg",
                        "content": "Imagine you were a stock trader and you know the future prices for a given stock (This is the problem input). Each day you would buy the stock if you knew you could sell it tomorrow for a profit (This is the greedy solution)."
                    }
                ]
            },
            {
                "id": 1567199,
                "content": [
                    {
                        "username": "shinxg",
                        "content": "as the topic describle"
                    },
                    {
                        "username": "PeaceRoasted",
                        "content": "This problem is way easier than the first one, how is this medium, both of these should be easy"
                    },
                    {
                        "username": "firezdog",
                        "content": "[@georgezakharov](/georgezakharov) came here to say this -- buy & sell I requires DP, this one doesn\\'t, right?"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "They all say that the problem should be easy until they got it on an interview (c)"
                    },
                    {
                        "username": "user2708P",
                        "content": "I would have imagined it would be medium. If you don\\'t know the solution could you solve it in less than 15 minutes?"
                    },
                    {
                        "username": "Sudo_terminate",
                        "content": "The problem being addressed in section 4.1 of CLRS is very much similar to this one. But when I applied \"maximum subarray\" , solution did not get accepted. I understand that maximum subarray maximizes contiguous sum. But I do not understand how to differentiate this problem from CLRS' problem statement.\\n\\nThanks\\n-------------------\\nupdate: page from the book\\nhttp://postimg.org/image/3ra3baa07/\\n\\nif you are not able to find the page, here is the pdf copy of book\\nhttp://tberg.dk/books/Introduction_to_algorithms_3rd_edition.pdf\\npage 89 (for pdf viewer)\\n(for printed book page no. 68)"
                    },
                    {
                        "username": "JoeNg_03",
                        "content": "Looks like leetcode isnt really friendly towards topdown dp solutions..."
                    },
                    {
                        "username": "faang_engineer4",
                        "content": "**Code snippet is included in the below video**\\n\\n For better understanding, do watch the complete video :) \\n \\n \\n \\n **If you find the code walk-through insightful, please subscribe to my channel !!!** \\n  Thanks & Cheers !!"
                    },
                    {
                        "username": "bhatttt",
                        "content": "the is one statement is miissing in the que content that\\n\"on a same day we can even byu or sell the poduct\"\\n"
                    },
                    {
                        "username": "rosabworkz",
                        "content": "Hi - Can someone explain what is the problem statement? Why are ths solution codes comparing prices on consecutive days only?"
                    },
                    {
                        "username": "ivmarkp",
                        "content": "I'm trying to understand the problem better and just need a little clarification on the problem statement part. Please share what you understood if you've solved this problem already.\\n\\nLet's say if I had a price list like 1, 4, 5, 1, 4. Now, if I buy on day 0 at price 1 and sell it on day 1 at price 4, can I buy on the same day i.e. day 1 after selling the stock and having gained a profit of 3?"
                    },
                    {
                        "username": "ItProgrammist",
                        "content": "<h1> EXPLANATION (With Image): </h1>\n\n In the previous problem \"121. Best Time to Buy and Sell Stock\", we considered at each step the minimum cost of buying a stock, and in future days we selected the maximum cost of selling.\n\n Here the logic is a bit similar: we have to consider all price gains of interest to us by day.\nThe picture below shows gains and losses:\n\n<h1>PICTURE:</h1>\n\n<a href=\"https://assets.leetcode.com/users/images/f1434648-03b1-4fb0-a698-318f05f2c6ee_1689866219.2187672.jpeg\" style=\"color: green;\"> <h2> !!!!! IMAGE HERE !!!!!</h2> </a>\n\n The question may arise: \"Wouldn't it be more profitable to consider at some point the smallest value and sell at the highest price?\".\n\n<b>Answer: Not always. </b>\nSince in the interval between small and large values there may be a descent, where it will be possible to take even more money.\n\n As a result, we summarize all green gains (since we are interested in maximum profit) and return the total amount."
                    }
                ]
            },
            {
                "id": 1885082,
                "content": [
                    {
                        "username": "shinxg",
                        "content": "as the topic describle"
                    },
                    {
                        "username": "PeaceRoasted",
                        "content": "This problem is way easier than the first one, how is this medium, both of these should be easy"
                    },
                    {
                        "username": "firezdog",
                        "content": "[@georgezakharov](/georgezakharov) came here to say this -- buy & sell I requires DP, this one doesn\\'t, right?"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "They all say that the problem should be easy until they got it on an interview (c)"
                    },
                    {
                        "username": "user2708P",
                        "content": "I would have imagined it would be medium. If you don\\'t know the solution could you solve it in less than 15 minutes?"
                    },
                    {
                        "username": "Sudo_terminate",
                        "content": "The problem being addressed in section 4.1 of CLRS is very much similar to this one. But when I applied \"maximum subarray\" , solution did not get accepted. I understand that maximum subarray maximizes contiguous sum. But I do not understand how to differentiate this problem from CLRS' problem statement.\\n\\nThanks\\n-------------------\\nupdate: page from the book\\nhttp://postimg.org/image/3ra3baa07/\\n\\nif you are not able to find the page, here is the pdf copy of book\\nhttp://tberg.dk/books/Introduction_to_algorithms_3rd_edition.pdf\\npage 89 (for pdf viewer)\\n(for printed book page no. 68)"
                    },
                    {
                        "username": "JoeNg_03",
                        "content": "Looks like leetcode isnt really friendly towards topdown dp solutions..."
                    },
                    {
                        "username": "faang_engineer4",
                        "content": "**Code snippet is included in the below video**\\n\\n For better understanding, do watch the complete video :) \\n \\n \\n \\n **If you find the code walk-through insightful, please subscribe to my channel !!!** \\n  Thanks & Cheers !!"
                    },
                    {
                        "username": "bhatttt",
                        "content": "the is one statement is miissing in the que content that\\n\"on a same day we can even byu or sell the poduct\"\\n"
                    },
                    {
                        "username": "rosabworkz",
                        "content": "Hi - Can someone explain what is the problem statement? Why are ths solution codes comparing prices on consecutive days only?"
                    },
                    {
                        "username": "ivmarkp",
                        "content": "I'm trying to understand the problem better and just need a little clarification on the problem statement part. Please share what you understood if you've solved this problem already.\\n\\nLet's say if I had a price list like 1, 4, 5, 1, 4. Now, if I buy on day 0 at price 1 and sell it on day 1 at price 4, can I buy on the same day i.e. day 1 after selling the stock and having gained a profit of 3?"
                    },
                    {
                        "username": "ItProgrammist",
                        "content": "<h1> EXPLANATION (With Image): </h1>\n\n In the previous problem \"121. Best Time to Buy and Sell Stock\", we considered at each step the minimum cost of buying a stock, and in future days we selected the maximum cost of selling.\n\n Here the logic is a bit similar: we have to consider all price gains of interest to us by day.\nThe picture below shows gains and losses:\n\n<h1>PICTURE:</h1>\n\n<a href=\"https://assets.leetcode.com/users/images/f1434648-03b1-4fb0-a698-318f05f2c6ee_1689866219.2187672.jpeg\" style=\"color: green;\"> <h2> !!!!! IMAGE HERE !!!!!</h2> </a>\n\n The question may arise: \"Wouldn't it be more profitable to consider at some point the smallest value and sell at the highest price?\".\n\n<b>Answer: Not always. </b>\nSince in the interval between small and large values there may be a descent, where it will be possible to take even more money.\n\n As a result, we summarize all green gains (since we are interested in maximum profit) and return the total amount."
                    }
                ]
            },
            {
                "id": 1572661,
                "content": [
                    {
                        "username": "shinxg",
                        "content": "as the topic describle"
                    },
                    {
                        "username": "PeaceRoasted",
                        "content": "This problem is way easier than the first one, how is this medium, both of these should be easy"
                    },
                    {
                        "username": "firezdog",
                        "content": "[@georgezakharov](/georgezakharov) came here to say this -- buy & sell I requires DP, this one doesn\\'t, right?"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "They all say that the problem should be easy until they got it on an interview (c)"
                    },
                    {
                        "username": "user2708P",
                        "content": "I would have imagined it would be medium. If you don\\'t know the solution could you solve it in less than 15 minutes?"
                    },
                    {
                        "username": "Sudo_terminate",
                        "content": "The problem being addressed in section 4.1 of CLRS is very much similar to this one. But when I applied \"maximum subarray\" , solution did not get accepted. I understand that maximum subarray maximizes contiguous sum. But I do not understand how to differentiate this problem from CLRS' problem statement.\\n\\nThanks\\n-------------------\\nupdate: page from the book\\nhttp://postimg.org/image/3ra3baa07/\\n\\nif you are not able to find the page, here is the pdf copy of book\\nhttp://tberg.dk/books/Introduction_to_algorithms_3rd_edition.pdf\\npage 89 (for pdf viewer)\\n(for printed book page no. 68)"
                    },
                    {
                        "username": "JoeNg_03",
                        "content": "Looks like leetcode isnt really friendly towards topdown dp solutions..."
                    },
                    {
                        "username": "faang_engineer4",
                        "content": "**Code snippet is included in the below video**\\n\\n For better understanding, do watch the complete video :) \\n \\n \\n \\n **If you find the code walk-through insightful, please subscribe to my channel !!!** \\n  Thanks & Cheers !!"
                    },
                    {
                        "username": "bhatttt",
                        "content": "the is one statement is miissing in the que content that\\n\"on a same day we can even byu or sell the poduct\"\\n"
                    },
                    {
                        "username": "rosabworkz",
                        "content": "Hi - Can someone explain what is the problem statement? Why are ths solution codes comparing prices on consecutive days only?"
                    },
                    {
                        "username": "ivmarkp",
                        "content": "I'm trying to understand the problem better and just need a little clarification on the problem statement part. Please share what you understood if you've solved this problem already.\\n\\nLet's say if I had a price list like 1, 4, 5, 1, 4. Now, if I buy on day 0 at price 1 and sell it on day 1 at price 4, can I buy on the same day i.e. day 1 after selling the stock and having gained a profit of 3?"
                    },
                    {
                        "username": "ItProgrammist",
                        "content": "<h1> EXPLANATION (With Image): </h1>\n\n In the previous problem \"121. Best Time to Buy and Sell Stock\", we considered at each step the minimum cost of buying a stock, and in future days we selected the maximum cost of selling.\n\n Here the logic is a bit similar: we have to consider all price gains of interest to us by day.\nThe picture below shows gains and losses:\n\n<h1>PICTURE:</h1>\n\n<a href=\"https://assets.leetcode.com/users/images/f1434648-03b1-4fb0-a698-318f05f2c6ee_1689866219.2187672.jpeg\" style=\"color: green;\"> <h2> !!!!! IMAGE HERE !!!!!</h2> </a>\n\n The question may arise: \"Wouldn't it be more profitable to consider at some point the smallest value and sell at the highest price?\".\n\n<b>Answer: Not always. </b>\nSince in the interval between small and large values there may be a descent, where it will be possible to take even more money.\n\n As a result, we summarize all green gains (since we are interested in maximum profit) and return the total amount."
                    }
                ]
            },
            {
                "id": 1567869,
                "content": [
                    {
                        "username": "shinxg",
                        "content": "as the topic describle"
                    },
                    {
                        "username": "PeaceRoasted",
                        "content": "This problem is way easier than the first one, how is this medium, both of these should be easy"
                    },
                    {
                        "username": "firezdog",
                        "content": "[@georgezakharov](/georgezakharov) came here to say this -- buy & sell I requires DP, this one doesn\\'t, right?"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "They all say that the problem should be easy until they got it on an interview (c)"
                    },
                    {
                        "username": "user2708P",
                        "content": "I would have imagined it would be medium. If you don\\'t know the solution could you solve it in less than 15 minutes?"
                    },
                    {
                        "username": "Sudo_terminate",
                        "content": "The problem being addressed in section 4.1 of CLRS is very much similar to this one. But when I applied \"maximum subarray\" , solution did not get accepted. I understand that maximum subarray maximizes contiguous sum. But I do not understand how to differentiate this problem from CLRS' problem statement.\\n\\nThanks\\n-------------------\\nupdate: page from the book\\nhttp://postimg.org/image/3ra3baa07/\\n\\nif you are not able to find the page, here is the pdf copy of book\\nhttp://tberg.dk/books/Introduction_to_algorithms_3rd_edition.pdf\\npage 89 (for pdf viewer)\\n(for printed book page no. 68)"
                    },
                    {
                        "username": "JoeNg_03",
                        "content": "Looks like leetcode isnt really friendly towards topdown dp solutions..."
                    },
                    {
                        "username": "faang_engineer4",
                        "content": "**Code snippet is included in the below video**\\n\\n For better understanding, do watch the complete video :) \\n \\n \\n \\n **If you find the code walk-through insightful, please subscribe to my channel !!!** \\n  Thanks & Cheers !!"
                    },
                    {
                        "username": "bhatttt",
                        "content": "the is one statement is miissing in the que content that\\n\"on a same day we can even byu or sell the poduct\"\\n"
                    },
                    {
                        "username": "rosabworkz",
                        "content": "Hi - Can someone explain what is the problem statement? Why are ths solution codes comparing prices on consecutive days only?"
                    },
                    {
                        "username": "ivmarkp",
                        "content": "I'm trying to understand the problem better and just need a little clarification on the problem statement part. Please share what you understood if you've solved this problem already.\\n\\nLet's say if I had a price list like 1, 4, 5, 1, 4. Now, if I buy on day 0 at price 1 and sell it on day 1 at price 4, can I buy on the same day i.e. day 1 after selling the stock and having gained a profit of 3?"
                    },
                    {
                        "username": "ItProgrammist",
                        "content": "<h1> EXPLANATION (With Image): </h1>\n\n In the previous problem \"121. Best Time to Buy and Sell Stock\", we considered at each step the minimum cost of buying a stock, and in future days we selected the maximum cost of selling.\n\n Here the logic is a bit similar: we have to consider all price gains of interest to us by day.\nThe picture below shows gains and losses:\n\n<h1>PICTURE:</h1>\n\n<a href=\"https://assets.leetcode.com/users/images/f1434648-03b1-4fb0-a698-318f05f2c6ee_1689866219.2187672.jpeg\" style=\"color: green;\"> <h2> !!!!! IMAGE HERE !!!!!</h2> </a>\n\n The question may arise: \"Wouldn't it be more profitable to consider at some point the smallest value and sell at the highest price?\".\n\n<b>Answer: Not always. </b>\nSince in the interval between small and large values there may be a descent, where it will be possible to take even more money.\n\n As a result, we summarize all green gains (since we are interested in maximum profit) and return the total amount."
                    }
                ]
            },
            {
                "id": 1576242,
                "content": [
                    {
                        "username": "shinxg",
                        "content": "as the topic describle"
                    },
                    {
                        "username": "PeaceRoasted",
                        "content": "This problem is way easier than the first one, how is this medium, both of these should be easy"
                    },
                    {
                        "username": "firezdog",
                        "content": "[@georgezakharov](/georgezakharov) came here to say this -- buy & sell I requires DP, this one doesn\\'t, right?"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "They all say that the problem should be easy until they got it on an interview (c)"
                    },
                    {
                        "username": "user2708P",
                        "content": "I would have imagined it would be medium. If you don\\'t know the solution could you solve it in less than 15 minutes?"
                    },
                    {
                        "username": "Sudo_terminate",
                        "content": "The problem being addressed in section 4.1 of CLRS is very much similar to this one. But when I applied \"maximum subarray\" , solution did not get accepted. I understand that maximum subarray maximizes contiguous sum. But I do not understand how to differentiate this problem from CLRS' problem statement.\\n\\nThanks\\n-------------------\\nupdate: page from the book\\nhttp://postimg.org/image/3ra3baa07/\\n\\nif you are not able to find the page, here is the pdf copy of book\\nhttp://tberg.dk/books/Introduction_to_algorithms_3rd_edition.pdf\\npage 89 (for pdf viewer)\\n(for printed book page no. 68)"
                    },
                    {
                        "username": "JoeNg_03",
                        "content": "Looks like leetcode isnt really friendly towards topdown dp solutions..."
                    },
                    {
                        "username": "faang_engineer4",
                        "content": "**Code snippet is included in the below video**\\n\\n For better understanding, do watch the complete video :) \\n \\n \\n \\n **If you find the code walk-through insightful, please subscribe to my channel !!!** \\n  Thanks & Cheers !!"
                    },
                    {
                        "username": "bhatttt",
                        "content": "the is one statement is miissing in the que content that\\n\"on a same day we can even byu or sell the poduct\"\\n"
                    },
                    {
                        "username": "rosabworkz",
                        "content": "Hi - Can someone explain what is the problem statement? Why are ths solution codes comparing prices on consecutive days only?"
                    },
                    {
                        "username": "ivmarkp",
                        "content": "I'm trying to understand the problem better and just need a little clarification on the problem statement part. Please share what you understood if you've solved this problem already.\\n\\nLet's say if I had a price list like 1, 4, 5, 1, 4. Now, if I buy on day 0 at price 1 and sell it on day 1 at price 4, can I buy on the same day i.e. day 1 after selling the stock and having gained a profit of 3?"
                    },
                    {
                        "username": "ItProgrammist",
                        "content": "<h1> EXPLANATION (With Image): </h1>\n\n In the previous problem \"121. Best Time to Buy and Sell Stock\", we considered at each step the minimum cost of buying a stock, and in future days we selected the maximum cost of selling.\n\n Here the logic is a bit similar: we have to consider all price gains of interest to us by day.\nThe picture below shows gains and losses:\n\n<h1>PICTURE:</h1>\n\n<a href=\"https://assets.leetcode.com/users/images/f1434648-03b1-4fb0-a698-318f05f2c6ee_1689866219.2187672.jpeg\" style=\"color: green;\"> <h2> !!!!! IMAGE HERE !!!!!</h2> </a>\n\n The question may arise: \"Wouldn't it be more profitable to consider at some point the smallest value and sell at the highest price?\".\n\n<b>Answer: Not always. </b>\nSince in the interval between small and large values there may be a descent, where it will be possible to take even more money.\n\n As a result, we summarize all green gains (since we are interested in maximum profit) and return the total amount."
                    }
                ]
            },
            {
                "id": 1576032,
                "content": [
                    {
                        "username": "shinxg",
                        "content": "as the topic describle"
                    },
                    {
                        "username": "PeaceRoasted",
                        "content": "This problem is way easier than the first one, how is this medium, both of these should be easy"
                    },
                    {
                        "username": "firezdog",
                        "content": "[@georgezakharov](/georgezakharov) came here to say this -- buy & sell I requires DP, this one doesn\\'t, right?"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "They all say that the problem should be easy until they got it on an interview (c)"
                    },
                    {
                        "username": "user2708P",
                        "content": "I would have imagined it would be medium. If you don\\'t know the solution could you solve it in less than 15 minutes?"
                    },
                    {
                        "username": "Sudo_terminate",
                        "content": "The problem being addressed in section 4.1 of CLRS is very much similar to this one. But when I applied \"maximum subarray\" , solution did not get accepted. I understand that maximum subarray maximizes contiguous sum. But I do not understand how to differentiate this problem from CLRS' problem statement.\\n\\nThanks\\n-------------------\\nupdate: page from the book\\nhttp://postimg.org/image/3ra3baa07/\\n\\nif you are not able to find the page, here is the pdf copy of book\\nhttp://tberg.dk/books/Introduction_to_algorithms_3rd_edition.pdf\\npage 89 (for pdf viewer)\\n(for printed book page no. 68)"
                    },
                    {
                        "username": "JoeNg_03",
                        "content": "Looks like leetcode isnt really friendly towards topdown dp solutions..."
                    },
                    {
                        "username": "faang_engineer4",
                        "content": "**Code snippet is included in the below video**\\n\\n For better understanding, do watch the complete video :) \\n \\n \\n \\n **If you find the code walk-through insightful, please subscribe to my channel !!!** \\n  Thanks & Cheers !!"
                    },
                    {
                        "username": "bhatttt",
                        "content": "the is one statement is miissing in the que content that\\n\"on a same day we can even byu or sell the poduct\"\\n"
                    },
                    {
                        "username": "rosabworkz",
                        "content": "Hi - Can someone explain what is the problem statement? Why are ths solution codes comparing prices on consecutive days only?"
                    },
                    {
                        "username": "ivmarkp",
                        "content": "I'm trying to understand the problem better and just need a little clarification on the problem statement part. Please share what you understood if you've solved this problem already.\\n\\nLet's say if I had a price list like 1, 4, 5, 1, 4. Now, if I buy on day 0 at price 1 and sell it on day 1 at price 4, can I buy on the same day i.e. day 1 after selling the stock and having gained a profit of 3?"
                    },
                    {
                        "username": "ItProgrammist",
                        "content": "<h1> EXPLANATION (With Image): </h1>\n\n In the previous problem \"121. Best Time to Buy and Sell Stock\", we considered at each step the minimum cost of buying a stock, and in future days we selected the maximum cost of selling.\n\n Here the logic is a bit similar: we have to consider all price gains of interest to us by day.\nThe picture below shows gains and losses:\n\n<h1>PICTURE:</h1>\n\n<a href=\"https://assets.leetcode.com/users/images/f1434648-03b1-4fb0-a698-318f05f2c6ee_1689866219.2187672.jpeg\" style=\"color: green;\"> <h2> !!!!! IMAGE HERE !!!!!</h2> </a>\n\n The question may arise: \"Wouldn't it be more profitable to consider at some point the smallest value and sell at the highest price?\".\n\n<b>Answer: Not always. </b>\nSince in the interval between small and large values there may be a descent, where it will be possible to take even more money.\n\n As a result, we summarize all green gains (since we are interested in maximum profit) and return the total amount."
                    }
                ]
            },
            {
                "id": 1575751,
                "content": [
                    {
                        "username": "shinxg",
                        "content": "as the topic describle"
                    },
                    {
                        "username": "PeaceRoasted",
                        "content": "This problem is way easier than the first one, how is this medium, both of these should be easy"
                    },
                    {
                        "username": "firezdog",
                        "content": "[@georgezakharov](/georgezakharov) came here to say this -- buy & sell I requires DP, this one doesn\\'t, right?"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "They all say that the problem should be easy until they got it on an interview (c)"
                    },
                    {
                        "username": "user2708P",
                        "content": "I would have imagined it would be medium. If you don\\'t know the solution could you solve it in less than 15 minutes?"
                    },
                    {
                        "username": "Sudo_terminate",
                        "content": "The problem being addressed in section 4.1 of CLRS is very much similar to this one. But when I applied \"maximum subarray\" , solution did not get accepted. I understand that maximum subarray maximizes contiguous sum. But I do not understand how to differentiate this problem from CLRS' problem statement.\\n\\nThanks\\n-------------------\\nupdate: page from the book\\nhttp://postimg.org/image/3ra3baa07/\\n\\nif you are not able to find the page, here is the pdf copy of book\\nhttp://tberg.dk/books/Introduction_to_algorithms_3rd_edition.pdf\\npage 89 (for pdf viewer)\\n(for printed book page no. 68)"
                    },
                    {
                        "username": "JoeNg_03",
                        "content": "Looks like leetcode isnt really friendly towards topdown dp solutions..."
                    },
                    {
                        "username": "faang_engineer4",
                        "content": "**Code snippet is included in the below video**\\n\\n For better understanding, do watch the complete video :) \\n \\n \\n \\n **If you find the code walk-through insightful, please subscribe to my channel !!!** \\n  Thanks & Cheers !!"
                    },
                    {
                        "username": "bhatttt",
                        "content": "the is one statement is miissing in the que content that\\n\"on a same day we can even byu or sell the poduct\"\\n"
                    },
                    {
                        "username": "rosabworkz",
                        "content": "Hi - Can someone explain what is the problem statement? Why are ths solution codes comparing prices on consecutive days only?"
                    },
                    {
                        "username": "ivmarkp",
                        "content": "I'm trying to understand the problem better and just need a little clarification on the problem statement part. Please share what you understood if you've solved this problem already.\\n\\nLet's say if I had a price list like 1, 4, 5, 1, 4. Now, if I buy on day 0 at price 1 and sell it on day 1 at price 4, can I buy on the same day i.e. day 1 after selling the stock and having gained a profit of 3?"
                    },
                    {
                        "username": "ItProgrammist",
                        "content": "<h1> EXPLANATION (With Image): </h1>\n\n In the previous problem \"121. Best Time to Buy and Sell Stock\", we considered at each step the minimum cost of buying a stock, and in future days we selected the maximum cost of selling.\n\n Here the logic is a bit similar: we have to consider all price gains of interest to us by day.\nThe picture below shows gains and losses:\n\n<h1>PICTURE:</h1>\n\n<a href=\"https://assets.leetcode.com/users/images/f1434648-03b1-4fb0-a698-318f05f2c6ee_1689866219.2187672.jpeg\" style=\"color: green;\"> <h2> !!!!! IMAGE HERE !!!!!</h2> </a>\n\n The question may arise: \"Wouldn't it be more profitable to consider at some point the smallest value and sell at the highest price?\".\n\n<b>Answer: Not always. </b>\nSince in the interval between small and large values there may be a descent, where it will be possible to take even more money.\n\n As a result, we summarize all green gains (since we are interested in maximum profit) and return the total amount."
                    }
                ]
            },
            {
                "id": 1572619,
                "content": [
                    {
                        "username": "shinxg",
                        "content": "as the topic describle"
                    },
                    {
                        "username": "PeaceRoasted",
                        "content": "This problem is way easier than the first one, how is this medium, both of these should be easy"
                    },
                    {
                        "username": "firezdog",
                        "content": "[@georgezakharov](/georgezakharov) came here to say this -- buy & sell I requires DP, this one doesn\\'t, right?"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "They all say that the problem should be easy until they got it on an interview (c)"
                    },
                    {
                        "username": "user2708P",
                        "content": "I would have imagined it would be medium. If you don\\'t know the solution could you solve it in less than 15 minutes?"
                    },
                    {
                        "username": "Sudo_terminate",
                        "content": "The problem being addressed in section 4.1 of CLRS is very much similar to this one. But when I applied \"maximum subarray\" , solution did not get accepted. I understand that maximum subarray maximizes contiguous sum. But I do not understand how to differentiate this problem from CLRS' problem statement.\\n\\nThanks\\n-------------------\\nupdate: page from the book\\nhttp://postimg.org/image/3ra3baa07/\\n\\nif you are not able to find the page, here is the pdf copy of book\\nhttp://tberg.dk/books/Introduction_to_algorithms_3rd_edition.pdf\\npage 89 (for pdf viewer)\\n(for printed book page no. 68)"
                    },
                    {
                        "username": "JoeNg_03",
                        "content": "Looks like leetcode isnt really friendly towards topdown dp solutions..."
                    },
                    {
                        "username": "faang_engineer4",
                        "content": "**Code snippet is included in the below video**\\n\\n For better understanding, do watch the complete video :) \\n \\n \\n \\n **If you find the code walk-through insightful, please subscribe to my channel !!!** \\n  Thanks & Cheers !!"
                    },
                    {
                        "username": "bhatttt",
                        "content": "the is one statement is miissing in the que content that\\n\"on a same day we can even byu or sell the poduct\"\\n"
                    },
                    {
                        "username": "rosabworkz",
                        "content": "Hi - Can someone explain what is the problem statement? Why are ths solution codes comparing prices on consecutive days only?"
                    },
                    {
                        "username": "ivmarkp",
                        "content": "I'm trying to understand the problem better and just need a little clarification on the problem statement part. Please share what you understood if you've solved this problem already.\\n\\nLet's say if I had a price list like 1, 4, 5, 1, 4. Now, if I buy on day 0 at price 1 and sell it on day 1 at price 4, can I buy on the same day i.e. day 1 after selling the stock and having gained a profit of 3?"
                    },
                    {
                        "username": "ItProgrammist",
                        "content": "<h1> EXPLANATION (With Image): </h1>\n\n In the previous problem \"121. Best Time to Buy and Sell Stock\", we considered at each step the minimum cost of buying a stock, and in future days we selected the maximum cost of selling.\n\n Here the logic is a bit similar: we have to consider all price gains of interest to us by day.\nThe picture below shows gains and losses:\n\n<h1>PICTURE:</h1>\n\n<a href=\"https://assets.leetcode.com/users/images/f1434648-03b1-4fb0-a698-318f05f2c6ee_1689866219.2187672.jpeg\" style=\"color: green;\"> <h2> !!!!! IMAGE HERE !!!!!</h2> </a>\n\n The question may arise: \"Wouldn't it be more profitable to consider at some point the smallest value and sell at the highest price?\".\n\n<b>Answer: Not always. </b>\nSince in the interval between small and large values there may be a descent, where it will be possible to take even more money.\n\n As a result, we summarize all green gains (since we are interested in maximum profit) and return the total amount."
                    }
                ]
            },
            {
                "id": 1567868,
                "content": [
                    {
                        "username": "shinxg",
                        "content": "as the topic describle"
                    },
                    {
                        "username": "PeaceRoasted",
                        "content": "This problem is way easier than the first one, how is this medium, both of these should be easy"
                    },
                    {
                        "username": "firezdog",
                        "content": "[@georgezakharov](/georgezakharov) came here to say this -- buy & sell I requires DP, this one doesn\\'t, right?"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "They all say that the problem should be easy until they got it on an interview (c)"
                    },
                    {
                        "username": "user2708P",
                        "content": "I would have imagined it would be medium. If you don\\'t know the solution could you solve it in less than 15 minutes?"
                    },
                    {
                        "username": "Sudo_terminate",
                        "content": "The problem being addressed in section 4.1 of CLRS is very much similar to this one. But when I applied \"maximum subarray\" , solution did not get accepted. I understand that maximum subarray maximizes contiguous sum. But I do not understand how to differentiate this problem from CLRS' problem statement.\\n\\nThanks\\n-------------------\\nupdate: page from the book\\nhttp://postimg.org/image/3ra3baa07/\\n\\nif you are not able to find the page, here is the pdf copy of book\\nhttp://tberg.dk/books/Introduction_to_algorithms_3rd_edition.pdf\\npage 89 (for pdf viewer)\\n(for printed book page no. 68)"
                    },
                    {
                        "username": "JoeNg_03",
                        "content": "Looks like leetcode isnt really friendly towards topdown dp solutions..."
                    },
                    {
                        "username": "faang_engineer4",
                        "content": "**Code snippet is included in the below video**\\n\\n For better understanding, do watch the complete video :) \\n \\n \\n \\n **If you find the code walk-through insightful, please subscribe to my channel !!!** \\n  Thanks & Cheers !!"
                    },
                    {
                        "username": "bhatttt",
                        "content": "the is one statement is miissing in the que content that\\n\"on a same day we can even byu or sell the poduct\"\\n"
                    },
                    {
                        "username": "rosabworkz",
                        "content": "Hi - Can someone explain what is the problem statement? Why are ths solution codes comparing prices on consecutive days only?"
                    },
                    {
                        "username": "ivmarkp",
                        "content": "I'm trying to understand the problem better and just need a little clarification on the problem statement part. Please share what you understood if you've solved this problem already.\\n\\nLet's say if I had a price list like 1, 4, 5, 1, 4. Now, if I buy on day 0 at price 1 and sell it on day 1 at price 4, can I buy on the same day i.e. day 1 after selling the stock and having gained a profit of 3?"
                    },
                    {
                        "username": "ItProgrammist",
                        "content": "<h1> EXPLANATION (With Image): </h1>\n\n In the previous problem \"121. Best Time to Buy and Sell Stock\", we considered at each step the minimum cost of buying a stock, and in future days we selected the maximum cost of selling.\n\n Here the logic is a bit similar: we have to consider all price gains of interest to us by day.\nThe picture below shows gains and losses:\n\n<h1>PICTURE:</h1>\n\n<a href=\"https://assets.leetcode.com/users/images/f1434648-03b1-4fb0-a698-318f05f2c6ee_1689866219.2187672.jpeg\" style=\"color: green;\"> <h2> !!!!! IMAGE HERE !!!!!</h2> </a>\n\n The question may arise: \"Wouldn't it be more profitable to consider at some point the smallest value and sell at the highest price?\".\n\n<b>Answer: Not always. </b>\nSince in the interval between small and large values there may be a descent, where it will be possible to take even more money.\n\n As a result, we summarize all green gains (since we are interested in maximum profit) and return the total amount."
                    }
                ]
            },
            {
                "id": 1979433,
                "content": [
                    {
                        "username": "shinxg",
                        "content": "as the topic describle"
                    },
                    {
                        "username": "PeaceRoasted",
                        "content": "This problem is way easier than the first one, how is this medium, both of these should be easy"
                    },
                    {
                        "username": "firezdog",
                        "content": "[@georgezakharov](/georgezakharov) came here to say this -- buy & sell I requires DP, this one doesn\\'t, right?"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "They all say that the problem should be easy until they got it on an interview (c)"
                    },
                    {
                        "username": "user2708P",
                        "content": "I would have imagined it would be medium. If you don\\'t know the solution could you solve it in less than 15 minutes?"
                    },
                    {
                        "username": "Sudo_terminate",
                        "content": "The problem being addressed in section 4.1 of CLRS is very much similar to this one. But when I applied \"maximum subarray\" , solution did not get accepted. I understand that maximum subarray maximizes contiguous sum. But I do not understand how to differentiate this problem from CLRS' problem statement.\\n\\nThanks\\n-------------------\\nupdate: page from the book\\nhttp://postimg.org/image/3ra3baa07/\\n\\nif you are not able to find the page, here is the pdf copy of book\\nhttp://tberg.dk/books/Introduction_to_algorithms_3rd_edition.pdf\\npage 89 (for pdf viewer)\\n(for printed book page no. 68)"
                    },
                    {
                        "username": "JoeNg_03",
                        "content": "Looks like leetcode isnt really friendly towards topdown dp solutions..."
                    },
                    {
                        "username": "faang_engineer4",
                        "content": "**Code snippet is included in the below video**\\n\\n For better understanding, do watch the complete video :) \\n \\n \\n \\n **If you find the code walk-through insightful, please subscribe to my channel !!!** \\n  Thanks & Cheers !!"
                    },
                    {
                        "username": "bhatttt",
                        "content": "the is one statement is miissing in the que content that\\n\"on a same day we can even byu or sell the poduct\"\\n"
                    },
                    {
                        "username": "rosabworkz",
                        "content": "Hi - Can someone explain what is the problem statement? Why are ths solution codes comparing prices on consecutive days only?"
                    },
                    {
                        "username": "ivmarkp",
                        "content": "I'm trying to understand the problem better and just need a little clarification on the problem statement part. Please share what you understood if you've solved this problem already.\\n\\nLet's say if I had a price list like 1, 4, 5, 1, 4. Now, if I buy on day 0 at price 1 and sell it on day 1 at price 4, can I buy on the same day i.e. day 1 after selling the stock and having gained a profit of 3?"
                    },
                    {
                        "username": "ItProgrammist",
                        "content": "<h1> EXPLANATION (With Image): </h1>\n\n In the previous problem \"121. Best Time to Buy and Sell Stock\", we considered at each step the minimum cost of buying a stock, and in future days we selected the maximum cost of selling.\n\n Here the logic is a bit similar: we have to consider all price gains of interest to us by day.\nThe picture below shows gains and losses:\n\n<h1>PICTURE:</h1>\n\n<a href=\"https://assets.leetcode.com/users/images/f1434648-03b1-4fb0-a698-318f05f2c6ee_1689866219.2187672.jpeg\" style=\"color: green;\"> <h2> !!!!! IMAGE HERE !!!!!</h2> </a>\n\n The question may arise: \"Wouldn't it be more profitable to consider at some point the smallest value and sell at the highest price?\".\n\n<b>Answer: Not always. </b>\nSince in the interval between small and large values there may be a descent, where it will be possible to take even more money.\n\n As a result, we summarize all green gains (since we are interested in maximum profit) and return the total amount."
                    }
                ]
            },
            {
                "id": 1941475,
                "content": [
                    {
                        "username": "ElPuercas",
                        "content": "I got confused initially on how to solve, the approach was kinda simple after some thought: \nIf stocks are rising, you buy at beginning of rise. \nIf you hold stock, and you see that stocks will lower, you sell at beginning of lower\n\nThats pretty much it, solution doesn't require much other thinking. Hope this helps someone. "
                    },
                    {
                        "username": "wangkou",
                        "content": "`return sum([prices[i+1] - prices[i] for i in range(len(prices)-1)  if prices[i+1] - prices[i] > 0])`"
                    },
                    {
                        "username": "aogundimu",
                        "content": "It is not clear whether you can look ahead or not. I am looking at the example given, how would you know that the next prices would not be greater than 7?\\n\\nInput: [7,1,5,3,6,4]\\nOutput: 7\\nExplanation: Buy on day 2 (price = 1) and sell on day 3 (price = 5), profit = 5-1 = 4.\\n             Then buy on day 4 (price = 3) and sell on day 5 (price = 6), profit = 6-3 = 3."
                    },
                    {
                        "username": "micahp216",
                        "content": "That\\'s my question. Do we really know what the future \"stock\" prices are? If we do then that changes a lot. From what I can tell, it\\'s assumed that we can look ahead."
                    },
                    {
                        "username": "AlmostSurely",
                        "content": "\\'\\'\\'\\ndef maxProfit(prices):\\n        \\n\\tdiff = [prices[i+1] - prices[i] for i in range(len(prices)-1)]\\n                \\n\\treturn sum([i for i in diff if i>0])\\n\\'\\'\\'"
                    },
                    {
                        "username": "youyou14531",
                        "content": "return sum([ prices[i+1]-prices[i] for i in range(len(prices)-1) if prices[i+1]-prices[i]>0])"
                    },
                    {
                        "username": "suzhongmou",
                        "content": "the input is [6,1,3,2,4,7]\\nin my opnion,the max total is buy when value==1,and sell when value==7, then the max total is 7-1==6.but the web said the answer is 7!"
                    },
                    {
                        "username": "vaishali_p14",
                        "content": "If you buy on day 2 and sell on day 3 then profit=3-1=2.  Next you buy on day 4 and sell on day 5, profit=4-2=2. Now you buy on the same day (day=5) and sell the next day (day=6), profit=7-4=3.\\n\\nTotal profit=2+2+3=7"
                    },
                    {
                        "username": "shi-liang",
                        "content": "I know it's right, my code is accepted. But how to prove this method is mathmetically right ?"
                    },
                    {
                        "username": "leelgangineni",
                        "content": "![image](https://assets.leetcode.com/users/images/0d66f0e5-f9ab-44b1-aaeb-858328e8b479_1644382382.591835.png)\\n"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nBut lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "zg8006",
                        "content": "Why does the input[2,1] has result of 0?\\nShould not the output be 1? Sell stocks at price 2 and rebuy it at price 1?"
                    },
                    {
                        "username": "michikatsu",
                        "content": "Why is 2nd version of this problem considered medium and 1st as easy, i\\'s swap them for sure"
                    }
                ]
            },
            {
                "id": 1574923,
                "content": [
                    {
                        "username": "ElPuercas",
                        "content": "I got confused initially on how to solve, the approach was kinda simple after some thought: \nIf stocks are rising, you buy at beginning of rise. \nIf you hold stock, and you see that stocks will lower, you sell at beginning of lower\n\nThats pretty much it, solution doesn't require much other thinking. Hope this helps someone. "
                    },
                    {
                        "username": "wangkou",
                        "content": "`return sum([prices[i+1] - prices[i] for i in range(len(prices)-1)  if prices[i+1] - prices[i] > 0])`"
                    },
                    {
                        "username": "aogundimu",
                        "content": "It is not clear whether you can look ahead or not. I am looking at the example given, how would you know that the next prices would not be greater than 7?\\n\\nInput: [7,1,5,3,6,4]\\nOutput: 7\\nExplanation: Buy on day 2 (price = 1) and sell on day 3 (price = 5), profit = 5-1 = 4.\\n             Then buy on day 4 (price = 3) and sell on day 5 (price = 6), profit = 6-3 = 3."
                    },
                    {
                        "username": "micahp216",
                        "content": "That\\'s my question. Do we really know what the future \"stock\" prices are? If we do then that changes a lot. From what I can tell, it\\'s assumed that we can look ahead."
                    },
                    {
                        "username": "AlmostSurely",
                        "content": "\\'\\'\\'\\ndef maxProfit(prices):\\n        \\n\\tdiff = [prices[i+1] - prices[i] for i in range(len(prices)-1)]\\n                \\n\\treturn sum([i for i in diff if i>0])\\n\\'\\'\\'"
                    },
                    {
                        "username": "youyou14531",
                        "content": "return sum([ prices[i+1]-prices[i] for i in range(len(prices)-1) if prices[i+1]-prices[i]>0])"
                    },
                    {
                        "username": "suzhongmou",
                        "content": "the input is [6,1,3,2,4,7]\\nin my opnion,the max total is buy when value==1,and sell when value==7, then the max total is 7-1==6.but the web said the answer is 7!"
                    },
                    {
                        "username": "vaishali_p14",
                        "content": "If you buy on day 2 and sell on day 3 then profit=3-1=2.  Next you buy on day 4 and sell on day 5, profit=4-2=2. Now you buy on the same day (day=5) and sell the next day (day=6), profit=7-4=3.\\n\\nTotal profit=2+2+3=7"
                    },
                    {
                        "username": "shi-liang",
                        "content": "I know it's right, my code is accepted. But how to prove this method is mathmetically right ?"
                    },
                    {
                        "username": "leelgangineni",
                        "content": "![image](https://assets.leetcode.com/users/images/0d66f0e5-f9ab-44b1-aaeb-858328e8b479_1644382382.591835.png)\\n"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nBut lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "zg8006",
                        "content": "Why does the input[2,1] has result of 0?\\nShould not the output be 1? Sell stocks at price 2 and rebuy it at price 1?"
                    },
                    {
                        "username": "michikatsu",
                        "content": "Why is 2nd version of this problem considered medium and 1st as easy, i\\'s swap them for sure"
                    }
                ]
            },
            {
                "id": 1574828,
                "content": [
                    {
                        "username": "ElPuercas",
                        "content": "I got confused initially on how to solve, the approach was kinda simple after some thought: \nIf stocks are rising, you buy at beginning of rise. \nIf you hold stock, and you see that stocks will lower, you sell at beginning of lower\n\nThats pretty much it, solution doesn't require much other thinking. Hope this helps someone. "
                    },
                    {
                        "username": "wangkou",
                        "content": "`return sum([prices[i+1] - prices[i] for i in range(len(prices)-1)  if prices[i+1] - prices[i] > 0])`"
                    },
                    {
                        "username": "aogundimu",
                        "content": "It is not clear whether you can look ahead or not. I am looking at the example given, how would you know that the next prices would not be greater than 7?\\n\\nInput: [7,1,5,3,6,4]\\nOutput: 7\\nExplanation: Buy on day 2 (price = 1) and sell on day 3 (price = 5), profit = 5-1 = 4.\\n             Then buy on day 4 (price = 3) and sell on day 5 (price = 6), profit = 6-3 = 3."
                    },
                    {
                        "username": "micahp216",
                        "content": "That\\'s my question. Do we really know what the future \"stock\" prices are? If we do then that changes a lot. From what I can tell, it\\'s assumed that we can look ahead."
                    },
                    {
                        "username": "AlmostSurely",
                        "content": "\\'\\'\\'\\ndef maxProfit(prices):\\n        \\n\\tdiff = [prices[i+1] - prices[i] for i in range(len(prices)-1)]\\n                \\n\\treturn sum([i for i in diff if i>0])\\n\\'\\'\\'"
                    },
                    {
                        "username": "youyou14531",
                        "content": "return sum([ prices[i+1]-prices[i] for i in range(len(prices)-1) if prices[i+1]-prices[i]>0])"
                    },
                    {
                        "username": "suzhongmou",
                        "content": "the input is [6,1,3,2,4,7]\\nin my opnion,the max total is buy when value==1,and sell when value==7, then the max total is 7-1==6.but the web said the answer is 7!"
                    },
                    {
                        "username": "vaishali_p14",
                        "content": "If you buy on day 2 and sell on day 3 then profit=3-1=2.  Next you buy on day 4 and sell on day 5, profit=4-2=2. Now you buy on the same day (day=5) and sell the next day (day=6), profit=7-4=3.\\n\\nTotal profit=2+2+3=7"
                    },
                    {
                        "username": "shi-liang",
                        "content": "I know it's right, my code is accepted. But how to prove this method is mathmetically right ?"
                    },
                    {
                        "username": "leelgangineni",
                        "content": "![image](https://assets.leetcode.com/users/images/0d66f0e5-f9ab-44b1-aaeb-858328e8b479_1644382382.591835.png)\\n"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nBut lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "zg8006",
                        "content": "Why does the input[2,1] has result of 0?\\nShould not the output be 1? Sell stocks at price 2 and rebuy it at price 1?"
                    },
                    {
                        "username": "michikatsu",
                        "content": "Why is 2nd version of this problem considered medium and 1st as easy, i\\'s swap them for sure"
                    }
                ]
            },
            {
                "id": 1573213,
                "content": [
                    {
                        "username": "ElPuercas",
                        "content": "I got confused initially on how to solve, the approach was kinda simple after some thought: \nIf stocks are rising, you buy at beginning of rise. \nIf you hold stock, and you see that stocks will lower, you sell at beginning of lower\n\nThats pretty much it, solution doesn't require much other thinking. Hope this helps someone. "
                    },
                    {
                        "username": "wangkou",
                        "content": "`return sum([prices[i+1] - prices[i] for i in range(len(prices)-1)  if prices[i+1] - prices[i] > 0])`"
                    },
                    {
                        "username": "aogundimu",
                        "content": "It is not clear whether you can look ahead or not. I am looking at the example given, how would you know that the next prices would not be greater than 7?\\n\\nInput: [7,1,5,3,6,4]\\nOutput: 7\\nExplanation: Buy on day 2 (price = 1) and sell on day 3 (price = 5), profit = 5-1 = 4.\\n             Then buy on day 4 (price = 3) and sell on day 5 (price = 6), profit = 6-3 = 3."
                    },
                    {
                        "username": "micahp216",
                        "content": "That\\'s my question. Do we really know what the future \"stock\" prices are? If we do then that changes a lot. From what I can tell, it\\'s assumed that we can look ahead."
                    },
                    {
                        "username": "AlmostSurely",
                        "content": "\\'\\'\\'\\ndef maxProfit(prices):\\n        \\n\\tdiff = [prices[i+1] - prices[i] for i in range(len(prices)-1)]\\n                \\n\\treturn sum([i for i in diff if i>0])\\n\\'\\'\\'"
                    },
                    {
                        "username": "youyou14531",
                        "content": "return sum([ prices[i+1]-prices[i] for i in range(len(prices)-1) if prices[i+1]-prices[i]>0])"
                    },
                    {
                        "username": "suzhongmou",
                        "content": "the input is [6,1,3,2,4,7]\\nin my opnion,the max total is buy when value==1,and sell when value==7, then the max total is 7-1==6.but the web said the answer is 7!"
                    },
                    {
                        "username": "vaishali_p14",
                        "content": "If you buy on day 2 and sell on day 3 then profit=3-1=2.  Next you buy on day 4 and sell on day 5, profit=4-2=2. Now you buy on the same day (day=5) and sell the next day (day=6), profit=7-4=3.\\n\\nTotal profit=2+2+3=7"
                    },
                    {
                        "username": "shi-liang",
                        "content": "I know it's right, my code is accepted. But how to prove this method is mathmetically right ?"
                    },
                    {
                        "username": "leelgangineni",
                        "content": "![image](https://assets.leetcode.com/users/images/0d66f0e5-f9ab-44b1-aaeb-858328e8b479_1644382382.591835.png)\\n"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nBut lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "zg8006",
                        "content": "Why does the input[2,1] has result of 0?\\nShould not the output be 1? Sell stocks at price 2 and rebuy it at price 1?"
                    },
                    {
                        "username": "michikatsu",
                        "content": "Why is 2nd version of this problem considered medium and 1st as easy, i\\'s swap them for sure"
                    }
                ]
            },
            {
                "id": 1572278,
                "content": [
                    {
                        "username": "ElPuercas",
                        "content": "I got confused initially on how to solve, the approach was kinda simple after some thought: \nIf stocks are rising, you buy at beginning of rise. \nIf you hold stock, and you see that stocks will lower, you sell at beginning of lower\n\nThats pretty much it, solution doesn't require much other thinking. Hope this helps someone. "
                    },
                    {
                        "username": "wangkou",
                        "content": "`return sum([prices[i+1] - prices[i] for i in range(len(prices)-1)  if prices[i+1] - prices[i] > 0])`"
                    },
                    {
                        "username": "aogundimu",
                        "content": "It is not clear whether you can look ahead or not. I am looking at the example given, how would you know that the next prices would not be greater than 7?\\n\\nInput: [7,1,5,3,6,4]\\nOutput: 7\\nExplanation: Buy on day 2 (price = 1) and sell on day 3 (price = 5), profit = 5-1 = 4.\\n             Then buy on day 4 (price = 3) and sell on day 5 (price = 6), profit = 6-3 = 3."
                    },
                    {
                        "username": "micahp216",
                        "content": "That\\'s my question. Do we really know what the future \"stock\" prices are? If we do then that changes a lot. From what I can tell, it\\'s assumed that we can look ahead."
                    },
                    {
                        "username": "AlmostSurely",
                        "content": "\\'\\'\\'\\ndef maxProfit(prices):\\n        \\n\\tdiff = [prices[i+1] - prices[i] for i in range(len(prices)-1)]\\n                \\n\\treturn sum([i for i in diff if i>0])\\n\\'\\'\\'"
                    },
                    {
                        "username": "youyou14531",
                        "content": "return sum([ prices[i+1]-prices[i] for i in range(len(prices)-1) if prices[i+1]-prices[i]>0])"
                    },
                    {
                        "username": "suzhongmou",
                        "content": "the input is [6,1,3,2,4,7]\\nin my opnion,the max total is buy when value==1,and sell when value==7, then the max total is 7-1==6.but the web said the answer is 7!"
                    },
                    {
                        "username": "vaishali_p14",
                        "content": "If you buy on day 2 and sell on day 3 then profit=3-1=2.  Next you buy on day 4 and sell on day 5, profit=4-2=2. Now you buy on the same day (day=5) and sell the next day (day=6), profit=7-4=3.\\n\\nTotal profit=2+2+3=7"
                    },
                    {
                        "username": "shi-liang",
                        "content": "I know it's right, my code is accepted. But how to prove this method is mathmetically right ?"
                    },
                    {
                        "username": "leelgangineni",
                        "content": "![image](https://assets.leetcode.com/users/images/0d66f0e5-f9ab-44b1-aaeb-858328e8b479_1644382382.591835.png)\\n"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nBut lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "zg8006",
                        "content": "Why does the input[2,1] has result of 0?\\nShould not the output be 1? Sell stocks at price 2 and rebuy it at price 1?"
                    },
                    {
                        "username": "michikatsu",
                        "content": "Why is 2nd version of this problem considered medium and 1st as easy, i\\'s swap them for sure"
                    }
                ]
            },
            {
                "id": 1571254,
                "content": [
                    {
                        "username": "ElPuercas",
                        "content": "I got confused initially on how to solve, the approach was kinda simple after some thought: \nIf stocks are rising, you buy at beginning of rise. \nIf you hold stock, and you see that stocks will lower, you sell at beginning of lower\n\nThats pretty much it, solution doesn't require much other thinking. Hope this helps someone. "
                    },
                    {
                        "username": "wangkou",
                        "content": "`return sum([prices[i+1] - prices[i] for i in range(len(prices)-1)  if prices[i+1] - prices[i] > 0])`"
                    },
                    {
                        "username": "aogundimu",
                        "content": "It is not clear whether you can look ahead or not. I am looking at the example given, how would you know that the next prices would not be greater than 7?\\n\\nInput: [7,1,5,3,6,4]\\nOutput: 7\\nExplanation: Buy on day 2 (price = 1) and sell on day 3 (price = 5), profit = 5-1 = 4.\\n             Then buy on day 4 (price = 3) and sell on day 5 (price = 6), profit = 6-3 = 3."
                    },
                    {
                        "username": "micahp216",
                        "content": "That\\'s my question. Do we really know what the future \"stock\" prices are? If we do then that changes a lot. From what I can tell, it\\'s assumed that we can look ahead."
                    },
                    {
                        "username": "AlmostSurely",
                        "content": "\\'\\'\\'\\ndef maxProfit(prices):\\n        \\n\\tdiff = [prices[i+1] - prices[i] for i in range(len(prices)-1)]\\n                \\n\\treturn sum([i for i in diff if i>0])\\n\\'\\'\\'"
                    },
                    {
                        "username": "youyou14531",
                        "content": "return sum([ prices[i+1]-prices[i] for i in range(len(prices)-1) if prices[i+1]-prices[i]>0])"
                    },
                    {
                        "username": "suzhongmou",
                        "content": "the input is [6,1,3,2,4,7]\\nin my opnion,the max total is buy when value==1,and sell when value==7, then the max total is 7-1==6.but the web said the answer is 7!"
                    },
                    {
                        "username": "vaishali_p14",
                        "content": "If you buy on day 2 and sell on day 3 then profit=3-1=2.  Next you buy on day 4 and sell on day 5, profit=4-2=2. Now you buy on the same day (day=5) and sell the next day (day=6), profit=7-4=3.\\n\\nTotal profit=2+2+3=7"
                    },
                    {
                        "username": "shi-liang",
                        "content": "I know it's right, my code is accepted. But how to prove this method is mathmetically right ?"
                    },
                    {
                        "username": "leelgangineni",
                        "content": "![image](https://assets.leetcode.com/users/images/0d66f0e5-f9ab-44b1-aaeb-858328e8b479_1644382382.591835.png)\\n"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nBut lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "zg8006",
                        "content": "Why does the input[2,1] has result of 0?\\nShould not the output be 1? Sell stocks at price 2 and rebuy it at price 1?"
                    },
                    {
                        "username": "michikatsu",
                        "content": "Why is 2nd version of this problem considered medium and 1st as easy, i\\'s swap them for sure"
                    }
                ]
            },
            {
                "id": 1571252,
                "content": [
                    {
                        "username": "ElPuercas",
                        "content": "I got confused initially on how to solve, the approach was kinda simple after some thought: \nIf stocks are rising, you buy at beginning of rise. \nIf you hold stock, and you see that stocks will lower, you sell at beginning of lower\n\nThats pretty much it, solution doesn't require much other thinking. Hope this helps someone. "
                    },
                    {
                        "username": "wangkou",
                        "content": "`return sum([prices[i+1] - prices[i] for i in range(len(prices)-1)  if prices[i+1] - prices[i] > 0])`"
                    },
                    {
                        "username": "aogundimu",
                        "content": "It is not clear whether you can look ahead or not. I am looking at the example given, how would you know that the next prices would not be greater than 7?\\n\\nInput: [7,1,5,3,6,4]\\nOutput: 7\\nExplanation: Buy on day 2 (price = 1) and sell on day 3 (price = 5), profit = 5-1 = 4.\\n             Then buy on day 4 (price = 3) and sell on day 5 (price = 6), profit = 6-3 = 3."
                    },
                    {
                        "username": "micahp216",
                        "content": "That\\'s my question. Do we really know what the future \"stock\" prices are? If we do then that changes a lot. From what I can tell, it\\'s assumed that we can look ahead."
                    },
                    {
                        "username": "AlmostSurely",
                        "content": "\\'\\'\\'\\ndef maxProfit(prices):\\n        \\n\\tdiff = [prices[i+1] - prices[i] for i in range(len(prices)-1)]\\n                \\n\\treturn sum([i for i in diff if i>0])\\n\\'\\'\\'"
                    },
                    {
                        "username": "youyou14531",
                        "content": "return sum([ prices[i+1]-prices[i] for i in range(len(prices)-1) if prices[i+1]-prices[i]>0])"
                    },
                    {
                        "username": "suzhongmou",
                        "content": "the input is [6,1,3,2,4,7]\\nin my opnion,the max total is buy when value==1,and sell when value==7, then the max total is 7-1==6.but the web said the answer is 7!"
                    },
                    {
                        "username": "vaishali_p14",
                        "content": "If you buy on day 2 and sell on day 3 then profit=3-1=2.  Next you buy on day 4 and sell on day 5, profit=4-2=2. Now you buy on the same day (day=5) and sell the next day (day=6), profit=7-4=3.\\n\\nTotal profit=2+2+3=7"
                    },
                    {
                        "username": "shi-liang",
                        "content": "I know it's right, my code is accepted. But how to prove this method is mathmetically right ?"
                    },
                    {
                        "username": "leelgangineni",
                        "content": "![image](https://assets.leetcode.com/users/images/0d66f0e5-f9ab-44b1-aaeb-858328e8b479_1644382382.591835.png)\\n"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nBut lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "zg8006",
                        "content": "Why does the input[2,1] has result of 0?\\nShould not the output be 1? Sell stocks at price 2 and rebuy it at price 1?"
                    },
                    {
                        "username": "michikatsu",
                        "content": "Why is 2nd version of this problem considered medium and 1st as easy, i\\'s swap them for sure"
                    }
                ]
            },
            {
                "id": 1570794,
                "content": [
                    {
                        "username": "ElPuercas",
                        "content": "I got confused initially on how to solve, the approach was kinda simple after some thought: \nIf stocks are rising, you buy at beginning of rise. \nIf you hold stock, and you see that stocks will lower, you sell at beginning of lower\n\nThats pretty much it, solution doesn't require much other thinking. Hope this helps someone. "
                    },
                    {
                        "username": "wangkou",
                        "content": "`return sum([prices[i+1] - prices[i] for i in range(len(prices)-1)  if prices[i+1] - prices[i] > 0])`"
                    },
                    {
                        "username": "aogundimu",
                        "content": "It is not clear whether you can look ahead or not. I am looking at the example given, how would you know that the next prices would not be greater than 7?\\n\\nInput: [7,1,5,3,6,4]\\nOutput: 7\\nExplanation: Buy on day 2 (price = 1) and sell on day 3 (price = 5), profit = 5-1 = 4.\\n             Then buy on day 4 (price = 3) and sell on day 5 (price = 6), profit = 6-3 = 3."
                    },
                    {
                        "username": "micahp216",
                        "content": "That\\'s my question. Do we really know what the future \"stock\" prices are? If we do then that changes a lot. From what I can tell, it\\'s assumed that we can look ahead."
                    },
                    {
                        "username": "AlmostSurely",
                        "content": "\\'\\'\\'\\ndef maxProfit(prices):\\n        \\n\\tdiff = [prices[i+1] - prices[i] for i in range(len(prices)-1)]\\n                \\n\\treturn sum([i for i in diff if i>0])\\n\\'\\'\\'"
                    },
                    {
                        "username": "youyou14531",
                        "content": "return sum([ prices[i+1]-prices[i] for i in range(len(prices)-1) if prices[i+1]-prices[i]>0])"
                    },
                    {
                        "username": "suzhongmou",
                        "content": "the input is [6,1,3,2,4,7]\\nin my opnion,the max total is buy when value==1,and sell when value==7, then the max total is 7-1==6.but the web said the answer is 7!"
                    },
                    {
                        "username": "vaishali_p14",
                        "content": "If you buy on day 2 and sell on day 3 then profit=3-1=2.  Next you buy on day 4 and sell on day 5, profit=4-2=2. Now you buy on the same day (day=5) and sell the next day (day=6), profit=7-4=3.\\n\\nTotal profit=2+2+3=7"
                    },
                    {
                        "username": "shi-liang",
                        "content": "I know it's right, my code is accepted. But how to prove this method is mathmetically right ?"
                    },
                    {
                        "username": "leelgangineni",
                        "content": "![image](https://assets.leetcode.com/users/images/0d66f0e5-f9ab-44b1-aaeb-858328e8b479_1644382382.591835.png)\\n"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nBut lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "zg8006",
                        "content": "Why does the input[2,1] has result of 0?\\nShould not the output be 1? Sell stocks at price 2 and rebuy it at price 1?"
                    },
                    {
                        "username": "michikatsu",
                        "content": "Why is 2nd version of this problem considered medium and 1st as easy, i\\'s swap them for sure"
                    }
                ]
            },
            {
                "id": 1567870,
                "content": [
                    {
                        "username": "ElPuercas",
                        "content": "I got confused initially on how to solve, the approach was kinda simple after some thought: \nIf stocks are rising, you buy at beginning of rise. \nIf you hold stock, and you see that stocks will lower, you sell at beginning of lower\n\nThats pretty much it, solution doesn't require much other thinking. Hope this helps someone. "
                    },
                    {
                        "username": "wangkou",
                        "content": "`return sum([prices[i+1] - prices[i] for i in range(len(prices)-1)  if prices[i+1] - prices[i] > 0])`"
                    },
                    {
                        "username": "aogundimu",
                        "content": "It is not clear whether you can look ahead or not. I am looking at the example given, how would you know that the next prices would not be greater than 7?\\n\\nInput: [7,1,5,3,6,4]\\nOutput: 7\\nExplanation: Buy on day 2 (price = 1) and sell on day 3 (price = 5), profit = 5-1 = 4.\\n             Then buy on day 4 (price = 3) and sell on day 5 (price = 6), profit = 6-3 = 3."
                    },
                    {
                        "username": "micahp216",
                        "content": "That\\'s my question. Do we really know what the future \"stock\" prices are? If we do then that changes a lot. From what I can tell, it\\'s assumed that we can look ahead."
                    },
                    {
                        "username": "AlmostSurely",
                        "content": "\\'\\'\\'\\ndef maxProfit(prices):\\n        \\n\\tdiff = [prices[i+1] - prices[i] for i in range(len(prices)-1)]\\n                \\n\\treturn sum([i for i in diff if i>0])\\n\\'\\'\\'"
                    },
                    {
                        "username": "youyou14531",
                        "content": "return sum([ prices[i+1]-prices[i] for i in range(len(prices)-1) if prices[i+1]-prices[i]>0])"
                    },
                    {
                        "username": "suzhongmou",
                        "content": "the input is [6,1,3,2,4,7]\\nin my opnion,the max total is buy when value==1,and sell when value==7, then the max total is 7-1==6.but the web said the answer is 7!"
                    },
                    {
                        "username": "vaishali_p14",
                        "content": "If you buy on day 2 and sell on day 3 then profit=3-1=2.  Next you buy on day 4 and sell on day 5, profit=4-2=2. Now you buy on the same day (day=5) and sell the next day (day=6), profit=7-4=3.\\n\\nTotal profit=2+2+3=7"
                    },
                    {
                        "username": "shi-liang",
                        "content": "I know it's right, my code is accepted. But how to prove this method is mathmetically right ?"
                    },
                    {
                        "username": "leelgangineni",
                        "content": "![image](https://assets.leetcode.com/users/images/0d66f0e5-f9ab-44b1-aaeb-858328e8b479_1644382382.591835.png)\\n"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nBut lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "zg8006",
                        "content": "Why does the input[2,1] has result of 0?\\nShould not the output be 1? Sell stocks at price 2 and rebuy it at price 1?"
                    },
                    {
                        "username": "michikatsu",
                        "content": "Why is 2nd version of this problem considered medium and 1st as easy, i\\'s swap them for sure"
                    }
                ]
            },
            {
                "id": 2075996,
                "content": [
                    {
                        "username": "ElPuercas",
                        "content": "I got confused initially on how to solve, the approach was kinda simple after some thought: \nIf stocks are rising, you buy at beginning of rise. \nIf you hold stock, and you see that stocks will lower, you sell at beginning of lower\n\nThats pretty much it, solution doesn't require much other thinking. Hope this helps someone. "
                    },
                    {
                        "username": "wangkou",
                        "content": "`return sum([prices[i+1] - prices[i] for i in range(len(prices)-1)  if prices[i+1] - prices[i] > 0])`"
                    },
                    {
                        "username": "aogundimu",
                        "content": "It is not clear whether you can look ahead or not. I am looking at the example given, how would you know that the next prices would not be greater than 7?\\n\\nInput: [7,1,5,3,6,4]\\nOutput: 7\\nExplanation: Buy on day 2 (price = 1) and sell on day 3 (price = 5), profit = 5-1 = 4.\\n             Then buy on day 4 (price = 3) and sell on day 5 (price = 6), profit = 6-3 = 3."
                    },
                    {
                        "username": "micahp216",
                        "content": "That\\'s my question. Do we really know what the future \"stock\" prices are? If we do then that changes a lot. From what I can tell, it\\'s assumed that we can look ahead."
                    },
                    {
                        "username": "AlmostSurely",
                        "content": "\\'\\'\\'\\ndef maxProfit(prices):\\n        \\n\\tdiff = [prices[i+1] - prices[i] for i in range(len(prices)-1)]\\n                \\n\\treturn sum([i for i in diff if i>0])\\n\\'\\'\\'"
                    },
                    {
                        "username": "youyou14531",
                        "content": "return sum([ prices[i+1]-prices[i] for i in range(len(prices)-1) if prices[i+1]-prices[i]>0])"
                    },
                    {
                        "username": "suzhongmou",
                        "content": "the input is [6,1,3,2,4,7]\\nin my opnion,the max total is buy when value==1,and sell when value==7, then the max total is 7-1==6.but the web said the answer is 7!"
                    },
                    {
                        "username": "vaishali_p14",
                        "content": "If you buy on day 2 and sell on day 3 then profit=3-1=2.  Next you buy on day 4 and sell on day 5, profit=4-2=2. Now you buy on the same day (day=5) and sell the next day (day=6), profit=7-4=3.\\n\\nTotal profit=2+2+3=7"
                    },
                    {
                        "username": "shi-liang",
                        "content": "I know it's right, my code is accepted. But how to prove this method is mathmetically right ?"
                    },
                    {
                        "username": "leelgangineni",
                        "content": "![image](https://assets.leetcode.com/users/images/0d66f0e5-f9ab-44b1-aaeb-858328e8b479_1644382382.591835.png)\\n"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nBut lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "zg8006",
                        "content": "Why does the input[2,1] has result of 0?\\nShould not the output be 1? Sell stocks at price 2 and rebuy it at price 1?"
                    },
                    {
                        "username": "michikatsu",
                        "content": "Why is 2nd version of this problem considered medium and 1st as easy, i\\'s swap them for sure"
                    }
                ]
            },
            {
                "id": 2066818,
                "content": [
                    {
                        "username": "HalfAPum",
                        "content": "Lol) \"Best Time to Buy and Sell Stock I\" was harder that this one"
                    },
                    {
                        "username": "Kenzie7",
                        "content": "I thought the wording \"maximum profit\" means we have to always find the largest sell prices in the index range of [buy_index +1:], and then we have to start choosing the buying at the index of [sell+1]. I DID NOT EXPECT TO SELL EVERY TIME IT\\'S HIGHER THAN THE BUYING PRICE!"
                    },
                    {
                        "username": "AdityaGoswami",
                        "content": "this line-\"However, you can buy it then immediately sell it on the same day\" makes the question with simpler answer makes it even more confusing"
                    },
                    {
                        "username": "Obaid07",
                        "content": "Try to avoid the Second test case , it\\'s misleading. "
                    },
                    {
                        "username": "benjelplan",
                        "content": "The problem doesn\\'t state whether you are allowed to sell and then buy on the same day (unless I\\'m missing something)"
                    },
                    {
                        "username": "harenbrs",
                        "content": "The performance measurements are so off here."
                    },
                    {
                        "username": "Harsha30ywffb",
                        "content": "who the hell are still trying it using stack like me . literally how these people are getting these optimised ideas."
                    },
                    {
                        "username": "bvchnguyen",
                        "content": "The differences between I and II should not warrant a change in level of difficulty imo. "
                    },
                    {
                        "username": "utalmighty",
                        "content": "Explore all the possibilities: \\n*We can buy and then sell. So, firstly we have to buy* `f(0, Buy)`\\n\\n- **Buy Possibilities**: \\n1. Buy current item `f(indx, Buy) - price[indx]` (if buying subtract the price as we are giving out the money)\\n2. Buy later `f(indx+1, Buy)`\\n \\n- **Sell Possibilities** : \\n\\n1. Sell current item and go to next for buying `price[indx]+f(indx+1, Buy)` (if selling add price as we are getting money)\\n2. Sell later `f(indx+1, Sell)`"
                    },
                    {
                        "username": "debugraghav",
                        "content": "hihi"
                    }
                ]
            },
            {
                "id": 2066047,
                "content": [
                    {
                        "username": "HalfAPum",
                        "content": "Lol) \"Best Time to Buy and Sell Stock I\" was harder that this one"
                    },
                    {
                        "username": "Kenzie7",
                        "content": "I thought the wording \"maximum profit\" means we have to always find the largest sell prices in the index range of [buy_index +1:], and then we have to start choosing the buying at the index of [sell+1]. I DID NOT EXPECT TO SELL EVERY TIME IT\\'S HIGHER THAN THE BUYING PRICE!"
                    },
                    {
                        "username": "AdityaGoswami",
                        "content": "this line-\"However, you can buy it then immediately sell it on the same day\" makes the question with simpler answer makes it even more confusing"
                    },
                    {
                        "username": "Obaid07",
                        "content": "Try to avoid the Second test case , it\\'s misleading. "
                    },
                    {
                        "username": "benjelplan",
                        "content": "The problem doesn\\'t state whether you are allowed to sell and then buy on the same day (unless I\\'m missing something)"
                    },
                    {
                        "username": "harenbrs",
                        "content": "The performance measurements are so off here."
                    },
                    {
                        "username": "Harsha30ywffb",
                        "content": "who the hell are still trying it using stack like me . literally how these people are getting these optimised ideas."
                    },
                    {
                        "username": "bvchnguyen",
                        "content": "The differences between I and II should not warrant a change in level of difficulty imo. "
                    },
                    {
                        "username": "utalmighty",
                        "content": "Explore all the possibilities: \\n*We can buy and then sell. So, firstly we have to buy* `f(0, Buy)`\\n\\n- **Buy Possibilities**: \\n1. Buy current item `f(indx, Buy) - price[indx]` (if buying subtract the price as we are giving out the money)\\n2. Buy later `f(indx+1, Buy)`\\n \\n- **Sell Possibilities** : \\n\\n1. Sell current item and go to next for buying `price[indx]+f(indx+1, Buy)` (if selling add price as we are getting money)\\n2. Sell later `f(indx+1, Sell)`"
                    },
                    {
                        "username": "debugraghav",
                        "content": "hihi"
                    }
                ]
            },
            {
                "id": 2064376,
                "content": [
                    {
                        "username": "HalfAPum",
                        "content": "Lol) \"Best Time to Buy and Sell Stock I\" was harder that this one"
                    },
                    {
                        "username": "Kenzie7",
                        "content": "I thought the wording \"maximum profit\" means we have to always find the largest sell prices in the index range of [buy_index +1:], and then we have to start choosing the buying at the index of [sell+1]. I DID NOT EXPECT TO SELL EVERY TIME IT\\'S HIGHER THAN THE BUYING PRICE!"
                    },
                    {
                        "username": "AdityaGoswami",
                        "content": "this line-\"However, you can buy it then immediately sell it on the same day\" makes the question with simpler answer makes it even more confusing"
                    },
                    {
                        "username": "Obaid07",
                        "content": "Try to avoid the Second test case , it\\'s misleading. "
                    },
                    {
                        "username": "benjelplan",
                        "content": "The problem doesn\\'t state whether you are allowed to sell and then buy on the same day (unless I\\'m missing something)"
                    },
                    {
                        "username": "harenbrs",
                        "content": "The performance measurements are so off here."
                    },
                    {
                        "username": "Harsha30ywffb",
                        "content": "who the hell are still trying it using stack like me . literally how these people are getting these optimised ideas."
                    },
                    {
                        "username": "bvchnguyen",
                        "content": "The differences between I and II should not warrant a change in level of difficulty imo. "
                    },
                    {
                        "username": "utalmighty",
                        "content": "Explore all the possibilities: \\n*We can buy and then sell. So, firstly we have to buy* `f(0, Buy)`\\n\\n- **Buy Possibilities**: \\n1. Buy current item `f(indx, Buy) - price[indx]` (if buying subtract the price as we are giving out the money)\\n2. Buy later `f(indx+1, Buy)`\\n \\n- **Sell Possibilities** : \\n\\n1. Sell current item and go to next for buying `price[indx]+f(indx+1, Buy)` (if selling add price as we are getting money)\\n2. Sell later `f(indx+1, Sell)`"
                    },
                    {
                        "username": "debugraghav",
                        "content": "hihi"
                    }
                ]
            },
            {
                "id": 2064080,
                "content": [
                    {
                        "username": "HalfAPum",
                        "content": "Lol) \"Best Time to Buy and Sell Stock I\" was harder that this one"
                    },
                    {
                        "username": "Kenzie7",
                        "content": "I thought the wording \"maximum profit\" means we have to always find the largest sell prices in the index range of [buy_index +1:], and then we have to start choosing the buying at the index of [sell+1]. I DID NOT EXPECT TO SELL EVERY TIME IT\\'S HIGHER THAN THE BUYING PRICE!"
                    },
                    {
                        "username": "AdityaGoswami",
                        "content": "this line-\"However, you can buy it then immediately sell it on the same day\" makes the question with simpler answer makes it even more confusing"
                    },
                    {
                        "username": "Obaid07",
                        "content": "Try to avoid the Second test case , it\\'s misleading. "
                    },
                    {
                        "username": "benjelplan",
                        "content": "The problem doesn\\'t state whether you are allowed to sell and then buy on the same day (unless I\\'m missing something)"
                    },
                    {
                        "username": "harenbrs",
                        "content": "The performance measurements are so off here."
                    },
                    {
                        "username": "Harsha30ywffb",
                        "content": "who the hell are still trying it using stack like me . literally how these people are getting these optimised ideas."
                    },
                    {
                        "username": "bvchnguyen",
                        "content": "The differences between I and II should not warrant a change in level of difficulty imo. "
                    },
                    {
                        "username": "utalmighty",
                        "content": "Explore all the possibilities: \\n*We can buy and then sell. So, firstly we have to buy* `f(0, Buy)`\\n\\n- **Buy Possibilities**: \\n1. Buy current item `f(indx, Buy) - price[indx]` (if buying subtract the price as we are giving out the money)\\n2. Buy later `f(indx+1, Buy)`\\n \\n- **Sell Possibilities** : \\n\\n1. Sell current item and go to next for buying `price[indx]+f(indx+1, Buy)` (if selling add price as we are getting money)\\n2. Sell later `f(indx+1, Sell)`"
                    },
                    {
                        "username": "debugraghav",
                        "content": "hihi"
                    }
                ]
            },
            {
                "id": 2059765,
                "content": [
                    {
                        "username": "HalfAPum",
                        "content": "Lol) \"Best Time to Buy and Sell Stock I\" was harder that this one"
                    },
                    {
                        "username": "Kenzie7",
                        "content": "I thought the wording \"maximum profit\" means we have to always find the largest sell prices in the index range of [buy_index +1:], and then we have to start choosing the buying at the index of [sell+1]. I DID NOT EXPECT TO SELL EVERY TIME IT\\'S HIGHER THAN THE BUYING PRICE!"
                    },
                    {
                        "username": "AdityaGoswami",
                        "content": "this line-\"However, you can buy it then immediately sell it on the same day\" makes the question with simpler answer makes it even more confusing"
                    },
                    {
                        "username": "Obaid07",
                        "content": "Try to avoid the Second test case , it\\'s misleading. "
                    },
                    {
                        "username": "benjelplan",
                        "content": "The problem doesn\\'t state whether you are allowed to sell and then buy on the same day (unless I\\'m missing something)"
                    },
                    {
                        "username": "harenbrs",
                        "content": "The performance measurements are so off here."
                    },
                    {
                        "username": "Harsha30ywffb",
                        "content": "who the hell are still trying it using stack like me . literally how these people are getting these optimised ideas."
                    },
                    {
                        "username": "bvchnguyen",
                        "content": "The differences between I and II should not warrant a change in level of difficulty imo. "
                    },
                    {
                        "username": "utalmighty",
                        "content": "Explore all the possibilities: \\n*We can buy and then sell. So, firstly we have to buy* `f(0, Buy)`\\n\\n- **Buy Possibilities**: \\n1. Buy current item `f(indx, Buy) - price[indx]` (if buying subtract the price as we are giving out the money)\\n2. Buy later `f(indx+1, Buy)`\\n \\n- **Sell Possibilities** : \\n\\n1. Sell current item and go to next for buying `price[indx]+f(indx+1, Buy)` (if selling add price as we are getting money)\\n2. Sell later `f(indx+1, Sell)`"
                    },
                    {
                        "username": "debugraghav",
                        "content": "hihi"
                    }
                ]
            },
            {
                "id": 2057799,
                "content": [
                    {
                        "username": "HalfAPum",
                        "content": "Lol) \"Best Time to Buy and Sell Stock I\" was harder that this one"
                    },
                    {
                        "username": "Kenzie7",
                        "content": "I thought the wording \"maximum profit\" means we have to always find the largest sell prices in the index range of [buy_index +1:], and then we have to start choosing the buying at the index of [sell+1]. I DID NOT EXPECT TO SELL EVERY TIME IT\\'S HIGHER THAN THE BUYING PRICE!"
                    },
                    {
                        "username": "AdityaGoswami",
                        "content": "this line-\"However, you can buy it then immediately sell it on the same day\" makes the question with simpler answer makes it even more confusing"
                    },
                    {
                        "username": "Obaid07",
                        "content": "Try to avoid the Second test case , it\\'s misleading. "
                    },
                    {
                        "username": "benjelplan",
                        "content": "The problem doesn\\'t state whether you are allowed to sell and then buy on the same day (unless I\\'m missing something)"
                    },
                    {
                        "username": "harenbrs",
                        "content": "The performance measurements are so off here."
                    },
                    {
                        "username": "Harsha30ywffb",
                        "content": "who the hell are still trying it using stack like me . literally how these people are getting these optimised ideas."
                    },
                    {
                        "username": "bvchnguyen",
                        "content": "The differences between I and II should not warrant a change in level of difficulty imo. "
                    },
                    {
                        "username": "utalmighty",
                        "content": "Explore all the possibilities: \\n*We can buy and then sell. So, firstly we have to buy* `f(0, Buy)`\\n\\n- **Buy Possibilities**: \\n1. Buy current item `f(indx, Buy) - price[indx]` (if buying subtract the price as we are giving out the money)\\n2. Buy later `f(indx+1, Buy)`\\n \\n- **Sell Possibilities** : \\n\\n1. Sell current item and go to next for buying `price[indx]+f(indx+1, Buy)` (if selling add price as we are getting money)\\n2. Sell later `f(indx+1, Sell)`"
                    },
                    {
                        "username": "debugraghav",
                        "content": "hihi"
                    }
                ]
            },
            {
                "id": 2043585,
                "content": [
                    {
                        "username": "HalfAPum",
                        "content": "Lol) \"Best Time to Buy and Sell Stock I\" was harder that this one"
                    },
                    {
                        "username": "Kenzie7",
                        "content": "I thought the wording \"maximum profit\" means we have to always find the largest sell prices in the index range of [buy_index +1:], and then we have to start choosing the buying at the index of [sell+1]. I DID NOT EXPECT TO SELL EVERY TIME IT\\'S HIGHER THAN THE BUYING PRICE!"
                    },
                    {
                        "username": "AdityaGoswami",
                        "content": "this line-\"However, you can buy it then immediately sell it on the same day\" makes the question with simpler answer makes it even more confusing"
                    },
                    {
                        "username": "Obaid07",
                        "content": "Try to avoid the Second test case , it\\'s misleading. "
                    },
                    {
                        "username": "benjelplan",
                        "content": "The problem doesn\\'t state whether you are allowed to sell and then buy on the same day (unless I\\'m missing something)"
                    },
                    {
                        "username": "harenbrs",
                        "content": "The performance measurements are so off here."
                    },
                    {
                        "username": "Harsha30ywffb",
                        "content": "who the hell are still trying it using stack like me . literally how these people are getting these optimised ideas."
                    },
                    {
                        "username": "bvchnguyen",
                        "content": "The differences between I and II should not warrant a change in level of difficulty imo. "
                    },
                    {
                        "username": "utalmighty",
                        "content": "Explore all the possibilities: \\n*We can buy and then sell. So, firstly we have to buy* `f(0, Buy)`\\n\\n- **Buy Possibilities**: \\n1. Buy current item `f(indx, Buy) - price[indx]` (if buying subtract the price as we are giving out the money)\\n2. Buy later `f(indx+1, Buy)`\\n \\n- **Sell Possibilities** : \\n\\n1. Sell current item and go to next for buying `price[indx]+f(indx+1, Buy)` (if selling add price as we are getting money)\\n2. Sell later `f(indx+1, Sell)`"
                    },
                    {
                        "username": "debugraghav",
                        "content": "hihi"
                    }
                ]
            },
            {
                "id": 2041415,
                "content": [
                    {
                        "username": "HalfAPum",
                        "content": "Lol) \"Best Time to Buy and Sell Stock I\" was harder that this one"
                    },
                    {
                        "username": "Kenzie7",
                        "content": "I thought the wording \"maximum profit\" means we have to always find the largest sell prices in the index range of [buy_index +1:], and then we have to start choosing the buying at the index of [sell+1]. I DID NOT EXPECT TO SELL EVERY TIME IT\\'S HIGHER THAN THE BUYING PRICE!"
                    },
                    {
                        "username": "AdityaGoswami",
                        "content": "this line-\"However, you can buy it then immediately sell it on the same day\" makes the question with simpler answer makes it even more confusing"
                    },
                    {
                        "username": "Obaid07",
                        "content": "Try to avoid the Second test case , it\\'s misleading. "
                    },
                    {
                        "username": "benjelplan",
                        "content": "The problem doesn\\'t state whether you are allowed to sell and then buy on the same day (unless I\\'m missing something)"
                    },
                    {
                        "username": "harenbrs",
                        "content": "The performance measurements are so off here."
                    },
                    {
                        "username": "Harsha30ywffb",
                        "content": "who the hell are still trying it using stack like me . literally how these people are getting these optimised ideas."
                    },
                    {
                        "username": "bvchnguyen",
                        "content": "The differences between I and II should not warrant a change in level of difficulty imo. "
                    },
                    {
                        "username": "utalmighty",
                        "content": "Explore all the possibilities: \\n*We can buy and then sell. So, firstly we have to buy* `f(0, Buy)`\\n\\n- **Buy Possibilities**: \\n1. Buy current item `f(indx, Buy) - price[indx]` (if buying subtract the price as we are giving out the money)\\n2. Buy later `f(indx+1, Buy)`\\n \\n- **Sell Possibilities** : \\n\\n1. Sell current item and go to next for buying `price[indx]+f(indx+1, Buy)` (if selling add price as we are getting money)\\n2. Sell later `f(indx+1, Sell)`"
                    },
                    {
                        "username": "debugraghav",
                        "content": "hihi"
                    }
                ]
            },
            {
                "id": 2036633,
                "content": [
                    {
                        "username": "HalfAPum",
                        "content": "Lol) \"Best Time to Buy and Sell Stock I\" was harder that this one"
                    },
                    {
                        "username": "Kenzie7",
                        "content": "I thought the wording \"maximum profit\" means we have to always find the largest sell prices in the index range of [buy_index +1:], and then we have to start choosing the buying at the index of [sell+1]. I DID NOT EXPECT TO SELL EVERY TIME IT\\'S HIGHER THAN THE BUYING PRICE!"
                    },
                    {
                        "username": "AdityaGoswami",
                        "content": "this line-\"However, you can buy it then immediately sell it on the same day\" makes the question with simpler answer makes it even more confusing"
                    },
                    {
                        "username": "Obaid07",
                        "content": "Try to avoid the Second test case , it\\'s misleading. "
                    },
                    {
                        "username": "benjelplan",
                        "content": "The problem doesn\\'t state whether you are allowed to sell and then buy on the same day (unless I\\'m missing something)"
                    },
                    {
                        "username": "harenbrs",
                        "content": "The performance measurements are so off here."
                    },
                    {
                        "username": "Harsha30ywffb",
                        "content": "who the hell are still trying it using stack like me . literally how these people are getting these optimised ideas."
                    },
                    {
                        "username": "bvchnguyen",
                        "content": "The differences between I and II should not warrant a change in level of difficulty imo. "
                    },
                    {
                        "username": "utalmighty",
                        "content": "Explore all the possibilities: \\n*We can buy and then sell. So, firstly we have to buy* `f(0, Buy)`\\n\\n- **Buy Possibilities**: \\n1. Buy current item `f(indx, Buy) - price[indx]` (if buying subtract the price as we are giving out the money)\\n2. Buy later `f(indx+1, Buy)`\\n \\n- **Sell Possibilities** : \\n\\n1. Sell current item and go to next for buying `price[indx]+f(indx+1, Buy)` (if selling add price as we are getting money)\\n2. Sell later `f(indx+1, Sell)`"
                    },
                    {
                        "username": "debugraghav",
                        "content": "hihi"
                    }
                ]
            },
            {
                "id": 2036560,
                "content": [
                    {
                        "username": "HalfAPum",
                        "content": "Lol) \"Best Time to Buy and Sell Stock I\" was harder that this one"
                    },
                    {
                        "username": "Kenzie7",
                        "content": "I thought the wording \"maximum profit\" means we have to always find the largest sell prices in the index range of [buy_index +1:], and then we have to start choosing the buying at the index of [sell+1]. I DID NOT EXPECT TO SELL EVERY TIME IT\\'S HIGHER THAN THE BUYING PRICE!"
                    },
                    {
                        "username": "AdityaGoswami",
                        "content": "this line-\"However, you can buy it then immediately sell it on the same day\" makes the question with simpler answer makes it even more confusing"
                    },
                    {
                        "username": "Obaid07",
                        "content": "Try to avoid the Second test case , it\\'s misleading. "
                    },
                    {
                        "username": "benjelplan",
                        "content": "The problem doesn\\'t state whether you are allowed to sell and then buy on the same day (unless I\\'m missing something)"
                    },
                    {
                        "username": "harenbrs",
                        "content": "The performance measurements are so off here."
                    },
                    {
                        "username": "Harsha30ywffb",
                        "content": "who the hell are still trying it using stack like me . literally how these people are getting these optimised ideas."
                    },
                    {
                        "username": "bvchnguyen",
                        "content": "The differences between I and II should not warrant a change in level of difficulty imo. "
                    },
                    {
                        "username": "utalmighty",
                        "content": "Explore all the possibilities: \\n*We can buy and then sell. So, firstly we have to buy* `f(0, Buy)`\\n\\n- **Buy Possibilities**: \\n1. Buy current item `f(indx, Buy) - price[indx]` (if buying subtract the price as we are giving out the money)\\n2. Buy later `f(indx+1, Buy)`\\n \\n- **Sell Possibilities** : \\n\\n1. Sell current item and go to next for buying `price[indx]+f(indx+1, Buy)` (if selling add price as we are getting money)\\n2. Sell later `f(indx+1, Sell)`"
                    },
                    {
                        "username": "debugraghav",
                        "content": "hihi"
                    }
                ]
            },
            {
                "id": 2036258,
                "content": [
                    {
                        "username": "Limon020",
                        "content": "It could be worded better to say \"you can sell it then immediately buy it on the same day\". I think this makes more sense for why this matters to the solution."
                    },
                    {
                        "username": "user7041C",
                        "content": "On each day, you may decide to buy and/or sell the stock. \\nThe above line is important which will simply the solution. "
                    },
                    {
                        "username": "Elliott_Young",
                        "content": "I find the easiest way to complete these problems is to draw a histogram for the array. After doing this, it became abundantly clear to me how to answer the question."
                    },
                    {
                        "username": "WajeehHasan",
                        "content": "hint : we will always sell for non-negative profit."
                    },
                    {
                        "username": "anuron_das",
                        "content": "Honestly all the $$O(n)$$ approaches here actually have very little to do with $$dp$$. When I came back to this problem after many days, I came hoping to solve it using $$dp$$. However I could come up with only $$O(n^2)$$ approach. Would appreciate if someone can tell me any linear time optimized $$dp$$ solution."
                    },
                    {
                        "username": "VikasNiranjan",
                        "content": "[ 6, 1, 3 ,2, 4, 7]\\n\\nhow this could generate a profit of 7?\\nAccording to me this could generate a max profit of 6.\\n"
                    },
                    {
                        "username": "Carver182",
                        "content": "buy on second day(price 1) - sell on 3th day(price 3) = profit is 2. Buy on 4th day(price 2) - sell at last day(price 7) = profit is 5. Overall profit is 2+5 = 7"
                    },
                    {
                        "username": "user0111VT",
                        "content": "I have a feeling that this should be labelled as \"easy\" and not \"medium\". Especially compared to the previous best time to buy / sell exercise."
                    },
                    {
                        "username": "georgezakharov",
                        "content": "They all say that the problem should be easy until they got it on an interview (c)"
                    },
                    {
                        "username": "AlikEmelianov",
                        "content": "This should be an easy"
                    },
                    {
                        "username": "parikhadi31",
                        "content": "Can anyone tell me what should be the output if the usecase is like [3,3] ?"
                    },
                    {
                        "username": "parikhadi31",
                        "content": "[@araguma](/araguma) Thank you!! That was helpful. "
                    },
                    {
                        "username": "araguma",
                        "content": "Should be 0 since you can\\'t make any profit by buying and selling at 3. For future reference, you can add your own testcase and run it to see the expected result."
                    },
                    {
                        "username": "araguma",
                        "content": "Feels like the difficulty of I and II should be swapped."
                    }
                ]
            },
            {
                "id": 2034210,
                "content": [
                    {
                        "username": "Limon020",
                        "content": "It could be worded better to say \"you can sell it then immediately buy it on the same day\". I think this makes more sense for why this matters to the solution."
                    },
                    {
                        "username": "user7041C",
                        "content": "On each day, you may decide to buy and/or sell the stock. \\nThe above line is important which will simply the solution. "
                    },
                    {
                        "username": "Elliott_Young",
                        "content": "I find the easiest way to complete these problems is to draw a histogram for the array. After doing this, it became abundantly clear to me how to answer the question."
                    },
                    {
                        "username": "WajeehHasan",
                        "content": "hint : we will always sell for non-negative profit."
                    },
                    {
                        "username": "anuron_das",
                        "content": "Honestly all the $$O(n)$$ approaches here actually have very little to do with $$dp$$. When I came back to this problem after many days, I came hoping to solve it using $$dp$$. However I could come up with only $$O(n^2)$$ approach. Would appreciate if someone can tell me any linear time optimized $$dp$$ solution."
                    },
                    {
                        "username": "VikasNiranjan",
                        "content": "[ 6, 1, 3 ,2, 4, 7]\\n\\nhow this could generate a profit of 7?\\nAccording to me this could generate a max profit of 6.\\n"
                    },
                    {
                        "username": "Carver182",
                        "content": "buy on second day(price 1) - sell on 3th day(price 3) = profit is 2. Buy on 4th day(price 2) - sell at last day(price 7) = profit is 5. Overall profit is 2+5 = 7"
                    },
                    {
                        "username": "user0111VT",
                        "content": "I have a feeling that this should be labelled as \"easy\" and not \"medium\". Especially compared to the previous best time to buy / sell exercise."
                    },
                    {
                        "username": "georgezakharov",
                        "content": "They all say that the problem should be easy until they got it on an interview (c)"
                    },
                    {
                        "username": "AlikEmelianov",
                        "content": "This should be an easy"
                    },
                    {
                        "username": "parikhadi31",
                        "content": "Can anyone tell me what should be the output if the usecase is like [3,3] ?"
                    },
                    {
                        "username": "parikhadi31",
                        "content": "[@araguma](/araguma) Thank you!! That was helpful. "
                    },
                    {
                        "username": "araguma",
                        "content": "Should be 0 since you can\\'t make any profit by buying and selling at 3. For future reference, you can add your own testcase and run it to see the expected result."
                    },
                    {
                        "username": "araguma",
                        "content": "Feels like the difficulty of I and II should be swapped."
                    }
                ]
            },
            {
                "id": 2029069,
                "content": [
                    {
                        "username": "Limon020",
                        "content": "It could be worded better to say \"you can sell it then immediately buy it on the same day\". I think this makes more sense for why this matters to the solution."
                    },
                    {
                        "username": "user7041C",
                        "content": "On each day, you may decide to buy and/or sell the stock. \\nThe above line is important which will simply the solution. "
                    },
                    {
                        "username": "Elliott_Young",
                        "content": "I find the easiest way to complete these problems is to draw a histogram for the array. After doing this, it became abundantly clear to me how to answer the question."
                    },
                    {
                        "username": "WajeehHasan",
                        "content": "hint : we will always sell for non-negative profit."
                    },
                    {
                        "username": "anuron_das",
                        "content": "Honestly all the $$O(n)$$ approaches here actually have very little to do with $$dp$$. When I came back to this problem after many days, I came hoping to solve it using $$dp$$. However I could come up with only $$O(n^2)$$ approach. Would appreciate if someone can tell me any linear time optimized $$dp$$ solution."
                    },
                    {
                        "username": "VikasNiranjan",
                        "content": "[ 6, 1, 3 ,2, 4, 7]\\n\\nhow this could generate a profit of 7?\\nAccording to me this could generate a max profit of 6.\\n"
                    },
                    {
                        "username": "Carver182",
                        "content": "buy on second day(price 1) - sell on 3th day(price 3) = profit is 2. Buy on 4th day(price 2) - sell at last day(price 7) = profit is 5. Overall profit is 2+5 = 7"
                    },
                    {
                        "username": "user0111VT",
                        "content": "I have a feeling that this should be labelled as \"easy\" and not \"medium\". Especially compared to the previous best time to buy / sell exercise."
                    },
                    {
                        "username": "georgezakharov",
                        "content": "They all say that the problem should be easy until they got it on an interview (c)"
                    },
                    {
                        "username": "AlikEmelianov",
                        "content": "This should be an easy"
                    },
                    {
                        "username": "parikhadi31",
                        "content": "Can anyone tell me what should be the output if the usecase is like [3,3] ?"
                    },
                    {
                        "username": "parikhadi31",
                        "content": "[@araguma](/araguma) Thank you!! That was helpful. "
                    },
                    {
                        "username": "araguma",
                        "content": "Should be 0 since you can\\'t make any profit by buying and selling at 3. For future reference, you can add your own testcase and run it to see the expected result."
                    },
                    {
                        "username": "araguma",
                        "content": "Feels like the difficulty of I and II should be swapped."
                    }
                ]
            },
            {
                "id": 2017581,
                "content": [
                    {
                        "username": "Limon020",
                        "content": "It could be worded better to say \"you can sell it then immediately buy it on the same day\". I think this makes more sense for why this matters to the solution."
                    },
                    {
                        "username": "user7041C",
                        "content": "On each day, you may decide to buy and/or sell the stock. \\nThe above line is important which will simply the solution. "
                    },
                    {
                        "username": "Elliott_Young",
                        "content": "I find the easiest way to complete these problems is to draw a histogram for the array. After doing this, it became abundantly clear to me how to answer the question."
                    },
                    {
                        "username": "WajeehHasan",
                        "content": "hint : we will always sell for non-negative profit."
                    },
                    {
                        "username": "anuron_das",
                        "content": "Honestly all the $$O(n)$$ approaches here actually have very little to do with $$dp$$. When I came back to this problem after many days, I came hoping to solve it using $$dp$$. However I could come up with only $$O(n^2)$$ approach. Would appreciate if someone can tell me any linear time optimized $$dp$$ solution."
                    },
                    {
                        "username": "VikasNiranjan",
                        "content": "[ 6, 1, 3 ,2, 4, 7]\\n\\nhow this could generate a profit of 7?\\nAccording to me this could generate a max profit of 6.\\n"
                    },
                    {
                        "username": "Carver182",
                        "content": "buy on second day(price 1) - sell on 3th day(price 3) = profit is 2. Buy on 4th day(price 2) - sell at last day(price 7) = profit is 5. Overall profit is 2+5 = 7"
                    },
                    {
                        "username": "user0111VT",
                        "content": "I have a feeling that this should be labelled as \"easy\" and not \"medium\". Especially compared to the previous best time to buy / sell exercise."
                    },
                    {
                        "username": "georgezakharov",
                        "content": "They all say that the problem should be easy until they got it on an interview (c)"
                    },
                    {
                        "username": "AlikEmelianov",
                        "content": "This should be an easy"
                    },
                    {
                        "username": "parikhadi31",
                        "content": "Can anyone tell me what should be the output if the usecase is like [3,3] ?"
                    },
                    {
                        "username": "parikhadi31",
                        "content": "[@araguma](/araguma) Thank you!! That was helpful. "
                    },
                    {
                        "username": "araguma",
                        "content": "Should be 0 since you can\\'t make any profit by buying and selling at 3. For future reference, you can add your own testcase and run it to see the expected result."
                    },
                    {
                        "username": "araguma",
                        "content": "Feels like the difficulty of I and II should be swapped."
                    }
                ]
            },
            {
                "id": 2012463,
                "content": [
                    {
                        "username": "Limon020",
                        "content": "It could be worded better to say \"you can sell it then immediately buy it on the same day\". I think this makes more sense for why this matters to the solution."
                    },
                    {
                        "username": "user7041C",
                        "content": "On each day, you may decide to buy and/or sell the stock. \\nThe above line is important which will simply the solution. "
                    },
                    {
                        "username": "Elliott_Young",
                        "content": "I find the easiest way to complete these problems is to draw a histogram for the array. After doing this, it became abundantly clear to me how to answer the question."
                    },
                    {
                        "username": "WajeehHasan",
                        "content": "hint : we will always sell for non-negative profit."
                    },
                    {
                        "username": "anuron_das",
                        "content": "Honestly all the $$O(n)$$ approaches here actually have very little to do with $$dp$$. When I came back to this problem after many days, I came hoping to solve it using $$dp$$. However I could come up with only $$O(n^2)$$ approach. Would appreciate if someone can tell me any linear time optimized $$dp$$ solution."
                    },
                    {
                        "username": "VikasNiranjan",
                        "content": "[ 6, 1, 3 ,2, 4, 7]\\n\\nhow this could generate a profit of 7?\\nAccording to me this could generate a max profit of 6.\\n"
                    },
                    {
                        "username": "Carver182",
                        "content": "buy on second day(price 1) - sell on 3th day(price 3) = profit is 2. Buy on 4th day(price 2) - sell at last day(price 7) = profit is 5. Overall profit is 2+5 = 7"
                    },
                    {
                        "username": "user0111VT",
                        "content": "I have a feeling that this should be labelled as \"easy\" and not \"medium\". Especially compared to the previous best time to buy / sell exercise."
                    },
                    {
                        "username": "georgezakharov",
                        "content": "They all say that the problem should be easy until they got it on an interview (c)"
                    },
                    {
                        "username": "AlikEmelianov",
                        "content": "This should be an easy"
                    },
                    {
                        "username": "parikhadi31",
                        "content": "Can anyone tell me what should be the output if the usecase is like [3,3] ?"
                    },
                    {
                        "username": "parikhadi31",
                        "content": "[@araguma](/araguma) Thank you!! That was helpful. "
                    },
                    {
                        "username": "araguma",
                        "content": "Should be 0 since you can\\'t make any profit by buying and selling at 3. For future reference, you can add your own testcase and run it to see the expected result."
                    },
                    {
                        "username": "araguma",
                        "content": "Feels like the difficulty of I and II should be swapped."
                    }
                ]
            },
            {
                "id": 2011063,
                "content": [
                    {
                        "username": "Limon020",
                        "content": "It could be worded better to say \"you can sell it then immediately buy it on the same day\". I think this makes more sense for why this matters to the solution."
                    },
                    {
                        "username": "user7041C",
                        "content": "On each day, you may decide to buy and/or sell the stock. \\nThe above line is important which will simply the solution. "
                    },
                    {
                        "username": "Elliott_Young",
                        "content": "I find the easiest way to complete these problems is to draw a histogram for the array. After doing this, it became abundantly clear to me how to answer the question."
                    },
                    {
                        "username": "WajeehHasan",
                        "content": "hint : we will always sell for non-negative profit."
                    },
                    {
                        "username": "anuron_das",
                        "content": "Honestly all the $$O(n)$$ approaches here actually have very little to do with $$dp$$. When I came back to this problem after many days, I came hoping to solve it using $$dp$$. However I could come up with only $$O(n^2)$$ approach. Would appreciate if someone can tell me any linear time optimized $$dp$$ solution."
                    },
                    {
                        "username": "VikasNiranjan",
                        "content": "[ 6, 1, 3 ,2, 4, 7]\\n\\nhow this could generate a profit of 7?\\nAccording to me this could generate a max profit of 6.\\n"
                    },
                    {
                        "username": "Carver182",
                        "content": "buy on second day(price 1) - sell on 3th day(price 3) = profit is 2. Buy on 4th day(price 2) - sell at last day(price 7) = profit is 5. Overall profit is 2+5 = 7"
                    },
                    {
                        "username": "user0111VT",
                        "content": "I have a feeling that this should be labelled as \"easy\" and not \"medium\". Especially compared to the previous best time to buy / sell exercise."
                    },
                    {
                        "username": "georgezakharov",
                        "content": "They all say that the problem should be easy until they got it on an interview (c)"
                    },
                    {
                        "username": "AlikEmelianov",
                        "content": "This should be an easy"
                    },
                    {
                        "username": "parikhadi31",
                        "content": "Can anyone tell me what should be the output if the usecase is like [3,3] ?"
                    },
                    {
                        "username": "parikhadi31",
                        "content": "[@araguma](/araguma) Thank you!! That was helpful. "
                    },
                    {
                        "username": "araguma",
                        "content": "Should be 0 since you can\\'t make any profit by buying and selling at 3. For future reference, you can add your own testcase and run it to see the expected result."
                    },
                    {
                        "username": "araguma",
                        "content": "Feels like the difficulty of I and II should be swapped."
                    }
                ]
            },
            {
                "id": 2001753,
                "content": [
                    {
                        "username": "Limon020",
                        "content": "It could be worded better to say \"you can sell it then immediately buy it on the same day\". I think this makes more sense for why this matters to the solution."
                    },
                    {
                        "username": "user7041C",
                        "content": "On each day, you may decide to buy and/or sell the stock. \\nThe above line is important which will simply the solution. "
                    },
                    {
                        "username": "Elliott_Young",
                        "content": "I find the easiest way to complete these problems is to draw a histogram for the array. After doing this, it became abundantly clear to me how to answer the question."
                    },
                    {
                        "username": "WajeehHasan",
                        "content": "hint : we will always sell for non-negative profit."
                    },
                    {
                        "username": "anuron_das",
                        "content": "Honestly all the $$O(n)$$ approaches here actually have very little to do with $$dp$$. When I came back to this problem after many days, I came hoping to solve it using $$dp$$. However I could come up with only $$O(n^2)$$ approach. Would appreciate if someone can tell me any linear time optimized $$dp$$ solution."
                    },
                    {
                        "username": "VikasNiranjan",
                        "content": "[ 6, 1, 3 ,2, 4, 7]\\n\\nhow this could generate a profit of 7?\\nAccording to me this could generate a max profit of 6.\\n"
                    },
                    {
                        "username": "Carver182",
                        "content": "buy on second day(price 1) - sell on 3th day(price 3) = profit is 2. Buy on 4th day(price 2) - sell at last day(price 7) = profit is 5. Overall profit is 2+5 = 7"
                    },
                    {
                        "username": "user0111VT",
                        "content": "I have a feeling that this should be labelled as \"easy\" and not \"medium\". Especially compared to the previous best time to buy / sell exercise."
                    },
                    {
                        "username": "georgezakharov",
                        "content": "They all say that the problem should be easy until they got it on an interview (c)"
                    },
                    {
                        "username": "AlikEmelianov",
                        "content": "This should be an easy"
                    },
                    {
                        "username": "parikhadi31",
                        "content": "Can anyone tell me what should be the output if the usecase is like [3,3] ?"
                    },
                    {
                        "username": "parikhadi31",
                        "content": "[@araguma](/araguma) Thank you!! That was helpful. "
                    },
                    {
                        "username": "araguma",
                        "content": "Should be 0 since you can\\'t make any profit by buying and selling at 3. For future reference, you can add your own testcase and run it to see the expected result."
                    },
                    {
                        "username": "araguma",
                        "content": "Feels like the difficulty of I and II should be swapped."
                    }
                ]
            },
            {
                "id": 2001665,
                "content": [
                    {
                        "username": "Limon020",
                        "content": "It could be worded better to say \"you can sell it then immediately buy it on the same day\". I think this makes more sense for why this matters to the solution."
                    },
                    {
                        "username": "user7041C",
                        "content": "On each day, you may decide to buy and/or sell the stock. \\nThe above line is important which will simply the solution. "
                    },
                    {
                        "username": "Elliott_Young",
                        "content": "I find the easiest way to complete these problems is to draw a histogram for the array. After doing this, it became abundantly clear to me how to answer the question."
                    },
                    {
                        "username": "WajeehHasan",
                        "content": "hint : we will always sell for non-negative profit."
                    },
                    {
                        "username": "anuron_das",
                        "content": "Honestly all the $$O(n)$$ approaches here actually have very little to do with $$dp$$. When I came back to this problem after many days, I came hoping to solve it using $$dp$$. However I could come up with only $$O(n^2)$$ approach. Would appreciate if someone can tell me any linear time optimized $$dp$$ solution."
                    },
                    {
                        "username": "VikasNiranjan",
                        "content": "[ 6, 1, 3 ,2, 4, 7]\\n\\nhow this could generate a profit of 7?\\nAccording to me this could generate a max profit of 6.\\n"
                    },
                    {
                        "username": "Carver182",
                        "content": "buy on second day(price 1) - sell on 3th day(price 3) = profit is 2. Buy on 4th day(price 2) - sell at last day(price 7) = profit is 5. Overall profit is 2+5 = 7"
                    },
                    {
                        "username": "user0111VT",
                        "content": "I have a feeling that this should be labelled as \"easy\" and not \"medium\". Especially compared to the previous best time to buy / sell exercise."
                    },
                    {
                        "username": "georgezakharov",
                        "content": "They all say that the problem should be easy until they got it on an interview (c)"
                    },
                    {
                        "username": "AlikEmelianov",
                        "content": "This should be an easy"
                    },
                    {
                        "username": "parikhadi31",
                        "content": "Can anyone tell me what should be the output if the usecase is like [3,3] ?"
                    },
                    {
                        "username": "parikhadi31",
                        "content": "[@araguma](/araguma) Thank you!! That was helpful. "
                    },
                    {
                        "username": "araguma",
                        "content": "Should be 0 since you can\\'t make any profit by buying and selling at 3. For future reference, you can add your own testcase and run it to see the expected result."
                    },
                    {
                        "username": "araguma",
                        "content": "Feels like the difficulty of I and II should be swapped."
                    }
                ]
            },
            {
                "id": 1988359,
                "content": [
                    {
                        "username": "Limon020",
                        "content": "It could be worded better to say \"you can sell it then immediately buy it on the same day\". I think this makes more sense for why this matters to the solution."
                    },
                    {
                        "username": "user7041C",
                        "content": "On each day, you may decide to buy and/or sell the stock. \\nThe above line is important which will simply the solution. "
                    },
                    {
                        "username": "Elliott_Young",
                        "content": "I find the easiest way to complete these problems is to draw a histogram for the array. After doing this, it became abundantly clear to me how to answer the question."
                    },
                    {
                        "username": "WajeehHasan",
                        "content": "hint : we will always sell for non-negative profit."
                    },
                    {
                        "username": "anuron_das",
                        "content": "Honestly all the $$O(n)$$ approaches here actually have very little to do with $$dp$$. When I came back to this problem after many days, I came hoping to solve it using $$dp$$. However I could come up with only $$O(n^2)$$ approach. Would appreciate if someone can tell me any linear time optimized $$dp$$ solution."
                    },
                    {
                        "username": "VikasNiranjan",
                        "content": "[ 6, 1, 3 ,2, 4, 7]\\n\\nhow this could generate a profit of 7?\\nAccording to me this could generate a max profit of 6.\\n"
                    },
                    {
                        "username": "Carver182",
                        "content": "buy on second day(price 1) - sell on 3th day(price 3) = profit is 2. Buy on 4th day(price 2) - sell at last day(price 7) = profit is 5. Overall profit is 2+5 = 7"
                    },
                    {
                        "username": "user0111VT",
                        "content": "I have a feeling that this should be labelled as \"easy\" and not \"medium\". Especially compared to the previous best time to buy / sell exercise."
                    },
                    {
                        "username": "georgezakharov",
                        "content": "They all say that the problem should be easy until they got it on an interview (c)"
                    },
                    {
                        "username": "AlikEmelianov",
                        "content": "This should be an easy"
                    },
                    {
                        "username": "parikhadi31",
                        "content": "Can anyone tell me what should be the output if the usecase is like [3,3] ?"
                    },
                    {
                        "username": "parikhadi31",
                        "content": "[@araguma](/araguma) Thank you!! That was helpful. "
                    },
                    {
                        "username": "araguma",
                        "content": "Should be 0 since you can\\'t make any profit by buying and selling at 3. For future reference, you can add your own testcase and run it to see the expected result."
                    },
                    {
                        "username": "araguma",
                        "content": "Feels like the difficulty of I and II should be swapped."
                    }
                ]
            },
            {
                "id": 1988239,
                "content": [
                    {
                        "username": "Limon020",
                        "content": "It could be worded better to say \"you can sell it then immediately buy it on the same day\". I think this makes more sense for why this matters to the solution."
                    },
                    {
                        "username": "user7041C",
                        "content": "On each day, you may decide to buy and/or sell the stock. \\nThe above line is important which will simply the solution. "
                    },
                    {
                        "username": "Elliott_Young",
                        "content": "I find the easiest way to complete these problems is to draw a histogram for the array. After doing this, it became abundantly clear to me how to answer the question."
                    },
                    {
                        "username": "WajeehHasan",
                        "content": "hint : we will always sell for non-negative profit."
                    },
                    {
                        "username": "anuron_das",
                        "content": "Honestly all the $$O(n)$$ approaches here actually have very little to do with $$dp$$. When I came back to this problem after many days, I came hoping to solve it using $$dp$$. However I could come up with only $$O(n^2)$$ approach. Would appreciate if someone can tell me any linear time optimized $$dp$$ solution."
                    },
                    {
                        "username": "VikasNiranjan",
                        "content": "[ 6, 1, 3 ,2, 4, 7]\\n\\nhow this could generate a profit of 7?\\nAccording to me this could generate a max profit of 6.\\n"
                    },
                    {
                        "username": "Carver182",
                        "content": "buy on second day(price 1) - sell on 3th day(price 3) = profit is 2. Buy on 4th day(price 2) - sell at last day(price 7) = profit is 5. Overall profit is 2+5 = 7"
                    },
                    {
                        "username": "user0111VT",
                        "content": "I have a feeling that this should be labelled as \"easy\" and not \"medium\". Especially compared to the previous best time to buy / sell exercise."
                    },
                    {
                        "username": "georgezakharov",
                        "content": "They all say that the problem should be easy until they got it on an interview (c)"
                    },
                    {
                        "username": "AlikEmelianov",
                        "content": "This should be an easy"
                    },
                    {
                        "username": "parikhadi31",
                        "content": "Can anyone tell me what should be the output if the usecase is like [3,3] ?"
                    },
                    {
                        "username": "parikhadi31",
                        "content": "[@araguma](/araguma) Thank you!! That was helpful. "
                    },
                    {
                        "username": "araguma",
                        "content": "Should be 0 since you can\\'t make any profit by buying and selling at 3. For future reference, you can add your own testcase and run it to see the expected result."
                    },
                    {
                        "username": "araguma",
                        "content": "Feels like the difficulty of I and II should be swapped."
                    }
                ]
            },
            {
                "id": 1973208,
                "content": [
                    {
                        "username": "rakeshks7",
                        "content": "am i stupid for thinking of dp and ending up with MLE only to realize that it can be solved in a greedy way \\uD83D\\uDC80"
                    },
                    {
                        "username": "SteveGan",
                        "content": "How could I obtain the prices array in real life?"
                    },
                    {
                        "username": "vanshjain499",
                        "content": "Just consider the profit if future price is high\\nOnly single condition required-->  if(arr[i]>arr[i-1]) profit+=(arr[i]-arr[i-1]);\\n        \\n"
                    },
                    {
                        "username": "pkjha0102",
                        "content": "\"Profit value between any two days is sum (positive + negative) profit values of consecutive days between the two chosen days.\"\\nThis catch reduced my 40 lines top-down DP solution to 4 lines solution."
                    },
                    {
                        "username": "sayan0110",
                        "content": "We have to start the for loop from 1 and then need  to compair prices[i] > prices[i-1]\\nThen profit = profit + prices[i] - prices[i-1]\\nthen return profit."
                    },
                    {
                        "username": "Harshsharma12",
                        "content": "Best approach to solve this problem\\nhttps://leetcode.com/problems/best-time-to-buy-and-sell-stock-ii/description/comments/1567200"
                    },
                    {
                        "username": "vivekkedia22",
                        "content": "hello can someone please explain that how is this going to be 8\\n[3,3,5,0,0,3,1,4]\\nmy output is 6 while expected output is 8"
                    },
                    {
                        "username": "tesudesu",
                        "content": "Buy 3, sell at 5 --> profit 2\\nBuy 0, sell at 3 --> profit 3\\nBuy 1, sell at 4 --> profit 3"
                    },
                    {
                        "username": "Tribhuwan-Joshi",
                        "content": "This should be easy and Part 1 should be medium . In this question all you have to catch is how to track the index where prices are going high and only consider them"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "They all say that the problem should be easy until they got it on an interview (c)"
                    },
                    {
                        "username": "tesudesu",
                        "content": "\"However, you can buy it then immediately sell it on the same day.\"\\n\\nRead it as \"However, you can **sell** it then immediately **buy** it on the same day.\""
                    },
                    {
                        "username": "SaketNarayane",
                        "content": "If you read the problem carefully, it is even easier than the \\'Best Time to Buy and Sell Stock I\\' problem\\n"
                    }
                ]
            },
            {
                "id": 1962711,
                "content": [
                    {
                        "username": "rakeshks7",
                        "content": "am i stupid for thinking of dp and ending up with MLE only to realize that it can be solved in a greedy way \\uD83D\\uDC80"
                    },
                    {
                        "username": "SteveGan",
                        "content": "How could I obtain the prices array in real life?"
                    },
                    {
                        "username": "vanshjain499",
                        "content": "Just consider the profit if future price is high\\nOnly single condition required-->  if(arr[i]>arr[i-1]) profit+=(arr[i]-arr[i-1]);\\n        \\n"
                    },
                    {
                        "username": "pkjha0102",
                        "content": "\"Profit value between any two days is sum (positive + negative) profit values of consecutive days between the two chosen days.\"\\nThis catch reduced my 40 lines top-down DP solution to 4 lines solution."
                    },
                    {
                        "username": "sayan0110",
                        "content": "We have to start the for loop from 1 and then need  to compair prices[i] > prices[i-1]\\nThen profit = profit + prices[i] - prices[i-1]\\nthen return profit."
                    },
                    {
                        "username": "Harshsharma12",
                        "content": "Best approach to solve this problem\\nhttps://leetcode.com/problems/best-time-to-buy-and-sell-stock-ii/description/comments/1567200"
                    },
                    {
                        "username": "vivekkedia22",
                        "content": "hello can someone please explain that how is this going to be 8\\n[3,3,5,0,0,3,1,4]\\nmy output is 6 while expected output is 8"
                    },
                    {
                        "username": "tesudesu",
                        "content": "Buy 3, sell at 5 --> profit 2\\nBuy 0, sell at 3 --> profit 3\\nBuy 1, sell at 4 --> profit 3"
                    },
                    {
                        "username": "Tribhuwan-Joshi",
                        "content": "This should be easy and Part 1 should be medium . In this question all you have to catch is how to track the index where prices are going high and only consider them"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "They all say that the problem should be easy until they got it on an interview (c)"
                    },
                    {
                        "username": "tesudesu",
                        "content": "\"However, you can buy it then immediately sell it on the same day.\"\\n\\nRead it as \"However, you can **sell** it then immediately **buy** it on the same day.\""
                    },
                    {
                        "username": "SaketNarayane",
                        "content": "If you read the problem carefully, it is even easier than the \\'Best Time to Buy and Sell Stock I\\' problem\\n"
                    }
                ]
            },
            {
                "id": 1956828,
                "content": [
                    {
                        "username": "rakeshks7",
                        "content": "am i stupid for thinking of dp and ending up with MLE only to realize that it can be solved in a greedy way \\uD83D\\uDC80"
                    },
                    {
                        "username": "SteveGan",
                        "content": "How could I obtain the prices array in real life?"
                    },
                    {
                        "username": "vanshjain499",
                        "content": "Just consider the profit if future price is high\\nOnly single condition required-->  if(arr[i]>arr[i-1]) profit+=(arr[i]-arr[i-1]);\\n        \\n"
                    },
                    {
                        "username": "pkjha0102",
                        "content": "\"Profit value between any two days is sum (positive + negative) profit values of consecutive days between the two chosen days.\"\\nThis catch reduced my 40 lines top-down DP solution to 4 lines solution."
                    },
                    {
                        "username": "sayan0110",
                        "content": "We have to start the for loop from 1 and then need  to compair prices[i] > prices[i-1]\\nThen profit = profit + prices[i] - prices[i-1]\\nthen return profit."
                    },
                    {
                        "username": "Harshsharma12",
                        "content": "Best approach to solve this problem\\nhttps://leetcode.com/problems/best-time-to-buy-and-sell-stock-ii/description/comments/1567200"
                    },
                    {
                        "username": "vivekkedia22",
                        "content": "hello can someone please explain that how is this going to be 8\\n[3,3,5,0,0,3,1,4]\\nmy output is 6 while expected output is 8"
                    },
                    {
                        "username": "tesudesu",
                        "content": "Buy 3, sell at 5 --> profit 2\\nBuy 0, sell at 3 --> profit 3\\nBuy 1, sell at 4 --> profit 3"
                    },
                    {
                        "username": "Tribhuwan-Joshi",
                        "content": "This should be easy and Part 1 should be medium . In this question all you have to catch is how to track the index where prices are going high and only consider them"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "They all say that the problem should be easy until they got it on an interview (c)"
                    },
                    {
                        "username": "tesudesu",
                        "content": "\"However, you can buy it then immediately sell it on the same day.\"\\n\\nRead it as \"However, you can **sell** it then immediately **buy** it on the same day.\""
                    },
                    {
                        "username": "SaketNarayane",
                        "content": "If you read the problem carefully, it is even easier than the \\'Best Time to Buy and Sell Stock I\\' problem\\n"
                    }
                ]
            },
            {
                "id": 1942645,
                "content": [
                    {
                        "username": "rakeshks7",
                        "content": "am i stupid for thinking of dp and ending up with MLE only to realize that it can be solved in a greedy way \\uD83D\\uDC80"
                    },
                    {
                        "username": "SteveGan",
                        "content": "How could I obtain the prices array in real life?"
                    },
                    {
                        "username": "vanshjain499",
                        "content": "Just consider the profit if future price is high\\nOnly single condition required-->  if(arr[i]>arr[i-1]) profit+=(arr[i]-arr[i-1]);\\n        \\n"
                    },
                    {
                        "username": "pkjha0102",
                        "content": "\"Profit value between any two days is sum (positive + negative) profit values of consecutive days between the two chosen days.\"\\nThis catch reduced my 40 lines top-down DP solution to 4 lines solution."
                    },
                    {
                        "username": "sayan0110",
                        "content": "We have to start the for loop from 1 and then need  to compair prices[i] > prices[i-1]\\nThen profit = profit + prices[i] - prices[i-1]\\nthen return profit."
                    },
                    {
                        "username": "Harshsharma12",
                        "content": "Best approach to solve this problem\\nhttps://leetcode.com/problems/best-time-to-buy-and-sell-stock-ii/description/comments/1567200"
                    },
                    {
                        "username": "vivekkedia22",
                        "content": "hello can someone please explain that how is this going to be 8\\n[3,3,5,0,0,3,1,4]\\nmy output is 6 while expected output is 8"
                    },
                    {
                        "username": "tesudesu",
                        "content": "Buy 3, sell at 5 --> profit 2\\nBuy 0, sell at 3 --> profit 3\\nBuy 1, sell at 4 --> profit 3"
                    },
                    {
                        "username": "Tribhuwan-Joshi",
                        "content": "This should be easy and Part 1 should be medium . In this question all you have to catch is how to track the index where prices are going high and only consider them"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "They all say that the problem should be easy until they got it on an interview (c)"
                    },
                    {
                        "username": "tesudesu",
                        "content": "\"However, you can buy it then immediately sell it on the same day.\"\\n\\nRead it as \"However, you can **sell** it then immediately **buy** it on the same day.\""
                    },
                    {
                        "username": "SaketNarayane",
                        "content": "If you read the problem carefully, it is even easier than the \\'Best Time to Buy and Sell Stock I\\' problem\\n"
                    }
                ]
            },
            {
                "id": 1939317,
                "content": [
                    {
                        "username": "rakeshks7",
                        "content": "am i stupid for thinking of dp and ending up with MLE only to realize that it can be solved in a greedy way \\uD83D\\uDC80"
                    },
                    {
                        "username": "SteveGan",
                        "content": "How could I obtain the prices array in real life?"
                    },
                    {
                        "username": "vanshjain499",
                        "content": "Just consider the profit if future price is high\\nOnly single condition required-->  if(arr[i]>arr[i-1]) profit+=(arr[i]-arr[i-1]);\\n        \\n"
                    },
                    {
                        "username": "pkjha0102",
                        "content": "\"Profit value between any two days is sum (positive + negative) profit values of consecutive days between the two chosen days.\"\\nThis catch reduced my 40 lines top-down DP solution to 4 lines solution."
                    },
                    {
                        "username": "sayan0110",
                        "content": "We have to start the for loop from 1 and then need  to compair prices[i] > prices[i-1]\\nThen profit = profit + prices[i] - prices[i-1]\\nthen return profit."
                    },
                    {
                        "username": "Harshsharma12",
                        "content": "Best approach to solve this problem\\nhttps://leetcode.com/problems/best-time-to-buy-and-sell-stock-ii/description/comments/1567200"
                    },
                    {
                        "username": "vivekkedia22",
                        "content": "hello can someone please explain that how is this going to be 8\\n[3,3,5,0,0,3,1,4]\\nmy output is 6 while expected output is 8"
                    },
                    {
                        "username": "tesudesu",
                        "content": "Buy 3, sell at 5 --> profit 2\\nBuy 0, sell at 3 --> profit 3\\nBuy 1, sell at 4 --> profit 3"
                    },
                    {
                        "username": "Tribhuwan-Joshi",
                        "content": "This should be easy and Part 1 should be medium . In this question all you have to catch is how to track the index where prices are going high and only consider them"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "They all say that the problem should be easy until they got it on an interview (c)"
                    },
                    {
                        "username": "tesudesu",
                        "content": "\"However, you can buy it then immediately sell it on the same day.\"\\n\\nRead it as \"However, you can **sell** it then immediately **buy** it on the same day.\""
                    },
                    {
                        "username": "SaketNarayane",
                        "content": "If you read the problem carefully, it is even easier than the \\'Best Time to Buy and Sell Stock I\\' problem\\n"
                    }
                ]
            },
            {
                "id": 1938075,
                "content": [
                    {
                        "username": "rakeshks7",
                        "content": "am i stupid for thinking of dp and ending up with MLE only to realize that it can be solved in a greedy way \\uD83D\\uDC80"
                    },
                    {
                        "username": "SteveGan",
                        "content": "How could I obtain the prices array in real life?"
                    },
                    {
                        "username": "vanshjain499",
                        "content": "Just consider the profit if future price is high\\nOnly single condition required-->  if(arr[i]>arr[i-1]) profit+=(arr[i]-arr[i-1]);\\n        \\n"
                    },
                    {
                        "username": "pkjha0102",
                        "content": "\"Profit value between any two days is sum (positive + negative) profit values of consecutive days between the two chosen days.\"\\nThis catch reduced my 40 lines top-down DP solution to 4 lines solution."
                    },
                    {
                        "username": "sayan0110",
                        "content": "We have to start the for loop from 1 and then need  to compair prices[i] > prices[i-1]\\nThen profit = profit + prices[i] - prices[i-1]\\nthen return profit."
                    },
                    {
                        "username": "Harshsharma12",
                        "content": "Best approach to solve this problem\\nhttps://leetcode.com/problems/best-time-to-buy-and-sell-stock-ii/description/comments/1567200"
                    },
                    {
                        "username": "vivekkedia22",
                        "content": "hello can someone please explain that how is this going to be 8\\n[3,3,5,0,0,3,1,4]\\nmy output is 6 while expected output is 8"
                    },
                    {
                        "username": "tesudesu",
                        "content": "Buy 3, sell at 5 --> profit 2\\nBuy 0, sell at 3 --> profit 3\\nBuy 1, sell at 4 --> profit 3"
                    },
                    {
                        "username": "Tribhuwan-Joshi",
                        "content": "This should be easy and Part 1 should be medium . In this question all you have to catch is how to track the index where prices are going high and only consider them"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "They all say that the problem should be easy until they got it on an interview (c)"
                    },
                    {
                        "username": "tesudesu",
                        "content": "\"However, you can buy it then immediately sell it on the same day.\"\\n\\nRead it as \"However, you can **sell** it then immediately **buy** it on the same day.\""
                    },
                    {
                        "username": "SaketNarayane",
                        "content": "If you read the problem carefully, it is even easier than the \\'Best Time to Buy and Sell Stock I\\' problem\\n"
                    }
                ]
            },
            {
                "id": 1930707,
                "content": [
                    {
                        "username": "rakeshks7",
                        "content": "am i stupid for thinking of dp and ending up with MLE only to realize that it can be solved in a greedy way \\uD83D\\uDC80"
                    },
                    {
                        "username": "SteveGan",
                        "content": "How could I obtain the prices array in real life?"
                    },
                    {
                        "username": "vanshjain499",
                        "content": "Just consider the profit if future price is high\\nOnly single condition required-->  if(arr[i]>arr[i-1]) profit+=(arr[i]-arr[i-1]);\\n        \\n"
                    },
                    {
                        "username": "pkjha0102",
                        "content": "\"Profit value between any two days is sum (positive + negative) profit values of consecutive days between the two chosen days.\"\\nThis catch reduced my 40 lines top-down DP solution to 4 lines solution."
                    },
                    {
                        "username": "sayan0110",
                        "content": "We have to start the for loop from 1 and then need  to compair prices[i] > prices[i-1]\\nThen profit = profit + prices[i] - prices[i-1]\\nthen return profit."
                    },
                    {
                        "username": "Harshsharma12",
                        "content": "Best approach to solve this problem\\nhttps://leetcode.com/problems/best-time-to-buy-and-sell-stock-ii/description/comments/1567200"
                    },
                    {
                        "username": "vivekkedia22",
                        "content": "hello can someone please explain that how is this going to be 8\\n[3,3,5,0,0,3,1,4]\\nmy output is 6 while expected output is 8"
                    },
                    {
                        "username": "tesudesu",
                        "content": "Buy 3, sell at 5 --> profit 2\\nBuy 0, sell at 3 --> profit 3\\nBuy 1, sell at 4 --> profit 3"
                    },
                    {
                        "username": "Tribhuwan-Joshi",
                        "content": "This should be easy and Part 1 should be medium . In this question all you have to catch is how to track the index where prices are going high and only consider them"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "They all say that the problem should be easy until they got it on an interview (c)"
                    },
                    {
                        "username": "tesudesu",
                        "content": "\"However, you can buy it then immediately sell it on the same day.\"\\n\\nRead it as \"However, you can **sell** it then immediately **buy** it on the same day.\""
                    },
                    {
                        "username": "SaketNarayane",
                        "content": "If you read the problem carefully, it is even easier than the \\'Best Time to Buy and Sell Stock I\\' problem\\n"
                    }
                ]
            },
            {
                "id": 1928781,
                "content": [
                    {
                        "username": "rakeshks7",
                        "content": "am i stupid for thinking of dp and ending up with MLE only to realize that it can be solved in a greedy way \\uD83D\\uDC80"
                    },
                    {
                        "username": "SteveGan",
                        "content": "How could I obtain the prices array in real life?"
                    },
                    {
                        "username": "vanshjain499",
                        "content": "Just consider the profit if future price is high\\nOnly single condition required-->  if(arr[i]>arr[i-1]) profit+=(arr[i]-arr[i-1]);\\n        \\n"
                    },
                    {
                        "username": "pkjha0102",
                        "content": "\"Profit value between any two days is sum (positive + negative) profit values of consecutive days between the two chosen days.\"\\nThis catch reduced my 40 lines top-down DP solution to 4 lines solution."
                    },
                    {
                        "username": "sayan0110",
                        "content": "We have to start the for loop from 1 and then need  to compair prices[i] > prices[i-1]\\nThen profit = profit + prices[i] - prices[i-1]\\nthen return profit."
                    },
                    {
                        "username": "Harshsharma12",
                        "content": "Best approach to solve this problem\\nhttps://leetcode.com/problems/best-time-to-buy-and-sell-stock-ii/description/comments/1567200"
                    },
                    {
                        "username": "vivekkedia22",
                        "content": "hello can someone please explain that how is this going to be 8\\n[3,3,5,0,0,3,1,4]\\nmy output is 6 while expected output is 8"
                    },
                    {
                        "username": "tesudesu",
                        "content": "Buy 3, sell at 5 --> profit 2\\nBuy 0, sell at 3 --> profit 3\\nBuy 1, sell at 4 --> profit 3"
                    },
                    {
                        "username": "Tribhuwan-Joshi",
                        "content": "This should be easy and Part 1 should be medium . In this question all you have to catch is how to track the index where prices are going high and only consider them"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "They all say that the problem should be easy until they got it on an interview (c)"
                    },
                    {
                        "username": "tesudesu",
                        "content": "\"However, you can buy it then immediately sell it on the same day.\"\\n\\nRead it as \"However, you can **sell** it then immediately **buy** it on the same day.\""
                    },
                    {
                        "username": "SaketNarayane",
                        "content": "If you read the problem carefully, it is even easier than the \\'Best Time to Buy and Sell Stock I\\' problem\\n"
                    }
                ]
            },
            {
                "id": 1928190,
                "content": [
                    {
                        "username": "rakeshks7",
                        "content": "am i stupid for thinking of dp and ending up with MLE only to realize that it can be solved in a greedy way \\uD83D\\uDC80"
                    },
                    {
                        "username": "SteveGan",
                        "content": "How could I obtain the prices array in real life?"
                    },
                    {
                        "username": "vanshjain499",
                        "content": "Just consider the profit if future price is high\\nOnly single condition required-->  if(arr[i]>arr[i-1]) profit+=(arr[i]-arr[i-1]);\\n        \\n"
                    },
                    {
                        "username": "pkjha0102",
                        "content": "\"Profit value between any two days is sum (positive + negative) profit values of consecutive days between the two chosen days.\"\\nThis catch reduced my 40 lines top-down DP solution to 4 lines solution."
                    },
                    {
                        "username": "sayan0110",
                        "content": "We have to start the for loop from 1 and then need  to compair prices[i] > prices[i-1]\\nThen profit = profit + prices[i] - prices[i-1]\\nthen return profit."
                    },
                    {
                        "username": "Harshsharma12",
                        "content": "Best approach to solve this problem\\nhttps://leetcode.com/problems/best-time-to-buy-and-sell-stock-ii/description/comments/1567200"
                    },
                    {
                        "username": "vivekkedia22",
                        "content": "hello can someone please explain that how is this going to be 8\\n[3,3,5,0,0,3,1,4]\\nmy output is 6 while expected output is 8"
                    },
                    {
                        "username": "tesudesu",
                        "content": "Buy 3, sell at 5 --> profit 2\\nBuy 0, sell at 3 --> profit 3\\nBuy 1, sell at 4 --> profit 3"
                    },
                    {
                        "username": "Tribhuwan-Joshi",
                        "content": "This should be easy and Part 1 should be medium . In this question all you have to catch is how to track the index where prices are going high and only consider them"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "They all say that the problem should be easy until they got it on an interview (c)"
                    },
                    {
                        "username": "tesudesu",
                        "content": "\"However, you can buy it then immediately sell it on the same day.\"\\n\\nRead it as \"However, you can **sell** it then immediately **buy** it on the same day.\""
                    },
                    {
                        "username": "SaketNarayane",
                        "content": "If you read the problem carefully, it is even easier than the \\'Best Time to Buy and Sell Stock I\\' problem\\n"
                    }
                ]
            },
            {
                "id": 1908981,
                "content": [
                    {
                        "username": "rakeshks7",
                        "content": "am i stupid for thinking of dp and ending up with MLE only to realize that it can be solved in a greedy way \\uD83D\\uDC80"
                    },
                    {
                        "username": "SteveGan",
                        "content": "How could I obtain the prices array in real life?"
                    },
                    {
                        "username": "vanshjain499",
                        "content": "Just consider the profit if future price is high\\nOnly single condition required-->  if(arr[i]>arr[i-1]) profit+=(arr[i]-arr[i-1]);\\n        \\n"
                    },
                    {
                        "username": "pkjha0102",
                        "content": "\"Profit value between any two days is sum (positive + negative) profit values of consecutive days between the two chosen days.\"\\nThis catch reduced my 40 lines top-down DP solution to 4 lines solution."
                    },
                    {
                        "username": "sayan0110",
                        "content": "We have to start the for loop from 1 and then need  to compair prices[i] > prices[i-1]\\nThen profit = profit + prices[i] - prices[i-1]\\nthen return profit."
                    },
                    {
                        "username": "Harshsharma12",
                        "content": "Best approach to solve this problem\\nhttps://leetcode.com/problems/best-time-to-buy-and-sell-stock-ii/description/comments/1567200"
                    },
                    {
                        "username": "vivekkedia22",
                        "content": "hello can someone please explain that how is this going to be 8\\n[3,3,5,0,0,3,1,4]\\nmy output is 6 while expected output is 8"
                    },
                    {
                        "username": "tesudesu",
                        "content": "Buy 3, sell at 5 --> profit 2\\nBuy 0, sell at 3 --> profit 3\\nBuy 1, sell at 4 --> profit 3"
                    },
                    {
                        "username": "Tribhuwan-Joshi",
                        "content": "This should be easy and Part 1 should be medium . In this question all you have to catch is how to track the index where prices are going high and only consider them"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "They all say that the problem should be easy until they got it on an interview (c)"
                    },
                    {
                        "username": "tesudesu",
                        "content": "\"However, you can buy it then immediately sell it on the same day.\"\\n\\nRead it as \"However, you can **sell** it then immediately **buy** it on the same day.\""
                    },
                    {
                        "username": "SaketNarayane",
                        "content": "If you read the problem carefully, it is even easier than the \\'Best Time to Buy and Sell Stock I\\' problem\\n"
                    }
                ]
            },
            {
                "id": 1899340,
                "content": [
                    {
                        "username": "MenaiAla",
                        "content": "**Same day** confused me a lot."
                    },
                    {
                        "username": "zalars",
                        "content": "What\\'s the point to describe such a task in that form if we can\\'t buy and sell in the past from the present?"
                    },
                    {
                        "username": "user4184tG",
                        "content": "there seems to be a problem with Ex1: when you rebuy the stock on day 4 (price = 3) you spend the given amount, thereby taking away from the net profit [by 3 in this case].\neach time a repurchase is made, money is spent- which takes away from the net profit (I'm assuming)"
                    },
                    {
                        "username": "apjo2009",
                        "content": "so that means in the example 2 where prices=[1,2,3,4,5], i can buy on day 1 sell on day 2 profit=2-1=1, buy on day 2 sell on day 3 profit=1+(3-2)=1+1=2, buy on day 3 sell on day 4 profit = 2+(4-3)=3, and finally buy on day 4 & sell on day 5 profit=3+(5-4)=4, is this right? "
                    },
                    {
                        "username": "Skripko",
                        "content": "This task must be easy! "
                    },
                    {
                        "username": "georgezakharov",
                        "content": "They all say that the problem should be easy until they got it on an interview (c)"
                    },
                    {
                        "username": "user7854c",
                        "content": "[3,3,5,0,0,3,1,4]\\n\\nThis test case is spitting wrong expected output? My o/p is 6, expected is 8.\\nTell me how it is 8?"
                    },
                    {
                        "username": "PratD",
                        "content": "\nBuy at index 0 and sell at 2 --> (3,5) = 2\nBuy at index 3 and sell at 5 --> (0,3) = 3\nBuy at index 6 and sell at 7 --> (1,4) = 3\n\nTotal is 2+3+3 = 8"
                    },
                    {
                        "username": "Syed_Waseem",
                        "content": "1) In this question whenever stock value goes down reset your current stock\n\n2) After setting current stock check for value which is max in the right of current stock(for max profit) then calculate profit and add it to totalProfit\n\n3)Then set your current stock to next index of maximum value(because at maximum value we sold our stock) now we want new stock\n\ncode:-\nclass Solution {\n    public int maxProfit(int[] prices) {\n        int currentstock = prices[0];   \n        int totalprofit = 0;\n        for(int i=0; i<prices.length-1; ++i) {\n            if(prices[i] > prices[i+1]) {   //Reseting current stock\n                currentstock = prices[i+1];\n            } else {\n                //Checking for max value in right of current stock\n                while(i<(prices.length-1) && prices[i] < prices[i+1]) { \n                    ++i;\n                }\n                //Calculating profit\n                totalprofit += prices[i] - currentstock;\n                //Setting current stock to next index of maxi value\n                if(i<prices.length-1) {\n                    currentstock = prices[i+1];\n                }\n            }\n        }\n        \n        return totalprofit;\n    }\n}"
                    },
                    {
                        "username": "ignorant_ppp",
                        "content": "can anyone explain me how second testcase working ?? "
                    },
                    {
                        "username": "debaudh",
                        "content": "\"Medium\" ?? really ?!"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Nah, just kidding"
                    },
                    {
                        "username": "gurnainwadhwa",
                        "content": "can be easily solved in O(n)"
                    }
                ]
            },
            {
                "id": 1894741,
                "content": [
                    {
                        "username": "MenaiAla",
                        "content": "**Same day** confused me a lot."
                    },
                    {
                        "username": "zalars",
                        "content": "What\\'s the point to describe such a task in that form if we can\\'t buy and sell in the past from the present?"
                    },
                    {
                        "username": "user4184tG",
                        "content": "there seems to be a problem with Ex1: when you rebuy the stock on day 4 (price = 3) you spend the given amount, thereby taking away from the net profit [by 3 in this case].\neach time a repurchase is made, money is spent- which takes away from the net profit (I'm assuming)"
                    },
                    {
                        "username": "apjo2009",
                        "content": "so that means in the example 2 where prices=[1,2,3,4,5], i can buy on day 1 sell on day 2 profit=2-1=1, buy on day 2 sell on day 3 profit=1+(3-2)=1+1=2, buy on day 3 sell on day 4 profit = 2+(4-3)=3, and finally buy on day 4 & sell on day 5 profit=3+(5-4)=4, is this right? "
                    },
                    {
                        "username": "Skripko",
                        "content": "This task must be easy! "
                    },
                    {
                        "username": "georgezakharov",
                        "content": "They all say that the problem should be easy until they got it on an interview (c)"
                    },
                    {
                        "username": "user7854c",
                        "content": "[3,3,5,0,0,3,1,4]\\n\\nThis test case is spitting wrong expected output? My o/p is 6, expected is 8.\\nTell me how it is 8?"
                    },
                    {
                        "username": "PratD",
                        "content": "\nBuy at index 0 and sell at 2 --> (3,5) = 2\nBuy at index 3 and sell at 5 --> (0,3) = 3\nBuy at index 6 and sell at 7 --> (1,4) = 3\n\nTotal is 2+3+3 = 8"
                    },
                    {
                        "username": "Syed_Waseem",
                        "content": "1) In this question whenever stock value goes down reset your current stock\n\n2) After setting current stock check for value which is max in the right of current stock(for max profit) then calculate profit and add it to totalProfit\n\n3)Then set your current stock to next index of maximum value(because at maximum value we sold our stock) now we want new stock\n\ncode:-\nclass Solution {\n    public int maxProfit(int[] prices) {\n        int currentstock = prices[0];   \n        int totalprofit = 0;\n        for(int i=0; i<prices.length-1; ++i) {\n            if(prices[i] > prices[i+1]) {   //Reseting current stock\n                currentstock = prices[i+1];\n            } else {\n                //Checking for max value in right of current stock\n                while(i<(prices.length-1) && prices[i] < prices[i+1]) { \n                    ++i;\n                }\n                //Calculating profit\n                totalprofit += prices[i] - currentstock;\n                //Setting current stock to next index of maxi value\n                if(i<prices.length-1) {\n                    currentstock = prices[i+1];\n                }\n            }\n        }\n        \n        return totalprofit;\n    }\n}"
                    },
                    {
                        "username": "ignorant_ppp",
                        "content": "can anyone explain me how second testcase working ?? "
                    },
                    {
                        "username": "debaudh",
                        "content": "\"Medium\" ?? really ?!"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Nah, just kidding"
                    },
                    {
                        "username": "gurnainwadhwa",
                        "content": "can be easily solved in O(n)"
                    }
                ]
            },
            {
                "id": 1892088,
                "content": [
                    {
                        "username": "MenaiAla",
                        "content": "**Same day** confused me a lot."
                    },
                    {
                        "username": "zalars",
                        "content": "What\\'s the point to describe such a task in that form if we can\\'t buy and sell in the past from the present?"
                    },
                    {
                        "username": "user4184tG",
                        "content": "there seems to be a problem with Ex1: when you rebuy the stock on day 4 (price = 3) you spend the given amount, thereby taking away from the net profit [by 3 in this case].\neach time a repurchase is made, money is spent- which takes away from the net profit (I'm assuming)"
                    },
                    {
                        "username": "apjo2009",
                        "content": "so that means in the example 2 where prices=[1,2,3,4,5], i can buy on day 1 sell on day 2 profit=2-1=1, buy on day 2 sell on day 3 profit=1+(3-2)=1+1=2, buy on day 3 sell on day 4 profit = 2+(4-3)=3, and finally buy on day 4 & sell on day 5 profit=3+(5-4)=4, is this right? "
                    },
                    {
                        "username": "Skripko",
                        "content": "This task must be easy! "
                    },
                    {
                        "username": "georgezakharov",
                        "content": "They all say that the problem should be easy until they got it on an interview (c)"
                    },
                    {
                        "username": "user7854c",
                        "content": "[3,3,5,0,0,3,1,4]\\n\\nThis test case is spitting wrong expected output? My o/p is 6, expected is 8.\\nTell me how it is 8?"
                    },
                    {
                        "username": "PratD",
                        "content": "\nBuy at index 0 and sell at 2 --> (3,5) = 2\nBuy at index 3 and sell at 5 --> (0,3) = 3\nBuy at index 6 and sell at 7 --> (1,4) = 3\n\nTotal is 2+3+3 = 8"
                    },
                    {
                        "username": "Syed_Waseem",
                        "content": "1) In this question whenever stock value goes down reset your current stock\n\n2) After setting current stock check for value which is max in the right of current stock(for max profit) then calculate profit and add it to totalProfit\n\n3)Then set your current stock to next index of maximum value(because at maximum value we sold our stock) now we want new stock\n\ncode:-\nclass Solution {\n    public int maxProfit(int[] prices) {\n        int currentstock = prices[0];   \n        int totalprofit = 0;\n        for(int i=0; i<prices.length-1; ++i) {\n            if(prices[i] > prices[i+1]) {   //Reseting current stock\n                currentstock = prices[i+1];\n            } else {\n                //Checking for max value in right of current stock\n                while(i<(prices.length-1) && prices[i] < prices[i+1]) { \n                    ++i;\n                }\n                //Calculating profit\n                totalprofit += prices[i] - currentstock;\n                //Setting current stock to next index of maxi value\n                if(i<prices.length-1) {\n                    currentstock = prices[i+1];\n                }\n            }\n        }\n        \n        return totalprofit;\n    }\n}"
                    },
                    {
                        "username": "ignorant_ppp",
                        "content": "can anyone explain me how second testcase working ?? "
                    },
                    {
                        "username": "debaudh",
                        "content": "\"Medium\" ?? really ?!"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Nah, just kidding"
                    },
                    {
                        "username": "gurnainwadhwa",
                        "content": "can be easily solved in O(n)"
                    }
                ]
            },
            {
                "id": 1880969,
                "content": [
                    {
                        "username": "MenaiAla",
                        "content": "**Same day** confused me a lot."
                    },
                    {
                        "username": "zalars",
                        "content": "What\\'s the point to describe such a task in that form if we can\\'t buy and sell in the past from the present?"
                    },
                    {
                        "username": "user4184tG",
                        "content": "there seems to be a problem with Ex1: when you rebuy the stock on day 4 (price = 3) you spend the given amount, thereby taking away from the net profit [by 3 in this case].\neach time a repurchase is made, money is spent- which takes away from the net profit (I'm assuming)"
                    },
                    {
                        "username": "apjo2009",
                        "content": "so that means in the example 2 where prices=[1,2,3,4,5], i can buy on day 1 sell on day 2 profit=2-1=1, buy on day 2 sell on day 3 profit=1+(3-2)=1+1=2, buy on day 3 sell on day 4 profit = 2+(4-3)=3, and finally buy on day 4 & sell on day 5 profit=3+(5-4)=4, is this right? "
                    },
                    {
                        "username": "Skripko",
                        "content": "This task must be easy! "
                    },
                    {
                        "username": "georgezakharov",
                        "content": "They all say that the problem should be easy until they got it on an interview (c)"
                    },
                    {
                        "username": "user7854c",
                        "content": "[3,3,5,0,0,3,1,4]\\n\\nThis test case is spitting wrong expected output? My o/p is 6, expected is 8.\\nTell me how it is 8?"
                    },
                    {
                        "username": "PratD",
                        "content": "\nBuy at index 0 and sell at 2 --> (3,5) = 2\nBuy at index 3 and sell at 5 --> (0,3) = 3\nBuy at index 6 and sell at 7 --> (1,4) = 3\n\nTotal is 2+3+3 = 8"
                    },
                    {
                        "username": "Syed_Waseem",
                        "content": "1) In this question whenever stock value goes down reset your current stock\n\n2) After setting current stock check for value which is max in the right of current stock(for max profit) then calculate profit and add it to totalProfit\n\n3)Then set your current stock to next index of maximum value(because at maximum value we sold our stock) now we want new stock\n\ncode:-\nclass Solution {\n    public int maxProfit(int[] prices) {\n        int currentstock = prices[0];   \n        int totalprofit = 0;\n        for(int i=0; i<prices.length-1; ++i) {\n            if(prices[i] > prices[i+1]) {   //Reseting current stock\n                currentstock = prices[i+1];\n            } else {\n                //Checking for max value in right of current stock\n                while(i<(prices.length-1) && prices[i] < prices[i+1]) { \n                    ++i;\n                }\n                //Calculating profit\n                totalprofit += prices[i] - currentstock;\n                //Setting current stock to next index of maxi value\n                if(i<prices.length-1) {\n                    currentstock = prices[i+1];\n                }\n            }\n        }\n        \n        return totalprofit;\n    }\n}"
                    },
                    {
                        "username": "ignorant_ppp",
                        "content": "can anyone explain me how second testcase working ?? "
                    },
                    {
                        "username": "debaudh",
                        "content": "\"Medium\" ?? really ?!"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Nah, just kidding"
                    },
                    {
                        "username": "gurnainwadhwa",
                        "content": "can be easily solved in O(n)"
                    }
                ]
            },
            {
                "id": 1870133,
                "content": [
                    {
                        "username": "MenaiAla",
                        "content": "**Same day** confused me a lot."
                    },
                    {
                        "username": "zalars",
                        "content": "What\\'s the point to describe such a task in that form if we can\\'t buy and sell in the past from the present?"
                    },
                    {
                        "username": "user4184tG",
                        "content": "there seems to be a problem with Ex1: when you rebuy the stock on day 4 (price = 3) you spend the given amount, thereby taking away from the net profit [by 3 in this case].\neach time a repurchase is made, money is spent- which takes away from the net profit (I'm assuming)"
                    },
                    {
                        "username": "apjo2009",
                        "content": "so that means in the example 2 where prices=[1,2,3,4,5], i can buy on day 1 sell on day 2 profit=2-1=1, buy on day 2 sell on day 3 profit=1+(3-2)=1+1=2, buy on day 3 sell on day 4 profit = 2+(4-3)=3, and finally buy on day 4 & sell on day 5 profit=3+(5-4)=4, is this right? "
                    },
                    {
                        "username": "Skripko",
                        "content": "This task must be easy! "
                    },
                    {
                        "username": "georgezakharov",
                        "content": "They all say that the problem should be easy until they got it on an interview (c)"
                    },
                    {
                        "username": "user7854c",
                        "content": "[3,3,5,0,0,3,1,4]\\n\\nThis test case is spitting wrong expected output? My o/p is 6, expected is 8.\\nTell me how it is 8?"
                    },
                    {
                        "username": "PratD",
                        "content": "\nBuy at index 0 and sell at 2 --> (3,5) = 2\nBuy at index 3 and sell at 5 --> (0,3) = 3\nBuy at index 6 and sell at 7 --> (1,4) = 3\n\nTotal is 2+3+3 = 8"
                    },
                    {
                        "username": "Syed_Waseem",
                        "content": "1) In this question whenever stock value goes down reset your current stock\n\n2) After setting current stock check for value which is max in the right of current stock(for max profit) then calculate profit and add it to totalProfit\n\n3)Then set your current stock to next index of maximum value(because at maximum value we sold our stock) now we want new stock\n\ncode:-\nclass Solution {\n    public int maxProfit(int[] prices) {\n        int currentstock = prices[0];   \n        int totalprofit = 0;\n        for(int i=0; i<prices.length-1; ++i) {\n            if(prices[i] > prices[i+1]) {   //Reseting current stock\n                currentstock = prices[i+1];\n            } else {\n                //Checking for max value in right of current stock\n                while(i<(prices.length-1) && prices[i] < prices[i+1]) { \n                    ++i;\n                }\n                //Calculating profit\n                totalprofit += prices[i] - currentstock;\n                //Setting current stock to next index of maxi value\n                if(i<prices.length-1) {\n                    currentstock = prices[i+1];\n                }\n            }\n        }\n        \n        return totalprofit;\n    }\n}"
                    },
                    {
                        "username": "ignorant_ppp",
                        "content": "can anyone explain me how second testcase working ?? "
                    },
                    {
                        "username": "debaudh",
                        "content": "\"Medium\" ?? really ?!"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Nah, just kidding"
                    },
                    {
                        "username": "gurnainwadhwa",
                        "content": "can be easily solved in O(n)"
                    }
                ]
            },
            {
                "id": 1868089,
                "content": [
                    {
                        "username": "MenaiAla",
                        "content": "**Same day** confused me a lot."
                    },
                    {
                        "username": "zalars",
                        "content": "What\\'s the point to describe such a task in that form if we can\\'t buy and sell in the past from the present?"
                    },
                    {
                        "username": "user4184tG",
                        "content": "there seems to be a problem with Ex1: when you rebuy the stock on day 4 (price = 3) you spend the given amount, thereby taking away from the net profit [by 3 in this case].\neach time a repurchase is made, money is spent- which takes away from the net profit (I'm assuming)"
                    },
                    {
                        "username": "apjo2009",
                        "content": "so that means in the example 2 where prices=[1,2,3,4,5], i can buy on day 1 sell on day 2 profit=2-1=1, buy on day 2 sell on day 3 profit=1+(3-2)=1+1=2, buy on day 3 sell on day 4 profit = 2+(4-3)=3, and finally buy on day 4 & sell on day 5 profit=3+(5-4)=4, is this right? "
                    },
                    {
                        "username": "Skripko",
                        "content": "This task must be easy! "
                    },
                    {
                        "username": "georgezakharov",
                        "content": "They all say that the problem should be easy until they got it on an interview (c)"
                    },
                    {
                        "username": "user7854c",
                        "content": "[3,3,5,0,0,3,1,4]\\n\\nThis test case is spitting wrong expected output? My o/p is 6, expected is 8.\\nTell me how it is 8?"
                    },
                    {
                        "username": "PratD",
                        "content": "\nBuy at index 0 and sell at 2 --> (3,5) = 2\nBuy at index 3 and sell at 5 --> (0,3) = 3\nBuy at index 6 and sell at 7 --> (1,4) = 3\n\nTotal is 2+3+3 = 8"
                    },
                    {
                        "username": "Syed_Waseem",
                        "content": "1) In this question whenever stock value goes down reset your current stock\n\n2) After setting current stock check for value which is max in the right of current stock(for max profit) then calculate profit and add it to totalProfit\n\n3)Then set your current stock to next index of maximum value(because at maximum value we sold our stock) now we want new stock\n\ncode:-\nclass Solution {\n    public int maxProfit(int[] prices) {\n        int currentstock = prices[0];   \n        int totalprofit = 0;\n        for(int i=0; i<prices.length-1; ++i) {\n            if(prices[i] > prices[i+1]) {   //Reseting current stock\n                currentstock = prices[i+1];\n            } else {\n                //Checking for max value in right of current stock\n                while(i<(prices.length-1) && prices[i] < prices[i+1]) { \n                    ++i;\n                }\n                //Calculating profit\n                totalprofit += prices[i] - currentstock;\n                //Setting current stock to next index of maxi value\n                if(i<prices.length-1) {\n                    currentstock = prices[i+1];\n                }\n            }\n        }\n        \n        return totalprofit;\n    }\n}"
                    },
                    {
                        "username": "ignorant_ppp",
                        "content": "can anyone explain me how second testcase working ?? "
                    },
                    {
                        "username": "debaudh",
                        "content": "\"Medium\" ?? really ?!"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Nah, just kidding"
                    },
                    {
                        "username": "gurnainwadhwa",
                        "content": "can be easily solved in O(n)"
                    }
                ]
            },
            {
                "id": 1863935,
                "content": [
                    {
                        "username": "MenaiAla",
                        "content": "**Same day** confused me a lot."
                    },
                    {
                        "username": "zalars",
                        "content": "What\\'s the point to describe such a task in that form if we can\\'t buy and sell in the past from the present?"
                    },
                    {
                        "username": "user4184tG",
                        "content": "there seems to be a problem with Ex1: when you rebuy the stock on day 4 (price = 3) you spend the given amount, thereby taking away from the net profit [by 3 in this case].\neach time a repurchase is made, money is spent- which takes away from the net profit (I'm assuming)"
                    },
                    {
                        "username": "apjo2009",
                        "content": "so that means in the example 2 where prices=[1,2,3,4,5], i can buy on day 1 sell on day 2 profit=2-1=1, buy on day 2 sell on day 3 profit=1+(3-2)=1+1=2, buy on day 3 sell on day 4 profit = 2+(4-3)=3, and finally buy on day 4 & sell on day 5 profit=3+(5-4)=4, is this right? "
                    },
                    {
                        "username": "Skripko",
                        "content": "This task must be easy! "
                    },
                    {
                        "username": "georgezakharov",
                        "content": "They all say that the problem should be easy until they got it on an interview (c)"
                    },
                    {
                        "username": "user7854c",
                        "content": "[3,3,5,0,0,3,1,4]\\n\\nThis test case is spitting wrong expected output? My o/p is 6, expected is 8.\\nTell me how it is 8?"
                    },
                    {
                        "username": "PratD",
                        "content": "\nBuy at index 0 and sell at 2 --> (3,5) = 2\nBuy at index 3 and sell at 5 --> (0,3) = 3\nBuy at index 6 and sell at 7 --> (1,4) = 3\n\nTotal is 2+3+3 = 8"
                    },
                    {
                        "username": "Syed_Waseem",
                        "content": "1) In this question whenever stock value goes down reset your current stock\n\n2) After setting current stock check for value which is max in the right of current stock(for max profit) then calculate profit and add it to totalProfit\n\n3)Then set your current stock to next index of maximum value(because at maximum value we sold our stock) now we want new stock\n\ncode:-\nclass Solution {\n    public int maxProfit(int[] prices) {\n        int currentstock = prices[0];   \n        int totalprofit = 0;\n        for(int i=0; i<prices.length-1; ++i) {\n            if(prices[i] > prices[i+1]) {   //Reseting current stock\n                currentstock = prices[i+1];\n            } else {\n                //Checking for max value in right of current stock\n                while(i<(prices.length-1) && prices[i] < prices[i+1]) { \n                    ++i;\n                }\n                //Calculating profit\n                totalprofit += prices[i] - currentstock;\n                //Setting current stock to next index of maxi value\n                if(i<prices.length-1) {\n                    currentstock = prices[i+1];\n                }\n            }\n        }\n        \n        return totalprofit;\n    }\n}"
                    },
                    {
                        "username": "ignorant_ppp",
                        "content": "can anyone explain me how second testcase working ?? "
                    },
                    {
                        "username": "debaudh",
                        "content": "\"Medium\" ?? really ?!"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Nah, just kidding"
                    },
                    {
                        "username": "gurnainwadhwa",
                        "content": "can be easily solved in O(n)"
                    }
                ]
            },
            {
                "id": 1860872,
                "content": [
                    {
                        "username": "MenaiAla",
                        "content": "**Same day** confused me a lot."
                    },
                    {
                        "username": "zalars",
                        "content": "What\\'s the point to describe such a task in that form if we can\\'t buy and sell in the past from the present?"
                    },
                    {
                        "username": "user4184tG",
                        "content": "there seems to be a problem with Ex1: when you rebuy the stock on day 4 (price = 3) you spend the given amount, thereby taking away from the net profit [by 3 in this case].\neach time a repurchase is made, money is spent- which takes away from the net profit (I'm assuming)"
                    },
                    {
                        "username": "apjo2009",
                        "content": "so that means in the example 2 where prices=[1,2,3,4,5], i can buy on day 1 sell on day 2 profit=2-1=1, buy on day 2 sell on day 3 profit=1+(3-2)=1+1=2, buy on day 3 sell on day 4 profit = 2+(4-3)=3, and finally buy on day 4 & sell on day 5 profit=3+(5-4)=4, is this right? "
                    },
                    {
                        "username": "Skripko",
                        "content": "This task must be easy! "
                    },
                    {
                        "username": "georgezakharov",
                        "content": "They all say that the problem should be easy until they got it on an interview (c)"
                    },
                    {
                        "username": "user7854c",
                        "content": "[3,3,5,0,0,3,1,4]\\n\\nThis test case is spitting wrong expected output? My o/p is 6, expected is 8.\\nTell me how it is 8?"
                    },
                    {
                        "username": "PratD",
                        "content": "\nBuy at index 0 and sell at 2 --> (3,5) = 2\nBuy at index 3 and sell at 5 --> (0,3) = 3\nBuy at index 6 and sell at 7 --> (1,4) = 3\n\nTotal is 2+3+3 = 8"
                    },
                    {
                        "username": "Syed_Waseem",
                        "content": "1) In this question whenever stock value goes down reset your current stock\n\n2) After setting current stock check for value which is max in the right of current stock(for max profit) then calculate profit and add it to totalProfit\n\n3)Then set your current stock to next index of maximum value(because at maximum value we sold our stock) now we want new stock\n\ncode:-\nclass Solution {\n    public int maxProfit(int[] prices) {\n        int currentstock = prices[0];   \n        int totalprofit = 0;\n        for(int i=0; i<prices.length-1; ++i) {\n            if(prices[i] > prices[i+1]) {   //Reseting current stock\n                currentstock = prices[i+1];\n            } else {\n                //Checking for max value in right of current stock\n                while(i<(prices.length-1) && prices[i] < prices[i+1]) { \n                    ++i;\n                }\n                //Calculating profit\n                totalprofit += prices[i] - currentstock;\n                //Setting current stock to next index of maxi value\n                if(i<prices.length-1) {\n                    currentstock = prices[i+1];\n                }\n            }\n        }\n        \n        return totalprofit;\n    }\n}"
                    },
                    {
                        "username": "ignorant_ppp",
                        "content": "can anyone explain me how second testcase working ?? "
                    },
                    {
                        "username": "debaudh",
                        "content": "\"Medium\" ?? really ?!"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Nah, just kidding"
                    },
                    {
                        "username": "gurnainwadhwa",
                        "content": "can be easily solved in O(n)"
                    }
                ]
            },
            {
                "id": 1860713,
                "content": [
                    {
                        "username": "MenaiAla",
                        "content": "**Same day** confused me a lot."
                    },
                    {
                        "username": "zalars",
                        "content": "What\\'s the point to describe such a task in that form if we can\\'t buy and sell in the past from the present?"
                    },
                    {
                        "username": "user4184tG",
                        "content": "there seems to be a problem with Ex1: when you rebuy the stock on day 4 (price = 3) you spend the given amount, thereby taking away from the net profit [by 3 in this case].\neach time a repurchase is made, money is spent- which takes away from the net profit (I'm assuming)"
                    },
                    {
                        "username": "apjo2009",
                        "content": "so that means in the example 2 where prices=[1,2,3,4,5], i can buy on day 1 sell on day 2 profit=2-1=1, buy on day 2 sell on day 3 profit=1+(3-2)=1+1=2, buy on day 3 sell on day 4 profit = 2+(4-3)=3, and finally buy on day 4 & sell on day 5 profit=3+(5-4)=4, is this right? "
                    },
                    {
                        "username": "Skripko",
                        "content": "This task must be easy! "
                    },
                    {
                        "username": "georgezakharov",
                        "content": "They all say that the problem should be easy until they got it on an interview (c)"
                    },
                    {
                        "username": "user7854c",
                        "content": "[3,3,5,0,0,3,1,4]\\n\\nThis test case is spitting wrong expected output? My o/p is 6, expected is 8.\\nTell me how it is 8?"
                    },
                    {
                        "username": "PratD",
                        "content": "\nBuy at index 0 and sell at 2 --> (3,5) = 2\nBuy at index 3 and sell at 5 --> (0,3) = 3\nBuy at index 6 and sell at 7 --> (1,4) = 3\n\nTotal is 2+3+3 = 8"
                    },
                    {
                        "username": "Syed_Waseem",
                        "content": "1) In this question whenever stock value goes down reset your current stock\n\n2) After setting current stock check for value which is max in the right of current stock(for max profit) then calculate profit and add it to totalProfit\n\n3)Then set your current stock to next index of maximum value(because at maximum value we sold our stock) now we want new stock\n\ncode:-\nclass Solution {\n    public int maxProfit(int[] prices) {\n        int currentstock = prices[0];   \n        int totalprofit = 0;\n        for(int i=0; i<prices.length-1; ++i) {\n            if(prices[i] > prices[i+1]) {   //Reseting current stock\n                currentstock = prices[i+1];\n            } else {\n                //Checking for max value in right of current stock\n                while(i<(prices.length-1) && prices[i] < prices[i+1]) { \n                    ++i;\n                }\n                //Calculating profit\n                totalprofit += prices[i] - currentstock;\n                //Setting current stock to next index of maxi value\n                if(i<prices.length-1) {\n                    currentstock = prices[i+1];\n                }\n            }\n        }\n        \n        return totalprofit;\n    }\n}"
                    },
                    {
                        "username": "ignorant_ppp",
                        "content": "can anyone explain me how second testcase working ?? "
                    },
                    {
                        "username": "debaudh",
                        "content": "\"Medium\" ?? really ?!"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Nah, just kidding"
                    },
                    {
                        "username": "gurnainwadhwa",
                        "content": "can be easily solved in O(n)"
                    }
                ]
            },
            {
                "id": 1841474,
                "content": [
                    {
                        "username": "MenaiAla",
                        "content": "**Same day** confused me a lot."
                    },
                    {
                        "username": "zalars",
                        "content": "What\\'s the point to describe such a task in that form if we can\\'t buy and sell in the past from the present?"
                    },
                    {
                        "username": "user4184tG",
                        "content": "there seems to be a problem with Ex1: when you rebuy the stock on day 4 (price = 3) you spend the given amount, thereby taking away from the net profit [by 3 in this case].\neach time a repurchase is made, money is spent- which takes away from the net profit (I'm assuming)"
                    },
                    {
                        "username": "apjo2009",
                        "content": "so that means in the example 2 where prices=[1,2,3,4,5], i can buy on day 1 sell on day 2 profit=2-1=1, buy on day 2 sell on day 3 profit=1+(3-2)=1+1=2, buy on day 3 sell on day 4 profit = 2+(4-3)=3, and finally buy on day 4 & sell on day 5 profit=3+(5-4)=4, is this right? "
                    },
                    {
                        "username": "Skripko",
                        "content": "This task must be easy! "
                    },
                    {
                        "username": "georgezakharov",
                        "content": "They all say that the problem should be easy until they got it on an interview (c)"
                    },
                    {
                        "username": "user7854c",
                        "content": "[3,3,5,0,0,3,1,4]\\n\\nThis test case is spitting wrong expected output? My o/p is 6, expected is 8.\\nTell me how it is 8?"
                    },
                    {
                        "username": "PratD",
                        "content": "\nBuy at index 0 and sell at 2 --> (3,5) = 2\nBuy at index 3 and sell at 5 --> (0,3) = 3\nBuy at index 6 and sell at 7 --> (1,4) = 3\n\nTotal is 2+3+3 = 8"
                    },
                    {
                        "username": "Syed_Waseem",
                        "content": "1) In this question whenever stock value goes down reset your current stock\n\n2) After setting current stock check for value which is max in the right of current stock(for max profit) then calculate profit and add it to totalProfit\n\n3)Then set your current stock to next index of maximum value(because at maximum value we sold our stock) now we want new stock\n\ncode:-\nclass Solution {\n    public int maxProfit(int[] prices) {\n        int currentstock = prices[0];   \n        int totalprofit = 0;\n        for(int i=0; i<prices.length-1; ++i) {\n            if(prices[i] > prices[i+1]) {   //Reseting current stock\n                currentstock = prices[i+1];\n            } else {\n                //Checking for max value in right of current stock\n                while(i<(prices.length-1) && prices[i] < prices[i+1]) { \n                    ++i;\n                }\n                //Calculating profit\n                totalprofit += prices[i] - currentstock;\n                //Setting current stock to next index of maxi value\n                if(i<prices.length-1) {\n                    currentstock = prices[i+1];\n                }\n            }\n        }\n        \n        return totalprofit;\n    }\n}"
                    },
                    {
                        "username": "ignorant_ppp",
                        "content": "can anyone explain me how second testcase working ?? "
                    },
                    {
                        "username": "debaudh",
                        "content": "\"Medium\" ?? really ?!"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Nah, just kidding"
                    },
                    {
                        "username": "gurnainwadhwa",
                        "content": "can be easily solved in O(n)"
                    }
                ]
            },
            {
                "id": 1840210,
                "content": [
                    {
                        "username": "user2906qE",
                        "content": "This should be easy, solution is super simple, you just need to understand that max profit will be always whenever you can sell on a lover price that previous day."
                    },
                    {
                        "username": "georgezakharov",
                        "content": "They all say that the problem should be easy until they got it on an interview (c)"
                    },
                    {
                        "username": "jekatigr",
                        "content": "This problem should be `easy`-labeled and [previous buy-and-sell](https://leetcode.com/problems/best-time-to-buy-and-sell-stock) should be `medium`.\nSliding window approach in above task mush less intuitive than compare-with-prev-element-and-add approach in that one."
                    },
                    {
                        "username": "teckyshubham",
                        "content": "int [][]dp;\\n    public int helper(int []prices,boolean buy,boolean sell,int buyPr,int index){\\n        if(index==prices.length){\\n            return 0;\\n        }\\n        if(dp[index][buyPr]!=-1){\\n            return dp[index][buyPr];\\n        }\\n        int ans=0;\\n        if(buy){\\n            //two option either to sell orr not to sell\\n            int ansCheck1=helper(prices,false,sell,0,index+1)+(prices[index]);\\n            int ansCheck2=helper(prices,buy,sell,buyPr,index+1);\\n            ans=Math.max(ansCheck1,ansCheck2);\\n        }else{\\n            //two option either to buy the stock or to sell the stock\\n            int ansCheck1=helper(prices,true,sell,1,index+1)-prices[index];\\n            int ansCheck2=helper(prices,buy,sell,buyPr,index+1);\\n            ans=Math.max(ansCheck1,ansCheck2);\\n        }\\n        return dp[index][buyPr]=ans;\\n    }\\n    public int maxProfit(int[] prices) {\\n        dp=new int[prices.length+1][3];\\n        for(int []arr:dp){\\n            Arrays.fill(arr,-1);\\n        }\\n        return helper(prices,false,false,0,0);\\n    }\\n"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nBut lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "teckyshubham",
                        "content": " `int [][]dp;\\n    public int helper(int []prices,boolean buy,boolean sell,int buyPr,int index){\\n        if(index==prices.length){\\n            return 0;\\n        }\\n        if(dp[index][buyPr]!=-1){\\n            return dp[index][buyPr];\\n        }\\n        int ans=0;\\n        if(buy){\\n            //two option either to sell orr not to sell\\n            int ansCheck1=helper(prices,false,sell,0,index+1)+(prices[index]);\\n            int ansCheck2=helper(prices,buy,sell,buyPr,index+1);\\n            ans=Math.max(ansCheck1,ansCheck2);\\n        }else{\\n            //two option either to buy the stock or to sell the stock\\n            int ansCheck1=helper(prices,true,sell,1,index+1)-prices[index];\\n            int ansCheck2=helper(prices,buy,sell,buyPr,index+1);\\n            ans=Math.max(ansCheck1,ansCheck2);\\n        }\\n        return dp[index][buyPr]=ans;\\n    }\\n    public int maxProfit(int[] prices) {\\n        dp=new int[prices.length+1][3];\\n        for(int []arr:dp){\\n            Arrays.fill(arr,-1);\\n        }\\n        return helper(prices,false,false,0,0);\\n    }\\n `"
                    },
                    {
                        "username": "Tiger_Ros",
                        "content": "This was easier than the first version lol"
                    },
                    {
                        "username": "jkvin114",
                        "content": "I don`t understand why this one is included in DP study plan"
                    },
                    {
                        "username": "s1ttu",
                        "content": "just check for each i in prices whether it is greater then it previous version or not \\nprices[i]>prices[i-1] then calculate the difference and make a variable the stores difference of all \\nas it is mentioned in statement we can do the buy and sell operation as many times we want this approach will be like purcheasing the stock by checking tomarrows price of it \\nhere\\'s the python code of it \\n\\n maxx = 0\\n        for i in range(1, len(prices)):\\n            if prices[i] > prices[i-1]: maxx += prices[i] - prices[i-1]\\n        return maxx"
                    },
                    {
                        "username": "htcca",
                        "content": "only add every increasement to the result?"
                    },
                    {
                        "username": "colabee992",
                        "content": "Buy low sell high.\nIf profit, take, else, don't take. "
                    },
                    {
                        "username": "loia5tqd001",
                        "content": "This is how I will code it in real life (assuming there\\'s a transaction fee every time we make a transaction so I don\\'t want to just buy/sell every day, but wait for the trend to change only instead)\\n```\\nfunction maxProfit(prices: number[]): number {\\n    let lastBuy = -1;\\n    let lastSell = -1;\\n    let profit = 0;\\n    const havingStock = () => lastBuy > lastSell;\\n    const buy = (atIndex: number) => {\\n        lastBuy = atIndex;\\n    }\\n    const sell = (atIndex: number) => {\\n        lastSell = atIndex;\\n        const thisProfit = prices[lastSell] - prices[lastBuy];\\n        profit += thisProfit;\\n    }\\n    for (let i = 0; i < prices.length; i++) {\\n        const isLastItem = i === prices.length - 1;\\n        if (isLastItem && havingStock()) {\\n            sell(i);\\n            break;\\n        }\\n\\n        const willUp = prices[i + 1] > prices[i];\\n        if (willUp && !havingStock()) {\\n            buy(i);\\n        } \\n\\n        const willDown = prices[i + 1] < prices[i]\\n        if (willDown && havingStock()) {\\n            sell(i);\\n        }\\n    }\\n    return profit;\\n};\\n```"
                    }
                ]
            },
            {
                "id": 1827141,
                "content": [
                    {
                        "username": "user2906qE",
                        "content": "This should be easy, solution is super simple, you just need to understand that max profit will be always whenever you can sell on a lover price that previous day."
                    },
                    {
                        "username": "georgezakharov",
                        "content": "They all say that the problem should be easy until they got it on an interview (c)"
                    },
                    {
                        "username": "jekatigr",
                        "content": "This problem should be `easy`-labeled and [previous buy-and-sell](https://leetcode.com/problems/best-time-to-buy-and-sell-stock) should be `medium`.\nSliding window approach in above task mush less intuitive than compare-with-prev-element-and-add approach in that one."
                    },
                    {
                        "username": "teckyshubham",
                        "content": "int [][]dp;\\n    public int helper(int []prices,boolean buy,boolean sell,int buyPr,int index){\\n        if(index==prices.length){\\n            return 0;\\n        }\\n        if(dp[index][buyPr]!=-1){\\n            return dp[index][buyPr];\\n        }\\n        int ans=0;\\n        if(buy){\\n            //two option either to sell orr not to sell\\n            int ansCheck1=helper(prices,false,sell,0,index+1)+(prices[index]);\\n            int ansCheck2=helper(prices,buy,sell,buyPr,index+1);\\n            ans=Math.max(ansCheck1,ansCheck2);\\n        }else{\\n            //two option either to buy the stock or to sell the stock\\n            int ansCheck1=helper(prices,true,sell,1,index+1)-prices[index];\\n            int ansCheck2=helper(prices,buy,sell,buyPr,index+1);\\n            ans=Math.max(ansCheck1,ansCheck2);\\n        }\\n        return dp[index][buyPr]=ans;\\n    }\\n    public int maxProfit(int[] prices) {\\n        dp=new int[prices.length+1][3];\\n        for(int []arr:dp){\\n            Arrays.fill(arr,-1);\\n        }\\n        return helper(prices,false,false,0,0);\\n    }\\n"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nBut lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "teckyshubham",
                        "content": " `int [][]dp;\\n    public int helper(int []prices,boolean buy,boolean sell,int buyPr,int index){\\n        if(index==prices.length){\\n            return 0;\\n        }\\n        if(dp[index][buyPr]!=-1){\\n            return dp[index][buyPr];\\n        }\\n        int ans=0;\\n        if(buy){\\n            //two option either to sell orr not to sell\\n            int ansCheck1=helper(prices,false,sell,0,index+1)+(prices[index]);\\n            int ansCheck2=helper(prices,buy,sell,buyPr,index+1);\\n            ans=Math.max(ansCheck1,ansCheck2);\\n        }else{\\n            //two option either to buy the stock or to sell the stock\\n            int ansCheck1=helper(prices,true,sell,1,index+1)-prices[index];\\n            int ansCheck2=helper(prices,buy,sell,buyPr,index+1);\\n            ans=Math.max(ansCheck1,ansCheck2);\\n        }\\n        return dp[index][buyPr]=ans;\\n    }\\n    public int maxProfit(int[] prices) {\\n        dp=new int[prices.length+1][3];\\n        for(int []arr:dp){\\n            Arrays.fill(arr,-1);\\n        }\\n        return helper(prices,false,false,0,0);\\n    }\\n `"
                    },
                    {
                        "username": "Tiger_Ros",
                        "content": "This was easier than the first version lol"
                    },
                    {
                        "username": "jkvin114",
                        "content": "I don`t understand why this one is included in DP study plan"
                    },
                    {
                        "username": "s1ttu",
                        "content": "just check for each i in prices whether it is greater then it previous version or not \\nprices[i]>prices[i-1] then calculate the difference and make a variable the stores difference of all \\nas it is mentioned in statement we can do the buy and sell operation as many times we want this approach will be like purcheasing the stock by checking tomarrows price of it \\nhere\\'s the python code of it \\n\\n maxx = 0\\n        for i in range(1, len(prices)):\\n            if prices[i] > prices[i-1]: maxx += prices[i] - prices[i-1]\\n        return maxx"
                    },
                    {
                        "username": "htcca",
                        "content": "only add every increasement to the result?"
                    },
                    {
                        "username": "colabee992",
                        "content": "Buy low sell high.\nIf profit, take, else, don't take. "
                    },
                    {
                        "username": "loia5tqd001",
                        "content": "This is how I will code it in real life (assuming there\\'s a transaction fee every time we make a transaction so I don\\'t want to just buy/sell every day, but wait for the trend to change only instead)\\n```\\nfunction maxProfit(prices: number[]): number {\\n    let lastBuy = -1;\\n    let lastSell = -1;\\n    let profit = 0;\\n    const havingStock = () => lastBuy > lastSell;\\n    const buy = (atIndex: number) => {\\n        lastBuy = atIndex;\\n    }\\n    const sell = (atIndex: number) => {\\n        lastSell = atIndex;\\n        const thisProfit = prices[lastSell] - prices[lastBuy];\\n        profit += thisProfit;\\n    }\\n    for (let i = 0; i < prices.length; i++) {\\n        const isLastItem = i === prices.length - 1;\\n        if (isLastItem && havingStock()) {\\n            sell(i);\\n            break;\\n        }\\n\\n        const willUp = prices[i + 1] > prices[i];\\n        if (willUp && !havingStock()) {\\n            buy(i);\\n        } \\n\\n        const willDown = prices[i + 1] < prices[i]\\n        if (willDown && havingStock()) {\\n            sell(i);\\n        }\\n    }\\n    return profit;\\n};\\n```"
                    }
                ]
            },
            {
                "id": 1815153,
                "content": [
                    {
                        "username": "user2906qE",
                        "content": "This should be easy, solution is super simple, you just need to understand that max profit will be always whenever you can sell on a lover price that previous day."
                    },
                    {
                        "username": "georgezakharov",
                        "content": "They all say that the problem should be easy until they got it on an interview (c)"
                    },
                    {
                        "username": "jekatigr",
                        "content": "This problem should be `easy`-labeled and [previous buy-and-sell](https://leetcode.com/problems/best-time-to-buy-and-sell-stock) should be `medium`.\nSliding window approach in above task mush less intuitive than compare-with-prev-element-and-add approach in that one."
                    },
                    {
                        "username": "teckyshubham",
                        "content": "int [][]dp;\\n    public int helper(int []prices,boolean buy,boolean sell,int buyPr,int index){\\n        if(index==prices.length){\\n            return 0;\\n        }\\n        if(dp[index][buyPr]!=-1){\\n            return dp[index][buyPr];\\n        }\\n        int ans=0;\\n        if(buy){\\n            //two option either to sell orr not to sell\\n            int ansCheck1=helper(prices,false,sell,0,index+1)+(prices[index]);\\n            int ansCheck2=helper(prices,buy,sell,buyPr,index+1);\\n            ans=Math.max(ansCheck1,ansCheck2);\\n        }else{\\n            //two option either to buy the stock or to sell the stock\\n            int ansCheck1=helper(prices,true,sell,1,index+1)-prices[index];\\n            int ansCheck2=helper(prices,buy,sell,buyPr,index+1);\\n            ans=Math.max(ansCheck1,ansCheck2);\\n        }\\n        return dp[index][buyPr]=ans;\\n    }\\n    public int maxProfit(int[] prices) {\\n        dp=new int[prices.length+1][3];\\n        for(int []arr:dp){\\n            Arrays.fill(arr,-1);\\n        }\\n        return helper(prices,false,false,0,0);\\n    }\\n"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nBut lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "teckyshubham",
                        "content": " `int [][]dp;\\n    public int helper(int []prices,boolean buy,boolean sell,int buyPr,int index){\\n        if(index==prices.length){\\n            return 0;\\n        }\\n        if(dp[index][buyPr]!=-1){\\n            return dp[index][buyPr];\\n        }\\n        int ans=0;\\n        if(buy){\\n            //two option either to sell orr not to sell\\n            int ansCheck1=helper(prices,false,sell,0,index+1)+(prices[index]);\\n            int ansCheck2=helper(prices,buy,sell,buyPr,index+1);\\n            ans=Math.max(ansCheck1,ansCheck2);\\n        }else{\\n            //two option either to buy the stock or to sell the stock\\n            int ansCheck1=helper(prices,true,sell,1,index+1)-prices[index];\\n            int ansCheck2=helper(prices,buy,sell,buyPr,index+1);\\n            ans=Math.max(ansCheck1,ansCheck2);\\n        }\\n        return dp[index][buyPr]=ans;\\n    }\\n    public int maxProfit(int[] prices) {\\n        dp=new int[prices.length+1][3];\\n        for(int []arr:dp){\\n            Arrays.fill(arr,-1);\\n        }\\n        return helper(prices,false,false,0,0);\\n    }\\n `"
                    },
                    {
                        "username": "Tiger_Ros",
                        "content": "This was easier than the first version lol"
                    },
                    {
                        "username": "jkvin114",
                        "content": "I don`t understand why this one is included in DP study plan"
                    },
                    {
                        "username": "s1ttu",
                        "content": "just check for each i in prices whether it is greater then it previous version or not \\nprices[i]>prices[i-1] then calculate the difference and make a variable the stores difference of all \\nas it is mentioned in statement we can do the buy and sell operation as many times we want this approach will be like purcheasing the stock by checking tomarrows price of it \\nhere\\'s the python code of it \\n\\n maxx = 0\\n        for i in range(1, len(prices)):\\n            if prices[i] > prices[i-1]: maxx += prices[i] - prices[i-1]\\n        return maxx"
                    },
                    {
                        "username": "htcca",
                        "content": "only add every increasement to the result?"
                    },
                    {
                        "username": "colabee992",
                        "content": "Buy low sell high.\nIf profit, take, else, don't take. "
                    },
                    {
                        "username": "loia5tqd001",
                        "content": "This is how I will code it in real life (assuming there\\'s a transaction fee every time we make a transaction so I don\\'t want to just buy/sell every day, but wait for the trend to change only instead)\\n```\\nfunction maxProfit(prices: number[]): number {\\n    let lastBuy = -1;\\n    let lastSell = -1;\\n    let profit = 0;\\n    const havingStock = () => lastBuy > lastSell;\\n    const buy = (atIndex: number) => {\\n        lastBuy = atIndex;\\n    }\\n    const sell = (atIndex: number) => {\\n        lastSell = atIndex;\\n        const thisProfit = prices[lastSell] - prices[lastBuy];\\n        profit += thisProfit;\\n    }\\n    for (let i = 0; i < prices.length; i++) {\\n        const isLastItem = i === prices.length - 1;\\n        if (isLastItem && havingStock()) {\\n            sell(i);\\n            break;\\n        }\\n\\n        const willUp = prices[i + 1] > prices[i];\\n        if (willUp && !havingStock()) {\\n            buy(i);\\n        } \\n\\n        const willDown = prices[i + 1] < prices[i]\\n        if (willDown && havingStock()) {\\n            sell(i);\\n        }\\n    }\\n    return profit;\\n};\\n```"
                    }
                ]
            },
            {
                "id": 1815151,
                "content": [
                    {
                        "username": "user2906qE",
                        "content": "This should be easy, solution is super simple, you just need to understand that max profit will be always whenever you can sell on a lover price that previous day."
                    },
                    {
                        "username": "georgezakharov",
                        "content": "They all say that the problem should be easy until they got it on an interview (c)"
                    },
                    {
                        "username": "jekatigr",
                        "content": "This problem should be `easy`-labeled and [previous buy-and-sell](https://leetcode.com/problems/best-time-to-buy-and-sell-stock) should be `medium`.\nSliding window approach in above task mush less intuitive than compare-with-prev-element-and-add approach in that one."
                    },
                    {
                        "username": "teckyshubham",
                        "content": "int [][]dp;\\n    public int helper(int []prices,boolean buy,boolean sell,int buyPr,int index){\\n        if(index==prices.length){\\n            return 0;\\n        }\\n        if(dp[index][buyPr]!=-1){\\n            return dp[index][buyPr];\\n        }\\n        int ans=0;\\n        if(buy){\\n            //two option either to sell orr not to sell\\n            int ansCheck1=helper(prices,false,sell,0,index+1)+(prices[index]);\\n            int ansCheck2=helper(prices,buy,sell,buyPr,index+1);\\n            ans=Math.max(ansCheck1,ansCheck2);\\n        }else{\\n            //two option either to buy the stock or to sell the stock\\n            int ansCheck1=helper(prices,true,sell,1,index+1)-prices[index];\\n            int ansCheck2=helper(prices,buy,sell,buyPr,index+1);\\n            ans=Math.max(ansCheck1,ansCheck2);\\n        }\\n        return dp[index][buyPr]=ans;\\n    }\\n    public int maxProfit(int[] prices) {\\n        dp=new int[prices.length+1][3];\\n        for(int []arr:dp){\\n            Arrays.fill(arr,-1);\\n        }\\n        return helper(prices,false,false,0,0);\\n    }\\n"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nBut lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "teckyshubham",
                        "content": " `int [][]dp;\\n    public int helper(int []prices,boolean buy,boolean sell,int buyPr,int index){\\n        if(index==prices.length){\\n            return 0;\\n        }\\n        if(dp[index][buyPr]!=-1){\\n            return dp[index][buyPr];\\n        }\\n        int ans=0;\\n        if(buy){\\n            //two option either to sell orr not to sell\\n            int ansCheck1=helper(prices,false,sell,0,index+1)+(prices[index]);\\n            int ansCheck2=helper(prices,buy,sell,buyPr,index+1);\\n            ans=Math.max(ansCheck1,ansCheck2);\\n        }else{\\n            //two option either to buy the stock or to sell the stock\\n            int ansCheck1=helper(prices,true,sell,1,index+1)-prices[index];\\n            int ansCheck2=helper(prices,buy,sell,buyPr,index+1);\\n            ans=Math.max(ansCheck1,ansCheck2);\\n        }\\n        return dp[index][buyPr]=ans;\\n    }\\n    public int maxProfit(int[] prices) {\\n        dp=new int[prices.length+1][3];\\n        for(int []arr:dp){\\n            Arrays.fill(arr,-1);\\n        }\\n        return helper(prices,false,false,0,0);\\n    }\\n `"
                    },
                    {
                        "username": "Tiger_Ros",
                        "content": "This was easier than the first version lol"
                    },
                    {
                        "username": "jkvin114",
                        "content": "I don`t understand why this one is included in DP study plan"
                    },
                    {
                        "username": "s1ttu",
                        "content": "just check for each i in prices whether it is greater then it previous version or not \\nprices[i]>prices[i-1] then calculate the difference and make a variable the stores difference of all \\nas it is mentioned in statement we can do the buy and sell operation as many times we want this approach will be like purcheasing the stock by checking tomarrows price of it \\nhere\\'s the python code of it \\n\\n maxx = 0\\n        for i in range(1, len(prices)):\\n            if prices[i] > prices[i-1]: maxx += prices[i] - prices[i-1]\\n        return maxx"
                    },
                    {
                        "username": "htcca",
                        "content": "only add every increasement to the result?"
                    },
                    {
                        "username": "colabee992",
                        "content": "Buy low sell high.\nIf profit, take, else, don't take. "
                    },
                    {
                        "username": "loia5tqd001",
                        "content": "This is how I will code it in real life (assuming there\\'s a transaction fee every time we make a transaction so I don\\'t want to just buy/sell every day, but wait for the trend to change only instead)\\n```\\nfunction maxProfit(prices: number[]): number {\\n    let lastBuy = -1;\\n    let lastSell = -1;\\n    let profit = 0;\\n    const havingStock = () => lastBuy > lastSell;\\n    const buy = (atIndex: number) => {\\n        lastBuy = atIndex;\\n    }\\n    const sell = (atIndex: number) => {\\n        lastSell = atIndex;\\n        const thisProfit = prices[lastSell] - prices[lastBuy];\\n        profit += thisProfit;\\n    }\\n    for (let i = 0; i < prices.length; i++) {\\n        const isLastItem = i === prices.length - 1;\\n        if (isLastItem && havingStock()) {\\n            sell(i);\\n            break;\\n        }\\n\\n        const willUp = prices[i + 1] > prices[i];\\n        if (willUp && !havingStock()) {\\n            buy(i);\\n        } \\n\\n        const willDown = prices[i + 1] < prices[i]\\n        if (willDown && havingStock()) {\\n            sell(i);\\n        }\\n    }\\n    return profit;\\n};\\n```"
                    }
                ]
            },
            {
                "id": 1808623,
                "content": [
                    {
                        "username": "user2906qE",
                        "content": "This should be easy, solution is super simple, you just need to understand that max profit will be always whenever you can sell on a lover price that previous day."
                    },
                    {
                        "username": "georgezakharov",
                        "content": "They all say that the problem should be easy until they got it on an interview (c)"
                    },
                    {
                        "username": "jekatigr",
                        "content": "This problem should be `easy`-labeled and [previous buy-and-sell](https://leetcode.com/problems/best-time-to-buy-and-sell-stock) should be `medium`.\nSliding window approach in above task mush less intuitive than compare-with-prev-element-and-add approach in that one."
                    },
                    {
                        "username": "teckyshubham",
                        "content": "int [][]dp;\\n    public int helper(int []prices,boolean buy,boolean sell,int buyPr,int index){\\n        if(index==prices.length){\\n            return 0;\\n        }\\n        if(dp[index][buyPr]!=-1){\\n            return dp[index][buyPr];\\n        }\\n        int ans=0;\\n        if(buy){\\n            //two option either to sell orr not to sell\\n            int ansCheck1=helper(prices,false,sell,0,index+1)+(prices[index]);\\n            int ansCheck2=helper(prices,buy,sell,buyPr,index+1);\\n            ans=Math.max(ansCheck1,ansCheck2);\\n        }else{\\n            //two option either to buy the stock or to sell the stock\\n            int ansCheck1=helper(prices,true,sell,1,index+1)-prices[index];\\n            int ansCheck2=helper(prices,buy,sell,buyPr,index+1);\\n            ans=Math.max(ansCheck1,ansCheck2);\\n        }\\n        return dp[index][buyPr]=ans;\\n    }\\n    public int maxProfit(int[] prices) {\\n        dp=new int[prices.length+1][3];\\n        for(int []arr:dp){\\n            Arrays.fill(arr,-1);\\n        }\\n        return helper(prices,false,false,0,0);\\n    }\\n"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nBut lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "teckyshubham",
                        "content": " `int [][]dp;\\n    public int helper(int []prices,boolean buy,boolean sell,int buyPr,int index){\\n        if(index==prices.length){\\n            return 0;\\n        }\\n        if(dp[index][buyPr]!=-1){\\n            return dp[index][buyPr];\\n        }\\n        int ans=0;\\n        if(buy){\\n            //two option either to sell orr not to sell\\n            int ansCheck1=helper(prices,false,sell,0,index+1)+(prices[index]);\\n            int ansCheck2=helper(prices,buy,sell,buyPr,index+1);\\n            ans=Math.max(ansCheck1,ansCheck2);\\n        }else{\\n            //two option either to buy the stock or to sell the stock\\n            int ansCheck1=helper(prices,true,sell,1,index+1)-prices[index];\\n            int ansCheck2=helper(prices,buy,sell,buyPr,index+1);\\n            ans=Math.max(ansCheck1,ansCheck2);\\n        }\\n        return dp[index][buyPr]=ans;\\n    }\\n    public int maxProfit(int[] prices) {\\n        dp=new int[prices.length+1][3];\\n        for(int []arr:dp){\\n            Arrays.fill(arr,-1);\\n        }\\n        return helper(prices,false,false,0,0);\\n    }\\n `"
                    },
                    {
                        "username": "Tiger_Ros",
                        "content": "This was easier than the first version lol"
                    },
                    {
                        "username": "jkvin114",
                        "content": "I don`t understand why this one is included in DP study plan"
                    },
                    {
                        "username": "s1ttu",
                        "content": "just check for each i in prices whether it is greater then it previous version or not \\nprices[i]>prices[i-1] then calculate the difference and make a variable the stores difference of all \\nas it is mentioned in statement we can do the buy and sell operation as many times we want this approach will be like purcheasing the stock by checking tomarrows price of it \\nhere\\'s the python code of it \\n\\n maxx = 0\\n        for i in range(1, len(prices)):\\n            if prices[i] > prices[i-1]: maxx += prices[i] - prices[i-1]\\n        return maxx"
                    },
                    {
                        "username": "htcca",
                        "content": "only add every increasement to the result?"
                    },
                    {
                        "username": "colabee992",
                        "content": "Buy low sell high.\nIf profit, take, else, don't take. "
                    },
                    {
                        "username": "loia5tqd001",
                        "content": "This is how I will code it in real life (assuming there\\'s a transaction fee every time we make a transaction so I don\\'t want to just buy/sell every day, but wait for the trend to change only instead)\\n```\\nfunction maxProfit(prices: number[]): number {\\n    let lastBuy = -1;\\n    let lastSell = -1;\\n    let profit = 0;\\n    const havingStock = () => lastBuy > lastSell;\\n    const buy = (atIndex: number) => {\\n        lastBuy = atIndex;\\n    }\\n    const sell = (atIndex: number) => {\\n        lastSell = atIndex;\\n        const thisProfit = prices[lastSell] - prices[lastBuy];\\n        profit += thisProfit;\\n    }\\n    for (let i = 0; i < prices.length; i++) {\\n        const isLastItem = i === prices.length - 1;\\n        if (isLastItem && havingStock()) {\\n            sell(i);\\n            break;\\n        }\\n\\n        const willUp = prices[i + 1] > prices[i];\\n        if (willUp && !havingStock()) {\\n            buy(i);\\n        } \\n\\n        const willDown = prices[i + 1] < prices[i]\\n        if (willDown && havingStock()) {\\n            sell(i);\\n        }\\n    }\\n    return profit;\\n};\\n```"
                    }
                ]
            },
            {
                "id": 1793546,
                "content": [
                    {
                        "username": "user2906qE",
                        "content": "This should be easy, solution is super simple, you just need to understand that max profit will be always whenever you can sell on a lover price that previous day."
                    },
                    {
                        "username": "georgezakharov",
                        "content": "They all say that the problem should be easy until they got it on an interview (c)"
                    },
                    {
                        "username": "jekatigr",
                        "content": "This problem should be `easy`-labeled and [previous buy-and-sell](https://leetcode.com/problems/best-time-to-buy-and-sell-stock) should be `medium`.\nSliding window approach in above task mush less intuitive than compare-with-prev-element-and-add approach in that one."
                    },
                    {
                        "username": "teckyshubham",
                        "content": "int [][]dp;\\n    public int helper(int []prices,boolean buy,boolean sell,int buyPr,int index){\\n        if(index==prices.length){\\n            return 0;\\n        }\\n        if(dp[index][buyPr]!=-1){\\n            return dp[index][buyPr];\\n        }\\n        int ans=0;\\n        if(buy){\\n            //two option either to sell orr not to sell\\n            int ansCheck1=helper(prices,false,sell,0,index+1)+(prices[index]);\\n            int ansCheck2=helper(prices,buy,sell,buyPr,index+1);\\n            ans=Math.max(ansCheck1,ansCheck2);\\n        }else{\\n            //two option either to buy the stock or to sell the stock\\n            int ansCheck1=helper(prices,true,sell,1,index+1)-prices[index];\\n            int ansCheck2=helper(prices,buy,sell,buyPr,index+1);\\n            ans=Math.max(ansCheck1,ansCheck2);\\n        }\\n        return dp[index][buyPr]=ans;\\n    }\\n    public int maxProfit(int[] prices) {\\n        dp=new int[prices.length+1][3];\\n        for(int []arr:dp){\\n            Arrays.fill(arr,-1);\\n        }\\n        return helper(prices,false,false,0,0);\\n    }\\n"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nBut lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "teckyshubham",
                        "content": " `int [][]dp;\\n    public int helper(int []prices,boolean buy,boolean sell,int buyPr,int index){\\n        if(index==prices.length){\\n            return 0;\\n        }\\n        if(dp[index][buyPr]!=-1){\\n            return dp[index][buyPr];\\n        }\\n        int ans=0;\\n        if(buy){\\n            //two option either to sell orr not to sell\\n            int ansCheck1=helper(prices,false,sell,0,index+1)+(prices[index]);\\n            int ansCheck2=helper(prices,buy,sell,buyPr,index+1);\\n            ans=Math.max(ansCheck1,ansCheck2);\\n        }else{\\n            //two option either to buy the stock or to sell the stock\\n            int ansCheck1=helper(prices,true,sell,1,index+1)-prices[index];\\n            int ansCheck2=helper(prices,buy,sell,buyPr,index+1);\\n            ans=Math.max(ansCheck1,ansCheck2);\\n        }\\n        return dp[index][buyPr]=ans;\\n    }\\n    public int maxProfit(int[] prices) {\\n        dp=new int[prices.length+1][3];\\n        for(int []arr:dp){\\n            Arrays.fill(arr,-1);\\n        }\\n        return helper(prices,false,false,0,0);\\n    }\\n `"
                    },
                    {
                        "username": "Tiger_Ros",
                        "content": "This was easier than the first version lol"
                    },
                    {
                        "username": "jkvin114",
                        "content": "I don`t understand why this one is included in DP study plan"
                    },
                    {
                        "username": "s1ttu",
                        "content": "just check for each i in prices whether it is greater then it previous version or not \\nprices[i]>prices[i-1] then calculate the difference and make a variable the stores difference of all \\nas it is mentioned in statement we can do the buy and sell operation as many times we want this approach will be like purcheasing the stock by checking tomarrows price of it \\nhere\\'s the python code of it \\n\\n maxx = 0\\n        for i in range(1, len(prices)):\\n            if prices[i] > prices[i-1]: maxx += prices[i] - prices[i-1]\\n        return maxx"
                    },
                    {
                        "username": "htcca",
                        "content": "only add every increasement to the result?"
                    },
                    {
                        "username": "colabee992",
                        "content": "Buy low sell high.\nIf profit, take, else, don't take. "
                    },
                    {
                        "username": "loia5tqd001",
                        "content": "This is how I will code it in real life (assuming there\\'s a transaction fee every time we make a transaction so I don\\'t want to just buy/sell every day, but wait for the trend to change only instead)\\n```\\nfunction maxProfit(prices: number[]): number {\\n    let lastBuy = -1;\\n    let lastSell = -1;\\n    let profit = 0;\\n    const havingStock = () => lastBuy > lastSell;\\n    const buy = (atIndex: number) => {\\n        lastBuy = atIndex;\\n    }\\n    const sell = (atIndex: number) => {\\n        lastSell = atIndex;\\n        const thisProfit = prices[lastSell] - prices[lastBuy];\\n        profit += thisProfit;\\n    }\\n    for (let i = 0; i < prices.length; i++) {\\n        const isLastItem = i === prices.length - 1;\\n        if (isLastItem && havingStock()) {\\n            sell(i);\\n            break;\\n        }\\n\\n        const willUp = prices[i + 1] > prices[i];\\n        if (willUp && !havingStock()) {\\n            buy(i);\\n        } \\n\\n        const willDown = prices[i + 1] < prices[i]\\n        if (willDown && havingStock()) {\\n            sell(i);\\n        }\\n    }\\n    return profit;\\n};\\n```"
                    }
                ]
            },
            {
                "id": 1781018,
                "content": [
                    {
                        "username": "user2906qE",
                        "content": "This should be easy, solution is super simple, you just need to understand that max profit will be always whenever you can sell on a lover price that previous day."
                    },
                    {
                        "username": "georgezakharov",
                        "content": "They all say that the problem should be easy until they got it on an interview (c)"
                    },
                    {
                        "username": "jekatigr",
                        "content": "This problem should be `easy`-labeled and [previous buy-and-sell](https://leetcode.com/problems/best-time-to-buy-and-sell-stock) should be `medium`.\nSliding window approach in above task mush less intuitive than compare-with-prev-element-and-add approach in that one."
                    },
                    {
                        "username": "teckyshubham",
                        "content": "int [][]dp;\\n    public int helper(int []prices,boolean buy,boolean sell,int buyPr,int index){\\n        if(index==prices.length){\\n            return 0;\\n        }\\n        if(dp[index][buyPr]!=-1){\\n            return dp[index][buyPr];\\n        }\\n        int ans=0;\\n        if(buy){\\n            //two option either to sell orr not to sell\\n            int ansCheck1=helper(prices,false,sell,0,index+1)+(prices[index]);\\n            int ansCheck2=helper(prices,buy,sell,buyPr,index+1);\\n            ans=Math.max(ansCheck1,ansCheck2);\\n        }else{\\n            //two option either to buy the stock or to sell the stock\\n            int ansCheck1=helper(prices,true,sell,1,index+1)-prices[index];\\n            int ansCheck2=helper(prices,buy,sell,buyPr,index+1);\\n            ans=Math.max(ansCheck1,ansCheck2);\\n        }\\n        return dp[index][buyPr]=ans;\\n    }\\n    public int maxProfit(int[] prices) {\\n        dp=new int[prices.length+1][3];\\n        for(int []arr:dp){\\n            Arrays.fill(arr,-1);\\n        }\\n        return helper(prices,false,false,0,0);\\n    }\\n"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nBut lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "teckyshubham",
                        "content": " `int [][]dp;\\n    public int helper(int []prices,boolean buy,boolean sell,int buyPr,int index){\\n        if(index==prices.length){\\n            return 0;\\n        }\\n        if(dp[index][buyPr]!=-1){\\n            return dp[index][buyPr];\\n        }\\n        int ans=0;\\n        if(buy){\\n            //two option either to sell orr not to sell\\n            int ansCheck1=helper(prices,false,sell,0,index+1)+(prices[index]);\\n            int ansCheck2=helper(prices,buy,sell,buyPr,index+1);\\n            ans=Math.max(ansCheck1,ansCheck2);\\n        }else{\\n            //two option either to buy the stock or to sell the stock\\n            int ansCheck1=helper(prices,true,sell,1,index+1)-prices[index];\\n            int ansCheck2=helper(prices,buy,sell,buyPr,index+1);\\n            ans=Math.max(ansCheck1,ansCheck2);\\n        }\\n        return dp[index][buyPr]=ans;\\n    }\\n    public int maxProfit(int[] prices) {\\n        dp=new int[prices.length+1][3];\\n        for(int []arr:dp){\\n            Arrays.fill(arr,-1);\\n        }\\n        return helper(prices,false,false,0,0);\\n    }\\n `"
                    },
                    {
                        "username": "Tiger_Ros",
                        "content": "This was easier than the first version lol"
                    },
                    {
                        "username": "jkvin114",
                        "content": "I don`t understand why this one is included in DP study plan"
                    },
                    {
                        "username": "s1ttu",
                        "content": "just check for each i in prices whether it is greater then it previous version or not \\nprices[i]>prices[i-1] then calculate the difference and make a variable the stores difference of all \\nas it is mentioned in statement we can do the buy and sell operation as many times we want this approach will be like purcheasing the stock by checking tomarrows price of it \\nhere\\'s the python code of it \\n\\n maxx = 0\\n        for i in range(1, len(prices)):\\n            if prices[i] > prices[i-1]: maxx += prices[i] - prices[i-1]\\n        return maxx"
                    },
                    {
                        "username": "htcca",
                        "content": "only add every increasement to the result?"
                    },
                    {
                        "username": "colabee992",
                        "content": "Buy low sell high.\nIf profit, take, else, don't take. "
                    },
                    {
                        "username": "loia5tqd001",
                        "content": "This is how I will code it in real life (assuming there\\'s a transaction fee every time we make a transaction so I don\\'t want to just buy/sell every day, but wait for the trend to change only instead)\\n```\\nfunction maxProfit(prices: number[]): number {\\n    let lastBuy = -1;\\n    let lastSell = -1;\\n    let profit = 0;\\n    const havingStock = () => lastBuy > lastSell;\\n    const buy = (atIndex: number) => {\\n        lastBuy = atIndex;\\n    }\\n    const sell = (atIndex: number) => {\\n        lastSell = atIndex;\\n        const thisProfit = prices[lastSell] - prices[lastBuy];\\n        profit += thisProfit;\\n    }\\n    for (let i = 0; i < prices.length; i++) {\\n        const isLastItem = i === prices.length - 1;\\n        if (isLastItem && havingStock()) {\\n            sell(i);\\n            break;\\n        }\\n\\n        const willUp = prices[i + 1] > prices[i];\\n        if (willUp && !havingStock()) {\\n            buy(i);\\n        } \\n\\n        const willDown = prices[i + 1] < prices[i]\\n        if (willDown && havingStock()) {\\n            sell(i);\\n        }\\n    }\\n    return profit;\\n};\\n```"
                    }
                ]
            },
            {
                "id": 1775919,
                "content": [
                    {
                        "username": "user2906qE",
                        "content": "This should be easy, solution is super simple, you just need to understand that max profit will be always whenever you can sell on a lover price that previous day."
                    },
                    {
                        "username": "georgezakharov",
                        "content": "They all say that the problem should be easy until they got it on an interview (c)"
                    },
                    {
                        "username": "jekatigr",
                        "content": "This problem should be `easy`-labeled and [previous buy-and-sell](https://leetcode.com/problems/best-time-to-buy-and-sell-stock) should be `medium`.\nSliding window approach in above task mush less intuitive than compare-with-prev-element-and-add approach in that one."
                    },
                    {
                        "username": "teckyshubham",
                        "content": "int [][]dp;\\n    public int helper(int []prices,boolean buy,boolean sell,int buyPr,int index){\\n        if(index==prices.length){\\n            return 0;\\n        }\\n        if(dp[index][buyPr]!=-1){\\n            return dp[index][buyPr];\\n        }\\n        int ans=0;\\n        if(buy){\\n            //two option either to sell orr not to sell\\n            int ansCheck1=helper(prices,false,sell,0,index+1)+(prices[index]);\\n            int ansCheck2=helper(prices,buy,sell,buyPr,index+1);\\n            ans=Math.max(ansCheck1,ansCheck2);\\n        }else{\\n            //two option either to buy the stock or to sell the stock\\n            int ansCheck1=helper(prices,true,sell,1,index+1)-prices[index];\\n            int ansCheck2=helper(prices,buy,sell,buyPr,index+1);\\n            ans=Math.max(ansCheck1,ansCheck2);\\n        }\\n        return dp[index][buyPr]=ans;\\n    }\\n    public int maxProfit(int[] prices) {\\n        dp=new int[prices.length+1][3];\\n        for(int []arr:dp){\\n            Arrays.fill(arr,-1);\\n        }\\n        return helper(prices,false,false,0,0);\\n    }\\n"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nBut lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "teckyshubham",
                        "content": " `int [][]dp;\\n    public int helper(int []prices,boolean buy,boolean sell,int buyPr,int index){\\n        if(index==prices.length){\\n            return 0;\\n        }\\n        if(dp[index][buyPr]!=-1){\\n            return dp[index][buyPr];\\n        }\\n        int ans=0;\\n        if(buy){\\n            //two option either to sell orr not to sell\\n            int ansCheck1=helper(prices,false,sell,0,index+1)+(prices[index]);\\n            int ansCheck2=helper(prices,buy,sell,buyPr,index+1);\\n            ans=Math.max(ansCheck1,ansCheck2);\\n        }else{\\n            //two option either to buy the stock or to sell the stock\\n            int ansCheck1=helper(prices,true,sell,1,index+1)-prices[index];\\n            int ansCheck2=helper(prices,buy,sell,buyPr,index+1);\\n            ans=Math.max(ansCheck1,ansCheck2);\\n        }\\n        return dp[index][buyPr]=ans;\\n    }\\n    public int maxProfit(int[] prices) {\\n        dp=new int[prices.length+1][3];\\n        for(int []arr:dp){\\n            Arrays.fill(arr,-1);\\n        }\\n        return helper(prices,false,false,0,0);\\n    }\\n `"
                    },
                    {
                        "username": "Tiger_Ros",
                        "content": "This was easier than the first version lol"
                    },
                    {
                        "username": "jkvin114",
                        "content": "I don`t understand why this one is included in DP study plan"
                    },
                    {
                        "username": "s1ttu",
                        "content": "just check for each i in prices whether it is greater then it previous version or not \\nprices[i]>prices[i-1] then calculate the difference and make a variable the stores difference of all \\nas it is mentioned in statement we can do the buy and sell operation as many times we want this approach will be like purcheasing the stock by checking tomarrows price of it \\nhere\\'s the python code of it \\n\\n maxx = 0\\n        for i in range(1, len(prices)):\\n            if prices[i] > prices[i-1]: maxx += prices[i] - prices[i-1]\\n        return maxx"
                    },
                    {
                        "username": "htcca",
                        "content": "only add every increasement to the result?"
                    },
                    {
                        "username": "colabee992",
                        "content": "Buy low sell high.\nIf profit, take, else, don't take. "
                    },
                    {
                        "username": "loia5tqd001",
                        "content": "This is how I will code it in real life (assuming there\\'s a transaction fee every time we make a transaction so I don\\'t want to just buy/sell every day, but wait for the trend to change only instead)\\n```\\nfunction maxProfit(prices: number[]): number {\\n    let lastBuy = -1;\\n    let lastSell = -1;\\n    let profit = 0;\\n    const havingStock = () => lastBuy > lastSell;\\n    const buy = (atIndex: number) => {\\n        lastBuy = atIndex;\\n    }\\n    const sell = (atIndex: number) => {\\n        lastSell = atIndex;\\n        const thisProfit = prices[lastSell] - prices[lastBuy];\\n        profit += thisProfit;\\n    }\\n    for (let i = 0; i < prices.length; i++) {\\n        const isLastItem = i === prices.length - 1;\\n        if (isLastItem && havingStock()) {\\n            sell(i);\\n            break;\\n        }\\n\\n        const willUp = prices[i + 1] > prices[i];\\n        if (willUp && !havingStock()) {\\n            buy(i);\\n        } \\n\\n        const willDown = prices[i + 1] < prices[i]\\n        if (willDown && havingStock()) {\\n            sell(i);\\n        }\\n    }\\n    return profit;\\n};\\n```"
                    }
                ]
            },
            {
                "id": 1764764,
                "content": [
                    {
                        "username": "user2906qE",
                        "content": "This should be easy, solution is super simple, you just need to understand that max profit will be always whenever you can sell on a lover price that previous day."
                    },
                    {
                        "username": "georgezakharov",
                        "content": "They all say that the problem should be easy until they got it on an interview (c)"
                    },
                    {
                        "username": "jekatigr",
                        "content": "This problem should be `easy`-labeled and [previous buy-and-sell](https://leetcode.com/problems/best-time-to-buy-and-sell-stock) should be `medium`.\nSliding window approach in above task mush less intuitive than compare-with-prev-element-and-add approach in that one."
                    },
                    {
                        "username": "teckyshubham",
                        "content": "int [][]dp;\\n    public int helper(int []prices,boolean buy,boolean sell,int buyPr,int index){\\n        if(index==prices.length){\\n            return 0;\\n        }\\n        if(dp[index][buyPr]!=-1){\\n            return dp[index][buyPr];\\n        }\\n        int ans=0;\\n        if(buy){\\n            //two option either to sell orr not to sell\\n            int ansCheck1=helper(prices,false,sell,0,index+1)+(prices[index]);\\n            int ansCheck2=helper(prices,buy,sell,buyPr,index+1);\\n            ans=Math.max(ansCheck1,ansCheck2);\\n        }else{\\n            //two option either to buy the stock or to sell the stock\\n            int ansCheck1=helper(prices,true,sell,1,index+1)-prices[index];\\n            int ansCheck2=helper(prices,buy,sell,buyPr,index+1);\\n            ans=Math.max(ansCheck1,ansCheck2);\\n        }\\n        return dp[index][buyPr]=ans;\\n    }\\n    public int maxProfit(int[] prices) {\\n        dp=new int[prices.length+1][3];\\n        for(int []arr:dp){\\n            Arrays.fill(arr,-1);\\n        }\\n        return helper(prices,false,false,0,0);\\n    }\\n"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nBut lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "teckyshubham",
                        "content": " `int [][]dp;\\n    public int helper(int []prices,boolean buy,boolean sell,int buyPr,int index){\\n        if(index==prices.length){\\n            return 0;\\n        }\\n        if(dp[index][buyPr]!=-1){\\n            return dp[index][buyPr];\\n        }\\n        int ans=0;\\n        if(buy){\\n            //two option either to sell orr not to sell\\n            int ansCheck1=helper(prices,false,sell,0,index+1)+(prices[index]);\\n            int ansCheck2=helper(prices,buy,sell,buyPr,index+1);\\n            ans=Math.max(ansCheck1,ansCheck2);\\n        }else{\\n            //two option either to buy the stock or to sell the stock\\n            int ansCheck1=helper(prices,true,sell,1,index+1)-prices[index];\\n            int ansCheck2=helper(prices,buy,sell,buyPr,index+1);\\n            ans=Math.max(ansCheck1,ansCheck2);\\n        }\\n        return dp[index][buyPr]=ans;\\n    }\\n    public int maxProfit(int[] prices) {\\n        dp=new int[prices.length+1][3];\\n        for(int []arr:dp){\\n            Arrays.fill(arr,-1);\\n        }\\n        return helper(prices,false,false,0,0);\\n    }\\n `"
                    },
                    {
                        "username": "Tiger_Ros",
                        "content": "This was easier than the first version lol"
                    },
                    {
                        "username": "jkvin114",
                        "content": "I don`t understand why this one is included in DP study plan"
                    },
                    {
                        "username": "s1ttu",
                        "content": "just check for each i in prices whether it is greater then it previous version or not \\nprices[i]>prices[i-1] then calculate the difference and make a variable the stores difference of all \\nas it is mentioned in statement we can do the buy and sell operation as many times we want this approach will be like purcheasing the stock by checking tomarrows price of it \\nhere\\'s the python code of it \\n\\n maxx = 0\\n        for i in range(1, len(prices)):\\n            if prices[i] > prices[i-1]: maxx += prices[i] - prices[i-1]\\n        return maxx"
                    },
                    {
                        "username": "htcca",
                        "content": "only add every increasement to the result?"
                    },
                    {
                        "username": "colabee992",
                        "content": "Buy low sell high.\nIf profit, take, else, don't take. "
                    },
                    {
                        "username": "loia5tqd001",
                        "content": "This is how I will code it in real life (assuming there\\'s a transaction fee every time we make a transaction so I don\\'t want to just buy/sell every day, but wait for the trend to change only instead)\\n```\\nfunction maxProfit(prices: number[]): number {\\n    let lastBuy = -1;\\n    let lastSell = -1;\\n    let profit = 0;\\n    const havingStock = () => lastBuy > lastSell;\\n    const buy = (atIndex: number) => {\\n        lastBuy = atIndex;\\n    }\\n    const sell = (atIndex: number) => {\\n        lastSell = atIndex;\\n        const thisProfit = prices[lastSell] - prices[lastBuy];\\n        profit += thisProfit;\\n    }\\n    for (let i = 0; i < prices.length; i++) {\\n        const isLastItem = i === prices.length - 1;\\n        if (isLastItem && havingStock()) {\\n            sell(i);\\n            break;\\n        }\\n\\n        const willUp = prices[i + 1] > prices[i];\\n        if (willUp && !havingStock()) {\\n            buy(i);\\n        } \\n\\n        const willDown = prices[i + 1] < prices[i]\\n        if (willDown && havingStock()) {\\n            sell(i);\\n        }\\n    }\\n    return profit;\\n};\\n```"
                    }
                ]
            },
            {
                "id": 1759225,
                "content": [
                    {
                        "username": "user2906qE",
                        "content": "This should be easy, solution is super simple, you just need to understand that max profit will be always whenever you can sell on a lover price that previous day."
                    },
                    {
                        "username": "georgezakharov",
                        "content": "They all say that the problem should be easy until they got it on an interview (c)"
                    },
                    {
                        "username": "jekatigr",
                        "content": "This problem should be `easy`-labeled and [previous buy-and-sell](https://leetcode.com/problems/best-time-to-buy-and-sell-stock) should be `medium`.\nSliding window approach in above task mush less intuitive than compare-with-prev-element-and-add approach in that one."
                    },
                    {
                        "username": "teckyshubham",
                        "content": "int [][]dp;\\n    public int helper(int []prices,boolean buy,boolean sell,int buyPr,int index){\\n        if(index==prices.length){\\n            return 0;\\n        }\\n        if(dp[index][buyPr]!=-1){\\n            return dp[index][buyPr];\\n        }\\n        int ans=0;\\n        if(buy){\\n            //two option either to sell orr not to sell\\n            int ansCheck1=helper(prices,false,sell,0,index+1)+(prices[index]);\\n            int ansCheck2=helper(prices,buy,sell,buyPr,index+1);\\n            ans=Math.max(ansCheck1,ansCheck2);\\n        }else{\\n            //two option either to buy the stock or to sell the stock\\n            int ansCheck1=helper(prices,true,sell,1,index+1)-prices[index];\\n            int ansCheck2=helper(prices,buy,sell,buyPr,index+1);\\n            ans=Math.max(ansCheck1,ansCheck2);\\n        }\\n        return dp[index][buyPr]=ans;\\n    }\\n    public int maxProfit(int[] prices) {\\n        dp=new int[prices.length+1][3];\\n        for(int []arr:dp){\\n            Arrays.fill(arr,-1);\\n        }\\n        return helper(prices,false,false,0,0);\\n    }\\n"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nBut lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "teckyshubham",
                        "content": " `int [][]dp;\\n    public int helper(int []prices,boolean buy,boolean sell,int buyPr,int index){\\n        if(index==prices.length){\\n            return 0;\\n        }\\n        if(dp[index][buyPr]!=-1){\\n            return dp[index][buyPr];\\n        }\\n        int ans=0;\\n        if(buy){\\n            //two option either to sell orr not to sell\\n            int ansCheck1=helper(prices,false,sell,0,index+1)+(prices[index]);\\n            int ansCheck2=helper(prices,buy,sell,buyPr,index+1);\\n            ans=Math.max(ansCheck1,ansCheck2);\\n        }else{\\n            //two option either to buy the stock or to sell the stock\\n            int ansCheck1=helper(prices,true,sell,1,index+1)-prices[index];\\n            int ansCheck2=helper(prices,buy,sell,buyPr,index+1);\\n            ans=Math.max(ansCheck1,ansCheck2);\\n        }\\n        return dp[index][buyPr]=ans;\\n    }\\n    public int maxProfit(int[] prices) {\\n        dp=new int[prices.length+1][3];\\n        for(int []arr:dp){\\n            Arrays.fill(arr,-1);\\n        }\\n        return helper(prices,false,false,0,0);\\n    }\\n `"
                    },
                    {
                        "username": "Tiger_Ros",
                        "content": "This was easier than the first version lol"
                    },
                    {
                        "username": "jkvin114",
                        "content": "I don`t understand why this one is included in DP study plan"
                    },
                    {
                        "username": "s1ttu",
                        "content": "just check for each i in prices whether it is greater then it previous version or not \\nprices[i]>prices[i-1] then calculate the difference and make a variable the stores difference of all \\nas it is mentioned in statement we can do the buy and sell operation as many times we want this approach will be like purcheasing the stock by checking tomarrows price of it \\nhere\\'s the python code of it \\n\\n maxx = 0\\n        for i in range(1, len(prices)):\\n            if prices[i] > prices[i-1]: maxx += prices[i] - prices[i-1]\\n        return maxx"
                    },
                    {
                        "username": "htcca",
                        "content": "only add every increasement to the result?"
                    },
                    {
                        "username": "colabee992",
                        "content": "Buy low sell high.\nIf profit, take, else, don't take. "
                    },
                    {
                        "username": "loia5tqd001",
                        "content": "This is how I will code it in real life (assuming there\\'s a transaction fee every time we make a transaction so I don\\'t want to just buy/sell every day, but wait for the trend to change only instead)\\n```\\nfunction maxProfit(prices: number[]): number {\\n    let lastBuy = -1;\\n    let lastSell = -1;\\n    let profit = 0;\\n    const havingStock = () => lastBuy > lastSell;\\n    const buy = (atIndex: number) => {\\n        lastBuy = atIndex;\\n    }\\n    const sell = (atIndex: number) => {\\n        lastSell = atIndex;\\n        const thisProfit = prices[lastSell] - prices[lastBuy];\\n        profit += thisProfit;\\n    }\\n    for (let i = 0; i < prices.length; i++) {\\n        const isLastItem = i === prices.length - 1;\\n        if (isLastItem && havingStock()) {\\n            sell(i);\\n            break;\\n        }\\n\\n        const willUp = prices[i + 1] > prices[i];\\n        if (willUp && !havingStock()) {\\n            buy(i);\\n        } \\n\\n        const willDown = prices[i + 1] < prices[i]\\n        if (willDown && havingStock()) {\\n            sell(i);\\n        }\\n    }\\n    return profit;\\n};\\n```"
                    }
                ]
            },
            {
                "id": 1756344,
                "content": [
                    {
                        "username": "mohamed_waseela",
                        "content": "https://youtu.be/-Qpk2XJ5XJQ"
                    },
                    {
                        "username": "aditya223307",
                        "content": "can anyone tell me where i am doing wrong?\\nint maxProfit(vector<int>& prices) {\\n        unordered_map<int , int> m;\\n        m[prices[0]]=0;\\n        for(int i=1; i<prices.size(); i++){\\n            m[prices[i]]=prices[i] - prices[i-1];\\n        }\\n        int ans=0;\\n        for(auto it= m.begin(); it!= m.end() ; it++){\\n            if((*it).second >0){\\n                ans = ans + (*it).second;\\n            }\\n        }\\n        return ans;"
                    },
                    {
                        "username": "jje-",
                        "content": "Why the number of dislikes is so high?"
                    },
                    {
                        "username": "ymgcksge",
                        "content": "can i buy on the same day i sell?"
                    },
                    {
                        "username": "AnkushR10",
                        "content": "https://github.com/AnkushRawat10601/Leetcode/blob/main/122_buy_and_sell_stocks.cpp"
                    },
                    {
                        "username": "javeria",
                        "content": "Why is the brute force solution O(n^n)?"
                    },
                    {
                        "username": "adityasinghz",
                        "content": "it\\'s 2^n not n^n"
                    },
                    {
                        "username": "satyamS_71",
                        "content": "I understand the question but why is it tagged under dynamic programming , I mean ,  what part of the question tells that it is a dp question , or how one will know it requires a dp solution? \\n"
                    },
                    {
                        "username": "amanbanka100",
                        "content": "The difficulty level of this question should be Easy"
                    },
                    {
                        "username": "SaikatDass",
                        "content": "BEST OPTIMIZED SOLUTION IN JAVA | BEST TIME TO BUY AND SELL STOCK |\\nclass Solution {\\n    public int maxProfit(int[] prices) {\\n        int buyPrice = Integer.MAX_VALUE;\\n        int profit, maxProfit = 0;\\n        for(int i = 0; i < prices.length; i++){\\n            if(buyPrice > prices[i]){\\n                buyPrice = prices[i];\\n            }\\n            else if(buyPrice < prices[i]){\\n                profit = prices[i] - buyPrice;\\n                maxProfit += profit;\\n                buyPrice = prices[i];\\n            }\\n        }\\n        return maxProfit;\\n    }\\n}"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nBut lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "codewithvivekpandey",
                        "content": "dp solutoin \\n\\n `class Solution {\\npublic:\\n\\n    int f(int ind, bool canBuy, vector<int> &prices, vector<vector<int>> &dp){\\n        if(ind == prices.size()){\\n            return 0;\\n        }\\n\\n        if(dp[ind][canBuy] != -1)\\n            return dp[ind][canBuy];    \\n\\n        // check can buy\\n        if(canBuy){\\n            //buying\\n            int buying = -prices[ind] + f(ind+1,false,prices,dp);\\n            // not buy\\n            int notBuy = 0 + f(ind+1,true,prices,dp);\\n\\n            return dp[ind][canBuy] = max(buying, notBuy);\\n        }else{\\n            //selling\\n            int selling = prices[ind] + f(ind+1,true,prices,dp);\\n            //not sell\\n            int notSell = 0 + f(ind+1,false,prices,dp);\\n\\n            return dp[ind][canBuy] = max(selling,notSell);\\n        }\\n    }\\n\\n    int maxProfit(vector<int>& prices) {\\n        vector<vector<int>> dp(prices.size(), vector<int> (2,-1));\\n       return f(0,true,prices,dp); \\n    }\\n};`"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nBut lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    }
                ]
            },
            {
                "id": 1746030,
                "content": [
                    {
                        "username": "mohamed_waseela",
                        "content": "https://youtu.be/-Qpk2XJ5XJQ"
                    },
                    {
                        "username": "aditya223307",
                        "content": "can anyone tell me where i am doing wrong?\\nint maxProfit(vector<int>& prices) {\\n        unordered_map<int , int> m;\\n        m[prices[0]]=0;\\n        for(int i=1; i<prices.size(); i++){\\n            m[prices[i]]=prices[i] - prices[i-1];\\n        }\\n        int ans=0;\\n        for(auto it= m.begin(); it!= m.end() ; it++){\\n            if((*it).second >0){\\n                ans = ans + (*it).second;\\n            }\\n        }\\n        return ans;"
                    },
                    {
                        "username": "jje-",
                        "content": "Why the number of dislikes is so high?"
                    },
                    {
                        "username": "ymgcksge",
                        "content": "can i buy on the same day i sell?"
                    },
                    {
                        "username": "AnkushR10",
                        "content": "https://github.com/AnkushRawat10601/Leetcode/blob/main/122_buy_and_sell_stocks.cpp"
                    },
                    {
                        "username": "javeria",
                        "content": "Why is the brute force solution O(n^n)?"
                    },
                    {
                        "username": "adityasinghz",
                        "content": "it\\'s 2^n not n^n"
                    },
                    {
                        "username": "satyamS_71",
                        "content": "I understand the question but why is it tagged under dynamic programming , I mean ,  what part of the question tells that it is a dp question , or how one will know it requires a dp solution? \\n"
                    },
                    {
                        "username": "amanbanka100",
                        "content": "The difficulty level of this question should be Easy"
                    },
                    {
                        "username": "SaikatDass",
                        "content": "BEST OPTIMIZED SOLUTION IN JAVA | BEST TIME TO BUY AND SELL STOCK |\\nclass Solution {\\n    public int maxProfit(int[] prices) {\\n        int buyPrice = Integer.MAX_VALUE;\\n        int profit, maxProfit = 0;\\n        for(int i = 0; i < prices.length; i++){\\n            if(buyPrice > prices[i]){\\n                buyPrice = prices[i];\\n            }\\n            else if(buyPrice < prices[i]){\\n                profit = prices[i] - buyPrice;\\n                maxProfit += profit;\\n                buyPrice = prices[i];\\n            }\\n        }\\n        return maxProfit;\\n    }\\n}"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nBut lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "codewithvivekpandey",
                        "content": "dp solutoin \\n\\n `class Solution {\\npublic:\\n\\n    int f(int ind, bool canBuy, vector<int> &prices, vector<vector<int>> &dp){\\n        if(ind == prices.size()){\\n            return 0;\\n        }\\n\\n        if(dp[ind][canBuy] != -1)\\n            return dp[ind][canBuy];    \\n\\n        // check can buy\\n        if(canBuy){\\n            //buying\\n            int buying = -prices[ind] + f(ind+1,false,prices,dp);\\n            // not buy\\n            int notBuy = 0 + f(ind+1,true,prices,dp);\\n\\n            return dp[ind][canBuy] = max(buying, notBuy);\\n        }else{\\n            //selling\\n            int selling = prices[ind] + f(ind+1,true,prices,dp);\\n            //not sell\\n            int notSell = 0 + f(ind+1,false,prices,dp);\\n\\n            return dp[ind][canBuy] = max(selling,notSell);\\n        }\\n    }\\n\\n    int maxProfit(vector<int>& prices) {\\n        vector<vector<int>> dp(prices.size(), vector<int> (2,-1));\\n       return f(0,true,prices,dp); \\n    }\\n};`"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nBut lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    }
                ]
            },
            {
                "id": 1726313,
                "content": [
                    {
                        "username": "mohamed_waseela",
                        "content": "https://youtu.be/-Qpk2XJ5XJQ"
                    },
                    {
                        "username": "aditya223307",
                        "content": "can anyone tell me where i am doing wrong?\\nint maxProfit(vector<int>& prices) {\\n        unordered_map<int , int> m;\\n        m[prices[0]]=0;\\n        for(int i=1; i<prices.size(); i++){\\n            m[prices[i]]=prices[i] - prices[i-1];\\n        }\\n        int ans=0;\\n        for(auto it= m.begin(); it!= m.end() ; it++){\\n            if((*it).second >0){\\n                ans = ans + (*it).second;\\n            }\\n        }\\n        return ans;"
                    },
                    {
                        "username": "jje-",
                        "content": "Why the number of dislikes is so high?"
                    },
                    {
                        "username": "ymgcksge",
                        "content": "can i buy on the same day i sell?"
                    },
                    {
                        "username": "AnkushR10",
                        "content": "https://github.com/AnkushRawat10601/Leetcode/blob/main/122_buy_and_sell_stocks.cpp"
                    },
                    {
                        "username": "javeria",
                        "content": "Why is the brute force solution O(n^n)?"
                    },
                    {
                        "username": "adityasinghz",
                        "content": "it\\'s 2^n not n^n"
                    },
                    {
                        "username": "satyamS_71",
                        "content": "I understand the question but why is it tagged under dynamic programming , I mean ,  what part of the question tells that it is a dp question , or how one will know it requires a dp solution? \\n"
                    },
                    {
                        "username": "amanbanka100",
                        "content": "The difficulty level of this question should be Easy"
                    },
                    {
                        "username": "SaikatDass",
                        "content": "BEST OPTIMIZED SOLUTION IN JAVA | BEST TIME TO BUY AND SELL STOCK |\\nclass Solution {\\n    public int maxProfit(int[] prices) {\\n        int buyPrice = Integer.MAX_VALUE;\\n        int profit, maxProfit = 0;\\n        for(int i = 0; i < prices.length; i++){\\n            if(buyPrice > prices[i]){\\n                buyPrice = prices[i];\\n            }\\n            else if(buyPrice < prices[i]){\\n                profit = prices[i] - buyPrice;\\n                maxProfit += profit;\\n                buyPrice = prices[i];\\n            }\\n        }\\n        return maxProfit;\\n    }\\n}"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nBut lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "codewithvivekpandey",
                        "content": "dp solutoin \\n\\n `class Solution {\\npublic:\\n\\n    int f(int ind, bool canBuy, vector<int> &prices, vector<vector<int>> &dp){\\n        if(ind == prices.size()){\\n            return 0;\\n        }\\n\\n        if(dp[ind][canBuy] != -1)\\n            return dp[ind][canBuy];    \\n\\n        // check can buy\\n        if(canBuy){\\n            //buying\\n            int buying = -prices[ind] + f(ind+1,false,prices,dp);\\n            // not buy\\n            int notBuy = 0 + f(ind+1,true,prices,dp);\\n\\n            return dp[ind][canBuy] = max(buying, notBuy);\\n        }else{\\n            //selling\\n            int selling = prices[ind] + f(ind+1,true,prices,dp);\\n            //not sell\\n            int notSell = 0 + f(ind+1,false,prices,dp);\\n\\n            return dp[ind][canBuy] = max(selling,notSell);\\n        }\\n    }\\n\\n    int maxProfit(vector<int>& prices) {\\n        vector<vector<int>> dp(prices.size(), vector<int> (2,-1));\\n       return f(0,true,prices,dp); \\n    }\\n};`"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nBut lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    }
                ]
            },
            {
                "id": 1726080,
                "content": [
                    {
                        "username": "mohamed_waseela",
                        "content": "https://youtu.be/-Qpk2XJ5XJQ"
                    },
                    {
                        "username": "aditya223307",
                        "content": "can anyone tell me where i am doing wrong?\\nint maxProfit(vector<int>& prices) {\\n        unordered_map<int , int> m;\\n        m[prices[0]]=0;\\n        for(int i=1; i<prices.size(); i++){\\n            m[prices[i]]=prices[i] - prices[i-1];\\n        }\\n        int ans=0;\\n        for(auto it= m.begin(); it!= m.end() ; it++){\\n            if((*it).second >0){\\n                ans = ans + (*it).second;\\n            }\\n        }\\n        return ans;"
                    },
                    {
                        "username": "jje-",
                        "content": "Why the number of dislikes is so high?"
                    },
                    {
                        "username": "ymgcksge",
                        "content": "can i buy on the same day i sell?"
                    },
                    {
                        "username": "AnkushR10",
                        "content": "https://github.com/AnkushRawat10601/Leetcode/blob/main/122_buy_and_sell_stocks.cpp"
                    },
                    {
                        "username": "javeria",
                        "content": "Why is the brute force solution O(n^n)?"
                    },
                    {
                        "username": "adityasinghz",
                        "content": "it\\'s 2^n not n^n"
                    },
                    {
                        "username": "satyamS_71",
                        "content": "I understand the question but why is it tagged under dynamic programming , I mean ,  what part of the question tells that it is a dp question , or how one will know it requires a dp solution? \\n"
                    },
                    {
                        "username": "amanbanka100",
                        "content": "The difficulty level of this question should be Easy"
                    },
                    {
                        "username": "SaikatDass",
                        "content": "BEST OPTIMIZED SOLUTION IN JAVA | BEST TIME TO BUY AND SELL STOCK |\\nclass Solution {\\n    public int maxProfit(int[] prices) {\\n        int buyPrice = Integer.MAX_VALUE;\\n        int profit, maxProfit = 0;\\n        for(int i = 0; i < prices.length; i++){\\n            if(buyPrice > prices[i]){\\n                buyPrice = prices[i];\\n            }\\n            else if(buyPrice < prices[i]){\\n                profit = prices[i] - buyPrice;\\n                maxProfit += profit;\\n                buyPrice = prices[i];\\n            }\\n        }\\n        return maxProfit;\\n    }\\n}"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nBut lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "codewithvivekpandey",
                        "content": "dp solutoin \\n\\n `class Solution {\\npublic:\\n\\n    int f(int ind, bool canBuy, vector<int> &prices, vector<vector<int>> &dp){\\n        if(ind == prices.size()){\\n            return 0;\\n        }\\n\\n        if(dp[ind][canBuy] != -1)\\n            return dp[ind][canBuy];    \\n\\n        // check can buy\\n        if(canBuy){\\n            //buying\\n            int buying = -prices[ind] + f(ind+1,false,prices,dp);\\n            // not buy\\n            int notBuy = 0 + f(ind+1,true,prices,dp);\\n\\n            return dp[ind][canBuy] = max(buying, notBuy);\\n        }else{\\n            //selling\\n            int selling = prices[ind] + f(ind+1,true,prices,dp);\\n            //not sell\\n            int notSell = 0 + f(ind+1,false,prices,dp);\\n\\n            return dp[ind][canBuy] = max(selling,notSell);\\n        }\\n    }\\n\\n    int maxProfit(vector<int>& prices) {\\n        vector<vector<int>> dp(prices.size(), vector<int> (2,-1));\\n       return f(0,true,prices,dp); \\n    }\\n};`"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nBut lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    }
                ]
            },
            {
                "id": 1723743,
                "content": [
                    {
                        "username": "mohamed_waseela",
                        "content": "https://youtu.be/-Qpk2XJ5XJQ"
                    },
                    {
                        "username": "aditya223307",
                        "content": "can anyone tell me where i am doing wrong?\\nint maxProfit(vector<int>& prices) {\\n        unordered_map<int , int> m;\\n        m[prices[0]]=0;\\n        for(int i=1; i<prices.size(); i++){\\n            m[prices[i]]=prices[i] - prices[i-1];\\n        }\\n        int ans=0;\\n        for(auto it= m.begin(); it!= m.end() ; it++){\\n            if((*it).second >0){\\n                ans = ans + (*it).second;\\n            }\\n        }\\n        return ans;"
                    },
                    {
                        "username": "jje-",
                        "content": "Why the number of dislikes is so high?"
                    },
                    {
                        "username": "ymgcksge",
                        "content": "can i buy on the same day i sell?"
                    },
                    {
                        "username": "AnkushR10",
                        "content": "https://github.com/AnkushRawat10601/Leetcode/blob/main/122_buy_and_sell_stocks.cpp"
                    },
                    {
                        "username": "javeria",
                        "content": "Why is the brute force solution O(n^n)?"
                    },
                    {
                        "username": "adityasinghz",
                        "content": "it\\'s 2^n not n^n"
                    },
                    {
                        "username": "satyamS_71",
                        "content": "I understand the question but why is it tagged under dynamic programming , I mean ,  what part of the question tells that it is a dp question , or how one will know it requires a dp solution? \\n"
                    },
                    {
                        "username": "amanbanka100",
                        "content": "The difficulty level of this question should be Easy"
                    },
                    {
                        "username": "SaikatDass",
                        "content": "BEST OPTIMIZED SOLUTION IN JAVA | BEST TIME TO BUY AND SELL STOCK |\\nclass Solution {\\n    public int maxProfit(int[] prices) {\\n        int buyPrice = Integer.MAX_VALUE;\\n        int profit, maxProfit = 0;\\n        for(int i = 0; i < prices.length; i++){\\n            if(buyPrice > prices[i]){\\n                buyPrice = prices[i];\\n            }\\n            else if(buyPrice < prices[i]){\\n                profit = prices[i] - buyPrice;\\n                maxProfit += profit;\\n                buyPrice = prices[i];\\n            }\\n        }\\n        return maxProfit;\\n    }\\n}"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nBut lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "codewithvivekpandey",
                        "content": "dp solutoin \\n\\n `class Solution {\\npublic:\\n\\n    int f(int ind, bool canBuy, vector<int> &prices, vector<vector<int>> &dp){\\n        if(ind == prices.size()){\\n            return 0;\\n        }\\n\\n        if(dp[ind][canBuy] != -1)\\n            return dp[ind][canBuy];    \\n\\n        // check can buy\\n        if(canBuy){\\n            //buying\\n            int buying = -prices[ind] + f(ind+1,false,prices,dp);\\n            // not buy\\n            int notBuy = 0 + f(ind+1,true,prices,dp);\\n\\n            return dp[ind][canBuy] = max(buying, notBuy);\\n        }else{\\n            //selling\\n            int selling = prices[ind] + f(ind+1,true,prices,dp);\\n            //not sell\\n            int notSell = 0 + f(ind+1,false,prices,dp);\\n\\n            return dp[ind][canBuy] = max(selling,notSell);\\n        }\\n    }\\n\\n    int maxProfit(vector<int>& prices) {\\n        vector<vector<int>> dp(prices.size(), vector<int> (2,-1));\\n       return f(0,true,prices,dp); \\n    }\\n};`"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nBut lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    }
                ]
            },
            {
                "id": 1709001,
                "content": [
                    {
                        "username": "mohamed_waseela",
                        "content": "https://youtu.be/-Qpk2XJ5XJQ"
                    },
                    {
                        "username": "aditya223307",
                        "content": "can anyone tell me where i am doing wrong?\\nint maxProfit(vector<int>& prices) {\\n        unordered_map<int , int> m;\\n        m[prices[0]]=0;\\n        for(int i=1; i<prices.size(); i++){\\n            m[prices[i]]=prices[i] - prices[i-1];\\n        }\\n        int ans=0;\\n        for(auto it= m.begin(); it!= m.end() ; it++){\\n            if((*it).second >0){\\n                ans = ans + (*it).second;\\n            }\\n        }\\n        return ans;"
                    },
                    {
                        "username": "jje-",
                        "content": "Why the number of dislikes is so high?"
                    },
                    {
                        "username": "ymgcksge",
                        "content": "can i buy on the same day i sell?"
                    },
                    {
                        "username": "AnkushR10",
                        "content": "https://github.com/AnkushRawat10601/Leetcode/blob/main/122_buy_and_sell_stocks.cpp"
                    },
                    {
                        "username": "javeria",
                        "content": "Why is the brute force solution O(n^n)?"
                    },
                    {
                        "username": "adityasinghz",
                        "content": "it\\'s 2^n not n^n"
                    },
                    {
                        "username": "satyamS_71",
                        "content": "I understand the question but why is it tagged under dynamic programming , I mean ,  what part of the question tells that it is a dp question , or how one will know it requires a dp solution? \\n"
                    },
                    {
                        "username": "amanbanka100",
                        "content": "The difficulty level of this question should be Easy"
                    },
                    {
                        "username": "SaikatDass",
                        "content": "BEST OPTIMIZED SOLUTION IN JAVA | BEST TIME TO BUY AND SELL STOCK |\\nclass Solution {\\n    public int maxProfit(int[] prices) {\\n        int buyPrice = Integer.MAX_VALUE;\\n        int profit, maxProfit = 0;\\n        for(int i = 0; i < prices.length; i++){\\n            if(buyPrice > prices[i]){\\n                buyPrice = prices[i];\\n            }\\n            else if(buyPrice < prices[i]){\\n                profit = prices[i] - buyPrice;\\n                maxProfit += profit;\\n                buyPrice = prices[i];\\n            }\\n        }\\n        return maxProfit;\\n    }\\n}"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nBut lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "codewithvivekpandey",
                        "content": "dp solutoin \\n\\n `class Solution {\\npublic:\\n\\n    int f(int ind, bool canBuy, vector<int> &prices, vector<vector<int>> &dp){\\n        if(ind == prices.size()){\\n            return 0;\\n        }\\n\\n        if(dp[ind][canBuy] != -1)\\n            return dp[ind][canBuy];    \\n\\n        // check can buy\\n        if(canBuy){\\n            //buying\\n            int buying = -prices[ind] + f(ind+1,false,prices,dp);\\n            // not buy\\n            int notBuy = 0 + f(ind+1,true,prices,dp);\\n\\n            return dp[ind][canBuy] = max(buying, notBuy);\\n        }else{\\n            //selling\\n            int selling = prices[ind] + f(ind+1,true,prices,dp);\\n            //not sell\\n            int notSell = 0 + f(ind+1,false,prices,dp);\\n\\n            return dp[ind][canBuy] = max(selling,notSell);\\n        }\\n    }\\n\\n    int maxProfit(vector<int>& prices) {\\n        vector<vector<int>> dp(prices.size(), vector<int> (2,-1));\\n       return f(0,true,prices,dp); \\n    }\\n};`"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nBut lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    }
                ]
            },
            {
                "id": 1702303,
                "content": [
                    {
                        "username": "mohamed_waseela",
                        "content": "https://youtu.be/-Qpk2XJ5XJQ"
                    },
                    {
                        "username": "aditya223307",
                        "content": "can anyone tell me where i am doing wrong?\\nint maxProfit(vector<int>& prices) {\\n        unordered_map<int , int> m;\\n        m[prices[0]]=0;\\n        for(int i=1; i<prices.size(); i++){\\n            m[prices[i]]=prices[i] - prices[i-1];\\n        }\\n        int ans=0;\\n        for(auto it= m.begin(); it!= m.end() ; it++){\\n            if((*it).second >0){\\n                ans = ans + (*it).second;\\n            }\\n        }\\n        return ans;"
                    },
                    {
                        "username": "jje-",
                        "content": "Why the number of dislikes is so high?"
                    },
                    {
                        "username": "ymgcksge",
                        "content": "can i buy on the same day i sell?"
                    },
                    {
                        "username": "AnkushR10",
                        "content": "https://github.com/AnkushRawat10601/Leetcode/blob/main/122_buy_and_sell_stocks.cpp"
                    },
                    {
                        "username": "javeria",
                        "content": "Why is the brute force solution O(n^n)?"
                    },
                    {
                        "username": "adityasinghz",
                        "content": "it\\'s 2^n not n^n"
                    },
                    {
                        "username": "satyamS_71",
                        "content": "I understand the question but why is it tagged under dynamic programming , I mean ,  what part of the question tells that it is a dp question , or how one will know it requires a dp solution? \\n"
                    },
                    {
                        "username": "amanbanka100",
                        "content": "The difficulty level of this question should be Easy"
                    },
                    {
                        "username": "SaikatDass",
                        "content": "BEST OPTIMIZED SOLUTION IN JAVA | BEST TIME TO BUY AND SELL STOCK |\\nclass Solution {\\n    public int maxProfit(int[] prices) {\\n        int buyPrice = Integer.MAX_VALUE;\\n        int profit, maxProfit = 0;\\n        for(int i = 0; i < prices.length; i++){\\n            if(buyPrice > prices[i]){\\n                buyPrice = prices[i];\\n            }\\n            else if(buyPrice < prices[i]){\\n                profit = prices[i] - buyPrice;\\n                maxProfit += profit;\\n                buyPrice = prices[i];\\n            }\\n        }\\n        return maxProfit;\\n    }\\n}"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nBut lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "codewithvivekpandey",
                        "content": "dp solutoin \\n\\n `class Solution {\\npublic:\\n\\n    int f(int ind, bool canBuy, vector<int> &prices, vector<vector<int>> &dp){\\n        if(ind == prices.size()){\\n            return 0;\\n        }\\n\\n        if(dp[ind][canBuy] != -1)\\n            return dp[ind][canBuy];    \\n\\n        // check can buy\\n        if(canBuy){\\n            //buying\\n            int buying = -prices[ind] + f(ind+1,false,prices,dp);\\n            // not buy\\n            int notBuy = 0 + f(ind+1,true,prices,dp);\\n\\n            return dp[ind][canBuy] = max(buying, notBuy);\\n        }else{\\n            //selling\\n            int selling = prices[ind] + f(ind+1,true,prices,dp);\\n            //not sell\\n            int notSell = 0 + f(ind+1,false,prices,dp);\\n\\n            return dp[ind][canBuy] = max(selling,notSell);\\n        }\\n    }\\n\\n    int maxProfit(vector<int>& prices) {\\n        vector<vector<int>> dp(prices.size(), vector<int> (2,-1));\\n       return f(0,true,prices,dp); \\n    }\\n};`"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nBut lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    }
                ]
            },
            {
                "id": 1696583,
                "content": [
                    {
                        "username": "mohamed_waseela",
                        "content": "https://youtu.be/-Qpk2XJ5XJQ"
                    },
                    {
                        "username": "aditya223307",
                        "content": "can anyone tell me where i am doing wrong?\\nint maxProfit(vector<int>& prices) {\\n        unordered_map<int , int> m;\\n        m[prices[0]]=0;\\n        for(int i=1; i<prices.size(); i++){\\n            m[prices[i]]=prices[i] - prices[i-1];\\n        }\\n        int ans=0;\\n        for(auto it= m.begin(); it!= m.end() ; it++){\\n            if((*it).second >0){\\n                ans = ans + (*it).second;\\n            }\\n        }\\n        return ans;"
                    },
                    {
                        "username": "jje-",
                        "content": "Why the number of dislikes is so high?"
                    },
                    {
                        "username": "ymgcksge",
                        "content": "can i buy on the same day i sell?"
                    },
                    {
                        "username": "AnkushR10",
                        "content": "https://github.com/AnkushRawat10601/Leetcode/blob/main/122_buy_and_sell_stocks.cpp"
                    },
                    {
                        "username": "javeria",
                        "content": "Why is the brute force solution O(n^n)?"
                    },
                    {
                        "username": "adityasinghz",
                        "content": "it\\'s 2^n not n^n"
                    },
                    {
                        "username": "satyamS_71",
                        "content": "I understand the question but why is it tagged under dynamic programming , I mean ,  what part of the question tells that it is a dp question , or how one will know it requires a dp solution? \\n"
                    },
                    {
                        "username": "amanbanka100",
                        "content": "The difficulty level of this question should be Easy"
                    },
                    {
                        "username": "SaikatDass",
                        "content": "BEST OPTIMIZED SOLUTION IN JAVA | BEST TIME TO BUY AND SELL STOCK |\\nclass Solution {\\n    public int maxProfit(int[] prices) {\\n        int buyPrice = Integer.MAX_VALUE;\\n        int profit, maxProfit = 0;\\n        for(int i = 0; i < prices.length; i++){\\n            if(buyPrice > prices[i]){\\n                buyPrice = prices[i];\\n            }\\n            else if(buyPrice < prices[i]){\\n                profit = prices[i] - buyPrice;\\n                maxProfit += profit;\\n                buyPrice = prices[i];\\n            }\\n        }\\n        return maxProfit;\\n    }\\n}"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nBut lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "codewithvivekpandey",
                        "content": "dp solutoin \\n\\n `class Solution {\\npublic:\\n\\n    int f(int ind, bool canBuy, vector<int> &prices, vector<vector<int>> &dp){\\n        if(ind == prices.size()){\\n            return 0;\\n        }\\n\\n        if(dp[ind][canBuy] != -1)\\n            return dp[ind][canBuy];    \\n\\n        // check can buy\\n        if(canBuy){\\n            //buying\\n            int buying = -prices[ind] + f(ind+1,false,prices,dp);\\n            // not buy\\n            int notBuy = 0 + f(ind+1,true,prices,dp);\\n\\n            return dp[ind][canBuy] = max(buying, notBuy);\\n        }else{\\n            //selling\\n            int selling = prices[ind] + f(ind+1,true,prices,dp);\\n            //not sell\\n            int notSell = 0 + f(ind+1,false,prices,dp);\\n\\n            return dp[ind][canBuy] = max(selling,notSell);\\n        }\\n    }\\n\\n    int maxProfit(vector<int>& prices) {\\n        vector<vector<int>> dp(prices.size(), vector<int> (2,-1));\\n       return f(0,true,prices,dp); \\n    }\\n};`"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nBut lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    }
                ]
            },
            {
                "id": 1694710,
                "content": [
                    {
                        "username": "mohamed_waseela",
                        "content": "https://youtu.be/-Qpk2XJ5XJQ"
                    },
                    {
                        "username": "aditya223307",
                        "content": "can anyone tell me where i am doing wrong?\\nint maxProfit(vector<int>& prices) {\\n        unordered_map<int , int> m;\\n        m[prices[0]]=0;\\n        for(int i=1; i<prices.size(); i++){\\n            m[prices[i]]=prices[i] - prices[i-1];\\n        }\\n        int ans=0;\\n        for(auto it= m.begin(); it!= m.end() ; it++){\\n            if((*it).second >0){\\n                ans = ans + (*it).second;\\n            }\\n        }\\n        return ans;"
                    },
                    {
                        "username": "jje-",
                        "content": "Why the number of dislikes is so high?"
                    },
                    {
                        "username": "ymgcksge",
                        "content": "can i buy on the same day i sell?"
                    },
                    {
                        "username": "AnkushR10",
                        "content": "https://github.com/AnkushRawat10601/Leetcode/blob/main/122_buy_and_sell_stocks.cpp"
                    },
                    {
                        "username": "javeria",
                        "content": "Why is the brute force solution O(n^n)?"
                    },
                    {
                        "username": "adityasinghz",
                        "content": "it\\'s 2^n not n^n"
                    },
                    {
                        "username": "satyamS_71",
                        "content": "I understand the question but why is it tagged under dynamic programming , I mean ,  what part of the question tells that it is a dp question , or how one will know it requires a dp solution? \\n"
                    },
                    {
                        "username": "amanbanka100",
                        "content": "The difficulty level of this question should be Easy"
                    },
                    {
                        "username": "SaikatDass",
                        "content": "BEST OPTIMIZED SOLUTION IN JAVA | BEST TIME TO BUY AND SELL STOCK |\\nclass Solution {\\n    public int maxProfit(int[] prices) {\\n        int buyPrice = Integer.MAX_VALUE;\\n        int profit, maxProfit = 0;\\n        for(int i = 0; i < prices.length; i++){\\n            if(buyPrice > prices[i]){\\n                buyPrice = prices[i];\\n            }\\n            else if(buyPrice < prices[i]){\\n                profit = prices[i] - buyPrice;\\n                maxProfit += profit;\\n                buyPrice = prices[i];\\n            }\\n        }\\n        return maxProfit;\\n    }\\n}"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nBut lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "codewithvivekpandey",
                        "content": "dp solutoin \\n\\n `class Solution {\\npublic:\\n\\n    int f(int ind, bool canBuy, vector<int> &prices, vector<vector<int>> &dp){\\n        if(ind == prices.size()){\\n            return 0;\\n        }\\n\\n        if(dp[ind][canBuy] != -1)\\n            return dp[ind][canBuy];    \\n\\n        // check can buy\\n        if(canBuy){\\n            //buying\\n            int buying = -prices[ind] + f(ind+1,false,prices,dp);\\n            // not buy\\n            int notBuy = 0 + f(ind+1,true,prices,dp);\\n\\n            return dp[ind][canBuy] = max(buying, notBuy);\\n        }else{\\n            //selling\\n            int selling = prices[ind] + f(ind+1,true,prices,dp);\\n            //not sell\\n            int notSell = 0 + f(ind+1,false,prices,dp);\\n\\n            return dp[ind][canBuy] = max(selling,notSell);\\n        }\\n    }\\n\\n    int maxProfit(vector<int>& prices) {\\n        vector<vector<int>> dp(prices.size(), vector<int> (2,-1));\\n       return f(0,true,prices,dp); \\n    }\\n};`"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nBut lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    }
                ]
            },
            {
                "id": 1635909,
                "content": [
                    {
                        "username": "mohamed_waseela",
                        "content": "https://youtu.be/-Qpk2XJ5XJQ"
                    },
                    {
                        "username": "aditya223307",
                        "content": "can anyone tell me where i am doing wrong?\\nint maxProfit(vector<int>& prices) {\\n        unordered_map<int , int> m;\\n        m[prices[0]]=0;\\n        for(int i=1; i<prices.size(); i++){\\n            m[prices[i]]=prices[i] - prices[i-1];\\n        }\\n        int ans=0;\\n        for(auto it= m.begin(); it!= m.end() ; it++){\\n            if((*it).second >0){\\n                ans = ans + (*it).second;\\n            }\\n        }\\n        return ans;"
                    },
                    {
                        "username": "jje-",
                        "content": "Why the number of dislikes is so high?"
                    },
                    {
                        "username": "ymgcksge",
                        "content": "can i buy on the same day i sell?"
                    },
                    {
                        "username": "AnkushR10",
                        "content": "https://github.com/AnkushRawat10601/Leetcode/blob/main/122_buy_and_sell_stocks.cpp"
                    },
                    {
                        "username": "javeria",
                        "content": "Why is the brute force solution O(n^n)?"
                    },
                    {
                        "username": "adityasinghz",
                        "content": "it\\'s 2^n not n^n"
                    },
                    {
                        "username": "satyamS_71",
                        "content": "I understand the question but why is it tagged under dynamic programming , I mean ,  what part of the question tells that it is a dp question , or how one will know it requires a dp solution? \\n"
                    },
                    {
                        "username": "amanbanka100",
                        "content": "The difficulty level of this question should be Easy"
                    },
                    {
                        "username": "SaikatDass",
                        "content": "BEST OPTIMIZED SOLUTION IN JAVA | BEST TIME TO BUY AND SELL STOCK |\\nclass Solution {\\n    public int maxProfit(int[] prices) {\\n        int buyPrice = Integer.MAX_VALUE;\\n        int profit, maxProfit = 0;\\n        for(int i = 0; i < prices.length; i++){\\n            if(buyPrice > prices[i]){\\n                buyPrice = prices[i];\\n            }\\n            else if(buyPrice < prices[i]){\\n                profit = prices[i] - buyPrice;\\n                maxProfit += profit;\\n                buyPrice = prices[i];\\n            }\\n        }\\n        return maxProfit;\\n    }\\n}"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nBut lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "codewithvivekpandey",
                        "content": "dp solutoin \\n\\n `class Solution {\\npublic:\\n\\n    int f(int ind, bool canBuy, vector<int> &prices, vector<vector<int>> &dp){\\n        if(ind == prices.size()){\\n            return 0;\\n        }\\n\\n        if(dp[ind][canBuy] != -1)\\n            return dp[ind][canBuy];    \\n\\n        // check can buy\\n        if(canBuy){\\n            //buying\\n            int buying = -prices[ind] + f(ind+1,false,prices,dp);\\n            // not buy\\n            int notBuy = 0 + f(ind+1,true,prices,dp);\\n\\n            return dp[ind][canBuy] = max(buying, notBuy);\\n        }else{\\n            //selling\\n            int selling = prices[ind] + f(ind+1,true,prices,dp);\\n            //not sell\\n            int notSell = 0 + f(ind+1,false,prices,dp);\\n\\n            return dp[ind][canBuy] = max(selling,notSell);\\n        }\\n    }\\n\\n    int maxProfit(vector<int>& prices) {\\n        vector<vector<int>> dp(prices.size(), vector<int> (2,-1));\\n       return f(0,true,prices,dp); \\n    }\\n};`"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nBut lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    }
                ]
            }
        ]
    }
]