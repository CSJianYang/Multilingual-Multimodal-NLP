[
    {
        "title": "Wiggle Sort",
        "question_content": null,
        "solutions": [],
        "discussions": [
            {
                "id": 1574148,
                "content": [
                    {
                        "username": "laodasb",
                        "content": "If you learned discreted mathematics...I\\' m sure that you may need a proof,  here is it, if I was wrong, please correct me, thanks.\\n\\nWe claim that: **If we make odd-indexed element larger than its neighbour elements, it can result a wiggle sorted array.**\\n\\n**Base case: **\\n\\nwhen index i is 0 or 1, that \\'s good--->[2],[2,3].\\nif  i == 2, we simply swap elements to result a array [x,y,z], and y is larger than x and z, the claim is also good.**\\n\\n**Assumption:**\\n\\nAssume that our claim is good for i == k, we need to prove it is also true for i== k+1:\\n\\n4 cases:\\n\\tcase1:i is odd, nums[i-1] smaller: good.\\n\\tcase2:i is odd, nums[i-1] larger:then,swap(i,i-1)--->doesn\\'t matter previous sorted array, because nums[i] is smaller...\\n\\tcase3:i is even, nums[i-1] larger:good.\\n\\tcase4:i is even,nums[i-1] smaller:then,swap(i,i-1)--->doesn\\'t matter previous sorted array, because nums[i] is larger.\\n\\t\\nConclusion: \\n\\tFrom above proof, no matter the newly element is an odd-indexed or even-indexed, only if we make the odd-indexed element larger than its neighbour elements, we maintain a wiggle sort array.\\n\\n\\n"
                    },
                    {
                        "username": "reddddddd",
                        "content": "I could not find any example where we cannot wiggle sort an array. \\n\\nBut, do we have a formal proof that every array can be wiggle sorted ?"
                    },
                    {
                        "username": "TGBBSZWHWDLANZP",
                        "content": "the criteria states <= and >= so an array of all the same elements, eg [1,1,1,1,1,1], is a valid wiggle sort."
                    },
                    {
                        "username": "user8228j",
                        "content": "For Python, if you are reassigning the entire value of the nums array at once, instead of doing \\nnums = ...\\ndo nums[:] = ...\\nThat way python doesnt create a new local variable nums with the same name"
                    },
                    {
                        "username": "TGBBSZWHWDLANZP",
                        "content": "did you use nums.sort() to sort it in place?"
                    },
                    {
                        "username": "rajs217",
                        "content": "Observation.\\nOne array with increasing order\\nOne array with decreasing order\\n\\nMerge them to the same length of original array.\\n\\neg: \\nOriginal Array: [3,5,2,1,6,4]\\nIncreasing Order Array: [ 1,2,3,4,5,6]\\nDecreasing Order Array: [6,5,4,3,2,1]\\n\\nMerge them ( merge doesnt mean directly add, one element from increasing array and in next turn one element from decreasing array )\\n\\n[1,6,2,5,3,4] ( stop length is same as orignal array )\\n\\nFOR ODD LENGTH OF ARRAY\\n\\nsame steps as even length but in the and add one extra element from increasing array."
                    },
                    {
                        "username": "RohitSgh",
                        "content": "The question can be **reworded** as\\n> **Reorder** given array in such a manner that \"every element at an `odd index` is greater than or equal to its adjoining elements at `even indices`\""
                    },
                    {
                        "username": "johnsonys",
                        "content": "Given an unsorted array nums, reorder it in-place such that nums[0] < nums[1] > nums[2] < nums[3]...\\nFor example, given nums = [1, 1, 1, 3, 3, 3, 2, 2, 2], one possible answer is [1, 3, 2, 3, 2, 3, 1, 2, 1].\\n\\nNote: the difference between this and the former question is that two adjacent number cannot be the same."
                    },
                    {
                        "username": "AlecLC",
                        "content": "My professor would be happy that bubble sort has an actual use lol"
                    },
                    {
                        "username": "mushroom_in_rain",
                        "content": "This one is more like \\'easy\\' for me instead of \\'medium\\' .... Many questions marked as easy but require much more time to think of, like the question #734 from last week."
                    },
                    {
                        "username": "kmp1084",
                        "content": "The O(N) method is genius :)"
                    },
                    {
                        "username": "ajinkyagavane",
                        "content": "*** APPROACH 1****\nTwo hints: I hope you don't need the second hint ;)\n\n**** HINT 1 ****\nObserve alternate terms in the condition: nums[0] <= nums[1] >= nums[2] <= nums[3]...\nPut them under two lists such that all the numbers in list1 are less than all the numbers in list2\n\n*\n*\n*\n**** HINT 2 ****\nWhat if nums[0] >= nums[2], and nums[1] >= nums[3]? \n- we still satisfy the given condition\n\nThus, if we have a sorted list1, and list2.. we should arrive at the solution with a little rearrangement.\n\n\n*** APPROACH 2 ****\n**** HINT *****\nPerhaps, traverse the list and satisfy the given condition in a pairwise fashion."
                    }
                ]
            },
            {
                "id": 1568055,
                "content": [
                    {
                        "username": "laodasb",
                        "content": "If you learned discreted mathematics...I\\' m sure that you may need a proof,  here is it, if I was wrong, please correct me, thanks.\\n\\nWe claim that: **If we make odd-indexed element larger than its neighbour elements, it can result a wiggle sorted array.**\\n\\n**Base case: **\\n\\nwhen index i is 0 or 1, that \\'s good--->[2],[2,3].\\nif  i == 2, we simply swap elements to result a array [x,y,z], and y is larger than x and z, the claim is also good.**\\n\\n**Assumption:**\\n\\nAssume that our claim is good for i == k, we need to prove it is also true for i== k+1:\\n\\n4 cases:\\n\\tcase1:i is odd, nums[i-1] smaller: good.\\n\\tcase2:i is odd, nums[i-1] larger:then,swap(i,i-1)--->doesn\\'t matter previous sorted array, because nums[i] is smaller...\\n\\tcase3:i is even, nums[i-1] larger:good.\\n\\tcase4:i is even,nums[i-1] smaller:then,swap(i,i-1)--->doesn\\'t matter previous sorted array, because nums[i] is larger.\\n\\t\\nConclusion: \\n\\tFrom above proof, no matter the newly element is an odd-indexed or even-indexed, only if we make the odd-indexed element larger than its neighbour elements, we maintain a wiggle sort array.\\n\\n\\n"
                    },
                    {
                        "username": "reddddddd",
                        "content": "I could not find any example where we cannot wiggle sort an array. \\n\\nBut, do we have a formal proof that every array can be wiggle sorted ?"
                    },
                    {
                        "username": "TGBBSZWHWDLANZP",
                        "content": "the criteria states <= and >= so an array of all the same elements, eg [1,1,1,1,1,1], is a valid wiggle sort."
                    },
                    {
                        "username": "user8228j",
                        "content": "For Python, if you are reassigning the entire value of the nums array at once, instead of doing \\nnums = ...\\ndo nums[:] = ...\\nThat way python doesnt create a new local variable nums with the same name"
                    },
                    {
                        "username": "TGBBSZWHWDLANZP",
                        "content": "did you use nums.sort() to sort it in place?"
                    },
                    {
                        "username": "rajs217",
                        "content": "Observation.\\nOne array with increasing order\\nOne array with decreasing order\\n\\nMerge them to the same length of original array.\\n\\neg: \\nOriginal Array: [3,5,2,1,6,4]\\nIncreasing Order Array: [ 1,2,3,4,5,6]\\nDecreasing Order Array: [6,5,4,3,2,1]\\n\\nMerge them ( merge doesnt mean directly add, one element from increasing array and in next turn one element from decreasing array )\\n\\n[1,6,2,5,3,4] ( stop length is same as orignal array )\\n\\nFOR ODD LENGTH OF ARRAY\\n\\nsame steps as even length but in the and add one extra element from increasing array."
                    },
                    {
                        "username": "RohitSgh",
                        "content": "The question can be **reworded** as\\n> **Reorder** given array in such a manner that \"every element at an `odd index` is greater than or equal to its adjoining elements at `even indices`\""
                    },
                    {
                        "username": "johnsonys",
                        "content": "Given an unsorted array nums, reorder it in-place such that nums[0] < nums[1] > nums[2] < nums[3]...\\nFor example, given nums = [1, 1, 1, 3, 3, 3, 2, 2, 2], one possible answer is [1, 3, 2, 3, 2, 3, 1, 2, 1].\\n\\nNote: the difference between this and the former question is that two adjacent number cannot be the same."
                    },
                    {
                        "username": "AlecLC",
                        "content": "My professor would be happy that bubble sort has an actual use lol"
                    },
                    {
                        "username": "mushroom_in_rain",
                        "content": "This one is more like \\'easy\\' for me instead of \\'medium\\' .... Many questions marked as easy but require much more time to think of, like the question #734 from last week."
                    },
                    {
                        "username": "kmp1084",
                        "content": "The O(N) method is genius :)"
                    },
                    {
                        "username": "ajinkyagavane",
                        "content": "*** APPROACH 1****\nTwo hints: I hope you don't need the second hint ;)\n\n**** HINT 1 ****\nObserve alternate terms in the condition: nums[0] <= nums[1] >= nums[2] <= nums[3]...\nPut them under two lists such that all the numbers in list1 are less than all the numbers in list2\n\n*\n*\n*\n**** HINT 2 ****\nWhat if nums[0] >= nums[2], and nums[1] >= nums[3]? \n- we still satisfy the given condition\n\nThus, if we have a sorted list1, and list2.. we should arrive at the solution with a little rearrangement.\n\n\n*** APPROACH 2 ****\n**** HINT *****\nPerhaps, traverse the list and satisfy the given condition in a pairwise fashion."
                    }
                ]
            },
            {
                "id": 1792566,
                "content": [
                    {
                        "username": "laodasb",
                        "content": "If you learned discreted mathematics...I\\' m sure that you may need a proof,  here is it, if I was wrong, please correct me, thanks.\\n\\nWe claim that: **If we make odd-indexed element larger than its neighbour elements, it can result a wiggle sorted array.**\\n\\n**Base case: **\\n\\nwhen index i is 0 or 1, that \\'s good--->[2],[2,3].\\nif  i == 2, we simply swap elements to result a array [x,y,z], and y is larger than x and z, the claim is also good.**\\n\\n**Assumption:**\\n\\nAssume that our claim is good for i == k, we need to prove it is also true for i== k+1:\\n\\n4 cases:\\n\\tcase1:i is odd, nums[i-1] smaller: good.\\n\\tcase2:i is odd, nums[i-1] larger:then,swap(i,i-1)--->doesn\\'t matter previous sorted array, because nums[i] is smaller...\\n\\tcase3:i is even, nums[i-1] larger:good.\\n\\tcase4:i is even,nums[i-1] smaller:then,swap(i,i-1)--->doesn\\'t matter previous sorted array, because nums[i] is larger.\\n\\t\\nConclusion: \\n\\tFrom above proof, no matter the newly element is an odd-indexed or even-indexed, only if we make the odd-indexed element larger than its neighbour elements, we maintain a wiggle sort array.\\n\\n\\n"
                    },
                    {
                        "username": "reddddddd",
                        "content": "I could not find any example where we cannot wiggle sort an array. \\n\\nBut, do we have a formal proof that every array can be wiggle sorted ?"
                    },
                    {
                        "username": "TGBBSZWHWDLANZP",
                        "content": "the criteria states <= and >= so an array of all the same elements, eg [1,1,1,1,1,1], is a valid wiggle sort."
                    },
                    {
                        "username": "user8228j",
                        "content": "For Python, if you are reassigning the entire value of the nums array at once, instead of doing \\nnums = ...\\ndo nums[:] = ...\\nThat way python doesnt create a new local variable nums with the same name"
                    },
                    {
                        "username": "TGBBSZWHWDLANZP",
                        "content": "did you use nums.sort() to sort it in place?"
                    },
                    {
                        "username": "rajs217",
                        "content": "Observation.\\nOne array with increasing order\\nOne array with decreasing order\\n\\nMerge them to the same length of original array.\\n\\neg: \\nOriginal Array: [3,5,2,1,6,4]\\nIncreasing Order Array: [ 1,2,3,4,5,6]\\nDecreasing Order Array: [6,5,4,3,2,1]\\n\\nMerge them ( merge doesnt mean directly add, one element from increasing array and in next turn one element from decreasing array )\\n\\n[1,6,2,5,3,4] ( stop length is same as orignal array )\\n\\nFOR ODD LENGTH OF ARRAY\\n\\nsame steps as even length but in the and add one extra element from increasing array."
                    },
                    {
                        "username": "RohitSgh",
                        "content": "The question can be **reworded** as\\n> **Reorder** given array in such a manner that \"every element at an `odd index` is greater than or equal to its adjoining elements at `even indices`\""
                    },
                    {
                        "username": "johnsonys",
                        "content": "Given an unsorted array nums, reorder it in-place such that nums[0] < nums[1] > nums[2] < nums[3]...\\nFor example, given nums = [1, 1, 1, 3, 3, 3, 2, 2, 2], one possible answer is [1, 3, 2, 3, 2, 3, 1, 2, 1].\\n\\nNote: the difference between this and the former question is that two adjacent number cannot be the same."
                    },
                    {
                        "username": "AlecLC",
                        "content": "My professor would be happy that bubble sort has an actual use lol"
                    },
                    {
                        "username": "mushroom_in_rain",
                        "content": "This one is more like \\'easy\\' for me instead of \\'medium\\' .... Many questions marked as easy but require much more time to think of, like the question #734 from last week."
                    },
                    {
                        "username": "kmp1084",
                        "content": "The O(N) method is genius :)"
                    },
                    {
                        "username": "ajinkyagavane",
                        "content": "*** APPROACH 1****\nTwo hints: I hope you don't need the second hint ;)\n\n**** HINT 1 ****\nObserve alternate terms in the condition: nums[0] <= nums[1] >= nums[2] <= nums[3]...\nPut them under two lists such that all the numbers in list1 are less than all the numbers in list2\n\n*\n*\n*\n**** HINT 2 ****\nWhat if nums[0] >= nums[2], and nums[1] >= nums[3]? \n- we still satisfy the given condition\n\nThus, if we have a sorted list1, and list2.. we should arrive at the solution with a little rearrangement.\n\n\n*** APPROACH 2 ****\n**** HINT *****\nPerhaps, traverse the list and satisfy the given condition in a pairwise fashion."
                    }
                ]
            },
            {
                "id": 1794914,
                "content": [
                    {
                        "username": "laodasb",
                        "content": "If you learned discreted mathematics...I\\' m sure that you may need a proof,  here is it, if I was wrong, please correct me, thanks.\\n\\nWe claim that: **If we make odd-indexed element larger than its neighbour elements, it can result a wiggle sorted array.**\\n\\n**Base case: **\\n\\nwhen index i is 0 or 1, that \\'s good--->[2],[2,3].\\nif  i == 2, we simply swap elements to result a array [x,y,z], and y is larger than x and z, the claim is also good.**\\n\\n**Assumption:**\\n\\nAssume that our claim is good for i == k, we need to prove it is also true for i== k+1:\\n\\n4 cases:\\n\\tcase1:i is odd, nums[i-1] smaller: good.\\n\\tcase2:i is odd, nums[i-1] larger:then,swap(i,i-1)--->doesn\\'t matter previous sorted array, because nums[i] is smaller...\\n\\tcase3:i is even, nums[i-1] larger:good.\\n\\tcase4:i is even,nums[i-1] smaller:then,swap(i,i-1)--->doesn\\'t matter previous sorted array, because nums[i] is larger.\\n\\t\\nConclusion: \\n\\tFrom above proof, no matter the newly element is an odd-indexed or even-indexed, only if we make the odd-indexed element larger than its neighbour elements, we maintain a wiggle sort array.\\n\\n\\n"
                    },
                    {
                        "username": "reddddddd",
                        "content": "I could not find any example where we cannot wiggle sort an array. \\n\\nBut, do we have a formal proof that every array can be wiggle sorted ?"
                    },
                    {
                        "username": "TGBBSZWHWDLANZP",
                        "content": "the criteria states <= and >= so an array of all the same elements, eg [1,1,1,1,1,1], is a valid wiggle sort."
                    },
                    {
                        "username": "user8228j",
                        "content": "For Python, if you are reassigning the entire value of the nums array at once, instead of doing \\nnums = ...\\ndo nums[:] = ...\\nThat way python doesnt create a new local variable nums with the same name"
                    },
                    {
                        "username": "TGBBSZWHWDLANZP",
                        "content": "did you use nums.sort() to sort it in place?"
                    },
                    {
                        "username": "rajs217",
                        "content": "Observation.\\nOne array with increasing order\\nOne array with decreasing order\\n\\nMerge them to the same length of original array.\\n\\neg: \\nOriginal Array: [3,5,2,1,6,4]\\nIncreasing Order Array: [ 1,2,3,4,5,6]\\nDecreasing Order Array: [6,5,4,3,2,1]\\n\\nMerge them ( merge doesnt mean directly add, one element from increasing array and in next turn one element from decreasing array )\\n\\n[1,6,2,5,3,4] ( stop length is same as orignal array )\\n\\nFOR ODD LENGTH OF ARRAY\\n\\nsame steps as even length but in the and add one extra element from increasing array."
                    },
                    {
                        "username": "RohitSgh",
                        "content": "The question can be **reworded** as\\n> **Reorder** given array in such a manner that \"every element at an `odd index` is greater than or equal to its adjoining elements at `even indices`\""
                    },
                    {
                        "username": "johnsonys",
                        "content": "Given an unsorted array nums, reorder it in-place such that nums[0] < nums[1] > nums[2] < nums[3]...\\nFor example, given nums = [1, 1, 1, 3, 3, 3, 2, 2, 2], one possible answer is [1, 3, 2, 3, 2, 3, 1, 2, 1].\\n\\nNote: the difference between this and the former question is that two adjacent number cannot be the same."
                    },
                    {
                        "username": "AlecLC",
                        "content": "My professor would be happy that bubble sort has an actual use lol"
                    },
                    {
                        "username": "mushroom_in_rain",
                        "content": "This one is more like \\'easy\\' for me instead of \\'medium\\' .... Many questions marked as easy but require much more time to think of, like the question #734 from last week."
                    },
                    {
                        "username": "kmp1084",
                        "content": "The O(N) method is genius :)"
                    },
                    {
                        "username": "ajinkyagavane",
                        "content": "*** APPROACH 1****\nTwo hints: I hope you don't need the second hint ;)\n\n**** HINT 1 ****\nObserve alternate terms in the condition: nums[0] <= nums[1] >= nums[2] <= nums[3]...\nPut them under two lists such that all the numbers in list1 are less than all the numbers in list2\n\n*\n*\n*\n**** HINT 2 ****\nWhat if nums[0] >= nums[2], and nums[1] >= nums[3]? \n- we still satisfy the given condition\n\nThus, if we have a sorted list1, and list2.. we should arrive at the solution with a little rearrangement.\n\n\n*** APPROACH 2 ****\n**** HINT *****\nPerhaps, traverse the list and satisfy the given condition in a pairwise fashion."
                    }
                ]
            },
            {
                "id": 1794852,
                "content": [
                    {
                        "username": "laodasb",
                        "content": "If you learned discreted mathematics...I\\' m sure that you may need a proof,  here is it, if I was wrong, please correct me, thanks.\\n\\nWe claim that: **If we make odd-indexed element larger than its neighbour elements, it can result a wiggle sorted array.**\\n\\n**Base case: **\\n\\nwhen index i is 0 or 1, that \\'s good--->[2],[2,3].\\nif  i == 2, we simply swap elements to result a array [x,y,z], and y is larger than x and z, the claim is also good.**\\n\\n**Assumption:**\\n\\nAssume that our claim is good for i == k, we need to prove it is also true for i== k+1:\\n\\n4 cases:\\n\\tcase1:i is odd, nums[i-1] smaller: good.\\n\\tcase2:i is odd, nums[i-1] larger:then,swap(i,i-1)--->doesn\\'t matter previous sorted array, because nums[i] is smaller...\\n\\tcase3:i is even, nums[i-1] larger:good.\\n\\tcase4:i is even,nums[i-1] smaller:then,swap(i,i-1)--->doesn\\'t matter previous sorted array, because nums[i] is larger.\\n\\t\\nConclusion: \\n\\tFrom above proof, no matter the newly element is an odd-indexed or even-indexed, only if we make the odd-indexed element larger than its neighbour elements, we maintain a wiggle sort array.\\n\\n\\n"
                    },
                    {
                        "username": "reddddddd",
                        "content": "I could not find any example where we cannot wiggle sort an array. \\n\\nBut, do we have a formal proof that every array can be wiggle sorted ?"
                    },
                    {
                        "username": "TGBBSZWHWDLANZP",
                        "content": "the criteria states <= and >= so an array of all the same elements, eg [1,1,1,1,1,1], is a valid wiggle sort."
                    },
                    {
                        "username": "user8228j",
                        "content": "For Python, if you are reassigning the entire value of the nums array at once, instead of doing \\nnums = ...\\ndo nums[:] = ...\\nThat way python doesnt create a new local variable nums with the same name"
                    },
                    {
                        "username": "TGBBSZWHWDLANZP",
                        "content": "did you use nums.sort() to sort it in place?"
                    },
                    {
                        "username": "rajs217",
                        "content": "Observation.\\nOne array with increasing order\\nOne array with decreasing order\\n\\nMerge them to the same length of original array.\\n\\neg: \\nOriginal Array: [3,5,2,1,6,4]\\nIncreasing Order Array: [ 1,2,3,4,5,6]\\nDecreasing Order Array: [6,5,4,3,2,1]\\n\\nMerge them ( merge doesnt mean directly add, one element from increasing array and in next turn one element from decreasing array )\\n\\n[1,6,2,5,3,4] ( stop length is same as orignal array )\\n\\nFOR ODD LENGTH OF ARRAY\\n\\nsame steps as even length but in the and add one extra element from increasing array."
                    },
                    {
                        "username": "RohitSgh",
                        "content": "The question can be **reworded** as\\n> **Reorder** given array in such a manner that \"every element at an `odd index` is greater than or equal to its adjoining elements at `even indices`\""
                    },
                    {
                        "username": "johnsonys",
                        "content": "Given an unsorted array nums, reorder it in-place such that nums[0] < nums[1] > nums[2] < nums[3]...\\nFor example, given nums = [1, 1, 1, 3, 3, 3, 2, 2, 2], one possible answer is [1, 3, 2, 3, 2, 3, 1, 2, 1].\\n\\nNote: the difference between this and the former question is that two adjacent number cannot be the same."
                    },
                    {
                        "username": "AlecLC",
                        "content": "My professor would be happy that bubble sort has an actual use lol"
                    },
                    {
                        "username": "mushroom_in_rain",
                        "content": "This one is more like \\'easy\\' for me instead of \\'medium\\' .... Many questions marked as easy but require much more time to think of, like the question #734 from last week."
                    },
                    {
                        "username": "kmp1084",
                        "content": "The O(N) method is genius :)"
                    },
                    {
                        "username": "ajinkyagavane",
                        "content": "*** APPROACH 1****\nTwo hints: I hope you don't need the second hint ;)\n\n**** HINT 1 ****\nObserve alternate terms in the condition: nums[0] <= nums[1] >= nums[2] <= nums[3]...\nPut them under two lists such that all the numbers in list1 are less than all the numbers in list2\n\n*\n*\n*\n**** HINT 2 ****\nWhat if nums[0] >= nums[2], and nums[1] >= nums[3]? \n- we still satisfy the given condition\n\nThus, if we have a sorted list1, and list2.. we should arrive at the solution with a little rearrangement.\n\n\n*** APPROACH 2 ****\n**** HINT *****\nPerhaps, traverse the list and satisfy the given condition in a pairwise fashion."
                    }
                ]
            },
            {
                "id": 1571523,
                "content": [
                    {
                        "username": "laodasb",
                        "content": "If you learned discreted mathematics...I\\' m sure that you may need a proof,  here is it, if I was wrong, please correct me, thanks.\\n\\nWe claim that: **If we make odd-indexed element larger than its neighbour elements, it can result a wiggle sorted array.**\\n\\n**Base case: **\\n\\nwhen index i is 0 or 1, that \\'s good--->[2],[2,3].\\nif  i == 2, we simply swap elements to result a array [x,y,z], and y is larger than x and z, the claim is also good.**\\n\\n**Assumption:**\\n\\nAssume that our claim is good for i == k, we need to prove it is also true for i== k+1:\\n\\n4 cases:\\n\\tcase1:i is odd, nums[i-1] smaller: good.\\n\\tcase2:i is odd, nums[i-1] larger:then,swap(i,i-1)--->doesn\\'t matter previous sorted array, because nums[i] is smaller...\\n\\tcase3:i is even, nums[i-1] larger:good.\\n\\tcase4:i is even,nums[i-1] smaller:then,swap(i,i-1)--->doesn\\'t matter previous sorted array, because nums[i] is larger.\\n\\t\\nConclusion: \\n\\tFrom above proof, no matter the newly element is an odd-indexed or even-indexed, only if we make the odd-indexed element larger than its neighbour elements, we maintain a wiggle sort array.\\n\\n\\n"
                    },
                    {
                        "username": "reddddddd",
                        "content": "I could not find any example where we cannot wiggle sort an array. \\n\\nBut, do we have a formal proof that every array can be wiggle sorted ?"
                    },
                    {
                        "username": "TGBBSZWHWDLANZP",
                        "content": "the criteria states <= and >= so an array of all the same elements, eg [1,1,1,1,1,1], is a valid wiggle sort."
                    },
                    {
                        "username": "user8228j",
                        "content": "For Python, if you are reassigning the entire value of the nums array at once, instead of doing \\nnums = ...\\ndo nums[:] = ...\\nThat way python doesnt create a new local variable nums with the same name"
                    },
                    {
                        "username": "TGBBSZWHWDLANZP",
                        "content": "did you use nums.sort() to sort it in place?"
                    },
                    {
                        "username": "rajs217",
                        "content": "Observation.\\nOne array with increasing order\\nOne array with decreasing order\\n\\nMerge them to the same length of original array.\\n\\neg: \\nOriginal Array: [3,5,2,1,6,4]\\nIncreasing Order Array: [ 1,2,3,4,5,6]\\nDecreasing Order Array: [6,5,4,3,2,1]\\n\\nMerge them ( merge doesnt mean directly add, one element from increasing array and in next turn one element from decreasing array )\\n\\n[1,6,2,5,3,4] ( stop length is same as orignal array )\\n\\nFOR ODD LENGTH OF ARRAY\\n\\nsame steps as even length but in the and add one extra element from increasing array."
                    },
                    {
                        "username": "RohitSgh",
                        "content": "The question can be **reworded** as\\n> **Reorder** given array in such a manner that \"every element at an `odd index` is greater than or equal to its adjoining elements at `even indices`\""
                    },
                    {
                        "username": "johnsonys",
                        "content": "Given an unsorted array nums, reorder it in-place such that nums[0] < nums[1] > nums[2] < nums[3]...\\nFor example, given nums = [1, 1, 1, 3, 3, 3, 2, 2, 2], one possible answer is [1, 3, 2, 3, 2, 3, 1, 2, 1].\\n\\nNote: the difference between this and the former question is that two adjacent number cannot be the same."
                    },
                    {
                        "username": "AlecLC",
                        "content": "My professor would be happy that bubble sort has an actual use lol"
                    },
                    {
                        "username": "mushroom_in_rain",
                        "content": "This one is more like \\'easy\\' for me instead of \\'medium\\' .... Many questions marked as easy but require much more time to think of, like the question #734 from last week."
                    },
                    {
                        "username": "kmp1084",
                        "content": "The O(N) method is genius :)"
                    },
                    {
                        "username": "ajinkyagavane",
                        "content": "*** APPROACH 1****\nTwo hints: I hope you don't need the second hint ;)\n\n**** HINT 1 ****\nObserve alternate terms in the condition: nums[0] <= nums[1] >= nums[2] <= nums[3]...\nPut them under two lists such that all the numbers in list1 are less than all the numbers in list2\n\n*\n*\n*\n**** HINT 2 ****\nWhat if nums[0] >= nums[2], and nums[1] >= nums[3]? \n- we still satisfy the given condition\n\nThus, if we have a sorted list1, and list2.. we should arrive at the solution with a little rearrangement.\n\n\n*** APPROACH 2 ****\n**** HINT *****\nPerhaps, traverse the list and satisfy the given condition in a pairwise fashion."
                    }
                ]
            },
            {
                "id": 1847651,
                "content": [
                    {
                        "username": "laodasb",
                        "content": "If you learned discreted mathematics...I\\' m sure that you may need a proof,  here is it, if I was wrong, please correct me, thanks.\\n\\nWe claim that: **If we make odd-indexed element larger than its neighbour elements, it can result a wiggle sorted array.**\\n\\n**Base case: **\\n\\nwhen index i is 0 or 1, that \\'s good--->[2],[2,3].\\nif  i == 2, we simply swap elements to result a array [x,y,z], and y is larger than x and z, the claim is also good.**\\n\\n**Assumption:**\\n\\nAssume that our claim is good for i == k, we need to prove it is also true for i== k+1:\\n\\n4 cases:\\n\\tcase1:i is odd, nums[i-1] smaller: good.\\n\\tcase2:i is odd, nums[i-1] larger:then,swap(i,i-1)--->doesn\\'t matter previous sorted array, because nums[i] is smaller...\\n\\tcase3:i is even, nums[i-1] larger:good.\\n\\tcase4:i is even,nums[i-1] smaller:then,swap(i,i-1)--->doesn\\'t matter previous sorted array, because nums[i] is larger.\\n\\t\\nConclusion: \\n\\tFrom above proof, no matter the newly element is an odd-indexed or even-indexed, only if we make the odd-indexed element larger than its neighbour elements, we maintain a wiggle sort array.\\n\\n\\n"
                    },
                    {
                        "username": "reddddddd",
                        "content": "I could not find any example where we cannot wiggle sort an array. \\n\\nBut, do we have a formal proof that every array can be wiggle sorted ?"
                    },
                    {
                        "username": "TGBBSZWHWDLANZP",
                        "content": "the criteria states <= and >= so an array of all the same elements, eg [1,1,1,1,1,1], is a valid wiggle sort."
                    },
                    {
                        "username": "user8228j",
                        "content": "For Python, if you are reassigning the entire value of the nums array at once, instead of doing \\nnums = ...\\ndo nums[:] = ...\\nThat way python doesnt create a new local variable nums with the same name"
                    },
                    {
                        "username": "TGBBSZWHWDLANZP",
                        "content": "did you use nums.sort() to sort it in place?"
                    },
                    {
                        "username": "rajs217",
                        "content": "Observation.\\nOne array with increasing order\\nOne array with decreasing order\\n\\nMerge them to the same length of original array.\\n\\neg: \\nOriginal Array: [3,5,2,1,6,4]\\nIncreasing Order Array: [ 1,2,3,4,5,6]\\nDecreasing Order Array: [6,5,4,3,2,1]\\n\\nMerge them ( merge doesnt mean directly add, one element from increasing array and in next turn one element from decreasing array )\\n\\n[1,6,2,5,3,4] ( stop length is same as orignal array )\\n\\nFOR ODD LENGTH OF ARRAY\\n\\nsame steps as even length but in the and add one extra element from increasing array."
                    },
                    {
                        "username": "RohitSgh",
                        "content": "The question can be **reworded** as\\n> **Reorder** given array in such a manner that \"every element at an `odd index` is greater than or equal to its adjoining elements at `even indices`\""
                    },
                    {
                        "username": "johnsonys",
                        "content": "Given an unsorted array nums, reorder it in-place such that nums[0] < nums[1] > nums[2] < nums[3]...\\nFor example, given nums = [1, 1, 1, 3, 3, 3, 2, 2, 2], one possible answer is [1, 3, 2, 3, 2, 3, 1, 2, 1].\\n\\nNote: the difference between this and the former question is that two adjacent number cannot be the same."
                    },
                    {
                        "username": "AlecLC",
                        "content": "My professor would be happy that bubble sort has an actual use lol"
                    },
                    {
                        "username": "mushroom_in_rain",
                        "content": "This one is more like \\'easy\\' for me instead of \\'medium\\' .... Many questions marked as easy but require much more time to think of, like the question #734 from last week."
                    },
                    {
                        "username": "kmp1084",
                        "content": "The O(N) method is genius :)"
                    },
                    {
                        "username": "ajinkyagavane",
                        "content": "*** APPROACH 1****\nTwo hints: I hope you don't need the second hint ;)\n\n**** HINT 1 ****\nObserve alternate terms in the condition: nums[0] <= nums[1] >= nums[2] <= nums[3]...\nPut them under two lists such that all the numbers in list1 are less than all the numbers in list2\n\n*\n*\n*\n**** HINT 2 ****\nWhat if nums[0] >= nums[2], and nums[1] >= nums[3]? \n- we still satisfy the given condition\n\nThus, if we have a sorted list1, and list2.. we should arrive at the solution with a little rearrangement.\n\n\n*** APPROACH 2 ****\n**** HINT *****\nPerhaps, traverse the list and satisfy the given condition in a pairwise fashion."
                    }
                ]
            },
            {
                "id": 1801339,
                "content": [
                    {
                        "username": "laodasb",
                        "content": "If you learned discreted mathematics...I\\' m sure that you may need a proof,  here is it, if I was wrong, please correct me, thanks.\\n\\nWe claim that: **If we make odd-indexed element larger than its neighbour elements, it can result a wiggle sorted array.**\\n\\n**Base case: **\\n\\nwhen index i is 0 or 1, that \\'s good--->[2],[2,3].\\nif  i == 2, we simply swap elements to result a array [x,y,z], and y is larger than x and z, the claim is also good.**\\n\\n**Assumption:**\\n\\nAssume that our claim is good for i == k, we need to prove it is also true for i== k+1:\\n\\n4 cases:\\n\\tcase1:i is odd, nums[i-1] smaller: good.\\n\\tcase2:i is odd, nums[i-1] larger:then,swap(i,i-1)--->doesn\\'t matter previous sorted array, because nums[i] is smaller...\\n\\tcase3:i is even, nums[i-1] larger:good.\\n\\tcase4:i is even,nums[i-1] smaller:then,swap(i,i-1)--->doesn\\'t matter previous sorted array, because nums[i] is larger.\\n\\t\\nConclusion: \\n\\tFrom above proof, no matter the newly element is an odd-indexed or even-indexed, only if we make the odd-indexed element larger than its neighbour elements, we maintain a wiggle sort array.\\n\\n\\n"
                    },
                    {
                        "username": "reddddddd",
                        "content": "I could not find any example where we cannot wiggle sort an array. \\n\\nBut, do we have a formal proof that every array can be wiggle sorted ?"
                    },
                    {
                        "username": "TGBBSZWHWDLANZP",
                        "content": "the criteria states <= and >= so an array of all the same elements, eg [1,1,1,1,1,1], is a valid wiggle sort."
                    },
                    {
                        "username": "user8228j",
                        "content": "For Python, if you are reassigning the entire value of the nums array at once, instead of doing \\nnums = ...\\ndo nums[:] = ...\\nThat way python doesnt create a new local variable nums with the same name"
                    },
                    {
                        "username": "TGBBSZWHWDLANZP",
                        "content": "did you use nums.sort() to sort it in place?"
                    },
                    {
                        "username": "rajs217",
                        "content": "Observation.\\nOne array with increasing order\\nOne array with decreasing order\\n\\nMerge them to the same length of original array.\\n\\neg: \\nOriginal Array: [3,5,2,1,6,4]\\nIncreasing Order Array: [ 1,2,3,4,5,6]\\nDecreasing Order Array: [6,5,4,3,2,1]\\n\\nMerge them ( merge doesnt mean directly add, one element from increasing array and in next turn one element from decreasing array )\\n\\n[1,6,2,5,3,4] ( stop length is same as orignal array )\\n\\nFOR ODD LENGTH OF ARRAY\\n\\nsame steps as even length but in the and add one extra element from increasing array."
                    },
                    {
                        "username": "RohitSgh",
                        "content": "The question can be **reworded** as\\n> **Reorder** given array in such a manner that \"every element at an `odd index` is greater than or equal to its adjoining elements at `even indices`\""
                    },
                    {
                        "username": "johnsonys",
                        "content": "Given an unsorted array nums, reorder it in-place such that nums[0] < nums[1] > nums[2] < nums[3]...\\nFor example, given nums = [1, 1, 1, 3, 3, 3, 2, 2, 2], one possible answer is [1, 3, 2, 3, 2, 3, 1, 2, 1].\\n\\nNote: the difference between this and the former question is that two adjacent number cannot be the same."
                    },
                    {
                        "username": "AlecLC",
                        "content": "My professor would be happy that bubble sort has an actual use lol"
                    },
                    {
                        "username": "mushroom_in_rain",
                        "content": "This one is more like \\'easy\\' for me instead of \\'medium\\' .... Many questions marked as easy but require much more time to think of, like the question #734 from last week."
                    },
                    {
                        "username": "kmp1084",
                        "content": "The O(N) method is genius :)"
                    },
                    {
                        "username": "ajinkyagavane",
                        "content": "*** APPROACH 1****\nTwo hints: I hope you don't need the second hint ;)\n\n**** HINT 1 ****\nObserve alternate terms in the condition: nums[0] <= nums[1] >= nums[2] <= nums[3]...\nPut them under two lists such that all the numbers in list1 are less than all the numbers in list2\n\n*\n*\n*\n**** HINT 2 ****\nWhat if nums[0] >= nums[2], and nums[1] >= nums[3]? \n- we still satisfy the given condition\n\nThus, if we have a sorted list1, and list2.. we should arrive at the solution with a little rearrangement.\n\n\n*** APPROACH 2 ****\n**** HINT *****\nPerhaps, traverse the list and satisfy the given condition in a pairwise fashion."
                    }
                ]
            },
            {
                "id": 1793488,
                "content": [
                    {
                        "username": "laodasb",
                        "content": "If you learned discreted mathematics...I\\' m sure that you may need a proof,  here is it, if I was wrong, please correct me, thanks.\\n\\nWe claim that: **If we make odd-indexed element larger than its neighbour elements, it can result a wiggle sorted array.**\\n\\n**Base case: **\\n\\nwhen index i is 0 or 1, that \\'s good--->[2],[2,3].\\nif  i == 2, we simply swap elements to result a array [x,y,z], and y is larger than x and z, the claim is also good.**\\n\\n**Assumption:**\\n\\nAssume that our claim is good for i == k, we need to prove it is also true for i== k+1:\\n\\n4 cases:\\n\\tcase1:i is odd, nums[i-1] smaller: good.\\n\\tcase2:i is odd, nums[i-1] larger:then,swap(i,i-1)--->doesn\\'t matter previous sorted array, because nums[i] is smaller...\\n\\tcase3:i is even, nums[i-1] larger:good.\\n\\tcase4:i is even,nums[i-1] smaller:then,swap(i,i-1)--->doesn\\'t matter previous sorted array, because nums[i] is larger.\\n\\t\\nConclusion: \\n\\tFrom above proof, no matter the newly element is an odd-indexed or even-indexed, only if we make the odd-indexed element larger than its neighbour elements, we maintain a wiggle sort array.\\n\\n\\n"
                    },
                    {
                        "username": "reddddddd",
                        "content": "I could not find any example where we cannot wiggle sort an array. \\n\\nBut, do we have a formal proof that every array can be wiggle sorted ?"
                    },
                    {
                        "username": "TGBBSZWHWDLANZP",
                        "content": "the criteria states <= and >= so an array of all the same elements, eg [1,1,1,1,1,1], is a valid wiggle sort."
                    },
                    {
                        "username": "user8228j",
                        "content": "For Python, if you are reassigning the entire value of the nums array at once, instead of doing \\nnums = ...\\ndo nums[:] = ...\\nThat way python doesnt create a new local variable nums with the same name"
                    },
                    {
                        "username": "TGBBSZWHWDLANZP",
                        "content": "did you use nums.sort() to sort it in place?"
                    },
                    {
                        "username": "rajs217",
                        "content": "Observation.\\nOne array with increasing order\\nOne array with decreasing order\\n\\nMerge them to the same length of original array.\\n\\neg: \\nOriginal Array: [3,5,2,1,6,4]\\nIncreasing Order Array: [ 1,2,3,4,5,6]\\nDecreasing Order Array: [6,5,4,3,2,1]\\n\\nMerge them ( merge doesnt mean directly add, one element from increasing array and in next turn one element from decreasing array )\\n\\n[1,6,2,5,3,4] ( stop length is same as orignal array )\\n\\nFOR ODD LENGTH OF ARRAY\\n\\nsame steps as even length but in the and add one extra element from increasing array."
                    },
                    {
                        "username": "RohitSgh",
                        "content": "The question can be **reworded** as\\n> **Reorder** given array in such a manner that \"every element at an `odd index` is greater than or equal to its adjoining elements at `even indices`\""
                    },
                    {
                        "username": "johnsonys",
                        "content": "Given an unsorted array nums, reorder it in-place such that nums[0] < nums[1] > nums[2] < nums[3]...\\nFor example, given nums = [1, 1, 1, 3, 3, 3, 2, 2, 2], one possible answer is [1, 3, 2, 3, 2, 3, 1, 2, 1].\\n\\nNote: the difference between this and the former question is that two adjacent number cannot be the same."
                    },
                    {
                        "username": "AlecLC",
                        "content": "My professor would be happy that bubble sort has an actual use lol"
                    },
                    {
                        "username": "mushroom_in_rain",
                        "content": "This one is more like \\'easy\\' for me instead of \\'medium\\' .... Many questions marked as easy but require much more time to think of, like the question #734 from last week."
                    },
                    {
                        "username": "kmp1084",
                        "content": "The O(N) method is genius :)"
                    },
                    {
                        "username": "ajinkyagavane",
                        "content": "*** APPROACH 1****\nTwo hints: I hope you don't need the second hint ;)\n\n**** HINT 1 ****\nObserve alternate terms in the condition: nums[0] <= nums[1] >= nums[2] <= nums[3]...\nPut them under two lists such that all the numbers in list1 are less than all the numbers in list2\n\n*\n*\n*\n**** HINT 2 ****\nWhat if nums[0] >= nums[2], and nums[1] >= nums[3]? \n- we still satisfy the given condition\n\nThus, if we have a sorted list1, and list2.. we should arrive at the solution with a little rearrangement.\n\n\n*** APPROACH 2 ****\n**** HINT *****\nPerhaps, traverse the list and satisfy the given condition in a pairwise fashion."
                    }
                ]
            },
            {
                "id": 1793455,
                "content": [
                    {
                        "username": "laodasb",
                        "content": "If you learned discreted mathematics...I\\' m sure that you may need a proof,  here is it, if I was wrong, please correct me, thanks.\\n\\nWe claim that: **If we make odd-indexed element larger than its neighbour elements, it can result a wiggle sorted array.**\\n\\n**Base case: **\\n\\nwhen index i is 0 or 1, that \\'s good--->[2],[2,3].\\nif  i == 2, we simply swap elements to result a array [x,y,z], and y is larger than x and z, the claim is also good.**\\n\\n**Assumption:**\\n\\nAssume that our claim is good for i == k, we need to prove it is also true for i== k+1:\\n\\n4 cases:\\n\\tcase1:i is odd, nums[i-1] smaller: good.\\n\\tcase2:i is odd, nums[i-1] larger:then,swap(i,i-1)--->doesn\\'t matter previous sorted array, because nums[i] is smaller...\\n\\tcase3:i is even, nums[i-1] larger:good.\\n\\tcase4:i is even,nums[i-1] smaller:then,swap(i,i-1)--->doesn\\'t matter previous sorted array, because nums[i] is larger.\\n\\t\\nConclusion: \\n\\tFrom above proof, no matter the newly element is an odd-indexed or even-indexed, only if we make the odd-indexed element larger than its neighbour elements, we maintain a wiggle sort array.\\n\\n\\n"
                    },
                    {
                        "username": "reddddddd",
                        "content": "I could not find any example where we cannot wiggle sort an array. \\n\\nBut, do we have a formal proof that every array can be wiggle sorted ?"
                    },
                    {
                        "username": "TGBBSZWHWDLANZP",
                        "content": "the criteria states <= and >= so an array of all the same elements, eg [1,1,1,1,1,1], is a valid wiggle sort."
                    },
                    {
                        "username": "user8228j",
                        "content": "For Python, if you are reassigning the entire value of the nums array at once, instead of doing \\nnums = ...\\ndo nums[:] = ...\\nThat way python doesnt create a new local variable nums with the same name"
                    },
                    {
                        "username": "TGBBSZWHWDLANZP",
                        "content": "did you use nums.sort() to sort it in place?"
                    },
                    {
                        "username": "rajs217",
                        "content": "Observation.\\nOne array with increasing order\\nOne array with decreasing order\\n\\nMerge them to the same length of original array.\\n\\neg: \\nOriginal Array: [3,5,2,1,6,4]\\nIncreasing Order Array: [ 1,2,3,4,5,6]\\nDecreasing Order Array: [6,5,4,3,2,1]\\n\\nMerge them ( merge doesnt mean directly add, one element from increasing array and in next turn one element from decreasing array )\\n\\n[1,6,2,5,3,4] ( stop length is same as orignal array )\\n\\nFOR ODD LENGTH OF ARRAY\\n\\nsame steps as even length but in the and add one extra element from increasing array."
                    },
                    {
                        "username": "RohitSgh",
                        "content": "The question can be **reworded** as\\n> **Reorder** given array in such a manner that \"every element at an `odd index` is greater than or equal to its adjoining elements at `even indices`\""
                    },
                    {
                        "username": "johnsonys",
                        "content": "Given an unsorted array nums, reorder it in-place such that nums[0] < nums[1] > nums[2] < nums[3]...\\nFor example, given nums = [1, 1, 1, 3, 3, 3, 2, 2, 2], one possible answer is [1, 3, 2, 3, 2, 3, 1, 2, 1].\\n\\nNote: the difference between this and the former question is that two adjacent number cannot be the same."
                    },
                    {
                        "username": "AlecLC",
                        "content": "My professor would be happy that bubble sort has an actual use lol"
                    },
                    {
                        "username": "mushroom_in_rain",
                        "content": "This one is more like \\'easy\\' for me instead of \\'medium\\' .... Many questions marked as easy but require much more time to think of, like the question #734 from last week."
                    },
                    {
                        "username": "kmp1084",
                        "content": "The O(N) method is genius :)"
                    },
                    {
                        "username": "ajinkyagavane",
                        "content": "*** APPROACH 1****\nTwo hints: I hope you don't need the second hint ;)\n\n**** HINT 1 ****\nObserve alternate terms in the condition: nums[0] <= nums[1] >= nums[2] <= nums[3]...\nPut them under two lists such that all the numbers in list1 are less than all the numbers in list2\n\n*\n*\n*\n**** HINT 2 ****\nWhat if nums[0] >= nums[2], and nums[1] >= nums[3]? \n- we still satisfy the given condition\n\nThus, if we have a sorted list1, and list2.. we should arrive at the solution with a little rearrangement.\n\n\n*** APPROACH 2 ****\n**** HINT *****\nPerhaps, traverse the list and satisfy the given condition in a pairwise fashion."
                    }
                ]
            },
            {
                "id": 1574148,
                "content": [
                    {
                        "username": "laodasb",
                        "content": "If you learned discreted mathematics...I\\' m sure that you may need a proof,  here is it, if I was wrong, please correct me, thanks.\\n\\nWe claim that: **If we make odd-indexed element larger than its neighbour elements, it can result a wiggle sorted array.**\\n\\n**Base case: **\\n\\nwhen index i is 0 or 1, that \\'s good--->[2],[2,3].\\nif  i == 2, we simply swap elements to result a array [x,y,z], and y is larger than x and z, the claim is also good.**\\n\\n**Assumption:**\\n\\nAssume that our claim is good for i == k, we need to prove it is also true for i== k+1:\\n\\n4 cases:\\n\\tcase1:i is odd, nums[i-1] smaller: good.\\n\\tcase2:i is odd, nums[i-1] larger:then,swap(i,i-1)--->doesn\\'t matter previous sorted array, because nums[i] is smaller...\\n\\tcase3:i is even, nums[i-1] larger:good.\\n\\tcase4:i is even,nums[i-1] smaller:then,swap(i,i-1)--->doesn\\'t matter previous sorted array, because nums[i] is larger.\\n\\t\\nConclusion: \\n\\tFrom above proof, no matter the newly element is an odd-indexed or even-indexed, only if we make the odd-indexed element larger than its neighbour elements, we maintain a wiggle sort array.\\n\\n\\n"
                    },
                    {
                        "username": "reddddddd",
                        "content": "I could not find any example where we cannot wiggle sort an array. \\n\\nBut, do we have a formal proof that every array can be wiggle sorted ?"
                    },
                    {
                        "username": "TGBBSZWHWDLANZP",
                        "content": "the criteria states <= and >= so an array of all the same elements, eg [1,1,1,1,1,1], is a valid wiggle sort."
                    },
                    {
                        "username": "user8228j",
                        "content": "For Python, if you are reassigning the entire value of the nums array at once, instead of doing \\nnums = ...\\ndo nums[:] = ...\\nThat way python doesnt create a new local variable nums with the same name"
                    },
                    {
                        "username": "TGBBSZWHWDLANZP",
                        "content": "did you use nums.sort() to sort it in place?"
                    },
                    {
                        "username": "rajs217",
                        "content": "Observation.\\nOne array with increasing order\\nOne array with decreasing order\\n\\nMerge them to the same length of original array.\\n\\neg: \\nOriginal Array: [3,5,2,1,6,4]\\nIncreasing Order Array: [ 1,2,3,4,5,6]\\nDecreasing Order Array: [6,5,4,3,2,1]\\n\\nMerge them ( merge doesnt mean directly add, one element from increasing array and in next turn one element from decreasing array )\\n\\n[1,6,2,5,3,4] ( stop length is same as orignal array )\\n\\nFOR ODD LENGTH OF ARRAY\\n\\nsame steps as even length but in the and add one extra element from increasing array."
                    },
                    {
                        "username": "RohitSgh",
                        "content": "The question can be **reworded** as\\n> **Reorder** given array in such a manner that \"every element at an `odd index` is greater than or equal to its adjoining elements at `even indices`\""
                    },
                    {
                        "username": "johnsonys",
                        "content": "Given an unsorted array nums, reorder it in-place such that nums[0] < nums[1] > nums[2] < nums[3]...\\nFor example, given nums = [1, 1, 1, 3, 3, 3, 2, 2, 2], one possible answer is [1, 3, 2, 3, 2, 3, 1, 2, 1].\\n\\nNote: the difference between this and the former question is that two adjacent number cannot be the same."
                    },
                    {
                        "username": "AlecLC",
                        "content": "My professor would be happy that bubble sort has an actual use lol"
                    },
                    {
                        "username": "mushroom_in_rain",
                        "content": "This one is more like \\'easy\\' for me instead of \\'medium\\' .... Many questions marked as easy but require much more time to think of, like the question #734 from last week."
                    },
                    {
                        "username": "kmp1084",
                        "content": "The O(N) method is genius :)"
                    },
                    {
                        "username": "ajinkyagavane",
                        "content": "*** APPROACH 1****\nTwo hints: I hope you don't need the second hint ;)\n\n**** HINT 1 ****\nObserve alternate terms in the condition: nums[0] <= nums[1] >= nums[2] <= nums[3]...\nPut them under two lists such that all the numbers in list1 are less than all the numbers in list2\n\n*\n*\n*\n**** HINT 2 ****\nWhat if nums[0] >= nums[2], and nums[1] >= nums[3]? \n- we still satisfy the given condition\n\nThus, if we have a sorted list1, and list2.. we should arrive at the solution with a little rearrangement.\n\n\n*** APPROACH 2 ****\n**** HINT *****\nPerhaps, traverse the list and satisfy the given condition in a pairwise fashion."
                    }
                ]
            },
            {
                "id": 1568055,
                "content": [
                    {
                        "username": "laodasb",
                        "content": "If you learned discreted mathematics...I\\' m sure that you may need a proof,  here is it, if I was wrong, please correct me, thanks.\\n\\nWe claim that: **If we make odd-indexed element larger than its neighbour elements, it can result a wiggle sorted array.**\\n\\n**Base case: **\\n\\nwhen index i is 0 or 1, that \\'s good--->[2],[2,3].\\nif  i == 2, we simply swap elements to result a array [x,y,z], and y is larger than x and z, the claim is also good.**\\n\\n**Assumption:**\\n\\nAssume that our claim is good for i == k, we need to prove it is also true for i== k+1:\\n\\n4 cases:\\n\\tcase1:i is odd, nums[i-1] smaller: good.\\n\\tcase2:i is odd, nums[i-1] larger:then,swap(i,i-1)--->doesn\\'t matter previous sorted array, because nums[i] is smaller...\\n\\tcase3:i is even, nums[i-1] larger:good.\\n\\tcase4:i is even,nums[i-1] smaller:then,swap(i,i-1)--->doesn\\'t matter previous sorted array, because nums[i] is larger.\\n\\t\\nConclusion: \\n\\tFrom above proof, no matter the newly element is an odd-indexed or even-indexed, only if we make the odd-indexed element larger than its neighbour elements, we maintain a wiggle sort array.\\n\\n\\n"
                    },
                    {
                        "username": "reddddddd",
                        "content": "I could not find any example where we cannot wiggle sort an array. \\n\\nBut, do we have a formal proof that every array can be wiggle sorted ?"
                    },
                    {
                        "username": "TGBBSZWHWDLANZP",
                        "content": "the criteria states <= and >= so an array of all the same elements, eg [1,1,1,1,1,1], is a valid wiggle sort."
                    },
                    {
                        "username": "user8228j",
                        "content": "For Python, if you are reassigning the entire value of the nums array at once, instead of doing \\nnums = ...\\ndo nums[:] = ...\\nThat way python doesnt create a new local variable nums with the same name"
                    },
                    {
                        "username": "TGBBSZWHWDLANZP",
                        "content": "did you use nums.sort() to sort it in place?"
                    },
                    {
                        "username": "rajs217",
                        "content": "Observation.\\nOne array with increasing order\\nOne array with decreasing order\\n\\nMerge them to the same length of original array.\\n\\neg: \\nOriginal Array: [3,5,2,1,6,4]\\nIncreasing Order Array: [ 1,2,3,4,5,6]\\nDecreasing Order Array: [6,5,4,3,2,1]\\n\\nMerge them ( merge doesnt mean directly add, one element from increasing array and in next turn one element from decreasing array )\\n\\n[1,6,2,5,3,4] ( stop length is same as orignal array )\\n\\nFOR ODD LENGTH OF ARRAY\\n\\nsame steps as even length but in the and add one extra element from increasing array."
                    },
                    {
                        "username": "RohitSgh",
                        "content": "The question can be **reworded** as\\n> **Reorder** given array in such a manner that \"every element at an `odd index` is greater than or equal to its adjoining elements at `even indices`\""
                    },
                    {
                        "username": "johnsonys",
                        "content": "Given an unsorted array nums, reorder it in-place such that nums[0] < nums[1] > nums[2] < nums[3]...\\nFor example, given nums = [1, 1, 1, 3, 3, 3, 2, 2, 2], one possible answer is [1, 3, 2, 3, 2, 3, 1, 2, 1].\\n\\nNote: the difference between this and the former question is that two adjacent number cannot be the same."
                    },
                    {
                        "username": "AlecLC",
                        "content": "My professor would be happy that bubble sort has an actual use lol"
                    },
                    {
                        "username": "mushroom_in_rain",
                        "content": "This one is more like \\'easy\\' for me instead of \\'medium\\' .... Many questions marked as easy but require much more time to think of, like the question #734 from last week."
                    },
                    {
                        "username": "kmp1084",
                        "content": "The O(N) method is genius :)"
                    },
                    {
                        "username": "ajinkyagavane",
                        "content": "*** APPROACH 1****\nTwo hints: I hope you don't need the second hint ;)\n\n**** HINT 1 ****\nObserve alternate terms in the condition: nums[0] <= nums[1] >= nums[2] <= nums[3]...\nPut them under two lists such that all the numbers in list1 are less than all the numbers in list2\n\n*\n*\n*\n**** HINT 2 ****\nWhat if nums[0] >= nums[2], and nums[1] >= nums[3]? \n- we still satisfy the given condition\n\nThus, if we have a sorted list1, and list2.. we should arrive at the solution with a little rearrangement.\n\n\n*** APPROACH 2 ****\n**** HINT *****\nPerhaps, traverse the list and satisfy the given condition in a pairwise fashion."
                    }
                ]
            },
            {
                "id": 1792566,
                "content": [
                    {
                        "username": "laodasb",
                        "content": "If you learned discreted mathematics...I\\' m sure that you may need a proof,  here is it, if I was wrong, please correct me, thanks.\\n\\nWe claim that: **If we make odd-indexed element larger than its neighbour elements, it can result a wiggle sorted array.**\\n\\n**Base case: **\\n\\nwhen index i is 0 or 1, that \\'s good--->[2],[2,3].\\nif  i == 2, we simply swap elements to result a array [x,y,z], and y is larger than x and z, the claim is also good.**\\n\\n**Assumption:**\\n\\nAssume that our claim is good for i == k, we need to prove it is also true for i== k+1:\\n\\n4 cases:\\n\\tcase1:i is odd, nums[i-1] smaller: good.\\n\\tcase2:i is odd, nums[i-1] larger:then,swap(i,i-1)--->doesn\\'t matter previous sorted array, because nums[i] is smaller...\\n\\tcase3:i is even, nums[i-1] larger:good.\\n\\tcase4:i is even,nums[i-1] smaller:then,swap(i,i-1)--->doesn\\'t matter previous sorted array, because nums[i] is larger.\\n\\t\\nConclusion: \\n\\tFrom above proof, no matter the newly element is an odd-indexed or even-indexed, only if we make the odd-indexed element larger than its neighbour elements, we maintain a wiggle sort array.\\n\\n\\n"
                    },
                    {
                        "username": "reddddddd",
                        "content": "I could not find any example where we cannot wiggle sort an array. \\n\\nBut, do we have a formal proof that every array can be wiggle sorted ?"
                    },
                    {
                        "username": "TGBBSZWHWDLANZP",
                        "content": "the criteria states <= and >= so an array of all the same elements, eg [1,1,1,1,1,1], is a valid wiggle sort."
                    },
                    {
                        "username": "user8228j",
                        "content": "For Python, if you are reassigning the entire value of the nums array at once, instead of doing \\nnums = ...\\ndo nums[:] = ...\\nThat way python doesnt create a new local variable nums with the same name"
                    },
                    {
                        "username": "TGBBSZWHWDLANZP",
                        "content": "did you use nums.sort() to sort it in place?"
                    },
                    {
                        "username": "rajs217",
                        "content": "Observation.\\nOne array with increasing order\\nOne array with decreasing order\\n\\nMerge them to the same length of original array.\\n\\neg: \\nOriginal Array: [3,5,2,1,6,4]\\nIncreasing Order Array: [ 1,2,3,4,5,6]\\nDecreasing Order Array: [6,5,4,3,2,1]\\n\\nMerge them ( merge doesnt mean directly add, one element from increasing array and in next turn one element from decreasing array )\\n\\n[1,6,2,5,3,4] ( stop length is same as orignal array )\\n\\nFOR ODD LENGTH OF ARRAY\\n\\nsame steps as even length but in the and add one extra element from increasing array."
                    },
                    {
                        "username": "RohitSgh",
                        "content": "The question can be **reworded** as\\n> **Reorder** given array in such a manner that \"every element at an `odd index` is greater than or equal to its adjoining elements at `even indices`\""
                    },
                    {
                        "username": "johnsonys",
                        "content": "Given an unsorted array nums, reorder it in-place such that nums[0] < nums[1] > nums[2] < nums[3]...\\nFor example, given nums = [1, 1, 1, 3, 3, 3, 2, 2, 2], one possible answer is [1, 3, 2, 3, 2, 3, 1, 2, 1].\\n\\nNote: the difference between this and the former question is that two adjacent number cannot be the same."
                    },
                    {
                        "username": "AlecLC",
                        "content": "My professor would be happy that bubble sort has an actual use lol"
                    },
                    {
                        "username": "mushroom_in_rain",
                        "content": "This one is more like \\'easy\\' for me instead of \\'medium\\' .... Many questions marked as easy but require much more time to think of, like the question #734 from last week."
                    },
                    {
                        "username": "kmp1084",
                        "content": "The O(N) method is genius :)"
                    },
                    {
                        "username": "ajinkyagavane",
                        "content": "*** APPROACH 1****\nTwo hints: I hope you don't need the second hint ;)\n\n**** HINT 1 ****\nObserve alternate terms in the condition: nums[0] <= nums[1] >= nums[2] <= nums[3]...\nPut them under two lists such that all the numbers in list1 are less than all the numbers in list2\n\n*\n*\n*\n**** HINT 2 ****\nWhat if nums[0] >= nums[2], and nums[1] >= nums[3]? \n- we still satisfy the given condition\n\nThus, if we have a sorted list1, and list2.. we should arrive at the solution with a little rearrangement.\n\n\n*** APPROACH 2 ****\n**** HINT *****\nPerhaps, traverse the list and satisfy the given condition in a pairwise fashion."
                    }
                ]
            },
            {
                "id": 1794914,
                "content": [
                    {
                        "username": "laodasb",
                        "content": "If you learned discreted mathematics...I\\' m sure that you may need a proof,  here is it, if I was wrong, please correct me, thanks.\\n\\nWe claim that: **If we make odd-indexed element larger than its neighbour elements, it can result a wiggle sorted array.**\\n\\n**Base case: **\\n\\nwhen index i is 0 or 1, that \\'s good--->[2],[2,3].\\nif  i == 2, we simply swap elements to result a array [x,y,z], and y is larger than x and z, the claim is also good.**\\n\\n**Assumption:**\\n\\nAssume that our claim is good for i == k, we need to prove it is also true for i== k+1:\\n\\n4 cases:\\n\\tcase1:i is odd, nums[i-1] smaller: good.\\n\\tcase2:i is odd, nums[i-1] larger:then,swap(i,i-1)--->doesn\\'t matter previous sorted array, because nums[i] is smaller...\\n\\tcase3:i is even, nums[i-1] larger:good.\\n\\tcase4:i is even,nums[i-1] smaller:then,swap(i,i-1)--->doesn\\'t matter previous sorted array, because nums[i] is larger.\\n\\t\\nConclusion: \\n\\tFrom above proof, no matter the newly element is an odd-indexed or even-indexed, only if we make the odd-indexed element larger than its neighbour elements, we maintain a wiggle sort array.\\n\\n\\n"
                    },
                    {
                        "username": "reddddddd",
                        "content": "I could not find any example where we cannot wiggle sort an array. \\n\\nBut, do we have a formal proof that every array can be wiggle sorted ?"
                    },
                    {
                        "username": "TGBBSZWHWDLANZP",
                        "content": "the criteria states <= and >= so an array of all the same elements, eg [1,1,1,1,1,1], is a valid wiggle sort."
                    },
                    {
                        "username": "user8228j",
                        "content": "For Python, if you are reassigning the entire value of the nums array at once, instead of doing \\nnums = ...\\ndo nums[:] = ...\\nThat way python doesnt create a new local variable nums with the same name"
                    },
                    {
                        "username": "TGBBSZWHWDLANZP",
                        "content": "did you use nums.sort() to sort it in place?"
                    },
                    {
                        "username": "rajs217",
                        "content": "Observation.\\nOne array with increasing order\\nOne array with decreasing order\\n\\nMerge them to the same length of original array.\\n\\neg: \\nOriginal Array: [3,5,2,1,6,4]\\nIncreasing Order Array: [ 1,2,3,4,5,6]\\nDecreasing Order Array: [6,5,4,3,2,1]\\n\\nMerge them ( merge doesnt mean directly add, one element from increasing array and in next turn one element from decreasing array )\\n\\n[1,6,2,5,3,4] ( stop length is same as orignal array )\\n\\nFOR ODD LENGTH OF ARRAY\\n\\nsame steps as even length but in the and add one extra element from increasing array."
                    },
                    {
                        "username": "RohitSgh",
                        "content": "The question can be **reworded** as\\n> **Reorder** given array in such a manner that \"every element at an `odd index` is greater than or equal to its adjoining elements at `even indices`\""
                    },
                    {
                        "username": "johnsonys",
                        "content": "Given an unsorted array nums, reorder it in-place such that nums[0] < nums[1] > nums[2] < nums[3]...\\nFor example, given nums = [1, 1, 1, 3, 3, 3, 2, 2, 2], one possible answer is [1, 3, 2, 3, 2, 3, 1, 2, 1].\\n\\nNote: the difference between this and the former question is that two adjacent number cannot be the same."
                    },
                    {
                        "username": "AlecLC",
                        "content": "My professor would be happy that bubble sort has an actual use lol"
                    },
                    {
                        "username": "mushroom_in_rain",
                        "content": "This one is more like \\'easy\\' for me instead of \\'medium\\' .... Many questions marked as easy but require much more time to think of, like the question #734 from last week."
                    },
                    {
                        "username": "kmp1084",
                        "content": "The O(N) method is genius :)"
                    },
                    {
                        "username": "ajinkyagavane",
                        "content": "*** APPROACH 1****\nTwo hints: I hope you don't need the second hint ;)\n\n**** HINT 1 ****\nObserve alternate terms in the condition: nums[0] <= nums[1] >= nums[2] <= nums[3]...\nPut them under two lists such that all the numbers in list1 are less than all the numbers in list2\n\n*\n*\n*\n**** HINT 2 ****\nWhat if nums[0] >= nums[2], and nums[1] >= nums[3]? \n- we still satisfy the given condition\n\nThus, if we have a sorted list1, and list2.. we should arrive at the solution with a little rearrangement.\n\n\n*** APPROACH 2 ****\n**** HINT *****\nPerhaps, traverse the list and satisfy the given condition in a pairwise fashion."
                    }
                ]
            },
            {
                "id": 1794852,
                "content": [
                    {
                        "username": "laodasb",
                        "content": "If you learned discreted mathematics...I\\' m sure that you may need a proof,  here is it, if I was wrong, please correct me, thanks.\\n\\nWe claim that: **If we make odd-indexed element larger than its neighbour elements, it can result a wiggle sorted array.**\\n\\n**Base case: **\\n\\nwhen index i is 0 or 1, that \\'s good--->[2],[2,3].\\nif  i == 2, we simply swap elements to result a array [x,y,z], and y is larger than x and z, the claim is also good.**\\n\\n**Assumption:**\\n\\nAssume that our claim is good for i == k, we need to prove it is also true for i== k+1:\\n\\n4 cases:\\n\\tcase1:i is odd, nums[i-1] smaller: good.\\n\\tcase2:i is odd, nums[i-1] larger:then,swap(i,i-1)--->doesn\\'t matter previous sorted array, because nums[i] is smaller...\\n\\tcase3:i is even, nums[i-1] larger:good.\\n\\tcase4:i is even,nums[i-1] smaller:then,swap(i,i-1)--->doesn\\'t matter previous sorted array, because nums[i] is larger.\\n\\t\\nConclusion: \\n\\tFrom above proof, no matter the newly element is an odd-indexed or even-indexed, only if we make the odd-indexed element larger than its neighbour elements, we maintain a wiggle sort array.\\n\\n\\n"
                    },
                    {
                        "username": "reddddddd",
                        "content": "I could not find any example where we cannot wiggle sort an array. \\n\\nBut, do we have a formal proof that every array can be wiggle sorted ?"
                    },
                    {
                        "username": "TGBBSZWHWDLANZP",
                        "content": "the criteria states <= and >= so an array of all the same elements, eg [1,1,1,1,1,1], is a valid wiggle sort."
                    },
                    {
                        "username": "user8228j",
                        "content": "For Python, if you are reassigning the entire value of the nums array at once, instead of doing \\nnums = ...\\ndo nums[:] = ...\\nThat way python doesnt create a new local variable nums with the same name"
                    },
                    {
                        "username": "TGBBSZWHWDLANZP",
                        "content": "did you use nums.sort() to sort it in place?"
                    },
                    {
                        "username": "rajs217",
                        "content": "Observation.\\nOne array with increasing order\\nOne array with decreasing order\\n\\nMerge them to the same length of original array.\\n\\neg: \\nOriginal Array: [3,5,2,1,6,4]\\nIncreasing Order Array: [ 1,2,3,4,5,6]\\nDecreasing Order Array: [6,5,4,3,2,1]\\n\\nMerge them ( merge doesnt mean directly add, one element from increasing array and in next turn one element from decreasing array )\\n\\n[1,6,2,5,3,4] ( stop length is same as orignal array )\\n\\nFOR ODD LENGTH OF ARRAY\\n\\nsame steps as even length but in the and add one extra element from increasing array."
                    },
                    {
                        "username": "RohitSgh",
                        "content": "The question can be **reworded** as\\n> **Reorder** given array in such a manner that \"every element at an `odd index` is greater than or equal to its adjoining elements at `even indices`\""
                    },
                    {
                        "username": "johnsonys",
                        "content": "Given an unsorted array nums, reorder it in-place such that nums[0] < nums[1] > nums[2] < nums[3]...\\nFor example, given nums = [1, 1, 1, 3, 3, 3, 2, 2, 2], one possible answer is [1, 3, 2, 3, 2, 3, 1, 2, 1].\\n\\nNote: the difference between this and the former question is that two adjacent number cannot be the same."
                    },
                    {
                        "username": "AlecLC",
                        "content": "My professor would be happy that bubble sort has an actual use lol"
                    },
                    {
                        "username": "mushroom_in_rain",
                        "content": "This one is more like \\'easy\\' for me instead of \\'medium\\' .... Many questions marked as easy but require much more time to think of, like the question #734 from last week."
                    },
                    {
                        "username": "kmp1084",
                        "content": "The O(N) method is genius :)"
                    },
                    {
                        "username": "ajinkyagavane",
                        "content": "*** APPROACH 1****\nTwo hints: I hope you don't need the second hint ;)\n\n**** HINT 1 ****\nObserve alternate terms in the condition: nums[0] <= nums[1] >= nums[2] <= nums[3]...\nPut them under two lists such that all the numbers in list1 are less than all the numbers in list2\n\n*\n*\n*\n**** HINT 2 ****\nWhat if nums[0] >= nums[2], and nums[1] >= nums[3]? \n- we still satisfy the given condition\n\nThus, if we have a sorted list1, and list2.. we should arrive at the solution with a little rearrangement.\n\n\n*** APPROACH 2 ****\n**** HINT *****\nPerhaps, traverse the list and satisfy the given condition in a pairwise fashion."
                    }
                ]
            },
            {
                "id": 1571523,
                "content": [
                    {
                        "username": "laodasb",
                        "content": "If you learned discreted mathematics...I\\' m sure that you may need a proof,  here is it, if I was wrong, please correct me, thanks.\\n\\nWe claim that: **If we make odd-indexed element larger than its neighbour elements, it can result a wiggle sorted array.**\\n\\n**Base case: **\\n\\nwhen index i is 0 or 1, that \\'s good--->[2],[2,3].\\nif  i == 2, we simply swap elements to result a array [x,y,z], and y is larger than x and z, the claim is also good.**\\n\\n**Assumption:**\\n\\nAssume that our claim is good for i == k, we need to prove it is also true for i== k+1:\\n\\n4 cases:\\n\\tcase1:i is odd, nums[i-1] smaller: good.\\n\\tcase2:i is odd, nums[i-1] larger:then,swap(i,i-1)--->doesn\\'t matter previous sorted array, because nums[i] is smaller...\\n\\tcase3:i is even, nums[i-1] larger:good.\\n\\tcase4:i is even,nums[i-1] smaller:then,swap(i,i-1)--->doesn\\'t matter previous sorted array, because nums[i] is larger.\\n\\t\\nConclusion: \\n\\tFrom above proof, no matter the newly element is an odd-indexed or even-indexed, only if we make the odd-indexed element larger than its neighbour elements, we maintain a wiggle sort array.\\n\\n\\n"
                    },
                    {
                        "username": "reddddddd",
                        "content": "I could not find any example where we cannot wiggle sort an array. \\n\\nBut, do we have a formal proof that every array can be wiggle sorted ?"
                    },
                    {
                        "username": "TGBBSZWHWDLANZP",
                        "content": "the criteria states <= and >= so an array of all the same elements, eg [1,1,1,1,1,1], is a valid wiggle sort."
                    },
                    {
                        "username": "user8228j",
                        "content": "For Python, if you are reassigning the entire value of the nums array at once, instead of doing \\nnums = ...\\ndo nums[:] = ...\\nThat way python doesnt create a new local variable nums with the same name"
                    },
                    {
                        "username": "TGBBSZWHWDLANZP",
                        "content": "did you use nums.sort() to sort it in place?"
                    },
                    {
                        "username": "rajs217",
                        "content": "Observation.\\nOne array with increasing order\\nOne array with decreasing order\\n\\nMerge them to the same length of original array.\\n\\neg: \\nOriginal Array: [3,5,2,1,6,4]\\nIncreasing Order Array: [ 1,2,3,4,5,6]\\nDecreasing Order Array: [6,5,4,3,2,1]\\n\\nMerge them ( merge doesnt mean directly add, one element from increasing array and in next turn one element from decreasing array )\\n\\n[1,6,2,5,3,4] ( stop length is same as orignal array )\\n\\nFOR ODD LENGTH OF ARRAY\\n\\nsame steps as even length but in the and add one extra element from increasing array."
                    },
                    {
                        "username": "RohitSgh",
                        "content": "The question can be **reworded** as\\n> **Reorder** given array in such a manner that \"every element at an `odd index` is greater than or equal to its adjoining elements at `even indices`\""
                    },
                    {
                        "username": "johnsonys",
                        "content": "Given an unsorted array nums, reorder it in-place such that nums[0] < nums[1] > nums[2] < nums[3]...\\nFor example, given nums = [1, 1, 1, 3, 3, 3, 2, 2, 2], one possible answer is [1, 3, 2, 3, 2, 3, 1, 2, 1].\\n\\nNote: the difference between this and the former question is that two adjacent number cannot be the same."
                    },
                    {
                        "username": "AlecLC",
                        "content": "My professor would be happy that bubble sort has an actual use lol"
                    },
                    {
                        "username": "mushroom_in_rain",
                        "content": "This one is more like \\'easy\\' for me instead of \\'medium\\' .... Many questions marked as easy but require much more time to think of, like the question #734 from last week."
                    },
                    {
                        "username": "kmp1084",
                        "content": "The O(N) method is genius :)"
                    },
                    {
                        "username": "ajinkyagavane",
                        "content": "*** APPROACH 1****\nTwo hints: I hope you don't need the second hint ;)\n\n**** HINT 1 ****\nObserve alternate terms in the condition: nums[0] <= nums[1] >= nums[2] <= nums[3]...\nPut them under two lists such that all the numbers in list1 are less than all the numbers in list2\n\n*\n*\n*\n**** HINT 2 ****\nWhat if nums[0] >= nums[2], and nums[1] >= nums[3]? \n- we still satisfy the given condition\n\nThus, if we have a sorted list1, and list2.. we should arrive at the solution with a little rearrangement.\n\n\n*** APPROACH 2 ****\n**** HINT *****\nPerhaps, traverse the list and satisfy the given condition in a pairwise fashion."
                    }
                ]
            },
            {
                "id": 1847651,
                "content": [
                    {
                        "username": "laodasb",
                        "content": "If you learned discreted mathematics...I\\' m sure that you may need a proof,  here is it, if I was wrong, please correct me, thanks.\\n\\nWe claim that: **If we make odd-indexed element larger than its neighbour elements, it can result a wiggle sorted array.**\\n\\n**Base case: **\\n\\nwhen index i is 0 or 1, that \\'s good--->[2],[2,3].\\nif  i == 2, we simply swap elements to result a array [x,y,z], and y is larger than x and z, the claim is also good.**\\n\\n**Assumption:**\\n\\nAssume that our claim is good for i == k, we need to prove it is also true for i== k+1:\\n\\n4 cases:\\n\\tcase1:i is odd, nums[i-1] smaller: good.\\n\\tcase2:i is odd, nums[i-1] larger:then,swap(i,i-1)--->doesn\\'t matter previous sorted array, because nums[i] is smaller...\\n\\tcase3:i is even, nums[i-1] larger:good.\\n\\tcase4:i is even,nums[i-1] smaller:then,swap(i,i-1)--->doesn\\'t matter previous sorted array, because nums[i] is larger.\\n\\t\\nConclusion: \\n\\tFrom above proof, no matter the newly element is an odd-indexed or even-indexed, only if we make the odd-indexed element larger than its neighbour elements, we maintain a wiggle sort array.\\n\\n\\n"
                    },
                    {
                        "username": "reddddddd",
                        "content": "I could not find any example where we cannot wiggle sort an array. \\n\\nBut, do we have a formal proof that every array can be wiggle sorted ?"
                    },
                    {
                        "username": "TGBBSZWHWDLANZP",
                        "content": "the criteria states <= and >= so an array of all the same elements, eg [1,1,1,1,1,1], is a valid wiggle sort."
                    },
                    {
                        "username": "user8228j",
                        "content": "For Python, if you are reassigning the entire value of the nums array at once, instead of doing \\nnums = ...\\ndo nums[:] = ...\\nThat way python doesnt create a new local variable nums with the same name"
                    },
                    {
                        "username": "TGBBSZWHWDLANZP",
                        "content": "did you use nums.sort() to sort it in place?"
                    },
                    {
                        "username": "rajs217",
                        "content": "Observation.\\nOne array with increasing order\\nOne array with decreasing order\\n\\nMerge them to the same length of original array.\\n\\neg: \\nOriginal Array: [3,5,2,1,6,4]\\nIncreasing Order Array: [ 1,2,3,4,5,6]\\nDecreasing Order Array: [6,5,4,3,2,1]\\n\\nMerge them ( merge doesnt mean directly add, one element from increasing array and in next turn one element from decreasing array )\\n\\n[1,6,2,5,3,4] ( stop length is same as orignal array )\\n\\nFOR ODD LENGTH OF ARRAY\\n\\nsame steps as even length but in the and add one extra element from increasing array."
                    },
                    {
                        "username": "RohitSgh",
                        "content": "The question can be **reworded** as\\n> **Reorder** given array in such a manner that \"every element at an `odd index` is greater than or equal to its adjoining elements at `even indices`\""
                    },
                    {
                        "username": "johnsonys",
                        "content": "Given an unsorted array nums, reorder it in-place such that nums[0] < nums[1] > nums[2] < nums[3]...\\nFor example, given nums = [1, 1, 1, 3, 3, 3, 2, 2, 2], one possible answer is [1, 3, 2, 3, 2, 3, 1, 2, 1].\\n\\nNote: the difference between this and the former question is that two adjacent number cannot be the same."
                    },
                    {
                        "username": "AlecLC",
                        "content": "My professor would be happy that bubble sort has an actual use lol"
                    },
                    {
                        "username": "mushroom_in_rain",
                        "content": "This one is more like \\'easy\\' for me instead of \\'medium\\' .... Many questions marked as easy but require much more time to think of, like the question #734 from last week."
                    },
                    {
                        "username": "kmp1084",
                        "content": "The O(N) method is genius :)"
                    },
                    {
                        "username": "ajinkyagavane",
                        "content": "*** APPROACH 1****\nTwo hints: I hope you don't need the second hint ;)\n\n**** HINT 1 ****\nObserve alternate terms in the condition: nums[0] <= nums[1] >= nums[2] <= nums[3]...\nPut them under two lists such that all the numbers in list1 are less than all the numbers in list2\n\n*\n*\n*\n**** HINT 2 ****\nWhat if nums[0] >= nums[2], and nums[1] >= nums[3]? \n- we still satisfy the given condition\n\nThus, if we have a sorted list1, and list2.. we should arrive at the solution with a little rearrangement.\n\n\n*** APPROACH 2 ****\n**** HINT *****\nPerhaps, traverse the list and satisfy the given condition in a pairwise fashion."
                    }
                ]
            },
            {
                "id": 1801339,
                "content": [
                    {
                        "username": "laodasb",
                        "content": "If you learned discreted mathematics...I\\' m sure that you may need a proof,  here is it, if I was wrong, please correct me, thanks.\\n\\nWe claim that: **If we make odd-indexed element larger than its neighbour elements, it can result a wiggle sorted array.**\\n\\n**Base case: **\\n\\nwhen index i is 0 or 1, that \\'s good--->[2],[2,3].\\nif  i == 2, we simply swap elements to result a array [x,y,z], and y is larger than x and z, the claim is also good.**\\n\\n**Assumption:**\\n\\nAssume that our claim is good for i == k, we need to prove it is also true for i== k+1:\\n\\n4 cases:\\n\\tcase1:i is odd, nums[i-1] smaller: good.\\n\\tcase2:i is odd, nums[i-1] larger:then,swap(i,i-1)--->doesn\\'t matter previous sorted array, because nums[i] is smaller...\\n\\tcase3:i is even, nums[i-1] larger:good.\\n\\tcase4:i is even,nums[i-1] smaller:then,swap(i,i-1)--->doesn\\'t matter previous sorted array, because nums[i] is larger.\\n\\t\\nConclusion: \\n\\tFrom above proof, no matter the newly element is an odd-indexed or even-indexed, only if we make the odd-indexed element larger than its neighbour elements, we maintain a wiggle sort array.\\n\\n\\n"
                    },
                    {
                        "username": "reddddddd",
                        "content": "I could not find any example where we cannot wiggle sort an array. \\n\\nBut, do we have a formal proof that every array can be wiggle sorted ?"
                    },
                    {
                        "username": "TGBBSZWHWDLANZP",
                        "content": "the criteria states <= and >= so an array of all the same elements, eg [1,1,1,1,1,1], is a valid wiggle sort."
                    },
                    {
                        "username": "user8228j",
                        "content": "For Python, if you are reassigning the entire value of the nums array at once, instead of doing \\nnums = ...\\ndo nums[:] = ...\\nThat way python doesnt create a new local variable nums with the same name"
                    },
                    {
                        "username": "TGBBSZWHWDLANZP",
                        "content": "did you use nums.sort() to sort it in place?"
                    },
                    {
                        "username": "rajs217",
                        "content": "Observation.\\nOne array with increasing order\\nOne array with decreasing order\\n\\nMerge them to the same length of original array.\\n\\neg: \\nOriginal Array: [3,5,2,1,6,4]\\nIncreasing Order Array: [ 1,2,3,4,5,6]\\nDecreasing Order Array: [6,5,4,3,2,1]\\n\\nMerge them ( merge doesnt mean directly add, one element from increasing array and in next turn one element from decreasing array )\\n\\n[1,6,2,5,3,4] ( stop length is same as orignal array )\\n\\nFOR ODD LENGTH OF ARRAY\\n\\nsame steps as even length but in the and add one extra element from increasing array."
                    },
                    {
                        "username": "RohitSgh",
                        "content": "The question can be **reworded** as\\n> **Reorder** given array in such a manner that \"every element at an `odd index` is greater than or equal to its adjoining elements at `even indices`\""
                    },
                    {
                        "username": "johnsonys",
                        "content": "Given an unsorted array nums, reorder it in-place such that nums[0] < nums[1] > nums[2] < nums[3]...\\nFor example, given nums = [1, 1, 1, 3, 3, 3, 2, 2, 2], one possible answer is [1, 3, 2, 3, 2, 3, 1, 2, 1].\\n\\nNote: the difference between this and the former question is that two adjacent number cannot be the same."
                    },
                    {
                        "username": "AlecLC",
                        "content": "My professor would be happy that bubble sort has an actual use lol"
                    },
                    {
                        "username": "mushroom_in_rain",
                        "content": "This one is more like \\'easy\\' for me instead of \\'medium\\' .... Many questions marked as easy but require much more time to think of, like the question #734 from last week."
                    },
                    {
                        "username": "kmp1084",
                        "content": "The O(N) method is genius :)"
                    },
                    {
                        "username": "ajinkyagavane",
                        "content": "*** APPROACH 1****\nTwo hints: I hope you don't need the second hint ;)\n\n**** HINT 1 ****\nObserve alternate terms in the condition: nums[0] <= nums[1] >= nums[2] <= nums[3]...\nPut them under two lists such that all the numbers in list1 are less than all the numbers in list2\n\n*\n*\n*\n**** HINT 2 ****\nWhat if nums[0] >= nums[2], and nums[1] >= nums[3]? \n- we still satisfy the given condition\n\nThus, if we have a sorted list1, and list2.. we should arrive at the solution with a little rearrangement.\n\n\n*** APPROACH 2 ****\n**** HINT *****\nPerhaps, traverse the list and satisfy the given condition in a pairwise fashion."
                    }
                ]
            },
            {
                "id": 1793488,
                "content": [
                    {
                        "username": "laodasb",
                        "content": "If you learned discreted mathematics...I\\' m sure that you may need a proof,  here is it, if I was wrong, please correct me, thanks.\\n\\nWe claim that: **If we make odd-indexed element larger than its neighbour elements, it can result a wiggle sorted array.**\\n\\n**Base case: **\\n\\nwhen index i is 0 or 1, that \\'s good--->[2],[2,3].\\nif  i == 2, we simply swap elements to result a array [x,y,z], and y is larger than x and z, the claim is also good.**\\n\\n**Assumption:**\\n\\nAssume that our claim is good for i == k, we need to prove it is also true for i== k+1:\\n\\n4 cases:\\n\\tcase1:i is odd, nums[i-1] smaller: good.\\n\\tcase2:i is odd, nums[i-1] larger:then,swap(i,i-1)--->doesn\\'t matter previous sorted array, because nums[i] is smaller...\\n\\tcase3:i is even, nums[i-1] larger:good.\\n\\tcase4:i is even,nums[i-1] smaller:then,swap(i,i-1)--->doesn\\'t matter previous sorted array, because nums[i] is larger.\\n\\t\\nConclusion: \\n\\tFrom above proof, no matter the newly element is an odd-indexed or even-indexed, only if we make the odd-indexed element larger than its neighbour elements, we maintain a wiggle sort array.\\n\\n\\n"
                    },
                    {
                        "username": "reddddddd",
                        "content": "I could not find any example where we cannot wiggle sort an array. \\n\\nBut, do we have a formal proof that every array can be wiggle sorted ?"
                    },
                    {
                        "username": "TGBBSZWHWDLANZP",
                        "content": "the criteria states <= and >= so an array of all the same elements, eg [1,1,1,1,1,1], is a valid wiggle sort."
                    },
                    {
                        "username": "user8228j",
                        "content": "For Python, if you are reassigning the entire value of the nums array at once, instead of doing \\nnums = ...\\ndo nums[:] = ...\\nThat way python doesnt create a new local variable nums with the same name"
                    },
                    {
                        "username": "TGBBSZWHWDLANZP",
                        "content": "did you use nums.sort() to sort it in place?"
                    },
                    {
                        "username": "rajs217",
                        "content": "Observation.\\nOne array with increasing order\\nOne array with decreasing order\\n\\nMerge them to the same length of original array.\\n\\neg: \\nOriginal Array: [3,5,2,1,6,4]\\nIncreasing Order Array: [ 1,2,3,4,5,6]\\nDecreasing Order Array: [6,5,4,3,2,1]\\n\\nMerge them ( merge doesnt mean directly add, one element from increasing array and in next turn one element from decreasing array )\\n\\n[1,6,2,5,3,4] ( stop length is same as orignal array )\\n\\nFOR ODD LENGTH OF ARRAY\\n\\nsame steps as even length but in the and add one extra element from increasing array."
                    },
                    {
                        "username": "RohitSgh",
                        "content": "The question can be **reworded** as\\n> **Reorder** given array in such a manner that \"every element at an `odd index` is greater than or equal to its adjoining elements at `even indices`\""
                    },
                    {
                        "username": "johnsonys",
                        "content": "Given an unsorted array nums, reorder it in-place such that nums[0] < nums[1] > nums[2] < nums[3]...\\nFor example, given nums = [1, 1, 1, 3, 3, 3, 2, 2, 2], one possible answer is [1, 3, 2, 3, 2, 3, 1, 2, 1].\\n\\nNote: the difference between this and the former question is that two adjacent number cannot be the same."
                    },
                    {
                        "username": "AlecLC",
                        "content": "My professor would be happy that bubble sort has an actual use lol"
                    },
                    {
                        "username": "mushroom_in_rain",
                        "content": "This one is more like \\'easy\\' for me instead of \\'medium\\' .... Many questions marked as easy but require much more time to think of, like the question #734 from last week."
                    },
                    {
                        "username": "kmp1084",
                        "content": "The O(N) method is genius :)"
                    },
                    {
                        "username": "ajinkyagavane",
                        "content": "*** APPROACH 1****\nTwo hints: I hope you don't need the second hint ;)\n\n**** HINT 1 ****\nObserve alternate terms in the condition: nums[0] <= nums[1] >= nums[2] <= nums[3]...\nPut them under two lists such that all the numbers in list1 are less than all the numbers in list2\n\n*\n*\n*\n**** HINT 2 ****\nWhat if nums[0] >= nums[2], and nums[1] >= nums[3]? \n- we still satisfy the given condition\n\nThus, if we have a sorted list1, and list2.. we should arrive at the solution with a little rearrangement.\n\n\n*** APPROACH 2 ****\n**** HINT *****\nPerhaps, traverse the list and satisfy the given condition in a pairwise fashion."
                    }
                ]
            },
            {
                "id": 1793455,
                "content": [
                    {
                        "username": "laodasb",
                        "content": "If you learned discreted mathematics...I\\' m sure that you may need a proof,  here is it, if I was wrong, please correct me, thanks.\\n\\nWe claim that: **If we make odd-indexed element larger than its neighbour elements, it can result a wiggle sorted array.**\\n\\n**Base case: **\\n\\nwhen index i is 0 or 1, that \\'s good--->[2],[2,3].\\nif  i == 2, we simply swap elements to result a array [x,y,z], and y is larger than x and z, the claim is also good.**\\n\\n**Assumption:**\\n\\nAssume that our claim is good for i == k, we need to prove it is also true for i== k+1:\\n\\n4 cases:\\n\\tcase1:i is odd, nums[i-1] smaller: good.\\n\\tcase2:i is odd, nums[i-1] larger:then,swap(i,i-1)--->doesn\\'t matter previous sorted array, because nums[i] is smaller...\\n\\tcase3:i is even, nums[i-1] larger:good.\\n\\tcase4:i is even,nums[i-1] smaller:then,swap(i,i-1)--->doesn\\'t matter previous sorted array, because nums[i] is larger.\\n\\t\\nConclusion: \\n\\tFrom above proof, no matter the newly element is an odd-indexed or even-indexed, only if we make the odd-indexed element larger than its neighbour elements, we maintain a wiggle sort array.\\n\\n\\n"
                    },
                    {
                        "username": "reddddddd",
                        "content": "I could not find any example where we cannot wiggle sort an array. \\n\\nBut, do we have a formal proof that every array can be wiggle sorted ?"
                    },
                    {
                        "username": "TGBBSZWHWDLANZP",
                        "content": "the criteria states <= and >= so an array of all the same elements, eg [1,1,1,1,1,1], is a valid wiggle sort."
                    },
                    {
                        "username": "user8228j",
                        "content": "For Python, if you are reassigning the entire value of the nums array at once, instead of doing \\nnums = ...\\ndo nums[:] = ...\\nThat way python doesnt create a new local variable nums with the same name"
                    },
                    {
                        "username": "TGBBSZWHWDLANZP",
                        "content": "did you use nums.sort() to sort it in place?"
                    },
                    {
                        "username": "rajs217",
                        "content": "Observation.\\nOne array with increasing order\\nOne array with decreasing order\\n\\nMerge them to the same length of original array.\\n\\neg: \\nOriginal Array: [3,5,2,1,6,4]\\nIncreasing Order Array: [ 1,2,3,4,5,6]\\nDecreasing Order Array: [6,5,4,3,2,1]\\n\\nMerge them ( merge doesnt mean directly add, one element from increasing array and in next turn one element from decreasing array )\\n\\n[1,6,2,5,3,4] ( stop length is same as orignal array )\\n\\nFOR ODD LENGTH OF ARRAY\\n\\nsame steps as even length but in the and add one extra element from increasing array."
                    },
                    {
                        "username": "RohitSgh",
                        "content": "The question can be **reworded** as\\n> **Reorder** given array in such a manner that \"every element at an `odd index` is greater than or equal to its adjoining elements at `even indices`\""
                    },
                    {
                        "username": "johnsonys",
                        "content": "Given an unsorted array nums, reorder it in-place such that nums[0] < nums[1] > nums[2] < nums[3]...\\nFor example, given nums = [1, 1, 1, 3, 3, 3, 2, 2, 2], one possible answer is [1, 3, 2, 3, 2, 3, 1, 2, 1].\\n\\nNote: the difference between this and the former question is that two adjacent number cannot be the same."
                    },
                    {
                        "username": "AlecLC",
                        "content": "My professor would be happy that bubble sort has an actual use lol"
                    },
                    {
                        "username": "mushroom_in_rain",
                        "content": "This one is more like \\'easy\\' for me instead of \\'medium\\' .... Many questions marked as easy but require much more time to think of, like the question #734 from last week."
                    },
                    {
                        "username": "kmp1084",
                        "content": "The O(N) method is genius :)"
                    },
                    {
                        "username": "ajinkyagavane",
                        "content": "*** APPROACH 1****\nTwo hints: I hope you don't need the second hint ;)\n\n**** HINT 1 ****\nObserve alternate terms in the condition: nums[0] <= nums[1] >= nums[2] <= nums[3]...\nPut them under two lists such that all the numbers in list1 are less than all the numbers in list2\n\n*\n*\n*\n**** HINT 2 ****\nWhat if nums[0] >= nums[2], and nums[1] >= nums[3]? \n- we still satisfy the given condition\n\nThus, if we have a sorted list1, and list2.. we should arrive at the solution with a little rearrangement.\n\n\n*** APPROACH 2 ****\n**** HINT *****\nPerhaps, traverse the list and satisfy the given condition in a pairwise fashion."
                    }
                ]
            }
        ]
    },
    {
        "title": "Zigzag Iterator",
        "question_content": null,
        "solutions": [],
        "discussions": [
            {
                "id": 1571524,
                "content": [
                    {
                        "username": "istudy0",
                        "content": "This is not directly related to the question but it would be good if C++ interface methods are same as iterator class.\\nWhen this question is asked, the interviewer expects to see those operator methods and thus, it will be good to see different interface requirement for C++ so I can learn from others what exactly I need to implement. ;-)"
                    },
                    {
                        "username": "mkohar",
                        "content": "Intuition for python : \\n1. keep a flag variable which keeps track of which vector should you pop out the result of\\n2. Keep two pointers (1  for each vector)"
                    }
                ]
            },
            {
                "id": 1727027,
                "content": [
                    {
                        "username": "istudy0",
                        "content": "This is not directly related to the question but it would be good if C++ interface methods are same as iterator class.\\nWhen this question is asked, the interviewer expects to see those operator methods and thus, it will be good to see different interface requirement for C++ so I can learn from others what exactly I need to implement. ;-)"
                    },
                    {
                        "username": "mkohar",
                        "content": "Intuition for python : \\n1. keep a flag variable which keeps track of which vector should you pop out the result of\\n2. Keep two pointers (1  for each vector)"
                    }
                ]
            }
        ]
    },
    {
        "title": "Expression Add Operators",
        "question_content": "<p>Given a string <code>num</code> that contains only digits and an integer <code>target</code>, return <em><strong>all possibilities</strong> to insert the binary operators </em><code>&#39;+&#39;</code><em>, </em><code>&#39;-&#39;</code><em>, and/or </em><code>&#39;*&#39;</code><em> between the digits of </em><code>num</code><em> so that the resultant expression evaluates to the </em><code>target</code><em> value</em>.</p>\n\n<p>Note that operands in the returned expressions <strong>should not</strong> contain leading zeros.</p>\n\n<p>&nbsp;</p>\n<p><strong class=\"example\">Example 1:</strong></p>\n\n<pre>\n<strong>Input:</strong> num = &quot;123&quot;, target = 6\n<strong>Output:</strong> [&quot;1*2*3&quot;,&quot;1+2+3&quot;]\n<strong>Explanation:</strong> Both &quot;1*2*3&quot; and &quot;1+2+3&quot; evaluate to 6.\n</pre>\n\n<p><strong class=\"example\">Example 2:</strong></p>\n\n<pre>\n<strong>Input:</strong> num = &quot;232&quot;, target = 8\n<strong>Output:</strong> [&quot;2*3+2&quot;,&quot;2+3*2&quot;]\n<strong>Explanation:</strong> Both &quot;2*3+2&quot; and &quot;2+3*2&quot; evaluate to 8.\n</pre>\n\n<p><strong class=\"example\">Example 3:</strong></p>\n\n<pre>\n<strong>Input:</strong> num = &quot;3456237490&quot;, target = 9191\n<strong>Output:</strong> []\n<strong>Explanation:</strong> There are no expressions that can be created from &quot;3456237490&quot; to evaluate to 9191.\n</pre>\n\n<p>&nbsp;</p>\n<p><strong>Constraints:</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= num.length &lt;= 10</code></li>\n\t<li><code>num</code> consists of only digits.</li>\n\t<li><code>-2<sup>31</sup> &lt;= target &lt;= 2<sup>31</sup> - 1</code></li>\n</ul>\n",
        "solutions": [
            {
                "id": 71895,
                "title": "java-standard-backtrace-ac-solutoin-short-and-clear",
                "content": "This problem has a lot of edge cases to be considered:\\n\\n1. overflow: we use a long type once it is larger than Integer.MAX_VALUE or minimum, we get over it. \\n2. 0 sequence: because we can't have numbers with multiple digits started with zero, we have to deal with it too.\\n3. a little trick is that we should save the value that is to be multiplied in the next recursion.\\n\\n---\\n\\n    public class Solution {\\n        public List<String> addOperators(String num, int target) {\\n            List<String> rst = new ArrayList<String>();\\n            if(num == null || num.length() == 0) return rst;\\n            helper(rst, \"\", num, target, 0, 0, 0);\\n            return rst;\\n        }\\n        public void helper(List<String> rst, String path, String num, int target, int pos, long eval, long multed){\\n            if(pos == num.length()){\\n                if(target == eval)\\n                    rst.add(path);\\n                return;\\n            }\\n            for(int i = pos; i < num.length(); i++){\\n                if(i != pos && num.charAt(pos) == '0') break;\\n                long cur = Long.parseLong(num.substring(pos, i + 1));\\n                if(pos == 0){\\n                    helper(rst, path + cur, num, target, i + 1, cur, cur);\\n                }\\n                else{\\n                    helper(rst, path + \"+\" + cur, num, target, i + 1, eval + cur , cur);\\n                    \\n                    helper(rst, path + \"-\" + cur, num, target, i + 1, eval -cur, -cur);\\n                    \\n                    helper(rst, path + \"*\" + cur, num, target, i + 1, eval - multed + multed * cur, multed * cur );\\n                }\\n            }\\n        }\\n    }",
                "solutionTags": [
                    "Java"
                ],
                "code": "class Solution {\\n        public List<String> addOperators(String num, int target) {\\n            List<String> rst = new ArrayList<String>();\\n            if(num == null || num.length() == 0) return rst;\\n            helper(rst, \"\", num, target, 0, 0, 0);\\n            return rst;\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 572099,
                "title": "c-java-python-backtracking-evaluate-on-the-fly-clean-concise",
                "content": "**\\u2714\\uFE0F Approach 1: Backtracking & Evaluate Expression**\\n- We use backtracking to generate all possible expressions by adding `+`, `-`, `*` to between the digits of `s` string.\\n- Then write a function `evaluate(string expression)` to evaluate a string expression, if the evaluated result is equal to `target`, we add that expression string to our answer.\\n<details>\\n<summary>Click to see the implementation!</summary>\\n\\n<iframe src=\"https://leetcode.com/playground/6KRPJGSj/shared\" frameBorder=\"0\" width=\"100%\" height=\"1200\"></iframe>\\n</details>\\n\\n---\\n\\n**\\u2714\\uFE0F Approach 2: Backtracking & Evaluate on the fly (Best Solution)**\\n- We use backtracking to generate all possible expressions by adding `+`, `-`, `*` to between the digits of `s` string.\\n- There is no priority since there are no parentheses `(` and `)` in our `s` string, so we can evaluate the expression on the fly to save time.\\n- There are total 3 operators:\\n\\t- `+` operator: `newResult = resSoFar + num`\\n\\t- `-` operator: `newResult = resSoFar - num`.\\n\\t- `*` operator: We need to keep the `prevNum` so that to calculate `newResult` we need to minus `prevNum` then plus with `prevNum * num`. So `newResult = resSoFar - prevNum + prevNum * num`.\\n<iframe src=\"https://leetcode.com/playground/J8AiipGK/shared\" frameBorder=\"0\" width=\"100%\" height=\"600\"></iframe>\\n\\nIf you think this **post is useful**, I\\'m happy if you **give a vote**. Any **questions or discussions are welcome!** Thank a lot.",
                "solutionTags": [],
                "code": "**\\u2714\\uFE0F Approach 1: Backtracking & Evaluate Expression**\\n- We use backtracking to generate all possible expressions by adding `+`, `-`, `*` to between the digits of `s` string.\\n- Then write a function `evaluate(string expression)` to evaluate a string expression, if the evaluated result is equal to `target`, we add that expression string to our answer.\\n<details>\\n<summary>Click to see the implementation!</summary>\\n\\n<iframe src=\"https://leetcode.com/playground/6KRPJGSj/shared\" frameBorder=\"0\" width=\"100%\" height=\"1200\"></iframe>\\n</details>\\n\\n---\\n\\n**\\u2714\\uFE0F Approach 2: Backtracking & Evaluate on the fly (Best Solution)**\\n- We use backtracking to generate all possible expressions by adding `+`, `-`, `*` to between the digits of `s` string.\\n- There is no priority since there are no parentheses `(` and `)` in our `s` string, so we can evaluate the expression on the fly to save time.\\n- There are total 3 operators:\\n\\t- `+` operator: `newResult = resSoFar + num`\\n\\t- `-` operator: `newResult = resSoFar - num`.\\n\\t- `*` operator: We need to keep the `prevNum` so that to calculate `newResult` we need to minus `prevNum` then plus with `prevNum * num`. So `newResult = resSoFar - prevNum + prevNum * num`.\\n<iframe src=\"https://leetcode.com/playground/J8AiipGK/shared\" frameBorder=\"0\" width=\"100%\" height=\"600\"></iframe>\\n\\nIf you think this **post is useful**, I\\'m happy if you **give a vote**. Any **questions or discussions are welcome!** Thank a lot.",
                "codeTag": "Unknown"
            },
            {
                "id": 71968,
                "title": "clean-python-dfs-with-comments",
                "content": "dfs() parameters:  \\nnum:   remaining num string  \\ntemp:  temporally string with operators added  \\ncur:     current result of \"temp\" string  \\nlast:     last multiply-level number in \"temp\". if next operator is \"multiply\", \"cur\" and \"last\" will be updated  \\nres:      result to return\\n\\n    def addOperators(self, num, target):\\n        res, self.target = [], target\\n        for i in range(1,len(num)+1):\\n            if i == 1 or (i > 1 and num[0] != \"0\"): # prevent \"00*\" as a number\\n                self.dfs(num[i:], num[:i], int(num[:i]), int(num[:i]), res) # this step put first number in the string\\n        return res\\n\\n    def dfs(self, num, temp, cur, last, res):\\n        if not num:\\n            if cur == self.target:\\n                res.append(temp)\\n            return\\n        for i in range(1, len(num)+1):\\n            val = num[:i]\\n            if i == 1 or (i > 1 and num[0] != \"0\"): # prevent \"00*\" as a number\\n                self.dfs(num[i:], temp + \"+\" + val, cur+int(val), int(val), res)\\n                self.dfs(num[i:], temp + \"-\" + val, cur-int(val), -int(val), res)\\n                self.dfs(num[i:], temp + \"*\" + val, cur-last+last*int(val), last*int(val), res)",
                "solutionTags": [
                    "Python"
                ],
                "code": "dfs() parameters:  \\nnum:   remaining num string  \\ntemp:  temporally string with operators added  \\ncur:     current result of \"temp\" string  \\nlast:     last multiply-level number in \"temp\". if next operator is \"multiply\", \"cur\" and \"last\" will be updated  \\nres:      result to return\\n\\n    def addOperators(self, num, target):\\n        res, self.target = [], target\\n        for i in range(1,len(num)+1):\\n            if i == 1 or (i > 1 and num[0] != \"0\"): # prevent \"00*\" as a number\\n                self.dfs(num[i:], num[:i], int(num[:i]), int(num[:i]), res) # this step put first number in the string\\n        return res\\n\\n    def dfs(self, num, temp, cur, last, res):\\n        if not num:\\n            if cur == self.target:\\n                res.append(temp)\\n            return\\n        for i in range(1, len(num)+1):\\n            val = num[:i]\\n            if i == 1 or (i > 1 and num[0] != \"0\"): # prevent \"00*\" as a number\\n                self.dfs(num[i:], temp + \"+\" + val, cur+int(val), int(val), res)\\n                self.dfs(num[i:], temp + \"-\" + val, cur-int(val), -int(val), res)\\n                self.dfs(num[i:], temp + \"*\" + val, cur-last+last*int(val), last*int(val), res)",
                "codeTag": "Python3"
            },
            {
                "id": 71898,
                "title": "17-lines-solution-dfs-c",
                "content": "    class Solution {\\n    private:\\n        // cur: {string} expression generated so far.\\n        // pos: {int}    current visiting position of num.\\n        // cv:  {long}   cumulative value so far.\\n        // pv:  {long}   previous operand value.\\n        // op:  {char}   previous operator used.\\n        void dfs(std::vector<string>& res, const string& num, const int target, string cur, int pos, const long cv, const long pv, const char op) {\\n            if (pos == num.size() && cv == target) {\\n                res.push_back(cur);\\n            } else {\\n                for (int i=pos+1; i<=num.size(); i++) {\\n                    string t = num.substr(pos, i-pos);\\n                    long now = stol(t);\\n                    if (to_string(now).size() != t.size()) continue;\\n                    dfs(res, num, target, cur+'+'+t, i, cv+now, now, '+');\\n                    dfs(res, num, target, cur+'-'+t, i, cv-now, now, '-');\\n                    dfs(res, num, target, cur+'*'+t, i, (op == '-') ? cv+pv - pv*now : ((op == '+') ? cv-pv + pv*now : pv*now), pv*now, op);\\n                }\\n            }\\n        }\\n    \\n    public:\\n        vector<string> addOperators(string num, int target) {\\n            vector<string> res;\\n            if (num.empty()) return res;\\n            for (int i=1; i<=num.size(); i++) {\\n                string s = num.substr(0, i);\\n                long cur = stol(s);\\n                if (to_string(cur).size() != s.size()) continue;\\n                dfs(res, num, target, s, i, cur, cur, '#');         // no operator defined.\\n            }\\n    \\n            return res;\\n        }\\n    };",
                "solutionTags": [
                    "C++"
                ],
                "code": "class Solution {\\n    private:\\n        // cur: {string}",
                "codeTag": "Java"
            },
            {
                "id": 71897,
                "title": "java-ac-solution-19ms-beat-100-00",
                "content": "I am surprised that it beats 100.00% other solutions, so i have to share this.\\n\\n    void dfs(List<String> ret, char[] path, int len, long left, long cur, char[] digits, int pos, int target) {\\n        if (pos == digits.length) {\\n            if (left + cur == target) ret.add(new String(path, 0, len));\\n            return;\\n        }\\n        long n = 0;\\n        int j = len + 1;\\n        for (int i = pos; i < digits.length; i++) {\\n            n = n * 10 + digits[i] - '0';\\n            path[j++] = digits[i];\\n            path[len] = '+';\\n            dfs(ret, path, j, left + cur, n, digits, i + 1, target);\\n            path[len] = '-';\\n            dfs(ret, path, j, left + cur, -n, digits, i + 1, target);\\n            path[len] = '*';\\n            dfs(ret, path, j, left, cur * n, digits, i + 1, target);\\n            if (digits[pos] == '0') break; \\n        }\\n    }\\n    public List<String> addOperators(String num, int target) {\\n        List<String> ret = new LinkedList<>();\\n        if (num.length() == 0) return ret;\\n        char[] path = new char[num.length() * 2 - 1];\\n        char[] digits = num.toCharArray();\\n        long n = 0;\\n        for (int i = 0; i < digits.length; i++) {\\n            n = n * 10 + digits[i] - '0';\\n            path[i] = digits[i];\\n            dfs(ret, path, i + 1, 0, n, digits, i + 1, target);\\n            if (n == 0) break;\\n        }\\n        return ret;\\n    }",
                "solutionTags": [],
                "code": "I am surprised that it beats 100.00% other solutions, so i have to share this.\\n\\n    void dfs(List<String> ret, char[] path, int len, long left, long cur, char[] digits, int pos, int target) {\\n        if (pos == digits.length) {\\n            if (left + cur == target) ret.add(new String(path, 0, len));\\n            return;\\n        }\\n        long n = 0;\\n        int j = len + 1;\\n        for (int i = pos; i < digits.length; i++) {\\n            n = n * 10 + digits[i] - '0';\\n            path[j++] = digits[i];\\n            path[len] = '+';\\n            dfs(ret, path, j, left + cur, n, digits, i + 1, target);\\n            path[len] = '-';\\n            dfs(ret, path, j, left + cur, -n, digits, i + 1, target);\\n            path[len] = '*';\\n            dfs(ret, path, j, left, cur * n, digits, i + 1, target);\\n            if (digits[pos] == '0') break; \\n        }\\n    }\\n    public List<String> addOperators(String num, int target) {\\n        List<String> ret = new LinkedList<>();\\n        if (num.length() == 0) return ret;\\n        char[] path = new char[num.length() * 2 - 1];\\n        char[] digits = num.toCharArray();\\n        long n = 0;\\n        for (int i = 0; i < digits.length; i++) {\\n            n = n * 10 + digits[i] - '0';\\n            path[i] = digits[i];\\n            dfs(ret, path, i + 1, 0, n, digits, i + 1, target);\\n            if (n == 0) break;\\n        }\\n        return ret;\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 1470156,
                "title": "python-dfs-with-stack-of-monomials-explained",
                "content": "Quite diffucult problem, which is similar to Basic Calculators problem (**0224**, **0227**). Let us consider `dfs` with the following parameters:\\n\\n1. `idx` is the index of current element we traverse in `num`.\\n2. `path` is the string built so far.\\n3. `value` is current value of created path.\\n4. `last` is the value of the last monomial.\\n\\nHere we use idea of stack of monomials: imagine, that we have expression `1*2 + 3*4*5`, then we have the following steps: `[1], [2], [2, 3], [2,12], [2,60]`: each time we have `+` or `-` we add one element to the end of stack; each time we have `*` we update the last element in stack.\\n\\nThen when we traverse our string, we can have several options: each time we need to create `tmp = int(num[idx: i])` and make sure that this is valid number: `tmp` will be the next number we are going to use. Then if `last == None`, we have only one option. If `last != None`, we can have `3` options which symbol we can take: if it is `+` or `-`, we just update `value` and sign of `tmp`. If it is multiplication, we need to update both `value` and `last` should be multiplied by `tmp`.\\n\\n#### Complexity\\nIt is potentially `O(4^n * n)`, because on each step we have `4` options: `+`, `-`, `*` or no sign. Space complexity potentially the same.\\n\\n#### Code\\n```python\\nclass Solution:\\n    def addOperators(self, num, target):\\n        def dfs(idx, path, value, last):            \\n            if idx == n and value == target:\\n                ans.append(path)\\n            \\n            for i in range(idx + 1, n + 1):\\n                tmp = int(num[idx: i])\\n                if i == idx + 1 or (i > idx + 1 and num[idx] != \"0\"):\\n                    if last is None :\\n                        dfs(i, num[idx: i], tmp, tmp)\\n                    else:\\n                        dfs(i, path + \\'+\\' + num[idx: i], value + tmp, tmp)\\n                        dfs(i, path + \\'-\\' + num[idx: i], value - tmp, -tmp)\\n                        dfs(i, path + \\'*\\' + num[idx: i], value - last + last*tmp, last*tmp)\\n        \\n        ans, n = [], len(num)\\n        dfs(0, \"\", 0, None)\\n        return ans\\n```\\n\\nIf you have any questions, feel free to ask. If you like solution and explanations, please **Upvote!**",
                "solutionTags": [
                    "Stack"
                ],
                "code": "```python\\nclass Solution:\\n    def addOperators(self, num, target):\\n        def dfs(idx, path, value, last):            \\n            if idx == n and value == target:\\n                ans.append(path)\\n            \\n            for i in range(idx + 1, n + 1):\\n                tmp = int(num[idx: i])\\n                if i == idx + 1 or (i > idx + 1 and num[idx] != \"0\"):\\n                    if last is None :\\n                        dfs(i, num[idx: i], tmp, tmp)\\n                    else:\\n                        dfs(i, path + \\'+\\' + num[idx: i], value + tmp, tmp)\\n                        dfs(i, path + \\'-\\' + num[idx: i], value - tmp, -tmp)\\n                        dfs(i, path + \\'*\\' + num[idx: i], value - last + last*tmp, last*tmp)\\n        \\n        ans, n = [], len(num)\\n        dfs(0, \"\", 0, None)\\n        return ans\\n```",
                "codeTag": "Java"
            },
            {
                "id": 71921,
                "title": "java-simple-solution-beats-96-56",
                "content": "Inspired by [this great solution][1]. \\n\\nWhat's different is, I use backtracking with `StringBuilder` instead of directly String addition.\\n\\nThis increase speed by `20%`.\\n\\n    public List<String> addOperators(String num, int target) {\\n        List<String> res = new ArrayList<>();\\n       \\tStringBuilder sb = new StringBuilder();\\n        dfs(res, sb, num, 0, target, 0, 0);\\n        return res;\\n        \\n    }\\n    public void dfs(List<String> res, StringBuilder sb, String num, int pos, int target, long prev, long multi) { \\n    \\tif(pos == num.length()) {\\n    \\t\\tif(target == prev) res.add(sb.toString());\\n    \\t\\treturn;\\n    \\t}\\n    \\tfor(int i = pos; i < num.length(); i++) {\\n    \\t\\tif(num.charAt(pos) == '0' && i != pos) break;\\n    \\t\\tlong curr = Long.parseLong(num.substring(pos, i + 1));\\n    \\t\\tint len = sb.length();\\n    \\t\\tif(pos == 0) {\\n    \\t\\t\\tdfs(res, sb.append(curr), num, i + 1, target, curr, curr); \\n    \\t\\t\\tsb.setLength(len);\\n    \\t\\t} else {\\n    \\t\\t\\tdfs(res, sb.append(\"+\").append(curr), num, i + 1, target, prev + curr, curr); \\n    \\t\\t\\tsb.setLength(len);\\n    \\t\\t\\tdfs(res, sb.append(\"-\").append(curr), num, i + 1, target, prev - curr, -curr); \\n    \\t\\t\\tsb.setLength(len);\\n    \\t\\t\\tdfs(res, sb.append(\"*\").append(curr), num, i + 1, target, prev - multi + multi * curr, multi * curr); \\n    \\t\\t\\tsb.setLength(len);\\n    \\t\\t}\\n    \\t}\\n    }\\n\\n\\n  [1]: https://leetcode.com/discuss/58614/java-standard-backtrace-ac-solutoin-short-and-clear",
                "solutionTags": [
                    "Java"
                ],
                "code": "Inspired by [this great solution][1]. \\n\\nWhat's different is, I use backtracking with `StringBuilder` instead of directly String addition.\\n\\nThis increase speed by `20%`.\\n\\n    public List<String> addOperators(String num, int target) {\\n        List<String> res = new ArrayList<>();\\n       \\tStringBuilder sb = new StringBuilder();\\n        dfs(res, sb, num, 0, target, 0, 0);\\n        return res;\\n        \\n    }\\n    public void dfs(List<String> res, StringBuilder sb, String num, int pos, int target, long prev, long multi) { \\n    \\tif(pos == num.length()) {\\n    \\t\\tif(target == prev) res.add(sb.toString());\\n    \\t\\treturn;\\n    \\t}\\n    \\tfor(int i = pos; i < num.length(); i++) {\\n    \\t\\tif(num.charAt(pos) == '0' && i != pos) break;\\n    \\t\\tlong curr = Long.parseLong(num.substring(pos, i + 1));\\n    \\t\\tint len = sb.length();\\n    \\t\\tif(pos == 0) {\\n    \\t\\t\\tdfs(res, sb.append(curr), num, i + 1, target, curr, curr); \\n    \\t\\t\\tsb.setLength(len);\\n    \\t\\t} else {\\n    \\t\\t\\tdfs(res, sb.append(\"+\").append(curr), num, i + 1, target, prev + curr, curr); \\n    \\t\\t\\tsb.setLength(len);\\n    \\t\\t\\tdfs(res, sb.append(\"-\").append(curr), num, i + 1, target, prev - curr, -curr); \\n    \\t\\t\\tsb.setLength(len);\\n    \\t\\t\\tdfs(res, sb.append(\"*\").append(curr), num, i + 1, target, prev - multi + multi * curr, multi * curr); \\n    \\t\\t\\tsb.setLength(len);\\n    \\t\\t}\\n    \\t}\\n    }\\n\\n\\n  [1]: https://leetcode.com/discuss/58614/java-standard-backtrace-ac-solutoin-short-and-clear",
                "codeTag": "Unknown"
            },
            {
                "id": 352605,
                "title": "explanation-and-way-to-make-it-efficient-from-134-ms-to-9-ms-to-beat-100",
                "content": "A war against each other [ String con Vs string builder vs char [] ]\\n\\nWhole code is commented well to understand;\\n\\nAll version are same, its just the usage of String , String builder and char [] to build the expression is differ. \\n\\n\\nUsing strings connectinations \\n---------------------\\n<details>\\nRuntime: 134 ms, faster than 30.99% of Java online submissions for Expression Add Operators.\\nMemory Usage: 63.4 MB, less than 14.58% of Java online submissions for Expression Add Operators.\\n\\n```\\n\\n/**\\n * Explanation: https://leetcode.com/articles/expression-add-operators/\\n * <p>\\n * Our choices:\\n * 1. We can choose a single digits as operands Or multi digits as operand (  1 + 2 or 12 + 34 )\\n * 2. we can choose only one operator between two operands\\n * <p>\\n * Our Constraints:\\n * 1. We can\\'t take more numbers than given in input string ( index >= input.length)\\n * 2. We can\\'t take more operators then available in input\\n * 3. We can choose only one operator once\\n * 4. We need two operands for a operator and operator can\\'t be apply on single operand\\n * <p>\\n * Out Goal:\\n * 1. once we form a expression, if that expression evaluates to our \"target\" then this is our solution.\\n * 2. if not, we discard\\n * <p>\\n * <p>\\n * Runtime: 134 ms, faster than 30.99% of Java online submissions for Expression Add Operators.\\n * Memory Usage: 63.4 MB, less than 14.58% of Java online submissions for Expression Add Operators.\\n */\\nclass AddOperatorsBacktrackingString {\\n\\n\\n//    char ops[] = {\\'+\\', \\'-\\', \\'*\\'};\\n\\n    public List<String> addOperators(String num, int target) {\\n\\n        List<String> expressions = new ArrayList<>();\\n\\n        if (num == null || num.isEmpty())\\n            return expressions;\\n\\n\\n        addOperators(num, target, 0, 0, 0, \"\", expressions);\\n\\n        return expressions;\\n\\n\\n    }\\n\\n    /**\\n     * @param num\\n     * @param target\\n     * @param index\\n     * @param currentValue\\n     * @param lastValue\\n     * @param expression\\n     * @param result\\n     */\\n    private void addOperators(String num, int target, int index, long currentValue, long lastValue, String expression, List<String> result) {\\n\\n        /**\\n         * Our Constraints:\\n         * 1. We can\\'t take more numbers than given in input string ( index >= input.length)\\n         */\\n\\n        if (index == num.length()) {\\n\\n            /**\\n             * Out Goal:\\n             * 1. once we form a expression, if that expression evaluates to our \"target\" then this is our solution.\\n             */\\n\\n            if (currentValue == target) {\\n                //then this is our solution.\\n                result.add(expression);\\n\\n            } //2. if not, we discard\\n\\n\\n            return;\\n\\n        }\\n\\n        /**\\n         * Our choices:\\n         * 1. We can choose a single digits as operands Or multi digits as operand (  1 + 2 or 12 + 34 )\\n         */\\n        for (int i = index; i < num.length(); i++) {\\n\\n\\n            /**\\n             * We don\\'t consider a operand which is 0 as single digit operand, as operand like 0 or 01 , 023... does not make sense\\n             *  To avoid cases where we have 1 + 05 or 1 * 05 since 05 won\\'t be a\\n             */\\n            if (i != index && num.charAt(index) == \\'0\\')\\n                break;\\n\\n            long currentDigitsValue = Long.parseLong(num.substring(index, i + 1));\\n\\n\\n            /**\\n             * Our Constraints:\\n             * 4. We need two operands for a operator and operator can\\'t be apply on single operand\\n             */\\n\\n            if (index == 0) {\\n                // as this is the first digit only, then don\\'t apply any operator\\n\\n                addOperators(num, target, i + 1, currentDigitsValue, currentDigitsValue, expression + currentDigitsValue, result);\\n\\n            } else {\\n                //We have two operands, last and current\\n\\n                /**\\n                 * Plus operator application \\'+\\'; Current value become = so far value + current digit value and last value would be the current digit value\\n                 * current Value = 12\\n                 * last Value = 2 ( say we did like 10 + 2 )\\n                 * currentDigitvalue = 5 then expression is 10 + 2 + 5 = 17\\n                 * So last value would be 5\\n                 */\\n                addOperators(num, target, i + 1, currentValue + currentDigitsValue, currentDigitsValue, expression + \"+\" + currentDigitsValue, result);\\n\\n                /**\\n                 * Minus operator application \\'-\\'; Current value become = so far value - current digit value and last value would be the -current digit value\\n                 * current Value = 12\\n                 * last Value = 2 ( say we did like 10 + 2 )\\n                 * currentDigitvalue = 5 then expression is 10 + 2 - 5 = 7\\n                 * So last value would be -5\\n                 */\\n                addOperators(num, target, i + 1, currentValue - currentDigitsValue, -currentDigitsValue, expression + \"-\" + currentDigitsValue, result);\\n\\n\\n                /**\\n                 * Multiply operator application \\'*\\'; As this has the highest precedence then + and -, we simply can\\'t apply * on last and current value.\\n                 * Current value become = currentValue - lastValue + last*currentDigitvalue;\\n                 * For example\\n                 * current value = 12 ,\\n                 * last value = 2 ( let say we applied + as 10 + 2 )\\n                 * currendDigitValue = 4\\n                 * so expression become : 10 + 2 * 4\\n                 * if we simply do 12 * 4 = 24 which is wrong as 10 + 2 * 4 = 10 + 8 = 18\\n                 *\\n                 * New value = 10 + 2 * 4 = 18\\n                 * last value = 2*4 = 8\\n                 *\\n                 *\\n                 */\\n                addOperators(num, target, i + 1, currentValue - lastValue + lastValue * currentDigitsValue, lastValue * currentDigitsValue, expression + \"*\" + currentDigitsValue, result);\\n\\n\\n            }\\n\\n\\n        }\\n\\n\\n    }\\n\\n}\\n```\\n\\n\\n</details>\\n\\nUsing StringBuilder \\n---------------\\n<details>\\n\\nRuntime: 81 ms, faster than 83.65% of Java online submissions for Expression Add Operators.\\nMemory Usage: 57.9 MB, less than 53.12% of Java online submissions for Expression Add Operators.\\n\\n```\\n\\n\\n/**\\n * Instead of using String concatenation we\\'ll use strinbuilder\\n * Runtime: 81 ms, faster than 83.65% of Java online submissions for Expression Add Operators.\\n * Memory Usage: 57.9 MB, less than 53.12% of Java online submissions for Expression Add Operators.\\n * <p>\\n * StringBuilder boost it performance from 84ms to 81ms.\\n */\\nclass AddOperatorsBacktrackingStringBuilder {\\n\\n\\n    public List<String> addOperators(String num, int target) {\\n\\n        List<String> expressions = new ArrayList<>();\\n\\n        if (num == null || num.isEmpty())\\n            return expressions;\\n\\n\\n        addOperators(num, target, 0, 0, 0, new StringBuilder(), expressions);\\n\\n        return expressions;\\n\\n\\n    }\\n\\n    /**\\n     * @param num\\n     * @param target\\n     * @param index\\n     * @param currentValue\\n     * @param lastValue\\n     * @param expression\\n     * @param result\\n     */\\n    private void addOperators(String num, int target, int index, long currentValue, long lastValue, StringBuilder expression, List<String> result) {\\n\\n        /**\\n         * Our Constraints:\\n         * 1. We can\\'t take more numbers than given in input string ( index >= input.length)\\n         */\\n\\n        if (index == num.length()) {\\n\\n            /**\\n             * Out Goal:\\n             * 1. once we form a expression, if that expression evaluates to our \"target\" then this is our solution.\\n             */\\n\\n            if (currentValue == target) {\\n                //then this is our solution.\\n                result.add(expression.toString());\\n\\n            } //2. if not, we discard\\n\\n\\n            return;\\n\\n        }\\n\\n        /**\\n         * Our choices:\\n         * 1. We can choose a single digits as operands Or multi digits as operand (  1 + 2 or 12 + 34 )\\n         */\\n        for (int i = index; i < num.length(); i++) {\\n\\n\\n            /**\\n             * We don\\'t consider a operand which is 0 as single digit operand, as operand like 0 or 01 , 023... does not make sense\\n             *  To avoid cases where we have 1 + 05 or 1 * 05 since 05 won\\'t be a\\n             */\\n            if (i != index && num.charAt(index) == \\'0\\')\\n                break;\\n\\n            long currentDigitsValue = Long.parseLong(num.substring(index, i + 1));\\n            int len = expression.length();\\n\\n            /**\\n             * Our Constraints:\\n             * 4. We need two operands for a operator and operator can\\'t be apply on single operand\\n             */\\n\\n            if (index == 0) {\\n                // as this is the first digit only, then don\\'t apply any operator\\n\\n\\n                addOperators(num, target, i + 1, currentDigitsValue, currentDigitsValue, expression.append(currentDigitsValue), result);\\n                expression.setLength(len); // This will make sure that this expression won\\'t exceed otherwise we need to remove \"currentDigitsValue\" from this to backtrack.\\n\\n            } else {\\n                //We have two operands, last and current\\n\\n                /**\\n                 * Plus operator application \\'+\\'; Current value become = so far value + current digit value and last value would be the current digit value\\n                 * current Value = 12\\n                 * last Value = 2 ( say we did like 10 + 2 )\\n                 * currentDigitvalue = 5 then expression is 10 + 2 + 5 = 17\\n                 * So last value would be 5\\n                 */\\n                addOperators(num, target, i + 1, currentValue + currentDigitsValue, currentDigitsValue, expression.append(\"+\").append(currentDigitsValue), result);\\n                expression.setLength(len);// This will make sure that this expression won\\'t exceed otherwise we need to remove \"currentDigitsValue\" from this to backtrack.\\n\\n                /**\\n                 * Minus operator application \\'-\\'; Current value become = so far value - current digit value and last value would be the -current digit value\\n                 * current Value = 12\\n                 * last Value = 2 ( say we did like 10 + 2 )\\n                 * currentDigitvalue = 5 then expression is 10 + 2 - 5 = 7\\n                 * So last value would be -5\\n                 */\\n                addOperators(num, target, i + 1, currentValue - currentDigitsValue, -currentDigitsValue, expression.append(\"-\").append(currentDigitsValue), result);\\n                expression.setLength(len);// This will make sure that this expression won\\'t exceed otherwise we need to remove \"currentDigitsValue\" from this to backtrack.\\n\\n                /**\\n                 * Multiply operator application \\'*\\'; As this has the highest precedence then + and -, we simply can\\'t apply * on last and current value.\\n                 * Current value become = currentValue - lastValue + last*currentDigitvalue;\\n                 * For example\\n                 * current value = 12 ,\\n                 * last value = 2 ( let say we applied + as 10 + 2 )\\n                 * currendDigitValue = 4\\n                 * so expression become : 10 + 2 * 4\\n                 * if we simply do 12 * 4 = 24 which is wrong as 10 + 2 * 4 = 10 + 8 = 18\\n                 *\\n                 * New value = 10 + 2 * 4 = 18\\n                 * last value = 2*4 = 8\\n                 *\\n                 *\\n                 */\\n                addOperators(num, target, i + 1, currentValue - lastValue + lastValue * currentDigitsValue, lastValue * currentDigitsValue, expression.append(\"*\").append(currentDigitsValue), result);\\n                expression.setLength(len);// This will make sure that this expression won\\'t exceed otherwise we need to remove \"currentDigitsValue\" from this to backtrack.\\n\\n            }\\n\\n\\n        }\\n\\n\\n    }\\n\\n}\\n```\\n\\n</details>\\n\\n\\nUsing Char [] Array\\n-------------\\n<details>\\nRuntime: 11 ms, faster than 96.45% of Java online submissions for Expression Add Operators.\\nMemory Usage: 39.4 MB, less than 95.83% of Java online submissions for Expression Add Operators.\\n\\n```\\n\\n/**\\n * Instead of using String concatenation Or strinbuilder, we\\'ll use char array\\n * Runtime: 11 ms, faster than 96.45% of Java online submissions for Expression Add Operators.\\n * Memory Usage: 39.4 MB, less than 95.83% of Java online submissions for Expression Add Operators.\\n */\\nclass AddOperatorsBacktrackingCharArray {\\n\\n\\n    public List<String> addOperators(String num, int target) {\\n\\n        List<String> expressions = new ArrayList<>();\\n\\n        if (num == null || num.isEmpty())\\n            return expressions;\\n\\n        char cache[] = new char[2 * num.length()];\\n\\n        addOperators(num, target, 0, 0, 0, cache, 0, expressions);\\n\\n        return expressions;\\n\\n\\n    }\\n\\n    /**\\n     * @param num\\n     * @param target\\n     * @param index\\n     * @param currentValue\\n     * @param lastValue\\n     * @param expression\\n     * @param result\\n     */\\n    private void addOperators(String num, int target, int index, long currentValue, long lastValue, char[] expression, int expressionEndIndex, List<String> result) {\\n\\n        /**\\n         * Our Constraints:\\n         * 1. We can\\'t take more numbers than given in input string ( index >= input.length)\\n         */\\n\\n        if (index == num.length()) {\\n\\n            /**\\n             * Out Goal:\\n             * 1. once we form a expression, if that expression evaluates to our \"target\" then this is our solution.\\n             */\\n\\n            if (currentValue == target) {\\n                //then this is our solution.\\n                result.add(new String(expression, 0, expressionEndIndex));\\n\\n            } //2. if not, we discard\\n\\n\\n            return;\\n\\n        }\\n\\n        /**\\n         * Find new cache length;\\n         * the corner case, where we have no data in cache, in this case we need to push at first index (0) otherwise at the next index\\n         *\\n         */\\n        int nextExpressionEndIndex = (index == 0) ? expressionEndIndex : expressionEndIndex + 1;\\n\\n        long currentDigitsValue = 0;\\n        /**\\n         * Our choices:\\n         * 1. We can choose a single digits as operands Or multi digits as operand (  1 + 2 or 12 + 34 )\\n         */\\n        for (int i = index; i < num.length(); i++) {\\n\\n\\n            /**\\n             * We don\\'t consider a operand which is 0 as single digit operand, as operand like 0 or 01 , 023... does not make sense\\n             *  To avoid cases where we have 1 + 05 or 1 * 05 since 05 won\\'t be a\\n             */\\n            if (i != index && num.charAt(index) == \\'0\\')\\n                break;\\n\\n            currentDigitsValue = currentDigitsValue * 10 + num.charAt(i) - \\'0\\';\\n\\n\\n            /**\\n             * Our Constraints:\\n             * 4. We need two operands for a operator and operator can\\'t be apply on single operand\\n             */\\n\\n            if (index == 0) {\\n                // as this is the first digit only, then don\\'t apply any operator\\n                //Append\\n                expression[nextExpressionEndIndex++] = num.charAt(i);\\n\\n\\n                addOperators(num, target, i + 1, currentDigitsValue, currentDigitsValue, expression, nextExpressionEndIndex, result);\\n\\n            } else {\\n                //We have two operands, last and current\\n                //Append\\n                expression[nextExpressionEndIndex++] = num.charAt(i);\\n\\n                /**\\n                 * Plus operator application \\'+\\'; Current value become = so far value + current digit value and last value would be the current digit value\\n                 * current Value = 12\\n                 * last Value = 2 ( say we did like 10 + 2 )\\n                 * currentDigitvalue = 5 then expression is 10 + 2 + 5 = 17\\n                 * So last value would be 5\\n                 */\\n                expression[expressionEndIndex] = \\'+\\';\\n                addOperators(num, target, i + 1, currentValue + currentDigitsValue, currentDigitsValue, expression, nextExpressionEndIndex, result);\\n\\n                /**\\n                 * Minus operator application \\'-\\'; Current value become = so far value - current digit value and last value would be the -current digit value\\n                 * current Value = 12\\n                 * last Value = 2 ( say we did like 10 + 2 )\\n                 * currentDigitvalue = 5 then expression is 10 + 2 - 5 = 7\\n                 * So last value would be -5\\n                 */\\n                expression[expressionEndIndex] = \\'-\\';\\n                addOperators(num, target, i + 1, currentValue - currentDigitsValue, -currentDigitsValue, expression, nextExpressionEndIndex, result);\\n\\n                /**\\n                 * Multiply operator application \\'*\\'; As this has the highest precedence then + and -, we simply can\\'t apply * on last and current value.\\n                 * Current value become = currentValue - lastValue + last*currentDigitvalue;\\n                 * For example\\n                 * current value = 12 ,\\n                 * last value = 2 ( let say we applied + as 10 + 2 )\\n                 * currendDigitValue = 4\\n                 * so expression become : 10 + 2 * 4\\n                 * if we simply do 12 * 4 = 24 which is wrong as 10 + 2 * 4 = 10 + 8 = 18\\n                 *\\n                 * New value = 10 + 2 * 4 = 18\\n                 * last value = 2*4 = 8\\n                 *\\n                 *\\n                 */\\n                expression[expressionEndIndex] = \\'*\\';\\n                addOperators(num, target, i + 1, currentValue - lastValue + lastValue * currentDigitsValue, lastValue * currentDigitsValue, expression, nextExpressionEndIndex, result);\\n\\n            }\\n\\n\\n        }\\n\\n\\n    }\\n\\n}\\n```\\n\\n</details>\\n\\nUsing Char [] for both input and intermiddate expression\\n------------------------------------\\n\\n<details>\\n Runtime: **9 ms, faster than 99.28%** of Java online submissions for Expression Add Operators.\\n Memory Usage: 39.5 MB, less than 94.79% of Java online submissions for Expression Add Operators.\\n \\n ```\\n \\n\\n    public List<String> addOperators(String num, int target) {\\n\\n        List<String> expressions = new ArrayList<>();\\n\\n        if (num == null || num.isEmpty())\\n            return expressions;\\n\\n        char cache[] = new char[2 * num.length()];\\n\\n        addOperators(num.toCharArray(), target, 0, 0, 0, cache, 0, expressions);\\n\\n        return expressions;\\n\\n\\n    }\\n\\n    /**\\n     * @param num\\n     * @param target\\n     * @param index\\n     * @param currentValue\\n     * @param lastValue\\n     * @param expression\\n     * @param result\\n     */\\n    private void addOperators(char num[], int target, int index, long currentValue, long lastValue, char[] expression, int expressionEndIndex, List<String> result) {\\n\\n        /**\\n         * Our Constraints:\\n         * 1. We can\\'t take more numbers than given in input string ( index >= input.length)\\n         */\\n\\n        if (index == num.length) {\\n\\n            /**\\n             * Out Goal:\\n             * 1. once we form a expression, if that expression evaluates to our \"target\" then this is our solution.\\n             */\\n\\n            if (currentValue == target) {\\n                //then this is our solution.\\n                result.add(new String(expression, 0, expressionEndIndex));\\n\\n            } //2. if not, we discard\\n\\n\\n            return;\\n\\n        }\\n\\n        /**\\n         * Find new cache length;\\n         * the corner case, where we have no data in cache, in this case we need to push at first index (0) otherwise at the next index\\n         *\\n         */\\n        int nextExpressionEndIndex = (index == 0) ? expressionEndIndex : expressionEndIndex + 1;\\n\\n        long currentDigitsValue = 0;\\n        /**\\n         * Our choices:\\n         * 1. We can choose a single digits as operands Or multi digits as operand (  1 + 2 or 12 + 34 )\\n         */\\n        for (int i = index; i < num.length; i++) {\\n\\n\\n            /**\\n             * We don\\'t consider a operand which is 0 as single digit operand, as operand like 0 or 01 , 023... does not make sense\\n             *  To avoid cases where we have 1 + 05 or 1 * 05 since 05 won\\'t be a\\n             */\\n            if (i != index && num[index] == \\'0\\')\\n                break;\\n\\n            currentDigitsValue = currentDigitsValue * 10 + num[i] - \\'0\\';\\n\\n\\n            /**\\n             * Our Constraints:\\n             * 4. We need two operands for a operator and operator can\\'t be apply on single operand\\n             */\\n\\n            if (index == 0) {\\n                // as this is the first digit only, then don\\'t apply any operator\\n                //Append\\n                expression[nextExpressionEndIndex++] = num[i];\\n\\n\\n                addOperators(num, target, i + 1, currentDigitsValue, currentDigitsValue, expression, nextExpressionEndIndex, result);\\n\\n            } else {\\n                //We have two operands, last and current\\n                //Append\\n                expression[nextExpressionEndIndex++] = num[i];\\n\\n                /**\\n                 * Plus operator application \\'+\\'; Current value become = so far value + current digit value and last value would be the current digit value\\n                 * current Value = 12\\n                 * last Value = 2 ( say we did like 10 + 2 )\\n                 * currentDigitvalue = 5 then expression is 10 + 2 + 5 = 17\\n                 * So last value would be 5\\n                 */\\n                expression[expressionEndIndex] = \\'+\\';\\n                addOperators(num, target, i + 1, currentValue + currentDigitsValue, currentDigitsValue, expression, nextExpressionEndIndex, result);\\n\\n                /**\\n                 * Minus operator application \\'-\\'; Current value become = so far value - current digit value and last value would be the -current digit value\\n                 * current Value = 12\\n                 * last Value = 2 ( say we did like 10 + 2 )\\n                 * currentDigitvalue = 5 then expression is 10 + 2 - 5 = 7\\n                 * So last value would be -5\\n                 */\\n                expression[expressionEndIndex] = \\'-\\';\\n                addOperators(num, target, i + 1, currentValue - currentDigitsValue, -currentDigitsValue, expression, nextExpressionEndIndex, result);\\n\\n                /**\\n                 * Multiply operator application \\'*\\'; As this has the highest precedence then + and -, we simply can\\'t apply * on last and current value.\\n                 * Current value become = currentValue - lastValue + last*currentDigitvalue;\\n                 * For example\\n                 * current value = 12 ,\\n                 * last value = 2 ( let say we applied + as 10 + 2 )\\n                 * currendDigitValue = 4\\n                 * so expression become : 10 + 2 * 4\\n                 * if we simply do 12 * 4 = 24 which is wrong as 10 + 2 * 4 = 10 + 8 = 18\\n                 *\\n                 * New value = 10 + 2 * 4 = 18\\n                 * last value = 2*4 = 8\\n                 *\\n                 *\\n                 */\\n                expression[expressionEndIndex] = \\'*\\';\\n                addOperators(num, target, i + 1, currentValue - lastValue + lastValue * currentDigitsValue, lastValue * currentDigitsValue, expression, nextExpressionEndIndex, result);\\n\\n            }\\n\\n\\n        }\\n\\n\\n    }\\n ```\\n\\n\\n<details>",
                "solutionTags": [],
                "code": "```\\n\\n/**\\n * Explanation: https://leetcode.com/articles/expression-add-operators/\\n * <p>\\n * Our choices:\\n * 1. We can choose a single digits as operands Or multi digits as operand (  1 + 2 or 12 + 34 )\\n * 2. we can choose only one operator between two operands\\n * <p>\\n * Our Constraints:\\n * 1. We can\\'t take more numbers than given in input string ( index >= input.length)\\n * 2. We can\\'t take more operators then available in input\\n * 3. We can choose only one operator once\\n * 4. We need two operands for a operator and operator can\\'t be apply on single operand\\n * <p>\\n * Out Goal:\\n * 1. once we form a expression, if that expression evaluates to our \"target\" then this is our solution.\\n * 2. if not, we discard\\n * <p>\\n * <p>\\n * Runtime: 134 ms, faster than 30.99% of Java online submissions for Expression Add Operators.\\n * Memory Usage: 63.4 MB, less than 14.58% of Java online submissions for Expression Add Operators.\\n */\\nclass AddOperatorsBacktrackingString {\\n\\n\\n//    char ops[] = {\\'+\\', \\'-\\', \\'*\\'};\\n\\n    public List<String> addOperators(String num, int target) {\\n\\n        List<String> expressions = new ArrayList<>();\\n\\n        if (num == null || num.isEmpty())\\n            return expressions;\\n\\n\\n        addOperators(num, target, 0, 0, 0, \"\", expressions);\\n\\n        return expressions;\\n\\n\\n    }\\n\\n    /**\\n     * @param num\\n     * @param target\\n     * @param index\\n     * @param currentValue\\n     * @param lastValue\\n     * @param expression\\n     * @param result\\n     */\\n    private void addOperators(String num, int target, int index, long currentValue, long lastValue, String expression, List<String> result) {\\n\\n        /**\\n         * Our Constraints:\\n         * 1. We can\\'t take more numbers than given in input string ( index >= input.length)\\n         */\\n\\n        if (index == num.length()) {\\n\\n            /**\\n             * Out Goal:\\n             * 1. once we form a expression, if that expression evaluates to our \"target\" then this is our solution.\\n             */\\n\\n            if (currentValue == target) {\\n                //then this is our solution.\\n                result.add(expression);\\n\\n            } //2. if not, we discard\\n\\n\\n            return;\\n\\n        }\\n\\n        /**\\n         * Our choices:\\n         * 1. We can choose a single digits as operands Or multi digits as operand (  1 + 2 or 12 + 34 )\\n         */\\n        for (int i = index; i < num.length(); i++) {\\n\\n\\n            /**\\n             * We don\\'t consider a operand which is 0 as single digit operand, as operand like 0 or 01 , 023... does not make sense\\n             *  To avoid cases where we have 1 + 05 or 1 * 05 since 05 won\\'t be a\\n             */\\n            if (i != index && num.charAt(index) == \\'0\\')\\n                break;\\n\\n            long currentDigitsValue = Long.parseLong(num.substring(index, i + 1));\\n\\n\\n            /**\\n             * Our Constraints:\\n             * 4. We need two operands for a operator and operator can\\'t be apply on single operand\\n             */\\n\\n            if (index == 0) {\\n                // as this is the first digit only, then don\\'t apply any operator\\n\\n                addOperators(num, target, i + 1, currentDigitsValue, currentDigitsValue, expression + currentDigitsValue, result);\\n\\n            } else {\\n                //We have two operands, last and current\\n\\n                /**\\n                 * Plus operator application \\'+\\'; Current value become = so far value + current digit value and last value would be the current digit value\\n                 * current Value = 12\\n                 * last Value = 2 ( say we did like 10 + 2 )\\n                 * currentDigitvalue = 5 then expression is 10 + 2 + 5 = 17\\n                 * So last value would be 5\\n                 */\\n                addOperators(num, target, i + 1, currentValue + currentDigitsValue, currentDigitsValue, expression + \"+\" + currentDigitsValue, result);\\n\\n                /**\\n                 * Minus operator application \\'-\\'; Current value become = so far value - current digit value and last value would be the -current digit value\\n                 * current Value = 12\\n                 * last Value = 2 ( say we did like 10 + 2 )\\n                 * currentDigitvalue = 5 then expression is 10 + 2 - 5 = 7\\n                 * So last value would be -5\\n                 */\\n                addOperators(num, target, i + 1, currentValue - currentDigitsValue, -currentDigitsValue, expression + \"-\" + currentDigitsValue, result);\\n\\n\\n                /**\\n                 * Multiply operator application \\'*\\'; As this has the highest precedence then + and -, we simply can\\'t apply * on last and current value.\\n                 * Current value become = currentValue - lastValue + last*currentDigitvalue;\\n                 * For example\\n                 * current value = 12 ,\\n                 * last value = 2 ( let say we applied + as 10 + 2 )\\n                 * currendDigitValue = 4\\n                 * so expression become : 10 + 2 * 4\\n                 * if we simply do 12 * 4 = 24 which is wrong as 10 + 2 * 4 = 10 + 8 = 18\\n                 *\\n                 * New value = 10 + 2 * 4 = 18\\n                 * last value = 2*4 = 8\\n                 *\\n                 *\\n                 */\\n                addOperators(num, target, i + 1, currentValue - lastValue + lastValue * currentDigitsValue, lastValue * currentDigitsValue, expression + \"*\" + currentDigitsValue, result);\\n\\n\\n            }\\n\\n\\n        }\\n\\n\\n    }\\n\\n}\\n```\n```\\n\\n\\n/**\\n * Instead of using String concatenation we\\'ll use strinbuilder\\n * Runtime: 81 ms, faster than 83.65% of Java online submissions for Expression Add Operators.\\n * Memory Usage: 57.9 MB, less than 53.12% of Java online submissions for Expression Add Operators.\\n * <p>\\n * StringBuilder boost it performance from 84ms to 81ms.\\n */\\nclass AddOperatorsBacktrackingStringBuilder {\\n\\n\\n    public List<String> addOperators(String num, int target) {\\n\\n        List<String> expressions = new ArrayList<>();\\n\\n        if (num == null || num.isEmpty())\\n            return expressions;\\n\\n\\n        addOperators(num, target, 0, 0, 0, new StringBuilder(), expressions);\\n\\n        return expressions;\\n\\n\\n    }\\n\\n    /**\\n     * @param num\\n     * @param target\\n     * @param index\\n     * @param currentValue\\n     * @param lastValue\\n     * @param expression\\n     * @param result\\n     */\\n    private void addOperators(String num, int target, int index, long currentValue, long lastValue, StringBuilder expression, List<String> result) {\\n\\n        /**\\n         * Our Constraints:\\n         * 1. We can\\'t take more numbers than given in input string ( index >= input.length)\\n         */\\n\\n        if (index == num.length()) {\\n\\n            /**\\n             * Out Goal:\\n             * 1. once we form a expression, if that expression evaluates to our \"target\" then this is our solution.\\n             */\\n\\n            if (currentValue == target) {\\n                //then this is our solution.\\n                result.add(expression.toString());\\n\\n            } //2. if not, we discard\\n\\n\\n            return;\\n\\n        }\\n\\n        /**\\n         * Our choices:\\n         * 1. We can choose a single digits as operands Or multi digits as operand (  1 + 2 or 12 + 34 )\\n         */\\n        for (int i = index; i < num.length(); i++) {\\n\\n\\n            /**\\n             * We don\\'t consider a operand which is 0 as single digit operand, as operand like 0 or 01 , 023... does not make sense\\n             *  To avoid cases where we have 1 + 05 or 1 * 05 since 05 won\\'t be a\\n             */\\n            if (i != index && num.charAt(index) == \\'0\\')\\n                break;\\n\\n            long currentDigitsValue = Long.parseLong(num.substring(index, i + 1));\\n            int len = expression.length();\\n\\n            /**\\n             * Our Constraints:\\n             * 4. We need two operands for a operator and operator can\\'t be apply on single operand\\n             */\\n\\n            if (index == 0) {\\n                // as this is the first digit only, then don\\'t apply any operator\\n\\n\\n                addOperators(num, target, i + 1, currentDigitsValue, currentDigitsValue, expression.append(currentDigitsValue), result);\\n                expression.setLength(len); // This will make sure that this expression won\\'t exceed otherwise we need to remove \"currentDigitsValue\" from this to backtrack.\\n\\n            } else {\\n                //We have two operands, last and current\\n\\n                /**\\n                 * Plus operator application \\'+\\'; Current value become = so far value + current digit value and last value would be the current digit value\\n                 * current Value = 12\\n                 * last Value = 2 ( say we did like 10 + 2 )\\n                 * currentDigitvalue = 5 then expression is 10 + 2 + 5 = 17\\n                 * So last value would be 5\\n                 */\\n                addOperators(num, target, i + 1, currentValue + currentDigitsValue, currentDigitsValue, expression.append(\"+\").append(currentDigitsValue), result);\\n                expression.setLength(len);// This will make sure that this expression won\\'t exceed otherwise we need to remove \"currentDigitsValue\" from this to backtrack.\\n\\n                /**\\n                 * Minus operator application \\'-\\'; Current value become = so far value - current digit value and last value would be the -current digit value\\n                 * current Value = 12\\n                 * last Value = 2 ( say we did like 10 + 2 )\\n                 * currentDigitvalue = 5 then expression is 10 + 2 - 5 = 7\\n                 * So last value would be -5\\n                 */\\n                addOperators(num, target, i + 1, currentValue - currentDigitsValue, -currentDigitsValue, expression.append(\"-\").append(currentDigitsValue), result);\\n                expression.setLength(len);// This will make sure that this expression won\\'t exceed otherwise we need to remove \"currentDigitsValue\" from this to backtrack.\\n\\n                /**\\n                 * Multiply operator application \\'*\\'; As this has the highest precedence then + and -, we simply can\\'t apply * on last and current value.\\n                 * Current value become = currentValue - lastValue + last*currentDigitvalue;\\n                 * For example\\n                 * current value = 12 ,\\n                 * last value = 2 ( let say we applied + as 10 + 2 )\\n                 * currendDigitValue = 4\\n                 * so expression become : 10 + 2 * 4\\n                 * if we simply do 12 * 4 = 24 which is wrong as 10 + 2 * 4 = 10 + 8 = 18\\n                 *\\n                 * New value = 10 + 2 * 4 = 18\\n                 * last value = 2*4 = 8\\n                 *\\n                 *\\n                 */\\n                addOperators(num, target, i + 1, currentValue - lastValue + lastValue * currentDigitsValue, lastValue * currentDigitsValue, expression.append(\"*\").append(currentDigitsValue), result);\\n                expression.setLength(len);// This will make sure that this expression won\\'t exceed otherwise we need to remove \"currentDigitsValue\" from this to backtrack.\\n\\n            }\\n\\n\\n        }\\n\\n\\n    }\\n\\n}\\n```\n```\\n\\n/**\\n * Instead of using String concatenation Or strinbuilder, we\\'ll use char array\\n * Runtime: 11 ms, faster than 96.45% of Java online submissions for Expression Add Operators.\\n * Memory Usage: 39.4 MB, less than 95.83% of Java online submissions for Expression Add Operators.\\n */\\nclass AddOperatorsBacktrackingCharArray {\\n\\n\\n    public List<String> addOperators(String num, int target) {\\n\\n        List<String> expressions = new ArrayList<>();\\n\\n        if (num == null || num.isEmpty())\\n            return expressions;\\n\\n        char cache[] = new char[2 * num.length()];\\n\\n        addOperators(num, target, 0, 0, 0, cache, 0, expressions);\\n\\n        return expressions;\\n\\n\\n    }\\n\\n    /**\\n     * @param num\\n     * @param target\\n     * @param index\\n     * @param currentValue\\n     * @param lastValue\\n     * @param expression\\n     * @param result\\n     */\\n    private void addOperators(String num, int target, int index, long currentValue, long lastValue, char[] expression, int expressionEndIndex, List<String> result) {\\n\\n        /**\\n         * Our Constraints:\\n         * 1. We can\\'t take more numbers than given in input string ( index >= input.length)\\n         */\\n\\n        if (index == num.length()) {\\n\\n            /**\\n             * Out Goal:\\n             * 1. once we form a expression, if that expression evaluates to our \"target\" then this is our solution.\\n             */\\n\\n            if (currentValue == target) {\\n                //then this is our solution.\\n                result.add(new String(expression, 0, expressionEndIndex));\\n\\n            } //2. if not, we discard\\n\\n\\n            return;\\n\\n        }\\n\\n        /**\\n         * Find new cache length;\\n         * the corner case, where we have no data in cache, in this case we need to push at first index (0) otherwise at the next index\\n         *\\n         */\\n        int nextExpressionEndIndex = (index == 0) ? expressionEndIndex : expressionEndIndex + 1;\\n\\n        long currentDigitsValue = 0;\\n        /**\\n         * Our choices:\\n         * 1. We can choose a single digits as operands Or multi digits as operand (  1 + 2 or 12 + 34 )\\n         */\\n        for (int i = index; i < num.length(); i++) {\\n\\n\\n            /**\\n             * We don\\'t consider a operand which is 0 as single digit operand, as operand like 0 or 01 , 023... does not make sense\\n             *  To avoid cases where we have 1 + 05 or 1 * 05 since 05 won\\'t be a\\n             */\\n            if (i != index && num.charAt(index) == \\'0\\')\\n                break;\\n\\n            currentDigitsValue = currentDigitsValue * 10 + num.charAt(i) - \\'0\\';\\n\\n\\n            /**\\n             * Our Constraints:\\n             * 4. We need two operands for a operator and operator can\\'t be apply on single operand\\n             */\\n\\n            if (index == 0) {\\n                // as this is the first digit only, then don\\'t apply any operator\\n                //Append\\n                expression[nextExpressionEndIndex++] = num.charAt(i);\\n\\n\\n                addOperators(num, target, i + 1, currentDigitsValue, currentDigitsValue, expression, nextExpressionEndIndex, result);\\n\\n            } else {\\n                //We have two operands, last and current\\n                //Append\\n                expression[nextExpressionEndIndex++] = num.charAt(i);\\n\\n                /**\\n                 * Plus operator application \\'+\\'; Current value become = so far value + current digit value and last value would be the current digit value\\n                 * current Value = 12\\n                 * last Value = 2 ( say we did like 10 + 2 )\\n                 * currentDigitvalue = 5 then expression is 10 + 2 + 5 = 17\\n                 * So last value would be 5\\n                 */\\n                expression[expressionEndIndex] = \\'+\\';\\n                addOperators(num, target, i + 1, currentValue + currentDigitsValue, currentDigitsValue, expression, nextExpressionEndIndex, result);\\n\\n                /**\\n                 * Minus operator application \\'-\\'; Current value become = so far value - current digit value and last value would be the -current digit value\\n                 * current Value = 12\\n                 * last Value = 2 ( say we did like 10 + 2 )\\n                 * currentDigitvalue = 5 then expression is 10 + 2 - 5 = 7\\n                 * So last value would be -5\\n                 */\\n                expression[expressionEndIndex] = \\'-\\';\\n                addOperators(num, target, i + 1, currentValue - currentDigitsValue, -currentDigitsValue, expression, nextExpressionEndIndex, result);\\n\\n                /**\\n                 * Multiply operator application \\'*\\'; As this has the highest precedence then + and -, we simply can\\'t apply * on last and current value.\\n                 * Current value become = currentValue - lastValue + last*currentDigitvalue;\\n                 * For example\\n                 * current value = 12 ,\\n                 * last value = 2 ( let say we applied + as 10 + 2 )\\n                 * currendDigitValue = 4\\n                 * so expression become : 10 + 2 * 4\\n                 * if we simply do 12 * 4 = 24 which is wrong as 10 + 2 * 4 = 10 + 8 = 18\\n                 *\\n                 * New value = 10 + 2 * 4 = 18\\n                 * last value = 2*4 = 8\\n                 *\\n                 *\\n                 */\\n                expression[expressionEndIndex] = \\'*\\';\\n                addOperators(num, target, i + 1, currentValue - lastValue + lastValue * currentDigitsValue, lastValue * currentDigitsValue, expression, nextExpressionEndIndex, result);\\n\\n            }\\n\\n\\n        }\\n\\n\\n    }\\n\\n}\\n```\n```\\n \\n\\n    public List<String> addOperators(String num, int target) {\\n\\n        List<String> expressions = new ArrayList<>();\\n\\n        if (num == null || num.isEmpty())\\n            return expressions;\\n\\n        char cache[] = new char[2 * num.length()];\\n\\n        addOperators(num.toCharArray(), target, 0, 0, 0, cache, 0, expressions);\\n\\n        return expressions;\\n\\n\\n    }\\n\\n    /**\\n     * @param num\\n     * @param target\\n     * @param index\\n     * @param currentValue\\n     * @param lastValue\\n     * @param expression\\n     * @param result\\n     */\\n    private void addOperators(char num[], int target, int index, long currentValue, long lastValue, char[] expression, int expressionEndIndex, List<String> result) {\\n\\n        /**\\n         * Our Constraints:\\n         * 1. We can\\'t take more numbers than given in input string ( index >= input.length)\\n         */\\n\\n        if (index == num.length) {\\n\\n            /**\\n             * Out Goal:\\n             * 1. once we form a expression, if that expression evaluates to our \"target\" then this is our solution.\\n             */\\n\\n            if (currentValue == target) {\\n                //then this is our solution.\\n                result.add(new String(expression, 0, expressionEndIndex));\\n\\n            } //2. if not, we discard\\n\\n\\n            return;\\n\\n        }\\n\\n        /**\\n         * Find new cache length;\\n         * the corner case, where we have no data in cache, in this case we need to push at first index (0) otherwise at the next index\\n         *\\n         */\\n        int nextExpressionEndIndex = (index == 0) ? expressionEndIndex : expressionEndIndex + 1;\\n\\n        long currentDigitsValue = 0;\\n        /**\\n         * Our choices:\\n         * 1. We can choose a single digits as operands Or multi digits as operand (  1 + 2 or 12 + 34 )\\n         */\\n        for (int i = index; i < num.length; i++) {\\n\\n\\n            /**\\n             * We don\\'t consider a operand which is 0 as single digit operand, as operand like 0 or 01 , 023... does not make sense\\n             *  To avoid cases where we have 1 + 05 or 1 * 05 since 05 won\\'t be a\\n             */\\n            if (i != index && num[index] == \\'0\\')\\n                break;\\n\\n            currentDigitsValue = currentDigitsValue * 10 + num[i] - \\'0\\';\\n\\n\\n            /**\\n             * Our Constraints:\\n             * 4. We need two operands for a operator and operator can\\'t be apply on single operand\\n             */\\n\\n            if (index == 0) {\\n                // as this is the first digit only, then don\\'t apply any operator\\n                //Append\\n                expression[nextExpressionEndIndex++] = num[i];\\n\\n\\n                addOperators(num, target, i + 1, currentDigitsValue, currentDigitsValue, expression, nextExpressionEndIndex, result);\\n\\n            } else {\\n                //We have two operands, last and current\\n                //Append\\n                expression[nextExpressionEndIndex++] = num[i];\\n\\n                /**\\n                 * Plus operator application \\'+\\'; Current value become = so far value + current digit value and last value would be the current digit value\\n                 * current Value = 12\\n                 * last Value = 2 ( say we did like 10 + 2 )\\n                 * currentDigitvalue = 5 then expression is 10 + 2 + 5 = 17\\n                 * So last value would be 5\\n                 */\\n                expression[expressionEndIndex] = \\'+\\';\\n                addOperators(num, target, i + 1, currentValue + currentDigitsValue, currentDigitsValue, expression, nextExpressionEndIndex, result);\\n\\n                /**\\n                 * Minus operator application \\'-\\'; Current value become = so far value - current digit value and last value would be the -current digit value\\n                 * current Value = 12\\n                 * last Value = 2 ( say we did like 10 + 2 )\\n                 * currentDigitvalue = 5 then expression is 10 + 2 - 5 = 7\\n                 * So last value would be -5\\n                 */\\n                expression[expressionEndIndex] = \\'-\\';\\n                addOperators(num, target, i + 1, currentValue - currentDigitsValue, -currentDigitsValue, expression, nextExpressionEndIndex, result);\\n\\n                /**\\n                 * Multiply operator application \\'*\\'; As this has the highest precedence then + and -, we simply can\\'t apply * on last and current value.\\n                 * Current value become = currentValue - lastValue + last*currentDigitvalue;\\n                 * For example\\n                 * current value = 12 ,\\n                 * last value = 2 ( let say we applied + as 10 + 2 )\\n                 * currendDigitValue = 4\\n                 * so expression become : 10 + 2 * 4\\n                 * if we simply do 12 * 4 = 24 which is wrong as 10 + 2 * 4 = 10 + 8 = 18\\n                 *\\n                 * New value = 10 + 2 * 4 = 18\\n                 * last value = 2*4 = 8\\n                 *\\n                 *\\n                 */\\n                expression[expressionEndIndex] = \\'*\\';\\n                addOperators(num, target, i + 1, currentValue - lastValue + lastValue * currentDigitsValue, lastValue * currentDigitsValue, expression, nextExpressionEndIndex, result);\\n\\n            }\\n\\n\\n        }\\n\\n\\n    }\\n ```",
                "codeTag": "Java"
            },
            {
                "id": 71971,
                "title": "accepted-c-solution",
                "content": "    void addOperators(vector<string>& result, string nums, string t, long long last, long long curVal, int target) {\\n\\t\\tif (nums.length() == 0) {\\n\\t\\t\\tif (curVal == target)\\n\\t\\t\\t\\tresult.push_back(t);\\n\\t\\t\\treturn;\\n\\t\\t}\\n\\n\\t\\tfor (int i = 1; i<=nums.length(); i++) {\\n\\t\\t\\tstring num = nums.substr(0, i);\\n\\t\\t\\tif(num.length() > 1 && num[0] == '0')\\n\\t\\t\\t    return;\\n\\t\\t\\t\\n\\t\\t\\tstring nextNum = nums.substr(i);\\n\\n\\t\\t\\tif (t.length() > 0) {\\n\\t\\t\\t\\taddOperators(result, nextNum, t + \"+\" + num, stoll(num), curVal + stoll(num), target);\\n\\t\\t\\t\\taddOperators(result, nextNum, t + \"-\" + num, -stoll(num), curVal - stoll(num), target);\\n\\t\\t\\t\\taddOperators(result, nextNum, t + \"*\" + num, last * stoll(num), (curVal - last) + (last * stoll(num)), target);\\n\\t\\t\\t}\\n\\t\\t\\telse \\n\\t\\t\\t\\taddOperators(result, nextNum, num, stoll(num), stoll(num), target);\\n\\t\\t}\\n\\t}\\n\\n\\tvector<string> addOperators(string num, int target) {\\n\\t\\tvector<string> result;\\n\\t\\taddOperators(result, num, \"\", 0, 0, target);\\n\\t\\treturn result;\\n\\t}",
                "solutionTags": [],
                "code": "    void addOperators(vector<string>& result, string nums, string t, long long last, long long curVal, int target) {\\n\\t\\tif (nums.length() == 0) {\\n\\t\\t\\tif (curVal == target)\\n\\t\\t\\t\\tresult.push_back(t);\\n\\t\\t\\treturn;\\n\\t\\t}\\n\\n\\t\\tfor (int i = 1; i<=nums.length(); i++) {\\n\\t\\t\\tstring num = nums.substr(0, i);\\n\\t\\t\\tif(num.length() > 1 && num[0] == '0')\\n\\t\\t\\t    return;\\n\\t\\t\\t\\n\\t\\t\\tstring nextNum = nums.substr(i);\\n\\n\\t\\t\\tif (t.length() > 0) {\\n\\t\\t\\t\\taddOperators(result, nextNum, t + \"+\" + num, stoll(num), curVal + stoll(num), target);\\n\\t\\t\\t\\taddOperators(result, nextNum, t + \"-\" + num, -stoll(num), curVal - stoll(num), target);\\n\\t\\t\\t\\taddOperators(result, nextNum, t + \"*\" + num, last * stoll(num), (curVal - last) + (last * stoll(num)), target);\\n\\t\\t\\t}\\n\\t\\t\\telse \\n\\t\\t\\t\\taddOperators(result, nextNum, num, stoll(num), stoll(num), target);\\n\\t\\t}\\n\\t}\\n\\n\\tvector<string> addOperators(string num, int target) {\\n\\t\\tvector<string> result;\\n\\t\\taddOperators(result, num, \"\", 0, 0, target);\\n\\t\\treturn result;\\n\\t}",
                "codeTag": "Unknown"
            },
            {
                "id": 310707,
                "title": "clean-python-dfs-solution",
                "content": "Please see and vote for my solutions for these similar problems\\n[224. Basic Calculator](https://leetcode.com/problems/basic-calculator/discuss/429098/Python3-solution-after-tokenization-(60ms-beat-99.75))\\n[227. Basic Calculator II](https://leetcode.com/problems/basic-calculator-ii/discuss/429100/Python3-solution-after-tokenization-(56ms-beat-99.92))\\n[282. Expression Add Operators](https://leetcode.com/problems/expression-add-operators/discuss/310707/Clean-Python-DFS-solution)\\n[772. Basic Calculator III](https://leetcode.com/problems/basic-calculator-iii/discuss/429132/Python3-solution-after-tokenization-(40ms-beat-93.59))\\n\\n```\\n    def addOperators(self, num, target):\\n        def dfs(l, r, expr, cur, last, res):\\n            if l == r:\\n                if cur == target:\\n                    res.append(expr)\\n                return\\n            for i in range(l + 1, r + 1):\\n                if i == l + 1 or (i > l + 1 and num[l] != \"0\"): # prevent \"00\"\\n                    s, x = num[l:i], int(num[l:i])\\n                    if last == None:\\n                        dfs(i, r, s, x, x, res)\\n                    else:\\n                        dfs(i, r, expr+\"+\"+s, cur + x, x, res)\\n                        dfs(i, r, expr+\"-\"+s, cur - x, -x, res)\\n                        dfs(i, r, expr+\"*\"+s, cur-last+last*x, last*x, res)\\n        \\n        res = []\\n        dfs(0, len(num), \\'\\', 0, None, res)\\n        return res\\n```",
                "solutionTags": [],
                "code": "```\\n    def addOperators(self, num, target):\\n        def dfs(l, r, expr, cur, last, res):\\n            if l == r:\\n                if cur == target:\\n                    res.append(expr)\\n                return\\n            for i in range(l + 1, r + 1):\\n                if i == l + 1 or (i > l + 1 and num[l] != \"0\"): # prevent \"00\"\\n                    s, x = num[l:i], int(num[l:i])\\n                    if last == None:\\n                        dfs(i, r, s, x, x, res)\\n                    else:\\n                        dfs(i, r, expr+\"+\"+s, cur + x, x, res)\\n                        dfs(i, r, expr+\"-\"+s, cur - x, -x, res)\\n                        dfs(i, r, expr+\"*\"+s, cur-last+last*x, last*x, res)\\n        \\n        res = []\\n        dfs(0, len(num), \\'\\', 0, None, res)\\n        return res\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 71975,
                "title": "some-thoughts-on-the-algorithm-slr-1-and-optimization-meet-in-the-middle-spatial-data-structure",
                "content": "Share some thoughts of mine.\\n\\nThis algorithm resembles a SLR(1) parser.\\n\\nEach parse tree can be represented by 3 semantic values: add+mul*last.\\nWhile adding a symbol and a digit on the right side, the right spine of the parse tree may change. This process resembles the linear construction algorithm of a Cartesian tree.\\n\\nIn the figure below, the 3 trees on the right are derived from the leftmost.\\n\\n      +         +         +           +\\n     / \\\\       / \\\\       / \\\\         / \\\\\\n    2   *     2   *     2   *       +   6\\n       / \\\\       / \\\\       / \\\\     / \\\\\\n      3   @     3   @     *   6   2   *\\n         / \\\\       / \\\\   / \\\\         / \\\\\\n        4   5     @   6 3   @       3   @\\n                 / \\\\       / \\\\         / \\\\\\n                4   5     4   5       4   5\\n\\nNeglecting the leading zero issue (which can be easily rectified in a recursive parser), the grammar is:\\n\\n    E ::= E \"+\" F | E \"-\" F\\n    F ::= F \"*\" L\\n    L ::= \"0\" | ... | \"9\" | L \"0\" | ... | L \"9\"\\n\\nEach production contributes one node in the right spine of the parse tree, and these productions are hierarchical, that is, a lower-priority symbol cannot occur in the subtree of a higher-priority symbol. Thus the longest distance of the rightmost node to the root is 3. On the other hand, the LR(0) item sets are acyclic and the longest distance is 3.\\n\\n`-` can be seen as `+` if we regard the following digit as the opposite number. Addition and multiplication have units, so we can attach a `+`/`*` node if there is none. Juxtaposition has the highest priority so we can reduce them immediately. Thus 3 leaves and 2 inner nodes can represent a parse tree. That is why there are 3 semantic values in most solutions.\\n\\nState sets of each position can be represented by semantic values to minimize the space consumption.\\nFor each prefix of the enumerated expression in question, the rightmost node of the partial syntax tree represents current symbol and it has no more than 3 ancestors. For each ancestor `v`, we keep the semantic value of its left subtree, thus 3 integers are sufficient to represent the state.\\n\\nThis process can also be applied from right to left, so we can use a meet-in-the-middle algorithm to accelerate. We enumerate symbols in the right half and get many suffixes, each of which contributes 3 semantic values. The sum is indispensable, the first addend is necessary if we take account of multiplication. The first number in the first addend is necessary if we take in to account juxtaposition.\\n\\nIf we combine the partial results from the left side and the right side with `+` or `-`, the enumeration is `O(4^(n/2)*2^(n/2)) = O(2^(1.5n))`, better than brute-force `O(4^n) = O(2^(2n))`.\\nThe combination of `*` is tough, as it takes 2 semantic values (juxtaposition requires 3 which is unsolvable). How can be combine `a+b` from the left with `*c+d` from the right, and let the result `a+b*c+d=result` ? We can handle it with geometry method.\\n'c,d' from the right represents a line: `y=c*x+d`, the point (b, target-a) is on the line iff `target-a=c*b+d <=> a+b*c+d=target`. We turn the problem into: given `O(4^(n/2))` points and `O(4^(n/2))` lines, for each point, find the lines passing through it.\\nOrganize those points into a spatial data structure like quad-tree may be helpful. \\n\\nIf you can read Chinese, see [http://maskray.me/blog/2015-10-16-leetcode-expression-add-operators][1] , where I have written these thoughts in detail . It also gives some examples demonstrating the limit of the length of the right spine. \\n\\n    \\n    typedef long long ll;\\n    class Solution {\\n      string a;\\n      int n, nn, target;\\n      vector<multimap<ll, string>> e_plus, e_minus;\\n      vector<string> res;\\n      void backward(int k, string s, ll add, ll mul, ll last, ll ten) {\\n        if (k < nn) return;\\n        int x = a[k-1]-'0';\\n        ll ten2 = 10*ten, sum = add+mul*last;\\n        backward(k-1, string(1, a[k-1])+s, add, mul, last+ten2*x, ten2);\\n        if (ten == 1 || last >= ten) { // `last` has no leading zero\\n          backward(k-1, string(1, a[k-1])+'*'+s, add, mul*last, x, 1);\\n          backward(k-1, string(1, a[k-1])+'+'+s, sum, 1, x, 1);\\n          backward(k-1, string(1, a[k-1])+'-'+s, add-mul*last, 1, x, 1);\\n          e_plus[k].insert(make_pair(sum, s));\\n          e_minus[k].insert(make_pair(add-mul*last, s));\\n        }\\n      }\\n      void forward(int k, string s, ll add, ll mul, ll last) {\\n        ll sum = add+mul*last;\\n        if (k == n) {\\n          if (sum == target)\\n            res.push_back(s);\\n          return;\\n        }\\n        int x = a[k]-'0';\\n        if (last) // no leading zero\\n          forward(k+1, s+a[k], add, mul, last*10+x);\\n        forward(k+1, s+'*'+a[k], add, mul*last, x);\\n        if (k < nn) {\\n          forward(k+1, s+'+'+a[k], sum, 1, x);\\n          forward(k+1, s+'-'+a[k], sum, -1, x);\\n        } else {\\n          auto rg = e_plus[k].equal_range(target-sum);\\n          for (auto it = rg.first; it != rg.second; ++it)\\n            res.push_back(s+'+'+it->second);\\n          rg = e_minus[k].equal_range(target-sum);\\n          for (auto it = rg.first; it != rg.second; ++it)\\n            res.push_back(s+'-'+it->second);\\n        }\\n      }\\n    public:\\n      vector<string> addOperators(string num, int target) {\\n        a = num;\\n        n = a.size();\\n        if (n) {\\n          nn = n/2; // 0 < nn < n\\n          this->target = target;\\n          e_plus.resize(n);\\n          e_minus.resize(n);\\n          backward(n-1, string(1, a[n-1]), 0, 1, a[n-1]-'0', 1);\\n          forward(1, string(1, a[0]), 0, 1, a[0]-'0');\\n        }\\n        return res;\\n      }\\n    };\\n\\n\\n  [1]: http://maskray.me/blog/2015-10-16-leetcode-expression-add-operators",
                "solutionTags": [
                    "C++"
                ],
                "code": "class Solution {\\n      string a;\\n      int n, nn, target;\\n      vector<multimap<ll, string>> e_plus, e_minus;\\n      vector<string> res;\\n      void backward(int k, string s, ll add, ll mul, ll last, ll ten) {\\n        if (k < nn) return;\\n        int x = a[k-1]-'0';\\n        ll ten2 = 10*ten, sum = add+mul*last;\\n        backward(k-1, string(1, a[k-1])+s, add, mul, last+ten2*x, ten2);\\n        if (ten == 1 || last >= ten) { // `last` has no leading zero\\n          backward(k-1, string(1, a[k-1])+'*'+s, add, mul*last, x, 1);\\n          backward(k-1, string(1, a[k-1])+'+'+s, sum, 1, x, 1);\\n          backward(k-1, string(1, a[k-1])+'-'+s, add-mul*last, 1, x, 1);\\n          e_plus[k].insert(make_pair(sum, s));\\n          e_minus[k].insert(make_pair(add-mul*last, s));\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 792406,
                "title": "super-clean-python-backtracking-soution",
                "content": "```\\nclass Solution:\\n    def addOperators(self, num: str, target: int) -> List[str]:\\n        if not num:\\n            return []\\n\\t\\t\\t\\n        num_len = len(num)\\n        res = []\\n        \\n        def dfs(idx, path):\\n            if idx == num_len - 1:\\n                # num_len - 1 to prevent situations like (1+2+) or (1*3*) etc..\\n                path = path + num[idx] \\n                if eval(path) == target:\\n                    res.append(path)\\n                return\\n            \\n            dfs(idx+1, path + num[idx] + \"+\") \\n            dfs(idx+1, path + num[idx] + \"-\")\\n            dfs(idx+1, path + num[idx] + \"*\")\\n            if (path and path[-1] not in [\\'+\\', \\'-\\', \\'*\\'] and num[idx] == \\'0\\') or num[idx] != \\'0\\':\\n                \\n                # Prevent cases such as (2+05) which cannot be evaluated using the eval function\\n                # Cases such as 12+104 should be acceptable, but not 121+04\\n                \\n                dfs(idx+1, path + num[idx])\\n            \\n        dfs(0, \"\")\\n        return res\\n            \\n```",
                "solutionTags": [
                    "Python",
                    "Backtracking",
                    "Depth-First Search"
                ],
                "code": "```\\nclass Solution:\\n    def addOperators(self, num: str, target: int) -> List[str]:\\n        if not num:\\n            return []\\n\\t\\t\\t\\n        num_len = len(num)\\n        res = []\\n        \\n        def dfs(idx, path):\\n            if idx == num_len - 1:\\n                # num_len - 1 to prevent situations like (1+2+) or (1*3*) etc..\\n                path = path + num[idx] \\n                if eval(path) == target:\\n                    res.append(path)\\n                return\\n            \\n            dfs(idx+1, path + num[idx] + \"+\") \\n            dfs(idx+1, path + num[idx] + \"-\")\\n            dfs(idx+1, path + num[idx] + \"*\")\\n            if (path and path[-1] not in [\\'+\\', \\'-\\', \\'*\\'] and num[idx] == \\'0\\') or num[idx] != \\'0\\':\\n                \\n                # Prevent cases such as (2+05) which cannot be evaluated using the eval function\\n                # Cases such as 12+104 should be acceptable, but not 121+04\\n                \\n                dfs(idx+1, path + num[idx])\\n            \\n        dfs(0, \"\")\\n        return res\\n            \\n```",
                "codeTag": "Java"
            },
            {
                "id": 354772,
                "title": "c-concise-dfs",
                "content": "```cpp\\nvector<string> addOperators(string num, int target) {\\n\\tvector<string> res;\\n\\tdfs(num, 0, target, \"\", 0, 0, res);\\n\\treturn res;\\n}\\n\\nvoid dfs(string &num, int start, int target, string path, long prev, long cur, vector<string> &res) {\\n\\tif(start == num.size() && prev + cur == target) res.push_back(path);\\n\\n\\tfor(int i = 1; start + i <= num.size(); i++) {\\n\\t\\tstring s = num.substr(start, i);\\n\\t\\tlong n = stoll(s);\\n\\t\\tif(to_string(n).size() != s.size()) return;\\n\\t\\tif(!start) dfs(num, i, target, s, 0, n, res);\\n\\t\\telse {\\n\\t\\t\\tdfs(num, start + i, target, path + \"+\" + s, prev + cur, n, res);\\n\\t\\t\\tdfs(num, start + i, target, path + \"-\" + s, prev + cur, -n, res);\\n\\t\\t\\tdfs(num, start + i, target, path + \"*\" + s, prev, cur * n, res);\\n\\t\\t}\\n\\t}\\n}\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Backtracking",
                    "Depth-First Search"
                ],
                "code": "```cpp\\nvector<string> addOperators(string num, int target) {\\n\\tvector<string> res;\\n\\tdfs(num, 0, target, \"\", 0, 0, res);\\n\\treturn res;\\n}\\n\\nvoid dfs(string &num, int start, int target, string path, long prev, long cur, vector<string> &res) {\\n\\tif(start == num.size() && prev + cur == target) res.push_back(path);\\n\\n\\tfor(int i = 1; start + i <= num.size(); i++) {\\n\\t\\tstring s = num.substr(start, i);\\n\\t\\tlong n = stoll(s);\\n\\t\\tif(to_string(n).size() != s.size()) return;\\n\\t\\tif(!start) dfs(num, i, target, s, 0, n, res);\\n\\t\\telse {\\n\\t\\t\\tdfs(num, start + i, target, path + \"+\" + s, prev + cur, n, res);\\n\\t\\t\\tdfs(num, start + i, target, path + \"-\" + s, prev + cur, -n, res);\\n\\t\\t\\tdfs(num, start + i, target, path + \"*\" + s, prev, cur * n, res);\\n\\t\\t}\\n\\t}\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 140390,
                "title": "a-recursive-algorithm-with-detailed-explanation-and-proof-of-correctness",
                "content": "## Remarks\\nI think the algorithm becomes quite easy to understand once you understand the **definition and properties** I\\'ve listed below. Everything else is implementation formalities.\\n\\n## Definition\\nThe following definition and notation will help simplify the proof of correctness later\\n\\n**Eval** : Exp -> N  \\nIt\\'s a function that takes in a string of the form \"23-3\\\\*7+50\". Basically *Exp* resembles the a viable arrangement of operators (** \\\\*, +, - only**) and digits as the problem specifies. It\\'s behaves just like how we would manually calculate *Exp*.\\n\\nExample:  \\n\\n* Eval(\"5\") = 5.  \\n\\n* Eval(\"3+2*7-4\") = 13\\n\\n## Property\\nWe assume the following properties of *Eval*, and we will use them later to verify the correctness of our algorithm. I think they are all very intuitive, but I don\\'t know how to formally prove them.  \\n\\nA and B will be arbitrary *Exp*, *+* will append the two adjacent strings.\\n\\n### P1\\n    Eval(A + \\'+\\' + B) = Eval(A) + Eval(B)\\nExample:  \\nEval(\"4\\\\*3+3-2\") = Eval(\"4\\\\*3\") + Eval(\"3-2\")\\n\\n### P2\\n    Eval(A + \\'-\\' + B) = Eval(A) + Eval(\\'-1*\\' + B)\\nExample:  \\nEval(\"4\\\\*3-3-2\") = Eval(\"4\\\\*3\") + Eval(\"-1*3-2\")\\n\\n### P3\\n    Eval(A + \\'*\\' + B + \\'*\\' + C) = Eval(str(Eval(A + \\'*\\' + B)) + \\'*\\' + C)\\n\\nNote: *str* turns a number into its string representation.\\nExample:  \\nEval(\\'4\\\\*3\\\\*3+2\\') = Eval(str(Eval(4\\\\*3)) + \\'\\\\*\\' + \\'3+2\\') = Eval(\\'12\\\\*3+2\\')\\n\\n\\n### P4\\n    Eval(\\'1*\\' + A) = Eval(A)\\n\\nNote: This can be easily derived by case analysis (on A) and the previous three properties.  \\nExample:  \\nEval(\\'5+7\\') = Eval(\\'1\\\\*5+7\\')\\n\\n\\n## Algorithm\\nConsider a slightly modified version of this problem:  \\nGiven a number X, and a list of numbers lon = [N1, N2, ..., Nk], and a target number  \\n\\n**F(X, lon, target)** returns the combinations of \"X \\\\* N1N2N3\" that yields target, where the rules for inserting operator between digits is the same as problem described above  \\n\\nThe only difference being there is a multiplication operator inserted after X already.  \\n\\nOur **original problem** asks for all possible arrangements of input *lon* such that each arrangement *E* satisfies **Eval(E) = target**. Well, by property 4, that is just a special case of the more generalized **F**, namely, **F(1, lon, target)**.\\n\\nWe will show how to recursively apply **F** to compute the desired output. We do this by enumerating all cases based on the input.  \\n**Note:** We denote lon as [N1, N2, ..., Nk]. Thus len(lon) = k\\n\\n\\n### Base case\\nWhen *k == 1*, by definition of **F**, if *X \\\\* N1 == target*, this arrangement is qualified, and we return its string representation: *str(X) + \\'\\\\*\\' + str(N1)*  \\n\\n### Recursive cases\\nRemember we can either insert one of the three operators, or not insert anything. Thus we have 4 cases:\\n\\n### Insert nothing\\nWe keep N1 and N2 together in this case, but this only works if N1 is not \\'0\\', since something like \\'07\\' will not be a valid NumberString.  \\nAssume that, and by definition of **F**, we can recursively compute the output as \\n\\n**F(X, [N1 \\\\* 10 + N2, N3, ..., Nk], target)**\\n\\n### Insert +\\nThe final arrangement will look like **\\'X \\\\* N1 + E\\'**, where *E* is whatever arrangement the rest of the lon ([N2, N3, ..., Nk]) came out to be.  \\nThus, we want this string to evaluate to *target*, meaning that,  \\n**Eval(\\'X * N1\\' + \\'+\\' +  E) = target**. By property 1 we have:  \\n**target = Eval(\\'X \\\\* N1\\') + Eval(E) = X \\\\* N1 + Eval(E)**  \\nIn other words, we want **Eval(E) = target - X \\\\* N1**  \\nWhat are the possible arrangements for that? That is precisely a subproblem to the original problem, thus the answer for that is \\n\\n**F(1, [N2, N3, ..., Nk], target - X \\\\* N1**\\n\\n### Insert -\\nThis is similar to the case with \\'+\\' above, because we can use property 2 to transform \\'-\\'.  \\nWe want **Eval(\\'X * N1\\' + \\'-\\' +  E) = target**. By property 2 we have:\\n**target = Eval(\\'X \\\\* N1\\') + Eval(\\'-1\\\\*\\' + E) = X \\\\* N1 + Eval(\\'-1\\\\*\\' + E)**  \\nIn other words, we want **Eval(\\'-1\\\\*\\' + E) = target - X \\\\* N1**  \\nTo solve this subproblem, we need to utilize the definition for **F**, which suggests that the answer is \\n\\n**F(-1, [N2, N3, ..., Nk], target - X \\\\* N1**\\n\\n\\n### Insert *\\nThis follows the same pattern as the above cases.  \\nWe want **Eval(\\'X \\\\* N1\\' + \\'\\\\*\\' +  E) = target**. By property 3 we have:  \\n**target = Eval(str(Eval(\\'X \\\\* N1\\')) + \\'\\\\*\\' + E)**  \\nBy definition of **F**, we can derived the answer easily:\\n\\n**F(X \\\\* N1, [N2, N3, ..., Nk], target**\\n\\n\\n## Code\\nThe following is my implementation of the algorithm in Python3. It\\'s exactly like what I described above. \\n\\n    def addOperators(self, num, target):\\n        \"\"\"\\n        :type num: str\\n        :type target: int\\n        :rtype: List[str]\\n        \"\"\"\\n\\n        lon = list(map(int, num))\\n        answer = []\\n\\n        # F is exactly like what we defined above, except it has\\n        # an extra argument to keep track of the partial string arrangement (including \\'X*\\')\\n        # already determined as it recurs down the search\\n        # Also lon is represented as lon[start:]\\n        # Viable arrangement will be appened into @answer in string form\\n        def F(x, start, targ, prevArrangement):\\n\\t\\t\\t\\t\\n            # notice that start increments on every recursive call, so termination is ensured. \\n            if start == len(lon) - 1:\\n                if x * lon[start] == targ:\\n                    answer.append(prevArrangement + str(lon[start]))\\n                return\\n\\n            #  case 1 (no operator insertion)\\n            # we have to modify the value of lon[start + 1]\\n            # so we restore its value after the function returns\\n            if lon[start] != 0:\\n                lon[start + 1] += lon[start] * 10\\n                F(x, start + 1, targ, prevArrangement)\\n                lon[start + 1] -= lon[start] * 10\\n\\n            # case 2, insert \\'+\\'\\n            F(1, start + 1, targ - x*lon[start], prevArrangement + str(lon[start]) + \\'+\\')\\n\\n            # case 3, insert \\'-\\'\\n            F(-1, start + 1, targ - x*lon[start], prevArrangement + str(lon[start]) + \\'-\\')\\n\\n            # case 4, insert \\'*\\'\\n            F(x * lon[start], start + 1, targ, prevArrangement + str(lon[start]) + \\'*\\')\\n\\n\\n        # since we don\\'t want to keep the \"1*\" in the front, we initialize\\n        # prevArrangement to be empty string. \\n        F(1, 0, target, \"\")\\n        return answer\\n\\n\\n",
                "solutionTags": [],
                "code": "## Remarks\\nI think the algorithm becomes quite easy to understand once you understand the **definition and properties** I\\'ve listed below. Everything else is implementation formalities.\\n\\n## Definition\\nThe following definition and notation will help simplify the proof of correctness later\\n\\n**Eval** : Exp -> N  \\nIt\\'s a function that takes in a string of the form \"23-3\\\\*7+50\". Basically *Exp* resembles the a viable arrangement of operators (** \\\\*, +, - only**) and digits as the problem specifies. It\\'s behaves just like how we would manually calculate *Exp*.\\n\\nExample:  \\n\\n* Eval(\"5\") = 5.  \\n\\n* Eval(\"3+2*7-4\") = 13\\n\\n## Property\\nWe assume the following properties of *Eval*, and we will use them later to verify the correctness of our algorithm. I think they are all very intuitive, but I don\\'t know how to formally prove them.  \\n\\nA and B will be arbitrary *Exp*, *+* will append the two adjacent strings.\\n\\n### P1\\n    Eval(A + \\'+\\' + B) = Eval(A) + Eval(B)\\nExample:  \\nEval(\"4\\\\*3+3-2\") = Eval(\"4\\\\*3\") + Eval(\"3-2\")\\n\\n### P2\\n    Eval(A + \\'-\\' + B) = Eval(A) + Eval(\\'-1*\\' + B)\\nExample:  \\nEval(\"4\\\\*3-3-2\") = Eval(\"4\\\\*3\") + Eval(\"-1*3-2\")\\n\\n### P3\\n    Eval(A + \\'*\\' + B + \\'*\\' + C) = Eval(str(Eval(A + \\'*\\' + B)) + \\'*\\' + C)\\n\\nNote: *str* turns a number into its string representation.\\nExample:  \\nEval(\\'4\\\\*3\\\\*3+2\\') = Eval(str(Eval(4\\\\*3)) + \\'\\\\*\\' + \\'3+2\\') = Eval(\\'12\\\\*3+2\\')\\n\\n\\n### P4\\n    Eval(\\'1*\\' + A) = Eval(A)\\n\\nNote: This can be easily derived by case analysis (on A) and the previous three properties.  \\nExample:  \\nEval(\\'5+7\\') = Eval(\\'1\\\\*5+7\\')\\n\\n\\n## Algorithm\\nConsider a slightly modified version of this problem:  \\nGiven a number X, and a list of numbers lon = [N1, N2, ..., Nk], and a target number  \\n\\n**F(X, lon, target)** returns the combinations of \"X \\\\* N1N2N3\" that yields target, where the rules for inserting operator between digits is the same as problem described above  \\n\\nThe only difference being there is a multiplication operator inserted after X already.  \\n\\nOur **original problem** asks for all possible arrangements of input *lon* such that each arrangement *E* satisfies **Eval(E) = target**. Well, by property 4, that is just a special case of the more generalized **F**, namely, **F(1, lon, target)**.\\n\\nWe will show how to recursively apply **F** to compute the desired output. We do this by enumerating all cases based on the input.  \\n**Note:** We denote lon as [N1, N2, ..., Nk]. Thus len(lon) = k\\n\\n\\n### Base case\\nWhen *k == 1*, by definition of **F**, if *X \\\\* N1 == target*, this arrangement is qualified, and we return its string representation: *str(X) + \\'\\\\*\\' + str(N1)*  \\n\\n### Recursive cases\\nRemember we can either insert one of the three operators, or not insert anything. Thus we have 4 cases:\\n\\n### Insert nothing\\nWe keep N1 and N2 together in this case, but this only works if N1 is not \\'0\\', since something like \\'07\\' will not be a valid NumberString.  \\nAssume that, and by definition of **F**, we can recursively compute the output as \\n\\n**F(X, [N1 \\\\* 10 + N2, N3, ..., Nk], target)**\\n\\n### Insert +\\nThe final arrangement will look like **\\'X \\\\* N1 + E\\'**, where *E* is whatever arrangement the rest of the lon ([N2, N3, ..., Nk]) came out to be.  \\nThus, we want this string to evaluate to *target*, meaning that,  \\n**Eval(\\'X * N1\\' + \\'+\\' +  E) = target**. By property 1 we have:  \\n**target = Eval(\\'X \\\\* N1\\') + Eval(E) = X \\\\* N1 + Eval(E)**  \\nIn other words, we want **Eval(E) = target - X \\\\* N1**  \\nWhat are the possible arrangements for that? That is precisely a subproblem to the original problem, thus the answer for that is \\n\\n**F(1, [N2, N3, ..., Nk], target - X \\\\* N1**\\n\\n### Insert -\\nThis is similar to the case with \\'+\\' above, because we can use property 2 to transform \\'-\\'.  \\nWe want **Eval(\\'X * N1\\' + \\'-\\' +  E) = target**. By property 2 we have:\\n**target = Eval(\\'X \\\\* N1\\') + Eval(\\'-1\\\\*\\' + E) = X \\\\* N1 + Eval(\\'-1\\\\*\\' + E)**  \\nIn other words, we want **Eval(\\'-1\\\\*\\' + E) = target - X \\\\* N1**  \\nTo solve this subproblem, we need to utilize the definition for **F**, which suggests that the answer is \\n\\n**F(-1, [N2, N3, ..., Nk], target - X \\\\* N1**\\n\\n\\n### Insert *\\nThis follows the same pattern as the above cases.  \\nWe want **Eval(\\'X \\\\* N1\\' + \\'\\\\*\\' +  E) = target**. By property 3 we have:  \\n**target = Eval(str(Eval(\\'X \\\\* N1\\')) + \\'\\\\*\\' + E)**  \\nBy definition of **F**, we can derived the answer easily:\\n\\n**F(X \\\\* N1, [N2, N3, ..., Nk], target**\\n\\n\\n## Code\\nThe following is my implementation of the algorithm in Python3. It\\'s exactly like what I described above. \\n\\n    def addOperators(self, num, target):\\n        \"\"\"\\n        :type num: str\\n        :type target: int\\n        :rtype: List[str]\\n        \"\"\"\\n\\n        lon = list(map(int, num))\\n        answer = []\\n\\n        # F is exactly like what we defined above, except it has\\n        # an extra argument to keep track of the partial string arrangement (including \\'X*\\')\\n        # already determined as it recurs down the search\\n        # Also lon is represented as lon[start:]\\n        # Viable arrangement will be appened into @answer in string form\\n        def F(x, start, targ, prevArrangement):\\n\\t\\t\\t\\t\\n            # notice that start increments on every recursive call, so termination is ensured. \\n            if start == len(lon) - 1:\\n                if x * lon[start] == targ:\\n                    answer.append(prevArrangement + str(lon[start]))\\n                return\\n\\n            #  case 1 (no operator insertion)\\n            # we have to modify the value of lon[start + 1]\\n            # so we restore its value after the function returns\\n            if lon[start] != 0:\\n                lon[start + 1] += lon[start] * 10\\n                F(x, start + 1, targ, prevArrangement)\\n                lon[start + 1] -= lon[start] * 10\\n\\n            # case 2, insert \\'+\\'\\n            F(1, start + 1, targ - x*lon[start], prevArrangement + str(lon[start]) + \\'+\\')\\n\\n            # case 3, insert \\'-\\'\\n            F(-1, start + 1, targ - x*lon[start], prevArrangement + str(lon[start]) + \\'-\\')\\n\\n            # case 4, insert \\'*\\'\\n            F(x * lon[start], start + 1, targ, prevArrangement + str(lon[start]) + \\'*\\')\\n\\n\\n        # since we don\\'t want to keep the \"1*\" in the front, we initialize\\n        # prevArrangement to be empty string. \\n        F(1, 0, target, \"\")\\n        return answer\\n\\n\\n",
                "codeTag": "Python3"
            },
            {
                "id": 1068461,
                "title": "javascript-simple-backtracking-solution",
                "content": "```javascript\\nvar addOperators = function(num, target) {\\n    const output = []\\n    \\n    function permute(str, arr, total, prev) {\\n        if(!str.length && total === target) output.push(arr.join(\\'\\'));\\n        \\n        let len = str.length;\\n        if(str[0] === \\'0\\') len = 1;\\n\\n        for(let i = 1; i <= len; i++) {\\n            const curr = +str.slice(0, i);\\n            const rest = str.slice(i);\\n            \\n            if(!arr.length) permute(rest, [curr], curr, curr);\\n            else {\\n                permute(rest, [...arr, \\'+\\', curr], total+curr, curr);\\n                permute(rest, [...arr, \\'-\\', curr], total-curr, 0-curr);\\n                const prod = prev * curr;\\n                permute(rest, [...arr, \\'*\\', curr], total-prev+prod, prod);\\n            }\\n        }\\n    }\\n    permute(num, [], 0, 0);\\n    return output;\\n};\\n```",
                "solutionTags": [
                    "JavaScript",
                    "Backtracking"
                ],
                "code": "```javascript\\nvar addOperators = function(num, target) {\\n    const output = []\\n    \\n    function permute(str, arr, total, prev) {\\n        if(!str.length && total === target) output.push(arr.join(\\'\\'));\\n        \\n        let len = str.length;\\n        if(str[0] === \\'0\\') len = 1;\\n\\n        for(let i = 1; i <= len; i++) {\\n            const curr = +str.slice(0, i);\\n            const rest = str.slice(i);\\n            \\n            if(!arr.length) permute(rest, [curr], curr, curr);\\n            else {\\n                permute(rest, [...arr, \\'+\\', curr], total+curr, curr);\\n                permute(rest, [...arr, \\'-\\', curr], total-curr, 0-curr);\\n                const prod = prev * curr;\\n                permute(rest, [...arr, \\'*\\', curr], total-prev+prod, prod);\\n            }\\n        }\\n    }\\n    permute(num, [], 0, 0);\\n    return output;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1470556,
                "title": "c-backtracking-beginner-explained-easy-to-understand-clean",
                "content": "# ***Approach***\\n```\\n    This problem is a pretty good backtracking problem\\n    You can easily apply dfs to find all possible expressions , but the main problem is in evaluating that expression simultaneously!!!\\n    \\n    Points to remember:\\n        (1) First number of expression is operatorless[meaning no operator is before it]\\n        (2) string path stores : expression for a branch\\n        (3) res : it stores the result calculated so far!!!\\n        (4) prev : stores the last number of expression\\n        (5) sub_string : holds number for [index to i] , take example , index = 0 , i = 2 , num = \"1234\" then  sub_string = \"123\"\\n                take example\\n                    2 + 3 * 3\\n                    if path = \"2+3\" , prev = 3\\n                take another example\\n                    2 + 3 * 4 * 2\\n                    if path = \"2+3*4\" , prev = 12\\n                NOTE : when we pick * as operator we pick prev = prev * number\\n                \\n----------------------------------------------------------------------------------------------------------------------\\n\\n    Logic Simplified:\\n        if(index == num.size() and res is target)\\n            push path to expression and then return\\n            \\n        run loop from[index to end]\\n        {\\n            form sub_string , simultaneously form number\\n            \\n            if(a number with leading 0 is formed as sub_string)\\n                break;\\n            \\n            if(we are forming first number of expression)\\n                pick no operator and apply dfs\\n            else\\n            {\\n                pick + operator and apply dfs , prev = number\\n                pick - operator and apply dfs , prev = -number\\n                pick * operator and apply dfs , prev = prev * number [while evaluating res we first subtract prev_val because it is attached or connected to next val]\\n            }\\n        }\\n----------------------------------------------------------------------------------------------------------------------        \\n```\\n# ***Code***\\n```\\nclass Solution {\\npublic:\\n    vector<string> expressions;\\n    vector<string> addOperators(string num, int target) {\\n        dfs(num , target , 0 , \"\" , 0 , 0);\\n        return expressions;\\n    }\\n    void dfs(string &num , int target , int index , string path , long int res , long int prev)\\n    {\\n        if(index == num.size() and res == target)\\n        {\\n            expressions.push_back(path);\\n            return;\\n        }\\n        \\n        long int number = 0;\\n        string sub_string = \"\";\\n        \\n        for(int i = index ; i < num.size() ; ++i)\\n        {\\n            sub_string += num[i];\\n            number = (number * 10) + num[i] - \\'0\\';\\n            \\n            if(sub_string.size() > 1 and sub_string[0] == \\'0\\') // skipping numbers with leading 0\\'s\\n                break;\\n            \\n            if(index == 0) // first number of expression is picked without operator\\n            {\\n                dfs(num , target , i + 1 , sub_string , number, number);\\n            }\\n            else\\n            {\\n                // (1) + operation inserted\\n                dfs(num , target , i + 1 , path  + \"+\" + sub_string , res  + number , number);\\n                    \\n                // (2) - operation inserted\\n                dfs(num , target , i + 1 , path + \"-\" + sub_string , res  - number , -number);\\n                \\n                // (3) * operation inserted\\n                dfs(num , target , i + 1 , path + \"*\" + sub_string , (res - prev)  + (prev * number) , prev * number);\\n            }\\n        }\\n            \\n    }\\n    \\n};\\n```\\n# ***If you liked the solution , Please Upvote :)***",
                "solutionTags": [
                    "C",
                    "Backtracking",
                    "Depth-First Search"
                ],
                "code": "```\\n    This problem is a pretty good backtracking problem\\n    You can easily apply dfs to find all possible expressions , but the main problem is in evaluating that expression simultaneously!!!\\n    \\n    Points to remember:\\n        (1) First number of expression is operatorless[meaning no operator is before it]\\n        (2) string path stores : expression for a branch\\n        (3) res : it stores the result calculated so far!!!\\n        (4) prev : stores the last number of expression\\n        (5) sub_string : holds number for [index to i] , take example , index = 0 , i = 2 , num = \"1234\" then  sub_string = \"123\"\\n                take example\\n                    2 + 3 * 3\\n                    if path = \"2+3\" , prev = 3\\n                take another example\\n                    2 + 3 * 4 * 2\\n                    if path = \"2+3*4\" , prev = 12\\n                NOTE : when we pick * as operator we pick prev = prev * number\\n                \\n----------------------------------------------------------------------------------------------------------------------\\n\\n    Logic Simplified:\\n        if(index == num.size() and res is target)\\n            push path to expression and then return\\n            \\n        run loop from[index to end]\\n        {\\n            form sub_string , simultaneously form number\\n            \\n            if(a number with leading 0 is formed as sub_string)\\n                break;\\n            \\n            if(we are forming first number of expression)\\n                pick no operator and apply dfs\\n            else\\n            {\\n                pick + operator and apply dfs , prev = number\\n                pick - operator and apply dfs , prev = -number\\n                pick * operator and apply dfs , prev = prev * number [while evaluating res we first subtract prev_val because it is attached or connected to next val]\\n            }\\n        }\\n----------------------------------------------------------------------------------------------------------------------        \\n```\n```\\nclass Solution {\\npublic:\\n    vector<string> expressions;\\n    vector<string> addOperators(string num, int target) {\\n        dfs(num , target , 0 , \"\" , 0 , 0);\\n        return expressions;\\n    }\\n    void dfs(string &num , int target , int index , string path , long int res , long int prev)\\n    {\\n        if(index == num.size() and res == target)\\n        {\\n            expressions.push_back(path);\\n            return;\\n        }\\n        \\n        long int number = 0;\\n        string sub_string = \"\";\\n        \\n        for(int i = index ; i < num.size() ; ++i)\\n        {\\n            sub_string += num[i];\\n            number = (number * 10) + num[i] - \\'0\\';\\n            \\n            if(sub_string.size() > 1 and sub_string[0] == \\'0\\') // skipping numbers with leading 0\\'s\\n                break;\\n            \\n            if(index == 0) // first number of expression is picked without operator\\n            {\\n                dfs(num , target , i + 1 , sub_string , number, number);\\n            }\\n            else\\n            {\\n                // (1) + operation inserted\\n                dfs(num , target , i + 1 , path  + \"+\" + sub_string , res  + number , number);\\n                    \\n                // (2) - operation inserted\\n                dfs(num , target , i + 1 , path + \"-\" + sub_string , res  - number , -number);\\n                \\n                // (3) * operation inserted\\n                dfs(num , target , i + 1 , path + \"*\" + sub_string , (res - prev)  + (prev * number) , prev * number);\\n            }\\n        }\\n            \\n    }\\n    \\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 71967,
                "title": "elegant-java-solution",
                "content": "    public class Solution {\\n    List<String> result =new ArrayList<String>();\\n    public List<String> addOperators(String num, int target) {\\n        for(int i=1;i<=num.length();i++){\\n            if(i>=2 && num.charAt(0)=='0') continue;\\n            bfs(num.substring(i),num.substring(0,i),target,0,Long.parseLong(num.substring(0,i)),true);\\n        }\\n        return result;\\n    }\\n    \\n    public void bfs(String s,String trace,int target,long pre,long current,boolean sign){\\n        long sum = sign? pre+current:pre-current;\\n        if(s.length()==0){\\n            if(sum==(long) target) result.add(trace);\\n            return;\\n        }\\n        for(int i=1;i<=s.length();i++){\\n            if(i>=2 && s.charAt(0)=='0') continue;\\n            int number = Integer.parseInt(s.substring(0,i));\\n            bfs(s.substring(i),trace+\"+\"+number,target,sum,number,true);\\n            bfs(s.substring(i),trace+\"-\"+number,target,sum,number,false);\\n            bfs(s.substring(i),trace+\"*\"+number,target,pre,current*number,sign);\\n        }\\n    }\\n}",
                "solutionTags": [],
                "code": "class Solution {\\n    List<String> result =new ArrayList<String>();\\n    public List<String> addOperators(String num, int target) {\\n        for(int i=1;i<=num.length();i++){\\n            if(i>=2 && num.charAt(0)=='0') continue;\\n            bfs(num.substring(i),num.substring(0,i),target,0,Long.parseLong(num.substring(0,i)),true);\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 71947,
                "title": "16ms-c-solution",
                "content": "The idea is to cut a value from the left of the string and then for each of operations '+', '-', '*' repeat the procedure recursively. The trick is to pass the sum of all left summands and the product of rightmost factors. This allows to calculate the left sum and the right product on the next step depending on the next chosen operation.\\n\\n    class Solution {\\n        typedef long long int i64;\\n        \\n        string myS;\\n        const char* s;\\n        i64 target;\\n        int slen;\\n        \\n    public:\\n      \\n        vector<string> addOperators(const string& num, int t) {\\n            myS = num;\\n            slen = myS.size();\\n            s = myS.c_str();\\n            target = t;\\n            \\n            vector<string> res;\\n            char buf[slen*2+1];\\n            \\n            int lmax = (s[0] == '0' ? 1 : slen);\\n            i64 v = 0;\\n            for (int l=1; l<=lmax; ++l) {\\n                int c = s[l-1];\\n                v = v*10 + (c-'0');   // add next digit\\n                buf[l-1] = c;  // only need to append the last digit\\n                processTail(0, v, l, buf, l, res);\\n            }\\n            return res;\\n        }\\n    \\n        void processTail(i64 prevsum, i64 last, int pos, char* buf, int bufpos, vector<string>& res) {\\n            if (pos == slen) {\\n                // end of string\\n                // check the value and save\\n                if (prevsum+last == target) {\\n                    buf[bufpos] = 0;\\n                    res.push_back(buf);\\n                }\\n                return;\\n            }\\n            \\n            int lmax = (s[pos] == '0' ? 1 : slen-pos); // don't allow multichar intergers starting from a '0'\\n            i64 v = 0;\\n            for (int l=1; l<=lmax; ++l) {\\n                int c = s[pos+l-1];\\n                v = v*10 + (c-'0');     // add next digit to v\\n    \\n                buf[bufpos] = '+';\\n                buf[bufpos+l] = c;      // only need to append the last digit of v\\n                processTail(prevsum+last, v, pos+l, buf, bufpos+l+1, res);\\n    \\n                buf[bufpos] = '-'; \\n                processTail(prevsum+last, -v, pos+l, buf, bufpos+l+1, res);\\n    \\n                buf[bufpos] = '*'; \\n                processTail(prevsum, last*v, pos+l, buf, bufpos+l+1, res);\\n            }\\n        }\\n    };",
                "solutionTags": [
                    "C++"
                ],
                "code": "class Solution {\\n        typedef long long int i64;\\n        \\n        string myS;\\n        const char* s;\\n        i64 target;\\n        int slen;\\n        \\n    public:\\n      \\n        vector<string> addOperators(const string& num, int t) {\\n            myS = num;\\n            slen = myS.size();\\n            s = myS.c_str();\\n            target = t;\\n            \\n            vector<string> res;\\n            char buf[slen*2+1];\\n            \\n            int lmax = (s[0] == '0' ? 1 : slen);\\n            i64 v = 0;\\n            for (int l=1; l<=lmax; ++l) {\\n                int c = s[l-1];\\n                v = v*10 + (c-'0');   // add next digit\\n                buf[l-1] = c;  // only need to append the last digit\\n                processTail(0, v, l, buf, l, res);\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 3742718,
                "title": "c-hinglish-easy-explanation-backtracking-interview-prep",
                "content": "# Approach\\n- Explained in the code\\n\\n# Code\\n```\\nclass Solution\\n{\\n   \\t1. Numbers ke beech mein operators dalna hain +,-,*.\\n   \\t2. Teeno ko baari baari se try karna hain jisse target achieve ho to backtracking use karenge hi.\\n   \\t3. Ab isme dhyan rakhna hain ki koi \\n   \\t- leading 0 na ho \\n   \\t- BODMAS rules are followed\\n   \\t4. Subtraction and Addition rules to aasani se follow ho jayenge\\n   \\t5. Multiplication mein hame previous operation ko hatana padega jaise agar prev operation sum that to vo operation hatake multiplication dalenge.\\n   \\t6. First index pe hain to aage bad jayenge \\n   \\t7. Recursive Calls mein we will keep track of index in num,sumPath,sum,prev.\\n\\n//==============================================================================================================================\\n    public:\\n        void recursiveCall(int i, string sumPath, long sum, long prev, string num, int target, vector<string> &result)\\n        {\\n           \\t// If we have reached the end of \\'num\\'\\n            if (i == num.size())\\n            {\\n                if (sum == target)\\n                {\\n                   \\t// If the target is achieved, add the path to the result\\n                    result.push_back(sumPath);\\n                }\\n                return;\\n            }\\n\\n            for (int j = i; j < num.size(); j++)\\n            {\\n                if (j > i && num[i] == \\'0\\')\\n                {\\n                   \\t// Avoid leading zeros in the number\\n                    break;\\n                }\\n\\n                long number = stol(num.substr(i, j - i + 1));\\n               \\t// Convert the substring to a long number\\n                string tempPath = num.substr(i, j - i + 1);\\n               \\t// Temporary substring representing the path we have traversed so far\\n\\n                if (i == 0)\\n                {\\n                   \\t// If we are on the first index of \\'num\\', start a new path\\n                    recursiveCall(j + 1, tempPath, number, number, num, target, result);\\n                }\\n                else\\n                {\\n                   \\t// Addition operation\\n                    recursiveCall(j + 1, sumPath + \\'+\\' + tempPath, sum + number, number, num, target, result);\\n                   \\t// Subtraction operation\\n                    recursiveCall(j + 1, sumPath + \\'-\\' + tempPath, sum - number, -number, num, target, result);\\n                   \\t// Multiplication operation\\n                    recursiveCall(j + 1, sumPath + \\'*\\' + tempPath, sum - prev + (prev *number), prev *number, num, target, result);\\n                   \\t// While doing the multiplication operation, we remove the previous operation and update it with the multiplication operation\\n                   \\t// This is done to follow the BODMAS rules for correct precedence\\n                }\\n            }\\n        }\\n\\n    vector<string> addOperators(string num, int target)\\n    {\\n        vector<string> result;\\n        recursiveCall(0, \"\", 0, 0, num, target, result);\\n    //recursiveCall(CurrentIndex,Path,sum,prev,num,target,result)\\n        return result;\\n    }\\n};\\n```\\n# Complexity\\n- Time complexity: $O(3^n)$ where `n is num size` and `3 are our operations` on each char of num.\\n\\n- Space complexity: $O(n^3)$ Worst Case Scenario where `n is num size`.\\n\\nIf you *like* \\uD83D\\uDC4D this solution do *upvote* \\u2B06\\uFE0F and if there is any *improvement or suggestion* do mention it in the *comment* section \\uD83D\\uDE0A.\\n\\n<p align=\"center\">\\n<img src=\"https://assets.leetcode.com/users/images/1b604300-df68-46aa-a267-71f38463bb89_1684820402.7869222.jpeg\" width=\\'350\\' alt=\"Upvote Image\">\\n</p>",
                "solutionTags": [
                    "C++",
                    "Math",
                    "String",
                    "Backtracking"
                ],
                "code": "```\\nclass Solution\\n{\\n   \\t1. Numbers ke beech mein operators dalna hain +,-,*.\\n   \\t2. Teeno ko baari baari se try karna hain jisse target achieve ho to backtracking use karenge hi.\\n   \\t3. Ab isme dhyan rakhna hain ki koi \\n   \\t- leading 0 na ho \\n   \\t- BODMAS rules are followed\\n   \\t4. Subtraction and Addition rules to aasani se follow ho jayenge\\n   \\t5. Multiplication mein hame previous operation ko hatana padega jaise agar prev operation sum that to vo operation hatake multiplication dalenge.\\n   \\t6. First index pe hain to aage bad jayenge \\n   \\t7. Recursive Calls mein we will keep track of index in num,sumPath,sum,prev.\\n\\n//==============================================================================================================================\\n    public:\\n        void recursiveCall(int i, string sumPath, long sum, long prev, string num, int target, vector<string> &result)\\n        {\\n           \\t// If we have reached the end of \\'num\\'\\n            if (i == num.size())\\n            {\\n                if (sum == target)\\n                {\\n                   \\t// If the target is achieved, add the path to the result\\n                    result.push_back(sumPath);\\n                }\\n                return;\\n            }\\n\\n            for (int j = i; j < num.size(); j++)\\n            {\\n                if (j > i && num[i] == \\'0\\')\\n                {\\n                   \\t// Avoid leading zeros in the number\\n                    break;\\n                }\\n\\n                long number = stol(num.substr(i, j - i + 1));\\n               \\t// Convert the substring to a long number\\n                string tempPath = num.substr(i, j - i + 1);\\n               \\t// Temporary substring representing the path we have traversed so far\\n\\n                if (i == 0)\\n                {\\n                   \\t// If we are on the first index of \\'num\\', start a new path\\n                    recursiveCall(j + 1, tempPath, number, number, num, target, result);\\n                }\\n                else\\n                {\\n                   \\t// Addition operation\\n                    recursiveCall(j + 1, sumPath + \\'+\\' + tempPath, sum + number, number, num, target, result);\\n                   \\t// Subtraction operation\\n                    recursiveCall(j + 1, sumPath + \\'-\\' + tempPath, sum - number, -number, num, target, result);\\n                   \\t// Multiplication operation\\n                    recursiveCall(j + 1, sumPath + \\'*\\' + tempPath, sum - prev + (prev *number), prev *number, num, target, result);\\n                   \\t// While doing the multiplication operation, we remove the previous operation and update it with the multiplication operation\\n                   \\t// This is done to follow the BODMAS rules for correct precedence\\n                }\\n            }\\n        }\\n\\n    vector<string> addOperators(string num, int target)\\n    {\\n        vector<string> result;\\n        recursiveCall(0, \"\", 0, 0, num, target, result);\\n    //recursiveCall(CurrentIndex,Path,sum,prev,num,target,result)\\n        return result;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1470847,
                "title": "c-dfs",
                "content": "```\\nclass Solution {\\npublic:\\n    vector<string> ans;\\n    void dfs(int i, string path, long resSoFar, long prevNum, const string &s, const int &target){\\n        if(i==s.size() and resSoFar==target){\\n            ans.push_back(path);\\n            return;\\n        }\\n        \\n        string curNumStr = \"\";\\n        long curNum=0;\\n        for(int j=i;j<s.size();++j){\\n            if(j>i and s[i]==\\'0\\') break; //leading zero not allowed\\n            //eg:105 --> 1*05=5(but 05 is now allowed)\\n            curNumStr.push_back(s[j]);\\n            curNum = (curNum*10)+(s[j]-\\'0\\');\\n            if(i==0){\\n                dfs(j+1, path+curNumStr, curNum, curNum, s, target);\\n            }else{\\n                dfs(j+1, path+\"+\"+curNumStr, resSoFar+curNum, curNum, s, target);\\n                dfs(j+1, path+\"-\"+curNumStr, resSoFar-curNum, -curNum, s, target);\\n                dfs(j+1, path+\"*\"+curNumStr, resSoFar-prevNum+(curNum*prevNum), prevNum*curNum, s, target);\\n            }\\n        }\\n        return;\\n    }\\n    \\n    vector<string> addOperators(string &num, int target) {\\n        dfs(0,\"\",0,0,num,target);\\n        return ans;\\n    }\\n};\\n```\\nPlease **UPVOTE**",
                "solutionTags": [
                    "C++",
                    "C",
                    "Depth-First Search"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<string> ans;\\n    void dfs(int i, string path, long resSoFar, long prevNum, const string &s, const int &target){\\n        if(i==s.size() and resSoFar==target){\\n            ans.push_back(path);\\n            return;\\n        }\\n        \\n        string curNumStr = \"\";\\n        long curNum=0;\\n        for(int j=i;j<s.size();++j){\\n            if(j>i and s[i]==\\'0\\') break; //leading zero not allowed\\n            //eg:105 --> 1*05=5(but 05 is now allowed)\\n            curNumStr.push_back(s[j]);\\n            curNum = (curNum*10)+(s[j]-\\'0\\');\\n            if(i==0){\\n                dfs(j+1, path+curNumStr, curNum, curNum, s, target);\\n            }else{\\n                dfs(j+1, path+\"+\"+curNumStr, resSoFar+curNum, curNum, s, target);\\n                dfs(j+1, path+\"-\"+curNumStr, resSoFar-curNum, -curNum, s, target);\\n                dfs(j+1, path+\"*\"+curNumStr, resSoFar-prevNum+(curNum*prevNum), prevNum*curNum, s, target);\\n            }\\n        }\\n        return;\\n    }\\n    \\n    vector<string> addOperators(string &num, int target) {\\n        dfs(0,\"\",0,0,num,target);\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 447209,
                "title": "clean-python3-backtracking-solution",
                "content": "```\\nclass Solution:\\n    def addOperators(self, num: str, target: int) -> List[str]:\\n        L = len(num)\\n        ans = set()\\n        \\n        def backtrack(i, total, last, expr):\\n            if i == L:\\n                if total == target:\\n                    ans.add(expr)\\n                return\\n            \\n            for j in range(i, L):\\n                n = int(num[i:j+1])\\n                if i == 0:\\n                    backtrack(j+1, n, n, str(n))\\n                else:\\n                    backtrack(j+1, total + n, n, expr + \\'+\\' + str(n))\\n                    backtrack(j+1, total - n, -n, expr + \\'-\\' + str(n))\\n                    backtrack(j+1, total - last + last * n, last * n, expr + \\'*\\' + str(n))\\n                if n == 0:\\n                    break\\n                    \\n        backtrack(0, 0, 0, \\'\\')\\n        return list(ans)\\n```",
                "solutionTags": [
                    "Python3",
                    "Backtracking"
                ],
                "code": "```\\nclass Solution:\\n    def addOperators(self, num: str, target: int) -> List[str]:\\n        L = len(num)\\n        ans = set()\\n        \\n        def backtrack(i, total, last, expr):\\n            if i == L:\\n                if total == target:\\n                    ans.add(expr)\\n                return\\n            \\n            for j in range(i, L):\\n                n = int(num[i:j+1])\\n                if i == 0:\\n                    backtrack(j+1, n, n, str(n))\\n                else:\\n                    backtrack(j+1, total + n, n, expr + \\'+\\' + str(n))\\n                    backtrack(j+1, total - n, -n, expr + \\'-\\' + str(n))\\n                    backtrack(j+1, total - last + last * n, last * n, expr + \\'*\\' + str(n))\\n                if n == 0:\\n                    break\\n                    \\n        backtrack(0, 0, 0, \\'\\')\\n        return list(ans)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 142357,
                "title": "backtracking",
                "content": "> Factors to be enumerated:\\n- num can be divided into arbitrary numbers, each number can be arbitrary length, represented by `num.substring(start, end)`\\n- preceding operator of each number can be  \\'+\\', \\'-\\',  or \\'x\\'\\n```\\nTake num = \"12\" for example, state tree is as blow:\\n root\\n   /\\\\\\n  1 12 --level 1\\n /|\\\\\\n+ - *\\n| | |\\n2 2 2 -- level 2\\n```\\n\\n> If we specify an `element = num.substring(start, end)`, with any possible operator in front, we get a new value. `start` increases in next round, the problem becomes smaller.\\n\\n> The base case is: start == num.length()\\n> The special case is: the first operand doesn\\'t have`preceding operator`\\n\\n> Note: if `preceding operator` is `*`, value of current expression should be re-evaluated by restoring the `difference` first\\n```\\nTake 1 + 2 * 3 for example,\\n  val = 1 + 2 = 3\\n  diff = 2\\n// when start = 2, i.e. we meet curNum = 3\\n  val = val - diff + diff * curNum\\n      = 3 - 2 + 2 * 3 = 7\\n```\\n****\\n```\\nclass Solution {\\n    private List<String> result;\\n    \\n    public List<String> addOperators(String num, int target) {\\n        result = new ArrayList<>();\\n        addOperators(num, target, 0, 0, \"\", 0);\\n        return result;\\n    }\\n    \\n    /* \\n    @param: num\\n    @param: target\\n    @param: start  start index in num\\n    @param: val  current value of expr\\n    @param: expr  expression\\n    @param: diff  difference\\n    */\\n    private void addOperators(String num, int target, int start, long val, String expr, long diff) {\\n        if (start == num.length()) {\\n            \\n            if (target == val) {\\n                result.add(expr);\\n            } \\n            return;\\n        }\\n        \\n        for (int end = start + 1; end <= num.length(); end++) {\\n            String cur = num.substring(start, end);\\n            \\n            if (cur.charAt(0) == \\'0\\' && cur.length() > 1) {\\n                // Invalid number\\n                continue;\\n            }\\n            \\n            long curNum = Long.parseLong(cur);\\n            \\n            if (start == 0) {\\n                // The first number\\n                addOperators(num, target, end, curNum, cur, curNum);\\n            } else {\\n                // + in front\\n                addOperators(num, target, end, val + curNum, expr + \"+\" + cur, curNum);\\n            \\n                // - in front\\n                addOperators(num, target, end, val - curNum, expr + \"-\" + cur, -curNum);\\n        \\n                // * in front\\n                addOperators(num, target, end, val - diff + diff * curNum, expr + \"*\" + cur, diff * curNum);\\n            }\\n        }\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nTake num = \"12\" for example, state tree is as blow:\\n root\\n   /\\\\\\n  1 12 --level 1\\n /|\\\\\\n+ - *\\n| | |\\n2 2 2 -- level 2\\n```\n```\\nTake 1 + 2 * 3 for example,\\n  val = 1 + 2 = 3\\n  diff = 2\\n// when start = 2, i.e. we meet curNum = 3\\n  val = val - diff + diff * curNum\\n      = 3 - 2 + 2 * 3 = 7\\n```\n```\\nclass Solution {\\n    private List<String> result;\\n    \\n    public List<String> addOperators(String num, int target) {\\n        result = new ArrayList<>();\\n        addOperators(num, target, 0, 0, \"\", 0);\\n        return result;\\n    }\\n    \\n    /* \\n    @param: num\\n    @param: target\\n    @param: start  start index in num\\n    @param: val  current value of expr\\n    @param: expr  expression\\n    @param: diff  difference\\n    */\\n    private void addOperators(String num, int target, int start, long val, String expr, long diff) {\\n        if (start == num.length()) {\\n            \\n            if (target == val) {\\n                result.add(expr);\\n            } \\n            return;\\n        }\\n        \\n        for (int end = start + 1; end <= num.length(); end++) {\\n            String cur = num.substring(start, end);\\n            \\n            if (cur.charAt(0) == \\'0\\' && cur.length() > 1) {\\n                // Invalid number\\n                continue;\\n            }\\n            \\n            long curNum = Long.parseLong(cur);\\n            \\n            if (start == 0) {\\n                // The first number\\n                addOperators(num, target, end, curNum, cur, curNum);\\n            } else {\\n                // + in front\\n                addOperators(num, target, end, val + curNum, expr + \"+\" + cur, curNum);\\n            \\n                // - in front\\n                addOperators(num, target, end, val - curNum, expr + \"-\" + cur, -curNum);\\n        \\n                // * in front\\n                addOperators(num, target, end, val - diff + diff * curNum, expr + \"*\" + cur, diff * curNum);\\n            }\\n        }\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 71984,
                "title": "ac-solution-c-short",
                "content": "    class Solution {\\n    public:\\n        vector<string> addOperators(string num, int target) {\\n    \\t\\tvector<string> ret;\\n    \\t\\tif (num.length() == 0) return ret;\\n    \\t\\thelp(num, target, ret, num[0] - '0', num.substr(0, 1), 1, 1);\\n    \\t\\treturn ret;\\n    \\t}\\n    \\n    \\tvoid help(const string num, int target, vector<string> & v, long long last, string s, int idx, int left) {\\n    \\t\\tif (target == last*left && idx == num.length())\\n    \\t\\t{\\n    \\t\\t\\tv.push_back(s);\\n    \\t\\t\\treturn;\\n    \\t\\t}\\n    \\t\\telse if (idx == num.length()) return;\\n    \\t\\telse {\\n    \\t\\t\\tif(last!=0) help(num, target, v, last * 10 + num[idx] - '0', s + num.substr(idx, 1), idx + 1, left);\\n    \\t\\t\\thelp(num, target, v, num[idx] - '0', s + '*' + num.substr(idx, 1), idx + 1, last*left);\\n    \\t\\t\\thelp(num, target - left*last, v, num[idx] - '0', s + '+' + num.substr(idx, 1), idx + 1, 1);\\n    \\t\\t\\thelp(num, target - left*last, v, num[idx] - '0', s + '-' + num.substr(idx, 1), idx + 1, -1);\\n    \\t\\t}\\n    \\t}\\n    };",
                "solutionTags": [
                    "C++"
                ],
                "code": "class Solution {\\n    public:\\n        vector<string> addOperators(string num, int target) {\\n    \\t\\tvector<string> ret;\\n    \\t\\tif (num.length() == 0) return ret;\\n    \\t\\thelp(num, target, ret, num[0] - '0', num.substr(0, 1), 1, 1);\\n    \\t\\treturn ret;\\n    \\t}",
                "codeTag": "Java"
            },
            {
                "id": 1830287,
                "title": "java-recursion-backtracking",
                "content": "Here i have used two recursions.\\n1) one recursion for splitting the string\\n2) one recusion for adding operators in between\\n```\\nclass Solution {\\n    String s;\\n    List<String>result;\\n    int target;\\n    public void operator(int i,int prev,long prod,long mid,String exp,List<Long>l){\\n        if(i==l.size()){\\n            if(mid+prod==target)\\n                result.add(exp);\\n            return;\\n        }\\n        if(prev==-1){\\n            operator(i+1,0,-1*l.get(i)*l.get(i-1),mid+l.get(i-1),exp+\"*\"+l.get(i),l);\\n        }else if(prev==1){\\n            operator(i+1,0,l.get(i)*l.get(i-1),mid-l.get(i-1),exp+\"*\"+l.get(i),l);\\n        }else{\\n            operator(i+1,0,prod*l.get(i),mid,exp+\"*\"+l.get(i),l);\\n        }\\n        operator(i+1,-1,0,mid+prod-l.get(i),exp+\"-\"+l.get(i),l);\\n        operator(i+1,1,0,mid+prod+l.get(i),exp+\"+\"+l.get(i),l);\\n    }\\n    public void rec(int in,List<Long>l){\\n        if(in==s.length()){\\n            operator(1,1,0,l.get(0),l.get(0)+\"\",l);\\n            return;\\n        }\\n        if(s.charAt(in)==\\'0\\'){\\n            l.add(0L);\\n            rec(in+1,l);\\n            l.remove(l.size()-1);\\n        }else{\\n            for(int i=in;i<s.length();i++){\\n                l.add(Long.parseLong(s.substring(in,i+1)));\\n                rec(i+1,l);\\n                l.remove(l.size()-1);\\n            }\\n        }\\n    }\\n    public List<String> addOperators(String num, int target) {\\n        result=new ArrayList<>();\\n        this.s=num;\\n        this.target=target;\\n        rec(0,new ArrayList<>(30));\\n        return result;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Backtracking",
                    "Recursion"
                ],
                "code": "```\\nclass Solution {\\n    String s;\\n    List<String>result;\\n    int target;\\n    public void operator(int i,int prev,long prod,long mid,String exp,List<Long>l){\\n        if(i==l.size()){\\n            if(mid+prod==target)\\n                result.add(exp);\\n            return;\\n        }\\n        if(prev==-1){\\n            operator(i+1,0,-1*l.get(i)*l.get(i-1),mid+l.get(i-1),exp+\"*\"+l.get(i),l);\\n        }else if(prev==1){\\n            operator(i+1,0,l.get(i)*l.get(i-1),mid-l.get(i-1),exp+\"*\"+l.get(i),l);\\n        }else{\\n            operator(i+1,0,prod*l.get(i),mid,exp+\"*\"+l.get(i),l);\\n        }\\n        operator(i+1,-1,0,mid+prod-l.get(i),exp+\"-\"+l.get(i),l);\\n        operator(i+1,1,0,mid+prod+l.get(i),exp+\"+\"+l.get(i),l);\\n    }\\n    public void rec(int in,List<Long>l){\\n        if(in==s.length()){\\n            operator(1,1,0,l.get(0),l.get(0)+\"\",l);\\n            return;\\n        }\\n        if(s.charAt(in)==\\'0\\'){\\n            l.add(0L);\\n            rec(in+1,l);\\n            l.remove(l.size()-1);\\n        }else{\\n            for(int i=in;i<s.length();i++){\\n                l.add(Long.parseLong(s.substring(in,i+1)));\\n                rec(i+1,l);\\n                l.remove(l.size()-1);\\n            }\\n        }\\n    }\\n    public List<String> addOperators(String num, int target) {\\n        result=new ArrayList<>();\\n        this.s=num;\\n        this.target=target;\\n        rec(0,new ArrayList<>(30));\\n        return result;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 71951,
                "title": "very-concise-c-solution",
                "content": "    class Solution {\\n    public:\\n        void DFS(string num, long sum, string path, int pos, long pre, int val)\\n        {\\n            pre = pre*10 + num[pos]-'0';\\n            if(pre > INT_MAX) return;\\n            if(sum+pre*val ==0 && pos== num.size()-1) result.push_back(path+num[pos]);\\n            if(pos== num.size()-1) return;\\n            if(pre) DFS(num, sum, path+num[pos], pos+1, pre, val);\\n            DFS(num, sum+pre*val, path+num[pos]+'+', pos+1, 0, 1);\\n            DFS(num, sum+pre*val, path+num[pos]+'-', pos+1, 0, -1);\\n            DFS(num, sum, path+num[pos]+'*', pos+1, 0, val*pre);\\n        }\\n    \\n        vector<string> addOperators(string num, int target) {\\n            if(num.size() ==0) return {};\\n            DFS(num, -target, \"\", 0, 0, 1);\\n            return result;\\n        }\\n    private:\\n        vector<string> result;\\n    };",
                "solutionTags": [],
                "code": "class Solution {\\n    public:\\n        void DFS(string num, long sum, string path, int pos, long pre, int val)\\n        {\\n            pre = pre*10 + num[pos]-'0';\\n            if(pre > INT_MAX) return;\\n            if(sum+pre*val ==0 && pos== num.size()-1) result.push_back(path+num[pos]);\\n            if(pos== num.size()-1) return;\\n            if(pre) DFS(num, sum, path+num[pos], pos+1, pre, val);\\n            DFS(num, sum+pre*val, path+num[pos]+'+', pos+1, 0, 1);\\n            DFS(num, sum+pre*val, path+num[pos]+'-', pos+1, 0, -1);\\n            DFS(num, sum, path+num[pos]+'*', pos+1, 0, val*pre);\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 71986,
                "title": "17-line-accepted-c-dfs-solution",
                "content": "    public IList<string> AddOperators(string num, int target) {\\n        IList<string> result = new List<string>();\\n        dfs(result, \"\", 0, 0, num, target);\\n        return result;\\n    }\\n    private void dfs(IList<string> result, string curStr, long curSum, long curHead, string curNum, long target){\\n        if(curNum.Length == 0 && target - curSum - curHead == 0) result.Add(curStr);\\n        for(int i = 1; i < 11 && i <= curNum.Length; i++){\\n            string strNum = curNum.Substring(0, i); long lNum = Convert.ToInt64(strNum);\\n            if(lNum > int.MaxValue || curHead > int.MaxValue) break;\\n            if(curStr.Length == 0) dfs(result, strNum, 0, lNum, curNum.Substring(i), target);\\n            else{\\n                dfs(result, curStr + \"*\" + strNum, curSum, curHead * lNum, curNum.Substring(i), target);\\n                dfs(result, curStr + \"+\" + strNum, curSum + curHead, lNum, curNum.Substring(i), target);\\n                dfs(result, curStr + \"-\" + strNum, curSum + curHead, -lNum, curNum.Substring(i), target);\\n            }\\n            if(lNum == 0) break; // avoid result of \"000\"/\"012\" etc\\n        }\\n    }\\n\\nThe first version accepted here.\\n\\n    public IList<string> AddOperators(string num, int target) {\\n        IList<long> curList = new List<long>();\\n        IList<string> result = new List<string>();\\n        if(num.Length == 0) return result;\\n        for(int i = 1; i < 11 && i <= num.Length; i++){\\n            string curStr = num.Substring(0, i);\\n            if(Convert.ToInt64(curStr) <= int.MaxValue){\\n                curList.Add(Convert.ToInt64(curStr));\\n                dfs(result, curStr, curList, num.Substring(i), target);\\n                curList.RemoveAt(curList.Count - 1);\\n            }\\n            if(curStr == \"0\") break;\\n        }\\n        return result;\\n    }\\n    \\n    private void dfs(IList<string> result, string curStr, IList<long> curList, string curNum, long target){\\n        if(curNum.Length == 0){\\n            foreach(int i in curList) target -= i;\\n            if(target == 0) result.Add(curStr);\\n            return;\\n        }\\n        for(int i = 1; i < 11 && i <= curNum.Length; i++){\\n            string tmpNum = curNum.Substring(0, i);\\n            long lNum = Convert.ToInt64(tmpNum);\\n            if(lNum <= int.MaxValue){\\n                long tmp = curList[curList.Count - 1];\\n                curList[curList.Count - 1] *= lNum;\\n                if(Math.Abs(curList[curList.Count - 1]) <= int.MaxValue)\\n                    dfs(result, curStr + \"*\" + tmpNum, curList, curNum.Substring(i), target);\\n                curList[curList.Count - 1] = tmp;\\n\\n                curList.Add(lNum);\\n                dfs(result, curStr + \"+\" + tmpNum, curList, curNum.Substring(i), target);\\n                curList[curList.Count - 1] = -lNum;\\n                dfs(result, curStr + \"-\" + tmpNum, curList, curNum.Substring(i), target);\\n                curList.RemoveAt(curList.Count - 1);\\n            }\\n            if(lNum == 0) break;\\n        }\\n    }",
                "solutionTags": [],
                "code": "    public IList<string> AddOperators(string num, int target) {\\n        IList<string> result = new List<string>();\\n        dfs(result, \"\", 0, 0, num, target);\\n        return result;\\n    }\\n    private void dfs(IList<string> result, string curStr, long curSum, long curHead, string curNum, long target){\\n        if(curNum.Length == 0 && target - curSum - curHead == 0) result.Add(curStr);\\n        for(int i = 1; i < 11 && i <= curNum.Length; i++){\\n            string strNum = curNum.Substring(0, i); long lNum = Convert.ToInt64(strNum);\\n            if(lNum > int.MaxValue || curHead > int.MaxValue) break;\\n            if(curStr.Length == 0) dfs(result, strNum, 0, lNum, curNum.Substring(i), target);\\n            else{\\n                dfs(result, curStr + \"*\" + strNum, curSum, curHead * lNum, curNum.Substring(i), target);\\n                dfs(result, curStr + \"+\" + strNum, curSum + curHead, lNum, curNum.Substring(i), target);\\n                dfs(result, curStr + \"-\" + strNum, curSum + curHead, -lNum, curNum.Substring(i), target);\\n            }\\n            if(lNum == 0) break; // avoid result of \"000\"/\"012\" etc\\n        }\\n    }\\n\\nThe first version accepted here.\\n\\n    public IList<string> AddOperators(string num, int target) {\\n        IList<long> curList = new List<long>();\\n        IList<string> result = new List<string>();\\n        if(num.Length == 0) return result;\\n        for(int i = 1; i < 11 && i <= num.Length; i++){\\n            string curStr = num.Substring(0, i);\\n            if(Convert.ToInt64(curStr) <= int.MaxValue){\\n                curList.Add(Convert.ToInt64(curStr));\\n                dfs(result, curStr, curList, num.Substring(i), target);\\n                curList.RemoveAt(curList.Count - 1);\\n            }\\n            if(curStr == \"0\") break;\\n        }\\n        return result;\\n    }\\n    \\n    private void dfs(IList<string> result, string curStr, IList<long> curList, string curNum, long target){\\n        if(curNum.Length == 0){\\n            foreach(int i in curList) target -= i;\\n            if(target == 0) result.Add(curStr);\\n            return;\\n        }\\n        for(int i = 1; i < 11 && i <= curNum.Length; i++){\\n            string tmpNum = curNum.Substring(0, i);\\n            long lNum = Convert.ToInt64(tmpNum);\\n            if(lNum <= int.MaxValue){\\n                long tmp = curList[curList.Count - 1];\\n                curList[curList.Count - 1] *= lNum;\\n                if(Math.Abs(curList[curList.Count - 1]) <= int.MaxValue)\\n                    dfs(result, curStr + \"*\" + tmpNum, curList, curNum.Substring(i), target);\\n                curList[curList.Count - 1] = tmp;\\n\\n                curList.Add(lNum);\\n                dfs(result, curStr + \"+\" + tmpNum, curList, curNum.Substring(i), target);\\n                curList[curList.Count - 1] = -lNum;\\n                dfs(result, curStr + \"-\" + tmpNum, curList, curNum.Substring(i), target);\\n                curList.RemoveAt(curList.Count - 1);\\n            }\\n            if(lNum == 0) break;\\n        }\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 1482147,
                "title": "java-backtracking-template-explained",
                "content": "**Idea:**\\n* Use backtracking to generate all possibilities\\n* If start = 0, there is no operand before current and no operation can be done with single operand, so just append to expression\\n* Else form the expression and calculate on the fly\\n* Multiplication is a special case because it has higher precedence over `+/-`. So subtract the previous number from the value of expression yet, then add the result to the product of previousNumber and current\\n* Calculate expression on the fly. Calculating after the genertion of complete expression is inefficient.\\n* Edge cases: \\n\\t* take` long` for calculations as the result can overflow\\n\\t* Only 0 can have a leading zero, every other number with a leading zero would be invalid (the break case)\\n\\n![image](https://assets.leetcode.com/users/images/e3298cec-e3b2-47a4-bd67-7cd9a7abcf2e_1632447794.322304.png)\\n**T/S:** O(n4\\u207F)/O(n), where n = size(num)\\n```\\npublic List<String> addOperators(String num, int target) {\\n\\tvar result = new ArrayList<String>();\\n\\taddOperators(num, target, 0, result, \"\", 0, 0);\\n\\treturn result;\\n}\\n\\nprivate void addOperators(String num, int target, int start, List<String> result, String expression, long valueYet, long previousNumber) {\\n\\tif (start == num.length() && valueYet == target)\\n\\t\\tresult.add(expression);\\n\\telse\\n\\t\\t// for each choice\\n\\t\\tfor (var i = start; i < num.length(); i++) {\\n\\t\\t\\tif (i != start && num.charAt(start) == \\'0\\')\\n\\t\\t\\t\\tbreak;\\n\\t\\t\\tvar current = Long.parseLong(num.substring(start, i + 1));\\n\\t\\n\\t\\t\\t// choose-explore-unchoose\\n\\t\\t\\tif (start == 0) {\\n\\t\\t\\t\\taddOperators(num, target, i + 1, result, expression + current, current, current);\\n\\t\\t\\t} else {\\n\\t\\t\\t\\taddOperators(num, target, i + 1, result, expression + \"+\" + current, valueYet + current, current);\\n\\t\\t\\t\\taddOperators(num, target, i + 1, result, expression + \"-\" + current, valueYet - current, -current);\\n\\t\\t\\t\\t\\n\\t\\t\\t\\tvar newValue = (valueYet - previousNumber) + (previousNumber * current);\\n\\t\\t\\t\\taddOperators(num, target, i + 1, result, expression + \"*\" + current, newValue, previousNumber * current);\\n\\t\\t\\t}\\n\\t\\t}\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Backtracking"
                ],
                "code": "```\\npublic List<String> addOperators(String num, int target) {\\n\\tvar result = new ArrayList<String>();\\n\\taddOperators(num, target, 0, result, \"\", 0, 0);\\n\\treturn result;\\n}\\n\\nprivate void addOperators(String num, int target, int start, List<String> result, String expression, long valueYet, long previousNumber) {\\n\\tif (start == num.length() && valueYet == target)\\n\\t\\tresult.add(expression);\\n\\telse\\n\\t\\t// for each choice\\n\\t\\tfor (var i = start; i < num.length(); i++) {\\n\\t\\t\\tif (i != start && num.charAt(start) == \\'0\\')\\n\\t\\t\\t\\tbreak;\\n\\t\\t\\tvar current = Long.parseLong(num.substring(start, i + 1));\\n\\t\\n\\t\\t\\t// choose-explore-unchoose\\n\\t\\t\\tif (start == 0) {\\n\\t\\t\\t\\taddOperators(num, target, i + 1, result, expression + current, current, current);\\n\\t\\t\\t} else {\\n\\t\\t\\t\\taddOperators(num, target, i + 1, result, expression + \"+\" + current, valueYet + current, current);\\n\\t\\t\\t\\taddOperators(num, target, i + 1, result, expression + \"-\" + current, valueYet - current, -current);\\n\\t\\t\\t\\t\\n\\t\\t\\t\\tvar newValue = (valueYet - previousNumber) + (previousNumber * current);\\n\\t\\t\\t\\taddOperators(num, target, i + 1, result, expression + \"*\" + current, newValue, previousNumber * current);\\n\\t\\t\\t}\\n\\t\\t}\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1473359,
                "title": "c-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    vector<string> expressions;\\n    vector<string> addOperators(string num, int target) {\\n        dfs(num , target , 0 , \"\" , 0 , 0);\\n        return expressions;\\n    }\\n    void dfs(string &num , int target , int index , string path , long int res , long int prev)\\n    {\\n        if(index == num.size() and res == target)\\n        {\\n            expressions.push_back(path);\\n            return;\\n        }\\n        \\n        long int number = 0;\\n        string sub_string = \"\";\\n        \\n        for(int i = index ; i < num.size() ; ++i)\\n        {\\n            sub_string += num[i];\\n            number = (number * 10) + num[i] - \\'0\\';\\n            \\n            if(sub_string.size() > 1 and sub_string[0] == \\'0\\') // skipping numbers with leading 0\\'s\\n                break;\\n            \\n            if(index == 0) // first number of expression is picked without operator\\n            {\\n                dfs(num , target , i + 1 , sub_string , number, number);\\n            }\\n            else\\n            {\\n                // (1) + operation inserted\\n                dfs(num , target , i + 1 , path  + \"+\" + sub_string , res  + number , number);\\n                    \\n                // (2) - operation inserted\\n                dfs(num , target , i + 1 , path + \"-\" + sub_string , res  - number , -number);\\n                \\n                // (3) * operation inserted\\n                dfs(num , target , i + 1 , path + \"*\" + sub_string , (res - prev)  + (prev * number) , prev * number);\\n            }\\n        }\\n            \\n    }\\n    \\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<string> expressions;\\n    vector<string> addOperators(string num, int target) {\\n        dfs(num , target , 0 , \"\" , 0 , 0);\\n        return expressions;\\n    }\\n    void dfs(string &num , int target , int index , string path , long int res , long int prev)\\n    {\\n        if(index == num.size() and res == target)\\n        {\\n            expressions.push_back(path);\\n            return;\\n        }\\n        \\n        long int number = 0;\\n        string sub_string = \"\";\\n        \\n        for(int i = index ; i < num.size() ; ++i)\\n        {\\n            sub_string += num[i];\\n            number = (number * 10) + num[i] - \\'0\\';\\n            \\n            if(sub_string.size() > 1 and sub_string[0] == \\'0\\') // skipping numbers with leading 0\\'s\\n                break;\\n            \\n            if(index == 0) // first number of expression is picked without operator\\n            {\\n                dfs(num , target , i + 1 , sub_string , number, number);\\n            }\\n            else\\n            {\\n                // (1) + operation inserted\\n                dfs(num , target , i + 1 , path  + \"+\" + sub_string , res  + number , number);\\n                    \\n                // (2) - operation inserted\\n                dfs(num , target , i + 1 , path + \"-\" + sub_string , res  - number , -number);\\n                \\n                // (3) * operation inserted\\n                dfs(num , target , i + 1 , path + \"*\" + sub_string , (res - prev)  + (prev * number) , prev * number);\\n            }\\n        }\\n            \\n    }\\n    \\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 893132,
                "title": "faster-than-100-twice-optimization-explanation",
                "content": "Inspired by some great writers and code, \\nthis post is approximately faster than \\nprevious fastest DFS by 4x and previous fastest BFS by 2x. \\nIt makes time complexity from 4^(N) to 4^1/2(N). [(some ideas and analysis from MaskRay)](https://leetcode.com/problems/expression-add-operators/discuss/71975/Some-thoughts-on-the-algorithm%3A-SLR(1)-and-optimization%3A-meet-in-the-middle-(-spatial-data-structure))\\n\\nI\\'d like to share the surprising result and ideas to inspire others in simple words. \\n\\nThe basic solution is using DFS to tracking the results of each operator because the given string is not long. \\nMost writers\\' code is very short and quite understandable. \\nI suppose you have been very familiar with it. \\n\\nBut if the string is longer than current and old fashion can\\'t work well, \\nwe finally must optimize it. \\nMaybe you have found the runtime distribution is a wide range. (40ms ~7000+)\\n\\nIn short, \\nwe can ***use DP and symmetry as possible.***\\n\\nAs some posts mentioned, we can ***divide the string into first half and second half*** \\nbecause we can use operator + and -  to combine these two parts\\' results and decrease the search space. \\nIn other words, the results of the first half +(-) second half must be the target.\\nFor example, \\n(1+2) **+ (3-1)** = 5 or (1+2) **- (3-1)** = 5 is true.\\n\\nBesides, if we use DP meanwhile, it also can help ***combine some found results first.***\\n\\nAfter some attemps, I found BFS is more efficient in this task than DFS. (although using DFS is easier)\\nAt first look, I also think DFS is better. But when I tried to optimize, I found \\n***DFS is harder to deal with split concisely and manipulate index than BFS***, \\nespecially we need to create a DP table by indexes and split.\\n\\nAs for DP table, we reuse the same main function\\nto ***extract the second half\\'s results from the middle to the end*** for later check and combination. \\nAnd we ***only need to extract the results of positive +\"string\"*** because the negative -\"string\" is reverse of +\"string\".\\nFor example, \\n(1+2) **+ (3-1+2)**  and (1+2) **- (3-1+2)**, \\nbold parts\\' values are respectively +4 and -4, but combinations are the same.\\n\\nBesides, we also can use multiplication \\nbecause ***known partial result + current possible maximal operation(multiplication) must be greater than target***, \\notherwise we can\\'t use operator + or - to achieve the target afterwards. \\nThis can help us decrease the search space a lot.\\n\\nCode with clear comments step by step as below.\\nDP table, **preview**, is a nested hashmap, \\nstoring **{key string: { combination value: possible combination}}**\\n\\n```\\nclass Solution(object): # BFS, best 40 ms, most posts\\' results are around 700~6000+ ms\\n\\n    def addOperators(self, num, target):\\n        if not num: return []\\n\\n        # set the boolean for reusing the func(main search and creating DP)\\n        def BFS(num, cutEdge = False):\\n            firstValue = int(num[0])\\n            # (pre-result, pre-Sum, pre-operation, pre-Number\\'s value)\\n            queue = [(num[0], firstValue, firstValue, firstValue)]\\n\\n            for i, c in enumerate(num):\\n                if i == 0: continue\\n                newQ, v = [], int(c)\\n                for preString, preSum, preOP, preNum in queue:\\n                    # combine with previous num without operator\\n                    if preString[-1] != \\'0\\' or (len(preString) > 1 and preString[-2] not in (\\'-\\', \\'+\\', \\'*\\')):\\n                    # preOP / preNum * v: extract pre-operation to operate with current value\\n                        curOP = preOP * 10 + preOP / preNum * v\\n                        curSum = preSum - preOP + curOP\\n                        curVal = preNum * 10 + v\\n                        newQ.append([preString + c, curSum, curOP, curVal])\\n\\n                    # if current maximal possible num is less than remaining sum,\\n                    # there\\'s no result because only multiplication can create maximal num.\\n                    # use this line when main search, not creating DP\\n                    if not cutEdge and max(1, abs(preOP)) * int(num[i:]) < abs(target - preSum):\\n                        continue\\n\\n                    # new search of \"*\", \"+\", \"-\"\\n                    newQ.append([preString + \\'*\\' + c, preSum - preOP + preOP * v, preOP * v, v])\\n                    if num[i:] not in preview:\\n                        newQ.append([preString + \\'+\\' + c, preSum + v, v, v])   \\n                        newQ.append([preString + \\'-\\' + c, preSum - v, -v, v])\\n                    \\n                    # check and combine second part\\'s results of \"+\" and \"-\" when main search\\n                    if not cutEdge and i >= len(num)-half:\\n                        restSum = target - preSum\\n                        # if able to achieve target, + second part\\'s result directly\\n                        if restSum in preview[num[i:]]:\\n                            for parse in preview[num[i:]][restSum]:\\n                                parseResult.append(preString + \"+\" + parse)\\n                        # we can reverse the results in DP for \"-\",\\n                        if -restSum in preview[num[i:]]:\\n                            for parse in preview[num[i:]][-restSum]:\\n                                parse = parse.replace(\"-\", \" \").replace(\"+\", \"-\").replace(\" \", \"+\")\\n                                parseResult.append(preString + \"-\" + parse)\\n                queue = newQ\\n\\n            # collect cut edge results(DP) \\n            if cutEdge:\\n                result = defaultdict(list)\\n                for element in queue:\\n                    result[element[1]].append(element[0])\\n                return result\\n\\n            # main BFS\\'s result\\n            else: return queue         \\n        \\n        # cut string into two halves for preview(DP table)\\n        # { key string: { combination value: possible combination} } \\n        preview = {} \\n        half = len(num)//2 + 1\\n        for i in range(-half, 0):\\n            preview[num[i:]] = BFS(num[i:], True)\\n\\n        parseResult = [] \\n        return [e[0] for e in BFS(num) if e[1] == target] + parseResult\\n```\\nSome ideas are also from [bairongdong1](https://leetcode.com/problems/expression-add-operators/discuss/703797/Python-beat-100-84ms)\\n\\nThe method is similar to bidirectional BFS and works better than DFS \\nbecause we can use the partial results in the middle of the string to largely decrease the search space.\\n\\nIf we have concern about the memory, \\nwe also can adapt the DP preview, \\njust store the combinations\\' values, not including combinations. \\nIt still works well.\\n\\nBy the way,\\nSome people used eval() with string.\\nBut that\\'s less helpful.\\n```\\neval(\"1+2+3\")\\n100000 loops, best of 3: 4.6 \\xB5s per loop\\nint(\"1\")+int(\"2\")+int(\"3\")\\n1000000 loops, best of 3: 474 ns per loop\\n```\\n\\nWelcome suggestion, question and comments.\\nIf helpful, ***please upvote! Thanks a lot!***",
                "solutionTags": [],
                "code": "```\\nclass Solution(object): # BFS, best 40 ms, most posts\\' results are around 700~6000+ ms\\n\\n    def addOperators(self, num, target):\\n        if not num: return []\\n\\n        # set the boolean for reusing the func(main search and creating DP)\\n        def BFS(num, cutEdge = False):\\n            firstValue = int(num[0])\\n            # (pre-result, pre-Sum, pre-operation, pre-Number\\'s value)\\n            queue = [(num[0], firstValue, firstValue, firstValue)]\\n\\n            for i, c in enumerate(num):\\n                if i == 0: continue\\n                newQ, v = [], int(c)\\n                for preString, preSum, preOP, preNum in queue:\\n                    # combine with previous num without operator\\n                    if preString[-1] != \\'0\\' or (len(preString) > 1 and preString[-2] not in (\\'-\\', \\'+\\', \\'*\\')):\\n                    # preOP / preNum * v: extract pre-operation to operate with current value\\n                        curOP = preOP * 10 + preOP / preNum * v\\n                        curSum = preSum - preOP + curOP\\n                        curVal = preNum * 10 + v\\n                        newQ.append([preString + c, curSum, curOP, curVal])\\n\\n                    # if current maximal possible num is less than remaining sum,\\n                    # there\\'s no result because only multiplication can create maximal num.\\n                    # use this line when main search, not creating DP\\n                    if not cutEdge and max(1, abs(preOP)) * int(num[i:]) < abs(target - preSum):\\n                        continue\\n\\n                    # new search of \"*\", \"+\", \"-\"\\n                    newQ.append([preString + \\'*\\' + c, preSum - preOP + preOP * v, preOP * v, v])\\n                    if num[i:] not in preview:\\n                        newQ.append([preString + \\'+\\' + c, preSum + v, v, v])   \\n                        newQ.append([preString + \\'-\\' + c, preSum - v, -v, v])\\n                    \\n                    # check and combine second part\\'s results of \"+\" and \"-\" when main search\\n                    if not cutEdge and i >= len(num)-half:\\n                        restSum = target - preSum\\n                        # if able to achieve target, + second part\\'s result directly\\n                        if restSum in preview[num[i:]]:\\n                            for parse in preview[num[i:]][restSum]:\\n                                parseResult.append(preString + \"+\" + parse)\\n                        # we can reverse the results in DP for \"-\",\\n                        if -restSum in preview[num[i:]]:\\n                            for parse in preview[num[i:]][-restSum]:\\n                                parse = parse.replace(\"-\", \" \").replace(\"+\", \"-\").replace(\" \", \"+\")\\n                                parseResult.append(preString + \"-\" + parse)\\n                queue = newQ\\n\\n            # collect cut edge results(DP) \\n            if cutEdge:\\n                result = defaultdict(list)\\n                for element in queue:\\n                    result[element[1]].append(element[0])\\n                return result\\n\\n            # main BFS\\'s result\\n            else: return queue         \\n        \\n        # cut string into two halves for preview(DP table)\\n        # { key string: { combination value: possible combination} } \\n        preview = {} \\n        half = len(num)//2 + 1\\n        for i in range(-half, 0):\\n            preview[num[i:]] = BFS(num[i:], True)\\n\\n        parseResult = [] \\n        return [e[0] for e in BFS(num) if e[1] == target] + parseResult\\n```\n```\\neval(\"1+2+3\")\\n100000 loops, best of 3: 4.6 \\xB5s per loop\\nint(\"1\")+int(\"2\")+int(\"3\")\\n1000000 loops, best of 3: 474 ns per loop\\n```",
                "codeTag": "Java"
            },
            {
                "id": 230225,
                "title": "python-solution",
                "content": "Time complexity: `O(n^2*3^n)`, space complexity: `O(n^2*3^n)`.\\n\\n```\\nclass Solution:\\n    def addOperators(self, num, target):\\n        \"\"\"\\n        :type num: str\\n        :type target: int\\n        :rtype: List[str]\\n        \"\"\"\\n        def recurse(idx, val, prev_val, ops):\\n            if idx == len(num):\\n                if val == target:\\n                    res.append(\"\".join(ops))\\n            else:\\n                curr_val = 0\\n                for i in range(idx, len(num)):\\n                    curr_val = 10*curr_val + int(num[i])\\n                    if idx == 0:\\n                        recurse(i+1, curr_val, curr_val, ops+[str(curr_val)])\\n                    else:\\n                        v = val - prev_val\\n                        recurse(i+1, v+prev_val*curr_val, prev_val*curr_val, ops+[\"*\"+str(curr_val)])\\n                        recurse(i+1, val+curr_val, curr_val, ops+[\"+\"+str(curr_val)])\\n                        recurse(i+1, val-curr_val, -curr_val, ops+[\"-\"+str(curr_val)])\\n                    if num[idx] == \"0\":\\n                        break\\n        res = []\\n        recurse(0, 0, 0, [])\\n        return res\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def addOperators(self, num, target):\\n        \"\"\"\\n        :type num: str\\n        :type target: int\\n        :rtype: List[str]\\n        \"\"\"\\n        def recurse(idx, val, prev_val, ops):\\n            if idx == len(num):\\n                if val == target:\\n                    res.append(\"\".join(ops))\\n            else:\\n                curr_val = 0\\n                for i in range(idx, len(num)):\\n                    curr_val = 10*curr_val + int(num[i])\\n                    if idx == 0:\\n                        recurse(i+1, curr_val, curr_val, ops+[str(curr_val)])\\n                    else:\\n                        v = val - prev_val\\n                        recurse(i+1, v+prev_val*curr_val, prev_val*curr_val, ops+[\"*\"+str(curr_val)])\\n                        recurse(i+1, val+curr_val, curr_val, ops+[\"+\"+str(curr_val)])\\n                        recurse(i+1, val-curr_val, -curr_val, ops+[\"-\"+str(curr_val)])\\n                    if num[idx] == \"0\":\\n                        break\\n        res = []\\n        recurse(0, 0, 0, [])\\n        return res\\n```",
                "codeTag": "Java"
            },
            {
                "id": 71899,
                "title": "swift-implementation-with-docs-and-full-comments",
                "content": "This is a variation on some solutions in this forum but written in Swift. This problem has a large number of permutations which I attempt to capture in the comments.\\n```\\nclass Solution {\\n    \\n    // Recursion \\n    // - Parameters:\\n    //     - results: String array of valid math operation strings to return\\n    //     - result: String with current operation string being constructed\\n    //     - digits: Int array with the individual digits\\n    //     - target: Int with the target operation final value\\n    //     - offset: Current position in the digits array\\n    //     - mr:     MR like a calculator holding the result of the last operation\\n    //     - prior:  Special param to help multiplication which is backward looking due to order of operations (BOMDAS)\\n    func dfs(_ results: inout [String], _ result: String, _ digits: [Int], _ target: Int, _ offset: Int, _ mr: Int, _ prior: Int) {\\n        \\n        // if we're evaluated all the digits, we're at the end of the recrusion\\n        if offset == digits.count {\\n            // save the result string if the MR value equal to our target\\n            if target == mr {\\n                results.append(result)\\n            }\\n            return\\n        }\\n        \\n        // walk the down digit array from the current offset\\n        for i in offset..<digits.count {\\n            // zeros are handled slightly differently\\n            // to account for 10, if we see a zero but we're not at the\\n            // current offset, we need to treat it like a 10\\n            // (the question is vague about this but it's in the examples)\\n            if i != offset && digits[offset] == 0 {\\n                break\\n            }\\n\\n            // build the current number from the digits\\n            var val = 0\\n            // i+1 is not bounded, so make sure we\\n            // don't exceed the digit array bounds\\n            for x in offset..<i+1 where x < digits.count {\\n                // increase the existing value of val by a power of 10 on each iteration\\n                val *= 10\\n                val += digits[x]\\n            }\\n            \\n            // if we're at the first digit, there's no operation possible\\n            if offset == 0 {\\n                // the first digit is simple, initialize the string and MR is digit\\n                dfs(&results, result + String(val), digits, target, i + 1, val, val)\\n            } else {\\n                // addition: add the digit to the string and add it to MR, track it in case we mul next\\n                dfs(&results, result + \"+\" + String(val), digits, target, i + 1, mr + val, val)\\n                // substraction: add the digit to the string and minus it from MR, track it in case we mul next\\n                dfs(&results, result + \"-\" + String(val), digits, target, i + 1, mr - val, -val)\\n                // multiplication: add the digit to the string, but we have an order of operations to deal with\\n                // BOMDAS, so minus the prior value and add the multiplied value to MR, track the multiplied value in prior\\n                dfs(&results, result + \"*\" + String(val), digits, target, i + 1, mr - prior + (prior * val), prior * val)\\n            }\\n        }\\n    }\\n    \\n    // the problem description is a bit vague, but we don't just\\n    // care about single digits, it's all possible numbers comprised \\n    // of those digits, this greatly increases the number of permutations\\n    // to O(n^2)\\n    func addOperators(_ num: String, _ target: Int) -> [String] {\\n        var results: [String] = []\\n        \\n        // ensure we have evaluatble input\\n        if num.count == 0 {\\n            return results\\n        }\\n        \\n        // split the string into an array of digits\\n        let digits = Array(num).map({Int(String($0))!})\\n        \\n        // recurse from index zero\\n        dfs(&results, \"\", digits, target, 0, 0, 0)\\n        \\n        return results\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    \\n    // Recursion \\n    // - Parameters:\\n    //     - results: String array of valid math operation strings to return\\n    //     - result: String with current operation string being constructed\\n    //     - digits: Int array with the individual digits\\n    //     - target: Int with the target operation final value\\n    //     - offset: Current position in the digits array\\n    //     - mr:     MR like a calculator holding the result of the last operation\\n    //     - prior:  Special param to help multiplication which is backward looking due to order of operations (BOMDAS)\\n    func dfs(_ results: inout [String], _ result: String, _ digits: [Int], _ target: Int, _ offset: Int, _ mr: Int, _ prior: Int) {\\n        \\n        // if we're evaluated all the digits, we're at the end of the recrusion\\n        if offset == digits.count {\\n            // save the result string if the MR value equal to our target\\n            if target == mr {\\n                results.append(result)\\n            }\\n            return\\n        }\\n        \\n        // walk the down digit array from the current offset\\n        for i in offset..<digits.count {\\n            // zeros are handled slightly differently\\n            // to account for 10, if we see a zero but we're not at the\\n            // current offset, we need to treat it like a 10\\n            // (the question is vague about this but it's in the examples)\\n            if i != offset && digits[offset] == 0 {\\n                break\\n            }\\n\\n            // build the current number from the digits\\n            var val = 0\\n            // i+1 is not bounded, so make sure we\\n            // don't exceed the digit array bounds\\n            for x in offset..<i+1 where x < digits.count {\\n                // increase the existing value of val by a power of 10 on each iteration\\n                val *= 10\\n                val += digits[x]\\n            }\\n            \\n            // if we're at the first digit, there's no operation possible\\n            if offset == 0 {\\n                // the first digit is simple, initialize the string and MR is digit\\n                dfs(&results, result + String(val), digits, target, i + 1, val, val)\\n            } else {\\n                // addition: add the digit to the string and add it to MR, track it in case we mul next\\n                dfs(&results, result + \"+\" + String(val), digits, target, i + 1, mr + val, val)\\n                // substraction: add the digit to the string and minus it from MR, track it in case we mul next\\n                dfs(&results, result + \"-\" + String(val), digits, target, i + 1, mr - val, -val)\\n                // multiplication: add the digit to the string, but we have an order of operations to deal with\\n                // BOMDAS, so minus the prior value and add the multiplied value to MR, track the multiplied value in prior\\n                dfs(&results, result + \"*\" + String(val), digits, target, i + 1, mr - prior + (prior * val), prior * val)\\n            }\\n        }\\n    }\\n    \\n    // the problem description is a bit vague, but we don't just\\n    // care about single digits, it's all possible numbers comprised \\n    // of those digits, this greatly increases the number of permutations\\n    // to O(n^2)\\n    func addOperators(_ num: String, _ target: Int) -> [String] {\\n        var results: [String] = []\\n        \\n        // ensure we have evaluatble input\\n        if num.count == 0 {\\n            return results\\n        }\\n        \\n        // split the string into an array of digits\\n        let digits = Array(num).map({Int(String($0))!})\\n        \\n        // recurse from index zero\\n        dfs(&results, \"\", digits, target, 0, 0, 0)\\n        \\n        return results\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 71960,
                "title": "shortest-c-solution",
                "content": "    //cur: current position in s\\n    //cnum: number formed by s[position of previous op...cur]\\n    //num: result of a1*a2*a3... before previous op\\n    //res: result of previous calculation, not including num\\n    //str: current string\\n    //s:   original string\\n    //when we add an op at cur:\\n    //\\t\\t1) +: num=1, res=res+num*cnum\\n    //\\t\\t2) -: num=-1, res=res+num*cnum\\n    //\\t\\t3) *: num=num*cnum, res=res\\n\\n    class Solution {\\n    public:\\n    \\tvector<string>ans;\\n    \\tvoid dfs(int cur, long long cnum, long long num, long long res, string str, string s){\\n    \\t\\tcnum = cnum * 10 + s[cur] - '0';\\n    \\t\\tif (cur+1 == s.size()){\\n    \\t\\t\\tif (res + num*cnum == 0)ans.push_back(str + s[cur]);\\n    \\t\\t\\treturn;\\n    \\t\\t}\\n    \\t\\tif (cnum != 0)dfs(cur + 1, cnum, num, res, str + s[cur], s);//no op here and no leading 0\\n    \\t\\tdfs(cur + 1, 0, 1, res + num*cnum, str + s[cur] + '+', s);//+\\n    \\t\\tdfs(cur + 1, 0, -1, res + num*cnum, str + s[cur] + '-', s);//-\\n    \\t\\tdfs(cur + 1, 0, num*cnum, res, str + s[cur] + '*', s);//* \\n    \\t}\\n    \\tvector<string> addOperators(string num, int target) {\\n    \\t\\tif (num.size() > 0)dfs(0, 0, 1, -(long long)target, \"\", num);\\n    \\t\\treturn ans;\\n    \\t}\\n    };",
                "solutionTags": [
                    "C++"
                ],
                "code": "class Solution {\\n    public:\\n    \\tvector<string>ans;\\n    \\tvoid dfs(int cur, long long cnum, long long num, long long res, string str, string s){\\n    \\t\\tcnum = cnum * 10 + s[cur] - '0';\\n    \\t\\tif (cur+1 == s.size()){\\n    \\t\\t\\tif (res + num*cnum == 0)ans.push_back(str + s[cur]);\\n    \\t\\t\\treturn;\\n    \\t\\t}",
                "codeTag": "Java"
            },
            {
                "id": 71980,
                "title": "accepted-java-solution-use-the-function-in-basic-calculateii",
                "content": "**The basic idea is to generate all possible expressions using backtrace.**\\n\\n    public List<String> addOperators(String num, int target) {\\n        if(num.length() == 0) return new ArrayList<String>();\\n        List<String> res = new ArrayList<String>();\\n        ArrayList<String> ops = new  ArrayList<String>();\\n        ops.add(\"+\");ops.add(\"-\");ops.add(\"*\");ops.add(\"\");\\n        gen(num,0,\"\",res,ops,target,num.charAt(0) == '0');\\n        return res;\\n    }\\n    // the last digit in num is treated separately,beacase we can not add operator after the last digit\\n    public void gen(String num,int index,String cur,List<String> res,ArrayList<String> operators,int target,boolean flag){\\n        if(index == num.length()-1){\\n            String tmp = new String(cur+num.charAt(index));\\n            // when the situation is 10+01 this is not valid, and 100+1 is valid, special case. \\n            if( (cur.length() == 0 ||  (!flag && Character.isDigit(cur.charAt(cur.length()-1))) || !Character.isDigit(cur.charAt(cur.length()-1)) )&&calculate(tmp) == target){\\n                res.add(tmp);\\n            }\\n        }else {\\n            for(int j=0;j<operators.size();j++){\\n                // the last element in operators is \"\" .If the situation is 123+03\\n                // this is not valid , but 123+10003 is valid, if the index point to last '0'\\n                // flag is used to determine whether we can use concat operator\\n                if(flag && j == operators.size()-1) continue;\\n                // set the flag if we use \"+\",\"-\",\"*\" operator\\n                gen(num,index+1,cur+num.charAt(index)+operators.get(j),res,operators,target, j== operators.size()-1 ? flag:num.charAt(index+1) == '0' );\\n            }\\n        }\\n    }\\n    //use long to pass the special case \\n    public int calculate(String s) {\\n        s = s+\"+\";\\n        long res = 0;\\n        long val = 0;\\n        char sign = '+';\\n        Stack<Long> st = new Stack<Long>();\\n        for(int i=0;i<s.length();i++){\\n            if(Character.isDigit(s.charAt(i))){\\n                val = val*10+s.charAt(i)-'0';\\n            }else if(s.charAt(i) !=' '){\\n                switch(sign){\\n                    case '+':\\n                        st.push(val);\\n                        break;\\n                    case '-':\\n                        st.push(-val);\\n                        break;\\n                    case '*':\\n                        st.push(st.pop()*val);\\n                        break;\\n                    case '/':\\n                        st.push(st.pop()/val);\\n                        break;\\n                }\\n                val = 0;\\n                sign = s.charAt(i);\\n            }\\n        }\\n        for(long x:st) res+=x;\\n        return res > Integer.MAX_VALUE ? Integer.MAX_VALUE:(int) res;\\n    }",
                "solutionTags": [],
                "code": "**The basic idea is to generate all possible expressions using backtrace.**\\n\\n    public List<String> addOperators(String num, int target) {\\n        if(num.length() == 0) return new ArrayList<String>();\\n        List<String> res = new ArrayList<String>();\\n        ArrayList<String> ops = new  ArrayList<String>();\\n        ops.add(\"+\");ops.add(\"-\");ops.add(\"*\");ops.add(\"\");\\n        gen(num,0,\"\",res,ops,target,num.charAt(0) == '0');\\n        return res;\\n    }\\n    // the last digit in num is treated separately,beacase we can not add operator after the last digit\\n    public void gen(String num,int index,String cur,List<String> res,ArrayList<String> operators,int target,boolean flag){\\n        if(index == num.length()-1){\\n            String tmp = new String(cur+num.charAt(index));\\n            // when the situation is 10+01 this is not valid, and 100+1 is valid, special case. \\n            if( (cur.length() == 0 ||  (!flag && Character.isDigit(cur.charAt(cur.length()-1))) || !Character.isDigit(cur.charAt(cur.length()-1)) )&&calculate(tmp) == target){\\n                res.add(tmp);\\n            }\\n        }else {\\n            for(int j=0;j<operators.size();j++){\\n                // the last element in operators is \"\" .If the situation is 123+03\\n                // this is not valid , but 123+10003 is valid, if the index point to last '0'\\n                // flag is used to determine whether we can use concat operator\\n                if(flag && j == operators.size()-1) continue;\\n                // set the flag if we use \"+\",\"-\",\"*\" operator\\n                gen(num,index+1,cur+num.charAt(index)+operators.get(j),res,operators,target, j== operators.size()-1 ? flag:num.charAt(index+1) == '0' );\\n            }\\n        }\\n    }\\n    //use long to pass the special case \\n    public int calculate(String s) {\\n        s = s+\"+\";\\n        long res = 0;\\n        long val = 0;\\n        char sign = '+';\\n        Stack<Long> st = new Stack<Long>();\\n        for(int i=0;i<s.length();i++){\\n            if(Character.isDigit(s.charAt(i))){\\n                val = val*10+s.charAt(i)-'0';\\n            }else if(s.charAt(i) !=' '){\\n                switch(sign){\\n                    case '+':\\n                        st.push(val);\\n                        break;\\n                    case '-':\\n                        st.push(-val);\\n                        break;\\n                    case '*':\\n                        st.push(st.pop()*val);\\n                        break;\\n                    case '/':\\n                        st.push(st.pop()/val);\\n                        break;\\n                }\\n                val = 0;\\n                sign = s.charAt(i);\\n            }\\n        }\\n        for(long x:st) res+=x;\\n        return res > Integer.MAX_VALUE ? Integer.MAX_VALUE:(int) res;\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 2799103,
                "title": "simple-c-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<string> addOperators(string num, int target) {\\n        vector<string> ans;\\n        recursion(ans, num, target, \"\", 0, 0, 0 );\\n        return ans;\\n    }\\n    \\n    void recursion(vector<string>& ans, const string& num, const int& target, string expression, int idx, int prevNum, long long curTotal){\\n        int n = num.size();\\n        if(idx==n){\\n            if(curTotal==target){\\n                ans.push_back(expression);\\n            }\\n            return;\\n        }\\n        string curNumStr = \"\";\\n        long long curNum = 0;\\n        for(int i = idx; i<n; i++){\\n            if(i>idx && num[idx]==\\'0\\')break;\\n            curNumStr+=num[i];\\n            curNum = curNum*10+(num[i]-\\'0\\');\\n            // 2345\\n            if(idx==0){\\n                recursion(ans, num, target, expression+curNumStr, i+1, curNum, curTotal+curNum);\\n            }\\n            else{\\n                recursion(ans, num, target, expression+\"+\"+curNumStr, i+1, curNum, curTotal+curNum);\\n                recursion(ans, num, target, expression+\"-\"+curNumStr, i+1, -curNum, curTotal-curNum);\\n                recursion(ans, num, target, expression+\"*\"+curNumStr, i+1, prevNum*curNum, curTotal-prevNum+prevNum*curNum);\\n            }\\n        }\\n    }\\n    \\n};\\n\\n\\n\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<string> addOperators(string num, int target) {\\n        vector<string> ans;\\n        recursion(ans, num, target, \"\", 0, 0, 0 );\\n        return ans;\\n    }\\n    \\n    void recursion(vector<string>& ans, const string& num, const int& target, string expression, int idx, int prevNum, long long curTotal){\\n        int n = num.size();\\n        if(idx==n){\\n            if(curTotal==target){\\n                ans.push_back(expression);\\n            }\\n            return;\\n        }\\n        string curNumStr = \"\";\\n        long long curNum = 0;\\n        for(int i = idx; i<n; i++){\\n            if(i>idx && num[idx]==\\'0\\')break;\\n            curNumStr+=num[i];\\n            curNum = curNum*10+(num[i]-\\'0\\');\\n            // 2345\\n            if(idx==0){\\n                recursion(ans, num, target, expression+curNumStr, i+1, curNum, curTotal+curNum);\\n            }\\n            else{\\n                recursion(ans, num, target, expression+\"+\"+curNumStr, i+1, curNum, curTotal+curNum);\\n                recursion(ans, num, target, expression+\"-\"+curNumStr, i+1, -curNum, curTotal-curNum);\\n                recursion(ans, num, target, expression+\"*\"+curNumStr, i+1, prevNum*curNum, curTotal-prevNum+prevNum*curNum);\\n            }\\n        }\\n    }\\n    \\n};\\n\\n\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 71950,
                "title": "typical-backtracking-solution-with-detailed-explanation-in-c",
                "content": "### Solution\\n\\n#### Analysis\\nTypical backtracking problem as it is. Try to split the string into small blocks and then meantime try different operators among them.\\n\\n- from a starting position, we can try different valid length for the current number but if the length is bigger than 1 and the first digit is zero then just stop;\\n- using different operators to connect the current number, calculate and then store them in a temporary string for the next number till the end;\\n- but when we try `*`, we have to be more careful since multiplier will associate its previous number and has higher precedence, so we as a result have to record its previous number; but this will require us to handle it delicately when we are inserting `+ or -`, as for `+` we can just put the number as previous but as to `-`, we will need to set `-number` as previous; because we have to subtract the previous number first when inserting `*` - inserting means we are do the calculation with the current number here;\\n- since the target is an `int`, so when the number is larger than INT_MAX, we should just stop there.\\n\\n#### Improvements\\n- there will be numbers collected larger than INT_MAX, so we have to adopt `long` - long long here is unnecessary;\\n- collecting the number one character at a time is more efficient to convert the substring directly to integer using `stol`;\\n- using temporary substring to replace `to_string(number)` will save lots of converting time;\\n- actually we can just use one temporary string and append the digit instead of retrieving the substring each time.\\n\\nThe whole solution in C++ is as follows.\\n\\n```\\nclass Solution {\\nprivate:\\n    int sLen;\\n    void traverse(const string s, int pos, long current, long pre, int sum, string path, vector<string>& v)\\n    {\\n        if(sLen == pos) { if(current == sum) v.push_back(path); return ; }\\n        long num = 0;\\n        string t;\\n        for(int i = pos; i < sLen; ++i)\\n        {\\n            if(i-pos>0 && s[pos]=='0') return ;\\n            t += s[i];\\n            num = 10*num + s[i]-'0';\\n            if(num > INT_MAX) return ;\\n            if(pos == 0) traverse(s, i+1, num, num, sum, t, v);\\n            else\\n            {\\n                traverse(s, i+1, current+num, num, sum, path+\"+\"+t, v);\\n                traverse(s, i+1, current-num, -num, sum, path+\"-\"+t, v);\\n                traverse(s, i+1, current-pre+pre*num, pre*num, sum, path+\"*\"+t, v);\\n            }\\n        }\\n    }\\npublic:\\n    vector<string> addOperators(string s, int target) {\\n        sLen = s.length();\\n        vector<string> v;\\n        traverse(s, 0, 0, 0, target, \"\", v);\\n        return v;\\n    }\\n};\\n```\\n\\n\\nAlways welcome new ideas and `practical` tricks, just leave them in the comments!",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\nprivate:\\n    int sLen;\\n    void traverse(const string s, int pos, long current, long pre, int sum, string path, vector<string>& v)\\n    {\\n        if(sLen == pos) { if(current == sum) v.push_back(path); return ; }\\n        long num = 0;\\n        string t;\\n        for(int i = pos; i < sLen; ++i)\\n        {\\n            if(i-pos>0 && s[pos]=='0') return ;\\n            t += s[i];\\n            num = 10*num + s[i]-'0';\\n            if(num > INT_MAX) return ;\\n            if(pos == 0) traverse(s, i+1, num, num, sum, t, v);\\n            else\\n            {\\n                traverse(s, i+1, current+num, num, sum, path+\"+\"+t, v);\\n                traverse(s, i+1, current-num, -num, sum, path+\"-\"+t, v);\\n                traverse(s, i+1, current-pre+pre*num, pre*num, sum, path+\"*\"+t, v);\\n            }\\n        }\\n    }\\npublic:\\n    vector<string> addOperators(string s, int target) {\\n        sLen = s.length();\\n        vector<string> v;\\n        traverse(s, 0, 0, 0, target, \"\", v);\\n        return v;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3236396,
                "title": "282-solution-with-step-by-step-explanation",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\nStep-by-step explanation:\\n\\n1. The input to the function is a string num and an integer target, representing the number to be expressed and the target value to be achieved, respectively.\\n2. The function initializes an empty list ans to store all possible expressions that evaluate to the target value.\\n3. The function defines a DFS (depth-first search) function dfs to generate all possible expressions.\\n4. The DFS function takes four parameters: start represents the current index in the string num, prev represents the previous operand value, eval represents the current evaluated value, and path represents the list of operands and operators that form the current expression.\\n5. The DFS function uses recursion to generate all possible expressions. At each recursive call, it evaluates the expression formed so far, and if the evaluation equals the target value, it adds the expression to the answer list.\\n6. The DFS function iterates over all possible operands starting from the current index start, and for each operand, it iterates over all possible operators (+, -, *) and generates new expressions by appending the current operand and operator to the current path, and updating the previous operand value, evaluated value, and current index accordingly.\\n7. The DFS function terminates when the current index reaches the end of the string num.\\n8. The main function addOperators starts the DFS with initial parameters start=0, prev=0, eval=0, and path=[], and\\n# Complexity\\n- Time complexity:\\n87.49%\\n\\n- Space complexity:\\n78.86%\\n\\n# Code\\n```\\nclass Solution:\\n  def addOperators(self, num: str, target: int) -> List[str]:\\n    ans = [] # list to store all possible expressions that evaluate to the target\\n\\n    # DFS function to generate all possible expressions\\n    # start: current index in num\\n    # prev: previous operand value\\n    # eval: current evaluated value\\n    # path: list to store current expression\\n    def dfs(start: int, prev: int, eval: int, path: List[str]) -> None:\\n      # base case: reached end of num\\n      if start == len(num):\\n        # check if current evaluation equals target\\n        if eval == target:\\n          # add current expression to the answer list\\n          ans.append(\\'\\'.join(path))\\n        return\\n\\n      # iterate over all possible operands from current index\\n      for i in range(start, len(num)):\\n        # special case: ignore operands starting with 0, except 0 itself\\n        if i > start and num[start] == \\'0\\':\\n          return\\n        s = num[start:i + 1]\\n        curr = int(s)\\n        # special case: first operand, simply add it to the path and evaluate\\n        if start == 0:\\n          path.append(s)\\n          dfs(i + 1, curr, curr, path)\\n          path.pop()\\n        # general case: iterate over all possible operators and operands\\n        else:\\n          for op in [\\'+\\', \\'-\\', \\'*\\']:\\n            path.append(op + s)\\n            # addition: add current operand to evaluated value\\n            if op == \\'+\\':\\n              dfs(i + 1, curr, eval + curr, path)\\n            # subtraction: subtract current operand from evaluated value\\n            elif op == \\'-\\':\\n              dfs(i + 1, -curr, eval - curr, path)\\n            # multiplication: multiply current operand with previous operand and update evaluated value\\n            else:\\n              dfs(i + 1, prev * curr, eval - prev + prev * curr, path)\\n            path.pop()\\n\\n    # start DFS with initial parameters\\n    dfs(0, 0, 0, [])\\n    return ans\\n\\n```",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Math",
                    "String",
                    "Backtracking"
                ],
                "code": "```\\nclass Solution:\\n  def addOperators(self, num: str, target: int) -> List[str]:\\n    ans = [] # list to store all possible expressions that evaluate to the target\\n\\n    # DFS function to generate all possible expressions\\n    # start: current index in num\\n    # prev: previous operand value\\n    # eval: current evaluated value\\n    # path: list to store current expression\\n    def dfs(start: int, prev: int, eval: int, path: List[str]) -> None:\\n      # base case: reached end of num\\n      if start == len(num):\\n        # check if current evaluation equals target\\n        if eval == target:\\n          # add current expression to the answer list\\n          ans.append(\\'\\'.join(path))\\n        return\\n\\n      # iterate over all possible operands from current index\\n      for i in range(start, len(num)):\\n        # special case: ignore operands starting with 0, except 0 itself\\n        if i > start and num[start] == \\'0\\':\\n          return\\n        s = num[start:i + 1]\\n        curr = int(s)\\n        # special case: first operand, simply add it to the path and evaluate\\n        if start == 0:\\n          path.append(s)\\n          dfs(i + 1, curr, curr, path)\\n          path.pop()\\n        # general case: iterate over all possible operators and operands\\n        else:\\n          for op in [\\'+\\', \\'-\\', \\'*\\']:\\n            path.append(op + s)\\n            # addition: add current operand to evaluated value\\n            if op == \\'+\\':\\n              dfs(i + 1, curr, eval + curr, path)\\n            # subtraction: subtract current operand from evaluated value\\n            elif op == \\'-\\':\\n              dfs(i + 1, -curr, eval - curr, path)\\n            # multiplication: multiply current operand with previous operand and update evaluated value\\n            else:\\n              dfs(i + 1, prev * curr, eval - prev + prev * curr, path)\\n            path.pop()\\n\\n    # start DFS with initial parameters\\n    dfs(0, 0, 0, [])\\n    return ans\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1471816,
                "title": "10-lines-clean-and-easy-to-understand-solution-in-c",
                "content": "General idea would be the same as most solution but the code is much more clean, concise and easier to understand than most of the top voted solution. \\n\\nKey idea to make everything more concise is to separate the multiplier accumulated using a variable.\\n\\n```\\nclass Solution {\\nprivate:\\n    string num;\\n    int target;\\n    vector<string> allAnswer;\\n    \\npublic:\\n\\t/*\\n\\t\\ti:          current index of num to operates on\\n\\t\\texpression: current expression so far\\n\\t\\tsum:        the partial sum before the last \\'+\\' or \\'-\\' operators\\n\\t\\tcurNum:     the last operand\\n\\t\\tmultiplier: the multiplier to the last operand\\n\\t*/\\n    void add(int i, string expression, long long sum, long long curNum, long long multiplier) {\\n        if(i == num.size()) {\\n            if(sum + multiplier * curNum == target)\\n                allAnswer.push_back(expression);\\n            return;\\n        }\\n        \\n        if(curNum != 0)\\n            add(i+1, expression + num[i], sum, curNum * 10 + (num[i]-\\'0\\'), multiplier);\\n        \\n        add(i+1, expression + \"+\" + num[i], sum + multiplier * curNum, num[i]-\\'0\\', 1);\\n        add(i+1, expression + \"-\" + num[i], sum + multiplier * curNum, num[i]-\\'0\\', -1);\\n        add(i+1, expression + \"*\" + num[i], sum, num[i]-\\'0\\', multiplier * curNum);\\n    };\\n    \\n    vector<string> addOperators(string num, int target) {\\n        this->num = num;\\n        this->target = target;\\n        \\n        add(1, num.substr(0, 1), 0, num[0]-\\'0\\', 1);\\n        return allAnswer;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nclass Solution {\\nprivate:\\n    string num;\\n    int target;\\n    vector<string> allAnswer;\\n    \\npublic:\\n\\t/*\\n\\t\\ti:          current index of num to operates on\\n\\t\\texpression: current expression so far\\n\\t\\tsum:        the partial sum before the last \\'+\\' or \\'-\\' operators\\n\\t\\tcurNum:     the last operand\\n\\t\\tmultiplier: the multiplier to the last operand\\n\\t*/\\n    void add(int i, string expression, long long sum, long long curNum, long long multiplier) {\\n        if(i == num.size()) {\\n            if(sum + multiplier * curNum == target)\\n                allAnswer.push_back(expression);\\n            return;\\n        }\\n        \\n        if(curNum != 0)\\n            add(i+1, expression + num[i], sum, curNum * 10 + (num[i]-\\'0\\'), multiplier);\\n        \\n        add(i+1, expression + \"+\" + num[i], sum + multiplier * curNum, num[i]-\\'0\\', 1);\\n        add(i+1, expression + \"-\" + num[i], sum + multiplier * curNum, num[i]-\\'0\\', -1);\\n        add(i+1, expression + \"*\" + num[i], sum, num[i]-\\'0\\', multiplier * curNum);\\n    };\\n    \\n    vector<string> addOperators(string num, int target) {\\n        this->num = num;\\n        this->target = target;\\n        \\n        add(1, num.substr(0, 1), 0, num[0]-\\'0\\', 1);\\n        return allAnswer;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1470261,
                "title": "python3-a-super-easy-cheat-solution-a-general-approach-for-all-languages",
                "content": "Using the `eval` function makes this question from hard to medium.\\n- `i` is the current index\\n- `s` is the current temporary string\\n- leading is the leading character, right after \\n\\t- the start, or,\\n\\t- an operator like `+` or `-` or `*`\\n\\n`leading` is important since it let\\'s us skip over sequences starting from 0, as in `05` or `009`. And the rest is classic recursion.\\n\\n```\\nclass Solution:\\n    def addOperators(self, num: str, target: int) -> List[str]:\\n        n = len(num)\\n        ans = []\\n        def recurse(i, s, leading):\\n            if i > n-1:\\n                if eval(s) == target:\\n                    ans.append(s)\\n                return\\n            \\n            if leading != \\'0\\':\\n                recurse(i+1, s+num[i], leading)\\n            recurse(i+1, s+\"+\"+num[i], num[i])\\n            recurse(i+1, s+\"-\"+num[i], num[i])\\n            recurse(i+1, s+\"*\"+num[i], num[i])\\n            \\n        recurse(1, num[0], num[0])\\n        \\n        return ans\\n```\\n\\nWe can do a manual computation for `eval` and write our own function\\n```\\nclass Solution:\\n    def addOperators(self, num: str, target: int) -> List[str]:\\n        def evaluate(s):\\n            a = []\\n            temp = \"\"\\n            for c in s:\\n                if \\'0\\' <= c <= \\'9\\': \\n                    temp += c\\n                else:\\n                    a.append(int(temp))\\n                    a.append(c)\\n                    temp = \"\"\\n            a.append(int(temp))\\n            \\n            total = a[0]\\n            prev = a[0]\\n            for i in range(len(a)-1):\\n                item = a[i]\\n                if item == \\'+\\':\\n                    total = total + a[i+1]\\n                    prev = a[i+1]\\n                elif item == \\'-\\':\\n                    total = total - a[i+1]\\n                    prev = -a[i+1]\\n                elif item == \\'*\\':\\n                    total = total - prev + prev * a[i+1]\\n                    prev = prev * a[i+1]\\n            return total\\n        \\n        n = len(num)\\n        ans = []\\n        def recurse(i, s, leading):\\n            if i > n-1:\\n                if evaluate(s) == target:\\n                    ans.append(s)\\n                return\\n            \\n            if leading != \\'0\\':\\n                recurse(i+1, s+num[i], leading)\\n            recurse(i+1, s+\"+\"+num[i], num[i])\\n            recurse(i+1, s+\"-\"+num[i], num[i])\\n            recurse(i+1, s+\"*\"+num[i], num[i])\\n            \\n            \\n        \\n        recurse(1, num[0], num[0])\\n        \\n        return ans\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def addOperators(self, num: str, target: int) -> List[str]:\\n        n = len(num)\\n        ans = []\\n        def recurse(i, s, leading):\\n            if i > n-1:\\n                if eval(s) == target:\\n                    ans.append(s)\\n                return\\n            \\n            if leading != \\'0\\':\\n                recurse(i+1, s+num[i], leading)\\n            recurse(i+1, s+\"+\"+num[i], num[i])\\n            recurse(i+1, s+\"-\"+num[i], num[i])\\n            recurse(i+1, s+\"*\"+num[i], num[i])\\n            \\n        recurse(1, num[0], num[0])\\n        \\n        return ans\\n```\n```\\nclass Solution:\\n    def addOperators(self, num: str, target: int) -> List[str]:\\n        def evaluate(s):\\n            a = []\\n            temp = \"\"\\n            for c in s:\\n                if \\'0\\' <= c <= \\'9\\': \\n                    temp += c\\n                else:\\n                    a.append(int(temp))\\n                    a.append(c)\\n                    temp = \"\"\\n            a.append(int(temp))\\n            \\n            total = a[0]\\n            prev = a[0]\\n            for i in range(len(a)-1):\\n                item = a[i]\\n                if item == \\'+\\':\\n                    total = total + a[i+1]\\n                    prev = a[i+1]\\n                elif item == \\'-\\':\\n                    total = total - a[i+1]\\n                    prev = -a[i+1]\\n                elif item == \\'*\\':\\n                    total = total - prev + prev * a[i+1]\\n                    prev = prev * a[i+1]\\n            return total\\n        \\n        n = len(num)\\n        ans = []\\n        def recurse(i, s, leading):\\n            if i > n-1:\\n                if evaluate(s) == target:\\n                    ans.append(s)\\n                return\\n            \\n            if leading != \\'0\\':\\n                recurse(i+1, s+num[i], leading)\\n            recurse(i+1, s+\"+\"+num[i], num[i])\\n            recurse(i+1, s+\"-\"+num[i], num[i])\\n            recurse(i+1, s+\"*\"+num[i], num[i])\\n            \\n            \\n        \\n        recurse(1, num[0], num[0])\\n        \\n        return ans\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1275613,
                "title": "recursive-c-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    \\n    vector<string> result;\\n\\n    vector<string> addOperators(string num, int target) \\n    {     \\n        solve(num, target, 0, \"\", 0, 0);\\n        return result;\\n    }\\n    \\n    void solve(string num, int target, int start, string str, long sum, long last)\\n    {\\n        if(num.size() == start)\\n        {\\n            if(target == sum)\\n                result.push_back(str);\\n            return;\\n        }\\n        \\n        long x = 0;\\n        string ret = \"\";\\n        \\n        for(int i=start; i<num.size(); ++i)\\n        {\\n            x = x*10 + num[i]-\\'0\\';\\n            ret += num[i]; \\n            \\n            if(start == 0)\\n                solve(num, target, i+1, str+ret, x, x);\\n            \\n            else\\n            {\\n                solve(num, target, i+1, str+\"*\"+ret, sum-last+x*last, x*last);\\n                solve(num, target, i+1, str+\"+\"+ret, sum+x, x);\\n                solve(num, target, i+1, str+\"-\"+ret, sum-x, -x);\\n            } \\n            \\n            if(x == 0)\\n                break; \\n        }\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Recursion"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    \\n    vector<string> result;\\n\\n    vector<string> addOperators(string num, int target) \\n    {     \\n        solve(num, target, 0, \"\", 0, 0);\\n        return result;\\n    }\\n    \\n    void solve(string num, int target, int start, string str, long sum, long last)\\n    {\\n        if(num.size() == start)\\n        {\\n            if(target == sum)\\n                result.push_back(str);\\n            return;\\n        }\\n        \\n        long x = 0;\\n        string ret = \"\";\\n        \\n        for(int i=start; i<num.size(); ++i)\\n        {\\n            x = x*10 + num[i]-\\'0\\';\\n            ret += num[i]; \\n            \\n            if(start == 0)\\n                solve(num, target, i+1, str+ret, x, x);\\n            \\n            else\\n            {\\n                solve(num, target, i+1, str+\"*\"+ret, sum-last+x*last, x*last);\\n                solve(num, target, i+1, str+\"+\"+ret, sum+x, x);\\n                solve(num, target, i+1, str+\"-\"+ret, sum-x, -x);\\n            } \\n            \\n            if(x == 0)\\n                break; \\n        }\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 395651,
                "title": "python-solution-with-step-by-step-inline-explanation",
                "content": "```python\\nclass Solution:\\n    def addOperators(self, num: str, target: int) -> List[str]:        \\n        def recurse(i, pre, cur, val, eq):\\n            \"\"\"\\n            There are four types of operations:\\n                1. Digit concatenation to form a number\\n                2. Addition\\n                3. Subtraction\\n                4. Multiplication\\n\\n            i int: cursor\\n            pre int: previous operand\\n            cur int: current operand\\n            val int: final result so far\\n            eq list: equation components\\n            \"\"\"\\n            # when the cursor reaches to the end of the given string\\n            if i == len(num):\\n                # we check:\\n                #   1. if the final result is equal to the target\\n                #   2. if the current operand is already evaluated\\n                # if both requirements met, the equation is qualified\\n                if val == target and cur == 0:\\n                    res.append(\\'\\'.join(map(str, eq[1:])))\\n                return\\n            \\n            # append the new digit to the current operand\\n            cur = cur * 10 + int(num[i])\\n            i += 1\\n\\n            # 1. Digit concatenation\\n            # it is only possible when the current operand is greater than 0, in \\n            # which case the operand is led by a non-zero digit. \\n            if cur > 0:\\n                # by concatenating digits, the previous operand, final result and \\n                # equation remain the same, while the current operand is updated \\n                # but yet evaluated\\n                recurse(i, pre, cur, val, eq)\\n            \\n            # For the rest operations, the current operand will be evaluated w/ \\n            # different operators, and the result will be reflected in the final \\n            # result and the equation. Meanwhile, the current operand will be \\n            # used as the previous operand for the next recursion\\n\\n            # 2. Addition\\n            # append the addition sign and current operand to the equation\\n            eq += [\\'+\\', cur]\\n            # add the current operand to the final result, use it as the \\n            # previous operand and clear the current operand for the next \\n            # recursion\\n            recurse(i, cur, 0, val + cur, eq)\\n            # pop out the previous oprand and operator to reuse the equation \\n            # list\\n            eq.pop()\\n            eq.pop()\\n            \\n            # note that the first operand in the equation is treated as being \\n            # added to 0. So for the first operand, only addition is available. \\n            # When the equation is empty, it means the first operand is being \\n            # dealt with, and we should stop here\\n            if not eq:\\n                return\\n            \\n            # 3. Subtraction\\n            eq += [\\'-\\', cur]\\n            # similar to addition, but we subtract the current operand from the \\n            # final result, and use the reverse of the current operand as the \\n            # previous operand for the next recursion\\n            recurse(i, -cur, 0, val - cur, eq)\\n            eq.pop()\\n            eq.pop()\\n            \\n            # 4. Multiplication\\n            eq += [\\'*\\', cur]\\n            # the key difference is that multiplication has the priority over \\n            # additions and subtractions, and it is commutative (i.e. the order \\n            # of the operands doesn\\'t matter). Hence, regardless of the type of \\n            # operation done previously, we always reverse it and prioritize the \\n            # evaluation of the current one, since it enforces the priority if \\n            # the previous operation is addition or subtraction, but do no harm \\n            # if multiplication (`a*b*c` will becomes `c*b*a`, which gives the \\n            # same result)\\n            cur *= pre \\n            # in practice, we subtract the previous operand from the final \\n            # result to reverse the previous operation and multiply it with the \\n            # current one. Then we add the result to the final result. \\n            recurse(i, cur, 0, val - pre + cur, eq)\\n            eq.pop()\\n            eq.pop()\\n        \\n        res = []\\n        recurse(0, 0, 0, 0, [])\\n        return res\\n```",
                "solutionTags": [],
                "code": "```python\\nclass Solution:\\n    def addOperators(self, num: str, target: int) -> List[str]:        \\n        def recurse(i, pre, cur, val, eq):\\n            \"\"\"\\n            There are four types of operations:\\n                1. Digit concatenation to form a number\\n                2. Addition\\n                3. Subtraction\\n                4. Multiplication\\n\\n            i int: cursor\\n            pre int: previous operand\\n            cur int: current operand\\n            val int: final result so far\\n            eq list: equation components\\n            \"\"\"\\n            # when the cursor reaches to the end of the given string\\n            if i == len(num):\\n                # we check:\\n                #   1. if the final result is equal to the target\\n                #   2. if the current operand is already evaluated\\n                # if both requirements met, the equation is qualified\\n                if val == target and cur == 0:\\n                    res.append(\\'\\'.join(map(str, eq[1:])))\\n                return\\n            \\n            # append the new digit to the current operand\\n            cur = cur * 10 + int(num[i])\\n            i += 1\\n\\n            # 1. Digit concatenation\\n            # it is only possible when the current operand is greater than 0, in \\n            # which case the operand is led by a non-zero digit. \\n            if cur > 0:\\n                # by concatenating digits, the previous operand, final result and \\n                # equation remain the same, while the current operand is updated \\n                # but yet evaluated\\n                recurse(i, pre, cur, val, eq)\\n            \\n            # For the rest operations, the current operand will be evaluated w/ \\n            # different operators, and the result will be reflected in the final \\n            # result and the equation. Meanwhile, the current operand will be \\n            # used as the previous operand for the next recursion\\n\\n            # 2. Addition\\n            # append the addition sign and current operand to the equation\\n            eq += [\\'+\\', cur]\\n            # add the current operand to the final result, use it as the \\n            # previous operand and clear the current operand for the next \\n            # recursion\\n            recurse(i, cur, 0, val + cur, eq)\\n            # pop out the previous oprand and operator to reuse the equation \\n            # list\\n            eq.pop()\\n            eq.pop()\\n            \\n            # note that the first operand in the equation is treated as being \\n            # added to 0. So for the first operand, only addition is available. \\n            # When the equation is empty, it means the first operand is being \\n            # dealt with, and we should stop here\\n            if not eq:\\n                return\\n            \\n            # 3. Subtraction\\n            eq += [\\'-\\', cur]\\n            # similar to addition, but we subtract the current operand from the \\n            # final result, and use the reverse of the current operand as the \\n            # previous operand for the next recursion\\n            recurse(i, -cur, 0, val - cur, eq)\\n            eq.pop()\\n            eq.pop()\\n            \\n            # 4. Multiplication\\n            eq += [\\'*\\', cur]\\n            # the key difference is that multiplication has the priority over \\n            # additions and subtractions, and it is commutative (i.e. the order \\n            # of the operands doesn\\'t matter). Hence, regardless of the type of \\n            # operation done previously, we always reverse it and prioritize the \\n            # evaluation of the current one, since it enforces the priority if \\n            # the previous operation is addition or subtraction, but do no harm \\n            # if multiplication (`a*b*c` will becomes `c*b*a`, which gives the \\n            # same result)\\n            cur *= pre \\n            # in practice, we subtract the previous operand from the final \\n            # result to reverse the previous operation and multiply it with the \\n            # current one. Then we add the result to the final result. \\n            recurse(i, cur, 0, val - pre + cur, eq)\\n            eq.pop()\\n            eq.pop()\\n        \\n        res = []\\n        recurse(0, 0, 0, 0, [])\\n        return res\\n```",
                "codeTag": "Java"
            },
            {
                "id": 191083,
                "title": "python-backtracking-solution-beating-95-with-time-complexity-proof",
                "content": "```python\\nclass Solution(object):\\n    ans = []\\n    \\n    def addOperators(self, num, target):\\n        \"\"\"\\n        This is one clarification in this question i.e. a number can\\'t start with 0. Like if we are given 105 and target\\n        5, 1 X 05 is not possible. It\\'s a simple backtracking algorithm without any optimization or DP.\\n        \\n        Proof Of Runtime is given in is given below i.e.\\n        \\n        T(N) = Total Number of Valid Expressions = 3 * 4^(N - 2) so that\\'s why runtime is O(4^N). \\n        \\n\\tRun Time complexity can also been proved by following intuitive approach.\\n\\t\\t\\t\\t\\n        If we just allow single digits so each digit can have 3 possible operators before it i.e. +, -, *\\n        which means total number of combinations to be checked are O(3^N). If we allow non-single digits as well then\\n        each digit has 4 possible values before it i.e. +, -, *, None. None means we don\\'t have any operations before\\n        digit and current digit is considered part of previous digit and they both form a number. So total combinations\\n        to be checked are O(4^N)\\n        :type num: str\\n        :type target: int\\n        :rtype: List[str]\\n        \"\"\"\\n        self.ans = []\\n        num = list(map(int, list(num)))\\n        \\n        def __addOperators(exp_val=0, last_val=0, index=0, prefix=\"\"):\\n            if index < len(num):\\n                number = 0\\n                prev_index = index\\n                while index < len(num):\\n                    number *= 10\\n                    number += num[index]\\n                    \\n                    if not prefix:\\n                        __addOperators(exp_val + number, number, index + 1, str(number))\\n                    else:\\n                        new_prefix = prefix + \\'{}\\' + str(number)\\n                        __addOperators(exp_val + number, number, index + 1, new_prefix.format(\\'+\\'))\\n                        __addOperators(exp_val - number, -1 * number, index + 1, new_prefix.format(\\'-\\'))\\n\\n                        multiply_val = exp_val + last_val * (number - 1)\\n                        __addOperators(multiply_val, last_val * number, index + 1, new_prefix.format(\\'*\\'))\\n                    \\n                    if prev_index == index and number == 0:\\n                        break\\n                    else:\\n                        index += 1\\n            elif exp_val == target:\\n                self.ans.append(prefix)\\n                \\n        \\n        if num:\\n            __addOperators()\\n        \\n        print(len(self.ans))\\n        return self.ans\\n        \\n```\\n\\n\\n#### Run Time\\n\\nTotal number of valid expressions as per author are O(N^2 x 3^N). But following proof says otherwise.\\n\\nT(N) = Total Number of Valid Expressions\\n\\nT(N) = 3T(N - 1) + 3T(N - 2) + 3T(N - 3) + .... 3T(0)\\n\\nIf we use first digit as an operand, total number of valid expressions would be T(N - 1) x 3. Three accounts\\nfor our three operations. If we use first two digits as an operand, total number of valid expressions would be T(N - 2) x 3 and so on.\\n\\nNow T(N - 1) = 3T(N - 2) + 3T(N - 3) + 3T(N - 4) + .... 3T(0)\\n\\nif we put T(N - 1) in T(N) we\\'ll get\\n\\nT(N) = 3 x 4 ( T(N - 2) + T(N - 3) + T(N - 4) + .... T(0) )\\n\\nIf we put T(N - 2) in T(N) we\\'ll get\\n\\nT(N) = 3 x 4^2 ( T(N - 3) + T(N - 4) + T(N - 5) + .... T(0) )\\n\\nIf we generalize it, we\\'ll get\\n\\nT(N) = 3 x 4^k ( T(N - (k + 1)) + T(N - (k + 2)) + .... T(0))\\n\\nIf we put k = N - 1, we\\'ll get\\n\\nT(N) = 3 x 4^(N - 1) (T(0)) = O(4^N)\\n\\nSo Total valid expressions are O(4^N). Not sure how author deduced O(N^2 x 3^N)\\n\\nFor the worst case of an array of 0s and target 0, length of our output would be O(4^N). I\\'m not sure then how author is claiming a O(N^2 x 3^N) runtime.\\n\\n",
                "solutionTags": [],
                "code": "```python\\nclass Solution(object):\\n    ans = []\\n    \\n    def addOperators(self, num, target):\\n        \"\"\"\\n        This is one clarification in this question i.e. a number can\\'t start with 0. Like if we are given 105 and target\\n        5, 1 X 05 is not possible. It\\'s a simple backtracking algorithm without any optimization or DP.\\n        \\n        Proof Of Runtime is given in is given below i.e.\\n        \\n        T(N) = Total Number of Valid Expressions = 3 * 4^(N - 2) so that\\'s why runtime is O(4^N). \\n        \\n\\tRun Time complexity can also been proved by following intuitive approach.\\n\\t\\t\\t\\t\\n        If we just allow single digits so each digit can have 3 possible operators before it i.e. +, -, *\\n        which means total number of combinations to be checked are O(3^N). If we allow non-single digits as well then\\n        each digit has 4 possible values before it i.e. +, -, *, None. None means we don\\'t have any operations before\\n        digit and current digit is considered part of previous digit and they both form a number. So total combinations\\n        to be checked are O(4^N)\\n        :type num: str\\n        :type target: int\\n        :rtype: List[str]\\n        \"\"\"\\n        self.ans = []\\n        num = list(map(int, list(num)))\\n        \\n        def __addOperators(exp_val=0, last_val=0, index=0, prefix=\"\"):\\n            if index < len(num):\\n                number = 0\\n                prev_index = index\\n                while index < len(num):\\n                    number *= 10\\n                    number += num[index]\\n                    \\n                    if not prefix:\\n                        __addOperators(exp_val + number, number, index + 1, str(number))\\n                    else:\\n                        new_prefix = prefix + \\'{}\\' + str(number)\\n                        __addOperators(exp_val + number, number, index + 1, new_prefix.format(\\'+\\'))\\n                        __addOperators(exp_val - number, -1 * number, index + 1, new_prefix.format(\\'-\\'))\\n\\n                        multiply_val = exp_val + last_val * (number - 1)\\n                        __addOperators(multiply_val, last_val * number, index + 1, new_prefix.format(\\'*\\'))\\n                    \\n                    if prev_index == index and number == 0:\\n                        break\\n                    else:\\n                        index += 1\\n            elif exp_val == target:\\n                self.ans.append(prefix)\\n                \\n        \\n        if num:\\n            __addOperators()\\n        \\n        print(len(self.ans))\\n        return self.ans\\n        \\n```",
                "codeTag": "Java"
            },
            {
                "id": 146166,
                "title": "swift-4-1-2",
                "content": "```\\nclass Solution {\\n    \\n    var res = [String]()\\n    func addOperators(_ num: String, _ target: Int) -> [String] {\\n        guard num.count != 0 else { return [] }\\n        search(num, num.startIndex, \"\", target, 0, 0)\\n        return res\\n    }\\n    \\n    func search(_ num: String, _ start: String.Index, _ path: String, _ target: Int, _ sum: Int, _ last: Int) {\\n        \\n        if start == num.endIndex {\\n            if target == sum {\\n                res.append(path)\\n            }\\n            return\\n        }\\n        \\n        var index = start\\n        while index < num.endIndex {\\n            let x = Int(String(num[start...index]))!\\n            \\n            if start == num.startIndex {\\n                search(num, num.index(after: index), String(x), target, x, x)\\n            }\\n            else {\\n                search(num, num.index(after: index), path + \"*\" + String(x), target, sum - last + last * x, last * x)\\n                search(num, num.index(after: index), path + \"+\" + String(x), target, sum + x, x)\\n                search(num, num.index(after: index), path + \"-\" + String(x), target, sum - x, -x)\\n            }\\n            \\n            if x == 0 {\\n                break\\n            }\\n            \\n            index = num.index(after: index)\\n        }\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    \\n    var res = [String]()\\n    func addOperators(_ num: String, _ target: Int) -> [String] {\\n        guard num.count != 0 else { return [] }\\n        search(num, num.startIndex, \"\", target, 0, 0)\\n        return res\\n    }\\n    \\n    func search(_ num: String, _ start: String.Index, _ path: String, _ target: Int, _ sum: Int, _ last: Int) {\\n        \\n        if start == num.endIndex {\\n            if target == sum {\\n                res.append(path)\\n            }\\n            return\\n        }\\n        \\n        var index = start\\n        while index < num.endIndex {\\n            let x = Int(String(num[start...index]))!\\n            \\n            if start == num.startIndex {\\n                search(num, num.index(after: index), String(x), target, x, x)\\n            }\\n            else {\\n                search(num, num.index(after: index), path + \"*\" + String(x), target, sum - last + last * x, last * x)\\n                search(num, num.index(after: index), path + \"+\" + String(x), target, sum + x, x)\\n                search(num, num.index(after: index), path + \"-\" + String(x), target, sum - x, -x)\\n            }\\n            \\n            if x == 0 {\\n                break\\n            }\\n            \\n            index = num.index(after: index)\\n        }\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 128460,
                "title": "simple-python-dfs-that-beats-100",
                "content": "Scan number in num one by one. Each time seeing a new number we have 4 options:\\n1. add a +\\n2. add a - \\n3. add a *\\n4. append it to end of previous number\\nFor example, if current expression is 20+2 and we encounter 1, we can construct:\\n(1) 20+2+1\\n(2) 20+2-1\\n(3) 20+2*1\\n(4) 20+21\\nAll expressions can be expressed as the sum of another expression and a product of one or multiple numbers\\nExpr = Expr\\' + product, where Expr\\' can be null.\\n\\n```\\nclass Solution(object):\\n    def addOperators(self, num, target):\\n        \"\"\"\\n        :type num: str\\n        :type target: int\\n        :rtype: List[str]\\n        \"\"\"\\n        if not num:\\n            return []\\n        if len(num) == 1:\\n            if int(num) == target:\\n                return [num]\\n            return []\\n\\n        nums = [int(i) for i in num]\\n        res = []\\n        \\n        def dfs(i, expr, prod, prevSum, curr):\\n            \"\"\"\\n            previous result can be interpreted as: a product of a sequence of numbers + a prevous result\\n            :param i: position in num\\n            :param expr: current expression\\n            :param prod: current product, e.g. 2*1*3 for \\'2*4+0+2*1*3\\'\\n            :param prevSum: value of expression before product, e.g. 2*4+0=0 for \\'2*4+0+2*1*3\\'\\n            :param curr: most recent number, e.g. 21 in expression \\'20+21\\' \\n            \"\"\"\\n            if i == len(nums)-1:\\n                if prevSum + prod + nums[i] == target:\\n                    res.append(expr + \\'+\\' + str(nums[i]))\\n                if prevSum + prod - nums[i] == target:\\n                    res.append(expr + \\'-\\' + str(nums[i]))\\n                if prevSum + prod*nums[i] == target:\\n                    res.append(expr + \\'*\\' + str(nums[i]))\\n                # prod = prevProd*curr; \\n                # new_prod = prevProd*(curr*10+nums[i]) = 10*prod + prod//curr*nums[i]\\n                if curr and 10*prod + prod//curr*nums[i] + prevSum == target:\\n                    res.append(expr+str(nums[i]))\\n            else:\\n                dfs(i+1, expr+\\'+\\'+str(nums[i]), nums[i], prod+prevSum, nums[i])\\n                dfs(i+1, expr+\\'-\\'+str(nums[i]), -nums[i], prod+prevSum, nums[i])\\n                dfs(i+1, expr+\\'*\\'+str(nums[i]), nums[i]*prod, prevSum, nums[i])\\n                if curr:\\n                    # append nums[i] directly to last number, impossible when last number is 0\\n                    dfs(i+1, expr+str(nums[i]), 10*prod + prod//curr*nums[i], prevSum, 10*curr+nums[i])\\n        \\n        dfs(1, str(nums[0]), nums[0], 0, nums[0])\\n        return res\\n```\\n\\nRun time: 417ms(100%)",
                "solutionTags": [],
                "code": "```\\nclass Solution(object):\\n    def addOperators(self, num, target):\\n        \"\"\"\\n        :type num: str\\n        :type target: int\\n        :rtype: List[str]\\n        \"\"\"\\n        if not num:\\n            return []\\n        if len(num) == 1:\\n            if int(num) == target:\\n                return [num]\\n            return []\\n\\n        nums = [int(i) for i in num]\\n        res = []\\n        \\n        def dfs(i, expr, prod, prevSum, curr):\\n            \"\"\"\\n            previous result can be interpreted as: a product of a sequence of numbers + a prevous result\\n            :param i: position in num\\n            :param expr: current expression\\n            :param prod: current product, e.g. 2*1*3 for \\'2*4+0+2*1*3\\'\\n            :param prevSum: value of expression before product, e.g. 2*4+0=0 for \\'2*4+0+2*1*3\\'\\n            :param curr: most recent number, e.g. 21 in expression \\'20+21\\' \\n            \"\"\"\\n            if i == len(nums)-1:\\n                if prevSum + prod + nums[i] == target:\\n                    res.append(expr + \\'+\\' + str(nums[i]))\\n                if prevSum + prod - nums[i] == target:\\n                    res.append(expr + \\'-\\' + str(nums[i]))\\n                if prevSum + prod*nums[i] == target:\\n                    res.append(expr + \\'*\\' + str(nums[i]))\\n                # prod = prevProd*curr; \\n                # new_prod = prevProd*(curr*10+nums[i]) = 10*prod + prod//curr*nums[i]\\n                if curr and 10*prod + prod//curr*nums[i] + prevSum == target:\\n                    res.append(expr+str(nums[i]))\\n            else:\\n                dfs(i+1, expr+\\'+\\'+str(nums[i]), nums[i], prod+prevSum, nums[i])\\n                dfs(i+1, expr+\\'-\\'+str(nums[i]), -nums[i], prod+prevSum, nums[i])\\n                dfs(i+1, expr+\\'*\\'+str(nums[i]), nums[i]*prod, prevSum, nums[i])\\n                if curr:\\n                    # append nums[i] directly to last number, impossible when last number is 0\\n                    dfs(i+1, expr+str(nums[i]), 10*prod + prod//curr*nums[i], prevSum, 10*curr+nums[i])\\n        \\n        dfs(1, str(nums[0]), nums[0], 0, nums[0])\\n        return res\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2631886,
                "title": "python-3-282-expression-add-operators-t-m-87-88",
                "content": "```\\nclass Solution:\\n    def addOperators(self, num: str, target: int) -> List[str]:\\n\\n        def dfs(num: str, tmp: str, curr:int, prev:int) -> None:\\n            nonlocal target\\n            if not num:\\n                if curr == target:\\n                    ans.append(tmp)\\n                return\\n\\n            for i in range(len(num)):\\n                pref, suff = num[i+1:], num[:i+1]\\n                if i == 0 or i > 0 and num[0] != \"0\":\\n                    dfs(pref, tmp + \"+\" + suff, curr+int(suff), int(suff))\\n                    dfs(pref, tmp + \"-\" + suff, curr-int(suff), -int(suff))\\n                    dfs(pref, tmp + \"*\" + suff, curr-prev+prev*int(suff), prev*int(suff))\\n            return\\n\\n        ans, target = [], target\\n\\n        for i in range(len(num)):\\n            if i == 0 or i > 0 and num[0] != \\'0\\':\\n                dfs(num[i+1:], num[:i+1], int(num[:i+1]), int(num[:i+1]))\\n\\n        return ans\\n```\\n[https://leetcode.com/submissions/detail/809999125/](http://)",
                "solutionTags": [
                    "Python",
                    "Depth-First Search"
                ],
                "code": "```\\nclass Solution:\\n    def addOperators(self, num: str, target: int) -> List[str]:\\n\\n        def dfs(num: str, tmp: str, curr:int, prev:int) -> None:\\n            nonlocal target\\n            if not num:\\n                if curr == target:\\n                    ans.append(tmp)\\n                return\\n\\n            for i in range(len(num)):\\n                pref, suff = num[i+1:], num[:i+1]\\n                if i == 0 or i > 0 and num[0] != \"0\":\\n                    dfs(pref, tmp + \"+\" + suff, curr+int(suff), int(suff))\\n                    dfs(pref, tmp + \"-\" + suff, curr-int(suff), -int(suff))\\n                    dfs(pref, tmp + \"*\" + suff, curr-prev+prev*int(suff), prev*int(suff))\\n            return\\n\\n        ans, target = [], target\\n\\n        for i in range(len(num)):\\n            if i == 0 or i > 0 and num[0] != \\'0\\':\\n                dfs(num[i+1:], num[:i+1], int(num[:i+1]), int(num[:i+1]))\\n\\n        return ans\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1726419,
                "title": "short-python-solution-using-backtracking-and-on-the-fly-evaluation",
                "content": "The idea is to iterate through the number string, form a number out of the digits encountered till that point, and test all three signs with that and the accumulated list of numbers, called the trace.\\n\\nI have tried to add comprehensive comments. However, if there is any lack of clarity or possible improvement, please feel free to comment.\\n```\\nclass Solution:\\n    def addOperators(self, num: str, target: int) -> List[str]:\\n\\t\\n        # Initializing the resulting list\\n        res = []\\n\\t\\t\\n        def backtrack(num, path, trace):\\n            nonlocal res\\n\\t\\t\\t\\n            # Here, we have reached the end of the number string, i.e., there is no digit left\\n            if not num:\\n                # Our trace contains only +ve/-ve numbers that can simply be summed up to get the evaluated value.\\n                # If the sum is equal to the target, we add the path (expression string) to the result list.\\n                if sum(trace) == target: res.append(path)\\n                return\\n\\t\\t\\t\\t\\n            # curr is the current value of the candidate integer\\n            # i is the position in the number string\\n            # Since we are passing only the remaining part of the String to the next recursive call, i starts from 0\\n            # rlim is the range which handles the case where we don\\'t include numbers with leading zeros like 05, 012 etc\\n            curr, i, rlim = 0, 0, len(num) if num[0] != \\'0\\' else 1\\n\\t\\t\\t\\n            # This loop iterates through the number string and includes a new digit into the candidate number at each iteration\\n            # This would ensure that we are trying 1, 12, 123 for a string that starts with \"123\"\\n            while i < rlim:\\n\\t\\t\\t\\n                curr = curr*10 + int(num[i])\\n                i += 1\\n\\t\\t\\t\\t\\n                # If we have already got some numbers, we enter this condition\\n                if trace:\\n                    # If the operation is simple \\'+\\' or \\'-\\', we can add the number with the sign to the trace\\n                    backtrack(num[i:], path+\\'+\\'+num[:i], trace+[curr])\\n                    backtrack(num[i:], path+\\'-\\'+num[:i], trace+[-curr])\\n                    # If the sign is *, we have to pick up the last element of the trace, multiply it with the current number, and append it back to the trace\\n                    backtrack(num[i:], path+\\'*\\'+num[:i], trace[:-1]+[curr*trace[-1]])\\n\\t\\t\\t\\t\\t\\n                # If there is no trace, we simply have to add the positive number to the same\\n                else:\\n                    backtrack(num[i:], num[:i], [curr])\\n\\t\\t\\t\\t\\t\\n        backtrack(num, \\'\\', [])\\n        return res\\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nclass Solution:\\n    def addOperators(self, num: str, target: int) -> List[str]:\\n\\t\\n        # Initializing the resulting list\\n        res = []\\n\\t\\t\\n        def backtrack(num, path, trace):\\n            nonlocal res\\n\\t\\t\\t\\n            # Here, we have reached the end of the number string, i.e., there is no digit left\\n            if not num:\\n                # Our trace contains only +ve/-ve numbers that can simply be summed up to get the evaluated value.\\n                # If the sum is equal to the target, we add the path (expression string) to the result list.\\n                if sum(trace) == target: res.append(path)\\n                return\\n\\t\\t\\t\\t\\n            # curr is the current value of the candidate integer\\n            # i is the position in the number string\\n            # Since we are passing only the remaining part of the String to the next recursive call, i starts from 0\\n            # rlim is the range which handles the case where we don\\'t include numbers with leading zeros like 05, 012 etc\\n            curr, i, rlim = 0, 0, len(num) if num[0] != \\'0\\' else 1\\n\\t\\t\\t\\n            # This loop iterates through the number string and includes a new digit into the candidate number at each iteration\\n            # This would ensure that we are trying 1, 12, 123 for a string that starts with \"123\"\\n            while i < rlim:\\n\\t\\t\\t\\n                curr = curr*10 + int(num[i])\\n                i += 1\\n\\t\\t\\t\\t\\n                # If we have already got some numbers, we enter this condition\\n                if trace:\\n                    # If the operation is simple \\'+\\' or \\'-\\', we can add the number with the sign to the trace\\n                    backtrack(num[i:], path+\\'+\\'+num[:i], trace+[curr])\\n                    backtrack(num[i:], path+\\'-\\'+num[:i], trace+[-curr])\\n                    # If the sign is *, we have to pick up the last element of the trace, multiply it with the current number, and append it back to the trace\\n                    backtrack(num[i:], path+\\'*\\'+num[:i], trace[:-1]+[curr*trace[-1]])\\n\\t\\t\\t\\t\\t\\n                # If there is no trace, we simply have to add the positive number to the same\\n                else:\\n                    backtrack(num[i:], num[:i], [curr])\\n\\t\\t\\t\\t\\t\\n        backtrack(num, \\'\\', [])\\n        return res\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1324527,
                "title": "worst-problem-i-have-seen-on-lc-took-me-3-hours-to-ac-java-backtracking",
                "content": "1. Just backtrack every possible combination\\n2. Maintain a set of outputs to avoid duplicacy\\n3. Keep track of previous operator and operand. This will help you reverse the previous action when you will encounter * operation.\\n\\nHappy to explain.\\n\\n```\\nclass Solution {\\n    final char[] operators = {\\'+\\', \\'-\\', \\'*\\'};\\n    public List<String> addOperators(String num, int target) {\\n        Set<String> result = new HashSet<>();\\n        util(result, new StringBuilder(), num, target, -1, 0, num.length(), 3, 0, true);\\n        return result.stream().collect(Collectors.toList());\\n    }\\n    \\n    private void util(Set<String> result, StringBuilder sb, String num, int target, int current, int start, int len, int operatorLen, int prev, boolean isPositive) {\\n        if(current == target && start == len) {\\n            result.add(sb.toString());\\n            return;\\n        }\\n        for(int i = start; i < len; ++i) {\\n            String tempStr = num.substring(start, i + 1);\\n            if(tempStr.length() > 1 && tempStr.charAt(0) == \\'0\\') continue;\\n            if(Long.parseLong(tempStr) > Integer.MAX_VALUE) continue;\\n            int currentNum = Integer.parseInt(tempStr);\\n            for(int j = 0; j < operatorLen; ++j) {\\n                int sbLen = sb.length();\\n                int prevCurrent = current;\\n                int prevPrev = prev;\\n                boolean prevIsPositive = isPositive;\\n                if(sbLen > 0) {\\n                    sb.append(operators[j]);\\n                    switch(operators[j]) {\\n                        case \\'+\\':\\n                            current += currentNum;\\n                            prev = currentNum;\\n                            isPositive = true;\\n                            break;\\n                        case \\'-\\':\\n                            current -= currentNum;\\n                            prev = currentNum;\\n                            isPositive = false;\\n                            break;\\n                        case \\'*\\':\\n                            if(isPositive) {\\n                                current -= prev;\\n                                prev *= currentNum;\\n                                current += (prev);\\n                            } else {\\n                                current += prev;\\n                                prev *= currentNum;\\n                                current -= (prev);\\n                            }\\n                            break;\\n                    }\\n                } else {\\n                    current = currentNum;\\n                    prev = currentNum;\\n                }\\n                sb.append(tempStr);\\n                util(result, sb, num, target, current, i + 1, len, operatorLen, prev, isPositive);\\n                sb.setLength(sbLen);\\n                current = prevCurrent;\\n                prev = prevPrev;\\n                isPositive = prevIsPositive;\\n            }\\n        }\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Backtracking"
                ],
                "code": "```\\nclass Solution {\\n    final char[] operators = {\\'+\\', \\'-\\', \\'*\\'};\\n    public List<String> addOperators(String num, int target) {\\n        Set<String> result = new HashSet<>();\\n        util(result, new StringBuilder(), num, target, -1, 0, num.length(), 3, 0, true);\\n        return result.stream().collect(Collectors.toList());\\n    }\\n    \\n    private void util(Set<String> result, StringBuilder sb, String num, int target, int current, int start, int len, int operatorLen, int prev, boolean isPositive) {\\n        if(current == target && start == len) {\\n            result.add(sb.toString());\\n            return;\\n        }\\n        for(int i = start; i < len; ++i) {\\n            String tempStr = num.substring(start, i + 1);\\n            if(tempStr.length() > 1 && tempStr.charAt(0) == \\'0\\') continue;\\n            if(Long.parseLong(tempStr) > Integer.MAX_VALUE) continue;\\n            int currentNum = Integer.parseInt(tempStr);\\n            for(int j = 0; j < operatorLen; ++j) {\\n                int sbLen = sb.length();\\n                int prevCurrent = current;\\n                int prevPrev = prev;\\n                boolean prevIsPositive = isPositive;\\n                if(sbLen > 0) {\\n                    sb.append(operators[j]);\\n                    switch(operators[j]) {\\n                        case \\'+\\':\\n                            current += currentNum;\\n                            prev = currentNum;\\n                            isPositive = true;\\n                            break;\\n                        case \\'-\\':\\n                            current -= currentNum;\\n                            prev = currentNum;\\n                            isPositive = false;\\n                            break;\\n                        case \\'*\\':\\n                            if(isPositive) {\\n                                current -= prev;\\n                                prev *= currentNum;\\n                                current += (prev);\\n                            } else {\\n                                current += prev;\\n                                prev *= currentNum;\\n                                current -= (prev);\\n                            }\\n                            break;\\n                    }\\n                } else {\\n                    current = currentNum;\\n                    prev = currentNum;\\n                }\\n                sb.append(tempStr);\\n                util(result, sb, num, target, current, i + 1, len, operatorLen, prev, isPositive);\\n                sb.setLength(sbLen);\\n                current = prevCurrent;\\n                prev = prevPrev;\\n                isPositive = prevIsPositive;\\n            }\\n        }\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1031229,
                "title": "python-simple-heavily-commented-and-accepted-recursive-solution",
                "content": "Simple and easy to understand solution. This solution evaluates the expression on the fly so it saves additonal computation of evaluating the value in the end\\n\\n```\\nclass Solution:\\n    def addOperators(self, num: str, target: int) -> List[str]:\\n        exprs = []\\n        \\n        def recurse(idx, value, delta, exp):\\n            # base case here\\n            if idx == len(num):\\n                if value == target:\\n                    exprs.append(\"\".join(exp))\\n            \\n            # the loop will create the current operand and recursively call\\n            # the next set of actions to be executed\\n            for i in range(idx, len(num)):\\n                # this is to avoid cases where the operand starts with a 0\\n                # we need to have a case with just the 0 but not something like\\n                # 05, so the condition will return early if we find such cases\\n                if num[idx] == \\'0\\' and i > idx:\\n                    return\\n                \\n                curr = int(num[idx:i+1])\\n                curr_str = num[idx:i+1]\\n                \\n                # when we start the problem we dont have a preceding operator or operand\\n                if idx == 0:\\n                    recurse(i+1, curr, curr, exp + [curr_str])\\n                else:\\n                    # We need to do 3 different recursions for each operator\\n                    # value stores the running value of the expression evaluated so far\\n                    # the crux of the logic lies in how we use and pass delta\\n                    # when the operation is \\'+\\' or \\'-\\' we don\\'t care much about it and can just\\n                    # add or subtract it from the value \\n                    # when \\'*\\' is involved, we need to follow the precedence relation,\\n                    # but we have already evaluated the previous operator. We know the\\n                    # previous operation that was performed and how much it contributed to the value i.e., delta\\n                    # so, we can revert that operation by subtracting delta from value and reapplying the multiplication\\n                    recurse(i+1, value+curr, curr, exp + [\\'+\\', curr_str])\\n                    recurse(i+1, value-curr, -curr, exp + [\\'-\\', curr_str])\\n                    recurse(i+1, (value-delta)+curr*delta, curr*delta, exp + [\\'*\\', curr_str])\\n                            \\n        recurse(0, 0, 0, [])\\n        return exprs\\n                            \\n            \\n```",
                "solutionTags": [
                    "Python3",
                    "Recursion"
                ],
                "code": "```\\nclass Solution:\\n    def addOperators(self, num: str, target: int) -> List[str]:\\n        exprs = []\\n        \\n        def recurse(idx, value, delta, exp):\\n            # base case here\\n            if idx == len(num):\\n                if value == target:\\n                    exprs.append(\"\".join(exp))\\n            \\n            # the loop will create the current operand and recursively call\\n            # the next set of actions to be executed\\n            for i in range(idx, len(num)):\\n                # this is to avoid cases where the operand starts with a 0\\n                # we need to have a case with just the 0 but not something like\\n                # 05, so the condition will return early if we find such cases\\n                if num[idx] == \\'0\\' and i > idx:\\n                    return\\n                \\n                curr = int(num[idx:i+1])\\n                curr_str = num[idx:i+1]\\n                \\n                # when we start the problem we dont have a preceding operator or operand\\n                if idx == 0:\\n                    recurse(i+1, curr, curr, exp + [curr_str])\\n                else:\\n                    # We need to do 3 different recursions for each operator\\n                    # value stores the running value of the expression evaluated so far\\n                    # the crux of the logic lies in how we use and pass delta\\n                    # when the operation is \\'+\\' or \\'-\\' we don\\'t care much about it and can just\\n                    # add or subtract it from the value \\n                    # when \\'*\\' is involved, we need to follow the precedence relation,\\n                    # but we have already evaluated the previous operator. We know the\\n                    # previous operation that was performed and how much it contributed to the value i.e., delta\\n                    # so, we can revert that operation by subtracting delta from value and reapplying the multiplication\\n                    recurse(i+1, value+curr, curr, exp + [\\'+\\', curr_str])\\n                    recurse(i+1, value-curr, -curr, exp + [\\'-\\', curr_str])\\n                    recurse(i+1, (value-delta)+curr*delta, curr*delta, exp + [\\'*\\', curr_str])\\n                            \\n        recurse(0, 0, 0, [])\\n        return exprs\\n                            \\n            \\n```",
                "codeTag": "Java"
            },
            {
                "id": 71923,
                "title": "some-thougths",
                "content": "The following DFS is similar to top solutions.\\n* c++\\n```\\n    vector<string> addOperators(string num, int target) {\\n        vector<string> exp;\\n        string cur;\\n        dfs(0,0,0,target,cur,num,exp);\\n        return exp;\\n    }\\n    void dfs(int p, int prod, long res, int target, string& cur, string &num,vector<string>& exp) {\\n        int n = num.size();\\n        if(p==n && res==target) exp.push_back(cur);\\n        long v = 0;\\n        int sz = cur.size(); \\n        string s;\\n        for(int i=p;i<n;i++) {\\n            v=v*10+num[i]-\\'0\\';\\n            s+=num[i];\\n            if(cur.empty()) dfs(i+1,v,res+v,target,cur+=s,num,exp);\\n            else {\\n                dfs(i+1,v,res+v,target,cur+=\\'+\\'+s,num,exp);\\n                cur.resize(sz);\\n                dfs(i+1,-v,res-v,target,cur+=\\'-\\'+s,num,exp);\\n                cur.resize(sz);\\n                dfs(i+1,prod*v,res-prod+prod*v,target,cur+=\\'*\\'+s,num,exp);\\n            }\\n            cur.resize(sz);\\n            if(!v) return;\\n        }\\n    }\\n``` \\n* java\\n```\\n\\tList<String> res;\\n    public List<String> addOperators(String num, int target) {\\n        res=new ArrayList<>();\\n        dfs(0,0,0,target,num,new StringBuilder());\\n        return res;\\n    }\\n    private void dfs(int p, long eval, long mult, int target, String num, StringBuilder sb) {\\n        int n=num.length();\\n        if(p==n) {\\n            if(eval==target) {\\n                res.add(sb.toString());\\n            }\\n        }\\n        int len=sb.length();\\n        long number=0;\\n        for(int i=p;i<n;i++) {\\n            number = number*10 + num.charAt(i)-\\'0\\';\\n            if(p==0) {//no sign before first number\\n                dfs(i+1,number,number,target,num,sb.append(number));\\n                sb.setLength(len);\\n            } else {\\n                dfs(i+1,eval+number,number,target,num,sb.append(\\'+\\').append(number));\\n                sb.setLength(len);\\n                dfs(i+1,eval-number,-number,target,num,sb.append(\\'-\\').append(number));\\n                sb.setLength(len);\\n                dfs(i+1,eval-mult+mult*number,mult*number,target,num,sb.append(\\'*\\').append(number));\\n                sb.setLength(len);\\n            }\\n            if(num.charAt(p)==\\'0\\') { //01 is invalid\\n                return;\\n            }\\n        }\\n    }\\n```\\nTime complexity O(4^n)\\nT(n) = 3 * T(n-1) + 3 * T(n-2) + 3 * T(n-3) + ... + 3 *T(1);\\nT(n-1) = 3 * T(n-2) + 3 * T(n-3) + ... 3 * T(1);\\nThus T(n) = 4T(n-1);\\n\\nSpace complexity O(n)\\nIgnoring the large output, space complexity is depth of the recursion.\\n\\nMost recursions can be speeded up by memorization. How about this one? No, because there is no duplicate states.\\n\\nHow about BFS? If a problem can be solved by one, we can solve it by the other. DFS has much lower memory requirements than BFS because it is not necessary to store all the children at each level. The search space is exponential so BFS space complexity is exponential which makes it not acceptable.",
                "solutionTags": [
                    "Java",
                    "C"
                ],
                "code": "```\\n    vector<string> addOperators(string num, int target) {\\n        vector<string> exp;\\n        string cur;\\n        dfs(0,0,0,target,cur,num,exp);\\n        return exp;\\n    }\\n    void dfs(int p, int prod, long res, int target, string& cur, string &num,vector<string>& exp) {\\n        int n = num.size();\\n        if(p==n && res==target) exp.push_back(cur);\\n        long v = 0;\\n        int sz = cur.size(); \\n        string s;\\n        for(int i=p;i<n;i++) {\\n            v=v*10+num[i]-\\'0\\';\\n            s+=num[i];\\n            if(cur.empty()) dfs(i+1,v,res+v,target,cur+=s,num,exp);\\n            else {\\n                dfs(i+1,v,res+v,target,cur+=\\'+\\'+s,num,exp);\\n                cur.resize(sz);\\n                dfs(i+1,-v,res-v,target,cur+=\\'-\\'+s,num,exp);\\n                cur.resize(sz);\\n                dfs(i+1,prod*v,res-prod+prod*v,target,cur+=\\'*\\'+s,num,exp);\\n            }\\n            cur.resize(sz);\\n            if(!v) return;\\n        }\\n    }\\n```\n```\\n\\tList<String> res;\\n    public List<String> addOperators(String num, int target) {\\n        res=new ArrayList<>();\\n        dfs(0,0,0,target,num,new StringBuilder());\\n        return res;\\n    }\\n    private void dfs(int p, long eval, long mult, int target, String num, StringBuilder sb) {\\n        int n=num.length();\\n        if(p==n) {\\n            if(eval==target) {\\n                res.add(sb.toString());\\n            }\\n        }\\n        int len=sb.length();\\n        long number=0;\\n        for(int i=p;i<n;i++) {\\n            number = number*10 + num.charAt(i)-\\'0\\';\\n            if(p==0) {//no sign before first number\\n                dfs(i+1,number,number,target,num,sb.append(number));\\n                sb.setLength(len);\\n            } else {\\n                dfs(i+1,eval+number,number,target,num,sb.append(\\'+\\').append(number));\\n                sb.setLength(len);\\n                dfs(i+1,eval-number,-number,target,num,sb.append(\\'-\\').append(number));\\n                sb.setLength(len);\\n                dfs(i+1,eval-mult+mult*number,mult*number,target,num,sb.append(\\'*\\').append(number));\\n                sb.setLength(len);\\n            }\\n            if(num.charAt(p)==\\'0\\') { //01 is invalid\\n                return;\\n            }\\n        }\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 71959,
                "title": "c-solution-with-explanation",
                "content": "We can consider a number \"12\" or a product of numbers \"1*2\" as a subset, '+' or '-' will be the separator for subsets. Whenever we inserts a '+' or '-', product will be reset to be 1. \\n\\n\\n    Pattern: \\n    sumSofar + sign(1/-1) * [product * concatenate(lastNum, num[pos]) operator]\\n\\ne.g. num: \"1142356\" \\n    \\n    One possible sequence till position 5:    1+142*35[*/-/+/none]\\n    Before position 5:\\n    sumSofar = 1, product = 142, lastNum = 3, curNum = 35, sign = 1\\n    Now, so here, one of the three operators '*', '-', '+' or none of them can be inserted after 3.\\n    '*':  path-> `1+142*35*`, lastNum -> 0, product -> 142 * 35 * 1\\n    '+':  path-> `1+142*35+`, lastNum -> 0, product -> 1, sumSofar += 142 * 35 * 1, sign -> 1 \\n    '-':  path-> `1+142*35-`, lastNum -> 0, product -> 1, sumSofar += 142 * 35 * 1, sign -> -1\\n    none: path-> `1+142*35`, lastNum -> curNum = 35 \\n\\n \\n\\n\\nCode\\n\\n    class Solution {\\n    public:\\n        vector<string> addOperators(string num, int target) {\\n            vector<string> answer;\\n            if(num.size()) dfs(num, 0, target, 0, 1, 0, \"\", answer, 1); // pos: next to process position num[pos]\\n            return answer;\\n        }\\n        \\n        void dfs(string &num, int pos, int target, long long lastNum, long long product, long long sumSofar, string path, vector<string> &answer, int sign){\\n            \\n            long long curNum = lastNum * 10 + num[pos] - '0'; \\n            if(pos + 1 == num.size()){\\n                if(sumSofar + product * curNum * sign == target)\\n                    answer.push_back(path + num[pos]);\\n                return; \\n            }\\n            // for pos < num.size() - 1, \\u201c*\\u201d / \\u201c+\\u201d / \\u201c-\\u201d / no op / can be inserted after num[pos]\\n            dfs(num, pos + 1, target, 0, product * curNum, sumSofar, path + num[pos] + \"*\", answer, sign); // *\\n            dfs(num, pos + 1, target, 0, 1, sumSofar + product * curNum * sign, path + num[pos] + \"+\", answer, 1); // +\\n            dfs(num, pos + 1, target, 0, 1, sumSofar + product * curNum * sign, path + num[pos] + \"-\", answer, -1); // -\\n            if(curNum != 0) dfs(num, pos + 1, target, curNum, product, sumSofar, path + num[pos], answer, sign); // no operator\\n        } \\n    };",
                "solutionTags": [
                    "C++"
                ],
                "code": "class Solution {\\n    public:\\n        vector<string> addOperators(string num, int target) {\\n            vector<string> answer;\\n            if(num.size()) dfs(num, 0, target, 0, 1, 0, \"\", answer, 1); // pos: next to process position num[pos]\\n            return answer;\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 71966,
                "title": "my-20ms-c-dfs-solution",
                "content": "    typedef long long int Int64;\\n    \\n    class Solution {\\n    private:\\n        const char *numstr;\\n        Int64 target64;\\n        int n;\\n        \\n        void dfs(Int64 prev, Int64 curr, int next, char* buffer, int buffernext, vector<string>& res)\\n        {\\n            if(next == n)\\n            {\\n                buffer[buffernext] = '\\\\0';\\n                if(prev+curr == target64)\\n                {\\n                    string s = buffer;\\n                    res.push_back(s);\\n                }\\n                return;\\n            }\\n            \\n            int lm;\\n            if(numstr[next] == '0')\\n                lm = next+1;\\n            else\\n                lm = n;\\n            \\n            int l;\\n            Int64 v=0;\\n            for(l=next; l<lm; l++)\\n            {\\n                buffer[buffernext+l-next+1] = numstr[l];\\n                v = v*10 + (numstr[l] - '0');\\n                \\n                buffer[buffernext] = '+';\\n                dfs(prev+curr, v, l+1, buffer, buffernext+l-next+2, res);\\n                \\n                buffer[buffernext] = '-';\\n                dfs(prev+curr, -v, l+1, buffer, buffernext+l-next+2, res);\\n                \\n                buffer[buffernext] = '*';\\n                dfs(prev, curr*v, l+1, buffer, buffernext+l-next+2, res);\\n            }\\n        }\\n    public:\\n        vector<string> addOperators(string num, int target) {\\n            vector<string> result;\\n            \\n            n = num.size();\\n            target64 = (Int64) target;\\n            numstr = num.c_str();\\n            \\n            char buf[2*n];\\n            int lmax;\\n            if(numstr[0] == '0') // A number starts with '0' must be 0\\n                lmax = 1;\\n            else\\n                lmax = n;\\n            int i;\\n            Int64 previous = 0;\\n            Int64 current = 0;\\n            for(i=0; i<lmax; i++)\\n            {\\n                current = current*10 + (numstr[i] - '0');\\n                buf[i] = numstr[i];\\n                dfs(previous, current, i+1, buf, i+1, result);\\n            }\\n            return result;\\n        }\\n    };",
                "solutionTags": [
                    "C++",
                    "Depth-First Search"
                ],
                "code": "class Solution {\\n    private:\\n        const char *numstr;\\n        Int64 target64;\\n        int n;\\n        \\n        void dfs(Int64 prev, Int64 curr, int next, char* buffer, int buffernext, vector<string>& res)\\n        {\\n            if(next == n)\\n            {\\n                buffer[buffernext] = '\\\\0';\\n                if(prev+curr == target64)\\n                {\\n                    string s = buffer;\\n                    res.push_back(s);\\n                }",
                "codeTag": "Java"
            },
            {
                "id": 3330455,
                "title": "well-explained-python-code",
                "content": "\\n\\n# Code\\n```\\nclass Solution:\\n    def addOperators(self, s: str, target: int) -> List[str]:\\n        # need to traverse through s\\n        # backtrack each case of  start index and then +,*,-\\n        # need empty array ofcourse\\n        # need curidx = i\\n        # need the str path to append to the arr if my --> cur_num == target\\n        # need the prevNum access for multiplication\\n        # 1 2 3 4 5 --> 1 + 2 + 3 + 4 * 5\\n        #               ^ ^ ^ ^ ^ ^ ^ == 10 but we wanna do 4*5 so ---\\n        # just do 1 + 2 + 3 + 4 + (- 4) + (4 * 5)\\n        # return ans\\n        \\n        res = []\\n\\n        def dfs(i, path, cur_num, prevNum):\\n            if i == len(s):\\n                if cur_num == target:\\n                    res.append(path)\\n                return\\n            \\n            for j in range(i, len(s)):\\n                # starting with zero?\\n                if j > i and s[i] == \\'0\\':\\n                    break\\n                num = int(s[i:j+1])\\n\\n                # if cur index is 0 then simple add that number\\n                if i == 0:\\n                    dfs(j + 1, path + str(num), cur_num + num, num)\\n                else:\\n                    dfs(j + 1, path + \"+\" + str(num), cur_num + num, num)\\n                    dfs(j + 1, path + \"-\" + str(num), cur_num - num, -num)\\n                    dfs(j + 1, path + \"*\" + str(num), cur_num - prevNum + prevNum * num, prevNum * num)\\n        \\n        dfs(0, \"\", 0, 0)\\n        return res\\n        \\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def addOperators(self, s: str, target: int) -> List[str]:\\n        # need to traverse through s\\n        # backtrack each case of  start index and then +,*,-\\n        # need empty array ofcourse\\n        # need curidx = i\\n        # need the str path to append to the arr if my --> cur_num == target\\n        # need the prevNum access for multiplication\\n        # 1 2 3 4 5 --> 1 + 2 + 3 + 4 * 5\\n        #               ^ ^ ^ ^ ^ ^ ^ == 10 but we wanna do 4*5 so ---\\n        # just do 1 + 2 + 3 + 4 + (- 4) + (4 * 5)\\n        # return ans\\n        \\n        res = []\\n\\n        def dfs(i, path, cur_num, prevNum):\\n            if i == len(s):\\n                if cur_num == target:\\n                    res.append(path)\\n                return\\n            \\n            for j in range(i, len(s)):\\n                # starting with zero?\\n                if j > i and s[i] == \\'0\\':\\n                    break\\n                num = int(s[i:j+1])\\n\\n                # if cur index is 0 then simple add that number\\n                if i == 0:\\n                    dfs(j + 1, path + str(num), cur_num + num, num)\\n                else:\\n                    dfs(j + 1, path + \"+\" + str(num), cur_num + num, num)\\n                    dfs(j + 1, path + \"-\" + str(num), cur_num - num, -num)\\n                    dfs(j + 1, path + \"*\" + str(num), cur_num - prevNum + prevNum * num, prevNum * num)\\n        \\n        dfs(0, \"\", 0, 0)\\n        return res\\n        \\n```",
                "codeTag": "Java"
            },
            {
                "id": 2511436,
                "title": "python-recursive-dfs-step-by-step-walkthrough-long-post",
                "content": "**Intuition**\\n\\n1. We start off the problem by enumerating all possible ways to split up our numbers:\\n\\t```\\n\\tdef dfs(i: int, expr: List[str]):\\n\\t\\tif i == n:\\n\\t\\t\\t# evaluate expression\\n\\t\\t\\treturn\\n\\n\\t\\tfor j in range(i, n):\\n\\t\\t    # for every position in between digits\\n\\t\\t\\t# we add a break\\n\\t\\t\\tdfs(j + 1, expr + [num[i:j + 1]])\\n\\t```\\n\\t\\n2. Not too bad so far. Then we add our operators:\\n\\t```\\n\\tdef dfs(i: int, expr: List[str]):\\n\\t\\tif i == n:\\n\\t\\t\\t# evaluate expression\\n\\t\\t\\treturn\\n\\n\\t\\tfor j in range(i, n):\\n\\t\\t\\tif not expr:\\n\\t\\t\\t\\t# we are at the beginning of the num\\n\\t\\t\\t\\t# we cannot add operators before any\\n\\t\\t\\t\\t# digits\\n\\t\\t\\t\\tdfs(j + 1, expr + [num[i:j + 1]])\\n\\t\\t\\telse:\\n\\t\\t\\t\\tdfs(j + 1, expr + [\"+\"] + [num[i:j + 1]])\\n\\t\\t\\t\\tdfs(j + 1, expr + [\"-\"] + [num[i:j + 1]])\\n\\t\\t\\t\\tdfs(j + 1, expr + [\"*\"] + [num[i:j + 1]])\\n\\t```\\n\\n3. You will notice that the above doesn\\'t account for numbers with leading zeroes. So we add that edge case check in our DFS:\\n\\t```\\n\\tdef dfs(i: int, expr: List[str]):\\n\\t\\tif i == n:\\n\\t\\t\\t# evaluate expression\\n\\t\\t\\treturn\\n\\n\\t\\tfor j in range(i, n):\\n\\t\\t\\tif not expr:\\n\\t\\t\\t\\tdfs(j + 1, expr + [num[i:j + 1]])\\n\\t\\t\\telse:\\n\\t\\t\\t\\tdfs(j + 1, expr + [\"+\"] + [num[i:j + 1]])\\n\\t\\t\\t\\tdfs(j + 1, expr + [\"-\"] + [num[i:j + 1]])\\n\\t\\t\\t\\tdfs(j + 1, expr + [\"*\"] + [num[i:j + 1]])\\n\\n\\t\\t\\tif num[i] == \"0\":\\n\\t\\t\\t\\t# we have a leading zero, only allow a single DFS call\\n\\t\\t\\t\\t# then break\\n\\t\\t\\t\\tbreak\\n\\t```\\n\\n4. If the problem is a bit easier, we might get away with calling `eval(expr)` once we generate the permutations. However Python is slow and the problem is LC Hard for a reason. So we need to evaluate our expression on-the-fly\\n\\n5. Let\\'s imagine we ONLY had \"+\" and \"-\". We might evaluate our values like so:\\n\\t```\\n\\tdef dfs(i: int, expr: List[str], val):\\n\\t\\tif i == n:\\n            if val == target:\\n\\t\\t\\t    res.append(\"\".join(expr))\\n\\t\\t\\treturn\\n\\n\\t\\tfor j in range(i, n):\\n\\t\\t    operand_str = num[i:j + 1]\\n\\t\\t\\toperand = int(operand_str)\\n\\t\\t\\t\\n\\t\\t\\tif not expr:\\n\\t\\t\\t\\tdfs(j + 1, expr + [operand_str])\\n\\t\\t\\telse:\\n\\t\\t\\t\\tdfs(j + 1, expr + [\"+\"] + [operand_str], val + operand)\\n\\t\\t\\t\\tdfs(j + 1, expr + [\"-\"] + [operand_str], val - operand)\\n\\t\\t\\t\\t\\n\\t\\t\\t\\t# let\\'s ignore multiplying for now\\n\\t\\t\\t\\t# dfs(j + 1, expr + [\"*\"] + [operand_str])\\n\\n\\t\\t\\tif num[i] == \"0\":\\n\\t\\t\\t\\tbreak\\n\\t```\\n\\n6. Almost there! But what about multiplication? It takes precedence over add/subtract. Imagine if we have: `A+B*D`. Using our method in step #5, we might end up with `(A+B)*D`. How do we correct this?\\n\\n7. Let\\'s assume we are stuck with `(A+B)`. Algebraically, we would need to \"undo\" the previous addition like so:\\n\\t```\\n\\t(A + B) - B + B * D = A + (B * D)\\n\\t```\\n\\n8. With this new observation, we have our final DFS implementation:\\n\\n**Solution**\\n```\\nclass Solution:\\n    def addOperators(self, num: str, target: int) -> List[str]:\\n        n = len(num)\\n        \\n        res = []\\n        \\n        def dfs(i: int, expr: List[str], val, prev):\\n            if i == n:\\n                if val == target:\\n                    res.append(\"\".join(expr))\\n                return\\n        \\n            for j in range(i, n):\\n                operand_s = num[i:j + 1]\\n                operand_i = int(operand_s)\\n                \\n                if not expr:\\n                    # we are reading the first number\\n                    # so we do not add any operators yet\\n                    dfs(j + 1, [operand_s], operand_i, operand_i)\\n                    \\n                else:\\n                    dfs(j + 1, expr + [\"+\"] + [operand_s], val + operand_i, operand_i)\\n                    dfs(j + 1, expr + [\"-\"] + [operand_s], val - operand_i, -operand_i)\\n                    \\n                    # when we DFS with a multiply, we need to \"undo\" a previous calculation\\n                    dfs(j + 1, expr + [\"*\"] + [operand_s], val - prev + operand_i * prev, operand_i * prev)\\n                    \\n                if num[i] == \"0\":\\n                    # we only want to dfs ONCE if we are\\n                    # currently reading a zero.\\n                    #\\n                    # for example 0 + 0 + 1 is valid\\n                    # however, 00 + 1 is not valid\\n                    break\\n        \\n        dfs(0, [], 0, 0)\\n        \\n        return res\\n```",
                "solutionTags": [
                    "Python",
                    "Depth-First Search",
                    "Recursion"
                ],
                "code": "```\\n\\tdef dfs(i: int, expr: List[str]):\\n\\t\\tif i == n:\\n\\t\\t\\t# evaluate expression\\n\\t\\t\\treturn\\n\\n\\t\\tfor j in range(i, n):\\n\\t\\t    # for every position in between digits\\n\\t\\t\\t# we add a break\\n\\t\\t\\tdfs(j + 1, expr + [num[i:j + 1]])\\n\\t```\n```\\n\\tdef dfs(i: int, expr: List[str]):\\n\\t\\tif i == n:\\n\\t\\t\\t# evaluate expression\\n\\t\\t\\treturn\\n\\n\\t\\tfor j in range(i, n):\\n\\t\\t\\tif not expr:\\n\\t\\t\\t\\t# we are at the beginning of the num\\n\\t\\t\\t\\t# we cannot add operators before any\\n\\t\\t\\t\\t# digits\\n\\t\\t\\t\\tdfs(j + 1, expr + [num[i:j + 1]])\\n\\t\\t\\telse:\\n\\t\\t\\t\\tdfs(j + 1, expr + [\"+\"] + [num[i:j + 1]])\\n\\t\\t\\t\\tdfs(j + 1, expr + [\"-\"] + [num[i:j + 1]])\\n\\t\\t\\t\\tdfs(j + 1, expr + [\"*\"] + [num[i:j + 1]])\\n\\t```\n```\\n\\tdef dfs(i: int, expr: List[str]):\\n\\t\\tif i == n:\\n\\t\\t\\t# evaluate expression\\n\\t\\t\\treturn\\n\\n\\t\\tfor j in range(i, n):\\n\\t\\t\\tif not expr:\\n\\t\\t\\t\\tdfs(j + 1, expr + [num[i:j + 1]])\\n\\t\\t\\telse:\\n\\t\\t\\t\\tdfs(j + 1, expr + [\"+\"] + [num[i:j + 1]])\\n\\t\\t\\t\\tdfs(j + 1, expr + [\"-\"] + [num[i:j + 1]])\\n\\t\\t\\t\\tdfs(j + 1, expr + [\"*\"] + [num[i:j + 1]])\\n\\n\\t\\t\\tif num[i] == \"0\":\\n\\t\\t\\t\\t# we have a leading zero, only allow a single DFS call\\n\\t\\t\\t\\t# then break\\n\\t\\t\\t\\tbreak\\n\\t```\n```\\n\\tdef dfs(i: int, expr: List[str], val):\\n\\t\\tif i == n:\\n            if val == target:\\n\\t\\t\\t    res.append(\"\".join(expr))\\n\\t\\t\\treturn\\n\\n\\t\\tfor j in range(i, n):\\n\\t\\t    operand_str = num[i:j + 1]\\n\\t\\t\\toperand = int(operand_str)\\n\\t\\t\\t\\n\\t\\t\\tif not expr:\\n\\t\\t\\t\\tdfs(j + 1, expr + [operand_str])\\n\\t\\t\\telse:\\n\\t\\t\\t\\tdfs(j + 1, expr + [\"+\"] + [operand_str], val + operand)\\n\\t\\t\\t\\tdfs(j + 1, expr + [\"-\"] + [operand_str], val - operand)\\n\\t\\t\\t\\t\\n\\t\\t\\t\\t# let\\'s ignore multiplying for now\\n\\t\\t\\t\\t# dfs(j + 1, expr + [\"*\"] + [operand_str])\\n\\n\\t\\t\\tif num[i] == \"0\":\\n\\t\\t\\t\\tbreak\\n\\t```\n```\\n\\t(A + B) - B + B * D = A + (B * D)\\n\\t```\n```\\nclass Solution:\\n    def addOperators(self, num: str, target: int) -> List[str]:\\n        n = len(num)\\n        \\n        res = []\\n        \\n        def dfs(i: int, expr: List[str], val, prev):\\n            if i == n:\\n                if val == target:\\n                    res.append(\"\".join(expr))\\n                return\\n        \\n            for j in range(i, n):\\n                operand_s = num[i:j + 1]\\n                operand_i = int(operand_s)\\n                \\n                if not expr:\\n                    # we are reading the first number\\n                    # so we do not add any operators yet\\n                    dfs(j + 1, [operand_s], operand_i, operand_i)\\n                    \\n                else:\\n                    dfs(j + 1, expr + [\"+\"] + [operand_s], val + operand_i, operand_i)\\n                    dfs(j + 1, expr + [\"-\"] + [operand_s], val - operand_i, -operand_i)\\n                    \\n                    # when we DFS with a multiply, we need to \"undo\" a previous calculation\\n                    dfs(j + 1, expr + [\"*\"] + [operand_s], val - prev + operand_i * prev, operand_i * prev)\\n                    \\n                if num[i] == \"0\":\\n                    # we only want to dfs ONCE if we are\\n                    # currently reading a zero.\\n                    #\\n                    # for example 0 + 0 + 1 is valid\\n                    # however, 00 + 1 is not valid\\n                    break\\n        \\n        dfs(0, [], 0, 0)\\n        \\n        return res\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1910325,
                "title": "expression-add-operators-solution-java",
                "content": "class Solution {\\n  public List<String> addOperators(String num, int target) {\\n    List<String> ans = new ArrayList<>();\\n    dfs(num, target, 0, 0, 0, new StringBuilder(), ans);\\n    return ans;\\n  }\\n\\n  private void dfs(String num, int target, int s, long prev, long eval, StringBuilder sb,\\n                   List<String> ans) {\\n    if (s == num.length()) {\\n      if (eval == target)\\n        ans.add(sb.toString());\\n      return;\\n    }\\n\\n    for (int i = s; i < num.length(); ++i) {\\n      if (i > s && num.charAt(s) == \\'0\\')\\n        return;\\n      final long curr = Long.parseLong(num.substring(s, i + 1));\\n      final int length = sb.length();\\n      if (s == 0) { // first num\\n        dfs(num, target, i + 1, curr, curr, sb.append(curr), ans);\\n        sb.setLength(length);\\n      } else {\\n        dfs(num, target, i + 1, curr, eval + curr, sb.append(\"+\").append(curr), ans);\\n        sb.setLength(length);\\n        dfs(num, target, i + 1, -curr, eval - curr, sb.append(\"-\").append(curr), ans);\\n        sb.setLength(length);\\n        dfs(num, target, i + 1, prev * curr, eval - prev + prev * curr, sb.append(\"*\").append(curr),\\n            ans);\\n        sb.setLength(length);\\n      }\\n    }\\n  }\\n}\\n",
                "solutionTags": [
                    "Math",
                    "String",
                    "Backtracking"
                ],
                "code": "class Solution {\\n  public List<String> addOperators(String num, int target) {\\n    List<String> ans = new ArrayList<>();\\n    dfs(num, target, 0, 0, 0, new StringBuilder(), ans);\\n    return ans;\\n  }",
                "codeTag": "Java"
            },
            {
                "id": 1449082,
                "title": "simple-clean-java-solution",
                "content": "```\\nclass Solution {\\n    public List<String> addOperators(String num, int target) {\\n        List<String> result = new ArrayList<>();\\n        addOperators(num, target, result, 0, 0, 0, \"\");\\n        return result;\\n    }\\n    \\n    private void addOperators(String num, int target, List<String> result, int index, long value, long previous, String current) {\\n        if(index == num.length()) {\\n            if(value + previous == target) {\\n                result.add(current);\\n            }\\n            return;\\n        }\\n        \\n        int end = num.length();\\n        if(num.charAt(index) == \\'0\\') {\\n            end = index + 1;\\n        }\\n        \\n        for(int i = index + 1; i <= end; i ++) {\\n            long currentValue = Long.valueOf(num.substring(index, i));\\n            \\n            if(index == 0) {\\n                addOperators(num, target, result, i, 0, currentValue, String.valueOf(currentValue));\\n                continue;\\n            } \\n            \\n            // Add +\\n            addOperators(num, target, result, i, value + previous, currentValue, current + \"+\" + currentValue);\\n            // Add -\\n            addOperators(num, target, result, i, value + previous, -currentValue, current + \"-\" + currentValue);\\n            // Add *\\n            addOperators(num, target, result, i, value, previous * currentValue, current + \"*\" + currentValue);\\n        }\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public List<String> addOperators(String num, int target) {\\n        List<String> result = new ArrayList<>();\\n        addOperators(num, target, result, 0, 0, 0, \"\");\\n        return result;\\n    }\\n    \\n    private void addOperators(String num, int target, List<String> result, int index, long value, long previous, String current) {\\n        if(index == num.length()) {\\n            if(value + previous == target) {\\n                result.add(current);\\n            }\\n            return;\\n        }\\n        \\n        int end = num.length();\\n        if(num.charAt(index) == \\'0\\') {\\n            end = index + 1;\\n        }\\n        \\n        for(int i = index + 1; i <= end; i ++) {\\n            long currentValue = Long.valueOf(num.substring(index, i));\\n            \\n            if(index == 0) {\\n                addOperators(num, target, result, i, 0, currentValue, String.valueOf(currentValue));\\n                continue;\\n            } \\n            \\n            // Add +\\n            addOperators(num, target, result, i, value + previous, currentValue, current + \"+\" + currentValue);\\n            // Add -\\n            addOperators(num, target, result, i, value + previous, -currentValue, current + \"-\" + currentValue);\\n            // Add *\\n            addOperators(num, target, result, i, value, previous * currentValue, current + \"*\" + currentValue);\\n        }\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1356498,
                "title": "python-recursive-with-stack",
                "content": "It\\'s the same idea as the basic calculator implementation using stack.\\n\\n* if the operator is `+` or `-`, push to stack as is.\\n* if the operator is `*` , pop the stack and multiplly it by the current number, then push the result to the stack\\n\\n```\\nclass Solution:\\n    def addOperators(self, num: str, target: int) -> List[str]:\\n        size = len(num)\\n        \\n        def solve(index: int, stack: list = None, built: str = None) -> List[str]:\\n            if index >= size:\\n                if sum(stack) == target:\\n                    return [built]\\n                else:\\n                    return []\\n            \\n            res = []\\n            \\n            for i in range(index + 1, size + 1):\\n                ns = num[index: i]\\n                if ns[0] == \\'0\\' and i - index > 1:\\n                    break\\n                    \\n                n = int(ns)\\n                \\n                if index == 0:\\n                    res += solve(i, stack=[n], built=ns)\\n                else:\\n                    res += solve(i, stack=stack + [n], built=built + \\'+\\' + ns)\\n                    res += solve(i, stack=stack + [-n], built=built + \\'-\\' + ns)\\n                    res += solve(i, stack=stack[:-1] + [stack[-1] * n], built=built + \\'*\\' + ns)\\n                \\n            return res\\n        \\n        return solve(0)\\n```",
                "solutionTags": [
                    "Python",
                    "Stack"
                ],
                "code": "```\\nclass Solution:\\n    def addOperators(self, num: str, target: int) -> List[str]:\\n        size = len(num)\\n        \\n        def solve(index: int, stack: list = None, built: str = None) -> List[str]:\\n            if index >= size:\\n                if sum(stack) == target:\\n                    return [built]\\n                else:\\n                    return []\\n            \\n            res = []\\n            \\n            for i in range(index + 1, size + 1):\\n                ns = num[index: i]\\n                if ns[0] == \\'0\\' and i - index > 1:\\n                    break\\n                    \\n                n = int(ns)\\n                \\n                if index == 0:\\n                    res += solve(i, stack=[n], built=ns)\\n                else:\\n                    res += solve(i, stack=stack + [n], built=built + \\'+\\' + ns)\\n                    res += solve(i, stack=stack + [-n], built=built + \\'-\\' + ns)\\n                    res += solve(i, stack=stack[:-1] + [stack[-1] * n], built=built + \\'*\\' + ns)\\n                \\n            return res\\n        \\n        return solve(0)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1325327,
                "title": "c-easy-to-understand-backtracking-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    vector<string> res;\\n    \\n    void solve(string str, int idx, string temp, long long last, long long  value, int target) {\\n        \\n        if(idx == str.length()) {\\n            if(value == target)\\n                res.push_back(temp);\\n            return;\\n        }\\n        \\n        \\n        for(int i=idx; i<str.length(); i++) {\\n            \\n            string s = str.substr(idx, i - idx + 1);\\n            \\n            if(s.length() > 1 and s[0] == \\'0\\')\\n                return;\\n            \\n            long long curr = stoll(s);\\n            \\n            if(temp.empty()) {\\n                solve(str, i+1, temp + s, curr, curr, target);\\n            }\\n\\n            else {\\n                solve(str, i+1, temp + \"+\" + s, curr, value + curr, target);\\n                solve(str, i+1, temp + \"-\" + s, -curr, value - curr, target);\\n                solve(str, i+1, temp + \"*\" + s, curr*last, (value - last) + (curr*last) , target);                \\n            }\\n        }\\n    }\\n        \\n        \\n    vector<string> addOperators(string str, int target) {\\n        \\n        solve(str,0,\"\",0,0,target);\\n        \\n        return res;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<string> res;\\n    \\n    void solve(string str, int idx, string temp, long long last, long long  value, int target) {\\n        \\n        if(idx == str.length()) {\\n            if(value == target)\\n                res.push_back(temp);\\n            return;\\n        }\\n        \\n        \\n        for(int i=idx; i<str.length(); i++) {\\n            \\n            string s = str.substr(idx, i - idx + 1);\\n            \\n            if(s.length() > 1 and s[0] == \\'0\\')\\n                return;\\n            \\n            long long curr = stoll(s);\\n            \\n            if(temp.empty()) {\\n                solve(str, i+1, temp + s, curr, curr, target);\\n            }\\n\\n            else {\\n                solve(str, i+1, temp + \"+\" + s, curr, value + curr, target);\\n                solve(str, i+1, temp + \"-\" + s, -curr, value - curr, target);\\n                solve(str, i+1, temp + \"*\" + s, curr*last, (value - last) + (curr*last) , target);                \\n            }\\n        }\\n    }\\n        \\n        \\n    vector<string> addOperators(string str, int target) {\\n        \\n        solve(str,0,\"\",0,0,target);\\n        \\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1070001,
                "title": "why-do-i-get-tle-again-starting-from-examples-cpp-solution-with-analysis",
                "content": "Key point: store temp value & move terms to the right( why don\\'t we change the value right of \"=\")\\nFor those who only needs the solution, go to part IV directly. \\nIf you have any questions or suggestions, feel free to write below.\\n\\n**I. Introduction**\\n\\tTo better explain what I did, please allow me to introduce a new operator \"~\", which means literally combine two numbers. For instance, 1~3 = 13, 67~89 = 6789, -7~8 = -78( pay extra attention to this! ). Noticed that it\\'s different from x*10+y, we need to write a specific function implementing this operator, see function \"combine\" for details.\\n\\t\\n![image](https://assets.leetcode.com/users/images/86455c2f-4687-435e-8aaa-dd19737bdf3d_1619089354.4731524.png)\\n\\n\\nSo for a string containing n digits, there are n-1 blanks to fill and there are 4 possibilities for every blank, so the total possibilities is 4^(n-1). \\n\\n**II. A Straight-forward solution and why it results in TLE**\\nTo try all the possibilities, we can easily devise a solution using recursion: try + - * ~ one by one in each blank and move forward. Unfortunately, this solution give you TLE because you only calculate the value after you fully build the expression, which involves too much redundant calculation. \\n\\nTo get some intuition, take this half finished equation (left part) as an example\\n\\n![image](https://assets.leetcode.com/users/images/080acc6f-780f-45f4-8821-e8a2aff181c3_1619089502.8828244.png)\\n\\n\\nThere\\'re two blanks left, so there\\'re 4^2=16 possibilities left. So1*2+3~4 would be calculate 16 times. \\n\\n\\n\\n**III. A revised solution**\\nShown as above, redundant computation gives you TLE in return. A naive approach is to calculate the \\u201Cpartial answer\\u201D or \\u201Cvalue so far\\u201D, that is, the output of the part we have finished. \\n\\n\\nFor instance, in the equation given above, we could directly compute the value of 1*2+34 = 36 and use this \"value so far\" for future attempts. \\n\\n![image](https://assets.leetcode.com/users/images/a94b1185-1682-4c51-80be-cf5cc1135f03_1619089538.4591494.png)\\n\\n\\n\\nActaully, why don\\'t we move this 36 to the right part since no matter what operator between 5 and 8 is, the \"value so far\" is fixed.\\n![image](https://assets.leetcode.com/users/images/5c55a2e1-9b0d-4a9c-a350-d4e8b918f0b2_1619089570.8583777.png)\\n\\n\\nFurther look at the following equation, we find that once we decide to use \"+\" between two digits, the value of the part left of \"+\" is always fixed and we should move this part to the right.\\n![image](https://assets.leetcode.com/users/images/ed0d13c0-ed78-45b6-b1e2-b774b5e29e63_1619081561.0559442.png)\\n![image](https://assets.leetcode.com/users/images/069edc53-a92a-4e29-a330-1b9e799df708_1619081714.311086.png)\\n\\nActually, we can also do this when we decide to use \"-\" for the same reason. The only thing we need to care is to keep the \"-\" inside of the right part.\\n\\n![image](https://assets.leetcode.com/users/images/44b5ae95-82a8-450d-bd36-3d4b16286ec1_1619082005.560652.png)\\n\\nThen the question come: what if we decide to use * between two digits?\\nIndeed, we cannot move the left part to the right in this circumstance, what\\'s worse, we cannot even calculate the left part because of \"~\". \\n![image](https://assets.leetcode.com/users/images/d154422f-a2bd-4c07-97dd-7f6100bd2ef1_1619082782.6420016.png)\\n\\n\\nAssume we merge \"5*8\" into 40, just like the picture shows. If we decide to use \"~\" between 8 and 9, them the 40 would be  meaningless and there\\'s no way to fix it (the solution leetcode gives couldn\\'t handle this). In order to handle this, some special tricks are used. The following content talks about how to handle * and ~.\\n\\nWe utilize two \"registers\" reg1, reg2 (reg1 is set to be the first digit and reg2 is initialized to 1) to the save two factors and a special \"pointer\" pointing at one of them, telling us which one is \"active\". The pointer points to reg1 from the begining. Let\\'s start with an example:\\nFrom the very begining, reg1 = the first digit = 5, reg2 = 1, ptr = reg1. \\n\\nFirst blank:\\n![image](https://assets.leetcode.com/users/images/cde1f912-6be2-46aa-8b55-99c98b167770_1619084518.2493339.png)\\nWe decide to use \"*\" between 5 and 8: we update the two registers in a fixed way: reg1 = reg1 * reg2, reg2 = next digits. Change the ptr to reg2. Now the reg1 = 5 * 1 = 5,  reg2 = 8,  ptr = reg2\\n\\n\\nSecond blank:\\n![image](https://assets.leetcode.com/users/images/050361bf-df4a-48c9-a281-97857ec75bc6_1619084858.448591.png)\\nIn the second blank, we choose * anew. Again, update two registers with the same rule and change the ptr to 2(not changed). After that, \\nreg1 = 5 * 8 = 40    reg2 = 9  ptr = reg2\\n\\n\\nThrid blank:\\n![image](https://assets.leetcode.com/users/images/a4037de7-6378-4a5e-8306-10119c915ecc_1619086227.804287.png)\\nHere we decide to use \"-\". As we said before, move the left part to the right and the left part is given by reg1 * reg2 = 360. Then we change reg1 to next digit -6; set reg2 = 1, and set ptr back to reg1. The equation becomes:\\n![image](https://assets.leetcode.com/users/images/d7a86855-04fe-41a5-82f1-77320ad01271_1619086504.715896.png)\\n\\n\\nFifth blank:\\n![image](https://assets.leetcode.com/users/images/fe1c4598-a9db-424a-bf42-ec64182b48ad_1619086668.9973226.png)\\nIf we choose \"~\" for this blank, we need to merge the next digit (2 here) with the register pointer by ptr, that is, reg1.\\nThen we have: reg1=  -62  reg2 = 1  ptr = reg1.\\n\\n...\\n\\nSo in a nutshell, \\nwhen we use \"+\" or \"-\", we should move the left part to the right by set right -= reg1 * reg2, and set reg1=reg2=1, ptr = reg1;\\nwhen we use \"*\", set reg1 *= reg2, and reg2 = next digits, ptr = reg2;\\nwhen we use \"~\", set the reg? pointed by ptr to combine(reg?, next digit).\\n\\nIn the end, if we find reg1 * reg2 = right, this combination of operators is valid.\\n\\n**IV. The final solution**\\n\\tThis solution owns nice performance.\\n\\t![image](https://assets.leetcode.com/users/images/f79db340-220c-45e8-9511-d9215c8c31ce_1613575140.6618643.png)\\n\\n\\n\\n```\\nclass Solution {\\npublic:\\n    vector<string> res;\\n\\n    long long combine(long long a, long long b){\\n        /**\\n         * you need to make sure: a ! = 0\\n         * combine(54,8) = 548 combine(-42,8) = -428\\n        */\\n        bool negative = (a<0);\\n        a = abs(a);\\n        return (negative)? -(a*10 + b) : (a*10 + b);\\n    }\\n\\n    void handle(const string& num, const long long& target, const int& index, \\n\\t\\t\\t\\tconst long long B1, const long long B2,const int ptr, char* op_rec){\\n        if(index == num.size()-1){\\n            // reach the end\\n            if(target - B1*B2 == 0){\\n                // this is a feasible solution! Store it in res.\\n                string temp = to_string(num[0]-\\'0\\');\\n                for(int i=0;i<num.size()-1;++i){\\n                    if(op_rec[i] == \\'~\\')\\n                        temp += num[i+1];\\n                    else {\\n                        temp += op_rec[i];\\n                        temp += num[i+1];  \\n                    }\\n                }\\n                res.push_back(temp);\\n            }\\n            // nope, do nothing.\\n            return;\\n        }\\n        long long next_target;\\n        int digit = num[index + 1] - \\'0\\';\\n        // not the end\\n        // \"+\"\\n        op_rec[index] = \\'+\\';\\n        next_target = target - B1 * B2;\\n        handle(num,next_target,index+1,digit,1,1,op_rec);\\n\\n        // \"-\"\\n        op_rec[index] = \\'-\\';\\n        //next_target = target - B1 * B2; same as above\\n        handle(num,next_target,index+1,-digit,1,1,op_rec);\\n\\n        // \"*\"\\n        op_rec[index] = \\'*\\';\\n        handle(num,target,index+1,B1*B2,digit,2,op_rec);\\n\\n        // \"~\"\\n        op_rec[index] = \\'~\\';\\n        long long B1_copy = B1;\\n        long long B2_copy = B2;\\n        if(ptr == 1 && B1 != 0)\\n            // you cannot combine 0 and 9 to 09\\n            B1_copy = combine(B1_copy,digit);\\n        else if(ptr == 2 & B2 != 0)\\n            B2_copy = combine(B2_copy,digit);\\n        else\\n            return;\\n        handle(num,target,index+1,B1_copy,B2_copy,ptr,op_rec);\\n    }\\n\\n    vector<string> addOperators(string num, int target) {\\n        if(num.empty())\\n            return res;\\n        char *op_rec = new char[num.size()-1];\\n        int index = 0;\\n        long long B1 = num[0] - \\'0\\', B2 = 1;\\n        int ptr = 1;\\n\\n        handle(num,target,index,B1,B2,ptr,op_rec);\\n        delete[] op_rec;\\n        return res;\\n    }\\n    \\n};\\n```\\n\\n\\n\\n\\n",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<string> res;\\n\\n    long long combine(long long a, long long b){\\n        /**\\n         * you need to make sure: a ! = 0\\n         * combine(54,8) = 548 combine(-42,8) = -428\\n        */\\n        bool negative = (a<0);\\n        a = abs(a);\\n        return (negative)? -(a*10 + b) : (a*10 + b);\\n    }\\n\\n    void handle(const string& num, const long long& target, const int& index, \\n\\t\\t\\t\\tconst long long B1, const long long B2,const int ptr, char* op_rec){\\n        if(index == num.size()-1){\\n            // reach the end\\n            if(target - B1*B2 == 0){\\n                // this is a feasible solution! Store it in res.\\n                string temp = to_string(num[0]-\\'0\\');\\n                for(int i=0;i<num.size()-1;++i){\\n                    if(op_rec[i] == \\'~\\')\\n                        temp += num[i+1];\\n                    else {\\n                        temp += op_rec[i];\\n                        temp += num[i+1];  \\n                    }\\n                }\\n                res.push_back(temp);\\n            }\\n            // nope, do nothing.\\n            return;\\n        }\\n        long long next_target;\\n        int digit = num[index + 1] - \\'0\\';\\n        // not the end\\n        // \"+\"\\n        op_rec[index] = \\'+\\';\\n        next_target = target - B1 * B2;\\n        handle(num,next_target,index+1,digit,1,1,op_rec);\\n\\n        // \"-\"\\n        op_rec[index] = \\'-\\';\\n        //next_target = target - B1 * B2; same as above\\n        handle(num,next_target,index+1,-digit,1,1,op_rec);\\n\\n        // \"*\"\\n        op_rec[index] = \\'*\\';\\n        handle(num,target,index+1,B1*B2,digit,2,op_rec);\\n\\n        // \"~\"\\n        op_rec[index] = \\'~\\';\\n        long long B1_copy = B1;\\n        long long B2_copy = B2;\\n        if(ptr == 1 && B1 != 0)\\n            // you cannot combine 0 and 9 to 09\\n            B1_copy = combine(B1_copy,digit);\\n        else if(ptr == 2 & B2 != 0)\\n            B2_copy = combine(B2_copy,digit);\\n        else\\n            return;\\n        handle(num,target,index+1,B1_copy,B2_copy,ptr,op_rec);\\n    }\\n\\n    vector<string> addOperators(string num, int target) {\\n        if(num.empty())\\n            return res;\\n        char *op_rec = new char[num.size()-1];\\n        int index = 0;\\n        long long B1 = num[0] - \\'0\\', B2 = 1;\\n        int ptr = 1;\\n\\n        handle(num,target,index,B1,B2,ptr,op_rec);\\n        delete[] op_rec;\\n        return res;\\n    }\\n    \\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 954157,
                "title": "simple-go-solution-with-backtracking",
                "content": "```golang\\nimport (\\n    \"strconv\"\\n)\\n\\n\\nfunc addOperators(num string, target int) []string {\\n    out := []string{}\\n    \\n    var backtrack func(string, string, int, int)\\n    \\n    backtrack = func(num, prefix string, val, last int) {\\n        if len(num) == 0 {\\n            if val == target {\\n                out = append(out, prefix)\\n            }\\n            return\\n        }\\n        \\n        for i := 1; i <= len(num); i++ {\\n            str := num[:i]\\n            digit, _ := strconv.Atoi(str)\\n            \\n\\t\\t\\t// prevent numbers starting with 0 except the number 0 itself\\n            if num[0] == \\'0\\'&& i != 1 {\\n                continue\\n            }\\n            \\n\\t\\t\\t// for the first call\\n            if prefix == \"\" {\\n                backtrack(num[i:], str, digit, digit)\\n            } else {\\n                backtrack(num[i:], prefix + \"+\" + str, val + digit, digit)\\n                backtrack(num[i:], prefix + \"-\" + str, val - digit, -digit)\\n                backtrack(num[i:], prefix + \"*\" + str, val - last + last * digit, last * digit)\\n            }\\n        }\\n    }\\n    \\n    backtrack(num, \"\", 0, 0)\\n    \\n    return out\\n}\\n```",
                "solutionTags": [
                    "Go"
                ],
                "code": "```golang\\nimport (\\n    \"strconv\"\\n)\\n\\n\\nfunc addOperators(num string, target int) []string {\\n    out := []string{}\\n    \\n    var backtrack func(string, string, int, int)\\n    \\n    backtrack = func(num, prefix string, val, last int) {\\n        if len(num) == 0 {\\n            if val == target {\\n                out = append(out, prefix)\\n            }\\n            return\\n        }\\n        \\n        for i := 1; i <= len(num); i++ {\\n            str := num[:i]\\n            digit, _ := strconv.Atoi(str)\\n            \\n\\t\\t\\t// prevent numbers starting with 0 except the number 0 itself\\n            if num[0] == \\'0\\'&& i != 1 {\\n                continue\\n            }\\n            \\n\\t\\t\\t// for the first call\\n            if prefix == \"\" {\\n                backtrack(num[i:], str, digit, digit)\\n            } else {\\n                backtrack(num[i:], prefix + \"+\" + str, val + digit, digit)\\n                backtrack(num[i:], prefix + \"-\" + str, val - digit, -digit)\\n                backtrack(num[i:], prefix + \"*\" + str, val - last + last * digit, last * digit)\\n            }\\n        }\\n    }\\n    \\n    backtrack(num, \"\", 0, 0)\\n    \\n    return out\\n}\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 887544,
                "title": "c-simple",
                "content": "```\\n vector<string> arr;\\n    \\n    void helper(string & num, int target, int start, int end, long sum, string s, int last){\\n        if(target == sum && start == num.length()){\\n            arr.push_back(s);\\n            return;\\n        }\\n        if(start <= end){\\n            string temp = \"\";\\n            for(int i=start;i<=end;i++){\\n                if(i!=start && num[start] == \\'0\\')\\n                    break;\\n                temp+=num[i];\\n                long n = stol(temp);\\n                if(start == 0)\\n                    helper(num, target, i+1, end, n, temp, n);\\n                else{\\n                    helper(num, target, i+1, end, sum+n,  s+\"+\"+temp, n);\\n                    helper(num, target, i+1, end, sum-n,  s+\"-\"+temp, -1*n);\\n                    helper(num, target, i+1, end, sum - last +last*n,  s+\"*\"+temp, last*n);\\n                }\\n                \\n            }\\n        }\\n        \\n        \\n    }\\n    \\n    \\n    vector<string> addOperators(string num, int target) {\\n        helper(num, target, 0, num.length()-1, 0, \"\", 0);\\n        return arr;\\n    }\\n```",
                "solutionTags": [],
                "code": "```\\n vector<string> arr;\\n    \\n    void helper(string & num, int target, int start, int end, long sum, string s, int last){\\n        if(target == sum && start == num.length()){\\n            arr.push_back(s);\\n            return;\\n        }\\n        if(start <= end){\\n            string temp = \"\";\\n            for(int i=start;i<=end;i++){\\n                if(i!=start && num[start] == \\'0\\')\\n                    break;\\n                temp+=num[i];\\n                long n = stol(temp);\\n                if(start == 0)\\n                    helper(num, target, i+1, end, n, temp, n);\\n                else{\\n                    helper(num, target, i+1, end, sum+n,  s+\"+\"+temp, n);\\n                    helper(num, target, i+1, end, sum-n,  s+\"-\"+temp, -1*n);\\n                    helper(num, target, i+1, end, sum - last +last*n,  s+\"*\"+temp, last*n);\\n                }\\n                \\n            }\\n        }\\n        \\n        \\n    }\\n    \\n    \\n    vector<string> addOperators(string num, int target) {\\n        helper(num, target, 0, num.length()-1, 0, \"\", 0);\\n        return arr;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 797728,
                "title": "python-dfs-intuitive-no-helper-function",
                "content": "We store such information in each node: next_index to add in our path, current path and if our current expression has a leading zero.\\n\\nSince we can not have expressions like (1+05), we need to keep track of if our current path has a leading zero. This can be done by judging if num[index] is zero because we are adding path+ops+num[index] to the stack.\\n\\nHowever, my implementation is very slow, any suggestions to improve would be appreciated. Current implementation is O(N^4) because in between each number we have to decide among +, -, * and no operator (4 possible chocies). And there are n-1 such decisions we have to make since there are n numbers. I don\\'t think we can get around this amount of cost. However, I do believe there might be some ways to optimize from implementation point of view.\\n\\n```\\nclass Solution:\\n    def addOperators(self, num: str, target: int) -> List[str]:\\n        if not num:\\n            return []\\n        stack = [(1, num[0], num[0]==\\'0\\')] # next_index, path, has_leading_zero\\n        ans = []\\n        while stack:\\n            index, path, zero = stack.pop()\\n            if index == len(num):\\n                if eval(path) == target:\\n                    ans.append(path)\\n            if index < len(num):\\n                if not zero:\\n                    stack.append((index+1, path+num[index], zero))\\n                stack.append((index+1, path+\\'+\\'+num[index], num[index]==\\'0\\'))\\n                stack.append((index+1, path+\\'-\\'+num[index], num[index]==\\'0\\'))\\n                stack.append((index+1, path+\\'*\\'+num[index], num[index]==\\'0\\'))\\n        return ans\\n```",
                "solutionTags": [
                    "Python",
                    "Depth-First Search"
                ],
                "code": "```\\nclass Solution:\\n    def addOperators(self, num: str, target: int) -> List[str]:\\n        if not num:\\n            return []\\n        stack = [(1, num[0], num[0]==\\'0\\')] # next_index, path, has_leading_zero\\n        ans = []\\n        while stack:\\n            index, path, zero = stack.pop()\\n            if index == len(num):\\n                if eval(path) == target:\\n                    ans.append(path)\\n            if index < len(num):\\n                if not zero:\\n                    stack.append((index+1, path+num[index], zero))\\n                stack.append((index+1, path+\\'+\\'+num[index], num[index]==\\'0\\'))\\n                stack.append((index+1, path+\\'-\\'+num[index], num[index]==\\'0\\'))\\n                stack.append((index+1, path+\\'*\\'+num[index], num[index]==\\'0\\'))\\n        return ans\\n```",
                "codeTag": "Java"
            },
            {
                "id": 696519,
                "title": "python-backtracking-very-simple-solution-with-explanation",
                "content": "```\\nclass Solution:\\n    def addOperators(self, num: str, target: int) -> List[str]:\\n        ## RC ##\\n\\t\\t## APPROACH : BACKTRACKING ##\\n\\t\\t## LOGIC ##\\n\\t\\t#\\t1. Draw backtracking tree starting with \"\" and 1st level being number for num 123: its 1 or 12 or 123 (attach *, -, + and send for dfs)\\n\\t\\t#\\t2. When you are the last digit, donot send for dfs, compute the result\\n        #   3. Check out for some interesting edge cases, interviewer is looking for those you to solve.\\n\\t\\t# edge cases : 105 5, 100009 9, 569 45\\n        \\n        ## TIME COMPLEXICITY : O(4^N) ## (each level you are creating 4 branches)\\n\\t\\t## SPACE COMPLEXICITY : O(4^N) ##\\n        \\n        def dfs( curr, num ):\\n            if curr in visited:\\n                return\\n            visited.add(curr)\\n            for i, ch in enumerate(num):\\n                if i == len(num) - 1:     # when you are at last digit, calculate the result\\n                    if eval(curr + num) == target:\\n                        result.append(curr + num)\\n                else:\\n                    dfs( curr + num[:i+1] + \"*\", num[i+1:])\\n                    dfs( curr + num[:i+1] + \"-\", num[i+1:])\\n                    dfs( curr + num[:i+1] + \"+\", num[i+1:])\\n                \\n                if num[:i+1] == \"0\":     # edge case, in the number you are sending in if the first digit is 0, donot send further. ex: 105, send 0 but not 05.\\n                    break\\n        result = []\\n        visited = set()\\n        dfs( \"\", num )\\n        return result\\n```",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def addOperators(self, num: str, target: int) -> List[str]:\\n        ## RC ##\\n\\t\\t## APPROACH : BACKTRACKING ##\\n\\t\\t## LOGIC ##\\n\\t\\t#\\t1. Draw backtracking tree starting with \"\" and 1st level being number for num 123: its 1 or 12 or 123 (attach *, -, + and send for dfs)\\n\\t\\t#\\t2. When you are the last digit, donot send for dfs, compute the result\\n        #   3. Check out for some interesting edge cases, interviewer is looking for those you to solve.\\n\\t\\t# edge cases : 105 5, 100009 9, 569 45\\n        \\n        ## TIME COMPLEXICITY : O(4^N) ## (each level you are creating 4 branches)\\n\\t\\t## SPACE COMPLEXICITY : O(4^N) ##\\n        \\n        def dfs( curr, num ):\\n            if curr in visited:\\n                return\\n            visited.add(curr)\\n            for i, ch in enumerate(num):\\n                if i == len(num) - 1:     # when you are at last digit, calculate the result\\n                    if eval(curr + num) == target:\\n                        result.append(curr + num)\\n                else:\\n                    dfs( curr + num[:i+1] + \"*\", num[i+1:])\\n                    dfs( curr + num[:i+1] + \"-\", num[i+1:])\\n                    dfs( curr + num[:i+1] + \"+\", num[i+1:])\\n                \\n                if num[:i+1] == \"0\":     # edge case, in the number you are sending in if the first digit is 0, donot send further. ex: 105, send 0 but not 05.\\n                    break\\n        result = []\\n        visited = set()\\n        dfs( \"\", num )\\n        return result\\n```",
                "codeTag": "Java"
            },
            {
                "id": 441680,
                "title": "accepted-c-backtracking-solution-easy-to-understand-w-comments-fast-93-14-memory-100",
                "content": "\\npublic class Solution \\n{\\n\\n    private List<string> answers;\\n    private string num;\\n    private int target;\\n    \\n    public IList<string> AddOperators(string num, int target) {        \\n        if (num == null || num.Length == 0)\\n            return new List<string>();\\n        \\n        // class member usage for readability\\n        this.num = num;\\n        this.target = target;\\n        this.answers = new List<string>();        \\n        \\n        process(0, 0, 0, 0, new StringBuilder());\\n        \\n        return answers;\\n    }\\n    \\n    // Retrieving answers during recursive procedure call\\n    // Type long is used to avoid integer overflows\\n    // StringBuilder is used to speed up the execution and reduce memory consumption\\n    private void process(int index, long previousOperand, long currentOperand, long value, StringBuilder expression)\\n    {\\n        if (index == num.Length)\\n        {\\n            // new answer found\\n            // value 0 is used for expression validation\\n            if (value == target && currentOperand == 0)\\n                answers.Add(expression.ToString());\\n            return;\\n        }\\n                \\n        // Case 0 - create multi-digit number\\n        currentOperand = currentOperand * 10 + int.Parse(num[index].ToString());\\n        string sop = currentOperand.ToString();\\n\\n        if (currentOperand > 0)\\n        {\\n            // Case 1 - proceed with no operation only if it does not start with 0 e.g. 05\\n            process(index + 1, previousOperand, currentOperand, value, expression);\\n        }\\n         \\n        if (expression.Length == 0)\\n        {\\n            // Case 2 - proceed with first number\\n            process(index + 1, currentOperand, 0, currentOperand, expression.Append(sop));\\n            expression.Length = expression.Length - sop.Length;\\n        }\\n        else\\n        {\\n            // Case 3 - proceed with addition\\n            process(index + 1, currentOperand, 0, value + currentOperand, expression.Append(\"+\").Append(sop));\\n            expression.Length = expression.Length - sop.Length - 1;\\n\\n            // Case 4 - proceed with subtraction\\n            process(index + 1, -currentOperand, 0, value - currentOperand, expression.Append(\"-\").Append(sop));\\n            expression.Length = expression.Length - sop.Length - 1;\\n\\n            // Case 5 - proceed with multiplication\\n            process(index + 1, previousOperand * currentOperand, 0, value - previousOperand + (previousOperand * currentOperand), expression.Append(\"*\").Append(sop));            \\n            expression.Length = expression.Length - sop.Length - 1;\\n        }\\n    }\\n}",
                "solutionTags": [],
                "code": "class Solution \\n{\\n\\n    private List<string> answers;\\n    private string num;\\n    private int target;\\n    \\n    public IList<string> AddOperators(string num, int target) {        \\n        if (num == null || num.Length == 0)\\n            return new List<string>();\\n        \\n        // class member usage for readability\\n        this.num = num;\\n        this.target = target;\\n        this.answers = new List<string>();        \\n        \\n        process(0, 0, 0, 0, new StringBuilder());\\n        \\n        return answers;\\n    }",
                "codeTag": "Java"
            },
            {
                "id": 404755,
                "title": "c-easy-to-understand-backtracking",
                "content": "```C++\\nvector<string> addOperators(string num, int target) {\\n\\tvector<string> res;\\n\\tstring cur = \"\";\\n\\taddOperators(num, 0, target, 0, 1, cur, res);\\n\\treturn res;\\n}\\n\\nvoid addOperators(string num, int index, int target, long val, long mult, string &cur,\\n\\t\\t\\t\\t  vector<string> &res) {\\n\\tif (index == num.length()) {\\n\\t\\tif (val == target) {\\n\\t\\t\\tres.push_back(cur);\\n\\t\\t}\\n\\t\\treturn;\\n\\t}\\n\\n\\tint len = cur.size();\\n\\tfor (int i = index; i < num.length(); i++) {\\n\\t\\tstring sVal = num.substr(index, i - index + 1);\\n\\t\\tlong n = stol(sVal);\\n\\t\\tif (index == 0) {\\n\\t\\t\\tcur += sVal;\\n\\t\\t\\taddOperators(num, i + 1, target, n, n, cur, res);\\n\\t\\t\\tcur.resize(len);\\n\\t\\t} else {\\n\\t\\t\\t// +\\n\\t\\t\\tcur += \"+\" + sVal;\\n\\t\\t\\taddOperators(num, i + 1, target, val + n, n, cur, res);\\n\\t\\t\\tcur.resize(len);\\n\\t\\t\\t// -\\n\\t\\t\\tcur += \"-\" + sVal;\\n\\t\\t\\taddOperators(num, i + 1, target, val - n, -n, cur, res);\\n\\t\\t\\tcur.resize(len);\\n\\t\\t\\t// *\\n\\t\\t\\tcur += \"*\" + sVal;\\n\\t\\t\\taddOperators(num, i + 1, target, val - mult + mult * n, mult * n, cur, res);\\n\\t\\t\\tcur.resize(len);\\n\\t\\t}\\n\\t\\tif (n == 0) return;\\n\\t}\\n}\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```C++\\nvector<string> addOperators(string num, int target) {\\n\\tvector<string> res;\\n\\tstring cur = \"\";\\n\\taddOperators(num, 0, target, 0, 1, cur, res);\\n\\treturn res;\\n}\\n\\nvoid addOperators(string num, int index, int target, long val, long mult, string &cur,\\n\\t\\t\\t\\t  vector<string> &res) {\\n\\tif (index == num.length()) {\\n\\t\\tif (val == target) {\\n\\t\\t\\tres.push_back(cur);\\n\\t\\t}\\n\\t\\treturn;\\n\\t}\\n\\n\\tint len = cur.size();\\n\\tfor (int i = index; i < num.length(); i++) {\\n\\t\\tstring sVal = num.substr(index, i - index + 1);\\n\\t\\tlong n = stol(sVal);\\n\\t\\tif (index == 0) {\\n\\t\\t\\tcur += sVal;\\n\\t\\t\\taddOperators(num, i + 1, target, n, n, cur, res);\\n\\t\\t\\tcur.resize(len);\\n\\t\\t} else {\\n\\t\\t\\t// +\\n\\t\\t\\tcur += \"+\" + sVal;\\n\\t\\t\\taddOperators(num, i + 1, target, val + n, n, cur, res);\\n\\t\\t\\tcur.resize(len);\\n\\t\\t\\t// -\\n\\t\\t\\tcur += \"-\" + sVal;\\n\\t\\t\\taddOperators(num, i + 1, target, val - n, -n, cur, res);\\n\\t\\t\\tcur.resize(len);\\n\\t\\t\\t// *\\n\\t\\t\\tcur += \"*\" + sVal;\\n\\t\\t\\taddOperators(num, i + 1, target, val - mult + mult * n, mult * n, cur, res);\\n\\t\\t\\tcur.resize(len);\\n\\t\\t}\\n\\t\\tif (n == 0) return;\\n\\t}\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 385450,
                "title": "python-solution-320ms-18-lines-with-easy-to-understand-variable-names-and-explanation",
                "content": "Reference: https://leetcode.com/problems/expression-add-operators/discuss/128460/simple-Python-DFS-that-beats-100\\n```\\n    def addOperators(self, num: str, target: int) -> List[str]:\\n        if not num: return []\\n        res = []\\n\\n        def helper(start, expr, val, prev):\\n            if val == target and start == len(num):\\n                res.append(expr); return\\n\\t\\t\\tif start < len(num) and max(1, abs(prev)) * (int(num[start:])) < abs(target - val): return   # target not reachable\\n            for i in range(start, len(num)):\\n                curr = num[start: i+1]\\n                if len(curr) != len(str(int(curr))): break   # prevent \\'00\\',\\'01\\',... treated as one number\\n                if start == 0:\\n                    helper(i+1, curr, int(curr), int(curr))\\n                else:\\n                    helper(i+1, expr+\\'+\\'+curr, val+int(curr), int(curr))\\n                    helper(i+1, expr+\\'-\\'+curr, val-int(curr), -int(curr))   # -curr is interpreted as +(-curr)\\n                    helper(i+1, expr+\\'*\\'+curr, val-prev+prev*int(curr), prev*int(curr))   # since * has precedence over + we have to roll back +prev\\n        \\n        helper(0, \\'\\', 0, 0)\\n        return res\\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\n    def addOperators(self, num: str, target: int) -> List[str]:\\n        if not num: return []\\n        res = []\\n\\n        def helper(start, expr, val, prev):\\n            if val == target and start == len(num):\\n                res.append(expr); return\\n\\t\\t\\tif start < len(num) and max(1, abs(prev)) * (int(num[start:])) < abs(target - val): return   # target not reachable\\n            for i in range(start, len(num)):\\n                curr = num[start: i+1]\\n                if len(curr) != len(str(int(curr))): break   # prevent \\'00\\',\\'01\\',... treated as one number\\n                if start == 0:\\n                    helper(i+1, curr, int(curr), int(curr))\\n                else:\\n                    helper(i+1, expr+\\'+\\'+curr, val+int(curr), int(curr))\\n                    helper(i+1, expr+\\'-\\'+curr, val-int(curr), -int(curr))   # -curr is interpreted as +(-curr)\\n                    helper(i+1, expr+\\'*\\'+curr, val-prev+prev*int(curr), prev*int(curr))   # since * has precedence over + we have to roll back +prev\\n        \\n        helper(0, \\'\\', 0, 0)\\n        return res\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 317731,
                "title": "java-dfs-139-ms-faster-than-20-95-61-1-mb-less-than-40-86",
                "content": "```\\nclass Solution {\\n    public List<String> addOperators(String num, int target) {\\n        List<String> res = new ArrayList<>();\\n        dfs(num, target, 0, \"\", 0, 0, res);\\n        return res;\\n    }\\n    \\n    private void dfs(String num, int target, int pos, String str, long sum, long last, List<String> res) {\\n        if (pos == num.length()) {\\n            if (sum == target) {\\n                res.add(str);\\n            }\\n            return;\\n        }\\n        for (int i = pos; i < num.length(); ++i) {\\n            long x = Long.valueOf(num.substring(pos, i + 1));\\n            if (pos == 0) {\\n                dfs(num, target, i + 1, str + x, x, x, res);\\n            } else {\\n                dfs(num, target, i + 1, str + \"*\" + x, sum - last + last * x, last * x, res);\\n                dfs(num, target, i + 1, str + \"-\" + x, sum - x, -x, res);\\n                dfs(num, target, i + 1, str + \"+\" + x, sum + x, x, res);\\n            }\\n            if (x == 0) {\\n                break;\\n            }\\n        }\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public List<String> addOperators(String num, int target) {\\n        List<String> res = new ArrayList<>();\\n        dfs(num, target, 0, \"\", 0, 0, res);\\n        return res;\\n    }\\n    \\n    private void dfs(String num, int target, int pos, String str, long sum, long last, List<String> res) {\\n        if (pos == num.length()) {\\n            if (sum == target) {\\n                res.add(str);\\n            }\\n            return;\\n        }\\n        for (int i = pos; i < num.length(); ++i) {\\n            long x = Long.valueOf(num.substring(pos, i + 1));\\n            if (pos == 0) {\\n                dfs(num, target, i + 1, str + x, x, x, res);\\n            } else {\\n                dfs(num, target, i + 1, str + \"*\" + x, sum - last + last * x, last * x, res);\\n                dfs(num, target, i + 1, str + \"-\" + x, sum - x, -x, res);\\n                dfs(num, target, i + 1, str + \"+\" + x, sum + x, x, res);\\n            }\\n            if (x == 0) {\\n                break;\\n            }\\n        }\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 71906,
                "title": "c-backtracking",
                "content": "C++ version of this [solution](https://discuss.leetcode.com/topic/24523/java-standard-backtrace-ac-solutoin-short-and-clear/12).\\n```\\nclass Solution {\\npublic:\\n    vector<string> addOperators(string num, int target) {\\n        vector<string>res;\\n        backtrack(res, num, target, 0, 0, 0, \"\");\\n        return res;\\n    }\\n    \\n    void backtrack(vector<string>& res, string num, int target, int pos, long sum, long multiply, string path){\\n        if(pos == num.size()){\\n            if(target == sum) res.push_back(path);\\n            return;\\n        }\\n        for(int i = pos; i < num.size(); i++){\\n            if(i != pos && num[pos] == '0') break;\\n            long cur = stol(num.substr(pos, i - pos + 1));\\n            if(pos == 0){\\n                backtrack(res, num, target, i + 1, cur, cur, path + to_string(cur));\\n            }\\n            else{\\n                backtrack(res, num, target, i + 1, sum + cur, cur, path + \"+\" + to_string(cur));\\n                backtrack(res, num, target, i + 1, sum - cur, -cur, path + \"-\" + to_string(cur));\\n                backtrack(res, num, target, i + 1, sum - multiply + multiply * cur, multiply * cur, path + \"*\" + to_string(cur));    \\n            }\\n        }\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<string> addOperators(string num, int target) {\\n        vector<string>res;\\n        backtrack(res, num, target, 0, 0, 0, \"\");\\n        return res;\\n    }\\n    \\n    void backtrack(vector<string>& res, string num, int target, int pos, long sum, long multiply, string path){\\n        if(pos == num.size()){\\n            if(target == sum) res.push_back(path);\\n            return;\\n        }\\n        for(int i = pos; i < num.size(); i++){\\n            if(i != pos && num[pos] == '0') break;\\n            long cur = stol(num.substr(pos, i - pos + 1));\\n            if(pos == 0){\\n                backtrack(res, num, target, i + 1, cur, cur, path + to_string(cur));\\n            }\\n            else{\\n                backtrack(res, num, target, i + 1, sum + cur, cur, path + \"+\" + to_string(cur));\\n                backtrack(res, num, target, i + 1, sum - cur, -cur, path + \"-\" + to_string(cur));\\n                backtrack(res, num, target, i + 1, sum - multiply + multiply * cur, multiply * cur, path + \"*\" + to_string(cur));    \\n            }\\n        }\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 71930,
                "title": "clean-c-dfs-solution-beating-96",
                "content": "Base on Basic Calculator II, the handling for * is that, we keep a prev variable to keep track of the previous addition or subtraction operation, when we what to use * operator, we can do:\\n\\ncurrent_sum = current_sum - prev + prev * operand,\\nprev = prev * operand\\n\\nThen we just need to use DFS to enumerate all possibilities of adding multiplication, addition, subtraction operators at each possible positions.\\n\\nOne thing we need to pay attention is that if the current number has more than 1 digits, and it's starting with a 0, then this is not a valid case.\\n\\n```\\n    vector<string> addOperators(string num, int target) {\\n        string path;\\n        vector<string> result;\\n        dfs(num, 0, 0, target, 0, path, result);\\n        return result;\\n    }\\n    \\n    void dfs(const string& num, int pos, long long sum, int target, long long prev, string& path, vector<string>& result) {\\n        if (pos >= num.size()) {\\n            if (sum == target) result.push_back(path);\\n            return;\\n        }\\n        \\n        long long left = 0;\\n        int size = path.size();\\n        string buffer;\\n        for (int i=pos; i<num.size(); i++) {\\n            left = left * 10 + num[i] - '0';\\n            buffer.push_back(num[i]);\\n            if (pos == 0) {\\n                path += buffer;\\n                dfs(num, i+1, sum+left, target, left, path, result);\\n                path.resize(size);\\n            } else {\\n                path += \"+\";\\n                path += buffer;\\n                dfs(num, i+1, sum+left, target, left, path, result);\\n                path.resize(size);\\n                \\n                path += \"-\";\\n                path += buffer;\\n                dfs(num, i+1, sum-left, target, -left, path, result);\\n                path.resize(size);\\n                \\n                path += \"*\";\\n                path += buffer;\\n                dfs(num, i+1, sum-prev+prev*left, target, prev*left, path, result);\\n                path.resize(size);\\n            }\\n            if (num[pos] == '0') break;\\n        }\\n    }\\n```",
                "solutionTags": [],
                "code": "```\\n    vector<string> addOperators(string num, int target) {\\n        string path;\\n        vector<string> result;\\n        dfs(num, 0, 0, target, 0, path, result);\\n        return result;\\n    }\\n    \\n    void dfs(const string& num, int pos, long long sum, int target, long long prev, string& path, vector<string>& result) {\\n        if (pos >= num.size()) {\\n            if (sum == target) result.push_back(path);\\n            return;\\n        }\\n        \\n        long long left = 0;\\n        int size = path.size();\\n        string buffer;\\n        for (int i=pos; i<num.size(); i++) {\\n            left = left * 10 + num[i] - '0';\\n            buffer.push_back(num[i]);\\n            if (pos == 0) {\\n                path += buffer;\\n                dfs(num, i+1, sum+left, target, left, path, result);\\n                path.resize(size);\\n            } else {\\n                path += \"+\";\\n                path += buffer;\\n                dfs(num, i+1, sum+left, target, left, path, result);\\n                path.resize(size);\\n                \\n                path += \"-\";\\n                path += buffer;\\n                dfs(num, i+1, sum-left, target, -left, path, result);\\n                path.resize(size);\\n                \\n                path += \"*\";\\n                path += buffer;\\n                dfs(num, i+1, sum-prev+prev*left, target, prev*left, path, result);\\n                path.resize(size);\\n            }\\n            if (num[pos] == '0') break;\\n        }\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 71931,
                "title": "python-solution-with-detailed-explanation",
                "content": "**Solution**\\n\\n**Expression Add Operators** https://leetcode.com/problems/expression-add-operators/\\n\\n**Recursion and Backtracking**\\n1. Make sure you understand the problem: 1234 does not mean adding brackets, we just need to add operators.\\n2. 1234 = Processed \"12\" and now handle the substring \"34\".\\n3. We could have processed \"12\" in many ways. But when we reach the part of \"34\", we just care about the value computed so far and the immediate prev value.\\n4. For example: \"1+2\", \"1-2\", \"1\\\\*2\" would have a so_far value as 3,-1,2 and previous value as 2,-2,2.\\n5. When we reach \"34\", we would have arrived from one of the paths like \"1+2\", \"1-2\", \"1\\\\*2\". We therefore know the prev value. This is needed for multiplication part since (1+2)\\\\*3 should be really 1+2\\\\*3 since we dont have any brackets. Hence we do 1+2-2+2\\\\*3\\n```\\nclass Solution(object):\\n    def addOperators(self, num, target):\\n        \"\"\"\\n        :type num: str\\n        :type target: int\\n        :rtype: List[str]\\n        \"\"\"\\n        results = []\\n        self.helper(0, num, 0, 0, \"\", target, results)\\n        return results\\n    \\n    def helper(self, k, num, ssum, prev, e, t, res):\\n        if k == len(num):\\n            if ssum == t:\\n                res.append(\"\".join([x for x in e]))\\n        else:\\n            for i in range(k, len(num)):\\n                left = num[k:i+1]\\n                ileft = int(left)\\n                if left[0] == \"0\" and len(left) > 1: ### IGNORE INPUT LIKE \"00\", \"005\", \"0006\"\\n                    continue\\n                if k == 0:\\n                    self.helper(i+1, num, ileft, ileft, left, t, res)\\n                else:\\n                    self.helper(i+1, num, ssum+ileft, ileft, e+\"+\"+left, t, res)\\n                    self.helper(i+1, num, ssum-ileft, ileft*-1, e+\"-\"+left, t, res)\\n                    self.helper(i+1, num, ssum-prev+ileft*prev, ileft*prev, e+\"*\"+left, t, res)\\n            return\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution(object):\\n    def addOperators(self, num, target):\\n        \"\"\"\\n        :type num: str\\n        :type target: int\\n        :rtype: List[str]\\n        \"\"\"\\n        results = []\\n        self.helper(0, num, 0, 0, \"\", target, results)\\n        return results\\n    \\n    def helper(self, k, num, ssum, prev, e, t, res):\\n        if k == len(num):\\n            if ssum == t:\\n                res.append(\"\".join([x for x in e]))\\n        else:\\n            for i in range(k, len(num)):\\n                left = num[k:i+1]\\n                ileft = int(left)\\n                if left[0] == \"0\" and len(left) > 1: ### IGNORE INPUT LIKE \"00\", \"005\", \"0006\"\\n                    continue\\n                if k == 0:\\n                    self.helper(i+1, num, ileft, ileft, left, t, res)\\n                else:\\n                    self.helper(i+1, num, ssum+ileft, ileft, e+\"+\"+left, t, res)\\n                    self.helper(i+1, num, ssum-ileft, ileft*-1, e+\"-\"+left, t, res)\\n                    self.helper(i+1, num, ssum-prev+ileft*prev, ileft*prev, e+\"*\"+left, t, res)\\n            return\\n```",
                "codeTag": "Java"
            },
            {
                "id": 71987,
                "title": "my-short-python-accepted-code",
                "content": "    class Solution(object):\\n    def addOperators(self, num, target):\\n        \"\"\"\\n        :type num: str\\n        :type target: int\\n        :rtype: List[str]\\n        \"\"\"\\n        def solve(target, pos, negate, prod):\\n            expr = []\\n\\n            for i in xrange(pos, len(num)):\\n                if i > pos and num[pos] == \"0\":\\n                    break\\n\\n                if i == len(num) -1:\\n                    if negate * prod * int(num[pos:i+1]) == target:\\n                        expr.extend([num[pos:i+1]])\\n                    break\\n                \\n                add_expr = solve(target - prod * negate * long(num[pos:i+1]), i+1, 1, 1)\\n                expr.extend([num[pos:i+1] + \"+\" + e for e in add_expr])\\n\\n                sub_expr = solve(target - prod * negate * long(num[pos:i+1]), i+1, -1, 1)     \\n                expr.extend([num[pos:i+1] + \"-\" + e for e in sub_expr])\\n\\n                mul_expr = solve(target, i+1, 1, prod * negate * long(num[pos:i+1]))\\n                expr.extend([num[pos:i+1] + \"*\" + e for e in mul_expr])\\n\\n            return expr\\n        \\n        return solve(target, 0, 1, 1)",
                "solutionTags": [],
                "code": "    class Solution(object):\\n    def addOperators(self, num, target):\\n        \"\"\"\\n        :type num: str\\n        :type target: int\\n        :rtype: List[str]\\n        \"\"\"\\n        def solve(target, pos, negate, prod):\\n            expr = []\\n\\n            for i in xrange(pos, len(num)):\\n                if i > pos and num[pos] == \"0\":\\n                    break\\n\\n                if i == len(num) -1:\\n                    if negate * prod * int(num[pos:i+1]) == target:\\n                        expr.extend([num[pos:i+1]])\\n                    break\\n                \\n                add_expr = solve(target - prod * negate * long(num[pos:i+1]), i+1, 1, 1)\\n                expr.extend([num[pos:i+1] + \"+\" + e for e in add_expr])\\n\\n                sub_expr = solve(target - prod * negate * long(num[pos:i+1]), i+1, -1, 1)     \\n                expr.extend([num[pos:i+1] + \"-\" + e for e in sub_expr])\\n\\n                mul_expr = solve(target, i+1, 1, prod * negate * long(num[pos:i+1]))\\n                expr.extend([num[pos:i+1] + \"*\" + e for e in mul_expr])\\n\\n            return expr\\n        \\n        return solve(target, 0, 1, 1)",
                "codeTag": "Java"
            },
            {
                "id": 2449863,
                "title": "c-code-for-beginners-backtracking-evaluate-on-the-fly-simple-code",
                "content": "```\\nclass Solution {\\npublic:    \\n    void generate(string &num, int target, int curr, vector<string> &res, string build, long long int prevNumber, long long int currSum, int n){\\n        if(curr==num.size()){\\n            if(currSum==target){\\n                res.push_back(build);\\n            }\\n            return;\\n        }\\n        for(int len=1;len<=(n-curr);len++){  // n-curr is the remaining length of the string num\\n            string number=num.substr(curr,len);\\n            if(number[0]==\\'0\\' && number.size()>1){  // can not be having leading zeroes in size>1\\n                continue;\\n            }\\n            long long int currNum=stoll(number);\\n            generate(num,target,curr+len,res,build+\"+\"+number,currNum,currSum+currNum,n); // ADD\\n            generate(num,target,curr+len,res,build+\"-\"+number,-currNum,currSum-currNum,n);  //SUBTRACT\\n            generate(num,target,curr+len,res,build+\"*\"+number,currNum*prevNumber,currSum-prevNumber+currNum*prevNumber,n);  \\n\\t\\t\\t// MULTIPLY, Notice:- the previous Number is currNum*prevNumber, this is because a multiplication will take the previous number with it, and then proceed\\n        }\\n    }\\n    vector<string> addOperators(string num, int target) {\\n        vector<string> res;\\n        int n=num.size();\\n        for(int len=1;len<=n;len++){\\n            string number=num.substr(0,len);\\n            if(number[0]==\\'0\\' && number.size()>1){\\n                continue;\\n            }\\n            long long int currNum=stoll(number);\\n            generate(num,target,len,res,number,currNum,currNum,n);\\n        }\\n        return res;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Backtracking",
                    "Depth-First Search",
                    "Recursion"
                ],
                "code": "```\\nclass Solution {\\npublic:    \\n    void generate(string &num, int target, int curr, vector<string> &res, string build, long long int prevNumber, long long int currSum, int n){\\n        if(curr==num.size()){\\n            if(currSum==target){\\n                res.push_back(build);\\n            }\\n            return;\\n        }\\n        for(int len=1;len<=(n-curr);len++){  // n-curr is the remaining length of the string num\\n            string number=num.substr(curr,len);\\n            if(number[0]==\\'0\\' && number.size()>1){  // can not be having leading zeroes in size>1\\n                continue;\\n            }\\n            long long int currNum=stoll(number);\\n            generate(num,target,curr+len,res,build+\"+\"+number,currNum,currSum+currNum,n); // ADD\\n            generate(num,target,curr+len,res,build+\"-\"+number,-currNum,currSum-currNum,n);  //SUBTRACT\\n            generate(num,target,curr+len,res,build+\"*\"+number,currNum*prevNumber,currSum-prevNumber+currNum*prevNumber,n);  \\n\\t\\t\\t// MULTIPLY, Notice:- the previous Number is currNum*prevNumber, this is because a multiplication will take the previous number with it, and then proceed\\n        }\\n    }\\n    vector<string> addOperators(string num, int target) {\\n        vector<string> res;\\n        int n=num.size();\\n        for(int len=1;len<=n;len++){\\n            string number=num.substr(0,len);\\n            if(number[0]==\\'0\\' && number.size()>1){\\n                continue;\\n            }\\n            long long int currNum=stoll(number);\\n            generate(num,target,len,res,number,currNum,currNum,n);\\n        }\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2092254,
                "title": "c-concise-recursive-solution",
                "content": "**[C++] Solution for finding expressions with operators that gives target as result:**\\n\\n\\n```\\nclass Solution {\\npublic:\\n    vector<string> addOperators(string num, int target) {\\n        addOperatorsAndEvaluate(num, target, 0, \"\", 0, 0);\\n        return expressions;\\n    }\\n    \\nprivate:\\n    vector<string> expressions;\\n    void addOperatorsAndEvaluate(string& nums, int& target, int index, string exp, long value, long prev) {\\n        if (index==nums.size()) {\\n            if (value == target) {\\n                expressions.push_back(exp);\\n            }\\n            return;\\n        }\\n        \\n        string numStr = \"\";\\n        long num = 0;\\n        for(int j=index; j<nums.size(); j++) {\\n            // Handling the case for avoiding numbers with leading 0\\n            if (j>index && nums[index]==\\'0\\') break;\\n            \\n            numStr += nums[j];\\n            num = num*10 + (nums[j]-\\'0\\');\\n            \\n            if (exp.size()==0) {\\n                addOperatorsAndEvaluate(nums, target, j+1, exp+numStr, num, num);\\n            } else {\\n                addOperatorsAndEvaluate(nums, target, j+1, exp+\\'+\\'+numStr, value+num, num);\\n                addOperatorsAndEvaluate(nums, target, j+1, exp+\\'-\\'+numStr, value-num, -num);\\n                addOperatorsAndEvaluate(nums, target, j+1, exp+\\'*\\'+numStr, (value-prev)+(prev*num), prev*num);\\n            }\\n        }\\n    }\\n};\\n```\\n\\nPlease do **upvote** if you find this helpful.\\nFeel free to add your comments or ask queries.",
                "solutionTags": [
                    "C",
                    "Recursion"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<string> addOperators(string num, int target) {\\n        addOperatorsAndEvaluate(num, target, 0, \"\", 0, 0);\\n        return expressions;\\n    }\\n    \\nprivate:\\n    vector<string> expressions;\\n    void addOperatorsAndEvaluate(string& nums, int& target, int index, string exp, long value, long prev) {\\n        if (index==nums.size()) {\\n            if (value == target) {\\n                expressions.push_back(exp);\\n            }\\n            return;\\n        }\\n        \\n        string numStr = \"\";\\n        long num = 0;\\n        for(int j=index; j<nums.size(); j++) {\\n            // Handling the case for avoiding numbers with leading 0\\n            if (j>index && nums[index]==\\'0\\') break;\\n            \\n            numStr += nums[j];\\n            num = num*10 + (nums[j]-\\'0\\');\\n            \\n            if (exp.size()==0) {\\n                addOperatorsAndEvaluate(nums, target, j+1, exp+numStr, num, num);\\n            } else {\\n                addOperatorsAndEvaluate(nums, target, j+1, exp+\\'+\\'+numStr, value+num, num);\\n                addOperatorsAndEvaluate(nums, target, j+1, exp+\\'-\\'+numStr, value-num, -num);\\n                addOperatorsAndEvaluate(nums, target, j+1, exp+\\'*\\'+numStr, (value-prev)+(prev*num), prev*num);\\n            }\\n        }\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1963629,
                "title": "easy-to-understand-c-code",
                "content": "* ***Using Backtracking***\\n\\n```\\nclass Solution {\\npublic:\\n    \\n    vector<string> res;\\n    \\n    void helper(string str, int target, int i, string curr, long long res_so_far, long long prev_num)\\n    {\\n        if(i == str.size())\\n        {\\n            if(res_so_far == target)\\n            {\\n                res.push_back(curr);\\n            }\\n            \\n            return;\\n        }\\n        \\n        for(int j = i; j < str.size(); j++)\\n        {\\n            if(j > i && str[i] == \\'0\\')\\n            {\\n                break;\\n            }\\n            \\n            string curr_str = str.substr(i, j - i + 1);\\n            \\n            long long curr_num = stoll(curr_str);\\n            \\n            if(i == 0)\\n            {\\n                helper(str, target, j + 1, curr + curr_str, curr_num, curr_num);\\n            }\\n            else\\n            {\\n                helper(str, target, j + 1, curr + \"+\" + curr_str, res_so_far + curr_num, curr_num);\\n                \\n                helper(str, target, j + 1, curr + \"-\" + curr_str, res_so_far - curr_num, -curr_num);\\n                \\n                helper(str, target, j + 1, curr + \"*\" + curr_str, res_so_far - prev_num + prev_num * curr_num, prev_num * curr_num);\\n            }\\n        }\\n    }\\n    \\n    vector<string> addOperators(string str, int target) {\\n        \\n        int n = str.size();\\n        \\n        helper(str, target, 0, \"\", 0, 0);\\n        \\n        return res;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Backtracking"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    \\n    vector<string> res;\\n    \\n    void helper(string str, int target, int i, string curr, long long res_so_far, long long prev_num)\\n    {\\n        if(i == str.size())\\n        {\\n            if(res_so_far == target)\\n            {\\n                res.push_back(curr);\\n            }\\n            \\n            return;\\n        }\\n        \\n        for(int j = i; j < str.size(); j++)\\n        {\\n            if(j > i && str[i] == \\'0\\')\\n            {\\n                break;\\n            }\\n            \\n            string curr_str = str.substr(i, j - i + 1);\\n            \\n            long long curr_num = stoll(curr_str);\\n            \\n            if(i == 0)\\n            {\\n                helper(str, target, j + 1, curr + curr_str, curr_num, curr_num);\\n            }\\n            else\\n            {\\n                helper(str, target, j + 1, curr + \"+\" + curr_str, res_so_far + curr_num, curr_num);\\n                \\n                helper(str, target, j + 1, curr + \"-\" + curr_str, res_so_far - curr_num, -curr_num);\\n                \\n                helper(str, target, j + 1, curr + \"*\" + curr_str, res_so_far - prev_num + prev_num * curr_num, prev_num * curr_num);\\n            }\\n        }\\n    }\\n    \\n    vector<string> addOperators(string str, int target) {\\n        \\n        int n = str.size();\\n        \\n        helper(str, target, 0, \"\", 0, 0);\\n        \\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1897046,
                "title": "c-back-tracking",
                "content": "```\\nclass Solution {\\npublic:\\n    void dfs(const string& s, int idx, long long curr, long long val, int target, string& expr, vector<string>& res) {\\n        if (idx == s.size()) {\\n            if (curr == target) {\\n                res.push_back(expr);\\n            }\\n            return;\\n        }\\n        \\n        size_t sz = expr.size();\\n        long long int v = 0;\\n        for (int i = idx; i < s.size(); ++i) {\\n            v = v * 10 + s[i] - \\'0\\';\\n            \\n            string&& sub = s.substr(idx, i - idx + 1);\\n            if (idx == 0) {\\n                expr += sub;\\n                dfs(s, i + 1, curr + v, v, target, expr, res);\\n                expr.resize(sz);\\n            } else {\\n                expr += \\'+\\';\\n                expr += sub;\\n                dfs(s, i + 1, curr + v, v, target, expr, res);\\n                expr.resize(sz);\\n                \\n                expr += \\'-\\';\\n                expr += sub;\\n                dfs(s, i + 1, curr - v, -v, target, expr, res);\\n                expr.resize(sz);\\n                \\n                expr += \\'*\\';\\n                expr += sub;\\n                dfs(s, i + 1, curr - val + v * val, v * val, target, expr, res);\\n                expr.resize(sz);\\n            }\\n            \\n            if (!v) {\\n                break;\\n            }\\n        }\\n    }\\n    \\n    vector<string> addOperators(string num, int target) {\\n        string expr;\\n        vector<string> res;\\n        dfs(num, 0, 0, 0, target, expr, res);\\n        return res;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    void dfs(const string& s, int idx, long long curr, long long val, int target, string& expr, vector<string>& res) {\\n        if (idx == s.size()) {\\n            if (curr == target) {\\n                res.push_back(expr);\\n            }\\n            return;\\n        }\\n        \\n        size_t sz = expr.size();\\n        long long int v = 0;\\n        for (int i = idx; i < s.size(); ++i) {\\n            v = v * 10 + s[i] - \\'0\\';\\n            \\n            string&& sub = s.substr(idx, i - idx + 1);\\n            if (idx == 0) {\\n                expr += sub;\\n                dfs(s, i + 1, curr + v, v, target, expr, res);\\n                expr.resize(sz);\\n            } else {\\n                expr += \\'+\\';\\n                expr += sub;\\n                dfs(s, i + 1, curr + v, v, target, expr, res);\\n                expr.resize(sz);\\n                \\n                expr += \\'-\\';\\n                expr += sub;\\n                dfs(s, i + 1, curr - v, -v, target, expr, res);\\n                expr.resize(sz);\\n                \\n                expr += \\'*\\';\\n                expr += sub;\\n                dfs(s, i + 1, curr - val + v * val, v * val, target, expr, res);\\n                expr.resize(sz);\\n            }\\n            \\n            if (!v) {\\n                break;\\n            }\\n        }\\n    }\\n    \\n    vector<string> addOperators(string num, int target) {\\n        string expr;\\n        vector<string> res;\\n        dfs(num, 0, 0, 0, target, expr, res);\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1888167,
                "title": "java-dsf-solution",
                "content": "```\\n\\tpublic List<String> addOperators(String num, int target) {\\n        result = new ArrayList<String>();\\n        helper(num,0,0,\"\",target,0);\\n        return result;\\n    }\\n    private void helper(String num,int index,long soFar,String temp,int target,long prev){\\n        if(index == num.length()){\\n            if(soFar == target){\\n                result.add(temp);    \\n            }\\n        } else {\\n            for(int i = index; i < num.length(); i ++){\\n                if(i != index && num.charAt(index) == \\'0\\') break;//Any other number can not start with 0\\n                \\n                long curr = Long.valueOf(num.substring(index,i+1));\\n                if(index == 0){//If its first, no need to calculate\\n                    helper(num,i+1,curr,temp+curr,target,curr);\\n                } else {\\n                    long plusValue = curr;\\n                    helper(num,i+1,soFar+plusValue,temp+\"+\"+curr,target,plusValue);\\n                    \\n                    long minusValue = -curr;\\n                    helper(num,i+1,soFar+minusValue,temp+\"-\"+curr,target,minusValue);\\n                    \\n                    long mulValue = prev*curr;\\n                    //subtract previously added value from mulValue\\n                    helper(num,i+1,soFar+mulValue - prev,temp+\"*\"+curr,target,mulValue);\\n                }\\n            }\\n        }\\n    }\\n```\\t",
                "solutionTags": [],
                "code": "```\\n\\tpublic List<String> addOperators(String num, int target) {\\n        result = new ArrayList<String>();\\n        helper(num,0,0,\"\",target,0);\\n        return result;\\n    }\\n    private void helper(String num,int index,long soFar,String temp,int target,long prev){\\n        if(index == num.length()){\\n            if(soFar == target){\\n                result.add(temp);    \\n            }\\n        } else {\\n            for(int i = index; i < num.length(); i ++){\\n                if(i != index && num.charAt(index) == \\'0\\') break;//Any other number can not start with 0\\n                \\n                long curr = Long.valueOf(num.substring(index,i+1));\\n                if(index == 0){//If its first, no need to calculate\\n                    helper(num,i+1,curr,temp+curr,target,curr);\\n                } else {\\n                    long plusValue = curr;\\n                    helper(num,i+1,soFar+plusValue,temp+\"+\"+curr,target,plusValue);\\n                    \\n                    long minusValue = -curr;\\n                    helper(num,i+1,soFar+minusValue,temp+\"-\"+curr,target,minusValue);\\n                    \\n                    long mulValue = prev*curr;\\n                    //subtract previously added value from mulValue\\n                    helper(num,i+1,soFar+mulValue - prev,temp+\"*\"+curr,target,mulValue);\\n                }\\n            }\\n        }\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1846436,
                "title": "python-bfs-not-the-fastest-but-easy-to-understand",
                "content": "Disclaimer: I\\'m using the `eval()` built-in. Feel free to replace it with your solution in https://leetcode.com/problems/basic-calculator/\\n\\n#### Idea\\n\\n- Iterate all character `n` in `num`. Between each digit, we can either insert an operater `+`, `-`, `*`, or do nothing.\\n- Keep expanding the list of all possible formula\\n- At the end of the iteration, evaluate each formula, and keep the ones that are equal to `target`\\n \\n```python\\nclass Solution:\\n    def addOperators(self, num: str, target: int) -> List[str]:\\n        result = []\\n        candidates = deque()\\n        candidates.append(num[0])\\n        for i in range(1, len(num)):\\n            size = len(candidates)\\n            next_char = num[i]\\n            for _ in range(size):\\n                c = candidates.popleft()\\n                for op in [\"+\", \"-\", \"*\"]:\\n                    candidates.append(c + op + next_char)\\n                if c.endswith(\"0\") and (len(c) == 1 or not c[-2].isnumeric()):\\n                    continue\\n                candidates.append(c + next_char)\\n        return [c for c in candidates if eval(c) == target]\\n```\\n",
                "solutionTags": [
                    "Python",
                    "Breadth-First Search"
                ],
                "code": "```python\\nclass Solution:\\n    def addOperators(self, num: str, target: int) -> List[str]:\\n        result = []\\n        candidates = deque()\\n        candidates.append(num[0])\\n        for i in range(1, len(num)):\\n            size = len(candidates)\\n            next_char = num[i]\\n            for _ in range(size):\\n                c = candidates.popleft()\\n                for op in [\"+\", \"-\", \"*\"]:\\n                    candidates.append(c + op + next_char)\\n                if c.endswith(\"0\") and (len(c) == 1 or not c[-2].isnumeric()):\\n                    continue\\n                candidates.append(c + next_char)\\n        return [c for c in candidates if eval(c) == target]\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1791871,
                "title": "python-soln-backtrack",
                "content": "\\tclass Solution:\\n\\t\\tdef addOperators(self, num: str, target: int) -> List[str]:\\n\\t\\t\\t# Time O(4^n), Space O(n)\\n\\t\\t\\tdef backtrack(idx, prev,curr,value,s):\\n\\t\\t\\t\\tif idx == n:\\n\\t\\t\\t\\t\\tif value == target and curr == 0:\\n\\t\\t\\t\\t\\t\\tself.result.append(s)\\n\\t\\t\\t\\t\\treturn\\n\\n\\t\\t\\t\\tcurr = curr * 10 + int(num[idx])\\n\\n\\t\\t\\t\\tif curr > 0:\\n\\t\\t\\t\\t\\tbacktrack(idx+1, prev,curr,value,s)\\n\\n\\t\\t\\t\\tif not s:\\n\\t\\t\\t\\t\\tbacktrack(idx+1, curr, 0, value+curr, str(curr))\\n\\t\\t\\t\\telse:\\n\\t\\t\\t\\t\\tbacktrack(idx+1, curr, 0, value+curr, s+\"+\"+str(curr))\\n\\t\\t\\t\\t\\tbacktrack(idx+1, -curr, 0, value-curr, s+\"-\"+str(curr))\\n\\t\\t\\t\\t\\tbacktrack(idx+1, prev*curr, 0, value-prev+prev*curr, s+\"*\"+str(curr))\\n\\n\\t\\t\\tn = len(num)\\n\\t\\t\\tself.result = []\\n\\t\\t\\tbacktrack(0,0,0,0,\"\")\\n\\n\\t\\t\\treturn self.result",
                "solutionTags": [
                    "Python",
                    "Backtracking"
                ],
                "code": "\\tclass Solution:\\n\\t\\tdef addOperators(self, num: str, target: int) -> List[str]:\\n\\t\\t\\t# Time O(4^n), Space O(n)\\n\\t\\t\\tdef backtrack(idx, prev,curr,value,s):\\n\\t\\t\\t\\tif idx == n:\\n\\t\\t\\t\\t\\tif value == target and curr == 0:\\n\\t\\t\\t\\t\\t\\tself.result.append(s)\\n\\t\\t\\t\\t\\treturn\\n\\n\\t\\t\\t\\tcurr = curr * 10 + int(num[idx])\\n\\n\\t\\t\\t\\tif curr > 0:\\n\\t\\t\\t\\t\\tbacktrack(idx+1, prev,curr,value,s)\\n\\n\\t\\t\\t\\tif not s:\\n\\t\\t\\t\\t\\tbacktrack(idx+1, curr, 0, value+curr, str(curr))\\n\\t\\t\\t\\telse:\\n\\t\\t\\t\\t\\tbacktrack(idx+1, curr, 0, value+curr, s+\"+\"+str(curr))\\n\\t\\t\\t\\t\\tbacktrack(idx+1, -curr, 0, value-curr, s+\"-\"+str(curr))\\n\\t\\t\\t\\t\\tbacktrack(idx+1, prev*curr, 0, value-prev+prev*curr, s+\"*\"+str(curr))\\n\\n\\t\\t\\tn = len(num)\\n\\t\\t\\tself.result = []\\n\\t\\t\\tbacktrack(0,0,0,0,\"\")\\n\\n\\t\\t\\treturn self.result",
                "codeTag": "Java"
            },
            {
                "id": 1566064,
                "title": "c-clean-and-concise-code",
                "content": "class Solution {\\npublic:\\n    \\n    void func(vector<string>&res,string curExp,string input,long long target,long long pos,long long curVal,long long last){\\n        \\n        if(pos==input.length()){\\n            \\n            if(curVal==target){\\n                res.push_back(curExp);\\n            }\\n            \\n            return;\\n            \\n        }\\n        \\n        for(int i=pos;i<input.length();i++){\\n            \\n            if(i!=pos && input[pos]==\\'0\\'){\\n                break;\\n            }\\n            \\n            string part=input.substr(pos,i+1-pos);\\n            \\n            long long curr=stoll(part);\\n            \\n            if(pos==0){\\n                \\n                func(res,curExp+part,input,target,i+1,curr,curr);\\n                \\n            }\\n            \\n            \\n            else{\\n                \\n                \\n                 func(res,curExp+\"+\"+part,input,target,i+1,curVal+curr,curr);\\n                \\n                 func(res,curExp+\"-\"+part,input,target,i+1,curVal-curr,-curr);\\n                \\n                 func(res,curExp+\"*\"+part,input,target,i+1,curVal-last+last*curr,last*curr);\\n                \\n                \\n            }\\n            \\n        }\\n        \\n        \\n    }\\n    \\n    vector<string> addOperators(string num, int target) {\\n        \\n        vector<string>res;\\n        \\n        func(res,\"\",num,target,0,0,0);\\n        \\n        return res;\\n        \\n    }\\n};",
                "solutionTags": [],
                "code": "class Solution {\\npublic:\\n    \\n    void func(vector<string>&res,string curExp,string input,long long target,long long pos,long long curVal,long long last){\\n        \\n        if(pos==input.length()){\\n            \\n            if(curVal==target){\\n                res.push_back(curExp);\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 1541067,
                "title": "python-solution-with-comments",
                "content": "```\\nclass Solution:\\n    def addOperators(self, num: str, target: int) -> List[str]:\\n        \\n        res = []\\n        \\n        def recurse(sidx, path, result_so_far, prev_num):\\n            if sidx == len(num):\\n                if result_so_far == target:\\n                    res.append(path[:]) \\n                return\\n            \\n            for i in range(sidx, len(num)):\\n                prefix = num[sidx:i+1]\\n                curr_num = int(prefix)\\n                \\n                if len(prefix) > 1 and prefix[0] == \"0\": return # don\\'t process if there is a leading 0. \\n                \\n                if prev_num is None:\\n                    recurse(i+1, path + prefix, result_so_far + curr_num, curr_num)\\n                else:\\n                    # consider +\\n                    recurse(i+1, path+\\'+\\'+prefix, result_so_far + curr_num, curr_num)\\n                    # consider -\\n                    recurse(i+1, path+\\'-\\'+prefix, result_so_far - curr_num, -curr_num)\\n                    # consider *\\n                    #temp = result_so_far - prev_num\\n                    #result_so_far = temp + curr_num * prev_num\\n                    #prev_num = (curr_num * prev_num) THIS IS THE CRUX of this Problem\\n                    recurse(i+1, path+\\'*\\'+prefix, result_so_far - prev_num + (curr_num * prev_num), (curr_num * prev_num))\\n\\n        recurse(0,\"\", 0, None)\\n        return res\\n        \\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def addOperators(self, num: str, target: int) -> List[str]:\\n        \\n        res = []\\n        \\n        def recurse(sidx, path, result_so_far, prev_num):\\n            if sidx == len(num):\\n                if result_so_far == target:\\n                    res.append(path[:]) \\n                return\\n            \\n            for i in range(sidx, len(num)):\\n                prefix = num[sidx:i+1]\\n                curr_num = int(prefix)\\n                \\n                if len(prefix) > 1 and prefix[0] == \"0\": return # don\\'t process if there is a leading 0. \\n                \\n                if prev_num is None:\\n                    recurse(i+1, path + prefix, result_so_far + curr_num, curr_num)\\n                else:\\n                    # consider +\\n                    recurse(i+1, path+\\'+\\'+prefix, result_so_far + curr_num, curr_num)\\n                    # consider -\\n                    recurse(i+1, path+\\'-\\'+prefix, result_so_far - curr_num, -curr_num)\\n                    # consider *\\n                    #temp = result_so_far - prev_num\\n                    #result_so_far = temp + curr_num * prev_num\\n                    #prev_num = (curr_num * prev_num) THIS IS THE CRUX of this Problem\\n                    recurse(i+1, path+\\'*\\'+prefix, result_so_far - prev_num + (curr_num * prev_num), (curr_num * prev_num))\\n\\n        recurse(0,\"\", 0, None)\\n        return res\\n        \\n```",
                "codeTag": "Java"
            },
            {
                "id": 1536328,
                "title": "python3-strightforward-and-consice",
                "content": "Similar idea with \\'calculators\\' problems, we record previous value for the multiply and check every possible symble/number combinations.\\n```\\nclass Solution:\\n    def addOperators(self, num: str, target: int) -> List[str]:\\n        res = []\\n        prev = None\\n        def dfs(i, val, path, prev):\\n            if i == len(num):\\n                if val == target:\\n                    res.append(path)\\n                return\\n            cur_val = 0\\n            for j in range(i, len(num)):\\n                cur_val = cur_val * 10 + int(num[j])\\n                if prev == None:\\n                    dfs(j+1, val+cur_val, path+num[i:j+1],cur_val)\\n                else:\\n                    dfs(j+1, val+cur_val,path+\\'+\\'+num[i:j+1],cur_val)\\n                    dfs(j+1, val-cur_val,path+\\'-\\'+num[i:j+1],-cur_val)\\n                    dfs(j+1, val+cur_val*prev-prev,path+\\'*\\'+num[i:j+1],cur_val*prev)\\n                \\n                if num[i] == \\'0\\':#prevent leading zeros\\n                    break\\n        dfs(0, 0, \\'\\', None)\\n        return res\\n                ```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def addOperators(self, num: str, target: int) -> List[str]:\\n        res = []\\n        prev = None\\n        def dfs(i, val, path, prev):\\n            if i == len(num):\\n                if val == target:\\n                    res.append(path)\\n                return\\n            cur_val = 0\\n            for j in range(i, len(num)):\\n                cur_val = cur_val * 10 + int(num[j])\\n                if prev == None:\\n                    dfs(j+1, val+cur_val, path+num[i:j+1],cur_val)\\n                else:\\n                    dfs(j+1, val+cur_val,path+\\'+\\'+num[i:j+1],cur_val)\\n                    dfs(j+1, val-cur_val,path+\\'-\\'+num[i:j+1],-cur_val)\\n                    dfs(j+1, val+cur_val*prev-prev,path+\\'*\\'+num[i:j+1],cur_val*prev)\\n                \\n                if num[i] == \\'0\\':#prevent leading zeros\\n                    break\\n        dfs(0, 0, \\'\\', None)\\n        return res\\n                ```",
                "codeTag": "Java"
            },
            {
                "id": 1471556,
                "title": "javascript-backtracking-99-93",
                "content": "![image](https://assets.leetcode.com/users/images/55b2671b-75dc-4252-ac72-e6c0a1d38e2e_1632000773.7629488.png)\\n\\nNot even going to lie to you, this one\\'s Hard.  See LC solution tab for basic approach.\\n\\n```\\nvar addOperators = function(num, target) {\\n  const res = [];\\n  backtrack();\\n  return res;\\n  \\n  function backtrack(ind = 0, tot = 0, exp = \\'\\', curNum = 0, befMult = 0) {\\n    //If at end and curNum is still a value or we didn\\'t find the total\\n    //Return because it\\'s not a correct solution path.\\n    if (ind === num.length && (curNum || tot !== target)) return;\\n\\t\\n    //If at end and total === target, push answer and return.\\n    if (ind === num.length && tot === target) return res.push(exp);\\n\\t\\n    //num[ind]-0 converts string at current index to a number.\\n    //*10 grow cur.  Two lines below just give possible number permutations.\\n    //Note that all recursive calls other than this one set curNum = 0.\\n    //This one calls with curNum = next.  What is next though?\\n    //First time this runs, next = 0 * 10 + (num[ind]-0).  Let\\'s say we get 1 in num[ind],\\n    //0*10 + 1 = 1.  Then we invoke backtrack again, but we only increment index and \\n    //pass in our 1.  Now, next time, next = 1 * 10 + num[idx].  Let\\'s say 5 this time.\\n    //This sets next to 15.  In this way, we have built up 15 from 1,5.  Combinations\\n    //of all the above are now in recursive paths.  The if(next) ensures we aren\\'t recursing\\n\\t//down erroneous paths - Ie. \\'10122\\' could lead us to build up \\'01\\', \\'012\\', \\'0122\\' which \\n\\t//just turns out to be the same as if we skipped the 0 and started building up at the 1.\\n    const next = curNum * 10 + (num[ind]-0);\\n    if (next) backtrack(ind+1, tot, exp, next, befMult);\\n\\t\\n    //Here we add.  We start with adding because if expression is empty (as in when invoked),\\n    //we can\\'t just subtract or multiply out of the gate.  We need to get at least one number in expression\\n    //before doing those operations, else \\'-5\\' or \\'*5\\' is going to end up at the start of our exp.\\n    //Here, we can check if there\\'s expression length or not, if not, we just add next num as a string (+\\'\\').\\n    //This is allowed because 0 + num still equals the num.  0 - 5 doesn\\'t equal the original num, and 0*5\\n    //certainly doesn\\'t either.  Ergo, we have to add first in order to attain a valid starting number to recurse on.\\n\\t//If total = -5 or 0 after just having a \\'5\\' in expression, our expression and total are out of sync.  Adding first\\n\\t//avoids this issue.\\n    backtrack(ind+1, tot + next, exp.length ? exp+\"+\"+next : next + \\'\\', 0, next);\\n\\t\\n    //If we are in a recursion level After initial invocation, there will be exp.length.\\n    //Now that we know we already have at least one num in the exp, we can use\\n    //the other operators to alter total / expression.\\n    if (exp.length) {\\n      backtrack(ind+1, tot - next, exp+\"-\"+next, 0, -next);\\n\\t\\t\\n      //This is the trickiest part of the problem imo.  If you could just use eval(exp) every time to \\n      //calculate total not on-the-fly, it\\'s Way easier.  Butttttt, I suppose when you get a number\\n      //like 999879687348598, and have expressions like \\'9+9*9-8*7-9+6-8*3-4-8*5+9-8\\'...\\n      //and you\\'re evaluating on Every permutation / recursion level... That is a little taxing.  \\n      //Keeping track of the total Before multiplying last is very clever and definitely the right way \\n      //to do it, but that\\'s not an easy intuitive leap to make imo.  Hopefully my future interviewer\\'s fine \\n      //with the terrible eval() runtime or generous with the hints. lol...  Because I\\'m not sure I\\'d get\\n      //this without at least a nudge.\\n      backtrack(ind+1, tot - befMult + (befMult * next), exp+\"*\"+next, 0, (befMult * next));\\n    }\\n  }\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\nvar addOperators = function(num, target) {\\n  const res = [];\\n  backtrack();\\n  return res;\\n  \\n  function backtrack(ind = 0, tot = 0, exp = \\'\\', curNum = 0, befMult = 0) {\\n    //If at end and curNum is still a value or we didn\\'t find the total\\n    //Return because it\\'s not a correct solution path.\\n    if (ind === num.length && (curNum || tot !== target)) return;\\n\\t\\n    //If at end and total === target, push answer and return.\\n    if (ind === num.length && tot === target) return res.push(exp);\\n\\t\\n    //num[ind]-0 converts string at current index to a number.\\n    //*10 grow cur.  Two lines below just give possible number permutations.\\n    //Note that all recursive calls other than this one set curNum = 0.\\n    //This one calls with curNum = next.  What is next though?\\n    //First time this runs, next = 0 * 10 + (num[ind]-0).  Let\\'s say we get 1 in num[ind],\\n    //0*10 + 1 = 1.  Then we invoke backtrack again, but we only increment index and \\n    //pass in our 1.  Now, next time, next = 1 * 10 + num[idx].  Let\\'s say 5 this time.\\n    //This sets next to 15.  In this way, we have built up 15 from 1,5.  Combinations\\n    //of all the above are now in recursive paths.  The if(next) ensures we aren\\'t recursing\\n\\t//down erroneous paths - Ie. \\'10122\\' could lead us to build up \\'01\\', \\'012\\', \\'0122\\' which \\n\\t//just turns out to be the same as if we skipped the 0 and started building up at the 1.\\n    const next = curNum * 10 + (num[ind]-0);\\n    if (next) backtrack(ind+1, tot, exp, next, befMult);\\n\\t\\n    //Here we add.  We start with adding because if expression is empty (as in when invoked),\\n    //we can\\'t just subtract or multiply out of the gate.  We need to get at least one number in expression\\n    //before doing those operations, else \\'-5\\' or \\'*5\\' is going to end up at the start of our exp.\\n    //Here, we can check if there\\'s expression length or not, if not, we just add next num as a string (+\\'\\').\\n    //This is allowed because 0 + num still equals the num.  0 - 5 doesn\\'t equal the original num, and 0*5\\n    //certainly doesn\\'t either.  Ergo, we have to add first in order to attain a valid starting number to recurse on.\\n\\t//If total = -5 or 0 after just having a \\'5\\' in expression, our expression and total are out of sync.  Adding first\\n\\t//avoids this issue.\\n    backtrack(ind+1, tot + next, exp.length ? exp+\"+\"+next : next + \\'\\', 0, next);\\n\\t\\n    //If we are in a recursion level After initial invocation, there will be exp.length.\\n    //Now that we know we already have at least one num in the exp, we can use\\n    //the other operators to alter total / expression.\\n    if (exp.length) {\\n      backtrack(ind+1, tot - next, exp+\"-\"+next, 0, -next);\\n\\t\\t\\n      //This is the trickiest part of the problem imo.  If you could just use eval(exp) every time to \\n      //calculate total not on-the-fly, it\\'s Way easier.  Butttttt, I suppose when you get a number\\n      //like 999879687348598, and have expressions like \\'9+9*9-8*7-9+6-8*3-4-8*5+9-8\\'...\\n      //and you\\'re evaluating on Every permutation / recursion level... That is a little taxing.  \\n      //Keeping track of the total Before multiplying last is very clever and definitely the right way \\n      //to do it, but that\\'s not an easy intuitive leap to make imo.  Hopefully my future interviewer\\'s fine \\n      //with the terrible eval() runtime or generous with the hints. lol...  Because I\\'m not sure I\\'d get\\n      //this without at least a nudge.\\n      backtrack(ind+1, tot - befMult + (befMult * next), exp+\"*\"+next, 0, (befMult * next));\\n    }\\n  }\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1470697,
                "title": "python-dfs-solution-for-loop-clear",
                "content": "Idea:\\n- We start with the first digit then add other digits with operators `\\'+\\',\\'-\\',\\'*\\',\\'\\'` in front. \\n- We need empty operator to add more digits to the digit. At the end we evall all the operations in stack and if it\\'s equal to target we return it.\\n\\n- The trickiest part is to avoid making oprations like \\'1+00\\'. The way to slove that if previous number is \\'0\\' and operator is \\'\\' we go back until we can and meet non \\'0\\' or operators `\\'+\\',\\'-\\',\\'*\\'`. Depending on the way we stopped we proceed with adding more 0s or skip.\\n\\n\\n```python\\nclass Solution:\\n    def addOperators(self, S: str, target: int) -> List[str]:\\n        q = [S[0]]\\n        \\n        for n in S[1:]:\\n            updated_q = []\\n            while q:\\n                node = q.pop()\\n                for o in {\\'*\\',\\'+\\',\\'-\\',\\'\\'}:\\n                    # check if node before == 0 \\n                    # then we need to force adding operator if number is \\'0\\' to avoid \\'00\\'\\n                    # otherwise if number ends with 0 but starts with other digit like 1 (\\'1000\\') we are fine\\n                    if node[-1] == \\'0\\' and o == \\'\\':\\n                        i = len(node)-1\\n                        while i >= 0 and node[i] == \\'0\\':\\n                            i -= 1\\n                        if i < 0 or node[i] in {\\'*\\',\\'+\\',\\'-\\'}:\\n                            continue\\n                            \\n                    updated_q.append(node + o + n)\\n            q = updated_q[:]\\n        \\n        return [e for e in q if eval(e) == target]       \\n```\\nTime coplexity: `O(N 4^N)`\\nSpace: `O(4 ^ N)`",
                "solutionTags": [
                    "Python",
                    "Depth-First Search"
                ],
                "code": "```python\\nclass Solution:\\n    def addOperators(self, S: str, target: int) -> List[str]:\\n        q = [S[0]]\\n        \\n        for n in S[1:]:\\n            updated_q = []\\n            while q:\\n                node = q.pop()\\n                for o in {\\'*\\',\\'+\\',\\'-\\',\\'\\'}:\\n                    # check if node before == 0 \\n                    # then we need to force adding operator if number is \\'0\\' to avoid \\'00\\'\\n                    # otherwise if number ends with 0 but starts with other digit like 1 (\\'1000\\') we are fine\\n                    if node[-1] == \\'0\\' and o == \\'\\':\\n                        i = len(node)-1\\n                        while i >= 0 and node[i] == \\'0\\':\\n                            i -= 1\\n                        if i < 0 or node[i] in {\\'*\\',\\'+\\',\\'-\\'}:\\n                            continue\\n                            \\n                    updated_q.append(node + o + n)\\n            q = updated_q[:]\\n        \\n        return [e for e in q if eval(e) == target]       \\n```",
                "codeTag": "Java"
            },
            {
                "id": 1402499,
                "title": "backtracking-c-solution",
                "content": "Here\\'s my solution. It gives correct results but also produces duplicate strings. Can anybody please tell me how to prevent the duplicacy?\\n```\\nclass Solution {\\npublic:\\n    void solve(unordered_set<string> &res, string num, int target, int ind, int n, string temp){\\n        if(ind == n){\\n            temp.pop_back();\\n            int a = temp[0]-\\'0\\', op;\\n            for(int i = 1; i < temp.length(); i++){\\n                if(temp[i] != \\'+\\' && temp[i] != \\'-\\' && temp[i] != \\'*\\'){\\n                    if(op == \\'+\\'){\\n                        a += (temp[i]-\\'0\\');\\n                    }\\n                    if(op == \\'*\\'){\\n                        a *= (temp[i]-\\'0\\');\\n                    }\\n                    if(op == \\'-\\'){\\n                        a -= (temp[i]-\\'0\\');\\n                    }\\n                }\\n                else{\\n                    op = temp[i];\\n                }\\n            }\\n            if(a == target){\\n                res.insert(temp);\\n            }\\n            return;\\n        }\\n        \\n        temp += num.substr(ind, 1) + \"+\";\\n        solve(res, num, target, ind+1, n, temp);\\n        temp.erase(temp.end()-2, temp.end());\\n        \\n        temp += num.substr(ind, 1) + \"-\";\\n        solve(res, num, target, ind+1, n, temp);\\n        temp.erase(temp.end()-2, temp.end());\\n        \\n        temp += num.substr(ind, 1) + \"*\";\\n        solve(res, num, target, ind+1, n, temp);\\n        temp.erase(temp.end()-2, temp.end());\\n    }\\n    vector<string> addOperators(string num, int target) {\\n        unordered_set<string> res;\\n        vector<string> ans;\\n        int n = num.length();\\n        \\n        solve(res, num, target, 0, n, \"\");\\n        \\n        for(auto i : res){\\n            ans.push_back(i);\\n        }\\n        \\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "Backtracking"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    void solve(unordered_set<string> &res, string num, int target, int ind, int n, string temp){\\n        if(ind == n){\\n            temp.pop_back();\\n            int a = temp[0]-\\'0\\', op;\\n            for(int i = 1; i < temp.length(); i++){\\n                if(temp[i] != \\'+\\' && temp[i] != \\'-\\' && temp[i] != \\'*\\'){\\n                    if(op == \\'+\\'){\\n                        a += (temp[i]-\\'0\\');\\n                    }\\n                    if(op == \\'*\\'){\\n                        a *= (temp[i]-\\'0\\');\\n                    }\\n                    if(op == \\'-\\'){\\n                        a -= (temp[i]-\\'0\\');\\n                    }\\n                }\\n                else{\\n                    op = temp[i];\\n                }\\n            }\\n            if(a == target){\\n                res.insert(temp);\\n            }\\n            return;\\n        }\\n        \\n        temp += num.substr(ind, 1) + \"+\";\\n        solve(res, num, target, ind+1, n, temp);\\n        temp.erase(temp.end()-2, temp.end());\\n        \\n        temp += num.substr(ind, 1) + \"-\";\\n        solve(res, num, target, ind+1, n, temp);\\n        temp.erase(temp.end()-2, temp.end());\\n        \\n        temp += num.substr(ind, 1) + \"*\";\\n        solve(res, num, target, ind+1, n, temp);\\n        temp.erase(temp.end()-2, temp.end());\\n    }\\n    vector<string> addOperators(string num, int target) {\\n        unordered_set<string> res;\\n        vector<string> ans;\\n        int n = num.length();\\n        \\n        solve(res, num, target, 0, n, \"\");\\n        \\n        for(auto i : res){\\n            ans.push_back(i);\\n        }\\n        \\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1193048,
                "title": "swift-clean-code",
                "content": "```swift\\nclass Solution {\\n    func addOperators(_ num: String, _ target: Int) -> [String] {\\n        var res = [String]()\\n        let sArr = Array(num)\\n        func dfs(_ path: String, _ index: Int, _ value: Int, _ multed: Int) {\\n            if index == sArr.endIndex {\\n                if value == target {\\n                    res.append(path)    \\n                }\\n                return\\n            }\\n            var curr = 0\\n            for i in index..<sArr.endIndex {\\n                if i != index && sArr[index] == \"0\" {break}\\n                curr = curr*10 + Int(String(sArr[i]))!\\n                if index == 0 {\\n                    dfs(path+\"\\\\(curr)\", i+1, curr, curr)\\n                } else {\\n                    dfs(path+\"+\\\\(curr)\", i+1, value + curr, curr)\\n                    dfs(path+\"-\\\\(curr)\", i+1, value - curr, -curr)\\n                    dfs(path+\"*\\\\(curr)\", i+1, value - multed + multed * curr, multed * curr)\\n                }\\n            }\\n        }\\n        dfs(\"\",0,0,0)\\n        return res\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```swift\\nclass Solution {\\n    func addOperators(_ num: String, _ target: Int) -> [String] {\\n        var res = [String]()\\n        let sArr = Array(num)\\n        func dfs(_ path: String, _ index: Int, _ value: Int, _ multed: Int) {\\n            if index == sArr.endIndex {\\n                if value == target {\\n                    res.append(path)    \\n                }\\n                return\\n            }\\n            var curr = 0\\n            for i in index..<sArr.endIndex {\\n                if i != index && sArr[index] == \"0\" {break}\\n                curr = curr*10 + Int(String(sArr[i]))!\\n                if index == 0 {\\n                    dfs(path+\"\\\\(curr)\", i+1, curr, curr)\\n                } else {\\n                    dfs(path+\"+\\\\(curr)\", i+1, value + curr, curr)\\n                    dfs(path+\"-\\\\(curr)\", i+1, value - curr, -curr)\\n                    dfs(path+\"*\\\\(curr)\", i+1, value - multed + multed * curr, multed * curr)\\n                }\\n            }\\n        }\\n        dfs(\"\",0,0,0)\\n        return res\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1041628,
                "title": "c-using-backtracking-template-with-explaination",
                "content": "I have used standard backtracking template to solve the problem with optimizations to calculate the value of expressiom on the fly.\\nindex variable is the starting point of second operand, except when index == 0 (as first operator has not been selected yet).\\n\\nThere are 3 operators that can be applied to second operand: +, - , *\\nWe take care of concatenating digits when calculating operand.\\n\\nThe idea here is to reduce the expression as a + b. We are storing 2 varibales for calculations. Add denotes a, and Mul denotes b.\\nAs * has higher precedence over + and -, we want to store operand, if next operator is *\\nMul dentotes operand if next operator is *\\nAdd denotes operand for +\\n\\nTotal value for expression = add + mul\\n\\n```\\ne.g. 1 * 2 + 5 - 3 * 4 * 3 + 1\\n\\t\\t\\t\\t   A          M\\n1                  0          1\\n1*2                0          2\\n1*2+5              2          5 (If * is next operator, it will get multiplied to 5 only, so we apply + operator, Add = Mul + Add)\\n1*2+5-3            7         -3 (similarly, for * to be next operator, -3 will be first operand, so Add = Add + Mul)\\n1*2+5-3*4          7         -12 (If * is next operator, it should get multiplied to -3*4) \\n1*2+5-3*4*3        7         -36\\n1*2+5-3*4*3+1     -31         1\\n```\\n\\n```\\nclass Solution {\\n    vector<string> result;\\n    int target;\\npublic:\\n    vector<string> addOperators(string num, int target) {\\n        this->target = target;\\n        string s = \"\";\\n        getComb(num, 0, 0, 0, s);\\n        return result;\\n    }\\n    \\n    void getComb(string& num, int index, long add, long mul, string s) {\\n        if (add > INT_MAX || mul > INT_MAX) {\\n            return;\\n        }\\n        \\n        if (index == num.size()) {\\n            if (add + mul == target) {\\n                result.push_back(s);\\n            }\\n            return;\\n        }\\n        \\n        for (int i = index; i < num.size(); i++) {\\n            if (num.at(index) == \\'0\\' && i > index) {\\n                return;\\n            }\\n            \\n            long x = stol(num.substr(index, i - index + 1));\\n            if (index == 0) {\\n                getComb(num, i + 1, 0, x, s + to_string(x));\\n                continue;\\n            }\\n            \\n            getComb(num, i + 1, add + mul, x, s + \"+\" + to_string(x));\\n            getComb(num, i + 1, add + mul, -x, s + \"-\" + to_string(x));            \\n            getComb(num, i + 1, add, mul * x, s + \"*\" + to_string(x));\\n        }\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Backtracking"
                ],
                "code": "```\\ne.g. 1 * 2 + 5 - 3 * 4 * 3 + 1\\n\\t\\t\\t\\t   A          M\\n1                  0          1\\n1*2                0          2\\n1*2+5              2          5 (If * is next operator, it will get multiplied to 5 only, so we apply + operator, Add = Mul + Add)\\n1*2+5-3            7         -3 (similarly, for * to be next operator, -3 will be first operand, so Add = Add + Mul)\\n1*2+5-3*4          7         -12 (If * is next operator, it should get multiplied to -3*4) \\n1*2+5-3*4*3        7         -36\\n1*2+5-3*4*3+1     -31         1\\n```\n```\\nclass Solution {\\n    vector<string> result;\\n    int target;\\npublic:\\n    vector<string> addOperators(string num, int target) {\\n        this->target = target;\\n        string s = \"\";\\n        getComb(num, 0, 0, 0, s);\\n        return result;\\n    }\\n    \\n    void getComb(string& num, int index, long add, long mul, string s) {\\n        if (add > INT_MAX || mul > INT_MAX) {\\n            return;\\n        }\\n        \\n        if (index == num.size()) {\\n            if (add + mul == target) {\\n                result.push_back(s);\\n            }\\n            return;\\n        }\\n        \\n        for (int i = index; i < num.size(); i++) {\\n            if (num.at(index) == \\'0\\' && i > index) {\\n                return;\\n            }\\n            \\n            long x = stol(num.substr(index, i - index + 1));\\n            if (index == 0) {\\n                getComb(num, i + 1, 0, x, s + to_string(x));\\n                continue;\\n            }\\n            \\n            getComb(num, i + 1, add + mul, x, s + \"+\" + to_string(x));\\n            getComb(num, i + 1, add + mul, -x, s + \"-\" + to_string(x));            \\n            getComb(num, i + 1, add, mul * x, s + \"*\" + to_string(x));\\n        }\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 992834,
                "title": "c-solution-beats-80",
                "content": "```\\nclass Solution {\\npublic:\\n    vector<string> result;\\n\\n    vector<string> addOperators(string &num, int target) {\\n        dfs(num, target, 0, \"\", 0, 0);\\n        return result;\\n    }\\n\\n    void dfs(string &num, int target, int start, string str, long long sum, long long last) {\\n        if (num.size() == start) {\\n            if (target == sum) result.push_back(str);\\n            return;\\n        }\\n        \\n        long long x = 0;\\n        string ret = \"\";\\n        \\n        for (int i = start; i < num.size(); ++i) {\\n            x = x * 10 + num[i] - \\'0\\';\\n            ret += num[i];\\n            \\n            if (start == 0) {\\n                dfs(num, target, i + 1, str + ret, x, x);\\n            } else {\\n                dfs(num, target, i + 1, str + \"*\" + ret, sum - last + x * last, x * last);\\n                dfs(num, target, i + 1, str + \"+\" + ret, sum + x, x);\\n                dfs(num, target, i + 1, str + \"-\" + ret, sum - x, -x);\\n            }\\n            \\n            if (x == 0) break;            \\n        }\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<string> result;\\n\\n    vector<string> addOperators(string &num, int target) {\\n        dfs(num, target, 0, \"\", 0, 0);\\n        return result;\\n    }\\n\\n    void dfs(string &num, int target, int start, string str, long long sum, long long last) {\\n        if (num.size() == start) {\\n            if (target == sum) result.push_back(str);\\n            return;\\n        }\\n        \\n        long long x = 0;\\n        string ret = \"\";\\n        \\n        for (int i = start; i < num.size(); ++i) {\\n            x = x * 10 + num[i] - \\'0\\';\\n            ret += num[i];\\n            \\n            if (start == 0) {\\n                dfs(num, target, i + 1, str + ret, x, x);\\n            } else {\\n                dfs(num, target, i + 1, str + \"*\" + ret, sum - last + x * last, x * last);\\n                dfs(num, target, i + 1, str + \"+\" + ret, sum + x, x);\\n                dfs(num, target, i + 1, str + \"-\" + ret, sum - x, -x);\\n            }\\n            \\n            if (x == 0) break;            \\n        }\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 962682,
                "title": "simplified-python-solution-backtracking-w-o-eval",
                "content": "Example by leetcode was excessively complicated, so simplified\\n\\n````\\nclass Solution:\\n    def addOperators(self, num: str, target: int) -> List[str]:\\n        res = []\\n\\n        def backtrack(idx,prev,value,path):\\n            nonlocal res\\n\\n            if idx == len(num):\\n                if value == target:\\n\\t\\t\\t\\t\\t# trim first char as it will be +\\n                    res.append(path[1:])\\n                return\\n\\n            curr = 0\\n            curr_s = \\'\\'\\n\\n            # create all prefixes e.g. 1, 12, 123\\n            for i in range(idx,len(num)):\\n                curr *= 10\\n                curr += int(num[i])  \\n                curr_s += num[i]\\n\\n                # add to current total\\n                backtrack(i+1, curr, value + curr, path + \\'+\\' + curr_s)\\n\\n                if path:\\n                    # minus from current total\\n                    backtrack(i+1, -curr, value - curr, path + \\'-\\' + curr_s)\\n                    \\n                    # multiply is a special case\\n                    # as * has precedence we need\\n                    # to remove the previous value\\n                    # and multiply with the current\\n                    backtrack(i+1, prev * curr, value - prev + prev * curr, path + \\'*\\' + curr_s)\\n\\n                # nothing else can be created as prefix is 0 (01)\\n                if curr == 0:\\n                    break\\n\\n        backtrack(0,0,0,\\'\\')\\n        return res\\n```",
                "solutionTags": [],
                "code": "````\\nclass Solution:\\n    def addOperators(self, num: str, target: int) -> List[str]:\\n        res = []\\n\\n        def backtrack(idx,prev,value,path):\\n            nonlocal res\\n\\n            if idx == len(num):\\n                if value == target:\\n\\t\\t\\t\\t\\t# trim first char as it will be +\\n                    res.append(path[1:])\\n                return\\n\\n            curr = 0\\n            curr_s = \\'\\'\\n\\n            # create all prefixes e.g. 1, 12, 123\\n            for i in range(idx,len(num)):\\n                curr *= 10\\n                curr += int(num[i])  \\n                curr_s += num[i]\\n\\n                # add to current total\\n                backtrack(i+1, curr, value + curr, path + \\'+\\' + curr_s)\\n\\n                if path:\\n                    # minus from current total\\n                    backtrack(i+1, -curr, value - curr, path + \\'-\\' + curr_s)\\n                    \\n                    # multiply is a special case\\n                    # as * has precedence we need\\n                    # to remove the previous value\\n                    # and multiply with the current\\n                    backtrack(i+1, prev * curr, value - prev + prev * curr, path + \\'*\\' + curr_s)\\n\\n                # nothing else can be created as prefix is 0 (01)\\n                if curr == 0:\\n                    break\\n\\n        backtrack(0,0,0,\\'\\')\\n        return res\\n```",
                "codeTag": "Java"
            },
            {
                "id": 837116,
                "title": "simple-and-easy-python-solution-backtracking",
                "content": "```\\nclass Solution:\\n    def Util(self, num, target, ind, l, mem, exp):\\n        if ind == l - 1:\\n            exp += num[ind]\\n            if eval(exp) == target:\\n                return [exp]\\n        if ind >= l:\\n            return []\\n        ret1 = self.Util(num, target, ind + 1, l, mem, exp + str(num[ind]) + \\'+\\')\\n        ret2 = self.Util(num, target, ind + 1, l, mem, exp + str(num[ind]) + \\'-\\')\\n        ret3 = self.Util(num, target, ind + 1, l, mem, exp + str(num[ind]) + \\'*\\')\\n        if (exp and exp[-1].isdigit() is True and num[ind] == \\'0\\') or num[ind] != \\'0\\':\\n            ret4 = self.Util(num, target, ind + 1, l, mem, exp + str(num[ind]))\\n            ret = ret1 + ret2 + ret3 + ret4\\n        else:\\n            ret = ret1 + ret2 + ret3\\n        return ret\\n        \\n    def addOperators(self, num: str, target: int) -> List[str]:\\n        return self.Util(num, target, 0, len(num), dict(), \\'\\')\\n```",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Backtracking"
                ],
                "code": "```\\nclass Solution:\\n    def Util(self, num, target, ind, l, mem, exp):\\n        if ind == l - 1:\\n            exp += num[ind]\\n            if eval(exp) == target:\\n                return [exp]\\n        if ind >= l:\\n            return []\\n        ret1 = self.Util(num, target, ind + 1, l, mem, exp + str(num[ind]) + \\'+\\')\\n        ret2 = self.Util(num, target, ind + 1, l, mem, exp + str(num[ind]) + \\'-\\')\\n        ret3 = self.Util(num, target, ind + 1, l, mem, exp + str(num[ind]) + \\'*\\')\\n        if (exp and exp[-1].isdigit() is True and num[ind] == \\'0\\') or num[ind] != \\'0\\':\\n            ret4 = self.Util(num, target, ind + 1, l, mem, exp + str(num[ind]))\\n            ret = ret1 + ret2 + ret3 + ret4\\n        else:\\n            ret = ret1 + ret2 + ret3\\n        return ret\\n        \\n    def addOperators(self, num: str, target: int) -> List[str]:\\n        return self.Util(num, target, 0, len(num), dict(), \\'\\')\\n```",
                "codeTag": "Java"
            },
            {
                "id": 724989,
                "title": "bfs-and-dfs-with-intuitive-figure-and-explanations-python3",
                "content": "the example figure for DFS, input is \\'123\\' and target=6\\n![image](https://assets.leetcode.com/users/images/115f3d0f-c186-4ce4-822c-21e4fea6cf2e_1594172504.141081.png)\\n\\nspecial case:\\n![image](https://assets.leetcode.com/users/images/558c2bf1-4c09-47e2-a094-6c2806b77549_1594523624.2076805.png)\\n\\n\\n\\n```\\nclass Solution:\\n    \\n    # bfs\\n    def addOperators_bfs(self, numstr, target):\\n        res = []\\n        q = collections.deque() # try to use deque here, if use [], it will be too slow to pass OJ\\n        for i in range(1, len(numstr)+1):\\n            if i == 1 or (i>1 and numstr[0] != \\'0\\'):\\n                q.append([numstr[i:], numstr[:i], int(numstr[:i]), int(numstr[:i])]) \\n                # remain str, current formula, the value of current formula, the last.vale of the formula\\n        \\n        while q:\\n            qsize = len(q)\\n            for i in range(qsize):\\n                atuple = q.popleft() # collections.deque() or popleft() is also fine\\n                remainstr, fstr, fval, flast = atuple[0], atuple[1], atuple[2], atuple[3]\\n                if len(remainstr) == 0 and fval == target:\\n                    res.append(fstr)\\n                    continue\\n                \\n                for j in range(1, len(remainstr)+1):\\n                    if j==1 or (j>1 and remainstr[0] != \\'0\\'):\\n                        # +, -, *\\n                        val = remainstr[:j]\\n                        q.append([remainstr[j:], fstr + \\'+\\' + val, fval + int(val), int(val)])\\n                        q.append([remainstr[j:], fstr + \\'-\\' + val, fval - int(val), -int(val)])\\n                        q.append([remainstr[j:], fstr + \\'*\\' + val, fval - flast + flast*int(val), flast*int(val)])\\n        return res\\n    \\n    # dfs\\n    def addOperators(self, num: str, target: int) -> List[str]:\\n        res = []\\n        self.target = target\\n        \\n        for i in range(1, len(num) + 1):\\n            if i==1 or (i>1 and num[0] != \\'0\\'):\\n                self.dfs(num[i:], num[:i], int(num[:i]), int(num[:i]), res)\\n        return res\\n    \\n    def dfs(self, num, fstr, fval, flast, res):\\n        # fstr = string of current formula\\n        # fval = value of current formula\\n        # flast = last value for +- and last computing result for * in formula. For example, if fstr=2+3, then flast=3, if fstr=2-3, then flast=-3, if fstr=2+3*4, then flast=3*4=12\\n        if not num:\\n            if fval == self.target:\\n                res.append(fstr)\\n            return\\n        \\n        for i in range(1, len(num)+1):\\n            val=num[:i]\\n            if i == 1 or (i>1 and num[0] != \\'0\\'):\\n                self.dfs(num[i:], fstr + \\'+\\' + val, fval + int(val), int(val), res)\\n                self.dfs(num[i:], fstr + \\'-\\' + val, fval - int(val), -int(val), res)\\n                self.dfs(num[i:], fstr + \\'*\\' + val, fval-flast+flast*int(val), flast*int(val), res)\\n               \\n            # 2+3*2: currently coming is *2, current formula = 2+3, its value is 5, the last vale of this formula is 3, thus: 5-3+3*2 is fine\\n            # 2-3*5: currently coming is *5, current formula = 2-3, its value is -1, the last vale of this formula is -3, thus: -1-(-3) + (-3)*5 = -1+3-15=-13\\n            # 3*5*2: currently coming is *2, current formula = 3*5, its value is 15, the last vale of this formula is 3*5=15!, thus: 15-15+15*2=30, result is okay as well\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    \\n    # bfs\\n    def addOperators_bfs(self, numstr, target):\\n        res = []\\n        q = collections.deque() # try to use deque here, if use [], it will be too slow to pass OJ\\n        for i in range(1, len(numstr)+1):\\n            if i == 1 or (i>1 and numstr[0] != \\'0\\'):\\n                q.append([numstr[i:], numstr[:i], int(numstr[:i]), int(numstr[:i])]) \\n                # remain str, current formula, the value of current formula, the last.vale of the formula\\n        \\n        while q:\\n            qsize = len(q)\\n            for i in range(qsize):\\n                atuple = q.popleft() # collections.deque() or popleft() is also fine\\n                remainstr, fstr, fval, flast = atuple[0], atuple[1], atuple[2], atuple[3]\\n                if len(remainstr) == 0 and fval == target:\\n                    res.append(fstr)\\n                    continue\\n                \\n                for j in range(1, len(remainstr)+1):\\n                    if j==1 or (j>1 and remainstr[0] != \\'0\\'):\\n                        # +, -, *\\n                        val = remainstr[:j]\\n                        q.append([remainstr[j:], fstr + \\'+\\' + val, fval + int(val), int(val)])\\n                        q.append([remainstr[j:], fstr + \\'-\\' + val, fval - int(val), -int(val)])\\n                        q.append([remainstr[j:], fstr + \\'*\\' + val, fval - flast + flast*int(val), flast*int(val)])\\n        return res\\n    \\n    # dfs\\n    def addOperators(self, num: str, target: int) -> List[str]:\\n        res = []\\n        self.target = target\\n        \\n        for i in range(1, len(num) + 1):\\n            if i==1 or (i>1 and num[0] != \\'0\\'):\\n                self.dfs(num[i:], num[:i], int(num[:i]), int(num[:i]), res)\\n        return res\\n    \\n    def dfs(self, num, fstr, fval, flast, res):\\n        # fstr = string of current formula\\n        # fval = value of current formula\\n        # flast = last value for +- and last computing result for * in formula. For example, if fstr=2+3, then flast=3, if fstr=2-3, then flast=-3, if fstr=2+3*4, then flast=3*4=12\\n        if not num:\\n            if fval == self.target:\\n                res.append(fstr)\\n            return\\n        \\n        for i in range(1, len(num)+1):\\n            val=num[:i]\\n            if i == 1 or (i>1 and num[0] != \\'0\\'):\\n                self.dfs(num[i:], fstr + \\'+\\' + val, fval + int(val), int(val), res)\\n                self.dfs(num[i:], fstr + \\'-\\' + val, fval - int(val), -int(val), res)\\n                self.dfs(num[i:], fstr + \\'*\\' + val, fval-flast+flast*int(val), flast*int(val), res)\\n               \\n            # 2+3*2: currently coming is *2, current formula = 2+3, its value is 5, the last vale of this formula is 3, thus: 5-3+3*2 is fine\\n            # 2-3*5: currently coming is *5, current formula = 2-3, its value is -1, the last vale of this formula is -3, thus: -1-(-3) + (-3)*5 = -1+3-15=-13\\n            # 3*5*2: currently coming is *2, current formula = 3*5, its value is 15, the last vale of this formula is 3*5=15!, thus: 15-15+15*2=30, result is okay as well\\n```",
                "codeTag": "Java"
            },
            {
                "id": 632105,
                "title": "java-backtrack-just-brutal-force-dfs",
                "content": "Orig: https://leetcode.com/problems/expression-add-operators/discuss/71895/Java-Standard-Backtrace-AC-Solutoin-short-and-clear\\n```\\nclass Solution {\\n    List<String> res = new ArrayList<>();\\n    long m, t;\\n    String num;\\n    public List<String> addOperators(String num, int target) {\\n        this.num = num;\\n        if (num == null || num.length() == 0) return res;\\n        m = num.length();\\n        t = target;\\n        dfs(\"\", 0, 0, 0);\\n        return res;\\n    }\\n    \\n    private void dfs(String s, int idx, long sum, long mul) {\\n        if (idx == m) {\\n            if (sum == t) res.add(s);\\n            return;\\n        }\\n        for (int i = idx; i < m; i++) {\\n            if (i != idx && num.charAt(idx) == \\'0\\') break;  //invalid number format, for example, \"03\".\\n            long n = Long.parseLong(num.substring(idx, i+1));  // must use long to avoid overflow\\n            if (idx == 0) {    // first must be \"+\"\\n                dfs(n + \"\", i + 1, n, n);\\n                continue;\\n            }\\n            dfs(s + \"+\" + n, i + 1, sum + n, n);\\n            dfs(s + \"-\" + n, i + 1, sum - n, -n);\\n            dfs(s + \"*\" + n, i + 1, sum - mul + mul * n, mul * n);\\n            // if (i == idx && num.charAt(idx) == \\'0\\') break;  // must put before \"if (idx == 0) {\"\"\\n        }\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    List<String> res = new ArrayList<>();\\n    long m, t;\\n    String num;\\n    public List<String> addOperators(String num, int target) {\\n        this.num = num;\\n        if (num == null || num.length() == 0) return res;\\n        m = num.length();\\n        t = target;\\n        dfs(\"\", 0, 0, 0);\\n        return res;\\n    }\\n    \\n    private void dfs(String s, int idx, long sum, long mul) {\\n        if (idx == m) {\\n            if (sum == t) res.add(s);\\n            return;\\n        }\\n        for (int i = idx; i < m; i++) {\\n            if (i != idx && num.charAt(idx) == \\'0\\') break;  //invalid number format, for example, \"03\".\\n            long n = Long.parseLong(num.substring(idx, i+1));  // must use long to avoid overflow\\n            if (idx == 0) {    // first must be \"+\"\\n                dfs(n + \"\", i + 1, n, n);\\n                continue;\\n            }\\n            dfs(s + \"+\" + n, i + 1, sum + n, n);\\n            dfs(s + \"-\" + n, i + 1, sum - n, -n);\\n            dfs(s + \"*\" + n, i + 1, sum - mul + mul * n, mul * n);\\n            // if (i == idx && num.charAt(idx) == \\'0\\') break;  // must put before \"if (idx == 0) {\"\"\\n        }\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 482137,
                "title": "self-explanatory-beats-96-submissions",
                "content": "```\\nclass Solution(object):\\n    def addOperators(self, num, target):\\n        res = []\\n        n = len(num)\\n        def dfs(currIndex,prevVal,currVal,expr):\\n          if currIndex==n:\\n            if currVal==target:\\n              res.append(expr)\\n            return\\n          for i in range(currIndex,n):\\n            operand = num[currIndex:i+1]\\n            if len(operand)>1 and operand[0]==\\'0\\':\\n              break\\n            integerOp = int(operand)\\n            if currIndex==0:\\n              dfs(i+1,integerOp,integerOp,operand)\\n            else:\\n              #addition\\n              dfs(i+1,integerOp,currVal+integerOp,expr+\\'+\\'+operand)\\n              #substraction\\n              dfs(i+1,-integerOp,currVal-integerOp,expr+\\'-\\'+operand)\\n              #multiply\\n              dfs(i+1, prevVal*integerOp,\\n                  (currVal-prevVal)+(prevVal*integerOp),\\n                 expr+\\'*\\'+operand)\\n              \\n        dfs(0,0,0,\"\")\\n        # print res\\n        return res\\n    ```",
                "solutionTags": [
                    "Python",
                    "Depth-First Search"
                ],
                "code": "```\\nclass Solution(object):\\n    def addOperators(self, num, target):\\n        res = []\\n        n = len(num)\\n        def dfs(currIndex,prevVal,currVal,expr):\\n          if currIndex==n:\\n            if currVal==target:\\n              res.append(expr)\\n            return\\n          for i in range(currIndex,n):\\n            operand = num[currIndex:i+1]\\n            if len(operand)>1 and operand[0]==\\'0\\':\\n              break\\n            integerOp = int(operand)\\n            if currIndex==0:\\n              dfs(i+1,integerOp,integerOp,operand)\\n            else:\\n              #addition\\n              dfs(i+1,integerOp,currVal+integerOp,expr+\\'+\\'+operand)\\n              #substraction\\n              dfs(i+1,-integerOp,currVal-integerOp,expr+\\'-\\'+operand)\\n              #multiply\\n              dfs(i+1, prevVal*integerOp,\\n                  (currVal-prevVal)+(prevVal*integerOp),\\n                 expr+\\'*\\'+operand)\\n              \\n        dfs(0,0,0,\"\")\\n        # print res\\n        return res\\n    ```",
                "codeTag": "Java"
            },
            {
                "id": 359405,
                "title": "easy-understand-java-solution",
                "content": "```\\nclass Solution {\\n    public List<String> addOperators(String num, int target) {\\n        List<String> res = new ArrayList<>();\\n        dfs(res, 0, 0, 0, \"\", num, target);\\n        return res;\\n    }\\n    \\n    private void dfs(List<String> res, int idx, long bufVal, long sum,\\n                     String path, String num, int target) {\\n        if (idx == num.length()) {\\n            if (sum + bufVal == target) {\\n                res.add(path);\\n            }\\n            return;\\n        } \\n        \\n        for (int i = idx; i < num.length(); i++) {\\n            if (i != idx && num.charAt(idx) == \\'0\\') {\\n                break;\\n            }\\n            \\n            long cur = Long.parseLong(num.substring(idx, i + 1));\\n            if (idx == 0) {\\n                dfs(res, i + 1, cur, sum, path + cur, num, target);   \\n            } else {\\n                dfs(res, i + 1, cur, sum + bufVal, path + \"+\" + cur, num, target);\\n                dfs(res, i + 1, -cur, sum + bufVal, path + \"-\" + cur, num, target);\\n                dfs(res, i + 1, bufVal * cur, sum, path + \"*\" + cur, num, target);\\n            }\\n        }\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public List<String> addOperators(String num, int target) {\\n        List<String> res = new ArrayList<>();\\n        dfs(res, 0, 0, 0, \"\", num, target);\\n        return res;\\n    }\\n    \\n    private void dfs(List<String> res, int idx, long bufVal, long sum,\\n                     String path, String num, int target) {\\n        if (idx == num.length()) {\\n            if (sum + bufVal == target) {\\n                res.add(path);\\n            }\\n            return;\\n        } \\n        \\n        for (int i = idx; i < num.length(); i++) {\\n            if (i != idx && num.charAt(idx) == \\'0\\') {\\n                break;\\n            }\\n            \\n            long cur = Long.parseLong(num.substring(idx, i + 1));\\n            if (idx == 0) {\\n                dfs(res, i + 1, cur, sum, path + cur, num, target);   \\n            } else {\\n                dfs(res, i + 1, cur, sum + bufVal, path + \"+\" + cur, num, target);\\n                dfs(res, i + 1, -cur, sum + bufVal, path + \"-\" + cur, num, target);\\n                dfs(res, i + 1, bufVal * cur, sum, path + \"*\" + cur, num, target);\\n            }\\n        }\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 225907,
                "title": "python-backtracking-dfs",
                "content": "```\\nclass Solution:\\n    def addOperators(self, num, target):\\n        \"\"\"\\n        :type num: str\\n        :type target: int\\n        :rtype: List[str]\\n        \"\"\"\\n        self.N = len(num)\\n        self.target = target\\n        self.num = num\\n        self.ans = []\\n        self.dfs(0, 0, 0, \\'\\')\\n        return self.ans\\n        \\n    def dfs(self, idx, total_val, prev_num, path):\\n        if idx == self.N:\\n            if total_val == self.target:\\n                self.ans.append(path)\\n            return\\n        \\n        cur_num = 0\\n        for i in range(idx, self.N):\\n            cur_num = cur_num * 10 + int(self.num[i])\\n            if idx == 0:\\n                self.dfs(i+1, cur_num, cur_num, path + str(cur_num))\\n            else:\\n                val = total_val - prev_num\\n                self.dfs(i+1, val + prev_num * cur_num, prev_num * cur_num, path + \\'*\\' + str(cur_num))\\n                self.dfs(i+1, val + prev_num + cur_num, cur_num, path + \\'+\\' + str(cur_num))\\n                self.dfs(i+1, val + prev_num - cur_num, -cur_num, path + \\'-\\' + str(cur_num))\\n            \\n            if self.num[idx] == \\'0\\':\\n                break\\n       \\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def addOperators(self, num, target):\\n        \"\"\"\\n        :type num: str\\n        :type target: int\\n        :rtype: List[str]\\n        \"\"\"\\n        self.N = len(num)\\n        self.target = target\\n        self.num = num\\n        self.ans = []\\n        self.dfs(0, 0, 0, \\'\\')\\n        return self.ans\\n        \\n    def dfs(self, idx, total_val, prev_num, path):\\n        if idx == self.N:\\n            if total_val == self.target:\\n                self.ans.append(path)\\n            return\\n        \\n        cur_num = 0\\n        for i in range(idx, self.N):\\n            cur_num = cur_num * 10 + int(self.num[i])\\n            if idx == 0:\\n                self.dfs(i+1, cur_num, cur_num, path + str(cur_num))\\n            else:\\n                val = total_val - prev_num\\n                self.dfs(i+1, val + prev_num * cur_num, prev_num * cur_num, path + \\'*\\' + str(cur_num))\\n                self.dfs(i+1, val + prev_num + cur_num, cur_num, path + \\'+\\' + str(cur_num))\\n                self.dfs(i+1, val + prev_num - cur_num, -cur_num, path + \\'-\\' + str(cur_num))\\n            \\n            if self.num[idx] == \\'0\\':\\n                break\\n       \\n```",
                "codeTag": "Java"
            },
            {
                "id": 161121,
                "title": "slow-but-easy-understand-python-code",
                "content": "```\\nclass Solution(object):\\n    def addOperators(self, num, target):\\n        \"\"\"\\n        :type num: str\\n        :type target: int\\n        :rtype: List[str]\\n        \"\"\"\\n        results = []\\n        self.helper(num, 0, target, 0, 0, \"\", results)\\n        return results\\n    \\n    def helper(self, string, start, target, sum_so_far, last, path, results):\\n        if start == len(string) and sum_so_far == target:\\n            results.append(path)\\n        \\n        for end in range(start+1, len(string)+1):\\n            sub_string = string[start:end]\\n            if len(sub_string) > 1 and sub_string[0] == \\'0\\':\\n                break\\n            cur = int(sub_string)\\n            if start == 0:\\n                self.helper(string, end, target, sum_so_far + cur, cur, path + sub_string, results)\\n            else:\\n                self.helper(string, end, target, sum_so_far + cur, cur, path + \"+\" + sub_string, results)\\n                self.helper(string, end, target, sum_so_far - cur, -cur, path + \"-\" + sub_string, results)\\n                self.helper(string, end, target, sum_so_far - last + cur * last, cur * last, path + \"*\" + sub_string, results)\\n                \\n   ```",
                "solutionTags": [],
                "code": "```\\nclass Solution(object):\\n    def addOperators(self, num, target):\\n        \"\"\"\\n        :type num: str\\n        :type target: int\\n        :rtype: List[str]\\n        \"\"\"\\n        results = []\\n        self.helper(num, 0, target, 0, 0, \"\", results)\\n        return results\\n    \\n    def helper(self, string, start, target, sum_so_far, last, path, results):\\n        if start == len(string) and sum_so_far == target:\\n            results.append(path)\\n        \\n        for end in range(start+1, len(string)+1):\\n            sub_string = string[start:end]\\n            if len(sub_string) > 1 and sub_string[0] == \\'0\\':\\n                break\\n            cur = int(sub_string)\\n            if start == 0:\\n                self.helper(string, end, target, sum_so_far + cur, cur, path + sub_string, results)\\n            else:\\n                self.helper(string, end, target, sum_so_far + cur, cur, path + \"+\" + sub_string, results)\\n                self.helper(string, end, target, sum_so_far - cur, -cur, path + \"-\" + sub_string, results)\\n                self.helper(string, end, target, sum_so_far - last + cur * last, cur * last, path + \"*\" + sub_string, results)\\n                \\n   ```",
                "codeTag": "Java"
            },
            {
                "id": 159507,
                "title": "easy-to-understand-kotlin-solution",
                "content": "The only language you use should be Kotlin\\n\\n```\\n    fun addOperators(num: String, target: Int): List<String> {\\n        val goodList : MutableList<String> = mutableListOf()\\n        fun eval(s : String, output : String, acc : Long, lastTerm : Long, start : Boolean) {\\n            if(s.isEmpty()) {\\n                if(acc + lastTerm == target.toLong()) {\\n                    goodList.add(output)\\n                }\\n                return\\n            }\\n            for (i in (1..s.length)) {\\n                val firstString = s.substring(0, i)\\n                if(firstString.length > 1 && firstString[0] == \\'0\\') {\\n                    return\\n                }\\n                val first = firstString.toLong()\\n                val rest = s.drop(i)\\n                //Case one, add the first int\\n                eval(rest, \"$output+$firstString\", acc + lastTerm, first, false)\\n                if(!start) {\\n                    eval(rest, \"$output-$firstString\", acc + lastTerm, -first, false)\\n                    eval(rest, \"$output*$firstString\", acc, lastTerm * first, false)\\n                }\\n            }\\n        }\\n        eval(num, \"\", 0, 0, true)\\n        return goodList.map {it.drop(1)}.toList()\\n    }\\n\\t\\t```",
                "solutionTags": [],
                "code": "```\\n    fun addOperators(num: String, target: Int): List<String> {\\n        val goodList : MutableList<String> = mutableListOf()\\n        fun eval(s : String, output : String, acc : Long, lastTerm : Long, start : Boolean) {\\n            if(s.isEmpty()) {\\n                if(acc + lastTerm == target.toLong()) {\\n                    goodList.add(output)\\n                }\\n                return\\n            }\\n            for (i in (1..s.length)) {\\n                val firstString = s.substring(0, i)\\n                if(firstString.length > 1 && firstString[0] == \\'0\\') {\\n                    return\\n                }\\n                val first = firstString.toLong()\\n                val rest = s.drop(i)\\n                //Case one, add the first int\\n                eval(rest, \"$output+$firstString\", acc + lastTerm, first, false)\\n                if(!start) {\\n                    eval(rest, \"$output-$firstString\", acc + lastTerm, -first, false)\\n                    eval(rest, \"$output*$firstString\", acc, lastTerm * first, false)\\n                }\\n            }\\n        }\\n        eval(num, \"\", 0, 0, true)\\n        return goodList.map {it.drop(1)}.toList()\\n    }\\n\\t\\t```",
                "codeTag": "Unknown"
            },
            {
                "id": 121113,
                "title": "why-simple-dfs-is-so-slow-python",
                "content": "Consider two solutions:\\n```\\n# solution 1\\ndef addOperators(self, num, target):\\n    \\n    def dfs(tail, path, tot, prev):\\n        if not tail and tot == target:\\n            paths.append(path)\\n        else:\\n            for i in range(1, len(tail) + 1):\\n                if i == 1 or tail[0] != \\'0\\':\\n                    val = int(tail[:i])\\n                    dfs(tail[i:], path + \\'+\\' + tail[:i], tot + val, val)\\n                    dfs(tail[i:], path + \\'-\\' + tail[:i], tot - val, -val)\\n                    dfs(tail[i:], path + \\'*\\' + tail[:i], tot - prev + prev * val, prev * val)\\n\\n    paths = []\\n    for i in range(1, len(num) + 1):\\n        if i == 1 or num[0] != \\'0\\':\\n            head = int(num[:i])\\n            dfs(num[i:], num[:i], head, head)\\n\\n    return paths\\n```\\nand\\n```\\n# solution 2\\ndef addOperators(self, num, target):\\n    if not num: \\n        return []\\n    \\n    def dfs(path, s):\\n        if not s :\\n            if eval(path) == target:\\n                paths.append(path)\\n        else:\\n            ops = [\\'+\\', \\'-\\', \\'*\\'] if s[0] == \\'0\\' else [\\'+\\', \\'-\\', \\'*\\', \\'\\']\\n            for op in ops:\\n                dfs(path + op + s[0], s[1:])\\n\\n    paths = []\\n    dfs(num[0], num[1:])\\n\\n    return paths\\n```\\n\\nI think the time complexity are both O(N^4):\\nFor solution1: T(N) = 3*(T(N-1) + T(N-2) + ...), T(N-1) = 3*(T(N-2)+ ...) => T(N) = 4T(N-1) => O(N^4)\\nFor solution2: T(N) = 4T(N-1) => O(N^4)\\nBoth solution requires string slicing, in fact, more slicing operations in solution1. I don\\'t see any significant differences on time complexity in the both solution.\\n\\nBut in reality: the run time for the following test cases are:\\n(\"3456237\", 10000): 38ms vs 80ms\\n(\"34562374\", 10000): 54ms vs 229ms\\n(\"345623749\", 10000): 127ms vs 986ms\\nwhich clearly shows solution1 and solution2 is vastly different. \\nWhat are the operation overhead in solution2 make it so slow?",
                "solutionTags": [],
                "code": "```\\n# solution 1\\ndef addOperators(self, num, target):\\n    \\n    def dfs(tail, path, tot, prev):\\n        if not tail and tot == target:\\n            paths.append(path)\\n        else:\\n            for i in range(1, len(tail) + 1):\\n                if i == 1 or tail[0] != \\'0\\':\\n                    val = int(tail[:i])\\n                    dfs(tail[i:], path + \\'+\\' + tail[:i], tot + val, val)\\n                    dfs(tail[i:], path + \\'-\\' + tail[:i], tot - val, -val)\\n                    dfs(tail[i:], path + \\'*\\' + tail[:i], tot - prev + prev * val, prev * val)\\n\\n    paths = []\\n    for i in range(1, len(num) + 1):\\n        if i == 1 or num[0] != \\'0\\':\\n            head = int(num[:i])\\n            dfs(num[i:], num[:i], head, head)\\n\\n    return paths\\n```\n```\\n# solution 2\\ndef addOperators(self, num, target):\\n    if not num: \\n        return []\\n    \\n    def dfs(path, s):\\n        if not s :\\n            if eval(path) == target:\\n                paths.append(path)\\n        else:\\n            ops = [\\'+\\', \\'-\\', \\'*\\'] if s[0] == \\'0\\' else [\\'+\\', \\'-\\', \\'*\\', \\'\\']\\n            for op in ops:\\n                dfs(path + op + s[0], s[1:])\\n\\n    paths = []\\n    dfs(num[0], num[1:])\\n\\n    return paths\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 71900,
                "title": "18-line-clean-python-solution-dfs-with-comment",
                "content": "```\\nclass Solution(object):\\n    def addOperators(self, num, target):\\n        def dfs(remain, curr_str, curr, prev):\\n            if not remain and curr == target:\\n                res.append(curr_str)\\n                \\n            for i in range(1, len(remain) + 1):\\n                if len(curr_str) == 0:   #avoid generate str begin with +-*\\n                    if not (i > 1 and remain[0] == '0'):   # avoid '0X' case be counted\\n                        dfs(remain[i:], remain[:i], int(remain[:i]), int(remain[:i]))\\n                else:\\n                    if not (i > 1 and remain[0] == '0'):\\n                        dfs(remain[i:], curr_str + '+' + remain[:i], curr + int(remain[:i]), int(remain[:i]))\\n                        dfs(remain[i:], curr_str + '-' + remain[:i], curr - int(remain[:i]), -int(remain[:i]))\\n                        # need take extra care for '*' case, a+b*c = a+b-b+b*c\\n                        dfs(remain[i:], curr_str + '*' + remain[:i], curr - prev + prev * int(remain[:i]), prev * int(remain[:i]))\\n            \\n        res = []\\n        dfs(num, '', 0, 0)\\n        return res\\n\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution(object):\\n    def addOperators(self, num, target):\\n        def dfs(remain, curr_str, curr, prev):\\n            if not remain and curr == target:\\n                res.append(curr_str)\\n                \\n            for i in range(1, len(remain) + 1):\\n                if len(curr_str) == 0:   #avoid generate str begin with +-*\\n                    if not (i > 1 and remain[0] == '0'):   # avoid '0X' case be counted\\n                        dfs(remain[i:], remain[:i], int(remain[:i]), int(remain[:i]))\\n                else:\\n                    if not (i > 1 and remain[0] == '0'):\\n                        dfs(remain[i:], curr_str + '+' + remain[:i], curr + int(remain[:i]), int(remain[:i]))\\n                        dfs(remain[i:], curr_str + '-' + remain[:i], curr - int(remain[:i]), -int(remain[:i]))\\n                        # need take extra care for '*' case, a+b*c = a+b-b+b*c\\n                        dfs(remain[i:], curr_str + '*' + remain[:i], curr - prev + prev * int(remain[:i]), prev * int(remain[:i]))\\n            \\n        res = []\\n        dfs(num, '', 0, 0)\\n        return res\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 71926,
                "title": "my-brilliant-solution-different-and-easy-to-understand-with-explanation",
                "content": "Suppose that our input string is \"1234\". The length is 4.\\nthere are 3 spots between these 4 digits: 1_2_3_4.\\n\\non each spot, we can either put one of the operator s ( -, +, * ) or put nothing. For example, if I put ' * ' in the first spot, + in the second spot and nothing in the third spot, I will have: 1*2+34.\\nSo each spot can have 4 options. So overall, there can be 4^3 choices.\\n\\nDon't you think there is a reason behind not having ' / ' as an option? There is a reason: we can show any of our choices as a binary from 0 to 3:\\n\\n00: put nothing between two numbers\\n01: put '+' between two numbers\\n10: put '*' between two numbers\\n11: put '-' between two numbers\\n\\nNow I can iterate between 0 to 4^3 and decide for each spot which number I should choose. For example, for the expression discussed above (1*2+34) the generated code to choose operators looks like this:\\n100100\\n\\n(I actually start from 1, because 0 is: 000000 which will give me: 1234 which doesn't have any operator)\\n\\nThen I can read through the code and decide which operator to put and form a string called expression. Then I will send the expression to a calculator which is simply a 'Expression calculator' and check if the result of the current expression equals to target. If yes, I will add it to the result list.\\n\\nSo let's make it for n. If the length of the input string is n, we have n-1 spots, so 4^n-1 choices.\\nWe iterate between 1 to 4^n-1 and parse the number to binary and if it has leading zeros, make sure to include the zeros in our operators string. Then check the operators string 2 by to and add the operator (or don't add anything) by comparing the number to its corresponding operator.\\n\\n```\\nstatic List<string> AddOperators(string num, int target, List<string> total_strings)\\n        {\\n            int n = num.Length;\\n            for (int i = 1; i < Math.Pow(4, n - 1); i++)\\n            {\\n\\t\\t//parsing to binary, then add leading zeros until we have enough length. for example, if n=4, we have 3 spots to fill\\n\\t\\t//if the current number code is 000011, we make sure to include 4 leading zeros to our string.\\n                string operators = Convert.ToString(i, 2).PadLeft((n - 1) * 2, '0'); \\n                string expression = num[0].ToString();\\n                for (int j = 1; j <= n-1 ; j ++)\\n                {\\n                    string Operator = operators.Substring((j-1)*2, 2);\\n                    //if (Operator == \"00\") SKIP; //not necessary\\n                    if (Operator == \"01\") expression += '+';\\n                    if (Operator == \"10\") expression += '*';\\n                    if (Operator == \"11\") expression += '-';\\n                    expression += num[j];\\n                }\\n                if (Calculator(expression) == target)\\n                    total_strings.Add(expression);\\n\\n            }\\n            return total_strings;\\n        }\\n        static int Calculator(string exp)\\n        {\\n            Stack<int> st = new Stack<int>();\\n            int current_num = 0;\\n            char sign = '+';\\n            int result = 0;\\n\\n            for(int i=0; i<exp.Length; i++)\\n            {\\n                if (char.IsDigit(exp[i]))\\n                    current_num = current_num * 10 +int.Parse(exp[i].ToString());\\n                if(!char.IsDigit(exp[i]) || i==exp.Length-1)\\n                {\\n                    if (sign == '+')\\n                        st.Push(current_num);\\n                    if (sign == '-')\\n                        st.Push(-1 * current_num);\\n                    if(sign=='*')\\n                    {\\n                        int temp = st.Pop();\\n                        st.Push(temp * current_num);\\n                    }\\n                    sign = exp[i];\\n                    current_num = 0;\\n                }\\n            }\\n            while(st.Any())\\n            {\\n                result += st.Pop();\\n            }\\n            return result;\\n        }\\n```",
                "solutionTags": [],
                "code": "```\\nstatic List<string> AddOperators(string num, int target, List<string> total_strings)\\n        {\\n            int n = num.Length;\\n            for (int i = 1; i < Math.Pow(4, n - 1); i++)\\n            {\\n\\t\\t//parsing to binary, then add leading zeros until we have enough length. for example, if n=4, we have 3 spots to fill\\n\\t\\t//if the current number code is 000011, we make sure to include 4 leading zeros to our string.\\n                string operators = Convert.ToString(i, 2).PadLeft((n - 1) * 2, '0'); \\n                string expression = num[0].ToString();\\n                for (int j = 1; j <= n-1 ; j ++)\\n                {\\n                    string Operator = operators.Substring((j-1)*2, 2);\\n                    //if (Operator == \"00\") SKIP; //not necessary\\n                    if (Operator == \"01\") expression += '+';\\n                    if (Operator == \"10\") expression += '*';\\n                    if (Operator == \"11\") expression += '-';\\n                    expression += num[j];\\n                }\\n                if (Calculator(expression) == target)\\n                    total_strings.Add(expression);\\n\\n            }\\n            return total_strings;\\n        }\\n        static int Calculator(string exp)\\n        {\\n            Stack<int> st = new Stack<int>();\\n            int current_num = 0;\\n            char sign = '+';\\n            int result = 0;\\n\\n            for(int i=0; i<exp.Length; i++)\\n            {\\n                if (char.IsDigit(exp[i]))\\n                    current_num = current_num * 10 +int.Parse(exp[i].ToString());\\n                if(!char.IsDigit(exp[i]) || i==exp.Length-1)\\n                {\\n                    if (sign == '+')\\n                        st.Push(current_num);\\n                    if (sign == '-')\\n                        st.Push(-1 * current_num);\\n                    if(sign=='*')\\n                    {\\n                        int temp = st.Pop();\\n                        st.Push(temp * current_num);\\n                    }\\n                    sign = exp[i];\\n                    current_num = 0;\\n                }\\n            }\\n            while(st.Any())\\n            {\\n                result += st.Pop();\\n            }\\n            return result;\\n        }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 71937,
                "title": "simple-and-straight-forward-ruby-solution",
                "content": "uncomment the line for 'puts' to see the output per recursion.\\n````\\ndef add_operators(num, target)\\n    @sets = []\\n    @num = num\\n    @target = target\\n    add_forward(\"\", nil, nil, 0)\\n    @sets\\nend\\n\\ndef add_forward(expression_str, expression_val, mult, counter)\\n    #puts \"counter: #{counter}, expression_str: #{expression_str}, #{eval(expression_str)}\"\\n    if counter == @num.length && expression_val == @target\\n        @sets << expression_str\\n        return\\n    end\\n    size = @num[counter] == \"0\" ? counter + 1 : @num.length\\n    for i in (counter+1)..size\\n        current_num = @num[counter...i].to_i\\n        if expression_str == \"\"\\n            add_forward(current_num.to_s, current_num, current_num, i)\\n            next\\n        end\\n\\n        add_forward(expression_str+\"+\"+current_num.to_s, expression_val+current_num, current_num, i)\\n        add_forward(expression_str+\"-\"+current_num.to_s, expression_val-current_num, -current_num, i)\\n        add_forward(expression_str+\"*\"+current_num.to_s, (expression_val-mult)+(mult*current_num), (mult*current_num), i)\\n    end\\nend\\n````",
                "solutionTags": [],
                "code": "````\\ndef add_operators(num, target)\\n    @sets = []\\n    @num = num\\n    @target = target\\n    add_forward(\"\", nil, nil, 0)\\n    @sets\\nend\\n\\ndef add_forward(expression_str, expression_val, mult, counter)\\n    #puts \"counter: #{counter}, expression_str: #{expression_str}, #{eval(expression_str)}\"\\n    if counter == @num.length && expression_val == @target\\n        @sets << expression_str\\n        return\\n    end\\n    size = @num[counter] == \"0\" ? counter + 1 : @num.length\\n    for i in (counter+1)..size\\n        current_num = @num[counter...i].to_i\\n        if expression_str == \"\"\\n            add_forward(current_num.to_s, current_num, current_num, i)\\n            next\\n        end\\n\\n        add_forward(expression_str+\"+\"+current_num.to_s, expression_val+current_num, current_num, i)\\n        add_forward(expression_str+\"-\"+current_num.to_s, expression_val-current_num, -current_num, i)\\n        add_forward(expression_str+\"*\"+current_num.to_s, (expression_val-mult)+(mult*current_num), (mult*current_num), i)\\n    end\\nend\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 71938,
                "title": "python-dfs-beats-98",
                "content": "I didn't look at other solutions so not sure if others are better, but here's what I came up with. Basically it does a DFS on the search space of all the possible combinations of arithmetic expressions, building the expression string as it goes along. To handle the higher operator precedence of multiplication I keep a running total of the previous left and right operands, so that the current result isn't calculated prematurely.  Below is my code.  Comments and suggestions appreciated\\n\\n```\\nclass Solution(object):\\n    def search(self,left,right, si,num,target,expr,res):\\n        if si >= len(num):\\n            if left+right == target:\\n                res.append(expr)\\n            return\\n        curr = 0\\n        for i in xrange(si,len(num)):\\n            curr = curr*10 + ord(num[i])-ord('0')\\n            currNum = num[si:i+1]\\n            if currNum[0]=='0' and len(currNum) > 1:\\n                continue # skip numbers with leading zeroes\\n            if si==0:\\n                self.search(0,curr,i+1,num,target,currNum,res)\\n            else:\\n                self.search(left+right,curr,i+1,num,target,expr+'+'+currNum,res) # plus\\n                self.search(left+right,-curr,i+1,num,target,expr+'-'+currNum,res) # minus\\n                self.search(left,right*curr,i+1,num,target,expr+'*'+currNum,res) # multiply\\n            \\n    def addOperators(self, num, target):\\n        res = []\\n        self.search(0,0,0,num,target,\"\",res)\\n        return res\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution(object):\\n    def search(self,left,right, si,num,target,expr,res):\\n        if si >= len(num):\\n            if left+right == target:\\n                res.append(expr)\\n            return\\n        curr = 0\\n        for i in xrange(si,len(num)):\\n            curr = curr*10 + ord(num[i])-ord('0')\\n            currNum = num[si:i+1]\\n            if currNum[0]=='0' and len(currNum) > 1:\\n                continue # skip numbers with leading zeroes\\n            if si==0:\\n                self.search(0,curr,i+1,num,target,currNum,res)\\n            else:\\n                self.search(left+right,curr,i+1,num,target,expr+'+'+currNum,res) # plus\\n                self.search(left+right,-curr,i+1,num,target,expr+'-'+currNum,res) # minus\\n                self.search(left,right*curr,i+1,num,target,expr+'*'+currNum,res) # multiply\\n            \\n    def addOperators(self, num, target):\\n        res = []\\n        self.search(0,0,0,num,target,\"\",res)\\n        return res\\n```",
                "codeTag": "Java"
            },
            {
                "id": 71948,
                "title": "short-java-solution-without-loop",
                "content": "Maintain three numbers: **sum, mulL, mulR**. Attempt to reach the point that **sum + mulL * mulR == target**\\nStringBuilder is not used, because String is shorter and the solution is fast enough to fit the time limit.\\n\\n```\\npublic class Solution {\\n    public List<String> addOperators(String num, int target) {\\n        List<String> ans = new ArrayList<>();\\n        search(ans, num, target, \"\", 0, 0, 1, 0);\\n        return ans;\\n    }\\n    private void search(List<String> ans, String num, int target, String literal, int idx, long sum, long mulL, long mulR) {\\n        if (idx < num.length()) {\\n            int digit = num.charAt(idx) - '0';\\n            if (idx > 0) {\\n                search(ans, num, target, literal + \"+\" + digit, idx + 1, sum + mulL * mulR, 1, digit);\\n                search(ans, num, target, literal + \"-\" + digit, idx + 1, sum + mulL * mulR, 1, -digit);\\n                search(ans, num, target, literal + \"*\" + digit, idx + 1, sum, mulL * mulR, digit);\\n            }\\n            if (idx == 0 || mulR != 0) {\\n                search(ans, num, target, literal + digit, idx + 1, sum, mulL, mulR * 10 + (mulR >= 0 ? digit : -digit));\\n            }\\n        } else if (sum + mulL * mulR == target) {\\n            ans.add(literal);\\n        }\\n    }\\n}\\n\\n```",
                "solutionTags": [],
                "code": "```\\npublic class Solution {\\n    public List<String> addOperators(String num, int target) {\\n        List<String> ans = new ArrayList<>();\\n        search(ans, num, target, \"\", 0, 0, 1, 0);\\n        return ans;\\n    }\\n    private void search(List<String> ans, String num, int target, String literal, int idx, long sum, long mulL, long mulR) {\\n        if (idx < num.length()) {\\n            int digit = num.charAt(idx) - '0';\\n            if (idx > 0) {\\n                search(ans, num, target, literal + \"+\" + digit, idx + 1, sum + mulL * mulR, 1, digit);\\n                search(ans, num, target, literal + \"-\" + digit, idx + 1, sum + mulL * mulR, 1, -digit);\\n                search(ans, num, target, literal + \"*\" + digit, idx + 1, sum, mulL * mulR, digit);\\n            }\\n            if (idx == 0 || mulR != 0) {\\n                search(ans, num, target, literal + digit, idx + 1, sum, mulL, mulR * 10 + (mulR >= 0 ? digit : -digit));\\n            }\\n        } else if (sum + mulL * mulR == target) {\\n            ans.add(literal);\\n        }\\n    }\\n}\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 71952,
                "title": "clear-c-solution-with-some-explanations",
                "content": "    vector<string> addOperators(string num, int target) {\\n    \\tvector<string> res;\\n    \\thelp(res, num, target, 0, \"\", 0);\\n    \\treturn res;\\n    }\\n    //use long long to avoid overflow\\n    void help(vector<string> &res, string num, long long target, int pos, string pre, long long last) {   \\n    \\tif (pos == num.size() && target == 0) {\\n    \\t\\tres.push_back(pre);\\n    \\t\\treturn;\\n    \\t}\\n    \\tfor (int i = pos; i < num.size(); i++) {\\n    \\t\\tif (num[pos] == '0' && i > pos)                  //strings like \"05\" are not correct expression \\n    \\t\\t\\tbreak;\\n    \\t\\tstring temp = num.substr(pos, i - pos + 1);\\n    \\t\\tlong long cur = stoll(temp);                  \\n    \\t\\tif (pos == 0)\\n    \\t\\t\\thelp(res, num, target - cur, i + 1, temp, cur);\\n    \\t\\telse {\\n    \\t\\t\\thelp(res, num, target - cur, i + 1, pre + \"+\" + temp, cur);\\n    \\t\\t\\thelp(res, num, target + cur, i + 1, pre + \"-\" + temp, -cur);\\n    \\t\\t\\thelp(res, num, target + last - last*cur, i + 1, pre + \"*\" + temp, last*cur);\\n                //'*'is not same to '+-', we should plus \"last\" that we shouldn't have + or -.(* with high priority)\\n    \\t\\t}\\n    \\t}\\n    }\\n\\n\\nThis is not a difficult problem but it really confuses me a lot.",
                "solutionTags": [],
                "code": "    vector<string> addOperators(string num, int target) {\\n    \\tvector<string> res;\\n    \\thelp(res, num, target, 0, \"\", 0);\\n    \\treturn res;\\n    }\\n    //use long long to avoid overflow\\n    void help(vector<string> &res, string num, long long target, int pos, string pre, long long last) {   \\n    \\tif (pos == num.size() && target == 0) {\\n    \\t\\tres.push_back(pre);\\n    \\t\\treturn;\\n    \\t}\\n    \\tfor (int i = pos; i < num.size(); i++) {\\n    \\t\\tif (num[pos] == '0' && i > pos)                  //strings like \"05\" are not correct expression \\n    \\t\\t\\tbreak;\\n    \\t\\tstring temp = num.substr(pos, i - pos + 1);\\n    \\t\\tlong long cur = stoll(temp);                  \\n    \\t\\tif (pos == 0)\\n    \\t\\t\\thelp(res, num, target - cur, i + 1, temp, cur);\\n    \\t\\telse {\\n    \\t\\t\\thelp(res, num, target - cur, i + 1, pre + \"+\" + temp, cur);\\n    \\t\\t\\thelp(res, num, target + cur, i + 1, pre + \"-\" + temp, -cur);\\n    \\t\\t\\thelp(res, num, target + last - last*cur, i + 1, pre + \"*\" + temp, last*cur);\\n                //'*'is not same to '+-', we should plus \"last\" that we shouldn't have + or -.(* with high priority)\\n    \\t\\t}\\n    \\t}\\n    }\\n\\n\\nThis is not a difficult problem but it really confuses me a lot.",
                "codeTag": "Unknown"
            },
            {
                "id": 71961,
                "title": "far-beating-all-submissions-in-c-accepted-with-16ms-well-explained",
                "content": "Always recursive method will a nice choice to handle this kind of DFS problem but meantime we should record some variables to move to the next round (in each round we will store the operator and then the selected number):\\n\\n- the current result -> sum;\\n- the previous number or partial result -> we need to handle <font color=\"#ff0000\">multiplication</font> unlike addition or subtraction it should be handled separately -> this is the <font color=\"#ff0000\">only reason</font> why we need this variable -> pre;\\n\\nOthers will be easily understood, I think with the help of the detailed comments in code.\\n\\nB.T.W. the complexity analysis is not quite easy here, but in a rough way:\\n\\n- space cost O(n^2)\\n- time cost O(2^n)\\n\\nIf some one gets some clear idea of this, please share with me. Thanks in advance!\\n\\n----------\\n\\n\\n       void helper(char* num, int len, int start, int target, long long sum, long long pre, char* stack, int top, char*** arr, int* returnSize)\\n    {\\n        if(start == len) //end of the string;\\n        {\\n            if(target == sum) //check whether it's valid;\\n            {\\n                stack[++top] = '\\\\0'; //terminate the string;\\n                *returnSize += 1; \\n                *arr = (char**)realloc(*arr, sizeof(char*)*(*returnSize));\\n                (*arr)[*returnSize-1] = (char*)malloc(sizeof(char)*(top+1));\\n                for(int i = 0; i <= top; i++)\\n                    (*arr)[*returnSize-1][i] = stack[i];\\n            }\\n            return ; \\n        }\\n        long long val = 0; //in case of INT_MAX or INT_MIN;\\n        int index = top+1; //record the index for the operator;\\n        for(int i = start; i < len; i++)\\n        {\\n            val = 10*val + num[i] - '0'; //collect the number;\\n            if(start == 0) //if it's the first number, no operator should be added;\\n            {\\n                stack[top+1] = num[i];\\n                helper(num, len, i+1, target, val, val, stack, top+1, arr, returnSize);\\n            }\\n            else\\n            {\\n                stack[top+2] = num[i];\\n                stack[index] = '-'; //get the sum directly by sum-val and record -1*val as pre in case the next operator is '*';\\n                helper(num, len, i+1, target, sum-val, -1*val, stack, top+2, arr, returnSize);\\n                stack[index] = '+'; //store val as pre in case the next operator is '*';\\n                helper(num, len, i+1, target, sum+val, val, stack, top+2, arr, returnSize);\\n                stack[index] = '*'; //we have to delete the pre first and then add the product of pre and var and then store pre*val in case the next operator is '*';\\n                helper(num, len, i+1, target, sum-pre+pre*val, pre*val, stack, top+2, arr, returnSize);\\n            }\\n            if(num[start] == '0') break; //no number starts with 0;\\n            top++;\\n        }\\n    }\\n    char** addOperators(char* num, int target, int* returnSize)\\n    {\\n        char** arr = (char**)malloc(sizeof(char*));\\n        *returnSize = 0;\\n        int len = strlen(num);\\n        if(len == 0) return arr;\\n        char* stack = (char*)malloc(sizeof(char)*2*len);\\n        int top = -1;\\n        helper(num, len, 0, target, 0, 0, stack, top, &arr, returnSize);\\n        return arr;\\n    }",
                "solutionTags": [],
                "code": "Always recursive method will a nice choice to handle this kind of DFS problem but meantime we should record some variables to move to the next round (in each round we will store the operator and then the selected number):\\n\\n- the current result -> sum;\\n- the previous number or partial result -> we need to handle <font color=\"#ff0000\">multiplication</font> unlike addition or subtraction it should be handled separately -> this is the <font color=\"#ff0000\">only reason</font> why we need this variable -> pre;\\n\\nOthers will be easily understood, I think with the help of the detailed comments in code.\\n\\nB.T.W. the complexity analysis is not quite easy here, but in a rough way:\\n\\n- space cost O(n^2)\\n- time cost O(2^n)\\n\\nIf some one gets some clear idea of this, please share with me. Thanks in advance!\\n\\n----------\\n\\n\\n       void helper(char* num, int len, int start, int target, long long sum, long long pre, char* stack, int top, char*** arr, int* returnSize)\\n    {\\n        if(start == len) //end of the string;\\n        {\\n            if(target == sum) //check whether it's valid;\\n            {\\n                stack[++top] = '\\\\0'; //terminate the string;\\n                *returnSize += 1; \\n                *arr = (char**)realloc(*arr, sizeof(char*)*(*returnSize));\\n                (*arr)[*returnSize-1] = (char*)malloc(sizeof(char)*(top+1));\\n                for(int i = 0; i <= top; i++)\\n                    (*arr)[*returnSize-1][i] = stack[i];\\n            }\\n            return ; \\n        }\\n        long long val = 0; //in case of INT_MAX or INT_MIN;\\n        int index = top+1; //record the index for the operator;\\n        for(int i = start; i < len; i++)\\n        {\\n            val = 10*val + num[i] - '0'; //collect the number;\\n            if(start == 0) //if it's the first number, no operator should be added;\\n            {\\n                stack[top+1] = num[i];\\n                helper(num, len, i+1, target, val, val, stack, top+1, arr, returnSize);\\n            }\\n            else\\n            {\\n                stack[top+2] = num[i];\\n                stack[index] = '-'; //get the sum directly by sum-val and record -1*val as pre in case the next operator is '*';\\n                helper(num, len, i+1, target, sum-val, -1*val, stack, top+2, arr, returnSize);\\n                stack[index] = '+'; //store val as pre in case the next operator is '*';\\n                helper(num, len, i+1, target, sum+val, val, stack, top+2, arr, returnSize);\\n                stack[index] = '*'; //we have to delete the pre first and then add the product of pre and var and then store pre*val in case the next operator is '*';\\n                helper(num, len, i+1, target, sum-pre+pre*val, pre*val, stack, top+2, arr, returnSize);\\n            }\\n            if(num[start] == '0') break; //no number starts with 0;\\n            top++;\\n        }\\n    }\\n    char** addOperators(char* num, int target, int* returnSize)\\n    {\\n        char** arr = (char**)malloc(sizeof(char*));\\n        *returnSize = 0;\\n        int len = strlen(num);\\n        if(len == 0) return arr;\\n        char* stack = (char*)malloc(sizeof(char)*2*len);\\n        int top = -1;\\n        helper(num, len, 0, target, 0, 0, stack, top, &arr, returnSize);\\n        return arr;\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 71964,
                "title": "there-seems-not-any-c-solution-post-share-mine",
                "content": "    void ao( char* num, int cur, double left, double sum, char* sol, char*** res, int* resEnd, int* resCap, int target ){\\n        if( cur == strlen(num) && left * sum == target ){\\n            if( *resEnd == *resCap ){\\n                *resCap *= 2;\\n                *res = realloc( *res, (*resCap) * sizeof( **res ) );\\n            }\\n            ( *res )[ *resEnd ] = sol;\\n            ( *resEnd )++;\\n            return;\\n        }\\n        \\n        if( cur == strlen(num) ){\\n            return;\\n        }\\n        \\n        int oldLen = strlen( sol );\\n        if( sum != 0 ){\\n            char* newSol = calloc( oldLen, sizeof( *newSol ) );\\n            strcpy( newSol, sol );\\n            newSol[ oldLen ] = num[cur];\\n            ao( num, cur+1, left, sum * 10 + ( num[ cur ] - '0' ), newSol, res, resEnd, resCap, target );\\n        }\\n        {\\n            char* newSol = calloc( oldLen, sizeof( *newSol ) );\\n            strcpy( newSol, sol );\\n            newSol[ oldLen ] = '*';\\n            newSol[ oldLen + 1 ] = num[cur];\\n            ao( num, cur+1, left * sum, num[ cur ] - '0', newSol, res, resEnd, resCap, target );\\n        }\\n        {\\n            char* newSol = calloc( oldLen, sizeof( *newSol ) );\\n            strcpy( newSol, sol );\\n            newSol[ oldLen ] = '+';\\n            newSol[ oldLen+1 ] = num[cur];\\n            ao( num, cur+1, 1, num[cur] - '0', newSol, res, resEnd, resCap, target - left * sum );\\n        }\\n        {\\n            char* newSol = calloc( oldLen, sizeof( *newSol ) );\\n            strcpy( newSol, sol );\\n            newSol[ oldLen ] = '-';\\n            newSol[ oldLen+1 ] = num[cur];\\n            ao( num, cur+1, -1, num[cur] - '0', newSol, res, resEnd, resCap, target - left * sum );\\n        }\\n        \\n        free( sol );\\n    } \\n    \\n    char** addOperators(char* num, int target, int* returnSize) {\\n        int resCap = 16;\\n        char** res = calloc( resCap, sizeof( *res ) );\\n        int resEnd = 0; // 0 .. resEnd-1 is the current result we have\\n    \\n        int n = strlen( num );\\n    \\n        if( n== 0 ){\\n            return res;\\n        }\\n        \\n        char* sol = calloc( 2 * n - 1, sizeof( *sol ) );\\n        memset( sol, '\\\\0', 2 * n - 1);\\n        sol[0] = num[0];\\n        \\n        ao( num, 1, 1, num[0] - '0', sol, &res, &resEnd, &resCap, target );\\n        \\n        *returnSize = resEnd;\\n        return res;\\n    }",
                "solutionTags": [],
                "code": "    void ao( char* num, int cur, double left, double sum, char* sol, char*** res, int* resEnd, int* resCap, int target ){\\n        if( cur == strlen(num) && left * sum == target ){\\n            if( *resEnd == *resCap ){\\n                *resCap *= 2;\\n                *res = realloc( *res, (*resCap) * sizeof( **res ) );\\n            }\\n            ( *res )[ *resEnd ] = sol;\\n            ( *resEnd )++;\\n            return;\\n        }\\n        \\n        if( cur == strlen(num) ){\\n            return;\\n        }\\n        \\n        int oldLen = strlen( sol );\\n        if( sum != 0 ){\\n            char* newSol = calloc( oldLen, sizeof( *newSol ) );\\n            strcpy( newSol, sol );\\n            newSol[ oldLen ] = num[cur];\\n            ao( num, cur+1, left, sum * 10 + ( num[ cur ] - '0' ), newSol, res, resEnd, resCap, target );\\n        }\\n        {\\n            char* newSol = calloc( oldLen, sizeof( *newSol ) );\\n            strcpy( newSol, sol );\\n            newSol[ oldLen ] = '*';\\n            newSol[ oldLen + 1 ] = num[cur];\\n            ao( num, cur+1, left * sum, num[ cur ] - '0', newSol, res, resEnd, resCap, target );\\n        }\\n        {\\n            char* newSol = calloc( oldLen, sizeof( *newSol ) );\\n            strcpy( newSol, sol );\\n            newSol[ oldLen ] = '+';\\n            newSol[ oldLen+1 ] = num[cur];\\n            ao( num, cur+1, 1, num[cur] - '0', newSol, res, resEnd, resCap, target - left * sum );\\n        }\\n        {\\n            char* newSol = calloc( oldLen, sizeof( *newSol ) );\\n            strcpy( newSol, sol );\\n            newSol[ oldLen ] = '-';\\n            newSol[ oldLen+1 ] = num[cur];\\n            ao( num, cur+1, -1, num[cur] - '0', newSol, res, resEnd, resCap, target - left * sum );\\n        }\\n        \\n        free( sol );\\n    } \\n    \\n    char** addOperators(char* num, int target, int* returnSize) {\\n        int resCap = 16;\\n        char** res = calloc( resCap, sizeof( *res ) );\\n        int resEnd = 0; // 0 .. resEnd-1 is the current result we have\\n    \\n        int n = strlen( num );\\n    \\n        if( n== 0 ){\\n            return res;\\n        }\\n        \\n        char* sol = calloc( 2 * n - 1, sizeof( *sol ) );\\n        memset( sol, '\\\\0', 2 * n - 1);\\n        sol[0] = num[0];\\n        \\n        ao( num, 1, 1, num[0] - '0', sol, &res, &resEnd, &resCap, target );\\n        \\n        *returnSize = resEnd;\\n        return res;\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 3817648,
                "title": "c-solution",
                "content": "\\n```\\nclass Solution {\\npublic:\\nvoid generate(string &num, int target, int curr, vector<string> &res, string build, long long int prevNumber, long long int currSum, int n){\\n        if(curr==num.size()){\\n            if(currSum==target){\\n                res.push_back(build);\\n            }\\n            return;\\n        }\\n        for(int len=1;len<=(n-curr);len++){\\n            string number=num.substr(curr,len);\\n            if(number[0]==\\'0\\' && number.size()>1){\\n                continue;\\n            }\\n            long long int currNum=stoll(number);\\n            generate(num,target,curr+len,res,build+\"+\"+number,currNum,currSum+currNum,n);\\n            generate(num,target,curr+len,res,build+\"-\"+number,-currNum,currSum-currNum,n);\\n            generate(num,target,curr+len,res,build+\"*\"+number,currNum*prevNumber,currSum-prevNumber+currNum*prevNumber,n);\\n        }\\n    }\\n    vector<string> addOperators(string num, int target) {\\n          vector<string> res;\\n        int n=num.size();\\n        for(int len=1;len<=n;len++){\\n            string number=num.substr(0,len);\\n            if(number[0]==\\'0\\' && number.size()>1){\\n                continue;\\n            }\\n            long long int currNum=stoll(number);\\n            generate(num,target,len,res,number,currNum,currNum,n);\\n        }\\n        return res;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Recursion"
                ],
                "code": "```\\nclass Solution {\\npublic:\\nvoid generate(string &num, int target, int curr, vector<string> &res, string build, long long int prevNumber, long long int currSum, int n){\\n        if(curr==num.size()){\\n            if(currSum==target){\\n                res.push_back(build);\\n            }\\n            return;\\n        }\\n        for(int len=1;len<=(n-curr);len++){\\n            string number=num.substr(curr,len);\\n            if(number[0]==\\'0\\' && number.size()>1){\\n                continue;\\n            }\\n            long long int currNum=stoll(number);\\n            generate(num,target,curr+len,res,build+\"+\"+number,currNum,currSum+currNum,n);\\n            generate(num,target,curr+len,res,build+\"-\"+number,-currNum,currSum-currNum,n);\\n            generate(num,target,curr+len,res,build+\"*\"+number,currNum*prevNumber,currSum-prevNumber+currNum*prevNumber,n);\\n        }\\n    }\\n    vector<string> addOperators(string num, int target) {\\n          vector<string> res;\\n        int n=num.size();\\n        for(int len=1;len<=n;len++){\\n            string number=num.substr(0,len);\\n            if(number[0]==\\'0\\' && number.size()>1){\\n                continue;\\n            }\\n            long long int currNum=stoll(number);\\n            generate(num,target,len,res,number,currNum,currNum,n);\\n        }\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3696293,
                "title": "c-expression-evaluation-with-memoization",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nApproach is to use a backtracking technique with memoization. We can recursively build the expressions by trying out different operators at each step and keeping track of the current sum. The memoization technique can help avoid redundant calculations and improve efficiency by storing intermediate results. This approach would require careful handling of operators and their precedence.\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nAddition: We make a recursive call with the updated currentSum by adding the current number and the updated currentExpr by appending the \\'+\\' operator and the current number.\\n\\nSubtraction: We make a recursive call with the updated currentSum by subtracting the current number and the updated currentExpr by appending the \\'-\\' operator and the current number.\\n\\nMultiplication: We make a recursive call with the updated currentSum by subtracting the previous number and adding the product of the previous number and the current number. We also update the currentExpr accordingly.\\n\\nWhen considering the multiplication operation, we need to take into account its precedence over addition and subtraction. In other words, multiplication should be evaluated before addition and subtraction in the expression.\\n\\nTo incorporate multiplication into our backtracking algorithm, we need to keep track of the previous number (operand) and update the current sum accordingly when encountering the multiplication operator.\\n\\n# Complexity\\n- Time complexity:\\nthe number of possible expressions can be approximated as 3^(n-1) since each digit (except the first one) can be preceded by three different operators. Therefore, the time complexity of the backtracking algorithm can be considered as O(3^(n-1)).\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nspace complexity due to the recursive stack is O(n)\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    unordered_map<string, bool> memo;\\n    vector<string> result;\\n    \\n    void backtrack(string num, int target, int index, long currentSum, long prevNum, string currentExpr) {\\n        if (index == num.length()) {\\n            if (currentSum == target) {\\n                result.push_back(currentExpr);\\n            }\\n            return;\\n        }\\n        \\n        for (int i = index; i < num.length(); i++) {\\n            string currentStr = num.substr(index, i - index + 1);\\n            \\n            if (currentStr.length() > 1 && currentStr[0] == \\'0\\') {\\n                // Avoid leading zeros\\n                break;\\n            }\\n            \\n            long currentNum = stol(currentStr);\\n            \\n            if (index == 0) {\\n                backtrack(num, target, i + 1, currentNum, currentNum, currentExpr + currentStr);\\n            } else {\\n                // \\'+\\'\\n                backtrack(num, target, i + 1, currentSum + currentNum, currentNum, currentExpr + \"+\" + currentStr);\\n                \\n                // \\'-\\'\\n                backtrack(num, target, i + 1, currentSum - currentNum, -currentNum, currentExpr + \"-\" + currentStr);\\n                \\n                // \\'*\\'\\n                backtrack(num, target, i + 1, currentSum - prevNum + prevNum * currentNum, prevNum * currentNum, currentExpr + \"*\" + currentStr);\\n            }\\n        }\\n    }\\n    \\n    vector<string> addOperators(string num, int target) {\\n        backtrack(num, target, 0, 0, 0, \"\");\\n        return result;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    unordered_map<string, bool> memo;\\n    vector<string> result;\\n    \\n    void backtrack(string num, int target, int index, long currentSum, long prevNum, string currentExpr) {\\n        if (index == num.length()) {\\n            if (currentSum == target) {\\n                result.push_back(currentExpr);\\n            }\\n            return;\\n        }\\n        \\n        for (int i = index; i < num.length(); i++) {\\n            string currentStr = num.substr(index, i - index + 1);\\n            \\n            if (currentStr.length() > 1 && currentStr[0] == \\'0\\') {\\n                // Avoid leading zeros\\n                break;\\n            }\\n            \\n            long currentNum = stol(currentStr);\\n            \\n            if (index == 0) {\\n                backtrack(num, target, i + 1, currentNum, currentNum, currentExpr + currentStr);\\n            } else {\\n                // \\'+\\'\\n                backtrack(num, target, i + 1, currentSum + currentNum, currentNum, currentExpr + \"+\" + currentStr);\\n                \\n                // \\'-\\'\\n                backtrack(num, target, i + 1, currentSum - currentNum, -currentNum, currentExpr + \"-\" + currentStr);\\n                \\n                // \\'*\\'\\n                backtrack(num, target, i + 1, currentSum - prevNum + prevNum * currentNum, prevNum * currentNum, currentExpr + \"*\" + currentStr);\\n            }\\n        }\\n    }\\n    \\n    vector<string> addOperators(string num, int target) {\\n        backtrack(num, target, 0, 0, 0, \"\");\\n        return result;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3636686,
                "title": "backtracking-solution-without-pruning-easy-to-understand-go-solution",
                "content": "# Intuition\\nBack track to form all the possible expressions. Don\\'t prune as it might elminate possible solutions. Use stack to evaluate the expression.\\n\\n# Approach\\n* multiplication operation has higher precedence than addion(+) or substraction(-)\\n\\n# Code\\n```\\nimport \"strconv\"\\nimport \"strings\"\\n// -1 = +\\n// -2 = -\\n// -3 = *\\n\\nfunc addOperators(num string, target int) []string {\\n\\tfinalResults := []string{}\\n\\tnumber, _ := strconv.Atoi(num)\\n\\texpr := make([]int, len(num))\\n\\tl := len(num) - 1\\n\\tfor number != 0 {\\n\\t\\texpr[l] = number % 10\\n\\t\\tl--\\n\\t\\t//expr = append(expr, number%10)\\n\\t\\tnumber = number / 10\\n\\t}\\n\\t//reverse := func(s string) string {\\n\\t//\\trns := []rune(s) // convert to rune\\n\\t//\\tfor i, j := 0, len(rns)-1; i < j; i, j = i+1, j-1 {\\n\\t//\\n\\t//\\t\\t// swap the letters of the string,\\n\\t//\\t\\t// like first with last and so on.\\n\\t//\\t\\trns[i], rns[j] = rns[j], rns[i]\\n\\t//\\t}\\n\\t//\\n\\t//\\t// return the reversed string.\\n\\t//\\treturn string(rns)\\n\\t//}\\n\\taddToResults := func(expression []int) {\\n\\t\\tvar r strings.Builder\\n\\t\\tfor _, v := range expression {\\n\\t\\t\\tif v == -1 {\\n\\t\\t\\t\\tr.WriteString(\"+\")\\n\\t\\t\\t} else if v == -2 {\\n\\t\\t\\t\\tr.WriteString(\"-\")\\n\\t\\t\\t} else if v == -3 {\\n\\t\\t\\t\\tr.WriteString(\"*\")\\n\\t\\t\\t} else {\\n\\t\\t\\t\\tr.WriteString(strconv.Itoa(v))\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\tfinalResults = append(finalResults, r.String())\\n\\t}\\n\\n\\tvalidExpression := func(expression []int, target int) int {\\n\\t\\tstack := []int{}\\n\\t\\t//fmt.Println(\"Expression : \", expression)\\n\\t\\tfor _, val := range expression {\\n\\t\\t\\tif val >= 0 && len(stack) > 0 && stack[len(stack)-1] == -3 {\\n\\t\\t\\t\\tstack[len(stack)-2] = val * stack[len(stack)-2]\\n\\t\\t\\t\\tstack = stack[:len(stack)-1]\\n\\t\\t\\t} else {\\n\\t\\t\\t\\tstack = append(stack, val)\\n\\t\\t\\t}\\n\\t\\t}\\n\\n\\t\\tif len(stack) > 1 {\\n\\t\\t\\tresult := stack[0]\\n\\t\\t\\toperation := stack[1]\\n\\t\\t\\tfor i := 2; i < len(stack); i++ {\\n\\t\\t\\t\\tif stack[i] > 0 {\\n\\t\\t\\t\\t\\tif operation == -1 {\\n\\t\\t\\t\\t\\t\\tresult = result + stack[i]\\n\\t\\t\\t\\t\\t} else {\\n\\t\\t\\t\\t\\t\\tresult = result - stack[i]\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t} else {\\n\\t\\t\\t\\t\\toperation = stack[i]\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t\\t//fmt.Println(\"Result: \", result)\\n\\t\\t\\treturn result\\n\\t\\t}\\n\\t\\t//fmt.Println(\"Result: \", stack[0])\\n\\t\\treturn stack[0]\\n\\t}\\n\\n\\tvar add func([]int, []int, int, int)\\n\\tadd = func(num []int, expression []int, target int, index int) {\\n\\t\\tif index == len(num) {\\n\\t\\t\\tif validExpression(expression, target) == target {\\n\\t\\t\\t\\taddToResults(expression)\\n\\t\\t\\t}\\n\\t\\t} else {\\n            // Add\\n            copyExp := make([]int, len(expression))\\n\\t\\t\\tcopy(copyExp, expression)\\n\\t\\t\\tcopyExp = append(copyExp, -1)\\n\\t\\t\\tcopyExp = append(copyExp, num[index])\\n\\t\\t\\tadd(num, copyExp, target, index+1)\\n\\n            //Substract\\n\\t\\t\\tcopyExp = make([]int, len(expression))\\n\\t\\t\\tcopy(copyExp, expression)\\n\\t\\t\\tcopyExp = append(copyExp, -2)\\n\\t\\t\\tcopyExp = append(copyExp, num[index])\\n            add(num, copyExp, target, index+1)\\n\\n            // Multiplication\\n\\t\\t\\tcopyExp = make([]int, len(expression))\\n\\t\\t\\tcopy(copyExp, expression)\\n\\t\\t\\tcopyExp = append(copyExp, -3)\\n\\t\\t\\tcopyExp = append(copyExp, num[index])\\n            add(num, copyExp, target, index+1)\\n\\n            // Combine current digit with last operand\\n            if expression[len(expression)-1] != 0 {\\n                expression[len(expression)-1] = (expression[len(expression)-1]*10)+num[index];\\n                add(num, expression,target, index+1)\\n            }\\n\\n\\t\\t}\\n\\t}\\n\\tadd(expr, []int{expr[0]}, target, 1)\\n\\treturn finalResults\\n}\\n```",
                "solutionTags": [
                    "Go",
                    "String",
                    "Backtracking",
                    "Stack"
                ],
                "code": "```\\nimport \"strconv\"\\nimport \"strings\"\\n// -1 = +\\n// -2 = -\\n// -3 = *\\n\\nfunc addOperators(num string, target int) []string {\\n\\tfinalResults := []string{}\\n\\tnumber, _ := strconv.Atoi(num)\\n\\texpr := make([]int, len(num))\\n\\tl := len(num) - 1\\n\\tfor number != 0 {\\n\\t\\texpr[l] = number % 10\\n\\t\\tl--\\n\\t\\t//expr = append(expr, number%10)\\n\\t\\tnumber = number / 10\\n\\t}\\n\\t//reverse := func(s string) string {\\n\\t//\\trns := []rune(s) // convert to rune\\n\\t//\\tfor i, j := 0, len(rns)-1; i < j; i, j = i+1, j-1 {\\n\\t//\\n\\t//\\t\\t// swap the letters of the string,\\n\\t//\\t\\t// like first with last and so on.\\n\\t//\\t\\trns[i], rns[j] = rns[j], rns[i]\\n\\t//\\t}\\n\\t//\\n\\t//\\t// return the reversed string.\\n\\t//\\treturn string(rns)\\n\\t//}\\n\\taddToResults := func(expression []int) {\\n\\t\\tvar r strings.Builder\\n\\t\\tfor _, v := range expression {\\n\\t\\t\\tif v == -1 {\\n\\t\\t\\t\\tr.WriteString(\"+\")\\n\\t\\t\\t} else if v == -2 {\\n\\t\\t\\t\\tr.WriteString(\"-\")\\n\\t\\t\\t} else if v == -3 {\\n\\t\\t\\t\\tr.WriteString(\"*\")\\n\\t\\t\\t} else {\\n\\t\\t\\t\\tr.WriteString(strconv.Itoa(v))\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\tfinalResults = append(finalResults, r.String())\\n\\t}\\n\\n\\tvalidExpression := func(expression []int, target int) int {\\n\\t\\tstack := []int{}\\n\\t\\t//fmt.Println(\"Expression : \", expression)\\n\\t\\tfor _, val := range expression {\\n\\t\\t\\tif val >= 0 && len(stack) > 0 && stack[len(stack)-1] == -3 {\\n\\t\\t\\t\\tstack[len(stack)-2] = val * stack[len(stack)-2]\\n\\t\\t\\t\\tstack = stack[:len(stack)-1]\\n\\t\\t\\t} else {\\n\\t\\t\\t\\tstack = append(stack, val)\\n\\t\\t\\t}\\n\\t\\t}\\n\\n\\t\\tif len(stack) > 1 {\\n\\t\\t\\tresult := stack[0]\\n\\t\\t\\toperation := stack[1]\\n\\t\\t\\tfor i := 2; i < len(stack); i++ {\\n\\t\\t\\t\\tif stack[i] > 0 {\\n\\t\\t\\t\\t\\tif operation == -1 {\\n\\t\\t\\t\\t\\t\\tresult = result + stack[i]\\n\\t\\t\\t\\t\\t} else {\\n\\t\\t\\t\\t\\t\\tresult = result - stack[i]\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t} else {\\n\\t\\t\\t\\t\\toperation = stack[i]\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t\\t//fmt.Println(\"Result: \", result)\\n\\t\\t\\treturn result\\n\\t\\t}\\n\\t\\t//fmt.Println(\"Result: \", stack[0])\\n\\t\\treturn stack[0]\\n\\t}\\n\\n\\tvar add func([]int, []int, int, int)\\n\\tadd = func(num []int, expression []int, target int, index int) {\\n\\t\\tif index == len(num) {\\n\\t\\t\\tif validExpression(expression, target) == target {\\n\\t\\t\\t\\taddToResults(expression)\\n\\t\\t\\t}\\n\\t\\t} else {\\n            // Add\\n            copyExp := make([]int, len(expression))\\n\\t\\t\\tcopy(copyExp, expression)\\n\\t\\t\\tcopyExp = append(copyExp, -1)\\n\\t\\t\\tcopyExp = append(copyExp, num[index])\\n\\t\\t\\tadd(num, copyExp, target, index+1)\\n\\n            //Substract\\n\\t\\t\\tcopyExp = make([]int, len(expression))\\n\\t\\t\\tcopy(copyExp, expression)\\n\\t\\t\\tcopyExp = append(copyExp, -2)\\n\\t\\t\\tcopyExp = append(copyExp, num[index])\\n            add(num, copyExp, target, index+1)\\n\\n            // Multiplication\\n\\t\\t\\tcopyExp = make([]int, len(expression))\\n\\t\\t\\tcopy(copyExp, expression)\\n\\t\\t\\tcopyExp = append(copyExp, -3)\\n\\t\\t\\tcopyExp = append(copyExp, num[index])\\n            add(num, copyExp, target, index+1)\\n\\n            // Combine current digit with last operand\\n            if expression[len(expression)-1] != 0 {\\n                expression[len(expression)-1] = (expression[len(expression)-1]*10)+num[index];\\n                add(num, expression,target, index+1)\\n            }\\n\\n\\t\\t}\\n\\t}\\n\\tadd(expr, []int{expr[0]}, target, 1)\\n\\treturn finalResults\\n}\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 2518924,
                "title": "share-my-c-ac-code",
                "content": "```cpp\\nclass Solution {\\n  public:\\n    vector<string> addOperators(string num, int target) {\\n      string prev;\\n      vector<string> ans;\\n      foo(num, 0, 0, target, prev, ans);\\n      return ans;\\n    }\\n    void eval(long long a, char op, long long b, long long& res, long long& mul_res) {\\n      switch(op) {\\n        case \\'+\\':\\n          res = a + b + mul_res;\\n          mul_res = 0;\\n          break;\\n        case \\'-\\':\\n          res = a - b + mul_res;\\n          mul_res = 0;\\n          break;\\n        case \\'*\\':\\n          //don\\'t know previous sign, deal in calling function\\n          //if (mul_res == 0) mul_res = a;\\n          mul_res *= b;\\n          res += mul_res;\\n          break;\\n        case \\' \\':\\n          res = b;\\n          break;\\n        default:\\n          cerr << \"invalid operator\\\\n\";\\n          exit(1);\\n      }\\n      \\n    }\\n    void foo(string nums, long long cur, long long mul_cur, int target, string& prev, vector<string>& ans) {\\n      char last_op = prev.empty() ? \\' \\' : prev.back();\\n      if (nums.length() == 1 || nums[0] != \\'0\\') { //except leading zero\\n        long long num = stol(nums);\\n        long long tmp = cur, mul_tmp = mul_cur;\\n        eval(cur, last_op, num, tmp, mul_tmp);\\n        //cout << prev  << nums << \" == \" << tmp << \" #\" << cur << \" \" << mul_cur << \" \" << target << endl; //use python eval to test\\n        if (tmp == target) ans.push_back(prev + nums);\\n      }\\n      const size_t nums_len = nums.length();\\n      if (nums.length() < 2) return;\\n      \\n      const size_t cur_prev_len = prev.length();\\n      for (size_t i = 1; i < nums_len; i++) {\\n        string fronts = nums.substr(0, i);\\n        if (i > 1 && nums[0] == \\'0\\') break;//leading zero\\n        string backs = nums.substr(i);\\n        long long front = stol(fronts);\\n        long long new_cur = cur, new_mul = mul_cur;\\n        eval(cur, last_op, front, new_cur, new_mul);\\n        \\n        prev += fronts;\\n        prev.push_back(\\'+\\');\\n        foo(backs, new_cur, 0, target, prev, ans);\\n        \\n        prev.back() = \\'-\\';\\n        foo(backs, new_cur, 0, target, prev, ans);\\n        \\n        prev.back() = \\'*\\';\\n        if (last_op != \\'*\\') //last_op is not \\'*\\'\\n          new_mul = ((last_op == \\'-\\') * -2 + 1) * front;\\n        foo(backs, cur, new_mul, target, prev, ans);\\n        \\n        prev.resize(cur_prev_len);\\n      }\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```cpp\\nclass Solution {\\n  public:\\n    vector<string> addOperators(string num, int target) {\\n      string prev;\\n      vector<string> ans;\\n      foo(num, 0, 0, target, prev, ans);\\n      return ans;\\n    }\\n    void eval(long long a, char op, long long b, long long& res, long long& mul_res) {\\n      switch(op) {\\n        case \\'+\\':\\n          res = a + b + mul_res;\\n          mul_res = 0;\\n          break;\\n        case \\'-\\':\\n          res = a - b + mul_res;\\n          mul_res = 0;\\n          break;\\n        case \\'*\\':\\n          //don\\'t know previous sign, deal in calling function\\n          //if (mul_res == 0) mul_res = a;\\n          mul_res *= b;\\n          res += mul_res;\\n          break;\\n        case \\' \\':\\n          res = b;\\n          break;\\n        default:\\n          cerr << \"invalid operator\\\\n\";\\n          exit(1);\\n      }\\n      \\n    }\\n    void foo(string nums, long long cur, long long mul_cur, int target, string& prev, vector<string>& ans) {\\n      char last_op = prev.empty() ? \\' \\' : prev.back();\\n      if (nums.length() == 1 || nums[0] != \\'0\\') { //except leading zero\\n        long long num = stol(nums);\\n        long long tmp = cur, mul_tmp = mul_cur;\\n        eval(cur, last_op, num, tmp, mul_tmp);\\n        //cout << prev  << nums << \" == \" << tmp << \" #\" << cur << \" \" << mul_cur << \" \" << target << endl; //use python eval to test\\n        if (tmp == target) ans.push_back(prev + nums);\\n      }\\n      const size_t nums_len = nums.length();\\n      if (nums.length() < 2) return;\\n      \\n      const size_t cur_prev_len = prev.length();\\n      for (size_t i = 1; i < nums_len; i++) {\\n        string fronts = nums.substr(0, i);\\n        if (i > 1 && nums[0] == \\'0\\') break;//leading zero\\n        string backs = nums.substr(i);\\n        long long front = stol(fronts);\\n        long long new_cur = cur, new_mul = mul_cur;\\n        eval(cur, last_op, front, new_cur, new_mul);\\n        \\n        prev += fronts;\\n        prev.push_back(\\'+\\');\\n        foo(backs, new_cur, 0, target, prev, ans);\\n        \\n        prev.back() = \\'-\\';\\n        foo(backs, new_cur, 0, target, prev, ans);\\n        \\n        prev.back() = \\'*\\';\\n        if (last_op != \\'*\\') //last_op is not \\'*\\'\\n          new_mul = ((last_op == \\'-\\') * -2 + 1) * front;\\n        foo(backs, cur, new_mul, target, prev, ans);\\n        \\n        prev.resize(cur_prev_len);\\n      }\\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 2394320,
                "title": "python-recursive-solution",
                "content": "```\\nclass Solution:\\n    def addOperators(self, num: str, target: int) -> List[str]:\\n        answer = set()\\n        \\n        def dp(idx, total, path, last_number):\\n            if idx == len(num) and total == target:\\n                answer.add(path)\\n                \\n            if idx >= len(num):\\n                return\\n            \\n            for i in range(idx, len(num)):\\n                if len(num[idx:i+1]) > 1 and num[idx:i+1][0] == \"0\":\\n                    continue\\n                    \\n                tmp_number = num[idx:i+1]\\n                \\n                if last_number == \"\":\\n                    dp(i + 1, int(tmp_number), tmp_number, tmp_number)\\n                else:\\n                    # addition\\n                    dp(i + 1,total + int(tmp_number), path + \"+\" + tmp_number, tmp_number)\\n                    \\n                    # subtraction\\n                    dp(i + 1,total - int(tmp_number), path + \"-\" + tmp_number, \"-\" + tmp_number)\\n                    \\n                    # multiplication\\n                    dp(i + 1, total-int(last_number) + (int(last_number) * int(tmp_number)), path + \"*\" + tmp_number, str(int(tmp_number) * int(last_number)))\\n\\n        dp(0,-1,\"\", \"\")\\n        return answer\\n\\n```",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Recursion"
                ],
                "code": "```\\nclass Solution:\\n    def addOperators(self, num: str, target: int) -> List[str]:\\n        answer = set()\\n        \\n        def dp(idx, total, path, last_number):\\n            if idx == len(num) and total == target:\\n                answer.add(path)\\n                \\n            if idx >= len(num):\\n                return\\n            \\n            for i in range(idx, len(num)):\\n                if len(num[idx:i+1]) > 1 and num[idx:i+1][0] == \"0\":\\n                    continue\\n                    \\n                tmp_number = num[idx:i+1]\\n                \\n                if last_number == \"\":\\n                    dp(i + 1, int(tmp_number), tmp_number, tmp_number)\\n                else:\\n                    # addition\\n                    dp(i + 1,total + int(tmp_number), path + \"+\" + tmp_number, tmp_number)\\n                    \\n                    # subtraction\\n                    dp(i + 1,total - int(tmp_number), path + \"-\" + tmp_number, \"-\" + tmp_number)\\n                    \\n                    # multiplication\\n                    dp(i + 1, total-int(last_number) + (int(last_number) * int(tmp_number)), path + \"*\" + tmp_number, str(int(tmp_number) * int(last_number)))\\n\\n        dp(0,-1,\"\", \"\")\\n        return answer\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2301093,
                "title": "python3",
                "content": "class Solution:\\n\\n    def addOperators(self, num: str, target: int) -> List[str]:\\n        n = len(num)\\n        result = []\\n        \\n        def Helper(i,prev,curr,val,expr):\\n            if i == n:\\n                if val == target and curr==0:\\n                    result.append(expr)\\n                return\\n            \\n            curr = curr*10 + int(num[i])\\n            \\n            if curr>0:\\n                Helper(i+1,prev,curr,val,expr)\\n                \\n            if not expr:\\n                Helper(i+1,curr,0,val+curr,str(curr))\\n            else:\\n                Helper(i+1,curr,0,val+curr,expr+\\'+\\'+str(curr))\\n                Helper(i+1,-curr,0,val-curr,expr+\\'-\\'+str(curr))\\n                Helper(i+1,prev*curr,0,val-prev+prev*curr,expr+\\'*\\'+str(curr))\\n           \\n        Helper(0,0,0,0,\"\")\\n        return result",
                "solutionTags": [],
                "code": "class Solution:\\n\\n    def addOperators(self, num: str, target: int) -> List[str]:\\n        n = len(num)\\n        result = []\\n        \\n        def Helper(i,prev,curr,val,expr):\\n            if i == n:\\n                if val == target and curr==0:\\n                    result.append(expr)\\n                return\\n            \\n            curr = curr*10 + int(num[i])\\n            \\n            if curr>0:\\n                Helper(i+1,prev,curr,val,expr)\\n                \\n            if not expr:\\n                Helper(i+1,curr,0,val+curr,str(curr))\\n            else:\\n                Helper(i+1,curr,0,val+curr,expr+\\'+\\'+str(curr))\\n                Helper(i+1,-curr,0,val-curr,expr+\\'-\\'+str(curr))\\n                Helper(i+1,prev*curr,0,val-prev+prev*curr,expr+\\'*\\'+str(curr))\\n           \\n        Helper(0,0,0,0,\"\")\\n        return result",
                "codeTag": "Java"
            },
            {
                "id": 2210626,
                "title": "c-backtrack-clean-code",
                "content": "\\tclass Solution {\\n\\tpublic:\\n\\t\\tvector<string> res;\\n\\t\\tstring s;\\n\\t\\tint target, n;\\n\\t\\tvoid solve(int it,  string path, long long resSoFar, long long prev){\\n\\t\\t\\tif(it == n){\\n\\t\\t\\t\\tif(resSoFar == target) res.push_back(path);\\n\\t\\t\\t\\treturn;\\n\\t\\t\\t}\\n\\t\\t\\tlong long num = 0;\\n\\t\\t\\tstring tmp;\\n\\n\\t\\t\\tfor(auto j = it; j < n; j++){\\n\\t\\t\\t\\tif(j > it && s[it] == \\'0\\') break;\\n\\n\\t\\t\\t\\tnum = num * 10 + (s[j] - \\'0\\');\\n\\t\\t\\t\\ttmp.push_back(s[j]);\\n\\n\\t\\t\\t\\tif(it == 0) solve(j + 1, tmp, num, num);\\n\\t\\t\\t\\telse{\\n\\t\\t\\t\\t\\tsolve(j + 1, path + \"+\" + tmp, resSoFar + num, num);\\n\\t\\t\\t\\t\\tsolve(j + 1, path + \\'-\\' + tmp, resSoFar - num, -num);\\n\\t\\t\\t\\t\\tsolve(j + 1, path + \\'*\\' + tmp, resSoFar - prev + prev * num, prev * num);\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\n\\t\\t}\\n\\t\\tvector<string> addOperators(string num, int target) {\\n\\t\\t\\tthis -> target = target;\\n\\t\\t\\ts = num, n = num.size();\\n\\n\\t\\t\\tsolve(0, \"\", 0, 0);\\n\\t\\t\\treturn res;\\n\\t\\t}\\n\\t};",
                "solutionTags": [
                    "C",
                    "Backtracking"
                ],
                "code": "class Solution {\\n\\tpublic:\\n\\t\\tvector<string> res;\\n\\t\\tstring s;\\n\\t\\tint target, n;\\n\\t\\tvoid solve(int it,  string path, long long resSoFar, long long prev){\\n\\t\\t\\tif(it == n){\\n\\t\\t\\t\\tif(resSoFar == target) res.push_back(path);\\n\\t\\t\\t\\treturn;\\n\\t\\t\\t}",
                "codeTag": "Java"
            },
            {
                "id": 2157952,
                "title": "c",
                "content": "(```)  class Solution {\\npublic:\\n    \\n    vector<string> ans;\\n    \\n    string num;\\n    int target;\\n    \\n    vector<string> addOperators(string num, int target) {\\n        \\n        this->num = num;\\n        \\n        this->target = target;\\n        \\n        backtrack( 0, \"\", 0, 0);\\n        \\n        return ans;\\n    }\\n    void backtrack(int i, const string& path, long resSoFar, long prevNum) {\\n        \\n        if (i == num.size()) {\\n            \\n            if (resSoFar == target)   \\n            {\\n                ans.push_back(path);\\n                \\n            }\\n            \\n            return;\\n        \\n        }\\n        \\n        string numStr;\\n        \\n        long num1 = 0;\\n        \\n        for (int j = i; j < num.length(); j++) {\\n            \\n            if (j > i && num[i] == \\'0\\')\\n            {\\n                break;\\n            }\\n            numStr += num[j];\\n            \\n            num1 = num1 * 10 + num[j] - \\'0\\';\\n            \\n            if (i == 0) {\\n                \\n                backtrack(j + 1, path + numStr, num1, num1);\\n                \\n            } else {\\n                \\n                backtrack(j + 1, path + \"+\" + numStr, resSoFar + num1, num1);\\n                \\n                backtrack(j + 1, path + \"-\" + numStr, resSoFar - num1, -num1);\\n                \\n                backtrack(j + 1, path + \"*\" + numStr, resSoFar - prevNum + prevNum * num1, prevNum * num1);\\n            }\\n        }\\n    }\\n};    \\n",
                "solutionTags": [],
                "code": "class Solution {\\npublic:\\n    \\n    vector<string> ans;\\n    \\n    string num;\\n    int target;\\n    \\n    vector<string> addOperators(string num, int target) {\\n        \\n        this->num = num;\\n        \\n        this->target = target;\\n        \\n        backtrack( 0, \"\", 0, 0);\\n        \\n        return ans;\\n    }",
                "codeTag": "Java"
            },
            {
                "id": 2109805,
                "title": "python-dfs-solution",
                "content": "```\\nclass Solution:\\n    def addOperators(self, num, target):\\n        res, self.target = [], target\\n        for i in range(1,len(num)+1):\\n            if i == 1 or (i > 1 and num[0] != \"0\"): # prevent \"00*\" as a number\\n                self.dfs(num[i:], num[:i], int(num[:i]), int(num[:i]), res) # this step put first number in the string\\n        return res\\n\\n    def dfs(self, num, temp, cur, last, res):\\n        if not num:\\n            if cur == self.target:\\n                res.append(temp)\\n            return\\n        for i in range(1, len(num)+1):\\n            val = num[:i]\\n            if i == 1 or (i > 1 and num[0] != \"0\"): # prevent \"00*\" as a number\\n                self.dfs(num[i:], temp + \"+\" + val, cur+int(val), int(val), res)\\n                self.dfs(num[i:], temp + \"-\" + val, cur-int(val), -int(val), res)\\n                self.dfs(num[i:], temp + \"*\" + val, cur-last+last*int(val), last*int(val), res)        \\n\\t\\t\\t\\t```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nclass Solution:\\n    def addOperators(self, num, target):\\n        res, self.target = [], target\\n        for i in range(1,len(num)+1):\\n            if i == 1 or (i > 1 and num[0] != \"0\"): # prevent \"00*\" as a number\\n                self.dfs(num[i:], num[:i], int(num[:i]), int(num[:i]), res) # this step put first number in the string\\n        return res\\n\\n    def dfs(self, num, temp, cur, last, res):\\n        if not num:\\n            if cur == self.target:\\n                res.append(temp)\\n            return\\n        for i in range(1, len(num)+1):\\n            val = num[:i]\\n            if i == 1 or (i > 1 and num[0] != \"0\"): # prevent \"00*\" as a number\\n                self.dfs(num[i:], temp + \"+\" + val, cur+int(val), int(val), res)\\n                self.dfs(num[i:], temp + \"-\" + val, cur-int(val), -int(val), res)\\n                self.dfs(num[i:], temp + \"*\" + val, cur-last+last*int(val), last*int(val), res)        \\n\\t\\t\\t\\t```",
                "codeTag": "Java"
            },
            {
                "id": 1999699,
                "title": "python-naive-recursion",
                "content": "Can pass. Although it is slow. but the code cleaner. Replace - with +-, so that the final string will only have + and * two operations. \\nFirst split by + to get all parts. \\nThen split by * to get each part value. Super clean to code.\\nAlso, each part split by + can be cached to avoid duplicate calculation.\\n\\n```\\nclass Solution:\\n    def addOperators(self, num: str, target: int) -> List[str]:\\n        n = len(num)\\n        \\n        ans = []\\n        \\n        @cache\\n        def subcheck(s):            \\n            parts = s.split(\\'*\\')\\n            res = int(parts[0])\\n            for p in parts[1:]:\\n                res *= int(p)\\n            return res\\n        \\n        def check(s):      \\n            ss = \\'\\'.join(s)\\n            # print(s)\\n            parts = ss.split(\\'+\\')\\n            sumv = sum(map(subcheck, parts))\\n            if sumv == target:\\n                ss = ss.replace(\\'+-\\', \\'-\\')\\n                ans.append(ss)\\n        \\n        def bt(cur, i):\\n            if i == n:\\n                check(cur)\\n                return\\n            if i == 0:\\n                bt(cur + [num[i]], i + 1)\\n            else:\\n                if cur[-1] == \\'0\\' and (len(cur)< 2 or (not (\\'0\\'<= cur[-2] <= \\'9\\'))): # for leading 0\\n                    bt(cur + [\\'+\\', num[i]], i + 1)\\n                    bt(cur + [\\'+-\\', num[i]], i + 1)\\n                    bt(cur + [\\'*\\', num[i]], i + 1)\\n                else:\\n                    bt(cur + [num[i]], i + 1)\\n                    bt(cur + [\\'+\\', num[i]], i + 1)\\n                    bt(cur + [\\'+-\\', num[i]], i + 1)\\n                    bt(cur + [\\'*\\', num[i]], i + 1)            \\n            \\n        bt([], 0)\\n        \\n        return ans\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def addOperators(self, num: str, target: int) -> List[str]:\\n        n = len(num)\\n        \\n        ans = []\\n        \\n        @cache\\n        def subcheck(s):            \\n            parts = s.split(\\'*\\')\\n            res = int(parts[0])\\n            for p in parts[1:]:\\n                res *= int(p)\\n            return res\\n        \\n        def check(s):      \\n            ss = \\'\\'.join(s)\\n            # print(s)\\n            parts = ss.split(\\'+\\')\\n            sumv = sum(map(subcheck, parts))\\n            if sumv == target:\\n                ss = ss.replace(\\'+-\\', \\'-\\')\\n                ans.append(ss)\\n        \\n        def bt(cur, i):\\n            if i == n:\\n                check(cur)\\n                return\\n            if i == 0:\\n                bt(cur + [num[i]], i + 1)\\n            else:\\n                if cur[-1] == \\'0\\' and (len(cur)< 2 or (not (\\'0\\'<= cur[-2] <= \\'9\\'))): # for leading 0\\n                    bt(cur + [\\'+\\', num[i]], i + 1)\\n                    bt(cur + [\\'+-\\', num[i]], i + 1)\\n                    bt(cur + [\\'*\\', num[i]], i + 1)\\n                else:\\n                    bt(cur + [num[i]], i + 1)\\n                    bt(cur + [\\'+\\', num[i]], i + 1)\\n                    bt(cur + [\\'+-\\', num[i]], i + 1)\\n                    bt(cur + [\\'*\\', num[i]], i + 1)            \\n            \\n        bt([], 0)\\n        \\n        return ans\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1940237,
                "title": "python-code",
                "content": "```\\n    def addOperators(self, num: str, T: int) -> List[str]:\\n\\n\\t\\tdef f(i, exp, prev, expval):\\n\\n\\t\\t\\tif i == len(num):\\n\\t\\t\\t\\tif expval == T:\\n\\t\\t\\t\\t\\tself.res.append(exp)\\n\\t\\t\\t\\treturn\\n\\n\\t\\t\\tfor j in range(i, len(num)):\\n\\t\\t\\t\\tcur = int(num[i:j+1])\\n\\t\\t\\t\\tif num[i] == \\'0\\' and i < j: # 1* 05 = 1*5 is not allowed so 05 has to be skipped. IMP\\n\\t\\t\\t\\t\\treturn\\n\\n\\t\\t\\t\\tif i == 0:\\n\\t\\t\\t\\t\\tf(j+1, str(cur), cur, cur) # IMP: 1st number will not use any operators. Each subsequent number will be <op> num\\n\\t\\t\\t\\telse:\\n\\t\\t\\t\\t\\tf(j+1, exp + \\'+\\' + str(cur), cur, expval+cur)\\n\\t\\t\\t\\t\\tf(j+1, exp + \\'-\\' + str(cur), -cur, expval-cur) # IMP: -cur is passed to reverse this calulation on encountering \\'*\\'\\n\\t\\t\\t\\t\\tf(j+1, exp + \\'*\\' + str(cur), prev*cur, expval - prev + prev*cur) #IMP\\n\\n\\t\\tself.res = []\\n\\t\\tf(0, \"\", 0, 0)\\n\\t\\treturn self.res\\n\\n# To tackle the problem of order of evalution (calculating the product before sum), we always calculate sum but change the exp val when we encounter the \\'*\\'\\n```",
                "solutionTags": [],
                "code": "```\\n    def addOperators(self, num: str, T: int) -> List[str]:\\n\\n\\t\\tdef f(i, exp, prev, expval):\\n\\n\\t\\t\\tif i == len(num):\\n\\t\\t\\t\\tif expval == T:\\n\\t\\t\\t\\t\\tself.res.append(exp)\\n\\t\\t\\t\\treturn\\n\\n\\t\\t\\tfor j in range(i, len(num)):\\n\\t\\t\\t\\tcur = int(num[i:j+1])\\n\\t\\t\\t\\tif num[i] == \\'0\\' and i < j: # 1* 05 = 1*5 is not allowed so 05 has to be skipped. IMP\\n\\t\\t\\t\\t\\treturn\\n\\n\\t\\t\\t\\tif i == 0:\\n\\t\\t\\t\\t\\tf(j+1, str(cur), cur, cur) # IMP: 1st number will not use any operators. Each subsequent number will be <op> num\\n\\t\\t\\t\\telse:\\n\\t\\t\\t\\t\\tf(j+1, exp + \\'+\\' + str(cur), cur, expval+cur)\\n\\t\\t\\t\\t\\tf(j+1, exp + \\'-\\' + str(cur), -cur, expval-cur) # IMP: -cur is passed to reverse this calulation on encountering \\'*\\'\\n\\t\\t\\t\\t\\tf(j+1, exp + \\'*\\' + str(cur), prev*cur, expval - prev + prev*cur) #IMP\\n\\n\\t\\tself.res = []\\n\\t\\tf(0, \"\", 0, 0)\\n\\t\\treturn self.res\\n\\n# To tackle the problem of order of evalution (calculating the product before sum), we always calculate sum but change the exp val when we encounter the \\'*\\'\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 1926405,
                "title": "java-99-fast-solution-with-full-detailed-explanations",
                "content": "```\\nclass Solution\\n{\\n    public List<String> addOperators(String num, int target)\\n    {\\n        List<String> result = new ArrayList<>();\\n        if (target == Integer.MIN_VALUE) return result;\\n        \\n        // using char array to avoid more space consuming by string\\n        char[] originalChars = num.toCharArray();\\n        int len = num.length();\\n        \\n        // the maximum length of the new string with operators is 2 * len - 1(1 + 1 + 2)\\n        // add an operator in between each character\\n        char[] newChars = new char[len + len - 1];\\n        \\n        // originalIndex: the index we use to track in original num.\\n        int originalIndex = 0;\\n        \\n        // newIndex: the index we use to track in new formed string with operators.\\n        int newIndex = 0;\\n        \\n        int currentValue = 0;   // the current operand value.\\n        \\n        long targetL = target;  // avoid overflow.\\n        \\n        // The first operand is without operator before it.\\n        for (int i = 0; i < len; i++)\\n        {\\n            // current value can be multiple digits.\\n            currentValue = 10 * currentValue + (originalChars[i] - \\'0\\');\\n            \\n            // form new string with operators.\\n            newChars[newIndex++] = originalChars[i];\\n            \\n            // using helper function formOperator to process the rest (recursion)\\n            formOperator(result, originalChars, newChars, i + 1, newIndex, len, 0, currentValue, targetL);\\n            \\n            if (currentValue == 0) break;   // can only has single digit: 0 if value == 0, no need to calculate multiple digits.\\n        }\\n        \\n        return result;\\n    }\\n    \\n    // ......pre_preSum (+) preValue <operator> currentValue;\\n    // if (+) is (-), the preValue will be -preValue;\\n    // if <operator> is (*), then pre_presSum stays, first calculate preValue * currentValue;\\n    \\n    private void formOperator(List<String> result, char[] originalChars, char[] newChars, \\n                              int originalIndex, int newIndex, int len,\\n                              long pre_preSum, long preValue, long targetL)\\n    {\\n        // already reach to the end of the original chars.\\n        if (originalIndex == len)\\n        {\\n            if (pre_preSum + preValue == targetL)\\n            {\\n                result.add(new String(newChars, 0, newIndex));\\n            }\\n            \\n            return;\\n        }\\n        \\n        long currentValue = 0;\\n        int operatorIndex = newIndex++;\\n        \\n        for (int i = originalIndex; i < len; i++)\\n        {\\n            // current value can be multiple digits.\\n            currentValue = 10 * currentValue + (originalChars[i] - \\'0\\');\\n            \\n            // form new string with operators.\\n            newChars[newIndex++] = originalChars[i];\\n            \\n            newChars[operatorIndex] = \\'+\\';\\n            formOperator(result, originalChars, newChars, i + 1, newIndex, len, pre_preSum + preValue, currentValue, targetL);\\n            \\n            newChars[operatorIndex] = \\'-\\';\\n            formOperator(result, originalChars, newChars, i + 1, newIndex, len, pre_preSum + preValue, -currentValue, targetL);\\n            \\n            newChars[operatorIndex] = \\'*\\';\\n            formOperator(result, originalChars, newChars, i + 1, newIndex, len, pre_preSum, preValue * currentValue, targetL);\\n            \\n            if (currentValue == 0) break;   // no leading zeros(multiple digits).\\n        }\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Backtracking"
                ],
                "code": "```\\nclass Solution\\n{\\n    public List<String> addOperators(String num, int target)\\n    {\\n        List<String> result = new ArrayList<>();\\n        if (target == Integer.MIN_VALUE) return result;\\n        \\n        // using char array to avoid more space consuming by string\\n        char[] originalChars = num.toCharArray();\\n        int len = num.length();\\n        \\n        // the maximum length of the new string with operators is 2 * len - 1(1 + 1 + 2)\\n        // add an operator in between each character\\n        char[] newChars = new char[len + len - 1];\\n        \\n        // originalIndex: the index we use to track in original num.\\n        int originalIndex = 0;\\n        \\n        // newIndex: the index we use to track in new formed string with operators.\\n        int newIndex = 0;\\n        \\n        int currentValue = 0;   // the current operand value.\\n        \\n        long targetL = target;  // avoid overflow.\\n        \\n        // The first operand is without operator before it.\\n        for (int i = 0; i < len; i++)\\n        {\\n            // current value can be multiple digits.\\n            currentValue = 10 * currentValue + (originalChars[i] - \\'0\\');\\n            \\n            // form new string with operators.\\n            newChars[newIndex++] = originalChars[i];\\n            \\n            // using helper function formOperator to process the rest (recursion)\\n            formOperator(result, originalChars, newChars, i + 1, newIndex, len, 0, currentValue, targetL);\\n            \\n            if (currentValue == 0) break;   // can only has single digit: 0 if value == 0, no need to calculate multiple digits.\\n        }\\n        \\n        return result;\\n    }\\n    \\n    // ......pre_preSum (+) preValue <operator> currentValue;\\n    // if (+) is (-), the preValue will be -preValue;\\n    // if <operator> is (*), then pre_presSum stays, first calculate preValue * currentValue;\\n    \\n    private void formOperator(List<String> result, char[] originalChars, char[] newChars, \\n                              int originalIndex, int newIndex, int len,\\n                              long pre_preSum, long preValue, long targetL)\\n    {\\n        // already reach to the end of the original chars.\\n        if (originalIndex == len)\\n        {\\n            if (pre_preSum + preValue == targetL)\\n            {\\n                result.add(new String(newChars, 0, newIndex));\\n            }\\n            \\n            return;\\n        }\\n        \\n        long currentValue = 0;\\n        int operatorIndex = newIndex++;\\n        \\n        for (int i = originalIndex; i < len; i++)\\n        {\\n            // current value can be multiple digits.\\n            currentValue = 10 * currentValue + (originalChars[i] - \\'0\\');\\n            \\n            // form new string with operators.\\n            newChars[newIndex++] = originalChars[i];\\n            \\n            newChars[operatorIndex] = \\'+\\';\\n            formOperator(result, originalChars, newChars, i + 1, newIndex, len, pre_preSum + preValue, currentValue, targetL);\\n            \\n            newChars[operatorIndex] = \\'-\\';\\n            formOperator(result, originalChars, newChars, i + 1, newIndex, len, pre_preSum + preValue, -currentValue, targetL);\\n            \\n            newChars[operatorIndex] = \\'*\\';\\n            formOperator(result, originalChars, newChars, i + 1, newIndex, len, pre_preSum, preValue * currentValue, targetL);\\n            \\n            if (currentValue == 0) break;   // no leading zeros(multiple digits).\\n        }\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1883703,
                "title": "c-dfs-solution-very-easy-to-understand-with-comment",
                "content": "Many thanks to this post, I was inspired and fully understand the process after thinking it through\\nhttps://leetcode.com/problems/expression-add-operators/discuss/1553905/C-DFS-Easy-to-understand\\n\\n\\n\\n    \\n\\n    \\n    public class Solution {\\n    List<string> result;\\n    string s;\\n    int target;\\n\\t// inspired from this post https://leetcode.com/problems/expression-add-operators/discuss/1553905/C-DFS-Easy-to-understand\\n    public IList<string> AddOperators(string num, int target) \\n    {\\n        result = new List<string>();\\n        this.s=num;\\n        this.target=target;\\n        \\n        dfs(0, string.Empty, 0, 0);\\n        return result;\\n    }\\n    \\n    public void dfs(int startIndex, string temp, long prev, long curResult)\\n    {\\n        if(startIndex == s.Length)\\n        {\\n            if(prev+curResult == target)\\n                result.Add(temp);  \\n            return;\\n        }\\n        \\n        // start from startIndex again for next number\\n        for(int i=startIndex; i < s.Length; i++)\\n        {\\n            // i+1 - startIndex was length from startIndex\\n            // get every substring from startIndex\\n            var cur = s.Substring(startIndex, i+1-startIndex);\\n            \\n            // leading 0\\n            if(cur.Length > 1 && cur[0] == \\'0\\')\\n                continue;\\n            \\n            var curNum = Int64.Parse(cur);\\n            \\n            if(startIndex == 0)\\n                dfs(i+1, cur, curNum, 0);\\n            else\\n            {\\n                // please refer to 227. Basic Calculator II\\'s optimal solution about defered calculation \\n                    //  \\'*\\')\\n                        dfs(i+1, temp + \"*\" + cur, prev*curNum, curResult);\\n                    // \\'+\\')\\n                        dfs(i+1, temp + \"+\" + cur, curNum,  curResult + prev);\\n                    // \\'-\\')\\n                        dfs(i+1, temp + \"-\" + cur, -curNum, curResult + prev);\\n            }\\n        }\\n    }\\n}",
                "solutionTags": [],
                "code": "class Solution {\\n    List<string> result;\\n    string s;\\n    int target;\\n\\t// inspired from this post https://leetcode.com/problems/expression-add-operators/discuss/1553905/C-DFS-Easy-to-understand\\n    public IList<string> AddOperators(string num, int target) \\n    {\\n        result = new List<string>();\\n        this.s=num;\\n        this.target=target;\\n        \\n        dfs(0, string.Empty, 0, 0);\\n        return result;\\n    }",
                "codeTag": "Java"
            },
            {
                "id": 1832360,
                "title": "c-learning-opportunities",
                "content": "March 8, 2022\\n**Introduction**\\nIt is a hard level algorithm. The tip is to learn how to handle multiplication and put it\\'s precedence before \"+\" and \"-\". \\n\\n**Case study I** \\nFor example, if you have a sequence of 12345 and you have proceeded to 1 + 2 + 3, now your eval is 6 right? If you want to add a * between 3 and 4, you would take 3 as the digit to be multiplied, so you want to take it out from the existing eval. You have 1 + 2 + 3 * 4 and the eval now is (1 + 2 + 3) - 3 + (3 * 4). \\n\\n**Case study II**\\nWe need to maintain the value of consecutive * result, if we want to do another * operation, just minus consecutive * result, and use that to multiply the new number.\\n\\nfor 1 + 2 * 3 if we want to *4, so it should 1 + 2 * 3 - 2 * 3 + 2 * 3  *  4\\n\\nThe following code uses the above idea to handle multiplication. Try to debug second test case and see if it is true to have -2 * 3, followed by 2 * 3 * 4. \\n\\nThe following C# code passes online judge. \\n\\n```\\nusing System;\\nusing System.Collections.Generic;\\nusing System.Linq;\\nusing System.Text;\\nusing System.Threading.Tasks;\\n\\nnamespace _228_epxression_and_operator_B\\n{\\n    class Program\\n    {\\n        static void Main(string[] args)\\n        {\\n            var test = new Program();\\n            var result = test.AddOperators(\"123\", 6);\\n        }\\n\\n        public IList<string> AddOperators(string num, int target)\\n        {           \\n            if (num == null || num.Length == 0)\\n            {\\n                return new List<string>();\\n            }\\n\\n            var result = new List<string>();\\n\\n            runDFS(result, \"\", num, target, 0, 0, 0);\\n            return result;\\n        }\\n\\n        /// <summary>\\n        /// study code\\n        /// https://leetcode.com/problems/expression-add-operators/discuss/71895/Java-Standard-Backtrace-AC-Solutoin-short-and-clear\\n        /// </summary>\\n        /// <param name=\"expressions\"></param>\\n        /// <param name=\"path\"></param>\\n        /// <param name=\"num\"></param>\\n        /// <param name=\"target\"></param>\\n        /// <param name=\"pos\"></param>\\n        /// <param name=\"eval\"></param>\\n        /// <param name=\"multed\"></param>\\n        private void runDFS(List<string> expressions, string path, string num, int target, int pos, long eval, long multed)\\n        {\\n            if (pos == num.Length)\\n            {\\n                if (target == eval)\\n                {\\n                    expressions.Add(path);\\n                }\\n\\n                return;\\n            }\\n\\n            for (int i = pos; i < num.Length; i++)\\n            {\\n                if (i != pos && num[pos] == \\'0\\')\\n                {\\n                    break;\\n                }\\n\\n                long operand = Convert.ToInt64(num.Substring(pos, i - pos + 1));\\n\\n                if (pos == 0)\\n                {\\n                    runDFS(expressions, path + operand, num, target, i + 1, operand, operand);\\n                }\\n                else\\n                {\\n                    runDFS(expressions, path + \"+\" + operand, num, target, i + 1, eval + operand, operand);\\n                    runDFS(expressions, path + \"-\" + operand, num, target, i + 1, eval - operand, -operand);\\n                    runDFS(expressions, path + \"*\" + operand, num, target, i + 1, eval - multed + multed * operand, multed * operand);\\n                }\\n            }\\n        }\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nusing System;\\nusing System.Collections.Generic;\\nusing System.Linq;\\nusing System.Text;\\nusing System.Threading.Tasks;\\n\\nnamespace _228_epxression_and_operator_B\\n{\\n    class Program\\n    {\\n        static void Main(string[] args)\\n        {\\n            var test = new Program();\\n            var result = test.AddOperators(\"123\", 6);\\n        }\\n\\n        public IList<string> AddOperators(string num, int target)\\n        {           \\n            if (num == null || num.Length == 0)\\n            {\\n                return new List<string>();\\n            }\\n\\n            var result = new List<string>();\\n\\n            runDFS(result, \"\", num, target, 0, 0, 0);\\n            return result;\\n        }\\n\\n        /// <summary>\\n        /// study code\\n        /// https://leetcode.com/problems/expression-add-operators/discuss/71895/Java-Standard-Backtrace-AC-Solutoin-short-and-clear\\n        /// </summary>\\n        /// <param name=\"expressions\"></param>\\n        /// <param name=\"path\"></param>\\n        /// <param name=\"num\"></param>\\n        /// <param name=\"target\"></param>\\n        /// <param name=\"pos\"></param>\\n        /// <param name=\"eval\"></param>\\n        /// <param name=\"multed\"></param>\\n        private void runDFS(List<string> expressions, string path, string num, int target, int pos, long eval, long multed)\\n        {\\n            if (pos == num.Length)\\n            {\\n                if (target == eval)\\n                {\\n                    expressions.Add(path);\\n                }\\n\\n                return;\\n            }\\n\\n            for (int i = pos; i < num.Length; i++)\\n            {\\n                if (i != pos && num[pos] == \\'0\\')\\n                {\\n                    break;\\n                }\\n\\n                long operand = Convert.ToInt64(num.Substring(pos, i - pos + 1));\\n\\n                if (pos == 0)\\n                {\\n                    runDFS(expressions, path + operand, num, target, i + 1, operand, operand);\\n                }\\n                else\\n                {\\n                    runDFS(expressions, path + \"+\" + operand, num, target, i + 1, eval + operand, operand);\\n                    runDFS(expressions, path + \"-\" + operand, num, target, i + 1, eval - operand, -operand);\\n                    runDFS(expressions, path + \"*\" + operand, num, target, i + 1, eval - multed + multed * operand, multed * operand);\\n                }\\n            }\\n        }\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1724667,
                "title": "python-backtracking",
                "content": "```\\nclass Solution:\\n    def addOperators(self, num: str, target: int) -> List[str]:\\n        \\n        # required = is there a leading 0 to the current expression?\\n        def backtracking(solution, pos, num, target, expression, required):\\n            if pos == len(num):\\n                S = 0\\n                operators = []\\n                for c in expression:\\n                    if not c.isnumeric():\\n                        operators.append(c)\\n                \\n                if len(operators) == 0:\\n                    if target == int(expression):\\n                        solution.append(expression)\\n                else:\\n                    oldExp = expression\\n                    for o in \"*+-\":\\n                        expression = expression.replace(o, \" \")\\n                    \\n                    values = expression.split()\\n                    j = len(values) - 1\\n                    k = len(operators) - 1\\n                    while j > 0: # and k >= 0:\\n                        if operators[k] == \\'+\\':\\n                            S += int(values[j])\\n                        elif operators[k] == \\'-\\':\\n                            S -= int(values[j])\\n                        else:\\n                            P = int(values[j])\\n                            k -= 1\\n                            j -= 1\\n                            while j > 0 and operators[k] == \\'*\\': # and k >= 0 :\\n                                P *= int(values[j])\\n                                j -= 1\\n                                k -= 1\\n                            P *= int(values[j])\\n                            if j == 0:\\n                                S += P\\n                            else:\\n                                if operators[k] == \\'-\\':\\n                                    S -= P\\n                                else:\\n                                    S += P\\n                        j -= 1\\n                        k -= 1\\n                    if j == 0:\\n                        S += int(values[0])\\n                    if S == target:\\n                        solution.append(oldExp)\\n            else:\\n                r = False\\n                if num[pos] == \\'0\\':\\n                    r = True\\n                \\n                if required == False:\\n                    backtracking(solution, pos + 1, num, target, expression + num[pos], False)\\n                backtracking(solution, pos + 1, num, target, expression + \\'+\\' + num[pos], r)\\n                backtracking(solution, pos + 1, num, target, expression + \\'-\\' + num[pos], r)\\n                backtracking(solution, pos + 1, num, target, expression + \\'*\\' + num[pos], r)\\n                \\n        \\n        solution = []\\n        if num[0] == \\'0\\':\\n            backtracking(solution, 1, num, target, num[0], True)\\n        else:\\n            backtracking(solution, 1, num, target, num[0], False)\\n        \\n        return solution\\n```",
                "solutionTags": [
                    "Python",
                    "Backtracking"
                ],
                "code": "```\\nclass Solution:\\n    def addOperators(self, num: str, target: int) -> List[str]:\\n        \\n        # required = is there a leading 0 to the current expression?\\n        def backtracking(solution, pos, num, target, expression, required):\\n            if pos == len(num):\\n                S = 0\\n                operators = []\\n                for c in expression:\\n                    if not c.isnumeric():\\n                        operators.append(c)\\n                \\n                if len(operators) == 0:\\n                    if target == int(expression):\\n                        solution.append(expression)\\n                else:\\n                    oldExp = expression\\n                    for o in \"*+-\":\\n                        expression = expression.replace(o, \" \")\\n                    \\n                    values = expression.split()\\n                    j = len(values) - 1\\n                    k = len(operators) - 1\\n                    while j > 0: # and k >= 0:\\n                        if operators[k] == \\'+\\':\\n                            S += int(values[j])\\n                        elif operators[k] == \\'-\\':\\n                            S -= int(values[j])\\n                        else:\\n                            P = int(values[j])\\n                            k -= 1\\n                            j -= 1\\n                            while j > 0 and operators[k] == \\'*\\': # and k >= 0 :\\n                                P *= int(values[j])\\n                                j -= 1\\n                                k -= 1\\n                            P *= int(values[j])\\n                            if j == 0:\\n                                S += P\\n                            else:\\n                                if operators[k] == \\'-\\':\\n                                    S -= P\\n                                else:\\n                                    S += P\\n                        j -= 1\\n                        k -= 1\\n                    if j == 0:\\n                        S += int(values[0])\\n                    if S == target:\\n                        solution.append(oldExp)\\n            else:\\n                r = False\\n                if num[pos] == \\'0\\':\\n                    r = True\\n                \\n                if required == False:\\n                    backtracking(solution, pos + 1, num, target, expression + num[pos], False)\\n                backtracking(solution, pos + 1, num, target, expression + \\'+\\' + num[pos], r)\\n                backtracking(solution, pos + 1, num, target, expression + \\'-\\' + num[pos], r)\\n                backtracking(solution, pos + 1, num, target, expression + \\'*\\' + num[pos], r)\\n                \\n        \\n        solution = []\\n        if num[0] == \\'0\\':\\n            backtracking(solution, 1, num, target, num[0], True)\\n        else:\\n            backtracking(solution, 1, num, target, num[0], False)\\n        \\n        return solution\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1714422,
                "title": "20-lines-ez-to-understand-python-solution-with-comments",
                "content": "```\\nclass Solution:\\n    def addOperators(self, num: str, target: int) -> List[str]:\\n        result = []\\n        self.add_helper(num, 0, \"\", 0, target, result, 0)\\n        return result\\n    \\n    def add_helper(self, num, cur_idx, candidate, value, target, result, last):\\n\\t    # add to result when proceeding the whole string and value equals to target\\n        if value == target and cur_idx == len(num):\\n            result.append(candidate)\\n            return\\n        \\n        # slice a number between current position to the end of string\\n        for i in range(cur_idx, len(num)):\\n            # if number is not a single digit 0 (0 at current index but have numbers in the following), just dont slice any more\\n            if num[cur_idx] == \"0\" and i != cur_idx:\\n                break\\n            cur_num = num[cur_idx : i + 1]\\n            \\n            # if it\\'s slicing number from beginning\\n            if cur_idx == 0:\\n                self.add_helper(num, i + 1, cur_num, value + int(cur_num), target, result, int(cur_num))\\n            else:\\n                # use last to record last number proceeded\\n                self.add_helper(num, i + 1, candidate + \"+\" + cur_num, value + int(cur_num), target, result, int(cur_num))\\n                self.add_helper(num, i + 1, candidate + \"-\" + cur_num, value - int(cur_num), target, result, -int(cur_num))                \\n                self.add_helper(num, i + 1, candidate + \"*\" + cur_num, value - last + last * int(cur_num), target, result, last * int(cur_num))\\n\\n        \\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def addOperators(self, num: str, target: int) -> List[str]:\\n        result = []\\n        self.add_helper(num, 0, \"\", 0, target, result, 0)\\n        return result\\n    \\n    def add_helper(self, num, cur_idx, candidate, value, target, result, last):\\n\\t    # add to result when proceeding the whole string and value equals to target\\n        if value == target and cur_idx == len(num):\\n            result.append(candidate)\\n            return\\n        \\n        # slice a number between current position to the end of string\\n        for i in range(cur_idx, len(num)):\\n            # if number is not a single digit 0 (0 at current index but have numbers in the following), just dont slice any more\\n            if num[cur_idx] == \"0\" and i != cur_idx:\\n                break\\n            cur_num = num[cur_idx : i + 1]\\n            \\n            # if it\\'s slicing number from beginning\\n            if cur_idx == 0:\\n                self.add_helper(num, i + 1, cur_num, value + int(cur_num), target, result, int(cur_num))\\n            else:\\n                # use last to record last number proceeded\\n                self.add_helper(num, i + 1, candidate + \"+\" + cur_num, value + int(cur_num), target, result, int(cur_num))\\n                self.add_helper(num, i + 1, candidate + \"-\" + cur_num, value - int(cur_num), target, result, -int(cur_num))                \\n                self.add_helper(num, i + 1, candidate + \"*\" + cur_num, value - last + last * int(cur_num), target, result, last * int(cur_num))\\n\\n        \\n```",
                "codeTag": "Java"
            },
            {
                "id": 1688637,
                "title": "python3-naive-way-backtrack-with-eval",
                "content": "```\\nclass Solution:\\n    def addOperators(self, num: str, target: int) -> List[str]:\\n        \\n        ans = []\\n        \\n        def backtrack(start, path):\\n            if len(path) == 1 and path == \"0\":\\n                return\\n            if len(path) >= 2 and path[-2:] in [\"+0\", \"-0\", \"*0\"]:\\n                return\\n            if start == len(num) - 1:\\n                if eval(path+num[-1]) == target:\\n                    ans.append(path+num[-1])\\n                return\\n            backtrack(start+1, path+num[start]+\"*\")\\n            backtrack(start+1, path+num[start]+\"+\")\\n            backtrack(start+1, path+num[start]+\"-\")\\n            backtrack(start+1, path+num[start])\\n\\n            \\n        backtrack(0, \"\")\\n        \\n        return ans\\n                \\n        \\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def addOperators(self, num: str, target: int) -> List[str]:\\n        \\n        ans = []\\n        \\n        def backtrack(start, path):\\n            if len(path) == 1 and path == \"0\":\\n                return\\n            if len(path) >= 2 and path[-2:] in [\"+0\", \"-0\", \"*0\"]:\\n                return\\n            if start == len(num) - 1:\\n                if eval(path+num[-1]) == target:\\n                    ans.append(path+num[-1])\\n                return\\n            backtrack(start+1, path+num[start]+\"*\")\\n            backtrack(start+1, path+num[start]+\"+\")\\n            backtrack(start+1, path+num[start]+\"-\")\\n            backtrack(start+1, path+num[start])\\n\\n            \\n        backtrack(0, \"\")\\n        \\n        return ans\\n                \\n        \\n```",
                "codeTag": "Java"
            },
            {
                "id": 1685789,
                "title": "python-straightforward-w-explanation",
                "content": "This problem involves some basic recursion however the challenge arises from following order of operations. For instance, take the following expression: `4 + 2 * 5`. The way our program would calculate without following order of ops would be: `4 + 2 * 5 = 6 * 5 = 30` which is obviously wrong. \\n\\nWhat we need to do when we see a multiplication is reverse our previous operation and then do the multiplication. For instance, `4 + 2 * 5 => 6 * 5 => (6 - 2) + 2 * 5 = 14`. What we did is keep track of the previous number that would help us reverse the previous operation. When we subtract that number from the current result, we get the value of the previous expression and then we can simply add the product. \\n\\nIn the above example, at the multiplication step, the previous value was `2`. When `2` was subtracted from the current sum of `6`, we got our previous sum of `4` to which we could add `2 * 5`. If the expression to evaluate were instead `4 - 2 * 5`, we would store `-2` as our previous value as that would allow us to reverse the subtraction: `4 - 2 * 5 => 2 * 5 => (2 - -2) + -2 * 5 = -6`.\\n\\nIf the expression were `4 * 2 * 5`, we would just store the current number times the previous number: `4 * 2 * 5 = 8 * 5 = 40`.\\n\\nTo skip leading zeroes, we check if the first digit at the current index is a 0 and if so, we can stop after the first iteration of the loop.\\n\\n```\\nclass Solution:\\n    def addOperators(self, num: str, target: int) -> List[str]:\\n        res = []\\n        \\n        def recurse(curIdx=0, curExpr=[], curSum=0, prevNum=0):\\n            if curIdx >= len(num):\\n                if curSum == target:\\n                    res.append(\\'\\'.join(curExpr))\\n                return\\n            \\n            for i in range(curIdx, len(num)):\\n                curNum = int(num[curIdx:i+1])\\n                if not curExpr:\\n                    recurse(i + 1, [str(curNum)], curNum, curNum)\\n                else:\\n                    recurse(i + 1, [*curExpr, \\'+\\', str(curNum)], curSum + curNum, curNum)\\n                    recurse(i + 1, [*curExpr, \\'-\\', str(curNum)], curSum - curNum, -curNum)\\n                    \\n                    prevSum = curSum - prevNum\\n                    recurse(i + 1, [*curExpr, \\'*\\', str(curNum)], \\n                            prevSum + curNum * prevNum, curNum * prevNum)\\n                \\n                if num[curIdx] == \\'0\\':\\n                    break\\n        \\n        recurse()\\n        return res",
                "solutionTags": [
                    "Python",
                    "Backtracking",
                    "Depth-First Search",
                    "Recursion"
                ],
                "code": "This problem involves some basic recursion however the challenge arises from following order of operations. For instance, take the following expression: `4 + 2 * 5`. The way our program would calculate without following order of ops would be: `4 + 2 * 5 = 6 * 5 = 30` which is obviously wrong. \\n\\nWhat we need to do when we see a multiplication is reverse our previous operation and then do the multiplication. For instance, `4 + 2 * 5 => 6 * 5 => (6 - 2) + 2 * 5 = 14`. What we did is keep track of the previous number that would help us reverse the previous operation. When we subtract that number from the current result, we get the value of the previous expression and then we can simply add the product. \\n\\nIn the above example, at the multiplication step, the previous value was `2`. When `2` was subtracted from the current sum of `6`, we got our previous sum of `4` to which we could add `2 * 5`. If the expression to evaluate were instead `4 - 2 * 5`, we would store `-2` as our previous value as that would allow us to reverse the subtraction: `4 - 2 * 5 => 2 * 5 => (2 - -2) + -2 * 5 = -6`.\\n\\nIf the expression were `4 * 2 * 5`, we would just store the current number times the previous number: `4 * 2 * 5 = 8 * 5 = 40`.\\n\\nTo skip leading zeroes, we check if the first digit at the current index is a 0 and if so, we can stop after the first iteration of the loop.\\n\\n```\\nclass Solution:\\n    def addOperators(self, num: str, target: int) -> List[str]:\\n        res = []\\n        \\n        def recurse(curIdx=0, curExpr=[], curSum=0, prevNum=0):\\n            if curIdx >= len(num):\\n                if curSum == target:\\n                    res.append(\\'\\'.join(curExpr))\\n                return\\n            \\n            for i in range(curIdx, len(num)):\\n                curNum = int(num[curIdx:i+1])\\n                if not curExpr:\\n                    recurse(i + 1, [str(curNum)], curNum, curNum)\\n                else:\\n                    recurse(i + 1, [*curExpr, \\'+\\', str(curNum)], curSum + curNum, curNum)\\n                    recurse(i + 1, [*curExpr, \\'-\\', str(curNum)], curSum - curNum, -curNum)\\n                    \\n                    prevSum = curSum - prevNum\\n                    recurse(i + 1, [*curExpr, \\'*\\', str(curNum)], \\n                            prevSum + curNum * prevNum, curNum * prevNum)\\n                \\n                if num[curIdx] == \\'0\\':\\n                    break\\n        \\n        recurse()\\n        return res",
                "codeTag": "Java"
            },
            {
                "id": 1621590,
                "title": "python-backtracking",
                "content": "* at every digit, we have an option of either adding it to the prev no, or use it with some operand\\n* in total we have 4 different operations which we have to accomplish, +, - , * and adding cur digit to prev digit\\n```\\n def addOperators(self, num: \\'str\\', target: \\'int\\') -> \\'List[str]\\':\\n        N = len(num)\\n        answers = []\\n        def recurse(idx, prev, cur, value, path):\\n            if idx == N:\\n                if value == target and cur == 0:\\n                    answers.append(\"\".join(path[1:]))\\n                return\\n            cur = cur*10 + int(num[idx])\\n            str_op = str(cur)\\n            if cur > 0:\\n\\t\\t\\t\\t# Add nothing to path, since added digit to cur\\n                recurse(idx + 1, prev, cur, value, path)\\n\\t\\t\\t# Perform addition \\n            recurse(idx + 1, cur, 0, value + cur, path +[\"+\", str_op])\\n\\t\\t\\t# can only perform subtraction, multiplication when our path not empty\\n            if path:\\n\\t\\t\\t\\t# Perform subtraction \\n                recurse(idx + 1, -cur, 0, value - cur, path +[\\'-\\', str_op])\\n\\t\\t\\t\\t# Perform multiplication\\n                recurse(idx + 1, cur * prev, 0, value - prev + (cur * prev), path +[\\'*\\', str_op])\\n                \\n        recurse(0, 0, 0, 0, [])    \\n        return answers\\n```",
                "solutionTags": [
                    "Backtracking"
                ],
                "code": "```\\n def addOperators(self, num: \\'str\\', target: \\'int\\') -> \\'List[str]\\':\\n        N = len(num)\\n        answers = []\\n        def recurse(idx, prev, cur, value, path):\\n            if idx == N:\\n                if value == target and cur == 0:\\n                    answers.append(\"\".join(path[1:]))\\n                return\\n            cur = cur*10 + int(num[idx])\\n            str_op = str(cur)\\n            if cur > 0:\\n\\t\\t\\t\\t# Add nothing to path, since added digit to cur\\n                recurse(idx + 1, prev, cur, value, path)\\n\\t\\t\\t# Perform addition \\n            recurse(idx + 1, cur, 0, value + cur, path +[\"+\", str_op])\\n\\t\\t\\t# can only perform subtraction, multiplication when our path not empty\\n            if path:\\n\\t\\t\\t\\t# Perform subtraction \\n                recurse(idx + 1, -cur, 0, value - cur, path +[\\'-\\', str_op])\\n\\t\\t\\t\\t# Perform multiplication\\n                recurse(idx + 1, cur * prev, 0, value - prev + (cur * prev), path +[\\'*\\', str_op])\\n                \\n        recurse(0, 0, 0, 0, [])    \\n        return answers\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 1611458,
                "title": "javascript-clean-concise-code-backtracking",
                "content": "```\\nvar addOperators = function(num, target) {\\n    let ans = [];\\n    \\n    const backtracking = (index, left, right, string) => {\\n        if (index === num.length) {\\n            if (left + right === target)\\n                ans.push(string); \\n            return;\\n        }\\n\\n        let val = 0;\\n        for (let i = index; i < num.length; i++) {\\n            val = val * 10 + Number(num[i]);\\n            backtracking(i + 1, left + right, val, string + \"+\" + val);\\n            backtracking(i + 1, left + right, -val, string + \"-\" + val);\\n            backtracking(i + 1, left, right * val, string + \"*\" + val);\\n            if (num[index] === \"0\")\\n                break;\\n        }  \\n    };\\n\\n    let val = 0;\\n    for (let i = 0; i < num.length; i++) {\\n        val = val * 10 + Number(num[i]);\\n        backtracking(i + 1, 0, val, val.toString());\\n        if (num[0] === \"0\")\\n            break;\\n    }\\n    \\n    return ans;\\n};\\n\\n```",
                "solutionTags": [],
                "code": "```\\nvar addOperators = function(num, target) {\\n    let ans = [];\\n    \\n    const backtracking = (index, left, right, string) => {\\n        if (index === num.length) {\\n            if (left + right === target)\\n                ans.push(string); \\n            return;\\n        }\\n\\n        let val = 0;\\n        for (let i = index; i < num.length; i++) {\\n            val = val * 10 + Number(num[i]);\\n            backtracking(i + 1, left + right, val, string + \"+\" + val);\\n            backtracking(i + 1, left + right, -val, string + \"-\" + val);\\n            backtracking(i + 1, left, right * val, string + \"*\" + val);\\n            if (num[index] === \"0\")\\n                break;\\n        }  \\n    };\\n\\n    let val = 0;\\n    for (let i = 0; i < num.length; i++) {\\n        val = val * 10 + Number(num[i]);\\n        backtracking(i + 1, 0, val, val.toString());\\n        if (num[0] === \"0\")\\n            break;\\n    }\\n    \\n    return ans;\\n};\\n\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1596238,
                "title": "clean-commented-dfs-python-beats-98-time-78-memory",
                "content": "# Initially\\n0th index, prev is 0, val is 0 and expression string is empty\\nAt each step:-\\n## Addition\\ncur become prev, \\nadd cur to sum, \\nadd info to expression\\n## Subtraction\\n-cur become prev,\\nsubtract cur from sum,\\nadd info to expression \\n## Multiplication\\ncur\\\\*prev becomes prev,\\nsubtract prev from sum(to undo what was done by adding prev) & add cur*prev,\\nadd info to expression \\n```\\nclass Solution:\\n    def addOperators(self, num: str, target: int) -> List[str]:\\n        n = len(num)\\n        ans = []\\n        \\n        def dfs(start,prev_operand,expr_val,expr_str):\\n            if start==n:\\n                if expr_val==target:\\n                    ans.append(expr_str[1:]) # remove + sign at start\\n                return\\n            \\n            # To handle leading zeros condition\\n            endPtr = n+1 if num[start]!=\\'0\\' else start+2\\n            \\n            for end in range(start+1,endPtr):\\n                cur_operand_str = num[start:end]\\n                cur_operand = int(cur_operand_str)\\n                dfs(end,cur_operand,expr_val+cur_operand,expr_str+\\'+\\'+cur_operand_str) # addition\\n                if expr_str: # sub & mult only possible if previous operand\\n                    dfs(end,-cur_operand,expr_val-cur_operand,expr_str+\\'-\\'+cur_operand_str) # subtraction\\n                    product = cur_operand*prev_operand\\n                    dfs(end,product,expr_val-prev_operand+product, expr_str+\\'*\\'+cur_operand_str) # multiplication\\n        \\n        dfs(0,0,0,\\'\\' )\\n        return ans\\n            \\n```",
                "solutionTags": [
                    "Python",
                    "Depth-First Search"
                ],
                "code": "```\\nclass Solution:\\n    def addOperators(self, num: str, target: int) -> List[str]:\\n        n = len(num)\\n        ans = []\\n        \\n        def dfs(start,prev_operand,expr_val,expr_str):\\n            if start==n:\\n                if expr_val==target:\\n                    ans.append(expr_str[1:]) # remove + sign at start\\n                return\\n            \\n            # To handle leading zeros condition\\n            endPtr = n+1 if num[start]!=\\'0\\' else start+2\\n            \\n            for end in range(start+1,endPtr):\\n                cur_operand_str = num[start:end]\\n                cur_operand = int(cur_operand_str)\\n                dfs(end,cur_operand,expr_val+cur_operand,expr_str+\\'+\\'+cur_operand_str) # addition\\n                if expr_str: # sub & mult only possible if previous operand\\n                    dfs(end,-cur_operand,expr_val-cur_operand,expr_str+\\'-\\'+cur_operand_str) # subtraction\\n                    product = cur_operand*prev_operand\\n                    dfs(end,product,expr_val-prev_operand+product, expr_str+\\'*\\'+cur_operand_str) # multiplication\\n        \\n        dfs(0,0,0,\\'\\' )\\n        return ans\\n            \\n```",
                "codeTag": "Java"
            },
            {
                "id": 1579560,
                "title": "simple-c-recursive-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    void solve(vector<string> &ans,string currstr,string input,int t,int pos,long long currval,long long last)\\n    {\\n        if(pos==input.length())\\n        {\\n            if(currval==t)\\n                ans.push_back(currstr);\\n            return;\\n        }\\n        for(int i=pos;i<input.length();i++)\\n        {\\n            if(pos!=i && input[pos]==\\'0\\')\\n                break;\\n            string part=input.substr(pos,i+1-pos);\\n            long long curr=stoll(part);\\n            if(pos==0)\\n            {\\n                solve(ans,currstr+part,input,t,i+1,curr,curr);\\n            }\\n            else\\n            {\\n                solve(ans,currstr+\"+\"+part,input,t,i+1,currval+curr,curr);\\n                solve(ans,currstr+\"-\"+part,input,t,i+1,currval-curr,-curr);\\n                solve(ans,currstr+\"*\"+part,input,t,i+1,currval-last+last*curr,last*curr);\\n            }\\n        }\\n    }\\n    vector<string> addOperators(string num, int t) {\\n        vector<string> ans;\\n        solve(ans,\"\",num,t,0,0,0);\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    void solve(vector<string> &ans,string currstr,string input,int t,int pos,long long currval,long long last)\\n    {\\n        if(pos==input.length())\\n        {\\n            if(currval==t)\\n                ans.push_back(currstr);\\n            return;\\n        }\\n        for(int i=pos;i<input.length();i++)\\n        {\\n            if(pos!=i && input[pos]==\\'0\\')\\n                break;\\n            string part=input.substr(pos,i+1-pos);\\n            long long curr=stoll(part);\\n            if(pos==0)\\n            {\\n                solve(ans,currstr+part,input,t,i+1,curr,curr);\\n            }\\n            else\\n            {\\n                solve(ans,currstr+\"+\"+part,input,t,i+1,currval+curr,curr);\\n                solve(ans,currstr+\"-\"+part,input,t,i+1,currval-curr,-curr);\\n                solve(ans,currstr+\"*\"+part,input,t,i+1,currval-last+last*curr,last*curr);\\n            }\\n        }\\n    }\\n    vector<string> addOperators(string num, int t) {\\n        vector<string> ans;\\n        solve(ans,\"\",num,t,0,0,0);\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1553905,
                "title": "c-dfs-easy-to-understand",
                "content": "Got the idea for calculating the value on the fly from \\nhttps://leetcode.com/problems/expression-add-operators/discuss/441680/Accepted-C-backtracking-solution%3A-Easy-to-understand-w-comments-fast-93.14-memory-100\\n\\n```\\npublic class Solution \\n{\\n    List<char> ops;\\n    IList<string> lst;\\n    \\n    public IList<string> AddOperators(string num, int target) \\n    {\\n        ops = new List<char>();\\n        lst = new List<string>();\\n        ops.Add(\\'+\\');\\n        ops.Add(\\'-\\');\\n        ops.Add(\\'*\\');\\n        dfs(num, 0, \"\", 0, 0, target);\\n        return lst;\\n    }\\n    \\n    public void dfs(string s, int index, string calc, long prev, long sofar, int target)\\n    {\\n        if(index == s.Length)\\n        {\\n            if(sofar == target)\\n                lst.Add(calc);\\n            \\n            return;\\n        }\\n        \\n        int count = 1;\\n        for(int i = index; i < s.Length; i++)\\n        {\\n            var nextindex = index + count;\\n            var cur = s.Substring(index, count);\\n            \\n            if(cur.Length > 1 && cur[0] == \\'0\\')\\n                continue;\\n            \\n            var curnum = Convert.ToInt64(cur);\\n            \\n            if(index == 0)\\n            {\\n                dfs(s, nextindex, cur, curnum, curnum, target);\\n            }\\n            else\\n            {\\n                foreach(var op in ops)\\n                {\\n                    if(op == \\'*\\')\\n                        dfs(s, nextindex, calc + \"*\" + cur, curnum*prev, ((sofar - prev) + prev * curnum), target);\\n                    else if(op == \\'+\\')\\n                        dfs(s, nextindex, calc + \"+\" + cur, curnum, sofar + curnum, target);\\n                    else if(op == \\'-\\')\\n                        dfs(s, nextindex, calc + \"-\" + cur, -curnum, sofar - curnum, target);\\n                } \\n            }\\n            \\n            count++;\\n        }\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\npublic class Solution \\n{\\n    List<char> ops;\\n    IList<string> lst;\\n    \\n    public IList<string> AddOperators(string num, int target) \\n    {\\n        ops = new List<char>();\\n        lst = new List<string>();\\n        ops.Add(\\'+\\');\\n        ops.Add(\\'-\\');\\n        ops.Add(\\'*\\');\\n        dfs(num, 0, \"\", 0, 0, target);\\n        return lst;\\n    }\\n    \\n    public void dfs(string s, int index, string calc, long prev, long sofar, int target)\\n    {\\n        if(index == s.Length)\\n        {\\n            if(sofar == target)\\n                lst.Add(calc);\\n            \\n            return;\\n        }\\n        \\n        int count = 1;\\n        for(int i = index; i < s.Length; i++)\\n        {\\n            var nextindex = index + count;\\n            var cur = s.Substring(index, count);\\n            \\n            if(cur.Length > 1 && cur[0] == \\'0\\')\\n                continue;\\n            \\n            var curnum = Convert.ToInt64(cur);\\n            \\n            if(index == 0)\\n            {\\n                dfs(s, nextindex, cur, curnum, curnum, target);\\n            }\\n            else\\n            {\\n                foreach(var op in ops)\\n                {\\n                    if(op == \\'*\\')\\n                        dfs(s, nextindex, calc + \"*\" + cur, curnum*prev, ((sofar - prev) + prev * curnum), target);\\n                    else if(op == \\'+\\')\\n                        dfs(s, nextindex, calc + \"+\" + cur, curnum, sofar + curnum, target);\\n                    else if(op == \\'-\\')\\n                        dfs(s, nextindex, calc + \"-\" + cur, -curnum, sofar - curnum, target);\\n                } \\n            }\\n            \\n            count++;\\n        }\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1539532,
                "title": "python-using-eval",
                "content": "```\\nclass Solution:\\n    def addOperators(self, num: str, target: int) -> List[str]:\\n    \\n        def backtrack(index,stack):\\n            \\n            if index == len(num)-1:\\n                stack.append(num[index])\\n                expres = \"\".join(stack[:])\\n                if eval(expres) == target:\\n                    out.append(expres)\\n                return\\n            \\n            leadZero = False\\n            \\n            if not (stack and stack[-1].isdigit()) and num[index] == \\'0\\':\\n                \\n                leadZero = True\\n                \\n            stack.append(num[index])\\n            \\n            for op in [\"+\",\"-\",\"*\"]:\\n                stack.append(op)  \\n                backtrack(index+1,stack[:])\\n                stack.pop()\\n            \\n            if not leadZero:\\n                \\n                backtrack(index+1,stack[:])\\n        \\n        out = []\\n        \\n        backtrack(0,[])\\n        \\n        return out\\n```",
                "solutionTags": [
                    "Python",
                    "Backtracking"
                ],
                "code": "```\\nclass Solution:\\n    def addOperators(self, num: str, target: int) -> List[str]:\\n    \\n        def backtrack(index,stack):\\n            \\n            if index == len(num)-1:\\n                stack.append(num[index])\\n                expres = \"\".join(stack[:])\\n                if eval(expres) == target:\\n                    out.append(expres)\\n                return\\n            \\n            leadZero = False\\n            \\n            if not (stack and stack[-1].isdigit()) and num[index] == \\'0\\':\\n                \\n                leadZero = True\\n                \\n            stack.append(num[index])\\n            \\n            for op in [\"+\",\"-\",\"*\"]:\\n                stack.append(op)  \\n                backtrack(index+1,stack[:])\\n                stack.pop()\\n            \\n            if not leadZero:\\n                \\n                backtrack(index+1,stack[:])\\n        \\n        out = []\\n        \\n        backtrack(0,[])\\n        \\n        return out\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1498795,
                "title": "js-simple-dfs",
                "content": "```\\nvar addOperators = function(num, target) {\\n    const res = [];\\n    \\n    const dfs = (pos, exp, result, prevNum) => {\\n        \\n        if(pos >= num.length) {\\n            if (result == target) {\\n                res.push(exp);\\n            }\\n            return;\\n        }\\n        for(let i=pos;i<num.length;i++) {\\n            if (i > pos &&  num[pos] == \\'0\\') break;\\n            const n = parseInt(num.substring(pos, i+1));\\n            if (pos == 0) {\\n                dfs(i+1, n+\"\", n, n);\\n            } else {\\n                dfs(i+1, exp+\\'+\\'+n, result+n, n);\\n                dfs(i+1, exp+\\'-\\'+n, result-n, -n);\\n                dfs(i+1, exp+\\'*\\'+n, result-prevNum+prevNum *n  , prevNum * n);\\n                \\n            }\\n        }\\n    }\\n    \\n    dfs(0, \\'\\', 0, 0);\\n       \\n    return res;\\n      \\n};\\n```",
                "solutionTags": [],
                "code": "```\\nvar addOperators = function(num, target) {\\n    const res = [];\\n    \\n    const dfs = (pos, exp, result, prevNum) => {\\n        \\n        if(pos >= num.length) {\\n            if (result == target) {\\n                res.push(exp);\\n            }\\n            return;\\n        }\\n        for(let i=pos;i<num.length;i++) {\\n            if (i > pos &&  num[pos] == \\'0\\') break;\\n            const n = parseInt(num.substring(pos, i+1));\\n            if (pos == 0) {\\n                dfs(i+1, n+\"\", n, n);\\n            } else {\\n                dfs(i+1, exp+\\'+\\'+n, result+n, n);\\n                dfs(i+1, exp+\\'-\\'+n, result-n, -n);\\n                dfs(i+1, exp+\\'*\\'+n, result-prevNum+prevNum *n  , prevNum * n);\\n                \\n            }\\n        }\\n    }\\n    \\n    dfs(0, \\'\\', 0, 0);\\n       \\n    return res;\\n      \\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1479596,
                "title": "javascript-dfs-116ms-89-74",
                "content": "```\\nlet s, n, t;\\nconst addOperators = (num, target) => {\\n    s = num, n = s.length, t = target;\\n    let res = [];\\n    dfs(0, \\'\\', 0, 0, res);\\n    return res;\\n};\\n\\nconst dfs = (pos, exp, pre, cur, res) => {\\n    if (pos == n) {\\n        if (cur == t) return res.push(exp);\\n    }\\n    for (let i = 1; i <= n - pos; i++) {\\n        let tmp = s.substr(pos, i);\\n        if (tmp[0] == \\'0\\' && tmp.length > 1) break;\\n        let x = tmp - \\'0\\';\\n        if (pos == 0) {\\n            dfs(i, tmp, x, x, res);\\n            continue;\\n        }\\n        dfs(pos + i, exp + \\'+\\' + tmp, x, cur + x, res);\\n        dfs(pos + i, exp + \\'-\\' + tmp, -x, cur - x, res);\\n        dfs(pos + i, exp + \\'*\\' + tmp, pre * x, cur - pre + pre * x, res);\\n    }\\n};\\n```",
                "solutionTags": [
                    "JavaScript",
                    "Backtracking",
                    "Depth-First Search"
                ],
                "code": "```\\nlet s, n, t;\\nconst addOperators = (num, target) => {\\n    s = num, n = s.length, t = target;\\n    let res = [];\\n    dfs(0, \\'\\', 0, 0, res);\\n    return res;\\n};\\n\\nconst dfs = (pos, exp, pre, cur, res) => {\\n    if (pos == n) {\\n        if (cur == t) return res.push(exp);\\n    }\\n    for (let i = 1; i <= n - pos; i++) {\\n        let tmp = s.substr(pos, i);\\n        if (tmp[0] == \\'0\\' && tmp.length > 1) break;\\n        let x = tmp - \\'0\\';\\n        if (pos == 0) {\\n            dfs(i, tmp, x, x, res);\\n            continue;\\n        }\\n        dfs(pos + i, exp + \\'+\\' + tmp, x, cur + x, res);\\n        dfs(pos + i, exp + \\'-\\' + tmp, -x, cur - x, res);\\n        dfs(pos + i, exp + \\'*\\' + tmp, pre * x, cur - pre + pre * x, res);\\n    }\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1479092,
                "title": "python-iterative-solution-beats-96",
                "content": "There are plenty of recursive solutions, but I found an iterative approach to be quite intuitive as well.\\n\\n1. Iterate over each digit\\n2. Maintain a list of all possible states from the previous digit\\n3. Create a list of all possible states after using this digit\\n\\t4. Concatenate the digits together (\"...12\")\\n\\t5. Addition (\"...1+2\")\\n\\t6. Subtraction (\"...1-2\")\\n\\t7. Multiplication (\"...1*2)\\n\\nOur state has 4 components\\n\\n1. Digits since the last operation (123 in \"9-99+123...\" or -123 in \"9-99-123...\")\\n2. Multiplier since the last +/- (value 6 in \"9-99+1\\\\*2\\\\*3...\")\\n3. Sum up to the previous +/- (value -90 in \"9-99+1\\\\*2\\\\*3...\")\\n4. String representation (\"9-99+123\")\\n\\nFor some reason this solution exceeds the time limit with C++, but beats 96% with Python. I guess recursion is just that inefficient with Python?\\n\\n```py\\nclass Solution:\\n    def addOperators(self, num: str, target: int) -> List[str]:\\n        # digits since last +/-/*, multiplier, sum up to previous +/-, string representation\\n        states = [(int(num[0]), 1, 0, num[0])]\\n        \\n        for d in num[1:]:\\n            d = int(d)\\n            next_states = []\\n            \\n            for last_digits, multiplier, sum_before, s in states:\\n                # concatenate with last_digits\\n                if last_digits > 0:\\n                    next_states.append((last_digits*10+d, multiplier, sum_before, f\"{s}{d}\"))\\n                elif last_digits < 0:\\n                    next_states.append((last_digits*10-d, multiplier, sum_before, f\"{s}{d}\"))\\n\\t\\t\\t\\t# ignore 0 to avoid leading zeros\\n                    \\n                # addition sign\\n                next_states.append((d, 1, sum_before+last_digits*multiplier, f\"{s}+{d}\"))\\n                # subtraction sign\\n                next_states.append((-d, 1, sum_before+last_digits*multiplier, f\"{s}-{d}\"))\\n                # multiplication sign\\n                next_states.append((d, last_digits*multiplier, sum_before, f\"{s}*{d}\"))\\n                \\n            states = next_states\\n\\n        result = []\\n        for last_digits, multiplier, sum_before, s in states:\\n            val = sum_before + multiplier * last_digits\\n            if val == target:\\n                result.append(s)\\n\\n        return result\\n```",
                "solutionTags": [],
                "code": "```py\\nclass Solution:\\n    def addOperators(self, num: str, target: int) -> List[str]:\\n        # digits since last +/-/*, multiplier, sum up to previous +/-, string representation\\n        states = [(int(num[0]), 1, 0, num[0])]\\n        \\n        for d in num[1:]:\\n            d = int(d)\\n            next_states = []\\n            \\n            for last_digits, multiplier, sum_before, s in states:\\n                # concatenate with last_digits\\n                if last_digits > 0:\\n                    next_states.append((last_digits*10+d, multiplier, sum_before, f\"{s}{d}\"))\\n                elif last_digits < 0:\\n                    next_states.append((last_digits*10-d, multiplier, sum_before, f\"{s}{d}\"))\\n\\t\\t\\t\\t# ignore 0 to avoid leading zeros\\n                    \\n                # addition sign\\n                next_states.append((d, 1, sum_before+last_digits*multiplier, f\"{s}+{d}\"))\\n                # subtraction sign\\n                next_states.append((-d, 1, sum_before+last_digits*multiplier, f\"{s}-{d}\"))\\n                # multiplication sign\\n                next_states.append((d, last_digits*multiplier, sum_before, f\"{s}*{d}\"))\\n                \\n            states = next_states\\n\\n        result = []\\n        for last_digits, multiplier, sum_before, s in states:\\n            val = sum_before + multiplier * last_digits\\n            if val == target:\\n                result.append(s)\\n\\n        return result\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1475043,
                "title": "c-282-expression-add-operators",
                "content": "\\n```\\nclass Solution {\\npublic:\\n    vector<string> addOperators(string num, int target) {\\n        int n = num.size(); \\n        vector<string> ans; \\n        \\n        function<void(int, long, long, string)> fn = [&](int i, long total, long last, string expr) {\\n            if (i == n) {\\n                if (total == target) ans.push_back(expr); \\n            } else {\\n                for (int ii = i; ii < (num[i] == \\'0\\' ? i+1 : n); ++ii) {\\n                    string ss = num.substr(i, ii-i+1); \\n                    long val = stol(ss); \\n                    if (i == 0) fn(ii+1, val, val, ss); \\n                    else {\\n                        fn(ii+1, total - last + last * val, last * val, expr + \"*\" + ss); \\n                        fn(ii+1, total + val, val, expr + \"+\" + ss); \\n                        fn(ii+1, total - val, -val, expr + \"-\" + ss); \\n                    }\\n                }\\n            }\\n        }; \\n        \\n        fn(0, 0, 0, \"\"); \\n        return ans; \\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<string> addOperators(string num, int target) {\\n        int n = num.size(); \\n        vector<string> ans; \\n        \\n        function<void(int, long, long, string)> fn = [&](int i, long total, long last, string expr) {\\n            if (i == n) {\\n                if (total == target) ans.push_back(expr); \\n            } else {\\n                for (int ii = i; ii < (num[i] == \\'0\\' ? i+1 : n); ++ii) {\\n                    string ss = num.substr(i, ii-i+1); \\n                    long val = stol(ss); \\n                    if (i == 0) fn(ii+1, val, val, ss); \\n                    else {\\n                        fn(ii+1, total - last + last * val, last * val, expr + \"*\" + ss); \\n                        fn(ii+1, total + val, val, expr + \"+\" + ss); \\n                        fn(ii+1, total - val, -val, expr + \"-\" + ss); \\n                    }\\n                }\\n            }\\n        }; \\n        \\n        fn(0, 0, 0, \"\"); \\n        return ans; \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1474313,
                "title": "python3-recursion",
                "content": "```\\nclass Solution:\\n    \\n    def solve(self, i, cur):\\n        if i == self.n:\\n            if eval(cur) == self.v:\\n                self.ans.append(cur)\\n            return\\n        if self.s[i] == \\'0\\':    # No leading zeros\\n            if i == self.n-1:\\n                self.solve(i+1, cur + \"0\")\\n            else:\\n                self.solve(i+1, cur + \"0*\")\\n                self.solve(i+1, cur + \"0+\")\\n                self.solve(i+1, cur + \"0-\")\\n            return\\n        s = \"\"\\n        for j in range(i, self.n - 1):\\n            s += self.s[j]\\n            self.solve(j+1, cur + s + \"*\")\\n            self.solve(j+1, cur + s + \"+\")\\n            self.solve(j+1, cur + s + \"-\")\\n        if self.s[i] != \\'0\\':\\n            self.solve(self.n, cur + self.s[i:])\\n        \\n    def addOperators(self, s: str, v: int) -> List[str]:\\n        self.v = v\\n        self.s = s\\n        self.n = len(s)\\n        self.ans = []\\n        self.solve(0, \"\")\\n        # print(self.ans)\\n        return self.ans\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    \\n    def solve(self, i, cur):\\n        if i == self.n:\\n            if eval(cur) == self.v:\\n                self.ans.append(cur)\\n            return\\n        if self.s[i] == \\'0\\':    # No leading zeros\\n            if i == self.n-1:\\n                self.solve(i+1, cur + \"0\")\\n            else:\\n                self.solve(i+1, cur + \"0*\")\\n                self.solve(i+1, cur + \"0+\")\\n                self.solve(i+1, cur + \"0-\")\\n            return\\n        s = \"\"\\n        for j in range(i, self.n - 1):\\n            s += self.s[j]\\n            self.solve(j+1, cur + s + \"*\")\\n            self.solve(j+1, cur + s + \"+\")\\n            self.solve(j+1, cur + s + \"-\")\\n        if self.s[i] != \\'0\\':\\n            self.solve(self.n, cur + self.s[i:])\\n        \\n    def addOperators(self, s: str, v: int) -> List[str]:\\n        self.v = v\\n        self.s = s\\n        self.n = len(s)\\n        self.ans = []\\n        self.solve(0, \"\")\\n        # print(self.ans)\\n        return self.ans\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1473865,
                "title": "java-easy-to-understand-solution-with-comments",
                "content": "Tried to explain all the cases and situations, let me know if anything is unclear or wrong. Hope it helps! :) \\n\\n```\\nclass Solution {\\n    String num;\\n    int len;\\n    List<String> ans;\\n    int target;\\n    \\n    public void dfs_helper(String build, long prev_no, long total, int pos){\\n        if(pos == len)\\n        {\\n            if(total == target)\\n                ans.add(build);\\n            return;\\n        }\\n        for(int i = pos;i<len;i++)\\n        {\\n            if(i>pos && num.charAt(pos) == \\'0\\')\\n                break; // needed to avoid cases like 00* (leading 0\\'s)\\n            // if you dont do this lets take an example\\n            // 105\\n            // 1 is added, string build = 1 and then we are at 0, i.e, pos == 1\\n            // if we go to i = 2 for pos and implement without this\\n            // we will get 1*5 as an answer which is wrong, as curr_num will be parsed as 5!\\n            // \"05\" will be 5!\\n            long curr_num = Long.parseLong(num.substring(pos,i+1)); // get the number\\n            if(pos == 0)\\n            {\\n                // have to add the 1st number to start the recursion.\\n                String to_send = build+curr_num;\\n                dfs_helper(to_send,curr_num,curr_num,i+1);\\n            }\\n            else\\n            {\\n                String to_send = build+\"+\"+curr_num;\\n                long t = total+curr_num;\\n                dfs_helper(to_send,curr_num,t,i+1);\\n                \\n                to_send = build+\"-\"+curr_num;\\n                t = total-curr_num;\\n                dfs_helper(to_send,(-1)*curr_num,t,i+1);\\n                // add and subtract are simple cases\\n                to_send = build+\"*\"+curr_num;\\n                t = total-prev_no+prev_no*curr_num;\\n                dfs_helper(to_send,curr_num*prev_no,t,i+1);\\n                // this is a tricky one lets say you have 1+2*3-5\\n                // if you do 2*3 then effective current number is 6 (consider it as 6 and pass it on)\\n                // to calculate the value now (total val) undo the effect of previous op by total-prev_no\\n                // and add the new evaluated val [prev_no*curr_num]\\n            }\\n        }\\n    }\\n    \\n    public List<String> addOperators(String num, int target) {\\n        /**\\n        Inputs that are req. for rec fn:\\n        a) string so far: 1+2*3\\n        b) prev number: 1+2*3 ==> prev number for next call from 3 will be 3\\n        c) value till that point: 1+2*3 ==> val till that point will be 7 [long]\\n        d) return list which will have the final output [make this global]\\n        e) postion pointer\\n        f) target to compare [make this global]\\n        g) length of total num string [make this global]\\n        h) the num string [make this global]\\n        */\\n        this.ans = new ArrayList<> ();\\n        this.len = num.length();\\n        this.target = target;\\n        this.num = num;\\n        dfs_helper(\"\",0,0,0);\\n        return ans;\\n    }\\n}\\n\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    String num;\\n    int len;\\n    List<String> ans;\\n    int target;\\n    \\n    public void dfs_helper(String build, long prev_no, long total, int pos){\\n        if(pos == len)\\n        {\\n            if(total == target)\\n                ans.add(build);\\n            return;\\n        }\\n        for(int i = pos;i<len;i++)\\n        {\\n            if(i>pos && num.charAt(pos) == \\'0\\')\\n                break; // needed to avoid cases like 00* (leading 0\\'s)\\n            // if you dont do this lets take an example\\n            // 105\\n            // 1 is added, string build = 1 and then we are at 0, i.e, pos == 1\\n            // if we go to i = 2 for pos and implement without this\\n            // we will get 1*5 as an answer which is wrong, as curr_num will be parsed as 5!\\n            // \"05\" will be 5!\\n            long curr_num = Long.parseLong(num.substring(pos,i+1)); // get the number\\n            if(pos == 0)\\n            {\\n                // have to add the 1st number to start the recursion.\\n                String to_send = build+curr_num;\\n                dfs_helper(to_send,curr_num,curr_num,i+1);\\n            }\\n            else\\n            {\\n                String to_send = build+\"+\"+curr_num;\\n                long t = total+curr_num;\\n                dfs_helper(to_send,curr_num,t,i+1);\\n                \\n                to_send = build+\"-\"+curr_num;\\n                t = total-curr_num;\\n                dfs_helper(to_send,(-1)*curr_num,t,i+1);\\n                // add and subtract are simple cases\\n                to_send = build+\"*\"+curr_num;\\n                t = total-prev_no+prev_no*curr_num;\\n                dfs_helper(to_send,curr_num*prev_no,t,i+1);\\n                // this is a tricky one lets say you have 1+2*3-5\\n                // if you do 2*3 then effective current number is 6 (consider it as 6 and pass it on)\\n                // to calculate the value now (total val) undo the effect of previous op by total-prev_no\\n                // and add the new evaluated val [prev_no*curr_num]\\n            }\\n        }\\n    }\\n    \\n    public List<String> addOperators(String num, int target) {\\n        /**\\n        Inputs that are req. for rec fn:\\n        a) string so far: 1+2*3\\n        b) prev number: 1+2*3 ==> prev number for next call from 3 will be 3\\n        c) value till that point: 1+2*3 ==> val till that point will be 7 [long]\\n        d) return list which will have the final output [make this global]\\n        e) postion pointer\\n        f) target to compare [make this global]\\n        g) length of total num string [make this global]\\n        h) the num string [make this global]\\n        */\\n        this.ans = new ArrayList<> ();\\n        this.len = num.length();\\n        this.target = target;\\n        this.num = num;\\n        dfs_helper(\"\",0,0,0);\\n        return ans;\\n    }\\n}\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1472505,
                "title": "easy-to-understand",
                "content": "If the operands were only single digits then it would be so much easier!\\n*But they aren\\'t*\\nOkay, then what if we already knew what the operands would be? Then we would only have to check for the 3 possible operators between every 2 operands which would be 3^(number of operands-1)\\n*How to get these pre-decided operands then..*\\nBit-Manipulation to the rescue:-\\n\\tWe only have to divide num into all possible operands and for each of these divisions check all the possible expressions it makes.\\n```\\nFinding all possible operand divisions from num and store them in a list -> 2^(length of num-1){\\n\\tchecking all the expressions these operands make -> 3^(size of the list of operands-1)\\n}\\nI dont know how to find the exact complexity but it would be something like ->\\n2^(length(num)-1) * 3^(m) where m ranges from [0,length(num)-1]\\n```\\n\\nJava Implementation : \\n```\\nclass Solution {\\n    public List<String> addOperators(String num, int target) {\\n        int n = num.length()-1;\\n        t = target;\\n        list = new ArrayList<>();\\n        outer : for(int i=0;i<(1<<n);i++){\\n            List<Long> arr = new ArrayList<>();\\n            long cur = num.charAt(0)-\\'0\\';\\n            for(int j=0;j<n;j++){\\n                if((i&(1<<j))!=0){\\n                    arr.add(cur);\\n                    cur = num.charAt(j+1)-\\'0\\';\\n                }   \\n                else{\\n                    if(cur==0) continue outer;\\n                    cur = cur*10 + (num.charAt(j+1)-\\'0\\');\\n                }\\n            }\\n            arr.add(cur);\\n            rec(arr.get(0),1,arr.get(0),arr.size(),\"\"+arr.get(0),0,arr);\\n        }\\n        return list;\\n    }\\n    \\n    public void rec(long eval, int i, long prev, int n, String exp, int type, List<Long> num){\\n        if(i==n){\\n            if(eval==t) list.add(exp);\\n            return;\\n        }\\n        long cur = num.get(i);\\n        rec(eval+cur,i+1,cur,n,exp+(\"+\"+cur),0,num);\\n        rec(eval-cur,i+1,cur,n,exp+(\"-\"+cur),1,num);\\n        if(type==0) rec(eval-prev+prev*cur,i+1,prev*cur,n,exp+(\"*\"+cur),0,num);\\n        else rec(eval+prev-prev*cur,i+1,prev*cur,n,exp+(\"*\"+cur),1,num); \\n    }\\n    \\n    public List<String> list;\\n    public int t;\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nFinding all possible operand divisions from num and store them in a list -> 2^(length of num-1){\\n\\tchecking all the expressions these operands make -> 3^(size of the list of operands-1)\\n}\\nI dont know how to find the exact complexity but it would be something like ->\\n2^(length(num)-1) * 3^(m) where m ranges from [0,length(num)-1]\\n```\n```\\nclass Solution {\\n    public List<String> addOperators(String num, int target) {\\n        int n = num.length()-1;\\n        t = target;\\n        list = new ArrayList<>();\\n        outer : for(int i=0;i<(1<<n);i++){\\n            List<Long> arr = new ArrayList<>();\\n            long cur = num.charAt(0)-\\'0\\';\\n            for(int j=0;j<n;j++){\\n                if((i&(1<<j))!=0){\\n                    arr.add(cur);\\n                    cur = num.charAt(j+1)-\\'0\\';\\n                }   \\n                else{\\n                    if(cur==0) continue outer;\\n                    cur = cur*10 + (num.charAt(j+1)-\\'0\\');\\n                }\\n            }\\n            arr.add(cur);\\n            rec(arr.get(0),1,arr.get(0),arr.size(),\"\"+arr.get(0),0,arr);\\n        }\\n        return list;\\n    }\\n    \\n    public void rec(long eval, int i, long prev, int n, String exp, int type, List<Long> num){\\n        if(i==n){\\n            if(eval==t) list.add(exp);\\n            return;\\n        }\\n        long cur = num.get(i);\\n        rec(eval+cur,i+1,cur,n,exp+(\"+\"+cur),0,num);\\n        rec(eval-cur,i+1,cur,n,exp+(\"-\"+cur),1,num);\\n        if(type==0) rec(eval-prev+prev*cur,i+1,prev*cur,n,exp+(\"*\"+cur),0,num);\\n        else rec(eval+prev-prev*cur,i+1,prev*cur,n,exp+(\"*\"+cur),1,num); \\n    }\\n    \\n    public List<String> list;\\n    public int t;\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1472173,
                "title": "c-dfs-backtracking",
                "content": "```\\nclass Solution {\\n    private:vector<string> ans;\\npublic:\\n    void dfs(int i,string path,long ressofar,long prevno,string s,int target)\\n    {\\n        if (i==s.length())\\n        {\\n            if (ressofar==target)  ans.push_back(path);\\n            \\n            return ;\\n        }\\n        long  no=0;\\n        for (int j=i;j<s.length();j++)\\n        {\\n            if (j>i && s[i]==\\'0\\')  break;\\n            no=no*10+(s[j]-48);\\n            //cout<<no<<\\' \\';\\n            int len= j-i+1;\\n            string subpath=s.substr(i,len);\\n            if (i==0)\\n            {\\n                dfs(j+1,path+subpath,no,no,s,target);\\n            }\\n            else\\n            {\\n                dfs(j+1,path + \"+\" + subpath,ressofar+no,no,s,target);\\n                 dfs(j+1,path + \"-\" + subpath,ressofar-no,-1* no,s,target);\\n                 dfs(j+1,path + \"*\" + subpath,ressofar-prevno+prevno*no,prevno*no,s,target);\\n            }\\n            \\n        }\\n    }\\n    \\n    vector<string> addOperators(string num, int target) {\\n     \\n        dfs(0,\"\",0,0,num,target);\\n          return ans;\\n    }\\n};",
                "solutionTags": [],
                "code": "class Solution {\\n    private:vector<string> ans;\\npublic:\\n    void dfs(int i,string path,long ressofar,long prevno,string s,int target)\\n    {\\n        if (i==s.length())\\n        {\\n            if (ressofar==target)  ans.push_back(path);\\n            \\n            return ;\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 1471696,
                "title": "python-clean-simple",
                "content": "```python\\nclass Solution:\\n    def addOperators(self, num: str, target: int) -> List[str]:\\n        results = []\\n        n = len(num)\\n        \\n        def dfs(i: int, expression: str, value: int, last: Optional[int]):\\n            if i == n and value == target:\\n                results.append(expression)\\n            \\n            for j in range(i+1, n+1):\\n                itoj = num[i:j]\\n                curr = int(itoj)\\n                if j == i + 1 or not itoj.startswith(\\'0\\'):\\n                    if last is None:\\n                        dfs(j, itoj, curr, curr)\\n                    else:\\n                        dfs(j, f\\'{expression}+{itoj}\\', value + curr, curr)\\n                        dfs(j, f\\'{expression}-{itoj}\\', value - curr, -curr)\\n                        dfs(j, f\\'{expression}*{itoj}\\', value - last + last * curr, last * curr)\\n        \\n        dfs(0, \\'\\', 0, None)\\n        return results\\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```python\\nclass Solution:\\n    def addOperators(self, num: str, target: int) -> List[str]:\\n        results = []\\n        n = len(num)\\n        \\n        def dfs(i: int, expression: str, value: int, last: Optional[int]):\\n            if i == n and value == target:\\n                results.append(expression)\\n            \\n            for j in range(i+1, n+1):\\n                itoj = num[i:j]\\n                curr = int(itoj)\\n                if j == i + 1 or not itoj.startswith(\\'0\\'):\\n                    if last is None:\\n                        dfs(j, itoj, curr, curr)\\n                    else:\\n                        dfs(j, f\\'{expression}+{itoj}\\', value + curr, curr)\\n                        dfs(j, f\\'{expression}-{itoj}\\', value - curr, -curr)\\n                        dfs(j, f\\'{expression}*{itoj}\\', value - last + last * curr, last * curr)\\n        \\n        dfs(0, \\'\\', 0, None)\\n        return results\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1471638,
                "title": "c-solution",
                "content": "```\\npublic class Solution {\\n    public IList<string> AddOperators(string num, int target) {\\n        \\n        List<string> res = new List<string>();\\n        if(string.IsNullOrEmpty(num))\\n            return res;\\n        \\n        dfs(num, target, 0, \"\", 0, 0, res);\\n        return res;\\n    }\\n    \\n    private void dfs(string num, int target, int idx, string expression, long expressionVal, long lastMonomial, List<string> res)\\n    {\\n        if(idx == num.Length)\\n        {\\n            if(expressionVal == target)\\n                res.Add(expression);\\n            return;\\n        }\\n        \\n        for(int i = idx; i < num.Length; i++)\\n        {\\n            string currStr = num.Substring(idx, i - idx + 1);\\n            \\n            if(currStr.Length > 1 && num[idx] == \\'0\\') break;  \\n            long currVal = long.Parse(currStr);\\n            \\n            if(idx == 0)\\n            {\\n                dfs(num, target, i + 1, expression + currStr, currVal, currVal, res);\\n            }\\n            else\\n            {\\n                // \\'+\\' and \\'-\\'\\n                dfs(num, target, i + 1, expression + \"+\" + currStr, expressionVal + currVal, currVal, res);\\n                dfs(num, target, i + 1, expression + \"-\" + currStr, expressionVal - currVal, -currVal, res);\\n\\n                // \\'*\\'\\n                dfs(num, target, i + 1, expression + \"*\" + currStr, expressionVal - lastMonomial + lastMonomial * currVal, lastMonomial* currVal, res);\\n            }\\n        }\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\npublic class Solution {\\n    public IList<string> AddOperators(string num, int target) {\\n        \\n        List<string> res = new List<string>();\\n        if(string.IsNullOrEmpty(num))\\n            return res;\\n        \\n        dfs(num, target, 0, \"\", 0, 0, res);\\n        return res;\\n    }\\n    \\n    private void dfs(string num, int target, int idx, string expression, long expressionVal, long lastMonomial, List<string> res)\\n    {\\n        if(idx == num.Length)\\n        {\\n            if(expressionVal == target)\\n                res.Add(expression);\\n            return;\\n        }\\n        \\n        for(int i = idx; i < num.Length; i++)\\n        {\\n            string currStr = num.Substring(idx, i - idx + 1);\\n            \\n            if(currStr.Length > 1 && num[idx] == \\'0\\') break;  \\n            long currVal = long.Parse(currStr);\\n            \\n            if(idx == 0)\\n            {\\n                dfs(num, target, i + 1, expression + currStr, currVal, currVal, res);\\n            }\\n            else\\n            {\\n                // \\'+\\' and \\'-\\'\\n                dfs(num, target, i + 1, expression + \"+\" + currStr, expressionVal + currVal, currVal, res);\\n                dfs(num, target, i + 1, expression + \"-\" + currStr, expressionVal - currVal, -currVal, res);\\n\\n                // \\'*\\'\\n                dfs(num, target, i + 1, expression + \"*\" + currStr, expressionVal - lastMonomial + lastMonomial * currVal, lastMonomial* currVal, res);\\n            }\\n        }\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1471275,
                "title": "java-backtracking-solution",
                "content": "```\\nclass Solution {\\n    public List<String> res = new ArrayList<>();\\n    public List<String> addOperators(String num, int target) {\\n        backtracking(num, 0, target, \"\", 0, 0);\\n        return res;\\n    }\\n    \\n    public void backtracking(String num, int ind, long target, String temp, long tot, long pre) {\\n        if (ind == num.length() && tot == target) {\\n            res.add(temp);\\n            return;\\n        }\\n        long cur = 0;\\n        for (int end = ind; end < num.length(); end++) {\\n            if (end > ind && num.charAt(ind) == \\'0\\') return;\\n            cur = cur * 10 + num.charAt(end) - \\'0\\';\\n            String sub = num.substring(ind, end + 1);\\n            if (ind == 0) {\\n                backtracking(num, end + 1, target, sub, cur, cur);\\n                continue;\\n            }\\n            backtracking(num, end + 1, target, temp + \"+\" + sub, tot + cur, cur);\\n            backtracking(num, end + 1, target, temp + \"-\" + sub, tot - cur, -cur);\\n            backtracking(num, end + 1, target, temp + \"*\" + sub, tot + (cur - 1) * pre, cur * pre);\\n        }\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Backtracking"
                ],
                "code": "```\\nclass Solution {\\n    public List<String> res = new ArrayList<>();\\n    public List<String> addOperators(String num, int target) {\\n        backtracking(num, 0, target, \"\", 0, 0);\\n        return res;\\n    }\\n    \\n    public void backtracking(String num, int ind, long target, String temp, long tot, long pre) {\\n        if (ind == num.length() && tot == target) {\\n            res.add(temp);\\n            return;\\n        }\\n        long cur = 0;\\n        for (int end = ind; end < num.length(); end++) {\\n            if (end > ind && num.charAt(ind) == \\'0\\') return;\\n            cur = cur * 10 + num.charAt(end) - \\'0\\';\\n            String sub = num.substring(ind, end + 1);\\n            if (ind == 0) {\\n                backtracking(num, end + 1, target, sub, cur, cur);\\n                continue;\\n            }\\n            backtracking(num, end + 1, target, temp + \"+\" + sub, tot + cur, cur);\\n            backtracking(num, end + 1, target, temp + \"-\" + sub, tot - cur, -cur);\\n            backtracking(num, end + 1, target, temp + \"*\" + sub, tot + (cur - 1) * pre, cur * pre);\\n        }\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1470576,
                "title": "c-simple-fast",
                "content": "```\\nclass Solution {\\npublic:\\n    vector<string> ValidExp;\\n    void calc(string &num,int index,long last,long result,int &target,string expression)\\n    {\\n        if(index==num.length())\\n        {\\n            if(result==target)\\n              ValidExp.push_back(expression);\\n            return;\\n        }\\n        for(int i=index;i<num.length();i++)\\n        {\\n            string subStr=num.substr(index,i-index+1);\\n            long val=stol(subStr);\\n            calc(num,i+1,val,result+val,target,index==0?expression+subStr:expression+\"+\"+subStr);\\n            if(index!=0)\\n            {\\n                calc(num,i+1,-1*val,result-val,target,expression+\"-\"+subStr);\\n                calc(num,i+1,last*val,result-last+last*val,target,expression+\"*\"+subStr);\\n            }\\n            if(num[index]==\\'0\\')\\n                break;\\n        }\\n    }\\n    \\n    vector<string> addOperators(string num, int target) \\n    {\\n        calc(num,0,0,0,target,\"\");\\n        return ValidExp;\\n    }\\n};\\n```\\n\\n***Little complex but much optimised solution***\\n\\n```\\nclass Solution {\\npublic:\\n    vector<string> ValidExp;\\n    void calc(string &num,int index,long last,long &result,int &target,string &expression)\\n    {\\n        if(index==num.length())\\n        {\\n            if(result==target)\\n              ValidExp.push_back(expression);\\n            return;\\n        }\\n        for(int i=index;i<num.length();i++)\\n        {\\n            string subStr=num.substr(index,i-index+1);\\n            long val=stol(subStr);\\n            long newResult=result+val;\\n            expression+=index==0?subStr:\"+\"+subStr;\\n            calc(num,i+1,val,newResult,target,expression);\\n            index==0?expression.erase():expression.erase(expression.length()-(i-index+2)); \\n            if(index!=0)\\n            {\\n                newResult=result-val;\\n                expression+=\"-\"+subStr;\\n                calc(num,i+1,-1*val,newResult,target,expression);\\n                expression.erase(expression.length()-(i-index+2));\\n                newResult=result-last+last*val;\\n                expression+=\"*\"+subStr;\\n                calc(num,i+1,last*val,newResult,target,expression);\\n                expression.erase(expression.length()-(i-index+2));\\n            }\\n            if(num[index]==\\'0\\')\\n                break;\\n        }\\n    }\\n    \\n    \\n    vector<string> addOperators(string num, int target) \\n    {\\n        string exp;\\n        long result=0;\\n        calc(num,0,0,result,target,exp);\\n        return ValidExp;\\n    }\\n};\\n```\\n",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<string> ValidExp;\\n    void calc(string &num,int index,long last,long result,int &target,string expression)\\n    {\\n        if(index==num.length())\\n        {\\n            if(result==target)\\n              ValidExp.push_back(expression);\\n            return;\\n        }\\n        for(int i=index;i<num.length();i++)\\n        {\\n            string subStr=num.substr(index,i-index+1);\\n            long val=stol(subStr);\\n            calc(num,i+1,val,result+val,target,index==0?expression+subStr:expression+\"+\"+subStr);\\n            if(index!=0)\\n            {\\n                calc(num,i+1,-1*val,result-val,target,expression+\"-\"+subStr);\\n                calc(num,i+1,last*val,result-last+last*val,target,expression+\"*\"+subStr);\\n            }\\n            if(num[index]==\\'0\\')\\n                break;\\n        }\\n    }\\n    \\n    vector<string> addOperators(string num, int target) \\n    {\\n        calc(num,0,0,0,target,\"\");\\n        return ValidExp;\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    vector<string> ValidExp;\\n    void calc(string &num,int index,long last,long &result,int &target,string &expression)\\n    {\\n        if(index==num.length())\\n        {\\n            if(result==target)\\n              ValidExp.push_back(expression);\\n            return;\\n        }\\n        for(int i=index;i<num.length();i++)\\n        {\\n            string subStr=num.substr(index,i-index+1);\\n            long val=stol(subStr);\\n            long newResult=result+val;\\n            expression+=index==0?subStr:\"+\"+subStr;\\n            calc(num,i+1,val,newResult,target,expression);\\n            index==0?expression.erase():expression.erase(expression.length()-(i-index+2)); \\n            if(index!=0)\\n            {\\n                newResult=result-val;\\n                expression+=\"-\"+subStr;\\n                calc(num,i+1,-1*val,newResult,target,expression);\\n                expression.erase(expression.length()-(i-index+2));\\n                newResult=result-last+last*val;\\n                expression+=\"*\"+subStr;\\n                calc(num,i+1,last*val,newResult,target,expression);\\n                expression.erase(expression.length()-(i-index+2));\\n            }\\n            if(num[index]==\\'0\\')\\n                break;\\n        }\\n    }\\n    \\n    \\n    vector<string> addOperators(string num, int target) \\n    {\\n        string exp;\\n        long result=0;\\n        calc(num,0,0,result,target,exp);\\n        return ValidExp;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1470358,
                "title": "javascript-backtracking-commented-solution-with-explanation",
                "content": "**Idea** \\nwe want to do backtracking and calculate the the sum of the expression on the fly so when we get to the end of num array we will have sum ready and calculated, so we know if it is equal to target and we want to insert it to result array.\\n\\nwe have 4 options when we backtrack:\\n1. we don\\'t want to proccess the number yet, we want to enlarge it, create a new number with more than one digit \"124\", so we backtrack with the new number we created and we don\\'t calculate the expression yet, so we just send `newNumToAdd` to the backtracking func and do nothing.\\n2. we want to proccess the number with Addtion.\\n3. we want to proccess the number with Substraction.\\n4. we want to proccess the number with Multiplication, this is the tricky part:\\nTo be able to calculate the multiplications expression on the fly, to do that we keep track of the previous number  (`prevExp`) we proccessed and if we want to do a multiplication we do `sum - prevExp + (prevExp * newNumToAdd)`\\n\\n```\\nvar addOperators = function(num, target) {\\n    const res = [];\\n    backtracking(num, target, 0, 0, \"\", 0, 0, res);\\n    return res;\\n};\\n\\nvar backtracking = function(num, target, index, sum, expression, currNumToAdd, prevExp, res) {\\n\\tif(index > num.length) {\\n        return;\\n    }\\n    // If we are at end of num AND the final value == target expected AND no currNumToAdd is left unprocessed\\n    if(index === num.length && sum === target && currNumToAdd === 0) {\\n        res.push(expression.slice(1));\\n        return;\\n    }\\n    const newNumToAdd = currNumToAdd*10 + (+num[index]);\\n    // To avoid cases where we have 1 + 05 or 1 * 05 since 05 won\\'t be a\\n    // valid operand. Hence this check. we only create number with more than 1 digit if (newNumToAdd > 0)\\n    if(newNumToAdd > 0) {\\n        backtracking(num, target, index+1, sum, expression, newNumToAdd, prevExp, res);\\n    }\\n    // ADDITION\\n    backtracking(num, target, index+1, sum + newNumToAdd, expression+\"+\"+newNumToAdd, 0, +newNumToAdd, res);\\n    // to avoid SUBTRACTION/MULTIPLICATION on first numToAdd when expression is empty(we asume we can only add)\\n    if(expression.length > 0) {\\n        // SUBTRACTION\\n        backtracking(num, target, index+1, sum - newNumToAdd, expression+\"-\"+newNumToAdd, 0, -newNumToAdd, res);\\n        // MULTIPLICATION\\n        const multSum = sum - prevExp + (prevExp * newNumToAdd);\\n        backtracking(num, target, index+1, multSum, expression+\"*\"+newNumToAdd, 0, (prevExp * newNumToAdd), res);\\n    }\\n    return;\\n}\\n\\n```\\n\\n**time comp**: O(4^N), where N length of num. O(4^N) because for every step in backtracking we have 4 paths.\\n**space comp**: O(N) for expression\\'s length string. also recursive stack space is O(N).",
                "solutionTags": [
                    "JavaScript",
                    "Backtracking"
                ],
                "code": "```\\nvar addOperators = function(num, target) {\\n    const res = [];\\n    backtracking(num, target, 0, 0, \"\", 0, 0, res);\\n    return res;\\n};\\n\\nvar backtracking = function(num, target, index, sum, expression, currNumToAdd, prevExp, res) {\\n\\tif(index > num.length) {\\n        return;\\n    }\\n    // If we are at end of num AND the final value == target expected AND no currNumToAdd is left unprocessed\\n    if(index === num.length && sum === target && currNumToAdd === 0) {\\n        res.push(expression.slice(1));\\n        return;\\n    }\\n    const newNumToAdd = currNumToAdd*10 + (+num[index]);\\n    // To avoid cases where we have 1 + 05 or 1 * 05 since 05 won\\'t be a\\n    // valid operand. Hence this check. we only create number with more than 1 digit if (newNumToAdd > 0)\\n    if(newNumToAdd > 0) {\\n        backtracking(num, target, index+1, sum, expression, newNumToAdd, prevExp, res);\\n    }\\n    // ADDITION\\n    backtracking(num, target, index+1, sum + newNumToAdd, expression+\"+\"+newNumToAdd, 0, +newNumToAdd, res);\\n    // to avoid SUBTRACTION/MULTIPLICATION on first numToAdd when expression is empty(we asume we can only add)\\n    if(expression.length > 0) {\\n        // SUBTRACTION\\n        backtracking(num, target, index+1, sum - newNumToAdd, expression+\"-\"+newNumToAdd, 0, -newNumToAdd, res);\\n        // MULTIPLICATION\\n        const multSum = sum - prevExp + (prevExp * newNumToAdd);\\n        backtracking(num, target, index+1, multSum, expression+\"*\"+newNumToAdd, 0, (prevExp * newNumToAdd), res);\\n    }\\n    return;\\n}\\n\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1470337,
                "title": "kotlin-solution",
                "content": "```\\nclass Solution {\\n    enum class Operator {\\n        NONE, ADD, SUB, MUL\\n    }\\n    data class Result(\\n        val resValue: Long, \\n        val resString: String, \\n        val lastBlockMultiplier: Long,\\n        val lastNumber: Long) {\\n        \\n        private val lastBlockRes: Long = lastBlockMultiplier * lastNumber\\n        \\n        fun add(op: Operator, num: Long): Result? {\\n            return when (op) {\\n                Operator.ADD -> Result(resValue + num, \"$resString+$num\", 1, num)\\n                Operator.SUB -> Result(resValue - num, \"$resString-$num\", -1, num)\\n                Operator.MUL -> Result(resValue - lastBlockRes + lastBlockRes * num,\\n                                       \"$resString*$num\", lastBlockRes, num)\\n                Operator.NONE -> if (lastNumber == 0L) { null } else {\\n                    Result(resValue - lastBlockRes + lastBlockMultiplier * (lastNumber * 10 + num),\\n                           \"$resString$num\", lastBlockMultiplier, lastNumber * 10 + num)\\n                }\\n            }\\n        }\\n    }\\n    fun addOperators(num: String, target: Int): List<String> {\\n        val res = mutableListOf<String>()\\n        \\n        fun addOperatorBefore(index: Int, prevResult: Result) {\\n            if (index == num.length) {\\n                if (prevResult.resValue == target.toLong()) {\\n                    res.add(prevResult.resString)\\n                }\\n                return\\n            }\\n            val digitNum = (num[index] - \\'0\\').toLong()\\n            val results = Operator.values().fold(mutableListOf<Result>()) { acc, op ->\\n                acc.apply { prevResult.add(op, digitNum)?.let { add(it) } }\\n            }\\n            results.forEach {\\n                addOperatorBefore(index + 1, it)\\n            }\\n        }\\n        \\n        val digitNum = (num[0] - \\'0\\').toLong()\\n        addOperatorBefore(1, Result(digitNum, \"${num[0]}\", 1L, digitNum))\\n        \\n        return res\\n    }\\n}\\n```",
                "solutionTags": [
                    "Kotlin"
                ],
                "code": "```\\nclass Solution {\\n    enum class Operator {\\n        NONE, ADD, SUB, MUL\\n    }\\n    data class Result(\\n        val resValue: Long, \\n        val resString: String, \\n        val lastBlockMultiplier: Long,\\n        val lastNumber: Long) {\\n        \\n        private val lastBlockRes: Long = lastBlockMultiplier * lastNumber\\n        \\n        fun add(op: Operator, num: Long): Result? {\\n            return when (op) {\\n                Operator.ADD -> Result(resValue + num, \"$resString+$num\", 1, num)\\n                Operator.SUB -> Result(resValue - num, \"$resString-$num\", -1, num)\\n                Operator.MUL -> Result(resValue - lastBlockRes + lastBlockRes * num,\\n                                       \"$resString*$num\", lastBlockRes, num)\\n                Operator.NONE -> if (lastNumber == 0L) { null } else {\\n                    Result(resValue - lastBlockRes + lastBlockMultiplier * (lastNumber * 10 + num),\\n                           \"$resString$num\", lastBlockMultiplier, lastNumber * 10 + num)\\n                }\\n            }\\n        }\\n    }\\n    fun addOperators(num: String, target: Int): List<String> {\\n        val res = mutableListOf<String>()\\n        \\n        fun addOperatorBefore(index: Int, prevResult: Result) {\\n            if (index == num.length) {\\n                if (prevResult.resValue == target.toLong()) {\\n                    res.add(prevResult.resString)\\n                }\\n                return\\n            }\\n            val digitNum = (num[index] - \\'0\\').toLong()\\n            val results = Operator.values().fold(mutableListOf<Result>()) { acc, op ->\\n                acc.apply { prevResult.add(op, digitNum)?.let { add(it) } }\\n            }\\n            results.forEach {\\n                addOperatorBefore(index + 1, it)\\n            }\\n        }\\n        \\n        val digitNum = (num[0] - \\'0\\').toLong()\\n        addOperatorBefore(1, Result(digitNum, \"${num[0]}\", 1L, digitNum))\\n        \\n        return res\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1465105,
                "title": "java-solution-backtracking",
                "content": "class Solution {\\n\\n    List<String> sol;\\n     public List<String> addOperators(String num, int target) {\\n        sol = new ArrayList<>();\\n\\n         if(Long.parseLong(num) > Integer.MAX_VALUE) return sol;\\n        \\n        recursion(num, target, 0, new StringBuilder());\\n        return sol;\\n    }\\n    \\n    \\n    public void recursion(String num, int target, int start, StringBuilder sb) {        \\n        if(start == num.length()) {\\n            // calculate opeartaion from String \\n            if(Integer.compare(calculate(sb.toString()), target) == 0) sol.add(sb.toString());\\n            return;\\n        }\\n          \\n        for(int i = start; i < num.length(); i++) {\\n            \\n            if(i-start> 0 && num.charAt(start) == \\'0\\') continue;  // number like: \"05\", \"00\".. \\n            \\n            if(start == 0 ) {\\n                sb.append(num.substring(start,i+1)+\"\"); // First number, example:  -> (1) + 2 + 3\\n                recursion(num, target, i + 1, sb);\\n                \\n            } else{\\n                // Addition (add the \"x\" and number)\\n                sb.append(\"+\");\\n                sb.append(num.substring(start,i+1)+\"\");\\n                recursion(num, target, i + 1, sb);\\n\\n                // Substraction (change \"+\" to \"-\")\\n                sb.replace(sb.length()-2-(i-start),sb.length()-1-(i-start), \"-\");\\n                recursion(num, target, i + 1, sb);\\n\\n                //Multiplication (change \"-\" to \"*\")\\n                sb.replace(sb.length()-2-(i-start),sb.length()-1-(i-start), \"*\");\\n                recursion(num, target, i + 1, sb);\\n            }\\n            //delete the added elements to backtrack\\n            if(sb.length()-2-(i-start) >= 0) sb.delete(sb.length()-2-(i-start),sb.length());\\n            else sb.delete(0, sb.length());\\n        }\\n        \\n    }\\n    \\n    \\n    \\n    public int calculate(String expression) {\\n        Stack<Integer> stack = new Stack<>();\\n        \\n        boolean isMultiplication = false;\\n        int pointer = 0;\\n        int sign = 1;\\n        int number = 0;\\n        \\n        while(pointer < expression.length()) {\\n\\n            if(expression.charAt(pointer) == \\'*\\') {\\n                isMultiplication = true;\\n                pointer++;\\n            }\\n            if(expression.charAt(pointer) == \\'-\\') {\\n                sign = -1;\\n                pointer++;\\n            } \\n            if(expression.charAt(pointer) == \\'+\\') {\\n                sign = 1;\\n                pointer++;\\n            } \\n            while(pointer < expression.length() && expression.charAt(pointer) >= \\'0\\' \\n                  && expression.charAt(pointer) <= \\'9\\') {\\n                number = number * 10 + Integer.parseInt(expression.charAt(pointer) + \"\");\\n                pointer++;\\n            }\\n            if(isMultiplication) {\\n                number *= stack.pop();\\n                isMultiplication = false;\\n            } \\n            stack.add(number*sign);\\n            number = 0;\\n            sign = 1;\\n        }\\n        \\n        int result = 0;\\n        for(int x: stack) result += x;\\n        return result;\\n    }\\n}",
                "solutionTags": [],
                "code": "class Solution {\\n\\n    List<String> sol;\\n     public List<String> addOperators(String num, int target) {\\n        sol = new ArrayList<>();\\n\\n         if(Long.parseLong(num) > Integer.MAX_VALUE) return sol;\\n        \\n        recursion(num, target, 0, new StringBuilder());\\n        return sol;\\n    }",
                "codeTag": "Java"
            },
            {
                "id": 1414131,
                "title": "python-simple-and-clear-dfs-solution-with-detailed-comments-beating-97",
                "content": "```\\nclass Solution:\\n    def addOperators(self, num: str, target: int) -> List[str]:\\n        result = []\\n        n = len(num)\\n        \\n        def dfs(pos, path, val, last_operand):\\n            if pos == n:\\n                if val == target:\\n                    result.append(path)\\n            else:\\n                for i in range(pos, n):\\n                    # try [pos..i] as an operand\\n                    if num[pos] == \\'0\\' and i != pos:\\n                        # For example \"0555\", Only consider \"0\" as possible operand\\n                        break\\n                    s = num[pos : i + 1]\\n                    v = int(s)\\n                    if pos == 0:\\n                        # no possible left operand\\n                        dfs(i + 1, s, v, v)\\n                    else:\\n                        dfs(i + 1, path + \\'+\\' + s, val + v, v)\\n                        dfs(i + 1, path + \\'-\\' + s, val - v, -v)\\n                        dfs(i + 1, path + \\'*\\' + s, val - last_operand + last_operand * v, last_operand * v)\\n        \\n        dfs(0, \\'\\', 0, 0)\\n        return result",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def addOperators(self, num: str, target: int) -> List[str]:\\n        result = []\\n        n = len(num)\\n        \\n        def dfs(pos, path, val, last_operand):\\n            if pos == n:\\n                if val == target:\\n                    result.append(path)\\n            else:\\n                for i in range(pos, n):\\n                    # try [pos..i] as an operand\\n                    if num[pos] == \\'0\\' and i != pos:\\n                        # For example \"0555\", Only consider \"0\" as possible operand\\n                        break\\n                    s = num[pos : i + 1]\\n                    v = int(s)\\n                    if pos == 0:\\n                        # no possible left operand\\n                        dfs(i + 1, s, v, v)\\n                    else:\\n                        dfs(i + 1, path + \\'+\\' + s, val + v, v)\\n                        dfs(i + 1, path + \\'-\\' + s, val - v, -v)\\n                        dfs(i + 1, path + \\'*\\' + s, val - last_operand + last_operand * v, last_operand * v)\\n        \\n        dfs(0, \\'\\', 0, 0)\\n        return result",
                "codeTag": "Java"
            },
            {
                "id": 1404761,
                "title": "java-backtracking",
                "content": "```\\nclass Solution {\\n    public List<String> addOperators(String num, int target) {\\n        List<String> result = new LinkedList<String>();\\n        helper(num, target, 0, 0, \\'!\\', 0, \"\", result);\\n        return result;\\n    }\\n    \\n    private void helper(String num, int target, long curSum, long prevNum, char prevOp, int pos, String local, List<String> result) {\\n        if (pos == num.length()) {\\n            if (curSum == (long)target) result.add(local);\\n            return ;\\n        }\\n        \\n        long curNum = 0;\\n        for(int i = pos; i < num.length(); i++) {\\n            if (i == pos || curNum > 0) {\\n                curNum = curNum*10 + Integer.valueOf(num.charAt(i)-\\'0\\');  \\n                if (pos == 0) {\\n                    helper(num, target, curNum, curNum, prevOp, i+1, String.valueOf(curNum), result);\\n                } else {\\n                    // +\\n                    helper(num, target, curSum+curNum, curNum, \\'+\\', i+1, local+\"+\"+curNum, result);\\n                    // -\\n                    helper(num, target, curSum-curNum, curNum, \\'-\\', i+1, local+\"-\"+curNum, result);\\n                    // *\\n                    if (prevOp == \\'-\\') {\\n                        helper(num, target, curSum+prevNum-(prevNum*curNum), prevNum*curNum, prevOp, i+1, local+\"*\"+curNum, result);\\n                    } else if (prevOp == \\'+\\') {\\n                        helper(num, target, curSum-prevNum+(prevNum*curNum), prevNum*curNum, prevOp, i+1, local+\"*\"+curNum, result);\\n                    } else {\\n                        helper(num, target, curSum*curNum, curNum, prevOp, i+1, local+\"*\"+curNum, result);    \\n                    }\\n                }   \\n            }\\n        }\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public List<String> addOperators(String num, int target) {\\n        List<String> result = new LinkedList<String>();\\n        helper(num, target, 0, 0, \\'!\\', 0, \"\", result);\\n        return result;\\n    }\\n    \\n    private void helper(String num, int target, long curSum, long prevNum, char prevOp, int pos, String local, List<String> result) {\\n        if (pos == num.length()) {\\n            if (curSum == (long)target) result.add(local);\\n            return ;\\n        }\\n        \\n        long curNum = 0;\\n        for(int i = pos; i < num.length(); i++) {\\n            if (i == pos || curNum > 0) {\\n                curNum = curNum*10 + Integer.valueOf(num.charAt(i)-\\'0\\');  \\n                if (pos == 0) {\\n                    helper(num, target, curNum, curNum, prevOp, i+1, String.valueOf(curNum), result);\\n                } else {\\n                    // +\\n                    helper(num, target, curSum+curNum, curNum, \\'+\\', i+1, local+\"+\"+curNum, result);\\n                    // -\\n                    helper(num, target, curSum-curNum, curNum, \\'-\\', i+1, local+\"-\"+curNum, result);\\n                    // *\\n                    if (prevOp == \\'-\\') {\\n                        helper(num, target, curSum+prevNum-(prevNum*curNum), prevNum*curNum, prevOp, i+1, local+\"*\"+curNum, result);\\n                    } else if (prevOp == \\'+\\') {\\n                        helper(num, target, curSum-prevNum+(prevNum*curNum), prevNum*curNum, prevOp, i+1, local+\"*\"+curNum, result);\\n                    } else {\\n                        helper(num, target, curSum*curNum, curNum, prevOp, i+1, local+\"*\"+curNum, result);    \\n                    }\\n                }   \\n            }\\n        }\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1388352,
                "title": "very-simple-python-dfs-solution",
                "content": "start: start index\\nl: path\\ntot: sum\\nprev: previous value\\n\\n```\\nclass Solution:\\n    def addOperators(self, num, target):\\n        \\n        res = []\\n        \\n        def dfs(start = 0, l = \"\", tot = 0, prev = 0):\\n            if start == len(num):\\n                if tot == target:\\n                    res.append(l)\\n                return\\n            \\n            for i in range(start, len(num)):\\n                \\n                if i - start and int(num[start]) == 0:\\n                    continue\\n                \\n                cur = int(num[start:i + 1])\\n                if start == 0:\\n                    dfs(i + 1, l + str(cur), tot + cur, cur)\\n                else:\\n                    dfs(i + 1, l + \"+\" + str(cur), tot + cur, cur)\\n                    dfs(i + 1, l + \"-\" + str(cur), tot - cur, -cur)\\n                    dfs(i + 1, l + \"*\" + str(cur), tot - prev + prev * cur, prev * cur)\\n        \\n        dfs()\\n        \\n        return res\\n\\t```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def addOperators(self, num, target):\\n        \\n        res = []\\n        \\n        def dfs(start = 0, l = \"\", tot = 0, prev = 0):\\n            if start == len(num):\\n                if tot == target:\\n                    res.append(l)\\n                return\\n            \\n            for i in range(start, len(num)):\\n                \\n                if i - start and int(num[start]) == 0:\\n                    continue\\n                \\n                cur = int(num[start:i + 1])\\n                if start == 0:\\n                    dfs(i + 1, l + str(cur), tot + cur, cur)\\n                else:\\n                    dfs(i + 1, l + \"+\" + str(cur), tot + cur, cur)\\n                    dfs(i + 1, l + \"-\" + str(cur), tot - cur, -cur)\\n                    dfs(i + 1, l + \"*\" + str(cur), tot - prev + prev * cur, prev * cur)\\n        \\n        dfs()\\n        \\n        return res\\n\\t```",
                "codeTag": "Java"
            },
            {
                "id": 1284423,
                "title": "java-clean-code-dfs",
                "content": "```\\nclass Solution {\\n    public List<String> addOperators(String num, int target) {\\n        ArrayList<String> res = new ArrayList<>();\\n        dfs(0,0,0,0,num, target,\"\",res);\\n        return res;\\n    }\\n    \\n    void dfs(int ci, long val, long prev, long cur, String num,long target, String str, ArrayList<String> res){\\n        if(ci == num.length()){\\n            if(val == target && cur == 0) {\\n                res.add(str);\\n            }\\n            return;\\n        }\\n\\n        int cd= num.charAt(ci) - \\'0\\';\\n        cur = 10 * cur; \\n        cur += cd;\\n\\n        //no op\\n        if(cur > 0)\\n            dfs(ci+1, val, prev, cur, num, target, str , res );\\n        \\n        // + \\n        if(str.equals(\"\")) {\\n             dfs(ci+1, val+cur, cur, 0, num, target, str + cur, res );\\n            return;\\n        }\\n         dfs(ci+1, val+cur, cur, 0, num, target, str +\"+\" + cur, res );\\n          // -\\n        dfs(ci+1, val -cur, -cur, 0, num, target, str +\"-\" + cur, res );\\n\\n        // *\\n        dfs(ci+1, val -prev + (prev * cur), prev * cur, 0, num, target, str +\"*\" + cur, res );\\n    }\\n}\\n\\n\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public List<String> addOperators(String num, int target) {\\n        ArrayList<String> res = new ArrayList<>();\\n        dfs(0,0,0,0,num, target,\"\",res);\\n        return res;\\n    }\\n    \\n    void dfs(int ci, long val, long prev, long cur, String num,long target, String str, ArrayList<String> res){\\n        if(ci == num.length()){\\n            if(val == target && cur == 0) {\\n                res.add(str);\\n            }\\n            return;\\n        }\\n\\n        int cd= num.charAt(ci) - \\'0\\';\\n        cur = 10 * cur; \\n        cur += cd;\\n\\n        //no op\\n        if(cur > 0)\\n            dfs(ci+1, val, prev, cur, num, target, str , res );\\n        \\n        // + \\n        if(str.equals(\"\")) {\\n             dfs(ci+1, val+cur, cur, 0, num, target, str + cur, res );\\n            return;\\n        }\\n         dfs(ci+1, val+cur, cur, 0, num, target, str +\"+\" + cur, res );\\n          // -\\n        dfs(ci+1, val -cur, -cur, 0, num, target, str +\"-\" + cur, res );\\n\\n        // *\\n        dfs(ci+1, val -prev + (prev * cur), prev * cur, 0, num, target, str +\"*\" + cur, res );\\n    }\\n}\\n\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1245293,
                "title": "python-dfs-solution",
                "content": "```\\nclass Solution:\\n    def addOperators(self, num: str, target: int) -> List[str]:\\n        def dfs(pos, cur, pre, exp):\\n\\n            if pos == n:\\n                if cur == target:\\n                    res.append(exp)\\n                return\\n        \\n            for right in range(pos + 1, n + 1):\\n                tmp = num[pos:right]\\n                if tmp[0] == \\'0\\' and len(tmp) > 1:\\n                    break\\n                    \\n                val = int(tmp)\\n                if pos == 0:\\n                    dfs(right, val, val, tmp)\\n                else:\\n                    dfs(right, cur + val, val, exp + \"+\" + tmp)\\n                    dfs(right, cur - val, -val, exp + \"-\" + tmp)\\n                    dfs(right, cur - pre + pre * val, pre * val, exp + \"*\" + tmp)\\n            \\n        \\n        res = list()\\n        if not num or len(num) == 0:\\n            return res\\n        n = len(num)\\n        dfs(0, 0, 0, \"\")\\n        return res\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def addOperators(self, num: str, target: int) -> List[str]:\\n        def dfs(pos, cur, pre, exp):\\n\\n            if pos == n:\\n                if cur == target:\\n                    res.append(exp)\\n                return\\n        \\n            for right in range(pos + 1, n + 1):\\n                tmp = num[pos:right]\\n                if tmp[0] == \\'0\\' and len(tmp) > 1:\\n                    break\\n                    \\n                val = int(tmp)\\n                if pos == 0:\\n                    dfs(right, val, val, tmp)\\n                else:\\n                    dfs(right, cur + val, val, exp + \"+\" + tmp)\\n                    dfs(right, cur - val, -val, exp + \"-\" + tmp)\\n                    dfs(right, cur - pre + pre * val, pre * val, exp + \"*\" + tmp)\\n            \\n        \\n        res = list()\\n        if not num or len(num) == 0:\\n            return res\\n        n = len(num)\\n        dfs(0, 0, 0, \"\")\\n        return res\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1238289,
                "title": "c-clean-and-concise-beats-98-28",
                "content": "```\\nclass Solution {\\npublic:\\n    vector<string> ans;\\n    string buf;\\n    long t;\\n    int last;\\n    \\n    vector<string> addOperators(string num, int target) {\\n        buf.resize(20);\\n        t = target;\\n        last = num.size()-1;\\n        \\n        dfs(num, 0, 0, 0, 0, \\'+\\');\\n        \\n        return ans;\\n    }\\n    \\n    void dfs(string& num, int i, int j, long sum, long sumtmp, char prevop){                \\n        long v = 0;\\n        \\n        for (int k = i ; ; k++){\\n            v *= 10;\\n            v += long(num[k]-\\'0\\');\\n            buf[j] = num[k];\\n            j++;\\n            \\n            long sumtmptmp = (prevop == \\'*\\'?sumtmp*v: (prevop == \\'+\\'?sumtmp+v:sumtmp-v));\\n            \\n            if (k == last){\\n                if (sum+sumtmptmp == t) ans.push_back(buf.substr(0, j));\\n\\n                return;\\n            }\\n            \\n            buf[j] = \\'*\\';\\n            dfs(num, k+1, j+1, sum, sumtmptmp, \\'*\\');\\n            buf[j] = \\'+\\';\\n            dfs(num, k+1, j+1, sum+sumtmptmp, 0, \\'+\\');\\n            buf[j] = \\'-\\';\\n            dfs(num, k+1, j+1, sum+sumtmptmp, 0, \\'-\\');\\n            \\n            if (!v) return;\\n        }\\n    }\\n    \\n};\\n```",
                "solutionTags": [
                    "C",
                    "Backtracking",
                    "Depth-First Search"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<string> ans;\\n    string buf;\\n    long t;\\n    int last;\\n    \\n    vector<string> addOperators(string num, int target) {\\n        buf.resize(20);\\n        t = target;\\n        last = num.size()-1;\\n        \\n        dfs(num, 0, 0, 0, 0, \\'+\\');\\n        \\n        return ans;\\n    }\\n    \\n    void dfs(string& num, int i, int j, long sum, long sumtmp, char prevop){                \\n        long v = 0;\\n        \\n        for (int k = i ; ; k++){\\n            v *= 10;\\n            v += long(num[k]-\\'0\\');\\n            buf[j] = num[k];\\n            j++;\\n            \\n            long sumtmptmp = (prevop == \\'*\\'?sumtmp*v: (prevop == \\'+\\'?sumtmp+v:sumtmp-v));\\n            \\n            if (k == last){\\n                if (sum+sumtmptmp == t) ans.push_back(buf.substr(0, j));\\n\\n                return;\\n            }\\n            \\n            buf[j] = \\'*\\';\\n            dfs(num, k+1, j+1, sum, sumtmptmp, \\'*\\');\\n            buf[j] = \\'+\\';\\n            dfs(num, k+1, j+1, sum+sumtmptmp, 0, \\'+\\');\\n            buf[j] = \\'-\\';\\n            dfs(num, k+1, j+1, sum+sumtmptmp, 0, \\'-\\');\\n            \\n            if (!v) return;\\n        }\\n    }\\n    \\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1069896,
                "title": "clean-python-solution",
                "content": "The trick of this solution is to record the `last` calculated value for current  multiple (`*`) operation.\\n\\n```\\nclass Solution:\\n    def addOperators(self, num: str, target: int) -> List[str]:\\n        ret = []\\n        def dfs(subtotal, last, path, start):\\n            if start == len(num):\\n                if subtotal == target:\\n                    ret.append(\\'\\'.join(path))\\n                return\\n            for i in range(start, len(num)):\\n                ch = num[start:i + 1]\\n                if len(ch) > 1 and ch[0] == \\'0\\':\\n                    continue\\n                integer = int(ch)\\n                if not path:\\n                    dfs( integer, integer, [ch], i + 1 )\\n                else:\\n                    dfs( subtotal + integer, integer, path + [\\'+\\', ch], i + 1 )\\n                    dfs( subtotal - integer, -integer, path + [\\'-\\', ch],i + 1 )\\n\\t\\t\\t\\t\\t# the most interesting part:\\n\\t\\t\\t\\t\\t# e.g. 1+2*3, we record last as 2, so: 3-2+2*3 = 7\\n                    dfs( subtotal - last + last * integer, last * integer, path + [\\'*\\', ch], i + 1 ) \\n        dfs(0, 0, [], 0)\\n        return ret\\n```",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Depth-First Search"
                ],
                "code": "```\\nclass Solution:\\n    def addOperators(self, num: str, target: int) -> List[str]:\\n        ret = []\\n        def dfs(subtotal, last, path, start):\\n            if start == len(num):\\n                if subtotal == target:\\n                    ret.append(\\'\\'.join(path))\\n                return\\n            for i in range(start, len(num)):\\n                ch = num[start:i + 1]\\n                if len(ch) > 1 and ch[0] == \\'0\\':\\n                    continue\\n                integer = int(ch)\\n                if not path:\\n                    dfs( integer, integer, [ch], i + 1 )\\n                else:\\n                    dfs( subtotal + integer, integer, path + [\\'+\\', ch], i + 1 )\\n                    dfs( subtotal - integer, -integer, path + [\\'-\\', ch],i + 1 )\\n\\t\\t\\t\\t\\t# the most interesting part:\\n\\t\\t\\t\\t\\t# e.g. 1+2*3, we record last as 2, so: 3-2+2*3 = 7\\n                    dfs( subtotal - last + last * integer, last * integer, path + [\\'*\\', ch], i + 1 ) \\n        dfs(0, 0, [], 0)\\n        return ret\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1044199,
                "title": "java-basic-calculator-ii",
                "content": "This takes the Solution 2 of Basic Calculator II and modifies it. \\nThe idea is that we generate the string we are evaluating on the previous call and evaluate it in the next call. So basically Basic Calculator II + generate the next part of the string and call again Basic Calculator II.\\n\\n```\\n\\tint target;\\n    List<String> answer = new ArrayList<>();\\n    \\n    public List<String> addOperators(String num, int target) {\\n        this.target = target;\\n        addOp(num, 0, new StringBuilder(), 0, 0, \\'+\\', 0);\\n        return answer;\\n    }\\n    \\n    public void addOp(String num, int i, StringBuilder sb, long lOp, long rOp, char prevOp, long sum) {\\n        int numLen = num.length();\\n        int resLen = sb.length();\\n        \\n        // Get the current char of the result\\n        char c = resLen > 0 ? sb.charAt(resLen - 1) : \\'+\\';\\n        \\n        // Have this because we have multiple calls\\n        boolean isDigit = Character.isDigit(c);\\n        \\n        // Check this here in case we reach i==numLen and there is still a digit we haven\\'t added to rOp\\n        if(isDigit) {\\n            rOp = rOp * 10 + (c - \\'0\\');\\n        }\\n         \\n        // We want to to this once before ending at i==numLen\\n        if(resLen == 0 || i == numLen || c == \\'*\\' || c == \\'+\\' || c == \\'-\\') {\\n            if(prevOp == \\'+\\') {\\n                sum += lOp;\\n                lOp = rOp;\\n            } else if(prevOp == \\'-\\') {\\n                sum += lOp;\\n                lOp = -rOp;\\n            } else {\\n                lOp = lOp * rOp;\\n            }\\n            rOp = 0;\\n            prevOp = c;            \\n        } else if(isDigit) {           \\n            // Add operations and evaluate\\n            addOp(num, i, new StringBuilder(sb).append(\\'+\\'), lOp, rOp, prevOp, sum);\\n            addOp(num, i, new StringBuilder(sb).append(\\'-\\'), lOp, rOp, prevOp, sum);\\n            addOp(num, i, new StringBuilder(sb).append(\\'*\\'), lOp, rOp, prevOp, sum);                \\n        }\\n        \\n        // If we havent reached the end, we try NOT adding an operation.\\n        if(i < numLen) {\\n            // This prevent 05, 00. Catches leading zeros.\\n            if(!isDigit || (isDigit && (rOp != 0))) {\\n                addOp(num, i+1, sb.append(num.charAt(i)), lOp, rOp, prevOp, sum);                \\n            }            \\n        } else {\\n            // Base case is here. When we reached the end but already did all operations above.\\n            long result = sum + lOp;\\n            if(result == this.target) {\\n                this.answer.add(sb.toString());\\n            }\\n        }\\n    }\\n```",
                "solutionTags": [],
                "code": "```\\n\\tint target;\\n    List<String> answer = new ArrayList<>();\\n    \\n    public List<String> addOperators(String num, int target) {\\n        this.target = target;\\n        addOp(num, 0, new StringBuilder(), 0, 0, \\'+\\', 0);\\n        return answer;\\n    }\\n    \\n    public void addOp(String num, int i, StringBuilder sb, long lOp, long rOp, char prevOp, long sum) {\\n        int numLen = num.length();\\n        int resLen = sb.length();\\n        \\n        // Get the current char of the result\\n        char c = resLen > 0 ? sb.charAt(resLen - 1) : \\'+\\';\\n        \\n        // Have this because we have multiple calls\\n        boolean isDigit = Character.isDigit(c);\\n        \\n        // Check this here in case we reach i==numLen and there is still a digit we haven\\'t added to rOp\\n        if(isDigit) {\\n            rOp = rOp * 10 + (c - \\'0\\');\\n        }\\n         \\n        // We want to to this once before ending at i==numLen\\n        if(resLen == 0 || i == numLen || c == \\'*\\' || c == \\'+\\' || c == \\'-\\') {\\n            if(prevOp == \\'+\\') {\\n                sum += lOp;\\n                lOp = rOp;\\n            } else if(prevOp == \\'-\\') {\\n                sum += lOp;\\n                lOp = -rOp;\\n            } else {\\n                lOp = lOp * rOp;\\n            }\\n            rOp = 0;\\n            prevOp = c;            \\n        } else if(isDigit) {           \\n            // Add operations and evaluate\\n            addOp(num, i, new StringBuilder(sb).append(\\'+\\'), lOp, rOp, prevOp, sum);\\n            addOp(num, i, new StringBuilder(sb).append(\\'-\\'), lOp, rOp, prevOp, sum);\\n            addOp(num, i, new StringBuilder(sb).append(\\'*\\'), lOp, rOp, prevOp, sum);                \\n        }\\n        \\n        // If we havent reached the end, we try NOT adding an operation.\\n        if(i < numLen) {\\n            // This prevent 05, 00. Catches leading zeros.\\n            if(!isDigit || (isDigit && (rOp != 0))) {\\n                addOp(num, i+1, sb.append(num.charAt(i)), lOp, rOp, prevOp, sum);                \\n            }            \\n        } else {\\n            // Base case is here. When we reached the end but already did all operations above.\\n            long result = sum + lOp;\\n            if(result == this.target) {\\n                this.answer.add(sb.toString());\\n            }\\n        }\\n    }\\n```",
                "codeTag": "Unknown"
            }
        ],
        "discussions": [
            {
                "id": 1564924,
                "content": [
                    {
                        "username": "Israfel",
                        "content": "My input:\\n\\n\\u201c105\\u201d\\n5\\n\\nMy answer:\\n\\n    [\"10-5\",\"1*05\",\"1*0+5\"]\\n\\nExpected answer:\\n\\n    [\"1*0+5\",\"10-5\"]"
                    },
                    {
                        "username": "mike1029",
                        "content": "no leading 0 is required\\n"
                    },
                    {
                        "username": "turbocv",
                        "content": "who knows divide and conquer solution for this problem?"
                    },
                    {
                        "username": "manideepak650",
                        "content": "One of the misleading problems that I ever faced. The description clearly mentioned the operators must be placed between the digits. Yet, one of the testcases for 105 illustrated that 10 - 5."
                    },
                    {
                        "username": "MoRatio",
                        "content": "[@cartesPerforees](/cartesPerforees) \"But the prohibition to have leading zeroes does indicate that we can take more than a single digit tho\"\n\n\nNot really. Nothing should be \"indicated\" or \"implied\" anyway. The problem statement is formatted poorly. Simply state that individual digits in the string can be combined to form larger numbers and give an example."
                    },
                    {
                        "username": "cartesPerforees",
                        "content": "the \"-\" is between 0 and 5. 0 is a digit and so is 5, so it is placed between two digits. I don't see a contradiction.\nDo you mean that it is not clear whether we have the right to consider more than a single digit in the partition? Maybe it is not totally clear on that point. But the prohibition to have leading zeroes does indicate that we can take more than a single digit tho"
                    },
                    {
                        "username": "Student2091",
                        "content": "The way this problem phrases \\'+\\', \\'-\\', and/or \\'*\\' is really misleading. \\nI read it as \\'+\\', \\'-\\', and \\'/\\' or \\'\\\\*\\'. I then assumed the `/` is double division because \"72\" 3 expected answer is []. I also tried to come up with a DP solution because it is a tad slow. \\n\\nI wasted like 30 minutes on this. I took me a long time to realize `/` is not included."
                    },
                    {
                        "username": "cartesPerforees",
                        "content": "I don;t know how it was in 2022, but as of 2023, the formatting leaves little ambiguity. Visually, it is hard to  confuse \n\" `+`,`-` and/or `*` \" \nfor \" `+`,`-` and `/` or `*` \""
                    },
                    {
                        "username": "mustafabar",
                        "content": "for the test case 105 and target = 5, why is 1 * 05 not equal to 5? isn\\'t it leading 0 negligible ?"
                    },
                    {
                        "username": "abhinavsalar",
                        "content": "As far I have noticed if the dig is zero than it can not be include directly or as a prefix for some others digits. It can only be included as a suffix part of a digit."
                    },
                    {
                        "username": "zack0927",
                        "content": "Time Complexity:\\nT(n) = 3 * T(n-1) + 3 * T(n-2) + 3 * T(n-3) + ... + 3 *T(1) + O(n)\\nT(n-1) = 3 * T(n-2) + 3 * T(n-3) + ... 3 * T(1) + O(n)\\nT(0) = O(n)\\n\\nThe O(n) part is because of string copying. Thus T(n) = 4T(n-1) = 4 * 4^(n-1) * T(0) = O(n * 4 ^ n)\\nPlease correct me if I am wrong!!!"
                    },
                    {
                        "username": "paltech",
                        "content": "When the given string is 105 and target value is 5, i am not sure why \"1 * 05\" not considered as value eventhough  10 - 5 is value"
                    },
                    {
                        "username": "Adetomiwa",
                        "content": "According to the question, each number is expected to have no leading zeros. Basically, \"5\" is not considered the same as \"05\"."
                    },
                    {
                        "username": "HappyCerberus",
                        "content": "My solution found these two matches which indeed evaluate to 9191.\\n\\n\\t[\"34/5+62*37*4+9+0\",\"34/5+62*37*4+9-0\"]\\n\\t"
                    },
                    {
                        "username": "biciclub",
                        "content": "It appears division is not allowed"
                    },
                    {
                        "username": "kabir_singh",
                        "content": "for \"105\" the answer should be [1*0+5, 10-5, 1*05]. The last option has not been included in the question but is a valid answer"
                    },
                    {
                        "username": "doverbeach",
                        "content": "The output from Example 3 includes \"10-5\" which contains no operator between the digits 1 and 0. If this is permissable, would it be fair to say that the output from Example 4 should also include \"00\" which has the same value as the target?\\n*apologies for nitpicking lol"
                    }
                ]
            },
            {
                "id": 1565668,
                "content": [
                    {
                        "username": "Israfel",
                        "content": "My input:\\n\\n\\u201c105\\u201d\\n5\\n\\nMy answer:\\n\\n    [\"10-5\",\"1*05\",\"1*0+5\"]\\n\\nExpected answer:\\n\\n    [\"1*0+5\",\"10-5\"]"
                    },
                    {
                        "username": "mike1029",
                        "content": "no leading 0 is required\\n"
                    },
                    {
                        "username": "turbocv",
                        "content": "who knows divide and conquer solution for this problem?"
                    },
                    {
                        "username": "manideepak650",
                        "content": "One of the misleading problems that I ever faced. The description clearly mentioned the operators must be placed between the digits. Yet, one of the testcases for 105 illustrated that 10 - 5."
                    },
                    {
                        "username": "MoRatio",
                        "content": "[@cartesPerforees](/cartesPerforees) \"But the prohibition to have leading zeroes does indicate that we can take more than a single digit tho\"\n\n\nNot really. Nothing should be \"indicated\" or \"implied\" anyway. The problem statement is formatted poorly. Simply state that individual digits in the string can be combined to form larger numbers and give an example."
                    },
                    {
                        "username": "cartesPerforees",
                        "content": "the \"-\" is between 0 and 5. 0 is a digit and so is 5, so it is placed between two digits. I don't see a contradiction.\nDo you mean that it is not clear whether we have the right to consider more than a single digit in the partition? Maybe it is not totally clear on that point. But the prohibition to have leading zeroes does indicate that we can take more than a single digit tho"
                    },
                    {
                        "username": "Student2091",
                        "content": "The way this problem phrases \\'+\\', \\'-\\', and/or \\'*\\' is really misleading. \\nI read it as \\'+\\', \\'-\\', and \\'/\\' or \\'\\\\*\\'. I then assumed the `/` is double division because \"72\" 3 expected answer is []. I also tried to come up with a DP solution because it is a tad slow. \\n\\nI wasted like 30 minutes on this. I took me a long time to realize `/` is not included."
                    },
                    {
                        "username": "cartesPerforees",
                        "content": "I don;t know how it was in 2022, but as of 2023, the formatting leaves little ambiguity. Visually, it is hard to  confuse \n\" `+`,`-` and/or `*` \" \nfor \" `+`,`-` and `/` or `*` \""
                    },
                    {
                        "username": "mustafabar",
                        "content": "for the test case 105 and target = 5, why is 1 * 05 not equal to 5? isn\\'t it leading 0 negligible ?"
                    },
                    {
                        "username": "abhinavsalar",
                        "content": "As far I have noticed if the dig is zero than it can not be include directly or as a prefix for some others digits. It can only be included as a suffix part of a digit."
                    },
                    {
                        "username": "zack0927",
                        "content": "Time Complexity:\\nT(n) = 3 * T(n-1) + 3 * T(n-2) + 3 * T(n-3) + ... + 3 *T(1) + O(n)\\nT(n-1) = 3 * T(n-2) + 3 * T(n-3) + ... 3 * T(1) + O(n)\\nT(0) = O(n)\\n\\nThe O(n) part is because of string copying. Thus T(n) = 4T(n-1) = 4 * 4^(n-1) * T(0) = O(n * 4 ^ n)\\nPlease correct me if I am wrong!!!"
                    },
                    {
                        "username": "paltech",
                        "content": "When the given string is 105 and target value is 5, i am not sure why \"1 * 05\" not considered as value eventhough  10 - 5 is value"
                    },
                    {
                        "username": "Adetomiwa",
                        "content": "According to the question, each number is expected to have no leading zeros. Basically, \"5\" is not considered the same as \"05\"."
                    },
                    {
                        "username": "HappyCerberus",
                        "content": "My solution found these two matches which indeed evaluate to 9191.\\n\\n\\t[\"34/5+62*37*4+9+0\",\"34/5+62*37*4+9-0\"]\\n\\t"
                    },
                    {
                        "username": "biciclub",
                        "content": "It appears division is not allowed"
                    },
                    {
                        "username": "kabir_singh",
                        "content": "for \"105\" the answer should be [1*0+5, 10-5, 1*05]. The last option has not been included in the question but is a valid answer"
                    },
                    {
                        "username": "doverbeach",
                        "content": "The output from Example 3 includes \"10-5\" which contains no operator between the digits 1 and 0. If this is permissable, would it be fair to say that the output from Example 4 should also include \"00\" which has the same value as the target?\\n*apologies for nitpicking lol"
                    }
                ]
            },
            {
                "id": 1747503,
                "content": [
                    {
                        "username": "Israfel",
                        "content": "My input:\\n\\n\\u201c105\\u201d\\n5\\n\\nMy answer:\\n\\n    [\"10-5\",\"1*05\",\"1*0+5\"]\\n\\nExpected answer:\\n\\n    [\"1*0+5\",\"10-5\"]"
                    },
                    {
                        "username": "mike1029",
                        "content": "no leading 0 is required\\n"
                    },
                    {
                        "username": "turbocv",
                        "content": "who knows divide and conquer solution for this problem?"
                    },
                    {
                        "username": "manideepak650",
                        "content": "One of the misleading problems that I ever faced. The description clearly mentioned the operators must be placed between the digits. Yet, one of the testcases for 105 illustrated that 10 - 5."
                    },
                    {
                        "username": "MoRatio",
                        "content": "[@cartesPerforees](/cartesPerforees) \"But the prohibition to have leading zeroes does indicate that we can take more than a single digit tho\"\n\n\nNot really. Nothing should be \"indicated\" or \"implied\" anyway. The problem statement is formatted poorly. Simply state that individual digits in the string can be combined to form larger numbers and give an example."
                    },
                    {
                        "username": "cartesPerforees",
                        "content": "the \"-\" is between 0 and 5. 0 is a digit and so is 5, so it is placed between two digits. I don't see a contradiction.\nDo you mean that it is not clear whether we have the right to consider more than a single digit in the partition? Maybe it is not totally clear on that point. But the prohibition to have leading zeroes does indicate that we can take more than a single digit tho"
                    },
                    {
                        "username": "Student2091",
                        "content": "The way this problem phrases \\'+\\', \\'-\\', and/or \\'*\\' is really misleading. \\nI read it as \\'+\\', \\'-\\', and \\'/\\' or \\'\\\\*\\'. I then assumed the `/` is double division because \"72\" 3 expected answer is []. I also tried to come up with a DP solution because it is a tad slow. \\n\\nI wasted like 30 minutes on this. I took me a long time to realize `/` is not included."
                    },
                    {
                        "username": "cartesPerforees",
                        "content": "I don;t know how it was in 2022, but as of 2023, the formatting leaves little ambiguity. Visually, it is hard to  confuse \n\" `+`,`-` and/or `*` \" \nfor \" `+`,`-` and `/` or `*` \""
                    },
                    {
                        "username": "mustafabar",
                        "content": "for the test case 105 and target = 5, why is 1 * 05 not equal to 5? isn\\'t it leading 0 negligible ?"
                    },
                    {
                        "username": "abhinavsalar",
                        "content": "As far I have noticed if the dig is zero than it can not be include directly or as a prefix for some others digits. It can only be included as a suffix part of a digit."
                    },
                    {
                        "username": "zack0927",
                        "content": "Time Complexity:\\nT(n) = 3 * T(n-1) + 3 * T(n-2) + 3 * T(n-3) + ... + 3 *T(1) + O(n)\\nT(n-1) = 3 * T(n-2) + 3 * T(n-3) + ... 3 * T(1) + O(n)\\nT(0) = O(n)\\n\\nThe O(n) part is because of string copying. Thus T(n) = 4T(n-1) = 4 * 4^(n-1) * T(0) = O(n * 4 ^ n)\\nPlease correct me if I am wrong!!!"
                    },
                    {
                        "username": "paltech",
                        "content": "When the given string is 105 and target value is 5, i am not sure why \"1 * 05\" not considered as value eventhough  10 - 5 is value"
                    },
                    {
                        "username": "Adetomiwa",
                        "content": "According to the question, each number is expected to have no leading zeros. Basically, \"5\" is not considered the same as \"05\"."
                    },
                    {
                        "username": "HappyCerberus",
                        "content": "My solution found these two matches which indeed evaluate to 9191.\\n\\n\\t[\"34/5+62*37*4+9+0\",\"34/5+62*37*4+9-0\"]\\n\\t"
                    },
                    {
                        "username": "biciclub",
                        "content": "It appears division is not allowed"
                    },
                    {
                        "username": "kabir_singh",
                        "content": "for \"105\" the answer should be [1*0+5, 10-5, 1*05]. The last option has not been included in the question but is a valid answer"
                    },
                    {
                        "username": "doverbeach",
                        "content": "The output from Example 3 includes \"10-5\" which contains no operator between the digits 1 and 0. If this is permissable, would it be fair to say that the output from Example 4 should also include \"00\" which has the same value as the target?\\n*apologies for nitpicking lol"
                    }
                ]
            },
            {
                "id": 1576894,
                "content": [
                    {
                        "username": "Israfel",
                        "content": "My input:\\n\\n\\u201c105\\u201d\\n5\\n\\nMy answer:\\n\\n    [\"10-5\",\"1*05\",\"1*0+5\"]\\n\\nExpected answer:\\n\\n    [\"1*0+5\",\"10-5\"]"
                    },
                    {
                        "username": "mike1029",
                        "content": "no leading 0 is required\\n"
                    },
                    {
                        "username": "turbocv",
                        "content": "who knows divide and conquer solution for this problem?"
                    },
                    {
                        "username": "manideepak650",
                        "content": "One of the misleading problems that I ever faced. The description clearly mentioned the operators must be placed between the digits. Yet, one of the testcases for 105 illustrated that 10 - 5."
                    },
                    {
                        "username": "MoRatio",
                        "content": "[@cartesPerforees](/cartesPerforees) \"But the prohibition to have leading zeroes does indicate that we can take more than a single digit tho\"\n\n\nNot really. Nothing should be \"indicated\" or \"implied\" anyway. The problem statement is formatted poorly. Simply state that individual digits in the string can be combined to form larger numbers and give an example."
                    },
                    {
                        "username": "cartesPerforees",
                        "content": "the \"-\" is between 0 and 5. 0 is a digit and so is 5, so it is placed between two digits. I don't see a contradiction.\nDo you mean that it is not clear whether we have the right to consider more than a single digit in the partition? Maybe it is not totally clear on that point. But the prohibition to have leading zeroes does indicate that we can take more than a single digit tho"
                    },
                    {
                        "username": "Student2091",
                        "content": "The way this problem phrases \\'+\\', \\'-\\', and/or \\'*\\' is really misleading. \\nI read it as \\'+\\', \\'-\\', and \\'/\\' or \\'\\\\*\\'. I then assumed the `/` is double division because \"72\" 3 expected answer is []. I also tried to come up with a DP solution because it is a tad slow. \\n\\nI wasted like 30 minutes on this. I took me a long time to realize `/` is not included."
                    },
                    {
                        "username": "cartesPerforees",
                        "content": "I don;t know how it was in 2022, but as of 2023, the formatting leaves little ambiguity. Visually, it is hard to  confuse \n\" `+`,`-` and/or `*` \" \nfor \" `+`,`-` and `/` or `*` \""
                    },
                    {
                        "username": "mustafabar",
                        "content": "for the test case 105 and target = 5, why is 1 * 05 not equal to 5? isn\\'t it leading 0 negligible ?"
                    },
                    {
                        "username": "abhinavsalar",
                        "content": "As far I have noticed if the dig is zero than it can not be include directly or as a prefix for some others digits. It can only be included as a suffix part of a digit."
                    },
                    {
                        "username": "zack0927",
                        "content": "Time Complexity:\\nT(n) = 3 * T(n-1) + 3 * T(n-2) + 3 * T(n-3) + ... + 3 *T(1) + O(n)\\nT(n-1) = 3 * T(n-2) + 3 * T(n-3) + ... 3 * T(1) + O(n)\\nT(0) = O(n)\\n\\nThe O(n) part is because of string copying. Thus T(n) = 4T(n-1) = 4 * 4^(n-1) * T(0) = O(n * 4 ^ n)\\nPlease correct me if I am wrong!!!"
                    },
                    {
                        "username": "paltech",
                        "content": "When the given string is 105 and target value is 5, i am not sure why \"1 * 05\" not considered as value eventhough  10 - 5 is value"
                    },
                    {
                        "username": "Adetomiwa",
                        "content": "According to the question, each number is expected to have no leading zeros. Basically, \"5\" is not considered the same as \"05\"."
                    },
                    {
                        "username": "HappyCerberus",
                        "content": "My solution found these two matches which indeed evaluate to 9191.\\n\\n\\t[\"34/5+62*37*4+9+0\",\"34/5+62*37*4+9-0\"]\\n\\t"
                    },
                    {
                        "username": "biciclub",
                        "content": "It appears division is not allowed"
                    },
                    {
                        "username": "kabir_singh",
                        "content": "for \"105\" the answer should be [1*0+5, 10-5, 1*05]. The last option has not been included in the question but is a valid answer"
                    },
                    {
                        "username": "doverbeach",
                        "content": "The output from Example 3 includes \"10-5\" which contains no operator between the digits 1 and 0. If this is permissable, would it be fair to say that the output from Example 4 should also include \"00\" which has the same value as the target?\\n*apologies for nitpicking lol"
                    }
                ]
            },
            {
                "id": 1568041,
                "content": [
                    {
                        "username": "Israfel",
                        "content": "My input:\\n\\n\\u201c105\\u201d\\n5\\n\\nMy answer:\\n\\n    [\"10-5\",\"1*05\",\"1*0+5\"]\\n\\nExpected answer:\\n\\n    [\"1*0+5\",\"10-5\"]"
                    },
                    {
                        "username": "mike1029",
                        "content": "no leading 0 is required\\n"
                    },
                    {
                        "username": "turbocv",
                        "content": "who knows divide and conquer solution for this problem?"
                    },
                    {
                        "username": "manideepak650",
                        "content": "One of the misleading problems that I ever faced. The description clearly mentioned the operators must be placed between the digits. Yet, one of the testcases for 105 illustrated that 10 - 5."
                    },
                    {
                        "username": "MoRatio",
                        "content": "[@cartesPerforees](/cartesPerforees) \"But the prohibition to have leading zeroes does indicate that we can take more than a single digit tho\"\n\n\nNot really. Nothing should be \"indicated\" or \"implied\" anyway. The problem statement is formatted poorly. Simply state that individual digits in the string can be combined to form larger numbers and give an example."
                    },
                    {
                        "username": "cartesPerforees",
                        "content": "the \"-\" is between 0 and 5. 0 is a digit and so is 5, so it is placed between two digits. I don't see a contradiction.\nDo you mean that it is not clear whether we have the right to consider more than a single digit in the partition? Maybe it is not totally clear on that point. But the prohibition to have leading zeroes does indicate that we can take more than a single digit tho"
                    },
                    {
                        "username": "Student2091",
                        "content": "The way this problem phrases \\'+\\', \\'-\\', and/or \\'*\\' is really misleading. \\nI read it as \\'+\\', \\'-\\', and \\'/\\' or \\'\\\\*\\'. I then assumed the `/` is double division because \"72\" 3 expected answer is []. I also tried to come up with a DP solution because it is a tad slow. \\n\\nI wasted like 30 minutes on this. I took me a long time to realize `/` is not included."
                    },
                    {
                        "username": "cartesPerforees",
                        "content": "I don;t know how it was in 2022, but as of 2023, the formatting leaves little ambiguity. Visually, it is hard to  confuse \n\" `+`,`-` and/or `*` \" \nfor \" `+`,`-` and `/` or `*` \""
                    },
                    {
                        "username": "mustafabar",
                        "content": "for the test case 105 and target = 5, why is 1 * 05 not equal to 5? isn\\'t it leading 0 negligible ?"
                    },
                    {
                        "username": "abhinavsalar",
                        "content": "As far I have noticed if the dig is zero than it can not be include directly or as a prefix for some others digits. It can only be included as a suffix part of a digit."
                    },
                    {
                        "username": "zack0927",
                        "content": "Time Complexity:\\nT(n) = 3 * T(n-1) + 3 * T(n-2) + 3 * T(n-3) + ... + 3 *T(1) + O(n)\\nT(n-1) = 3 * T(n-2) + 3 * T(n-3) + ... 3 * T(1) + O(n)\\nT(0) = O(n)\\n\\nThe O(n) part is because of string copying. Thus T(n) = 4T(n-1) = 4 * 4^(n-1) * T(0) = O(n * 4 ^ n)\\nPlease correct me if I am wrong!!!"
                    },
                    {
                        "username": "paltech",
                        "content": "When the given string is 105 and target value is 5, i am not sure why \"1 * 05\" not considered as value eventhough  10 - 5 is value"
                    },
                    {
                        "username": "Adetomiwa",
                        "content": "According to the question, each number is expected to have no leading zeros. Basically, \"5\" is not considered the same as \"05\"."
                    },
                    {
                        "username": "HappyCerberus",
                        "content": "My solution found these two matches which indeed evaluate to 9191.\\n\\n\\t[\"34/5+62*37*4+9+0\",\"34/5+62*37*4+9-0\"]\\n\\t"
                    },
                    {
                        "username": "biciclub",
                        "content": "It appears division is not allowed"
                    },
                    {
                        "username": "kabir_singh",
                        "content": "for \"105\" the answer should be [1*0+5, 10-5, 1*05]. The last option has not been included in the question but is a valid answer"
                    },
                    {
                        "username": "doverbeach",
                        "content": "The output from Example 3 includes \"10-5\" which contains no operator between the digits 1 and 0. If this is permissable, would it be fair to say that the output from Example 4 should also include \"00\" which has the same value as the target?\\n*apologies for nitpicking lol"
                    }
                ]
            },
            {
                "id": 1570495,
                "content": [
                    {
                        "username": "Israfel",
                        "content": "My input:\\n\\n\\u201c105\\u201d\\n5\\n\\nMy answer:\\n\\n    [\"10-5\",\"1*05\",\"1*0+5\"]\\n\\nExpected answer:\\n\\n    [\"1*0+5\",\"10-5\"]"
                    },
                    {
                        "username": "mike1029",
                        "content": "no leading 0 is required\\n"
                    },
                    {
                        "username": "turbocv",
                        "content": "who knows divide and conquer solution for this problem?"
                    },
                    {
                        "username": "manideepak650",
                        "content": "One of the misleading problems that I ever faced. The description clearly mentioned the operators must be placed between the digits. Yet, one of the testcases for 105 illustrated that 10 - 5."
                    },
                    {
                        "username": "MoRatio",
                        "content": "[@cartesPerforees](/cartesPerforees) \"But the prohibition to have leading zeroes does indicate that we can take more than a single digit tho\"\n\n\nNot really. Nothing should be \"indicated\" or \"implied\" anyway. The problem statement is formatted poorly. Simply state that individual digits in the string can be combined to form larger numbers and give an example."
                    },
                    {
                        "username": "cartesPerforees",
                        "content": "the \"-\" is between 0 and 5. 0 is a digit and so is 5, so it is placed between two digits. I don't see a contradiction.\nDo you mean that it is not clear whether we have the right to consider more than a single digit in the partition? Maybe it is not totally clear on that point. But the prohibition to have leading zeroes does indicate that we can take more than a single digit tho"
                    },
                    {
                        "username": "Student2091",
                        "content": "The way this problem phrases \\'+\\', \\'-\\', and/or \\'*\\' is really misleading. \\nI read it as \\'+\\', \\'-\\', and \\'/\\' or \\'\\\\*\\'. I then assumed the `/` is double division because \"72\" 3 expected answer is []. I also tried to come up with a DP solution because it is a tad slow. \\n\\nI wasted like 30 minutes on this. I took me a long time to realize `/` is not included."
                    },
                    {
                        "username": "cartesPerforees",
                        "content": "I don;t know how it was in 2022, but as of 2023, the formatting leaves little ambiguity. Visually, it is hard to  confuse \n\" `+`,`-` and/or `*` \" \nfor \" `+`,`-` and `/` or `*` \""
                    },
                    {
                        "username": "mustafabar",
                        "content": "for the test case 105 and target = 5, why is 1 * 05 not equal to 5? isn\\'t it leading 0 negligible ?"
                    },
                    {
                        "username": "abhinavsalar",
                        "content": "As far I have noticed if the dig is zero than it can not be include directly or as a prefix for some others digits. It can only be included as a suffix part of a digit."
                    },
                    {
                        "username": "zack0927",
                        "content": "Time Complexity:\\nT(n) = 3 * T(n-1) + 3 * T(n-2) + 3 * T(n-3) + ... + 3 *T(1) + O(n)\\nT(n-1) = 3 * T(n-2) + 3 * T(n-3) + ... 3 * T(1) + O(n)\\nT(0) = O(n)\\n\\nThe O(n) part is because of string copying. Thus T(n) = 4T(n-1) = 4 * 4^(n-1) * T(0) = O(n * 4 ^ n)\\nPlease correct me if I am wrong!!!"
                    },
                    {
                        "username": "paltech",
                        "content": "When the given string is 105 and target value is 5, i am not sure why \"1 * 05\" not considered as value eventhough  10 - 5 is value"
                    },
                    {
                        "username": "Adetomiwa",
                        "content": "According to the question, each number is expected to have no leading zeros. Basically, \"5\" is not considered the same as \"05\"."
                    },
                    {
                        "username": "HappyCerberus",
                        "content": "My solution found these two matches which indeed evaluate to 9191.\\n\\n\\t[\"34/5+62*37*4+9+0\",\"34/5+62*37*4+9-0\"]\\n\\t"
                    },
                    {
                        "username": "biciclub",
                        "content": "It appears division is not allowed"
                    },
                    {
                        "username": "kabir_singh",
                        "content": "for \"105\" the answer should be [1*0+5, 10-5, 1*05]. The last option has not been included in the question but is a valid answer"
                    },
                    {
                        "username": "doverbeach",
                        "content": "The output from Example 3 includes \"10-5\" which contains no operator between the digits 1 and 0. If this is permissable, would it be fair to say that the output from Example 4 should also include \"00\" which has the same value as the target?\\n*apologies for nitpicking lol"
                    }
                ]
            },
            {
                "id": 1569873,
                "content": [
                    {
                        "username": "Israfel",
                        "content": "My input:\\n\\n\\u201c105\\u201d\\n5\\n\\nMy answer:\\n\\n    [\"10-5\",\"1*05\",\"1*0+5\"]\\n\\nExpected answer:\\n\\n    [\"1*0+5\",\"10-5\"]"
                    },
                    {
                        "username": "mike1029",
                        "content": "no leading 0 is required\\n"
                    },
                    {
                        "username": "turbocv",
                        "content": "who knows divide and conquer solution for this problem?"
                    },
                    {
                        "username": "manideepak650",
                        "content": "One of the misleading problems that I ever faced. The description clearly mentioned the operators must be placed between the digits. Yet, one of the testcases for 105 illustrated that 10 - 5."
                    },
                    {
                        "username": "MoRatio",
                        "content": "[@cartesPerforees](/cartesPerforees) \"But the prohibition to have leading zeroes does indicate that we can take more than a single digit tho\"\n\n\nNot really. Nothing should be \"indicated\" or \"implied\" anyway. The problem statement is formatted poorly. Simply state that individual digits in the string can be combined to form larger numbers and give an example."
                    },
                    {
                        "username": "cartesPerforees",
                        "content": "the \"-\" is between 0 and 5. 0 is a digit and so is 5, so it is placed between two digits. I don't see a contradiction.\nDo you mean that it is not clear whether we have the right to consider more than a single digit in the partition? Maybe it is not totally clear on that point. But the prohibition to have leading zeroes does indicate that we can take more than a single digit tho"
                    },
                    {
                        "username": "Student2091",
                        "content": "The way this problem phrases \\'+\\', \\'-\\', and/or \\'*\\' is really misleading. \\nI read it as \\'+\\', \\'-\\', and \\'/\\' or \\'\\\\*\\'. I then assumed the `/` is double division because \"72\" 3 expected answer is []. I also tried to come up with a DP solution because it is a tad slow. \\n\\nI wasted like 30 minutes on this. I took me a long time to realize `/` is not included."
                    },
                    {
                        "username": "cartesPerforees",
                        "content": "I don;t know how it was in 2022, but as of 2023, the formatting leaves little ambiguity. Visually, it is hard to  confuse \n\" `+`,`-` and/or `*` \" \nfor \" `+`,`-` and `/` or `*` \""
                    },
                    {
                        "username": "mustafabar",
                        "content": "for the test case 105 and target = 5, why is 1 * 05 not equal to 5? isn\\'t it leading 0 negligible ?"
                    },
                    {
                        "username": "abhinavsalar",
                        "content": "As far I have noticed if the dig is zero than it can not be include directly or as a prefix for some others digits. It can only be included as a suffix part of a digit."
                    },
                    {
                        "username": "zack0927",
                        "content": "Time Complexity:\\nT(n) = 3 * T(n-1) + 3 * T(n-2) + 3 * T(n-3) + ... + 3 *T(1) + O(n)\\nT(n-1) = 3 * T(n-2) + 3 * T(n-3) + ... 3 * T(1) + O(n)\\nT(0) = O(n)\\n\\nThe O(n) part is because of string copying. Thus T(n) = 4T(n-1) = 4 * 4^(n-1) * T(0) = O(n * 4 ^ n)\\nPlease correct me if I am wrong!!!"
                    },
                    {
                        "username": "paltech",
                        "content": "When the given string is 105 and target value is 5, i am not sure why \"1 * 05\" not considered as value eventhough  10 - 5 is value"
                    },
                    {
                        "username": "Adetomiwa",
                        "content": "According to the question, each number is expected to have no leading zeros. Basically, \"5\" is not considered the same as \"05\"."
                    },
                    {
                        "username": "HappyCerberus",
                        "content": "My solution found these two matches which indeed evaluate to 9191.\\n\\n\\t[\"34/5+62*37*4+9+0\",\"34/5+62*37*4+9-0\"]\\n\\t"
                    },
                    {
                        "username": "biciclub",
                        "content": "It appears division is not allowed"
                    },
                    {
                        "username": "kabir_singh",
                        "content": "for \"105\" the answer should be [1*0+5, 10-5, 1*05]. The last option has not been included in the question but is a valid answer"
                    },
                    {
                        "username": "doverbeach",
                        "content": "The output from Example 3 includes \"10-5\" which contains no operator between the digits 1 and 0. If this is permissable, would it be fair to say that the output from Example 4 should also include \"00\" which has the same value as the target?\\n*apologies for nitpicking lol"
                    }
                ]
            },
            {
                "id": 1569747,
                "content": [
                    {
                        "username": "Israfel",
                        "content": "My input:\\n\\n\\u201c105\\u201d\\n5\\n\\nMy answer:\\n\\n    [\"10-5\",\"1*05\",\"1*0+5\"]\\n\\nExpected answer:\\n\\n    [\"1*0+5\",\"10-5\"]"
                    },
                    {
                        "username": "mike1029",
                        "content": "no leading 0 is required\\n"
                    },
                    {
                        "username": "turbocv",
                        "content": "who knows divide and conquer solution for this problem?"
                    },
                    {
                        "username": "manideepak650",
                        "content": "One of the misleading problems that I ever faced. The description clearly mentioned the operators must be placed between the digits. Yet, one of the testcases for 105 illustrated that 10 - 5."
                    },
                    {
                        "username": "MoRatio",
                        "content": "[@cartesPerforees](/cartesPerforees) \"But the prohibition to have leading zeroes does indicate that we can take more than a single digit tho\"\n\n\nNot really. Nothing should be \"indicated\" or \"implied\" anyway. The problem statement is formatted poorly. Simply state that individual digits in the string can be combined to form larger numbers and give an example."
                    },
                    {
                        "username": "cartesPerforees",
                        "content": "the \"-\" is between 0 and 5. 0 is a digit and so is 5, so it is placed between two digits. I don't see a contradiction.\nDo you mean that it is not clear whether we have the right to consider more than a single digit in the partition? Maybe it is not totally clear on that point. But the prohibition to have leading zeroes does indicate that we can take more than a single digit tho"
                    },
                    {
                        "username": "Student2091",
                        "content": "The way this problem phrases \\'+\\', \\'-\\', and/or \\'*\\' is really misleading. \\nI read it as \\'+\\', \\'-\\', and \\'/\\' or \\'\\\\*\\'. I then assumed the `/` is double division because \"72\" 3 expected answer is []. I also tried to come up with a DP solution because it is a tad slow. \\n\\nI wasted like 30 minutes on this. I took me a long time to realize `/` is not included."
                    },
                    {
                        "username": "cartesPerforees",
                        "content": "I don;t know how it was in 2022, but as of 2023, the formatting leaves little ambiguity. Visually, it is hard to  confuse \n\" `+`,`-` and/or `*` \" \nfor \" `+`,`-` and `/` or `*` \""
                    },
                    {
                        "username": "mustafabar",
                        "content": "for the test case 105 and target = 5, why is 1 * 05 not equal to 5? isn\\'t it leading 0 negligible ?"
                    },
                    {
                        "username": "abhinavsalar",
                        "content": "As far I have noticed if the dig is zero than it can not be include directly or as a prefix for some others digits. It can only be included as a suffix part of a digit."
                    },
                    {
                        "username": "zack0927",
                        "content": "Time Complexity:\\nT(n) = 3 * T(n-1) + 3 * T(n-2) + 3 * T(n-3) + ... + 3 *T(1) + O(n)\\nT(n-1) = 3 * T(n-2) + 3 * T(n-3) + ... 3 * T(1) + O(n)\\nT(0) = O(n)\\n\\nThe O(n) part is because of string copying. Thus T(n) = 4T(n-1) = 4 * 4^(n-1) * T(0) = O(n * 4 ^ n)\\nPlease correct me if I am wrong!!!"
                    },
                    {
                        "username": "paltech",
                        "content": "When the given string is 105 and target value is 5, i am not sure why \"1 * 05\" not considered as value eventhough  10 - 5 is value"
                    },
                    {
                        "username": "Adetomiwa",
                        "content": "According to the question, each number is expected to have no leading zeros. Basically, \"5\" is not considered the same as \"05\"."
                    },
                    {
                        "username": "HappyCerberus",
                        "content": "My solution found these two matches which indeed evaluate to 9191.\\n\\n\\t[\"34/5+62*37*4+9+0\",\"34/5+62*37*4+9-0\"]\\n\\t"
                    },
                    {
                        "username": "biciclub",
                        "content": "It appears division is not allowed"
                    },
                    {
                        "username": "kabir_singh",
                        "content": "for \"105\" the answer should be [1*0+5, 10-5, 1*05]. The last option has not been included in the question but is a valid answer"
                    },
                    {
                        "username": "doverbeach",
                        "content": "The output from Example 3 includes \"10-5\" which contains no operator between the digits 1 and 0. If this is permissable, would it be fair to say that the output from Example 4 should also include \"00\" which has the same value as the target?\\n*apologies for nitpicking lol"
                    }
                ]
            },
            {
                "id": 1569054,
                "content": [
                    {
                        "username": "Israfel",
                        "content": "My input:\\n\\n\\u201c105\\u201d\\n5\\n\\nMy answer:\\n\\n    [\"10-5\",\"1*05\",\"1*0+5\"]\\n\\nExpected answer:\\n\\n    [\"1*0+5\",\"10-5\"]"
                    },
                    {
                        "username": "mike1029",
                        "content": "no leading 0 is required\\n"
                    },
                    {
                        "username": "turbocv",
                        "content": "who knows divide and conquer solution for this problem?"
                    },
                    {
                        "username": "manideepak650",
                        "content": "One of the misleading problems that I ever faced. The description clearly mentioned the operators must be placed between the digits. Yet, one of the testcases for 105 illustrated that 10 - 5."
                    },
                    {
                        "username": "MoRatio",
                        "content": "[@cartesPerforees](/cartesPerforees) \"But the prohibition to have leading zeroes does indicate that we can take more than a single digit tho\"\n\n\nNot really. Nothing should be \"indicated\" or \"implied\" anyway. The problem statement is formatted poorly. Simply state that individual digits in the string can be combined to form larger numbers and give an example."
                    },
                    {
                        "username": "cartesPerforees",
                        "content": "the \"-\" is between 0 and 5. 0 is a digit and so is 5, so it is placed between two digits. I don't see a contradiction.\nDo you mean that it is not clear whether we have the right to consider more than a single digit in the partition? Maybe it is not totally clear on that point. But the prohibition to have leading zeroes does indicate that we can take more than a single digit tho"
                    },
                    {
                        "username": "Student2091",
                        "content": "The way this problem phrases \\'+\\', \\'-\\', and/or \\'*\\' is really misleading. \\nI read it as \\'+\\', \\'-\\', and \\'/\\' or \\'\\\\*\\'. I then assumed the `/` is double division because \"72\" 3 expected answer is []. I also tried to come up with a DP solution because it is a tad slow. \\n\\nI wasted like 30 minutes on this. I took me a long time to realize `/` is not included."
                    },
                    {
                        "username": "cartesPerforees",
                        "content": "I don;t know how it was in 2022, but as of 2023, the formatting leaves little ambiguity. Visually, it is hard to  confuse \n\" `+`,`-` and/or `*` \" \nfor \" `+`,`-` and `/` or `*` \""
                    },
                    {
                        "username": "mustafabar",
                        "content": "for the test case 105 and target = 5, why is 1 * 05 not equal to 5? isn\\'t it leading 0 negligible ?"
                    },
                    {
                        "username": "abhinavsalar",
                        "content": "As far I have noticed if the dig is zero than it can not be include directly or as a prefix for some others digits. It can only be included as a suffix part of a digit."
                    },
                    {
                        "username": "zack0927",
                        "content": "Time Complexity:\\nT(n) = 3 * T(n-1) + 3 * T(n-2) + 3 * T(n-3) + ... + 3 *T(1) + O(n)\\nT(n-1) = 3 * T(n-2) + 3 * T(n-3) + ... 3 * T(1) + O(n)\\nT(0) = O(n)\\n\\nThe O(n) part is because of string copying. Thus T(n) = 4T(n-1) = 4 * 4^(n-1) * T(0) = O(n * 4 ^ n)\\nPlease correct me if I am wrong!!!"
                    },
                    {
                        "username": "paltech",
                        "content": "When the given string is 105 and target value is 5, i am not sure why \"1 * 05\" not considered as value eventhough  10 - 5 is value"
                    },
                    {
                        "username": "Adetomiwa",
                        "content": "According to the question, each number is expected to have no leading zeros. Basically, \"5\" is not considered the same as \"05\"."
                    },
                    {
                        "username": "HappyCerberus",
                        "content": "My solution found these two matches which indeed evaluate to 9191.\\n\\n\\t[\"34/5+62*37*4+9+0\",\"34/5+62*37*4+9-0\"]\\n\\t"
                    },
                    {
                        "username": "biciclub",
                        "content": "It appears division is not allowed"
                    },
                    {
                        "username": "kabir_singh",
                        "content": "for \"105\" the answer should be [1*0+5, 10-5, 1*05]. The last option has not been included in the question but is a valid answer"
                    },
                    {
                        "username": "doverbeach",
                        "content": "The output from Example 3 includes \"10-5\" which contains no operator between the digits 1 and 0. If this is permissable, would it be fair to say that the output from Example 4 should also include \"00\" which has the same value as the target?\\n*apologies for nitpicking lol"
                    }
                ]
            },
            {
                "id": 1570615,
                "content": [
                    {
                        "username": "Israfel",
                        "content": "My input:\\n\\n\\u201c105\\u201d\\n5\\n\\nMy answer:\\n\\n    [\"10-5\",\"1*05\",\"1*0+5\"]\\n\\nExpected answer:\\n\\n    [\"1*0+5\",\"10-5\"]"
                    },
                    {
                        "username": "mike1029",
                        "content": "no leading 0 is required\\n"
                    },
                    {
                        "username": "turbocv",
                        "content": "who knows divide and conquer solution for this problem?"
                    },
                    {
                        "username": "manideepak650",
                        "content": "One of the misleading problems that I ever faced. The description clearly mentioned the operators must be placed between the digits. Yet, one of the testcases for 105 illustrated that 10 - 5."
                    },
                    {
                        "username": "MoRatio",
                        "content": "[@cartesPerforees](/cartesPerforees) \"But the prohibition to have leading zeroes does indicate that we can take more than a single digit tho\"\n\n\nNot really. Nothing should be \"indicated\" or \"implied\" anyway. The problem statement is formatted poorly. Simply state that individual digits in the string can be combined to form larger numbers and give an example."
                    },
                    {
                        "username": "cartesPerforees",
                        "content": "the \"-\" is between 0 and 5. 0 is a digit and so is 5, so it is placed between two digits. I don't see a contradiction.\nDo you mean that it is not clear whether we have the right to consider more than a single digit in the partition? Maybe it is not totally clear on that point. But the prohibition to have leading zeroes does indicate that we can take more than a single digit tho"
                    },
                    {
                        "username": "Student2091",
                        "content": "The way this problem phrases \\'+\\', \\'-\\', and/or \\'*\\' is really misleading. \\nI read it as \\'+\\', \\'-\\', and \\'/\\' or \\'\\\\*\\'. I then assumed the `/` is double division because \"72\" 3 expected answer is []. I also tried to come up with a DP solution because it is a tad slow. \\n\\nI wasted like 30 minutes on this. I took me a long time to realize `/` is not included."
                    },
                    {
                        "username": "cartesPerforees",
                        "content": "I don;t know how it was in 2022, but as of 2023, the formatting leaves little ambiguity. Visually, it is hard to  confuse \n\" `+`,`-` and/or `*` \" \nfor \" `+`,`-` and `/` or `*` \""
                    },
                    {
                        "username": "mustafabar",
                        "content": "for the test case 105 and target = 5, why is 1 * 05 not equal to 5? isn\\'t it leading 0 negligible ?"
                    },
                    {
                        "username": "abhinavsalar",
                        "content": "As far I have noticed if the dig is zero than it can not be include directly or as a prefix for some others digits. It can only be included as a suffix part of a digit."
                    },
                    {
                        "username": "zack0927",
                        "content": "Time Complexity:\\nT(n) = 3 * T(n-1) + 3 * T(n-2) + 3 * T(n-3) + ... + 3 *T(1) + O(n)\\nT(n-1) = 3 * T(n-2) + 3 * T(n-3) + ... 3 * T(1) + O(n)\\nT(0) = O(n)\\n\\nThe O(n) part is because of string copying. Thus T(n) = 4T(n-1) = 4 * 4^(n-1) * T(0) = O(n * 4 ^ n)\\nPlease correct me if I am wrong!!!"
                    },
                    {
                        "username": "paltech",
                        "content": "When the given string is 105 and target value is 5, i am not sure why \"1 * 05\" not considered as value eventhough  10 - 5 is value"
                    },
                    {
                        "username": "Adetomiwa",
                        "content": "According to the question, each number is expected to have no leading zeros. Basically, \"5\" is not considered the same as \"05\"."
                    },
                    {
                        "username": "HappyCerberus",
                        "content": "My solution found these two matches which indeed evaluate to 9191.\\n\\n\\t[\"34/5+62*37*4+9+0\",\"34/5+62*37*4+9-0\"]\\n\\t"
                    },
                    {
                        "username": "biciclub",
                        "content": "It appears division is not allowed"
                    },
                    {
                        "username": "kabir_singh",
                        "content": "for \"105\" the answer should be [1*0+5, 10-5, 1*05]. The last option has not been included in the question but is a valid answer"
                    },
                    {
                        "username": "doverbeach",
                        "content": "The output from Example 3 includes \"10-5\" which contains no operator between the digits 1 and 0. If this is permissable, would it be fair to say that the output from Example 4 should also include \"00\" which has the same value as the target?\\n*apologies for nitpicking lol"
                    }
                ]
            },
            {
                "id": 1564924,
                "content": [
                    {
                        "username": "Israfel",
                        "content": "My input:\\n\\n\\u201c105\\u201d\\n5\\n\\nMy answer:\\n\\n    [\"10-5\",\"1*05\",\"1*0+5\"]\\n\\nExpected answer:\\n\\n    [\"1*0+5\",\"10-5\"]"
                    },
                    {
                        "username": "mike1029",
                        "content": "no leading 0 is required\\n"
                    },
                    {
                        "username": "turbocv",
                        "content": "who knows divide and conquer solution for this problem?"
                    },
                    {
                        "username": "manideepak650",
                        "content": "One of the misleading problems that I ever faced. The description clearly mentioned the operators must be placed between the digits. Yet, one of the testcases for 105 illustrated that 10 - 5."
                    },
                    {
                        "username": "MoRatio",
                        "content": "[@cartesPerforees](/cartesPerforees) \"But the prohibition to have leading zeroes does indicate that we can take more than a single digit tho\"\n\n\nNot really. Nothing should be \"indicated\" or \"implied\" anyway. The problem statement is formatted poorly. Simply state that individual digits in the string can be combined to form larger numbers and give an example."
                    },
                    {
                        "username": "cartesPerforees",
                        "content": "the \"-\" is between 0 and 5. 0 is a digit and so is 5, so it is placed between two digits. I don't see a contradiction.\nDo you mean that it is not clear whether we have the right to consider more than a single digit in the partition? Maybe it is not totally clear on that point. But the prohibition to have leading zeroes does indicate that we can take more than a single digit tho"
                    },
                    {
                        "username": "Student2091",
                        "content": "The way this problem phrases \\'+\\', \\'-\\', and/or \\'*\\' is really misleading. \\nI read it as \\'+\\', \\'-\\', and \\'/\\' or \\'\\\\*\\'. I then assumed the `/` is double division because \"72\" 3 expected answer is []. I also tried to come up with a DP solution because it is a tad slow. \\n\\nI wasted like 30 minutes on this. I took me a long time to realize `/` is not included."
                    },
                    {
                        "username": "cartesPerforees",
                        "content": "I don;t know how it was in 2022, but as of 2023, the formatting leaves little ambiguity. Visually, it is hard to  confuse \n\" `+`,`-` and/or `*` \" \nfor \" `+`,`-` and `/` or `*` \""
                    },
                    {
                        "username": "mustafabar",
                        "content": "for the test case 105 and target = 5, why is 1 * 05 not equal to 5? isn\\'t it leading 0 negligible ?"
                    },
                    {
                        "username": "abhinavsalar",
                        "content": "As far I have noticed if the dig is zero than it can not be include directly or as a prefix for some others digits. It can only be included as a suffix part of a digit."
                    },
                    {
                        "username": "zack0927",
                        "content": "Time Complexity:\\nT(n) = 3 * T(n-1) + 3 * T(n-2) + 3 * T(n-3) + ... + 3 *T(1) + O(n)\\nT(n-1) = 3 * T(n-2) + 3 * T(n-3) + ... 3 * T(1) + O(n)\\nT(0) = O(n)\\n\\nThe O(n) part is because of string copying. Thus T(n) = 4T(n-1) = 4 * 4^(n-1) * T(0) = O(n * 4 ^ n)\\nPlease correct me if I am wrong!!!"
                    },
                    {
                        "username": "paltech",
                        "content": "When the given string is 105 and target value is 5, i am not sure why \"1 * 05\" not considered as value eventhough  10 - 5 is value"
                    },
                    {
                        "username": "Adetomiwa",
                        "content": "According to the question, each number is expected to have no leading zeros. Basically, \"5\" is not considered the same as \"05\"."
                    },
                    {
                        "username": "HappyCerberus",
                        "content": "My solution found these two matches which indeed evaluate to 9191.\\n\\n\\t[\"34/5+62*37*4+9+0\",\"34/5+62*37*4+9-0\"]\\n\\t"
                    },
                    {
                        "username": "biciclub",
                        "content": "It appears division is not allowed"
                    },
                    {
                        "username": "kabir_singh",
                        "content": "for \"105\" the answer should be [1*0+5, 10-5, 1*05]. The last option has not been included in the question but is a valid answer"
                    },
                    {
                        "username": "doverbeach",
                        "content": "The output from Example 3 includes \"10-5\" which contains no operator between the digits 1 and 0. If this is permissable, would it be fair to say that the output from Example 4 should also include \"00\" which has the same value as the target?\\n*apologies for nitpicking lol"
                    }
                ]
            },
            {
                "id": 1565668,
                "content": [
                    {
                        "username": "Israfel",
                        "content": "My input:\\n\\n\\u201c105\\u201d\\n5\\n\\nMy answer:\\n\\n    [\"10-5\",\"1*05\",\"1*0+5\"]\\n\\nExpected answer:\\n\\n    [\"1*0+5\",\"10-5\"]"
                    },
                    {
                        "username": "mike1029",
                        "content": "no leading 0 is required\\n"
                    },
                    {
                        "username": "turbocv",
                        "content": "who knows divide and conquer solution for this problem?"
                    },
                    {
                        "username": "manideepak650",
                        "content": "One of the misleading problems that I ever faced. The description clearly mentioned the operators must be placed between the digits. Yet, one of the testcases for 105 illustrated that 10 - 5."
                    },
                    {
                        "username": "MoRatio",
                        "content": "[@cartesPerforees](/cartesPerforees) \"But the prohibition to have leading zeroes does indicate that we can take more than a single digit tho\"\n\n\nNot really. Nothing should be \"indicated\" or \"implied\" anyway. The problem statement is formatted poorly. Simply state that individual digits in the string can be combined to form larger numbers and give an example."
                    },
                    {
                        "username": "cartesPerforees",
                        "content": "the \"-\" is between 0 and 5. 0 is a digit and so is 5, so it is placed between two digits. I don't see a contradiction.\nDo you mean that it is not clear whether we have the right to consider more than a single digit in the partition? Maybe it is not totally clear on that point. But the prohibition to have leading zeroes does indicate that we can take more than a single digit tho"
                    },
                    {
                        "username": "Student2091",
                        "content": "The way this problem phrases \\'+\\', \\'-\\', and/or \\'*\\' is really misleading. \\nI read it as \\'+\\', \\'-\\', and \\'/\\' or \\'\\\\*\\'. I then assumed the `/` is double division because \"72\" 3 expected answer is []. I also tried to come up with a DP solution because it is a tad slow. \\n\\nI wasted like 30 minutes on this. I took me a long time to realize `/` is not included."
                    },
                    {
                        "username": "cartesPerforees",
                        "content": "I don;t know how it was in 2022, but as of 2023, the formatting leaves little ambiguity. Visually, it is hard to  confuse \n\" `+`,`-` and/or `*` \" \nfor \" `+`,`-` and `/` or `*` \""
                    },
                    {
                        "username": "mustafabar",
                        "content": "for the test case 105 and target = 5, why is 1 * 05 not equal to 5? isn\\'t it leading 0 negligible ?"
                    },
                    {
                        "username": "abhinavsalar",
                        "content": "As far I have noticed if the dig is zero than it can not be include directly or as a prefix for some others digits. It can only be included as a suffix part of a digit."
                    },
                    {
                        "username": "zack0927",
                        "content": "Time Complexity:\\nT(n) = 3 * T(n-1) + 3 * T(n-2) + 3 * T(n-3) + ... + 3 *T(1) + O(n)\\nT(n-1) = 3 * T(n-2) + 3 * T(n-3) + ... 3 * T(1) + O(n)\\nT(0) = O(n)\\n\\nThe O(n) part is because of string copying. Thus T(n) = 4T(n-1) = 4 * 4^(n-1) * T(0) = O(n * 4 ^ n)\\nPlease correct me if I am wrong!!!"
                    },
                    {
                        "username": "paltech",
                        "content": "When the given string is 105 and target value is 5, i am not sure why \"1 * 05\" not considered as value eventhough  10 - 5 is value"
                    },
                    {
                        "username": "Adetomiwa",
                        "content": "According to the question, each number is expected to have no leading zeros. Basically, \"5\" is not considered the same as \"05\"."
                    },
                    {
                        "username": "HappyCerberus",
                        "content": "My solution found these two matches which indeed evaluate to 9191.\\n\\n\\t[\"34/5+62*37*4+9+0\",\"34/5+62*37*4+9-0\"]\\n\\t"
                    },
                    {
                        "username": "biciclub",
                        "content": "It appears division is not allowed"
                    },
                    {
                        "username": "kabir_singh",
                        "content": "for \"105\" the answer should be [1*0+5, 10-5, 1*05]. The last option has not been included in the question but is a valid answer"
                    },
                    {
                        "username": "doverbeach",
                        "content": "The output from Example 3 includes \"10-5\" which contains no operator between the digits 1 and 0. If this is permissable, would it be fair to say that the output from Example 4 should also include \"00\" which has the same value as the target?\\n*apologies for nitpicking lol"
                    }
                ]
            },
            {
                "id": 1747503,
                "content": [
                    {
                        "username": "Israfel",
                        "content": "My input:\\n\\n\\u201c105\\u201d\\n5\\n\\nMy answer:\\n\\n    [\"10-5\",\"1*05\",\"1*0+5\"]\\n\\nExpected answer:\\n\\n    [\"1*0+5\",\"10-5\"]"
                    },
                    {
                        "username": "mike1029",
                        "content": "no leading 0 is required\\n"
                    },
                    {
                        "username": "turbocv",
                        "content": "who knows divide and conquer solution for this problem?"
                    },
                    {
                        "username": "manideepak650",
                        "content": "One of the misleading problems that I ever faced. The description clearly mentioned the operators must be placed between the digits. Yet, one of the testcases for 105 illustrated that 10 - 5."
                    },
                    {
                        "username": "MoRatio",
                        "content": "[@cartesPerforees](/cartesPerforees) \"But the prohibition to have leading zeroes does indicate that we can take more than a single digit tho\"\n\n\nNot really. Nothing should be \"indicated\" or \"implied\" anyway. The problem statement is formatted poorly. Simply state that individual digits in the string can be combined to form larger numbers and give an example."
                    },
                    {
                        "username": "cartesPerforees",
                        "content": "the \"-\" is between 0 and 5. 0 is a digit and so is 5, so it is placed between two digits. I don't see a contradiction.\nDo you mean that it is not clear whether we have the right to consider more than a single digit in the partition? Maybe it is not totally clear on that point. But the prohibition to have leading zeroes does indicate that we can take more than a single digit tho"
                    },
                    {
                        "username": "Student2091",
                        "content": "The way this problem phrases \\'+\\', \\'-\\', and/or \\'*\\' is really misleading. \\nI read it as \\'+\\', \\'-\\', and \\'/\\' or \\'\\\\*\\'. I then assumed the `/` is double division because \"72\" 3 expected answer is []. I also tried to come up with a DP solution because it is a tad slow. \\n\\nI wasted like 30 minutes on this. I took me a long time to realize `/` is not included."
                    },
                    {
                        "username": "cartesPerforees",
                        "content": "I don;t know how it was in 2022, but as of 2023, the formatting leaves little ambiguity. Visually, it is hard to  confuse \n\" `+`,`-` and/or `*` \" \nfor \" `+`,`-` and `/` or `*` \""
                    },
                    {
                        "username": "mustafabar",
                        "content": "for the test case 105 and target = 5, why is 1 * 05 not equal to 5? isn\\'t it leading 0 negligible ?"
                    },
                    {
                        "username": "abhinavsalar",
                        "content": "As far I have noticed if the dig is zero than it can not be include directly or as a prefix for some others digits. It can only be included as a suffix part of a digit."
                    },
                    {
                        "username": "zack0927",
                        "content": "Time Complexity:\\nT(n) = 3 * T(n-1) + 3 * T(n-2) + 3 * T(n-3) + ... + 3 *T(1) + O(n)\\nT(n-1) = 3 * T(n-2) + 3 * T(n-3) + ... 3 * T(1) + O(n)\\nT(0) = O(n)\\n\\nThe O(n) part is because of string copying. Thus T(n) = 4T(n-1) = 4 * 4^(n-1) * T(0) = O(n * 4 ^ n)\\nPlease correct me if I am wrong!!!"
                    },
                    {
                        "username": "paltech",
                        "content": "When the given string is 105 and target value is 5, i am not sure why \"1 * 05\" not considered as value eventhough  10 - 5 is value"
                    },
                    {
                        "username": "Adetomiwa",
                        "content": "According to the question, each number is expected to have no leading zeros. Basically, \"5\" is not considered the same as \"05\"."
                    },
                    {
                        "username": "HappyCerberus",
                        "content": "My solution found these two matches which indeed evaluate to 9191.\\n\\n\\t[\"34/5+62*37*4+9+0\",\"34/5+62*37*4+9-0\"]\\n\\t"
                    },
                    {
                        "username": "biciclub",
                        "content": "It appears division is not allowed"
                    },
                    {
                        "username": "kabir_singh",
                        "content": "for \"105\" the answer should be [1*0+5, 10-5, 1*05]. The last option has not been included in the question but is a valid answer"
                    },
                    {
                        "username": "doverbeach",
                        "content": "The output from Example 3 includes \"10-5\" which contains no operator between the digits 1 and 0. If this is permissable, would it be fair to say that the output from Example 4 should also include \"00\" which has the same value as the target?\\n*apologies for nitpicking lol"
                    }
                ]
            },
            {
                "id": 1576894,
                "content": [
                    {
                        "username": "Israfel",
                        "content": "My input:\\n\\n\\u201c105\\u201d\\n5\\n\\nMy answer:\\n\\n    [\"10-5\",\"1*05\",\"1*0+5\"]\\n\\nExpected answer:\\n\\n    [\"1*0+5\",\"10-5\"]"
                    },
                    {
                        "username": "mike1029",
                        "content": "no leading 0 is required\\n"
                    },
                    {
                        "username": "turbocv",
                        "content": "who knows divide and conquer solution for this problem?"
                    },
                    {
                        "username": "manideepak650",
                        "content": "One of the misleading problems that I ever faced. The description clearly mentioned the operators must be placed between the digits. Yet, one of the testcases for 105 illustrated that 10 - 5."
                    },
                    {
                        "username": "MoRatio",
                        "content": "[@cartesPerforees](/cartesPerforees) \"But the prohibition to have leading zeroes does indicate that we can take more than a single digit tho\"\n\n\nNot really. Nothing should be \"indicated\" or \"implied\" anyway. The problem statement is formatted poorly. Simply state that individual digits in the string can be combined to form larger numbers and give an example."
                    },
                    {
                        "username": "cartesPerforees",
                        "content": "the \"-\" is between 0 and 5. 0 is a digit and so is 5, so it is placed between two digits. I don't see a contradiction.\nDo you mean that it is not clear whether we have the right to consider more than a single digit in the partition? Maybe it is not totally clear on that point. But the prohibition to have leading zeroes does indicate that we can take more than a single digit tho"
                    },
                    {
                        "username": "Student2091",
                        "content": "The way this problem phrases \\'+\\', \\'-\\', and/or \\'*\\' is really misleading. \\nI read it as \\'+\\', \\'-\\', and \\'/\\' or \\'\\\\*\\'. I then assumed the `/` is double division because \"72\" 3 expected answer is []. I also tried to come up with a DP solution because it is a tad slow. \\n\\nI wasted like 30 minutes on this. I took me a long time to realize `/` is not included."
                    },
                    {
                        "username": "cartesPerforees",
                        "content": "I don;t know how it was in 2022, but as of 2023, the formatting leaves little ambiguity. Visually, it is hard to  confuse \n\" `+`,`-` and/or `*` \" \nfor \" `+`,`-` and `/` or `*` \""
                    },
                    {
                        "username": "mustafabar",
                        "content": "for the test case 105 and target = 5, why is 1 * 05 not equal to 5? isn\\'t it leading 0 negligible ?"
                    },
                    {
                        "username": "abhinavsalar",
                        "content": "As far I have noticed if the dig is zero than it can not be include directly or as a prefix for some others digits. It can only be included as a suffix part of a digit."
                    },
                    {
                        "username": "zack0927",
                        "content": "Time Complexity:\\nT(n) = 3 * T(n-1) + 3 * T(n-2) + 3 * T(n-3) + ... + 3 *T(1) + O(n)\\nT(n-1) = 3 * T(n-2) + 3 * T(n-3) + ... 3 * T(1) + O(n)\\nT(0) = O(n)\\n\\nThe O(n) part is because of string copying. Thus T(n) = 4T(n-1) = 4 * 4^(n-1) * T(0) = O(n * 4 ^ n)\\nPlease correct me if I am wrong!!!"
                    },
                    {
                        "username": "paltech",
                        "content": "When the given string is 105 and target value is 5, i am not sure why \"1 * 05\" not considered as value eventhough  10 - 5 is value"
                    },
                    {
                        "username": "Adetomiwa",
                        "content": "According to the question, each number is expected to have no leading zeros. Basically, \"5\" is not considered the same as \"05\"."
                    },
                    {
                        "username": "HappyCerberus",
                        "content": "My solution found these two matches which indeed evaluate to 9191.\\n\\n\\t[\"34/5+62*37*4+9+0\",\"34/5+62*37*4+9-0\"]\\n\\t"
                    },
                    {
                        "username": "biciclub",
                        "content": "It appears division is not allowed"
                    },
                    {
                        "username": "kabir_singh",
                        "content": "for \"105\" the answer should be [1*0+5, 10-5, 1*05]. The last option has not been included in the question but is a valid answer"
                    },
                    {
                        "username": "doverbeach",
                        "content": "The output from Example 3 includes \"10-5\" which contains no operator between the digits 1 and 0. If this is permissable, would it be fair to say that the output from Example 4 should also include \"00\" which has the same value as the target?\\n*apologies for nitpicking lol"
                    }
                ]
            },
            {
                "id": 1568041,
                "content": [
                    {
                        "username": "Israfel",
                        "content": "My input:\\n\\n\\u201c105\\u201d\\n5\\n\\nMy answer:\\n\\n    [\"10-5\",\"1*05\",\"1*0+5\"]\\n\\nExpected answer:\\n\\n    [\"1*0+5\",\"10-5\"]"
                    },
                    {
                        "username": "mike1029",
                        "content": "no leading 0 is required\\n"
                    },
                    {
                        "username": "turbocv",
                        "content": "who knows divide and conquer solution for this problem?"
                    },
                    {
                        "username": "manideepak650",
                        "content": "One of the misleading problems that I ever faced. The description clearly mentioned the operators must be placed between the digits. Yet, one of the testcases for 105 illustrated that 10 - 5."
                    },
                    {
                        "username": "MoRatio",
                        "content": "[@cartesPerforees](/cartesPerforees) \"But the prohibition to have leading zeroes does indicate that we can take more than a single digit tho\"\n\n\nNot really. Nothing should be \"indicated\" or \"implied\" anyway. The problem statement is formatted poorly. Simply state that individual digits in the string can be combined to form larger numbers and give an example."
                    },
                    {
                        "username": "cartesPerforees",
                        "content": "the \"-\" is between 0 and 5. 0 is a digit and so is 5, so it is placed between two digits. I don't see a contradiction.\nDo you mean that it is not clear whether we have the right to consider more than a single digit in the partition? Maybe it is not totally clear on that point. But the prohibition to have leading zeroes does indicate that we can take more than a single digit tho"
                    },
                    {
                        "username": "Student2091",
                        "content": "The way this problem phrases \\'+\\', \\'-\\', and/or \\'*\\' is really misleading. \\nI read it as \\'+\\', \\'-\\', and \\'/\\' or \\'\\\\*\\'. I then assumed the `/` is double division because \"72\" 3 expected answer is []. I also tried to come up with a DP solution because it is a tad slow. \\n\\nI wasted like 30 minutes on this. I took me a long time to realize `/` is not included."
                    },
                    {
                        "username": "cartesPerforees",
                        "content": "I don;t know how it was in 2022, but as of 2023, the formatting leaves little ambiguity. Visually, it is hard to  confuse \n\" `+`,`-` and/or `*` \" \nfor \" `+`,`-` and `/` or `*` \""
                    },
                    {
                        "username": "mustafabar",
                        "content": "for the test case 105 and target = 5, why is 1 * 05 not equal to 5? isn\\'t it leading 0 negligible ?"
                    },
                    {
                        "username": "abhinavsalar",
                        "content": "As far I have noticed if the dig is zero than it can not be include directly or as a prefix for some others digits. It can only be included as a suffix part of a digit."
                    },
                    {
                        "username": "zack0927",
                        "content": "Time Complexity:\\nT(n) = 3 * T(n-1) + 3 * T(n-2) + 3 * T(n-3) + ... + 3 *T(1) + O(n)\\nT(n-1) = 3 * T(n-2) + 3 * T(n-3) + ... 3 * T(1) + O(n)\\nT(0) = O(n)\\n\\nThe O(n) part is because of string copying. Thus T(n) = 4T(n-1) = 4 * 4^(n-1) * T(0) = O(n * 4 ^ n)\\nPlease correct me if I am wrong!!!"
                    },
                    {
                        "username": "paltech",
                        "content": "When the given string is 105 and target value is 5, i am not sure why \"1 * 05\" not considered as value eventhough  10 - 5 is value"
                    },
                    {
                        "username": "Adetomiwa",
                        "content": "According to the question, each number is expected to have no leading zeros. Basically, \"5\" is not considered the same as \"05\"."
                    },
                    {
                        "username": "HappyCerberus",
                        "content": "My solution found these two matches which indeed evaluate to 9191.\\n\\n\\t[\"34/5+62*37*4+9+0\",\"34/5+62*37*4+9-0\"]\\n\\t"
                    },
                    {
                        "username": "biciclub",
                        "content": "It appears division is not allowed"
                    },
                    {
                        "username": "kabir_singh",
                        "content": "for \"105\" the answer should be [1*0+5, 10-5, 1*05]. The last option has not been included in the question but is a valid answer"
                    },
                    {
                        "username": "doverbeach",
                        "content": "The output from Example 3 includes \"10-5\" which contains no operator between the digits 1 and 0. If this is permissable, would it be fair to say that the output from Example 4 should also include \"00\" which has the same value as the target?\\n*apologies for nitpicking lol"
                    }
                ]
            },
            {
                "id": 1570495,
                "content": [
                    {
                        "username": "Israfel",
                        "content": "My input:\\n\\n\\u201c105\\u201d\\n5\\n\\nMy answer:\\n\\n    [\"10-5\",\"1*05\",\"1*0+5\"]\\n\\nExpected answer:\\n\\n    [\"1*0+5\",\"10-5\"]"
                    },
                    {
                        "username": "mike1029",
                        "content": "no leading 0 is required\\n"
                    },
                    {
                        "username": "turbocv",
                        "content": "who knows divide and conquer solution for this problem?"
                    },
                    {
                        "username": "manideepak650",
                        "content": "One of the misleading problems that I ever faced. The description clearly mentioned the operators must be placed between the digits. Yet, one of the testcases for 105 illustrated that 10 - 5."
                    },
                    {
                        "username": "MoRatio",
                        "content": "[@cartesPerforees](/cartesPerforees) \"But the prohibition to have leading zeroes does indicate that we can take more than a single digit tho\"\n\n\nNot really. Nothing should be \"indicated\" or \"implied\" anyway. The problem statement is formatted poorly. Simply state that individual digits in the string can be combined to form larger numbers and give an example."
                    },
                    {
                        "username": "cartesPerforees",
                        "content": "the \"-\" is between 0 and 5. 0 is a digit and so is 5, so it is placed between two digits. I don't see a contradiction.\nDo you mean that it is not clear whether we have the right to consider more than a single digit in the partition? Maybe it is not totally clear on that point. But the prohibition to have leading zeroes does indicate that we can take more than a single digit tho"
                    },
                    {
                        "username": "Student2091",
                        "content": "The way this problem phrases \\'+\\', \\'-\\', and/or \\'*\\' is really misleading. \\nI read it as \\'+\\', \\'-\\', and \\'/\\' or \\'\\\\*\\'. I then assumed the `/` is double division because \"72\" 3 expected answer is []. I also tried to come up with a DP solution because it is a tad slow. \\n\\nI wasted like 30 minutes on this. I took me a long time to realize `/` is not included."
                    },
                    {
                        "username": "cartesPerforees",
                        "content": "I don;t know how it was in 2022, but as of 2023, the formatting leaves little ambiguity. Visually, it is hard to  confuse \n\" `+`,`-` and/or `*` \" \nfor \" `+`,`-` and `/` or `*` \""
                    },
                    {
                        "username": "mustafabar",
                        "content": "for the test case 105 and target = 5, why is 1 * 05 not equal to 5? isn\\'t it leading 0 negligible ?"
                    },
                    {
                        "username": "abhinavsalar",
                        "content": "As far I have noticed if the dig is zero than it can not be include directly or as a prefix for some others digits. It can only be included as a suffix part of a digit."
                    },
                    {
                        "username": "zack0927",
                        "content": "Time Complexity:\\nT(n) = 3 * T(n-1) + 3 * T(n-2) + 3 * T(n-3) + ... + 3 *T(1) + O(n)\\nT(n-1) = 3 * T(n-2) + 3 * T(n-3) + ... 3 * T(1) + O(n)\\nT(0) = O(n)\\n\\nThe O(n) part is because of string copying. Thus T(n) = 4T(n-1) = 4 * 4^(n-1) * T(0) = O(n * 4 ^ n)\\nPlease correct me if I am wrong!!!"
                    },
                    {
                        "username": "paltech",
                        "content": "When the given string is 105 and target value is 5, i am not sure why \"1 * 05\" not considered as value eventhough  10 - 5 is value"
                    },
                    {
                        "username": "Adetomiwa",
                        "content": "According to the question, each number is expected to have no leading zeros. Basically, \"5\" is not considered the same as \"05\"."
                    },
                    {
                        "username": "HappyCerberus",
                        "content": "My solution found these two matches which indeed evaluate to 9191.\\n\\n\\t[\"34/5+62*37*4+9+0\",\"34/5+62*37*4+9-0\"]\\n\\t"
                    },
                    {
                        "username": "biciclub",
                        "content": "It appears division is not allowed"
                    },
                    {
                        "username": "kabir_singh",
                        "content": "for \"105\" the answer should be [1*0+5, 10-5, 1*05]. The last option has not been included in the question but is a valid answer"
                    },
                    {
                        "username": "doverbeach",
                        "content": "The output from Example 3 includes \"10-5\" which contains no operator between the digits 1 and 0. If this is permissable, would it be fair to say that the output from Example 4 should also include \"00\" which has the same value as the target?\\n*apologies for nitpicking lol"
                    }
                ]
            },
            {
                "id": 1569873,
                "content": [
                    {
                        "username": "Israfel",
                        "content": "My input:\\n\\n\\u201c105\\u201d\\n5\\n\\nMy answer:\\n\\n    [\"10-5\",\"1*05\",\"1*0+5\"]\\n\\nExpected answer:\\n\\n    [\"1*0+5\",\"10-5\"]"
                    },
                    {
                        "username": "mike1029",
                        "content": "no leading 0 is required\\n"
                    },
                    {
                        "username": "turbocv",
                        "content": "who knows divide and conquer solution for this problem?"
                    },
                    {
                        "username": "manideepak650",
                        "content": "One of the misleading problems that I ever faced. The description clearly mentioned the operators must be placed between the digits. Yet, one of the testcases for 105 illustrated that 10 - 5."
                    },
                    {
                        "username": "MoRatio",
                        "content": "[@cartesPerforees](/cartesPerforees) \"But the prohibition to have leading zeroes does indicate that we can take more than a single digit tho\"\n\n\nNot really. Nothing should be \"indicated\" or \"implied\" anyway. The problem statement is formatted poorly. Simply state that individual digits in the string can be combined to form larger numbers and give an example."
                    },
                    {
                        "username": "cartesPerforees",
                        "content": "the \"-\" is between 0 and 5. 0 is a digit and so is 5, so it is placed between two digits. I don't see a contradiction.\nDo you mean that it is not clear whether we have the right to consider more than a single digit in the partition? Maybe it is not totally clear on that point. But the prohibition to have leading zeroes does indicate that we can take more than a single digit tho"
                    },
                    {
                        "username": "Student2091",
                        "content": "The way this problem phrases \\'+\\', \\'-\\', and/or \\'*\\' is really misleading. \\nI read it as \\'+\\', \\'-\\', and \\'/\\' or \\'\\\\*\\'. I then assumed the `/` is double division because \"72\" 3 expected answer is []. I also tried to come up with a DP solution because it is a tad slow. \\n\\nI wasted like 30 minutes on this. I took me a long time to realize `/` is not included."
                    },
                    {
                        "username": "cartesPerforees",
                        "content": "I don;t know how it was in 2022, but as of 2023, the formatting leaves little ambiguity. Visually, it is hard to  confuse \n\" `+`,`-` and/or `*` \" \nfor \" `+`,`-` and `/` or `*` \""
                    },
                    {
                        "username": "mustafabar",
                        "content": "for the test case 105 and target = 5, why is 1 * 05 not equal to 5? isn\\'t it leading 0 negligible ?"
                    },
                    {
                        "username": "abhinavsalar",
                        "content": "As far I have noticed if the dig is zero than it can not be include directly or as a prefix for some others digits. It can only be included as a suffix part of a digit."
                    },
                    {
                        "username": "zack0927",
                        "content": "Time Complexity:\\nT(n) = 3 * T(n-1) + 3 * T(n-2) + 3 * T(n-3) + ... + 3 *T(1) + O(n)\\nT(n-1) = 3 * T(n-2) + 3 * T(n-3) + ... 3 * T(1) + O(n)\\nT(0) = O(n)\\n\\nThe O(n) part is because of string copying. Thus T(n) = 4T(n-1) = 4 * 4^(n-1) * T(0) = O(n * 4 ^ n)\\nPlease correct me if I am wrong!!!"
                    },
                    {
                        "username": "paltech",
                        "content": "When the given string is 105 and target value is 5, i am not sure why \"1 * 05\" not considered as value eventhough  10 - 5 is value"
                    },
                    {
                        "username": "Adetomiwa",
                        "content": "According to the question, each number is expected to have no leading zeros. Basically, \"5\" is not considered the same as \"05\"."
                    },
                    {
                        "username": "HappyCerberus",
                        "content": "My solution found these two matches which indeed evaluate to 9191.\\n\\n\\t[\"34/5+62*37*4+9+0\",\"34/5+62*37*4+9-0\"]\\n\\t"
                    },
                    {
                        "username": "biciclub",
                        "content": "It appears division is not allowed"
                    },
                    {
                        "username": "kabir_singh",
                        "content": "for \"105\" the answer should be [1*0+5, 10-5, 1*05]. The last option has not been included in the question but is a valid answer"
                    },
                    {
                        "username": "doverbeach",
                        "content": "The output from Example 3 includes \"10-5\" which contains no operator between the digits 1 and 0. If this is permissable, would it be fair to say that the output from Example 4 should also include \"00\" which has the same value as the target?\\n*apologies for nitpicking lol"
                    }
                ]
            },
            {
                "id": 1569747,
                "content": [
                    {
                        "username": "Israfel",
                        "content": "My input:\\n\\n\\u201c105\\u201d\\n5\\n\\nMy answer:\\n\\n    [\"10-5\",\"1*05\",\"1*0+5\"]\\n\\nExpected answer:\\n\\n    [\"1*0+5\",\"10-5\"]"
                    },
                    {
                        "username": "mike1029",
                        "content": "no leading 0 is required\\n"
                    },
                    {
                        "username": "turbocv",
                        "content": "who knows divide and conquer solution for this problem?"
                    },
                    {
                        "username": "manideepak650",
                        "content": "One of the misleading problems that I ever faced. The description clearly mentioned the operators must be placed between the digits. Yet, one of the testcases for 105 illustrated that 10 - 5."
                    },
                    {
                        "username": "MoRatio",
                        "content": "[@cartesPerforees](/cartesPerforees) \"But the prohibition to have leading zeroes does indicate that we can take more than a single digit tho\"\n\n\nNot really. Nothing should be \"indicated\" or \"implied\" anyway. The problem statement is formatted poorly. Simply state that individual digits in the string can be combined to form larger numbers and give an example."
                    },
                    {
                        "username": "cartesPerforees",
                        "content": "the \"-\" is between 0 and 5. 0 is a digit and so is 5, so it is placed between two digits. I don't see a contradiction.\nDo you mean that it is not clear whether we have the right to consider more than a single digit in the partition? Maybe it is not totally clear on that point. But the prohibition to have leading zeroes does indicate that we can take more than a single digit tho"
                    },
                    {
                        "username": "Student2091",
                        "content": "The way this problem phrases \\'+\\', \\'-\\', and/or \\'*\\' is really misleading. \\nI read it as \\'+\\', \\'-\\', and \\'/\\' or \\'\\\\*\\'. I then assumed the `/` is double division because \"72\" 3 expected answer is []. I also tried to come up with a DP solution because it is a tad slow. \\n\\nI wasted like 30 minutes on this. I took me a long time to realize `/` is not included."
                    },
                    {
                        "username": "cartesPerforees",
                        "content": "I don;t know how it was in 2022, but as of 2023, the formatting leaves little ambiguity. Visually, it is hard to  confuse \n\" `+`,`-` and/or `*` \" \nfor \" `+`,`-` and `/` or `*` \""
                    },
                    {
                        "username": "mustafabar",
                        "content": "for the test case 105 and target = 5, why is 1 * 05 not equal to 5? isn\\'t it leading 0 negligible ?"
                    },
                    {
                        "username": "abhinavsalar",
                        "content": "As far I have noticed if the dig is zero than it can not be include directly or as a prefix for some others digits. It can only be included as a suffix part of a digit."
                    },
                    {
                        "username": "zack0927",
                        "content": "Time Complexity:\\nT(n) = 3 * T(n-1) + 3 * T(n-2) + 3 * T(n-3) + ... + 3 *T(1) + O(n)\\nT(n-1) = 3 * T(n-2) + 3 * T(n-3) + ... 3 * T(1) + O(n)\\nT(0) = O(n)\\n\\nThe O(n) part is because of string copying. Thus T(n) = 4T(n-1) = 4 * 4^(n-1) * T(0) = O(n * 4 ^ n)\\nPlease correct me if I am wrong!!!"
                    },
                    {
                        "username": "paltech",
                        "content": "When the given string is 105 and target value is 5, i am not sure why \"1 * 05\" not considered as value eventhough  10 - 5 is value"
                    },
                    {
                        "username": "Adetomiwa",
                        "content": "According to the question, each number is expected to have no leading zeros. Basically, \"5\" is not considered the same as \"05\"."
                    },
                    {
                        "username": "HappyCerberus",
                        "content": "My solution found these two matches which indeed evaluate to 9191.\\n\\n\\t[\"34/5+62*37*4+9+0\",\"34/5+62*37*4+9-0\"]\\n\\t"
                    },
                    {
                        "username": "biciclub",
                        "content": "It appears division is not allowed"
                    },
                    {
                        "username": "kabir_singh",
                        "content": "for \"105\" the answer should be [1*0+5, 10-5, 1*05]. The last option has not been included in the question but is a valid answer"
                    },
                    {
                        "username": "doverbeach",
                        "content": "The output from Example 3 includes \"10-5\" which contains no operator between the digits 1 and 0. If this is permissable, would it be fair to say that the output from Example 4 should also include \"00\" which has the same value as the target?\\n*apologies for nitpicking lol"
                    }
                ]
            },
            {
                "id": 1569054,
                "content": [
                    {
                        "username": "Israfel",
                        "content": "My input:\\n\\n\\u201c105\\u201d\\n5\\n\\nMy answer:\\n\\n    [\"10-5\",\"1*05\",\"1*0+5\"]\\n\\nExpected answer:\\n\\n    [\"1*0+5\",\"10-5\"]"
                    },
                    {
                        "username": "mike1029",
                        "content": "no leading 0 is required\\n"
                    },
                    {
                        "username": "turbocv",
                        "content": "who knows divide and conquer solution for this problem?"
                    },
                    {
                        "username": "manideepak650",
                        "content": "One of the misleading problems that I ever faced. The description clearly mentioned the operators must be placed between the digits. Yet, one of the testcases for 105 illustrated that 10 - 5."
                    },
                    {
                        "username": "MoRatio",
                        "content": "[@cartesPerforees](/cartesPerforees) \"But the prohibition to have leading zeroes does indicate that we can take more than a single digit tho\"\n\n\nNot really. Nothing should be \"indicated\" or \"implied\" anyway. The problem statement is formatted poorly. Simply state that individual digits in the string can be combined to form larger numbers and give an example."
                    },
                    {
                        "username": "cartesPerforees",
                        "content": "the \"-\" is between 0 and 5. 0 is a digit and so is 5, so it is placed between two digits. I don't see a contradiction.\nDo you mean that it is not clear whether we have the right to consider more than a single digit in the partition? Maybe it is not totally clear on that point. But the prohibition to have leading zeroes does indicate that we can take more than a single digit tho"
                    },
                    {
                        "username": "Student2091",
                        "content": "The way this problem phrases \\'+\\', \\'-\\', and/or \\'*\\' is really misleading. \\nI read it as \\'+\\', \\'-\\', and \\'/\\' or \\'\\\\*\\'. I then assumed the `/` is double division because \"72\" 3 expected answer is []. I also tried to come up with a DP solution because it is a tad slow. \\n\\nI wasted like 30 minutes on this. I took me a long time to realize `/` is not included."
                    },
                    {
                        "username": "cartesPerforees",
                        "content": "I don;t know how it was in 2022, but as of 2023, the formatting leaves little ambiguity. Visually, it is hard to  confuse \n\" `+`,`-` and/or `*` \" \nfor \" `+`,`-` and `/` or `*` \""
                    },
                    {
                        "username": "mustafabar",
                        "content": "for the test case 105 and target = 5, why is 1 * 05 not equal to 5? isn\\'t it leading 0 negligible ?"
                    },
                    {
                        "username": "abhinavsalar",
                        "content": "As far I have noticed if the dig is zero than it can not be include directly or as a prefix for some others digits. It can only be included as a suffix part of a digit."
                    },
                    {
                        "username": "zack0927",
                        "content": "Time Complexity:\\nT(n) = 3 * T(n-1) + 3 * T(n-2) + 3 * T(n-3) + ... + 3 *T(1) + O(n)\\nT(n-1) = 3 * T(n-2) + 3 * T(n-3) + ... 3 * T(1) + O(n)\\nT(0) = O(n)\\n\\nThe O(n) part is because of string copying. Thus T(n) = 4T(n-1) = 4 * 4^(n-1) * T(0) = O(n * 4 ^ n)\\nPlease correct me if I am wrong!!!"
                    },
                    {
                        "username": "paltech",
                        "content": "When the given string is 105 and target value is 5, i am not sure why \"1 * 05\" not considered as value eventhough  10 - 5 is value"
                    },
                    {
                        "username": "Adetomiwa",
                        "content": "According to the question, each number is expected to have no leading zeros. Basically, \"5\" is not considered the same as \"05\"."
                    },
                    {
                        "username": "HappyCerberus",
                        "content": "My solution found these two matches which indeed evaluate to 9191.\\n\\n\\t[\"34/5+62*37*4+9+0\",\"34/5+62*37*4+9-0\"]\\n\\t"
                    },
                    {
                        "username": "biciclub",
                        "content": "It appears division is not allowed"
                    },
                    {
                        "username": "kabir_singh",
                        "content": "for \"105\" the answer should be [1*0+5, 10-5, 1*05]. The last option has not been included in the question but is a valid answer"
                    },
                    {
                        "username": "doverbeach",
                        "content": "The output from Example 3 includes \"10-5\" which contains no operator between the digits 1 and 0. If this is permissable, would it be fair to say that the output from Example 4 should also include \"00\" which has the same value as the target?\\n*apologies for nitpicking lol"
                    }
                ]
            },
            {
                "id": 1570615,
                "content": [
                    {
                        "username": "Israfel",
                        "content": "My input:\\n\\n\\u201c105\\u201d\\n5\\n\\nMy answer:\\n\\n    [\"10-5\",\"1*05\",\"1*0+5\"]\\n\\nExpected answer:\\n\\n    [\"1*0+5\",\"10-5\"]"
                    },
                    {
                        "username": "mike1029",
                        "content": "no leading 0 is required\\n"
                    },
                    {
                        "username": "turbocv",
                        "content": "who knows divide and conquer solution for this problem?"
                    },
                    {
                        "username": "manideepak650",
                        "content": "One of the misleading problems that I ever faced. The description clearly mentioned the operators must be placed between the digits. Yet, one of the testcases for 105 illustrated that 10 - 5."
                    },
                    {
                        "username": "MoRatio",
                        "content": "[@cartesPerforees](/cartesPerforees) \"But the prohibition to have leading zeroes does indicate that we can take more than a single digit tho\"\n\n\nNot really. Nothing should be \"indicated\" or \"implied\" anyway. The problem statement is formatted poorly. Simply state that individual digits in the string can be combined to form larger numbers and give an example."
                    },
                    {
                        "username": "cartesPerforees",
                        "content": "the \"-\" is between 0 and 5. 0 is a digit and so is 5, so it is placed between two digits. I don't see a contradiction.\nDo you mean that it is not clear whether we have the right to consider more than a single digit in the partition? Maybe it is not totally clear on that point. But the prohibition to have leading zeroes does indicate that we can take more than a single digit tho"
                    },
                    {
                        "username": "Student2091",
                        "content": "The way this problem phrases \\'+\\', \\'-\\', and/or \\'*\\' is really misleading. \\nI read it as \\'+\\', \\'-\\', and \\'/\\' or \\'\\\\*\\'. I then assumed the `/` is double division because \"72\" 3 expected answer is []. I also tried to come up with a DP solution because it is a tad slow. \\n\\nI wasted like 30 minutes on this. I took me a long time to realize `/` is not included."
                    },
                    {
                        "username": "cartesPerforees",
                        "content": "I don;t know how it was in 2022, but as of 2023, the formatting leaves little ambiguity. Visually, it is hard to  confuse \n\" `+`,`-` and/or `*` \" \nfor \" `+`,`-` and `/` or `*` \""
                    },
                    {
                        "username": "mustafabar",
                        "content": "for the test case 105 and target = 5, why is 1 * 05 not equal to 5? isn\\'t it leading 0 negligible ?"
                    },
                    {
                        "username": "abhinavsalar",
                        "content": "As far I have noticed if the dig is zero than it can not be include directly or as a prefix for some others digits. It can only be included as a suffix part of a digit."
                    },
                    {
                        "username": "zack0927",
                        "content": "Time Complexity:\\nT(n) = 3 * T(n-1) + 3 * T(n-2) + 3 * T(n-3) + ... + 3 *T(1) + O(n)\\nT(n-1) = 3 * T(n-2) + 3 * T(n-3) + ... 3 * T(1) + O(n)\\nT(0) = O(n)\\n\\nThe O(n) part is because of string copying. Thus T(n) = 4T(n-1) = 4 * 4^(n-1) * T(0) = O(n * 4 ^ n)\\nPlease correct me if I am wrong!!!"
                    },
                    {
                        "username": "paltech",
                        "content": "When the given string is 105 and target value is 5, i am not sure why \"1 * 05\" not considered as value eventhough  10 - 5 is value"
                    },
                    {
                        "username": "Adetomiwa",
                        "content": "According to the question, each number is expected to have no leading zeros. Basically, \"5\" is not considered the same as \"05\"."
                    },
                    {
                        "username": "HappyCerberus",
                        "content": "My solution found these two matches which indeed evaluate to 9191.\\n\\n\\t[\"34/5+62*37*4+9+0\",\"34/5+62*37*4+9-0\"]\\n\\t"
                    },
                    {
                        "username": "biciclub",
                        "content": "It appears division is not allowed"
                    },
                    {
                        "username": "kabir_singh",
                        "content": "for \"105\" the answer should be [1*0+5, 10-5, 1*05]. The last option has not been included in the question but is a valid answer"
                    },
                    {
                        "username": "doverbeach",
                        "content": "The output from Example 3 includes \"10-5\" which contains no operator between the digits 1 and 0. If this is permissable, would it be fair to say that the output from Example 4 should also include \"00\" which has the same value as the target?\\n*apologies for nitpicking lol"
                    }
                ]
            },
            {
                "id": 1861633,
                "content": [
                    {
                        "username": "prshntvrm1",
                        "content": "I am bit  confused with  the question\\nwhat if input is [\"123\"] and the target is 9\\nthe only expected ans is [12-3] \\nwhy not [1+2 * 3]"
                    },
                    {
                        "username": "avijain14",
                        "content": "the expression is evaluated according to BODMAS rule"
                    },
                    {
                        "username": "doudoukuaipao",
                        "content": "I am wondering Why can\\'t this question use DFS with memorization? Could someone help explain? THanks!"
                    },
                    {
                        "username": "miracle84",
                        "content": "Regarding 105 and 5 example, also possible answer is 1*05, of course in usual representation we use 5 without leading zero, but anyway 05 equals 5, than 1*05 is also possible solution. \\nOr if we must use only numbers without leading zero, may be it should be clearly mentioned in description?\\nOr correct me please, if i am wrong."
                    },
                    {
                        "username": "vikas5",
                        "content": "Hi,\\nFor input parameters\"105\" and 5, my algorithm is getting an additional answer as \"1*05\". Why is this not an valid answer? Can someone help me here?"
                    },
                    {
                        "username": "atruecubsfan",
                        "content": "I believe the runtime complexity for the vanilla DFS approach is O(4 ^ n).  However there are many subproblems that can be memo-ized.  Whats the complexity of the memoized version?  "
                    },
                    {
                        "username": "Blink_fw",
                        "content": "Do we need to handle the case where the input string is very long? For example, we have \"99....99\", where there are 100 '9' in the string and the target value is 0? I don't see any restriction on the string length."
                    },
                    {
                        "username": "Decision",
                        "content": "It seems taking exponential time: O(4^n) by DFS solution. \\n\\nDoes this problem have polynomial time solution?"
                    },
                    {
                        "username": "thanir10",
                        "content": "The question is misleading here. The question did not mention whether there could be operation between multiple digit \\nEx : 10 - 5 (Accepted)"
                    },
                    {
                        "username": "marknaman05",
                        "content": "Input\nnum =\n\"105\"\ntarget =\n5\nOutput\n`[\"1*0+5\",\"1*05\",\"10-5\"]`\nExpected\n`[\"1*0+5\",\"10-5\"]`\n\nWhy this case is wrong?"
                    },
                    {
                        "username": "prakhars31",
                        "content": "Description is not clear. Examples should include a testcase where more than one digit is taken to form a number."
                    }
                ]
            },
            {
                "id": 1575220,
                "content": [
                    {
                        "username": "prshntvrm1",
                        "content": "I am bit  confused with  the question\\nwhat if input is [\"123\"] and the target is 9\\nthe only expected ans is [12-3] \\nwhy not [1+2 * 3]"
                    },
                    {
                        "username": "avijain14",
                        "content": "the expression is evaluated according to BODMAS rule"
                    },
                    {
                        "username": "doudoukuaipao",
                        "content": "I am wondering Why can\\'t this question use DFS with memorization? Could someone help explain? THanks!"
                    },
                    {
                        "username": "miracle84",
                        "content": "Regarding 105 and 5 example, also possible answer is 1*05, of course in usual representation we use 5 without leading zero, but anyway 05 equals 5, than 1*05 is also possible solution. \\nOr if we must use only numbers without leading zero, may be it should be clearly mentioned in description?\\nOr correct me please, if i am wrong."
                    },
                    {
                        "username": "vikas5",
                        "content": "Hi,\\nFor input parameters\"105\" and 5, my algorithm is getting an additional answer as \"1*05\". Why is this not an valid answer? Can someone help me here?"
                    },
                    {
                        "username": "atruecubsfan",
                        "content": "I believe the runtime complexity for the vanilla DFS approach is O(4 ^ n).  However there are many subproblems that can be memo-ized.  Whats the complexity of the memoized version?  "
                    },
                    {
                        "username": "Blink_fw",
                        "content": "Do we need to handle the case where the input string is very long? For example, we have \"99....99\", where there are 100 '9' in the string and the target value is 0? I don't see any restriction on the string length."
                    },
                    {
                        "username": "Decision",
                        "content": "It seems taking exponential time: O(4^n) by DFS solution. \\n\\nDoes this problem have polynomial time solution?"
                    },
                    {
                        "username": "thanir10",
                        "content": "The question is misleading here. The question did not mention whether there could be operation between multiple digit \\nEx : 10 - 5 (Accepted)"
                    },
                    {
                        "username": "marknaman05",
                        "content": "Input\nnum =\n\"105\"\ntarget =\n5\nOutput\n`[\"1*0+5\",\"1*05\",\"10-5\"]`\nExpected\n`[\"1*0+5\",\"10-5\"]`\n\nWhy this case is wrong?"
                    },
                    {
                        "username": "prakhars31",
                        "content": "Description is not clear. Examples should include a testcase where more than one digit is taken to form a number."
                    }
                ]
            },
            {
                "id": 1574526,
                "content": [
                    {
                        "username": "prshntvrm1",
                        "content": "I am bit  confused with  the question\\nwhat if input is [\"123\"] and the target is 9\\nthe only expected ans is [12-3] \\nwhy not [1+2 * 3]"
                    },
                    {
                        "username": "avijain14",
                        "content": "the expression is evaluated according to BODMAS rule"
                    },
                    {
                        "username": "doudoukuaipao",
                        "content": "I am wondering Why can\\'t this question use DFS with memorization? Could someone help explain? THanks!"
                    },
                    {
                        "username": "miracle84",
                        "content": "Regarding 105 and 5 example, also possible answer is 1*05, of course in usual representation we use 5 without leading zero, but anyway 05 equals 5, than 1*05 is also possible solution. \\nOr if we must use only numbers without leading zero, may be it should be clearly mentioned in description?\\nOr correct me please, if i am wrong."
                    },
                    {
                        "username": "vikas5",
                        "content": "Hi,\\nFor input parameters\"105\" and 5, my algorithm is getting an additional answer as \"1*05\". Why is this not an valid answer? Can someone help me here?"
                    },
                    {
                        "username": "atruecubsfan",
                        "content": "I believe the runtime complexity for the vanilla DFS approach is O(4 ^ n).  However there are many subproblems that can be memo-ized.  Whats the complexity of the memoized version?  "
                    },
                    {
                        "username": "Blink_fw",
                        "content": "Do we need to handle the case where the input string is very long? For example, we have \"99....99\", where there are 100 '9' in the string and the target value is 0? I don't see any restriction on the string length."
                    },
                    {
                        "username": "Decision",
                        "content": "It seems taking exponential time: O(4^n) by DFS solution. \\n\\nDoes this problem have polynomial time solution?"
                    },
                    {
                        "username": "thanir10",
                        "content": "The question is misleading here. The question did not mention whether there could be operation between multiple digit \\nEx : 10 - 5 (Accepted)"
                    },
                    {
                        "username": "marknaman05",
                        "content": "Input\nnum =\n\"105\"\ntarget =\n5\nOutput\n`[\"1*0+5\",\"1*05\",\"10-5\"]`\nExpected\n`[\"1*0+5\",\"10-5\"]`\n\nWhy this case is wrong?"
                    },
                    {
                        "username": "prakhars31",
                        "content": "Description is not clear. Examples should include a testcase where more than one digit is taken to form a number."
                    }
                ]
            },
            {
                "id": 1572513,
                "content": [
                    {
                        "username": "prshntvrm1",
                        "content": "I am bit  confused with  the question\\nwhat if input is [\"123\"] and the target is 9\\nthe only expected ans is [12-3] \\nwhy not [1+2 * 3]"
                    },
                    {
                        "username": "avijain14",
                        "content": "the expression is evaluated according to BODMAS rule"
                    },
                    {
                        "username": "doudoukuaipao",
                        "content": "I am wondering Why can\\'t this question use DFS with memorization? Could someone help explain? THanks!"
                    },
                    {
                        "username": "miracle84",
                        "content": "Regarding 105 and 5 example, also possible answer is 1*05, of course in usual representation we use 5 without leading zero, but anyway 05 equals 5, than 1*05 is also possible solution. \\nOr if we must use only numbers without leading zero, may be it should be clearly mentioned in description?\\nOr correct me please, if i am wrong."
                    },
                    {
                        "username": "vikas5",
                        "content": "Hi,\\nFor input parameters\"105\" and 5, my algorithm is getting an additional answer as \"1*05\". Why is this not an valid answer? Can someone help me here?"
                    },
                    {
                        "username": "atruecubsfan",
                        "content": "I believe the runtime complexity for the vanilla DFS approach is O(4 ^ n).  However there are many subproblems that can be memo-ized.  Whats the complexity of the memoized version?  "
                    },
                    {
                        "username": "Blink_fw",
                        "content": "Do we need to handle the case where the input string is very long? For example, we have \"99....99\", where there are 100 '9' in the string and the target value is 0? I don't see any restriction on the string length."
                    },
                    {
                        "username": "Decision",
                        "content": "It seems taking exponential time: O(4^n) by DFS solution. \\n\\nDoes this problem have polynomial time solution?"
                    },
                    {
                        "username": "thanir10",
                        "content": "The question is misleading here. The question did not mention whether there could be operation between multiple digit \\nEx : 10 - 5 (Accepted)"
                    },
                    {
                        "username": "marknaman05",
                        "content": "Input\nnum =\n\"105\"\ntarget =\n5\nOutput\n`[\"1*0+5\",\"1*05\",\"10-5\"]`\nExpected\n`[\"1*0+5\",\"10-5\"]`\n\nWhy this case is wrong?"
                    },
                    {
                        "username": "prakhars31",
                        "content": "Description is not clear. Examples should include a testcase where more than one digit is taken to form a number."
                    }
                ]
            },
            {
                "id": 1571989,
                "content": [
                    {
                        "username": "prshntvrm1",
                        "content": "I am bit  confused with  the question\\nwhat if input is [\"123\"] and the target is 9\\nthe only expected ans is [12-3] \\nwhy not [1+2 * 3]"
                    },
                    {
                        "username": "avijain14",
                        "content": "the expression is evaluated according to BODMAS rule"
                    },
                    {
                        "username": "doudoukuaipao",
                        "content": "I am wondering Why can\\'t this question use DFS with memorization? Could someone help explain? THanks!"
                    },
                    {
                        "username": "miracle84",
                        "content": "Regarding 105 and 5 example, also possible answer is 1*05, of course in usual representation we use 5 without leading zero, but anyway 05 equals 5, than 1*05 is also possible solution. \\nOr if we must use only numbers without leading zero, may be it should be clearly mentioned in description?\\nOr correct me please, if i am wrong."
                    },
                    {
                        "username": "vikas5",
                        "content": "Hi,\\nFor input parameters\"105\" and 5, my algorithm is getting an additional answer as \"1*05\". Why is this not an valid answer? Can someone help me here?"
                    },
                    {
                        "username": "atruecubsfan",
                        "content": "I believe the runtime complexity for the vanilla DFS approach is O(4 ^ n).  However there are many subproblems that can be memo-ized.  Whats the complexity of the memoized version?  "
                    },
                    {
                        "username": "Blink_fw",
                        "content": "Do we need to handle the case where the input string is very long? For example, we have \"99....99\", where there are 100 '9' in the string and the target value is 0? I don't see any restriction on the string length."
                    },
                    {
                        "username": "Decision",
                        "content": "It seems taking exponential time: O(4^n) by DFS solution. \\n\\nDoes this problem have polynomial time solution?"
                    },
                    {
                        "username": "thanir10",
                        "content": "The question is misleading here. The question did not mention whether there could be operation between multiple digit \\nEx : 10 - 5 (Accepted)"
                    },
                    {
                        "username": "marknaman05",
                        "content": "Input\nnum =\n\"105\"\ntarget =\n5\nOutput\n`[\"1*0+5\",\"1*05\",\"10-5\"]`\nExpected\n`[\"1*0+5\",\"10-5\"]`\n\nWhy this case is wrong?"
                    },
                    {
                        "username": "prakhars31",
                        "content": "Description is not clear. Examples should include a testcase where more than one digit is taken to form a number."
                    }
                ]
            },
            {
                "id": 1571525,
                "content": [
                    {
                        "username": "prshntvrm1",
                        "content": "I am bit  confused with  the question\\nwhat if input is [\"123\"] and the target is 9\\nthe only expected ans is [12-3] \\nwhy not [1+2 * 3]"
                    },
                    {
                        "username": "avijain14",
                        "content": "the expression is evaluated according to BODMAS rule"
                    },
                    {
                        "username": "doudoukuaipao",
                        "content": "I am wondering Why can\\'t this question use DFS with memorization? Could someone help explain? THanks!"
                    },
                    {
                        "username": "miracle84",
                        "content": "Regarding 105 and 5 example, also possible answer is 1*05, of course in usual representation we use 5 without leading zero, but anyway 05 equals 5, than 1*05 is also possible solution. \\nOr if we must use only numbers without leading zero, may be it should be clearly mentioned in description?\\nOr correct me please, if i am wrong."
                    },
                    {
                        "username": "vikas5",
                        "content": "Hi,\\nFor input parameters\"105\" and 5, my algorithm is getting an additional answer as \"1*05\". Why is this not an valid answer? Can someone help me here?"
                    },
                    {
                        "username": "atruecubsfan",
                        "content": "I believe the runtime complexity for the vanilla DFS approach is O(4 ^ n).  However there are many subproblems that can be memo-ized.  Whats the complexity of the memoized version?  "
                    },
                    {
                        "username": "Blink_fw",
                        "content": "Do we need to handle the case where the input string is very long? For example, we have \"99....99\", where there are 100 '9' in the string and the target value is 0? I don't see any restriction on the string length."
                    },
                    {
                        "username": "Decision",
                        "content": "It seems taking exponential time: O(4^n) by DFS solution. \\n\\nDoes this problem have polynomial time solution?"
                    },
                    {
                        "username": "thanir10",
                        "content": "The question is misleading here. The question did not mention whether there could be operation between multiple digit \\nEx : 10 - 5 (Accepted)"
                    },
                    {
                        "username": "marknaman05",
                        "content": "Input\nnum =\n\"105\"\ntarget =\n5\nOutput\n`[\"1*0+5\",\"1*05\",\"10-5\"]`\nExpected\n`[\"1*0+5\",\"10-5\"]`\n\nWhy this case is wrong?"
                    },
                    {
                        "username": "prakhars31",
                        "content": "Description is not clear. Examples should include a testcase where more than one digit is taken to form a number."
                    }
                ]
            },
            {
                "id": 1571526,
                "content": [
                    {
                        "username": "prshntvrm1",
                        "content": "I am bit  confused with  the question\\nwhat if input is [\"123\"] and the target is 9\\nthe only expected ans is [12-3] \\nwhy not [1+2 * 3]"
                    },
                    {
                        "username": "avijain14",
                        "content": "the expression is evaluated according to BODMAS rule"
                    },
                    {
                        "username": "doudoukuaipao",
                        "content": "I am wondering Why can\\'t this question use DFS with memorization? Could someone help explain? THanks!"
                    },
                    {
                        "username": "miracle84",
                        "content": "Regarding 105 and 5 example, also possible answer is 1*05, of course in usual representation we use 5 without leading zero, but anyway 05 equals 5, than 1*05 is also possible solution. \\nOr if we must use only numbers without leading zero, may be it should be clearly mentioned in description?\\nOr correct me please, if i am wrong."
                    },
                    {
                        "username": "vikas5",
                        "content": "Hi,\\nFor input parameters\"105\" and 5, my algorithm is getting an additional answer as \"1*05\". Why is this not an valid answer? Can someone help me here?"
                    },
                    {
                        "username": "atruecubsfan",
                        "content": "I believe the runtime complexity for the vanilla DFS approach is O(4 ^ n).  However there are many subproblems that can be memo-ized.  Whats the complexity of the memoized version?  "
                    },
                    {
                        "username": "Blink_fw",
                        "content": "Do we need to handle the case where the input string is very long? For example, we have \"99....99\", where there are 100 '9' in the string and the target value is 0? I don't see any restriction on the string length."
                    },
                    {
                        "username": "Decision",
                        "content": "It seems taking exponential time: O(4^n) by DFS solution. \\n\\nDoes this problem have polynomial time solution?"
                    },
                    {
                        "username": "thanir10",
                        "content": "The question is misleading here. The question did not mention whether there could be operation between multiple digit \\nEx : 10 - 5 (Accepted)"
                    },
                    {
                        "username": "marknaman05",
                        "content": "Input\nnum =\n\"105\"\ntarget =\n5\nOutput\n`[\"1*0+5\",\"1*05\",\"10-5\"]`\nExpected\n`[\"1*0+5\",\"10-5\"]`\n\nWhy this case is wrong?"
                    },
                    {
                        "username": "prakhars31",
                        "content": "Description is not clear. Examples should include a testcase where more than one digit is taken to form a number."
                    }
                ]
            },
            {
                "id": 2040002,
                "content": [
                    {
                        "username": "prshntvrm1",
                        "content": "I am bit  confused with  the question\\nwhat if input is [\"123\"] and the target is 9\\nthe only expected ans is [12-3] \\nwhy not [1+2 * 3]"
                    },
                    {
                        "username": "avijain14",
                        "content": "the expression is evaluated according to BODMAS rule"
                    },
                    {
                        "username": "doudoukuaipao",
                        "content": "I am wondering Why can\\'t this question use DFS with memorization? Could someone help explain? THanks!"
                    },
                    {
                        "username": "miracle84",
                        "content": "Regarding 105 and 5 example, also possible answer is 1*05, of course in usual representation we use 5 without leading zero, but anyway 05 equals 5, than 1*05 is also possible solution. \\nOr if we must use only numbers without leading zero, may be it should be clearly mentioned in description?\\nOr correct me please, if i am wrong."
                    },
                    {
                        "username": "vikas5",
                        "content": "Hi,\\nFor input parameters\"105\" and 5, my algorithm is getting an additional answer as \"1*05\". Why is this not an valid answer? Can someone help me here?"
                    },
                    {
                        "username": "atruecubsfan",
                        "content": "I believe the runtime complexity for the vanilla DFS approach is O(4 ^ n).  However there are many subproblems that can be memo-ized.  Whats the complexity of the memoized version?  "
                    },
                    {
                        "username": "Blink_fw",
                        "content": "Do we need to handle the case where the input string is very long? For example, we have \"99....99\", where there are 100 '9' in the string and the target value is 0? I don't see any restriction on the string length."
                    },
                    {
                        "username": "Decision",
                        "content": "It seems taking exponential time: O(4^n) by DFS solution. \\n\\nDoes this problem have polynomial time solution?"
                    },
                    {
                        "username": "thanir10",
                        "content": "The question is misleading here. The question did not mention whether there could be operation between multiple digit \\nEx : 10 - 5 (Accepted)"
                    },
                    {
                        "username": "marknaman05",
                        "content": "Input\nnum =\n\"105\"\ntarget =\n5\nOutput\n`[\"1*0+5\",\"1*05\",\"10-5\"]`\nExpected\n`[\"1*0+5\",\"10-5\"]`\n\nWhy this case is wrong?"
                    },
                    {
                        "username": "prakhars31",
                        "content": "Description is not clear. Examples should include a testcase where more than one digit is taken to form a number."
                    }
                ]
            },
            {
                "id": 1994199,
                "content": [
                    {
                        "username": "prshntvrm1",
                        "content": "I am bit  confused with  the question\\nwhat if input is [\"123\"] and the target is 9\\nthe only expected ans is [12-3] \\nwhy not [1+2 * 3]"
                    },
                    {
                        "username": "avijain14",
                        "content": "the expression is evaluated according to BODMAS rule"
                    },
                    {
                        "username": "doudoukuaipao",
                        "content": "I am wondering Why can\\'t this question use DFS with memorization? Could someone help explain? THanks!"
                    },
                    {
                        "username": "miracle84",
                        "content": "Regarding 105 and 5 example, also possible answer is 1*05, of course in usual representation we use 5 without leading zero, but anyway 05 equals 5, than 1*05 is also possible solution. \\nOr if we must use only numbers without leading zero, may be it should be clearly mentioned in description?\\nOr correct me please, if i am wrong."
                    },
                    {
                        "username": "vikas5",
                        "content": "Hi,\\nFor input parameters\"105\" and 5, my algorithm is getting an additional answer as \"1*05\". Why is this not an valid answer? Can someone help me here?"
                    },
                    {
                        "username": "atruecubsfan",
                        "content": "I believe the runtime complexity for the vanilla DFS approach is O(4 ^ n).  However there are many subproblems that can be memo-ized.  Whats the complexity of the memoized version?  "
                    },
                    {
                        "username": "Blink_fw",
                        "content": "Do we need to handle the case where the input string is very long? For example, we have \"99....99\", where there are 100 '9' in the string and the target value is 0? I don't see any restriction on the string length."
                    },
                    {
                        "username": "Decision",
                        "content": "It seems taking exponential time: O(4^n) by DFS solution. \\n\\nDoes this problem have polynomial time solution?"
                    },
                    {
                        "username": "thanir10",
                        "content": "The question is misleading here. The question did not mention whether there could be operation between multiple digit \\nEx : 10 - 5 (Accepted)"
                    },
                    {
                        "username": "marknaman05",
                        "content": "Input\nnum =\n\"105\"\ntarget =\n5\nOutput\n`[\"1*0+5\",\"1*05\",\"10-5\"]`\nExpected\n`[\"1*0+5\",\"10-5\"]`\n\nWhy this case is wrong?"
                    },
                    {
                        "username": "prakhars31",
                        "content": "Description is not clear. Examples should include a testcase where more than one digit is taken to form a number."
                    }
                ]
            },
            {
                "id": 1979861,
                "content": [
                    {
                        "username": "prshntvrm1",
                        "content": "I am bit  confused with  the question\\nwhat if input is [\"123\"] and the target is 9\\nthe only expected ans is [12-3] \\nwhy not [1+2 * 3]"
                    },
                    {
                        "username": "avijain14",
                        "content": "the expression is evaluated according to BODMAS rule"
                    },
                    {
                        "username": "doudoukuaipao",
                        "content": "I am wondering Why can\\'t this question use DFS with memorization? Could someone help explain? THanks!"
                    },
                    {
                        "username": "miracle84",
                        "content": "Regarding 105 and 5 example, also possible answer is 1*05, of course in usual representation we use 5 without leading zero, but anyway 05 equals 5, than 1*05 is also possible solution. \\nOr if we must use only numbers without leading zero, may be it should be clearly mentioned in description?\\nOr correct me please, if i am wrong."
                    },
                    {
                        "username": "vikas5",
                        "content": "Hi,\\nFor input parameters\"105\" and 5, my algorithm is getting an additional answer as \"1*05\". Why is this not an valid answer? Can someone help me here?"
                    },
                    {
                        "username": "atruecubsfan",
                        "content": "I believe the runtime complexity for the vanilla DFS approach is O(4 ^ n).  However there are many subproblems that can be memo-ized.  Whats the complexity of the memoized version?  "
                    },
                    {
                        "username": "Blink_fw",
                        "content": "Do we need to handle the case where the input string is very long? For example, we have \"99....99\", where there are 100 '9' in the string and the target value is 0? I don't see any restriction on the string length."
                    },
                    {
                        "username": "Decision",
                        "content": "It seems taking exponential time: O(4^n) by DFS solution. \\n\\nDoes this problem have polynomial time solution?"
                    },
                    {
                        "username": "thanir10",
                        "content": "The question is misleading here. The question did not mention whether there could be operation between multiple digit \\nEx : 10 - 5 (Accepted)"
                    },
                    {
                        "username": "marknaman05",
                        "content": "Input\nnum =\n\"105\"\ntarget =\n5\nOutput\n`[\"1*0+5\",\"1*05\",\"10-5\"]`\nExpected\n`[\"1*0+5\",\"10-5\"]`\n\nWhy this case is wrong?"
                    },
                    {
                        "username": "prakhars31",
                        "content": "Description is not clear. Examples should include a testcase where more than one digit is taken to form a number."
                    }
                ]
            }
        ]
    },
    {
        "title": "Move Zeroes",
        "question_content": "<p>Given an integer array <code>nums</code>, move all <code>0</code>&#39;s to the end of it while maintaining the relative order of the non-zero elements.</p>\n\n<p><strong>Note</strong> that you must do this in-place without making a copy of the array.</p>\n\n<p>&nbsp;</p>\n<p><strong class=\"example\">Example 1:</strong></p>\n<pre><strong>Input:</strong> nums = [0,1,0,3,12]\n<strong>Output:</strong> [1,3,12,0,0]\n</pre><p><strong class=\"example\">Example 2:</strong></p>\n<pre><strong>Input:</strong> nums = [0]\n<strong>Output:</strong> [0]\n</pre>\n<p>&nbsp;</p>\n<p><strong>Constraints:</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= nums.length &lt;= 10<sup>4</sup></code></li>\n\t<li><code>-2<sup>31</sup> &lt;= nums[i] &lt;= 2<sup>31</sup> - 1</code></li>\n</ul>\n\n<p>&nbsp;</p>\n<strong>Follow up:</strong> Could you minimize the total number of operations done?",
        "solutions": [
            {
                "id": 172432,
                "title": "the-easiest-but-unusual-snowball-java-solution-beats-100-o-n-clear-explanation",
                "content": "The idea is that we go through the array and gather all zeros on our road.\\n![image](https://assets.leetcode.com/users/olsh/image_1537442610.png)\\n\\nLet\\'s take our example:\\nthe first step - we meet 0. \\nOkay, just remember that now the size of our snowball is 1. Go further.\\n![image](https://assets.leetcode.com/users/olsh/image_1537442825.png)\\n\\nNext step - we encounter 1. Swap the most left 0 of our snowball with element 1.\\n\\n![image](https://assets.leetcode.com/users/olsh/image_1537444682.png)\\n\\n\\n\\nNext step - we encounter 0 again! \\n\\n\\n\\n![image](https://assets.leetcode.com/users/olsh/image_1537443824.png)\\n\\n\\nOur ball gets bigger, now its size = 2.\\n\\n![image](https://assets.leetcode.com/users/olsh/image_1537443928.png)\\n\\n\\nNext step - 3. Swap again with the most left zero.\\n\\n![image](https://assets.leetcode.com/users/olsh/image_1537444816.png)\\n\\n\\nLooks like our zeros roll all the time\\n\\n![image](https://assets.leetcode.com/users/olsh/image_1537444189.png)\\n\\nNext step - 12. Swap again:\\n\\n![image](https://assets.leetcode.com/users/olsh/image_1537444465.png)\\n\\n\\nWe reached finish! Congratulations!\\n\\n![image](https://assets.leetcode.com/users/olsh/image_1537444540.png)\\n\\n\\nHere\\'s the code\\n\\n```\\nclass Solution {\\n     public void moveZeroes(int[] nums) {\\n        int snowBallSize = 0; \\n        for (int i=0;i<nums.length;i++){\\n\\t        if (nums[i]==0){\\n                snowBallSize++; \\n            }\\n            else if (snowBallSize > 0) {\\n\\t            int t = nums[i];\\n\\t            nums[i]=0;\\n\\t            nums[i-snowBallSize]=t;\\n            }\\n        }\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n     public void moveZeroes(int[] nums) {\\n        int snowBallSize = 0; \\n        for (int i=0;i<nums.length;i++){\\n\\t        if (nums[i]==0){\\n                snowBallSize++; \\n            }\\n            else if (snowBallSize > 0) {\\n\\t            int t = nums[i];\\n\\t            nums[i]=0;\\n\\t            nums[i-snowBallSize]=t;\\n            }\\n        }\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 72011,
                "title": "simple-o-n-java-solution-using-insert-index",
                "content": " \\n    // Shift non-zero values as far forward as possible\\n    // Fill remaining space with zeros\\n\\n    public void moveZeroes(int[] nums) {\\n        if (nums == null || nums.length == 0) return;        \\n\\n        int insertPos = 0;\\n        for (int num: nums) {\\n            if (num != 0) nums[insertPos++] = num;\\n        }        \\n\\n        while (insertPos < nums.length) {\\n            nums[insertPos++] = 0;\\n        }\\n    }",
                "solutionTags": [
                    "Java"
                ],
                "code": " \\n    // Shift non-zero values as far forward as possible\\n    // Fill remaining space with zeros\\n\\n    public void moveZeroes(int[] nums) {\\n        if (nums == null || nums.length == 0) return;        \\n\\n        int insertPos = 0;\\n        for (int num: nums) {\\n            if (num != 0) nums[insertPos++] = num;\\n        }        \\n\\n        while (insertPos < nums.length) {\\n            nums[insertPos++] = 0;\\n        }\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 562911,
                "title": "two-pointers-technique-python-o-n-time-o-1-space",
                "content": "Hi there! Here is my solution to this problem that uses two pointers technique.\\n\\n**Code:**\\n```\\nclass Solution:\\n    def moveZeroes(self, nums: list) -> None:\\n        slow = 0\\n        for fast in range(len(nums)):\\n            if nums[fast] != 0 and nums[slow] == 0:\\n                nums[slow], nums[fast] = nums[fast], nums[slow]\\n\\n            # wait while we find a non-zero element to\\n            # swap with you\\n            if nums[slow] != 0:\\n                slow += 1\\n```\\n\\n**Algorithm complexity:**\\n*Time complexity: O(n)*. Our fast pointer does not visit the same spot twice.\\n*Space complexity: O(1)*. All operations are made in-place\\n\\nIf you like my solution, I will really appreciate your upvoting. It will help other python-developers to find it faster. And as always, I wish you an enjoyable time on LeetCode.\\n\\n**Special thanks for the next comments:**\\n[**stanley98745**](https://leetcode.com/problems/move-zeroes/discuss/562911/two-pointers-technique-python-on-time-o1-space/513985)",
                "solutionTags": [
                    "Python3",
                    "Two Pointers"
                ],
                "code": "```\\nclass Solution:\\n    def moveZeroes(self, nums: list) -> None:\\n        slow = 0\\n        for fast in range(len(nums)):\\n            if nums[fast] != 0 and nums[slow] == 0:\\n                nums[slow], nums[fast] = nums[fast], nums[slow]\\n\\n            # wait while we find a non-zero element to\\n            # swap with you\\n            if nums[slow] != 0:\\n                slow += 1\\n```",
                "codeTag": "Java"
            },
            {
                "id": 72005,
                "title": "my-simple-c-solution",
                "content": "    class Solution {\\n    public:\\n        void moveZeroes(vector<int>& nums) {\\n            int j = 0;\\n            // move all the nonzero elements advance\\n            for (int i = 0; i < nums.size(); i++) {\\n                if (nums[i] != 0) {\\n                    nums[j++] = nums[i];\\n                }\\n            }\\n            for (;j < nums.size(); j++) {\\n                nums[j] = 0;\\n            }\\n        }\\n    };",
                "solutionTags": [
                    "C++"
                ],
                "code": "class Solution {\\n    public:\\n        void moveZeroes(vector<int>& nums) {\\n            int j = 0;\\n            // move all the nonzero elements advance\\n            for (int i = 0; i < nums.size(); i++) {\\n                if (nums[i] != 0) {\\n                    nums[j++] = nums[i];\\n                }",
                "codeTag": "Java"
            },
            {
                "id": 72000,
                "title": "1ms-java-solution",
                "content": "public class Solution {\\n    \\n    public void moveZeroes(int[] nums) {\\n\\n        int j = 0;\\n        for(int i = 0; i < nums.length; i++) {\\n            if(nums[i] != 0) {\\n                int temp = nums[j];\\n                nums[j] = nums[i];\\n                nums[i] = temp;\\n                j++;\\n            }\\n        }\\n    }\\n}",
                "solutionTags": [
                    "Java"
                ],
                "code": "class Solution {\\n    \\n    public void moveZeroes(int[] nums) {\\n\\n        int j = 0;\\n        for(int i = 0; i < nums.length; i++) {\\n            if(nums[i] != 0) {\\n                int temp = nums[j];\\n                nums[j] = nums[i];\\n                nums[i] = temp;\\n                j++;\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 72012,
                "title": "python-short-in-place-solution-with-comments",
                "content": "    \\n    # in-place\\n    def moveZeroes(self, nums):\\n        zero = 0  # records the position of \"0\"\\n        for i in xrange(len(nums)):\\n            if nums[i] != 0:\\n                nums[i], nums[zero] = nums[zero], nums[i]\\n                zero += 1",
                "solutionTags": [
                    "Python",
                    "Two Pointers"
                ],
                "code": "    \\n    # in-place\\n    def moveZeroes(self, nums):\\n        zero = 0  # records the position of \"0\"\\n        for i in xrange(len(nums)):\\n            if nums[i] != 0:\\n                nums[i], nums[zero] = nums[zero], nums[i]\\n                zero += 1",
                "codeTag": "Python3"
            },
            {
                "id": 1592151,
                "title": "python-solution-super-simple-clear-explanation",
                "content": "# 1. Solution\\n\\n```\\n    def moveZeroes(self, nums):\\n        n = len(nums)\\n        i = 0\\n        for j in range(n):\\n            if (nums[j] != 0):\\n                nums[i], nums[j] = nums[j], nums[i]\\n                i += 1\\n```\\n\\n\\n# 2. Main idea\\n* We use` i` to keep track of position of the first zero in the list (which changes as we go).\\n* We use` j `to keep track of the first non-zero value after the first zero (which is pointed by `i`).\\n* Each time we have` i` correctly points to a zero and `j` correctly points to the first non-zero after `i`, we swap the values that store at `i` and `j`.\\n* By doing this, we move zeros towards the end of the list gradually until `j` reaches the end.\\n* And when it does, we are done.\\n\\n# 3. Remarks\\n* No return value needed, since we are doing in-place modification.\\n* We use` nums[i], nums[j] = nums[j], nums[i]` to achieve the in-place modification because Python allows you to swaps values in a list using syntax: `x, y = y, x`.\\n\\n****Please upvote if you find this post useful, and welcome to any further discussion!***",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Two Pointers"
                ],
                "code": "```\\n    def moveZeroes(self, nums):\\n        n = len(nums)\\n        i = 0\\n        for j in range(n):\\n            if (nums[j] != 0):\\n                nums[i], nums[j] = nums[j], nums[i]\\n                i += 1\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 208755,
                "title": "python-solution",
                "content": "We initialize two pointers `i = 0`, `j = 0`. Iterate `j` over `range(len(nums))`, and if `nums[j] != 0`, we swap `nums[i]` and `nums[j]`, and increment `i` by `1`. It is easy to see the loop invariant that `nums[:i+1]` contains all nonzero elements in `nums[:j+1]` with relative order preserved. Hence when `j` reaches `len(nums)-1`, `nums[:i+1]` contains all nonzero elements in `nums` with relative order preserved.\\n\\nTime complexity: `O(n)`, space complexity: `O(1)`.\\n\\n```\\nclass Solution(object):\\n    def moveZeroes(self, nums):\\n        \"\"\"\\n        :type nums: List[int]\\n        :rtype: void Do not return anything, modify nums in-place instead.\\n        \"\"\"\\n        i = 0\\n        for j in range(len(nums)):\\n            if nums[j] != 0:\\n                nums[i], nums[j] = nums[j], nums[i]\\n                i += 1\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution(object):\\n    def moveZeroes(self, nums):\\n        \"\"\"\\n        :type nums: List[int]\\n        :rtype: void Do not return anything, modify nums in-place instead.\\n        \"\"\"\\n        i = 0\\n        for j in range(len(nums)):\\n            if nums[j] != 0:\\n                nums[i], nums[j] = nums[j], nums[i]\\n                i += 1\\n```",
                "codeTag": "Java"
            },
            {
                "id": 809349,
                "title": "simple-c-solutions-know-your-stl",
                "content": "It is easy to create your own solution to this problem, take this for instance:\\n```C++\\nvoid moveZeroes(vector<int>& nums)\\n{\\n\\tfor(int i=0,next=0;i<nums.size();++i)\\n\\t\\tif(nums[i])\\n\\t\\t\\tswap(nums[i],nums[next++]);\\n}\\n```\\nand an interviewer would probably ask you to do so even if you bring up one of the other solutions I mention here, but it is also important to know your STL. An interviewer might be more impressed with this solution that uses std::stable_parition:\\n```C++\\nvoid moveZeroes(vector<int>& nums)\\n{\\n    stable_partition(begin(nums),end(nums),[](int i){return i;});\\n}\\n```\\nBut you can even avoid using a lambda if you know your STL extremely well\\u2014check this out:\\n```C++\\nvoid moveZeroes(vector<int>& nums)\\n{\\n    stable_partition(rbegin(nums),rend(nums),logical_not<int>());\\n}\\n```\\nstd::logical_not is template function object that returns `!argument` for whatever is passed in. If the number is non-zero it will return false and if it is zero it will return true. This is the reverse of what the lambda does in the previous solution and so would move all the zeroes to the front, but to fix this we can just use the reverse iterators for the vector.",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```C++\\nvoid moveZeroes(vector<int>& nums)\\n{\\n\\tfor(int i=0,next=0;i<nums.size();++i)\\n\\t\\tif(nums[i])\\n\\t\\t\\tswap(nums[i],nums[next++]);\\n}\\n```\n```C++\\nvoid moveZeroes(vector<int>& nums)\\n{\\n    stable_partition(begin(nums),end(nums),[](int i){return i;});\\n}\\n```\n```C++\\nvoid moveZeroes(vector<int>& nums)\\n{\\n    stable_partition(rbegin(nums),rend(nums),logical_not<int>());\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3549476,
                "title": "easy-java-solution-beats-99-9",
                "content": "# Approach\\nThis code is for a method called `moveZeroes` that takes an array of integers called `nums` as input and moves all the zeros to the end of the array while keeping the order of the non-zero elements unchanged. Let\\'s break down the code step by step:\\n\\n1. Initialize a variable `i` to 0. This variable will be used to keep track of the index where the next non-zero element should be placed.\\n\\n2. Start a loop that iterates over each element `num` in the `nums` array.\\n\\n3. Check if the current element `num` is not equal to 0 (which means it\\'s a non-zero element).\\n\\n4. If the current element is non-zero, assign it to the position `nums[i]` in the array, and then increment `i` by 1. This moves the non-zero element to the left side of the array.\\n\\n5. After processing all the elements in the array, there might be some remaining positions towards the end of the array that need to be filled with zeros. \\n\\n6. Start another loop that continues from the last value of `i` until the end of the array (`nums.length`). \\n\\n7. Set the value of `nums[i]` to 0, effectively placing zeros in the remaining positions at the end of the array.\\n\\n8. Increment `i` by 1 in each iteration to move to the next position in the array.\\n\\n9. Once this loop is completed, all the non-zero elements have been moved to the front of the array, and any remaining positions towards the end of the array have been filled with zeros.\\n\\nThe code rearranges the array in-place, meaning it modifies the original `nums` array without creating a new one. After calling this `moveZeroes` method, the array `nums` will have all the zeros moved to the end while preserving the order of the non-zero elements.\\n\\n# Code\\n```\\nclass Solution {\\n    public void moveZeroes(int[] nums) {\\n        int i = 0; \\n        for (int num:nums){\\n            if(num != 0){\\n                nums[i] = num;\\n                i++;\\n            }\\n        }\\n        while(i<nums.length){\\n            nums[i] = 0;\\n            i++;\\n        }\\n    }\\n}\\n```\\n**Please upvote if you like the solution.\\nHappy Coding!** \\uD83D\\uDE0A",
                "solutionTags": [
                    "Java",
                    "Array",
                    "Two Pointers"
                ],
                "code": "```\\nclass Solution {\\n    public void moveZeroes(int[] nums) {\\n        int i = 0; \\n        for (int num:nums){\\n            if(num != 0){\\n                nums[i] = num;\\n                i++;\\n            }\\n        }\\n        while(i<nums.length){\\n            nums[i] = 0;\\n            i++;\\n        }\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 979820,
                "title": "two-pointer-visual-python",
                "content": "This problem uses a two pointer stratgey. The code is unintuitive . so i have provided a visual walkthrough. \\n\\n```python\\n def moveZeroes(self, nums: List[int]) -> None:\\n        i = 0\\n        for j in range(len(nums)):\\n            if nums[j] != 0:\\n                nums[i], nums[j] = nums[j], nums[i]\\n                i += 1\\n```\\n\\n![image](https://assets.leetcode.com/users/images/2490959a-5e63-46d0-b1f4-0393fe78e4d2_1608510556.5769494.png)\\n\\n[code courtesy of ZitaoWang](https://leetcode.com/problems/move-zeroes/discuss/208755/Python-solution)\\n",
                "solutionTags": [
                    "Python",
                    "Two Pointers"
                ],
                "code": "```python\\n def moveZeroes(self, nums: List[int]) -> None:\\n        i = 0\\n        for j in range(len(nums)):\\n            if nums[j] != 0:\\n                nums[i], nums[j] = nums[j], nums[i]\\n                i += 1\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 72045,
                "title": "c-accepted-code",
                "content": "    void moveZeroes(vector<int>& nums) {\\n        int last = 0, cur = 0;\\n        \\n        while(cur < nums.size()) {\\n            if(nums[cur] != 0) {\\n                swap(nums[last], nums[cur]);\\n                last++;\\n            }\\n            \\n            cur++;\\n        }\\n    }",
                "solutionTags": [],
                "code": "    void moveZeroes(vector<int>& nums) {\\n        int last = 0, cur = 0;\\n        \\n        while(cur < nums.size()) {\\n            if(nums[cur] != 0) {\\n                swap(nums[last], nums[cur]);\\n                last++;\\n            }\\n            \\n            cur++;\\n        }\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 3424746,
                "title": "easy-to-understand-code-c",
                "content": "# Approach\\n<!-- Describe your approach to solving the problem. -->\\nThis solution aims to move all the zeros in a given vector nums to the end of the vector while preserving the relative order of the non-zero elements. Let\\'s break down the solution step by step:\\n\\nInitialize variables:\\n\\nn stores the size of the vector nums.\\nstart represents the index where the next non-zero element should be placed.\\nend represents the index of the last element in the vector.\\nmid is used to iterate through the vector from the beginning to the end.\\nStart the while loop: The loop continues until mid reaches the index of the last element (end).\\n\\nCheck if the element at the current index mid is non-zero:\\n\\nIf nums[mid] is not equal to 0, it means it is a non-zero element.\\nIn this case, we need to move this non-zero element to the front of the vector.\\nTo achieve this, we swap the elements at indices start and mid, effectively moving the non-zero element to the position indicated by start.\\nIncrement start by 1: After swapping the elements, we increment start to prepare for the next non-zero element that we might encounter later in the vector.\\n\\nIncrement mid by 1: Regardless of whether the element at mid was non-zero or zero, we always increment mid by 1 to move on to the next element in the vector.\\n\\nRepeat steps 3-5 until mid exceeds end: This loop continues until we have iterated through all the elements in the vector.\\n\\nAfter the loop finishes, all the non-zero elements will be placed at the beginning of the vector, and all the zeros will be at the end. The relative order of the non-zero elements will remain the same as in the original vector.\\n\\nIt\\'s worth noting that this solution operates in-place, meaning it modifies the original vector without using any extra space.\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nO(n)\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nO(1)\\n# Code\\n```\\nclass Solution {\\npublic:\\n    void moveZeroes(vector<int>& nums) {\\n        int n= nums.size();\\n        int start=0, end=n-1,mid=0;\\n        while(mid<=end){\\n            if(nums[mid]!=0){\\n                swap(nums[start],nums[mid]);                  \\n                    start++;\\n            }\\n            mid++;\\n        }\\n    }\\n};\\n```\\n![upvote 1.jpeg](https://assets.leetcode.com/users/images/b3a0cacd-6403-44e6-a08a-f5c947c9c49c_1681675209.6594658.jpeg)\\n",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    void moveZeroes(vector<int>& nums) {\\n        int n= nums.size();\\n        int start=0, end=n-1,mid=0;\\n        while(mid<=end){\\n            if(nums[mid]!=0){\\n                swap(nums[start],nums[mid]);                  \\n                    start++;\\n            }\\n            mid++;\\n        }\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 72128,
                "title": "0ms-java-solution",
                "content": "   Insert the non-zero number first, then insert the zeroes.\\n\\n\\n     public class Solution{\\n        \\tpublic void moveZeroes(int[] nums){\\n        \\t\\tint index=0;\\n        \\t\\tfor (int i=0;i<nums.length;i++){\\n        \\t\\t\\tif (nums[i]!=0) nums[index++]=nums[i];\\n        \\t\\t}\\n        \\t\\twhile(index<nums.length){\\n        \\t\\t\\tnums[index++]=0;\\n        \\t\\t}\\n        \\t}\\n        \\n        }",
                "solutionTags": [],
                "code": "class Solution{\\n        \\tpublic void moveZeroes(int[] nums){\\n        \\t\\tint index=0;\\n        \\t\\tfor (int i=0;i<nums.length;i++){\\n        \\t\\t\\tif (nums[i]!=0) nums[index++]=nums[i];\\n        \\t\\t}",
                "codeTag": "Java"
            },
            {
                "id": 72132,
                "title": "one-line-c-code-20ms",
                "content": "The idea comes from the c++ erase/remove idiom.\\n\\n    class Solution {\\n    public:\\n        void moveZeroes(vector<int>& nums) {\\n            fill(remove(nums.begin(), nums.end(),0), nums.end(), 0);\\n        }\\n    };",
                "solutionTags": [],
                "code": "class Solution {\\n    public:\\n        void moveZeroes(vector<int>& nums) {\\n            fill(remove(nums.begin(), nums.end(),0), nums.end(), 0);\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 2685367,
                "title": "js-es6-two-pointers-93-with-explanation",
                "content": "![image](https://assets.leetcode.com/users/images/432c5704-6859-43e8-acd9-c3c8b9786b68_1665392777.2844386.png)\\n\\n**Two pointers** is the use of two different pointers (usually to keep track of array or string indexes) to solve a problem with specified indexes in order to save time and space.\\n\\nTo solve this problem, we create two pointers low = 0, and high = low + 1. Now while high < array length - 1, we keep iterating. If the symbol under the low index = 0, we stop the low and move only the high until it hits a number not equal to 0 (!==0). As soon as the high finds a non-zero, we swap low and high (that is, swap a number with zero), and only then start moving the low again.\\n\\nI hope the picture below will give you a clearer understanding :)\\n\\n![image](https://assets.leetcode.com/users/images/993ea39e-c1f6-45e8-98ec-23fd6168dd1c_1665395049.1154604.png)\\n\\n```\\nlet moveZeroes = function (nums) {\\n    let low = 0;\\n    let high = low + 1;\\n\\n    while (high <= nums.length - 1) {\\n        if (nums[low] !== 0) {\\n            low++;\\n            high++;\\n        } else {\\n            if (nums[high] !== 0) {\\n                [nums[low], nums[high]] = [nums[high], nums[low]];\\n                low++;\\n            }\\n            high++;\\n        }\\n    }\\n};\\n```\\n\\nI hope I was able to explain clearly. **Happy coding!** \\uD83D\\uDE43",
                "solutionTags": [
                    "JavaScript",
                    "Two Pointers"
                ],
                "code": "```\\nlet moveZeroes = function (nums) {\\n    let low = 0;\\n    let high = low + 1;\\n\\n    while (high <= nums.length - 1) {\\n        if (nums[low] !== 0) {\\n            low++;\\n            high++;\\n        } else {\\n            if (nums[high] !== 0) {\\n                [nums[low], nums[high]] = [nums[high], nums[low]];\\n                low++;\\n            }\\n            high++;\\n        }\\n    }\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 72364,
                "title": "javascript-124ms",
                "content": "var moveZeroes = function(nums) {\\n\\n    //two pointers\\n    var pos = 0;\\n    for (var i = 0; i < nums.length; i++) {\\n        if (nums[i] !== 0) {\\n            nums[pos++] = nums[i];\\n        }\\n    }\\n    for (i = pos; i < nums.length; i++) {\\n        nums[i] = 0;\\n    }\\n};",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "var moveZeroes = function(nums) {\\n\\n    //two pointers\\n    var pos = 0;\\n    for (var i = 0; i < nums.length; i++) {\\n        if (nums[i] !== 0) {\\n            nums[pos++] = nums[i];\\n        }\\n    }\\n    for (i = pos; i < nums.length; i++) {\\n        nums[i] = 0;\\n    }\\n};",
                "codeTag": "Unknown"
            },
            {
                "id": 3960034,
                "title": "three-simple-java-solutions-runtime-0ms-beats100",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code 1\\n```\\nclass Solution {\\n    public void moveZeroes(int[] nums) \\n   {\\n        int i = 0;\\n        for (int num : nums)\\n        {\\n            if (num != 0)\\n            {\\n                nums[i] = num;\\n                i++;\\n            }\\n        }\\n\\n        while (i <= nums.length - 1)\\n        {\\n            nums[i] = 0;\\n            i++;\\n        }\\n\\n    }\\n}\\n```\\n\\n# code 2\\n\\n```\\nclass Solution {\\n    public void moveZeroes(int[] nums) {\\n        int nonZeroIndex = 0;\\n\\n    for (int i = 0; i < nums.length; i++) {\\n        if (nums[i] != 0) {\\n            if (i != nonZeroIndex) { \\n                int temp = nums[nonZeroIndex];\\n                nums[nonZeroIndex] = nums[i];\\n                nums[i] = temp;\\n            }\\n            nonZeroIndex++;\\n        }\\n    }\\n    }\\n}\\n```\\n\\n# code 3\\nI don\\'t think it\\'s the best  => runtime 50ms\\n\\nIt moves non-zero elements to the left while maintaining their order and zeroes to the right\\n\\n\\n```\\nclass Solution {\\n    public void moveZeroes(int[] nums) \\n   {\\n        int temp = -1;\\n\\n        for (int i = 0  ; i <= nums.length - 1 ; i++)\\n        {\\n            if (temp == -1 && nums[i] == 0)\\n            {\\n                temp = i;\\n            }else if (temp != -1 && nums[i] != 0){\\n                nums[temp] = nums[i];\\n                nums[i] = 0;\\n                i = temp;\\n                temp = -1;\\n            }\\n        }\\n\\n    }\\n}\\n```\\n\\n![e78315ef-8a9d-492b-9908-e3917f23eb31_1674946036.087042.jpeg](https://assets.leetcode.com/users/images/209f8226-6751-4d01-99bc-1b4a509bfb01_1692992097.3519738.jpeg)\\n",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public void moveZeroes(int[] nums) \\n   {\\n        int i = 0;\\n        for (int num : nums)\\n        {\\n            if (num != 0)\\n            {\\n                nums[i] = num;\\n                i++;\\n            }\\n        }\\n\\n        while (i <= nums.length - 1)\\n        {\\n            nums[i] = 0;\\n            i++;\\n        }\\n\\n    }\\n}\\n```\n```\\nclass Solution {\\n    public void moveZeroes(int[] nums) {\\n        int nonZeroIndex = 0;\\n\\n    for (int i = 0; i < nums.length; i++) {\\n        if (nums[i] != 0) {\\n            if (i != nonZeroIndex) { \\n                int temp = nums[nonZeroIndex];\\n                nums[nonZeroIndex] = nums[i];\\n                nums[i] = temp;\\n            }\\n            nonZeroIndex++;\\n        }\\n    }\\n    }\\n}\\n```\n```\\nclass Solution {\\n    public void moveZeroes(int[] nums) \\n   {\\n        int temp = -1;\\n\\n        for (int i = 0  ; i <= nums.length - 1 ; i++)\\n        {\\n            if (temp == -1 && nums[i] == 0)\\n            {\\n                temp = i;\\n            }else if (temp != -1 && nums[i] != 0){\\n                nums[temp] = nums[i];\\n                nums[i] = 0;\\n                i = temp;\\n                temp = -1;\\n            }\\n        }\\n\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1630405,
                "title": "easy-c-solution-with-two-pointer-approach-line-by-line-explanation",
                "content": "Here I\\'ve used two pointers approach.\\nSteps:\\n1. Declare 2 pointers i and j.\\n2. Initialize i at 0 and j at 1.\\n3. Run the while loop until j is less than n (size of the array).\\n4. Now use if-else statements to compare.\\n5. If the value at both i and j index is 0, move the j pointer by 1 position.\\n6. If the value at i is 0 and value at j index is not zero, swap both the values and move both the pointers by 1 position.\\n7. In else case, move both the pointers by 1 position.\\n\\n```\\nclass Solution {\\npublic:\\n    void moveZeroes(vector<int>& nums) {\\n        int n = nums.size();\\n        int i = 0;\\n        int j = 1;\\n        while(j<n){\\n            if(nums[i]==0 && nums[j]!=0){\\n                swap(nums[i],nums[j]);\\n                i++;\\n                j++;\\n            }\\n            else if(nums[i]==0 && nums[j]==0){\\n                j++;\\n            }\\n            else{\\n                i++;\\n                j++;\\n            }\\n        }\\n    }\\n};\\n```\\n\\nFeel free to like and comment if you find this solution helpful, thanks.",
                "solutionTags": [
                    "C++",
                    "C",
                    "Two Pointers"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    void moveZeroes(vector<int>& nums) {\\n        int n = nums.size();\\n        int i = 0;\\n        int j = 1;\\n        while(j<n){\\n            if(nums[i]==0 && nums[j]!=0){\\n                swap(nums[i],nums[j]);\\n                i++;\\n                j++;\\n            }\\n            else if(nums[i]==0 && nums[j]==0){\\n                j++;\\n            }\\n            else{\\n                i++;\\n                j++;\\n            }\\n        }\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 72422,
                "title": "javascript-solution",
                "content": "    function moveZeroes(nums) {\\n      var idx = 0;\\n      for (var i = 0; i < nums.length; i++) {\\n        if (nums[i] !== 0) {\\n          nums[idx] = nums[i];\\n          nums[i] = idx === i ? nums[i] : 0;\\n          idx++;\\n        }\\n      }\\n    }",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "    function moveZeroes(nums) {\\n      var idx = 0;\\n      for (var i = 0; i < nums.length; i++) {\\n        if (nums[i] !== 0) {\\n          nums[idx] = nums[i];\\n          nums[i] = idx === i ? nums[i] : 0;\\n          idx++;\\n        }\\n      }\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 72074,
                "title": "share-my-one-line-python-solution",
                "content": "nums.sort(key= lambda x: 1 if x == 0 else 0)",
                "solutionTags": [
                    "Python"
                ],
                "code": "nums.sort(key= lambda x: 1 if x == 0 else 0)",
                "codeTag": "Unknown"
            },
            {
                "id": 1496643,
                "title": "java-tc-o-n-sc-o-1-one-pass-with-minimum-number-of-write-operations",
                "content": "```java\\n/**\\n * Find Non Zero element to swap. Keep index of Leftmost Zero.\\n *\\n * Total number of write operations = Number of Non-Zero elements that need to\\n *                                    be moved\\n *\\n * Time Complexity: O(N)\\n *\\n * Space Complexity: O(1)\\n *\\n * N = Length of input array.\\n */\\nclass Solution {\\n    public void moveZeroes(int[] nums) {\\n        if (nums == null) {\\n            throw new IllegalArgumentException(\"Input array is null\");\\n        }\\n        if (nums.length <= 1) {\\n            return;\\n        }\\n\\n        int insertPos = 0;\\n        for (int i = 0; i < nums.length; i++) {\\n            if (nums[i] != 0) {\\n                if (insertPos != i) {\\n                    nums[insertPos] = nums[i];\\n                    nums[i] = 0;\\n                }\\n                insertPos++;\\n            }\\n        }\\n    }\\n}\\n\\n```",
                "solutionTags": [
                    "Java",
                    "Array"
                ],
                "code": "```java\\n/**\\n * Find Non Zero element to swap. Keep index of Leftmost Zero.\\n *\\n * Total number of write operations = Number of Non-Zero elements that need to\\n *                                    be moved\\n *\\n * Time Complexity: O(N)\\n *\\n * Space Complexity: O(1)\\n *\\n * N = Length of input array.\\n */\\nclass Solution {\\n    public void moveZeroes(int[] nums) {\\n        if (nums == null) {\\n            throw new IllegalArgumentException(\"Input array is null\");\\n        }\\n        if (nums.length <= 1) {\\n            return;\\n        }\\n\\n        int insertPos = 0;\\n        for (int i = 0; i < nums.length; i++) {\\n            if (nums[i] != 0) {\\n                if (insertPos != i) {\\n                    nums[insertPos] = nums[i];\\n                    nums[i] = 0;\\n                }\\n                insertPos++;\\n            }\\n        }\\n    }\\n}\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3882065,
                "title": "simple-c-solution",
                "content": "# Using Extra Space\\n```\\nclass Solution {\\npublic:\\n    void moveZeroes(vector<int>& nums) {\\n        vector<int> temp(nums.size(),0);\\n        int k=0;\\n        for(int i=0;i<nums.size();i++){\\n            if(nums[i]!=0){\\n                temp[k++]=nums[i];\\n            }\\n        }\\n        nums=temp;\\n    }\\n};\\n```\\n# In-Place\\n```\\nclass Solution {\\npublic:\\n    void moveZeroes(vector<int>& nums) {\\n        int k=0;\\n        for(int i=0;i<nums.size();i++){\\n            if(nums[i]!=0){\\n                nums[k++]=nums[i];\\n            }\\n        }\\n        for(int i=k;i<nums.size();i++){\\n            nums[i]=0;\\n        }\\n```\\n# In-Place using Two Pointers\\n```\\nclass Solution {\\npublic:\\n    void moveZeroes(vector<int>& nums) {\\n        int i=0,j=0;\\n        while(i<nums.size() && j<nums.size()){\\n            if(nums[j]!=0){\\n                swap(nums[i++],nums[j++]);\\n            }\\n            else{\\n                j++;\\n            }\\n        }\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Two Pointers"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    void moveZeroes(vector<int>& nums) {\\n        vector<int> temp(nums.size(),0);\\n        int k=0;\\n        for(int i=0;i<nums.size();i++){\\n            if(nums[i]!=0){\\n                temp[k++]=nums[i];\\n            }\\n        }\\n        nums=temp;\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    void moveZeroes(vector<int>& nums) {\\n        int k=0;\\n        for(int i=0;i<nums.size();i++){\\n            if(nums[i]!=0){\\n                nums[k++]=nums[i];\\n            }\\n        }\\n        for(int i=k;i<nums.size();i++){\\n            nums[i]=0;\\n        }\\n```\n```\\nclass Solution {\\npublic:\\n    void moveZeroes(vector<int>& nums) {\\n        int i=0,j=0;\\n        while(i<nums.size() && j<nums.size()){\\n            if(nums[j]!=0){\\n                swap(nums[i++],nums[j++]);\\n            }\\n            else{\\n                j++;\\n            }\\n        }\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 72070,
                "title": "simple-javascript-solution",
                "content": "The idea is remove each 0 and add 0 at the end of array, so I use reverse iterate to do it!\\n\\n    var moveZeroes = function(nums) {       \\n        for(var i = nums.length;i--;){\\n            if(nums[i]===0){\\n                nums.splice(i,1)\\n                nums.push(0);\\n            }\\n        }\\n    };",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "The idea is remove each 0 and add 0 at the end of array, so I use reverse iterate to do it!\\n\\n    var moveZeroes = function(nums) {       \\n        for(var i = nums.length;i--;){\\n            if(nums[i]===0){\\n                nums.splice(i,1)\\n                nums.push(0);\\n            }\\n        }\\n    };",
                "codeTag": "Unknown"
            },
            {
                "id": 1126849,
                "title": "swift-move-zeroes",
                "content": "**Accepted solution + tests from the problem** \\uD83D\\uDE09\\n\\n```swift\\nclass Solution {\\n    func moveZeroes(_ nums: inout [Int]) {\\n        var i = 0, zero = 0\\n        while i < nums.count - zero {\\n            if nums[i] == 0 {\\n                zero += 1\\n                nums.append(0)\\n                nums.remove(at: i)\\n            } else {\\n                i += 1\\n            }\\n        }\\n    }\\n}\\n\\nfunc tests() {\\n    let s = Solution()\\n    var example1 = [0,1,0,3,12]\\n    s.moveZeroes(&example1)\\n    assert(example1 == [1,3,12,0,0]) // good\\n    \\n    var example2 = [0]\\n    s.moveZeroes(&example2)\\n    assert(example2 == [0]) // good\\n}\\n\\ntests()\\n```",
                "solutionTags": [
                    "Swift"
                ],
                "code": "```swift\\nclass Solution {\\n    func moveZeroes(_ nums: inout [Int]) {\\n        var i = 0, zero = 0\\n        while i < nums.count - zero {\\n            if nums[i] == 0 {\\n                zero += 1\\n                nums.append(0)\\n                nums.remove(at: i)\\n            } else {\\n                i += 1\\n            }\\n        }\\n    }\\n}\\n\\nfunc tests() {\\n    let s = Solution()\\n    var example1 = [0,1,0,3,12]\\n    s.moveZeroes(&example1)\\n    assert(example1 == [1,3,12,0,0]) // good\\n    \\n    var example2 = [0]\\n    s.moveZeroes(&example2)\\n    assert(example2 == [0]) // good\\n}\\n\\ntests()\\n```",
                "codeTag": "Java"
            },
            {
                "id": 549079,
                "title": "javascript-swap-array-elements",
                "content": "Find non zero numbers and count it.\\nThe count is index of non zero numbers.\\n\\n```\\nvar moveZeroes = function(nums) {\\n  let j = 0  // nonzero count\\n\\n  for (let i = 0; i < nums.length; i++) {\\n    if (nums[i] !== 0) {\\n\\t  // swap elements\\n      [nums[j], nums[i]] = [nums[i], nums[j]]\\n      j++\\n    }\\n  }\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\nvar moveZeroes = function(nums) {\\n  let j = 0  // nonzero count\\n\\n  for (let i = 0; i < nums.length; i++) {\\n    if (nums[i] !== 0) {\\n\\t  // swap elements\\n      [nums[j], nums[i]] = [nums[i], nums[j]]\\n      j++\\n    }\\n  }\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 258825,
                "title": "c-python-straight-forward-clean-concise",
                "content": "**Python**\\n```python\\nclass Solution:\\n    def moveZeroes(self, nums: List[int]) -> None:\\n        k = 0\\n        for i in range(len(nums)):\\n            if nums[i] != 0:\\n                nums[k] = nums[i]\\n                k += 1\\n                \\n        while k < len(nums):\\n            nums[k] = 0\\n            k += 1\\n```\\n\\n**C++**\\n```\\nclass Solution {\\npublic:\\n    void moveZeroes(vector<int>& nums) {\\n        int k = 0;\\n        int n = nums.size();\\n        \\n        for (int i = 0; i < n; i++)\\n            if (nums[i] != 0)\\n                nums[k++] = nums[i];\\n        \\n        for (int i = k; i < n; i++)\\n            nums[i] = 0;\\n    }\\n};\\n```\\n**Complexity**\\n- Time: `O(N)`\\n- Space: `O(1)`",
                "solutionTags": [
                    "C++"
                ],
                "code": "```python\\nclass Solution:\\n    def moveZeroes(self, nums: List[int]) -> None:\\n        k = 0\\n        for i in range(len(nums)):\\n            if nums[i] != 0:\\n                nums[k] = nums[i]\\n                k += 1\\n                \\n        while k < len(nums):\\n            nums[k] = 0\\n            k += 1\\n```\n```\\nclass Solution {\\npublic:\\n    void moveZeroes(vector<int>& nums) {\\n        int k = 0;\\n        int n = nums.size();\\n        \\n        for (int i = 0; i < n; i++)\\n            if (nums[i] != 0)\\n                nums[k++] = nums[i];\\n        \\n        for (int i = k; i < n; i++)\\n            nums[i] = 0;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2460373,
                "title": "c-100-two-pointer-single-loop-o-n-solution",
                "content": "***Please upvote if you like it!!!***\\n\\n**Approach:- (Use two pointer and swap approach)**\\n1. Take to integer i and j set both as \\'0\\'.\\n2. Take a loop iterate until i and j is less than length of given string.\\n\\t * if nums[j] is equal to 0,then swap(nums[i],nums[j]) and increment i & j by1.\\n\\t * else just increment j++.\\n\\n**~Time Complexity: O(N).**\\n**~Space Complexity: O(1).**\\n\\n**Code:-**\\n\\n```\\nclass Solution {\\npublic:\\n    void moveZeroes(vector<int>& nums) {\\n        int i=0,j=0;\\n        while(i<nums.size() && j<nums.size()){\\n            if(nums[j]!=0 ){\\n                swap(nums[i],nums[j]);\\n                i++;\\n                j++;\\n            }else j++;\\n        }  \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Two Pointers"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    void moveZeroes(vector<int>& nums) {\\n        int i=0,j=0;\\n        while(i<nums.size() && j<nums.size()){\\n            if(nums[j]!=0 ){\\n                swap(nums[i],nums[j]);\\n                i++;\\n                j++;\\n            }else j++;\\n        }  \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 72419,
                "title": "java-short-and-swappy-1ms",
                "content": "\\t\\n\\t\\n\\t\\n\\tpublic class Solution {    \\n\\t    \\n\\t    public void moveZeroes(int[] nums) {\\n\\t        int z = -1;\\n\\t        for (int i=0; i< nums.length; i++) {\\n\\t            int temp = nums[i];\\n\\t            if (temp != 0) {\\n\\t                nums[i]=nums[++z];\\n\\t                nums[z]=temp;\\n\\t            }\\n\\t        }\\n\\t    }\\n\\t\\n\\t}",
                "solutionTags": [],
                "code": "class Solution {    \\n\\t    \\n\\t    public void moveZeroes(int[] nums) {\\n\\t        int z = -1;\\n\\t        for (int i=0; i< nums.length; i++) {\\n\\t            int temp = nums[i];\\n\\t            if (temp != 0) {\\n\\t                nums[i]=nums[++z];\\n\\t                nums[z]=temp;\\n\\t            }",
                "codeTag": "Java"
            },
            {
                "id": 3649978,
                "title": "two-pointer-approach-tc-o-n-sc-o-1-c",
                "content": "\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n     O(n)\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n     O(1)\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    void moveZeroes(vector<int>& nums) {\\n        if(nums.size()==1) return;\\n        int l=0, r=0;\\n        while(r<nums.size()){\\n            if(nums[r]!=0){\\n                swap(nums[l],nums[r]);\\n                l++;\\n                \\n            }\\n            r++;\\n        }\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Array",
                    "Two Pointers"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    void moveZeroes(vector<int>& nums) {\\n        if(nums.size()==1) return;\\n        int l=0, r=0;\\n        while(r<nums.size()){\\n            if(nums[r]!=0){\\n                swap(nums[l],nums[r]);\\n                l++;\\n                \\n            }\\n            r++;\\n        }\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3400970,
                "title": "pointers-technique-python",
                "content": "# Intuition\\nHere is my solution to this problem that uses two pointers technique.\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:O(N)\\n Our fast pointer does not visit the same spot twice.\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:O(1)\\n    All operations are made in-place\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n\\nIf you like my solution, I will really appreciate your upvoting. It will help other python-developers to find it faster. And as always, I wish you an enjoyable time on LeetCode.\\n# Code\\n```\\nclass Solution:\\n    def moveZeroes(self, nums: list) -> None:\\n        slow = 0\\n        for fast in range(len(nums)):\\n            if nums[fast] != 0 and nums[slow] == 0:\\n                nums[slow], nums[fast] = nums[fast], nums[slow]\\n\\n            # wait while we find a non-zero element to\\n            # swap with you\\n            if nums[slow] != 0:\\n                slow += 1\\n```",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Two Pointers",
                    "Line Sweep"
                ],
                "code": "```\\nclass Solution:\\n    def moveZeroes(self, nums: list) -> None:\\n        slow = 0\\n        for fast in range(len(nums)):\\n            if nums[fast] != 0 and nums[slow] == 0:\\n                nums[slow], nums[fast] = nums[fast], nums[slow]\\n\\n            # wait while we find a non-zero element to\\n            # swap with you\\n            if nums[slow] != 0:\\n                slow += 1\\n```",
                "codeTag": "Java"
            },
            {
                "id": 72418,
                "title": "java-o-n-solution",
                "content": "public void moveZeroes(int[] nums) {\\n    int count = 0 , size = nums.length;\\n        \\n    for (int i = 0; i< size; i++) {\\n        if ( nums[i] == 0) { count ++;}\\n         if ( nums[i] != 0) { nums[i - count] = nums[i];}\\n    }\\n    for (int i = 0; i < count; i++ ) {\\n        nums[size - count  + i] = 0;\\n    }\\n}",
                "solutionTags": [
                    "Java"
                ],
                "code": "public void moveZeroes(int[] nums) {\\n    int count = 0 , size = nums.length;\\n        \\n    for (int i = 0; i< size; i++) {\\n        if ( nums[i] == 0) { count ++;}\\n         if ( nums[i] != 0) { nums[i - count] = nums[i];}\\n    }\\n    for (int i = 0; i < count; i++ ) {\\n        nums[size - count  + i] = 0;\\n    }\\n}",
                "codeTag": "Unknown"
            },
            {
                "id": 1748937,
                "title": "python-simple-and-clean-python-solution-by-two-approach",
                "content": "# 1. Approach 1 By Removing and Appending at Last\\n# If It is Useful To Understand Please UpVote Me \\uD83D\\uDD3C\\uD83D\\uDE4F\\uD83D\\uDE4F\\n\\tclass Solution:\\n\\t\\tdef moveZeroes(self, nums: List[int]) -> None:\\n\\t\\t\\t\"\"\"\\n\\t\\t\\tDo not return anything, modify nums in-place instead.\\n\\t\\t\\t\"\"\"\\n\\n\\t\\t\\tfor i in nums:\\n\\t\\t\\t\\tif i==0:\\n\\t\\t\\t\\t\\tnums.remove(i)\\n\\t\\t\\t\\t\\tnums.append(0)\\n\\n# 2. Approach 2 By Two Pointers Approach\\n# If It is Useful To Understand Please UpVote Me \\uD83D\\uDD3C\\uD83D\\uDE4F\\uD83D\\uDE4F\\uD83D\\uDE4F\\uD83D\\uDE4F\\n\\tclass Solution:\\n\\t\\tdef moveZeroes(self, nums: List[int]) -> None:\\n\\n\\t\\t\\tp,q=0,0\\n\\t\\t\\twhile q<len(nums):\\n\\t\\t\\t\\tif nums[q]==0:\\n\\t\\t\\t\\t\\tq=q+1\\n\\t\\t\\t\\telse:\\n\\t\\t\\t\\t\\tnums[p],nums[q]=nums[q],nums[p]\\n\\t\\t\\t\\t\\tp=p+1\\n\\t\\t\\t\\t\\tq=q+1\\n\\n\\t\\t\\treturn nums\\n\\n\\n\\n",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Two Pointers"
                ],
                "code": "# 1. Approach 1 By Removing and Appending at Last\\n# If It is Useful To Understand Please UpVote Me \\uD83D\\uDD3C\\uD83D\\uDE4F\\uD83D\\uDE4F\\n\\tclass Solution:\\n\\t\\tdef moveZeroes(self, nums: List[int]) -> None:\\n\\t\\t\\t\"\"\"\\n\\t\\t\\tDo not return anything, modify nums in-place instead.\\n\\t\\t\\t\"\"\"\\n\\n\\t\\t\\tfor i in nums:\\n\\t\\t\\t\\tif i==0:\\n\\t\\t\\t\\t\\tnums.remove(i)\\n\\t\\t\\t\\t\\tnums.append(0)\\n\\n# 2. Approach 2 By Two Pointers Approach\\n# If It is Useful To Understand Please UpVote Me \\uD83D\\uDD3C\\uD83D\\uDE4F\\uD83D\\uDE4F\\uD83D\\uDE4F\\uD83D\\uDE4F\\n\\tclass Solution:\\n\\t\\tdef moveZeroes(self, nums: List[int]) -> None:\\n\\n\\t\\t\\tp,q=0,0\\n\\t\\t\\twhile q<len(nums):\\n\\t\\t\\t\\tif nums[q]==0:\\n\\t\\t\\t\\t\\tq=q+1\\n\\t\\t\\t\\telse:\\n\\t\\t\\t\\t\\tnums[p],nums[q]=nums[q],nums[p]\\n\\t\\t\\t\\t\\tp=p+1\\n\\t\\t\\t\\t\\tq=q+1\\n\\n\\t\\t\\treturn nums\\n\\n\\n\\n",
                "codeTag": "Java"
            },
            {
                "id": 1040848,
                "title": "python-3-detailed-explanation-that-is-easy-to-grasp",
                "content": "This question definitely sits high on my hate list.\\n\\n**Idea**:\\nStart with two pointers (```l``` and ```r```) both at index zero.\\nThe left poiner (```l```) will look for places where we have a zero. The right pointer (```r```) will look for numbers that can substitute that zero.\\nAfter that, in the main loop, we need to consider all cases.\\nIf we found the zero spot (```nums[l] == 0```), we make a decision:\\nif ```nums[r]``` is a non-zero number, we have everything for a swap. Make this swap and move both pointers forward. If ```nums[r]``` is a zero, it\\'s not good, keep looking by moving ```r```.\\n Finally we have a case when ```nums[l] != 0```. Then we need to leave this cell by moving ```l``` and move ```r``` in order to keep the process going.\\n \\n```\\ndef moveZeroes(nums):\\n    l, r = 0, 0\\n    while r < len(nums):\\n        if nums[l] == 0:\\n            if nums[r] != 0:\\n                nums[l], nums[r] = nums[r], nums[l]\\n                l += 1\\n                r += 1\\n            else:\\n                r += 1\\n        else:\\n            l += 1\\n            r += 1\\n```",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Two Pointers"
                ],
                "code": "```l```\n```r```\n```l```\n```r```\n```nums[l] == 0```\n```nums[r]```\n```nums[r]```\n```r```\n```nums[l] != 0```\n```l```\n```r```\n```\\ndef moveZeroes(nums):\\n    l, r = 0, 0\\n    while r < len(nums):\\n        if nums[l] == 0:\\n            if nums[r] != 0:\\n                nums[l], nums[r] = nums[r], nums[l]\\n                l += 1\\n                r += 1\\n            else:\\n                r += 1\\n        else:\\n            l += 1\\n            r += 1\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 72099,
                "title": "very-simple-python-solutions",
                "content": "\\nSolution 1: traverse and swap last 0 and last non 0\\n\\n    class Solution(object):\\n        def moveZeroes(self, nums):\\n            \"\"\"\\n            :type nums: List[int]\\n            :rtype: void Do not return anything, modify nums in-place instead.\\n            \"\"\"\\n            last0 = 0\\n            for i in range(0,len(nums)):\\n                if (nums[i]!=0):\\n                    nums[i],nums[last0] = nums[last0],nums[i]\\n                    last0+=1\\n        \\nSolution 2 : one-liner from @toontong:  use sort() with customized compare function\\n            \\n    class Solution(object):\\n        def moveZeroes(self, nums):\\n            \"\"\"\\n            :type nums: List[int]\\n            :rtype: void Do not return anything, modify nums in-place instead.\\n            \"\"\"\\n            nums.sort(cmp=lambda a,b: 0 if b else -1)",
                "solutionTags": [
                    "Python"
                ],
                "code": "\\nSolution 1: traverse and swap last 0 and last non 0\\n\\n    class Solution(object):\\n        def moveZeroes(self, nums):\\n            \"\"\"\\n            :type nums: List[int]\\n            :rtype: void Do not return anything, modify nums in-place instead.\\n            \"\"\"\\n            last0 = 0\\n            for i in range(0,len(nums)):\\n                if (nums[i]!=0):\\n                    nums[i],nums[last0] = nums[last0],nums[i]\\n                    last0+=1\\n        \\nSolution 2 : one-liner from @toontong:  use sort() with customized compare function\\n            \\n    class Solution(object):\\n        def moveZeroes(self, nums):\\n            \"\"\"\\n            :type nums: List[int]\\n            :rtype: void Do not return anything, modify nums in-place instead.\\n            \"\"\"\\n            nums.sort(cmp=lambda a,b: 0 if b else -1)",
                "codeTag": "Java"
            },
            {
                "id": 72149,
                "title": "java-solution-of-move-zeroes",
                "content": "public class Solution {\\n\\n    public void moveZeroes(int[] nums) {\\n\\n        if(nums == null || nums.length == 0){\\n            return;\\n        }\\n        \\n        int j = 0;\\n        for(int i = 0; i < nums.length; i++){\\n            if(nums[i] != 0){\\n                nums[j] = nums[i];\\n                j++;\\n            }\\n        }\\n        \\n        for(int m = j; m < nums.length; m++){\\n            nums[m] = 0;\\n        }\\n        \\n        return;\\n    } \\n}",
                "solutionTags": [],
                "code": "class Solution {\\n\\n    public void moveZeroes(int[] nums) {\\n\\n        if(nums == null || nums.length == 0){\\n            return;\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 812522,
                "title": "javascript-solution-283",
                "content": "```\\n/**\\n * @param {number[]} nums\\n * @return {void} Do not return anything, modify nums in-place instead.\\n */\\nlet moveZeroes = function(nums) {\\n        for(let i= nums.length-1; i>=0; i--){\\n            if(nums[i]===0){\\n                nums.push(0) \\n                nums.splice(i,1)\\n            }\\n        }\\n        return nums\\n    };\\n```\\n**Runtime: 80 ms, faster than 80.00% of JavaScript online submissions for Move Zeroes.**\\n\\n**Memory Usage: 38.6 MB, less than 24.75% of JavaScript online submissions for Move Zeroes.**\\n\\n**Feedback Appreciated**",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {number[]} nums\\n * @return {void} Do not return anything, modify nums in-place instead.\\n */\\nlet moveZeroes = function(nums) {\\n        for(let i= nums.length-1; i>=0; i--){\\n            if(nums[i]===0){\\n                nums.push(0) \\n                nums.splice(i,1)\\n            }\\n        }\\n        return nums\\n    };\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3190560,
                "title": "python-clean-simple-o-n-solution-with-no-extra-space",
                "content": "\\n\\n# Complexity\\n- Time complexity: $$O(n)$$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: $$O(1)$$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def moveZeroes(self, nums: List[int]) -> None:\\n        \"\"\"\\n        Do not return anything, modify nums in-place instead.\\n        \"\"\"\\n        k = 0\\n        for i in nums:\\n            if i != 0:\\n                nums[k] = i\\n                k+=1\\n\\n        for i in range(k,len(nums)):\\n            nums[i] = 0\\n\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def moveZeroes(self, nums: List[int]) -> None:\\n        \"\"\"\\n        Do not return anything, modify nums in-place instead.\\n        \"\"\"\\n        k = 0\\n        for i in nums:\\n            if i != 0:\\n                nums[k] = i\\n                k+=1\\n\\n        for i in range(k,len(nums)):\\n            nums[i] = 0\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2872504,
                "title": "easiest-faang-method-ever",
                "content": "\\n\\n# \\uD83D\\uDDEF\\uFE0FApproach :-\\nSimilar to Dutch National Flag Algorithm\\uD83D\\uDCA1\\n<!-- Describe your approach to solving the problem. -->\\n\\n# \\uD83D\\uDDEF\\uFE0FComplexity :-\\n- Time complexity: O(n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# \\uD83D\\uDDEF\\uFE0FCode :-\\n```\\nclass Solution {\\npublic:\\n    void moveZeroes(vector<int>& nums) {\\n        int i,j;\\n        for(i=0,j=0;i<nums.size();){\\n            if(nums[i]==0) i++;\\n            else{\\n                swap(nums[i],nums[j]);\\n                i++;\\n                j++;\\n            }\\n        }  \\n    }\\n};\\n//Similar to Dutch National Flag Algo \\n```",
                "solutionTags": [
                    "C++",
                    "Java",
                    "Python3",
                    "Array",
                    "Two Pointers"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    void moveZeroes(vector<int>& nums) {\\n        int i,j;\\n        for(i=0,j=0;i<nums.size();){\\n            if(nums[i]==0) i++;\\n            else{\\n                swap(nums[i],nums[j]);\\n                i++;\\n                j++;\\n            }\\n        }  \\n    }\\n};\\n//Similar to Dutch National Flag Algo \\n```",
                "codeTag": "Java"
            },
            {
                "id": 2189498,
                "title": "javascript-simple-solution-o-n-2",
                "content": "```\\nvar moveZeroes = function(nums) {\\n    let size = nums.length;\\n     for (let i = 0; i < size; i++) {\\n         if (nums[i] === 0) {\\n             nums.splice(i, 1);\\n             nums.push(0);\\n             i--;\\n             size--;\\n         }\\n     }\\n    return nums;\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\nvar moveZeroes = function(nums) {\\n    let size = nums.length;\\n     for (let i = 0; i < size; i++) {\\n         if (nums[i] === 0) {\\n             nums.splice(i, 1);\\n             nums.push(0);\\n             i--;\\n             size--;\\n         }\\n     }\\n    return nums;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 404010,
                "title": "python-easy-solution",
                "content": "\\tclass Solution(object):\\n\\t\\tdef moveZeroes(self, nums):\\n\\t\\t\\ti=0\\n\\t\\t\\tn = len(nums)\\n\\t\\t\\twhile i <n:\\n\\t\\t\\t\\tif nums[i]==0:\\n\\t\\t\\t\\t\\tnums.pop(i)\\n\\t\\t\\t\\t\\tnums.append(0)\\n\\t\\t\\t\\t\\tn-=1\\n\\t\\t\\t\\telse:\\n\\t\\t\\t\\t\\ti+=1\\n",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "\\tclass Solution(object):\\n\\t\\tdef moveZeroes(self, nums):\\n\\t\\t\\ti=0\\n\\t\\t\\tn = len(nums)\\n\\t\\t\\twhile i <n:\\n\\t\\t\\t\\tif nums[i]==0:\\n\\t\\t\\t\\t\\tnums.pop(i)\\n\\t\\t\\t\\t\\tnums.append(0)\\n\\t\\t\\t\\t\\tn-=1\\n\\t\\t\\t\\telse:\\n\\t\\t\\t\\t\\ti+=1\\n",
                "codeTag": "Java"
            },
            {
                "id": 72467,
                "title": "c-1-line-or-3-lines-clean-code",
                "content": "    void moveZeroes(vector<int>& nums) {\\n      for (int i = 0, j = 0; i < nums.size(); i++) if(nums[i] != 0) swap(nums[i], nums[j++]);\\n    }\\n\\n     void moveZeroes(vector<int>& nums) {\\n        for (int i = 0, j = 0; i < nums.size(); i++)  {\\n            if (nums[i] != 0) swap(nums[i], nums[j++]);\\n        }\\n    }",
                "solutionTags": [],
                "code": "    void moveZeroes(vector<int>& nums) {\\n      for (int i = 0, j = 0; i < nums.size(); i++) if(nums[i] != 0) swap(nums[i], nums[j++]);\\n    }\\n\\n     void moveZeroes(vector<int>& nums) {\\n        for (int i = 0, j = 0; i < nums.size(); i++)  {\\n            if (nums[i] != 0) swap(nums[i], nums[j++]);\\n        }\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 3031230,
                "title": "1ms-easy-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nStep 1: Iterates the Array if element in the array is non-zero then store it into nums[j].\\nStep 2:Use a while loop & fill remaining elements by zero.\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public void moveZeroes(int[] nums) {\\n        int j = 0;\\n        for(int i=0;i<nums.length;i++){\\n            if(nums[i] != 0){\\n                nums[j] = nums[i];\\n                j++;\\n            }\\n        }\\n        while(j < nums.length){\\n            nums[j] = 0;\\n            j++;\\n        }            \\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public void moveZeroes(int[] nums) {\\n        int j = 0;\\n        for(int i=0;i<nums.length;i++){\\n            if(nums[i] != 0){\\n                nums[j] = nums[i];\\n                j++;\\n            }\\n        }\\n        while(j < nums.length){\\n            nums[j] = 0;\\n            j++;\\n        }            \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 72064,
                "title": "8ms-simple-c-solution",
                "content": "    void moveZeroes(int* nums, int numsSize) {\\n        int totalZeros = 0;\\n        \\n        for(int i = 0; i < numsSize; i++) {\\n            if(nums[i] == 0) {\\n                totalZeros++;\\n            }\\n            else {\\n                nums[i - totalZeros] = nums[i];\\n            }\\n        }\\n        \\n        for(int i = (numsSize - totalZeros); i < numsSize; i++) {\\n            nums[i] = 0;\\n        }\\n    }",
                "solutionTags": [],
                "code": "    void moveZeroes(int* nums, int numsSize) {\\n        int totalZeros = 0;\\n        \\n        for(int i = 0; i < numsSize; i++) {\\n            if(nums[i] == 0) {\\n                totalZeros++;\\n            }\\n            else {\\n                nums[i - totalZeros] = nums[i];\\n            }\\n        }\\n        \\n        for(int i = (numsSize - totalZeros); i < numsSize; i++) {\\n            nums[i] = 0;\\n        }\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 3950089,
                "title": "python3-beats-99-optimized-in-place-rearrangement",
                "content": "# Solution no. 01\\n\\n---\\n\\n\\n# Intuition\\nWhen approaching this problem, the idea is to perform an in-place modification of the given list of numbers. We can achieve this by first iterating through the list and moving all non-zero elements to the beginning of the list. Once we have moved all non-zero elements, we can fill the remaining positions with zeros. This approach ensures that the original order of non-zero elements is preserved while zeros are pushed to the end of the list.\\n\\n# Approach\\n1. Initialize a variable index to keep track of the position where the next non-zero element should be placed.\\n1. Iterate through each element num in the nums list.\\n   - If num is not equal to zero, assign num to the position index in the nums list and increment index.\\n1. After the iteration, all non-zero elements have been placed at the beginning of the list, and index indicates the position where the first zero should be placed.\\n1. Iterate from index to the end of the list, assigning zero to each position to fill the remaining positions with zeros.\\n\\nBy following this approach, we ensure that all non-zero elements are moved to the start of the list while maintaining their original order, and the remaining positions are filled with zeros.\\n\\n# Complexity\\n- Time complexity:\\n    - The first pass through the list takes O(n) time to move non-zero elements to the start of the list.\\n    - The second pass through the list takes O(n) time to fill the remaining positions with zeros.\\n    - The overall time complexity is dominated by the linear passes through the list, resulting in **O(n)** time complexity.\\n\\n- Space complexity:\\n    - The algorithm only uses a constant amount of extra space, regardless of the input size. Hence Space complexity of this code is **O(1)**\\n    - It modifies the input list in-place without requiring additional data structures.\\n\\n# Code\\n```\\nclass Solution:\\n    def moveZeroes(self, nums: List[int]) -> None:\\n        index = 0\\n\\n        # Place non-zero elements at the start of the list\\n        for num in nums:\\n            if num != 0:\\n                nums[index] = num\\n                index += 1\\n\\n        # Fill the remaining positions with zeroes\\n        while index < len(nums):\\n            nums[index] = 0\\n            index += 1\\n```\\n\\n---\\n\\n\\n\\n# Solution no. 02\\n\\n---\\n\\n# Intuition\\nInstead of directly filling the positions with zero after placing non-zero elements, we can maintain a pointer to indicate the position where the next non-zero element should be placed. This way, we only perform assignments when necessary, reducing the total number of assignments.\\n\\n# Approach\\n1. Initialize a variable index to 0, which represents the position where the next non-zero element should be placed.\\n1. Iterate through each element num in the nums list.\\n1. If num is not equal to zero, swap nums[index] and nums[i], and increment index.\\n1. After the iteration, all non-zero elements have been moved to their correct positions, and all positions after index are filled with zeros.\\n1. By swapping non-zero elements with the position index, we achieve the desired result without needing a separate loop to fill remaining positions with zeros.\\n\\nComplexity\\n- Time complexity: \\n    - **O(n)**\\n    - The single pass through the list takes O(n) time.\\n    - The number of assignments is minimized, which improves the constant factors involved in the time complexity.\\n\\n- Space complexity: \\n    - **O(1)**\\n    - The algorithm only uses a constant amount of extra space for variables.\\n    - It modifies the input list in-place without requiring additional data structures.\\n    \\nWhile this alternative approach doesn\\'t change the big-O time and space complexities, it might result in slightly better performance due to the reduced number of assignments.\\n\\n```\\nclass Solution:\\n    def moveZeroes(self, nums: List[int]) -> None:\\n        index = 0  \\n       \\n        for i in range(len(nums)):\\n            if nums[i] != 0:\\n                # If the current element is non-zero, swap it with the element at index\\n                # This effectively moves non-zero elements to the beginning of the list\\n                nums[i], nums[index] = nums[index], nums[i]\\n                index += 1 \\n                \\n```\\n\\n\\n",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Array",
                    "Two Pointers"
                ],
                "code": "```\\nclass Solution:\\n    def moveZeroes(self, nums: List[int]) -> None:\\n        index = 0\\n\\n        # Place non-zero elements at the start of the list\\n        for num in nums:\\n            if num != 0:\\n                nums[index] = num\\n                index += 1\\n\\n        # Fill the remaining positions with zeroes\\n        while index < len(nums):\\n            nums[index] = 0\\n            index += 1\\n```\n```\\nclass Solution:\\n    def moveZeroes(self, nums: List[int]) -> None:\\n        index = 0  \\n       \\n        for i in range(len(nums)):\\n            if nums[i] != 0:\\n                # If the current element is non-zero, swap it with the element at index\\n                # This effectively moves non-zero elements to the beginning of the list\\n                nums[i], nums[index] = nums[index], nums[i]\\n                index += 1 \\n                \\n```",
                "codeTag": "Java"
            },
            {
                "id": 1581373,
                "title": "javascript-o-n-91",
                "content": "let index = 0;\\n    const length = nums.length;\\n\\n    for (let i = 0; i < length; i++) {\\n        if (nums[i] !== 0) {\\n            nums[index] = nums[i];\\n            index++;\\n        }\\n    }\\n\\n    for (let i = index; i < length; i++) {\\n        nums[i] = 0;\\n    }\\n\\n    return nums;",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "let index = 0;\\n    const length = nums.length;\\n\\n    for (let i = 0; i < length; i++) {\\n        if (nums[i] !== 0) {\\n            nums[index] = nums[i];\\n            index++;\\n        }\\n    }\\n\\n    for (let i = index; i < length; i++) {\\n        nums[i] = 0;\\n    }\\n\\n    return nums;",
                "codeTag": "Unknown"
            },
            {
                "id": 1554462,
                "title": "0-ms-very-easy-c",
                "content": "```\\n\\n```class Solution {\\npublic:\\n    void moveZeroes(vector<int>& nums) {\\n        int left=0,right=0,temp;\\n        while(right<nums.size())\\n        {\\n            if(nums[right]==0)\\n                ++right;\\n            else\\n            {\\n                temp=nums[left];\\n                nums[left]=nums[right];\\n                nums[right]=temp;\\n                ++left;\\n                ++right;\\n            }\\n        }       \\n    }\\n};",
                "solutionTags": [
                    "C",
                    "Two Pointers"
                ],
                "code": "```\\n\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1019699,
                "title": "c-easy-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    void moveZeroes(vector<int>& nums) {\\n        int size = nums.size();\\n        \\n        int a=0;\\n        \\n        for(int i=0; i<size; i++) {\\n            if(nums[i]!=0) {\\n                swap(nums[i], nums[a]);\\n                a++;\\n            }\\n        }\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    void moveZeroes(vector<int>& nums) {\\n        int size = nums.size();\\n        \\n        int a=0;\\n        \\n        for(int i=0; i<size; i++) {\\n            if(nums[i]!=0) {\\n                swap(nums[i], nums[a]);\\n                a++;\\n            }\\n        }\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1001971,
                "title": "python-easy-solution-o-n-time-o-1-space",
                "content": "```\\nclass Solution(object):\\n    def moveZeroes(self, nums):\\n        c=0\\n        for i in range(len(nums)):\\n            if nums[i]!=0:\\n                nums[c],nums[i]=nums[i],nums[c]\\n                c+=1\\n        return nums\\n```",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nclass Solution(object):\\n    def moveZeroes(self, nums):\\n        c=0\\n        for i in range(len(nums)):\\n            if nums[i]!=0:\\n                nums[c],nums[i]=nums[i],nums[c]\\n                c+=1\\n        return nums\\n```",
                "codeTag": "Java"
            },
            {
                "id": 724397,
                "title": "idiomatic-go-solution",
                "content": "```\\nfunc moveZeroes(nums []int)  {\\n    nonZeroIndex := 0\\n    for i := 0; i < len(nums); i++ {\\n        if nums[i] != 0 {\\n            nums[i], nums[nonZeroIndex] = nums[nonZeroIndex], nums[i]\\n            nonZeroIndex++\\n        }\\n    }\\n}\\n```",
                "solutionTags": [
                    "Go"
                ],
                "code": "```\\nfunc moveZeroes(nums []int)  {\\n    nonZeroIndex := 0\\n    for i := 0; i < len(nums); i++ {\\n        if nums[i] != 0 {\\n            nums[i], nums[nonZeroIndex] = nums[nonZeroIndex], nums[i]\\n            nonZeroIndex++\\n        }\\n    }\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 72323,
                "title": "a-o-n-java-solution",
                "content": "public void moveZeroes(int[] nums) {\\n\\n        int count=0;\\n        for (int i = 0; i < nums.length; i++) {\\n\\t\\t\\tif(nums[i]==0)\\n\\t\\t\\t\\tcount++;\\n\\t\\t\\tif(count!=0&&nums[i]!=0){\\n\\t\\t\\t\\tnums[i-count]=nums[i];\\n\\t\\t\\t\\tnums[i]=0;\\n\\t\\t\\t}\\n\\t\\t}\\n}",
                "solutionTags": [
                    "Java"
                ],
                "code": "public void moveZeroes(int[] nums) {\\n\\n        int count=0;\\n        for (int i = 0; i < nums.length; i++) {\\n\\t\\t\\tif(nums[i]==0)\\n\\t\\t\\t\\tcount++;\\n\\t\\t\\tif(count!=0&&nums[i]!=0){\\n\\t\\t\\t\\tnums[i-count]=nums[i];\\n\\t\\t\\t\\tnums[i]=0;\\n\\t\\t\\t}\\n\\t\\t}\\n}",
                "codeTag": "Unknown"
            },
            {
                "id": 2733623,
                "title": "there-are-6-approaches-best-time-and-space-complexity",
                "content": "# There are six approaches.\\n**if you have any doubt please comment below.**\\n\\n\\n```Approach 1:```\\n\\ncode:\\n```\\nclass Solution {\\npublic:\\n    void moveZeroes(vector<int>& nums) {\\n                \\n        int index = 0; \\n        for (int i=0;i<nums.size();i++){\\n\\t\\t\\tif (nums[i]==0) index++; \\n\\t\\t\\telse if (index > 0) {\\n\\t\\t\\t\\tint temp = nums[i];\\n\\t\\t\\t\\tnums[i]=0;\\n                nums[i-index]=temp;\\n\\t\\t\\t}\\n        }\\n    }\\n};\\n```\\n\\n\\n```Approach 2:```\\n\\ncode:\\n```\\nclass Solution {\\npublic:\\n    void moveZeroes(vector<int>& nums) { \\n\\t\\n         int j = 0;\\n        \\n         for (int i = 0; i < nums.size(); i++) {\\n             if (nums[i] != 0) {\\n                 nums[j++] = nums[i];\\n             }\\n         }\\n         while (j < nums.size()) {\\n             nums[j] = 0;\\n             j++;\\n         }\\n        \\n    }\\n};\\n```\\n\\n```Approach 3:```\\n\\ncode:\\n```\\nclass Solution {\\npublic:\\n    void moveZeroes(vector<int>& nums) {\\n        \\n         int left = 0, right = 1;\\n\\t\\t \\n         while(right<nums.size() && left<right)\\n         {\\n             if(nums[left] == 0 && nums[right] != 0)\\n             {\\n                 int temp = nums[left];\\n                 nums[left++] = nums[right];\\n                 nums[right++] = temp;\\n                \\n             }\\n             else if(nums[left] == 0 && nums[right] == 0){\\n                 right++;\\n             }else if(nums[left] != 0 ){\\n                 left++;\\n                 right++;\\n             }else{\\n                 left++;\\n             }\\n         }\\n    }\\n};\\n```\\n\\n# Now using predefined function :\\n\\n```Approach 4:```\\n\\n\\n--> swap()\\n\\ncode:\\n\\n\\n```\\nclass Solution {\\npublic:\\n    void moveZeroes(vector<int>& nums) {\\n        \\n\\t\\tfor(int i=0,next=0;i<nums.size();++i){\\n\\t\\t\\tif(nums[i] != 0) {\\n\\t\\t\\t\\tswap(nums[i],nums[next++]);\\n\\t\\t\\t}\\n\\t\\t}\\t\\n    }\\n};\\n```\\n# Using STL (only for c++):\\n```Approach 5:```\\n\\ncode:\\n```\\nclass Solution {\\npublic:\\n    void moveZeroes(vector<int>& nums) {\\n\\t\\n        stable_partition(begin(nums),end(nums),[](int i){return i;});\\n    }\\n};\\n```\\n\\n```Approach 6:```\\n\\ncode:\\n```\\n\\nclass Solution {\\npublic:\\n    void moveZeroes(vector<int>& nums) {\\n      \\n        stable_partition(rbegin(nums),rend(nums),logical_not<int>());\\n    }\\n};\\n```\\n\\nHope it will help you\\uD83D\\uDE4C. \\nThank you",
                "solutionTags": [
                    "C"
                ],
                "code": "```Approach 1:```\n```\\nclass Solution {\\npublic:\\n    void moveZeroes(vector<int>& nums) {\\n                \\n        int index = 0; \\n        for (int i=0;i<nums.size();i++){\\n\\t\\t\\tif (nums[i]==0) index++; \\n\\t\\t\\telse if (index > 0) {\\n\\t\\t\\t\\tint temp = nums[i];\\n\\t\\t\\t\\tnums[i]=0;\\n                nums[i-index]=temp;\\n\\t\\t\\t}\\n        }\\n    }\\n};\\n```\n```Approach 2:```\n```\\nclass Solution {\\npublic:\\n    void moveZeroes(vector<int>& nums) { \\n\\t\\n         int j = 0;\\n        \\n         for (int i = 0; i < nums.size(); i++) {\\n             if (nums[i] != 0) {\\n                 nums[j++] = nums[i];\\n             }\\n         }\\n         while (j < nums.size()) {\\n             nums[j] = 0;\\n             j++;\\n         }\\n        \\n    }\\n};\\n```\n```Approach 3:```\n```\\nclass Solution {\\npublic:\\n    void moveZeroes(vector<int>& nums) {\\n        \\n         int left = 0, right = 1;\\n\\t\\t \\n         while(right<nums.size() && left<right)\\n         {\\n             if(nums[left] == 0 && nums[right] != 0)\\n             {\\n                 int temp = nums[left];\\n                 nums[left++] = nums[right];\\n                 nums[right++] = temp;\\n                \\n             }\\n             else if(nums[left] == 0 && nums[right] == 0){\\n                 right++;\\n             }else if(nums[left] != 0 ){\\n                 left++;\\n                 right++;\\n             }else{\\n                 left++;\\n             }\\n         }\\n    }\\n};\\n```\n```Approach 4:```\n```\\nclass Solution {\\npublic:\\n    void moveZeroes(vector<int>& nums) {\\n        \\n\\t\\tfor(int i=0,next=0;i<nums.size();++i){\\n\\t\\t\\tif(nums[i] != 0) {\\n\\t\\t\\t\\tswap(nums[i],nums[next++]);\\n\\t\\t\\t}\\n\\t\\t}\\t\\n    }\\n};\\n```\n```Approach 5:```\n```\\nclass Solution {\\npublic:\\n    void moveZeroes(vector<int>& nums) {\\n\\t\\n        stable_partition(begin(nums),end(nums),[](int i){return i;});\\n    }\\n};\\n```\n```Approach 6:```\n```\\n\\nclass Solution {\\npublic:\\n    void moveZeroes(vector<int>& nums) {\\n      \\n        stable_partition(rbegin(nums),rend(nums),logical_not<int>());\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1617399,
                "title": "javascript-typescript-really-clean-and-easy-two-pointer-solution",
                "content": "I\\'ve seen a lot of solutions that use splice, which imo is not in the spirit of the excercise and would probably get you in hot water if used during an interview.\\n\\nHere\\'s a really neat two pointer solution:\\n\\n```ts\\nfunction moveZeroes(nums: number[]): void {\\n  let writePointer = 0;\\n  for (let readPointer = 0; readPointer < nums.length; readPointer ++) {\\n    const val = nums[readPointer];\\n    nums[readPointer] = 0;\\n    if (val!==0) {\\n      nums[writePointer] = val;\\n      writePointer ++;\\n    }\\n  }\\n};\\n```\\n\\nExpanation:\\n\\nWe use two pointers, one to track the current value being read in the array, the other to track the position we can write in.\\n\\nIf we have an array without any zeroes, then the write pointer and read pointer will stay in keeping the whole time.\\n\\nHowever, if we do encounter a zero when reading using the read pointer, we simply do not increment the write pointer.\\n\\nThis means the next write of a non zero will lag behind the read pointer, overwriting the zero we found.\\n\\nFor simplicities sake, and to ensure trailing zeroes are maintained properly, we always assign 0 to the index we just read from. \\n\\nIt may be filled in at a later date with a non zero value if one exists. If not it will remain zero, along with all subsequent indexes, satisfying the excercises\\' criteria.",
                "solutionTags": [
                    "JavaScript",
                    "TypeScript",
                    "Two Pointers"
                ],
                "code": "```ts\\nfunction moveZeroes(nums: number[]): void {\\n  let writePointer = 0;\\n  for (let readPointer = 0; readPointer < nums.length; readPointer ++) {\\n    const val = nums[readPointer];\\n    nums[readPointer] = 0;\\n    if (val!==0) {\\n      nums[writePointer] = val;\\n      writePointer ++;\\n    }\\n  }\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 443317,
                "title": "c-faster-than-98-solutions",
                "content": "```\\n public void MoveZeroes(int[] nums) {\\n        int j = 0;\\n        \\n        for(int i = 0 ; i < nums.Length; i++)\\n            if(nums[i] != 0)\\n                nums[j++] = nums[i];\\n        \\n        while(j < nums.Length)\\n            nums[j++] = 0;\\n        \\n    }\\n```",
                "solutionTags": [],
                "code": "```\\n public void MoveZeroes(int[] nums) {\\n        int j = 0;\\n        \\n        for(int i = 0 ; i < nums.Length; i++)\\n            if(nums[i] != 0)\\n                nums[j++] = nums[i];\\n        \\n        while(j < nums.Length)\\n            nums[j++] = 0;\\n        \\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1662215,
                "title": "multiple-approach-in-c-2pointer-queue-with-easy-explanations",
                "content": "> **If you\\u2019re interested in coding you can join my Discord Server, link in the comment section. Also if you find any mistake please let me know. Thank you!\\u2764\\uFE0F**\\n> \\n\\n---\\n\\n## Explanation:\\n\\n### Solution 01\\n\\n- We are going to use the 2pointers approach.\\n- Take 2 variables i & j.\\n- At any point, if i\\u22600, then it will swap with j & j will be only moved after the swap().\\n- If any point i & j both indicates 0 then only i will move and j will keep track of 0.\\n- **Time complexity:** O(n).\\n\\n### Solution 02\\n\\n- Here I\\u2019ll use a queue to keep track of the indexes of 0.\\n- If the current index has 0, we\\u2019ll push the index***(i)*** to queue.\\n- If the current element is not 0 & the queue have element, then we\\u2019ll take the front element of the queue (mainly the index of the first 0).\\n- Put the current non 0 element to that index & place 0 to the current index. Push the current index to queue because it has 0 now! *[simply we swap the current element with the first index available in the queue & push current index as that have 0 now]*.\\n- Remove the first element using pop(), because queue remove element from front.\\n- **Time complexity:** O(n).\\n\\n---\\n\\n## Code:\\n\\n```cpp\\n//Solution 01:\\nclass Solution {\\npublic:\\n    void moveZeroes(vector<int>& nums) {\\n        int n= nums.size();\\n        int i=0, j=0;\\n        \\n        while(i<n){\\n            if(nums[i]!=0){\\n                swap(nums[i], nums[j]);\\n                i++; j++;\\n            }\\n            else \\n                i++;\\n        }\\n    }\\n};\\n\\n//Solution 02:\\nclass Solution {\\npublic:\\n    void moveZeroes(vector<int>& nums) {\\n        int n= nums.size();\\n        queue<int> add;\\n        for(int i=0; i<n; i++){\\n            if(nums[i]==0)\\n                add.push(i);\\n            else{\\n                if(!add.empty()){\\n                    int x=add.front();\\n                    nums[x]=nums[i];\\n                    nums[i]=0;\\n                    add.push(i);\\n                    add.pop();\\n                }\\n            }\\n        }\\n    }\\n};\\n```\\n\\n---\\n\\n> **Please upvote this solution**\\n>",
                "solutionTags": [
                    "C++",
                    "C",
                    "Two Pointers",
                    "Queue"
                ],
                "code": "```cpp\\n//Solution 01:\\nclass Solution {\\npublic:\\n    void moveZeroes(vector<int>& nums) {\\n        int n= nums.size();\\n        int i=0, j=0;\\n        \\n        while(i<n){\\n            if(nums[i]!=0){\\n                swap(nums[i], nums[j]);\\n                i++; j++;\\n            }\\n            else \\n                i++;\\n        }\\n    }\\n};\\n\\n//Solution 02:\\nclass Solution {\\npublic:\\n    void moveZeroes(vector<int>& nums) {\\n        int n= nums.size();\\n        queue<int> add;\\n        for(int i=0; i<n; i++){\\n            if(nums[i]==0)\\n                add.push(i);\\n            else{\\n                if(!add.empty()){\\n                    int x=add.front();\\n                    nums[x]=nums[i];\\n                    nums[i]=0;\\n                    add.push(i);\\n                    add.pop();\\n                }\\n            }\\n        }\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1505408,
                "title": "simple-o-n-solution-w-minimum-swaps-python",
                "content": "Simple solution with slow & fast pointers, that only starts swapping once the 1st zero is found.\\nAlthough using only the second loop starting from 0 with left = 0 will work, the first loop prevents redundant swaps for inputs like [1, 3, 1, 5, 2, 5, 1, 6, 0, 1, 0, 0, 0, 0], \\n\\nTime: O(n)\\nSpace: O(1)\\n\\n```\\nclass Solution(object):\\n    def moveZeroes(self, nums):\\n        \\n\\t\\t# Set slow pointer to the 1st zero.\\n        for left in range(len(nums)):\\n            if nums[left] == 0:\\n                break\\n        \\n\\t\\t# Swap elements at fast & slow if fast points to a non-zero number (and increment).\\n        for right in range(left + 1, len(nums)):\\n            if nums[right] != 0:\\n                nums[left], nums[right] = nums[right], nums[left]\\n                left += 1\\n\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution(object):\\n    def moveZeroes(self, nums):\\n        \\n\\t\\t# Set slow pointer to the 1st zero.\\n        for left in range(len(nums)):\\n            if nums[left] == 0:\\n                break\\n        \\n\\t\\t# Swap elements at fast & slow if fast points to a non-zero number (and increment).\\n        for right in range(left + 1, len(nums)):\\n            if nums[right] != 0:\\n                nums[left], nums[right] = nums[right], nums[left]\\n                left += 1\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 382795,
                "title": "python-24-ms-faster-than-99-59-of-python-online-submissions-for-move-zeroes",
                "content": "```\\ndef moveZeroes(self, nums):\\n        \"\"\"\\n        :type nums: List[int]\\n        :rtype: None Do not return anything, modify nums in-place instead.\\n        \"\"\"\\n        n = len(nums)\\n\\n        non_zero = 0\\n        \\n        for i in range(n):\\n            if nums[i] != 0:\\n                nums[non_zero],nums[i] = nums[i],nums[non_zero]\\n                non_zero +=1\\n```\\n",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\ndef moveZeroes(self, nums):\\n        \"\"\"\\n        :type nums: List[int]\\n        :rtype: None Do not return anything, modify nums in-place instead.\\n        \"\"\"\\n        n = len(nums)\\n\\n        non_zero = 0\\n        \\n        for i in range(n):\\n            if nums[i] != 0:\\n                nums[non_zero],nums[i] = nums[i],nums[non_zero]\\n                non_zero +=1\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 2940146,
                "title": "beats-98-easy-javascrtipt-o-n-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * @param {number[]} nums\\n * @return {void} Do not return anything, modify nums in-place instead.\\n */\\nvar moveZeroes = function (nums) {\\n\\n    let j = 0\\n    let i = 1\\n    while (i < nums.length) {\\n        if (nums[j] === 0 && nums[i] !== 0) {\\n            nums[j] = nums[i]\\n            nums[i] = 0\\n            j++\\n        }\\n        if (nums[j] !== 0) {\\n            j++\\n        }\\n        i++\\n    }\\n};\\n```",
                "solutionTags": [
                    "JavaScript",
                    "Array",
                    "Two Pointers"
                ],
                "code": "```\\n/**\\n * @param {number[]} nums\\n * @return {void} Do not return anything, modify nums in-place instead.\\n */\\nvar moveZeroes = function (nums) {\\n\\n    let j = 0\\n    let i = 1\\n    while (i < nums.length) {\\n        if (nums[j] === 0 && nums[i] !== 0) {\\n            nums[j] = nums[i]\\n            nums[i] = 0\\n            j++\\n        }\\n        if (nums[j] !== 0) {\\n            j++\\n        }\\n        i++\\n    }\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1373967,
                "title": "0ms-rust-solution",
                "content": "Runtime: 0 ms\\nMemory Usage: 2.2 MB\\n\\n## Using [.retain()](https://doc.rust-lang.org/std/vec/struct.Vec.html#method.retain)\\n## \\n```\\nimpl Solution {\\n    pub fn move_zeroes(nums: &mut Vec<i32>) {\\n        let mut z = Vec::new();\\n        nums.retain(|x| {\\n         if *x != 0 { true } else { z.push(0); false }\\n        });\\n        &nums.append(&mut z);\\n    }\\n}\\n```\\n## Two lines version using [.drain_filter()](https://github.com/rust-lang/rust/issues/43244) \\n##\\nThere\\'s an unstable nightly feature called **drain_filter** that does exactly what you want:\\n```\\n#![feature(drain_filter)]\\n\\nimpl Solution {\\n    pub fn move_zeroes(nums: &mut Vec<i32>) {\\n         let mut zeroes = nums.drain_filter(|x| *x == 0).collect::<Vec<_>>();\\n         &nums.append(&mut zeroes);\\n    }\\n}\\n```",
                "solutionTags": [
                    "Rust"
                ],
                "code": "```\\nimpl Solution {\\n    pub fn move_zeroes(nums: &mut Vec<i32>) {\\n        let mut z = Vec::new();\\n        nums.retain(|x| {\\n         if *x != 0 { true } else { z.push(0); false }\\n        });\\n        &nums.append(&mut z);\\n    }\\n}\\n```\n```\\n#![feature(drain_filter)]\\n\\nimpl Solution {\\n    pub fn move_zeroes(nums: &mut Vec<i32>) {\\n         let mut zeroes = nums.drain_filter(|x| *x == 0).collect::<Vec<_>>();\\n         &nums.append(&mut zeroes);\\n    }\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 72290,
                "title": "simple-java-solution",
                "content": "        int zeroCount = 0;\\n        for(int i = 0 ; i< nums.length; i++) {\\n            if (nums[i] == 0) {\\n                zeroCount++;\\n            } else if (zeroCount > 0 ){\\n                nums[i-zeroCount] = nums[i];\\n                nums[i] = 0;\\n            }\\n        }",
                "solutionTags": [],
                "code": "        int zeroCount = 0;\\n        for(int i = 0 ; i< nums.length; i++) {\\n            if (nums[i] == 0) {\\n                zeroCount++;\\n            } else if (zeroCount > 0 ){\\n                nums[i-zeroCount] = nums[i];\\n                nums[i] = 0;\\n            }\\n        }",
                "codeTag": "Unknown"
            },
            {
                "id": 72339,
                "title": "java-concise-in-place-solution",
                "content": "        \\n    public void moveZeroes(int[] nums) {\\n        int zero = 0, l = 0, r = nums.length;\\n        while (l < r) {\\n            if (nums[l] != 0) {\\n                int tmp = nums[zero];\\n                nums[zero++] = nums[l];\\n                nums[l] = tmp;\\n            }\\n            l++;\\n        }\\n    }",
                "solutionTags": [
                    "Java"
                ],
                "code": "        \\n    public void moveZeroes(int[] nums) {\\n        int zero = 0, l = 0, r = nums.length;\\n        while (l < r) {\\n            if (nums[l] != 0) {\\n                int tmp = nums[zero];\\n                nums[zero++] = nums[l];\\n                nums[l] = tmp;\\n            }\\n            l++;\\n        }\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 72342,
                "title": "java-easy-and-simple-solutions",
                "content": "    public class Solution {\\n    public void moveZeroes(int[] nums) {\\n        int movings=0;\\n        for(int i=0;i<nums.length;i++){\\n            if(nums[i]==0) {\\n                movings++;\\n                continue;\\n            }\\n            \\n            int temp=nums[i-movings];\\n            nums[i-movings]=nums[i];\\n            nums[i]=temp;\\n         }\\n    }\\n}",
                "solutionTags": [],
                "code": "class Solution {\\n    public void moveZeroes(int[] nums) {\\n        int movings=0;\\n        for(int i=0;i<nums.length;i++){\\n            if(nums[i]==0) {\\n                movings++;\\n                continue;\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 3236411,
                "title": "283-space-96-33-solution-with-step-by-step-explanation",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n- We initialize a pointer i to the beginning of the array. This pointer keeps track of where the next non-zero element should be placed.\\n- We loop through the array using another pointer j.\\n- If we encounter a non-zero element, we swap it with the element at the current position of i, effectively moving the non-zero element to the left of any zeroes encountered so far.\\n- We then increment the i pointer to move it to the next position, ready for the next non-zero element.\\n- Since we are modifying the input array in-place, we do not need to return anything.\\n\\n# Complexity\\n- Time complexity:\\n87.10%\\n\\n- Space complexity:\\n96.33%\\n\\n# Code\\n```\\nclass Solution:\\n    def moveZeroes(self, nums: List[int]) -> None:\\n        \"\"\"\\n        Do not return anything, modify nums in-place instead.\\n        \"\"\"\\n        # Initialize pointer to the beginning of the array\\n        i = 0\\n        # Loop through the array\\n        for j in range(len(nums)):\\n            # If the current element is non-zero\\n            if nums[j] != 0:\\n                # Swap it with the element at the current pointer\\n                nums[i], nums[j] = nums[j], nums[i]\\n                # Increment the pointer\\n                i += 1\\n\\n```",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Array",
                    "Two Pointers"
                ],
                "code": "```\\nclass Solution:\\n    def moveZeroes(self, nums: List[int]) -> None:\\n        \"\"\"\\n        Do not return anything, modify nums in-place instead.\\n        \"\"\"\\n        # Initialize pointer to the beginning of the array\\n        i = 0\\n        # Loop through the array\\n        for j in range(len(nums)):\\n            # If the current element is non-zero\\n            if nums[j] != 0:\\n                # Swap it with the element at the current pointer\\n                nums[i], nums[j] = nums[j], nums[i]\\n                # Increment the pointer\\n                i += 1\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2090354,
                "title": "c-easy-2-line-approach",
                "content": "```\\nclass Solution {\\npublic:\\n    void moveZeroes(vector<int>& nums) {\\n        int count=0;\\n        for(int i=0;i<nums.size();i++){\\n            if(nums[i]!=0){\\n                swap(nums[i],nums[count++]);\\n            }\\n        }\\n    }\\n};\\n```\\n\\n**please upvote if helpful**",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    void moveZeroes(vector<int>& nums) {\\n        int count=0;\\n        for(int i=0;i<nums.size();i++){\\n            if(nums[i]!=0){\\n                swap(nums[i],nums[count++]);\\n            }\\n        }\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1598708,
                "title": "concise-simple-4-line-java-solution-o-n-beats-100-clear-explanation",
                "content": "Basically, we are shiftng all the non-zero values to the front of the array ```nums```, & then insert ```0s``` in all the leftover indexes.\\n### For example, let\\'s take an array ```[0,6,9,2,0,5]```.\\n1.  The first ```for``` loop will traverse the whole array and pick all the non-zero elements(```6,9,2,5```) and shift them to the front of the array, maintaining the relative order. We have used the variable ```shifter``` to follow the above process.\\n\\n2.  Sub-result after this traversal : ```[0,6,9,2,0,5]``` **\\u2192** ```[6,9,2,5,0,5]```.\\n**Note:** *We are still having the value ```5``` at the last index because we have just copied the values, not replaced them.*\\n\\n3. Now, we need to insert ```0s``` in the indexes which are not yet traversed to get the final answer. Here, also ```shifter``` will help us as it\\'s value is equal to the required index to start putting ```0s```.\\n\\n4. Final answer :  ```[0,6,9,2,0,5]``` **\\u2192**  ```[6,9,2,5,0,5]``` **\\u2192**  ```[6,9,2,5,0,0]```.\\n\\n``` \\npublic void moveZeroes(int[] nums) {\\n        int shifter= 0;\\n        for(int i=0;i<nums.length;i++){\\n            if(nums[i]!= 0) nums[shifter++] = nums[i];\\n        }\\n        while(shifter<nums.length) nums[shifter++] =0;\\n    }\\n```\\n\\n*Do upvote, if it helps you* \\uD83D\\uDE00.\\n\\n",
                "solutionTags": [
                    "Java"
                ],
                "code": "```nums```\n```0s```\n```[0,6,9,2,0,5]```\n```for```\n```6,9,2,5```\n```shifter```\n```[0,6,9,2,0,5]```\n```[6,9,2,5,0,5]```\n```5```\n```0s```\n```shifter```\n```0s```\n```[0,6,9,2,0,5]```\n```[6,9,2,5,0,5]```\n```[6,9,2,5,0,0]```\n``` \\npublic void moveZeroes(int[] nums) {\\n        int shifter= 0;\\n        for(int i=0;i<nums.length;i++){\\n            if(nums[i]!= 0) nums[shifter++] = nums[i];\\n        }\\n        while(shifter<nums.length) nums[shifter++] =0;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 72292,
                "title": "move-zeros-solution-in-java",
                "content": "    public void moveZeroes(int[] nums) {\\n    \\tint i = -1, j = 0;\\n    \\twhile (j < nums.length) {\\n    \\t\\tif (nums[j] != 0) {\\n    \\t\\t\\tswap(++i, j, nums);\\n    \\t\\t}\\n    \\t\\tj++;\\n    \\t}\\n    }\\n    \\n    public void swap(int i, int j, int[] nums) {\\n    \\tint temp = nums[i];\\n    \\tnums[i] = nums[j];\\n    \\tnums[j] = temp;\\n    }",
                "solutionTags": [],
                "code": "    public void moveZeroes(int[] nums) {\\n    \\tint i = -1, j = 0;\\n    \\twhile (j < nums.length) {\\n    \\t\\tif (nums[j] != 0) {\\n    \\t\\t\\tswap(++i, j, nums);\\n    \\t\\t}\\n    \\t\\tj++;\\n    \\t}\\n    }\\n    \\n    public void swap(int i, int j, int[] nums) {\\n    \\tint temp = nums[i];\\n    \\tnums[i] = nums[j];\\n    \\tnums[j] = temp;\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 4030707,
                "title": "unusual-laconic-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nSort in python is stable, so order of equal elements will be not changed\\nhttps://wiki.python.org/moin/HowTo/Sorting#Sort_Stability_and_Complex_Sorts\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nJust sort them pretending that are only 2 types of values!\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n$$O(n*logn)$$\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n$$O(1)$$\\n# Code\\n```\\nclass Solution:\\n    def moveZeroes(self, nums: List[int]) -> None:\\n        \"\"\"\\n        Do not return anything, modify nums in-place instead.\\n        \"\"\"\\n        nums.sort(key=lambda x: x == 0)\\n        return nums\\n```",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Array",
                    "Sort",
                    "Sorting"
                ],
                "code": "```\\nclass Solution:\\n    def moveZeroes(self, nums: List[int]) -> None:\\n        \"\"\"\\n        Do not return anything, modify nums in-place instead.\\n        \"\"\"\\n        nums.sort(key=lambda x: x == 0)\\n        return nums\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2398347,
                "title": "java-simple-0ms-100-faster-two-pointer",
                "content": "```\\nclass Solution {\\n    public void moveZeroes(int[] nums) {\\n        int n = nums.length;\\n        int i = 0;\\n        for(int j = 0 ; j < n ; j++){\\n            if(nums[j] != 0) {\\n                nums[i] = nums[j];\\n                i++;\\n            }\\n        }\\n        for(int k = i ; k < n ; k++){\\n            nums[k] = 0;\\n        }\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Two Pointers"
                ],
                "code": "```\\nclass Solution {\\n    public void moveZeroes(int[] nums) {\\n        int n = nums.length;\\n        int i = 0;\\n        for(int j = 0 ; j < n ; j++){\\n            if(nums[j] != 0) {\\n                nums[i] = nums[j];\\n                i++;\\n            }\\n        }\\n        for(int k = i ; k < n ; k++){\\n            nums[k] = 0;\\n        }\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1756058,
                "title": "python-two-pointers-with-intuitive-explaination",
                "content": "```\\nclass Solution:\\n    def moveZeroes(self, nums: List[int]) -> None:\\n        \"\"\"\\n        Do not return anything, modify nums in-place instead.\\n        \"\"\"\\n        # Idea: have a slow pointer pointing at the beginning and only move with condition.\\n        # Condition: when iterating nums, if we encounter a nonzero, swap places with the slow and increase slow by 1.\\n        slow = 0\\n        for i in range(len(nums)):\\n            if nums[i]!=0:\\n                nums[i], nums[slow] = nums[slow], nums[i]\\n                slow+=1\\n```",
                "solutionTags": [
                    "Python",
                    "Two Pointers"
                ],
                "code": "```\\nclass Solution:\\n    def moveZeroes(self, nums: List[int]) -> None:\\n        \"\"\"\\n        Do not return anything, modify nums in-place instead.\\n        \"\"\"\\n        # Idea: have a slow pointer pointing at the beginning and only move with condition.\\n        # Condition: when iterating nums, if we encounter a nonzero, swap places with the slow and increase slow by 1.\\n        slow = 0\\n        for i in range(len(nums)):\\n            if nums[i]!=0:\\n                nums[i], nums[slow] = nums[slow], nums[i]\\n                slow+=1\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1631442,
                "title": "two-pointer-python-solution",
                "content": "Algorithm:\\n* keep slow pointer on 0 (zero) until fast pointer meet non-zero, i.e. fast pointer move while slow pointer remain on the same value\\n* swap evalues\\n* increment both slow and fast pointers\\n\\nIllustration:\\n\\n```\\n[0,1,0,3,12] -> [1,0,0,3,12] -> [1,0,0,3,12] -> [1, 3, 0, 0, 12] -> [1, 3, 0, 0, 12]  -> [1, 3, 12, 0, 0]\\n | |               | |             |   |               |  |                |      |                 |  | \\n s f               s f             s   f               s  f                s      f                 s  f \\n```\\n         \\nCode:\\n          \\n```\\nslow = 0\\nfast = 1\\nlength = len(nums) - 1\\n        \\nwhile slow <= length and fast <= length:\\n\\tif nums[slow] == 0 and nums[fast] != 0:\\n\\t\\tnums[slow] = nums[fast]\\n        nums[fast] = 0\\n            \\n    if nums[slow] != 0:\\n\\t\\tslow += 1\\n\\n    fast += 1\\n        \\nreturn nums\\n```\\n\\nTime complexity: O(n)\\nSpace complexity: O(1)\\n\\nIf you like, thumps up.",
                "solutionTags": [
                    "Python",
                    "Two Pointers"
                ],
                "code": "```\\n[0,1,0,3,12] -> [1,0,0,3,12] -> [1,0,0,3,12] -> [1, 3, 0, 0, 12] -> [1, 3, 0, 0, 12]  -> [1, 3, 12, 0, 0]\\n | |               | |             |   |               |  |                |      |                 |  | \\n s f               s f             s   f               s  f                s      f                 s  f \\n```\n```\\nslow = 0\\nfast = 1\\nlength = len(nums) - 1\\n        \\nwhile slow <= length and fast <= length:\\n\\tif nums[slow] == 0 and nums[fast] != 0:\\n\\t\\tnums[slow] = nums[fast]\\n        nums[fast] = 0\\n            \\n    if nums[slow] != 0:\\n\\t\\tslow += 1\\n\\n    fast += 1\\n        \\nreturn nums\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1431040,
                "title": "3-solutions-in-python",
                "content": "Using 2 pointers:\\n```\\t\\t\\t\\t\\t\\t\\nclass Solution:\\n    def moveZeroes(self, nums):\\n        left=0\\n        right=0\\n        while right<len(nums):\\n            if nums[right]==0:\\n                right+=1\\n            else:\\n                nums[left],nums[right]=nums[right],nums[left] #swap the numbers\\n                left+=1\\n                right+=1\\n```\\n\\n1 Liner:\\n```\\nclass Solution:\\n    def moveZeroes(self, nums):\\n        nums.sort(key=lambda i: i==0) #returns False (0) if not zero and True (1) if zero. Hence zero follows non-zero numbers\\n```\\n\\nUsing append and remove:\\n```\\nclass Solution:\\n    def moveZeroes(self, nums: List[int]) -> None:\\n        for i in range(len(nums)):\\n            if nums[i] == 0:   #check if the number is zero (if yes)\\n                nums.append(0) #add zero to the end of the list\\n                nums.remove(0) #remove the first zero found (from left)\\n```",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\t\\t\\t\\t\\t\\t\\nclass Solution:\\n    def moveZeroes(self, nums):\\n        left=0\\n        right=0\\n        while right<len(nums):\\n            if nums[right]==0:\\n                right+=1\\n            else:\\n                nums[left],nums[right]=nums[right],nums[left] #swap the numbers\\n                left+=1\\n                right+=1\\n```\n```\\nclass Solution:\\n    def moveZeroes(self, nums):\\n        nums.sort(key=lambda i: i==0) #returns False (0) if not zero and True (1) if zero. Hence zero follows non-zero numbers\\n```\n```\\nclass Solution:\\n    def moveZeroes(self, nums: List[int]) -> None:\\n        for i in range(len(nums)):\\n            if nums[i] == 0:   #check if the number is zero (if yes)\\n                nums.append(0) #add zero to the end of the list\\n                nums.remove(0) #remove the first zero found (from left)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1367010,
                "title": "java-4-line-code-with-two-pointer-technique",
                "content": "Two-Pointer Technique\\n\\n```\\npublic void moveZeroes(int[] nums) {\\n\\tfor (int i = 0, j = 0; j < nums.length; j++) {\\n\\t\\tif (nums[j] != 0) {\\n\\t\\t\\tnums[i] = nums[j];\\n\\t\\t\\tif (i++ != j) nums[j] = 0;\\n\\t\\t}\\n\\t}\\n}\\n```\\n\\nWhy we need `if (i != j) nums[j] = 0;` ?\\n\\tWithout this, we just simply move all the non-zero elements to left. We should also set the last few elements to 0.\\n\\tAttention! We cannot just simply set nums[j] to 0 because we might cover the new nums[i] when i==j.\\n\\t\\nPerformance:\\n0ms (faster than 100%)          O(n)\\n38.9MB (less than 94.91%)   O(1)",
                "solutionTags": [
                    "Java",
                    "Two Pointers"
                ],
                "code": "```\\npublic void moveZeroes(int[] nums) {\\n\\tfor (int i = 0, j = 0; j < nums.length; j++) {\\n\\t\\tif (nums[j] != 0) {\\n\\t\\t\\tnums[i] = nums[j];\\n\\t\\t\\tif (i++ != j) nums[j] = 0;\\n\\t\\t}\\n\\t}\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 539283,
                "title": "swift-solution",
                "content": "```swift\\nclass Solution {\\n    func moveZeroes(_ nums: inout [Int]) {\\n        var writeIdx = 0\\n        // Move non-zero items\\n        for num in nums where num != 0 {\\n            nums[writeIdx] = num\\n            writeIdx += 1\\n        }\\n        // Fill the remaining with zero\\n        for i in writeIdx..<nums.count {\\n            nums[i] = 0\\n        }\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```swift\\nclass Solution {\\n    func moveZeroes(_ nums: inout [Int]) {\\n        var writeIdx = 0\\n        // Move non-zero items\\n        for num in nums where num != 0 {\\n            nums[writeIdx] = num\\n            writeIdx += 1\\n        }\\n        // Fill the remaining with zero\\n        for i in writeIdx..<nums.count {\\n            nums[i] = 0\\n        }\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 399600,
                "title": "0-ms-java-solution",
                "content": "\\n\\n```\\nclass Solution {\\n    public void moveZeroes(int[] nums) {\\n        int index = 0;\\n        \\n        for (int i = 0; i < nums.length; i++) {\\n            if (nums[i] != 0) {\\n                nums[index++] = nums[i];\\n            }\\n        }\\n        \\n        for (int i = index; i < nums.length; i++) {\\n            nums[i] = 0;\\n        }\\n        \\n    }\\n}\\n```\\n\\nThis works by setting the left most value to the left most value greater than zero\\nAnd then we write over the values that were already placed to the left with zeros.\\n[1,0,3]\\nindex = 0;\\ni = 0\\nplace value 1 at nums[index]\\n[1,0,3]\\nindex = 1;\\ni = 1\\nvalue at i is 0 so skip\\nindex = 1\\ni = 2\\nplace value of nums[2] at nums[index]\\n[1,3,3]\\nsame thing again\\nnow you see we must write over the last 3 to a 0\\nstart from index and write 0\\'s until the end",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public void moveZeroes(int[] nums) {\\n        int index = 0;\\n        \\n        for (int i = 0; i < nums.length; i++) {\\n            if (nums[i] != 0) {\\n                nums[index++] = nums[i];\\n            }\\n        }\\n        \\n        for (int i = index; i < nums.length; i++) {\\n            nums[i] = 0;\\n        }\\n        \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 202535,
                "title": "python-3-one-liner",
                "content": "```\\ndef moveZeroes(self, nums):\\n\\tnums.sort(key=lambda x: x == 0)\\n```\\t\\t\\nSince values are ordered from False to True, we just simply check whether a value is 0 and ensure true returns. This can all be done with a simple lambda expression in the sort method of a list.",
                "solutionTags": [],
                "code": "```\\ndef moveZeroes(self, nums):\\n\\tnums.sort(key=lambda x: x == 0)\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 144994,
                "title": "c-solution",
                "content": "```\\npublic static void MoveZeros(int[] nums)\\n{\\n\\tif (nums == null || nums.Length <= 1)\\n\\t\\treturn;\\n\\n\\tint curr = 0;\\n\\tint next = 1;\\n\\n\\twhile (next <= nums.Length - 1)\\n\\t{\\n\\t\\tif (nums[curr] == 0)\\n\\t\\t{\\n\\t\\t\\tif (nums[next] == 0)\\n\\t\\t\\t{\\n\\t\\t\\t\\tnext++;\\n\\t\\t\\t\\tcontinue;\\n\\t\\t\\t}\\n\\t\\t\\telse\\n\\t\\t\\t{\\n\\t\\t\\t\\tnums[curr] = nums[next];\\n\\t\\t\\t\\tnums[next] = 0;\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\tcurr++;\\n\\t\\tnext++;\\n\\t}\\n}\\n```",
                "solutionTags": [],
                "code": "```\\npublic static void MoveZeros(int[] nums)\\n{\\n\\tif (nums == null || nums.Length <= 1)\\n\\t\\treturn;\\n\\n\\tint curr = 0;\\n\\tint next = 1;\\n\\n\\twhile (next <= nums.Length - 1)\\n\\t{\\n\\t\\tif (nums[curr] == 0)\\n\\t\\t{\\n\\t\\t\\tif (nums[next] == 0)\\n\\t\\t\\t{\\n\\t\\t\\t\\tnext++;\\n\\t\\t\\t\\tcontinue;\\n\\t\\t\\t}\\n\\t\\t\\telse\\n\\t\\t\\t{\\n\\t\\t\\t\\tnums[curr] = nums[next];\\n\\t\\t\\t\\tnums[next] = 0;\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\tcurr++;\\n\\t\\tnext++;\\n\\t}\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 72372,
                "title": "my-easy-java-solution-in-1ms-with-explanation",
                "content": "public class Solution {\\n    public void moveZeroes(int[] nums) {\\n        \\n        //if only 1 element is present, return\\n        if(nums.length==1)\\n            return;\\n\\n        int i=0;\\n        \\n        //iterate through the array counting number of zeros\\n        for(int k:nums)\\n        {\\n            if(k==0)\\n                i++;\\n        }\\n            \\n        //if no 0's exists or array only contains zeros , return\\n        if(i==0 || i==nums.length)\\n            return;\\n        \\n        //index to keep track of non-zero elements\\n        int m=0;\\n        \\n        //for loop to move all the non zero elements in order\\n        for(int j=0;j<nums.length;j++)\\n        {\\n            if(nums[j]!=0)\\n                nums[m++]=nums[j];\\n        }\\n        \\n        //insert the 0's in remaining spaces up till the end\\n        for(int j=nums.length-i;j<nums.length;j++)\\n        {\\n            nums[j]=0;\\n        }\\n        \\n        \\n        \\n        \\n        \\n    }\\n}",
                "solutionTags": [
                    "Java"
                ],
                "code": "class Solution {\\n    public void moveZeroes(int[] nums) {\\n        \\n        //if only 1 element is present, return\\n        if(nums.length==1)\\n            return;\\n\\n        int i=0;\\n        \\n        //iterate through the array counting number of zeros\\n        for(int k:nums)\\n        {\\n            if(k==0)\\n                i++;\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 72527,
                "title": "simple-in-place-java-solution-o-n-time-complexity",
                "content": "\\n    public void moveZeroes(int[] nums) {\\n        int count = 0;\\n        for (int i = 0; i < nums.length; i++) {\\n            if (nums[i] == 0) {\\n                count++;\\n            } else {\\n                nums[i - count] = nums[i];\\n                if (count != 0) {nums[i] = 0;}\\n            }\\n        }\\n        return;\\n    }",
                "solutionTags": [
                    "Java"
                ],
                "code": "\\n    public void moveZeroes(int[] nums) {\\n        int count = 0;\\n        for (int i = 0; i < nums.length; i++) {\\n            if (nums[i] == 0) {\\n                count++;\\n            } else {\\n                nums[i - count] = nums[i];\\n                if (count != 0) {nums[i] = 0;}\\n            }\\n        }\\n        return;\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 3477126,
                "title": "beats-99-98-simple-no-excessive-checking-writing-of-zeroes-or-content-o-n-o-1",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nCopy and move destination synchronously with source or skip zeroes.\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nFind the first zero-cell. It will be the start for writing.\\n\\nSkip zeros or copy content and move source and destination places synchronously.\\n\\nFill with zeroes to the end.\\n\\n# Complexity\\n- Time complexity: $$O(n)$$\\n- Space complexity: $$O(1)$$\\n- Code complexity: 2 one-purpose vars, 3 cycles, 1 condition\\n\\n# Code\\n```\\nclass Solution {\\n    public void moveZeroes(int[] nums) {\\n        int dst = -1;\\n        while (++dst < nums.length && nums[dst] != 0); // Find first zero\\n        int src = dst;\\n        while (++src < nums.length)\\n            if (nums[src] != 0)           // Skip\\n                nums[dst++] = nums[src];  // or copy content\\n        while (dst < nums.length)\\n            nums[dst++] = 0;              // Fill with zeroes to the end!\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public void moveZeroes(int[] nums) {\\n        int dst = -1;\\n        while (++dst < nums.length && nums[dst] != 0); // Find first zero\\n        int src = dst;\\n        while (++src < nums.length)\\n            if (nums[src] != 0)           // Skip\\n                nums[dst++] = nums[src];  // or copy content\\n        while (dst < nums.length)\\n            nums[dst++] = 0;              // Fill with zeroes to the end!\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3269137,
                "title": "single-loop-space-o-1-time-o-n",
                "content": "# Complexity\\n- Time complexity: $$O(n)$$\\n\\n- Space complexity: $$O(1)$$\\n\\n```\\n/**\\n * @param {number[]} nums\\n * @return {void} Do not return anything, modify nums in-place instead.\\n */\\nvar moveZeroes = function(nums) {\\n    let gap = 0;\\n    for(let i=0; i<nums.length; i++) {\\n        if(nums[i] === 0) {\\n            gap++;\\n        }\\n        else {\\n            [nums[i-gap], nums[i]] = [nums[i], nums[i-gap]]\\n        }\\n    }\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {number[]} nums\\n * @return {void} Do not return anything, modify nums in-place instead.\\n */\\nvar moveZeroes = function(nums) {\\n    let gap = 0;\\n    for(let i=0; i<nums.length; i++) {\\n        if(nums[i] === 0) {\\n            gap++;\\n        }\\n        else {\\n            [nums[i-gap], nums[i]] = [nums[i], nums[i-gap]]\\n        }\\n    }\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3248063,
                "title": "c-solution-beats-more-than-87-runtime-and-more-than-81-memory-easy-for-understanding",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n![image.png](https://assets.leetcode.com/users/images/d3fbbcc6-1088-4ac1-a69b-74bef8cfcac1_1677768639.8539567.png)\\n\\n\\n# Code\\n```\\npublic class Solution {\\n    public void MoveZeroes(int[] nums) {\\n        int lastZeroPos = 0;\\n\\n        for (int i = 0; i < nums.Length; i++)\\n        {\\n            if (nums[i] != 0)\\n            {\\n                (nums[lastZeroPos], nums[i]) = (nums[i], nums[lastZeroPos]);\\n                lastZeroPos++;\\n            }\\n        }\\n    }\\n}\\n```",
                "solutionTags": [
                    "C#",
                    "Two Pointers"
                ],
                "code": "```\\npublic class Solution {\\n    public void MoveZeroes(int[] nums) {\\n        int lastZeroPos = 0;\\n\\n        for (int i = 0; i < nums.Length; i++)\\n        {\\n            if (nums[i] != 0)\\n            {\\n                (nums[lastZeroPos], nums[i]) = (nums[i], nums[lastZeroPos]);\\n                lastZeroPos++;\\n            }\\n        }\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2975092,
                "title": "simple-java-solution-100-faster",
                "content": "\\n\\n# Code\\n```\\nclass Solution {\\n    public void moveZeroes(int[] nums) {\\n        int idx = 0;   \\n        for(int i = 0; i < nums.length; i++) {\\n            if(nums[i] != 0) {\\n                nums[idx] = nums[i];\\n                idx++;\\n            }\\n        }    \\n        while(idx < nums.length) {\\n            nums[idx] = 0;\\n            idx++;\\n        }\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public void moveZeroes(int[] nums) {\\n        int idx = 0;   \\n        for(int i = 0; i < nums.length; i++) {\\n            if(nums[i] != 0) {\\n                nums[idx] = nums[i];\\n                idx++;\\n            }\\n        }    \\n        while(idx < nums.length) {\\n            nums[idx] = 0;\\n            idx++;\\n        }\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2499865,
                "title": "python-easy-solution",
                "content": "Solution 1:\\n```\\ndef moveZeroes(self, nums: List[int]) -> None:\\n        \"\"\"\\n        Do not return anything, modify nums in-place instead.\\n        \"\"\"\\n        nums.sort(key=bool, reverse=True)\\n```\\nSolution 2:\\n```\\ndef moveZeroes(self, nums: List[int]) -> None:\\n        \"\"\"\\n        Do not return anything, modify nums in-place instead.\\n        \"\"\"\\n        i = 0\\n        for index in range(len(nums)):\\n            if nums[index] != 0:\\n                nums[index], nums[i] = nums[i], nums[index]\\n                i += 1\\n```",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\ndef moveZeroes(self, nums: List[int]) -> None:\\n        \"\"\"\\n        Do not return anything, modify nums in-place instead.\\n        \"\"\"\\n        nums.sort(key=bool, reverse=True)\\n```\n```\\ndef moveZeroes(self, nums: List[int]) -> None:\\n        \"\"\"\\n        Do not return anything, modify nums in-place instead.\\n        \"\"\"\\n        i = 0\\n        for index in range(len(nums)):\\n            if nums[index] != 0:\\n                nums[index], nums[i] = nums[i], nums[index]\\n                i += 1\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 2026541,
                "title": "c-and-java-solution-using-hashmap-and-iteration",
                "content": "**Algorithm for C**\\n* Create a separate index starting at 0 and insert non-zero num in nums array. And increment index.\\n* Insert 0 at the remaining spaces left\\n* Time Complexity: O(n) | Space Complexity: O(1)\\n\\n**Code for C**\\n```\\nvoid moveZeroes(int* nums, int numsSize){\\n    int index = 0;\\n    for(int i=0; i<numsSize; i++){\\n        if(nums[i] != 0){\\n            nums[index] = nums[i]; index++;\\n        }\\n    }\\n    for(int i=index; i<numsSize; i++){\\n        nums[i] = 0;\\n    }\\n}\\n```\\n\\n**Algorithm for Java**\\n* Insert non-zero element in HashMap.\\n* Insert all the values of HashMap in nums.\\n* Insert zero at the remaining spaces left.\\n* Time Complexity: O(n) | Space Complexity: O(n)\\n\\n**Code for Java**\\n\\n\\n```\\npublic void moveZeroes(int[] nums) {\\n        Map<Integer, Integer> map = new HashMap();\\n        int index=0;\\n        for(int i=0; i<nums.length; i++){\\n            if(nums[i] != 0) {\\n                map.put(index, nums[i]);\\n                index++;\\n            }\\n        }\\n        int i=0;\\n        for(Map.Entry<Integer, Integer> temp : map.entrySet()){\\n            nums[i] = temp.getValue(); i++;\\n        }\\n        for(int k = i; k<nums.length; k++){\\n            nums[k] = 0;\\n        }\\n    }\\n```\\n\\n**Please upvote if it helped you.**\\n*Feel free to ask any questions/query if any.*",
                "solutionTags": [
                    "Java",
                    "C"
                ],
                "code": "```\\nvoid moveZeroes(int* nums, int numsSize){\\n    int index = 0;\\n    for(int i=0; i<numsSize; i++){\\n        if(nums[i] != 0){\\n            nums[index] = nums[i]; index++;\\n        }\\n    }\\n    for(int i=index; i<numsSize; i++){\\n        nums[i] = 0;\\n    }\\n}\\n```\n```\\npublic void moveZeroes(int[] nums) {\\n        Map<Integer, Integer> map = new HashMap();\\n        int index=0;\\n        for(int i=0; i<nums.length; i++){\\n            if(nums[i] != 0) {\\n                map.put(index, nums[i]);\\n                index++;\\n            }\\n        }\\n        int i=0;\\n        for(Map.Entry<Integer, Integer> temp : map.entrySet()){\\n            nums[i] = temp.getValue(); i++;\\n        }\\n        for(int k = i; k<nums.length; k++){\\n            nums[k] = 0;\\n        }\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1787120,
                "title": "javascript",
                "content": "Runtime: 92 ms, faster than 94.41% of JavaScript online submissions for Move Zeroes.\\nMemory Usage: 47.2 MB, less than 7.35% of JavaScript online submissions for Move Zeroes.\\n```\\nvar moveZeroes = function(nums) {\\n    // O(n) Time Complexity\\n\\t// 2 Pointers\\n    let left = 0;\\n    \\n    for(let i = 0; i < nums.length; i++) {\\n        if(nums[i]!==0) {\\n            [nums[i], nums[left]] = [nums[left], nums[i]];\\n            left++;\\n        }\\n    }\\n\\treturn nums;\\n};",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "Runtime: 92 ms, faster than 94.41% of JavaScript online submissions for Move Zeroes.\\nMemory Usage: 47.2 MB, less than 7.35% of JavaScript online submissions for Move Zeroes.\\n```\\nvar moveZeroes = function(nums) {\\n    // O(n) Time Complexity\\n\\t// 2 Pointers\\n    let left = 0;\\n    \\n    for(let i = 0; i < nums.length; i++) {\\n        if(nums[i]!==0) {\\n            [nums[i], nums[left]] = [nums[left], nums[i]];\\n            left++;\\n        }\\n    }\\n\\treturn nums;\\n};",
                "codeTag": "Unknown"
            },
            {
                "id": 1643920,
                "title": "python-4-lines-of-code-solution",
                "content": "\\n\\tdef moveZeroes(self, nums: List[int]) -> None:\\n\\n        count=nums.count(0)\\n        \\n        for i in range(0,count):\\n            nums.remove(0)\\n            nums.append(0)",
                "solutionTags": [],
                "code": "\\n\\tdef moveZeroes(self, nums: List[int]) -> None:\\n\\n        count=nums.count(0)\\n        \\n        for i in range(0,count):\\n            nums.remove(0)\\n            nums.append(0)",
                "codeTag": "Python3"
            },
            {
                "id": 190320,
                "title": "python-two-pointers",
                "content": "```\\nclass Solution:\\n    def moveZeroes(self, nums):\\n        k = 0\\n        for i in range(len(nums)):\\n            if nums[i] != 0:\\n                nums[k] = nums[i]\\n                k += 1\\n        for i in range(k, len(nums)):\\n            nums[i] = 0\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def moveZeroes(self, nums):\\n        k = 0\\n        for i in range(len(nums)):\\n            if nums[i] != 0:\\n                nums[k] = nums[i]\\n                k += 1\\n        for i in range(k, len(nums)):\\n            nums[i] = 0\\n```",
                "codeTag": "Java"
            },
            {
                "id": 72415,
                "title": "0ms-java-solution",
                "content": "    public void moveZeroes(int[] nums) {\\n            if(nums==null || nums.length==0)\\n                return;\\n            int index=0;\\n            for(int i=0; i<nums.length; i++){\\n                if(nums[i]!=0) nums[index++] = nums[i];\\n            }\\n            \\n            for(int i=index; i<nums.length; i++){\\n                nums[i]=0;\\n            }\\n        }",
                "solutionTags": [],
                "code": "    public void moveZeroes(int[] nums) {\\n            if(nums==null || nums.length==0)\\n                return;\\n            int index=0;\\n            for(int i=0; i<nums.length; i++){\\n                if(nums[i]!=0) nums[index++] = nums[i];\\n            }\\n            \\n            for(int i=index; i<nums.length; i++){\\n                nums[i]=0;\\n            }\\n        }",
                "codeTag": "Unknown"
            },
            {
                "id": 72434,
                "title": "5-lines-o-n-java-solution-with-no-swapping",
                "content": "**Explanation**\\n\\nThe basic idea is to save all none-zero numbers in place in the front part, then fill 0 into the remaining part. No need to swap in this way. Any advice will be welcome!\\n\\n    public void moveZeroes(int[] nums) {\\n        int p = 0;// Index of none-zero number\\n        for (int i : nums) \\n            if (i != 0) \\n              nums[p++] = i;\\n        while (p < nums.length) nums[p++] = 0;\\n    }",
                "solutionTags": [],
                "code": "**Explanation**\\n\\nThe basic idea is to save all none-zero numbers in place in the front part, then fill 0 into the remaining part. No need to swap in this way. Any advice will be welcome!\\n\\n    public void moveZeroes(int[] nums) {\\n        int p = 0;// Index of none-zero number\\n        for (int i : nums) \\n            if (i != 0) \\n              nums[p++] = i;\\n        while (p < nums.length) nums[p++] = 0;\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 72494,
                "title": "python-1liner-using-inplace-sort",
                "content": "    class Solution(object):\\n        def moveZeroes(s, a):\\n            a.sort(key=lambda x: not x or None)",
                "solutionTags": [],
                "code": "    class Solution(object):\\n        def moveZeroes(s, a):\\n            a.sort(key=lambda x: not x or None)",
                "codeTag": "Java"
            },
            {
                "id": 3997353,
                "title": "move-zeroes",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    void moveZeroes(vector<int>& nums) {\\n        int nonZero=0;\\n        for(int j=0;j<nums.size();j++){\\n            if(nums[j]!=0){\\n                swap(nums[j],nums[nonZero]);\\n                nonZero++;\\n            }\\n        }\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    void moveZeroes(vector<int>& nums) {\\n        int nonZero=0;\\n        for(int j=0;j<nums.size();j++){\\n            if(nums[j]!=0){\\n                swap(nums[j],nums[nonZero]);\\n                nonZero++;\\n            }\\n        }\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3478594,
                "title": "easy-java-solution-for-beginners",
                "content": "\\n# Code\\n```\\nclass Solution {\\n    public void moveZeroes(int[] nums) {\\n        int a=0;\\n       \\n\\n        for(int i =0;i<nums.length;i++){\\n           if(nums[i]!=0 ){\\n               nums[a]=nums[i];\\n               a++;\\n           }\\n        }\\n\\n        for(int j =a;j<nums.length;j++){\\n            nums[j]=0;\\n        }\\n        \\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public void moveZeroes(int[] nums) {\\n        int a=0;\\n       \\n\\n        for(int i =0;i<nums.length;i++){\\n           if(nums[i]!=0 ){\\n               nums[a]=nums[i];\\n               a++;\\n           }\\n        }\\n\\n        for(int j =a;j<nums.length;j++){\\n            nums[j]=0;\\n        }\\n        \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3393989,
                "title": "easy-js-solution-using-destructuring",
                "content": "\\n\\n# Code\\n```\\n/**\\n * @param {number[]} nums\\n * @return {void} Do not return anything, modify nums in-place instead.\\n */\\nconst moveZeroes = function(nums) {\\n  let j =0;\\n  for(let i=0; i< nums.length;i++){\\n   if(nums[i] === 0){\\n      j++ ;\\n   } else { \\n     [nums[i-j], nums[i]] = [nums[i], nums[i-j]] \\n   }\\n  }\\n};\\n```",
                "solutionTags": [
                    "JavaScript",
                    "Two Pointers"
                ],
                "code": "```\\n/**\\n * @param {number[]} nums\\n * @return {void} Do not return anything, modify nums in-place instead.\\n */\\nconst moveZeroes = function(nums) {\\n  let j =0;\\n  for(let i=0; i< nums.length;i++){\\n   if(nums[i] === 0){\\n      j++ ;\\n   } else { \\n     [nums[i-j], nums[i]] = [nums[i], nums[i-j]] \\n   }\\n  }\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3378755,
                "title": "snowball-approach-fastest-proper-explanation",
                "content": "\\n# Approach\\nThe approach used in this solution is called the \"snowball approach\", which is a linear time complexity approach with constant space complexity.\\n\\nIn this approach, we use a variable \"snowball\" to keep track of the number of zeros we have encountered so far. We iterate over the vector and increment the snowball variable whenever we encounter a zero. When we encounter a non-zero element, we check if the snowball variable is greater than zero. If it is, we move the non-zero element to its correct position in the vector by swapping it with the element snowball positions before it. We then set the swapped element to zero.\\n\\nBy the end of the iteration, all the non-zero elements are in their correct positions, and all the zeros are at the end of the vector.****\\n\\n# Complexity\\n- Time complexity:$$O(n)$$\\n\\n\\n- Space complexity:$$O(1)$$\\n\\n\\n# Code\\n```\\nclass Solution {\\n    public:\\n     void moveZeroes(vector<int>& nums) {\\n        // snowball approach time=O(n) space=o(1)\\n        int snowball=0;\\n\\n        for(int i=0;i<nums.size();i++){\\n            if(nums[i]==0){\\n                snowball++;\\n            }\\n\\n            else if(snowball>0){\\n                nums[i-snowball]=nums[i];\\n                nums[i]=0;\\n            }\\n        }\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\n    public:\\n     void moveZeroes(vector<int>& nums) {\\n        // snowball approach time=O(n) space=o(1)\\n        int snowball=0;\\n\\n        for(int i=0;i<nums.size();i++){\\n            if(nums[i]==0){\\n                snowball++;\\n            }\\n\\n            else if(snowball>0){\\n                nums[i-snowball]=nums[i];\\n                nums[i]=0;\\n            }\\n        }\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3351454,
                "title": "very-easy-java-beats-100-o-n",
                "content": "# Intuition\\nsingle sweep method\\n\\n# Approach\\n1. ind - keep a pointer with you which will keep track of elements>0 \\n\\n2. zero - one more pointer to keep track of no. of zeros in array\\n\\n3. In a single loop whenever a element >0 appears add that element to \\nIth position , else increase the ind pointer and add +1 to zero\\n\\nex-\\narray =  0  5  4  15  0  1\\nindex =  0  1  2  3   4  5\\n\\nzero =0;\\nind =0;\\n-----------------------------\\nloop i=0 i<6 i++\\n-----------------------------\\ni=0\\na[0] =0\\nso, increase ind+1 , ind =1\\nalso increase zero by 1 , zero =1;\\na[1] = 5 ,  >0 hence\\na[0] = a[1];\\nlastly ind++ hence -> ind =2;\\n-----------------------------\\ni=1  ,ind=2, zero =1;\\na[2] = 4 ,>0\\nhence \\na[1] = a[2];\\nsize no change  = 1;\\nlastly ind++ -> ind =3;\\n-----------------------------\\ni=2 , ind =3 , zero =1;\\na[3]= 15 , >0\\na[2] = a[3];\\nsize same =1\\nind++ -> 4;\\n-----------------------------\\ni=3 , ind =4, size =1;\\na[4] =0 \\nhence\\nind++ , ind =5\\na[5] = 1 , >0\\na[3] = a[5]\\nsize +1 , size =2;\\nind++ , ind = 6;\\n--------------------------\\n\\n\\n\\n# Complexity\\n- Time complexity:\\nO(N)\\n\\n- Space complexity:\\nO(1)\\n\\n# Code\\n```\\nclass Solution {\\n    public void moveZeroes(int[] nums) {\\n        int n =nums.length;\\n        int zero = 0;\\n        int cha =0;\\n        for(int i =0;i<n;i++){\\n            while(cha<n && nums[cha]==0){\\n                cha++;\\n                zero++;\\n            }\\n            if(cha<n)\\n            nums[i] = nums[cha];\\n            cha++;\\n        }\\n\\n        for(int i =n-zero;i<n;i++){\\n            nums[i]=0;\\n        }\\n\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public void moveZeroes(int[] nums) {\\n        int n =nums.length;\\n        int zero = 0;\\n        int cha =0;\\n        for(int i =0;i<n;i++){\\n            while(cha<n && nums[cha]==0){\\n                cha++;\\n                zero++;\\n            }\\n            if(cha<n)\\n            nums[i] = nums[cha];\\n            cha++;\\n        }\\n\\n        for(int i =n-zero;i<n;i++){\\n            nums[i]=0;\\n        }\\n\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3089882,
                "title": "c-easy-god-speed-o-n-complexity",
                "content": "# Complexity\\n- Time complexity: O(n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: Constant\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    void moveZeroes(vector<int>& nums) {\\n        int n=nums.size(),j,i;\\n        j=0;\\n        i=0;\\n        while(j<n){\\n            if(nums[j]!=0){\\n                nums[i]=nums[j];\\n                i++;\\n            }\\n            j++;\\n        }\\n        while(i<n){\\n            nums[i]=0;\\n            i++;\\n        }\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    void moveZeroes(vector<int>& nums) {\\n        int n=nums.size(),j,i;\\n        j=0;\\n        i=0;\\n        while(j<n){\\n            if(nums[j]!=0){\\n                nums[i]=nums[j];\\n                i++;\\n            }\\n            j++;\\n        }\\n        while(i<n){\\n            nums[i]=0;\\n            i++;\\n        }\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2108395,
                "title": "kotlin-short-and-easy-to-understand-solution",
                "content": "```\\nclass Solution {\\n    fun moveZeroes(nums: IntArray): Unit {\\n        var pointer = 0\\n        nums.forEach { if (it != 0) nums[pointer++] = it }\\n        while (pointer < nums.size) nums[pointer++] = 0\\n    }\\n}\\n```\\nPlease upvote, if you like the solution)",
                "solutionTags": [
                    "Kotlin"
                ],
                "code": "```\\nclass Solution {\\n    fun moveZeroes(nums: IntArray): Unit {\\n        var pointer = 0\\n        nums.forEach { if (it != 0) nums[pointer++] = it }\\n        while (pointer < nums.size) nums[pointer++] = 0\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2071556,
                "title": "python-easy-to-understand-code",
                "content": "```\\nclass Solution:\\n    def moveZeroes(self, nums: List[int]) -> None:\\n        for i in nums:\\n            if i == 0:\\n                nums.remove(0)\\n                nums.append(0)\\n```\\nThe remove() method removes the first matching element (which is passed as an argument) from the list.\\nThe append() method adds an item to the end of the list.\\n.\\n.\\n.\\n.\\n.\\n.\\n.\\nPlease Upvote if you find this post useful.",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def moveZeroes(self, nums: List[int]) -> None:\\n        for i in nums:\\n            if i == 0:\\n                nums.remove(0)\\n                nums.append(0)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 992211,
                "title": "java-easy-100-faster-solution-with-explaination",
                "content": "```\\nclass Solution {\\n    public void moveZeroes(int[] nums) {\\n        int index=0;\\n        for(int i=0;i<nums.length;i++){\\n            if(nums[i]!=0){// we will shift all the non zero values to right\\n                nums[index]=nums[i];\\n                index++;// keep on increasing the index as well\\n            }\\n        }\\n        for(int i= index; i<nums.length;i++){ //now we will replace all the remaing indexes with zero\\n            nums[i]=0;\\n        }\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public void moveZeroes(int[] nums) {\\n        int index=0;\\n        for(int i=0;i<nums.length;i++){\\n            if(nums[i]!=0){// we will shift all the non zero values to right\\n                nums[index]=nums[i];\\n                index++;// keep on increasing the index as well\\n            }\\n        }\\n        for(int i= index; i<nums.length;i++){ //now we will replace all the remaing indexes with zero\\n            nums[i]=0;\\n        }\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 562748,
                "title": "so-few-people-use-c-style-pointers",
                "content": "I have to contribute my solution using proper C-style pointer arithmetic:\\n```\\nvoid moveZeroes(int* nums, int numsSize){\\n    int *write = nums, *end = nums + numsSize;\\n    for( int *read = nums; read < end; read++) if (*read) *write++ = *read;\\n    while (write < end) *write++ = 0;\\n}\\n```\\n\\nRuntime: 12 ms, faster than 89.09% of C online submissions for Move Zeroes.\\nMemory Usage: 7.2 MB, less than 100.00% of C online submissions for Move Zeroes.",
                "solutionTags": [],
                "code": "```\\nvoid moveZeroes(int* nums, int numsSize){\\n    int *write = nums, *end = nums + numsSize;\\n    for( int *read = nums; read < end; read++) if (*read) *write++ = *read;\\n    while (write < end) *write++ = 0;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 218181,
                "title": "python-beat-98",
                "content": "This is my way, very pythonic, although I admit this is a little bit tricky because it use del. In the other language, there is no such method.\\n   ```\\n def moveZeroes(self, nums):\\n        \"\"\"\\n        :type nums: List[int]\\n        :rtype: void Do not return anything, modify nums in-place instead.\\n        \"\"\"\\n        length = len(nums)\\n        i,j = 0,0\\n        while(i < length):\\n            if nums[j] == 0:\\n                del nums[j]\\n                nums.append(0)\\n                i += 1\\n                continue\\n            j += 1\\n            i += 1\\n```\\nNotice j is the real index and i is actually the number of operation time.",
                "solutionTags": [],
                "code": "```\\n def moveZeroes(self, nums):\\n        \"\"\"\\n        :type nums: List[int]\\n        :rtype: void Do not return anything, modify nums in-place instead.\\n        \"\"\"\\n        length = len(nums)\\n        i,j = 0,0\\n        while(i < length):\\n            if nums[j] == 0:\\n                del nums[j]\\n                nums.append(0)\\n                i += 1\\n                continue\\n            j += 1\\n            i += 1\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 72386,
                "title": "0ms-easy-to-understand-java-solution",
                "content": "    public class Solution {\\n        public void moveZeroes(int[] nums) {\\n            if(nums == null || nums.length < 1) return;\\n            int count = 0;\\n            int numslength = nums.length;\\n            for(int i=0; i<numslength; i++) {\\n                if(nums[i] != 0) {\\n                    nums[count] = nums[i];\\n                    count++;\\n            }\\n        }\\n        \\n        int numofzeros = numslength - count;\\n        for(int i=0; i<numofzeros; i++) nums[count + i] = 0;\\n    }\\n}",
                "solutionTags": [],
                "code": "class Solution {\\n        public void moveZeroes(int[] nums) {\\n            if(nums == null || nums.length < 1) return;\\n            int count = 0;\\n            int numslength = nums.length;\\n            for(int i=0; i<numslength; i++) {\\n                if(nums[i] != 0) {\\n                    nums[count] = nums[i];\\n                    count++;\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 72529,
                "title": "c-two-pointers",
                "content": "    class Solution {\\n    public:\\n        void moveZeroes(vector<int>& nums) {\\n            int j = -1;\\n            for(int i = 0;i < nums.size();i++){\\n                if(nums[i] != 0){\\n                    j++;\\n                    nums[j] = nums[i];\\n                }\\n            }\\n            for(int i = j+1;i < nums.size();i++)\\n            nums[i] = 0;\\n        }\\n    };",
                "solutionTags": [],
                "code": "class Solution {\\n    public:\\n        void moveZeroes(vector<int>& nums) {\\n            int j = -1;\\n            for(int i = 0;i < nums.size();i++){\\n                if(nums[i] != 0){\\n                    j++;\\n                    nums[j] = nums[i];\\n                }",
                "codeTag": "Java"
            },
            {
                "id": 3909891,
                "title": "c-java-solution-using-quicksort-algorithm-with-visual-explanation-o-1-space-complexity",
                "content": "# Approach\\nThis guy definitely explained it better than I could, so, instead of my own explanation, I leave you the video:\\n\\nhttps://youtu.be/aayNRwUN3Do\\n\\n# Code\\n```\\npublic class Solution {\\n    public void MoveZeroes(int[] nums) {\\n        int left = 0;\\n\\n        for (int right = 0; right < nums.Length; right++)\\n        {\\n            if(nums[right] != 0)\\n            {\\n                (nums[left], nums[right]) = (nums[right], nums[left]);\\n                left ++;\\n            }\\n        }\\n    }\\n}\\n```\\n\\n## If you found my solution helpful, please consider giving it an upvote. Happy coding!",
                "solutionTags": [
                    "C#"
                ],
                "code": "```\\npublic class Solution {\\n    public void MoveZeroes(int[] nums) {\\n        int left = 0;\\n\\n        for (int right = 0; right < nums.Length; right++)\\n        {\\n            if(nums[right] != 0)\\n            {\\n                (nums[left], nums[right]) = (nums[right], nums[left]);\\n                left ++;\\n            }\\n        }\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3747951,
                "title": "c-dutch-national-flag-algo",
                "content": "**Connect with me on LinkedIn**: https://www.linkedin.com/in/abhay5349singh/\\n\\n```\\nclass Solution {\\npublic:\\n    void moveZeroes(vector<int>& a) {\\n        int n=a.size();\\n        \\n        // [0,i] => non-zeros, [i+1,j-1] => zeros, [j,n-1] => undefined region\\n        int i=-1, j=0;\\n        while(j<n){\\n            if(a[j] != 0){\\n                i++; // expanding range for non-zeros\\n                swap(a[i],a[j]);\\n            }\\n            j++;\\n        }\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Two Pointers"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    void moveZeroes(vector<int>& a) {\\n        int n=a.size();\\n        \\n        // [0,i] => non-zeros, [i+1,j-1] => zeros, [j,n-1] => undefined region\\n        int i=-1, j=0;\\n        while(j<n){\\n            if(a[j] != 0){\\n                i++; // expanding range for non-zeros\\n                swap(a[i],a[j]);\\n            }\\n            j++;\\n        }\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3389868,
                "title": "c-best-solution-o-n-time-complexity",
                "content": "\\n# Code\\n```\\nvoid moveZeroes(int* nums, int numsSize){\\n    int j = 0;\\n    bool zero = false;\\n    for (int i = 0; i < numsSize; i++) {\\n        if (nums[i] == 0 && !zero) {\\n            zero = !zero;\\n            j = i;\\n        }\\n        else if (nums[i] != 0 && zero) {\\n            nums[j++] = nums[i];\\n            nums[i] = 0;\\n        }\\n    }\\n}\\n\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Array"
                ],
                "code": "```\\nvoid moveZeroes(int* nums, int numsSize){\\n    int j = 0;\\n    bool zero = false;\\n    for (int i = 0; i < numsSize; i++) {\\n        if (nums[i] == 0 && !zero) {\\n            zero = !zero;\\n            j = i;\\n        }\\n        else if (nums[i] != 0 && zero) {\\n            nums[j++] = nums[i];\\n            nums[i] = 0;\\n        }\\n    }\\n}\\n\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3322648,
                "title": "brute-force-but-guess-what-no-extra-space",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\nReplacing the original array with all non-zero elements in the front and then adding 0 to all the places left in the array, at the end.\\n\\n# Complexity\\n- Time complexity:\\nO(N)\\n\\n- Space complexity:\\nO(1)\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    void moveZeroes(vector<int>& nums) \\n    {\\n        int n=nums.size();\\n        int j = 0;\\n  for (int i = 0; i < n; i++)\\n  {\\n    if (nums[i] != 0)\\n    {\\n     nums[j] = nums[i];\\n      j++;\\n    }\\n  }\\n  for (int i = j; j < n; j++)\\n  {\\n    nums[j] = 0;\\n  }\\n        \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    void moveZeroes(vector<int>& nums) \\n    {\\n        int n=nums.size();\\n        int j = 0;\\n  for (int i = 0; i < n; i++)\\n  {\\n    if (nums[i] != 0)\\n    {\\n     nums[j] = nums[i];\\n      j++;\\n    }\\n  }\\n  for (int i = j; j < n; j++)\\n  {\\n    nums[j] = 0;\\n  }\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3250964,
                "title": "brute-force-and-optimal-approches",
                "content": "\\n# 1. Brute force Approach\\n```\\nclass Solution:\\n    def moveZeroes(self, nums: List[int]) -> None:\\n        for i in nums:\\n            if i==0:\\n                nums.remove(0)\\n                nums.append(i)\\n```\\n# 2. Optimal Approach\\n```\\nclass Solution:\\n    def moveZeroes(self, nums: List[int]) -> None:\\n        left=0\\n        for right in range(len(nums)):\\n            if nums[right]!=0:\\n                nums[right],nums[left]=nums[left],nums[right]\\n                left+=1\\n```\\n# please upvote me it would encourage me alot\\n\\n",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def moveZeroes(self, nums: List[int]) -> None:\\n        for i in nums:\\n            if i==0:\\n                nums.remove(0)\\n                nums.append(i)\\n```\n```\\nclass Solution:\\n    def moveZeroes(self, nums: List[int]) -> None:\\n        left=0\\n        for right in range(len(nums)):\\n            if nums[right]!=0:\\n                nums[right],nums[left]=nums[left],nums[right]\\n                left+=1\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3224717,
                "title": "very-easy-100-easiest-logic-ever-fully-explained-c-javascript-java",
                "content": "\\n# Complexity\\n- Time complexity:\\nO(n)\\n\\n- Space complexity:\\nO(1)\\n\\n# Code\\n```\\n/**\\n * @param {number[]} nums\\n * @return {void} Do not return anything, modify nums in-place instead.\\n */\\nvar moveZeroes = (nums) => {\\n  let j = 0;\\n  for (let i = 0; i < nums.length; i++) {\\n    if (nums[i] != 0) {\\n      nums[j++] = nums[i];\\n    }\\n  }\\n  for (; j < nums.length; j++) {\\n    nums[j] = 0;\\n  }\\n  return nums;\\n};\\n```\\n```\\nvar moveZeroes = function (nums) {\\n  let m = 0, temp;\\n\\n  for (let i = 0; i < nums.length; i++) {\\n    if (nums[i] != 0) {\\n      temp = nums[i];\\n      nums[i] = nums[m];\\n      nums[m] = temp;\\n      m++;\\n    }\\n  }\\n\\n  return nums;\\n}\\n```\\n# Approach\\nWe start loopng from the end of array\\nIf current element is 0, we remove it from array\\nAnd then push to the end\\n\\n```\\nvar moveZeroes = function(nums) {\\n    let end = nums.length;\\n\\tfor (let i = end; i >= 0; i--) { // We loop from the end of array\\n\\t\\tif (nums[i] === 0) { // if current element is 0\\n\\t\\t\\tnums.splice(i, 1); // we remove if from array\\n\\t\\t\\tnums.push(0); // and push to the end\\n\\t\\t}\\n\\t}\\n\\treturn nums;\\n};\\n```\\n##### I am working hard for you guys...\\n##### Please upvote if you found any help with this code...",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {number[]} nums\\n * @return {void} Do not return anything, modify nums in-place instead.\\n */\\nvar moveZeroes = (nums) => {\\n  let j = 0;\\n  for (let i = 0; i < nums.length; i++) {\\n    if (nums[i] != 0) {\\n      nums[j++] = nums[i];\\n    }\\n  }\\n  for (; j < nums.length; j++) {\\n    nums[j] = 0;\\n  }\\n  return nums;\\n};\\n```\n```\\nvar moveZeroes = function (nums) {\\n  let m = 0, temp;\\n\\n  for (let i = 0; i < nums.length; i++) {\\n    if (nums[i] != 0) {\\n      temp = nums[i];\\n      nums[i] = nums[m];\\n      nums[m] = temp;\\n      m++;\\n    }\\n  }\\n\\n  return nums;\\n}\\n```\n```\\nvar moveZeroes = function(nums) {\\n    let end = nums.length;\\n\\tfor (let i = end; i >= 0; i--) { // We loop from the end of array\\n\\t\\tif (nums[i] === 0) { // if current element is 0\\n\\t\\t\\tnums.splice(i, 1); // we remove if from array\\n\\t\\t\\tnums.push(0); // and push to the end\\n\\t\\t}\\n\\t}\\n\\treturn nums;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2767897,
                "title": "just-like-quick-sort-using-pevot-index-tc-n",
                "content": "```\\nclass Solution:\\n    def moveZeroes(self, nums: List[int]) -> None:\\n        pvt=0\\n        for i in range(len(nums)):\\n            if(nums[i]!=0):\\n                nums[i],nums[pvt]=nums[pvt],nums[i]\\n                pvt+=1\\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nclass Solution:\\n    def moveZeroes(self, nums: List[int]) -> None:\\n        pvt=0\\n        for i in range(len(nums)):\\n            if(nums[i]!=0):\\n                nums[i],nums[pvt]=nums[pvt],nums[i]\\n                pvt+=1\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2722767,
                "title": "golang-clearly-explained-two-pointer-solution",
                "content": "# Approach\\n<!-- Describe your approach to solving the problem. -->\\nWe define the left pointer $l$ that points to the place we will move the next non-zero number to.\\n\\nThe right pointer $r$ would go through the array. Two cases here:\\n\\n1. If nums[r] == 0, do nothing.\\n2. Otherwise, we set nums[l]=nums[r] and increment $l$ by one.\\n\\nAfter the right pointer is done going through the array, the pointer $l$ would be **EXACTLY** at the place we setting elements to zero at. So we just simply move $l$ to the end of the array setting all elements to zero.\\n\\n# Complexity\\n- Time complexity: O(n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nfunc moveZeroes(nums []int)  {\\n    l := 0\\n\\n    for r := range nums {\\n        if nums[r] != 0 {\\n            nums[l] = nums[r]\\n            l++\\n        }\\n    }\\n    for ; l < len(nums); l++ {\\n        nums[l] = 0\\n    }\\n    return\\n}\\n```",
                "solutionTags": [
                    "Go",
                    "Array",
                    "Two Pointers"
                ],
                "code": "```\\nfunc moveZeroes(nums []int)  {\\n    l := 0\\n\\n    for r := range nums {\\n        if nums[r] != 0 {\\n            nums[l] = nums[r]\\n            l++\\n        }\\n    }\\n    for ; l < len(nums); l++ {\\n        nums[l] = 0\\n    }\\n    return\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2624674,
                "title": "very-easy-php-solution",
                "content": "```\\nclass Solution {\\n\\n    /**\\n     * @param Integer[] $nums\\n     * @return NULL\\n     */\\n    function moveZeroes(&$nums) {\\n        for($i = 0; $i < count($nums); $i++){\\n            if ($nums[$i] === 0) {\\n                unset($nums[$i]);\\n                $nums[]= 0;\\n            }\\n        }\\n        return $nums;\\n    }\\n}\\n```",
                "solutionTags": [
                    "PHP"
                ],
                "code": "```\\nclass Solution {\\n\\n    /**\\n     * @param Integer[] $nums\\n     * @return NULL\\n     */\\n    function moveZeroes(&$nums) {\\n        for($i = 0; $i < count($nums); $i++){\\n            if ($nums[$i] === 0) {\\n                unset($nums[$i]);\\n                $nums[]= 0;\\n            }\\n        }\\n        return $nums;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2387606,
                "title": "simple-c-o-1-space-o-n-time-explanation-in-comments",
                "content": "**O(N) time and O(1) space.**\\n\\nWe will use a left pointer to keep track of first leftmost zero\\'s position. Whenever some non-zero element is found we will swap that element with this left pointer position and move the pointer one step ahead in array.\\n\\nLook for code comments for better understanding.\\n```\\nclass Solution {\\npublic:\\n    void moveZeroes(vector<int>& nums) {\\n        \\n        int left = 0;\\n        \\n        // Finding first zero to set our left pointer to point to first zero.\\n        while(left < nums.size() && nums[left] != 0)\\n            left++;\\n        \\n        // start iterating now after first found zero.\\n        for(int i=left+1;i<nums.size();i++)\\n        {\\n            // If zero found do nothing and move forward.\\n            if(nums[i] == 0)\\n                continue;\\n            \\n            // If non-zero elm then swap the left pointer pointing to zero with this element and move our left pointer forward.\\n            swap(nums[i],nums[left]);\\n            left++;\\n        }\\n        \\n    }\\n};\\n```\\n\\n# **Happy Coding :)**",
                "solutionTags": [
                    "C++",
                    "Array"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    void moveZeroes(vector<int>& nums) {\\n        \\n        int left = 0;\\n        \\n        // Finding first zero to set our left pointer to point to first zero.\\n        while(left < nums.size() && nums[left] != 0)\\n            left++;\\n        \\n        // start iterating now after first found zero.\\n        for(int i=left+1;i<nums.size();i++)\\n        {\\n            // If zero found do nothing and move forward.\\n            if(nums[i] == 0)\\n                continue;\\n            \\n            // If non-zero elm then swap the left pointer pointing to zero with this element and move our left pointer forward.\\n            swap(nums[i],nums[left]);\\n            left++;\\n        }\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2317855,
                "title": "swift-simplest-solution",
                "content": "Please, upvote if you found the solution useful.\\n```\\nclass Solution {\\n\\t/// Time: O(n). Space: O(1)\\n    func moveZeroes(_ nums: inout [Int]) {\\n        var lastNonZeroIndex = 0\\n        for i in 0..<nums.count {\\n            guard nums[i] != 0 else { continue }\\n            nums.swapAt(i, lastNonZeroIndex)\\n            lastNonZeroIndex += 1\\n        }\\n    }\\n}\\n```",
                "solutionTags": [
                    "Swift"
                ],
                "code": "```\\nclass Solution {\\n\\t/// Time: O(n). Space: O(1)\\n    func moveZeroes(_ nums: inout [Int]) {\\n        var lastNonZeroIndex = 0\\n        for i in 0..<nums.count {\\n            guard nums[i] != 0 else { continue }\\n            nums.swapAt(i, lastNonZeroIndex)\\n            lastNonZeroIndex += 1\\n        }\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1728278,
                "title": "two-pointers-2ms-runtime-java-easy-sol-fast",
                "content": "**Upvote** if it helped you please! \\nEasy and short using ***two pointers*** approach.\\n\\n```\\nclass Solution {\\n    public void moveZeroes(int[] nums) {\\n        int p1 = 0;\\n        int p2 = 1;\\n        while(p2 < nums.length) {\\n            if(nums[p1] == 0 && nums[p2] != 0) {\\n                nums[p1] = nums[p2];\\n                nums[p2] = 0;\\n                p1++;\\n                p2++;\\n            } else if(nums[p1] == 0 && nums[p2] == 0) {\\n               p2++; \\n            } else {\\n                p1++;\\n                p2++;\\n            }  \\n        }\\n    }\\n}\\n```\\n\\n",
                "solutionTags": [
                    "Java",
                    "Two Pointers"
                ],
                "code": "```\\nclass Solution {\\n    public void moveZeroes(int[] nums) {\\n        int p1 = 0;\\n        int p2 = 1;\\n        while(p2 < nums.length) {\\n            if(nums[p1] == 0 && nums[p2] != 0) {\\n                nums[p1] = nums[p2];\\n                nums[p2] = 0;\\n                p1++;\\n                p2++;\\n            } else if(nums[p1] == 0 && nums[p2] == 0) {\\n               p2++; \\n            } else {\\n                p1++;\\n                p2++;\\n            }  \\n        }\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1203079,
                "title": "c-one-liner",
                "content": "```\\nclass Solution {\\npublic:\\n    void moveZeroes(vector<int>& nums) {\\n        for(int i=0,j=0;i<nums.size();i++) if(nums[i]!=0)swap(nums[i],nums[j++]);\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    void moveZeroes(vector<int>& nums) {\\n        for(int i=0,j=0;i<nums.size();i++) if(nums[i]!=0)swap(nums[i],nums[j++]);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 530024,
                "title": "easy-o-n-js-solution",
                "content": "```\\nvar moveZeroes = function(nums) {\\n    let idxForNonZero = 0;\\n    for (let i = 0; i < nums.length; i++) {\\n        if (nums[i] !== 0) {\\n            [nums[idxForNonZero], nums[i]] = [nums[i], nums[idxForNonZero]];\\n            idxForNonZero++;\\n            // no need to check the swapped number because we are scanning through the array from the left so it is guaranteed that \\n            // the element at the idxForNonZero is zero (not non-zero).\\n        }\\n    }\\n    return nums;  \\n    // Time Complexity: O(n)\\n    // Space Complexity: O(1)\\n};\\n\\n// we want to have two partitions. The first partition has only non-zeros and the second partition has only zeroes.\\n// If we push all non-zeroes to the first partition, zeroes will be automatically moved to the second partition.\\n// So, we keep an index where the next non-zero will go into and this index starts from zero. Every time we encounter a non-zero, \\n// we swap this element with the number at the index for the next non-zero.\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\nvar moveZeroes = function(nums) {\\n    let idxForNonZero = 0;\\n    for (let i = 0; i < nums.length; i++) {\\n        if (nums[i] !== 0) {\\n            [nums[idxForNonZero], nums[i]] = [nums[i], nums[idxForNonZero]];\\n            idxForNonZero++;\\n            // no need to check the swapped number because we are scanning through the array from the left so it is guaranteed that \\n            // the element at the idxForNonZero is zero (not non-zero).\\n        }\\n    }\\n    return nums;  \\n    // Time Complexity: O(n)\\n    // Space Complexity: O(1)\\n};\\n\\n// we want to have two partitions. The first partition has only non-zeros and the second partition has only zeroes.\\n// If we push all non-zeroes to the first partition, zeroes will be automatically moved to the second partition.\\n// So, we keep an index where the next non-zero will go into and this index starts from zero. Every time we encounter a non-zero, \\n// we swap this element with the number at the index for the next non-zero.\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 154240,
                "title": "swift-solution",
                "content": "```class Solution {\\n    func moveZeroes(_ nums: inout [Int]) {\\n        let count = nums.count\\n        nums = nums.filter { $0 != 0}\\n        for _ in 0 ..< (count - nums.count) { nums.append(0) }\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```class Solution {\\n    func moveZeroes(_ nums: inout [Int]) {\\n        let count = nums.count\\n        nums = nums.filter { $0 != 0}\\n        for _ in 0 ..< (count - nums.count) { nums.append(0) }\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 72055,
                "title": "3-line-python-solution",
                "content": "```\\nclass Solution(object):\\n    def moveZeroes(self, nums):\\n        for i in range(len(nums))[::-1]:\\n            if nums[i] == 0:\\n                nums.append(nums.pop(i))\\n```\\nIf we iterate from the front and pop, the rest of the array will shift place and you will skip an element.\\nIf pop from the back then that is avoided by using [::-1] of range.\\npopping from the middle of the list is more expensive because it has to shift all the elements behind, but from the test cases this is pretty fast (probably because the tests are really short).  This is not as efficient as the two pointer solution (https://github.com/kamyu104/LeetCode/blob/master/Python/move-zeroes.py), but very very easy to understand.",
                "solutionTags": [],
                "code": "```\\nclass Solution(object):\\n    def moveZeroes(self, nums):\\n        for i in range(len(nums))[::-1]:\\n            if nums[i] == 0:\\n                nums.append(nums.pop(i))\\n```",
                "codeTag": "Java"
            },
            {
                "id": 72295,
                "title": "java-solution-in-0ms-beat-s87-69",
                "content": "    public class Solution {\\n        public void moveZeroes(int[] nums) {\\n            int counter = 0;\\n            int length = nums.length;\\n            for(int j = 0;j<length;j++){\\n                if(nums[j]==0){\\n                    counter++;\\n                }else {\\n                    nums[j-counter]=nums[j];\\n                    \\n                }\\n            }\\n            while(counter>0){\\n                nums[length-counter]=0;\\n                counter--;\\n            }\\n        }\\n    }\\ni think this answer is pretty easy to understand,so there is no comment",
                "solutionTags": [],
                "code": "class Solution {\\n        public void moveZeroes(int[] nums) {\\n            int counter = 0;\\n            int length = nums.length;\\n            for(int j = 0;j<length;j++){\\n                if(nums[j]==0){\\n                    counter++;\\n                }",
                "codeTag": "Java"
            },
            {
                "id": 72340,
                "title": "c-20ms-solution-explained",
                "content": "The idea is simply. Instead of moving 0s to the end, we move non-zeros to the front.\\n\\n    void moveZeroes(vector<int>& nums) {\\n        int j=0;\\n        for(int i=0;i<nums.size();i++){\\n            if (nums[i]) swap(nums[j++],nums[i]);\\n        }\\n    }",
                "solutionTags": [],
                "code": "The idea is simply. Instead of moving 0s to the end, we move non-zeros to the front.\\n\\n    void moveZeroes(vector<int>& nums) {\\n        int j=0;\\n        for(int i=0;i<nums.size();i++){\\n            if (nums[i]) swap(nums[j++],nums[i]);\\n        }\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 72311,
                "title": "6-lines-python-borrowed-partition-mechanism-from-quick-sort",
                "content": "    class Solution(object):\\n        def moveZeroes(self, nums):\\n            i = j = 0\\n            while i < len(nums):\\n                if nums[i] != 0:\\n                    nums[i], nums[j] = nums[j], nums[i]\\n                    j += 1\\n                i += 1",
                "solutionTags": [],
                "code": "    class Solution(object):\\n        def moveZeroes(self, nums):\\n            i = j = 0\\n            while i < len(nums):\\n                if nums[i] != 0:\\n                    nums[i], nums[j] = nums[j], nums[i]\\n                    j += 1\\n                i += 1",
                "codeTag": "Java"
            },
            {
                "id": 72521,
                "title": "java-o-n-solution-in-place-without-basecase",
                "content": "    public class Solution {\\n        public void moveZeroes(int[] nums) {\\n            int rightPos = 0, curr = 0;\\n            while(curr < nums.length) {\\n                if(nums[curr]!=0) nums[rightPos++] = nums[curr];\\n                curr++;\\n            }\\n            while(rightPos < nums.length) {\\n                nums[rightPos++] = 0;\\n            }\\n        }\\n    }",
                "solutionTags": [],
                "code": "class Solution {\\n        public void moveZeroes(int[] nums) {\\n            int rightPos = 0, curr = 0;\\n            while(curr < nums.length) {\\n                if(nums[curr]!=0) nums[rightPos++] = nums[curr];\\n                curr++;\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 4001789,
                "title": "two-pointer-solution-with-step-by-step-explanation",
                "content": "# Intuition\\nFor this problem we will use two pointer algorithm.\\n\\n# Approach\\nFirst we declare left and right pointers at 0 index position, then we start to iterate over nums array and look for two possible scenarios either right ponter points to zero in this scenario we just scip to next right pointer index, and if right pointer is pointing to non zero value, in this case we swap right and left numbers, the main takeaway is that left and right will be swapping until they found first zero, then left will be pointing to zero and right will go and find non zero number to swap with left, and repeat until right pointer will reach end of nums array.  \\n\\n# Complexity\\n- Time complexity:\\nO(n) - Since we iterate only once for each num in nums Array\\n\\n- Space complexity:\\nO(1) - since we create only two int pointers and we mutate original array.\\n\\n# Code\\n```\\nclass Solution {\\n    public void moveZeroes(int[] nums) {\\n        // declare left pointer\\n        int left = 0;\\n        // iterate over nums array with right pointer\\n        for(int right = 0; right < nums.length; right++) {\\n            // if right pointer is non zero:\\n            if(nums[right] != 0) {\\n                // create tmp variable to store right num\\n                int tmp = nums[right];\\n                // swap right num for left num\\n                nums[right] = nums[left];\\n                // swap left num for num that we stored in tmp\\n                nums[left] = tmp;\\n                // increment left pointer\\n                left++;\\n            }\\n        }\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Two Pointers"
                ],
                "code": "```\\nclass Solution {\\n    public void moveZeroes(int[] nums) {\\n        // declare left pointer\\n        int left = 0;\\n        // iterate over nums array with right pointer\\n        for(int right = 0; right < nums.length; right++) {\\n            // if right pointer is non zero:\\n            if(nums[right] != 0) {\\n                // create tmp variable to store right num\\n                int tmp = nums[right];\\n                // swap right num for left num\\n                nums[right] = nums[left];\\n                // swap left num for num that we stored in tmp\\n                nums[left] = tmp;\\n                // increment left pointer\\n                left++;\\n            }\\n        }\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3789531,
                "title": "c-easy-solution-in-single-traversal",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\njust count the non zero elements \\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nusing one pointer variable as count\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nO(n)\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nO(1)\\n# Code\\n```\\nclass Solution {\\npublic:\\n    void moveZeroes(vector<int>& nums) {\\n        int count=0;\\n        for(int i=0;i<nums.size();i++){\\n            if(nums[i]!=0){\\n                swap(nums[i],nums[count]);\\n                count++;\\n            }\\n        }\\n        \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    void moveZeroes(vector<int>& nums) {\\n        int count=0;\\n        for(int i=0;i<nums.size();i++){\\n            if(nums[i]!=0){\\n                swap(nums[i],nums[count]);\\n                count++;\\n            }\\n        }\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3404027,
                "title": "2-approaches-easily-explained-optimal-and-brute-c-code",
                "content": "# Brute force approach -->\\nWe can create an temporary array, \\nWe will traverse the entire given array and find out all the non-zero elements and put them in the temporary array.\\nThen we can put them back into the given array from the first position then rest size of the array will be filled with zero.\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n$$O(n)$$\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n$$O(n)$$ --> Size of the temporary array\\n# Brute Force Code \\n```\\nclass Solution {\\npublic:\\n    void moveZeroes(vector<int>& nums){\\n        vector<int>temp;\\n        int n=nums.size();\\n        for(int i=0;i<n;i++){\\n            if(nums[i]!=0){\\n                temp.push_back(nums[i]);    \\n            }\\n        }\\n        for(int i=0;i<temp.size();i++){\\n            nums[i]=temp[i];\\n        }\\n        for(int i=n-temp.size();i<n;i++){\\n            nums[i]=0;\\n        }\\n        return;\\n    }\\n}\\n```\\n# Optimal Approach -->\\nWe can use two pointer approach (i,j).\\nWe will set the value of j = -1\\nthen we will traverse the given array till it finds the first 0. Then the index of it will be stored in j and it will break. After this loop if j remains as -1 then the given array will be returned because it does not contain any element which is 0.\\nThen a loop will traverse from j+1 to the end of the given array.\\nWhere j will alway be pointing the index of the current 0 and i will find the non-zero element to swap nums[i] and nums[j], when swapping will happen then i and j both will increase. Otherwise only i will be increamented to find the next non-zero element.\\n# Optimized Code\\n```\\nclass Solution {\\npublic:\\n    void moveZeroes(vector<int>& nums) {\\n        int n=nums.size();\\n        int j=-1;\\n        for(int i=0;i<n;i++){\\n            if(nums[i]==0){\\n                j=i;\\n                break;\\n            }\\n        }\\n        if(j==-1){\\n            return ;\\n        }\\n        for(int i=j+1;i<n;i++){\\n            if(nums[i]!=0){\\n                swap(nums[i],nums[j]);\\n                j++;\\n            }\\n        }\\n        return ;\\n    }\\n};\\n```\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n$$O(n)$$\\n- Space complexity:\\n\\n$$O(1)$$ --> No extra space is used\\n\\n# Please Upvote if you find it helpful \\u2B06\\uFE0F",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    void moveZeroes(vector<int>& nums){\\n        vector<int>temp;\\n        int n=nums.size();\\n        for(int i=0;i<n;i++){\\n            if(nums[i]!=0){\\n                temp.push_back(nums[i]);    \\n            }\\n        }\\n        for(int i=0;i<temp.size();i++){\\n            nums[i]=temp[i];\\n        }\\n        for(int i=n-temp.size();i<n;i++){\\n            nums[i]=0;\\n        }\\n        return;\\n    }\\n}\\n```\n```\\nclass Solution {\\npublic:\\n    void moveZeroes(vector<int>& nums) {\\n        int n=nums.size();\\n        int j=-1;\\n        for(int i=0;i<n;i++){\\n            if(nums[i]==0){\\n                j=i;\\n                break;\\n            }\\n        }\\n        if(j==-1){\\n            return ;\\n        }\\n        for(int i=j+1;i<n;i++){\\n            if(nums[i]!=0){\\n                swap(nums[i],nums[j]);\\n                j++;\\n            }\\n        }\\n        return ;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3374523,
                "title": "beats-100-optimal-solution-using-two-pointers",
                "content": "\\n\\n# Complexity\\n- Time complexity:\\nO(N)\\n\\n- Space complexity:\\nO(1)\\n\\n# Code\\n```\\nclass Solution\\n{\\npublic:\\n  void moveZeroes(vector<int> &nums)\\n  {\\n    // finding first zero occurrence\\n    int k = 0;\\n    int n = nums.size();\\n    while (k < n)\\n    {\\n      if (nums[k] == 0)\\n      {\\n\\n        break;\\n      }\\n      else\\n      {\\n        k = k + 1;\\n      }\\n    }\\n\\n    // finding zeros and immediate non-zero elements and swapping them\\n    int i = k, j = k + 1;\\n\\n    while (i < n && j < n)\\n    {\\n      if (nums[j] != 0)\\n      {\\n        int temp = nums[i];\\n        nums[i] = nums[j];\\n        nums[j] = temp;\\n        i++;\\n      }\\n\\n      j++;\\n    }\\n  }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Java",
                    "Array",
                    "Two Pointers"
                ],
                "code": "```\\nclass Solution\\n{\\npublic:\\n  void moveZeroes(vector<int> &nums)\\n  {\\n    // finding first zero occurrence\\n    int k = 0;\\n    int n = nums.size();\\n    while (k < n)\\n    {\\n      if (nums[k] == 0)\\n      {\\n\\n        break;\\n      }\\n      else\\n      {\\n        k = k + 1;\\n      }\\n    }\\n\\n    // finding zeros and immediate non-zero elements and swapping them\\n    int i = k, j = k + 1;\\n\\n    while (i < n && j < n)\\n    {\\n      if (nums[j] != 0)\\n      {\\n        int temp = nums[i];\\n        nums[i] = nums[j];\\n        nums[j] = temp;\\n        i++;\\n      }\\n\\n      j++;\\n    }\\n  }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3278867,
                "title": "c-solution-with-follow-up-question",
                "content": "# Intuition\\n- when find non-zero element, move it forward until all its previous are non-zero\\n- searching from front to back, to ensure that its previous is non-zero denotes all its previous are non-zero\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# \\uD83C\\uDF40 Approach 1\\n- use for loop to find non-zero\\n- swap it forward one by one until hit the front or its previous is non-zero\\n- example: (0-indexed)\\n  - array: 0 ***0*** ***1*** 2\\n  - `swap(array[1], array[2]);`\\n  - array: ***0*** ***1*** 0 2\\n  - `swap(array[0], array[1]);`\\n  - array: 1 0 ***0*** ***2***\\n  - `swap(array[2], array[3]);`\\n  - array: 1 ***0*** ***2*** 0\\n  - `swap(array[1], array[2]);`\\n  - array: 1 2 0 0\\n  - done\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity: $$O(n^2)$$\\n    - one worst case is: $$[0, ... 0,1,...,n/2]$$, which totally do swap $$n^2/4$$ times\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: $$O(1)$$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code 1\\n```\\nvoid swap(int* a, int* b)\\n{\\n  int t = *a;\\n  *a = *b;\\n  *b = t;\\n}\\n\\nvoid moveZeroes(int* nums, int numsSize){\\n  for (size_t i = 0; i < numsSize; i++)\\n  {\\n    if (nums[i] != 0)\\n    {\\n      int j = i;\\n      while(j - 1 >= 0 && nums[j - 1] == 0)\\n      {\\n        swap(&nums[j - 1], &nums[j]);\\n        j--;\\n      }\\n    }\\n  }\\n}\\n```\\n\\n# \\uD83E\\uDD14\\uD83D\\uDCAD Follow up: Could you minimize the total number of operations done?\\n# \\uD83C\\uDF40 Approach 2\\n- use a index indicator `head_of_zeros` to store the swap place for non-zero\\n- use for loop to find non-zero\\n- swap it with `head_of_zeros`, then adjust `head_of_zeros`\\n- example: (0-indexed)\\n  - array: 1 ***0*** ***2*** 0 3 0 0 4\\n  - `swap(array[1], array[2]);`\\n  - array: 1 2 ***0*** 0 ***3*** 0 0 4\\n  - `swap(array[2], array[6]);`\\n  - array: 1 2 3 ***0*** 0 0 0 ***4***\\n  - `swap(array[3], array[7]);`\\n  - array: 1 2 3 4 0 0 0 0\\n  - done\\n- therefore, every swap operation does swap the number to the correct place \\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity: $$O(n)$$ , also improved time complexity\\n<!-- - , because `i` and `head_of_zeros` only move in one direction -->\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: $$O(1)$$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code 2\\n```\\nvoid swap(int* a, int* b)\\n{\\n  int t = *a;\\n  *a = *b;\\n  *b = t;\\n}\\n\\nvoid moveZeroes(int* nums, int numsSize){\\n  int head_of_zeros = 0;\\n  bool has_zero = false;\\n  for (size_t i = 0; i < numsSize; i++)\\n  {\\n    if (nums[i] != 0 && has_zero)\\n    {\\n      swap(&nums[i], &nums[head_of_zeros]);\\n      head_of_zeros += 1;\\n    }\\n    else if (nums[i] == 0 && !has_zero)\\n    {\\n      has_zero = true;\\n      head_of_zeros = i;\\n    }\\n  }\\n}\\n```\\n\\n![IMG_8144.jpeg](https://assets.leetcode.com/users/images/03173c2d-79c7-45f8-b43f-e2a45b6ba62e_1678681409.229773.jpeg)\\nPlease upvote, thank you OwO\\n",
                "solutionTags": [
                    "C",
                    "Array",
                    "Two Pointers"
                ],
                "code": "```\\nvoid swap(int* a, int* b)\\n{\\n  int t = *a;\\n  *a = *b;\\n  *b = t;\\n}\\n\\nvoid moveZeroes(int* nums, int numsSize){\\n  for (size_t i = 0; i < numsSize; i++)\\n  {\\n    if (nums[i] != 0)\\n    {\\n      int j = i;\\n      while(j - 1 >= 0 && nums[j - 1] == 0)\\n      {\\n        swap(&nums[j - 1], &nums[j]);\\n        j--;\\n      }\\n    }\\n  }\\n}\\n```\n```\\nvoid swap(int* a, int* b)\\n{\\n  int t = *a;\\n  *a = *b;\\n  *b = t;\\n}\\n\\nvoid moveZeroes(int* nums, int numsSize){\\n  int head_of_zeros = 0;\\n  bool has_zero = false;\\n  for (size_t i = 0; i < numsSize; i++)\\n  {\\n    if (nums[i] != 0 && has_zero)\\n    {\\n      swap(&nums[i], &nums[head_of_zeros]);\\n      head_of_zeros += 1;\\n    }\\n    else if (nums[i] == 0 && !has_zero)\\n    {\\n      has_zero = true;\\n      head_of_zeros = i;\\n    }\\n  }\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2968449,
                "title": "my-cpp-easy-solution",
                "content": "\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    void moveZeroes(vector<int>& nums) {\\n       int i = 0;\\n       for(int j = 0; j<nums.size(); j++)\\n       {\\n           if(nums[j]!=0)\\n           {\\n                 swap(nums[j] , nums[i]);\\n                 i++;\\n           }\\n       }\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    void moveZeroes(vector<int>& nums) {\\n       int i = 0;\\n       for(int j = 0; j<nums.size(); j++)\\n       {\\n           if(nums[j]!=0)\\n           {\\n                 swap(nums[j] , nums[i]);\\n                 i++;\\n           }\\n       }\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2736256,
                "title": "simple-java-solution-87",
                "content": "```\\n\\nclass Solution {\\n    public void moveZeroes(int[] arr) {\\n            int count = 0;  \\n \\n        for (int i = 0; i < arr.length; i++){\\n            if (arr[i] != 0)\\n                arr[count++] = arr[i]; \\n        }\\n \\n      \\n        while (count < arr.length)\\n            arr[count++] = 0;\\n    \\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\n\\nclass Solution {\\n    public void moveZeroes(int[] arr) {\\n            int count = 0;  \\n \\n        for (int i = 0; i < arr.length; i++){\\n            if (arr[i] != 0)\\n                arr[count++] = arr[i]; \\n        }\\n \\n      \\n        while (count < arr.length)\\n            arr[count++] = 0;\\n    \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2674777,
                "title": "c-simple-solution-easy-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    void moveZeroes(vector<int>& nums) {\\n        int i=0;\\n        for(int j=0; j<nums.size(); j++)\\n        {\\n            if(nums[j] != 0)\\n            {\\n                swap(nums[i],nums[j]);\\n                i++;\\n            }\\n        }\\n        \\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Array",
                    "Two Pointers"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    void moveZeroes(vector<int>& nums) {\\n        int i=0;\\n        for(int j=0; j<nums.size(); j++)\\n        {\\n            if(nums[j] != 0)\\n            {\\n                swap(nums[i],nums[j]);\\n                i++;\\n            }\\n        }\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2086532,
                "title": "move-zeros-python-solution",
                "content": "```\\nclass Solution:\\n    def moveZeroes(self, nums: List[int]) -> None:\\n        for i in nums:\\n            if i==0:\\n                nums.remove(i)\\n                nums.append(0)\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def moveZeroes(self, nums: List[int]) -> None:\\n        for i in nums:\\n            if i==0:\\n                nums.remove(i)\\n                nums.append(0)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1668209,
                "title": "easy-approach-solution-o-n",
                "content": "```\\nclass Solution {\\npublic:\\n    void moveZeroes(vector<int>& nums) {\\n        int i=0;\\n        for(int j=0;j<nums.size();j++){\\n            if(nums[j]!=0)\\n            {\\n                swap(nums[j],nums[i]);\\n                i++;\\n            }\\n        }\\n        \\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    void moveZeroes(vector<int>& nums) {\\n        int i=0;\\n        for(int j=0;j<nums.size();j++){\\n            if(nums[j]!=0)\\n            {\\n                swap(nums[j],nums[i]);\\n                i++;\\n            }\\n        }\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1638418,
                "title": "java-easy-solution-step-by-step-two-detailed-and-explained-cases-using-two-pointer-approach",
                "content": "**Guys here I am goinng to explain the whole thing considering two following cases:**\\n\\n# **CASE I: When Relative order of non-zero elements need not to be maintained**\\n\\nSTEP 1: Take Two pointers **Start** and **End** for first index and the last index of the array\\nSTEP 2: If the element at Start is 0  swap  it with the value at  end and increment the **start** and decrement the **end**\\nSTEP 3: If the element is not 0; increase the **start**\\n\\nThe code for above approach is given below;\\n```\\n public void moveZeroes(int[] nums) {\\n        \\n    int start=0;\\n    int end=nums.length-1;\\n\\n        while (start<end)\\n        {\\n            if (nums[start]==0)\\n            {\\n                int temp=nums[start];\\n                nums[start]=nums[end];\\n                nums[end]=temp;\\n                start++;\\n                end--;\\n            }\\n            else\\n            {\\n                start++;\\n            }\\n\\n        }\\n       \\n    }\\n```\\n\\nHere for input **nums=[0,1,0,3,12];**\\n**output=[12,1,3,0,0];**\\n\\nAll the zeroes have been pushed at the end but the relative order of non-zero elements are not maintained.\\n\\nNOW lets see How can we maintain the relative order while pushing the zeroes at end\\n\\n# **CASE II: When Relative order of non-zero elements need to be maintained**\\nSTEP 1: Take two pointers **i** and **j** set them to zero\\nSTEP 2: If element at index **i** is not zero; Swap it with element at **j** and increase **j**\\nSTEP 3: increase index **i** for both situation ......swapping occurs or not **I** will increase\\n\\n**The code for the above approach is given below:**\\n```\\n public void moveZeroes(int[] nums) {\\n        \\n    int i=0;\\n    int j=0;\\n    while (i<nums.length)\\n    {\\n        if (nums[i]!=0)\\n        {\\n            int temp=nums[i];\\n            nums[i]=nums[j];\\n            nums[j]=temp;\\n            j++;\\n        }\\n        i++;\\n    }\\n       \\n    }\\n```\\n\\n\\n\\nLet me explain with an example input **nums=[0,1,0,3,12]**\\n\\nstart with **i=0** and **j=0**; **n=nums.length=5**\\n\\n**nums[i]=0** and **nums[j]=0**\\n\\n  **nums[i]** and **nums[j]** both are 0 , so the condition is false for if statement so our **i** will increase and **j** remains at 0.\\n  \\n```\\n  Now i=1 and j=0  ; nums[i]=1  and nums[j]=0\\n  so nums[i]!=0 so now **SWAPPING** occurs and array becomes nums=[1,0,0,3,12] ; \\n  j is incremented to 1 and i is incremented to 2.\\n```\\n  \\n  Now **i=2** and **j=1**  ; **nums[i]=0**  and **nums[j]=0**\\n   so **nums[i]!=0** condition is false; no swapping occurs and **i** is increased to 3\\n   \\n   \\n     Now i=3 and j=1  ; nums[i]=3  and nums[j]=0\\n\\t  so nums[i]!=0 so now **SWAPPING** occurs and array becomes nums=[1,3,0,0,12] ;          \\n\\t  j is incremented to 2 and i is incremented to 4.\\n\\t  \\n\\t  ``  Now i=4 and j=2  ; nums[i]=12  and nums[j]=0\\n\\t  so nums[i]!=0 so now **SWAPPING** occurs and array becomes nums=[1,3,12,0,0] ;          \\n\\t  j is incremented to 3 and i is incremented to 5.\\n\\t  \\n\\t  now  i is not less than nums.length \\n\\t  Therefore no more iteration takes place and we have our sorted array.\\n\\n\\n\\nI HOPE  YOU LIKE IT.\\n\\nI SHALL BE THANKFULL TO THE RESPONSES AND UPVOTES....\\n\\n**#MY FIRST SOLUTION SUBMISSION**\\n\\nDO SUPPORT GUYS !! \\n\\n",
                "solutionTags": [
                    "Java",
                    "Two Pointers"
                ],
                "code": "```\\n public void moveZeroes(int[] nums) {\\n        \\n    int start=0;\\n    int end=nums.length-1;\\n\\n        while (start<end)\\n        {\\n            if (nums[start]==0)\\n            {\\n                int temp=nums[start];\\n                nums[start]=nums[end];\\n                nums[end]=temp;\\n                start++;\\n                end--;\\n            }\\n            else\\n            {\\n                start++;\\n            }\\n\\n        }\\n       \\n    }\\n```\n```\\n public void moveZeroes(int[] nums) {\\n        \\n    int i=0;\\n    int j=0;\\n    while (i<nums.length)\\n    {\\n        if (nums[i]!=0)\\n        {\\n            int temp=nums[i];\\n            nums[i]=nums[j];\\n            nums[j]=temp;\\n            j++;\\n        }\\n        i++;\\n    }\\n       \\n    }\\n```\n```\\n  Now i=1 and j=0  ; nums[i]=1  and nums[j]=0\\n  so nums[i]!=0 so now **SWAPPING** occurs and array becomes nums=[1,0,0,3,12] ; \\n  j is incremented to 1 and i is incremented to 2.\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1613027,
                "title": "two-pointer-approach-with-explaination-java-code",
                "content": "Time Complexity => O(N)\\nSpace Complexity => O(1)\\n```\\nclass Solution {\\n    public void moveZeroes(int[] nums) {\\n        int n = nums.length;\\n        \\n        if(n == 0 || n == 1)\\n            return;\\n        \\n        // Two Pointer Approach\\n        int left = 0; \\n        int right = 0;\\n        \\n        // for swap\\n        int temp;\\n        \\n        // Rearrangement\\n        while(right < n){\\n            // when ever right pointer see zero value it get incremented\\n            if(nums[right]==0)\\n                ++right;\\n            else {\\n                // when it see non-zero element it swap with left pointer value and then increment both right and left pointer\\n                \\n                //swap\\n                temp = nums[left];\\n                nums[left] = nums[right];\\n                nums[right] = temp;\\n                ++left;\\n                ++right;\\n            }\\n        }\\n    }\\n}\\n```\\n\\n**If you guys find it useful do upvote the solution**",
                "solutionTags": [
                    "Java",
                    "Two Pointers"
                ],
                "code": "```\\nclass Solution {\\n    public void moveZeroes(int[] nums) {\\n        int n = nums.length;\\n        \\n        if(n == 0 || n == 1)\\n            return;\\n        \\n        // Two Pointer Approach\\n        int left = 0; \\n        int right = 0;\\n        \\n        // for swap\\n        int temp;\\n        \\n        // Rearrangement\\n        while(right < n){\\n            // when ever right pointer see zero value it get incremented\\n            if(nums[right]==0)\\n                ++right;\\n            else {\\n                // when it see non-zero element it swap with left pointer value and then increment both right and left pointer\\n                \\n                //swap\\n                temp = nums[left];\\n                nums[left] = nums[right];\\n                nums[right] = temp;\\n                ++left;\\n                ++right;\\n            }\\n        }\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1464914,
                "title": "c-easy-solution-100-faster",
                "content": "```\\n// PLEASE UPVOTE IF YOU LIKE\\nclass Solution {\\npublic:\\n    void moveZeroes(vector<int>& nums) {\\n  int n=nums.size();\\n    int j=1;\\n        int i=0;\\n        while(i<n && j<n)\\n        {\\n                if(nums[i]==0 && nums[j]==0)\\n                {\\n                         j++;\\n                        continue;\\n                }\\n                else if(nums[i]==0 && nums[j]!=0)\\n                        swap(nums[i],nums[j]);\\n                i++;\\n                j++;\\n        }\\n        \\n \\n    }\\n};\\n\\n",
                "solutionTags": [],
                "code": "class Solution {\\npublic:\\n    void moveZeroes(vector<int>& nums) {\\n  int n=nums.size();\\n    int j=1;\\n        int i=0;\\n        while(i<n && j<n)\\n        {\\n                if(nums[i]==0 && nums[j]==0)\\n                {\\n                         j++;\\n                        continue;\\n                }",
                "codeTag": "Java"
            },
            {
                "id": 1391669,
                "title": "simple-c-o-n-solution-o-1-space-two-pointers",
                "content": "The idea I used is simple, i used z and j two pointers where z is to keep track of zeroes and j for swapping any non-zero element with the zeroes.\\n* if nums[z] = 0 and nums[j] is not 0 then we swap these two elements and increment accordingly.\\n* if nums[z] is not 0 then we just increment z so that we get to some index where the element is 0.\\n* otherwise we increment only j as in this case nums[z] will contain 0, with j we try to find the next non-zero number.\\n\\n```\\nExample:\\n0 1 0 3 12\\nz j\\nswap 0 and 1\\n\\n1 0 0 3 12\\n  z j\\nincrement j\\n\\n1 0 0 3 12\\n  z   j \\nswap 0 and 3\\n\\n1 3 0 0 12\\n    z    j\\nswap 0 and 12\\n\\n1 3 12 0 0\\n```\\n\\nCode Implementation:\\n\\n```\\nvoid moveZeroes(vector<int>& nums) {\\n        int n = nums.size();\\n        if(n<=1)return;\\n        int z = 0;\\n        int j = 1;\\n        while(j < n){\\n            if(nums[z] == 0 && nums[j]!=0){\\n                swap(nums[z],nums[j]);\\n                z++;               \\n            }\\n            if(nums[z]!=0)z++;\\n             j++;\\n        }\\n    }\\n```",
                "solutionTags": [
                    "C",
                    "Two Pointers"
                ],
                "code": "```\\nExample:\\n0 1 0 3 12\\nz j\\nswap 0 and 1\\n\\n1 0 0 3 12\\n  z j\\nincrement j\\n\\n1 0 0 3 12\\n  z   j \\nswap 0 and 3\\n\\n1 3 0 0 12\\n    z    j\\nswap 0 and 12\\n\\n1 3 12 0 0\\n```\n```\\nvoid moveZeroes(vector<int>& nums) {\\n        int n = nums.size();\\n        if(n<=1)return;\\n        int z = 0;\\n        int j = 1;\\n        while(j < n){\\n            if(nums[z] == 0 && nums[j]!=0){\\n                swap(nums[z],nums[j]);\\n                z++;               \\n            }\\n            if(nums[z]!=0)z++;\\n             j++;\\n        }\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1284557,
                "title": "clean-java-solution-single-traversal-100-faster",
                "content": "**Please *Upvote* if you like the Solution**\\n```\\nclass Solution {\\n    public void moveZeroes(int[] nums) {\\n        \\n        int count=0;\\n        for(int i=0;i<nums.length;i++){\\n            \\n            if(nums[i]!=0){\\n                int temp=nums[i];\\n                nums[i]=nums[count];\\n                nums[count]=temp;\\n                count++;\\n            }\\n        }\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public void moveZeroes(int[] nums) {\\n        \\n        int count=0;\\n        for(int i=0;i<nums.length;i++){\\n            \\n            if(nums[i]!=0){\\n                int temp=nums[i];\\n                nums[i]=nums[count];\\n                nums[count]=temp;\\n                count++;\\n            }\\n        }\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1145778,
                "title": "javascript",
                "content": "```\\nvar moveZeroes = function(nums) {\\n    let index = 0;\\n    for (let i = 0; i < nums.length; i ++) {\\n        if (nums[i] !== 0) {\\n            nums[index++] = nums[i]\\n        }\\n    }\\n    for (let i = index; i < nums.length; i++) {\\n        nums[i] = 0\\n    }\\n};",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\nvar moveZeroes = function(nums) {\\n    let index = 0;\\n    for (let i = 0; i < nums.length; i ++) {\\n        if (nums[i] !== 0) {\\n            nums[index++] = nums[i]\\n        }\\n    }\\n    for (let i = index; i < nums.length; i++) {\\n        nums[i] = 0\\n    }\\n};",
                "codeTag": "Unknown"
            },
            {
                "id": 563027,
                "title": "java-code-in-a-single-loop-time-complexity-o-n-100",
                "content": "Just pushing non-zero numbers to the front and replacing their index with 0\\n```\\n    public void moveZeroes(int[] nums) {\\n        for(int i=0, ci=0; i < nums.length ; i++){\\n            if(nums[i] != 0){\\n                if(ci != i){\\n                    nums[ci] = nums[i];\\n                    nums[i] = 0;\\n                }\\n                ci++;\\n            }\\n        }\\n    }\\n\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\n    public void moveZeroes(int[] nums) {\\n        for(int i=0, ci=0; i < nums.length ; i++){\\n            if(nums[i] != 0){\\n                if(ci != i){\\n                    nums[ci] = nums[i];\\n                    nums[i] = 0;\\n                }\\n                ci++;\\n            }\\n        }\\n    }\\n\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 555876,
                "title": "python-two-pointer-solution-beats-97-45",
                "content": "```\\nclass Solution:\\n    def moveZeroes(self, nums: List[int]) -> None:\\n        \"\"\"\\n        Do not return anything, modify nums in-place instead.\\n        \"\"\"\\n        i = 0\\n        j = 1\\n        \\n        while j < len(nums):\\n            if nums[i] == nums[j] and nums[i] == 0:\\n                j += 1\\n                continue\\n            \\n            if nums[i] == 0 and nums[j] != 0:\\n                # swap elements\\n                temp = nums[j]\\n                nums[j] = nums[i]\\n                nums[i] = temp\\n            \\n            i += 1\\n            j += 1\\n```",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Two Pointers"
                ],
                "code": "```\\nclass Solution:\\n    def moveZeroes(self, nums: List[int]) -> None:\\n        \"\"\"\\n        Do not return anything, modify nums in-place instead.\\n        \"\"\"\\n        i = 0\\n        j = 1\\n        \\n        while j < len(nums):\\n            if nums[i] == nums[j] and nums[i] == 0:\\n                j += 1\\n                continue\\n            \\n            if nums[i] == 0 and nums[j] != 0:\\n                # swap elements\\n                temp = nums[j]\\n                nums[j] = nums[i]\\n                nums[i] = temp\\n            \\n            i += 1\\n            j += 1\\n```",
                "codeTag": "Java"
            },
            {
                "id": 521275,
                "title": "rust-solution",
                "content": "```rust\\nimpl Solution {\\n    pub fn move_zeroes(nums: &mut Vec<i32>) {\\n        let mut i = 0;\\n        for j in 0..nums.len() {\\n            if nums[j] != 0 {\\n                nums.swap(i, j);\\n                i += 1;\\n            }\\n        }\\n    }\\n}\\n```",
                "solutionTags": [
                    "Rust"
                ],
                "code": "```rust\\nimpl Solution {\\n    pub fn move_zeroes(nums: &mut Vec<i32>) {\\n        let mut i = 0;\\n        for j in 0..nums.len() {\\n            if nums[j] != 0 {\\n                nums.swap(i, j);\\n                i += 1;\\n            }\\n        }\\n    }\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 467919,
                "title": "simple-javascript-solution",
                "content": "```javascript\\nvar moveZeroes = function(nums) {\\n    let count = 0;\\n    for(let i = 0; i < nums.length; i++){\\n        if(nums[i] != 0){\\n            nums[count++] = nums[i];\\n        }\\n    }\\n    for(let i = count; i < nums.length; i++){\\n        nums[i] = 0;\\n    }\\n    return nums;\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```javascript\\nvar moveZeroes = function(nums) {\\n    let count = 0;\\n    for(let i = 0; i < nums.length; i++){\\n        if(nums[i] != 0){\\n            nums[count++] = nums[i];\\n        }\\n    }\\n    for(let i = count; i < nums.length; i++){\\n        nums[i] = 0;\\n    }\\n    return nums;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 155841,
                "title": "python-use-sort",
                "content": "# Use sort to solve this problem\\n## Code\\n```python\\ndef move_zeroes(self, nums):\\n    nums.sort(key=lambda n: n == 0)\\n```\\n\\n## Explain\\n1. Python lists have a built-in `list.sort()` method that modifies the list in-place.\\n2. The key parameter to specify  `lambda n: n == 0` called on each num in nums prior to making comparisons\\n3. So all zero will be sort to the right, none zero will keep in origin order",
                "solutionTags": [],
                "code": "```python\\ndef move_zeroes(self, nums):\\n    nums.sort(key=lambda n: n == 0)\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 72394,
                "title": "javascript-solution-if-anyone-is-interested",
                "content": "    var moveZeroes = function(nums) {\\n        var temp = null;\\n        var j = 0;\\n        for(var i=0; i < nums.length; i++) {\\n            if (nums[i] !== 0) {\\n                temp = nums[j];\\n                nums[j] = nums[i];\\n                nums[i] = temp;\\n                j++;\\n            }\\n        }\\n    };",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "    var moveZeroes = function(nums) {\\n        var temp = null;\\n        var j = 0;\\n        for(var i=0; i < nums.length; i++) {\\n            if (nums[i] !== 0) {\\n                temp = nums[j];\\n                nums[j] = nums[i];\\n                nums[i] = temp;\\n                j++;\\n            }\\n        }\\n    };",
                "codeTag": "Unknown"
            },
            {
                "id": 3758272,
                "title": "python-easy-solution",
                "content": "# Complexity\\n- Time complexity:\\nO(n)\\n\\n- Space complexity:\\nO(1)\\n\\n# Code\\n```\\nclass Solution:\\n    def moveZeroes(self, nums: List[int]) -> None:\\n        \"\"\"\\n        Do not return anything, modify nums in-place instead.\\n        \"\"\"\\n        i=0\\n        while(i<len(nums)):\\n            if nums[i]==0:\\n                nums.append(0)\\n                nums.remove(0)\\n            i+=1\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def moveZeroes(self, nums: List[int]) -> None:\\n        \"\"\"\\n        Do not return anything, modify nums in-place instead.\\n        \"\"\"\\n        i=0\\n        while(i<len(nums)):\\n            if nums[i]==0:\\n                nums.append(0)\\n                nums.remove(0)\\n            i+=1\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3523618,
                "title": "java-solution-for-move-zeroes-problem",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nThe goal of this solution is to move all the zeroes in the input array nums to the end of the array while maintaining the relative order of the non-zero elements\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n1. Initialize a variable m to -1, which will keep track of the position of the first zero encountered.\\n2. Traverse the array nums from left to right: a. If the current element is zero, and m is -1 or the element at position m is non-zero, set m to the current index. b. If the current element is non-zero and m is not -1, swap the current element with the element at position m and increment m.\\n3. After the traversal, all the zeroes will be at the end of the array, and the relative order of the non-zero elements will be maintained.\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n O(n), where n is the length of the input array nums. The algorithm iterates through the array once\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nO(1), as the algorithm only uses a constant amount of extra space to store the variable m and the temporary variable temp used for swapping elements.\\n\\n# Code\\n```\\nclass Solution {\\n    public void moveZeroes(int[] nums) {\\n        int m=-1;\\n        for(int i=0; i<nums.length; i++)\\n        {\\n            if(nums[i]==0)\\n            {\\n                if(m==-1 || nums[m]!=0)\\n                {\\n                    m=i;\\n                }\\n            }\\n            else\\n            {\\n                if(m!=-1)\\n                {\\n                    int temp = nums[i];\\n                    nums[i]=nums[m];\\n                    nums[m]=temp;\\n                    m++;\\n                }\\n            }\\n        }\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public void moveZeroes(int[] nums) {\\n        int m=-1;\\n        for(int i=0; i<nums.length; i++)\\n        {\\n            if(nums[i]==0)\\n            {\\n                if(m==-1 || nums[m]!=0)\\n                {\\n                    m=i;\\n                }\\n            }\\n            else\\n            {\\n                if(m!=-1)\\n                {\\n                    int temp = nums[i];\\n                    nums[i]=nums[m];\\n                    nums[m]=temp;\\n                    m++;\\n                }\\n            }\\n        }\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3444972,
                "title": "python-5-lines-two-pointers",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nWe need to use pointers to move our zeros to the very end somehow by using the same datastructure and minimize the steps and time complexity of the algorithm. \\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nWe can utilize a two-pointer approach to solve this problem. The first pointer tracks the position of the last encountered non-zero element (initialized to zero), while the second pointer traverses the list. When we come across a non-zero element, we swap it with the element at the position indicated by the first pointer, and then increment the first pointer. This process ensures that all non-zero elements are shifted to the front of the array, while preserving their relative order. Finally, we fill the remaining elements with zeros.\\n\\nIf you find this helpful, please consider liking this post. I\\'ll continue to share more solutions like this. Should you have any questions, feel free to comment below, and I\\'ll respond as promptly as possible.\\n\\n\\n# Complexity\\n- Time complexity:\\nO(n)\\nWe are traversing the entire list at worst case, so this is why our time is big o of n. n being the numbers of elements in our list. \\n- Space complexity:\\nO(1)\\nsince we are updating the same list we are not using any extra space. \\n\\n# Code\\n```\\nclass Solution:\\n    def moveZeroes(self, nums: List[int]) -> None:\\n        \"\"\"\\n        Do not return anything, modify nums in-place instead.\\n        \"\"\"\\n        zero_pos = 0\\n        for i in range(len(nums)):\\n            if nums[i] != 0:\\n                nums[i], nums[zero_pos] = nums[zero_pos], nums[i]\\n                zero_pos += 1   \\n\\n\\n\\n            \\n\\n    \\n                \\n\\n\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def moveZeroes(self, nums: List[int]) -> None:\\n        \"\"\"\\n        Do not return anything, modify nums in-place instead.\\n        \"\"\"\\n        zero_pos = 0\\n        for i in range(len(nums)):\\n            if nums[i] != 0:\\n                nums[i], nums[zero_pos] = nums[zero_pos], nums[i]\\n                zero_pos += 1   \\n\\n\\n\\n            \\n\\n    \\n                \\n\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3354283,
                "title": "c-code-best-in-market",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    void moveZeroes(vector<int>& nums) {\\n        int lastzero=0;\\n        for(int i=0;i<nums.size();i++){\\n            if(nums[i]!=0){\\n                nums[lastzero]=nums[i];\\n                lastzero++;\\n            }\\n        }\\n        for(int i=lastzero;i<nums.size();i++){\\n            nums[i]=0;\\n        }   \\n       \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    void moveZeroes(vector<int>& nums) {\\n        int lastzero=0;\\n        for(int i=0;i<nums.size();i++){\\n            if(nums[i]!=0){\\n                nums[lastzero]=nums[i];\\n                lastzero++;\\n            }\\n        }\\n        for(int i=lastzero;i<nums.size();i++){\\n            nums[i]=0;\\n        }   \\n       \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3048350,
                "title": "java-solution-beats-100-constant-space-in-place-swap",
                "content": "# Approach \\n    In-place swap  \\n\\n    Only target Non-Zero element, Zero automaticaly arranged by its\\n    correct position;\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:O(n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    private void swap(int[] arr,int i,int j){\\n        int temp = arr[i];\\n        arr[i] = arr[j];\\n        arr[j] = temp;\\n    }\\n    public void moveZeroes(int[] nums) {\\n        int k = 0;\\n        int n = nums.length;\\n        for(int i=0;i<n;i++){\\n            if(nums[i] != 0){\\n                swap(nums,i,k++);\\n            }\\n        }\\n    }\\n}\\n```\\n\\n# Happy Coding \\uD83D\\uDC96\\n* Upvote if you like it",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    private void swap(int[] arr,int i,int j){\\n        int temp = arr[i];\\n        arr[i] = arr[j];\\n        arr[j] = temp;\\n    }\\n    public void moveZeroes(int[] nums) {\\n        int k = 0;\\n        int n = nums.length;\\n        for(int i=0;i<n;i++){\\n            if(nums[i] != 0){\\n                swap(nums,i,k++);\\n            }\\n        }\\n    }\\n}\\n```",
                "codeTag": "Java"
            }
        ],
        "discussions": [
            {
                "id": 1838268,
                "content": [
                    {
                        "username": "Nisha1205092",
                        "content": "it\\'s sad that I look for hints or ideas, but people just directly post codes here too!!! Whereas there\\'s a \\'solution\\' section separately. "
                    },
                    {
                        "username": "muhammedirshadismail0722",
                        "content": "\\n\\nEasiest \\uD83D\\uDE0E FAANG Method Ever !!! \\uD83D\\uDCA5||Best solution in python\\n\\n\\nhttps://leetcode.com/problems/move-zeroes/solutions/3923521/easiest-faang-method-ever-best-solution-in-python/"
                    },
                    {
                        "username": "aleazanrashid",
                        "content": "Let people discuss their issues with their solution "
                    },
                    {
                        "username": "mariusandries25",
                        "content": "It literally says not to post solutions in the discussion. This section is for tips and questions."
                    },
                    {
                        "username": "VladimirTheLeet",
                        "content": "I guess the rules don\\'t work for you if you can\\'t read \\xAF\\\\\\\\\\\\_(\\u30C4)_/\\xAF"
                    },
                    {
                        "username": "jerryy147",
                        "content": "all 3 rules say not to post a solution here in some form"
                    },
                    {
                        "username": "DoMonkeysFly7",
                        "content": "ppl are idiots frate, they wanna show how 'smart' they are"
                    },
                    {
                        "username": "mdegis",
                        "content": "I really do not understand how accepted solutions distribution works or measured for the solution.  I\\'ve basically submit the same solution 4 minutes apart, first one runtime was 491 ms and beat 25.21%... second one was 340 ms and beat 55.81%. Again, they are the same code! Nothing changed, not even an empty space. Just click \"submit\" button again. \\n\\nShould I stop caring about this number if there is no consistency at all?"
                    },
                    {
                        "username": "arc-arnob",
                        "content": "true and more over implicit declaration faster than explicit datatype declaration in typescript. "
                    },
                    {
                        "username": "bernardoolisan",
                        "content": "Is bc the leetcode server that runs your code might sometimes run faster or slower, is a compiler in a server. And yes, you should care about the percentage even if sometimes is not accurate, it gives you a approximation of how efficient is your code "
                    },
                    {
                        "username": "Priyamd",
                        "content": "i guess its a glitch "
                    },
                    {
                        "username": "potatopie",
                        "content": "its literally always the indians that post the solutions what concept of DISCUSSION do you guys not understand? "
                    },
                    {
                        "username": "AryanP45",
                        "content": "[@nKR5](/nKR5) Always fun reading these stereotypical comments"
                    },
                    {
                        "username": "nKR5",
                        "content": "Strong in programming language, weak in human communication language."
                    },
                    {
                        "username": "shubhamsharma123",
                        "content": " // striver solution\\n  int k=0;\\n        for(int i=0;i<nums.size();i++){\\n            if(nums[i]!=0){\\n            int temp=nums[k];\\n            nums[k]=nums[i];\\n            nums[i]= temp;\\n              k++;\\n            }\\n        }\\n        }"
                    },
                    {
                        "username": "vivekup3424",
                        "content": "Bro why you want hate by posting solution here, are you some kinda masochist."
                    },
                    {
                        "username": "swand0g",
                        "content": "nice job posting the solution in the one place leetcode specifies not to post solutions!"
                    },
                    {
                        "username": "neel19",
                        "content": "[@luan_hy](/luan_hy)  The instructor here (striver) has a very strong background in competitive programming. That\\'s how he can come up with such elegant solution. You can check out his tutorials on youtube. "
                    },
                    {
                        "username": "mariusandries25",
                        "content": "[@luan_hy](/luan_hy) The non-zero values are moved in front of array, the k variable keeping track of the moved values non-zero. Zeroes are implicit moving behind when swapping the non-zero. Then when encountering zero do nothing."
                    },
                    {
                        "username": "luan_hy",
                        "content": "Can you share what is your problem-solving step to come out with a so simple solution? "
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# Easiest \\uD83D\\uDE0E FAANG Method Ever !!! \\uD83D\\uDCA5 \\n\\nhttps://leetcode.com/problems/move-zeroes/solutions/2872504/easiest-faang-method-ever/?orderBy=most_votes"
                    },
                    {
                        "username": "atak",
                        "content": "\\t\\tzero_size = nums.count(0)\\n\\t\\tnums.delete(0)\\n\\t\\tnums = (nums + ([0] * zero_size ))"
                    },
                    {
                        "username": "muhammedirshadismail0722",
                        "content": "\\n\\nEasiest \\uD83D\\uDE0E FAANG Method Ever !!! \\uD83D\\uDCA5||Best solution in python\\n\\n\\nhttps://leetcode.com/problems/move-zeroes/solutions/3923521/easiest-faang-method-ever-best-solution-in-python/"
                    },
                    {
                        "username": "michaelknight492",
                        "content": "\"Note that you must do this in-place without making a copy of the array.\"\\n\\nI believe \"nums = (nums + ([0] * zero_size ))\" is  making a copy of the array"
                    },
                    {
                        "username": "saichandra004",
                        "content": "Cannot modify nums."
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# Easiest \\uD83D\\uDE0E FAANG Method Ever !!! \\uD83D\\uDCA5 \\n\\nhttps://leetcode.com/problems/move-zeroes/solutions/2872504/easiest-faang-method-ever/?orderBy=most_votes"
                    },
                    {
                        "username": "lanyiyun",
                        "content": "'''\\ndef moveZeroes(self, nums):\\n\\n        for i in range(nums.count(0)):\\n            nums.remove(0)\\n            nums.append(0)\\n'''"
                    },
                    {
                        "username": "starogre",
                        "content": "this doesn\\'t count. this creates a new list in memory. the challenge is to do it in-place"
                    },
                    {
                        "username": "saichandra004",
                        "content": "Cannot modify nums."
                    },
                    {
                        "username": "sainath81061",
                        "content": "public void MoveZeroes(int[] nums) {\\n        int i,count = 0;\\n        for(i=0;i<nums.Length;i++){\\n            if(nums[i] != 0){\\n                nums[count] = nums[i];\\n                count++;\\n            }\\n        }\\n        for(;count<nums.Length;count++){\\n            nums[count] = 0;\\n        }\\n        foreach(var x in nums){\\n            Console.WriteLine(x);\\n        }\\n    }"
                    },
                    {
                        "username": "LanceofLonginius",
                        "content": "do not post solutions here"
                    },
                    {
                        "username": "Kokopas",
                        "content": "Why this solution is not working,?\nI checked in on local interpreter and it works\n\nclass Solution:\n    def moveZeroes(self, nums) -> None:\n        \"\"\"\n        Do not return anything, modify nums in-place instead.\n        \"\"\"\n        zero_amount = nums.count(0)\n        zero_list=[]\n        n=0\n        while n < zero_amount:\n            zero_list.append(0)\n            n+=1      \n        nums = list(filter(lambda x: x!=0, nums))+zero_list"
                    },
                    {
                        "username": "vnhnhm",
                        "content": "[@muhammedirshadismail0722](/muhammedirshadismail0722) stop spamming"
                    },
                    {
                        "username": "Pranav_cs",
                        "content": "whe have to do it in-place don\\'t create a new list.\\nHint: use 2 pointers"
                    }
                ]
            },
            {
                "id": 1821489,
                "content": [
                    {
                        "username": "Nisha1205092",
                        "content": "it\\'s sad that I look for hints or ideas, but people just directly post codes here too!!! Whereas there\\'s a \\'solution\\' section separately. "
                    },
                    {
                        "username": "muhammedirshadismail0722",
                        "content": "\\n\\nEasiest \\uD83D\\uDE0E FAANG Method Ever !!! \\uD83D\\uDCA5||Best solution in python\\n\\n\\nhttps://leetcode.com/problems/move-zeroes/solutions/3923521/easiest-faang-method-ever-best-solution-in-python/"
                    },
                    {
                        "username": "aleazanrashid",
                        "content": "Let people discuss their issues with their solution "
                    },
                    {
                        "username": "mariusandries25",
                        "content": "It literally says not to post solutions in the discussion. This section is for tips and questions."
                    },
                    {
                        "username": "VladimirTheLeet",
                        "content": "I guess the rules don\\'t work for you if you can\\'t read \\xAF\\\\\\\\\\\\_(\\u30C4)_/\\xAF"
                    },
                    {
                        "username": "jerryy147",
                        "content": "all 3 rules say not to post a solution here in some form"
                    },
                    {
                        "username": "DoMonkeysFly7",
                        "content": "ppl are idiots frate, they wanna show how 'smart' they are"
                    },
                    {
                        "username": "mdegis",
                        "content": "I really do not understand how accepted solutions distribution works or measured for the solution.  I\\'ve basically submit the same solution 4 minutes apart, first one runtime was 491 ms and beat 25.21%... second one was 340 ms and beat 55.81%. Again, they are the same code! Nothing changed, not even an empty space. Just click \"submit\" button again. \\n\\nShould I stop caring about this number if there is no consistency at all?"
                    },
                    {
                        "username": "arc-arnob",
                        "content": "true and more over implicit declaration faster than explicit datatype declaration in typescript. "
                    },
                    {
                        "username": "bernardoolisan",
                        "content": "Is bc the leetcode server that runs your code might sometimes run faster or slower, is a compiler in a server. And yes, you should care about the percentage even if sometimes is not accurate, it gives you a approximation of how efficient is your code "
                    },
                    {
                        "username": "Priyamd",
                        "content": "i guess its a glitch "
                    },
                    {
                        "username": "potatopie",
                        "content": "its literally always the indians that post the solutions what concept of DISCUSSION do you guys not understand? "
                    },
                    {
                        "username": "AryanP45",
                        "content": "[@nKR5](/nKR5) Always fun reading these stereotypical comments"
                    },
                    {
                        "username": "nKR5",
                        "content": "Strong in programming language, weak in human communication language."
                    },
                    {
                        "username": "shubhamsharma123",
                        "content": " // striver solution\\n  int k=0;\\n        for(int i=0;i<nums.size();i++){\\n            if(nums[i]!=0){\\n            int temp=nums[k];\\n            nums[k]=nums[i];\\n            nums[i]= temp;\\n              k++;\\n            }\\n        }\\n        }"
                    },
                    {
                        "username": "vivekup3424",
                        "content": "Bro why you want hate by posting solution here, are you some kinda masochist."
                    },
                    {
                        "username": "swand0g",
                        "content": "nice job posting the solution in the one place leetcode specifies not to post solutions!"
                    },
                    {
                        "username": "neel19",
                        "content": "[@luan_hy](/luan_hy)  The instructor here (striver) has a very strong background in competitive programming. That\\'s how he can come up with such elegant solution. You can check out his tutorials on youtube. "
                    },
                    {
                        "username": "mariusandries25",
                        "content": "[@luan_hy](/luan_hy) The non-zero values are moved in front of array, the k variable keeping track of the moved values non-zero. Zeroes are implicit moving behind when swapping the non-zero. Then when encountering zero do nothing."
                    },
                    {
                        "username": "luan_hy",
                        "content": "Can you share what is your problem-solving step to come out with a so simple solution? "
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# Easiest \\uD83D\\uDE0E FAANG Method Ever !!! \\uD83D\\uDCA5 \\n\\nhttps://leetcode.com/problems/move-zeroes/solutions/2872504/easiest-faang-method-ever/?orderBy=most_votes"
                    },
                    {
                        "username": "atak",
                        "content": "\\t\\tzero_size = nums.count(0)\\n\\t\\tnums.delete(0)\\n\\t\\tnums = (nums + ([0] * zero_size ))"
                    },
                    {
                        "username": "muhammedirshadismail0722",
                        "content": "\\n\\nEasiest \\uD83D\\uDE0E FAANG Method Ever !!! \\uD83D\\uDCA5||Best solution in python\\n\\n\\nhttps://leetcode.com/problems/move-zeroes/solutions/3923521/easiest-faang-method-ever-best-solution-in-python/"
                    },
                    {
                        "username": "michaelknight492",
                        "content": "\"Note that you must do this in-place without making a copy of the array.\"\\n\\nI believe \"nums = (nums + ([0] * zero_size ))\" is  making a copy of the array"
                    },
                    {
                        "username": "saichandra004",
                        "content": "Cannot modify nums."
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# Easiest \\uD83D\\uDE0E FAANG Method Ever !!! \\uD83D\\uDCA5 \\n\\nhttps://leetcode.com/problems/move-zeroes/solutions/2872504/easiest-faang-method-ever/?orderBy=most_votes"
                    },
                    {
                        "username": "lanyiyun",
                        "content": "'''\\ndef moveZeroes(self, nums):\\n\\n        for i in range(nums.count(0)):\\n            nums.remove(0)\\n            nums.append(0)\\n'''"
                    },
                    {
                        "username": "starogre",
                        "content": "this doesn\\'t count. this creates a new list in memory. the challenge is to do it in-place"
                    },
                    {
                        "username": "saichandra004",
                        "content": "Cannot modify nums."
                    },
                    {
                        "username": "sainath81061",
                        "content": "public void MoveZeroes(int[] nums) {\\n        int i,count = 0;\\n        for(i=0;i<nums.Length;i++){\\n            if(nums[i] != 0){\\n                nums[count] = nums[i];\\n                count++;\\n            }\\n        }\\n        for(;count<nums.Length;count++){\\n            nums[count] = 0;\\n        }\\n        foreach(var x in nums){\\n            Console.WriteLine(x);\\n        }\\n    }"
                    },
                    {
                        "username": "LanceofLonginius",
                        "content": "do not post solutions here"
                    },
                    {
                        "username": "Kokopas",
                        "content": "Why this solution is not working,?\nI checked in on local interpreter and it works\n\nclass Solution:\n    def moveZeroes(self, nums) -> None:\n        \"\"\"\n        Do not return anything, modify nums in-place instead.\n        \"\"\"\n        zero_amount = nums.count(0)\n        zero_list=[]\n        n=0\n        while n < zero_amount:\n            zero_list.append(0)\n            n+=1      \n        nums = list(filter(lambda x: x!=0, nums))+zero_list"
                    },
                    {
                        "username": "vnhnhm",
                        "content": "[@muhammedirshadismail0722](/muhammedirshadismail0722) stop spamming"
                    },
                    {
                        "username": "Pranav_cs",
                        "content": "whe have to do it in-place don\\'t create a new list.\\nHint: use 2 pointers"
                    }
                ]
            },
            {
                "id": 1744663,
                "content": [
                    {
                        "username": "Nisha1205092",
                        "content": "it\\'s sad that I look for hints or ideas, but people just directly post codes here too!!! Whereas there\\'s a \\'solution\\' section separately. "
                    },
                    {
                        "username": "muhammedirshadismail0722",
                        "content": "\\n\\nEasiest \\uD83D\\uDE0E FAANG Method Ever !!! \\uD83D\\uDCA5||Best solution in python\\n\\n\\nhttps://leetcode.com/problems/move-zeroes/solutions/3923521/easiest-faang-method-ever-best-solution-in-python/"
                    },
                    {
                        "username": "aleazanrashid",
                        "content": "Let people discuss their issues with their solution "
                    },
                    {
                        "username": "mariusandries25",
                        "content": "It literally says not to post solutions in the discussion. This section is for tips and questions."
                    },
                    {
                        "username": "VladimirTheLeet",
                        "content": "I guess the rules don\\'t work for you if you can\\'t read \\xAF\\\\\\\\\\\\_(\\u30C4)_/\\xAF"
                    },
                    {
                        "username": "jerryy147",
                        "content": "all 3 rules say not to post a solution here in some form"
                    },
                    {
                        "username": "DoMonkeysFly7",
                        "content": "ppl are idiots frate, they wanna show how 'smart' they are"
                    },
                    {
                        "username": "mdegis",
                        "content": "I really do not understand how accepted solutions distribution works or measured for the solution.  I\\'ve basically submit the same solution 4 minutes apart, first one runtime was 491 ms and beat 25.21%... second one was 340 ms and beat 55.81%. Again, they are the same code! Nothing changed, not even an empty space. Just click \"submit\" button again. \\n\\nShould I stop caring about this number if there is no consistency at all?"
                    },
                    {
                        "username": "arc-arnob",
                        "content": "true and more over implicit declaration faster than explicit datatype declaration in typescript. "
                    },
                    {
                        "username": "bernardoolisan",
                        "content": "Is bc the leetcode server that runs your code might sometimes run faster or slower, is a compiler in a server. And yes, you should care about the percentage even if sometimes is not accurate, it gives you a approximation of how efficient is your code "
                    },
                    {
                        "username": "Priyamd",
                        "content": "i guess its a glitch "
                    },
                    {
                        "username": "potatopie",
                        "content": "its literally always the indians that post the solutions what concept of DISCUSSION do you guys not understand? "
                    },
                    {
                        "username": "AryanP45",
                        "content": "[@nKR5](/nKR5) Always fun reading these stereotypical comments"
                    },
                    {
                        "username": "nKR5",
                        "content": "Strong in programming language, weak in human communication language."
                    },
                    {
                        "username": "shubhamsharma123",
                        "content": " // striver solution\\n  int k=0;\\n        for(int i=0;i<nums.size();i++){\\n            if(nums[i]!=0){\\n            int temp=nums[k];\\n            nums[k]=nums[i];\\n            nums[i]= temp;\\n              k++;\\n            }\\n        }\\n        }"
                    },
                    {
                        "username": "vivekup3424",
                        "content": "Bro why you want hate by posting solution here, are you some kinda masochist."
                    },
                    {
                        "username": "swand0g",
                        "content": "nice job posting the solution in the one place leetcode specifies not to post solutions!"
                    },
                    {
                        "username": "neel19",
                        "content": "[@luan_hy](/luan_hy)  The instructor here (striver) has a very strong background in competitive programming. That\\'s how he can come up with such elegant solution. You can check out his tutorials on youtube. "
                    },
                    {
                        "username": "mariusandries25",
                        "content": "[@luan_hy](/luan_hy) The non-zero values are moved in front of array, the k variable keeping track of the moved values non-zero. Zeroes are implicit moving behind when swapping the non-zero. Then when encountering zero do nothing."
                    },
                    {
                        "username": "luan_hy",
                        "content": "Can you share what is your problem-solving step to come out with a so simple solution? "
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# Easiest \\uD83D\\uDE0E FAANG Method Ever !!! \\uD83D\\uDCA5 \\n\\nhttps://leetcode.com/problems/move-zeroes/solutions/2872504/easiest-faang-method-ever/?orderBy=most_votes"
                    },
                    {
                        "username": "atak",
                        "content": "\\t\\tzero_size = nums.count(0)\\n\\t\\tnums.delete(0)\\n\\t\\tnums = (nums + ([0] * zero_size ))"
                    },
                    {
                        "username": "muhammedirshadismail0722",
                        "content": "\\n\\nEasiest \\uD83D\\uDE0E FAANG Method Ever !!! \\uD83D\\uDCA5||Best solution in python\\n\\n\\nhttps://leetcode.com/problems/move-zeroes/solutions/3923521/easiest-faang-method-ever-best-solution-in-python/"
                    },
                    {
                        "username": "michaelknight492",
                        "content": "\"Note that you must do this in-place without making a copy of the array.\"\\n\\nI believe \"nums = (nums + ([0] * zero_size ))\" is  making a copy of the array"
                    },
                    {
                        "username": "saichandra004",
                        "content": "Cannot modify nums."
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# Easiest \\uD83D\\uDE0E FAANG Method Ever !!! \\uD83D\\uDCA5 \\n\\nhttps://leetcode.com/problems/move-zeroes/solutions/2872504/easiest-faang-method-ever/?orderBy=most_votes"
                    },
                    {
                        "username": "lanyiyun",
                        "content": "'''\\ndef moveZeroes(self, nums):\\n\\n        for i in range(nums.count(0)):\\n            nums.remove(0)\\n            nums.append(0)\\n'''"
                    },
                    {
                        "username": "starogre",
                        "content": "this doesn\\'t count. this creates a new list in memory. the challenge is to do it in-place"
                    },
                    {
                        "username": "saichandra004",
                        "content": "Cannot modify nums."
                    },
                    {
                        "username": "sainath81061",
                        "content": "public void MoveZeroes(int[] nums) {\\n        int i,count = 0;\\n        for(i=0;i<nums.Length;i++){\\n            if(nums[i] != 0){\\n                nums[count] = nums[i];\\n                count++;\\n            }\\n        }\\n        for(;count<nums.Length;count++){\\n            nums[count] = 0;\\n        }\\n        foreach(var x in nums){\\n            Console.WriteLine(x);\\n        }\\n    }"
                    },
                    {
                        "username": "LanceofLonginius",
                        "content": "do not post solutions here"
                    },
                    {
                        "username": "Kokopas",
                        "content": "Why this solution is not working,?\nI checked in on local interpreter and it works\n\nclass Solution:\n    def moveZeroes(self, nums) -> None:\n        \"\"\"\n        Do not return anything, modify nums in-place instead.\n        \"\"\"\n        zero_amount = nums.count(0)\n        zero_list=[]\n        n=0\n        while n < zero_amount:\n            zero_list.append(0)\n            n+=1      \n        nums = list(filter(lambda x: x!=0, nums))+zero_list"
                    },
                    {
                        "username": "vnhnhm",
                        "content": "[@muhammedirshadismail0722](/muhammedirshadismail0722) stop spamming"
                    },
                    {
                        "username": "Pranav_cs",
                        "content": "whe have to do it in-place don\\'t create a new list.\\nHint: use 2 pointers"
                    }
                ]
            },
            {
                "id": 2029724,
                "content": [
                    {
                        "username": "Nisha1205092",
                        "content": "it\\'s sad that I look for hints or ideas, but people just directly post codes here too!!! Whereas there\\'s a \\'solution\\' section separately. "
                    },
                    {
                        "username": "muhammedirshadismail0722",
                        "content": "\\n\\nEasiest \\uD83D\\uDE0E FAANG Method Ever !!! \\uD83D\\uDCA5||Best solution in python\\n\\n\\nhttps://leetcode.com/problems/move-zeroes/solutions/3923521/easiest-faang-method-ever-best-solution-in-python/"
                    },
                    {
                        "username": "aleazanrashid",
                        "content": "Let people discuss their issues with their solution "
                    },
                    {
                        "username": "mariusandries25",
                        "content": "It literally says not to post solutions in the discussion. This section is for tips and questions."
                    },
                    {
                        "username": "VladimirTheLeet",
                        "content": "I guess the rules don\\'t work for you if you can\\'t read \\xAF\\\\\\\\\\\\_(\\u30C4)_/\\xAF"
                    },
                    {
                        "username": "jerryy147",
                        "content": "all 3 rules say not to post a solution here in some form"
                    },
                    {
                        "username": "DoMonkeysFly7",
                        "content": "ppl are idiots frate, they wanna show how 'smart' they are"
                    },
                    {
                        "username": "mdegis",
                        "content": "I really do not understand how accepted solutions distribution works or measured for the solution.  I\\'ve basically submit the same solution 4 minutes apart, first one runtime was 491 ms and beat 25.21%... second one was 340 ms and beat 55.81%. Again, they are the same code! Nothing changed, not even an empty space. Just click \"submit\" button again. \\n\\nShould I stop caring about this number if there is no consistency at all?"
                    },
                    {
                        "username": "arc-arnob",
                        "content": "true and more over implicit declaration faster than explicit datatype declaration in typescript. "
                    },
                    {
                        "username": "bernardoolisan",
                        "content": "Is bc the leetcode server that runs your code might sometimes run faster or slower, is a compiler in a server. And yes, you should care about the percentage even if sometimes is not accurate, it gives you a approximation of how efficient is your code "
                    },
                    {
                        "username": "Priyamd",
                        "content": "i guess its a glitch "
                    },
                    {
                        "username": "potatopie",
                        "content": "its literally always the indians that post the solutions what concept of DISCUSSION do you guys not understand? "
                    },
                    {
                        "username": "AryanP45",
                        "content": "[@nKR5](/nKR5) Always fun reading these stereotypical comments"
                    },
                    {
                        "username": "nKR5",
                        "content": "Strong in programming language, weak in human communication language."
                    },
                    {
                        "username": "shubhamsharma123",
                        "content": " // striver solution\\n  int k=0;\\n        for(int i=0;i<nums.size();i++){\\n            if(nums[i]!=0){\\n            int temp=nums[k];\\n            nums[k]=nums[i];\\n            nums[i]= temp;\\n              k++;\\n            }\\n        }\\n        }"
                    },
                    {
                        "username": "vivekup3424",
                        "content": "Bro why you want hate by posting solution here, are you some kinda masochist."
                    },
                    {
                        "username": "swand0g",
                        "content": "nice job posting the solution in the one place leetcode specifies not to post solutions!"
                    },
                    {
                        "username": "neel19",
                        "content": "[@luan_hy](/luan_hy)  The instructor here (striver) has a very strong background in competitive programming. That\\'s how he can come up with such elegant solution. You can check out his tutorials on youtube. "
                    },
                    {
                        "username": "mariusandries25",
                        "content": "[@luan_hy](/luan_hy) The non-zero values are moved in front of array, the k variable keeping track of the moved values non-zero. Zeroes are implicit moving behind when swapping the non-zero. Then when encountering zero do nothing."
                    },
                    {
                        "username": "luan_hy",
                        "content": "Can you share what is your problem-solving step to come out with a so simple solution? "
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# Easiest \\uD83D\\uDE0E FAANG Method Ever !!! \\uD83D\\uDCA5 \\n\\nhttps://leetcode.com/problems/move-zeroes/solutions/2872504/easiest-faang-method-ever/?orderBy=most_votes"
                    },
                    {
                        "username": "atak",
                        "content": "\\t\\tzero_size = nums.count(0)\\n\\t\\tnums.delete(0)\\n\\t\\tnums = (nums + ([0] * zero_size ))"
                    },
                    {
                        "username": "muhammedirshadismail0722",
                        "content": "\\n\\nEasiest \\uD83D\\uDE0E FAANG Method Ever !!! \\uD83D\\uDCA5||Best solution in python\\n\\n\\nhttps://leetcode.com/problems/move-zeroes/solutions/3923521/easiest-faang-method-ever-best-solution-in-python/"
                    },
                    {
                        "username": "michaelknight492",
                        "content": "\"Note that you must do this in-place without making a copy of the array.\"\\n\\nI believe \"nums = (nums + ([0] * zero_size ))\" is  making a copy of the array"
                    },
                    {
                        "username": "saichandra004",
                        "content": "Cannot modify nums."
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# Easiest \\uD83D\\uDE0E FAANG Method Ever !!! \\uD83D\\uDCA5 \\n\\nhttps://leetcode.com/problems/move-zeroes/solutions/2872504/easiest-faang-method-ever/?orderBy=most_votes"
                    },
                    {
                        "username": "lanyiyun",
                        "content": "'''\\ndef moveZeroes(self, nums):\\n\\n        for i in range(nums.count(0)):\\n            nums.remove(0)\\n            nums.append(0)\\n'''"
                    },
                    {
                        "username": "starogre",
                        "content": "this doesn\\'t count. this creates a new list in memory. the challenge is to do it in-place"
                    },
                    {
                        "username": "saichandra004",
                        "content": "Cannot modify nums."
                    },
                    {
                        "username": "sainath81061",
                        "content": "public void MoveZeroes(int[] nums) {\\n        int i,count = 0;\\n        for(i=0;i<nums.Length;i++){\\n            if(nums[i] != 0){\\n                nums[count] = nums[i];\\n                count++;\\n            }\\n        }\\n        for(;count<nums.Length;count++){\\n            nums[count] = 0;\\n        }\\n        foreach(var x in nums){\\n            Console.WriteLine(x);\\n        }\\n    }"
                    },
                    {
                        "username": "LanceofLonginius",
                        "content": "do not post solutions here"
                    },
                    {
                        "username": "Kokopas",
                        "content": "Why this solution is not working,?\nI checked in on local interpreter and it works\n\nclass Solution:\n    def moveZeroes(self, nums) -> None:\n        \"\"\"\n        Do not return anything, modify nums in-place instead.\n        \"\"\"\n        zero_amount = nums.count(0)\n        zero_list=[]\n        n=0\n        while n < zero_amount:\n            zero_list.append(0)\n            n+=1      \n        nums = list(filter(lambda x: x!=0, nums))+zero_list"
                    },
                    {
                        "username": "vnhnhm",
                        "content": "[@muhammedirshadismail0722](/muhammedirshadismail0722) stop spamming"
                    },
                    {
                        "username": "Pranav_cs",
                        "content": "whe have to do it in-place don\\'t create a new list.\\nHint: use 2 pointers"
                    }
                ]
            },
            {
                "id": 1625836,
                "content": [
                    {
                        "username": "Nisha1205092",
                        "content": "it\\'s sad that I look for hints or ideas, but people just directly post codes here too!!! Whereas there\\'s a \\'solution\\' section separately. "
                    },
                    {
                        "username": "muhammedirshadismail0722",
                        "content": "\\n\\nEasiest \\uD83D\\uDE0E FAANG Method Ever !!! \\uD83D\\uDCA5||Best solution in python\\n\\n\\nhttps://leetcode.com/problems/move-zeroes/solutions/3923521/easiest-faang-method-ever-best-solution-in-python/"
                    },
                    {
                        "username": "aleazanrashid",
                        "content": "Let people discuss their issues with their solution "
                    },
                    {
                        "username": "mariusandries25",
                        "content": "It literally says not to post solutions in the discussion. This section is for tips and questions."
                    },
                    {
                        "username": "VladimirTheLeet",
                        "content": "I guess the rules don\\'t work for you if you can\\'t read \\xAF\\\\\\\\\\\\_(\\u30C4)_/\\xAF"
                    },
                    {
                        "username": "jerryy147",
                        "content": "all 3 rules say not to post a solution here in some form"
                    },
                    {
                        "username": "DoMonkeysFly7",
                        "content": "ppl are idiots frate, they wanna show how 'smart' they are"
                    },
                    {
                        "username": "mdegis",
                        "content": "I really do not understand how accepted solutions distribution works or measured for the solution.  I\\'ve basically submit the same solution 4 minutes apart, first one runtime was 491 ms and beat 25.21%... second one was 340 ms and beat 55.81%. Again, they are the same code! Nothing changed, not even an empty space. Just click \"submit\" button again. \\n\\nShould I stop caring about this number if there is no consistency at all?"
                    },
                    {
                        "username": "arc-arnob",
                        "content": "true and more over implicit declaration faster than explicit datatype declaration in typescript. "
                    },
                    {
                        "username": "bernardoolisan",
                        "content": "Is bc the leetcode server that runs your code might sometimes run faster or slower, is a compiler in a server. And yes, you should care about the percentage even if sometimes is not accurate, it gives you a approximation of how efficient is your code "
                    },
                    {
                        "username": "Priyamd",
                        "content": "i guess its a glitch "
                    },
                    {
                        "username": "potatopie",
                        "content": "its literally always the indians that post the solutions what concept of DISCUSSION do you guys not understand? "
                    },
                    {
                        "username": "AryanP45",
                        "content": "[@nKR5](/nKR5) Always fun reading these stereotypical comments"
                    },
                    {
                        "username": "nKR5",
                        "content": "Strong in programming language, weak in human communication language."
                    },
                    {
                        "username": "shubhamsharma123",
                        "content": " // striver solution\\n  int k=0;\\n        for(int i=0;i<nums.size();i++){\\n            if(nums[i]!=0){\\n            int temp=nums[k];\\n            nums[k]=nums[i];\\n            nums[i]= temp;\\n              k++;\\n            }\\n        }\\n        }"
                    },
                    {
                        "username": "vivekup3424",
                        "content": "Bro why you want hate by posting solution here, are you some kinda masochist."
                    },
                    {
                        "username": "swand0g",
                        "content": "nice job posting the solution in the one place leetcode specifies not to post solutions!"
                    },
                    {
                        "username": "neel19",
                        "content": "[@luan_hy](/luan_hy)  The instructor here (striver) has a very strong background in competitive programming. That\\'s how he can come up with such elegant solution. You can check out his tutorials on youtube. "
                    },
                    {
                        "username": "mariusandries25",
                        "content": "[@luan_hy](/luan_hy) The non-zero values are moved in front of array, the k variable keeping track of the moved values non-zero. Zeroes are implicit moving behind when swapping the non-zero. Then when encountering zero do nothing."
                    },
                    {
                        "username": "luan_hy",
                        "content": "Can you share what is your problem-solving step to come out with a so simple solution? "
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# Easiest \\uD83D\\uDE0E FAANG Method Ever !!! \\uD83D\\uDCA5 \\n\\nhttps://leetcode.com/problems/move-zeroes/solutions/2872504/easiest-faang-method-ever/?orderBy=most_votes"
                    },
                    {
                        "username": "atak",
                        "content": "\\t\\tzero_size = nums.count(0)\\n\\t\\tnums.delete(0)\\n\\t\\tnums = (nums + ([0] * zero_size ))"
                    },
                    {
                        "username": "muhammedirshadismail0722",
                        "content": "\\n\\nEasiest \\uD83D\\uDE0E FAANG Method Ever !!! \\uD83D\\uDCA5||Best solution in python\\n\\n\\nhttps://leetcode.com/problems/move-zeroes/solutions/3923521/easiest-faang-method-ever-best-solution-in-python/"
                    },
                    {
                        "username": "michaelknight492",
                        "content": "\"Note that you must do this in-place without making a copy of the array.\"\\n\\nI believe \"nums = (nums + ([0] * zero_size ))\" is  making a copy of the array"
                    },
                    {
                        "username": "saichandra004",
                        "content": "Cannot modify nums."
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# Easiest \\uD83D\\uDE0E FAANG Method Ever !!! \\uD83D\\uDCA5 \\n\\nhttps://leetcode.com/problems/move-zeroes/solutions/2872504/easiest-faang-method-ever/?orderBy=most_votes"
                    },
                    {
                        "username": "lanyiyun",
                        "content": "'''\\ndef moveZeroes(self, nums):\\n\\n        for i in range(nums.count(0)):\\n            nums.remove(0)\\n            nums.append(0)\\n'''"
                    },
                    {
                        "username": "starogre",
                        "content": "this doesn\\'t count. this creates a new list in memory. the challenge is to do it in-place"
                    },
                    {
                        "username": "saichandra004",
                        "content": "Cannot modify nums."
                    },
                    {
                        "username": "sainath81061",
                        "content": "public void MoveZeroes(int[] nums) {\\n        int i,count = 0;\\n        for(i=0;i<nums.Length;i++){\\n            if(nums[i] != 0){\\n                nums[count] = nums[i];\\n                count++;\\n            }\\n        }\\n        for(;count<nums.Length;count++){\\n            nums[count] = 0;\\n        }\\n        foreach(var x in nums){\\n            Console.WriteLine(x);\\n        }\\n    }"
                    },
                    {
                        "username": "LanceofLonginius",
                        "content": "do not post solutions here"
                    },
                    {
                        "username": "Kokopas",
                        "content": "Why this solution is not working,?\nI checked in on local interpreter and it works\n\nclass Solution:\n    def moveZeroes(self, nums) -> None:\n        \"\"\"\n        Do not return anything, modify nums in-place instead.\n        \"\"\"\n        zero_amount = nums.count(0)\n        zero_list=[]\n        n=0\n        while n < zero_amount:\n            zero_list.append(0)\n            n+=1      \n        nums = list(filter(lambda x: x!=0, nums))+zero_list"
                    },
                    {
                        "username": "vnhnhm",
                        "content": "[@muhammedirshadismail0722](/muhammedirshadismail0722) stop spamming"
                    },
                    {
                        "username": "Pranav_cs",
                        "content": "whe have to do it in-place don\\'t create a new list.\\nHint: use 2 pointers"
                    }
                ]
            },
            {
                "id": 1703891,
                "content": [
                    {
                        "username": "Nisha1205092",
                        "content": "it\\'s sad that I look for hints or ideas, but people just directly post codes here too!!! Whereas there\\'s a \\'solution\\' section separately. "
                    },
                    {
                        "username": "muhammedirshadismail0722",
                        "content": "\\n\\nEasiest \\uD83D\\uDE0E FAANG Method Ever !!! \\uD83D\\uDCA5||Best solution in python\\n\\n\\nhttps://leetcode.com/problems/move-zeroes/solutions/3923521/easiest-faang-method-ever-best-solution-in-python/"
                    },
                    {
                        "username": "aleazanrashid",
                        "content": "Let people discuss their issues with their solution "
                    },
                    {
                        "username": "mariusandries25",
                        "content": "It literally says not to post solutions in the discussion. This section is for tips and questions."
                    },
                    {
                        "username": "VladimirTheLeet",
                        "content": "I guess the rules don\\'t work for you if you can\\'t read \\xAF\\\\\\\\\\\\_(\\u30C4)_/\\xAF"
                    },
                    {
                        "username": "jerryy147",
                        "content": "all 3 rules say not to post a solution here in some form"
                    },
                    {
                        "username": "DoMonkeysFly7",
                        "content": "ppl are idiots frate, they wanna show how 'smart' they are"
                    },
                    {
                        "username": "mdegis",
                        "content": "I really do not understand how accepted solutions distribution works or measured for the solution.  I\\'ve basically submit the same solution 4 minutes apart, first one runtime was 491 ms and beat 25.21%... second one was 340 ms and beat 55.81%. Again, they are the same code! Nothing changed, not even an empty space. Just click \"submit\" button again. \\n\\nShould I stop caring about this number if there is no consistency at all?"
                    },
                    {
                        "username": "arc-arnob",
                        "content": "true and more over implicit declaration faster than explicit datatype declaration in typescript. "
                    },
                    {
                        "username": "bernardoolisan",
                        "content": "Is bc the leetcode server that runs your code might sometimes run faster or slower, is a compiler in a server. And yes, you should care about the percentage even if sometimes is not accurate, it gives you a approximation of how efficient is your code "
                    },
                    {
                        "username": "Priyamd",
                        "content": "i guess its a glitch "
                    },
                    {
                        "username": "potatopie",
                        "content": "its literally always the indians that post the solutions what concept of DISCUSSION do you guys not understand? "
                    },
                    {
                        "username": "AryanP45",
                        "content": "[@nKR5](/nKR5) Always fun reading these stereotypical comments"
                    },
                    {
                        "username": "nKR5",
                        "content": "Strong in programming language, weak in human communication language."
                    },
                    {
                        "username": "shubhamsharma123",
                        "content": " // striver solution\\n  int k=0;\\n        for(int i=0;i<nums.size();i++){\\n            if(nums[i]!=0){\\n            int temp=nums[k];\\n            nums[k]=nums[i];\\n            nums[i]= temp;\\n              k++;\\n            }\\n        }\\n        }"
                    },
                    {
                        "username": "vivekup3424",
                        "content": "Bro why you want hate by posting solution here, are you some kinda masochist."
                    },
                    {
                        "username": "swand0g",
                        "content": "nice job posting the solution in the one place leetcode specifies not to post solutions!"
                    },
                    {
                        "username": "neel19",
                        "content": "[@luan_hy](/luan_hy)  The instructor here (striver) has a very strong background in competitive programming. That\\'s how he can come up with such elegant solution. You can check out his tutorials on youtube. "
                    },
                    {
                        "username": "mariusandries25",
                        "content": "[@luan_hy](/luan_hy) The non-zero values are moved in front of array, the k variable keeping track of the moved values non-zero. Zeroes are implicit moving behind when swapping the non-zero. Then when encountering zero do nothing."
                    },
                    {
                        "username": "luan_hy",
                        "content": "Can you share what is your problem-solving step to come out with a so simple solution? "
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# Easiest \\uD83D\\uDE0E FAANG Method Ever !!! \\uD83D\\uDCA5 \\n\\nhttps://leetcode.com/problems/move-zeroes/solutions/2872504/easiest-faang-method-ever/?orderBy=most_votes"
                    },
                    {
                        "username": "atak",
                        "content": "\\t\\tzero_size = nums.count(0)\\n\\t\\tnums.delete(0)\\n\\t\\tnums = (nums + ([0] * zero_size ))"
                    },
                    {
                        "username": "muhammedirshadismail0722",
                        "content": "\\n\\nEasiest \\uD83D\\uDE0E FAANG Method Ever !!! \\uD83D\\uDCA5||Best solution in python\\n\\n\\nhttps://leetcode.com/problems/move-zeroes/solutions/3923521/easiest-faang-method-ever-best-solution-in-python/"
                    },
                    {
                        "username": "michaelknight492",
                        "content": "\"Note that you must do this in-place without making a copy of the array.\"\\n\\nI believe \"nums = (nums + ([0] * zero_size ))\" is  making a copy of the array"
                    },
                    {
                        "username": "saichandra004",
                        "content": "Cannot modify nums."
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# Easiest \\uD83D\\uDE0E FAANG Method Ever !!! \\uD83D\\uDCA5 \\n\\nhttps://leetcode.com/problems/move-zeroes/solutions/2872504/easiest-faang-method-ever/?orderBy=most_votes"
                    },
                    {
                        "username": "lanyiyun",
                        "content": "'''\\ndef moveZeroes(self, nums):\\n\\n        for i in range(nums.count(0)):\\n            nums.remove(0)\\n            nums.append(0)\\n'''"
                    },
                    {
                        "username": "starogre",
                        "content": "this doesn\\'t count. this creates a new list in memory. the challenge is to do it in-place"
                    },
                    {
                        "username": "saichandra004",
                        "content": "Cannot modify nums."
                    },
                    {
                        "username": "sainath81061",
                        "content": "public void MoveZeroes(int[] nums) {\\n        int i,count = 0;\\n        for(i=0;i<nums.Length;i++){\\n            if(nums[i] != 0){\\n                nums[count] = nums[i];\\n                count++;\\n            }\\n        }\\n        for(;count<nums.Length;count++){\\n            nums[count] = 0;\\n        }\\n        foreach(var x in nums){\\n            Console.WriteLine(x);\\n        }\\n    }"
                    },
                    {
                        "username": "LanceofLonginius",
                        "content": "do not post solutions here"
                    },
                    {
                        "username": "Kokopas",
                        "content": "Why this solution is not working,?\nI checked in on local interpreter and it works\n\nclass Solution:\n    def moveZeroes(self, nums) -> None:\n        \"\"\"\n        Do not return anything, modify nums in-place instead.\n        \"\"\"\n        zero_amount = nums.count(0)\n        zero_list=[]\n        n=0\n        while n < zero_amount:\n            zero_list.append(0)\n            n+=1      \n        nums = list(filter(lambda x: x!=0, nums))+zero_list"
                    },
                    {
                        "username": "vnhnhm",
                        "content": "[@muhammedirshadismail0722](/muhammedirshadismail0722) stop spamming"
                    },
                    {
                        "username": "Pranav_cs",
                        "content": "whe have to do it in-place don\\'t create a new list.\\nHint: use 2 pointers"
                    }
                ]
            },
            {
                "id": 1572592,
                "content": [
                    {
                        "username": "Nisha1205092",
                        "content": "it\\'s sad that I look for hints or ideas, but people just directly post codes here too!!! Whereas there\\'s a \\'solution\\' section separately. "
                    },
                    {
                        "username": "muhammedirshadismail0722",
                        "content": "\\n\\nEasiest \\uD83D\\uDE0E FAANG Method Ever !!! \\uD83D\\uDCA5||Best solution in python\\n\\n\\nhttps://leetcode.com/problems/move-zeroes/solutions/3923521/easiest-faang-method-ever-best-solution-in-python/"
                    },
                    {
                        "username": "aleazanrashid",
                        "content": "Let people discuss their issues with their solution "
                    },
                    {
                        "username": "mariusandries25",
                        "content": "It literally says not to post solutions in the discussion. This section is for tips and questions."
                    },
                    {
                        "username": "VladimirTheLeet",
                        "content": "I guess the rules don\\'t work for you if you can\\'t read \\xAF\\\\\\\\\\\\_(\\u30C4)_/\\xAF"
                    },
                    {
                        "username": "jerryy147",
                        "content": "all 3 rules say not to post a solution here in some form"
                    },
                    {
                        "username": "DoMonkeysFly7",
                        "content": "ppl are idiots frate, they wanna show how 'smart' they are"
                    },
                    {
                        "username": "mdegis",
                        "content": "I really do not understand how accepted solutions distribution works or measured for the solution.  I\\'ve basically submit the same solution 4 minutes apart, first one runtime was 491 ms and beat 25.21%... second one was 340 ms and beat 55.81%. Again, they are the same code! Nothing changed, not even an empty space. Just click \"submit\" button again. \\n\\nShould I stop caring about this number if there is no consistency at all?"
                    },
                    {
                        "username": "arc-arnob",
                        "content": "true and more over implicit declaration faster than explicit datatype declaration in typescript. "
                    },
                    {
                        "username": "bernardoolisan",
                        "content": "Is bc the leetcode server that runs your code might sometimes run faster or slower, is a compiler in a server. And yes, you should care about the percentage even if sometimes is not accurate, it gives you a approximation of how efficient is your code "
                    },
                    {
                        "username": "Priyamd",
                        "content": "i guess its a glitch "
                    },
                    {
                        "username": "potatopie",
                        "content": "its literally always the indians that post the solutions what concept of DISCUSSION do you guys not understand? "
                    },
                    {
                        "username": "AryanP45",
                        "content": "[@nKR5](/nKR5) Always fun reading these stereotypical comments"
                    },
                    {
                        "username": "nKR5",
                        "content": "Strong in programming language, weak in human communication language."
                    },
                    {
                        "username": "shubhamsharma123",
                        "content": " // striver solution\\n  int k=0;\\n        for(int i=0;i<nums.size();i++){\\n            if(nums[i]!=0){\\n            int temp=nums[k];\\n            nums[k]=nums[i];\\n            nums[i]= temp;\\n              k++;\\n            }\\n        }\\n        }"
                    },
                    {
                        "username": "vivekup3424",
                        "content": "Bro why you want hate by posting solution here, are you some kinda masochist."
                    },
                    {
                        "username": "swand0g",
                        "content": "nice job posting the solution in the one place leetcode specifies not to post solutions!"
                    },
                    {
                        "username": "neel19",
                        "content": "[@luan_hy](/luan_hy)  The instructor here (striver) has a very strong background in competitive programming. That\\'s how he can come up with such elegant solution. You can check out his tutorials on youtube. "
                    },
                    {
                        "username": "mariusandries25",
                        "content": "[@luan_hy](/luan_hy) The non-zero values are moved in front of array, the k variable keeping track of the moved values non-zero. Zeroes are implicit moving behind when swapping the non-zero. Then when encountering zero do nothing."
                    },
                    {
                        "username": "luan_hy",
                        "content": "Can you share what is your problem-solving step to come out with a so simple solution? "
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# Easiest \\uD83D\\uDE0E FAANG Method Ever !!! \\uD83D\\uDCA5 \\n\\nhttps://leetcode.com/problems/move-zeroes/solutions/2872504/easiest-faang-method-ever/?orderBy=most_votes"
                    },
                    {
                        "username": "atak",
                        "content": "\\t\\tzero_size = nums.count(0)\\n\\t\\tnums.delete(0)\\n\\t\\tnums = (nums + ([0] * zero_size ))"
                    },
                    {
                        "username": "muhammedirshadismail0722",
                        "content": "\\n\\nEasiest \\uD83D\\uDE0E FAANG Method Ever !!! \\uD83D\\uDCA5||Best solution in python\\n\\n\\nhttps://leetcode.com/problems/move-zeroes/solutions/3923521/easiest-faang-method-ever-best-solution-in-python/"
                    },
                    {
                        "username": "michaelknight492",
                        "content": "\"Note that you must do this in-place without making a copy of the array.\"\\n\\nI believe \"nums = (nums + ([0] * zero_size ))\" is  making a copy of the array"
                    },
                    {
                        "username": "saichandra004",
                        "content": "Cannot modify nums."
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# Easiest \\uD83D\\uDE0E FAANG Method Ever !!! \\uD83D\\uDCA5 \\n\\nhttps://leetcode.com/problems/move-zeroes/solutions/2872504/easiest-faang-method-ever/?orderBy=most_votes"
                    },
                    {
                        "username": "lanyiyun",
                        "content": "'''\\ndef moveZeroes(self, nums):\\n\\n        for i in range(nums.count(0)):\\n            nums.remove(0)\\n            nums.append(0)\\n'''"
                    },
                    {
                        "username": "starogre",
                        "content": "this doesn\\'t count. this creates a new list in memory. the challenge is to do it in-place"
                    },
                    {
                        "username": "saichandra004",
                        "content": "Cannot modify nums."
                    },
                    {
                        "username": "sainath81061",
                        "content": "public void MoveZeroes(int[] nums) {\\n        int i,count = 0;\\n        for(i=0;i<nums.Length;i++){\\n            if(nums[i] != 0){\\n                nums[count] = nums[i];\\n                count++;\\n            }\\n        }\\n        for(;count<nums.Length;count++){\\n            nums[count] = 0;\\n        }\\n        foreach(var x in nums){\\n            Console.WriteLine(x);\\n        }\\n    }"
                    },
                    {
                        "username": "LanceofLonginius",
                        "content": "do not post solutions here"
                    },
                    {
                        "username": "Kokopas",
                        "content": "Why this solution is not working,?\nI checked in on local interpreter and it works\n\nclass Solution:\n    def moveZeroes(self, nums) -> None:\n        \"\"\"\n        Do not return anything, modify nums in-place instead.\n        \"\"\"\n        zero_amount = nums.count(0)\n        zero_list=[]\n        n=0\n        while n < zero_amount:\n            zero_list.append(0)\n            n+=1      \n        nums = list(filter(lambda x: x!=0, nums))+zero_list"
                    },
                    {
                        "username": "vnhnhm",
                        "content": "[@muhammedirshadismail0722](/muhammedirshadismail0722) stop spamming"
                    },
                    {
                        "username": "Pranav_cs",
                        "content": "whe have to do it in-place don\\'t create a new list.\\nHint: use 2 pointers"
                    }
                ]
            },
            {
                "id": 1571527,
                "content": [
                    {
                        "username": "Nisha1205092",
                        "content": "it\\'s sad that I look for hints or ideas, but people just directly post codes here too!!! Whereas there\\'s a \\'solution\\' section separately. "
                    },
                    {
                        "username": "muhammedirshadismail0722",
                        "content": "\\n\\nEasiest \\uD83D\\uDE0E FAANG Method Ever !!! \\uD83D\\uDCA5||Best solution in python\\n\\n\\nhttps://leetcode.com/problems/move-zeroes/solutions/3923521/easiest-faang-method-ever-best-solution-in-python/"
                    },
                    {
                        "username": "aleazanrashid",
                        "content": "Let people discuss their issues with their solution "
                    },
                    {
                        "username": "mariusandries25",
                        "content": "It literally says not to post solutions in the discussion. This section is for tips and questions."
                    },
                    {
                        "username": "VladimirTheLeet",
                        "content": "I guess the rules don\\'t work for you if you can\\'t read \\xAF\\\\\\\\\\\\_(\\u30C4)_/\\xAF"
                    },
                    {
                        "username": "jerryy147",
                        "content": "all 3 rules say not to post a solution here in some form"
                    },
                    {
                        "username": "DoMonkeysFly7",
                        "content": "ppl are idiots frate, they wanna show how 'smart' they are"
                    },
                    {
                        "username": "mdegis",
                        "content": "I really do not understand how accepted solutions distribution works or measured for the solution.  I\\'ve basically submit the same solution 4 minutes apart, first one runtime was 491 ms and beat 25.21%... second one was 340 ms and beat 55.81%. Again, they are the same code! Nothing changed, not even an empty space. Just click \"submit\" button again. \\n\\nShould I stop caring about this number if there is no consistency at all?"
                    },
                    {
                        "username": "arc-arnob",
                        "content": "true and more over implicit declaration faster than explicit datatype declaration in typescript. "
                    },
                    {
                        "username": "bernardoolisan",
                        "content": "Is bc the leetcode server that runs your code might sometimes run faster or slower, is a compiler in a server. And yes, you should care about the percentage even if sometimes is not accurate, it gives you a approximation of how efficient is your code "
                    },
                    {
                        "username": "Priyamd",
                        "content": "i guess its a glitch "
                    },
                    {
                        "username": "potatopie",
                        "content": "its literally always the indians that post the solutions what concept of DISCUSSION do you guys not understand? "
                    },
                    {
                        "username": "AryanP45",
                        "content": "[@nKR5](/nKR5) Always fun reading these stereotypical comments"
                    },
                    {
                        "username": "nKR5",
                        "content": "Strong in programming language, weak in human communication language."
                    },
                    {
                        "username": "shubhamsharma123",
                        "content": " // striver solution\\n  int k=0;\\n        for(int i=0;i<nums.size();i++){\\n            if(nums[i]!=0){\\n            int temp=nums[k];\\n            nums[k]=nums[i];\\n            nums[i]= temp;\\n              k++;\\n            }\\n        }\\n        }"
                    },
                    {
                        "username": "vivekup3424",
                        "content": "Bro why you want hate by posting solution here, are you some kinda masochist."
                    },
                    {
                        "username": "swand0g",
                        "content": "nice job posting the solution in the one place leetcode specifies not to post solutions!"
                    },
                    {
                        "username": "neel19",
                        "content": "[@luan_hy](/luan_hy)  The instructor here (striver) has a very strong background in competitive programming. That\\'s how he can come up with such elegant solution. You can check out his tutorials on youtube. "
                    },
                    {
                        "username": "mariusandries25",
                        "content": "[@luan_hy](/luan_hy) The non-zero values are moved in front of array, the k variable keeping track of the moved values non-zero. Zeroes are implicit moving behind when swapping the non-zero. Then when encountering zero do nothing."
                    },
                    {
                        "username": "luan_hy",
                        "content": "Can you share what is your problem-solving step to come out with a so simple solution? "
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# Easiest \\uD83D\\uDE0E FAANG Method Ever !!! \\uD83D\\uDCA5 \\n\\nhttps://leetcode.com/problems/move-zeroes/solutions/2872504/easiest-faang-method-ever/?orderBy=most_votes"
                    },
                    {
                        "username": "atak",
                        "content": "\\t\\tzero_size = nums.count(0)\\n\\t\\tnums.delete(0)\\n\\t\\tnums = (nums + ([0] * zero_size ))"
                    },
                    {
                        "username": "muhammedirshadismail0722",
                        "content": "\\n\\nEasiest \\uD83D\\uDE0E FAANG Method Ever !!! \\uD83D\\uDCA5||Best solution in python\\n\\n\\nhttps://leetcode.com/problems/move-zeroes/solutions/3923521/easiest-faang-method-ever-best-solution-in-python/"
                    },
                    {
                        "username": "michaelknight492",
                        "content": "\"Note that you must do this in-place without making a copy of the array.\"\\n\\nI believe \"nums = (nums + ([0] * zero_size ))\" is  making a copy of the array"
                    },
                    {
                        "username": "saichandra004",
                        "content": "Cannot modify nums."
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# Easiest \\uD83D\\uDE0E FAANG Method Ever !!! \\uD83D\\uDCA5 \\n\\nhttps://leetcode.com/problems/move-zeroes/solutions/2872504/easiest-faang-method-ever/?orderBy=most_votes"
                    },
                    {
                        "username": "lanyiyun",
                        "content": "'''\\ndef moveZeroes(self, nums):\\n\\n        for i in range(nums.count(0)):\\n            nums.remove(0)\\n            nums.append(0)\\n'''"
                    },
                    {
                        "username": "starogre",
                        "content": "this doesn\\'t count. this creates a new list in memory. the challenge is to do it in-place"
                    },
                    {
                        "username": "saichandra004",
                        "content": "Cannot modify nums."
                    },
                    {
                        "username": "sainath81061",
                        "content": "public void MoveZeroes(int[] nums) {\\n        int i,count = 0;\\n        for(i=0;i<nums.Length;i++){\\n            if(nums[i] != 0){\\n                nums[count] = nums[i];\\n                count++;\\n            }\\n        }\\n        for(;count<nums.Length;count++){\\n            nums[count] = 0;\\n        }\\n        foreach(var x in nums){\\n            Console.WriteLine(x);\\n        }\\n    }"
                    },
                    {
                        "username": "LanceofLonginius",
                        "content": "do not post solutions here"
                    },
                    {
                        "username": "Kokopas",
                        "content": "Why this solution is not working,?\nI checked in on local interpreter and it works\n\nclass Solution:\n    def moveZeroes(self, nums) -> None:\n        \"\"\"\n        Do not return anything, modify nums in-place instead.\n        \"\"\"\n        zero_amount = nums.count(0)\n        zero_list=[]\n        n=0\n        while n < zero_amount:\n            zero_list.append(0)\n            n+=1      \n        nums = list(filter(lambda x: x!=0, nums))+zero_list"
                    },
                    {
                        "username": "vnhnhm",
                        "content": "[@muhammedirshadismail0722](/muhammedirshadismail0722) stop spamming"
                    },
                    {
                        "username": "Pranav_cs",
                        "content": "whe have to do it in-place don\\'t create a new list.\\nHint: use 2 pointers"
                    }
                ]
            },
            {
                "id": 1944210,
                "content": [
                    {
                        "username": "Nisha1205092",
                        "content": "it\\'s sad that I look for hints or ideas, but people just directly post codes here too!!! Whereas there\\'s a \\'solution\\' section separately. "
                    },
                    {
                        "username": "muhammedirshadismail0722",
                        "content": "\\n\\nEasiest \\uD83D\\uDE0E FAANG Method Ever !!! \\uD83D\\uDCA5||Best solution in python\\n\\n\\nhttps://leetcode.com/problems/move-zeroes/solutions/3923521/easiest-faang-method-ever-best-solution-in-python/"
                    },
                    {
                        "username": "aleazanrashid",
                        "content": "Let people discuss their issues with their solution "
                    },
                    {
                        "username": "mariusandries25",
                        "content": "It literally says not to post solutions in the discussion. This section is for tips and questions."
                    },
                    {
                        "username": "VladimirTheLeet",
                        "content": "I guess the rules don\\'t work for you if you can\\'t read \\xAF\\\\\\\\\\\\_(\\u30C4)_/\\xAF"
                    },
                    {
                        "username": "jerryy147",
                        "content": "all 3 rules say not to post a solution here in some form"
                    },
                    {
                        "username": "DoMonkeysFly7",
                        "content": "ppl are idiots frate, they wanna show how 'smart' they are"
                    },
                    {
                        "username": "mdegis",
                        "content": "I really do not understand how accepted solutions distribution works or measured for the solution.  I\\'ve basically submit the same solution 4 minutes apart, first one runtime was 491 ms and beat 25.21%... second one was 340 ms and beat 55.81%. Again, they are the same code! Nothing changed, not even an empty space. Just click \"submit\" button again. \\n\\nShould I stop caring about this number if there is no consistency at all?"
                    },
                    {
                        "username": "arc-arnob",
                        "content": "true and more over implicit declaration faster than explicit datatype declaration in typescript. "
                    },
                    {
                        "username": "bernardoolisan",
                        "content": "Is bc the leetcode server that runs your code might sometimes run faster or slower, is a compiler in a server. And yes, you should care about the percentage even if sometimes is not accurate, it gives you a approximation of how efficient is your code "
                    },
                    {
                        "username": "Priyamd",
                        "content": "i guess its a glitch "
                    },
                    {
                        "username": "potatopie",
                        "content": "its literally always the indians that post the solutions what concept of DISCUSSION do you guys not understand? "
                    },
                    {
                        "username": "AryanP45",
                        "content": "[@nKR5](/nKR5) Always fun reading these stereotypical comments"
                    },
                    {
                        "username": "nKR5",
                        "content": "Strong in programming language, weak in human communication language."
                    },
                    {
                        "username": "shubhamsharma123",
                        "content": " // striver solution\\n  int k=0;\\n        for(int i=0;i<nums.size();i++){\\n            if(nums[i]!=0){\\n            int temp=nums[k];\\n            nums[k]=nums[i];\\n            nums[i]= temp;\\n              k++;\\n            }\\n        }\\n        }"
                    },
                    {
                        "username": "vivekup3424",
                        "content": "Bro why you want hate by posting solution here, are you some kinda masochist."
                    },
                    {
                        "username": "swand0g",
                        "content": "nice job posting the solution in the one place leetcode specifies not to post solutions!"
                    },
                    {
                        "username": "neel19",
                        "content": "[@luan_hy](/luan_hy)  The instructor here (striver) has a very strong background in competitive programming. That\\'s how he can come up with such elegant solution. You can check out his tutorials on youtube. "
                    },
                    {
                        "username": "mariusandries25",
                        "content": "[@luan_hy](/luan_hy) The non-zero values are moved in front of array, the k variable keeping track of the moved values non-zero. Zeroes are implicit moving behind when swapping the non-zero. Then when encountering zero do nothing."
                    },
                    {
                        "username": "luan_hy",
                        "content": "Can you share what is your problem-solving step to come out with a so simple solution? "
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# Easiest \\uD83D\\uDE0E FAANG Method Ever !!! \\uD83D\\uDCA5 \\n\\nhttps://leetcode.com/problems/move-zeroes/solutions/2872504/easiest-faang-method-ever/?orderBy=most_votes"
                    },
                    {
                        "username": "atak",
                        "content": "\\t\\tzero_size = nums.count(0)\\n\\t\\tnums.delete(0)\\n\\t\\tnums = (nums + ([0] * zero_size ))"
                    },
                    {
                        "username": "muhammedirshadismail0722",
                        "content": "\\n\\nEasiest \\uD83D\\uDE0E FAANG Method Ever !!! \\uD83D\\uDCA5||Best solution in python\\n\\n\\nhttps://leetcode.com/problems/move-zeroes/solutions/3923521/easiest-faang-method-ever-best-solution-in-python/"
                    },
                    {
                        "username": "michaelknight492",
                        "content": "\"Note that you must do this in-place without making a copy of the array.\"\\n\\nI believe \"nums = (nums + ([0] * zero_size ))\" is  making a copy of the array"
                    },
                    {
                        "username": "saichandra004",
                        "content": "Cannot modify nums."
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# Easiest \\uD83D\\uDE0E FAANG Method Ever !!! \\uD83D\\uDCA5 \\n\\nhttps://leetcode.com/problems/move-zeroes/solutions/2872504/easiest-faang-method-ever/?orderBy=most_votes"
                    },
                    {
                        "username": "lanyiyun",
                        "content": "'''\\ndef moveZeroes(self, nums):\\n\\n        for i in range(nums.count(0)):\\n            nums.remove(0)\\n            nums.append(0)\\n'''"
                    },
                    {
                        "username": "starogre",
                        "content": "this doesn\\'t count. this creates a new list in memory. the challenge is to do it in-place"
                    },
                    {
                        "username": "saichandra004",
                        "content": "Cannot modify nums."
                    },
                    {
                        "username": "sainath81061",
                        "content": "public void MoveZeroes(int[] nums) {\\n        int i,count = 0;\\n        for(i=0;i<nums.Length;i++){\\n            if(nums[i] != 0){\\n                nums[count] = nums[i];\\n                count++;\\n            }\\n        }\\n        for(;count<nums.Length;count++){\\n            nums[count] = 0;\\n        }\\n        foreach(var x in nums){\\n            Console.WriteLine(x);\\n        }\\n    }"
                    },
                    {
                        "username": "LanceofLonginius",
                        "content": "do not post solutions here"
                    },
                    {
                        "username": "Kokopas",
                        "content": "Why this solution is not working,?\nI checked in on local interpreter and it works\n\nclass Solution:\n    def moveZeroes(self, nums) -> None:\n        \"\"\"\n        Do not return anything, modify nums in-place instead.\n        \"\"\"\n        zero_amount = nums.count(0)\n        zero_list=[]\n        n=0\n        while n < zero_amount:\n            zero_list.append(0)\n            n+=1      \n        nums = list(filter(lambda x: x!=0, nums))+zero_list"
                    },
                    {
                        "username": "vnhnhm",
                        "content": "[@muhammedirshadismail0722](/muhammedirshadismail0722) stop spamming"
                    },
                    {
                        "username": "Pranav_cs",
                        "content": "whe have to do it in-place don\\'t create a new list.\\nHint: use 2 pointers"
                    }
                ]
            },
            {
                "id": 1869625,
                "content": [
                    {
                        "username": "Nisha1205092",
                        "content": "it\\'s sad that I look for hints or ideas, but people just directly post codes here too!!! Whereas there\\'s a \\'solution\\' section separately. "
                    },
                    {
                        "username": "muhammedirshadismail0722",
                        "content": "\\n\\nEasiest \\uD83D\\uDE0E FAANG Method Ever !!! \\uD83D\\uDCA5||Best solution in python\\n\\n\\nhttps://leetcode.com/problems/move-zeroes/solutions/3923521/easiest-faang-method-ever-best-solution-in-python/"
                    },
                    {
                        "username": "aleazanrashid",
                        "content": "Let people discuss their issues with their solution "
                    },
                    {
                        "username": "mariusandries25",
                        "content": "It literally says not to post solutions in the discussion. This section is for tips and questions."
                    },
                    {
                        "username": "VladimirTheLeet",
                        "content": "I guess the rules don\\'t work for you if you can\\'t read \\xAF\\\\\\\\\\\\_(\\u30C4)_/\\xAF"
                    },
                    {
                        "username": "jerryy147",
                        "content": "all 3 rules say not to post a solution here in some form"
                    },
                    {
                        "username": "DoMonkeysFly7",
                        "content": "ppl are idiots frate, they wanna show how 'smart' they are"
                    },
                    {
                        "username": "mdegis",
                        "content": "I really do not understand how accepted solutions distribution works or measured for the solution.  I\\'ve basically submit the same solution 4 minutes apart, first one runtime was 491 ms and beat 25.21%... second one was 340 ms and beat 55.81%. Again, they are the same code! Nothing changed, not even an empty space. Just click \"submit\" button again. \\n\\nShould I stop caring about this number if there is no consistency at all?"
                    },
                    {
                        "username": "arc-arnob",
                        "content": "true and more over implicit declaration faster than explicit datatype declaration in typescript. "
                    },
                    {
                        "username": "bernardoolisan",
                        "content": "Is bc the leetcode server that runs your code might sometimes run faster or slower, is a compiler in a server. And yes, you should care about the percentage even if sometimes is not accurate, it gives you a approximation of how efficient is your code "
                    },
                    {
                        "username": "Priyamd",
                        "content": "i guess its a glitch "
                    },
                    {
                        "username": "potatopie",
                        "content": "its literally always the indians that post the solutions what concept of DISCUSSION do you guys not understand? "
                    },
                    {
                        "username": "AryanP45",
                        "content": "[@nKR5](/nKR5) Always fun reading these stereotypical comments"
                    },
                    {
                        "username": "nKR5",
                        "content": "Strong in programming language, weak in human communication language."
                    },
                    {
                        "username": "shubhamsharma123",
                        "content": " // striver solution\\n  int k=0;\\n        for(int i=0;i<nums.size();i++){\\n            if(nums[i]!=0){\\n            int temp=nums[k];\\n            nums[k]=nums[i];\\n            nums[i]= temp;\\n              k++;\\n            }\\n        }\\n        }"
                    },
                    {
                        "username": "vivekup3424",
                        "content": "Bro why you want hate by posting solution here, are you some kinda masochist."
                    },
                    {
                        "username": "swand0g",
                        "content": "nice job posting the solution in the one place leetcode specifies not to post solutions!"
                    },
                    {
                        "username": "neel19",
                        "content": "[@luan_hy](/luan_hy)  The instructor here (striver) has a very strong background in competitive programming. That\\'s how he can come up with such elegant solution. You can check out his tutorials on youtube. "
                    },
                    {
                        "username": "mariusandries25",
                        "content": "[@luan_hy](/luan_hy) The non-zero values are moved in front of array, the k variable keeping track of the moved values non-zero. Zeroes are implicit moving behind when swapping the non-zero. Then when encountering zero do nothing."
                    },
                    {
                        "username": "luan_hy",
                        "content": "Can you share what is your problem-solving step to come out with a so simple solution? "
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# Easiest \\uD83D\\uDE0E FAANG Method Ever !!! \\uD83D\\uDCA5 \\n\\nhttps://leetcode.com/problems/move-zeroes/solutions/2872504/easiest-faang-method-ever/?orderBy=most_votes"
                    },
                    {
                        "username": "atak",
                        "content": "\\t\\tzero_size = nums.count(0)\\n\\t\\tnums.delete(0)\\n\\t\\tnums = (nums + ([0] * zero_size ))"
                    },
                    {
                        "username": "muhammedirshadismail0722",
                        "content": "\\n\\nEasiest \\uD83D\\uDE0E FAANG Method Ever !!! \\uD83D\\uDCA5||Best solution in python\\n\\n\\nhttps://leetcode.com/problems/move-zeroes/solutions/3923521/easiest-faang-method-ever-best-solution-in-python/"
                    },
                    {
                        "username": "michaelknight492",
                        "content": "\"Note that you must do this in-place without making a copy of the array.\"\\n\\nI believe \"nums = (nums + ([0] * zero_size ))\" is  making a copy of the array"
                    },
                    {
                        "username": "saichandra004",
                        "content": "Cannot modify nums."
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# Easiest \\uD83D\\uDE0E FAANG Method Ever !!! \\uD83D\\uDCA5 \\n\\nhttps://leetcode.com/problems/move-zeroes/solutions/2872504/easiest-faang-method-ever/?orderBy=most_votes"
                    },
                    {
                        "username": "lanyiyun",
                        "content": "'''\\ndef moveZeroes(self, nums):\\n\\n        for i in range(nums.count(0)):\\n            nums.remove(0)\\n            nums.append(0)\\n'''"
                    },
                    {
                        "username": "starogre",
                        "content": "this doesn\\'t count. this creates a new list in memory. the challenge is to do it in-place"
                    },
                    {
                        "username": "saichandra004",
                        "content": "Cannot modify nums."
                    },
                    {
                        "username": "sainath81061",
                        "content": "public void MoveZeroes(int[] nums) {\\n        int i,count = 0;\\n        for(i=0;i<nums.Length;i++){\\n            if(nums[i] != 0){\\n                nums[count] = nums[i];\\n                count++;\\n            }\\n        }\\n        for(;count<nums.Length;count++){\\n            nums[count] = 0;\\n        }\\n        foreach(var x in nums){\\n            Console.WriteLine(x);\\n        }\\n    }"
                    },
                    {
                        "username": "LanceofLonginius",
                        "content": "do not post solutions here"
                    },
                    {
                        "username": "Kokopas",
                        "content": "Why this solution is not working,?\nI checked in on local interpreter and it works\n\nclass Solution:\n    def moveZeroes(self, nums) -> None:\n        \"\"\"\n        Do not return anything, modify nums in-place instead.\n        \"\"\"\n        zero_amount = nums.count(0)\n        zero_list=[]\n        n=0\n        while n < zero_amount:\n            zero_list.append(0)\n            n+=1      \n        nums = list(filter(lambda x: x!=0, nums))+zero_list"
                    },
                    {
                        "username": "vnhnhm",
                        "content": "[@muhammedirshadismail0722](/muhammedirshadismail0722) stop spamming"
                    },
                    {
                        "username": "Pranav_cs",
                        "content": "whe have to do it in-place don\\'t create a new list.\\nHint: use 2 pointers"
                    }
                ]
            },
            {
                "id": 1838268,
                "content": [
                    {
                        "username": "Nisha1205092",
                        "content": "it\\'s sad that I look for hints or ideas, but people just directly post codes here too!!! Whereas there\\'s a \\'solution\\' section separately. "
                    },
                    {
                        "username": "muhammedirshadismail0722",
                        "content": "\\n\\nEasiest \\uD83D\\uDE0E FAANG Method Ever !!! \\uD83D\\uDCA5||Best solution in python\\n\\n\\nhttps://leetcode.com/problems/move-zeroes/solutions/3923521/easiest-faang-method-ever-best-solution-in-python/"
                    },
                    {
                        "username": "aleazanrashid",
                        "content": "Let people discuss their issues with their solution "
                    },
                    {
                        "username": "mariusandries25",
                        "content": "It literally says not to post solutions in the discussion. This section is for tips and questions."
                    },
                    {
                        "username": "VladimirTheLeet",
                        "content": "I guess the rules don\\'t work for you if you can\\'t read \\xAF\\\\\\\\\\\\_(\\u30C4)_/\\xAF"
                    },
                    {
                        "username": "jerryy147",
                        "content": "all 3 rules say not to post a solution here in some form"
                    },
                    {
                        "username": "DoMonkeysFly7",
                        "content": "ppl are idiots frate, they wanna show how 'smart' they are"
                    },
                    {
                        "username": "mdegis",
                        "content": "I really do not understand how accepted solutions distribution works or measured for the solution.  I\\'ve basically submit the same solution 4 minutes apart, first one runtime was 491 ms and beat 25.21%... second one was 340 ms and beat 55.81%. Again, they are the same code! Nothing changed, not even an empty space. Just click \"submit\" button again. \\n\\nShould I stop caring about this number if there is no consistency at all?"
                    },
                    {
                        "username": "arc-arnob",
                        "content": "true and more over implicit declaration faster than explicit datatype declaration in typescript. "
                    },
                    {
                        "username": "bernardoolisan",
                        "content": "Is bc the leetcode server that runs your code might sometimes run faster or slower, is a compiler in a server. And yes, you should care about the percentage even if sometimes is not accurate, it gives you a approximation of how efficient is your code "
                    },
                    {
                        "username": "Priyamd",
                        "content": "i guess its a glitch "
                    },
                    {
                        "username": "potatopie",
                        "content": "its literally always the indians that post the solutions what concept of DISCUSSION do you guys not understand? "
                    },
                    {
                        "username": "AryanP45",
                        "content": "[@nKR5](/nKR5) Always fun reading these stereotypical comments"
                    },
                    {
                        "username": "nKR5",
                        "content": "Strong in programming language, weak in human communication language."
                    },
                    {
                        "username": "shubhamsharma123",
                        "content": " // striver solution\\n  int k=0;\\n        for(int i=0;i<nums.size();i++){\\n            if(nums[i]!=0){\\n            int temp=nums[k];\\n            nums[k]=nums[i];\\n            nums[i]= temp;\\n              k++;\\n            }\\n        }\\n        }"
                    },
                    {
                        "username": "vivekup3424",
                        "content": "Bro why you want hate by posting solution here, are you some kinda masochist."
                    },
                    {
                        "username": "swand0g",
                        "content": "nice job posting the solution in the one place leetcode specifies not to post solutions!"
                    },
                    {
                        "username": "neel19",
                        "content": "[@luan_hy](/luan_hy)  The instructor here (striver) has a very strong background in competitive programming. That\\'s how he can come up with such elegant solution. You can check out his tutorials on youtube. "
                    },
                    {
                        "username": "mariusandries25",
                        "content": "[@luan_hy](/luan_hy) The non-zero values are moved in front of array, the k variable keeping track of the moved values non-zero. Zeroes are implicit moving behind when swapping the non-zero. Then when encountering zero do nothing."
                    },
                    {
                        "username": "luan_hy",
                        "content": "Can you share what is your problem-solving step to come out with a so simple solution? "
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# Easiest \\uD83D\\uDE0E FAANG Method Ever !!! \\uD83D\\uDCA5 \\n\\nhttps://leetcode.com/problems/move-zeroes/solutions/2872504/easiest-faang-method-ever/?orderBy=most_votes"
                    },
                    {
                        "username": "atak",
                        "content": "\\t\\tzero_size = nums.count(0)\\n\\t\\tnums.delete(0)\\n\\t\\tnums = (nums + ([0] * zero_size ))"
                    },
                    {
                        "username": "muhammedirshadismail0722",
                        "content": "\\n\\nEasiest \\uD83D\\uDE0E FAANG Method Ever !!! \\uD83D\\uDCA5||Best solution in python\\n\\n\\nhttps://leetcode.com/problems/move-zeroes/solutions/3923521/easiest-faang-method-ever-best-solution-in-python/"
                    },
                    {
                        "username": "michaelknight492",
                        "content": "\"Note that you must do this in-place without making a copy of the array.\"\\n\\nI believe \"nums = (nums + ([0] * zero_size ))\" is  making a copy of the array"
                    },
                    {
                        "username": "saichandra004",
                        "content": "Cannot modify nums."
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# Easiest \\uD83D\\uDE0E FAANG Method Ever !!! \\uD83D\\uDCA5 \\n\\nhttps://leetcode.com/problems/move-zeroes/solutions/2872504/easiest-faang-method-ever/?orderBy=most_votes"
                    },
                    {
                        "username": "lanyiyun",
                        "content": "'''\\ndef moveZeroes(self, nums):\\n\\n        for i in range(nums.count(0)):\\n            nums.remove(0)\\n            nums.append(0)\\n'''"
                    },
                    {
                        "username": "starogre",
                        "content": "this doesn\\'t count. this creates a new list in memory. the challenge is to do it in-place"
                    },
                    {
                        "username": "saichandra004",
                        "content": "Cannot modify nums."
                    },
                    {
                        "username": "sainath81061",
                        "content": "public void MoveZeroes(int[] nums) {\\n        int i,count = 0;\\n        for(i=0;i<nums.Length;i++){\\n            if(nums[i] != 0){\\n                nums[count] = nums[i];\\n                count++;\\n            }\\n        }\\n        for(;count<nums.Length;count++){\\n            nums[count] = 0;\\n        }\\n        foreach(var x in nums){\\n            Console.WriteLine(x);\\n        }\\n    }"
                    },
                    {
                        "username": "LanceofLonginius",
                        "content": "do not post solutions here"
                    },
                    {
                        "username": "Kokopas",
                        "content": "Why this solution is not working,?\nI checked in on local interpreter and it works\n\nclass Solution:\n    def moveZeroes(self, nums) -> None:\n        \"\"\"\n        Do not return anything, modify nums in-place instead.\n        \"\"\"\n        zero_amount = nums.count(0)\n        zero_list=[]\n        n=0\n        while n < zero_amount:\n            zero_list.append(0)\n            n+=1      \n        nums = list(filter(lambda x: x!=0, nums))+zero_list"
                    },
                    {
                        "username": "vnhnhm",
                        "content": "[@muhammedirshadismail0722](/muhammedirshadismail0722) stop spamming"
                    },
                    {
                        "username": "Pranav_cs",
                        "content": "whe have to do it in-place don\\'t create a new list.\\nHint: use 2 pointers"
                    }
                ]
            },
            {
                "id": 1821489,
                "content": [
                    {
                        "username": "Nisha1205092",
                        "content": "it\\'s sad that I look for hints or ideas, but people just directly post codes here too!!! Whereas there\\'s a \\'solution\\' section separately. "
                    },
                    {
                        "username": "muhammedirshadismail0722",
                        "content": "\\n\\nEasiest \\uD83D\\uDE0E FAANG Method Ever !!! \\uD83D\\uDCA5||Best solution in python\\n\\n\\nhttps://leetcode.com/problems/move-zeroes/solutions/3923521/easiest-faang-method-ever-best-solution-in-python/"
                    },
                    {
                        "username": "aleazanrashid",
                        "content": "Let people discuss their issues with their solution "
                    },
                    {
                        "username": "mariusandries25",
                        "content": "It literally says not to post solutions in the discussion. This section is for tips and questions."
                    },
                    {
                        "username": "VladimirTheLeet",
                        "content": "I guess the rules don\\'t work for you if you can\\'t read \\xAF\\\\\\\\\\\\_(\\u30C4)_/\\xAF"
                    },
                    {
                        "username": "jerryy147",
                        "content": "all 3 rules say not to post a solution here in some form"
                    },
                    {
                        "username": "DoMonkeysFly7",
                        "content": "ppl are idiots frate, they wanna show how 'smart' they are"
                    },
                    {
                        "username": "mdegis",
                        "content": "I really do not understand how accepted solutions distribution works or measured for the solution.  I\\'ve basically submit the same solution 4 minutes apart, first one runtime was 491 ms and beat 25.21%... second one was 340 ms and beat 55.81%. Again, they are the same code! Nothing changed, not even an empty space. Just click \"submit\" button again. \\n\\nShould I stop caring about this number if there is no consistency at all?"
                    },
                    {
                        "username": "arc-arnob",
                        "content": "true and more over implicit declaration faster than explicit datatype declaration in typescript. "
                    },
                    {
                        "username": "bernardoolisan",
                        "content": "Is bc the leetcode server that runs your code might sometimes run faster or slower, is a compiler in a server. And yes, you should care about the percentage even if sometimes is not accurate, it gives you a approximation of how efficient is your code "
                    },
                    {
                        "username": "Priyamd",
                        "content": "i guess its a glitch "
                    },
                    {
                        "username": "potatopie",
                        "content": "its literally always the indians that post the solutions what concept of DISCUSSION do you guys not understand? "
                    },
                    {
                        "username": "AryanP45",
                        "content": "[@nKR5](/nKR5) Always fun reading these stereotypical comments"
                    },
                    {
                        "username": "nKR5",
                        "content": "Strong in programming language, weak in human communication language."
                    },
                    {
                        "username": "shubhamsharma123",
                        "content": " // striver solution\\n  int k=0;\\n        for(int i=0;i<nums.size();i++){\\n            if(nums[i]!=0){\\n            int temp=nums[k];\\n            nums[k]=nums[i];\\n            nums[i]= temp;\\n              k++;\\n            }\\n        }\\n        }"
                    },
                    {
                        "username": "vivekup3424",
                        "content": "Bro why you want hate by posting solution here, are you some kinda masochist."
                    },
                    {
                        "username": "swand0g",
                        "content": "nice job posting the solution in the one place leetcode specifies not to post solutions!"
                    },
                    {
                        "username": "neel19",
                        "content": "[@luan_hy](/luan_hy)  The instructor here (striver) has a very strong background in competitive programming. That\\'s how he can come up with such elegant solution. You can check out his tutorials on youtube. "
                    },
                    {
                        "username": "mariusandries25",
                        "content": "[@luan_hy](/luan_hy) The non-zero values are moved in front of array, the k variable keeping track of the moved values non-zero. Zeroes are implicit moving behind when swapping the non-zero. Then when encountering zero do nothing."
                    },
                    {
                        "username": "luan_hy",
                        "content": "Can you share what is your problem-solving step to come out with a so simple solution? "
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# Easiest \\uD83D\\uDE0E FAANG Method Ever !!! \\uD83D\\uDCA5 \\n\\nhttps://leetcode.com/problems/move-zeroes/solutions/2872504/easiest-faang-method-ever/?orderBy=most_votes"
                    },
                    {
                        "username": "atak",
                        "content": "\\t\\tzero_size = nums.count(0)\\n\\t\\tnums.delete(0)\\n\\t\\tnums = (nums + ([0] * zero_size ))"
                    },
                    {
                        "username": "muhammedirshadismail0722",
                        "content": "\\n\\nEasiest \\uD83D\\uDE0E FAANG Method Ever !!! \\uD83D\\uDCA5||Best solution in python\\n\\n\\nhttps://leetcode.com/problems/move-zeroes/solutions/3923521/easiest-faang-method-ever-best-solution-in-python/"
                    },
                    {
                        "username": "michaelknight492",
                        "content": "\"Note that you must do this in-place without making a copy of the array.\"\\n\\nI believe \"nums = (nums + ([0] * zero_size ))\" is  making a copy of the array"
                    },
                    {
                        "username": "saichandra004",
                        "content": "Cannot modify nums."
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# Easiest \\uD83D\\uDE0E FAANG Method Ever !!! \\uD83D\\uDCA5 \\n\\nhttps://leetcode.com/problems/move-zeroes/solutions/2872504/easiest-faang-method-ever/?orderBy=most_votes"
                    },
                    {
                        "username": "lanyiyun",
                        "content": "'''\\ndef moveZeroes(self, nums):\\n\\n        for i in range(nums.count(0)):\\n            nums.remove(0)\\n            nums.append(0)\\n'''"
                    },
                    {
                        "username": "starogre",
                        "content": "this doesn\\'t count. this creates a new list in memory. the challenge is to do it in-place"
                    },
                    {
                        "username": "saichandra004",
                        "content": "Cannot modify nums."
                    },
                    {
                        "username": "sainath81061",
                        "content": "public void MoveZeroes(int[] nums) {\\n        int i,count = 0;\\n        for(i=0;i<nums.Length;i++){\\n            if(nums[i] != 0){\\n                nums[count] = nums[i];\\n                count++;\\n            }\\n        }\\n        for(;count<nums.Length;count++){\\n            nums[count] = 0;\\n        }\\n        foreach(var x in nums){\\n            Console.WriteLine(x);\\n        }\\n    }"
                    },
                    {
                        "username": "LanceofLonginius",
                        "content": "do not post solutions here"
                    },
                    {
                        "username": "Kokopas",
                        "content": "Why this solution is not working,?\nI checked in on local interpreter and it works\n\nclass Solution:\n    def moveZeroes(self, nums) -> None:\n        \"\"\"\n        Do not return anything, modify nums in-place instead.\n        \"\"\"\n        zero_amount = nums.count(0)\n        zero_list=[]\n        n=0\n        while n < zero_amount:\n            zero_list.append(0)\n            n+=1      \n        nums = list(filter(lambda x: x!=0, nums))+zero_list"
                    },
                    {
                        "username": "vnhnhm",
                        "content": "[@muhammedirshadismail0722](/muhammedirshadismail0722) stop spamming"
                    },
                    {
                        "username": "Pranav_cs",
                        "content": "whe have to do it in-place don\\'t create a new list.\\nHint: use 2 pointers"
                    }
                ]
            },
            {
                "id": 1744663,
                "content": [
                    {
                        "username": "Nisha1205092",
                        "content": "it\\'s sad that I look for hints or ideas, but people just directly post codes here too!!! Whereas there\\'s a \\'solution\\' section separately. "
                    },
                    {
                        "username": "muhammedirshadismail0722",
                        "content": "\\n\\nEasiest \\uD83D\\uDE0E FAANG Method Ever !!! \\uD83D\\uDCA5||Best solution in python\\n\\n\\nhttps://leetcode.com/problems/move-zeroes/solutions/3923521/easiest-faang-method-ever-best-solution-in-python/"
                    },
                    {
                        "username": "aleazanrashid",
                        "content": "Let people discuss their issues with their solution "
                    },
                    {
                        "username": "mariusandries25",
                        "content": "It literally says not to post solutions in the discussion. This section is for tips and questions."
                    },
                    {
                        "username": "VladimirTheLeet",
                        "content": "I guess the rules don\\'t work for you if you can\\'t read \\xAF\\\\\\\\\\\\_(\\u30C4)_/\\xAF"
                    },
                    {
                        "username": "jerryy147",
                        "content": "all 3 rules say not to post a solution here in some form"
                    },
                    {
                        "username": "DoMonkeysFly7",
                        "content": "ppl are idiots frate, they wanna show how 'smart' they are"
                    },
                    {
                        "username": "mdegis",
                        "content": "I really do not understand how accepted solutions distribution works or measured for the solution.  I\\'ve basically submit the same solution 4 minutes apart, first one runtime was 491 ms and beat 25.21%... second one was 340 ms and beat 55.81%. Again, they are the same code! Nothing changed, not even an empty space. Just click \"submit\" button again. \\n\\nShould I stop caring about this number if there is no consistency at all?"
                    },
                    {
                        "username": "arc-arnob",
                        "content": "true and more over implicit declaration faster than explicit datatype declaration in typescript. "
                    },
                    {
                        "username": "bernardoolisan",
                        "content": "Is bc the leetcode server that runs your code might sometimes run faster or slower, is a compiler in a server. And yes, you should care about the percentage even if sometimes is not accurate, it gives you a approximation of how efficient is your code "
                    },
                    {
                        "username": "Priyamd",
                        "content": "i guess its a glitch "
                    },
                    {
                        "username": "potatopie",
                        "content": "its literally always the indians that post the solutions what concept of DISCUSSION do you guys not understand? "
                    },
                    {
                        "username": "AryanP45",
                        "content": "[@nKR5](/nKR5) Always fun reading these stereotypical comments"
                    },
                    {
                        "username": "nKR5",
                        "content": "Strong in programming language, weak in human communication language."
                    },
                    {
                        "username": "shubhamsharma123",
                        "content": " // striver solution\\n  int k=0;\\n        for(int i=0;i<nums.size();i++){\\n            if(nums[i]!=0){\\n            int temp=nums[k];\\n            nums[k]=nums[i];\\n            nums[i]= temp;\\n              k++;\\n            }\\n        }\\n        }"
                    },
                    {
                        "username": "vivekup3424",
                        "content": "Bro why you want hate by posting solution here, are you some kinda masochist."
                    },
                    {
                        "username": "swand0g",
                        "content": "nice job posting the solution in the one place leetcode specifies not to post solutions!"
                    },
                    {
                        "username": "neel19",
                        "content": "[@luan_hy](/luan_hy)  The instructor here (striver) has a very strong background in competitive programming. That\\'s how he can come up with such elegant solution. You can check out his tutorials on youtube. "
                    },
                    {
                        "username": "mariusandries25",
                        "content": "[@luan_hy](/luan_hy) The non-zero values are moved in front of array, the k variable keeping track of the moved values non-zero. Zeroes are implicit moving behind when swapping the non-zero. Then when encountering zero do nothing."
                    },
                    {
                        "username": "luan_hy",
                        "content": "Can you share what is your problem-solving step to come out with a so simple solution? "
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# Easiest \\uD83D\\uDE0E FAANG Method Ever !!! \\uD83D\\uDCA5 \\n\\nhttps://leetcode.com/problems/move-zeroes/solutions/2872504/easiest-faang-method-ever/?orderBy=most_votes"
                    },
                    {
                        "username": "atak",
                        "content": "\\t\\tzero_size = nums.count(0)\\n\\t\\tnums.delete(0)\\n\\t\\tnums = (nums + ([0] * zero_size ))"
                    },
                    {
                        "username": "muhammedirshadismail0722",
                        "content": "\\n\\nEasiest \\uD83D\\uDE0E FAANG Method Ever !!! \\uD83D\\uDCA5||Best solution in python\\n\\n\\nhttps://leetcode.com/problems/move-zeroes/solutions/3923521/easiest-faang-method-ever-best-solution-in-python/"
                    },
                    {
                        "username": "michaelknight492",
                        "content": "\"Note that you must do this in-place without making a copy of the array.\"\\n\\nI believe \"nums = (nums + ([0] * zero_size ))\" is  making a copy of the array"
                    },
                    {
                        "username": "saichandra004",
                        "content": "Cannot modify nums."
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# Easiest \\uD83D\\uDE0E FAANG Method Ever !!! \\uD83D\\uDCA5 \\n\\nhttps://leetcode.com/problems/move-zeroes/solutions/2872504/easiest-faang-method-ever/?orderBy=most_votes"
                    },
                    {
                        "username": "lanyiyun",
                        "content": "'''\\ndef moveZeroes(self, nums):\\n\\n        for i in range(nums.count(0)):\\n            nums.remove(0)\\n            nums.append(0)\\n'''"
                    },
                    {
                        "username": "starogre",
                        "content": "this doesn\\'t count. this creates a new list in memory. the challenge is to do it in-place"
                    },
                    {
                        "username": "saichandra004",
                        "content": "Cannot modify nums."
                    },
                    {
                        "username": "sainath81061",
                        "content": "public void MoveZeroes(int[] nums) {\\n        int i,count = 0;\\n        for(i=0;i<nums.Length;i++){\\n            if(nums[i] != 0){\\n                nums[count] = nums[i];\\n                count++;\\n            }\\n        }\\n        for(;count<nums.Length;count++){\\n            nums[count] = 0;\\n        }\\n        foreach(var x in nums){\\n            Console.WriteLine(x);\\n        }\\n    }"
                    },
                    {
                        "username": "LanceofLonginius",
                        "content": "do not post solutions here"
                    },
                    {
                        "username": "Kokopas",
                        "content": "Why this solution is not working,?\nI checked in on local interpreter and it works\n\nclass Solution:\n    def moveZeroes(self, nums) -> None:\n        \"\"\"\n        Do not return anything, modify nums in-place instead.\n        \"\"\"\n        zero_amount = nums.count(0)\n        zero_list=[]\n        n=0\n        while n < zero_amount:\n            zero_list.append(0)\n            n+=1      \n        nums = list(filter(lambda x: x!=0, nums))+zero_list"
                    },
                    {
                        "username": "vnhnhm",
                        "content": "[@muhammedirshadismail0722](/muhammedirshadismail0722) stop spamming"
                    },
                    {
                        "username": "Pranav_cs",
                        "content": "whe have to do it in-place don\\'t create a new list.\\nHint: use 2 pointers"
                    }
                ]
            },
            {
                "id": 2029724,
                "content": [
                    {
                        "username": "Nisha1205092",
                        "content": "it\\'s sad that I look for hints or ideas, but people just directly post codes here too!!! Whereas there\\'s a \\'solution\\' section separately. "
                    },
                    {
                        "username": "muhammedirshadismail0722",
                        "content": "\\n\\nEasiest \\uD83D\\uDE0E FAANG Method Ever !!! \\uD83D\\uDCA5||Best solution in python\\n\\n\\nhttps://leetcode.com/problems/move-zeroes/solutions/3923521/easiest-faang-method-ever-best-solution-in-python/"
                    },
                    {
                        "username": "aleazanrashid",
                        "content": "Let people discuss their issues with their solution "
                    },
                    {
                        "username": "mariusandries25",
                        "content": "It literally says not to post solutions in the discussion. This section is for tips and questions."
                    },
                    {
                        "username": "VladimirTheLeet",
                        "content": "I guess the rules don\\'t work for you if you can\\'t read \\xAF\\\\\\\\\\\\_(\\u30C4)_/\\xAF"
                    },
                    {
                        "username": "jerryy147",
                        "content": "all 3 rules say not to post a solution here in some form"
                    },
                    {
                        "username": "DoMonkeysFly7",
                        "content": "ppl are idiots frate, they wanna show how 'smart' they are"
                    },
                    {
                        "username": "mdegis",
                        "content": "I really do not understand how accepted solutions distribution works or measured for the solution.  I\\'ve basically submit the same solution 4 minutes apart, first one runtime was 491 ms and beat 25.21%... second one was 340 ms and beat 55.81%. Again, they are the same code! Nothing changed, not even an empty space. Just click \"submit\" button again. \\n\\nShould I stop caring about this number if there is no consistency at all?"
                    },
                    {
                        "username": "arc-arnob",
                        "content": "true and more over implicit declaration faster than explicit datatype declaration in typescript. "
                    },
                    {
                        "username": "bernardoolisan",
                        "content": "Is bc the leetcode server that runs your code might sometimes run faster or slower, is a compiler in a server. And yes, you should care about the percentage even if sometimes is not accurate, it gives you a approximation of how efficient is your code "
                    },
                    {
                        "username": "Priyamd",
                        "content": "i guess its a glitch "
                    },
                    {
                        "username": "potatopie",
                        "content": "its literally always the indians that post the solutions what concept of DISCUSSION do you guys not understand? "
                    },
                    {
                        "username": "AryanP45",
                        "content": "[@nKR5](/nKR5) Always fun reading these stereotypical comments"
                    },
                    {
                        "username": "nKR5",
                        "content": "Strong in programming language, weak in human communication language."
                    },
                    {
                        "username": "shubhamsharma123",
                        "content": " // striver solution\\n  int k=0;\\n        for(int i=0;i<nums.size();i++){\\n            if(nums[i]!=0){\\n            int temp=nums[k];\\n            nums[k]=nums[i];\\n            nums[i]= temp;\\n              k++;\\n            }\\n        }\\n        }"
                    },
                    {
                        "username": "vivekup3424",
                        "content": "Bro why you want hate by posting solution here, are you some kinda masochist."
                    },
                    {
                        "username": "swand0g",
                        "content": "nice job posting the solution in the one place leetcode specifies not to post solutions!"
                    },
                    {
                        "username": "neel19",
                        "content": "[@luan_hy](/luan_hy)  The instructor here (striver) has a very strong background in competitive programming. That\\'s how he can come up with such elegant solution. You can check out his tutorials on youtube. "
                    },
                    {
                        "username": "mariusandries25",
                        "content": "[@luan_hy](/luan_hy) The non-zero values are moved in front of array, the k variable keeping track of the moved values non-zero. Zeroes are implicit moving behind when swapping the non-zero. Then when encountering zero do nothing."
                    },
                    {
                        "username": "luan_hy",
                        "content": "Can you share what is your problem-solving step to come out with a so simple solution? "
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# Easiest \\uD83D\\uDE0E FAANG Method Ever !!! \\uD83D\\uDCA5 \\n\\nhttps://leetcode.com/problems/move-zeroes/solutions/2872504/easiest-faang-method-ever/?orderBy=most_votes"
                    },
                    {
                        "username": "atak",
                        "content": "\\t\\tzero_size = nums.count(0)\\n\\t\\tnums.delete(0)\\n\\t\\tnums = (nums + ([0] * zero_size ))"
                    },
                    {
                        "username": "muhammedirshadismail0722",
                        "content": "\\n\\nEasiest \\uD83D\\uDE0E FAANG Method Ever !!! \\uD83D\\uDCA5||Best solution in python\\n\\n\\nhttps://leetcode.com/problems/move-zeroes/solutions/3923521/easiest-faang-method-ever-best-solution-in-python/"
                    },
                    {
                        "username": "michaelknight492",
                        "content": "\"Note that you must do this in-place without making a copy of the array.\"\\n\\nI believe \"nums = (nums + ([0] * zero_size ))\" is  making a copy of the array"
                    },
                    {
                        "username": "saichandra004",
                        "content": "Cannot modify nums."
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# Easiest \\uD83D\\uDE0E FAANG Method Ever !!! \\uD83D\\uDCA5 \\n\\nhttps://leetcode.com/problems/move-zeroes/solutions/2872504/easiest-faang-method-ever/?orderBy=most_votes"
                    },
                    {
                        "username": "lanyiyun",
                        "content": "'''\\ndef moveZeroes(self, nums):\\n\\n        for i in range(nums.count(0)):\\n            nums.remove(0)\\n            nums.append(0)\\n'''"
                    },
                    {
                        "username": "starogre",
                        "content": "this doesn\\'t count. this creates a new list in memory. the challenge is to do it in-place"
                    },
                    {
                        "username": "saichandra004",
                        "content": "Cannot modify nums."
                    },
                    {
                        "username": "sainath81061",
                        "content": "public void MoveZeroes(int[] nums) {\\n        int i,count = 0;\\n        for(i=0;i<nums.Length;i++){\\n            if(nums[i] != 0){\\n                nums[count] = nums[i];\\n                count++;\\n            }\\n        }\\n        for(;count<nums.Length;count++){\\n            nums[count] = 0;\\n        }\\n        foreach(var x in nums){\\n            Console.WriteLine(x);\\n        }\\n    }"
                    },
                    {
                        "username": "LanceofLonginius",
                        "content": "do not post solutions here"
                    },
                    {
                        "username": "Kokopas",
                        "content": "Why this solution is not working,?\nI checked in on local interpreter and it works\n\nclass Solution:\n    def moveZeroes(self, nums) -> None:\n        \"\"\"\n        Do not return anything, modify nums in-place instead.\n        \"\"\"\n        zero_amount = nums.count(0)\n        zero_list=[]\n        n=0\n        while n < zero_amount:\n            zero_list.append(0)\n            n+=1      \n        nums = list(filter(lambda x: x!=0, nums))+zero_list"
                    },
                    {
                        "username": "vnhnhm",
                        "content": "[@muhammedirshadismail0722](/muhammedirshadismail0722) stop spamming"
                    },
                    {
                        "username": "Pranav_cs",
                        "content": "whe have to do it in-place don\\'t create a new list.\\nHint: use 2 pointers"
                    }
                ]
            },
            {
                "id": 1625836,
                "content": [
                    {
                        "username": "Nisha1205092",
                        "content": "it\\'s sad that I look for hints or ideas, but people just directly post codes here too!!! Whereas there\\'s a \\'solution\\' section separately. "
                    },
                    {
                        "username": "muhammedirshadismail0722",
                        "content": "\\n\\nEasiest \\uD83D\\uDE0E FAANG Method Ever !!! \\uD83D\\uDCA5||Best solution in python\\n\\n\\nhttps://leetcode.com/problems/move-zeroes/solutions/3923521/easiest-faang-method-ever-best-solution-in-python/"
                    },
                    {
                        "username": "aleazanrashid",
                        "content": "Let people discuss their issues with their solution "
                    },
                    {
                        "username": "mariusandries25",
                        "content": "It literally says not to post solutions in the discussion. This section is for tips and questions."
                    },
                    {
                        "username": "VladimirTheLeet",
                        "content": "I guess the rules don\\'t work for you if you can\\'t read \\xAF\\\\\\\\\\\\_(\\u30C4)_/\\xAF"
                    },
                    {
                        "username": "jerryy147",
                        "content": "all 3 rules say not to post a solution here in some form"
                    },
                    {
                        "username": "DoMonkeysFly7",
                        "content": "ppl are idiots frate, they wanna show how 'smart' they are"
                    },
                    {
                        "username": "mdegis",
                        "content": "I really do not understand how accepted solutions distribution works or measured for the solution.  I\\'ve basically submit the same solution 4 minutes apart, first one runtime was 491 ms and beat 25.21%... second one was 340 ms and beat 55.81%. Again, they are the same code! Nothing changed, not even an empty space. Just click \"submit\" button again. \\n\\nShould I stop caring about this number if there is no consistency at all?"
                    },
                    {
                        "username": "arc-arnob",
                        "content": "true and more over implicit declaration faster than explicit datatype declaration in typescript. "
                    },
                    {
                        "username": "bernardoolisan",
                        "content": "Is bc the leetcode server that runs your code might sometimes run faster or slower, is a compiler in a server. And yes, you should care about the percentage even if sometimes is not accurate, it gives you a approximation of how efficient is your code "
                    },
                    {
                        "username": "Priyamd",
                        "content": "i guess its a glitch "
                    },
                    {
                        "username": "potatopie",
                        "content": "its literally always the indians that post the solutions what concept of DISCUSSION do you guys not understand? "
                    },
                    {
                        "username": "AryanP45",
                        "content": "[@nKR5](/nKR5) Always fun reading these stereotypical comments"
                    },
                    {
                        "username": "nKR5",
                        "content": "Strong in programming language, weak in human communication language."
                    },
                    {
                        "username": "shubhamsharma123",
                        "content": " // striver solution\\n  int k=0;\\n        for(int i=0;i<nums.size();i++){\\n            if(nums[i]!=0){\\n            int temp=nums[k];\\n            nums[k]=nums[i];\\n            nums[i]= temp;\\n              k++;\\n            }\\n        }\\n        }"
                    },
                    {
                        "username": "vivekup3424",
                        "content": "Bro why you want hate by posting solution here, are you some kinda masochist."
                    },
                    {
                        "username": "swand0g",
                        "content": "nice job posting the solution in the one place leetcode specifies not to post solutions!"
                    },
                    {
                        "username": "neel19",
                        "content": "[@luan_hy](/luan_hy)  The instructor here (striver) has a very strong background in competitive programming. That\\'s how he can come up with such elegant solution. You can check out his tutorials on youtube. "
                    },
                    {
                        "username": "mariusandries25",
                        "content": "[@luan_hy](/luan_hy) The non-zero values are moved in front of array, the k variable keeping track of the moved values non-zero. Zeroes are implicit moving behind when swapping the non-zero. Then when encountering zero do nothing."
                    },
                    {
                        "username": "luan_hy",
                        "content": "Can you share what is your problem-solving step to come out with a so simple solution? "
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# Easiest \\uD83D\\uDE0E FAANG Method Ever !!! \\uD83D\\uDCA5 \\n\\nhttps://leetcode.com/problems/move-zeroes/solutions/2872504/easiest-faang-method-ever/?orderBy=most_votes"
                    },
                    {
                        "username": "atak",
                        "content": "\\t\\tzero_size = nums.count(0)\\n\\t\\tnums.delete(0)\\n\\t\\tnums = (nums + ([0] * zero_size ))"
                    },
                    {
                        "username": "muhammedirshadismail0722",
                        "content": "\\n\\nEasiest \\uD83D\\uDE0E FAANG Method Ever !!! \\uD83D\\uDCA5||Best solution in python\\n\\n\\nhttps://leetcode.com/problems/move-zeroes/solutions/3923521/easiest-faang-method-ever-best-solution-in-python/"
                    },
                    {
                        "username": "michaelknight492",
                        "content": "\"Note that you must do this in-place without making a copy of the array.\"\\n\\nI believe \"nums = (nums + ([0] * zero_size ))\" is  making a copy of the array"
                    },
                    {
                        "username": "saichandra004",
                        "content": "Cannot modify nums."
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# Easiest \\uD83D\\uDE0E FAANG Method Ever !!! \\uD83D\\uDCA5 \\n\\nhttps://leetcode.com/problems/move-zeroes/solutions/2872504/easiest-faang-method-ever/?orderBy=most_votes"
                    },
                    {
                        "username": "lanyiyun",
                        "content": "'''\\ndef moveZeroes(self, nums):\\n\\n        for i in range(nums.count(0)):\\n            nums.remove(0)\\n            nums.append(0)\\n'''"
                    },
                    {
                        "username": "starogre",
                        "content": "this doesn\\'t count. this creates a new list in memory. the challenge is to do it in-place"
                    },
                    {
                        "username": "saichandra004",
                        "content": "Cannot modify nums."
                    },
                    {
                        "username": "sainath81061",
                        "content": "public void MoveZeroes(int[] nums) {\\n        int i,count = 0;\\n        for(i=0;i<nums.Length;i++){\\n            if(nums[i] != 0){\\n                nums[count] = nums[i];\\n                count++;\\n            }\\n        }\\n        for(;count<nums.Length;count++){\\n            nums[count] = 0;\\n        }\\n        foreach(var x in nums){\\n            Console.WriteLine(x);\\n        }\\n    }"
                    },
                    {
                        "username": "LanceofLonginius",
                        "content": "do not post solutions here"
                    },
                    {
                        "username": "Kokopas",
                        "content": "Why this solution is not working,?\nI checked in on local interpreter and it works\n\nclass Solution:\n    def moveZeroes(self, nums) -> None:\n        \"\"\"\n        Do not return anything, modify nums in-place instead.\n        \"\"\"\n        zero_amount = nums.count(0)\n        zero_list=[]\n        n=0\n        while n < zero_amount:\n            zero_list.append(0)\n            n+=1      \n        nums = list(filter(lambda x: x!=0, nums))+zero_list"
                    },
                    {
                        "username": "vnhnhm",
                        "content": "[@muhammedirshadismail0722](/muhammedirshadismail0722) stop spamming"
                    },
                    {
                        "username": "Pranav_cs",
                        "content": "whe have to do it in-place don\\'t create a new list.\\nHint: use 2 pointers"
                    }
                ]
            },
            {
                "id": 1703891,
                "content": [
                    {
                        "username": "Nisha1205092",
                        "content": "it\\'s sad that I look for hints or ideas, but people just directly post codes here too!!! Whereas there\\'s a \\'solution\\' section separately. "
                    },
                    {
                        "username": "muhammedirshadismail0722",
                        "content": "\\n\\nEasiest \\uD83D\\uDE0E FAANG Method Ever !!! \\uD83D\\uDCA5||Best solution in python\\n\\n\\nhttps://leetcode.com/problems/move-zeroes/solutions/3923521/easiest-faang-method-ever-best-solution-in-python/"
                    },
                    {
                        "username": "aleazanrashid",
                        "content": "Let people discuss their issues with their solution "
                    },
                    {
                        "username": "mariusandries25",
                        "content": "It literally says not to post solutions in the discussion. This section is for tips and questions."
                    },
                    {
                        "username": "VladimirTheLeet",
                        "content": "I guess the rules don\\'t work for you if you can\\'t read \\xAF\\\\\\\\\\\\_(\\u30C4)_/\\xAF"
                    },
                    {
                        "username": "jerryy147",
                        "content": "all 3 rules say not to post a solution here in some form"
                    },
                    {
                        "username": "DoMonkeysFly7",
                        "content": "ppl are idiots frate, they wanna show how 'smart' they are"
                    },
                    {
                        "username": "mdegis",
                        "content": "I really do not understand how accepted solutions distribution works or measured for the solution.  I\\'ve basically submit the same solution 4 minutes apart, first one runtime was 491 ms and beat 25.21%... second one was 340 ms and beat 55.81%. Again, they are the same code! Nothing changed, not even an empty space. Just click \"submit\" button again. \\n\\nShould I stop caring about this number if there is no consistency at all?"
                    },
                    {
                        "username": "arc-arnob",
                        "content": "true and more over implicit declaration faster than explicit datatype declaration in typescript. "
                    },
                    {
                        "username": "bernardoolisan",
                        "content": "Is bc the leetcode server that runs your code might sometimes run faster or slower, is a compiler in a server. And yes, you should care about the percentage even if sometimes is not accurate, it gives you a approximation of how efficient is your code "
                    },
                    {
                        "username": "Priyamd",
                        "content": "i guess its a glitch "
                    },
                    {
                        "username": "potatopie",
                        "content": "its literally always the indians that post the solutions what concept of DISCUSSION do you guys not understand? "
                    },
                    {
                        "username": "AryanP45",
                        "content": "[@nKR5](/nKR5) Always fun reading these stereotypical comments"
                    },
                    {
                        "username": "nKR5",
                        "content": "Strong in programming language, weak in human communication language."
                    },
                    {
                        "username": "shubhamsharma123",
                        "content": " // striver solution\\n  int k=0;\\n        for(int i=0;i<nums.size();i++){\\n            if(nums[i]!=0){\\n            int temp=nums[k];\\n            nums[k]=nums[i];\\n            nums[i]= temp;\\n              k++;\\n            }\\n        }\\n        }"
                    },
                    {
                        "username": "vivekup3424",
                        "content": "Bro why you want hate by posting solution here, are you some kinda masochist."
                    },
                    {
                        "username": "swand0g",
                        "content": "nice job posting the solution in the one place leetcode specifies not to post solutions!"
                    },
                    {
                        "username": "neel19",
                        "content": "[@luan_hy](/luan_hy)  The instructor here (striver) has a very strong background in competitive programming. That\\'s how he can come up with such elegant solution. You can check out his tutorials on youtube. "
                    },
                    {
                        "username": "mariusandries25",
                        "content": "[@luan_hy](/luan_hy) The non-zero values are moved in front of array, the k variable keeping track of the moved values non-zero. Zeroes are implicit moving behind when swapping the non-zero. Then when encountering zero do nothing."
                    },
                    {
                        "username": "luan_hy",
                        "content": "Can you share what is your problem-solving step to come out with a so simple solution? "
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# Easiest \\uD83D\\uDE0E FAANG Method Ever !!! \\uD83D\\uDCA5 \\n\\nhttps://leetcode.com/problems/move-zeroes/solutions/2872504/easiest-faang-method-ever/?orderBy=most_votes"
                    },
                    {
                        "username": "atak",
                        "content": "\\t\\tzero_size = nums.count(0)\\n\\t\\tnums.delete(0)\\n\\t\\tnums = (nums + ([0] * zero_size ))"
                    },
                    {
                        "username": "muhammedirshadismail0722",
                        "content": "\\n\\nEasiest \\uD83D\\uDE0E FAANG Method Ever !!! \\uD83D\\uDCA5||Best solution in python\\n\\n\\nhttps://leetcode.com/problems/move-zeroes/solutions/3923521/easiest-faang-method-ever-best-solution-in-python/"
                    },
                    {
                        "username": "michaelknight492",
                        "content": "\"Note that you must do this in-place without making a copy of the array.\"\\n\\nI believe \"nums = (nums + ([0] * zero_size ))\" is  making a copy of the array"
                    },
                    {
                        "username": "saichandra004",
                        "content": "Cannot modify nums."
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# Easiest \\uD83D\\uDE0E FAANG Method Ever !!! \\uD83D\\uDCA5 \\n\\nhttps://leetcode.com/problems/move-zeroes/solutions/2872504/easiest-faang-method-ever/?orderBy=most_votes"
                    },
                    {
                        "username": "lanyiyun",
                        "content": "'''\\ndef moveZeroes(self, nums):\\n\\n        for i in range(nums.count(0)):\\n            nums.remove(0)\\n            nums.append(0)\\n'''"
                    },
                    {
                        "username": "starogre",
                        "content": "this doesn\\'t count. this creates a new list in memory. the challenge is to do it in-place"
                    },
                    {
                        "username": "saichandra004",
                        "content": "Cannot modify nums."
                    },
                    {
                        "username": "sainath81061",
                        "content": "public void MoveZeroes(int[] nums) {\\n        int i,count = 0;\\n        for(i=0;i<nums.Length;i++){\\n            if(nums[i] != 0){\\n                nums[count] = nums[i];\\n                count++;\\n            }\\n        }\\n        for(;count<nums.Length;count++){\\n            nums[count] = 0;\\n        }\\n        foreach(var x in nums){\\n            Console.WriteLine(x);\\n        }\\n    }"
                    },
                    {
                        "username": "LanceofLonginius",
                        "content": "do not post solutions here"
                    },
                    {
                        "username": "Kokopas",
                        "content": "Why this solution is not working,?\nI checked in on local interpreter and it works\n\nclass Solution:\n    def moveZeroes(self, nums) -> None:\n        \"\"\"\n        Do not return anything, modify nums in-place instead.\n        \"\"\"\n        zero_amount = nums.count(0)\n        zero_list=[]\n        n=0\n        while n < zero_amount:\n            zero_list.append(0)\n            n+=1      \n        nums = list(filter(lambda x: x!=0, nums))+zero_list"
                    },
                    {
                        "username": "vnhnhm",
                        "content": "[@muhammedirshadismail0722](/muhammedirshadismail0722) stop spamming"
                    },
                    {
                        "username": "Pranav_cs",
                        "content": "whe have to do it in-place don\\'t create a new list.\\nHint: use 2 pointers"
                    }
                ]
            },
            {
                "id": 1572592,
                "content": [
                    {
                        "username": "Nisha1205092",
                        "content": "it\\'s sad that I look for hints or ideas, but people just directly post codes here too!!! Whereas there\\'s a \\'solution\\' section separately. "
                    },
                    {
                        "username": "muhammedirshadismail0722",
                        "content": "\\n\\nEasiest \\uD83D\\uDE0E FAANG Method Ever !!! \\uD83D\\uDCA5||Best solution in python\\n\\n\\nhttps://leetcode.com/problems/move-zeroes/solutions/3923521/easiest-faang-method-ever-best-solution-in-python/"
                    },
                    {
                        "username": "aleazanrashid",
                        "content": "Let people discuss their issues with their solution "
                    },
                    {
                        "username": "mariusandries25",
                        "content": "It literally says not to post solutions in the discussion. This section is for tips and questions."
                    },
                    {
                        "username": "VladimirTheLeet",
                        "content": "I guess the rules don\\'t work for you if you can\\'t read \\xAF\\\\\\\\\\\\_(\\u30C4)_/\\xAF"
                    },
                    {
                        "username": "jerryy147",
                        "content": "all 3 rules say not to post a solution here in some form"
                    },
                    {
                        "username": "DoMonkeysFly7",
                        "content": "ppl are idiots frate, they wanna show how 'smart' they are"
                    },
                    {
                        "username": "mdegis",
                        "content": "I really do not understand how accepted solutions distribution works or measured for the solution.  I\\'ve basically submit the same solution 4 minutes apart, first one runtime was 491 ms and beat 25.21%... second one was 340 ms and beat 55.81%. Again, they are the same code! Nothing changed, not even an empty space. Just click \"submit\" button again. \\n\\nShould I stop caring about this number if there is no consistency at all?"
                    },
                    {
                        "username": "arc-arnob",
                        "content": "true and more over implicit declaration faster than explicit datatype declaration in typescript. "
                    },
                    {
                        "username": "bernardoolisan",
                        "content": "Is bc the leetcode server that runs your code might sometimes run faster or slower, is a compiler in a server. And yes, you should care about the percentage even if sometimes is not accurate, it gives you a approximation of how efficient is your code "
                    },
                    {
                        "username": "Priyamd",
                        "content": "i guess its a glitch "
                    },
                    {
                        "username": "potatopie",
                        "content": "its literally always the indians that post the solutions what concept of DISCUSSION do you guys not understand? "
                    },
                    {
                        "username": "AryanP45",
                        "content": "[@nKR5](/nKR5) Always fun reading these stereotypical comments"
                    },
                    {
                        "username": "nKR5",
                        "content": "Strong in programming language, weak in human communication language."
                    },
                    {
                        "username": "shubhamsharma123",
                        "content": " // striver solution\\n  int k=0;\\n        for(int i=0;i<nums.size();i++){\\n            if(nums[i]!=0){\\n            int temp=nums[k];\\n            nums[k]=nums[i];\\n            nums[i]= temp;\\n              k++;\\n            }\\n        }\\n        }"
                    },
                    {
                        "username": "vivekup3424",
                        "content": "Bro why you want hate by posting solution here, are you some kinda masochist."
                    },
                    {
                        "username": "swand0g",
                        "content": "nice job posting the solution in the one place leetcode specifies not to post solutions!"
                    },
                    {
                        "username": "neel19",
                        "content": "[@luan_hy](/luan_hy)  The instructor here (striver) has a very strong background in competitive programming. That\\'s how he can come up with such elegant solution. You can check out his tutorials on youtube. "
                    },
                    {
                        "username": "mariusandries25",
                        "content": "[@luan_hy](/luan_hy) The non-zero values are moved in front of array, the k variable keeping track of the moved values non-zero. Zeroes are implicit moving behind when swapping the non-zero. Then when encountering zero do nothing."
                    },
                    {
                        "username": "luan_hy",
                        "content": "Can you share what is your problem-solving step to come out with a so simple solution? "
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# Easiest \\uD83D\\uDE0E FAANG Method Ever !!! \\uD83D\\uDCA5 \\n\\nhttps://leetcode.com/problems/move-zeroes/solutions/2872504/easiest-faang-method-ever/?orderBy=most_votes"
                    },
                    {
                        "username": "atak",
                        "content": "\\t\\tzero_size = nums.count(0)\\n\\t\\tnums.delete(0)\\n\\t\\tnums = (nums + ([0] * zero_size ))"
                    },
                    {
                        "username": "muhammedirshadismail0722",
                        "content": "\\n\\nEasiest \\uD83D\\uDE0E FAANG Method Ever !!! \\uD83D\\uDCA5||Best solution in python\\n\\n\\nhttps://leetcode.com/problems/move-zeroes/solutions/3923521/easiest-faang-method-ever-best-solution-in-python/"
                    },
                    {
                        "username": "michaelknight492",
                        "content": "\"Note that you must do this in-place without making a copy of the array.\"\\n\\nI believe \"nums = (nums + ([0] * zero_size ))\" is  making a copy of the array"
                    },
                    {
                        "username": "saichandra004",
                        "content": "Cannot modify nums."
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# Easiest \\uD83D\\uDE0E FAANG Method Ever !!! \\uD83D\\uDCA5 \\n\\nhttps://leetcode.com/problems/move-zeroes/solutions/2872504/easiest-faang-method-ever/?orderBy=most_votes"
                    },
                    {
                        "username": "lanyiyun",
                        "content": "'''\\ndef moveZeroes(self, nums):\\n\\n        for i in range(nums.count(0)):\\n            nums.remove(0)\\n            nums.append(0)\\n'''"
                    },
                    {
                        "username": "starogre",
                        "content": "this doesn\\'t count. this creates a new list in memory. the challenge is to do it in-place"
                    },
                    {
                        "username": "saichandra004",
                        "content": "Cannot modify nums."
                    },
                    {
                        "username": "sainath81061",
                        "content": "public void MoveZeroes(int[] nums) {\\n        int i,count = 0;\\n        for(i=0;i<nums.Length;i++){\\n            if(nums[i] != 0){\\n                nums[count] = nums[i];\\n                count++;\\n            }\\n        }\\n        for(;count<nums.Length;count++){\\n            nums[count] = 0;\\n        }\\n        foreach(var x in nums){\\n            Console.WriteLine(x);\\n        }\\n    }"
                    },
                    {
                        "username": "LanceofLonginius",
                        "content": "do not post solutions here"
                    },
                    {
                        "username": "Kokopas",
                        "content": "Why this solution is not working,?\nI checked in on local interpreter and it works\n\nclass Solution:\n    def moveZeroes(self, nums) -> None:\n        \"\"\"\n        Do not return anything, modify nums in-place instead.\n        \"\"\"\n        zero_amount = nums.count(0)\n        zero_list=[]\n        n=0\n        while n < zero_amount:\n            zero_list.append(0)\n            n+=1      \n        nums = list(filter(lambda x: x!=0, nums))+zero_list"
                    },
                    {
                        "username": "vnhnhm",
                        "content": "[@muhammedirshadismail0722](/muhammedirshadismail0722) stop spamming"
                    },
                    {
                        "username": "Pranav_cs",
                        "content": "whe have to do it in-place don\\'t create a new list.\\nHint: use 2 pointers"
                    }
                ]
            },
            {
                "id": 1571527,
                "content": [
                    {
                        "username": "Nisha1205092",
                        "content": "it\\'s sad that I look for hints or ideas, but people just directly post codes here too!!! Whereas there\\'s a \\'solution\\' section separately. "
                    },
                    {
                        "username": "muhammedirshadismail0722",
                        "content": "\\n\\nEasiest \\uD83D\\uDE0E FAANG Method Ever !!! \\uD83D\\uDCA5||Best solution in python\\n\\n\\nhttps://leetcode.com/problems/move-zeroes/solutions/3923521/easiest-faang-method-ever-best-solution-in-python/"
                    },
                    {
                        "username": "aleazanrashid",
                        "content": "Let people discuss their issues with their solution "
                    },
                    {
                        "username": "mariusandries25",
                        "content": "It literally says not to post solutions in the discussion. This section is for tips and questions."
                    },
                    {
                        "username": "VladimirTheLeet",
                        "content": "I guess the rules don\\'t work for you if you can\\'t read \\xAF\\\\\\\\\\\\_(\\u30C4)_/\\xAF"
                    },
                    {
                        "username": "jerryy147",
                        "content": "all 3 rules say not to post a solution here in some form"
                    },
                    {
                        "username": "DoMonkeysFly7",
                        "content": "ppl are idiots frate, they wanna show how 'smart' they are"
                    },
                    {
                        "username": "mdegis",
                        "content": "I really do not understand how accepted solutions distribution works or measured for the solution.  I\\'ve basically submit the same solution 4 minutes apart, first one runtime was 491 ms and beat 25.21%... second one was 340 ms and beat 55.81%. Again, they are the same code! Nothing changed, not even an empty space. Just click \"submit\" button again. \\n\\nShould I stop caring about this number if there is no consistency at all?"
                    },
                    {
                        "username": "arc-arnob",
                        "content": "true and more over implicit declaration faster than explicit datatype declaration in typescript. "
                    },
                    {
                        "username": "bernardoolisan",
                        "content": "Is bc the leetcode server that runs your code might sometimes run faster or slower, is a compiler in a server. And yes, you should care about the percentage even if sometimes is not accurate, it gives you a approximation of how efficient is your code "
                    },
                    {
                        "username": "Priyamd",
                        "content": "i guess its a glitch "
                    },
                    {
                        "username": "potatopie",
                        "content": "its literally always the indians that post the solutions what concept of DISCUSSION do you guys not understand? "
                    },
                    {
                        "username": "AryanP45",
                        "content": "[@nKR5](/nKR5) Always fun reading these stereotypical comments"
                    },
                    {
                        "username": "nKR5",
                        "content": "Strong in programming language, weak in human communication language."
                    },
                    {
                        "username": "shubhamsharma123",
                        "content": " // striver solution\\n  int k=0;\\n        for(int i=0;i<nums.size();i++){\\n            if(nums[i]!=0){\\n            int temp=nums[k];\\n            nums[k]=nums[i];\\n            nums[i]= temp;\\n              k++;\\n            }\\n        }\\n        }"
                    },
                    {
                        "username": "vivekup3424",
                        "content": "Bro why you want hate by posting solution here, are you some kinda masochist."
                    },
                    {
                        "username": "swand0g",
                        "content": "nice job posting the solution in the one place leetcode specifies not to post solutions!"
                    },
                    {
                        "username": "neel19",
                        "content": "[@luan_hy](/luan_hy)  The instructor here (striver) has a very strong background in competitive programming. That\\'s how he can come up with such elegant solution. You can check out his tutorials on youtube. "
                    },
                    {
                        "username": "mariusandries25",
                        "content": "[@luan_hy](/luan_hy) The non-zero values are moved in front of array, the k variable keeping track of the moved values non-zero. Zeroes are implicit moving behind when swapping the non-zero. Then when encountering zero do nothing."
                    },
                    {
                        "username": "luan_hy",
                        "content": "Can you share what is your problem-solving step to come out with a so simple solution? "
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# Easiest \\uD83D\\uDE0E FAANG Method Ever !!! \\uD83D\\uDCA5 \\n\\nhttps://leetcode.com/problems/move-zeroes/solutions/2872504/easiest-faang-method-ever/?orderBy=most_votes"
                    },
                    {
                        "username": "atak",
                        "content": "\\t\\tzero_size = nums.count(0)\\n\\t\\tnums.delete(0)\\n\\t\\tnums = (nums + ([0] * zero_size ))"
                    },
                    {
                        "username": "muhammedirshadismail0722",
                        "content": "\\n\\nEasiest \\uD83D\\uDE0E FAANG Method Ever !!! \\uD83D\\uDCA5||Best solution in python\\n\\n\\nhttps://leetcode.com/problems/move-zeroes/solutions/3923521/easiest-faang-method-ever-best-solution-in-python/"
                    },
                    {
                        "username": "michaelknight492",
                        "content": "\"Note that you must do this in-place without making a copy of the array.\"\\n\\nI believe \"nums = (nums + ([0] * zero_size ))\" is  making a copy of the array"
                    },
                    {
                        "username": "saichandra004",
                        "content": "Cannot modify nums."
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# Easiest \\uD83D\\uDE0E FAANG Method Ever !!! \\uD83D\\uDCA5 \\n\\nhttps://leetcode.com/problems/move-zeroes/solutions/2872504/easiest-faang-method-ever/?orderBy=most_votes"
                    },
                    {
                        "username": "lanyiyun",
                        "content": "'''\\ndef moveZeroes(self, nums):\\n\\n        for i in range(nums.count(0)):\\n            nums.remove(0)\\n            nums.append(0)\\n'''"
                    },
                    {
                        "username": "starogre",
                        "content": "this doesn\\'t count. this creates a new list in memory. the challenge is to do it in-place"
                    },
                    {
                        "username": "saichandra004",
                        "content": "Cannot modify nums."
                    },
                    {
                        "username": "sainath81061",
                        "content": "public void MoveZeroes(int[] nums) {\\n        int i,count = 0;\\n        for(i=0;i<nums.Length;i++){\\n            if(nums[i] != 0){\\n                nums[count] = nums[i];\\n                count++;\\n            }\\n        }\\n        for(;count<nums.Length;count++){\\n            nums[count] = 0;\\n        }\\n        foreach(var x in nums){\\n            Console.WriteLine(x);\\n        }\\n    }"
                    },
                    {
                        "username": "LanceofLonginius",
                        "content": "do not post solutions here"
                    },
                    {
                        "username": "Kokopas",
                        "content": "Why this solution is not working,?\nI checked in on local interpreter and it works\n\nclass Solution:\n    def moveZeroes(self, nums) -> None:\n        \"\"\"\n        Do not return anything, modify nums in-place instead.\n        \"\"\"\n        zero_amount = nums.count(0)\n        zero_list=[]\n        n=0\n        while n < zero_amount:\n            zero_list.append(0)\n            n+=1      \n        nums = list(filter(lambda x: x!=0, nums))+zero_list"
                    },
                    {
                        "username": "vnhnhm",
                        "content": "[@muhammedirshadismail0722](/muhammedirshadismail0722) stop spamming"
                    },
                    {
                        "username": "Pranav_cs",
                        "content": "whe have to do it in-place don\\'t create a new list.\\nHint: use 2 pointers"
                    }
                ]
            },
            {
                "id": 1944210,
                "content": [
                    {
                        "username": "Nisha1205092",
                        "content": "it\\'s sad that I look for hints or ideas, but people just directly post codes here too!!! Whereas there\\'s a \\'solution\\' section separately. "
                    },
                    {
                        "username": "muhammedirshadismail0722",
                        "content": "\\n\\nEasiest \\uD83D\\uDE0E FAANG Method Ever !!! \\uD83D\\uDCA5||Best solution in python\\n\\n\\nhttps://leetcode.com/problems/move-zeroes/solutions/3923521/easiest-faang-method-ever-best-solution-in-python/"
                    },
                    {
                        "username": "aleazanrashid",
                        "content": "Let people discuss their issues with their solution "
                    },
                    {
                        "username": "mariusandries25",
                        "content": "It literally says not to post solutions in the discussion. This section is for tips and questions."
                    },
                    {
                        "username": "VladimirTheLeet",
                        "content": "I guess the rules don\\'t work for you if you can\\'t read \\xAF\\\\\\\\\\\\_(\\u30C4)_/\\xAF"
                    },
                    {
                        "username": "jerryy147",
                        "content": "all 3 rules say not to post a solution here in some form"
                    },
                    {
                        "username": "DoMonkeysFly7",
                        "content": "ppl are idiots frate, they wanna show how 'smart' they are"
                    },
                    {
                        "username": "mdegis",
                        "content": "I really do not understand how accepted solutions distribution works or measured for the solution.  I\\'ve basically submit the same solution 4 minutes apart, first one runtime was 491 ms and beat 25.21%... second one was 340 ms and beat 55.81%. Again, they are the same code! Nothing changed, not even an empty space. Just click \"submit\" button again. \\n\\nShould I stop caring about this number if there is no consistency at all?"
                    },
                    {
                        "username": "arc-arnob",
                        "content": "true and more over implicit declaration faster than explicit datatype declaration in typescript. "
                    },
                    {
                        "username": "bernardoolisan",
                        "content": "Is bc the leetcode server that runs your code might sometimes run faster or slower, is a compiler in a server. And yes, you should care about the percentage even if sometimes is not accurate, it gives you a approximation of how efficient is your code "
                    },
                    {
                        "username": "Priyamd",
                        "content": "i guess its a glitch "
                    },
                    {
                        "username": "potatopie",
                        "content": "its literally always the indians that post the solutions what concept of DISCUSSION do you guys not understand? "
                    },
                    {
                        "username": "AryanP45",
                        "content": "[@nKR5](/nKR5) Always fun reading these stereotypical comments"
                    },
                    {
                        "username": "nKR5",
                        "content": "Strong in programming language, weak in human communication language."
                    },
                    {
                        "username": "shubhamsharma123",
                        "content": " // striver solution\\n  int k=0;\\n        for(int i=0;i<nums.size();i++){\\n            if(nums[i]!=0){\\n            int temp=nums[k];\\n            nums[k]=nums[i];\\n            nums[i]= temp;\\n              k++;\\n            }\\n        }\\n        }"
                    },
                    {
                        "username": "vivekup3424",
                        "content": "Bro why you want hate by posting solution here, are you some kinda masochist."
                    },
                    {
                        "username": "swand0g",
                        "content": "nice job posting the solution in the one place leetcode specifies not to post solutions!"
                    },
                    {
                        "username": "neel19",
                        "content": "[@luan_hy](/luan_hy)  The instructor here (striver) has a very strong background in competitive programming. That\\'s how he can come up with such elegant solution. You can check out his tutorials on youtube. "
                    },
                    {
                        "username": "mariusandries25",
                        "content": "[@luan_hy](/luan_hy) The non-zero values are moved in front of array, the k variable keeping track of the moved values non-zero. Zeroes are implicit moving behind when swapping the non-zero. Then when encountering zero do nothing."
                    },
                    {
                        "username": "luan_hy",
                        "content": "Can you share what is your problem-solving step to come out with a so simple solution? "
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# Easiest \\uD83D\\uDE0E FAANG Method Ever !!! \\uD83D\\uDCA5 \\n\\nhttps://leetcode.com/problems/move-zeroes/solutions/2872504/easiest-faang-method-ever/?orderBy=most_votes"
                    },
                    {
                        "username": "atak",
                        "content": "\\t\\tzero_size = nums.count(0)\\n\\t\\tnums.delete(0)\\n\\t\\tnums = (nums + ([0] * zero_size ))"
                    },
                    {
                        "username": "muhammedirshadismail0722",
                        "content": "\\n\\nEasiest \\uD83D\\uDE0E FAANG Method Ever !!! \\uD83D\\uDCA5||Best solution in python\\n\\n\\nhttps://leetcode.com/problems/move-zeroes/solutions/3923521/easiest-faang-method-ever-best-solution-in-python/"
                    },
                    {
                        "username": "michaelknight492",
                        "content": "\"Note that you must do this in-place without making a copy of the array.\"\\n\\nI believe \"nums = (nums + ([0] * zero_size ))\" is  making a copy of the array"
                    },
                    {
                        "username": "saichandra004",
                        "content": "Cannot modify nums."
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# Easiest \\uD83D\\uDE0E FAANG Method Ever !!! \\uD83D\\uDCA5 \\n\\nhttps://leetcode.com/problems/move-zeroes/solutions/2872504/easiest-faang-method-ever/?orderBy=most_votes"
                    },
                    {
                        "username": "lanyiyun",
                        "content": "'''\\ndef moveZeroes(self, nums):\\n\\n        for i in range(nums.count(0)):\\n            nums.remove(0)\\n            nums.append(0)\\n'''"
                    },
                    {
                        "username": "starogre",
                        "content": "this doesn\\'t count. this creates a new list in memory. the challenge is to do it in-place"
                    },
                    {
                        "username": "saichandra004",
                        "content": "Cannot modify nums."
                    },
                    {
                        "username": "sainath81061",
                        "content": "public void MoveZeroes(int[] nums) {\\n        int i,count = 0;\\n        for(i=0;i<nums.Length;i++){\\n            if(nums[i] != 0){\\n                nums[count] = nums[i];\\n                count++;\\n            }\\n        }\\n        for(;count<nums.Length;count++){\\n            nums[count] = 0;\\n        }\\n        foreach(var x in nums){\\n            Console.WriteLine(x);\\n        }\\n    }"
                    },
                    {
                        "username": "LanceofLonginius",
                        "content": "do not post solutions here"
                    },
                    {
                        "username": "Kokopas",
                        "content": "Why this solution is not working,?\nI checked in on local interpreter and it works\n\nclass Solution:\n    def moveZeroes(self, nums) -> None:\n        \"\"\"\n        Do not return anything, modify nums in-place instead.\n        \"\"\"\n        zero_amount = nums.count(0)\n        zero_list=[]\n        n=0\n        while n < zero_amount:\n            zero_list.append(0)\n            n+=1      \n        nums = list(filter(lambda x: x!=0, nums))+zero_list"
                    },
                    {
                        "username": "vnhnhm",
                        "content": "[@muhammedirshadismail0722](/muhammedirshadismail0722) stop spamming"
                    },
                    {
                        "username": "Pranav_cs",
                        "content": "whe have to do it in-place don\\'t create a new list.\\nHint: use 2 pointers"
                    }
                ]
            },
            {
                "id": 1869625,
                "content": [
                    {
                        "username": "Nisha1205092",
                        "content": "it\\'s sad that I look for hints or ideas, but people just directly post codes here too!!! Whereas there\\'s a \\'solution\\' section separately. "
                    },
                    {
                        "username": "muhammedirshadismail0722",
                        "content": "\\n\\nEasiest \\uD83D\\uDE0E FAANG Method Ever !!! \\uD83D\\uDCA5||Best solution in python\\n\\n\\nhttps://leetcode.com/problems/move-zeroes/solutions/3923521/easiest-faang-method-ever-best-solution-in-python/"
                    },
                    {
                        "username": "aleazanrashid",
                        "content": "Let people discuss their issues with their solution "
                    },
                    {
                        "username": "mariusandries25",
                        "content": "It literally says not to post solutions in the discussion. This section is for tips and questions."
                    },
                    {
                        "username": "VladimirTheLeet",
                        "content": "I guess the rules don\\'t work for you if you can\\'t read \\xAF\\\\\\\\\\\\_(\\u30C4)_/\\xAF"
                    },
                    {
                        "username": "jerryy147",
                        "content": "all 3 rules say not to post a solution here in some form"
                    },
                    {
                        "username": "DoMonkeysFly7",
                        "content": "ppl are idiots frate, they wanna show how 'smart' they are"
                    },
                    {
                        "username": "mdegis",
                        "content": "I really do not understand how accepted solutions distribution works or measured for the solution.  I\\'ve basically submit the same solution 4 minutes apart, first one runtime was 491 ms and beat 25.21%... second one was 340 ms and beat 55.81%. Again, they are the same code! Nothing changed, not even an empty space. Just click \"submit\" button again. \\n\\nShould I stop caring about this number if there is no consistency at all?"
                    },
                    {
                        "username": "arc-arnob",
                        "content": "true and more over implicit declaration faster than explicit datatype declaration in typescript. "
                    },
                    {
                        "username": "bernardoolisan",
                        "content": "Is bc the leetcode server that runs your code might sometimes run faster or slower, is a compiler in a server. And yes, you should care about the percentage even if sometimes is not accurate, it gives you a approximation of how efficient is your code "
                    },
                    {
                        "username": "Priyamd",
                        "content": "i guess its a glitch "
                    },
                    {
                        "username": "potatopie",
                        "content": "its literally always the indians that post the solutions what concept of DISCUSSION do you guys not understand? "
                    },
                    {
                        "username": "AryanP45",
                        "content": "[@nKR5](/nKR5) Always fun reading these stereotypical comments"
                    },
                    {
                        "username": "nKR5",
                        "content": "Strong in programming language, weak in human communication language."
                    },
                    {
                        "username": "shubhamsharma123",
                        "content": " // striver solution\\n  int k=0;\\n        for(int i=0;i<nums.size();i++){\\n            if(nums[i]!=0){\\n            int temp=nums[k];\\n            nums[k]=nums[i];\\n            nums[i]= temp;\\n              k++;\\n            }\\n        }\\n        }"
                    },
                    {
                        "username": "vivekup3424",
                        "content": "Bro why you want hate by posting solution here, are you some kinda masochist."
                    },
                    {
                        "username": "swand0g",
                        "content": "nice job posting the solution in the one place leetcode specifies not to post solutions!"
                    },
                    {
                        "username": "neel19",
                        "content": "[@luan_hy](/luan_hy)  The instructor here (striver) has a very strong background in competitive programming. That\\'s how he can come up with such elegant solution. You can check out his tutorials on youtube. "
                    },
                    {
                        "username": "mariusandries25",
                        "content": "[@luan_hy](/luan_hy) The non-zero values are moved in front of array, the k variable keeping track of the moved values non-zero. Zeroes are implicit moving behind when swapping the non-zero. Then when encountering zero do nothing."
                    },
                    {
                        "username": "luan_hy",
                        "content": "Can you share what is your problem-solving step to come out with a so simple solution? "
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# Easiest \\uD83D\\uDE0E FAANG Method Ever !!! \\uD83D\\uDCA5 \\n\\nhttps://leetcode.com/problems/move-zeroes/solutions/2872504/easiest-faang-method-ever/?orderBy=most_votes"
                    },
                    {
                        "username": "atak",
                        "content": "\\t\\tzero_size = nums.count(0)\\n\\t\\tnums.delete(0)\\n\\t\\tnums = (nums + ([0] * zero_size ))"
                    },
                    {
                        "username": "muhammedirshadismail0722",
                        "content": "\\n\\nEasiest \\uD83D\\uDE0E FAANG Method Ever !!! \\uD83D\\uDCA5||Best solution in python\\n\\n\\nhttps://leetcode.com/problems/move-zeroes/solutions/3923521/easiest-faang-method-ever-best-solution-in-python/"
                    },
                    {
                        "username": "michaelknight492",
                        "content": "\"Note that you must do this in-place without making a copy of the array.\"\\n\\nI believe \"nums = (nums + ([0] * zero_size ))\" is  making a copy of the array"
                    },
                    {
                        "username": "saichandra004",
                        "content": "Cannot modify nums."
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# Easiest \\uD83D\\uDE0E FAANG Method Ever !!! \\uD83D\\uDCA5 \\n\\nhttps://leetcode.com/problems/move-zeroes/solutions/2872504/easiest-faang-method-ever/?orderBy=most_votes"
                    },
                    {
                        "username": "lanyiyun",
                        "content": "'''\\ndef moveZeroes(self, nums):\\n\\n        for i in range(nums.count(0)):\\n            nums.remove(0)\\n            nums.append(0)\\n'''"
                    },
                    {
                        "username": "starogre",
                        "content": "this doesn\\'t count. this creates a new list in memory. the challenge is to do it in-place"
                    },
                    {
                        "username": "saichandra004",
                        "content": "Cannot modify nums."
                    },
                    {
                        "username": "sainath81061",
                        "content": "public void MoveZeroes(int[] nums) {\\n        int i,count = 0;\\n        for(i=0;i<nums.Length;i++){\\n            if(nums[i] != 0){\\n                nums[count] = nums[i];\\n                count++;\\n            }\\n        }\\n        for(;count<nums.Length;count++){\\n            nums[count] = 0;\\n        }\\n        foreach(var x in nums){\\n            Console.WriteLine(x);\\n        }\\n    }"
                    },
                    {
                        "username": "LanceofLonginius",
                        "content": "do not post solutions here"
                    },
                    {
                        "username": "Kokopas",
                        "content": "Why this solution is not working,?\nI checked in on local interpreter and it works\n\nclass Solution:\n    def moveZeroes(self, nums) -> None:\n        \"\"\"\n        Do not return anything, modify nums in-place instead.\n        \"\"\"\n        zero_amount = nums.count(0)\n        zero_list=[]\n        n=0\n        while n < zero_amount:\n            zero_list.append(0)\n            n+=1      \n        nums = list(filter(lambda x: x!=0, nums))+zero_list"
                    },
                    {
                        "username": "vnhnhm",
                        "content": "[@muhammedirshadismail0722](/muhammedirshadismail0722) stop spamming"
                    },
                    {
                        "username": "Pranav_cs",
                        "content": "whe have to do it in-place don\\'t create a new list.\\nHint: use 2 pointers"
                    }
                ]
            },
            {
                "id": 1862004,
                "content": [
                    {
                        "username": "Akshat0706",
                        "content": "Remember QuickSort. Use two Pointers and swap non-zeros to left and zeros to right."
                    },
                    {
                        "username": "ASWINNATH123",
                        "content": "but tle is showing bruhh\\n"
                    },
                    {
                        "username": "kgjobsearch",
                        "content": "b=[0,1,0,3,12]\\nprint(list(a for a in b if a!= 0) + list(a for a in b if a == 0))"
                    },
                    {
                        "username": "azimBaldiwala",
                        "content": "You are making a new list here!!! QUESTION SAYS WE NEED TO MODIFY THE LIST , that is the purpose of the question .. else your solution is correct  "
                    },
                    {
                        "username": "pardhi1400",
                        "content": "it says keep the relative order does that mean not asending ? just the order the elements where in at the start?"
                    },
                    {
                        "username": "itsrishiydv",
                        "content": "Leetcode Python editor having some issue because below code is giving correct answer in local machine.\\n\\nclass Solution:\\n    def moveZeroes(self, nums: List[int]) -> None:\\n        \"\"\"\\n        Do not return anything, modify nums in-place instead.\\n        \"\"\"\\n        lis1=[]\\n        lis2=[]\\n        for i in nums:\\n            if i==0:\\n                lis2.append(i)\\n            if i!=0:\\n                lis1.append(i)\\n            \\n        return lis1+lis2"
                    },
                    {
                        "username": "aXXo",
                        "content": "you are supposed to modify in place. In your code you are creating two new lists"
                    },
                    {
                        "username": "aleazanrashid",
                        "content": " `class Solution:\\n    def moveZeroes(self, nums: List[int]) -> None:\\n        \"\"\"\\n        Do not return anything, modify nums in-place instead.\\n        \"\"\"\\n\\n        count = 0\\n        new = []\\n        \\n        for i in nums:\\n            if i == 0:\\n                count += 1\\n            else:\\n                new.append(i)\\n\\n        for i in range(count):\\n            new.append(0)\\n            \\n        return new`\\n\\n\\nmy solution works fine using pycharm but here i get wrong answer ?????"
                    },
                    {
                        "username": "aleazanrashid",
                        "content": "i came with new code, if you interested\n\n\ndef move_zer():\n\n    lis = [0,1,0,3,12]\n  \n    left, right = 0, len(lis) - 1\n\n    while left < right:\n\n        if lis[left] == 0 :\n            lis[left], lis[left + 1] = lis[left + 1], lis[left]\n\n        left += 1\n\n    return lis\n\nim tryng to solve this proplem with this code , it works fine but not when two zeros come next to each other , it move one of the zero to swap with next element but the another zero stays i need to come back to that zero and keep comparing or swapping any idea  ?\n"
                    },
                    {
                        "username": "aleazanrashid",
                        "content": "[@Siddharoodha10](/Siddharoodha10) ops\\n"
                    },
                    {
                        "username": "Siddharoodha10",
                        "content": "as per question u need to use nums list only. (its asking to modify nums in place only)"
                    },
                    {
                        "username": "CodeWizarder",
                        "content": "class Solution {\\n    public void moveZeroes(int[] nums) {\\n        ArrayList<Integer> ans = new ArrayList<>();\\n        solve(nums, ans, 0, 0);\\n        for(int i = 0; i < ans.size(); i++){\\n            nums[i] = ans.get(i);\\n        }\\n    }\\n\\n    public static void solve(int[] arr, ArrayList<Integer> ans, int index, int count){\\n        if(index == arr.length){\\n            for(int i = 0; i < count; i++){\\n                ans.add(0);\\n            }\\n            return;\\n        }\\n        if(arr[index] == 0){\\n            count++;\\n            solve(arr, ans, index + 1, count);\\n        }\\n        else{\\n            ans.add(arr[index]);\\n            solve(arr, ans, index + 1, count);\\n        }\\n    }\\n}"
                    },
                    {
                        "username": "mskamel",
                        "content": "Thanks for sharing your solution, it\\'s diverse from other ones here."
                    },
                    {
                        "username": "loyhongshenggg",
                        "content": "I\\'ve noticed that many people posted their answers here and thought perhaps, I could provide a hint!\\n\\nConsider having two pointers at the start of the array. Iterate through the array and swap between the pointers only when right pointer is non-zero, only after the swap, increment your left pointer (along with the right pointer). Otherwise, only increment your right pointer.\\n\\n(May not be the best solution out there, but feel free to comment and make changes)"
                    },
                    {
                        "username": "MariooY2",
                        "content": "var moveZeroes = function(nums) {\n    const len=nums.length;\n    let n=0;\n    for(let x=0;x<nums.length;x++){\n        if(nums[x]==0){\n            console.log(nums);\n            nums.splice(x,1);\n            x--;\n            n++;        \n        }\n    }\n    for(let x=nums.length;x<len;x++){\n        nums.push(0);\n    }\n\nreturn nums;\n\n}\neasy to understand javascript code"
                    },
                    {
                        "username": "JagodaDawidowska",
                        "content": "class Solution {\\n    public void moveZeroes(int[] nums) {\\n       int idxJ = 0;\\n        int x = (nums.length - 1);\\n\\n        for (int j = 0; j < nums.length - idxJ; j++) {\\n            if (nums[j] == 0) {\\n                int temp = nums[(x - idxJ)];\\n                nums[(x - idxJ)] = nums[j];\\n                nums[j] = temp;\\n                idxJ++;\\n            }\\n            System.out.println(Arrays.toString(nums));\\n        }      \\n    }\\n}\\nnums = [0,1,0,3,12] \\nmy output = [12,1,3,0,0] \\nexpected [1,3,12,0,0] \\nCould somone give me a hint to easy fix my code ?"
                    },
                    {
                        "username": "JagodaDawidowska",
                        "content": "since my code triggered  Output Limit Exceeded error I post it as one step closer to correct answer\\nclass Solution {\\n       public void moveZeroes(int[] nums) {\\n        int idxJ = 0;\\n        int x = (nums.length - 1);\\n\\n        for (int i = 0; i < nums.length ; i++) {\\n            for (int j = 0; j < nums.length - 1; j++) {\\n                if (nums[j] == 0) {\\n                    int temp = nums[j + 1];\\n                    nums[j + 1] = nums[j];\\n                    nums[j] = temp;\\n                    idxJ++;\\n                    System.out.println(Arrays.toString(nums));\\n                }\\n            }\\n        }\\n    }\\n} I guess I cant use modyfied bubble sort :( "
                    },
                    {
                        "username": "romangolev",
                        "content": "I am interested why does list comprehension does not work for python solution.\\nAlso I cannot assign one list to another for some reason, simple operation like this `nums=nums1` returns nothing"
                    }
                ]
            },
            {
                "id": 1576401,
                "content": [
                    {
                        "username": "Akshat0706",
                        "content": "Remember QuickSort. Use two Pointers and swap non-zeros to left and zeros to right."
                    },
                    {
                        "username": "ASWINNATH123",
                        "content": "but tle is showing bruhh\\n"
                    },
                    {
                        "username": "kgjobsearch",
                        "content": "b=[0,1,0,3,12]\\nprint(list(a for a in b if a!= 0) + list(a for a in b if a == 0))"
                    },
                    {
                        "username": "azimBaldiwala",
                        "content": "You are making a new list here!!! QUESTION SAYS WE NEED TO MODIFY THE LIST , that is the purpose of the question .. else your solution is correct  "
                    },
                    {
                        "username": "pardhi1400",
                        "content": "it says keep the relative order does that mean not asending ? just the order the elements where in at the start?"
                    },
                    {
                        "username": "itsrishiydv",
                        "content": "Leetcode Python editor having some issue because below code is giving correct answer in local machine.\\n\\nclass Solution:\\n    def moveZeroes(self, nums: List[int]) -> None:\\n        \"\"\"\\n        Do not return anything, modify nums in-place instead.\\n        \"\"\"\\n        lis1=[]\\n        lis2=[]\\n        for i in nums:\\n            if i==0:\\n                lis2.append(i)\\n            if i!=0:\\n                lis1.append(i)\\n            \\n        return lis1+lis2"
                    },
                    {
                        "username": "aXXo",
                        "content": "you are supposed to modify in place. In your code you are creating two new lists"
                    },
                    {
                        "username": "aleazanrashid",
                        "content": " `class Solution:\\n    def moveZeroes(self, nums: List[int]) -> None:\\n        \"\"\"\\n        Do not return anything, modify nums in-place instead.\\n        \"\"\"\\n\\n        count = 0\\n        new = []\\n        \\n        for i in nums:\\n            if i == 0:\\n                count += 1\\n            else:\\n                new.append(i)\\n\\n        for i in range(count):\\n            new.append(0)\\n            \\n        return new`\\n\\n\\nmy solution works fine using pycharm but here i get wrong answer ?????"
                    },
                    {
                        "username": "aleazanrashid",
                        "content": "i came with new code, if you interested\n\n\ndef move_zer():\n\n    lis = [0,1,0,3,12]\n  \n    left, right = 0, len(lis) - 1\n\n    while left < right:\n\n        if lis[left] == 0 :\n            lis[left], lis[left + 1] = lis[left + 1], lis[left]\n\n        left += 1\n\n    return lis\n\nim tryng to solve this proplem with this code , it works fine but not when two zeros come next to each other , it move one of the zero to swap with next element but the another zero stays i need to come back to that zero and keep comparing or swapping any idea  ?\n"
                    },
                    {
                        "username": "aleazanrashid",
                        "content": "[@Siddharoodha10](/Siddharoodha10) ops\\n"
                    },
                    {
                        "username": "Siddharoodha10",
                        "content": "as per question u need to use nums list only. (its asking to modify nums in place only)"
                    },
                    {
                        "username": "CodeWizarder",
                        "content": "class Solution {\\n    public void moveZeroes(int[] nums) {\\n        ArrayList<Integer> ans = new ArrayList<>();\\n        solve(nums, ans, 0, 0);\\n        for(int i = 0; i < ans.size(); i++){\\n            nums[i] = ans.get(i);\\n        }\\n    }\\n\\n    public static void solve(int[] arr, ArrayList<Integer> ans, int index, int count){\\n        if(index == arr.length){\\n            for(int i = 0; i < count; i++){\\n                ans.add(0);\\n            }\\n            return;\\n        }\\n        if(arr[index] == 0){\\n            count++;\\n            solve(arr, ans, index + 1, count);\\n        }\\n        else{\\n            ans.add(arr[index]);\\n            solve(arr, ans, index + 1, count);\\n        }\\n    }\\n}"
                    },
                    {
                        "username": "mskamel",
                        "content": "Thanks for sharing your solution, it\\'s diverse from other ones here."
                    },
                    {
                        "username": "loyhongshenggg",
                        "content": "I\\'ve noticed that many people posted their answers here and thought perhaps, I could provide a hint!\\n\\nConsider having two pointers at the start of the array. Iterate through the array and swap between the pointers only when right pointer is non-zero, only after the swap, increment your left pointer (along with the right pointer). Otherwise, only increment your right pointer.\\n\\n(May not be the best solution out there, but feel free to comment and make changes)"
                    },
                    {
                        "username": "MariooY2",
                        "content": "var moveZeroes = function(nums) {\n    const len=nums.length;\n    let n=0;\n    for(let x=0;x<nums.length;x++){\n        if(nums[x]==0){\n            console.log(nums);\n            nums.splice(x,1);\n            x--;\n            n++;        \n        }\n    }\n    for(let x=nums.length;x<len;x++){\n        nums.push(0);\n    }\n\nreturn nums;\n\n}\neasy to understand javascript code"
                    },
                    {
                        "username": "JagodaDawidowska",
                        "content": "class Solution {\\n    public void moveZeroes(int[] nums) {\\n       int idxJ = 0;\\n        int x = (nums.length - 1);\\n\\n        for (int j = 0; j < nums.length - idxJ; j++) {\\n            if (nums[j] == 0) {\\n                int temp = nums[(x - idxJ)];\\n                nums[(x - idxJ)] = nums[j];\\n                nums[j] = temp;\\n                idxJ++;\\n            }\\n            System.out.println(Arrays.toString(nums));\\n        }      \\n    }\\n}\\nnums = [0,1,0,3,12] \\nmy output = [12,1,3,0,0] \\nexpected [1,3,12,0,0] \\nCould somone give me a hint to easy fix my code ?"
                    },
                    {
                        "username": "JagodaDawidowska",
                        "content": "since my code triggered  Output Limit Exceeded error I post it as one step closer to correct answer\\nclass Solution {\\n       public void moveZeroes(int[] nums) {\\n        int idxJ = 0;\\n        int x = (nums.length - 1);\\n\\n        for (int i = 0; i < nums.length ; i++) {\\n            for (int j = 0; j < nums.length - 1; j++) {\\n                if (nums[j] == 0) {\\n                    int temp = nums[j + 1];\\n                    nums[j + 1] = nums[j];\\n                    nums[j] = temp;\\n                    idxJ++;\\n                    System.out.println(Arrays.toString(nums));\\n                }\\n            }\\n        }\\n    }\\n} I guess I cant use modyfied bubble sort :( "
                    },
                    {
                        "username": "romangolev",
                        "content": "I am interested why does list comprehension does not work for python solution.\\nAlso I cannot assign one list to another for some reason, simple operation like this `nums=nums1` returns nothing"
                    }
                ]
            },
            {
                "id": 2060872,
                "content": [
                    {
                        "username": "Akshat0706",
                        "content": "Remember QuickSort. Use two Pointers and swap non-zeros to left and zeros to right."
                    },
                    {
                        "username": "ASWINNATH123",
                        "content": "but tle is showing bruhh\\n"
                    },
                    {
                        "username": "kgjobsearch",
                        "content": "b=[0,1,0,3,12]\\nprint(list(a for a in b if a!= 0) + list(a for a in b if a == 0))"
                    },
                    {
                        "username": "azimBaldiwala",
                        "content": "You are making a new list here!!! QUESTION SAYS WE NEED TO MODIFY THE LIST , that is the purpose of the question .. else your solution is correct  "
                    },
                    {
                        "username": "pardhi1400",
                        "content": "it says keep the relative order does that mean not asending ? just the order the elements where in at the start?"
                    },
                    {
                        "username": "itsrishiydv",
                        "content": "Leetcode Python editor having some issue because below code is giving correct answer in local machine.\\n\\nclass Solution:\\n    def moveZeroes(self, nums: List[int]) -> None:\\n        \"\"\"\\n        Do not return anything, modify nums in-place instead.\\n        \"\"\"\\n        lis1=[]\\n        lis2=[]\\n        for i in nums:\\n            if i==0:\\n                lis2.append(i)\\n            if i!=0:\\n                lis1.append(i)\\n            \\n        return lis1+lis2"
                    },
                    {
                        "username": "aXXo",
                        "content": "you are supposed to modify in place. In your code you are creating two new lists"
                    },
                    {
                        "username": "aleazanrashid",
                        "content": " `class Solution:\\n    def moveZeroes(self, nums: List[int]) -> None:\\n        \"\"\"\\n        Do not return anything, modify nums in-place instead.\\n        \"\"\"\\n\\n        count = 0\\n        new = []\\n        \\n        for i in nums:\\n            if i == 0:\\n                count += 1\\n            else:\\n                new.append(i)\\n\\n        for i in range(count):\\n            new.append(0)\\n            \\n        return new`\\n\\n\\nmy solution works fine using pycharm but here i get wrong answer ?????"
                    },
                    {
                        "username": "aleazanrashid",
                        "content": "i came with new code, if you interested\n\n\ndef move_zer():\n\n    lis = [0,1,0,3,12]\n  \n    left, right = 0, len(lis) - 1\n\n    while left < right:\n\n        if lis[left] == 0 :\n            lis[left], lis[left + 1] = lis[left + 1], lis[left]\n\n        left += 1\n\n    return lis\n\nim tryng to solve this proplem with this code , it works fine but not when two zeros come next to each other , it move one of the zero to swap with next element but the another zero stays i need to come back to that zero and keep comparing or swapping any idea  ?\n"
                    },
                    {
                        "username": "aleazanrashid",
                        "content": "[@Siddharoodha10](/Siddharoodha10) ops\\n"
                    },
                    {
                        "username": "Siddharoodha10",
                        "content": "as per question u need to use nums list only. (its asking to modify nums in place only)"
                    },
                    {
                        "username": "CodeWizarder",
                        "content": "class Solution {\\n    public void moveZeroes(int[] nums) {\\n        ArrayList<Integer> ans = new ArrayList<>();\\n        solve(nums, ans, 0, 0);\\n        for(int i = 0; i < ans.size(); i++){\\n            nums[i] = ans.get(i);\\n        }\\n    }\\n\\n    public static void solve(int[] arr, ArrayList<Integer> ans, int index, int count){\\n        if(index == arr.length){\\n            for(int i = 0; i < count; i++){\\n                ans.add(0);\\n            }\\n            return;\\n        }\\n        if(arr[index] == 0){\\n            count++;\\n            solve(arr, ans, index + 1, count);\\n        }\\n        else{\\n            ans.add(arr[index]);\\n            solve(arr, ans, index + 1, count);\\n        }\\n    }\\n}"
                    },
                    {
                        "username": "mskamel",
                        "content": "Thanks for sharing your solution, it\\'s diverse from other ones here."
                    },
                    {
                        "username": "loyhongshenggg",
                        "content": "I\\'ve noticed that many people posted their answers here and thought perhaps, I could provide a hint!\\n\\nConsider having two pointers at the start of the array. Iterate through the array and swap between the pointers only when right pointer is non-zero, only after the swap, increment your left pointer (along with the right pointer). Otherwise, only increment your right pointer.\\n\\n(May not be the best solution out there, but feel free to comment and make changes)"
                    },
                    {
                        "username": "MariooY2",
                        "content": "var moveZeroes = function(nums) {\n    const len=nums.length;\n    let n=0;\n    for(let x=0;x<nums.length;x++){\n        if(nums[x]==0){\n            console.log(nums);\n            nums.splice(x,1);\n            x--;\n            n++;        \n        }\n    }\n    for(let x=nums.length;x<len;x++){\n        nums.push(0);\n    }\n\nreturn nums;\n\n}\neasy to understand javascript code"
                    },
                    {
                        "username": "JagodaDawidowska",
                        "content": "class Solution {\\n    public void moveZeroes(int[] nums) {\\n       int idxJ = 0;\\n        int x = (nums.length - 1);\\n\\n        for (int j = 0; j < nums.length - idxJ; j++) {\\n            if (nums[j] == 0) {\\n                int temp = nums[(x - idxJ)];\\n                nums[(x - idxJ)] = nums[j];\\n                nums[j] = temp;\\n                idxJ++;\\n            }\\n            System.out.println(Arrays.toString(nums));\\n        }      \\n    }\\n}\\nnums = [0,1,0,3,12] \\nmy output = [12,1,3,0,0] \\nexpected [1,3,12,0,0] \\nCould somone give me a hint to easy fix my code ?"
                    },
                    {
                        "username": "JagodaDawidowska",
                        "content": "since my code triggered  Output Limit Exceeded error I post it as one step closer to correct answer\\nclass Solution {\\n       public void moveZeroes(int[] nums) {\\n        int idxJ = 0;\\n        int x = (nums.length - 1);\\n\\n        for (int i = 0; i < nums.length ; i++) {\\n            for (int j = 0; j < nums.length - 1; j++) {\\n                if (nums[j] == 0) {\\n                    int temp = nums[j + 1];\\n                    nums[j + 1] = nums[j];\\n                    nums[j] = temp;\\n                    idxJ++;\\n                    System.out.println(Arrays.toString(nums));\\n                }\\n            }\\n        }\\n    }\\n} I guess I cant use modyfied bubble sort :( "
                    },
                    {
                        "username": "romangolev",
                        "content": "I am interested why does list comprehension does not work for python solution.\\nAlso I cannot assign one list to another for some reason, simple operation like this `nums=nums1` returns nothing"
                    }
                ]
            },
            {
                "id": 1947602,
                "content": [
                    {
                        "username": "Akshat0706",
                        "content": "Remember QuickSort. Use two Pointers and swap non-zeros to left and zeros to right."
                    },
                    {
                        "username": "ASWINNATH123",
                        "content": "but tle is showing bruhh\\n"
                    },
                    {
                        "username": "kgjobsearch",
                        "content": "b=[0,1,0,3,12]\\nprint(list(a for a in b if a!= 0) + list(a for a in b if a == 0))"
                    },
                    {
                        "username": "azimBaldiwala",
                        "content": "You are making a new list here!!! QUESTION SAYS WE NEED TO MODIFY THE LIST , that is the purpose of the question .. else your solution is correct  "
                    },
                    {
                        "username": "pardhi1400",
                        "content": "it says keep the relative order does that mean not asending ? just the order the elements where in at the start?"
                    },
                    {
                        "username": "itsrishiydv",
                        "content": "Leetcode Python editor having some issue because below code is giving correct answer in local machine.\\n\\nclass Solution:\\n    def moveZeroes(self, nums: List[int]) -> None:\\n        \"\"\"\\n        Do not return anything, modify nums in-place instead.\\n        \"\"\"\\n        lis1=[]\\n        lis2=[]\\n        for i in nums:\\n            if i==0:\\n                lis2.append(i)\\n            if i!=0:\\n                lis1.append(i)\\n            \\n        return lis1+lis2"
                    },
                    {
                        "username": "aXXo",
                        "content": "you are supposed to modify in place. In your code you are creating two new lists"
                    },
                    {
                        "username": "aleazanrashid",
                        "content": " `class Solution:\\n    def moveZeroes(self, nums: List[int]) -> None:\\n        \"\"\"\\n        Do not return anything, modify nums in-place instead.\\n        \"\"\"\\n\\n        count = 0\\n        new = []\\n        \\n        for i in nums:\\n            if i == 0:\\n                count += 1\\n            else:\\n                new.append(i)\\n\\n        for i in range(count):\\n            new.append(0)\\n            \\n        return new`\\n\\n\\nmy solution works fine using pycharm but here i get wrong answer ?????"
                    },
                    {
                        "username": "aleazanrashid",
                        "content": "i came with new code, if you interested\n\n\ndef move_zer():\n\n    lis = [0,1,0,3,12]\n  \n    left, right = 0, len(lis) - 1\n\n    while left < right:\n\n        if lis[left] == 0 :\n            lis[left], lis[left + 1] = lis[left + 1], lis[left]\n\n        left += 1\n\n    return lis\n\nim tryng to solve this proplem with this code , it works fine but not when two zeros come next to each other , it move one of the zero to swap with next element but the another zero stays i need to come back to that zero and keep comparing or swapping any idea  ?\n"
                    },
                    {
                        "username": "aleazanrashid",
                        "content": "[@Siddharoodha10](/Siddharoodha10) ops\\n"
                    },
                    {
                        "username": "Siddharoodha10",
                        "content": "as per question u need to use nums list only. (its asking to modify nums in place only)"
                    },
                    {
                        "username": "CodeWizarder",
                        "content": "class Solution {\\n    public void moveZeroes(int[] nums) {\\n        ArrayList<Integer> ans = new ArrayList<>();\\n        solve(nums, ans, 0, 0);\\n        for(int i = 0; i < ans.size(); i++){\\n            nums[i] = ans.get(i);\\n        }\\n    }\\n\\n    public static void solve(int[] arr, ArrayList<Integer> ans, int index, int count){\\n        if(index == arr.length){\\n            for(int i = 0; i < count; i++){\\n                ans.add(0);\\n            }\\n            return;\\n        }\\n        if(arr[index] == 0){\\n            count++;\\n            solve(arr, ans, index + 1, count);\\n        }\\n        else{\\n            ans.add(arr[index]);\\n            solve(arr, ans, index + 1, count);\\n        }\\n    }\\n}"
                    },
                    {
                        "username": "mskamel",
                        "content": "Thanks for sharing your solution, it\\'s diverse from other ones here."
                    },
                    {
                        "username": "loyhongshenggg",
                        "content": "I\\'ve noticed that many people posted their answers here and thought perhaps, I could provide a hint!\\n\\nConsider having two pointers at the start of the array. Iterate through the array and swap between the pointers only when right pointer is non-zero, only after the swap, increment your left pointer (along with the right pointer). Otherwise, only increment your right pointer.\\n\\n(May not be the best solution out there, but feel free to comment and make changes)"
                    },
                    {
                        "username": "MariooY2",
                        "content": "var moveZeroes = function(nums) {\n    const len=nums.length;\n    let n=0;\n    for(let x=0;x<nums.length;x++){\n        if(nums[x]==0){\n            console.log(nums);\n            nums.splice(x,1);\n            x--;\n            n++;        \n        }\n    }\n    for(let x=nums.length;x<len;x++){\n        nums.push(0);\n    }\n\nreturn nums;\n\n}\neasy to understand javascript code"
                    },
                    {
                        "username": "JagodaDawidowska",
                        "content": "class Solution {\\n    public void moveZeroes(int[] nums) {\\n       int idxJ = 0;\\n        int x = (nums.length - 1);\\n\\n        for (int j = 0; j < nums.length - idxJ; j++) {\\n            if (nums[j] == 0) {\\n                int temp = nums[(x - idxJ)];\\n                nums[(x - idxJ)] = nums[j];\\n                nums[j] = temp;\\n                idxJ++;\\n            }\\n            System.out.println(Arrays.toString(nums));\\n        }      \\n    }\\n}\\nnums = [0,1,0,3,12] \\nmy output = [12,1,3,0,0] \\nexpected [1,3,12,0,0] \\nCould somone give me a hint to easy fix my code ?"
                    },
                    {
                        "username": "JagodaDawidowska",
                        "content": "since my code triggered  Output Limit Exceeded error I post it as one step closer to correct answer\\nclass Solution {\\n       public void moveZeroes(int[] nums) {\\n        int idxJ = 0;\\n        int x = (nums.length - 1);\\n\\n        for (int i = 0; i < nums.length ; i++) {\\n            for (int j = 0; j < nums.length - 1; j++) {\\n                if (nums[j] == 0) {\\n                    int temp = nums[j + 1];\\n                    nums[j + 1] = nums[j];\\n                    nums[j] = temp;\\n                    idxJ++;\\n                    System.out.println(Arrays.toString(nums));\\n                }\\n            }\\n        }\\n    }\\n} I guess I cant use modyfied bubble sort :( "
                    },
                    {
                        "username": "romangolev",
                        "content": "I am interested why does list comprehension does not work for python solution.\\nAlso I cannot assign one list to another for some reason, simple operation like this `nums=nums1` returns nothing"
                    }
                ]
            },
            {
                "id": 1835342,
                "content": [
                    {
                        "username": "Akshat0706",
                        "content": "Remember QuickSort. Use two Pointers and swap non-zeros to left and zeros to right."
                    },
                    {
                        "username": "ASWINNATH123",
                        "content": "but tle is showing bruhh\\n"
                    },
                    {
                        "username": "kgjobsearch",
                        "content": "b=[0,1,0,3,12]\\nprint(list(a for a in b if a!= 0) + list(a for a in b if a == 0))"
                    },
                    {
                        "username": "azimBaldiwala",
                        "content": "You are making a new list here!!! QUESTION SAYS WE NEED TO MODIFY THE LIST , that is the purpose of the question .. else your solution is correct  "
                    },
                    {
                        "username": "pardhi1400",
                        "content": "it says keep the relative order does that mean not asending ? just the order the elements where in at the start?"
                    },
                    {
                        "username": "itsrishiydv",
                        "content": "Leetcode Python editor having some issue because below code is giving correct answer in local machine.\\n\\nclass Solution:\\n    def moveZeroes(self, nums: List[int]) -> None:\\n        \"\"\"\\n        Do not return anything, modify nums in-place instead.\\n        \"\"\"\\n        lis1=[]\\n        lis2=[]\\n        for i in nums:\\n            if i==0:\\n                lis2.append(i)\\n            if i!=0:\\n                lis1.append(i)\\n            \\n        return lis1+lis2"
                    },
                    {
                        "username": "aXXo",
                        "content": "you are supposed to modify in place. In your code you are creating two new lists"
                    },
                    {
                        "username": "aleazanrashid",
                        "content": " `class Solution:\\n    def moveZeroes(self, nums: List[int]) -> None:\\n        \"\"\"\\n        Do not return anything, modify nums in-place instead.\\n        \"\"\"\\n\\n        count = 0\\n        new = []\\n        \\n        for i in nums:\\n            if i == 0:\\n                count += 1\\n            else:\\n                new.append(i)\\n\\n        for i in range(count):\\n            new.append(0)\\n            \\n        return new`\\n\\n\\nmy solution works fine using pycharm but here i get wrong answer ?????"
                    },
                    {
                        "username": "aleazanrashid",
                        "content": "i came with new code, if you interested\n\n\ndef move_zer():\n\n    lis = [0,1,0,3,12]\n  \n    left, right = 0, len(lis) - 1\n\n    while left < right:\n\n        if lis[left] == 0 :\n            lis[left], lis[left + 1] = lis[left + 1], lis[left]\n\n        left += 1\n\n    return lis\n\nim tryng to solve this proplem with this code , it works fine but not when two zeros come next to each other , it move one of the zero to swap with next element but the another zero stays i need to come back to that zero and keep comparing or swapping any idea  ?\n"
                    },
                    {
                        "username": "aleazanrashid",
                        "content": "[@Siddharoodha10](/Siddharoodha10) ops\\n"
                    },
                    {
                        "username": "Siddharoodha10",
                        "content": "as per question u need to use nums list only. (its asking to modify nums in place only)"
                    },
                    {
                        "username": "CodeWizarder",
                        "content": "class Solution {\\n    public void moveZeroes(int[] nums) {\\n        ArrayList<Integer> ans = new ArrayList<>();\\n        solve(nums, ans, 0, 0);\\n        for(int i = 0; i < ans.size(); i++){\\n            nums[i] = ans.get(i);\\n        }\\n    }\\n\\n    public static void solve(int[] arr, ArrayList<Integer> ans, int index, int count){\\n        if(index == arr.length){\\n            for(int i = 0; i < count; i++){\\n                ans.add(0);\\n            }\\n            return;\\n        }\\n        if(arr[index] == 0){\\n            count++;\\n            solve(arr, ans, index + 1, count);\\n        }\\n        else{\\n            ans.add(arr[index]);\\n            solve(arr, ans, index + 1, count);\\n        }\\n    }\\n}"
                    },
                    {
                        "username": "mskamel",
                        "content": "Thanks for sharing your solution, it\\'s diverse from other ones here."
                    },
                    {
                        "username": "loyhongshenggg",
                        "content": "I\\'ve noticed that many people posted their answers here and thought perhaps, I could provide a hint!\\n\\nConsider having two pointers at the start of the array. Iterate through the array and swap between the pointers only when right pointer is non-zero, only after the swap, increment your left pointer (along with the right pointer). Otherwise, only increment your right pointer.\\n\\n(May not be the best solution out there, but feel free to comment and make changes)"
                    },
                    {
                        "username": "MariooY2",
                        "content": "var moveZeroes = function(nums) {\n    const len=nums.length;\n    let n=0;\n    for(let x=0;x<nums.length;x++){\n        if(nums[x]==0){\n            console.log(nums);\n            nums.splice(x,1);\n            x--;\n            n++;        \n        }\n    }\n    for(let x=nums.length;x<len;x++){\n        nums.push(0);\n    }\n\nreturn nums;\n\n}\neasy to understand javascript code"
                    },
                    {
                        "username": "JagodaDawidowska",
                        "content": "class Solution {\\n    public void moveZeroes(int[] nums) {\\n       int idxJ = 0;\\n        int x = (nums.length - 1);\\n\\n        for (int j = 0; j < nums.length - idxJ; j++) {\\n            if (nums[j] == 0) {\\n                int temp = nums[(x - idxJ)];\\n                nums[(x - idxJ)] = nums[j];\\n                nums[j] = temp;\\n                idxJ++;\\n            }\\n            System.out.println(Arrays.toString(nums));\\n        }      \\n    }\\n}\\nnums = [0,1,0,3,12] \\nmy output = [12,1,3,0,0] \\nexpected [1,3,12,0,0] \\nCould somone give me a hint to easy fix my code ?"
                    },
                    {
                        "username": "JagodaDawidowska",
                        "content": "since my code triggered  Output Limit Exceeded error I post it as one step closer to correct answer\\nclass Solution {\\n       public void moveZeroes(int[] nums) {\\n        int idxJ = 0;\\n        int x = (nums.length - 1);\\n\\n        for (int i = 0; i < nums.length ; i++) {\\n            for (int j = 0; j < nums.length - 1; j++) {\\n                if (nums[j] == 0) {\\n                    int temp = nums[j + 1];\\n                    nums[j + 1] = nums[j];\\n                    nums[j] = temp;\\n                    idxJ++;\\n                    System.out.println(Arrays.toString(nums));\\n                }\\n            }\\n        }\\n    }\\n} I guess I cant use modyfied bubble sort :( "
                    },
                    {
                        "username": "romangolev",
                        "content": "I am interested why does list comprehension does not work for python solution.\\nAlso I cannot assign one list to another for some reason, simple operation like this `nums=nums1` returns nothing"
                    }
                ]
            },
            {
                "id": 1765226,
                "content": [
                    {
                        "username": "Akshat0706",
                        "content": "Remember QuickSort. Use two Pointers and swap non-zeros to left and zeros to right."
                    },
                    {
                        "username": "ASWINNATH123",
                        "content": "but tle is showing bruhh\\n"
                    },
                    {
                        "username": "kgjobsearch",
                        "content": "b=[0,1,0,3,12]\\nprint(list(a for a in b if a!= 0) + list(a for a in b if a == 0))"
                    },
                    {
                        "username": "azimBaldiwala",
                        "content": "You are making a new list here!!! QUESTION SAYS WE NEED TO MODIFY THE LIST , that is the purpose of the question .. else your solution is correct  "
                    },
                    {
                        "username": "pardhi1400",
                        "content": "it says keep the relative order does that mean not asending ? just the order the elements where in at the start?"
                    },
                    {
                        "username": "itsrishiydv",
                        "content": "Leetcode Python editor having some issue because below code is giving correct answer in local machine.\\n\\nclass Solution:\\n    def moveZeroes(self, nums: List[int]) -> None:\\n        \"\"\"\\n        Do not return anything, modify nums in-place instead.\\n        \"\"\"\\n        lis1=[]\\n        lis2=[]\\n        for i in nums:\\n            if i==0:\\n                lis2.append(i)\\n            if i!=0:\\n                lis1.append(i)\\n            \\n        return lis1+lis2"
                    },
                    {
                        "username": "aXXo",
                        "content": "you are supposed to modify in place. In your code you are creating two new lists"
                    },
                    {
                        "username": "aleazanrashid",
                        "content": " `class Solution:\\n    def moveZeroes(self, nums: List[int]) -> None:\\n        \"\"\"\\n        Do not return anything, modify nums in-place instead.\\n        \"\"\"\\n\\n        count = 0\\n        new = []\\n        \\n        for i in nums:\\n            if i == 0:\\n                count += 1\\n            else:\\n                new.append(i)\\n\\n        for i in range(count):\\n            new.append(0)\\n            \\n        return new`\\n\\n\\nmy solution works fine using pycharm but here i get wrong answer ?????"
                    },
                    {
                        "username": "aleazanrashid",
                        "content": "i came with new code, if you interested\n\n\ndef move_zer():\n\n    lis = [0,1,0,3,12]\n  \n    left, right = 0, len(lis) - 1\n\n    while left < right:\n\n        if lis[left] == 0 :\n            lis[left], lis[left + 1] = lis[left + 1], lis[left]\n\n        left += 1\n\n    return lis\n\nim tryng to solve this proplem with this code , it works fine but not when two zeros come next to each other , it move one of the zero to swap with next element but the another zero stays i need to come back to that zero and keep comparing or swapping any idea  ?\n"
                    },
                    {
                        "username": "aleazanrashid",
                        "content": "[@Siddharoodha10](/Siddharoodha10) ops\\n"
                    },
                    {
                        "username": "Siddharoodha10",
                        "content": "as per question u need to use nums list only. (its asking to modify nums in place only)"
                    },
                    {
                        "username": "CodeWizarder",
                        "content": "class Solution {\\n    public void moveZeroes(int[] nums) {\\n        ArrayList<Integer> ans = new ArrayList<>();\\n        solve(nums, ans, 0, 0);\\n        for(int i = 0; i < ans.size(); i++){\\n            nums[i] = ans.get(i);\\n        }\\n    }\\n\\n    public static void solve(int[] arr, ArrayList<Integer> ans, int index, int count){\\n        if(index == arr.length){\\n            for(int i = 0; i < count; i++){\\n                ans.add(0);\\n            }\\n            return;\\n        }\\n        if(arr[index] == 0){\\n            count++;\\n            solve(arr, ans, index + 1, count);\\n        }\\n        else{\\n            ans.add(arr[index]);\\n            solve(arr, ans, index + 1, count);\\n        }\\n    }\\n}"
                    },
                    {
                        "username": "mskamel",
                        "content": "Thanks for sharing your solution, it\\'s diverse from other ones here."
                    },
                    {
                        "username": "loyhongshenggg",
                        "content": "I\\'ve noticed that many people posted their answers here and thought perhaps, I could provide a hint!\\n\\nConsider having two pointers at the start of the array. Iterate through the array and swap between the pointers only when right pointer is non-zero, only after the swap, increment your left pointer (along with the right pointer). Otherwise, only increment your right pointer.\\n\\n(May not be the best solution out there, but feel free to comment and make changes)"
                    },
                    {
                        "username": "MariooY2",
                        "content": "var moveZeroes = function(nums) {\n    const len=nums.length;\n    let n=0;\n    for(let x=0;x<nums.length;x++){\n        if(nums[x]==0){\n            console.log(nums);\n            nums.splice(x,1);\n            x--;\n            n++;        \n        }\n    }\n    for(let x=nums.length;x<len;x++){\n        nums.push(0);\n    }\n\nreturn nums;\n\n}\neasy to understand javascript code"
                    },
                    {
                        "username": "JagodaDawidowska",
                        "content": "class Solution {\\n    public void moveZeroes(int[] nums) {\\n       int idxJ = 0;\\n        int x = (nums.length - 1);\\n\\n        for (int j = 0; j < nums.length - idxJ; j++) {\\n            if (nums[j] == 0) {\\n                int temp = nums[(x - idxJ)];\\n                nums[(x - idxJ)] = nums[j];\\n                nums[j] = temp;\\n                idxJ++;\\n            }\\n            System.out.println(Arrays.toString(nums));\\n        }      \\n    }\\n}\\nnums = [0,1,0,3,12] \\nmy output = [12,1,3,0,0] \\nexpected [1,3,12,0,0] \\nCould somone give me a hint to easy fix my code ?"
                    },
                    {
                        "username": "JagodaDawidowska",
                        "content": "since my code triggered  Output Limit Exceeded error I post it as one step closer to correct answer\\nclass Solution {\\n       public void moveZeroes(int[] nums) {\\n        int idxJ = 0;\\n        int x = (nums.length - 1);\\n\\n        for (int i = 0; i < nums.length ; i++) {\\n            for (int j = 0; j < nums.length - 1; j++) {\\n                if (nums[j] == 0) {\\n                    int temp = nums[j + 1];\\n                    nums[j + 1] = nums[j];\\n                    nums[j] = temp;\\n                    idxJ++;\\n                    System.out.println(Arrays.toString(nums));\\n                }\\n            }\\n        }\\n    }\\n} I guess I cant use modyfied bubble sort :( "
                    },
                    {
                        "username": "romangolev",
                        "content": "I am interested why does list comprehension does not work for python solution.\\nAlso I cannot assign one list to another for some reason, simple operation like this `nums=nums1` returns nothing"
                    }
                ]
            },
            {
                "id": 2068974,
                "content": [
                    {
                        "username": "Akshat0706",
                        "content": "Remember QuickSort. Use two Pointers and swap non-zeros to left and zeros to right."
                    },
                    {
                        "username": "ASWINNATH123",
                        "content": "but tle is showing bruhh\\n"
                    },
                    {
                        "username": "kgjobsearch",
                        "content": "b=[0,1,0,3,12]\\nprint(list(a for a in b if a!= 0) + list(a for a in b if a == 0))"
                    },
                    {
                        "username": "azimBaldiwala",
                        "content": "You are making a new list here!!! QUESTION SAYS WE NEED TO MODIFY THE LIST , that is the purpose of the question .. else your solution is correct  "
                    },
                    {
                        "username": "pardhi1400",
                        "content": "it says keep the relative order does that mean not asending ? just the order the elements where in at the start?"
                    },
                    {
                        "username": "itsrishiydv",
                        "content": "Leetcode Python editor having some issue because below code is giving correct answer in local machine.\\n\\nclass Solution:\\n    def moveZeroes(self, nums: List[int]) -> None:\\n        \"\"\"\\n        Do not return anything, modify nums in-place instead.\\n        \"\"\"\\n        lis1=[]\\n        lis2=[]\\n        for i in nums:\\n            if i==0:\\n                lis2.append(i)\\n            if i!=0:\\n                lis1.append(i)\\n            \\n        return lis1+lis2"
                    },
                    {
                        "username": "aXXo",
                        "content": "you are supposed to modify in place. In your code you are creating two new lists"
                    },
                    {
                        "username": "aleazanrashid",
                        "content": " `class Solution:\\n    def moveZeroes(self, nums: List[int]) -> None:\\n        \"\"\"\\n        Do not return anything, modify nums in-place instead.\\n        \"\"\"\\n\\n        count = 0\\n        new = []\\n        \\n        for i in nums:\\n            if i == 0:\\n                count += 1\\n            else:\\n                new.append(i)\\n\\n        for i in range(count):\\n            new.append(0)\\n            \\n        return new`\\n\\n\\nmy solution works fine using pycharm but here i get wrong answer ?????"
                    },
                    {
                        "username": "aleazanrashid",
                        "content": "i came with new code, if you interested\n\n\ndef move_zer():\n\n    lis = [0,1,0,3,12]\n  \n    left, right = 0, len(lis) - 1\n\n    while left < right:\n\n        if lis[left] == 0 :\n            lis[left], lis[left + 1] = lis[left + 1], lis[left]\n\n        left += 1\n\n    return lis\n\nim tryng to solve this proplem with this code , it works fine but not when two zeros come next to each other , it move one of the zero to swap with next element but the another zero stays i need to come back to that zero and keep comparing or swapping any idea  ?\n"
                    },
                    {
                        "username": "aleazanrashid",
                        "content": "[@Siddharoodha10](/Siddharoodha10) ops\\n"
                    },
                    {
                        "username": "Siddharoodha10",
                        "content": "as per question u need to use nums list only. (its asking to modify nums in place only)"
                    },
                    {
                        "username": "CodeWizarder",
                        "content": "class Solution {\\n    public void moveZeroes(int[] nums) {\\n        ArrayList<Integer> ans = new ArrayList<>();\\n        solve(nums, ans, 0, 0);\\n        for(int i = 0; i < ans.size(); i++){\\n            nums[i] = ans.get(i);\\n        }\\n    }\\n\\n    public static void solve(int[] arr, ArrayList<Integer> ans, int index, int count){\\n        if(index == arr.length){\\n            for(int i = 0; i < count; i++){\\n                ans.add(0);\\n            }\\n            return;\\n        }\\n        if(arr[index] == 0){\\n            count++;\\n            solve(arr, ans, index + 1, count);\\n        }\\n        else{\\n            ans.add(arr[index]);\\n            solve(arr, ans, index + 1, count);\\n        }\\n    }\\n}"
                    },
                    {
                        "username": "mskamel",
                        "content": "Thanks for sharing your solution, it\\'s diverse from other ones here."
                    },
                    {
                        "username": "loyhongshenggg",
                        "content": "I\\'ve noticed that many people posted their answers here and thought perhaps, I could provide a hint!\\n\\nConsider having two pointers at the start of the array. Iterate through the array and swap between the pointers only when right pointer is non-zero, only after the swap, increment your left pointer (along with the right pointer). Otherwise, only increment your right pointer.\\n\\n(May not be the best solution out there, but feel free to comment and make changes)"
                    },
                    {
                        "username": "MariooY2",
                        "content": "var moveZeroes = function(nums) {\n    const len=nums.length;\n    let n=0;\n    for(let x=0;x<nums.length;x++){\n        if(nums[x]==0){\n            console.log(nums);\n            nums.splice(x,1);\n            x--;\n            n++;        \n        }\n    }\n    for(let x=nums.length;x<len;x++){\n        nums.push(0);\n    }\n\nreturn nums;\n\n}\neasy to understand javascript code"
                    },
                    {
                        "username": "JagodaDawidowska",
                        "content": "class Solution {\\n    public void moveZeroes(int[] nums) {\\n       int idxJ = 0;\\n        int x = (nums.length - 1);\\n\\n        for (int j = 0; j < nums.length - idxJ; j++) {\\n            if (nums[j] == 0) {\\n                int temp = nums[(x - idxJ)];\\n                nums[(x - idxJ)] = nums[j];\\n                nums[j] = temp;\\n                idxJ++;\\n            }\\n            System.out.println(Arrays.toString(nums));\\n        }      \\n    }\\n}\\nnums = [0,1,0,3,12] \\nmy output = [12,1,3,0,0] \\nexpected [1,3,12,0,0] \\nCould somone give me a hint to easy fix my code ?"
                    },
                    {
                        "username": "JagodaDawidowska",
                        "content": "since my code triggered  Output Limit Exceeded error I post it as one step closer to correct answer\\nclass Solution {\\n       public void moveZeroes(int[] nums) {\\n        int idxJ = 0;\\n        int x = (nums.length - 1);\\n\\n        for (int i = 0; i < nums.length ; i++) {\\n            for (int j = 0; j < nums.length - 1; j++) {\\n                if (nums[j] == 0) {\\n                    int temp = nums[j + 1];\\n                    nums[j + 1] = nums[j];\\n                    nums[j] = temp;\\n                    idxJ++;\\n                    System.out.println(Arrays.toString(nums));\\n                }\\n            }\\n        }\\n    }\\n} I guess I cant use modyfied bubble sort :( "
                    },
                    {
                        "username": "romangolev",
                        "content": "I am interested why does list comprehension does not work for python solution.\\nAlso I cannot assign one list to another for some reason, simple operation like this `nums=nums1` returns nothing"
                    }
                ]
            },
            {
                "id": 2068074,
                "content": [
                    {
                        "username": "Akshat0706",
                        "content": "Remember QuickSort. Use two Pointers and swap non-zeros to left and zeros to right."
                    },
                    {
                        "username": "ASWINNATH123",
                        "content": "but tle is showing bruhh\\n"
                    },
                    {
                        "username": "kgjobsearch",
                        "content": "b=[0,1,0,3,12]\\nprint(list(a for a in b if a!= 0) + list(a for a in b if a == 0))"
                    },
                    {
                        "username": "azimBaldiwala",
                        "content": "You are making a new list here!!! QUESTION SAYS WE NEED TO MODIFY THE LIST , that is the purpose of the question .. else your solution is correct  "
                    },
                    {
                        "username": "pardhi1400",
                        "content": "it says keep the relative order does that mean not asending ? just the order the elements where in at the start?"
                    },
                    {
                        "username": "itsrishiydv",
                        "content": "Leetcode Python editor having some issue because below code is giving correct answer in local machine.\\n\\nclass Solution:\\n    def moveZeroes(self, nums: List[int]) -> None:\\n        \"\"\"\\n        Do not return anything, modify nums in-place instead.\\n        \"\"\"\\n        lis1=[]\\n        lis2=[]\\n        for i in nums:\\n            if i==0:\\n                lis2.append(i)\\n            if i!=0:\\n                lis1.append(i)\\n            \\n        return lis1+lis2"
                    },
                    {
                        "username": "aXXo",
                        "content": "you are supposed to modify in place. In your code you are creating two new lists"
                    },
                    {
                        "username": "aleazanrashid",
                        "content": " `class Solution:\\n    def moveZeroes(self, nums: List[int]) -> None:\\n        \"\"\"\\n        Do not return anything, modify nums in-place instead.\\n        \"\"\"\\n\\n        count = 0\\n        new = []\\n        \\n        for i in nums:\\n            if i == 0:\\n                count += 1\\n            else:\\n                new.append(i)\\n\\n        for i in range(count):\\n            new.append(0)\\n            \\n        return new`\\n\\n\\nmy solution works fine using pycharm but here i get wrong answer ?????"
                    },
                    {
                        "username": "aleazanrashid",
                        "content": "i came with new code, if you interested\n\n\ndef move_zer():\n\n    lis = [0,1,0,3,12]\n  \n    left, right = 0, len(lis) - 1\n\n    while left < right:\n\n        if lis[left] == 0 :\n            lis[left], lis[left + 1] = lis[left + 1], lis[left]\n\n        left += 1\n\n    return lis\n\nim tryng to solve this proplem with this code , it works fine but not when two zeros come next to each other , it move one of the zero to swap with next element but the another zero stays i need to come back to that zero and keep comparing or swapping any idea  ?\n"
                    },
                    {
                        "username": "aleazanrashid",
                        "content": "[@Siddharoodha10](/Siddharoodha10) ops\\n"
                    },
                    {
                        "username": "Siddharoodha10",
                        "content": "as per question u need to use nums list only. (its asking to modify nums in place only)"
                    },
                    {
                        "username": "CodeWizarder",
                        "content": "class Solution {\\n    public void moveZeroes(int[] nums) {\\n        ArrayList<Integer> ans = new ArrayList<>();\\n        solve(nums, ans, 0, 0);\\n        for(int i = 0; i < ans.size(); i++){\\n            nums[i] = ans.get(i);\\n        }\\n    }\\n\\n    public static void solve(int[] arr, ArrayList<Integer> ans, int index, int count){\\n        if(index == arr.length){\\n            for(int i = 0; i < count; i++){\\n                ans.add(0);\\n            }\\n            return;\\n        }\\n        if(arr[index] == 0){\\n            count++;\\n            solve(arr, ans, index + 1, count);\\n        }\\n        else{\\n            ans.add(arr[index]);\\n            solve(arr, ans, index + 1, count);\\n        }\\n    }\\n}"
                    },
                    {
                        "username": "mskamel",
                        "content": "Thanks for sharing your solution, it\\'s diverse from other ones here."
                    },
                    {
                        "username": "loyhongshenggg",
                        "content": "I\\'ve noticed that many people posted their answers here and thought perhaps, I could provide a hint!\\n\\nConsider having two pointers at the start of the array. Iterate through the array and swap between the pointers only when right pointer is non-zero, only after the swap, increment your left pointer (along with the right pointer). Otherwise, only increment your right pointer.\\n\\n(May not be the best solution out there, but feel free to comment and make changes)"
                    },
                    {
                        "username": "MariooY2",
                        "content": "var moveZeroes = function(nums) {\n    const len=nums.length;\n    let n=0;\n    for(let x=0;x<nums.length;x++){\n        if(nums[x]==0){\n            console.log(nums);\n            nums.splice(x,1);\n            x--;\n            n++;        \n        }\n    }\n    for(let x=nums.length;x<len;x++){\n        nums.push(0);\n    }\n\nreturn nums;\n\n}\neasy to understand javascript code"
                    },
                    {
                        "username": "JagodaDawidowska",
                        "content": "class Solution {\\n    public void moveZeroes(int[] nums) {\\n       int idxJ = 0;\\n        int x = (nums.length - 1);\\n\\n        for (int j = 0; j < nums.length - idxJ; j++) {\\n            if (nums[j] == 0) {\\n                int temp = nums[(x - idxJ)];\\n                nums[(x - idxJ)] = nums[j];\\n                nums[j] = temp;\\n                idxJ++;\\n            }\\n            System.out.println(Arrays.toString(nums));\\n        }      \\n    }\\n}\\nnums = [0,1,0,3,12] \\nmy output = [12,1,3,0,0] \\nexpected [1,3,12,0,0] \\nCould somone give me a hint to easy fix my code ?"
                    },
                    {
                        "username": "JagodaDawidowska",
                        "content": "since my code triggered  Output Limit Exceeded error I post it as one step closer to correct answer\\nclass Solution {\\n       public void moveZeroes(int[] nums) {\\n        int idxJ = 0;\\n        int x = (nums.length - 1);\\n\\n        for (int i = 0; i < nums.length ; i++) {\\n            for (int j = 0; j < nums.length - 1; j++) {\\n                if (nums[j] == 0) {\\n                    int temp = nums[j + 1];\\n                    nums[j + 1] = nums[j];\\n                    nums[j] = temp;\\n                    idxJ++;\\n                    System.out.println(Arrays.toString(nums));\\n                }\\n            }\\n        }\\n    }\\n} I guess I cant use modyfied bubble sort :( "
                    },
                    {
                        "username": "romangolev",
                        "content": "I am interested why does list comprehension does not work for python solution.\\nAlso I cannot assign one list to another for some reason, simple operation like this `nums=nums1` returns nothing"
                    }
                ]
            },
            {
                "id": 2067541,
                "content": [
                    {
                        "username": "Akshat0706",
                        "content": "Remember QuickSort. Use two Pointers and swap non-zeros to left and zeros to right."
                    },
                    {
                        "username": "ASWINNATH123",
                        "content": "but tle is showing bruhh\\n"
                    },
                    {
                        "username": "kgjobsearch",
                        "content": "b=[0,1,0,3,12]\\nprint(list(a for a in b if a!= 0) + list(a for a in b if a == 0))"
                    },
                    {
                        "username": "azimBaldiwala",
                        "content": "You are making a new list here!!! QUESTION SAYS WE NEED TO MODIFY THE LIST , that is the purpose of the question .. else your solution is correct  "
                    },
                    {
                        "username": "pardhi1400",
                        "content": "it says keep the relative order does that mean not asending ? just the order the elements where in at the start?"
                    },
                    {
                        "username": "itsrishiydv",
                        "content": "Leetcode Python editor having some issue because below code is giving correct answer in local machine.\\n\\nclass Solution:\\n    def moveZeroes(self, nums: List[int]) -> None:\\n        \"\"\"\\n        Do not return anything, modify nums in-place instead.\\n        \"\"\"\\n        lis1=[]\\n        lis2=[]\\n        for i in nums:\\n            if i==0:\\n                lis2.append(i)\\n            if i!=0:\\n                lis1.append(i)\\n            \\n        return lis1+lis2"
                    },
                    {
                        "username": "aXXo",
                        "content": "you are supposed to modify in place. In your code you are creating two new lists"
                    },
                    {
                        "username": "aleazanrashid",
                        "content": " `class Solution:\\n    def moveZeroes(self, nums: List[int]) -> None:\\n        \"\"\"\\n        Do not return anything, modify nums in-place instead.\\n        \"\"\"\\n\\n        count = 0\\n        new = []\\n        \\n        for i in nums:\\n            if i == 0:\\n                count += 1\\n            else:\\n                new.append(i)\\n\\n        for i in range(count):\\n            new.append(0)\\n            \\n        return new`\\n\\n\\nmy solution works fine using pycharm but here i get wrong answer ?????"
                    },
                    {
                        "username": "aleazanrashid",
                        "content": "i came with new code, if you interested\n\n\ndef move_zer():\n\n    lis = [0,1,0,3,12]\n  \n    left, right = 0, len(lis) - 1\n\n    while left < right:\n\n        if lis[left] == 0 :\n            lis[left], lis[left + 1] = lis[left + 1], lis[left]\n\n        left += 1\n\n    return lis\n\nim tryng to solve this proplem with this code , it works fine but not when two zeros come next to each other , it move one of the zero to swap with next element but the another zero stays i need to come back to that zero and keep comparing or swapping any idea  ?\n"
                    },
                    {
                        "username": "aleazanrashid",
                        "content": "[@Siddharoodha10](/Siddharoodha10) ops\\n"
                    },
                    {
                        "username": "Siddharoodha10",
                        "content": "as per question u need to use nums list only. (its asking to modify nums in place only)"
                    },
                    {
                        "username": "CodeWizarder",
                        "content": "class Solution {\\n    public void moveZeroes(int[] nums) {\\n        ArrayList<Integer> ans = new ArrayList<>();\\n        solve(nums, ans, 0, 0);\\n        for(int i = 0; i < ans.size(); i++){\\n            nums[i] = ans.get(i);\\n        }\\n    }\\n\\n    public static void solve(int[] arr, ArrayList<Integer> ans, int index, int count){\\n        if(index == arr.length){\\n            for(int i = 0; i < count; i++){\\n                ans.add(0);\\n            }\\n            return;\\n        }\\n        if(arr[index] == 0){\\n            count++;\\n            solve(arr, ans, index + 1, count);\\n        }\\n        else{\\n            ans.add(arr[index]);\\n            solve(arr, ans, index + 1, count);\\n        }\\n    }\\n}"
                    },
                    {
                        "username": "mskamel",
                        "content": "Thanks for sharing your solution, it\\'s diverse from other ones here."
                    },
                    {
                        "username": "loyhongshenggg",
                        "content": "I\\'ve noticed that many people posted their answers here and thought perhaps, I could provide a hint!\\n\\nConsider having two pointers at the start of the array. Iterate through the array and swap between the pointers only when right pointer is non-zero, only after the swap, increment your left pointer (along with the right pointer). Otherwise, only increment your right pointer.\\n\\n(May not be the best solution out there, but feel free to comment and make changes)"
                    },
                    {
                        "username": "MariooY2",
                        "content": "var moveZeroes = function(nums) {\n    const len=nums.length;\n    let n=0;\n    for(let x=0;x<nums.length;x++){\n        if(nums[x]==0){\n            console.log(nums);\n            nums.splice(x,1);\n            x--;\n            n++;        \n        }\n    }\n    for(let x=nums.length;x<len;x++){\n        nums.push(0);\n    }\n\nreturn nums;\n\n}\neasy to understand javascript code"
                    },
                    {
                        "username": "JagodaDawidowska",
                        "content": "class Solution {\\n    public void moveZeroes(int[] nums) {\\n       int idxJ = 0;\\n        int x = (nums.length - 1);\\n\\n        for (int j = 0; j < nums.length - idxJ; j++) {\\n            if (nums[j] == 0) {\\n                int temp = nums[(x - idxJ)];\\n                nums[(x - idxJ)] = nums[j];\\n                nums[j] = temp;\\n                idxJ++;\\n            }\\n            System.out.println(Arrays.toString(nums));\\n        }      \\n    }\\n}\\nnums = [0,1,0,3,12] \\nmy output = [12,1,3,0,0] \\nexpected [1,3,12,0,0] \\nCould somone give me a hint to easy fix my code ?"
                    },
                    {
                        "username": "JagodaDawidowska",
                        "content": "since my code triggered  Output Limit Exceeded error I post it as one step closer to correct answer\\nclass Solution {\\n       public void moveZeroes(int[] nums) {\\n        int idxJ = 0;\\n        int x = (nums.length - 1);\\n\\n        for (int i = 0; i < nums.length ; i++) {\\n            for (int j = 0; j < nums.length - 1; j++) {\\n                if (nums[j] == 0) {\\n                    int temp = nums[j + 1];\\n                    nums[j + 1] = nums[j];\\n                    nums[j] = temp;\\n                    idxJ++;\\n                    System.out.println(Arrays.toString(nums));\\n                }\\n            }\\n        }\\n    }\\n} I guess I cant use modyfied bubble sort :( "
                    },
                    {
                        "username": "romangolev",
                        "content": "I am interested why does list comprehension does not work for python solution.\\nAlso I cannot assign one list to another for some reason, simple operation like this `nums=nums1` returns nothing"
                    }
                ]
            },
            {
                "id": 2048065,
                "content": [
                    {
                        "username": "Akshat0706",
                        "content": "Remember QuickSort. Use two Pointers and swap non-zeros to left and zeros to right."
                    },
                    {
                        "username": "ASWINNATH123",
                        "content": "but tle is showing bruhh\\n"
                    },
                    {
                        "username": "kgjobsearch",
                        "content": "b=[0,1,0,3,12]\\nprint(list(a for a in b if a!= 0) + list(a for a in b if a == 0))"
                    },
                    {
                        "username": "azimBaldiwala",
                        "content": "You are making a new list here!!! QUESTION SAYS WE NEED TO MODIFY THE LIST , that is the purpose of the question .. else your solution is correct  "
                    },
                    {
                        "username": "pardhi1400",
                        "content": "it says keep the relative order does that mean not asending ? just the order the elements where in at the start?"
                    },
                    {
                        "username": "itsrishiydv",
                        "content": "Leetcode Python editor having some issue because below code is giving correct answer in local machine.\\n\\nclass Solution:\\n    def moveZeroes(self, nums: List[int]) -> None:\\n        \"\"\"\\n        Do not return anything, modify nums in-place instead.\\n        \"\"\"\\n        lis1=[]\\n        lis2=[]\\n        for i in nums:\\n            if i==0:\\n                lis2.append(i)\\n            if i!=0:\\n                lis1.append(i)\\n            \\n        return lis1+lis2"
                    },
                    {
                        "username": "aXXo",
                        "content": "you are supposed to modify in place. In your code you are creating two new lists"
                    },
                    {
                        "username": "aleazanrashid",
                        "content": " `class Solution:\\n    def moveZeroes(self, nums: List[int]) -> None:\\n        \"\"\"\\n        Do not return anything, modify nums in-place instead.\\n        \"\"\"\\n\\n        count = 0\\n        new = []\\n        \\n        for i in nums:\\n            if i == 0:\\n                count += 1\\n            else:\\n                new.append(i)\\n\\n        for i in range(count):\\n            new.append(0)\\n            \\n        return new`\\n\\n\\nmy solution works fine using pycharm but here i get wrong answer ?????"
                    },
                    {
                        "username": "aleazanrashid",
                        "content": "i came with new code, if you interested\n\n\ndef move_zer():\n\n    lis = [0,1,0,3,12]\n  \n    left, right = 0, len(lis) - 1\n\n    while left < right:\n\n        if lis[left] == 0 :\n            lis[left], lis[left + 1] = lis[left + 1], lis[left]\n\n        left += 1\n\n    return lis\n\nim tryng to solve this proplem with this code , it works fine but not when two zeros come next to each other , it move one of the zero to swap with next element but the another zero stays i need to come back to that zero and keep comparing or swapping any idea  ?\n"
                    },
                    {
                        "username": "aleazanrashid",
                        "content": "[@Siddharoodha10](/Siddharoodha10) ops\\n"
                    },
                    {
                        "username": "Siddharoodha10",
                        "content": "as per question u need to use nums list only. (its asking to modify nums in place only)"
                    },
                    {
                        "username": "CodeWizarder",
                        "content": "class Solution {\\n    public void moveZeroes(int[] nums) {\\n        ArrayList<Integer> ans = new ArrayList<>();\\n        solve(nums, ans, 0, 0);\\n        for(int i = 0; i < ans.size(); i++){\\n            nums[i] = ans.get(i);\\n        }\\n    }\\n\\n    public static void solve(int[] arr, ArrayList<Integer> ans, int index, int count){\\n        if(index == arr.length){\\n            for(int i = 0; i < count; i++){\\n                ans.add(0);\\n            }\\n            return;\\n        }\\n        if(arr[index] == 0){\\n            count++;\\n            solve(arr, ans, index + 1, count);\\n        }\\n        else{\\n            ans.add(arr[index]);\\n            solve(arr, ans, index + 1, count);\\n        }\\n    }\\n}"
                    },
                    {
                        "username": "mskamel",
                        "content": "Thanks for sharing your solution, it\\'s diverse from other ones here."
                    },
                    {
                        "username": "loyhongshenggg",
                        "content": "I\\'ve noticed that many people posted their answers here and thought perhaps, I could provide a hint!\\n\\nConsider having two pointers at the start of the array. Iterate through the array and swap between the pointers only when right pointer is non-zero, only after the swap, increment your left pointer (along with the right pointer). Otherwise, only increment your right pointer.\\n\\n(May not be the best solution out there, but feel free to comment and make changes)"
                    },
                    {
                        "username": "MariooY2",
                        "content": "var moveZeroes = function(nums) {\n    const len=nums.length;\n    let n=0;\n    for(let x=0;x<nums.length;x++){\n        if(nums[x]==0){\n            console.log(nums);\n            nums.splice(x,1);\n            x--;\n            n++;        \n        }\n    }\n    for(let x=nums.length;x<len;x++){\n        nums.push(0);\n    }\n\nreturn nums;\n\n}\neasy to understand javascript code"
                    },
                    {
                        "username": "JagodaDawidowska",
                        "content": "class Solution {\\n    public void moveZeroes(int[] nums) {\\n       int idxJ = 0;\\n        int x = (nums.length - 1);\\n\\n        for (int j = 0; j < nums.length - idxJ; j++) {\\n            if (nums[j] == 0) {\\n                int temp = nums[(x - idxJ)];\\n                nums[(x - idxJ)] = nums[j];\\n                nums[j] = temp;\\n                idxJ++;\\n            }\\n            System.out.println(Arrays.toString(nums));\\n        }      \\n    }\\n}\\nnums = [0,1,0,3,12] \\nmy output = [12,1,3,0,0] \\nexpected [1,3,12,0,0] \\nCould somone give me a hint to easy fix my code ?"
                    },
                    {
                        "username": "JagodaDawidowska",
                        "content": "since my code triggered  Output Limit Exceeded error I post it as one step closer to correct answer\\nclass Solution {\\n       public void moveZeroes(int[] nums) {\\n        int idxJ = 0;\\n        int x = (nums.length - 1);\\n\\n        for (int i = 0; i < nums.length ; i++) {\\n            for (int j = 0; j < nums.length - 1; j++) {\\n                if (nums[j] == 0) {\\n                    int temp = nums[j + 1];\\n                    nums[j + 1] = nums[j];\\n                    nums[j] = temp;\\n                    idxJ++;\\n                    System.out.println(Arrays.toString(nums));\\n                }\\n            }\\n        }\\n    }\\n} I guess I cant use modyfied bubble sort :( "
                    },
                    {
                        "username": "romangolev",
                        "content": "I am interested why does list comprehension does not work for python solution.\\nAlso I cannot assign one list to another for some reason, simple operation like this `nums=nums1` returns nothing"
                    }
                ]
            },
            {
                "id": 2045221,
                "content": [
                    {
                        "username": "romanlavandos",
                        "content": "I hate transfering the answer from PyCharm to LeetCode. List comprehensions are not working, but some modules like math are already imported? Cmon -_-"
                    },
                    {
                        "username": "buzterblaze0908",
                        "content": "I dont\\' know how to pass the Case 1 of this problem, The expected output is displayed to my IDE with the given input from Case 1. However, when I ran my code here in LeetCode, the output is the input as well, nothing changed"
                    },
                    {
                        "username": "msa23005_iiitl",
                        "content": "nums=list(filter(lambda n:n!=0,nums))+[0]*(nums.count(0))\\nthis is a correct code but leetcode is not accepting it please check also leetcode admins look into this\\n"
                    },
                    {
                        "username": "jenkunsen",
                        "content": "Hint: a while loop avoids much of the struggle behind modifying an array in place."
                    },
                    {
                        "username": "e-007",
                        "content": "Passing test case1 in vscode but not here in leetcode, why?\nclass Solution {\n    public void moveZeroes(int[] nums) {\n        int n=nums.length;\n         int[] brr = new int[n];\n        int[] crr = new int[n];\n        int bIndex = 0;\n        int cIndex = 0;\n\n    for (int i = 0; i < n; i++) {\n        if (nums[i] != 0) {\n            brr[bIndex++] = nums[i];\n        } else {\n            crr[cIndex++] = nums[i];\n        }\n    }\n\n    for (int i = 0; i < bIndex; i++) {\n        System.out.print(brr[i] + \" \");\n    }\n    for (int i = 0; i < cIndex; i++) {\n        System.out.print(crr[i] + \" \");\n    }\n    }\n} "
                    },
                    {
                        "username": "shakeebsecond2",
                        "content": "Only 64/75 test cases passing please debug my code\\n\\nclass Solution {\\npublic:\\n    void moveZeroes(vector<int>& nums) {\\n        int temp;\\n        for(int i =0;i<nums.size();i++)\\n        {\\n            for(int j=i;j<nums.size()-1;j++)\\n            {\\n                if(nums[j]==0 && nums[j] != nums[j+1]) \\n                {\\n                    swap(nums[j],nums[j+1]);\\n                }\\n                else if(nums[j]==nums[j+1]){\\n                     swap(nums[j],nums[j+1]);\\n                }\\n                \\n            }\\n           \\n        }\\n        //reverse(nums.begin(),nums.end())\\n        \\n\\n\\n    }\\n};"
                    },
                    {
                        "username": "Vanka_Siddhartha",
                        "content": "class Solution:\\n    def moveZeroes(self, nums: List[int]) -> None:\\n        non_zero_index =0\\n        zero_count =0\\n        for i in range(0,len(nums)):\\n            if(nums[i]!=0):\\n                nums[non_zero_index] = nums[i]\\n                non_zero_index +=1\\n\\n        for i in range(non_zero_index, len(nums)):\\n            nums[i] = 0\\n         "
                    },
                    {
                        "username": "dhvanigupta27",
                        "content": "My code is working on my IDE but not here. I\\'ve already double checked the function name and everything else. What can I do to resolve this issue?"
                    },
                    {
                        "username": "luanrodrigues51",
                        "content": "Are you following this rule? \"you must do this in-place without making a copy of the array.\" You need to modify nums in order to work. Only return the solution will not work. "
                    },
                    {
                        "username": "Yixiu_Hugh",
                        "content": "I don\\'t know what is wrong tih my code, can someone explain it to me?\\nclass Solution:\\n    def moveZeroes(self, nums: List[int]) -> None:\\n       length = len(nums)\\n       for i in range(length):\\n           if i == length:\\n                nums\\n           else:\\n                if nums[i] == 0:\\n                    del nums[i]\\n                    nums.append(0)"
                    },
                    {
                        "username": "Yixiu_Hugh",
                        "content": "Can someone help me with my code?\n\nclass Solution:\n    def moveZeroes(self, nums: List[int]) -> None:\n        length = len(nums)\n        for i in range(length):\n            if i == length:\n                nums\n            else:\n                if nums[i] == 0:\n                    del nums[i]\n                    nums.append(0)\n"
                    }
                ]
            },
            {
                "id": 2044948,
                "content": [
                    {
                        "username": "romanlavandos",
                        "content": "I hate transfering the answer from PyCharm to LeetCode. List comprehensions are not working, but some modules like math are already imported? Cmon -_-"
                    },
                    {
                        "username": "buzterblaze0908",
                        "content": "I dont\\' know how to pass the Case 1 of this problem, The expected output is displayed to my IDE with the given input from Case 1. However, when I ran my code here in LeetCode, the output is the input as well, nothing changed"
                    },
                    {
                        "username": "msa23005_iiitl",
                        "content": "nums=list(filter(lambda n:n!=0,nums))+[0]*(nums.count(0))\\nthis is a correct code but leetcode is not accepting it please check also leetcode admins look into this\\n"
                    },
                    {
                        "username": "jenkunsen",
                        "content": "Hint: a while loop avoids much of the struggle behind modifying an array in place."
                    },
                    {
                        "username": "e-007",
                        "content": "Passing test case1 in vscode but not here in leetcode, why?\nclass Solution {\n    public void moveZeroes(int[] nums) {\n        int n=nums.length;\n         int[] brr = new int[n];\n        int[] crr = new int[n];\n        int bIndex = 0;\n        int cIndex = 0;\n\n    for (int i = 0; i < n; i++) {\n        if (nums[i] != 0) {\n            brr[bIndex++] = nums[i];\n        } else {\n            crr[cIndex++] = nums[i];\n        }\n    }\n\n    for (int i = 0; i < bIndex; i++) {\n        System.out.print(brr[i] + \" \");\n    }\n    for (int i = 0; i < cIndex; i++) {\n        System.out.print(crr[i] + \" \");\n    }\n    }\n} "
                    },
                    {
                        "username": "shakeebsecond2",
                        "content": "Only 64/75 test cases passing please debug my code\\n\\nclass Solution {\\npublic:\\n    void moveZeroes(vector<int>& nums) {\\n        int temp;\\n        for(int i =0;i<nums.size();i++)\\n        {\\n            for(int j=i;j<nums.size()-1;j++)\\n            {\\n                if(nums[j]==0 && nums[j] != nums[j+1]) \\n                {\\n                    swap(nums[j],nums[j+1]);\\n                }\\n                else if(nums[j]==nums[j+1]){\\n                     swap(nums[j],nums[j+1]);\\n                }\\n                \\n            }\\n           \\n        }\\n        //reverse(nums.begin(),nums.end())\\n        \\n\\n\\n    }\\n};"
                    },
                    {
                        "username": "Vanka_Siddhartha",
                        "content": "class Solution:\\n    def moveZeroes(self, nums: List[int]) -> None:\\n        non_zero_index =0\\n        zero_count =0\\n        for i in range(0,len(nums)):\\n            if(nums[i]!=0):\\n                nums[non_zero_index] = nums[i]\\n                non_zero_index +=1\\n\\n        for i in range(non_zero_index, len(nums)):\\n            nums[i] = 0\\n         "
                    },
                    {
                        "username": "dhvanigupta27",
                        "content": "My code is working on my IDE but not here. I\\'ve already double checked the function name and everything else. What can I do to resolve this issue?"
                    },
                    {
                        "username": "luanrodrigues51",
                        "content": "Are you following this rule? \"you must do this in-place without making a copy of the array.\" You need to modify nums in order to work. Only return the solution will not work. "
                    },
                    {
                        "username": "Yixiu_Hugh",
                        "content": "I don\\'t know what is wrong tih my code, can someone explain it to me?\\nclass Solution:\\n    def moveZeroes(self, nums: List[int]) -> None:\\n       length = len(nums)\\n       for i in range(length):\\n           if i == length:\\n                nums\\n           else:\\n                if nums[i] == 0:\\n                    del nums[i]\\n                    nums.append(0)"
                    },
                    {
                        "username": "Yixiu_Hugh",
                        "content": "Can someone help me with my code?\n\nclass Solution:\n    def moveZeroes(self, nums: List[int]) -> None:\n        length = len(nums)\n        for i in range(length):\n            if i == length:\n                nums\n            else:\n                if nums[i] == 0:\n                    del nums[i]\n                    nums.append(0)\n"
                    }
                ]
            },
            {
                "id": 2042653,
                "content": [
                    {
                        "username": "romanlavandos",
                        "content": "I hate transfering the answer from PyCharm to LeetCode. List comprehensions are not working, but some modules like math are already imported? Cmon -_-"
                    },
                    {
                        "username": "buzterblaze0908",
                        "content": "I dont\\' know how to pass the Case 1 of this problem, The expected output is displayed to my IDE with the given input from Case 1. However, when I ran my code here in LeetCode, the output is the input as well, nothing changed"
                    },
                    {
                        "username": "msa23005_iiitl",
                        "content": "nums=list(filter(lambda n:n!=0,nums))+[0]*(nums.count(0))\\nthis is a correct code but leetcode is not accepting it please check also leetcode admins look into this\\n"
                    },
                    {
                        "username": "jenkunsen",
                        "content": "Hint: a while loop avoids much of the struggle behind modifying an array in place."
                    },
                    {
                        "username": "e-007",
                        "content": "Passing test case1 in vscode but not here in leetcode, why?\nclass Solution {\n    public void moveZeroes(int[] nums) {\n        int n=nums.length;\n         int[] brr = new int[n];\n        int[] crr = new int[n];\n        int bIndex = 0;\n        int cIndex = 0;\n\n    for (int i = 0; i < n; i++) {\n        if (nums[i] != 0) {\n            brr[bIndex++] = nums[i];\n        } else {\n            crr[cIndex++] = nums[i];\n        }\n    }\n\n    for (int i = 0; i < bIndex; i++) {\n        System.out.print(brr[i] + \" \");\n    }\n    for (int i = 0; i < cIndex; i++) {\n        System.out.print(crr[i] + \" \");\n    }\n    }\n} "
                    },
                    {
                        "username": "shakeebsecond2",
                        "content": "Only 64/75 test cases passing please debug my code\\n\\nclass Solution {\\npublic:\\n    void moveZeroes(vector<int>& nums) {\\n        int temp;\\n        for(int i =0;i<nums.size();i++)\\n        {\\n            for(int j=i;j<nums.size()-1;j++)\\n            {\\n                if(nums[j]==0 && nums[j] != nums[j+1]) \\n                {\\n                    swap(nums[j],nums[j+1]);\\n                }\\n                else if(nums[j]==nums[j+1]){\\n                     swap(nums[j],nums[j+1]);\\n                }\\n                \\n            }\\n           \\n        }\\n        //reverse(nums.begin(),nums.end())\\n        \\n\\n\\n    }\\n};"
                    },
                    {
                        "username": "Vanka_Siddhartha",
                        "content": "class Solution:\\n    def moveZeroes(self, nums: List[int]) -> None:\\n        non_zero_index =0\\n        zero_count =0\\n        for i in range(0,len(nums)):\\n            if(nums[i]!=0):\\n                nums[non_zero_index] = nums[i]\\n                non_zero_index +=1\\n\\n        for i in range(non_zero_index, len(nums)):\\n            nums[i] = 0\\n         "
                    },
                    {
                        "username": "dhvanigupta27",
                        "content": "My code is working on my IDE but not here. I\\'ve already double checked the function name and everything else. What can I do to resolve this issue?"
                    },
                    {
                        "username": "luanrodrigues51",
                        "content": "Are you following this rule? \"you must do this in-place without making a copy of the array.\" You need to modify nums in order to work. Only return the solution will not work. "
                    },
                    {
                        "username": "Yixiu_Hugh",
                        "content": "I don\\'t know what is wrong tih my code, can someone explain it to me?\\nclass Solution:\\n    def moveZeroes(self, nums: List[int]) -> None:\\n       length = len(nums)\\n       for i in range(length):\\n           if i == length:\\n                nums\\n           else:\\n                if nums[i] == 0:\\n                    del nums[i]\\n                    nums.append(0)"
                    },
                    {
                        "username": "Yixiu_Hugh",
                        "content": "Can someone help me with my code?\n\nclass Solution:\n    def moveZeroes(self, nums: List[int]) -> None:\n        length = len(nums)\n        for i in range(length):\n            if i == length:\n                nums\n            else:\n                if nums[i] == 0:\n                    del nums[i]\n                    nums.append(0)\n"
                    }
                ]
            },
            {
                "id": 2023954,
                "content": [
                    {
                        "username": "romanlavandos",
                        "content": "I hate transfering the answer from PyCharm to LeetCode. List comprehensions are not working, but some modules like math are already imported? Cmon -_-"
                    },
                    {
                        "username": "buzterblaze0908",
                        "content": "I dont\\' know how to pass the Case 1 of this problem, The expected output is displayed to my IDE with the given input from Case 1. However, when I ran my code here in LeetCode, the output is the input as well, nothing changed"
                    },
                    {
                        "username": "msa23005_iiitl",
                        "content": "nums=list(filter(lambda n:n!=0,nums))+[0]*(nums.count(0))\\nthis is a correct code but leetcode is not accepting it please check also leetcode admins look into this\\n"
                    },
                    {
                        "username": "jenkunsen",
                        "content": "Hint: a while loop avoids much of the struggle behind modifying an array in place."
                    },
                    {
                        "username": "e-007",
                        "content": "Passing test case1 in vscode but not here in leetcode, why?\nclass Solution {\n    public void moveZeroes(int[] nums) {\n        int n=nums.length;\n         int[] brr = new int[n];\n        int[] crr = new int[n];\n        int bIndex = 0;\n        int cIndex = 0;\n\n    for (int i = 0; i < n; i++) {\n        if (nums[i] != 0) {\n            brr[bIndex++] = nums[i];\n        } else {\n            crr[cIndex++] = nums[i];\n        }\n    }\n\n    for (int i = 0; i < bIndex; i++) {\n        System.out.print(brr[i] + \" \");\n    }\n    for (int i = 0; i < cIndex; i++) {\n        System.out.print(crr[i] + \" \");\n    }\n    }\n} "
                    },
                    {
                        "username": "shakeebsecond2",
                        "content": "Only 64/75 test cases passing please debug my code\\n\\nclass Solution {\\npublic:\\n    void moveZeroes(vector<int>& nums) {\\n        int temp;\\n        for(int i =0;i<nums.size();i++)\\n        {\\n            for(int j=i;j<nums.size()-1;j++)\\n            {\\n                if(nums[j]==0 && nums[j] != nums[j+1]) \\n                {\\n                    swap(nums[j],nums[j+1]);\\n                }\\n                else if(nums[j]==nums[j+1]){\\n                     swap(nums[j],nums[j+1]);\\n                }\\n                \\n            }\\n           \\n        }\\n        //reverse(nums.begin(),nums.end())\\n        \\n\\n\\n    }\\n};"
                    },
                    {
                        "username": "Vanka_Siddhartha",
                        "content": "class Solution:\\n    def moveZeroes(self, nums: List[int]) -> None:\\n        non_zero_index =0\\n        zero_count =0\\n        for i in range(0,len(nums)):\\n            if(nums[i]!=0):\\n                nums[non_zero_index] = nums[i]\\n                non_zero_index +=1\\n\\n        for i in range(non_zero_index, len(nums)):\\n            nums[i] = 0\\n         "
                    },
                    {
                        "username": "dhvanigupta27",
                        "content": "My code is working on my IDE but not here. I\\'ve already double checked the function name and everything else. What can I do to resolve this issue?"
                    },
                    {
                        "username": "luanrodrigues51",
                        "content": "Are you following this rule? \"you must do this in-place without making a copy of the array.\" You need to modify nums in order to work. Only return the solution will not work. "
                    },
                    {
                        "username": "Yixiu_Hugh",
                        "content": "I don\\'t know what is wrong tih my code, can someone explain it to me?\\nclass Solution:\\n    def moveZeroes(self, nums: List[int]) -> None:\\n       length = len(nums)\\n       for i in range(length):\\n           if i == length:\\n                nums\\n           else:\\n                if nums[i] == 0:\\n                    del nums[i]\\n                    nums.append(0)"
                    },
                    {
                        "username": "Yixiu_Hugh",
                        "content": "Can someone help me with my code?\n\nclass Solution:\n    def moveZeroes(self, nums: List[int]) -> None:\n        length = len(nums)\n        for i in range(length):\n            if i == length:\n                nums\n            else:\n                if nums[i] == 0:\n                    del nums[i]\n                    nums.append(0)\n"
                    }
                ]
            },
            {
                "id": 2020584,
                "content": [
                    {
                        "username": "romanlavandos",
                        "content": "I hate transfering the answer from PyCharm to LeetCode. List comprehensions are not working, but some modules like math are already imported? Cmon -_-"
                    },
                    {
                        "username": "buzterblaze0908",
                        "content": "I dont\\' know how to pass the Case 1 of this problem, The expected output is displayed to my IDE with the given input from Case 1. However, when I ran my code here in LeetCode, the output is the input as well, nothing changed"
                    },
                    {
                        "username": "msa23005_iiitl",
                        "content": "nums=list(filter(lambda n:n!=0,nums))+[0]*(nums.count(0))\\nthis is a correct code but leetcode is not accepting it please check also leetcode admins look into this\\n"
                    },
                    {
                        "username": "jenkunsen",
                        "content": "Hint: a while loop avoids much of the struggle behind modifying an array in place."
                    },
                    {
                        "username": "e-007",
                        "content": "Passing test case1 in vscode but not here in leetcode, why?\nclass Solution {\n    public void moveZeroes(int[] nums) {\n        int n=nums.length;\n         int[] brr = new int[n];\n        int[] crr = new int[n];\n        int bIndex = 0;\n        int cIndex = 0;\n\n    for (int i = 0; i < n; i++) {\n        if (nums[i] != 0) {\n            brr[bIndex++] = nums[i];\n        } else {\n            crr[cIndex++] = nums[i];\n        }\n    }\n\n    for (int i = 0; i < bIndex; i++) {\n        System.out.print(brr[i] + \" \");\n    }\n    for (int i = 0; i < cIndex; i++) {\n        System.out.print(crr[i] + \" \");\n    }\n    }\n} "
                    },
                    {
                        "username": "shakeebsecond2",
                        "content": "Only 64/75 test cases passing please debug my code\\n\\nclass Solution {\\npublic:\\n    void moveZeroes(vector<int>& nums) {\\n        int temp;\\n        for(int i =0;i<nums.size();i++)\\n        {\\n            for(int j=i;j<nums.size()-1;j++)\\n            {\\n                if(nums[j]==0 && nums[j] != nums[j+1]) \\n                {\\n                    swap(nums[j],nums[j+1]);\\n                }\\n                else if(nums[j]==nums[j+1]){\\n                     swap(nums[j],nums[j+1]);\\n                }\\n                \\n            }\\n           \\n        }\\n        //reverse(nums.begin(),nums.end())\\n        \\n\\n\\n    }\\n};"
                    },
                    {
                        "username": "Vanka_Siddhartha",
                        "content": "class Solution:\\n    def moveZeroes(self, nums: List[int]) -> None:\\n        non_zero_index =0\\n        zero_count =0\\n        for i in range(0,len(nums)):\\n            if(nums[i]!=0):\\n                nums[non_zero_index] = nums[i]\\n                non_zero_index +=1\\n\\n        for i in range(non_zero_index, len(nums)):\\n            nums[i] = 0\\n         "
                    },
                    {
                        "username": "dhvanigupta27",
                        "content": "My code is working on my IDE but not here. I\\'ve already double checked the function name and everything else. What can I do to resolve this issue?"
                    },
                    {
                        "username": "luanrodrigues51",
                        "content": "Are you following this rule? \"you must do this in-place without making a copy of the array.\" You need to modify nums in order to work. Only return the solution will not work. "
                    },
                    {
                        "username": "Yixiu_Hugh",
                        "content": "I don\\'t know what is wrong tih my code, can someone explain it to me?\\nclass Solution:\\n    def moveZeroes(self, nums: List[int]) -> None:\\n       length = len(nums)\\n       for i in range(length):\\n           if i == length:\\n                nums\\n           else:\\n                if nums[i] == 0:\\n                    del nums[i]\\n                    nums.append(0)"
                    },
                    {
                        "username": "Yixiu_Hugh",
                        "content": "Can someone help me with my code?\n\nclass Solution:\n    def moveZeroes(self, nums: List[int]) -> None:\n        length = len(nums)\n        for i in range(length):\n            if i == length:\n                nums\n            else:\n                if nums[i] == 0:\n                    del nums[i]\n                    nums.append(0)\n"
                    }
                ]
            },
            {
                "id": 2019919,
                "content": [
                    {
                        "username": "romanlavandos",
                        "content": "I hate transfering the answer from PyCharm to LeetCode. List comprehensions are not working, but some modules like math are already imported? Cmon -_-"
                    },
                    {
                        "username": "buzterblaze0908",
                        "content": "I dont\\' know how to pass the Case 1 of this problem, The expected output is displayed to my IDE with the given input from Case 1. However, when I ran my code here in LeetCode, the output is the input as well, nothing changed"
                    },
                    {
                        "username": "msa23005_iiitl",
                        "content": "nums=list(filter(lambda n:n!=0,nums))+[0]*(nums.count(0))\\nthis is a correct code but leetcode is not accepting it please check also leetcode admins look into this\\n"
                    },
                    {
                        "username": "jenkunsen",
                        "content": "Hint: a while loop avoids much of the struggle behind modifying an array in place."
                    },
                    {
                        "username": "e-007",
                        "content": "Passing test case1 in vscode but not here in leetcode, why?\nclass Solution {\n    public void moveZeroes(int[] nums) {\n        int n=nums.length;\n         int[] brr = new int[n];\n        int[] crr = new int[n];\n        int bIndex = 0;\n        int cIndex = 0;\n\n    for (int i = 0; i < n; i++) {\n        if (nums[i] != 0) {\n            brr[bIndex++] = nums[i];\n        } else {\n            crr[cIndex++] = nums[i];\n        }\n    }\n\n    for (int i = 0; i < bIndex; i++) {\n        System.out.print(brr[i] + \" \");\n    }\n    for (int i = 0; i < cIndex; i++) {\n        System.out.print(crr[i] + \" \");\n    }\n    }\n} "
                    },
                    {
                        "username": "shakeebsecond2",
                        "content": "Only 64/75 test cases passing please debug my code\\n\\nclass Solution {\\npublic:\\n    void moveZeroes(vector<int>& nums) {\\n        int temp;\\n        for(int i =0;i<nums.size();i++)\\n        {\\n            for(int j=i;j<nums.size()-1;j++)\\n            {\\n                if(nums[j]==0 && nums[j] != nums[j+1]) \\n                {\\n                    swap(nums[j],nums[j+1]);\\n                }\\n                else if(nums[j]==nums[j+1]){\\n                     swap(nums[j],nums[j+1]);\\n                }\\n                \\n            }\\n           \\n        }\\n        //reverse(nums.begin(),nums.end())\\n        \\n\\n\\n    }\\n};"
                    },
                    {
                        "username": "Vanka_Siddhartha",
                        "content": "class Solution:\\n    def moveZeroes(self, nums: List[int]) -> None:\\n        non_zero_index =0\\n        zero_count =0\\n        for i in range(0,len(nums)):\\n            if(nums[i]!=0):\\n                nums[non_zero_index] = nums[i]\\n                non_zero_index +=1\\n\\n        for i in range(non_zero_index, len(nums)):\\n            nums[i] = 0\\n         "
                    },
                    {
                        "username": "dhvanigupta27",
                        "content": "My code is working on my IDE but not here. I\\'ve already double checked the function name and everything else. What can I do to resolve this issue?"
                    },
                    {
                        "username": "luanrodrigues51",
                        "content": "Are you following this rule? \"you must do this in-place without making a copy of the array.\" You need to modify nums in order to work. Only return the solution will not work. "
                    },
                    {
                        "username": "Yixiu_Hugh",
                        "content": "I don\\'t know what is wrong tih my code, can someone explain it to me?\\nclass Solution:\\n    def moveZeroes(self, nums: List[int]) -> None:\\n       length = len(nums)\\n       for i in range(length):\\n           if i == length:\\n                nums\\n           else:\\n                if nums[i] == 0:\\n                    del nums[i]\\n                    nums.append(0)"
                    },
                    {
                        "username": "Yixiu_Hugh",
                        "content": "Can someone help me with my code?\n\nclass Solution:\n    def moveZeroes(self, nums: List[int]) -> None:\n        length = len(nums)\n        for i in range(length):\n            if i == length:\n                nums\n            else:\n                if nums[i] == 0:\n                    del nums[i]\n                    nums.append(0)\n"
                    }
                ]
            },
            {
                "id": 2019539,
                "content": [
                    {
                        "username": "romanlavandos",
                        "content": "I hate transfering the answer from PyCharm to LeetCode. List comprehensions are not working, but some modules like math are already imported? Cmon -_-"
                    },
                    {
                        "username": "buzterblaze0908",
                        "content": "I dont\\' know how to pass the Case 1 of this problem, The expected output is displayed to my IDE with the given input from Case 1. However, when I ran my code here in LeetCode, the output is the input as well, nothing changed"
                    },
                    {
                        "username": "msa23005_iiitl",
                        "content": "nums=list(filter(lambda n:n!=0,nums))+[0]*(nums.count(0))\\nthis is a correct code but leetcode is not accepting it please check also leetcode admins look into this\\n"
                    },
                    {
                        "username": "jenkunsen",
                        "content": "Hint: a while loop avoids much of the struggle behind modifying an array in place."
                    },
                    {
                        "username": "e-007",
                        "content": "Passing test case1 in vscode but not here in leetcode, why?\nclass Solution {\n    public void moveZeroes(int[] nums) {\n        int n=nums.length;\n         int[] brr = new int[n];\n        int[] crr = new int[n];\n        int bIndex = 0;\n        int cIndex = 0;\n\n    for (int i = 0; i < n; i++) {\n        if (nums[i] != 0) {\n            brr[bIndex++] = nums[i];\n        } else {\n            crr[cIndex++] = nums[i];\n        }\n    }\n\n    for (int i = 0; i < bIndex; i++) {\n        System.out.print(brr[i] + \" \");\n    }\n    for (int i = 0; i < cIndex; i++) {\n        System.out.print(crr[i] + \" \");\n    }\n    }\n} "
                    },
                    {
                        "username": "shakeebsecond2",
                        "content": "Only 64/75 test cases passing please debug my code\\n\\nclass Solution {\\npublic:\\n    void moveZeroes(vector<int>& nums) {\\n        int temp;\\n        for(int i =0;i<nums.size();i++)\\n        {\\n            for(int j=i;j<nums.size()-1;j++)\\n            {\\n                if(nums[j]==0 && nums[j] != nums[j+1]) \\n                {\\n                    swap(nums[j],nums[j+1]);\\n                }\\n                else if(nums[j]==nums[j+1]){\\n                     swap(nums[j],nums[j+1]);\\n                }\\n                \\n            }\\n           \\n        }\\n        //reverse(nums.begin(),nums.end())\\n        \\n\\n\\n    }\\n};"
                    },
                    {
                        "username": "Vanka_Siddhartha",
                        "content": "class Solution:\\n    def moveZeroes(self, nums: List[int]) -> None:\\n        non_zero_index =0\\n        zero_count =0\\n        for i in range(0,len(nums)):\\n            if(nums[i]!=0):\\n                nums[non_zero_index] = nums[i]\\n                non_zero_index +=1\\n\\n        for i in range(non_zero_index, len(nums)):\\n            nums[i] = 0\\n         "
                    },
                    {
                        "username": "dhvanigupta27",
                        "content": "My code is working on my IDE but not here. I\\'ve already double checked the function name and everything else. What can I do to resolve this issue?"
                    },
                    {
                        "username": "luanrodrigues51",
                        "content": "Are you following this rule? \"you must do this in-place without making a copy of the array.\" You need to modify nums in order to work. Only return the solution will not work. "
                    },
                    {
                        "username": "Yixiu_Hugh",
                        "content": "I don\\'t know what is wrong tih my code, can someone explain it to me?\\nclass Solution:\\n    def moveZeroes(self, nums: List[int]) -> None:\\n       length = len(nums)\\n       for i in range(length):\\n           if i == length:\\n                nums\\n           else:\\n                if nums[i] == 0:\\n                    del nums[i]\\n                    nums.append(0)"
                    },
                    {
                        "username": "Yixiu_Hugh",
                        "content": "Can someone help me with my code?\n\nclass Solution:\n    def moveZeroes(self, nums: List[int]) -> None:\n        length = len(nums)\n        for i in range(length):\n            if i == length:\n                nums\n            else:\n                if nums[i] == 0:\n                    del nums[i]\n                    nums.append(0)\n"
                    }
                ]
            },
            {
                "id": 2016604,
                "content": [
                    {
                        "username": "romanlavandos",
                        "content": "I hate transfering the answer from PyCharm to LeetCode. List comprehensions are not working, but some modules like math are already imported? Cmon -_-"
                    },
                    {
                        "username": "buzterblaze0908",
                        "content": "I dont\\' know how to pass the Case 1 of this problem, The expected output is displayed to my IDE with the given input from Case 1. However, when I ran my code here in LeetCode, the output is the input as well, nothing changed"
                    },
                    {
                        "username": "msa23005_iiitl",
                        "content": "nums=list(filter(lambda n:n!=0,nums))+[0]*(nums.count(0))\\nthis is a correct code but leetcode is not accepting it please check also leetcode admins look into this\\n"
                    },
                    {
                        "username": "jenkunsen",
                        "content": "Hint: a while loop avoids much of the struggle behind modifying an array in place."
                    },
                    {
                        "username": "e-007",
                        "content": "Passing test case1 in vscode but not here in leetcode, why?\nclass Solution {\n    public void moveZeroes(int[] nums) {\n        int n=nums.length;\n         int[] brr = new int[n];\n        int[] crr = new int[n];\n        int bIndex = 0;\n        int cIndex = 0;\n\n    for (int i = 0; i < n; i++) {\n        if (nums[i] != 0) {\n            brr[bIndex++] = nums[i];\n        } else {\n            crr[cIndex++] = nums[i];\n        }\n    }\n\n    for (int i = 0; i < bIndex; i++) {\n        System.out.print(brr[i] + \" \");\n    }\n    for (int i = 0; i < cIndex; i++) {\n        System.out.print(crr[i] + \" \");\n    }\n    }\n} "
                    },
                    {
                        "username": "shakeebsecond2",
                        "content": "Only 64/75 test cases passing please debug my code\\n\\nclass Solution {\\npublic:\\n    void moveZeroes(vector<int>& nums) {\\n        int temp;\\n        for(int i =0;i<nums.size();i++)\\n        {\\n            for(int j=i;j<nums.size()-1;j++)\\n            {\\n                if(nums[j]==0 && nums[j] != nums[j+1]) \\n                {\\n                    swap(nums[j],nums[j+1]);\\n                }\\n                else if(nums[j]==nums[j+1]){\\n                     swap(nums[j],nums[j+1]);\\n                }\\n                \\n            }\\n           \\n        }\\n        //reverse(nums.begin(),nums.end())\\n        \\n\\n\\n    }\\n};"
                    },
                    {
                        "username": "Vanka_Siddhartha",
                        "content": "class Solution:\\n    def moveZeroes(self, nums: List[int]) -> None:\\n        non_zero_index =0\\n        zero_count =0\\n        for i in range(0,len(nums)):\\n            if(nums[i]!=0):\\n                nums[non_zero_index] = nums[i]\\n                non_zero_index +=1\\n\\n        for i in range(non_zero_index, len(nums)):\\n            nums[i] = 0\\n         "
                    },
                    {
                        "username": "dhvanigupta27",
                        "content": "My code is working on my IDE but not here. I\\'ve already double checked the function name and everything else. What can I do to resolve this issue?"
                    },
                    {
                        "username": "luanrodrigues51",
                        "content": "Are you following this rule? \"you must do this in-place without making a copy of the array.\" You need to modify nums in order to work. Only return the solution will not work. "
                    },
                    {
                        "username": "Yixiu_Hugh",
                        "content": "I don\\'t know what is wrong tih my code, can someone explain it to me?\\nclass Solution:\\n    def moveZeroes(self, nums: List[int]) -> None:\\n       length = len(nums)\\n       for i in range(length):\\n           if i == length:\\n                nums\\n           else:\\n                if nums[i] == 0:\\n                    del nums[i]\\n                    nums.append(0)"
                    },
                    {
                        "username": "Yixiu_Hugh",
                        "content": "Can someone help me with my code?\n\nclass Solution:\n    def moveZeroes(self, nums: List[int]) -> None:\n        length = len(nums)\n        for i in range(length):\n            if i == length:\n                nums\n            else:\n                if nums[i] == 0:\n                    del nums[i]\n                    nums.append(0)\n"
                    }
                ]
            },
            {
                "id": 2001894,
                "content": [
                    {
                        "username": "romanlavandos",
                        "content": "I hate transfering the answer from PyCharm to LeetCode. List comprehensions are not working, but some modules like math are already imported? Cmon -_-"
                    },
                    {
                        "username": "buzterblaze0908",
                        "content": "I dont\\' know how to pass the Case 1 of this problem, The expected output is displayed to my IDE with the given input from Case 1. However, when I ran my code here in LeetCode, the output is the input as well, nothing changed"
                    },
                    {
                        "username": "msa23005_iiitl",
                        "content": "nums=list(filter(lambda n:n!=0,nums))+[0]*(nums.count(0))\\nthis is a correct code but leetcode is not accepting it please check also leetcode admins look into this\\n"
                    },
                    {
                        "username": "jenkunsen",
                        "content": "Hint: a while loop avoids much of the struggle behind modifying an array in place."
                    },
                    {
                        "username": "e-007",
                        "content": "Passing test case1 in vscode but not here in leetcode, why?\nclass Solution {\n    public void moveZeroes(int[] nums) {\n        int n=nums.length;\n         int[] brr = new int[n];\n        int[] crr = new int[n];\n        int bIndex = 0;\n        int cIndex = 0;\n\n    for (int i = 0; i < n; i++) {\n        if (nums[i] != 0) {\n            brr[bIndex++] = nums[i];\n        } else {\n            crr[cIndex++] = nums[i];\n        }\n    }\n\n    for (int i = 0; i < bIndex; i++) {\n        System.out.print(brr[i] + \" \");\n    }\n    for (int i = 0; i < cIndex; i++) {\n        System.out.print(crr[i] + \" \");\n    }\n    }\n} "
                    },
                    {
                        "username": "shakeebsecond2",
                        "content": "Only 64/75 test cases passing please debug my code\\n\\nclass Solution {\\npublic:\\n    void moveZeroes(vector<int>& nums) {\\n        int temp;\\n        for(int i =0;i<nums.size();i++)\\n        {\\n            for(int j=i;j<nums.size()-1;j++)\\n            {\\n                if(nums[j]==0 && nums[j] != nums[j+1]) \\n                {\\n                    swap(nums[j],nums[j+1]);\\n                }\\n                else if(nums[j]==nums[j+1]){\\n                     swap(nums[j],nums[j+1]);\\n                }\\n                \\n            }\\n           \\n        }\\n        //reverse(nums.begin(),nums.end())\\n        \\n\\n\\n    }\\n};"
                    },
                    {
                        "username": "Vanka_Siddhartha",
                        "content": "class Solution:\\n    def moveZeroes(self, nums: List[int]) -> None:\\n        non_zero_index =0\\n        zero_count =0\\n        for i in range(0,len(nums)):\\n            if(nums[i]!=0):\\n                nums[non_zero_index] = nums[i]\\n                non_zero_index +=1\\n\\n        for i in range(non_zero_index, len(nums)):\\n            nums[i] = 0\\n         "
                    },
                    {
                        "username": "dhvanigupta27",
                        "content": "My code is working on my IDE but not here. I\\'ve already double checked the function name and everything else. What can I do to resolve this issue?"
                    },
                    {
                        "username": "luanrodrigues51",
                        "content": "Are you following this rule? \"you must do this in-place without making a copy of the array.\" You need to modify nums in order to work. Only return the solution will not work. "
                    },
                    {
                        "username": "Yixiu_Hugh",
                        "content": "I don\\'t know what is wrong tih my code, can someone explain it to me?\\nclass Solution:\\n    def moveZeroes(self, nums: List[int]) -> None:\\n       length = len(nums)\\n       for i in range(length):\\n           if i == length:\\n                nums\\n           else:\\n                if nums[i] == 0:\\n                    del nums[i]\\n                    nums.append(0)"
                    },
                    {
                        "username": "Yixiu_Hugh",
                        "content": "Can someone help me with my code?\n\nclass Solution:\n    def moveZeroes(self, nums: List[int]) -> None:\n        length = len(nums)\n        for i in range(length):\n            if i == length:\n                nums\n            else:\n                if nums[i] == 0:\n                    del nums[i]\n                    nums.append(0)\n"
                    }
                ]
            },
            {
                "id": 2000378,
                "content": [
                    {
                        "username": "romanlavandos",
                        "content": "I hate transfering the answer from PyCharm to LeetCode. List comprehensions are not working, but some modules like math are already imported? Cmon -_-"
                    },
                    {
                        "username": "buzterblaze0908",
                        "content": "I dont\\' know how to pass the Case 1 of this problem, The expected output is displayed to my IDE with the given input from Case 1. However, when I ran my code here in LeetCode, the output is the input as well, nothing changed"
                    },
                    {
                        "username": "msa23005_iiitl",
                        "content": "nums=list(filter(lambda n:n!=0,nums))+[0]*(nums.count(0))\\nthis is a correct code but leetcode is not accepting it please check also leetcode admins look into this\\n"
                    },
                    {
                        "username": "jenkunsen",
                        "content": "Hint: a while loop avoids much of the struggle behind modifying an array in place."
                    },
                    {
                        "username": "e-007",
                        "content": "Passing test case1 in vscode but not here in leetcode, why?\nclass Solution {\n    public void moveZeroes(int[] nums) {\n        int n=nums.length;\n         int[] brr = new int[n];\n        int[] crr = new int[n];\n        int bIndex = 0;\n        int cIndex = 0;\n\n    for (int i = 0; i < n; i++) {\n        if (nums[i] != 0) {\n            brr[bIndex++] = nums[i];\n        } else {\n            crr[cIndex++] = nums[i];\n        }\n    }\n\n    for (int i = 0; i < bIndex; i++) {\n        System.out.print(brr[i] + \" \");\n    }\n    for (int i = 0; i < cIndex; i++) {\n        System.out.print(crr[i] + \" \");\n    }\n    }\n} "
                    },
                    {
                        "username": "shakeebsecond2",
                        "content": "Only 64/75 test cases passing please debug my code\\n\\nclass Solution {\\npublic:\\n    void moveZeroes(vector<int>& nums) {\\n        int temp;\\n        for(int i =0;i<nums.size();i++)\\n        {\\n            for(int j=i;j<nums.size()-1;j++)\\n            {\\n                if(nums[j]==0 && nums[j] != nums[j+1]) \\n                {\\n                    swap(nums[j],nums[j+1]);\\n                }\\n                else if(nums[j]==nums[j+1]){\\n                     swap(nums[j],nums[j+1]);\\n                }\\n                \\n            }\\n           \\n        }\\n        //reverse(nums.begin(),nums.end())\\n        \\n\\n\\n    }\\n};"
                    },
                    {
                        "username": "Vanka_Siddhartha",
                        "content": "class Solution:\\n    def moveZeroes(self, nums: List[int]) -> None:\\n        non_zero_index =0\\n        zero_count =0\\n        for i in range(0,len(nums)):\\n            if(nums[i]!=0):\\n                nums[non_zero_index] = nums[i]\\n                non_zero_index +=1\\n\\n        for i in range(non_zero_index, len(nums)):\\n            nums[i] = 0\\n         "
                    },
                    {
                        "username": "dhvanigupta27",
                        "content": "My code is working on my IDE but not here. I\\'ve already double checked the function name and everything else. What can I do to resolve this issue?"
                    },
                    {
                        "username": "luanrodrigues51",
                        "content": "Are you following this rule? \"you must do this in-place without making a copy of the array.\" You need to modify nums in order to work. Only return the solution will not work. "
                    },
                    {
                        "username": "Yixiu_Hugh",
                        "content": "I don\\'t know what is wrong tih my code, can someone explain it to me?\\nclass Solution:\\n    def moveZeroes(self, nums: List[int]) -> None:\\n       length = len(nums)\\n       for i in range(length):\\n           if i == length:\\n                nums\\n           else:\\n                if nums[i] == 0:\\n                    del nums[i]\\n                    nums.append(0)"
                    },
                    {
                        "username": "Yixiu_Hugh",
                        "content": "Can someone help me with my code?\n\nclass Solution:\n    def moveZeroes(self, nums: List[int]) -> None:\n        length = len(nums)\n        for i in range(length):\n            if i == length:\n                nums\n            else:\n                if nums[i] == 0:\n                    del nums[i]\n                    nums.append(0)\n"
                    }
                ]
            },
            {
                "id": 1998805,
                "content": [
                    {
                        "username": "swapnilpurwar56",
                        "content": "What is wrong with this code? And what are the changes that I should do so that it run without error;\\n\\nCode-\\nclass Solution {\\npublic:\\n    void moveZeroes(vector<int>& nums) {\\n        int i=0, count=0;\\n        while(i<nums.size()){\\n            if(nums[i]==0){\\n                nums.erase(nums.begin()+i);\\n                count++;\\n                i=i-1;\\n            }\\n            else i++;\\n        }\\n        for(int i=0; i<count; i++) nums.push_back(0);\\n    }\\n};"
                    },
                    {
                        "username": "ozguner00",
                        "content": "Why 2 ms and %40 beats? i think unlucky testcase. Is it really bad code?\\n\\nclass Solution {\\n    public void moveZeroes(int[] nums) {\\n        int count = 0;\\n        for(int i = 0; i<nums.length-1; i++){\\n            if(nums[i] == 0){\\n                if(nums[i+1] != 0){\\n                    nums[i-count] = nums[i+1];\\n                    nums[i+1] = 0;\\n                }else count ++;\\n            }\\n        }\\n    }\\n}"
                    },
                    {
                        "username": "the_Steel",
                        "content": "class Solution {\\npublic:\\n    void moveZeroes(vector<int>& a) {\\n        int n=a.size();\\n        int j=-1;\\n        for(int i=0;i<n;i++){\\n            if(a[i]==0){\\n                j=i;\\n                break;\\n            }\\n        }\\n        for(int i=j+1;i<n;i++){\\n            if(a[i]!=0){\\n                swap(a[i],a[j]);\\n                j++;\\n            }\\n        }\\n        \\n    }\\n};\\n\\nanyone can help....\\nwhat is the error in this code , 1st 2 testcases are easily processed but cant able to submit this further."
                    },
                    {
                        "username": "akhacker0001",
                        "content": "class Solution {\\npublic:\\nvoid remove(std::vector<int>& v, size_t index) {\\n    v.erase(v.begin() + index);\\n}\\n    void moveZeroes(vector<int>& nums) {\\n      int count = 0;\\n      int arrLen = nums.size();\\n      for(int i = 0; i< arrLen; i++)\\n      if(nums[count] == 0){\\n        remove(nums,count);\\n        nums.push_back(0);\\n      }else{\\n        count++;\\n      }\\n    }\\n};\\n\\n\\n\\n\\ncheck this my bro \\n"
                    },
                    {
                        "username": "akhacker0001",
                        "content": "class Solution {\\n    public void moveZeroes(int[] nums) {\\n      int n=  nums.length;\\nint j=-1;\\nfor(int i=0;i<n;i++){\\nif(nums[i]==0){\\nj=i;\\nbreak;\\n}\\n}\\nfor(int i=j+1;i<n;i++){\\nif(nums[i]!=0){\\n  int swapEle = nums[i];\\n  nums[i] = nums[j];\\n  nums[j] = swapEle;\\nj++;\\n        \\n    }\\n}\\n    }\\n}\\n\\ncheck this the_Steel bro "
                    },
                    {
                        "username": "akhacker0001",
                        "content": "var moveZeroes = function(nums) {\\n    let len = nums.length;\\n    let count = 0\\n    for(let i = 0 ; i< len; i++){\\n      console.log(nums)\\n        if(nums[count] === 0){\\n            nums.splice(count,1)\\n            nums.push(0)\\n        }else{\\n          count++\\n        }\\n\\n    }\\n    \\n};\\n\\nhere is my code working perfectly when it faild last test case case no 74 it return the Output Limit Exceeded i dont know why"
                    },
                    {
                        "username": "saan146",
                        "content": "I do not understand why the IDE is not able to apprehend that my code is working fine,\\npublic void MoveZeroes(int[] nums)\\n        {\\n            List<int> numbers = nums.ToList<int>();\\n            for (int i = 0; i<numbers.Count; i++)\\n            {\\n                if(numbers[i] == 0)\\n                {\\n                    numbers.Remove(numbers[i]);\\n                    numbers.Add(0);\\n                }\\n            }\\n            int[] new_nums = numbers.ToArray();\\n            Console.WriteLine(\"[\"+string.Join(\",\", new_nums)+\"]\");\\n        }"
                    },
                    {
                        "username": "davidashish1996",
                        "content": "Why you are printing the brackets through console"
                    },
                    {
                        "username": "josephnanakofib",
                        "content": "Hey can I have some help? I posted this solution and it worked till the final use case which has nums as empty. Can't seem to figure out what's wrong:\n\n`\n\n        for i in range(len(nums)):\n            if nums[i] != 0:\n                curr = I\n                while ((curr - 1 >= 0) and (nums[curr - 1] == 0)):\n                    nums[curr],nums[curr - 1] = nums[curr - 1], nums[curr]\n                    curr -= 1\n`"
                    },
                    {
                        "username": "AMBER_FATIMA",
                        "content": "im getting tle for the last case by using bubble sort,help please?\\n"
                    },
                    {
                        "username": "davidashish1996",
                        "content": "[@AMBER_FATIMA](/AMBER_FATIMA)  Great "
                    },
                    {
                        "username": "AMBER_FATIMA",
                        "content": "[@davidashish1996](/davidashish1996) i solved the problem using 2 pointers thanks\\n\\n"
                    },
                    {
                        "username": "AMBER_FATIMA",
                        "content": "[@davidashish1996](/davidashish1996) i thought that way i could swap the 0s to the end without changing the sequence"
                    },
                    {
                        "username": "davidashish1996",
                        "content": "Why are you doing bubble sort you can just perform one comparison in O(n) time that will provide you the result."
                    },
                    {
                        "username": "a_andreasian",
                        "content": "both of my solutions this code didn\\'t approve. it literally wasn\\'t adding the zeros in the end and returning an error. whereas the same code ran perfectly in PyCharm and VScode.\\n"
                    },
                    {
                        "username": "eduard92",
                        "content": "I don\\'t feel this is easy if you do it in place without mumbo jumbo built-in functions"
                    },
                    {
                        "username": "davidashish1996",
                        "content": "In this case can\\'t we just traverse the array and make a comparison of non zero elements with zero\\'s and then swap it??"
                    },
                    {
                        "username": "davidashish1996",
                        "content": "[@aswinthalaa123123](/aswinthalaa123123) No one loop is sufficient for traversing and making the changes."
                    },
                    {
                        "username": "ASWINNATH123",
                        "content": "[@davidashish1996](/davidashish1996) means we have to use two for loop right?\\nand swap it "
                    },
                    {
                        "username": "davidashish1996",
                        "content": "[@aswinthalaa123123](/aswinthalaa123123) No Sorting this is basically using the 2 pointer concept if there are zeros continue increasing and if any nonzero is found swap with that all the nonzeros will come first and zeros will be placed at last"
                    },
                    {
                        "username": "ASWINNATH123",
                        "content": "what sort is this bro bubble or insertion\\n"
                    },
                    {
                        "username": "davidashish1996",
                        "content": "[@aswinthalaa123123](/aswinthalaa123123)  I have implemented using swapping and it\\'s working fine.   \\npublic void moveZeroes(int[] nums) {\\n        int n = nums.length;\\n        int i=0,j=0;\\n        while(j<n)\\n        {\\n            if(nums[j]==0)\\n            {\\n                j++;\\n            }\\n            else{\\n                int temp = nums[i];\\n                nums[i]=nums[j];\\n                nums[j]=temp;\\n                i++;\\n                j++;\\n            }\\n        }\\n      \\n    }"
                    },
                    {
                        "username": "ASWINNATH123",
                        "content": "tle error will show\\n"
                    }
                ]
            },
            {
                "id": 1975481,
                "content": [
                    {
                        "username": "swapnilpurwar56",
                        "content": "What is wrong with this code? And what are the changes that I should do so that it run without error;\\n\\nCode-\\nclass Solution {\\npublic:\\n    void moveZeroes(vector<int>& nums) {\\n        int i=0, count=0;\\n        while(i<nums.size()){\\n            if(nums[i]==0){\\n                nums.erase(nums.begin()+i);\\n                count++;\\n                i=i-1;\\n            }\\n            else i++;\\n        }\\n        for(int i=0; i<count; i++) nums.push_back(0);\\n    }\\n};"
                    },
                    {
                        "username": "ozguner00",
                        "content": "Why 2 ms and %40 beats? i think unlucky testcase. Is it really bad code?\\n\\nclass Solution {\\n    public void moveZeroes(int[] nums) {\\n        int count = 0;\\n        for(int i = 0; i<nums.length-1; i++){\\n            if(nums[i] == 0){\\n                if(nums[i+1] != 0){\\n                    nums[i-count] = nums[i+1];\\n                    nums[i+1] = 0;\\n                }else count ++;\\n            }\\n        }\\n    }\\n}"
                    },
                    {
                        "username": "the_Steel",
                        "content": "class Solution {\\npublic:\\n    void moveZeroes(vector<int>& a) {\\n        int n=a.size();\\n        int j=-1;\\n        for(int i=0;i<n;i++){\\n            if(a[i]==0){\\n                j=i;\\n                break;\\n            }\\n        }\\n        for(int i=j+1;i<n;i++){\\n            if(a[i]!=0){\\n                swap(a[i],a[j]);\\n                j++;\\n            }\\n        }\\n        \\n    }\\n};\\n\\nanyone can help....\\nwhat is the error in this code , 1st 2 testcases are easily processed but cant able to submit this further."
                    },
                    {
                        "username": "akhacker0001",
                        "content": "class Solution {\\npublic:\\nvoid remove(std::vector<int>& v, size_t index) {\\n    v.erase(v.begin() + index);\\n}\\n    void moveZeroes(vector<int>& nums) {\\n      int count = 0;\\n      int arrLen = nums.size();\\n      for(int i = 0; i< arrLen; i++)\\n      if(nums[count] == 0){\\n        remove(nums,count);\\n        nums.push_back(0);\\n      }else{\\n        count++;\\n      }\\n    }\\n};\\n\\n\\n\\n\\ncheck this my bro \\n"
                    },
                    {
                        "username": "akhacker0001",
                        "content": "class Solution {\\n    public void moveZeroes(int[] nums) {\\n      int n=  nums.length;\\nint j=-1;\\nfor(int i=0;i<n;i++){\\nif(nums[i]==0){\\nj=i;\\nbreak;\\n}\\n}\\nfor(int i=j+1;i<n;i++){\\nif(nums[i]!=0){\\n  int swapEle = nums[i];\\n  nums[i] = nums[j];\\n  nums[j] = swapEle;\\nj++;\\n        \\n    }\\n}\\n    }\\n}\\n\\ncheck this the_Steel bro "
                    },
                    {
                        "username": "akhacker0001",
                        "content": "var moveZeroes = function(nums) {\\n    let len = nums.length;\\n    let count = 0\\n    for(let i = 0 ; i< len; i++){\\n      console.log(nums)\\n        if(nums[count] === 0){\\n            nums.splice(count,1)\\n            nums.push(0)\\n        }else{\\n          count++\\n        }\\n\\n    }\\n    \\n};\\n\\nhere is my code working perfectly when it faild last test case case no 74 it return the Output Limit Exceeded i dont know why"
                    },
                    {
                        "username": "saan146",
                        "content": "I do not understand why the IDE is not able to apprehend that my code is working fine,\\npublic void MoveZeroes(int[] nums)\\n        {\\n            List<int> numbers = nums.ToList<int>();\\n            for (int i = 0; i<numbers.Count; i++)\\n            {\\n                if(numbers[i] == 0)\\n                {\\n                    numbers.Remove(numbers[i]);\\n                    numbers.Add(0);\\n                }\\n            }\\n            int[] new_nums = numbers.ToArray();\\n            Console.WriteLine(\"[\"+string.Join(\",\", new_nums)+\"]\");\\n        }"
                    },
                    {
                        "username": "davidashish1996",
                        "content": "Why you are printing the brackets through console"
                    },
                    {
                        "username": "josephnanakofib",
                        "content": "Hey can I have some help? I posted this solution and it worked till the final use case which has nums as empty. Can't seem to figure out what's wrong:\n\n`\n\n        for i in range(len(nums)):\n            if nums[i] != 0:\n                curr = I\n                while ((curr - 1 >= 0) and (nums[curr - 1] == 0)):\n                    nums[curr],nums[curr - 1] = nums[curr - 1], nums[curr]\n                    curr -= 1\n`"
                    },
                    {
                        "username": "AMBER_FATIMA",
                        "content": "im getting tle for the last case by using bubble sort,help please?\\n"
                    },
                    {
                        "username": "davidashish1996",
                        "content": "[@AMBER_FATIMA](/AMBER_FATIMA)  Great "
                    },
                    {
                        "username": "AMBER_FATIMA",
                        "content": "[@davidashish1996](/davidashish1996) i solved the problem using 2 pointers thanks\\n\\n"
                    },
                    {
                        "username": "AMBER_FATIMA",
                        "content": "[@davidashish1996](/davidashish1996) i thought that way i could swap the 0s to the end without changing the sequence"
                    },
                    {
                        "username": "davidashish1996",
                        "content": "Why are you doing bubble sort you can just perform one comparison in O(n) time that will provide you the result."
                    },
                    {
                        "username": "a_andreasian",
                        "content": "both of my solutions this code didn\\'t approve. it literally wasn\\'t adding the zeros in the end and returning an error. whereas the same code ran perfectly in PyCharm and VScode.\\n"
                    },
                    {
                        "username": "eduard92",
                        "content": "I don\\'t feel this is easy if you do it in place without mumbo jumbo built-in functions"
                    },
                    {
                        "username": "davidashish1996",
                        "content": "In this case can\\'t we just traverse the array and make a comparison of non zero elements with zero\\'s and then swap it??"
                    },
                    {
                        "username": "davidashish1996",
                        "content": "[@aswinthalaa123123](/aswinthalaa123123) No one loop is sufficient for traversing and making the changes."
                    },
                    {
                        "username": "ASWINNATH123",
                        "content": "[@davidashish1996](/davidashish1996) means we have to use two for loop right?\\nand swap it "
                    },
                    {
                        "username": "davidashish1996",
                        "content": "[@aswinthalaa123123](/aswinthalaa123123) No Sorting this is basically using the 2 pointer concept if there are zeros continue increasing and if any nonzero is found swap with that all the nonzeros will come first and zeros will be placed at last"
                    },
                    {
                        "username": "ASWINNATH123",
                        "content": "what sort is this bro bubble or insertion\\n"
                    },
                    {
                        "username": "davidashish1996",
                        "content": "[@aswinthalaa123123](/aswinthalaa123123)  I have implemented using swapping and it\\'s working fine.   \\npublic void moveZeroes(int[] nums) {\\n        int n = nums.length;\\n        int i=0,j=0;\\n        while(j<n)\\n        {\\n            if(nums[j]==0)\\n            {\\n                j++;\\n            }\\n            else{\\n                int temp = nums[i];\\n                nums[i]=nums[j];\\n                nums[j]=temp;\\n                i++;\\n                j++;\\n            }\\n        }\\n      \\n    }"
                    },
                    {
                        "username": "ASWINNATH123",
                        "content": "tle error will show\\n"
                    }
                ]
            },
            {
                "id": 1975234,
                "content": [
                    {
                        "username": "swapnilpurwar56",
                        "content": "What is wrong with this code? And what are the changes that I should do so that it run without error;\\n\\nCode-\\nclass Solution {\\npublic:\\n    void moveZeroes(vector<int>& nums) {\\n        int i=0, count=0;\\n        while(i<nums.size()){\\n            if(nums[i]==0){\\n                nums.erase(nums.begin()+i);\\n                count++;\\n                i=i-1;\\n            }\\n            else i++;\\n        }\\n        for(int i=0; i<count; i++) nums.push_back(0);\\n    }\\n};"
                    },
                    {
                        "username": "ozguner00",
                        "content": "Why 2 ms and %40 beats? i think unlucky testcase. Is it really bad code?\\n\\nclass Solution {\\n    public void moveZeroes(int[] nums) {\\n        int count = 0;\\n        for(int i = 0; i<nums.length-1; i++){\\n            if(nums[i] == 0){\\n                if(nums[i+1] != 0){\\n                    nums[i-count] = nums[i+1];\\n                    nums[i+1] = 0;\\n                }else count ++;\\n            }\\n        }\\n    }\\n}"
                    },
                    {
                        "username": "the_Steel",
                        "content": "class Solution {\\npublic:\\n    void moveZeroes(vector<int>& a) {\\n        int n=a.size();\\n        int j=-1;\\n        for(int i=0;i<n;i++){\\n            if(a[i]==0){\\n                j=i;\\n                break;\\n            }\\n        }\\n        for(int i=j+1;i<n;i++){\\n            if(a[i]!=0){\\n                swap(a[i],a[j]);\\n                j++;\\n            }\\n        }\\n        \\n    }\\n};\\n\\nanyone can help....\\nwhat is the error in this code , 1st 2 testcases are easily processed but cant able to submit this further."
                    },
                    {
                        "username": "akhacker0001",
                        "content": "class Solution {\\npublic:\\nvoid remove(std::vector<int>& v, size_t index) {\\n    v.erase(v.begin() + index);\\n}\\n    void moveZeroes(vector<int>& nums) {\\n      int count = 0;\\n      int arrLen = nums.size();\\n      for(int i = 0; i< arrLen; i++)\\n      if(nums[count] == 0){\\n        remove(nums,count);\\n        nums.push_back(0);\\n      }else{\\n        count++;\\n      }\\n    }\\n};\\n\\n\\n\\n\\ncheck this my bro \\n"
                    },
                    {
                        "username": "akhacker0001",
                        "content": "class Solution {\\n    public void moveZeroes(int[] nums) {\\n      int n=  nums.length;\\nint j=-1;\\nfor(int i=0;i<n;i++){\\nif(nums[i]==0){\\nj=i;\\nbreak;\\n}\\n}\\nfor(int i=j+1;i<n;i++){\\nif(nums[i]!=0){\\n  int swapEle = nums[i];\\n  nums[i] = nums[j];\\n  nums[j] = swapEle;\\nj++;\\n        \\n    }\\n}\\n    }\\n}\\n\\ncheck this the_Steel bro "
                    },
                    {
                        "username": "akhacker0001",
                        "content": "var moveZeroes = function(nums) {\\n    let len = nums.length;\\n    let count = 0\\n    for(let i = 0 ; i< len; i++){\\n      console.log(nums)\\n        if(nums[count] === 0){\\n            nums.splice(count,1)\\n            nums.push(0)\\n        }else{\\n          count++\\n        }\\n\\n    }\\n    \\n};\\n\\nhere is my code working perfectly when it faild last test case case no 74 it return the Output Limit Exceeded i dont know why"
                    },
                    {
                        "username": "saan146",
                        "content": "I do not understand why the IDE is not able to apprehend that my code is working fine,\\npublic void MoveZeroes(int[] nums)\\n        {\\n            List<int> numbers = nums.ToList<int>();\\n            for (int i = 0; i<numbers.Count; i++)\\n            {\\n                if(numbers[i] == 0)\\n                {\\n                    numbers.Remove(numbers[i]);\\n                    numbers.Add(0);\\n                }\\n            }\\n            int[] new_nums = numbers.ToArray();\\n            Console.WriteLine(\"[\"+string.Join(\",\", new_nums)+\"]\");\\n        }"
                    },
                    {
                        "username": "davidashish1996",
                        "content": "Why you are printing the brackets through console"
                    },
                    {
                        "username": "josephnanakofib",
                        "content": "Hey can I have some help? I posted this solution and it worked till the final use case which has nums as empty. Can't seem to figure out what's wrong:\n\n`\n\n        for i in range(len(nums)):\n            if nums[i] != 0:\n                curr = I\n                while ((curr - 1 >= 0) and (nums[curr - 1] == 0)):\n                    nums[curr],nums[curr - 1] = nums[curr - 1], nums[curr]\n                    curr -= 1\n`"
                    },
                    {
                        "username": "AMBER_FATIMA",
                        "content": "im getting tle for the last case by using bubble sort,help please?\\n"
                    },
                    {
                        "username": "davidashish1996",
                        "content": "[@AMBER_FATIMA](/AMBER_FATIMA)  Great "
                    },
                    {
                        "username": "AMBER_FATIMA",
                        "content": "[@davidashish1996](/davidashish1996) i solved the problem using 2 pointers thanks\\n\\n"
                    },
                    {
                        "username": "AMBER_FATIMA",
                        "content": "[@davidashish1996](/davidashish1996) i thought that way i could swap the 0s to the end without changing the sequence"
                    },
                    {
                        "username": "davidashish1996",
                        "content": "Why are you doing bubble sort you can just perform one comparison in O(n) time that will provide you the result."
                    },
                    {
                        "username": "a_andreasian",
                        "content": "both of my solutions this code didn\\'t approve. it literally wasn\\'t adding the zeros in the end and returning an error. whereas the same code ran perfectly in PyCharm and VScode.\\n"
                    },
                    {
                        "username": "eduard92",
                        "content": "I don\\'t feel this is easy if you do it in place without mumbo jumbo built-in functions"
                    },
                    {
                        "username": "davidashish1996",
                        "content": "In this case can\\'t we just traverse the array and make a comparison of non zero elements with zero\\'s and then swap it??"
                    },
                    {
                        "username": "davidashish1996",
                        "content": "[@aswinthalaa123123](/aswinthalaa123123) No one loop is sufficient for traversing and making the changes."
                    },
                    {
                        "username": "ASWINNATH123",
                        "content": "[@davidashish1996](/davidashish1996) means we have to use two for loop right?\\nand swap it "
                    },
                    {
                        "username": "davidashish1996",
                        "content": "[@aswinthalaa123123](/aswinthalaa123123) No Sorting this is basically using the 2 pointer concept if there are zeros continue increasing and if any nonzero is found swap with that all the nonzeros will come first and zeros will be placed at last"
                    },
                    {
                        "username": "ASWINNATH123",
                        "content": "what sort is this bro bubble or insertion\\n"
                    },
                    {
                        "username": "davidashish1996",
                        "content": "[@aswinthalaa123123](/aswinthalaa123123)  I have implemented using swapping and it\\'s working fine.   \\npublic void moveZeroes(int[] nums) {\\n        int n = nums.length;\\n        int i=0,j=0;\\n        while(j<n)\\n        {\\n            if(nums[j]==0)\\n            {\\n                j++;\\n            }\\n            else{\\n                int temp = nums[i];\\n                nums[i]=nums[j];\\n                nums[j]=temp;\\n                i++;\\n                j++;\\n            }\\n        }\\n      \\n    }"
                    },
                    {
                        "username": "ASWINNATH123",
                        "content": "tle error will show\\n"
                    }
                ]
            },
            {
                "id": 1973658,
                "content": [
                    {
                        "username": "swapnilpurwar56",
                        "content": "What is wrong with this code? And what are the changes that I should do so that it run without error;\\n\\nCode-\\nclass Solution {\\npublic:\\n    void moveZeroes(vector<int>& nums) {\\n        int i=0, count=0;\\n        while(i<nums.size()){\\n            if(nums[i]==0){\\n                nums.erase(nums.begin()+i);\\n                count++;\\n                i=i-1;\\n            }\\n            else i++;\\n        }\\n        for(int i=0; i<count; i++) nums.push_back(0);\\n    }\\n};"
                    },
                    {
                        "username": "ozguner00",
                        "content": "Why 2 ms and %40 beats? i think unlucky testcase. Is it really bad code?\\n\\nclass Solution {\\n    public void moveZeroes(int[] nums) {\\n        int count = 0;\\n        for(int i = 0; i<nums.length-1; i++){\\n            if(nums[i] == 0){\\n                if(nums[i+1] != 0){\\n                    nums[i-count] = nums[i+1];\\n                    nums[i+1] = 0;\\n                }else count ++;\\n            }\\n        }\\n    }\\n}"
                    },
                    {
                        "username": "the_Steel",
                        "content": "class Solution {\\npublic:\\n    void moveZeroes(vector<int>& a) {\\n        int n=a.size();\\n        int j=-1;\\n        for(int i=0;i<n;i++){\\n            if(a[i]==0){\\n                j=i;\\n                break;\\n            }\\n        }\\n        for(int i=j+1;i<n;i++){\\n            if(a[i]!=0){\\n                swap(a[i],a[j]);\\n                j++;\\n            }\\n        }\\n        \\n    }\\n};\\n\\nanyone can help....\\nwhat is the error in this code , 1st 2 testcases are easily processed but cant able to submit this further."
                    },
                    {
                        "username": "akhacker0001",
                        "content": "class Solution {\\npublic:\\nvoid remove(std::vector<int>& v, size_t index) {\\n    v.erase(v.begin() + index);\\n}\\n    void moveZeroes(vector<int>& nums) {\\n      int count = 0;\\n      int arrLen = nums.size();\\n      for(int i = 0; i< arrLen; i++)\\n      if(nums[count] == 0){\\n        remove(nums,count);\\n        nums.push_back(0);\\n      }else{\\n        count++;\\n      }\\n    }\\n};\\n\\n\\n\\n\\ncheck this my bro \\n"
                    },
                    {
                        "username": "akhacker0001",
                        "content": "class Solution {\\n    public void moveZeroes(int[] nums) {\\n      int n=  nums.length;\\nint j=-1;\\nfor(int i=0;i<n;i++){\\nif(nums[i]==0){\\nj=i;\\nbreak;\\n}\\n}\\nfor(int i=j+1;i<n;i++){\\nif(nums[i]!=0){\\n  int swapEle = nums[i];\\n  nums[i] = nums[j];\\n  nums[j] = swapEle;\\nj++;\\n        \\n    }\\n}\\n    }\\n}\\n\\ncheck this the_Steel bro "
                    },
                    {
                        "username": "akhacker0001",
                        "content": "var moveZeroes = function(nums) {\\n    let len = nums.length;\\n    let count = 0\\n    for(let i = 0 ; i< len; i++){\\n      console.log(nums)\\n        if(nums[count] === 0){\\n            nums.splice(count,1)\\n            nums.push(0)\\n        }else{\\n          count++\\n        }\\n\\n    }\\n    \\n};\\n\\nhere is my code working perfectly when it faild last test case case no 74 it return the Output Limit Exceeded i dont know why"
                    },
                    {
                        "username": "saan146",
                        "content": "I do not understand why the IDE is not able to apprehend that my code is working fine,\\npublic void MoveZeroes(int[] nums)\\n        {\\n            List<int> numbers = nums.ToList<int>();\\n            for (int i = 0; i<numbers.Count; i++)\\n            {\\n                if(numbers[i] == 0)\\n                {\\n                    numbers.Remove(numbers[i]);\\n                    numbers.Add(0);\\n                }\\n            }\\n            int[] new_nums = numbers.ToArray();\\n            Console.WriteLine(\"[\"+string.Join(\",\", new_nums)+\"]\");\\n        }"
                    },
                    {
                        "username": "davidashish1996",
                        "content": "Why you are printing the brackets through console"
                    },
                    {
                        "username": "josephnanakofib",
                        "content": "Hey can I have some help? I posted this solution and it worked till the final use case which has nums as empty. Can't seem to figure out what's wrong:\n\n`\n\n        for i in range(len(nums)):\n            if nums[i] != 0:\n                curr = I\n                while ((curr - 1 >= 0) and (nums[curr - 1] == 0)):\n                    nums[curr],nums[curr - 1] = nums[curr - 1], nums[curr]\n                    curr -= 1\n`"
                    },
                    {
                        "username": "AMBER_FATIMA",
                        "content": "im getting tle for the last case by using bubble sort,help please?\\n"
                    },
                    {
                        "username": "davidashish1996",
                        "content": "[@AMBER_FATIMA](/AMBER_FATIMA)  Great "
                    },
                    {
                        "username": "AMBER_FATIMA",
                        "content": "[@davidashish1996](/davidashish1996) i solved the problem using 2 pointers thanks\\n\\n"
                    },
                    {
                        "username": "AMBER_FATIMA",
                        "content": "[@davidashish1996](/davidashish1996) i thought that way i could swap the 0s to the end without changing the sequence"
                    },
                    {
                        "username": "davidashish1996",
                        "content": "Why are you doing bubble sort you can just perform one comparison in O(n) time that will provide you the result."
                    },
                    {
                        "username": "a_andreasian",
                        "content": "both of my solutions this code didn\\'t approve. it literally wasn\\'t adding the zeros in the end and returning an error. whereas the same code ran perfectly in PyCharm and VScode.\\n"
                    },
                    {
                        "username": "eduard92",
                        "content": "I don\\'t feel this is easy if you do it in place without mumbo jumbo built-in functions"
                    },
                    {
                        "username": "davidashish1996",
                        "content": "In this case can\\'t we just traverse the array and make a comparison of non zero elements with zero\\'s and then swap it??"
                    },
                    {
                        "username": "davidashish1996",
                        "content": "[@aswinthalaa123123](/aswinthalaa123123) No one loop is sufficient for traversing and making the changes."
                    },
                    {
                        "username": "ASWINNATH123",
                        "content": "[@davidashish1996](/davidashish1996) means we have to use two for loop right?\\nand swap it "
                    },
                    {
                        "username": "davidashish1996",
                        "content": "[@aswinthalaa123123](/aswinthalaa123123) No Sorting this is basically using the 2 pointer concept if there are zeros continue increasing and if any nonzero is found swap with that all the nonzeros will come first and zeros will be placed at last"
                    },
                    {
                        "username": "ASWINNATH123",
                        "content": "what sort is this bro bubble or insertion\\n"
                    },
                    {
                        "username": "davidashish1996",
                        "content": "[@aswinthalaa123123](/aswinthalaa123123)  I have implemented using swapping and it\\'s working fine.   \\npublic void moveZeroes(int[] nums) {\\n        int n = nums.length;\\n        int i=0,j=0;\\n        while(j<n)\\n        {\\n            if(nums[j]==0)\\n            {\\n                j++;\\n            }\\n            else{\\n                int temp = nums[i];\\n                nums[i]=nums[j];\\n                nums[j]=temp;\\n                i++;\\n                j++;\\n            }\\n        }\\n      \\n    }"
                    },
                    {
                        "username": "ASWINNATH123",
                        "content": "tle error will show\\n"
                    }
                ]
            },
            {
                "id": 1951272,
                "content": [
                    {
                        "username": "swapnilpurwar56",
                        "content": "What is wrong with this code? And what are the changes that I should do so that it run without error;\\n\\nCode-\\nclass Solution {\\npublic:\\n    void moveZeroes(vector<int>& nums) {\\n        int i=0, count=0;\\n        while(i<nums.size()){\\n            if(nums[i]==0){\\n                nums.erase(nums.begin()+i);\\n                count++;\\n                i=i-1;\\n            }\\n            else i++;\\n        }\\n        for(int i=0; i<count; i++) nums.push_back(0);\\n    }\\n};"
                    },
                    {
                        "username": "ozguner00",
                        "content": "Why 2 ms and %40 beats? i think unlucky testcase. Is it really bad code?\\n\\nclass Solution {\\n    public void moveZeroes(int[] nums) {\\n        int count = 0;\\n        for(int i = 0; i<nums.length-1; i++){\\n            if(nums[i] == 0){\\n                if(nums[i+1] != 0){\\n                    nums[i-count] = nums[i+1];\\n                    nums[i+1] = 0;\\n                }else count ++;\\n            }\\n        }\\n    }\\n}"
                    },
                    {
                        "username": "the_Steel",
                        "content": "class Solution {\\npublic:\\n    void moveZeroes(vector<int>& a) {\\n        int n=a.size();\\n        int j=-1;\\n        for(int i=0;i<n;i++){\\n            if(a[i]==0){\\n                j=i;\\n                break;\\n            }\\n        }\\n        for(int i=j+1;i<n;i++){\\n            if(a[i]!=0){\\n                swap(a[i],a[j]);\\n                j++;\\n            }\\n        }\\n        \\n    }\\n};\\n\\nanyone can help....\\nwhat is the error in this code , 1st 2 testcases are easily processed but cant able to submit this further."
                    },
                    {
                        "username": "akhacker0001",
                        "content": "class Solution {\\npublic:\\nvoid remove(std::vector<int>& v, size_t index) {\\n    v.erase(v.begin() + index);\\n}\\n    void moveZeroes(vector<int>& nums) {\\n      int count = 0;\\n      int arrLen = nums.size();\\n      for(int i = 0; i< arrLen; i++)\\n      if(nums[count] == 0){\\n        remove(nums,count);\\n        nums.push_back(0);\\n      }else{\\n        count++;\\n      }\\n    }\\n};\\n\\n\\n\\n\\ncheck this my bro \\n"
                    },
                    {
                        "username": "akhacker0001",
                        "content": "class Solution {\\n    public void moveZeroes(int[] nums) {\\n      int n=  nums.length;\\nint j=-1;\\nfor(int i=0;i<n;i++){\\nif(nums[i]==0){\\nj=i;\\nbreak;\\n}\\n}\\nfor(int i=j+1;i<n;i++){\\nif(nums[i]!=0){\\n  int swapEle = nums[i];\\n  nums[i] = nums[j];\\n  nums[j] = swapEle;\\nj++;\\n        \\n    }\\n}\\n    }\\n}\\n\\ncheck this the_Steel bro "
                    },
                    {
                        "username": "akhacker0001",
                        "content": "var moveZeroes = function(nums) {\\n    let len = nums.length;\\n    let count = 0\\n    for(let i = 0 ; i< len; i++){\\n      console.log(nums)\\n        if(nums[count] === 0){\\n            nums.splice(count,1)\\n            nums.push(0)\\n        }else{\\n          count++\\n        }\\n\\n    }\\n    \\n};\\n\\nhere is my code working perfectly when it faild last test case case no 74 it return the Output Limit Exceeded i dont know why"
                    },
                    {
                        "username": "saan146",
                        "content": "I do not understand why the IDE is not able to apprehend that my code is working fine,\\npublic void MoveZeroes(int[] nums)\\n        {\\n            List<int> numbers = nums.ToList<int>();\\n            for (int i = 0; i<numbers.Count; i++)\\n            {\\n                if(numbers[i] == 0)\\n                {\\n                    numbers.Remove(numbers[i]);\\n                    numbers.Add(0);\\n                }\\n            }\\n            int[] new_nums = numbers.ToArray();\\n            Console.WriteLine(\"[\"+string.Join(\",\", new_nums)+\"]\");\\n        }"
                    },
                    {
                        "username": "davidashish1996",
                        "content": "Why you are printing the brackets through console"
                    },
                    {
                        "username": "josephnanakofib",
                        "content": "Hey can I have some help? I posted this solution and it worked till the final use case which has nums as empty. Can't seem to figure out what's wrong:\n\n`\n\n        for i in range(len(nums)):\n            if nums[i] != 0:\n                curr = I\n                while ((curr - 1 >= 0) and (nums[curr - 1] == 0)):\n                    nums[curr],nums[curr - 1] = nums[curr - 1], nums[curr]\n                    curr -= 1\n`"
                    },
                    {
                        "username": "AMBER_FATIMA",
                        "content": "im getting tle for the last case by using bubble sort,help please?\\n"
                    },
                    {
                        "username": "davidashish1996",
                        "content": "[@AMBER_FATIMA](/AMBER_FATIMA)  Great "
                    },
                    {
                        "username": "AMBER_FATIMA",
                        "content": "[@davidashish1996](/davidashish1996) i solved the problem using 2 pointers thanks\\n\\n"
                    },
                    {
                        "username": "AMBER_FATIMA",
                        "content": "[@davidashish1996](/davidashish1996) i thought that way i could swap the 0s to the end without changing the sequence"
                    },
                    {
                        "username": "davidashish1996",
                        "content": "Why are you doing bubble sort you can just perform one comparison in O(n) time that will provide you the result."
                    },
                    {
                        "username": "a_andreasian",
                        "content": "both of my solutions this code didn\\'t approve. it literally wasn\\'t adding the zeros in the end and returning an error. whereas the same code ran perfectly in PyCharm and VScode.\\n"
                    },
                    {
                        "username": "eduard92",
                        "content": "I don\\'t feel this is easy if you do it in place without mumbo jumbo built-in functions"
                    },
                    {
                        "username": "davidashish1996",
                        "content": "In this case can\\'t we just traverse the array and make a comparison of non zero elements with zero\\'s and then swap it??"
                    },
                    {
                        "username": "davidashish1996",
                        "content": "[@aswinthalaa123123](/aswinthalaa123123) No one loop is sufficient for traversing and making the changes."
                    },
                    {
                        "username": "ASWINNATH123",
                        "content": "[@davidashish1996](/davidashish1996) means we have to use two for loop right?\\nand swap it "
                    },
                    {
                        "username": "davidashish1996",
                        "content": "[@aswinthalaa123123](/aswinthalaa123123) No Sorting this is basically using the 2 pointer concept if there are zeros continue increasing and if any nonzero is found swap with that all the nonzeros will come first and zeros will be placed at last"
                    },
                    {
                        "username": "ASWINNATH123",
                        "content": "what sort is this bro bubble or insertion\\n"
                    },
                    {
                        "username": "davidashish1996",
                        "content": "[@aswinthalaa123123](/aswinthalaa123123)  I have implemented using swapping and it\\'s working fine.   \\npublic void moveZeroes(int[] nums) {\\n        int n = nums.length;\\n        int i=0,j=0;\\n        while(j<n)\\n        {\\n            if(nums[j]==0)\\n            {\\n                j++;\\n            }\\n            else{\\n                int temp = nums[i];\\n                nums[i]=nums[j];\\n                nums[j]=temp;\\n                i++;\\n                j++;\\n            }\\n        }\\n      \\n    }"
                    },
                    {
                        "username": "ASWINNATH123",
                        "content": "tle error will show\\n"
                    }
                ]
            },
            {
                "id": 1949178,
                "content": [
                    {
                        "username": "swapnilpurwar56",
                        "content": "What is wrong with this code? And what are the changes that I should do so that it run without error;\\n\\nCode-\\nclass Solution {\\npublic:\\n    void moveZeroes(vector<int>& nums) {\\n        int i=0, count=0;\\n        while(i<nums.size()){\\n            if(nums[i]==0){\\n                nums.erase(nums.begin()+i);\\n                count++;\\n                i=i-1;\\n            }\\n            else i++;\\n        }\\n        for(int i=0; i<count; i++) nums.push_back(0);\\n    }\\n};"
                    },
                    {
                        "username": "ozguner00",
                        "content": "Why 2 ms and %40 beats? i think unlucky testcase. Is it really bad code?\\n\\nclass Solution {\\n    public void moveZeroes(int[] nums) {\\n        int count = 0;\\n        for(int i = 0; i<nums.length-1; i++){\\n            if(nums[i] == 0){\\n                if(nums[i+1] != 0){\\n                    nums[i-count] = nums[i+1];\\n                    nums[i+1] = 0;\\n                }else count ++;\\n            }\\n        }\\n    }\\n}"
                    },
                    {
                        "username": "the_Steel",
                        "content": "class Solution {\\npublic:\\n    void moveZeroes(vector<int>& a) {\\n        int n=a.size();\\n        int j=-1;\\n        for(int i=0;i<n;i++){\\n            if(a[i]==0){\\n                j=i;\\n                break;\\n            }\\n        }\\n        for(int i=j+1;i<n;i++){\\n            if(a[i]!=0){\\n                swap(a[i],a[j]);\\n                j++;\\n            }\\n        }\\n        \\n    }\\n};\\n\\nanyone can help....\\nwhat is the error in this code , 1st 2 testcases are easily processed but cant able to submit this further."
                    },
                    {
                        "username": "akhacker0001",
                        "content": "class Solution {\\npublic:\\nvoid remove(std::vector<int>& v, size_t index) {\\n    v.erase(v.begin() + index);\\n}\\n    void moveZeroes(vector<int>& nums) {\\n      int count = 0;\\n      int arrLen = nums.size();\\n      for(int i = 0; i< arrLen; i++)\\n      if(nums[count] == 0){\\n        remove(nums,count);\\n        nums.push_back(0);\\n      }else{\\n        count++;\\n      }\\n    }\\n};\\n\\n\\n\\n\\ncheck this my bro \\n"
                    },
                    {
                        "username": "akhacker0001",
                        "content": "class Solution {\\n    public void moveZeroes(int[] nums) {\\n      int n=  nums.length;\\nint j=-1;\\nfor(int i=0;i<n;i++){\\nif(nums[i]==0){\\nj=i;\\nbreak;\\n}\\n}\\nfor(int i=j+1;i<n;i++){\\nif(nums[i]!=0){\\n  int swapEle = nums[i];\\n  nums[i] = nums[j];\\n  nums[j] = swapEle;\\nj++;\\n        \\n    }\\n}\\n    }\\n}\\n\\ncheck this the_Steel bro "
                    },
                    {
                        "username": "akhacker0001",
                        "content": "var moveZeroes = function(nums) {\\n    let len = nums.length;\\n    let count = 0\\n    for(let i = 0 ; i< len; i++){\\n      console.log(nums)\\n        if(nums[count] === 0){\\n            nums.splice(count,1)\\n            nums.push(0)\\n        }else{\\n          count++\\n        }\\n\\n    }\\n    \\n};\\n\\nhere is my code working perfectly when it faild last test case case no 74 it return the Output Limit Exceeded i dont know why"
                    },
                    {
                        "username": "saan146",
                        "content": "I do not understand why the IDE is not able to apprehend that my code is working fine,\\npublic void MoveZeroes(int[] nums)\\n        {\\n            List<int> numbers = nums.ToList<int>();\\n            for (int i = 0; i<numbers.Count; i++)\\n            {\\n                if(numbers[i] == 0)\\n                {\\n                    numbers.Remove(numbers[i]);\\n                    numbers.Add(0);\\n                }\\n            }\\n            int[] new_nums = numbers.ToArray();\\n            Console.WriteLine(\"[\"+string.Join(\",\", new_nums)+\"]\");\\n        }"
                    },
                    {
                        "username": "davidashish1996",
                        "content": "Why you are printing the brackets through console"
                    },
                    {
                        "username": "josephnanakofib",
                        "content": "Hey can I have some help? I posted this solution and it worked till the final use case which has nums as empty. Can't seem to figure out what's wrong:\n\n`\n\n        for i in range(len(nums)):\n            if nums[i] != 0:\n                curr = I\n                while ((curr - 1 >= 0) and (nums[curr - 1] == 0)):\n                    nums[curr],nums[curr - 1] = nums[curr - 1], nums[curr]\n                    curr -= 1\n`"
                    },
                    {
                        "username": "AMBER_FATIMA",
                        "content": "im getting tle for the last case by using bubble sort,help please?\\n"
                    },
                    {
                        "username": "davidashish1996",
                        "content": "[@AMBER_FATIMA](/AMBER_FATIMA)  Great "
                    },
                    {
                        "username": "AMBER_FATIMA",
                        "content": "[@davidashish1996](/davidashish1996) i solved the problem using 2 pointers thanks\\n\\n"
                    },
                    {
                        "username": "AMBER_FATIMA",
                        "content": "[@davidashish1996](/davidashish1996) i thought that way i could swap the 0s to the end without changing the sequence"
                    },
                    {
                        "username": "davidashish1996",
                        "content": "Why are you doing bubble sort you can just perform one comparison in O(n) time that will provide you the result."
                    },
                    {
                        "username": "a_andreasian",
                        "content": "both of my solutions this code didn\\'t approve. it literally wasn\\'t adding the zeros in the end and returning an error. whereas the same code ran perfectly in PyCharm and VScode.\\n"
                    },
                    {
                        "username": "eduard92",
                        "content": "I don\\'t feel this is easy if you do it in place without mumbo jumbo built-in functions"
                    },
                    {
                        "username": "davidashish1996",
                        "content": "In this case can\\'t we just traverse the array and make a comparison of non zero elements with zero\\'s and then swap it??"
                    },
                    {
                        "username": "davidashish1996",
                        "content": "[@aswinthalaa123123](/aswinthalaa123123) No one loop is sufficient for traversing and making the changes."
                    },
                    {
                        "username": "ASWINNATH123",
                        "content": "[@davidashish1996](/davidashish1996) means we have to use two for loop right?\\nand swap it "
                    },
                    {
                        "username": "davidashish1996",
                        "content": "[@aswinthalaa123123](/aswinthalaa123123) No Sorting this is basically using the 2 pointer concept if there are zeros continue increasing and if any nonzero is found swap with that all the nonzeros will come first and zeros will be placed at last"
                    },
                    {
                        "username": "ASWINNATH123",
                        "content": "what sort is this bro bubble or insertion\\n"
                    },
                    {
                        "username": "davidashish1996",
                        "content": "[@aswinthalaa123123](/aswinthalaa123123)  I have implemented using swapping and it\\'s working fine.   \\npublic void moveZeroes(int[] nums) {\\n        int n = nums.length;\\n        int i=0,j=0;\\n        while(j<n)\\n        {\\n            if(nums[j]==0)\\n            {\\n                j++;\\n            }\\n            else{\\n                int temp = nums[i];\\n                nums[i]=nums[j];\\n                nums[j]=temp;\\n                i++;\\n                j++;\\n            }\\n        }\\n      \\n    }"
                    },
                    {
                        "username": "ASWINNATH123",
                        "content": "tle error will show\\n"
                    }
                ]
            },
            {
                "id": 1945320,
                "content": [
                    {
                        "username": "swapnilpurwar56",
                        "content": "What is wrong with this code? And what are the changes that I should do so that it run without error;\\n\\nCode-\\nclass Solution {\\npublic:\\n    void moveZeroes(vector<int>& nums) {\\n        int i=0, count=0;\\n        while(i<nums.size()){\\n            if(nums[i]==0){\\n                nums.erase(nums.begin()+i);\\n                count++;\\n                i=i-1;\\n            }\\n            else i++;\\n        }\\n        for(int i=0; i<count; i++) nums.push_back(0);\\n    }\\n};"
                    },
                    {
                        "username": "ozguner00",
                        "content": "Why 2 ms and %40 beats? i think unlucky testcase. Is it really bad code?\\n\\nclass Solution {\\n    public void moveZeroes(int[] nums) {\\n        int count = 0;\\n        for(int i = 0; i<nums.length-1; i++){\\n            if(nums[i] == 0){\\n                if(nums[i+1] != 0){\\n                    nums[i-count] = nums[i+1];\\n                    nums[i+1] = 0;\\n                }else count ++;\\n            }\\n        }\\n    }\\n}"
                    },
                    {
                        "username": "the_Steel",
                        "content": "class Solution {\\npublic:\\n    void moveZeroes(vector<int>& a) {\\n        int n=a.size();\\n        int j=-1;\\n        for(int i=0;i<n;i++){\\n            if(a[i]==0){\\n                j=i;\\n                break;\\n            }\\n        }\\n        for(int i=j+1;i<n;i++){\\n            if(a[i]!=0){\\n                swap(a[i],a[j]);\\n                j++;\\n            }\\n        }\\n        \\n    }\\n};\\n\\nanyone can help....\\nwhat is the error in this code , 1st 2 testcases are easily processed but cant able to submit this further."
                    },
                    {
                        "username": "akhacker0001",
                        "content": "class Solution {\\npublic:\\nvoid remove(std::vector<int>& v, size_t index) {\\n    v.erase(v.begin() + index);\\n}\\n    void moveZeroes(vector<int>& nums) {\\n      int count = 0;\\n      int arrLen = nums.size();\\n      for(int i = 0; i< arrLen; i++)\\n      if(nums[count] == 0){\\n        remove(nums,count);\\n        nums.push_back(0);\\n      }else{\\n        count++;\\n      }\\n    }\\n};\\n\\n\\n\\n\\ncheck this my bro \\n"
                    },
                    {
                        "username": "akhacker0001",
                        "content": "class Solution {\\n    public void moveZeroes(int[] nums) {\\n      int n=  nums.length;\\nint j=-1;\\nfor(int i=0;i<n;i++){\\nif(nums[i]==0){\\nj=i;\\nbreak;\\n}\\n}\\nfor(int i=j+1;i<n;i++){\\nif(nums[i]!=0){\\n  int swapEle = nums[i];\\n  nums[i] = nums[j];\\n  nums[j] = swapEle;\\nj++;\\n        \\n    }\\n}\\n    }\\n}\\n\\ncheck this the_Steel bro "
                    },
                    {
                        "username": "akhacker0001",
                        "content": "var moveZeroes = function(nums) {\\n    let len = nums.length;\\n    let count = 0\\n    for(let i = 0 ; i< len; i++){\\n      console.log(nums)\\n        if(nums[count] === 0){\\n            nums.splice(count,1)\\n            nums.push(0)\\n        }else{\\n          count++\\n        }\\n\\n    }\\n    \\n};\\n\\nhere is my code working perfectly when it faild last test case case no 74 it return the Output Limit Exceeded i dont know why"
                    },
                    {
                        "username": "saan146",
                        "content": "I do not understand why the IDE is not able to apprehend that my code is working fine,\\npublic void MoveZeroes(int[] nums)\\n        {\\n            List<int> numbers = nums.ToList<int>();\\n            for (int i = 0; i<numbers.Count; i++)\\n            {\\n                if(numbers[i] == 0)\\n                {\\n                    numbers.Remove(numbers[i]);\\n                    numbers.Add(0);\\n                }\\n            }\\n            int[] new_nums = numbers.ToArray();\\n            Console.WriteLine(\"[\"+string.Join(\",\", new_nums)+\"]\");\\n        }"
                    },
                    {
                        "username": "davidashish1996",
                        "content": "Why you are printing the brackets through console"
                    },
                    {
                        "username": "josephnanakofib",
                        "content": "Hey can I have some help? I posted this solution and it worked till the final use case which has nums as empty. Can't seem to figure out what's wrong:\n\n`\n\n        for i in range(len(nums)):\n            if nums[i] != 0:\n                curr = I\n                while ((curr - 1 >= 0) and (nums[curr - 1] == 0)):\n                    nums[curr],nums[curr - 1] = nums[curr - 1], nums[curr]\n                    curr -= 1\n`"
                    },
                    {
                        "username": "AMBER_FATIMA",
                        "content": "im getting tle for the last case by using bubble sort,help please?\\n"
                    },
                    {
                        "username": "davidashish1996",
                        "content": "[@AMBER_FATIMA](/AMBER_FATIMA)  Great "
                    },
                    {
                        "username": "AMBER_FATIMA",
                        "content": "[@davidashish1996](/davidashish1996) i solved the problem using 2 pointers thanks\\n\\n"
                    },
                    {
                        "username": "AMBER_FATIMA",
                        "content": "[@davidashish1996](/davidashish1996) i thought that way i could swap the 0s to the end without changing the sequence"
                    },
                    {
                        "username": "davidashish1996",
                        "content": "Why are you doing bubble sort you can just perform one comparison in O(n) time that will provide you the result."
                    },
                    {
                        "username": "a_andreasian",
                        "content": "both of my solutions this code didn\\'t approve. it literally wasn\\'t adding the zeros in the end and returning an error. whereas the same code ran perfectly in PyCharm and VScode.\\n"
                    },
                    {
                        "username": "eduard92",
                        "content": "I don\\'t feel this is easy if you do it in place without mumbo jumbo built-in functions"
                    },
                    {
                        "username": "davidashish1996",
                        "content": "In this case can\\'t we just traverse the array and make a comparison of non zero elements with zero\\'s and then swap it??"
                    },
                    {
                        "username": "davidashish1996",
                        "content": "[@aswinthalaa123123](/aswinthalaa123123) No one loop is sufficient for traversing and making the changes."
                    },
                    {
                        "username": "ASWINNATH123",
                        "content": "[@davidashish1996](/davidashish1996) means we have to use two for loop right?\\nand swap it "
                    },
                    {
                        "username": "davidashish1996",
                        "content": "[@aswinthalaa123123](/aswinthalaa123123) No Sorting this is basically using the 2 pointer concept if there are zeros continue increasing and if any nonzero is found swap with that all the nonzeros will come first and zeros will be placed at last"
                    },
                    {
                        "username": "ASWINNATH123",
                        "content": "what sort is this bro bubble or insertion\\n"
                    },
                    {
                        "username": "davidashish1996",
                        "content": "[@aswinthalaa123123](/aswinthalaa123123)  I have implemented using swapping and it\\'s working fine.   \\npublic void moveZeroes(int[] nums) {\\n        int n = nums.length;\\n        int i=0,j=0;\\n        while(j<n)\\n        {\\n            if(nums[j]==0)\\n            {\\n                j++;\\n            }\\n            else{\\n                int temp = nums[i];\\n                nums[i]=nums[j];\\n                nums[j]=temp;\\n                i++;\\n                j++;\\n            }\\n        }\\n      \\n    }"
                    },
                    {
                        "username": "ASWINNATH123",
                        "content": "tle error will show\\n"
                    }
                ]
            },
            {
                "id": 1945275,
                "content": [
                    {
                        "username": "swapnilpurwar56",
                        "content": "What is wrong with this code? And what are the changes that I should do so that it run without error;\\n\\nCode-\\nclass Solution {\\npublic:\\n    void moveZeroes(vector<int>& nums) {\\n        int i=0, count=0;\\n        while(i<nums.size()){\\n            if(nums[i]==0){\\n                nums.erase(nums.begin()+i);\\n                count++;\\n                i=i-1;\\n            }\\n            else i++;\\n        }\\n        for(int i=0; i<count; i++) nums.push_back(0);\\n    }\\n};"
                    },
                    {
                        "username": "ozguner00",
                        "content": "Why 2 ms and %40 beats? i think unlucky testcase. Is it really bad code?\\n\\nclass Solution {\\n    public void moveZeroes(int[] nums) {\\n        int count = 0;\\n        for(int i = 0; i<nums.length-1; i++){\\n            if(nums[i] == 0){\\n                if(nums[i+1] != 0){\\n                    nums[i-count] = nums[i+1];\\n                    nums[i+1] = 0;\\n                }else count ++;\\n            }\\n        }\\n    }\\n}"
                    },
                    {
                        "username": "the_Steel",
                        "content": "class Solution {\\npublic:\\n    void moveZeroes(vector<int>& a) {\\n        int n=a.size();\\n        int j=-1;\\n        for(int i=0;i<n;i++){\\n            if(a[i]==0){\\n                j=i;\\n                break;\\n            }\\n        }\\n        for(int i=j+1;i<n;i++){\\n            if(a[i]!=0){\\n                swap(a[i],a[j]);\\n                j++;\\n            }\\n        }\\n        \\n    }\\n};\\n\\nanyone can help....\\nwhat is the error in this code , 1st 2 testcases are easily processed but cant able to submit this further."
                    },
                    {
                        "username": "akhacker0001",
                        "content": "class Solution {\\npublic:\\nvoid remove(std::vector<int>& v, size_t index) {\\n    v.erase(v.begin() + index);\\n}\\n    void moveZeroes(vector<int>& nums) {\\n      int count = 0;\\n      int arrLen = nums.size();\\n      for(int i = 0; i< arrLen; i++)\\n      if(nums[count] == 0){\\n        remove(nums,count);\\n        nums.push_back(0);\\n      }else{\\n        count++;\\n      }\\n    }\\n};\\n\\n\\n\\n\\ncheck this my bro \\n"
                    },
                    {
                        "username": "akhacker0001",
                        "content": "class Solution {\\n    public void moveZeroes(int[] nums) {\\n      int n=  nums.length;\\nint j=-1;\\nfor(int i=0;i<n;i++){\\nif(nums[i]==0){\\nj=i;\\nbreak;\\n}\\n}\\nfor(int i=j+1;i<n;i++){\\nif(nums[i]!=0){\\n  int swapEle = nums[i];\\n  nums[i] = nums[j];\\n  nums[j] = swapEle;\\nj++;\\n        \\n    }\\n}\\n    }\\n}\\n\\ncheck this the_Steel bro "
                    },
                    {
                        "username": "akhacker0001",
                        "content": "var moveZeroes = function(nums) {\\n    let len = nums.length;\\n    let count = 0\\n    for(let i = 0 ; i< len; i++){\\n      console.log(nums)\\n        if(nums[count] === 0){\\n            nums.splice(count,1)\\n            nums.push(0)\\n        }else{\\n          count++\\n        }\\n\\n    }\\n    \\n};\\n\\nhere is my code working perfectly when it faild last test case case no 74 it return the Output Limit Exceeded i dont know why"
                    },
                    {
                        "username": "saan146",
                        "content": "I do not understand why the IDE is not able to apprehend that my code is working fine,\\npublic void MoveZeroes(int[] nums)\\n        {\\n            List<int> numbers = nums.ToList<int>();\\n            for (int i = 0; i<numbers.Count; i++)\\n            {\\n                if(numbers[i] == 0)\\n                {\\n                    numbers.Remove(numbers[i]);\\n                    numbers.Add(0);\\n                }\\n            }\\n            int[] new_nums = numbers.ToArray();\\n            Console.WriteLine(\"[\"+string.Join(\",\", new_nums)+\"]\");\\n        }"
                    },
                    {
                        "username": "davidashish1996",
                        "content": "Why you are printing the brackets through console"
                    },
                    {
                        "username": "josephnanakofib",
                        "content": "Hey can I have some help? I posted this solution and it worked till the final use case which has nums as empty. Can't seem to figure out what's wrong:\n\n`\n\n        for i in range(len(nums)):\n            if nums[i] != 0:\n                curr = I\n                while ((curr - 1 >= 0) and (nums[curr - 1] == 0)):\n                    nums[curr],nums[curr - 1] = nums[curr - 1], nums[curr]\n                    curr -= 1\n`"
                    },
                    {
                        "username": "AMBER_FATIMA",
                        "content": "im getting tle for the last case by using bubble sort,help please?\\n"
                    },
                    {
                        "username": "davidashish1996",
                        "content": "[@AMBER_FATIMA](/AMBER_FATIMA)  Great "
                    },
                    {
                        "username": "AMBER_FATIMA",
                        "content": "[@davidashish1996](/davidashish1996) i solved the problem using 2 pointers thanks\\n\\n"
                    },
                    {
                        "username": "AMBER_FATIMA",
                        "content": "[@davidashish1996](/davidashish1996) i thought that way i could swap the 0s to the end without changing the sequence"
                    },
                    {
                        "username": "davidashish1996",
                        "content": "Why are you doing bubble sort you can just perform one comparison in O(n) time that will provide you the result."
                    },
                    {
                        "username": "a_andreasian",
                        "content": "both of my solutions this code didn\\'t approve. it literally wasn\\'t adding the zeros in the end and returning an error. whereas the same code ran perfectly in PyCharm and VScode.\\n"
                    },
                    {
                        "username": "eduard92",
                        "content": "I don\\'t feel this is easy if you do it in place without mumbo jumbo built-in functions"
                    },
                    {
                        "username": "davidashish1996",
                        "content": "In this case can\\'t we just traverse the array and make a comparison of non zero elements with zero\\'s and then swap it??"
                    },
                    {
                        "username": "davidashish1996",
                        "content": "[@aswinthalaa123123](/aswinthalaa123123) No one loop is sufficient for traversing and making the changes."
                    },
                    {
                        "username": "ASWINNATH123",
                        "content": "[@davidashish1996](/davidashish1996) means we have to use two for loop right?\\nand swap it "
                    },
                    {
                        "username": "davidashish1996",
                        "content": "[@aswinthalaa123123](/aswinthalaa123123) No Sorting this is basically using the 2 pointer concept if there are zeros continue increasing and if any nonzero is found swap with that all the nonzeros will come first and zeros will be placed at last"
                    },
                    {
                        "username": "ASWINNATH123",
                        "content": "what sort is this bro bubble or insertion\\n"
                    },
                    {
                        "username": "davidashish1996",
                        "content": "[@aswinthalaa123123](/aswinthalaa123123)  I have implemented using swapping and it\\'s working fine.   \\npublic void moveZeroes(int[] nums) {\\n        int n = nums.length;\\n        int i=0,j=0;\\n        while(j<n)\\n        {\\n            if(nums[j]==0)\\n            {\\n                j++;\\n            }\\n            else{\\n                int temp = nums[i];\\n                nums[i]=nums[j];\\n                nums[j]=temp;\\n                i++;\\n                j++;\\n            }\\n        }\\n      \\n    }"
                    },
                    {
                        "username": "ASWINNATH123",
                        "content": "tle error will show\\n"
                    }
                ]
            },
            {
                "id": 1944209,
                "content": [
                    {
                        "username": "swapnilpurwar56",
                        "content": "What is wrong with this code? And what are the changes that I should do so that it run without error;\\n\\nCode-\\nclass Solution {\\npublic:\\n    void moveZeroes(vector<int>& nums) {\\n        int i=0, count=0;\\n        while(i<nums.size()){\\n            if(nums[i]==0){\\n                nums.erase(nums.begin()+i);\\n                count++;\\n                i=i-1;\\n            }\\n            else i++;\\n        }\\n        for(int i=0; i<count; i++) nums.push_back(0);\\n    }\\n};"
                    },
                    {
                        "username": "ozguner00",
                        "content": "Why 2 ms and %40 beats? i think unlucky testcase. Is it really bad code?\\n\\nclass Solution {\\n    public void moveZeroes(int[] nums) {\\n        int count = 0;\\n        for(int i = 0; i<nums.length-1; i++){\\n            if(nums[i] == 0){\\n                if(nums[i+1] != 0){\\n                    nums[i-count] = nums[i+1];\\n                    nums[i+1] = 0;\\n                }else count ++;\\n            }\\n        }\\n    }\\n}"
                    },
                    {
                        "username": "the_Steel",
                        "content": "class Solution {\\npublic:\\n    void moveZeroes(vector<int>& a) {\\n        int n=a.size();\\n        int j=-1;\\n        for(int i=0;i<n;i++){\\n            if(a[i]==0){\\n                j=i;\\n                break;\\n            }\\n        }\\n        for(int i=j+1;i<n;i++){\\n            if(a[i]!=0){\\n                swap(a[i],a[j]);\\n                j++;\\n            }\\n        }\\n        \\n    }\\n};\\n\\nanyone can help....\\nwhat is the error in this code , 1st 2 testcases are easily processed but cant able to submit this further."
                    },
                    {
                        "username": "akhacker0001",
                        "content": "class Solution {\\npublic:\\nvoid remove(std::vector<int>& v, size_t index) {\\n    v.erase(v.begin() + index);\\n}\\n    void moveZeroes(vector<int>& nums) {\\n      int count = 0;\\n      int arrLen = nums.size();\\n      for(int i = 0; i< arrLen; i++)\\n      if(nums[count] == 0){\\n        remove(nums,count);\\n        nums.push_back(0);\\n      }else{\\n        count++;\\n      }\\n    }\\n};\\n\\n\\n\\n\\ncheck this my bro \\n"
                    },
                    {
                        "username": "akhacker0001",
                        "content": "class Solution {\\n    public void moveZeroes(int[] nums) {\\n      int n=  nums.length;\\nint j=-1;\\nfor(int i=0;i<n;i++){\\nif(nums[i]==0){\\nj=i;\\nbreak;\\n}\\n}\\nfor(int i=j+1;i<n;i++){\\nif(nums[i]!=0){\\n  int swapEle = nums[i];\\n  nums[i] = nums[j];\\n  nums[j] = swapEle;\\nj++;\\n        \\n    }\\n}\\n    }\\n}\\n\\ncheck this the_Steel bro "
                    },
                    {
                        "username": "akhacker0001",
                        "content": "var moveZeroes = function(nums) {\\n    let len = nums.length;\\n    let count = 0\\n    for(let i = 0 ; i< len; i++){\\n      console.log(nums)\\n        if(nums[count] === 0){\\n            nums.splice(count,1)\\n            nums.push(0)\\n        }else{\\n          count++\\n        }\\n\\n    }\\n    \\n};\\n\\nhere is my code working perfectly when it faild last test case case no 74 it return the Output Limit Exceeded i dont know why"
                    },
                    {
                        "username": "saan146",
                        "content": "I do not understand why the IDE is not able to apprehend that my code is working fine,\\npublic void MoveZeroes(int[] nums)\\n        {\\n            List<int> numbers = nums.ToList<int>();\\n            for (int i = 0; i<numbers.Count; i++)\\n            {\\n                if(numbers[i] == 0)\\n                {\\n                    numbers.Remove(numbers[i]);\\n                    numbers.Add(0);\\n                }\\n            }\\n            int[] new_nums = numbers.ToArray();\\n            Console.WriteLine(\"[\"+string.Join(\",\", new_nums)+\"]\");\\n        }"
                    },
                    {
                        "username": "davidashish1996",
                        "content": "Why you are printing the brackets through console"
                    },
                    {
                        "username": "josephnanakofib",
                        "content": "Hey can I have some help? I posted this solution and it worked till the final use case which has nums as empty. Can't seem to figure out what's wrong:\n\n`\n\n        for i in range(len(nums)):\n            if nums[i] != 0:\n                curr = I\n                while ((curr - 1 >= 0) and (nums[curr - 1] == 0)):\n                    nums[curr],nums[curr - 1] = nums[curr - 1], nums[curr]\n                    curr -= 1\n`"
                    },
                    {
                        "username": "AMBER_FATIMA",
                        "content": "im getting tle for the last case by using bubble sort,help please?\\n"
                    },
                    {
                        "username": "davidashish1996",
                        "content": "[@AMBER_FATIMA](/AMBER_FATIMA)  Great "
                    },
                    {
                        "username": "AMBER_FATIMA",
                        "content": "[@davidashish1996](/davidashish1996) i solved the problem using 2 pointers thanks\\n\\n"
                    },
                    {
                        "username": "AMBER_FATIMA",
                        "content": "[@davidashish1996](/davidashish1996) i thought that way i could swap the 0s to the end without changing the sequence"
                    },
                    {
                        "username": "davidashish1996",
                        "content": "Why are you doing bubble sort you can just perform one comparison in O(n) time that will provide you the result."
                    },
                    {
                        "username": "a_andreasian",
                        "content": "both of my solutions this code didn\\'t approve. it literally wasn\\'t adding the zeros in the end and returning an error. whereas the same code ran perfectly in PyCharm and VScode.\\n"
                    },
                    {
                        "username": "eduard92",
                        "content": "I don\\'t feel this is easy if you do it in place without mumbo jumbo built-in functions"
                    },
                    {
                        "username": "davidashish1996",
                        "content": "In this case can\\'t we just traverse the array and make a comparison of non zero elements with zero\\'s and then swap it??"
                    },
                    {
                        "username": "davidashish1996",
                        "content": "[@aswinthalaa123123](/aswinthalaa123123) No one loop is sufficient for traversing and making the changes."
                    },
                    {
                        "username": "ASWINNATH123",
                        "content": "[@davidashish1996](/davidashish1996) means we have to use two for loop right?\\nand swap it "
                    },
                    {
                        "username": "davidashish1996",
                        "content": "[@aswinthalaa123123](/aswinthalaa123123) No Sorting this is basically using the 2 pointer concept if there are zeros continue increasing and if any nonzero is found swap with that all the nonzeros will come first and zeros will be placed at last"
                    },
                    {
                        "username": "ASWINNATH123",
                        "content": "what sort is this bro bubble or insertion\\n"
                    },
                    {
                        "username": "davidashish1996",
                        "content": "[@aswinthalaa123123](/aswinthalaa123123)  I have implemented using swapping and it\\'s working fine.   \\npublic void moveZeroes(int[] nums) {\\n        int n = nums.length;\\n        int i=0,j=0;\\n        while(j<n)\\n        {\\n            if(nums[j]==0)\\n            {\\n                j++;\\n            }\\n            else{\\n                int temp = nums[i];\\n                nums[i]=nums[j];\\n                nums[j]=temp;\\n                i++;\\n                j++;\\n            }\\n        }\\n      \\n    }"
                    },
                    {
                        "username": "ASWINNATH123",
                        "content": "tle error will show\\n"
                    }
                ]
            },
            {
                "id": 1914013,
                "content": [
                    {
                        "username": "swapnilpurwar56",
                        "content": "What is wrong with this code? And what are the changes that I should do so that it run without error;\\n\\nCode-\\nclass Solution {\\npublic:\\n    void moveZeroes(vector<int>& nums) {\\n        int i=0, count=0;\\n        while(i<nums.size()){\\n            if(nums[i]==0){\\n                nums.erase(nums.begin()+i);\\n                count++;\\n                i=i-1;\\n            }\\n            else i++;\\n        }\\n        for(int i=0; i<count; i++) nums.push_back(0);\\n    }\\n};"
                    },
                    {
                        "username": "ozguner00",
                        "content": "Why 2 ms and %40 beats? i think unlucky testcase. Is it really bad code?\\n\\nclass Solution {\\n    public void moveZeroes(int[] nums) {\\n        int count = 0;\\n        for(int i = 0; i<nums.length-1; i++){\\n            if(nums[i] == 0){\\n                if(nums[i+1] != 0){\\n                    nums[i-count] = nums[i+1];\\n                    nums[i+1] = 0;\\n                }else count ++;\\n            }\\n        }\\n    }\\n}"
                    },
                    {
                        "username": "the_Steel",
                        "content": "class Solution {\\npublic:\\n    void moveZeroes(vector<int>& a) {\\n        int n=a.size();\\n        int j=-1;\\n        for(int i=0;i<n;i++){\\n            if(a[i]==0){\\n                j=i;\\n                break;\\n            }\\n        }\\n        for(int i=j+1;i<n;i++){\\n            if(a[i]!=0){\\n                swap(a[i],a[j]);\\n                j++;\\n            }\\n        }\\n        \\n    }\\n};\\n\\nanyone can help....\\nwhat is the error in this code , 1st 2 testcases are easily processed but cant able to submit this further."
                    },
                    {
                        "username": "akhacker0001",
                        "content": "class Solution {\\npublic:\\nvoid remove(std::vector<int>& v, size_t index) {\\n    v.erase(v.begin() + index);\\n}\\n    void moveZeroes(vector<int>& nums) {\\n      int count = 0;\\n      int arrLen = nums.size();\\n      for(int i = 0; i< arrLen; i++)\\n      if(nums[count] == 0){\\n        remove(nums,count);\\n        nums.push_back(0);\\n      }else{\\n        count++;\\n      }\\n    }\\n};\\n\\n\\n\\n\\ncheck this my bro \\n"
                    },
                    {
                        "username": "akhacker0001",
                        "content": "class Solution {\\n    public void moveZeroes(int[] nums) {\\n      int n=  nums.length;\\nint j=-1;\\nfor(int i=0;i<n;i++){\\nif(nums[i]==0){\\nj=i;\\nbreak;\\n}\\n}\\nfor(int i=j+1;i<n;i++){\\nif(nums[i]!=0){\\n  int swapEle = nums[i];\\n  nums[i] = nums[j];\\n  nums[j] = swapEle;\\nj++;\\n        \\n    }\\n}\\n    }\\n}\\n\\ncheck this the_Steel bro "
                    },
                    {
                        "username": "akhacker0001",
                        "content": "var moveZeroes = function(nums) {\\n    let len = nums.length;\\n    let count = 0\\n    for(let i = 0 ; i< len; i++){\\n      console.log(nums)\\n        if(nums[count] === 0){\\n            nums.splice(count,1)\\n            nums.push(0)\\n        }else{\\n          count++\\n        }\\n\\n    }\\n    \\n};\\n\\nhere is my code working perfectly when it faild last test case case no 74 it return the Output Limit Exceeded i dont know why"
                    },
                    {
                        "username": "saan146",
                        "content": "I do not understand why the IDE is not able to apprehend that my code is working fine,\\npublic void MoveZeroes(int[] nums)\\n        {\\n            List<int> numbers = nums.ToList<int>();\\n            for (int i = 0; i<numbers.Count; i++)\\n            {\\n                if(numbers[i] == 0)\\n                {\\n                    numbers.Remove(numbers[i]);\\n                    numbers.Add(0);\\n                }\\n            }\\n            int[] new_nums = numbers.ToArray();\\n            Console.WriteLine(\"[\"+string.Join(\",\", new_nums)+\"]\");\\n        }"
                    },
                    {
                        "username": "davidashish1996",
                        "content": "Why you are printing the brackets through console"
                    },
                    {
                        "username": "josephnanakofib",
                        "content": "Hey can I have some help? I posted this solution and it worked till the final use case which has nums as empty. Can't seem to figure out what's wrong:\n\n`\n\n        for i in range(len(nums)):\n            if nums[i] != 0:\n                curr = I\n                while ((curr - 1 >= 0) and (nums[curr - 1] == 0)):\n                    nums[curr],nums[curr - 1] = nums[curr - 1], nums[curr]\n                    curr -= 1\n`"
                    },
                    {
                        "username": "AMBER_FATIMA",
                        "content": "im getting tle for the last case by using bubble sort,help please?\\n"
                    },
                    {
                        "username": "davidashish1996",
                        "content": "[@AMBER_FATIMA](/AMBER_FATIMA)  Great "
                    },
                    {
                        "username": "AMBER_FATIMA",
                        "content": "[@davidashish1996](/davidashish1996) i solved the problem using 2 pointers thanks\\n\\n"
                    },
                    {
                        "username": "AMBER_FATIMA",
                        "content": "[@davidashish1996](/davidashish1996) i thought that way i could swap the 0s to the end without changing the sequence"
                    },
                    {
                        "username": "davidashish1996",
                        "content": "Why are you doing bubble sort you can just perform one comparison in O(n) time that will provide you the result."
                    },
                    {
                        "username": "a_andreasian",
                        "content": "both of my solutions this code didn\\'t approve. it literally wasn\\'t adding the zeros in the end and returning an error. whereas the same code ran perfectly in PyCharm and VScode.\\n"
                    },
                    {
                        "username": "eduard92",
                        "content": "I don\\'t feel this is easy if you do it in place without mumbo jumbo built-in functions"
                    },
                    {
                        "username": "davidashish1996",
                        "content": "In this case can\\'t we just traverse the array and make a comparison of non zero elements with zero\\'s and then swap it??"
                    },
                    {
                        "username": "davidashish1996",
                        "content": "[@aswinthalaa123123](/aswinthalaa123123) No one loop is sufficient for traversing and making the changes."
                    },
                    {
                        "username": "ASWINNATH123",
                        "content": "[@davidashish1996](/davidashish1996) means we have to use two for loop right?\\nand swap it "
                    },
                    {
                        "username": "davidashish1996",
                        "content": "[@aswinthalaa123123](/aswinthalaa123123) No Sorting this is basically using the 2 pointer concept if there are zeros continue increasing and if any nonzero is found swap with that all the nonzeros will come first and zeros will be placed at last"
                    },
                    {
                        "username": "ASWINNATH123",
                        "content": "what sort is this bro bubble or insertion\\n"
                    },
                    {
                        "username": "davidashish1996",
                        "content": "[@aswinthalaa123123](/aswinthalaa123123)  I have implemented using swapping and it\\'s working fine.   \\npublic void moveZeroes(int[] nums) {\\n        int n = nums.length;\\n        int i=0,j=0;\\n        while(j<n)\\n        {\\n            if(nums[j]==0)\\n            {\\n                j++;\\n            }\\n            else{\\n                int temp = nums[i];\\n                nums[i]=nums[j];\\n                nums[j]=temp;\\n                i++;\\n                j++;\\n            }\\n        }\\n      \\n    }"
                    },
                    {
                        "username": "ASWINNATH123",
                        "content": "tle error will show\\n"
                    }
                ]
            },
            {
                "id": 1897617,
                "content": [
                    {
                        "username": "fgar13",
                        "content": "The constraints should be updated to include the fact that aside from the zeros, all the elements are already in ascending order. I spent too much time trying to implement what was essentially a sorting algorithm, not realizing that the array was essentially already sorted."
                    },
                    {
                        "username": "gabrielrosendo",
                        "content": "not all arrays are sorted"
                    },
                    {
                        "username": "zakmoulay07",
                        "content": "why ??? \n    public static void moveZeroes(int[] nums) {\n        int n = nums.length;\n        int l = 0, r = n - 1;\n        while (l < r) {\n            while (l < r && nums[r] == 0) {\n                r--;\n            }\n            while (l < r && nums[l] != 0) {\n                l++;\n            }\n\n            if (l < r)\n                swap(nums, l, r);\n        }\n    }\n\n    public static void swap(int[] nums, int a, int b) {\n        int temp = nums[a];\n        nums[a] = nums[b];\n        nums[b] = temp;\n    }\noutput 12,1,3,0,0    expected 1,3,12,0,0 "
                    },
                    {
                        "username": "garlapatipavan07",
                        "content": "//Simple c++ solution\\nvoid moveZeroes(vector<int>& nums) {\\n        int j = 0;\\n        for(int i = 0; i<nums.size(); i++){\\n            if(nums[i] != 0){\\n                swap(nums[i],nums[j]);\\n                j++;\\n            }\\n        }\\n    }"
                    },
                    {
                        "username": "Nitkapur30",
                        "content": "Hii Guys!! Check out my blog for the solution of this problem:\\nhttps://dsafordummies.digitalpress.blog/easy-array-leetcode-series-1/\\n\\nYou can also find two more easy level questions to test your skills in this particular blog! Thank you for supporting:)"
                    },
                    {
                        "username": "aleazanrashid",
                        "content": "im tryng to solve this proplem with this code below, it works fine but not when two zeros come next to each other , it move one of the zero to comapre with next element but the another zero stays i need to come back to that zero and keep comparing or swapping any idea guys ?\n\ndef move_zer():\n\n    lis = [0,1,0,3,12]\n        # [1,0,3,12,0]\n    left, right = 0, len(lis) - 1\n\n    while left < right:\n\n        if lis[left] ==0:\n            lis[left], lis[left + 1] = lis[left + 1], lis[left]\n\n        left += 1\n\n    return lis"
                    },
                    {
                        "username": "onigiricoco",
                        "content": "Could anyone tell me why this doesn\\'t work? \\n\\ndef move0(nums):\\n  return [i for i in nums if i!=0] +[j for j in nums if j==0]\\n\\nIt runs okay in my console , but returns [0,1,0,3,4] in leetcode"
                    },
                    {
                        "username": "pushkarsaxena96",
                        "content": "[@Siddharoodha10](/Siddharoodha10) Still does not work!"
                    },
                    {
                        "username": "Siddharoodha10",
                        "content": "I think it\\'s not expecting return . it needs to modify nums in-place only."
                    },
                    {
                        "username": "visva_123",
                        "content": "class Solution {\\npublic:\\n    void moveZeroes(vector<int>& nums) {\\n        \\n        vector<int>ans;\\n        int s =0;\\n        int n = nums.size();\\n        for(int i =0;i<n;i++){\\n            if(nums[i]!=0){\\n            swap(nums[i],nums[s++]);     \\n            }\\n           \\n\\n        }\\n         \\n    }\\n};"
                    },
                    {
                        "username": "arjun_50",
                        "content": "class Solution:\\n    def moveZeroes(self, nums: List[int]) -> None:\\n        d={}\\n        for item in nums:\\n            if (item in d):\\n                d[item] += 1\\n            else:\\n                d[item] = 1\\n  \\n        for j in range(d[0]):\\n            for i in range(len(nums)-1):\\n                if nums[i]==0:\\n                    nums[i],nums[i+1]=nums[i+1],nums[i]\\n    \\ncan anyone explain what exactly is wrong with this approach,pls\\nthis code is passing the testcases [0,1,0,3,12] and[0], but failing all other 70 cases\\n\\n\\n\\n"
                    },
                    {
                        "username": "Md_Hasan",
                        "content": "// Python easy solution in o(n)\\nclass Solution(object):\\n    def moveZeroes(self, nums):\\n        j=0\\n        for i in range(len(nums)):\\n            if(nums[i]!=0):\\n                nums[i],nums[j] = nums[j],nums[i]\\n                j+=1\\n\\n       return nums"
                    },
                    {
                        "username": "whovijaymaurya23",
                        "content": "As Some Test Case Can Contain the Negative number  also so we use the condition                 nums[i] !=0;\\n\\n\\nclass Solution {\\npublic:\\n    void moveZeroes(vector<int>& nums) {\\n       int k =0;\\n       for(int i=0; i<nums.size() ; i++)\\n       {\\n           if(nums[i]!=0){\\n        \\n        swap(nums[i],nums[k++]);\\n  \\n    }\\n       } \\n    }\\n};"
                    }
                ]
            },
            {
                "id": 1894371,
                "content": [
                    {
                        "username": "fgar13",
                        "content": "The constraints should be updated to include the fact that aside from the zeros, all the elements are already in ascending order. I spent too much time trying to implement what was essentially a sorting algorithm, not realizing that the array was essentially already sorted."
                    },
                    {
                        "username": "gabrielrosendo",
                        "content": "not all arrays are sorted"
                    },
                    {
                        "username": "zakmoulay07",
                        "content": "why ??? \n    public static void moveZeroes(int[] nums) {\n        int n = nums.length;\n        int l = 0, r = n - 1;\n        while (l < r) {\n            while (l < r && nums[r] == 0) {\n                r--;\n            }\n            while (l < r && nums[l] != 0) {\n                l++;\n            }\n\n            if (l < r)\n                swap(nums, l, r);\n        }\n    }\n\n    public static void swap(int[] nums, int a, int b) {\n        int temp = nums[a];\n        nums[a] = nums[b];\n        nums[b] = temp;\n    }\noutput 12,1,3,0,0    expected 1,3,12,0,0 "
                    },
                    {
                        "username": "garlapatipavan07",
                        "content": "//Simple c++ solution\\nvoid moveZeroes(vector<int>& nums) {\\n        int j = 0;\\n        for(int i = 0; i<nums.size(); i++){\\n            if(nums[i] != 0){\\n                swap(nums[i],nums[j]);\\n                j++;\\n            }\\n        }\\n    }"
                    },
                    {
                        "username": "Nitkapur30",
                        "content": "Hii Guys!! Check out my blog for the solution of this problem:\\nhttps://dsafordummies.digitalpress.blog/easy-array-leetcode-series-1/\\n\\nYou can also find two more easy level questions to test your skills in this particular blog! Thank you for supporting:)"
                    },
                    {
                        "username": "aleazanrashid",
                        "content": "im tryng to solve this proplem with this code below, it works fine but not when two zeros come next to each other , it move one of the zero to comapre with next element but the another zero stays i need to come back to that zero and keep comparing or swapping any idea guys ?\n\ndef move_zer():\n\n    lis = [0,1,0,3,12]\n        # [1,0,3,12,0]\n    left, right = 0, len(lis) - 1\n\n    while left < right:\n\n        if lis[left] ==0:\n            lis[left], lis[left + 1] = lis[left + 1], lis[left]\n\n        left += 1\n\n    return lis"
                    },
                    {
                        "username": "onigiricoco",
                        "content": "Could anyone tell me why this doesn\\'t work? \\n\\ndef move0(nums):\\n  return [i for i in nums if i!=0] +[j for j in nums if j==0]\\n\\nIt runs okay in my console , but returns [0,1,0,3,4] in leetcode"
                    },
                    {
                        "username": "pushkarsaxena96",
                        "content": "[@Siddharoodha10](/Siddharoodha10) Still does not work!"
                    },
                    {
                        "username": "Siddharoodha10",
                        "content": "I think it\\'s not expecting return . it needs to modify nums in-place only."
                    },
                    {
                        "username": "visva_123",
                        "content": "class Solution {\\npublic:\\n    void moveZeroes(vector<int>& nums) {\\n        \\n        vector<int>ans;\\n        int s =0;\\n        int n = nums.size();\\n        for(int i =0;i<n;i++){\\n            if(nums[i]!=0){\\n            swap(nums[i],nums[s++]);     \\n            }\\n           \\n\\n        }\\n         \\n    }\\n};"
                    },
                    {
                        "username": "arjun_50",
                        "content": "class Solution:\\n    def moveZeroes(self, nums: List[int]) -> None:\\n        d={}\\n        for item in nums:\\n            if (item in d):\\n                d[item] += 1\\n            else:\\n                d[item] = 1\\n  \\n        for j in range(d[0]):\\n            for i in range(len(nums)-1):\\n                if nums[i]==0:\\n                    nums[i],nums[i+1]=nums[i+1],nums[i]\\n    \\ncan anyone explain what exactly is wrong with this approach,pls\\nthis code is passing the testcases [0,1,0,3,12] and[0], but failing all other 70 cases\\n\\n\\n\\n"
                    },
                    {
                        "username": "Md_Hasan",
                        "content": "// Python easy solution in o(n)\\nclass Solution(object):\\n    def moveZeroes(self, nums):\\n        j=0\\n        for i in range(len(nums)):\\n            if(nums[i]!=0):\\n                nums[i],nums[j] = nums[j],nums[i]\\n                j+=1\\n\\n       return nums"
                    },
                    {
                        "username": "whovijaymaurya23",
                        "content": "As Some Test Case Can Contain the Negative number  also so we use the condition                 nums[i] !=0;\\n\\n\\nclass Solution {\\npublic:\\n    void moveZeroes(vector<int>& nums) {\\n       int k =0;\\n       for(int i=0; i<nums.size() ; i++)\\n       {\\n           if(nums[i]!=0){\\n        \\n        swap(nums[i],nums[k++]);\\n  \\n    }\\n       } \\n    }\\n};"
                    }
                ]
            },
            {
                "id": 1870161,
                "content": [
                    {
                        "username": "fgar13",
                        "content": "The constraints should be updated to include the fact that aside from the zeros, all the elements are already in ascending order. I spent too much time trying to implement what was essentially a sorting algorithm, not realizing that the array was essentially already sorted."
                    },
                    {
                        "username": "gabrielrosendo",
                        "content": "not all arrays are sorted"
                    },
                    {
                        "username": "zakmoulay07",
                        "content": "why ??? \n    public static void moveZeroes(int[] nums) {\n        int n = nums.length;\n        int l = 0, r = n - 1;\n        while (l < r) {\n            while (l < r && nums[r] == 0) {\n                r--;\n            }\n            while (l < r && nums[l] != 0) {\n                l++;\n            }\n\n            if (l < r)\n                swap(nums, l, r);\n        }\n    }\n\n    public static void swap(int[] nums, int a, int b) {\n        int temp = nums[a];\n        nums[a] = nums[b];\n        nums[b] = temp;\n    }\noutput 12,1,3,0,0    expected 1,3,12,0,0 "
                    },
                    {
                        "username": "garlapatipavan07",
                        "content": "//Simple c++ solution\\nvoid moveZeroes(vector<int>& nums) {\\n        int j = 0;\\n        for(int i = 0; i<nums.size(); i++){\\n            if(nums[i] != 0){\\n                swap(nums[i],nums[j]);\\n                j++;\\n            }\\n        }\\n    }"
                    },
                    {
                        "username": "Nitkapur30",
                        "content": "Hii Guys!! Check out my blog for the solution of this problem:\\nhttps://dsafordummies.digitalpress.blog/easy-array-leetcode-series-1/\\n\\nYou can also find two more easy level questions to test your skills in this particular blog! Thank you for supporting:)"
                    },
                    {
                        "username": "aleazanrashid",
                        "content": "im tryng to solve this proplem with this code below, it works fine but not when two zeros come next to each other , it move one of the zero to comapre with next element but the another zero stays i need to come back to that zero and keep comparing or swapping any idea guys ?\n\ndef move_zer():\n\n    lis = [0,1,0,3,12]\n        # [1,0,3,12,0]\n    left, right = 0, len(lis) - 1\n\n    while left < right:\n\n        if lis[left] ==0:\n            lis[left], lis[left + 1] = lis[left + 1], lis[left]\n\n        left += 1\n\n    return lis"
                    },
                    {
                        "username": "onigiricoco",
                        "content": "Could anyone tell me why this doesn\\'t work? \\n\\ndef move0(nums):\\n  return [i for i in nums if i!=0] +[j for j in nums if j==0]\\n\\nIt runs okay in my console , but returns [0,1,0,3,4] in leetcode"
                    },
                    {
                        "username": "pushkarsaxena96",
                        "content": "[@Siddharoodha10](/Siddharoodha10) Still does not work!"
                    },
                    {
                        "username": "Siddharoodha10",
                        "content": "I think it\\'s not expecting return . it needs to modify nums in-place only."
                    },
                    {
                        "username": "visva_123",
                        "content": "class Solution {\\npublic:\\n    void moveZeroes(vector<int>& nums) {\\n        \\n        vector<int>ans;\\n        int s =0;\\n        int n = nums.size();\\n        for(int i =0;i<n;i++){\\n            if(nums[i]!=0){\\n            swap(nums[i],nums[s++]);     \\n            }\\n           \\n\\n        }\\n         \\n    }\\n};"
                    },
                    {
                        "username": "arjun_50",
                        "content": "class Solution:\\n    def moveZeroes(self, nums: List[int]) -> None:\\n        d={}\\n        for item in nums:\\n            if (item in d):\\n                d[item] += 1\\n            else:\\n                d[item] = 1\\n  \\n        for j in range(d[0]):\\n            for i in range(len(nums)-1):\\n                if nums[i]==0:\\n                    nums[i],nums[i+1]=nums[i+1],nums[i]\\n    \\ncan anyone explain what exactly is wrong with this approach,pls\\nthis code is passing the testcases [0,1,0,3,12] and[0], but failing all other 70 cases\\n\\n\\n\\n"
                    },
                    {
                        "username": "Md_Hasan",
                        "content": "// Python easy solution in o(n)\\nclass Solution(object):\\n    def moveZeroes(self, nums):\\n        j=0\\n        for i in range(len(nums)):\\n            if(nums[i]!=0):\\n                nums[i],nums[j] = nums[j],nums[i]\\n                j+=1\\n\\n       return nums"
                    },
                    {
                        "username": "whovijaymaurya23",
                        "content": "As Some Test Case Can Contain the Negative number  also so we use the condition                 nums[i] !=0;\\n\\n\\nclass Solution {\\npublic:\\n    void moveZeroes(vector<int>& nums) {\\n       int k =0;\\n       for(int i=0; i<nums.size() ; i++)\\n       {\\n           if(nums[i]!=0){\\n        \\n        swap(nums[i],nums[k++]);\\n  \\n    }\\n       } \\n    }\\n};"
                    }
                ]
            },
            {
                "id": 1843266,
                "content": [
                    {
                        "username": "fgar13",
                        "content": "The constraints should be updated to include the fact that aside from the zeros, all the elements are already in ascending order. I spent too much time trying to implement what was essentially a sorting algorithm, not realizing that the array was essentially already sorted."
                    },
                    {
                        "username": "gabrielrosendo",
                        "content": "not all arrays are sorted"
                    },
                    {
                        "username": "zakmoulay07",
                        "content": "why ??? \n    public static void moveZeroes(int[] nums) {\n        int n = nums.length;\n        int l = 0, r = n - 1;\n        while (l < r) {\n            while (l < r && nums[r] == 0) {\n                r--;\n            }\n            while (l < r && nums[l] != 0) {\n                l++;\n            }\n\n            if (l < r)\n                swap(nums, l, r);\n        }\n    }\n\n    public static void swap(int[] nums, int a, int b) {\n        int temp = nums[a];\n        nums[a] = nums[b];\n        nums[b] = temp;\n    }\noutput 12,1,3,0,0    expected 1,3,12,0,0 "
                    },
                    {
                        "username": "garlapatipavan07",
                        "content": "//Simple c++ solution\\nvoid moveZeroes(vector<int>& nums) {\\n        int j = 0;\\n        for(int i = 0; i<nums.size(); i++){\\n            if(nums[i] != 0){\\n                swap(nums[i],nums[j]);\\n                j++;\\n            }\\n        }\\n    }"
                    },
                    {
                        "username": "Nitkapur30",
                        "content": "Hii Guys!! Check out my blog for the solution of this problem:\\nhttps://dsafordummies.digitalpress.blog/easy-array-leetcode-series-1/\\n\\nYou can also find two more easy level questions to test your skills in this particular blog! Thank you for supporting:)"
                    },
                    {
                        "username": "aleazanrashid",
                        "content": "im tryng to solve this proplem with this code below, it works fine but not when two zeros come next to each other , it move one of the zero to comapre with next element but the another zero stays i need to come back to that zero and keep comparing or swapping any idea guys ?\n\ndef move_zer():\n\n    lis = [0,1,0,3,12]\n        # [1,0,3,12,0]\n    left, right = 0, len(lis) - 1\n\n    while left < right:\n\n        if lis[left] ==0:\n            lis[left], lis[left + 1] = lis[left + 1], lis[left]\n\n        left += 1\n\n    return lis"
                    },
                    {
                        "username": "onigiricoco",
                        "content": "Could anyone tell me why this doesn\\'t work? \\n\\ndef move0(nums):\\n  return [i for i in nums if i!=0] +[j for j in nums if j==0]\\n\\nIt runs okay in my console , but returns [0,1,0,3,4] in leetcode"
                    },
                    {
                        "username": "pushkarsaxena96",
                        "content": "[@Siddharoodha10](/Siddharoodha10) Still does not work!"
                    },
                    {
                        "username": "Siddharoodha10",
                        "content": "I think it\\'s not expecting return . it needs to modify nums in-place only."
                    },
                    {
                        "username": "visva_123",
                        "content": "class Solution {\\npublic:\\n    void moveZeroes(vector<int>& nums) {\\n        \\n        vector<int>ans;\\n        int s =0;\\n        int n = nums.size();\\n        for(int i =0;i<n;i++){\\n            if(nums[i]!=0){\\n            swap(nums[i],nums[s++]);     \\n            }\\n           \\n\\n        }\\n         \\n    }\\n};"
                    },
                    {
                        "username": "arjun_50",
                        "content": "class Solution:\\n    def moveZeroes(self, nums: List[int]) -> None:\\n        d={}\\n        for item in nums:\\n            if (item in d):\\n                d[item] += 1\\n            else:\\n                d[item] = 1\\n  \\n        for j in range(d[0]):\\n            for i in range(len(nums)-1):\\n                if nums[i]==0:\\n                    nums[i],nums[i+1]=nums[i+1],nums[i]\\n    \\ncan anyone explain what exactly is wrong with this approach,pls\\nthis code is passing the testcases [0,1,0,3,12] and[0], but failing all other 70 cases\\n\\n\\n\\n"
                    },
                    {
                        "username": "Md_Hasan",
                        "content": "// Python easy solution in o(n)\\nclass Solution(object):\\n    def moveZeroes(self, nums):\\n        j=0\\n        for i in range(len(nums)):\\n            if(nums[i]!=0):\\n                nums[i],nums[j] = nums[j],nums[i]\\n                j+=1\\n\\n       return nums"
                    },
                    {
                        "username": "whovijaymaurya23",
                        "content": "As Some Test Case Can Contain the Negative number  also so we use the condition                 nums[i] !=0;\\n\\n\\nclass Solution {\\npublic:\\n    void moveZeroes(vector<int>& nums) {\\n       int k =0;\\n       for(int i=0; i<nums.size() ; i++)\\n       {\\n           if(nums[i]!=0){\\n        \\n        swap(nums[i],nums[k++]);\\n  \\n    }\\n       } \\n    }\\n};"
                    }
                ]
            },
            {
                "id": 1836625,
                "content": [
                    {
                        "username": "fgar13",
                        "content": "The constraints should be updated to include the fact that aside from the zeros, all the elements are already in ascending order. I spent too much time trying to implement what was essentially a sorting algorithm, not realizing that the array was essentially already sorted."
                    },
                    {
                        "username": "gabrielrosendo",
                        "content": "not all arrays are sorted"
                    },
                    {
                        "username": "zakmoulay07",
                        "content": "why ??? \n    public static void moveZeroes(int[] nums) {\n        int n = nums.length;\n        int l = 0, r = n - 1;\n        while (l < r) {\n            while (l < r && nums[r] == 0) {\n                r--;\n            }\n            while (l < r && nums[l] != 0) {\n                l++;\n            }\n\n            if (l < r)\n                swap(nums, l, r);\n        }\n    }\n\n    public static void swap(int[] nums, int a, int b) {\n        int temp = nums[a];\n        nums[a] = nums[b];\n        nums[b] = temp;\n    }\noutput 12,1,3,0,0    expected 1,3,12,0,0 "
                    },
                    {
                        "username": "garlapatipavan07",
                        "content": "//Simple c++ solution\\nvoid moveZeroes(vector<int>& nums) {\\n        int j = 0;\\n        for(int i = 0; i<nums.size(); i++){\\n            if(nums[i] != 0){\\n                swap(nums[i],nums[j]);\\n                j++;\\n            }\\n        }\\n    }"
                    },
                    {
                        "username": "Nitkapur30",
                        "content": "Hii Guys!! Check out my blog for the solution of this problem:\\nhttps://dsafordummies.digitalpress.blog/easy-array-leetcode-series-1/\\n\\nYou can also find two more easy level questions to test your skills in this particular blog! Thank you for supporting:)"
                    },
                    {
                        "username": "aleazanrashid",
                        "content": "im tryng to solve this proplem with this code below, it works fine but not when two zeros come next to each other , it move one of the zero to comapre with next element but the another zero stays i need to come back to that zero and keep comparing or swapping any idea guys ?\n\ndef move_zer():\n\n    lis = [0,1,0,3,12]\n        # [1,0,3,12,0]\n    left, right = 0, len(lis) - 1\n\n    while left < right:\n\n        if lis[left] ==0:\n            lis[left], lis[left + 1] = lis[left + 1], lis[left]\n\n        left += 1\n\n    return lis"
                    },
                    {
                        "username": "onigiricoco",
                        "content": "Could anyone tell me why this doesn\\'t work? \\n\\ndef move0(nums):\\n  return [i for i in nums if i!=0] +[j for j in nums if j==0]\\n\\nIt runs okay in my console , but returns [0,1,0,3,4] in leetcode"
                    },
                    {
                        "username": "pushkarsaxena96",
                        "content": "[@Siddharoodha10](/Siddharoodha10) Still does not work!"
                    },
                    {
                        "username": "Siddharoodha10",
                        "content": "I think it\\'s not expecting return . it needs to modify nums in-place only."
                    },
                    {
                        "username": "visva_123",
                        "content": "class Solution {\\npublic:\\n    void moveZeroes(vector<int>& nums) {\\n        \\n        vector<int>ans;\\n        int s =0;\\n        int n = nums.size();\\n        for(int i =0;i<n;i++){\\n            if(nums[i]!=0){\\n            swap(nums[i],nums[s++]);     \\n            }\\n           \\n\\n        }\\n         \\n    }\\n};"
                    },
                    {
                        "username": "arjun_50",
                        "content": "class Solution:\\n    def moveZeroes(self, nums: List[int]) -> None:\\n        d={}\\n        for item in nums:\\n            if (item in d):\\n                d[item] += 1\\n            else:\\n                d[item] = 1\\n  \\n        for j in range(d[0]):\\n            for i in range(len(nums)-1):\\n                if nums[i]==0:\\n                    nums[i],nums[i+1]=nums[i+1],nums[i]\\n    \\ncan anyone explain what exactly is wrong with this approach,pls\\nthis code is passing the testcases [0,1,0,3,12] and[0], but failing all other 70 cases\\n\\n\\n\\n"
                    },
                    {
                        "username": "Md_Hasan",
                        "content": "// Python easy solution in o(n)\\nclass Solution(object):\\n    def moveZeroes(self, nums):\\n        j=0\\n        for i in range(len(nums)):\\n            if(nums[i]!=0):\\n                nums[i],nums[j] = nums[j],nums[i]\\n                j+=1\\n\\n       return nums"
                    },
                    {
                        "username": "whovijaymaurya23",
                        "content": "As Some Test Case Can Contain the Negative number  also so we use the condition                 nums[i] !=0;\\n\\n\\nclass Solution {\\npublic:\\n    void moveZeroes(vector<int>& nums) {\\n       int k =0;\\n       for(int i=0; i<nums.size() ; i++)\\n       {\\n           if(nums[i]!=0){\\n        \\n        swap(nums[i],nums[k++]);\\n  \\n    }\\n       } \\n    }\\n};"
                    }
                ]
            },
            {
                "id": 1835973,
                "content": [
                    {
                        "username": "fgar13",
                        "content": "The constraints should be updated to include the fact that aside from the zeros, all the elements are already in ascending order. I spent too much time trying to implement what was essentially a sorting algorithm, not realizing that the array was essentially already sorted."
                    },
                    {
                        "username": "gabrielrosendo",
                        "content": "not all arrays are sorted"
                    },
                    {
                        "username": "zakmoulay07",
                        "content": "why ??? \n    public static void moveZeroes(int[] nums) {\n        int n = nums.length;\n        int l = 0, r = n - 1;\n        while (l < r) {\n            while (l < r && nums[r] == 0) {\n                r--;\n            }\n            while (l < r && nums[l] != 0) {\n                l++;\n            }\n\n            if (l < r)\n                swap(nums, l, r);\n        }\n    }\n\n    public static void swap(int[] nums, int a, int b) {\n        int temp = nums[a];\n        nums[a] = nums[b];\n        nums[b] = temp;\n    }\noutput 12,1,3,0,0    expected 1,3,12,0,0 "
                    },
                    {
                        "username": "garlapatipavan07",
                        "content": "//Simple c++ solution\\nvoid moveZeroes(vector<int>& nums) {\\n        int j = 0;\\n        for(int i = 0; i<nums.size(); i++){\\n            if(nums[i] != 0){\\n                swap(nums[i],nums[j]);\\n                j++;\\n            }\\n        }\\n    }"
                    },
                    {
                        "username": "Nitkapur30",
                        "content": "Hii Guys!! Check out my blog for the solution of this problem:\\nhttps://dsafordummies.digitalpress.blog/easy-array-leetcode-series-1/\\n\\nYou can also find two more easy level questions to test your skills in this particular blog! Thank you for supporting:)"
                    },
                    {
                        "username": "aleazanrashid",
                        "content": "im tryng to solve this proplem with this code below, it works fine but not when two zeros come next to each other , it move one of the zero to comapre with next element but the another zero stays i need to come back to that zero and keep comparing or swapping any idea guys ?\n\ndef move_zer():\n\n    lis = [0,1,0,3,12]\n        # [1,0,3,12,0]\n    left, right = 0, len(lis) - 1\n\n    while left < right:\n\n        if lis[left] ==0:\n            lis[left], lis[left + 1] = lis[left + 1], lis[left]\n\n        left += 1\n\n    return lis"
                    },
                    {
                        "username": "onigiricoco",
                        "content": "Could anyone tell me why this doesn\\'t work? \\n\\ndef move0(nums):\\n  return [i for i in nums if i!=0] +[j for j in nums if j==0]\\n\\nIt runs okay in my console , but returns [0,1,0,3,4] in leetcode"
                    },
                    {
                        "username": "pushkarsaxena96",
                        "content": "[@Siddharoodha10](/Siddharoodha10) Still does not work!"
                    },
                    {
                        "username": "Siddharoodha10",
                        "content": "I think it\\'s not expecting return . it needs to modify nums in-place only."
                    },
                    {
                        "username": "visva_123",
                        "content": "class Solution {\\npublic:\\n    void moveZeroes(vector<int>& nums) {\\n        \\n        vector<int>ans;\\n        int s =0;\\n        int n = nums.size();\\n        for(int i =0;i<n;i++){\\n            if(nums[i]!=0){\\n            swap(nums[i],nums[s++]);     \\n            }\\n           \\n\\n        }\\n         \\n    }\\n};"
                    },
                    {
                        "username": "arjun_50",
                        "content": "class Solution:\\n    def moveZeroes(self, nums: List[int]) -> None:\\n        d={}\\n        for item in nums:\\n            if (item in d):\\n                d[item] += 1\\n            else:\\n                d[item] = 1\\n  \\n        for j in range(d[0]):\\n            for i in range(len(nums)-1):\\n                if nums[i]==0:\\n                    nums[i],nums[i+1]=nums[i+1],nums[i]\\n    \\ncan anyone explain what exactly is wrong with this approach,pls\\nthis code is passing the testcases [0,1,0,3,12] and[0], but failing all other 70 cases\\n\\n\\n\\n"
                    },
                    {
                        "username": "Md_Hasan",
                        "content": "// Python easy solution in o(n)\\nclass Solution(object):\\n    def moveZeroes(self, nums):\\n        j=0\\n        for i in range(len(nums)):\\n            if(nums[i]!=0):\\n                nums[i],nums[j] = nums[j],nums[i]\\n                j+=1\\n\\n       return nums"
                    },
                    {
                        "username": "whovijaymaurya23",
                        "content": "As Some Test Case Can Contain the Negative number  also so we use the condition                 nums[i] !=0;\\n\\n\\nclass Solution {\\npublic:\\n    void moveZeroes(vector<int>& nums) {\\n       int k =0;\\n       for(int i=0; i<nums.size() ; i++)\\n       {\\n           if(nums[i]!=0){\\n        \\n        swap(nums[i],nums[k++]);\\n  \\n    }\\n       } \\n    }\\n};"
                    }
                ]
            },
            {
                "id": 1816223,
                "content": [
                    {
                        "username": "fgar13",
                        "content": "The constraints should be updated to include the fact that aside from the zeros, all the elements are already in ascending order. I spent too much time trying to implement what was essentially a sorting algorithm, not realizing that the array was essentially already sorted."
                    },
                    {
                        "username": "gabrielrosendo",
                        "content": "not all arrays are sorted"
                    },
                    {
                        "username": "zakmoulay07",
                        "content": "why ??? \n    public static void moveZeroes(int[] nums) {\n        int n = nums.length;\n        int l = 0, r = n - 1;\n        while (l < r) {\n            while (l < r && nums[r] == 0) {\n                r--;\n            }\n            while (l < r && nums[l] != 0) {\n                l++;\n            }\n\n            if (l < r)\n                swap(nums, l, r);\n        }\n    }\n\n    public static void swap(int[] nums, int a, int b) {\n        int temp = nums[a];\n        nums[a] = nums[b];\n        nums[b] = temp;\n    }\noutput 12,1,3,0,0    expected 1,3,12,0,0 "
                    },
                    {
                        "username": "garlapatipavan07",
                        "content": "//Simple c++ solution\\nvoid moveZeroes(vector<int>& nums) {\\n        int j = 0;\\n        for(int i = 0; i<nums.size(); i++){\\n            if(nums[i] != 0){\\n                swap(nums[i],nums[j]);\\n                j++;\\n            }\\n        }\\n    }"
                    },
                    {
                        "username": "Nitkapur30",
                        "content": "Hii Guys!! Check out my blog for the solution of this problem:\\nhttps://dsafordummies.digitalpress.blog/easy-array-leetcode-series-1/\\n\\nYou can also find two more easy level questions to test your skills in this particular blog! Thank you for supporting:)"
                    },
                    {
                        "username": "aleazanrashid",
                        "content": "im tryng to solve this proplem with this code below, it works fine but not when two zeros come next to each other , it move one of the zero to comapre with next element but the another zero stays i need to come back to that zero and keep comparing or swapping any idea guys ?\n\ndef move_zer():\n\n    lis = [0,1,0,3,12]\n        # [1,0,3,12,0]\n    left, right = 0, len(lis) - 1\n\n    while left < right:\n\n        if lis[left] ==0:\n            lis[left], lis[left + 1] = lis[left + 1], lis[left]\n\n        left += 1\n\n    return lis"
                    },
                    {
                        "username": "onigiricoco",
                        "content": "Could anyone tell me why this doesn\\'t work? \\n\\ndef move0(nums):\\n  return [i for i in nums if i!=0] +[j for j in nums if j==0]\\n\\nIt runs okay in my console , but returns [0,1,0,3,4] in leetcode"
                    },
                    {
                        "username": "pushkarsaxena96",
                        "content": "[@Siddharoodha10](/Siddharoodha10) Still does not work!"
                    },
                    {
                        "username": "Siddharoodha10",
                        "content": "I think it\\'s not expecting return . it needs to modify nums in-place only."
                    },
                    {
                        "username": "visva_123",
                        "content": "class Solution {\\npublic:\\n    void moveZeroes(vector<int>& nums) {\\n        \\n        vector<int>ans;\\n        int s =0;\\n        int n = nums.size();\\n        for(int i =0;i<n;i++){\\n            if(nums[i]!=0){\\n            swap(nums[i],nums[s++]);     \\n            }\\n           \\n\\n        }\\n         \\n    }\\n};"
                    },
                    {
                        "username": "arjun_50",
                        "content": "class Solution:\\n    def moveZeroes(self, nums: List[int]) -> None:\\n        d={}\\n        for item in nums:\\n            if (item in d):\\n                d[item] += 1\\n            else:\\n                d[item] = 1\\n  \\n        for j in range(d[0]):\\n            for i in range(len(nums)-1):\\n                if nums[i]==0:\\n                    nums[i],nums[i+1]=nums[i+1],nums[i]\\n    \\ncan anyone explain what exactly is wrong with this approach,pls\\nthis code is passing the testcases [0,1,0,3,12] and[0], but failing all other 70 cases\\n\\n\\n\\n"
                    },
                    {
                        "username": "Md_Hasan",
                        "content": "// Python easy solution in o(n)\\nclass Solution(object):\\n    def moveZeroes(self, nums):\\n        j=0\\n        for i in range(len(nums)):\\n            if(nums[i]!=0):\\n                nums[i],nums[j] = nums[j],nums[i]\\n                j+=1\\n\\n       return nums"
                    },
                    {
                        "username": "whovijaymaurya23",
                        "content": "As Some Test Case Can Contain the Negative number  also so we use the condition                 nums[i] !=0;\\n\\n\\nclass Solution {\\npublic:\\n    void moveZeroes(vector<int>& nums) {\\n       int k =0;\\n       for(int i=0; i<nums.size() ; i++)\\n       {\\n           if(nums[i]!=0){\\n        \\n        swap(nums[i],nums[k++]);\\n  \\n    }\\n       } \\n    }\\n};"
                    }
                ]
            },
            {
                "id": 1802250,
                "content": [
                    {
                        "username": "fgar13",
                        "content": "The constraints should be updated to include the fact that aside from the zeros, all the elements are already in ascending order. I spent too much time trying to implement what was essentially a sorting algorithm, not realizing that the array was essentially already sorted."
                    },
                    {
                        "username": "gabrielrosendo",
                        "content": "not all arrays are sorted"
                    },
                    {
                        "username": "zakmoulay07",
                        "content": "why ??? \n    public static void moveZeroes(int[] nums) {\n        int n = nums.length;\n        int l = 0, r = n - 1;\n        while (l < r) {\n            while (l < r && nums[r] == 0) {\n                r--;\n            }\n            while (l < r && nums[l] != 0) {\n                l++;\n            }\n\n            if (l < r)\n                swap(nums, l, r);\n        }\n    }\n\n    public static void swap(int[] nums, int a, int b) {\n        int temp = nums[a];\n        nums[a] = nums[b];\n        nums[b] = temp;\n    }\noutput 12,1,3,0,0    expected 1,3,12,0,0 "
                    },
                    {
                        "username": "garlapatipavan07",
                        "content": "//Simple c++ solution\\nvoid moveZeroes(vector<int>& nums) {\\n        int j = 0;\\n        for(int i = 0; i<nums.size(); i++){\\n            if(nums[i] != 0){\\n                swap(nums[i],nums[j]);\\n                j++;\\n            }\\n        }\\n    }"
                    },
                    {
                        "username": "Nitkapur30",
                        "content": "Hii Guys!! Check out my blog for the solution of this problem:\\nhttps://dsafordummies.digitalpress.blog/easy-array-leetcode-series-1/\\n\\nYou can also find two more easy level questions to test your skills in this particular blog! Thank you for supporting:)"
                    },
                    {
                        "username": "aleazanrashid",
                        "content": "im tryng to solve this proplem with this code below, it works fine but not when two zeros come next to each other , it move one of the zero to comapre with next element but the another zero stays i need to come back to that zero and keep comparing or swapping any idea guys ?\n\ndef move_zer():\n\n    lis = [0,1,0,3,12]\n        # [1,0,3,12,0]\n    left, right = 0, len(lis) - 1\n\n    while left < right:\n\n        if lis[left] ==0:\n            lis[left], lis[left + 1] = lis[left + 1], lis[left]\n\n        left += 1\n\n    return lis"
                    },
                    {
                        "username": "onigiricoco",
                        "content": "Could anyone tell me why this doesn\\'t work? \\n\\ndef move0(nums):\\n  return [i for i in nums if i!=0] +[j for j in nums if j==0]\\n\\nIt runs okay in my console , but returns [0,1,0,3,4] in leetcode"
                    },
                    {
                        "username": "pushkarsaxena96",
                        "content": "[@Siddharoodha10](/Siddharoodha10) Still does not work!"
                    },
                    {
                        "username": "Siddharoodha10",
                        "content": "I think it\\'s not expecting return . it needs to modify nums in-place only."
                    },
                    {
                        "username": "visva_123",
                        "content": "class Solution {\\npublic:\\n    void moveZeroes(vector<int>& nums) {\\n        \\n        vector<int>ans;\\n        int s =0;\\n        int n = nums.size();\\n        for(int i =0;i<n;i++){\\n            if(nums[i]!=0){\\n            swap(nums[i],nums[s++]);     \\n            }\\n           \\n\\n        }\\n         \\n    }\\n};"
                    },
                    {
                        "username": "arjun_50",
                        "content": "class Solution:\\n    def moveZeroes(self, nums: List[int]) -> None:\\n        d={}\\n        for item in nums:\\n            if (item in d):\\n                d[item] += 1\\n            else:\\n                d[item] = 1\\n  \\n        for j in range(d[0]):\\n            for i in range(len(nums)-1):\\n                if nums[i]==0:\\n                    nums[i],nums[i+1]=nums[i+1],nums[i]\\n    \\ncan anyone explain what exactly is wrong with this approach,pls\\nthis code is passing the testcases [0,1,0,3,12] and[0], but failing all other 70 cases\\n\\n\\n\\n"
                    },
                    {
                        "username": "Md_Hasan",
                        "content": "// Python easy solution in o(n)\\nclass Solution(object):\\n    def moveZeroes(self, nums):\\n        j=0\\n        for i in range(len(nums)):\\n            if(nums[i]!=0):\\n                nums[i],nums[j] = nums[j],nums[i]\\n                j+=1\\n\\n       return nums"
                    },
                    {
                        "username": "whovijaymaurya23",
                        "content": "As Some Test Case Can Contain the Negative number  also so we use the condition                 nums[i] !=0;\\n\\n\\nclass Solution {\\npublic:\\n    void moveZeroes(vector<int>& nums) {\\n       int k =0;\\n       for(int i=0; i<nums.size() ; i++)\\n       {\\n           if(nums[i]!=0){\\n        \\n        swap(nums[i],nums[k++]);\\n  \\n    }\\n       } \\n    }\\n};"
                    }
                ]
            },
            {
                "id": 1799408,
                "content": [
                    {
                        "username": "fgar13",
                        "content": "The constraints should be updated to include the fact that aside from the zeros, all the elements are already in ascending order. I spent too much time trying to implement what was essentially a sorting algorithm, not realizing that the array was essentially already sorted."
                    },
                    {
                        "username": "gabrielrosendo",
                        "content": "not all arrays are sorted"
                    },
                    {
                        "username": "zakmoulay07",
                        "content": "why ??? \n    public static void moveZeroes(int[] nums) {\n        int n = nums.length;\n        int l = 0, r = n - 1;\n        while (l < r) {\n            while (l < r && nums[r] == 0) {\n                r--;\n            }\n            while (l < r && nums[l] != 0) {\n                l++;\n            }\n\n            if (l < r)\n                swap(nums, l, r);\n        }\n    }\n\n    public static void swap(int[] nums, int a, int b) {\n        int temp = nums[a];\n        nums[a] = nums[b];\n        nums[b] = temp;\n    }\noutput 12,1,3,0,0    expected 1,3,12,0,0 "
                    },
                    {
                        "username": "garlapatipavan07",
                        "content": "//Simple c++ solution\\nvoid moveZeroes(vector<int>& nums) {\\n        int j = 0;\\n        for(int i = 0; i<nums.size(); i++){\\n            if(nums[i] != 0){\\n                swap(nums[i],nums[j]);\\n                j++;\\n            }\\n        }\\n    }"
                    },
                    {
                        "username": "Nitkapur30",
                        "content": "Hii Guys!! Check out my blog for the solution of this problem:\\nhttps://dsafordummies.digitalpress.blog/easy-array-leetcode-series-1/\\n\\nYou can also find two more easy level questions to test your skills in this particular blog! Thank you for supporting:)"
                    },
                    {
                        "username": "aleazanrashid",
                        "content": "im tryng to solve this proplem with this code below, it works fine but not when two zeros come next to each other , it move one of the zero to comapre with next element but the another zero stays i need to come back to that zero and keep comparing or swapping any idea guys ?\n\ndef move_zer():\n\n    lis = [0,1,0,3,12]\n        # [1,0,3,12,0]\n    left, right = 0, len(lis) - 1\n\n    while left < right:\n\n        if lis[left] ==0:\n            lis[left], lis[left + 1] = lis[left + 1], lis[left]\n\n        left += 1\n\n    return lis"
                    },
                    {
                        "username": "onigiricoco",
                        "content": "Could anyone tell me why this doesn\\'t work? \\n\\ndef move0(nums):\\n  return [i for i in nums if i!=0] +[j for j in nums if j==0]\\n\\nIt runs okay in my console , but returns [0,1,0,3,4] in leetcode"
                    },
                    {
                        "username": "pushkarsaxena96",
                        "content": "[@Siddharoodha10](/Siddharoodha10) Still does not work!"
                    },
                    {
                        "username": "Siddharoodha10",
                        "content": "I think it\\'s not expecting return . it needs to modify nums in-place only."
                    },
                    {
                        "username": "visva_123",
                        "content": "class Solution {\\npublic:\\n    void moveZeroes(vector<int>& nums) {\\n        \\n        vector<int>ans;\\n        int s =0;\\n        int n = nums.size();\\n        for(int i =0;i<n;i++){\\n            if(nums[i]!=0){\\n            swap(nums[i],nums[s++]);     \\n            }\\n           \\n\\n        }\\n         \\n    }\\n};"
                    },
                    {
                        "username": "arjun_50",
                        "content": "class Solution:\\n    def moveZeroes(self, nums: List[int]) -> None:\\n        d={}\\n        for item in nums:\\n            if (item in d):\\n                d[item] += 1\\n            else:\\n                d[item] = 1\\n  \\n        for j in range(d[0]):\\n            for i in range(len(nums)-1):\\n                if nums[i]==0:\\n                    nums[i],nums[i+1]=nums[i+1],nums[i]\\n    \\ncan anyone explain what exactly is wrong with this approach,pls\\nthis code is passing the testcases [0,1,0,3,12] and[0], but failing all other 70 cases\\n\\n\\n\\n"
                    },
                    {
                        "username": "Md_Hasan",
                        "content": "// Python easy solution in o(n)\\nclass Solution(object):\\n    def moveZeroes(self, nums):\\n        j=0\\n        for i in range(len(nums)):\\n            if(nums[i]!=0):\\n                nums[i],nums[j] = nums[j],nums[i]\\n                j+=1\\n\\n       return nums"
                    },
                    {
                        "username": "whovijaymaurya23",
                        "content": "As Some Test Case Can Contain the Negative number  also so we use the condition                 nums[i] !=0;\\n\\n\\nclass Solution {\\npublic:\\n    void moveZeroes(vector<int>& nums) {\\n       int k =0;\\n       for(int i=0; i<nums.size() ; i++)\\n       {\\n           if(nums[i]!=0){\\n        \\n        swap(nums[i],nums[k++]);\\n  \\n    }\\n       } \\n    }\\n};"
                    }
                ]
            },
            {
                "id": 1793913,
                "content": [
                    {
                        "username": "fgar13",
                        "content": "The constraints should be updated to include the fact that aside from the zeros, all the elements are already in ascending order. I spent too much time trying to implement what was essentially a sorting algorithm, not realizing that the array was essentially already sorted."
                    },
                    {
                        "username": "gabrielrosendo",
                        "content": "not all arrays are sorted"
                    },
                    {
                        "username": "zakmoulay07",
                        "content": "why ??? \n    public static void moveZeroes(int[] nums) {\n        int n = nums.length;\n        int l = 0, r = n - 1;\n        while (l < r) {\n            while (l < r && nums[r] == 0) {\n                r--;\n            }\n            while (l < r && nums[l] != 0) {\n                l++;\n            }\n\n            if (l < r)\n                swap(nums, l, r);\n        }\n    }\n\n    public static void swap(int[] nums, int a, int b) {\n        int temp = nums[a];\n        nums[a] = nums[b];\n        nums[b] = temp;\n    }\noutput 12,1,3,0,0    expected 1,3,12,0,0 "
                    },
                    {
                        "username": "garlapatipavan07",
                        "content": "//Simple c++ solution\\nvoid moveZeroes(vector<int>& nums) {\\n        int j = 0;\\n        for(int i = 0; i<nums.size(); i++){\\n            if(nums[i] != 0){\\n                swap(nums[i],nums[j]);\\n                j++;\\n            }\\n        }\\n    }"
                    },
                    {
                        "username": "Nitkapur30",
                        "content": "Hii Guys!! Check out my blog for the solution of this problem:\\nhttps://dsafordummies.digitalpress.blog/easy-array-leetcode-series-1/\\n\\nYou can also find two more easy level questions to test your skills in this particular blog! Thank you for supporting:)"
                    },
                    {
                        "username": "aleazanrashid",
                        "content": "im tryng to solve this proplem with this code below, it works fine but not when two zeros come next to each other , it move one of the zero to comapre with next element but the another zero stays i need to come back to that zero and keep comparing or swapping any idea guys ?\n\ndef move_zer():\n\n    lis = [0,1,0,3,12]\n        # [1,0,3,12,0]\n    left, right = 0, len(lis) - 1\n\n    while left < right:\n\n        if lis[left] ==0:\n            lis[left], lis[left + 1] = lis[left + 1], lis[left]\n\n        left += 1\n\n    return lis"
                    },
                    {
                        "username": "onigiricoco",
                        "content": "Could anyone tell me why this doesn\\'t work? \\n\\ndef move0(nums):\\n  return [i for i in nums if i!=0] +[j for j in nums if j==0]\\n\\nIt runs okay in my console , but returns [0,1,0,3,4] in leetcode"
                    },
                    {
                        "username": "pushkarsaxena96",
                        "content": "[@Siddharoodha10](/Siddharoodha10) Still does not work!"
                    },
                    {
                        "username": "Siddharoodha10",
                        "content": "I think it\\'s not expecting return . it needs to modify nums in-place only."
                    },
                    {
                        "username": "visva_123",
                        "content": "class Solution {\\npublic:\\n    void moveZeroes(vector<int>& nums) {\\n        \\n        vector<int>ans;\\n        int s =0;\\n        int n = nums.size();\\n        for(int i =0;i<n;i++){\\n            if(nums[i]!=0){\\n            swap(nums[i],nums[s++]);     \\n            }\\n           \\n\\n        }\\n         \\n    }\\n};"
                    },
                    {
                        "username": "arjun_50",
                        "content": "class Solution:\\n    def moveZeroes(self, nums: List[int]) -> None:\\n        d={}\\n        for item in nums:\\n            if (item in d):\\n                d[item] += 1\\n            else:\\n                d[item] = 1\\n  \\n        for j in range(d[0]):\\n            for i in range(len(nums)-1):\\n                if nums[i]==0:\\n                    nums[i],nums[i+1]=nums[i+1],nums[i]\\n    \\ncan anyone explain what exactly is wrong with this approach,pls\\nthis code is passing the testcases [0,1,0,3,12] and[0], but failing all other 70 cases\\n\\n\\n\\n"
                    },
                    {
                        "username": "Md_Hasan",
                        "content": "// Python easy solution in o(n)\\nclass Solution(object):\\n    def moveZeroes(self, nums):\\n        j=0\\n        for i in range(len(nums)):\\n            if(nums[i]!=0):\\n                nums[i],nums[j] = nums[j],nums[i]\\n                j+=1\\n\\n       return nums"
                    },
                    {
                        "username": "whovijaymaurya23",
                        "content": "As Some Test Case Can Contain the Negative number  also so we use the condition                 nums[i] !=0;\\n\\n\\nclass Solution {\\npublic:\\n    void moveZeroes(vector<int>& nums) {\\n       int k =0;\\n       for(int i=0; i<nums.size() ; i++)\\n       {\\n           if(nums[i]!=0){\\n        \\n        swap(nums[i],nums[k++]);\\n  \\n    }\\n       } \\n    }\\n};"
                    }
                ]
            },
            {
                "id": 1791478,
                "content": [
                    {
                        "username": "SharmaAyush",
                        "content": "class Solution {\\npublic:\\n\\nvoid moveZeroes(vector<int>& nums) {\\n        int l=0,m=0;\\n        while(m<nums.size())\\n        {\\n            switch(nums[m])\\n            {\\n                case 0:\\n                    m++;\\n                    break;\\n                default:\\n                    swap(nums[l++],nums[m++]);\\n                    break;\\n            }\\n        }\\n        for(int i=0;i<nums.size();i++){\\n            cout<<nums[i]<<\" \";\\n        }\\n    }\\n\\n\\n\\n};"
                    },
                    {
                        "username": "SharmaAyush",
                        "content": "class Solution {\\npublic:\\n    void moveZeroes(vector<int>& nums) {\\n        int j =0;\\n    \\n    for(int i=0;i<nums.size();i++)\\n    {\\n        if(nums[i]!=0){\\n            \\n            swap(nums[i],nums[j]);\\n              j++;\\n        }\\n    } \\n    }\\n};"
                    },
                    {
                        "username": "amineguettaby",
                        "content": "the new index of the current element is the current index - total_zeros from that index to 0 \\n "
                    },
                    {
                        "username": "argulhane10246",
                        "content": "all you need is to read hint 3 times before solving this question.\\nSolve the question iteratively and then just change the new array declaration with the old array name that\\'s it"
                    },
                    {
                        "username": "starogre",
                        "content": "that doesn\\'t work, pretty sure that creates a new list and eats memory that the problem says you shouldn\\'t. the correct way is to modify only the original list"
                    },
                    {
                        "username": "taral_13",
                        "content": "Hint: Use one pointer at index(start) = 0\nand use a loop to traverse through the array and move non zero element to index (start)"
                    },
                    {
                        "username": "amineguettaby",
                        "content": "good idea"
                    },
                    {
                        "username": "Coder15091999",
                        "content": "Beat 100%  Java Solution\\n\\npublic void moveZeroes(int[] nums) {\\n        int count=0;\\n        for(int i=0;i<nums.length;i++)\\n        {\\n            if(nums[i]==0)\\n            {\\n                count++;\\n            }\\n        }\\n        int i=0;\\n        for(int j=0;j<nums.length;j++)\\n        {\\n            if(nums[j]!=0)\\n            {\\n                nums[i]=nums[j];\\n                i++;\\n            }\\n        }\\n        for(int k=0;k<count;k++)\\n        {\\n            nums[i]=0;\\n            i++;\\n        }\\n    }\\n"
                    },
                    {
                        "username": "sHaan27",
                        "content": "class Solution {\\npublic:\\n    void moveZeroes(vector<int>& nums) {\\n        int i =0;\\n        for(int j =0;j<nums.size();j++)\\n        {\\n            if(nums[j] != 0)\\n            {\\n                swap(nums[j],nums[i]);\\n                i++;\\n            }\\n        }\\n    }\\n};"
                    },
                    {
                        "username": "artem_se_putem",
                        "content": "HA,  i am #1, it so easy to me. Common guys, you can do it. :3"
                    },
                    {
                        "username": "I_AM_JD",
                        "content": "# --------------------------------\\nclass Solution:\\n    def moveZeroes(self, nums: List[int]) -> None:\\n        \"\"\"\\n        Do not return anything, modify nums in-place instead.\\n        \"\"\"\\n        for key ,value in enumerate(nums):\\n          if value==0:\\n            nums.pop(key)\\n            nums.append(0)\\n\\nThis code is accepted fine\\n#---------------------------------------\\n\\n\\n\\nBut why this code not  accepted\\nclass Solution:\\n    def moveZeroes(self, nums: List[int]) -> None:\\n        \"\"\"\\n        Do not return anything, modify nums in-place instead.\\n        \"\"\"\\n        n=nums.count(0)\\n        nums = [x for x in nums if x!=0]\\n        zero = [0 for i in range(n)]\\n        nums=nums+zero\\n\\n        print(nums)\\n\\n\\n\\n\\n\\nAnyone please tell -------------------------------"
                    },
                    {
                        "username": "I_AM_JD",
                        "content": "[@nikhila01](/nikhila01)  Thanks bro now I understand"
                    },
                    {
                        "username": "nikhila01",
                        "content": "When you do `nums = nums + zero` you're not changing `nums` in place. You're creating a new list and assigning it to the local variable called `nums`. Once the function exits that change isn't visible.\n\nFirst, don't use the name `nums` when you're creating `[x for x in nums if x!=0]`. Give it another name like `nonzero`, otherwise you lose access to the original input list.\n\nThen try doing `nums[:] = nonzero + zero` which will actually copy the elements into `nums`. "
                    },
                    {
                        "username": "hari0911",
                        "content": "Easy solution check if number is not equal to 0 then swap with next number.\\nhttps://leetcode.com/problems/move-zeroes/solutions/3100334/easy-java-solution/"
                    }
                ]
            },
            {
                "id": 1791466,
                "content": [
                    {
                        "username": "SharmaAyush",
                        "content": "class Solution {\\npublic:\\n\\nvoid moveZeroes(vector<int>& nums) {\\n        int l=0,m=0;\\n        while(m<nums.size())\\n        {\\n            switch(nums[m])\\n            {\\n                case 0:\\n                    m++;\\n                    break;\\n                default:\\n                    swap(nums[l++],nums[m++]);\\n                    break;\\n            }\\n        }\\n        for(int i=0;i<nums.size();i++){\\n            cout<<nums[i]<<\" \";\\n        }\\n    }\\n\\n\\n\\n};"
                    },
                    {
                        "username": "SharmaAyush",
                        "content": "class Solution {\\npublic:\\n    void moveZeroes(vector<int>& nums) {\\n        int j =0;\\n    \\n    for(int i=0;i<nums.size();i++)\\n    {\\n        if(nums[i]!=0){\\n            \\n            swap(nums[i],nums[j]);\\n              j++;\\n        }\\n    } \\n    }\\n};"
                    },
                    {
                        "username": "amineguettaby",
                        "content": "the new index of the current element is the current index - total_zeros from that index to 0 \\n "
                    },
                    {
                        "username": "argulhane10246",
                        "content": "all you need is to read hint 3 times before solving this question.\\nSolve the question iteratively and then just change the new array declaration with the old array name that\\'s it"
                    },
                    {
                        "username": "starogre",
                        "content": "that doesn\\'t work, pretty sure that creates a new list and eats memory that the problem says you shouldn\\'t. the correct way is to modify only the original list"
                    },
                    {
                        "username": "taral_13",
                        "content": "Hint: Use one pointer at index(start) = 0\nand use a loop to traverse through the array and move non zero element to index (start)"
                    },
                    {
                        "username": "amineguettaby",
                        "content": "good idea"
                    },
                    {
                        "username": "Coder15091999",
                        "content": "Beat 100%  Java Solution\\n\\npublic void moveZeroes(int[] nums) {\\n        int count=0;\\n        for(int i=0;i<nums.length;i++)\\n        {\\n            if(nums[i]==0)\\n            {\\n                count++;\\n            }\\n        }\\n        int i=0;\\n        for(int j=0;j<nums.length;j++)\\n        {\\n            if(nums[j]!=0)\\n            {\\n                nums[i]=nums[j];\\n                i++;\\n            }\\n        }\\n        for(int k=0;k<count;k++)\\n        {\\n            nums[i]=0;\\n            i++;\\n        }\\n    }\\n"
                    },
                    {
                        "username": "sHaan27",
                        "content": "class Solution {\\npublic:\\n    void moveZeroes(vector<int>& nums) {\\n        int i =0;\\n        for(int j =0;j<nums.size();j++)\\n        {\\n            if(nums[j] != 0)\\n            {\\n                swap(nums[j],nums[i]);\\n                i++;\\n            }\\n        }\\n    }\\n};"
                    },
                    {
                        "username": "artem_se_putem",
                        "content": "HA,  i am #1, it so easy to me. Common guys, you can do it. :3"
                    },
                    {
                        "username": "I_AM_JD",
                        "content": "# --------------------------------\\nclass Solution:\\n    def moveZeroes(self, nums: List[int]) -> None:\\n        \"\"\"\\n        Do not return anything, modify nums in-place instead.\\n        \"\"\"\\n        for key ,value in enumerate(nums):\\n          if value==0:\\n            nums.pop(key)\\n            nums.append(0)\\n\\nThis code is accepted fine\\n#---------------------------------------\\n\\n\\n\\nBut why this code not  accepted\\nclass Solution:\\n    def moveZeroes(self, nums: List[int]) -> None:\\n        \"\"\"\\n        Do not return anything, modify nums in-place instead.\\n        \"\"\"\\n        n=nums.count(0)\\n        nums = [x for x in nums if x!=0]\\n        zero = [0 for i in range(n)]\\n        nums=nums+zero\\n\\n        print(nums)\\n\\n\\n\\n\\n\\nAnyone please tell -------------------------------"
                    },
                    {
                        "username": "I_AM_JD",
                        "content": "[@nikhila01](/nikhila01)  Thanks bro now I understand"
                    },
                    {
                        "username": "nikhila01",
                        "content": "When you do `nums = nums + zero` you're not changing `nums` in place. You're creating a new list and assigning it to the local variable called `nums`. Once the function exits that change isn't visible.\n\nFirst, don't use the name `nums` when you're creating `[x for x in nums if x!=0]`. Give it another name like `nonzero`, otherwise you lose access to the original input list.\n\nThen try doing `nums[:] = nonzero + zero` which will actually copy the elements into `nums`. "
                    },
                    {
                        "username": "hari0911",
                        "content": "Easy solution check if number is not equal to 0 then swap with next number.\\nhttps://leetcode.com/problems/move-zeroes/solutions/3100334/easy-java-solution/"
                    }
                ]
            },
            {
                "id": 1791305,
                "content": [
                    {
                        "username": "SharmaAyush",
                        "content": "class Solution {\\npublic:\\n\\nvoid moveZeroes(vector<int>& nums) {\\n        int l=0,m=0;\\n        while(m<nums.size())\\n        {\\n            switch(nums[m])\\n            {\\n                case 0:\\n                    m++;\\n                    break;\\n                default:\\n                    swap(nums[l++],nums[m++]);\\n                    break;\\n            }\\n        }\\n        for(int i=0;i<nums.size();i++){\\n            cout<<nums[i]<<\" \";\\n        }\\n    }\\n\\n\\n\\n};"
                    },
                    {
                        "username": "SharmaAyush",
                        "content": "class Solution {\\npublic:\\n    void moveZeroes(vector<int>& nums) {\\n        int j =0;\\n    \\n    for(int i=0;i<nums.size();i++)\\n    {\\n        if(nums[i]!=0){\\n            \\n            swap(nums[i],nums[j]);\\n              j++;\\n        }\\n    } \\n    }\\n};"
                    },
                    {
                        "username": "amineguettaby",
                        "content": "the new index of the current element is the current index - total_zeros from that index to 0 \\n "
                    },
                    {
                        "username": "argulhane10246",
                        "content": "all you need is to read hint 3 times before solving this question.\\nSolve the question iteratively and then just change the new array declaration with the old array name that\\'s it"
                    },
                    {
                        "username": "starogre",
                        "content": "that doesn\\'t work, pretty sure that creates a new list and eats memory that the problem says you shouldn\\'t. the correct way is to modify only the original list"
                    },
                    {
                        "username": "taral_13",
                        "content": "Hint: Use one pointer at index(start) = 0\nand use a loop to traverse through the array and move non zero element to index (start)"
                    },
                    {
                        "username": "amineguettaby",
                        "content": "good idea"
                    },
                    {
                        "username": "Coder15091999",
                        "content": "Beat 100%  Java Solution\\n\\npublic void moveZeroes(int[] nums) {\\n        int count=0;\\n        for(int i=0;i<nums.length;i++)\\n        {\\n            if(nums[i]==0)\\n            {\\n                count++;\\n            }\\n        }\\n        int i=0;\\n        for(int j=0;j<nums.length;j++)\\n        {\\n            if(nums[j]!=0)\\n            {\\n                nums[i]=nums[j];\\n                i++;\\n            }\\n        }\\n        for(int k=0;k<count;k++)\\n        {\\n            nums[i]=0;\\n            i++;\\n        }\\n    }\\n"
                    },
                    {
                        "username": "sHaan27",
                        "content": "class Solution {\\npublic:\\n    void moveZeroes(vector<int>& nums) {\\n        int i =0;\\n        for(int j =0;j<nums.size();j++)\\n        {\\n            if(nums[j] != 0)\\n            {\\n                swap(nums[j],nums[i]);\\n                i++;\\n            }\\n        }\\n    }\\n};"
                    },
                    {
                        "username": "artem_se_putem",
                        "content": "HA,  i am #1, it so easy to me. Common guys, you can do it. :3"
                    },
                    {
                        "username": "I_AM_JD",
                        "content": "# --------------------------------\\nclass Solution:\\n    def moveZeroes(self, nums: List[int]) -> None:\\n        \"\"\"\\n        Do not return anything, modify nums in-place instead.\\n        \"\"\"\\n        for key ,value in enumerate(nums):\\n          if value==0:\\n            nums.pop(key)\\n            nums.append(0)\\n\\nThis code is accepted fine\\n#---------------------------------------\\n\\n\\n\\nBut why this code not  accepted\\nclass Solution:\\n    def moveZeroes(self, nums: List[int]) -> None:\\n        \"\"\"\\n        Do not return anything, modify nums in-place instead.\\n        \"\"\"\\n        n=nums.count(0)\\n        nums = [x for x in nums if x!=0]\\n        zero = [0 for i in range(n)]\\n        nums=nums+zero\\n\\n        print(nums)\\n\\n\\n\\n\\n\\nAnyone please tell -------------------------------"
                    },
                    {
                        "username": "I_AM_JD",
                        "content": "[@nikhila01](/nikhila01)  Thanks bro now I understand"
                    },
                    {
                        "username": "nikhila01",
                        "content": "When you do `nums = nums + zero` you're not changing `nums` in place. You're creating a new list and assigning it to the local variable called `nums`. Once the function exits that change isn't visible.\n\nFirst, don't use the name `nums` when you're creating `[x for x in nums if x!=0]`. Give it another name like `nonzero`, otherwise you lose access to the original input list.\n\nThen try doing `nums[:] = nonzero + zero` which will actually copy the elements into `nums`. "
                    },
                    {
                        "username": "hari0911",
                        "content": "Easy solution check if number is not equal to 0 then swap with next number.\\nhttps://leetcode.com/problems/move-zeroes/solutions/3100334/easy-java-solution/"
                    }
                ]
            },
            {
                "id": 1789581,
                "content": [
                    {
                        "username": "SharmaAyush",
                        "content": "class Solution {\\npublic:\\n\\nvoid moveZeroes(vector<int>& nums) {\\n        int l=0,m=0;\\n        while(m<nums.size())\\n        {\\n            switch(nums[m])\\n            {\\n                case 0:\\n                    m++;\\n                    break;\\n                default:\\n                    swap(nums[l++],nums[m++]);\\n                    break;\\n            }\\n        }\\n        for(int i=0;i<nums.size();i++){\\n            cout<<nums[i]<<\" \";\\n        }\\n    }\\n\\n\\n\\n};"
                    },
                    {
                        "username": "SharmaAyush",
                        "content": "class Solution {\\npublic:\\n    void moveZeroes(vector<int>& nums) {\\n        int j =0;\\n    \\n    for(int i=0;i<nums.size();i++)\\n    {\\n        if(nums[i]!=0){\\n            \\n            swap(nums[i],nums[j]);\\n              j++;\\n        }\\n    } \\n    }\\n};"
                    },
                    {
                        "username": "amineguettaby",
                        "content": "the new index of the current element is the current index - total_zeros from that index to 0 \\n "
                    },
                    {
                        "username": "argulhane10246",
                        "content": "all you need is to read hint 3 times before solving this question.\\nSolve the question iteratively and then just change the new array declaration with the old array name that\\'s it"
                    },
                    {
                        "username": "starogre",
                        "content": "that doesn\\'t work, pretty sure that creates a new list and eats memory that the problem says you shouldn\\'t. the correct way is to modify only the original list"
                    },
                    {
                        "username": "taral_13",
                        "content": "Hint: Use one pointer at index(start) = 0\nand use a loop to traverse through the array and move non zero element to index (start)"
                    },
                    {
                        "username": "amineguettaby",
                        "content": "good idea"
                    },
                    {
                        "username": "Coder15091999",
                        "content": "Beat 100%  Java Solution\\n\\npublic void moveZeroes(int[] nums) {\\n        int count=0;\\n        for(int i=0;i<nums.length;i++)\\n        {\\n            if(nums[i]==0)\\n            {\\n                count++;\\n            }\\n        }\\n        int i=0;\\n        for(int j=0;j<nums.length;j++)\\n        {\\n            if(nums[j]!=0)\\n            {\\n                nums[i]=nums[j];\\n                i++;\\n            }\\n        }\\n        for(int k=0;k<count;k++)\\n        {\\n            nums[i]=0;\\n            i++;\\n        }\\n    }\\n"
                    },
                    {
                        "username": "sHaan27",
                        "content": "class Solution {\\npublic:\\n    void moveZeroes(vector<int>& nums) {\\n        int i =0;\\n        for(int j =0;j<nums.size();j++)\\n        {\\n            if(nums[j] != 0)\\n            {\\n                swap(nums[j],nums[i]);\\n                i++;\\n            }\\n        }\\n    }\\n};"
                    },
                    {
                        "username": "artem_se_putem",
                        "content": "HA,  i am #1, it so easy to me. Common guys, you can do it. :3"
                    },
                    {
                        "username": "I_AM_JD",
                        "content": "# --------------------------------\\nclass Solution:\\n    def moveZeroes(self, nums: List[int]) -> None:\\n        \"\"\"\\n        Do not return anything, modify nums in-place instead.\\n        \"\"\"\\n        for key ,value in enumerate(nums):\\n          if value==0:\\n            nums.pop(key)\\n            nums.append(0)\\n\\nThis code is accepted fine\\n#---------------------------------------\\n\\n\\n\\nBut why this code not  accepted\\nclass Solution:\\n    def moveZeroes(self, nums: List[int]) -> None:\\n        \"\"\"\\n        Do not return anything, modify nums in-place instead.\\n        \"\"\"\\n        n=nums.count(0)\\n        nums = [x for x in nums if x!=0]\\n        zero = [0 for i in range(n)]\\n        nums=nums+zero\\n\\n        print(nums)\\n\\n\\n\\n\\n\\nAnyone please tell -------------------------------"
                    },
                    {
                        "username": "I_AM_JD",
                        "content": "[@nikhila01](/nikhila01)  Thanks bro now I understand"
                    },
                    {
                        "username": "nikhila01",
                        "content": "When you do `nums = nums + zero` you're not changing `nums` in place. You're creating a new list and assigning it to the local variable called `nums`. Once the function exits that change isn't visible.\n\nFirst, don't use the name `nums` when you're creating `[x for x in nums if x!=0]`. Give it another name like `nonzero`, otherwise you lose access to the original input list.\n\nThen try doing `nums[:] = nonzero + zero` which will actually copy the elements into `nums`. "
                    },
                    {
                        "username": "hari0911",
                        "content": "Easy solution check if number is not equal to 0 then swap with next number.\\nhttps://leetcode.com/problems/move-zeroes/solutions/3100334/easy-java-solution/"
                    }
                ]
            },
            {
                "id": 1786931,
                "content": [
                    {
                        "username": "SharmaAyush",
                        "content": "class Solution {\\npublic:\\n\\nvoid moveZeroes(vector<int>& nums) {\\n        int l=0,m=0;\\n        while(m<nums.size())\\n        {\\n            switch(nums[m])\\n            {\\n                case 0:\\n                    m++;\\n                    break;\\n                default:\\n                    swap(nums[l++],nums[m++]);\\n                    break;\\n            }\\n        }\\n        for(int i=0;i<nums.size();i++){\\n            cout<<nums[i]<<\" \";\\n        }\\n    }\\n\\n\\n\\n};"
                    },
                    {
                        "username": "SharmaAyush",
                        "content": "class Solution {\\npublic:\\n    void moveZeroes(vector<int>& nums) {\\n        int j =0;\\n    \\n    for(int i=0;i<nums.size();i++)\\n    {\\n        if(nums[i]!=0){\\n            \\n            swap(nums[i],nums[j]);\\n              j++;\\n        }\\n    } \\n    }\\n};"
                    },
                    {
                        "username": "amineguettaby",
                        "content": "the new index of the current element is the current index - total_zeros from that index to 0 \\n "
                    },
                    {
                        "username": "argulhane10246",
                        "content": "all you need is to read hint 3 times before solving this question.\\nSolve the question iteratively and then just change the new array declaration with the old array name that\\'s it"
                    },
                    {
                        "username": "starogre",
                        "content": "that doesn\\'t work, pretty sure that creates a new list and eats memory that the problem says you shouldn\\'t. the correct way is to modify only the original list"
                    },
                    {
                        "username": "taral_13",
                        "content": "Hint: Use one pointer at index(start) = 0\nand use a loop to traverse through the array and move non zero element to index (start)"
                    },
                    {
                        "username": "amineguettaby",
                        "content": "good idea"
                    },
                    {
                        "username": "Coder15091999",
                        "content": "Beat 100%  Java Solution\\n\\npublic void moveZeroes(int[] nums) {\\n        int count=0;\\n        for(int i=0;i<nums.length;i++)\\n        {\\n            if(nums[i]==0)\\n            {\\n                count++;\\n            }\\n        }\\n        int i=0;\\n        for(int j=0;j<nums.length;j++)\\n        {\\n            if(nums[j]!=0)\\n            {\\n                nums[i]=nums[j];\\n                i++;\\n            }\\n        }\\n        for(int k=0;k<count;k++)\\n        {\\n            nums[i]=0;\\n            i++;\\n        }\\n    }\\n"
                    },
                    {
                        "username": "sHaan27",
                        "content": "class Solution {\\npublic:\\n    void moveZeroes(vector<int>& nums) {\\n        int i =0;\\n        for(int j =0;j<nums.size();j++)\\n        {\\n            if(nums[j] != 0)\\n            {\\n                swap(nums[j],nums[i]);\\n                i++;\\n            }\\n        }\\n    }\\n};"
                    },
                    {
                        "username": "artem_se_putem",
                        "content": "HA,  i am #1, it so easy to me. Common guys, you can do it. :3"
                    },
                    {
                        "username": "I_AM_JD",
                        "content": "# --------------------------------\\nclass Solution:\\n    def moveZeroes(self, nums: List[int]) -> None:\\n        \"\"\"\\n        Do not return anything, modify nums in-place instead.\\n        \"\"\"\\n        for key ,value in enumerate(nums):\\n          if value==0:\\n            nums.pop(key)\\n            nums.append(0)\\n\\nThis code is accepted fine\\n#---------------------------------------\\n\\n\\n\\nBut why this code not  accepted\\nclass Solution:\\n    def moveZeroes(self, nums: List[int]) -> None:\\n        \"\"\"\\n        Do not return anything, modify nums in-place instead.\\n        \"\"\"\\n        n=nums.count(0)\\n        nums = [x for x in nums if x!=0]\\n        zero = [0 for i in range(n)]\\n        nums=nums+zero\\n\\n        print(nums)\\n\\n\\n\\n\\n\\nAnyone please tell -------------------------------"
                    },
                    {
                        "username": "I_AM_JD",
                        "content": "[@nikhila01](/nikhila01)  Thanks bro now I understand"
                    },
                    {
                        "username": "nikhila01",
                        "content": "When you do `nums = nums + zero` you're not changing `nums` in place. You're creating a new list and assigning it to the local variable called `nums`. Once the function exits that change isn't visible.\n\nFirst, don't use the name `nums` when you're creating `[x for x in nums if x!=0]`. Give it another name like `nonzero`, otherwise you lose access to the original input list.\n\nThen try doing `nums[:] = nonzero + zero` which will actually copy the elements into `nums`. "
                    },
                    {
                        "username": "hari0911",
                        "content": "Easy solution check if number is not equal to 0 then swap with next number.\\nhttps://leetcode.com/problems/move-zeroes/solutions/3100334/easy-java-solution/"
                    }
                ]
            },
            {
                "id": 1786012,
                "content": [
                    {
                        "username": "SharmaAyush",
                        "content": "class Solution {\\npublic:\\n\\nvoid moveZeroes(vector<int>& nums) {\\n        int l=0,m=0;\\n        while(m<nums.size())\\n        {\\n            switch(nums[m])\\n            {\\n                case 0:\\n                    m++;\\n                    break;\\n                default:\\n                    swap(nums[l++],nums[m++]);\\n                    break;\\n            }\\n        }\\n        for(int i=0;i<nums.size();i++){\\n            cout<<nums[i]<<\" \";\\n        }\\n    }\\n\\n\\n\\n};"
                    },
                    {
                        "username": "SharmaAyush",
                        "content": "class Solution {\\npublic:\\n    void moveZeroes(vector<int>& nums) {\\n        int j =0;\\n    \\n    for(int i=0;i<nums.size();i++)\\n    {\\n        if(nums[i]!=0){\\n            \\n            swap(nums[i],nums[j]);\\n              j++;\\n        }\\n    } \\n    }\\n};"
                    },
                    {
                        "username": "amineguettaby",
                        "content": "the new index of the current element is the current index - total_zeros from that index to 0 \\n "
                    },
                    {
                        "username": "argulhane10246",
                        "content": "all you need is to read hint 3 times before solving this question.\\nSolve the question iteratively and then just change the new array declaration with the old array name that\\'s it"
                    },
                    {
                        "username": "starogre",
                        "content": "that doesn\\'t work, pretty sure that creates a new list and eats memory that the problem says you shouldn\\'t. the correct way is to modify only the original list"
                    },
                    {
                        "username": "taral_13",
                        "content": "Hint: Use one pointer at index(start) = 0\nand use a loop to traverse through the array and move non zero element to index (start)"
                    },
                    {
                        "username": "amineguettaby",
                        "content": "good idea"
                    },
                    {
                        "username": "Coder15091999",
                        "content": "Beat 100%  Java Solution\\n\\npublic void moveZeroes(int[] nums) {\\n        int count=0;\\n        for(int i=0;i<nums.length;i++)\\n        {\\n            if(nums[i]==0)\\n            {\\n                count++;\\n            }\\n        }\\n        int i=0;\\n        for(int j=0;j<nums.length;j++)\\n        {\\n            if(nums[j]!=0)\\n            {\\n                nums[i]=nums[j];\\n                i++;\\n            }\\n        }\\n        for(int k=0;k<count;k++)\\n        {\\n            nums[i]=0;\\n            i++;\\n        }\\n    }\\n"
                    },
                    {
                        "username": "sHaan27",
                        "content": "class Solution {\\npublic:\\n    void moveZeroes(vector<int>& nums) {\\n        int i =0;\\n        for(int j =0;j<nums.size();j++)\\n        {\\n            if(nums[j] != 0)\\n            {\\n                swap(nums[j],nums[i]);\\n                i++;\\n            }\\n        }\\n    }\\n};"
                    },
                    {
                        "username": "artem_se_putem",
                        "content": "HA,  i am #1, it so easy to me. Common guys, you can do it. :3"
                    },
                    {
                        "username": "I_AM_JD",
                        "content": "# --------------------------------\\nclass Solution:\\n    def moveZeroes(self, nums: List[int]) -> None:\\n        \"\"\"\\n        Do not return anything, modify nums in-place instead.\\n        \"\"\"\\n        for key ,value in enumerate(nums):\\n          if value==0:\\n            nums.pop(key)\\n            nums.append(0)\\n\\nThis code is accepted fine\\n#---------------------------------------\\n\\n\\n\\nBut why this code not  accepted\\nclass Solution:\\n    def moveZeroes(self, nums: List[int]) -> None:\\n        \"\"\"\\n        Do not return anything, modify nums in-place instead.\\n        \"\"\"\\n        n=nums.count(0)\\n        nums = [x for x in nums if x!=0]\\n        zero = [0 for i in range(n)]\\n        nums=nums+zero\\n\\n        print(nums)\\n\\n\\n\\n\\n\\nAnyone please tell -------------------------------"
                    },
                    {
                        "username": "I_AM_JD",
                        "content": "[@nikhila01](/nikhila01)  Thanks bro now I understand"
                    },
                    {
                        "username": "nikhila01",
                        "content": "When you do `nums = nums + zero` you're not changing `nums` in place. You're creating a new list and assigning it to the local variable called `nums`. Once the function exits that change isn't visible.\n\nFirst, don't use the name `nums` when you're creating `[x for x in nums if x!=0]`. Give it another name like `nonzero`, otherwise you lose access to the original input list.\n\nThen try doing `nums[:] = nonzero + zero` which will actually copy the elements into `nums`. "
                    },
                    {
                        "username": "hari0911",
                        "content": "Easy solution check if number is not equal to 0 then swap with next number.\\nhttps://leetcode.com/problems/move-zeroes/solutions/3100334/easy-java-solution/"
                    }
                ]
            },
            {
                "id": 1784692,
                "content": [
                    {
                        "username": "SharmaAyush",
                        "content": "class Solution {\\npublic:\\n\\nvoid moveZeroes(vector<int>& nums) {\\n        int l=0,m=0;\\n        while(m<nums.size())\\n        {\\n            switch(nums[m])\\n            {\\n                case 0:\\n                    m++;\\n                    break;\\n                default:\\n                    swap(nums[l++],nums[m++]);\\n                    break;\\n            }\\n        }\\n        for(int i=0;i<nums.size();i++){\\n            cout<<nums[i]<<\" \";\\n        }\\n    }\\n\\n\\n\\n};"
                    },
                    {
                        "username": "SharmaAyush",
                        "content": "class Solution {\\npublic:\\n    void moveZeroes(vector<int>& nums) {\\n        int j =0;\\n    \\n    for(int i=0;i<nums.size();i++)\\n    {\\n        if(nums[i]!=0){\\n            \\n            swap(nums[i],nums[j]);\\n              j++;\\n        }\\n    } \\n    }\\n};"
                    },
                    {
                        "username": "amineguettaby",
                        "content": "the new index of the current element is the current index - total_zeros from that index to 0 \\n "
                    },
                    {
                        "username": "argulhane10246",
                        "content": "all you need is to read hint 3 times before solving this question.\\nSolve the question iteratively and then just change the new array declaration with the old array name that\\'s it"
                    },
                    {
                        "username": "starogre",
                        "content": "that doesn\\'t work, pretty sure that creates a new list and eats memory that the problem says you shouldn\\'t. the correct way is to modify only the original list"
                    },
                    {
                        "username": "taral_13",
                        "content": "Hint: Use one pointer at index(start) = 0\nand use a loop to traverse through the array and move non zero element to index (start)"
                    },
                    {
                        "username": "amineguettaby",
                        "content": "good idea"
                    },
                    {
                        "username": "Coder15091999",
                        "content": "Beat 100%  Java Solution\\n\\npublic void moveZeroes(int[] nums) {\\n        int count=0;\\n        for(int i=0;i<nums.length;i++)\\n        {\\n            if(nums[i]==0)\\n            {\\n                count++;\\n            }\\n        }\\n        int i=0;\\n        for(int j=0;j<nums.length;j++)\\n        {\\n            if(nums[j]!=0)\\n            {\\n                nums[i]=nums[j];\\n                i++;\\n            }\\n        }\\n        for(int k=0;k<count;k++)\\n        {\\n            nums[i]=0;\\n            i++;\\n        }\\n    }\\n"
                    },
                    {
                        "username": "sHaan27",
                        "content": "class Solution {\\npublic:\\n    void moveZeroes(vector<int>& nums) {\\n        int i =0;\\n        for(int j =0;j<nums.size();j++)\\n        {\\n            if(nums[j] != 0)\\n            {\\n                swap(nums[j],nums[i]);\\n                i++;\\n            }\\n        }\\n    }\\n};"
                    },
                    {
                        "username": "artem_se_putem",
                        "content": "HA,  i am #1, it so easy to me. Common guys, you can do it. :3"
                    },
                    {
                        "username": "I_AM_JD",
                        "content": "# --------------------------------\\nclass Solution:\\n    def moveZeroes(self, nums: List[int]) -> None:\\n        \"\"\"\\n        Do not return anything, modify nums in-place instead.\\n        \"\"\"\\n        for key ,value in enumerate(nums):\\n          if value==0:\\n            nums.pop(key)\\n            nums.append(0)\\n\\nThis code is accepted fine\\n#---------------------------------------\\n\\n\\n\\nBut why this code not  accepted\\nclass Solution:\\n    def moveZeroes(self, nums: List[int]) -> None:\\n        \"\"\"\\n        Do not return anything, modify nums in-place instead.\\n        \"\"\"\\n        n=nums.count(0)\\n        nums = [x for x in nums if x!=0]\\n        zero = [0 for i in range(n)]\\n        nums=nums+zero\\n\\n        print(nums)\\n\\n\\n\\n\\n\\nAnyone please tell -------------------------------"
                    },
                    {
                        "username": "I_AM_JD",
                        "content": "[@nikhila01](/nikhila01)  Thanks bro now I understand"
                    },
                    {
                        "username": "nikhila01",
                        "content": "When you do `nums = nums + zero` you're not changing `nums` in place. You're creating a new list and assigning it to the local variable called `nums`. Once the function exits that change isn't visible.\n\nFirst, don't use the name `nums` when you're creating `[x for x in nums if x!=0]`. Give it another name like `nonzero`, otherwise you lose access to the original input list.\n\nThen try doing `nums[:] = nonzero + zero` which will actually copy the elements into `nums`. "
                    },
                    {
                        "username": "hari0911",
                        "content": "Easy solution check if number is not equal to 0 then swap with next number.\\nhttps://leetcode.com/problems/move-zeroes/solutions/3100334/easy-java-solution/"
                    }
                ]
            },
            {
                "id": 1783772,
                "content": [
                    {
                        "username": "SharmaAyush",
                        "content": "class Solution {\\npublic:\\n\\nvoid moveZeroes(vector<int>& nums) {\\n        int l=0,m=0;\\n        while(m<nums.size())\\n        {\\n            switch(nums[m])\\n            {\\n                case 0:\\n                    m++;\\n                    break;\\n                default:\\n                    swap(nums[l++],nums[m++]);\\n                    break;\\n            }\\n        }\\n        for(int i=0;i<nums.size();i++){\\n            cout<<nums[i]<<\" \";\\n        }\\n    }\\n\\n\\n\\n};"
                    },
                    {
                        "username": "SharmaAyush",
                        "content": "class Solution {\\npublic:\\n    void moveZeroes(vector<int>& nums) {\\n        int j =0;\\n    \\n    for(int i=0;i<nums.size();i++)\\n    {\\n        if(nums[i]!=0){\\n            \\n            swap(nums[i],nums[j]);\\n              j++;\\n        }\\n    } \\n    }\\n};"
                    },
                    {
                        "username": "amineguettaby",
                        "content": "the new index of the current element is the current index - total_zeros from that index to 0 \\n "
                    },
                    {
                        "username": "argulhane10246",
                        "content": "all you need is to read hint 3 times before solving this question.\\nSolve the question iteratively and then just change the new array declaration with the old array name that\\'s it"
                    },
                    {
                        "username": "starogre",
                        "content": "that doesn\\'t work, pretty sure that creates a new list and eats memory that the problem says you shouldn\\'t. the correct way is to modify only the original list"
                    },
                    {
                        "username": "taral_13",
                        "content": "Hint: Use one pointer at index(start) = 0\nand use a loop to traverse through the array and move non zero element to index (start)"
                    },
                    {
                        "username": "amineguettaby",
                        "content": "good idea"
                    },
                    {
                        "username": "Coder15091999",
                        "content": "Beat 100%  Java Solution\\n\\npublic void moveZeroes(int[] nums) {\\n        int count=0;\\n        for(int i=0;i<nums.length;i++)\\n        {\\n            if(nums[i]==0)\\n            {\\n                count++;\\n            }\\n        }\\n        int i=0;\\n        for(int j=0;j<nums.length;j++)\\n        {\\n            if(nums[j]!=0)\\n            {\\n                nums[i]=nums[j];\\n                i++;\\n            }\\n        }\\n        for(int k=0;k<count;k++)\\n        {\\n            nums[i]=0;\\n            i++;\\n        }\\n    }\\n"
                    },
                    {
                        "username": "sHaan27",
                        "content": "class Solution {\\npublic:\\n    void moveZeroes(vector<int>& nums) {\\n        int i =0;\\n        for(int j =0;j<nums.size();j++)\\n        {\\n            if(nums[j] != 0)\\n            {\\n                swap(nums[j],nums[i]);\\n                i++;\\n            }\\n        }\\n    }\\n};"
                    },
                    {
                        "username": "artem_se_putem",
                        "content": "HA,  i am #1, it so easy to me. Common guys, you can do it. :3"
                    },
                    {
                        "username": "I_AM_JD",
                        "content": "# --------------------------------\\nclass Solution:\\n    def moveZeroes(self, nums: List[int]) -> None:\\n        \"\"\"\\n        Do not return anything, modify nums in-place instead.\\n        \"\"\"\\n        for key ,value in enumerate(nums):\\n          if value==0:\\n            nums.pop(key)\\n            nums.append(0)\\n\\nThis code is accepted fine\\n#---------------------------------------\\n\\n\\n\\nBut why this code not  accepted\\nclass Solution:\\n    def moveZeroes(self, nums: List[int]) -> None:\\n        \"\"\"\\n        Do not return anything, modify nums in-place instead.\\n        \"\"\"\\n        n=nums.count(0)\\n        nums = [x for x in nums if x!=0]\\n        zero = [0 for i in range(n)]\\n        nums=nums+zero\\n\\n        print(nums)\\n\\n\\n\\n\\n\\nAnyone please tell -------------------------------"
                    },
                    {
                        "username": "I_AM_JD",
                        "content": "[@nikhila01](/nikhila01)  Thanks bro now I understand"
                    },
                    {
                        "username": "nikhila01",
                        "content": "When you do `nums = nums + zero` you're not changing `nums` in place. You're creating a new list and assigning it to the local variable called `nums`. Once the function exits that change isn't visible.\n\nFirst, don't use the name `nums` when you're creating `[x for x in nums if x!=0]`. Give it another name like `nonzero`, otherwise you lose access to the original input list.\n\nThen try doing `nums[:] = nonzero + zero` which will actually copy the elements into `nums`. "
                    },
                    {
                        "username": "hari0911",
                        "content": "Easy solution check if number is not equal to 0 then swap with next number.\\nhttps://leetcode.com/problems/move-zeroes/solutions/3100334/easy-java-solution/"
                    }
                ]
            },
            {
                "id": 1780798,
                "content": [
                    {
                        "username": "SharmaAyush",
                        "content": "class Solution {\\npublic:\\n\\nvoid moveZeroes(vector<int>& nums) {\\n        int l=0,m=0;\\n        while(m<nums.size())\\n        {\\n            switch(nums[m])\\n            {\\n                case 0:\\n                    m++;\\n                    break;\\n                default:\\n                    swap(nums[l++],nums[m++]);\\n                    break;\\n            }\\n        }\\n        for(int i=0;i<nums.size();i++){\\n            cout<<nums[i]<<\" \";\\n        }\\n    }\\n\\n\\n\\n};"
                    },
                    {
                        "username": "SharmaAyush",
                        "content": "class Solution {\\npublic:\\n    void moveZeroes(vector<int>& nums) {\\n        int j =0;\\n    \\n    for(int i=0;i<nums.size();i++)\\n    {\\n        if(nums[i]!=0){\\n            \\n            swap(nums[i],nums[j]);\\n              j++;\\n        }\\n    } \\n    }\\n};"
                    },
                    {
                        "username": "amineguettaby",
                        "content": "the new index of the current element is the current index - total_zeros from that index to 0 \\n "
                    },
                    {
                        "username": "argulhane10246",
                        "content": "all you need is to read hint 3 times before solving this question.\\nSolve the question iteratively and then just change the new array declaration with the old array name that\\'s it"
                    },
                    {
                        "username": "starogre",
                        "content": "that doesn\\'t work, pretty sure that creates a new list and eats memory that the problem says you shouldn\\'t. the correct way is to modify only the original list"
                    },
                    {
                        "username": "taral_13",
                        "content": "Hint: Use one pointer at index(start) = 0\nand use a loop to traverse through the array and move non zero element to index (start)"
                    },
                    {
                        "username": "amineguettaby",
                        "content": "good idea"
                    },
                    {
                        "username": "Coder15091999",
                        "content": "Beat 100%  Java Solution\\n\\npublic void moveZeroes(int[] nums) {\\n        int count=0;\\n        for(int i=0;i<nums.length;i++)\\n        {\\n            if(nums[i]==0)\\n            {\\n                count++;\\n            }\\n        }\\n        int i=0;\\n        for(int j=0;j<nums.length;j++)\\n        {\\n            if(nums[j]!=0)\\n            {\\n                nums[i]=nums[j];\\n                i++;\\n            }\\n        }\\n        for(int k=0;k<count;k++)\\n        {\\n            nums[i]=0;\\n            i++;\\n        }\\n    }\\n"
                    },
                    {
                        "username": "sHaan27",
                        "content": "class Solution {\\npublic:\\n    void moveZeroes(vector<int>& nums) {\\n        int i =0;\\n        for(int j =0;j<nums.size();j++)\\n        {\\n            if(nums[j] != 0)\\n            {\\n                swap(nums[j],nums[i]);\\n                i++;\\n            }\\n        }\\n    }\\n};"
                    },
                    {
                        "username": "artem_se_putem",
                        "content": "HA,  i am #1, it so easy to me. Common guys, you can do it. :3"
                    },
                    {
                        "username": "I_AM_JD",
                        "content": "# --------------------------------\\nclass Solution:\\n    def moveZeroes(self, nums: List[int]) -> None:\\n        \"\"\"\\n        Do not return anything, modify nums in-place instead.\\n        \"\"\"\\n        for key ,value in enumerate(nums):\\n          if value==0:\\n            nums.pop(key)\\n            nums.append(0)\\n\\nThis code is accepted fine\\n#---------------------------------------\\n\\n\\n\\nBut why this code not  accepted\\nclass Solution:\\n    def moveZeroes(self, nums: List[int]) -> None:\\n        \"\"\"\\n        Do not return anything, modify nums in-place instead.\\n        \"\"\"\\n        n=nums.count(0)\\n        nums = [x for x in nums if x!=0]\\n        zero = [0 for i in range(n)]\\n        nums=nums+zero\\n\\n        print(nums)\\n\\n\\n\\n\\n\\nAnyone please tell -------------------------------"
                    },
                    {
                        "username": "I_AM_JD",
                        "content": "[@nikhila01](/nikhila01)  Thanks bro now I understand"
                    },
                    {
                        "username": "nikhila01",
                        "content": "When you do `nums = nums + zero` you're not changing `nums` in place. You're creating a new list and assigning it to the local variable called `nums`. Once the function exits that change isn't visible.\n\nFirst, don't use the name `nums` when you're creating `[x for x in nums if x!=0]`. Give it another name like `nonzero`, otherwise you lose access to the original input list.\n\nThen try doing `nums[:] = nonzero + zero` which will actually copy the elements into `nums`. "
                    },
                    {
                        "username": "hari0911",
                        "content": "Easy solution check if number is not equal to 0 then swap with next number.\\nhttps://leetcode.com/problems/move-zeroes/solutions/3100334/easy-java-solution/"
                    }
                ]
            },
            {
                "id": 1774877,
                "content": [
                    {
                        "username": "SharmaAyush",
                        "content": "class Solution {\\npublic:\\n\\nvoid moveZeroes(vector<int>& nums) {\\n        int l=0,m=0;\\n        while(m<nums.size())\\n        {\\n            switch(nums[m])\\n            {\\n                case 0:\\n                    m++;\\n                    break;\\n                default:\\n                    swap(nums[l++],nums[m++]);\\n                    break;\\n            }\\n        }\\n        for(int i=0;i<nums.size();i++){\\n            cout<<nums[i]<<\" \";\\n        }\\n    }\\n\\n\\n\\n};"
                    },
                    {
                        "username": "SharmaAyush",
                        "content": "class Solution {\\npublic:\\n    void moveZeroes(vector<int>& nums) {\\n        int j =0;\\n    \\n    for(int i=0;i<nums.size();i++)\\n    {\\n        if(nums[i]!=0){\\n            \\n            swap(nums[i],nums[j]);\\n              j++;\\n        }\\n    } \\n    }\\n};"
                    },
                    {
                        "username": "amineguettaby",
                        "content": "the new index of the current element is the current index - total_zeros from that index to 0 \\n "
                    },
                    {
                        "username": "argulhane10246",
                        "content": "all you need is to read hint 3 times before solving this question.\\nSolve the question iteratively and then just change the new array declaration with the old array name that\\'s it"
                    },
                    {
                        "username": "starogre",
                        "content": "that doesn\\'t work, pretty sure that creates a new list and eats memory that the problem says you shouldn\\'t. the correct way is to modify only the original list"
                    },
                    {
                        "username": "taral_13",
                        "content": "Hint: Use one pointer at index(start) = 0\nand use a loop to traverse through the array and move non zero element to index (start)"
                    },
                    {
                        "username": "amineguettaby",
                        "content": "good idea"
                    },
                    {
                        "username": "Coder15091999",
                        "content": "Beat 100%  Java Solution\\n\\npublic void moveZeroes(int[] nums) {\\n        int count=0;\\n        for(int i=0;i<nums.length;i++)\\n        {\\n            if(nums[i]==0)\\n            {\\n                count++;\\n            }\\n        }\\n        int i=0;\\n        for(int j=0;j<nums.length;j++)\\n        {\\n            if(nums[j]!=0)\\n            {\\n                nums[i]=nums[j];\\n                i++;\\n            }\\n        }\\n        for(int k=0;k<count;k++)\\n        {\\n            nums[i]=0;\\n            i++;\\n        }\\n    }\\n"
                    },
                    {
                        "username": "sHaan27",
                        "content": "class Solution {\\npublic:\\n    void moveZeroes(vector<int>& nums) {\\n        int i =0;\\n        for(int j =0;j<nums.size();j++)\\n        {\\n            if(nums[j] != 0)\\n            {\\n                swap(nums[j],nums[i]);\\n                i++;\\n            }\\n        }\\n    }\\n};"
                    },
                    {
                        "username": "artem_se_putem",
                        "content": "HA,  i am #1, it so easy to me. Common guys, you can do it. :3"
                    },
                    {
                        "username": "I_AM_JD",
                        "content": "# --------------------------------\\nclass Solution:\\n    def moveZeroes(self, nums: List[int]) -> None:\\n        \"\"\"\\n        Do not return anything, modify nums in-place instead.\\n        \"\"\"\\n        for key ,value in enumerate(nums):\\n          if value==0:\\n            nums.pop(key)\\n            nums.append(0)\\n\\nThis code is accepted fine\\n#---------------------------------------\\n\\n\\n\\nBut why this code not  accepted\\nclass Solution:\\n    def moveZeroes(self, nums: List[int]) -> None:\\n        \"\"\"\\n        Do not return anything, modify nums in-place instead.\\n        \"\"\"\\n        n=nums.count(0)\\n        nums = [x for x in nums if x!=0]\\n        zero = [0 for i in range(n)]\\n        nums=nums+zero\\n\\n        print(nums)\\n\\n\\n\\n\\n\\nAnyone please tell -------------------------------"
                    },
                    {
                        "username": "I_AM_JD",
                        "content": "[@nikhila01](/nikhila01)  Thanks bro now I understand"
                    },
                    {
                        "username": "nikhila01",
                        "content": "When you do `nums = nums + zero` you're not changing `nums` in place. You're creating a new list and assigning it to the local variable called `nums`. Once the function exits that change isn't visible.\n\nFirst, don't use the name `nums` when you're creating `[x for x in nums if x!=0]`. Give it another name like `nonzero`, otherwise you lose access to the original input list.\n\nThen try doing `nums[:] = nonzero + zero` which will actually copy the elements into `nums`. "
                    },
                    {
                        "username": "hari0911",
                        "content": "Easy solution check if number is not equal to 0 then swap with next number.\\nhttps://leetcode.com/problems/move-zeroes/solutions/3100334/easy-java-solution/"
                    }
                ]
            },
            {
                "id": 1773119,
                "content": [
                    {
                        "username": "IMsherlocked",
                        "content": "Why this is getting wrong output( [0,1,0,3,12] ) for 1st test case.\nvar moveZeroes = function(nums) {\n        let zero = []\n        let nonZero = []\n        let k=0;\n    for(let i=0;i<nums.length;i++){\n        if(!nums[i]){\n          zero.push(0)\n        }else{\n            nonZero.push(nums[i])\n        }\n    }\n    return nonZero.concat(zero)\n};\nI tried this in js console and it was working there. "
                    },
                    {
                        "username": "LS_leet",
                        "content": "Similar like bubble sort method but bubble the 0 to the end.:\\nfor(int i=0;i<n;i++){\\n        for(int j=0;j<n;j++){\\n            if(nums[j]==0){\\n                swap(nums[j],nums[j+1]);\\n            }\\n        }\\n    }\\n"
                    },
                    {
                        "username": "imnischaygowda",
                        "content": "     \\nI tired using pop by index to remove zeroos and append 0 at last each time on popping.\\nBut my solution failed for,\\nnums = [0,1,0]\\nNot able to figure out why?\\nPlease let me know.\\n\\n `        # can i pop element based on index.\\n\\n        for i in range(len(nums)):\\n            # print(\\'ele\\', nums[i])\\n            if nums[i] == 0:\\n                del nums[i]\\n                # print(\\'pop\\', nums.pop(i))\\n                # print(\\'num\\', nums)\\n                nums.append(0).`  "
                    },
                    {
                        "username": "skiondwood",
                        "content": "TLDR:\na forward for-loop requires your i to increase by 1\nbut popping from the front affects the index of your elements\n\n\n\nwhen you pop the list from the beginning , it's length changes by -1, thereby changing the index of its elements \n(i.e. some element's index would decreases by 1 if an element preceding it was popped)\n\nbut at the same time you are running a for-loop where the loop's iteration index i is assumed to steadily increase by 1 per loop\n\ne.g.\nlet's assume I want to pop the i-th element in the following list, per each for-loop cycle:\n~~~\n\nlist = [0, 1, 2, 3, 4, 5]\n(0 is at index 0;\n 1 is at index 1;\n 2 is at index 2... etc.)\n\nrun a for-loop for i = 0, 1, 2, 3, 4, 5\nfor i in range(0,5):\n\nfirst loop; i = 0:\nlist.pop(i)\n(0 is popped)\nlist = [1, 2, 3, 4, 5]\n(note that 1 is now at index 0, when it was at index 1 previously; \nsame for all other numbers in the list; their index has shifted by -1)\n\nsecond loop; i = 1:\nlist.pop(i)\n(2 is popped)\nlist = [1, 3, 4, 5]\n(popping the 1-th element shifts the index of everything after it by -1)\n\nthird loop; i = 2:\nlist.pop(i)\n(4 is popped)\nlist = [1, 3, 5]\n\nfourth loop: i = 3:\nlist.pop(i)\n\n>> Error: index out of range\n(we can't pop an element in index 3\nwhen the list = [1, 3, 5] only has elements in index 0,1,2!)\n\n~~~~\nyour standard (forward) for-loop increases the i-index by 1 every cycle\nbut popping 'moves' your index back by 1 every cycle,\n\nso you are decreasing your index as i increases in each iteration of the for-loop, \ncausing them to go out-of-sync (and throw an index-out-of-range error, eventually)\n\nmeanwhile, you'll also be popping the elements at the wrong indexes!\n(in the example above, the originally intention was to pop every element, but I ended up popping every second element instead)\n\n\nsolution: \ntry using a for-loop that goes backward, starting from n-1 and ends at -1\n\nalternatively, you can implement a counter-variable that can be subtracted from your i to give you a 'true' index"
                    },
                    {
                        "username": "aayushmanarora",
                        "content": "class Solution {\\n    public void moveZeroes(int[] nums) {\\n        \\n\\n        int r=0;\\n        int l=0;\\n\\n        if(nums.length==0 || nums.length==1){\\n            return;\\n\\n        }\\n    \\n       while(r<nums.length){\\n           if(nums[r]==0){\\n               r++;\\n\\n           }\\n           else{\\n               int temp;\\n            temp=nums[r];\\n            nums[r]=nums[l];\\n             nums[l]=temp;\\n            l++;\\n            r++;\\n\\n\\n           }\\n       }\\n\\n    }\\n   \\n}"
                    },
                    {
                        "username": "mohamed_waseela",
                        "content": "https://youtu.be/-Qpk2XJ5XJQ"
                    },
                    {
                        "username": "Nitkapur30",
                        "content": "class Solution {\\npublic:\\n    void moveZeroes(vector<int>& nums) {\\n        int i,j;\\n        for(i=0,j=0;i<nums.size();){\\n            if(nums[i]!=0)\\n                {\\n                swap(nums[i],nums[j]);\\n                i++;\\n                j++;\\n               }\\n        }  \\n    }\\n};\\n "
                    },
                    {
                        "username": "silliconvally009",
                        "content": "can any find why it keep\\'s showing TLE error!\\nclass Solution {\\npublic:\\n    void moveZeroes(vector<int>& nums) {\\n        int i =0;\\n        \\n        while(i<nums.size()){\\n            int j = i+1;\\n            if(nums[j]!=0){\\n                swap(nums[i],nums[j]);\\n              i++;\\n              j++;\\n            }\\n         j++;\\n        }\\n    }\\n};"
                    },
                    {
                        "username": "Ravi_S_Kumar",
                        "content": " int i=0,j=1;\\n        while(j<nums.size()){\\n            if(nums[i] == 0 && nums[j]!=0){\\n                swap(nums[i],nums[j]);\\n                i++;\\n                j++;\\n            }\\n            if(nums[i] == 0 && nums[j]==0){\\n                j++;\\n            }\\n            if((nums[i] != 0 && nums[j]==0) || (nums[i] != 0 && nums[j]!=0)){\\n                i++;\\n                j++;\\n            }\\n        }\\n\\n\\nwhy is it showing runtime error?"
                    },
                    {
                        "username": "Rahul5914",
                        "content": "any other approach for this except two pointer"
                    },
                    {
                        "username": "305057174a",
                        "content": "why this is wrong??\\n\\nclass Solution:\\n    def moveZeroes(self, nums: List[int]) -> None:\\n        \"\"\"\\n        Do not return anything, modify nums in-place instead.\\n        \"\"\"\\n        a=[i for i in nums if i!=0]\\n        a.sort()\\n        b=[i for i in nums if i==0]\\n        for i in b:\\n         a.append(i)\\n        return a"
                    },
                    {
                        "username": "noobcoder09",
                        "content": "why are you sorting the array \\'a\\'? \\nAlso, question is about doing it in-place. Please correct me if I\\'m wrong. "
                    }
                ]
            },
            {
                "id": 1766589,
                "content": [
                    {
                        "username": "IMsherlocked",
                        "content": "Why this is getting wrong output( [0,1,0,3,12] ) for 1st test case.\nvar moveZeroes = function(nums) {\n        let zero = []\n        let nonZero = []\n        let k=0;\n    for(let i=0;i<nums.length;i++){\n        if(!nums[i]){\n          zero.push(0)\n        }else{\n            nonZero.push(nums[i])\n        }\n    }\n    return nonZero.concat(zero)\n};\nI tried this in js console and it was working there. "
                    },
                    {
                        "username": "LS_leet",
                        "content": "Similar like bubble sort method but bubble the 0 to the end.:\\nfor(int i=0;i<n;i++){\\n        for(int j=0;j<n;j++){\\n            if(nums[j]==0){\\n                swap(nums[j],nums[j+1]);\\n            }\\n        }\\n    }\\n"
                    },
                    {
                        "username": "imnischaygowda",
                        "content": "     \\nI tired using pop by index to remove zeroos and append 0 at last each time on popping.\\nBut my solution failed for,\\nnums = [0,1,0]\\nNot able to figure out why?\\nPlease let me know.\\n\\n `        # can i pop element based on index.\\n\\n        for i in range(len(nums)):\\n            # print(\\'ele\\', nums[i])\\n            if nums[i] == 0:\\n                del nums[i]\\n                # print(\\'pop\\', nums.pop(i))\\n                # print(\\'num\\', nums)\\n                nums.append(0).`  "
                    },
                    {
                        "username": "skiondwood",
                        "content": "TLDR:\na forward for-loop requires your i to increase by 1\nbut popping from the front affects the index of your elements\n\n\n\nwhen you pop the list from the beginning , it's length changes by -1, thereby changing the index of its elements \n(i.e. some element's index would decreases by 1 if an element preceding it was popped)\n\nbut at the same time you are running a for-loop where the loop's iteration index i is assumed to steadily increase by 1 per loop\n\ne.g.\nlet's assume I want to pop the i-th element in the following list, per each for-loop cycle:\n~~~\n\nlist = [0, 1, 2, 3, 4, 5]\n(0 is at index 0;\n 1 is at index 1;\n 2 is at index 2... etc.)\n\nrun a for-loop for i = 0, 1, 2, 3, 4, 5\nfor i in range(0,5):\n\nfirst loop; i = 0:\nlist.pop(i)\n(0 is popped)\nlist = [1, 2, 3, 4, 5]\n(note that 1 is now at index 0, when it was at index 1 previously; \nsame for all other numbers in the list; their index has shifted by -1)\n\nsecond loop; i = 1:\nlist.pop(i)\n(2 is popped)\nlist = [1, 3, 4, 5]\n(popping the 1-th element shifts the index of everything after it by -1)\n\nthird loop; i = 2:\nlist.pop(i)\n(4 is popped)\nlist = [1, 3, 5]\n\nfourth loop: i = 3:\nlist.pop(i)\n\n>> Error: index out of range\n(we can't pop an element in index 3\nwhen the list = [1, 3, 5] only has elements in index 0,1,2!)\n\n~~~~\nyour standard (forward) for-loop increases the i-index by 1 every cycle\nbut popping 'moves' your index back by 1 every cycle,\n\nso you are decreasing your index as i increases in each iteration of the for-loop, \ncausing them to go out-of-sync (and throw an index-out-of-range error, eventually)\n\nmeanwhile, you'll also be popping the elements at the wrong indexes!\n(in the example above, the originally intention was to pop every element, but I ended up popping every second element instead)\n\n\nsolution: \ntry using a for-loop that goes backward, starting from n-1 and ends at -1\n\nalternatively, you can implement a counter-variable that can be subtracted from your i to give you a 'true' index"
                    },
                    {
                        "username": "aayushmanarora",
                        "content": "class Solution {\\n    public void moveZeroes(int[] nums) {\\n        \\n\\n        int r=0;\\n        int l=0;\\n\\n        if(nums.length==0 || nums.length==1){\\n            return;\\n\\n        }\\n    \\n       while(r<nums.length){\\n           if(nums[r]==0){\\n               r++;\\n\\n           }\\n           else{\\n               int temp;\\n            temp=nums[r];\\n            nums[r]=nums[l];\\n             nums[l]=temp;\\n            l++;\\n            r++;\\n\\n\\n           }\\n       }\\n\\n    }\\n   \\n}"
                    },
                    {
                        "username": "mohamed_waseela",
                        "content": "https://youtu.be/-Qpk2XJ5XJQ"
                    },
                    {
                        "username": "Nitkapur30",
                        "content": "class Solution {\\npublic:\\n    void moveZeroes(vector<int>& nums) {\\n        int i,j;\\n        for(i=0,j=0;i<nums.size();){\\n            if(nums[i]!=0)\\n                {\\n                swap(nums[i],nums[j]);\\n                i++;\\n                j++;\\n               }\\n        }  \\n    }\\n};\\n "
                    },
                    {
                        "username": "silliconvally009",
                        "content": "can any find why it keep\\'s showing TLE error!\\nclass Solution {\\npublic:\\n    void moveZeroes(vector<int>& nums) {\\n        int i =0;\\n        \\n        while(i<nums.size()){\\n            int j = i+1;\\n            if(nums[j]!=0){\\n                swap(nums[i],nums[j]);\\n              i++;\\n              j++;\\n            }\\n         j++;\\n        }\\n    }\\n};"
                    },
                    {
                        "username": "Ravi_S_Kumar",
                        "content": " int i=0,j=1;\\n        while(j<nums.size()){\\n            if(nums[i] == 0 && nums[j]!=0){\\n                swap(nums[i],nums[j]);\\n                i++;\\n                j++;\\n            }\\n            if(nums[i] == 0 && nums[j]==0){\\n                j++;\\n            }\\n            if((nums[i] != 0 && nums[j]==0) || (nums[i] != 0 && nums[j]!=0)){\\n                i++;\\n                j++;\\n            }\\n        }\\n\\n\\nwhy is it showing runtime error?"
                    },
                    {
                        "username": "Rahul5914",
                        "content": "any other approach for this except two pointer"
                    },
                    {
                        "username": "305057174a",
                        "content": "why this is wrong??\\n\\nclass Solution:\\n    def moveZeroes(self, nums: List[int]) -> None:\\n        \"\"\"\\n        Do not return anything, modify nums in-place instead.\\n        \"\"\"\\n        a=[i for i in nums if i!=0]\\n        a.sort()\\n        b=[i for i in nums if i==0]\\n        for i in b:\\n         a.append(i)\\n        return a"
                    },
                    {
                        "username": "noobcoder09",
                        "content": "why are you sorting the array \\'a\\'? \\nAlso, question is about doing it in-place. Please correct me if I\\'m wrong. "
                    }
                ]
            },
            {
                "id": 1759321,
                "content": [
                    {
                        "username": "IMsherlocked",
                        "content": "Why this is getting wrong output( [0,1,0,3,12] ) for 1st test case.\nvar moveZeroes = function(nums) {\n        let zero = []\n        let nonZero = []\n        let k=0;\n    for(let i=0;i<nums.length;i++){\n        if(!nums[i]){\n          zero.push(0)\n        }else{\n            nonZero.push(nums[i])\n        }\n    }\n    return nonZero.concat(zero)\n};\nI tried this in js console and it was working there. "
                    },
                    {
                        "username": "LS_leet",
                        "content": "Similar like bubble sort method but bubble the 0 to the end.:\\nfor(int i=0;i<n;i++){\\n        for(int j=0;j<n;j++){\\n            if(nums[j]==0){\\n                swap(nums[j],nums[j+1]);\\n            }\\n        }\\n    }\\n"
                    },
                    {
                        "username": "imnischaygowda",
                        "content": "     \\nI tired using pop by index to remove zeroos and append 0 at last each time on popping.\\nBut my solution failed for,\\nnums = [0,1,0]\\nNot able to figure out why?\\nPlease let me know.\\n\\n `        # can i pop element based on index.\\n\\n        for i in range(len(nums)):\\n            # print(\\'ele\\', nums[i])\\n            if nums[i] == 0:\\n                del nums[i]\\n                # print(\\'pop\\', nums.pop(i))\\n                # print(\\'num\\', nums)\\n                nums.append(0).`  "
                    },
                    {
                        "username": "skiondwood",
                        "content": "TLDR:\na forward for-loop requires your i to increase by 1\nbut popping from the front affects the index of your elements\n\n\n\nwhen you pop the list from the beginning , it's length changes by -1, thereby changing the index of its elements \n(i.e. some element's index would decreases by 1 if an element preceding it was popped)\n\nbut at the same time you are running a for-loop where the loop's iteration index i is assumed to steadily increase by 1 per loop\n\ne.g.\nlet's assume I want to pop the i-th element in the following list, per each for-loop cycle:\n~~~\n\nlist = [0, 1, 2, 3, 4, 5]\n(0 is at index 0;\n 1 is at index 1;\n 2 is at index 2... etc.)\n\nrun a for-loop for i = 0, 1, 2, 3, 4, 5\nfor i in range(0,5):\n\nfirst loop; i = 0:\nlist.pop(i)\n(0 is popped)\nlist = [1, 2, 3, 4, 5]\n(note that 1 is now at index 0, when it was at index 1 previously; \nsame for all other numbers in the list; their index has shifted by -1)\n\nsecond loop; i = 1:\nlist.pop(i)\n(2 is popped)\nlist = [1, 3, 4, 5]\n(popping the 1-th element shifts the index of everything after it by -1)\n\nthird loop; i = 2:\nlist.pop(i)\n(4 is popped)\nlist = [1, 3, 5]\n\nfourth loop: i = 3:\nlist.pop(i)\n\n>> Error: index out of range\n(we can't pop an element in index 3\nwhen the list = [1, 3, 5] only has elements in index 0,1,2!)\n\n~~~~\nyour standard (forward) for-loop increases the i-index by 1 every cycle\nbut popping 'moves' your index back by 1 every cycle,\n\nso you are decreasing your index as i increases in each iteration of the for-loop, \ncausing them to go out-of-sync (and throw an index-out-of-range error, eventually)\n\nmeanwhile, you'll also be popping the elements at the wrong indexes!\n(in the example above, the originally intention was to pop every element, but I ended up popping every second element instead)\n\n\nsolution: \ntry using a for-loop that goes backward, starting from n-1 and ends at -1\n\nalternatively, you can implement a counter-variable that can be subtracted from your i to give you a 'true' index"
                    },
                    {
                        "username": "aayushmanarora",
                        "content": "class Solution {\\n    public void moveZeroes(int[] nums) {\\n        \\n\\n        int r=0;\\n        int l=0;\\n\\n        if(nums.length==0 || nums.length==1){\\n            return;\\n\\n        }\\n    \\n       while(r<nums.length){\\n           if(nums[r]==0){\\n               r++;\\n\\n           }\\n           else{\\n               int temp;\\n            temp=nums[r];\\n            nums[r]=nums[l];\\n             nums[l]=temp;\\n            l++;\\n            r++;\\n\\n\\n           }\\n       }\\n\\n    }\\n   \\n}"
                    },
                    {
                        "username": "mohamed_waseela",
                        "content": "https://youtu.be/-Qpk2XJ5XJQ"
                    },
                    {
                        "username": "Nitkapur30",
                        "content": "class Solution {\\npublic:\\n    void moveZeroes(vector<int>& nums) {\\n        int i,j;\\n        for(i=0,j=0;i<nums.size();){\\n            if(nums[i]!=0)\\n                {\\n                swap(nums[i],nums[j]);\\n                i++;\\n                j++;\\n               }\\n        }  \\n    }\\n};\\n "
                    },
                    {
                        "username": "silliconvally009",
                        "content": "can any find why it keep\\'s showing TLE error!\\nclass Solution {\\npublic:\\n    void moveZeroes(vector<int>& nums) {\\n        int i =0;\\n        \\n        while(i<nums.size()){\\n            int j = i+1;\\n            if(nums[j]!=0){\\n                swap(nums[i],nums[j]);\\n              i++;\\n              j++;\\n            }\\n         j++;\\n        }\\n    }\\n};"
                    },
                    {
                        "username": "Ravi_S_Kumar",
                        "content": " int i=0,j=1;\\n        while(j<nums.size()){\\n            if(nums[i] == 0 && nums[j]!=0){\\n                swap(nums[i],nums[j]);\\n                i++;\\n                j++;\\n            }\\n            if(nums[i] == 0 && nums[j]==0){\\n                j++;\\n            }\\n            if((nums[i] != 0 && nums[j]==0) || (nums[i] != 0 && nums[j]!=0)){\\n                i++;\\n                j++;\\n            }\\n        }\\n\\n\\nwhy is it showing runtime error?"
                    },
                    {
                        "username": "Rahul5914",
                        "content": "any other approach for this except two pointer"
                    },
                    {
                        "username": "305057174a",
                        "content": "why this is wrong??\\n\\nclass Solution:\\n    def moveZeroes(self, nums: List[int]) -> None:\\n        \"\"\"\\n        Do not return anything, modify nums in-place instead.\\n        \"\"\"\\n        a=[i for i in nums if i!=0]\\n        a.sort()\\n        b=[i for i in nums if i==0]\\n        for i in b:\\n         a.append(i)\\n        return a"
                    },
                    {
                        "username": "noobcoder09",
                        "content": "why are you sorting the array \\'a\\'? \\nAlso, question is about doing it in-place. Please correct me if I\\'m wrong. "
                    }
                ]
            },
            {
                "id": 1758004,
                "content": [
                    {
                        "username": "IMsherlocked",
                        "content": "Why this is getting wrong output( [0,1,0,3,12] ) for 1st test case.\nvar moveZeroes = function(nums) {\n        let zero = []\n        let nonZero = []\n        let k=0;\n    for(let i=0;i<nums.length;i++){\n        if(!nums[i]){\n          zero.push(0)\n        }else{\n            nonZero.push(nums[i])\n        }\n    }\n    return nonZero.concat(zero)\n};\nI tried this in js console and it was working there. "
                    },
                    {
                        "username": "LS_leet",
                        "content": "Similar like bubble sort method but bubble the 0 to the end.:\\nfor(int i=0;i<n;i++){\\n        for(int j=0;j<n;j++){\\n            if(nums[j]==0){\\n                swap(nums[j],nums[j+1]);\\n            }\\n        }\\n    }\\n"
                    },
                    {
                        "username": "imnischaygowda",
                        "content": "     \\nI tired using pop by index to remove zeroos and append 0 at last each time on popping.\\nBut my solution failed for,\\nnums = [0,1,0]\\nNot able to figure out why?\\nPlease let me know.\\n\\n `        # can i pop element based on index.\\n\\n        for i in range(len(nums)):\\n            # print(\\'ele\\', nums[i])\\n            if nums[i] == 0:\\n                del nums[i]\\n                # print(\\'pop\\', nums.pop(i))\\n                # print(\\'num\\', nums)\\n                nums.append(0).`  "
                    },
                    {
                        "username": "skiondwood",
                        "content": "TLDR:\na forward for-loop requires your i to increase by 1\nbut popping from the front affects the index of your elements\n\n\n\nwhen you pop the list from the beginning , it's length changes by -1, thereby changing the index of its elements \n(i.e. some element's index would decreases by 1 if an element preceding it was popped)\n\nbut at the same time you are running a for-loop where the loop's iteration index i is assumed to steadily increase by 1 per loop\n\ne.g.\nlet's assume I want to pop the i-th element in the following list, per each for-loop cycle:\n~~~\n\nlist = [0, 1, 2, 3, 4, 5]\n(0 is at index 0;\n 1 is at index 1;\n 2 is at index 2... etc.)\n\nrun a for-loop for i = 0, 1, 2, 3, 4, 5\nfor i in range(0,5):\n\nfirst loop; i = 0:\nlist.pop(i)\n(0 is popped)\nlist = [1, 2, 3, 4, 5]\n(note that 1 is now at index 0, when it was at index 1 previously; \nsame for all other numbers in the list; their index has shifted by -1)\n\nsecond loop; i = 1:\nlist.pop(i)\n(2 is popped)\nlist = [1, 3, 4, 5]\n(popping the 1-th element shifts the index of everything after it by -1)\n\nthird loop; i = 2:\nlist.pop(i)\n(4 is popped)\nlist = [1, 3, 5]\n\nfourth loop: i = 3:\nlist.pop(i)\n\n>> Error: index out of range\n(we can't pop an element in index 3\nwhen the list = [1, 3, 5] only has elements in index 0,1,2!)\n\n~~~~\nyour standard (forward) for-loop increases the i-index by 1 every cycle\nbut popping 'moves' your index back by 1 every cycle,\n\nso you are decreasing your index as i increases in each iteration of the for-loop, \ncausing them to go out-of-sync (and throw an index-out-of-range error, eventually)\n\nmeanwhile, you'll also be popping the elements at the wrong indexes!\n(in the example above, the originally intention was to pop every element, but I ended up popping every second element instead)\n\n\nsolution: \ntry using a for-loop that goes backward, starting from n-1 and ends at -1\n\nalternatively, you can implement a counter-variable that can be subtracted from your i to give you a 'true' index"
                    },
                    {
                        "username": "aayushmanarora",
                        "content": "class Solution {\\n    public void moveZeroes(int[] nums) {\\n        \\n\\n        int r=0;\\n        int l=0;\\n\\n        if(nums.length==0 || nums.length==1){\\n            return;\\n\\n        }\\n    \\n       while(r<nums.length){\\n           if(nums[r]==0){\\n               r++;\\n\\n           }\\n           else{\\n               int temp;\\n            temp=nums[r];\\n            nums[r]=nums[l];\\n             nums[l]=temp;\\n            l++;\\n            r++;\\n\\n\\n           }\\n       }\\n\\n    }\\n   \\n}"
                    },
                    {
                        "username": "mohamed_waseela",
                        "content": "https://youtu.be/-Qpk2XJ5XJQ"
                    },
                    {
                        "username": "Nitkapur30",
                        "content": "class Solution {\\npublic:\\n    void moveZeroes(vector<int>& nums) {\\n        int i,j;\\n        for(i=0,j=0;i<nums.size();){\\n            if(nums[i]!=0)\\n                {\\n                swap(nums[i],nums[j]);\\n                i++;\\n                j++;\\n               }\\n        }  \\n    }\\n};\\n "
                    },
                    {
                        "username": "silliconvally009",
                        "content": "can any find why it keep\\'s showing TLE error!\\nclass Solution {\\npublic:\\n    void moveZeroes(vector<int>& nums) {\\n        int i =0;\\n        \\n        while(i<nums.size()){\\n            int j = i+1;\\n            if(nums[j]!=0){\\n                swap(nums[i],nums[j]);\\n              i++;\\n              j++;\\n            }\\n         j++;\\n        }\\n    }\\n};"
                    },
                    {
                        "username": "Ravi_S_Kumar",
                        "content": " int i=0,j=1;\\n        while(j<nums.size()){\\n            if(nums[i] == 0 && nums[j]!=0){\\n                swap(nums[i],nums[j]);\\n                i++;\\n                j++;\\n            }\\n            if(nums[i] == 0 && nums[j]==0){\\n                j++;\\n            }\\n            if((nums[i] != 0 && nums[j]==0) || (nums[i] != 0 && nums[j]!=0)){\\n                i++;\\n                j++;\\n            }\\n        }\\n\\n\\nwhy is it showing runtime error?"
                    },
                    {
                        "username": "Rahul5914",
                        "content": "any other approach for this except two pointer"
                    },
                    {
                        "username": "305057174a",
                        "content": "why this is wrong??\\n\\nclass Solution:\\n    def moveZeroes(self, nums: List[int]) -> None:\\n        \"\"\"\\n        Do not return anything, modify nums in-place instead.\\n        \"\"\"\\n        a=[i for i in nums if i!=0]\\n        a.sort()\\n        b=[i for i in nums if i==0]\\n        for i in b:\\n         a.append(i)\\n        return a"
                    },
                    {
                        "username": "noobcoder09",
                        "content": "why are you sorting the array \\'a\\'? \\nAlso, question is about doing it in-place. Please correct me if I\\'m wrong. "
                    }
                ]
            },
            {
                "id": 1757561,
                "content": [
                    {
                        "username": "IMsherlocked",
                        "content": "Why this is getting wrong output( [0,1,0,3,12] ) for 1st test case.\nvar moveZeroes = function(nums) {\n        let zero = []\n        let nonZero = []\n        let k=0;\n    for(let i=0;i<nums.length;i++){\n        if(!nums[i]){\n          zero.push(0)\n        }else{\n            nonZero.push(nums[i])\n        }\n    }\n    return nonZero.concat(zero)\n};\nI tried this in js console and it was working there. "
                    },
                    {
                        "username": "LS_leet",
                        "content": "Similar like bubble sort method but bubble the 0 to the end.:\\nfor(int i=0;i<n;i++){\\n        for(int j=0;j<n;j++){\\n            if(nums[j]==0){\\n                swap(nums[j],nums[j+1]);\\n            }\\n        }\\n    }\\n"
                    },
                    {
                        "username": "imnischaygowda",
                        "content": "     \\nI tired using pop by index to remove zeroos and append 0 at last each time on popping.\\nBut my solution failed for,\\nnums = [0,1,0]\\nNot able to figure out why?\\nPlease let me know.\\n\\n `        # can i pop element based on index.\\n\\n        for i in range(len(nums)):\\n            # print(\\'ele\\', nums[i])\\n            if nums[i] == 0:\\n                del nums[i]\\n                # print(\\'pop\\', nums.pop(i))\\n                # print(\\'num\\', nums)\\n                nums.append(0).`  "
                    },
                    {
                        "username": "skiondwood",
                        "content": "TLDR:\na forward for-loop requires your i to increase by 1\nbut popping from the front affects the index of your elements\n\n\n\nwhen you pop the list from the beginning , it's length changes by -1, thereby changing the index of its elements \n(i.e. some element's index would decreases by 1 if an element preceding it was popped)\n\nbut at the same time you are running a for-loop where the loop's iteration index i is assumed to steadily increase by 1 per loop\n\ne.g.\nlet's assume I want to pop the i-th element in the following list, per each for-loop cycle:\n~~~\n\nlist = [0, 1, 2, 3, 4, 5]\n(0 is at index 0;\n 1 is at index 1;\n 2 is at index 2... etc.)\n\nrun a for-loop for i = 0, 1, 2, 3, 4, 5\nfor i in range(0,5):\n\nfirst loop; i = 0:\nlist.pop(i)\n(0 is popped)\nlist = [1, 2, 3, 4, 5]\n(note that 1 is now at index 0, when it was at index 1 previously; \nsame for all other numbers in the list; their index has shifted by -1)\n\nsecond loop; i = 1:\nlist.pop(i)\n(2 is popped)\nlist = [1, 3, 4, 5]\n(popping the 1-th element shifts the index of everything after it by -1)\n\nthird loop; i = 2:\nlist.pop(i)\n(4 is popped)\nlist = [1, 3, 5]\n\nfourth loop: i = 3:\nlist.pop(i)\n\n>> Error: index out of range\n(we can't pop an element in index 3\nwhen the list = [1, 3, 5] only has elements in index 0,1,2!)\n\n~~~~\nyour standard (forward) for-loop increases the i-index by 1 every cycle\nbut popping 'moves' your index back by 1 every cycle,\n\nso you are decreasing your index as i increases in each iteration of the for-loop, \ncausing them to go out-of-sync (and throw an index-out-of-range error, eventually)\n\nmeanwhile, you'll also be popping the elements at the wrong indexes!\n(in the example above, the originally intention was to pop every element, but I ended up popping every second element instead)\n\n\nsolution: \ntry using a for-loop that goes backward, starting from n-1 and ends at -1\n\nalternatively, you can implement a counter-variable that can be subtracted from your i to give you a 'true' index"
                    },
                    {
                        "username": "aayushmanarora",
                        "content": "class Solution {\\n    public void moveZeroes(int[] nums) {\\n        \\n\\n        int r=0;\\n        int l=0;\\n\\n        if(nums.length==0 || nums.length==1){\\n            return;\\n\\n        }\\n    \\n       while(r<nums.length){\\n           if(nums[r]==0){\\n               r++;\\n\\n           }\\n           else{\\n               int temp;\\n            temp=nums[r];\\n            nums[r]=nums[l];\\n             nums[l]=temp;\\n            l++;\\n            r++;\\n\\n\\n           }\\n       }\\n\\n    }\\n   \\n}"
                    },
                    {
                        "username": "mohamed_waseela",
                        "content": "https://youtu.be/-Qpk2XJ5XJQ"
                    },
                    {
                        "username": "Nitkapur30",
                        "content": "class Solution {\\npublic:\\n    void moveZeroes(vector<int>& nums) {\\n        int i,j;\\n        for(i=0,j=0;i<nums.size();){\\n            if(nums[i]!=0)\\n                {\\n                swap(nums[i],nums[j]);\\n                i++;\\n                j++;\\n               }\\n        }  \\n    }\\n};\\n "
                    },
                    {
                        "username": "silliconvally009",
                        "content": "can any find why it keep\\'s showing TLE error!\\nclass Solution {\\npublic:\\n    void moveZeroes(vector<int>& nums) {\\n        int i =0;\\n        \\n        while(i<nums.size()){\\n            int j = i+1;\\n            if(nums[j]!=0){\\n                swap(nums[i],nums[j]);\\n              i++;\\n              j++;\\n            }\\n         j++;\\n        }\\n    }\\n};"
                    },
                    {
                        "username": "Ravi_S_Kumar",
                        "content": " int i=0,j=1;\\n        while(j<nums.size()){\\n            if(nums[i] == 0 && nums[j]!=0){\\n                swap(nums[i],nums[j]);\\n                i++;\\n                j++;\\n            }\\n            if(nums[i] == 0 && nums[j]==0){\\n                j++;\\n            }\\n            if((nums[i] != 0 && nums[j]==0) || (nums[i] != 0 && nums[j]!=0)){\\n                i++;\\n                j++;\\n            }\\n        }\\n\\n\\nwhy is it showing runtime error?"
                    },
                    {
                        "username": "Rahul5914",
                        "content": "any other approach for this except two pointer"
                    },
                    {
                        "username": "305057174a",
                        "content": "why this is wrong??\\n\\nclass Solution:\\n    def moveZeroes(self, nums: List[int]) -> None:\\n        \"\"\"\\n        Do not return anything, modify nums in-place instead.\\n        \"\"\"\\n        a=[i for i in nums if i!=0]\\n        a.sort()\\n        b=[i for i in nums if i==0]\\n        for i in b:\\n         a.append(i)\\n        return a"
                    },
                    {
                        "username": "noobcoder09",
                        "content": "why are you sorting the array \\'a\\'? \\nAlso, question is about doing it in-place. Please correct me if I\\'m wrong. "
                    }
                ]
            },
            {
                "id": 1754559,
                "content": [
                    {
                        "username": "IMsherlocked",
                        "content": "Why this is getting wrong output( [0,1,0,3,12] ) for 1st test case.\nvar moveZeroes = function(nums) {\n        let zero = []\n        let nonZero = []\n        let k=0;\n    for(let i=0;i<nums.length;i++){\n        if(!nums[i]){\n          zero.push(0)\n        }else{\n            nonZero.push(nums[i])\n        }\n    }\n    return nonZero.concat(zero)\n};\nI tried this in js console and it was working there. "
                    },
                    {
                        "username": "LS_leet",
                        "content": "Similar like bubble sort method but bubble the 0 to the end.:\\nfor(int i=0;i<n;i++){\\n        for(int j=0;j<n;j++){\\n            if(nums[j]==0){\\n                swap(nums[j],nums[j+1]);\\n            }\\n        }\\n    }\\n"
                    },
                    {
                        "username": "imnischaygowda",
                        "content": "     \\nI tired using pop by index to remove zeroos and append 0 at last each time on popping.\\nBut my solution failed for,\\nnums = [0,1,0]\\nNot able to figure out why?\\nPlease let me know.\\n\\n `        # can i pop element based on index.\\n\\n        for i in range(len(nums)):\\n            # print(\\'ele\\', nums[i])\\n            if nums[i] == 0:\\n                del nums[i]\\n                # print(\\'pop\\', nums.pop(i))\\n                # print(\\'num\\', nums)\\n                nums.append(0).`  "
                    },
                    {
                        "username": "skiondwood",
                        "content": "TLDR:\na forward for-loop requires your i to increase by 1\nbut popping from the front affects the index of your elements\n\n\n\nwhen you pop the list from the beginning , it's length changes by -1, thereby changing the index of its elements \n(i.e. some element's index would decreases by 1 if an element preceding it was popped)\n\nbut at the same time you are running a for-loop where the loop's iteration index i is assumed to steadily increase by 1 per loop\n\ne.g.\nlet's assume I want to pop the i-th element in the following list, per each for-loop cycle:\n~~~\n\nlist = [0, 1, 2, 3, 4, 5]\n(0 is at index 0;\n 1 is at index 1;\n 2 is at index 2... etc.)\n\nrun a for-loop for i = 0, 1, 2, 3, 4, 5\nfor i in range(0,5):\n\nfirst loop; i = 0:\nlist.pop(i)\n(0 is popped)\nlist = [1, 2, 3, 4, 5]\n(note that 1 is now at index 0, when it was at index 1 previously; \nsame for all other numbers in the list; their index has shifted by -1)\n\nsecond loop; i = 1:\nlist.pop(i)\n(2 is popped)\nlist = [1, 3, 4, 5]\n(popping the 1-th element shifts the index of everything after it by -1)\n\nthird loop; i = 2:\nlist.pop(i)\n(4 is popped)\nlist = [1, 3, 5]\n\nfourth loop: i = 3:\nlist.pop(i)\n\n>> Error: index out of range\n(we can't pop an element in index 3\nwhen the list = [1, 3, 5] only has elements in index 0,1,2!)\n\n~~~~\nyour standard (forward) for-loop increases the i-index by 1 every cycle\nbut popping 'moves' your index back by 1 every cycle,\n\nso you are decreasing your index as i increases in each iteration of the for-loop, \ncausing them to go out-of-sync (and throw an index-out-of-range error, eventually)\n\nmeanwhile, you'll also be popping the elements at the wrong indexes!\n(in the example above, the originally intention was to pop every element, but I ended up popping every second element instead)\n\n\nsolution: \ntry using a for-loop that goes backward, starting from n-1 and ends at -1\n\nalternatively, you can implement a counter-variable that can be subtracted from your i to give you a 'true' index"
                    },
                    {
                        "username": "aayushmanarora",
                        "content": "class Solution {\\n    public void moveZeroes(int[] nums) {\\n        \\n\\n        int r=0;\\n        int l=0;\\n\\n        if(nums.length==0 || nums.length==1){\\n            return;\\n\\n        }\\n    \\n       while(r<nums.length){\\n           if(nums[r]==0){\\n               r++;\\n\\n           }\\n           else{\\n               int temp;\\n            temp=nums[r];\\n            nums[r]=nums[l];\\n             nums[l]=temp;\\n            l++;\\n            r++;\\n\\n\\n           }\\n       }\\n\\n    }\\n   \\n}"
                    },
                    {
                        "username": "mohamed_waseela",
                        "content": "https://youtu.be/-Qpk2XJ5XJQ"
                    },
                    {
                        "username": "Nitkapur30",
                        "content": "class Solution {\\npublic:\\n    void moveZeroes(vector<int>& nums) {\\n        int i,j;\\n        for(i=0,j=0;i<nums.size();){\\n            if(nums[i]!=0)\\n                {\\n                swap(nums[i],nums[j]);\\n                i++;\\n                j++;\\n               }\\n        }  \\n    }\\n};\\n "
                    },
                    {
                        "username": "silliconvally009",
                        "content": "can any find why it keep\\'s showing TLE error!\\nclass Solution {\\npublic:\\n    void moveZeroes(vector<int>& nums) {\\n        int i =0;\\n        \\n        while(i<nums.size()){\\n            int j = i+1;\\n            if(nums[j]!=0){\\n                swap(nums[i],nums[j]);\\n              i++;\\n              j++;\\n            }\\n         j++;\\n        }\\n    }\\n};"
                    },
                    {
                        "username": "Ravi_S_Kumar",
                        "content": " int i=0,j=1;\\n        while(j<nums.size()){\\n            if(nums[i] == 0 && nums[j]!=0){\\n                swap(nums[i],nums[j]);\\n                i++;\\n                j++;\\n            }\\n            if(nums[i] == 0 && nums[j]==0){\\n                j++;\\n            }\\n            if((nums[i] != 0 && nums[j]==0) || (nums[i] != 0 && nums[j]!=0)){\\n                i++;\\n                j++;\\n            }\\n        }\\n\\n\\nwhy is it showing runtime error?"
                    },
                    {
                        "username": "Rahul5914",
                        "content": "any other approach for this except two pointer"
                    },
                    {
                        "username": "305057174a",
                        "content": "why this is wrong??\\n\\nclass Solution:\\n    def moveZeroes(self, nums: List[int]) -> None:\\n        \"\"\"\\n        Do not return anything, modify nums in-place instead.\\n        \"\"\"\\n        a=[i for i in nums if i!=0]\\n        a.sort()\\n        b=[i for i in nums if i==0]\\n        for i in b:\\n         a.append(i)\\n        return a"
                    },
                    {
                        "username": "noobcoder09",
                        "content": "why are you sorting the array \\'a\\'? \\nAlso, question is about doing it in-place. Please correct me if I\\'m wrong. "
                    }
                ]
            },
            {
                "id": 1753587,
                "content": [
                    {
                        "username": "IMsherlocked",
                        "content": "Why this is getting wrong output( [0,1,0,3,12] ) for 1st test case.\nvar moveZeroes = function(nums) {\n        let zero = []\n        let nonZero = []\n        let k=0;\n    for(let i=0;i<nums.length;i++){\n        if(!nums[i]){\n          zero.push(0)\n        }else{\n            nonZero.push(nums[i])\n        }\n    }\n    return nonZero.concat(zero)\n};\nI tried this in js console and it was working there. "
                    },
                    {
                        "username": "LS_leet",
                        "content": "Similar like bubble sort method but bubble the 0 to the end.:\\nfor(int i=0;i<n;i++){\\n        for(int j=0;j<n;j++){\\n            if(nums[j]==0){\\n                swap(nums[j],nums[j+1]);\\n            }\\n        }\\n    }\\n"
                    },
                    {
                        "username": "imnischaygowda",
                        "content": "     \\nI tired using pop by index to remove zeroos and append 0 at last each time on popping.\\nBut my solution failed for,\\nnums = [0,1,0]\\nNot able to figure out why?\\nPlease let me know.\\n\\n `        # can i pop element based on index.\\n\\n        for i in range(len(nums)):\\n            # print(\\'ele\\', nums[i])\\n            if nums[i] == 0:\\n                del nums[i]\\n                # print(\\'pop\\', nums.pop(i))\\n                # print(\\'num\\', nums)\\n                nums.append(0).`  "
                    },
                    {
                        "username": "skiondwood",
                        "content": "TLDR:\na forward for-loop requires your i to increase by 1\nbut popping from the front affects the index of your elements\n\n\n\nwhen you pop the list from the beginning , it's length changes by -1, thereby changing the index of its elements \n(i.e. some element's index would decreases by 1 if an element preceding it was popped)\n\nbut at the same time you are running a for-loop where the loop's iteration index i is assumed to steadily increase by 1 per loop\n\ne.g.\nlet's assume I want to pop the i-th element in the following list, per each for-loop cycle:\n~~~\n\nlist = [0, 1, 2, 3, 4, 5]\n(0 is at index 0;\n 1 is at index 1;\n 2 is at index 2... etc.)\n\nrun a for-loop for i = 0, 1, 2, 3, 4, 5\nfor i in range(0,5):\n\nfirst loop; i = 0:\nlist.pop(i)\n(0 is popped)\nlist = [1, 2, 3, 4, 5]\n(note that 1 is now at index 0, when it was at index 1 previously; \nsame for all other numbers in the list; their index has shifted by -1)\n\nsecond loop; i = 1:\nlist.pop(i)\n(2 is popped)\nlist = [1, 3, 4, 5]\n(popping the 1-th element shifts the index of everything after it by -1)\n\nthird loop; i = 2:\nlist.pop(i)\n(4 is popped)\nlist = [1, 3, 5]\n\nfourth loop: i = 3:\nlist.pop(i)\n\n>> Error: index out of range\n(we can't pop an element in index 3\nwhen the list = [1, 3, 5] only has elements in index 0,1,2!)\n\n~~~~\nyour standard (forward) for-loop increases the i-index by 1 every cycle\nbut popping 'moves' your index back by 1 every cycle,\n\nso you are decreasing your index as i increases in each iteration of the for-loop, \ncausing them to go out-of-sync (and throw an index-out-of-range error, eventually)\n\nmeanwhile, you'll also be popping the elements at the wrong indexes!\n(in the example above, the originally intention was to pop every element, but I ended up popping every second element instead)\n\n\nsolution: \ntry using a for-loop that goes backward, starting from n-1 and ends at -1\n\nalternatively, you can implement a counter-variable that can be subtracted from your i to give you a 'true' index"
                    },
                    {
                        "username": "aayushmanarora",
                        "content": "class Solution {\\n    public void moveZeroes(int[] nums) {\\n        \\n\\n        int r=0;\\n        int l=0;\\n\\n        if(nums.length==0 || nums.length==1){\\n            return;\\n\\n        }\\n    \\n       while(r<nums.length){\\n           if(nums[r]==0){\\n               r++;\\n\\n           }\\n           else{\\n               int temp;\\n            temp=nums[r];\\n            nums[r]=nums[l];\\n             nums[l]=temp;\\n            l++;\\n            r++;\\n\\n\\n           }\\n       }\\n\\n    }\\n   \\n}"
                    },
                    {
                        "username": "mohamed_waseela",
                        "content": "https://youtu.be/-Qpk2XJ5XJQ"
                    },
                    {
                        "username": "Nitkapur30",
                        "content": "class Solution {\\npublic:\\n    void moveZeroes(vector<int>& nums) {\\n        int i,j;\\n        for(i=0,j=0;i<nums.size();){\\n            if(nums[i]!=0)\\n                {\\n                swap(nums[i],nums[j]);\\n                i++;\\n                j++;\\n               }\\n        }  \\n    }\\n};\\n "
                    },
                    {
                        "username": "silliconvally009",
                        "content": "can any find why it keep\\'s showing TLE error!\\nclass Solution {\\npublic:\\n    void moveZeroes(vector<int>& nums) {\\n        int i =0;\\n        \\n        while(i<nums.size()){\\n            int j = i+1;\\n            if(nums[j]!=0){\\n                swap(nums[i],nums[j]);\\n              i++;\\n              j++;\\n            }\\n         j++;\\n        }\\n    }\\n};"
                    },
                    {
                        "username": "Ravi_S_Kumar",
                        "content": " int i=0,j=1;\\n        while(j<nums.size()){\\n            if(nums[i] == 0 && nums[j]!=0){\\n                swap(nums[i],nums[j]);\\n                i++;\\n                j++;\\n            }\\n            if(nums[i] == 0 && nums[j]==0){\\n                j++;\\n            }\\n            if((nums[i] != 0 && nums[j]==0) || (nums[i] != 0 && nums[j]!=0)){\\n                i++;\\n                j++;\\n            }\\n        }\\n\\n\\nwhy is it showing runtime error?"
                    },
                    {
                        "username": "Rahul5914",
                        "content": "any other approach for this except two pointer"
                    },
                    {
                        "username": "305057174a",
                        "content": "why this is wrong??\\n\\nclass Solution:\\n    def moveZeroes(self, nums: List[int]) -> None:\\n        \"\"\"\\n        Do not return anything, modify nums in-place instead.\\n        \"\"\"\\n        a=[i for i in nums if i!=0]\\n        a.sort()\\n        b=[i for i in nums if i==0]\\n        for i in b:\\n         a.append(i)\\n        return a"
                    },
                    {
                        "username": "noobcoder09",
                        "content": "why are you sorting the array \\'a\\'? \\nAlso, question is about doing it in-place. Please correct me if I\\'m wrong. "
                    }
                ]
            },
            {
                "id": 1752531,
                "content": [
                    {
                        "username": "IMsherlocked",
                        "content": "Why this is getting wrong output( [0,1,0,3,12] ) for 1st test case.\nvar moveZeroes = function(nums) {\n        let zero = []\n        let nonZero = []\n        let k=0;\n    for(let i=0;i<nums.length;i++){\n        if(!nums[i]){\n          zero.push(0)\n        }else{\n            nonZero.push(nums[i])\n        }\n    }\n    return nonZero.concat(zero)\n};\nI tried this in js console and it was working there. "
                    },
                    {
                        "username": "LS_leet",
                        "content": "Similar like bubble sort method but bubble the 0 to the end.:\\nfor(int i=0;i<n;i++){\\n        for(int j=0;j<n;j++){\\n            if(nums[j]==0){\\n                swap(nums[j],nums[j+1]);\\n            }\\n        }\\n    }\\n"
                    },
                    {
                        "username": "imnischaygowda",
                        "content": "     \\nI tired using pop by index to remove zeroos and append 0 at last each time on popping.\\nBut my solution failed for,\\nnums = [0,1,0]\\nNot able to figure out why?\\nPlease let me know.\\n\\n `        # can i pop element based on index.\\n\\n        for i in range(len(nums)):\\n            # print(\\'ele\\', nums[i])\\n            if nums[i] == 0:\\n                del nums[i]\\n                # print(\\'pop\\', nums.pop(i))\\n                # print(\\'num\\', nums)\\n                nums.append(0).`  "
                    },
                    {
                        "username": "skiondwood",
                        "content": "TLDR:\na forward for-loop requires your i to increase by 1\nbut popping from the front affects the index of your elements\n\n\n\nwhen you pop the list from the beginning , it's length changes by -1, thereby changing the index of its elements \n(i.e. some element's index would decreases by 1 if an element preceding it was popped)\n\nbut at the same time you are running a for-loop where the loop's iteration index i is assumed to steadily increase by 1 per loop\n\ne.g.\nlet's assume I want to pop the i-th element in the following list, per each for-loop cycle:\n~~~\n\nlist = [0, 1, 2, 3, 4, 5]\n(0 is at index 0;\n 1 is at index 1;\n 2 is at index 2... etc.)\n\nrun a for-loop for i = 0, 1, 2, 3, 4, 5\nfor i in range(0,5):\n\nfirst loop; i = 0:\nlist.pop(i)\n(0 is popped)\nlist = [1, 2, 3, 4, 5]\n(note that 1 is now at index 0, when it was at index 1 previously; \nsame for all other numbers in the list; their index has shifted by -1)\n\nsecond loop; i = 1:\nlist.pop(i)\n(2 is popped)\nlist = [1, 3, 4, 5]\n(popping the 1-th element shifts the index of everything after it by -1)\n\nthird loop; i = 2:\nlist.pop(i)\n(4 is popped)\nlist = [1, 3, 5]\n\nfourth loop: i = 3:\nlist.pop(i)\n\n>> Error: index out of range\n(we can't pop an element in index 3\nwhen the list = [1, 3, 5] only has elements in index 0,1,2!)\n\n~~~~\nyour standard (forward) for-loop increases the i-index by 1 every cycle\nbut popping 'moves' your index back by 1 every cycle,\n\nso you are decreasing your index as i increases in each iteration of the for-loop, \ncausing them to go out-of-sync (and throw an index-out-of-range error, eventually)\n\nmeanwhile, you'll also be popping the elements at the wrong indexes!\n(in the example above, the originally intention was to pop every element, but I ended up popping every second element instead)\n\n\nsolution: \ntry using a for-loop that goes backward, starting from n-1 and ends at -1\n\nalternatively, you can implement a counter-variable that can be subtracted from your i to give you a 'true' index"
                    },
                    {
                        "username": "aayushmanarora",
                        "content": "class Solution {\\n    public void moveZeroes(int[] nums) {\\n        \\n\\n        int r=0;\\n        int l=0;\\n\\n        if(nums.length==0 || nums.length==1){\\n            return;\\n\\n        }\\n    \\n       while(r<nums.length){\\n           if(nums[r]==0){\\n               r++;\\n\\n           }\\n           else{\\n               int temp;\\n            temp=nums[r];\\n            nums[r]=nums[l];\\n             nums[l]=temp;\\n            l++;\\n            r++;\\n\\n\\n           }\\n       }\\n\\n    }\\n   \\n}"
                    },
                    {
                        "username": "mohamed_waseela",
                        "content": "https://youtu.be/-Qpk2XJ5XJQ"
                    },
                    {
                        "username": "Nitkapur30",
                        "content": "class Solution {\\npublic:\\n    void moveZeroes(vector<int>& nums) {\\n        int i,j;\\n        for(i=0,j=0;i<nums.size();){\\n            if(nums[i]!=0)\\n                {\\n                swap(nums[i],nums[j]);\\n                i++;\\n                j++;\\n               }\\n        }  \\n    }\\n};\\n "
                    },
                    {
                        "username": "silliconvally009",
                        "content": "can any find why it keep\\'s showing TLE error!\\nclass Solution {\\npublic:\\n    void moveZeroes(vector<int>& nums) {\\n        int i =0;\\n        \\n        while(i<nums.size()){\\n            int j = i+1;\\n            if(nums[j]!=0){\\n                swap(nums[i],nums[j]);\\n              i++;\\n              j++;\\n            }\\n         j++;\\n        }\\n    }\\n};"
                    },
                    {
                        "username": "Ravi_S_Kumar",
                        "content": " int i=0,j=1;\\n        while(j<nums.size()){\\n            if(nums[i] == 0 && nums[j]!=0){\\n                swap(nums[i],nums[j]);\\n                i++;\\n                j++;\\n            }\\n            if(nums[i] == 0 && nums[j]==0){\\n                j++;\\n            }\\n            if((nums[i] != 0 && nums[j]==0) || (nums[i] != 0 && nums[j]!=0)){\\n                i++;\\n                j++;\\n            }\\n        }\\n\\n\\nwhy is it showing runtime error?"
                    },
                    {
                        "username": "Rahul5914",
                        "content": "any other approach for this except two pointer"
                    },
                    {
                        "username": "305057174a",
                        "content": "why this is wrong??\\n\\nclass Solution:\\n    def moveZeroes(self, nums: List[int]) -> None:\\n        \"\"\"\\n        Do not return anything, modify nums in-place instead.\\n        \"\"\"\\n        a=[i for i in nums if i!=0]\\n        a.sort()\\n        b=[i for i in nums if i==0]\\n        for i in b:\\n         a.append(i)\\n        return a"
                    },
                    {
                        "username": "noobcoder09",
                        "content": "why are you sorting the array \\'a\\'? \\nAlso, question is about doing it in-place. Please correct me if I\\'m wrong. "
                    }
                ]
            },
            {
                "id": 1750735,
                "content": [
                    {
                        "username": "IMsherlocked",
                        "content": "Why this is getting wrong output( [0,1,0,3,12] ) for 1st test case.\nvar moveZeroes = function(nums) {\n        let zero = []\n        let nonZero = []\n        let k=0;\n    for(let i=0;i<nums.length;i++){\n        if(!nums[i]){\n          zero.push(0)\n        }else{\n            nonZero.push(nums[i])\n        }\n    }\n    return nonZero.concat(zero)\n};\nI tried this in js console and it was working there. "
                    },
                    {
                        "username": "LS_leet",
                        "content": "Similar like bubble sort method but bubble the 0 to the end.:\\nfor(int i=0;i<n;i++){\\n        for(int j=0;j<n;j++){\\n            if(nums[j]==0){\\n                swap(nums[j],nums[j+1]);\\n            }\\n        }\\n    }\\n"
                    },
                    {
                        "username": "imnischaygowda",
                        "content": "     \\nI tired using pop by index to remove zeroos and append 0 at last each time on popping.\\nBut my solution failed for,\\nnums = [0,1,0]\\nNot able to figure out why?\\nPlease let me know.\\n\\n `        # can i pop element based on index.\\n\\n        for i in range(len(nums)):\\n            # print(\\'ele\\', nums[i])\\n            if nums[i] == 0:\\n                del nums[i]\\n                # print(\\'pop\\', nums.pop(i))\\n                # print(\\'num\\', nums)\\n                nums.append(0).`  "
                    },
                    {
                        "username": "skiondwood",
                        "content": "TLDR:\na forward for-loop requires your i to increase by 1\nbut popping from the front affects the index of your elements\n\n\n\nwhen you pop the list from the beginning , it's length changes by -1, thereby changing the index of its elements \n(i.e. some element's index would decreases by 1 if an element preceding it was popped)\n\nbut at the same time you are running a for-loop where the loop's iteration index i is assumed to steadily increase by 1 per loop\n\ne.g.\nlet's assume I want to pop the i-th element in the following list, per each for-loop cycle:\n~~~\n\nlist = [0, 1, 2, 3, 4, 5]\n(0 is at index 0;\n 1 is at index 1;\n 2 is at index 2... etc.)\n\nrun a for-loop for i = 0, 1, 2, 3, 4, 5\nfor i in range(0,5):\n\nfirst loop; i = 0:\nlist.pop(i)\n(0 is popped)\nlist = [1, 2, 3, 4, 5]\n(note that 1 is now at index 0, when it was at index 1 previously; \nsame for all other numbers in the list; their index has shifted by -1)\n\nsecond loop; i = 1:\nlist.pop(i)\n(2 is popped)\nlist = [1, 3, 4, 5]\n(popping the 1-th element shifts the index of everything after it by -1)\n\nthird loop; i = 2:\nlist.pop(i)\n(4 is popped)\nlist = [1, 3, 5]\n\nfourth loop: i = 3:\nlist.pop(i)\n\n>> Error: index out of range\n(we can't pop an element in index 3\nwhen the list = [1, 3, 5] only has elements in index 0,1,2!)\n\n~~~~\nyour standard (forward) for-loop increases the i-index by 1 every cycle\nbut popping 'moves' your index back by 1 every cycle,\n\nso you are decreasing your index as i increases in each iteration of the for-loop, \ncausing them to go out-of-sync (and throw an index-out-of-range error, eventually)\n\nmeanwhile, you'll also be popping the elements at the wrong indexes!\n(in the example above, the originally intention was to pop every element, but I ended up popping every second element instead)\n\n\nsolution: \ntry using a for-loop that goes backward, starting from n-1 and ends at -1\n\nalternatively, you can implement a counter-variable that can be subtracted from your i to give you a 'true' index"
                    },
                    {
                        "username": "aayushmanarora",
                        "content": "class Solution {\\n    public void moveZeroes(int[] nums) {\\n        \\n\\n        int r=0;\\n        int l=0;\\n\\n        if(nums.length==0 || nums.length==1){\\n            return;\\n\\n        }\\n    \\n       while(r<nums.length){\\n           if(nums[r]==0){\\n               r++;\\n\\n           }\\n           else{\\n               int temp;\\n            temp=nums[r];\\n            nums[r]=nums[l];\\n             nums[l]=temp;\\n            l++;\\n            r++;\\n\\n\\n           }\\n       }\\n\\n    }\\n   \\n}"
                    },
                    {
                        "username": "mohamed_waseela",
                        "content": "https://youtu.be/-Qpk2XJ5XJQ"
                    },
                    {
                        "username": "Nitkapur30",
                        "content": "class Solution {\\npublic:\\n    void moveZeroes(vector<int>& nums) {\\n        int i,j;\\n        for(i=0,j=0;i<nums.size();){\\n            if(nums[i]!=0)\\n                {\\n                swap(nums[i],nums[j]);\\n                i++;\\n                j++;\\n               }\\n        }  \\n    }\\n};\\n "
                    },
                    {
                        "username": "silliconvally009",
                        "content": "can any find why it keep\\'s showing TLE error!\\nclass Solution {\\npublic:\\n    void moveZeroes(vector<int>& nums) {\\n        int i =0;\\n        \\n        while(i<nums.size()){\\n            int j = i+1;\\n            if(nums[j]!=0){\\n                swap(nums[i],nums[j]);\\n              i++;\\n              j++;\\n            }\\n         j++;\\n        }\\n    }\\n};"
                    },
                    {
                        "username": "Ravi_S_Kumar",
                        "content": " int i=0,j=1;\\n        while(j<nums.size()){\\n            if(nums[i] == 0 && nums[j]!=0){\\n                swap(nums[i],nums[j]);\\n                i++;\\n                j++;\\n            }\\n            if(nums[i] == 0 && nums[j]==0){\\n                j++;\\n            }\\n            if((nums[i] != 0 && nums[j]==0) || (nums[i] != 0 && nums[j]!=0)){\\n                i++;\\n                j++;\\n            }\\n        }\\n\\n\\nwhy is it showing runtime error?"
                    },
                    {
                        "username": "Rahul5914",
                        "content": "any other approach for this except two pointer"
                    },
                    {
                        "username": "305057174a",
                        "content": "why this is wrong??\\n\\nclass Solution:\\n    def moveZeroes(self, nums: List[int]) -> None:\\n        \"\"\"\\n        Do not return anything, modify nums in-place instead.\\n        \"\"\"\\n        a=[i for i in nums if i!=0]\\n        a.sort()\\n        b=[i for i in nums if i==0]\\n        for i in b:\\n         a.append(i)\\n        return a"
                    },
                    {
                        "username": "noobcoder09",
                        "content": "why are you sorting the array \\'a\\'? \\nAlso, question is about doing it in-place. Please correct me if I\\'m wrong. "
                    }
                ]
            },
            {
                "id": 1740546,
                "content": [
                    {
                        "username": "IMsherlocked",
                        "content": "Why this is getting wrong output( [0,1,0,3,12] ) for 1st test case.\nvar moveZeroes = function(nums) {\n        let zero = []\n        let nonZero = []\n        let k=0;\n    for(let i=0;i<nums.length;i++){\n        if(!nums[i]){\n          zero.push(0)\n        }else{\n            nonZero.push(nums[i])\n        }\n    }\n    return nonZero.concat(zero)\n};\nI tried this in js console and it was working there. "
                    },
                    {
                        "username": "LS_leet",
                        "content": "Similar like bubble sort method but bubble the 0 to the end.:\\nfor(int i=0;i<n;i++){\\n        for(int j=0;j<n;j++){\\n            if(nums[j]==0){\\n                swap(nums[j],nums[j+1]);\\n            }\\n        }\\n    }\\n"
                    },
                    {
                        "username": "imnischaygowda",
                        "content": "     \\nI tired using pop by index to remove zeroos and append 0 at last each time on popping.\\nBut my solution failed for,\\nnums = [0,1,0]\\nNot able to figure out why?\\nPlease let me know.\\n\\n `        # can i pop element based on index.\\n\\n        for i in range(len(nums)):\\n            # print(\\'ele\\', nums[i])\\n            if nums[i] == 0:\\n                del nums[i]\\n                # print(\\'pop\\', nums.pop(i))\\n                # print(\\'num\\', nums)\\n                nums.append(0).`  "
                    },
                    {
                        "username": "skiondwood",
                        "content": "TLDR:\na forward for-loop requires your i to increase by 1\nbut popping from the front affects the index of your elements\n\n\n\nwhen you pop the list from the beginning , it's length changes by -1, thereby changing the index of its elements \n(i.e. some element's index would decreases by 1 if an element preceding it was popped)\n\nbut at the same time you are running a for-loop where the loop's iteration index i is assumed to steadily increase by 1 per loop\n\ne.g.\nlet's assume I want to pop the i-th element in the following list, per each for-loop cycle:\n~~~\n\nlist = [0, 1, 2, 3, 4, 5]\n(0 is at index 0;\n 1 is at index 1;\n 2 is at index 2... etc.)\n\nrun a for-loop for i = 0, 1, 2, 3, 4, 5\nfor i in range(0,5):\n\nfirst loop; i = 0:\nlist.pop(i)\n(0 is popped)\nlist = [1, 2, 3, 4, 5]\n(note that 1 is now at index 0, when it was at index 1 previously; \nsame for all other numbers in the list; their index has shifted by -1)\n\nsecond loop; i = 1:\nlist.pop(i)\n(2 is popped)\nlist = [1, 3, 4, 5]\n(popping the 1-th element shifts the index of everything after it by -1)\n\nthird loop; i = 2:\nlist.pop(i)\n(4 is popped)\nlist = [1, 3, 5]\n\nfourth loop: i = 3:\nlist.pop(i)\n\n>> Error: index out of range\n(we can't pop an element in index 3\nwhen the list = [1, 3, 5] only has elements in index 0,1,2!)\n\n~~~~\nyour standard (forward) for-loop increases the i-index by 1 every cycle\nbut popping 'moves' your index back by 1 every cycle,\n\nso you are decreasing your index as i increases in each iteration of the for-loop, \ncausing them to go out-of-sync (and throw an index-out-of-range error, eventually)\n\nmeanwhile, you'll also be popping the elements at the wrong indexes!\n(in the example above, the originally intention was to pop every element, but I ended up popping every second element instead)\n\n\nsolution: \ntry using a for-loop that goes backward, starting from n-1 and ends at -1\n\nalternatively, you can implement a counter-variable that can be subtracted from your i to give you a 'true' index"
                    },
                    {
                        "username": "aayushmanarora",
                        "content": "class Solution {\\n    public void moveZeroes(int[] nums) {\\n        \\n\\n        int r=0;\\n        int l=0;\\n\\n        if(nums.length==0 || nums.length==1){\\n            return;\\n\\n        }\\n    \\n       while(r<nums.length){\\n           if(nums[r]==0){\\n               r++;\\n\\n           }\\n           else{\\n               int temp;\\n            temp=nums[r];\\n            nums[r]=nums[l];\\n             nums[l]=temp;\\n            l++;\\n            r++;\\n\\n\\n           }\\n       }\\n\\n    }\\n   \\n}"
                    },
                    {
                        "username": "mohamed_waseela",
                        "content": "https://youtu.be/-Qpk2XJ5XJQ"
                    },
                    {
                        "username": "Nitkapur30",
                        "content": "class Solution {\\npublic:\\n    void moveZeroes(vector<int>& nums) {\\n        int i,j;\\n        for(i=0,j=0;i<nums.size();){\\n            if(nums[i]!=0)\\n                {\\n                swap(nums[i],nums[j]);\\n                i++;\\n                j++;\\n               }\\n        }  \\n    }\\n};\\n "
                    },
                    {
                        "username": "silliconvally009",
                        "content": "can any find why it keep\\'s showing TLE error!\\nclass Solution {\\npublic:\\n    void moveZeroes(vector<int>& nums) {\\n        int i =0;\\n        \\n        while(i<nums.size()){\\n            int j = i+1;\\n            if(nums[j]!=0){\\n                swap(nums[i],nums[j]);\\n              i++;\\n              j++;\\n            }\\n         j++;\\n        }\\n    }\\n};"
                    },
                    {
                        "username": "Ravi_S_Kumar",
                        "content": " int i=0,j=1;\\n        while(j<nums.size()){\\n            if(nums[i] == 0 && nums[j]!=0){\\n                swap(nums[i],nums[j]);\\n                i++;\\n                j++;\\n            }\\n            if(nums[i] == 0 && nums[j]==0){\\n                j++;\\n            }\\n            if((nums[i] != 0 && nums[j]==0) || (nums[i] != 0 && nums[j]!=0)){\\n                i++;\\n                j++;\\n            }\\n        }\\n\\n\\nwhy is it showing runtime error?"
                    },
                    {
                        "username": "Rahul5914",
                        "content": "any other approach for this except two pointer"
                    },
                    {
                        "username": "305057174a",
                        "content": "why this is wrong??\\n\\nclass Solution:\\n    def moveZeroes(self, nums: List[int]) -> None:\\n        \"\"\"\\n        Do not return anything, modify nums in-place instead.\\n        \"\"\"\\n        a=[i for i in nums if i!=0]\\n        a.sort()\\n        b=[i for i in nums if i==0]\\n        for i in b:\\n         a.append(i)\\n        return a"
                    },
                    {
                        "username": "noobcoder09",
                        "content": "why are you sorting the array \\'a\\'? \\nAlso, question is about doing it in-place. Please correct me if I\\'m wrong. "
                    }
                ]
            },
            {
                "id": 1740158,
                "content": [
                    {
                        "username": "vermillion43015",
                        "content": "I'm a little curious as to why this code runs fine in Pycharm  no matter what array I throw at it but here it returns the wrong answer...\n\nclass Solution:\n    def moveZeroes(self, nums: List[int]) -> None:\n        return [nonZero for nonZero in nums if nonZero != 0] + \\\n            [Zero for Zero in nums if Zero == 0]"
                    },
                    {
                        "username": "Dezmond-sama",
                        "content": "You shouldn\\'t return anything. Just replace \"return [your array]\" with \"nums[:] = [your array]\" if you want to do it this way"
                    },
                    {
                        "username": "dotSlash-Adwitiya",
                        "content": "I don;t understand why the below code isn't working, its working on my machine for the same test cases its failing for in leetcode !\nThe first TC this below code failed for is : [0,1,1,0]\nBut the code runs perfectly for this same TC on my machine ! `\n\nvoid moveZeroes(vector<int> &nums)\n{\n  int left = 0, n = nums.size(), i = left + 1;\n  if (check(nums, n))\n    return;\n\n  while (i < n)\n  {\n    if (nums[i] != 0 && nums[left] != 0)\n    {\n      i++;\n      left++;\n    }\n    else if (nums[left] == 0 && nums[i] == 0)\n    {\n      while (nums[i] == 0 && i < n)\n      {\n        i++;\n      }\n      if (i < n)\n      {\n        swap(nums[i], nums[left]);\n        left++;\n        i++;\n      }\n    }\n\n    else if (nums[left] == 0 && nums[i] != 0)\n    {\n      swap(nums[left], nums[i]);\n      i++;\n      left++;\n    }\n    else\n    {\n      i++;\n      left++;\n    }\n  }\n}"
                    },
                    {
                        "username": "xAdvitya",
                        "content": "Double pointers makes this easy !"
                    },
                    {
                        "username": "Musaddik_Khan009",
                        "content": "class Solution {\\npublic:\\n    void moveZeroes(vector<int>& nums) {\\n    int i = 0;   // initialise first index \\n   for(int j = 0; j<nums.size(); j++){\\n       if(nums[j]  != 0){\\n           swap(nums[i] , nums[j]);\\n           i++;\\n       }\\n   }\\n\\n    }\\n};"
                    },
                    {
                        "username": "user0011s",
                        "content": "Hint 1 was extremely helpful in coming up with this approach. \\n\\nclass Solution {\\npublic void moveZeroes(int[] nums) {\\nint i = 0;\\nfor(int j = 0; j < nums.length; j++) {\\nif(nums[j] != 0) {\\nnums[i++] = nums[j];\\n}\\n}\\nwhile(i < nums.length) {\\nnums[i++] = 0;\\n}\\n}\\n}"
                    },
                    {
                        "username": "xanadoom",
                        "content": "let sol = [];\\n  for(let i = 0; i < nums.length; i++){\\n    if(nums[i] !== 0){\\n      sol.push(nums[i]);\\n    }\\n  }\\n   return sol.concat(nums.filter(x => x === 0));  \\n};\\ndont understand why my code dont work, whit nums = [0,1,0,3,12]; Output [0,1,0,3,12]; Expected [1,3,12,0,0].\\nSomeone have some advice why this code dont work?"
                    },
                    {
                        "username": "avalos010",
                        "content": "[@xanadoom](/xanadoom)  were supposed to modify the nums not return anything."
                    },
                    {
                        "username": "xanadoom",
                        "content": "var moveZeroes = function(nums) {\\n    return nums.filter(x => x !== 0).concat(nums.filter(x => x === 0))\\n};\\neven this code give same problem"
                    },
                    {
                        "username": "AnkushR10",
                        "content": "https://github.com/AnkushRawat10601/Leetcode/blob/main/283_move_zeroes.cpp"
                    },
                    {
                        "username": "devam25",
                        "content": "i am getting error in this code:\nclass Solution {\npublic:\n    void moveZeroes(vector<int>& nums) {\n     int a = nums.size()-1;\n     if(a<2) cout<<a;\n        for(int i=0; i<a; i++){\n            if(nums[i] == 0){\n                if(nums[a] != 0){\n                    swap(nums[a],nums[i]);\n                    a--;\n                }\n            }\n        }\n    }\n};"
                    },
                    {
                        "username": "omar22khaled",
                        "content": "This code runs well and get the right output on may local machine but when I uploaded it here, it got wrong answer. Could anyone explain why does this occur?\\n\\n`class Solution:`\\n`    def moveZeroes(self, nums: List[int]) -> None:`\\n`        nums = [i for i in nums if i !=0] + [i for i in nums if i == 0]`"
                    },
                    {
                        "username": "omar22khaled",
                        "content": "This code runs well and get the right output on may local machine but when I uploaded it here, it got wrong answer. Could anyone explain why does this occur?\\n\\n`class Solution:`\\n`    def moveZeroes(self, nums: List[int]) -> None:`\\n`        nums = [i for i in nums if i !=0] + [i for i in nums if i == 0]`"
                    },
                    {
                        "username": "anamika12b",
                        "content": "They don\\'t want you to change the first array at all. Here you are assigning another list to the initial input list"
                    }
                ]
            },
            {
                "id": 1736514,
                "content": [
                    {
                        "username": "vermillion43015",
                        "content": "I'm a little curious as to why this code runs fine in Pycharm  no matter what array I throw at it but here it returns the wrong answer...\n\nclass Solution:\n    def moveZeroes(self, nums: List[int]) -> None:\n        return [nonZero for nonZero in nums if nonZero != 0] + \\\n            [Zero for Zero in nums if Zero == 0]"
                    },
                    {
                        "username": "Dezmond-sama",
                        "content": "You shouldn\\'t return anything. Just replace \"return [your array]\" with \"nums[:] = [your array]\" if you want to do it this way"
                    },
                    {
                        "username": "dotSlash-Adwitiya",
                        "content": "I don;t understand why the below code isn't working, its working on my machine for the same test cases its failing for in leetcode !\nThe first TC this below code failed for is : [0,1,1,0]\nBut the code runs perfectly for this same TC on my machine ! `\n\nvoid moveZeroes(vector<int> &nums)\n{\n  int left = 0, n = nums.size(), i = left + 1;\n  if (check(nums, n))\n    return;\n\n  while (i < n)\n  {\n    if (nums[i] != 0 && nums[left] != 0)\n    {\n      i++;\n      left++;\n    }\n    else if (nums[left] == 0 && nums[i] == 0)\n    {\n      while (nums[i] == 0 && i < n)\n      {\n        i++;\n      }\n      if (i < n)\n      {\n        swap(nums[i], nums[left]);\n        left++;\n        i++;\n      }\n    }\n\n    else if (nums[left] == 0 && nums[i] != 0)\n    {\n      swap(nums[left], nums[i]);\n      i++;\n      left++;\n    }\n    else\n    {\n      i++;\n      left++;\n    }\n  }\n}"
                    },
                    {
                        "username": "xAdvitya",
                        "content": "Double pointers makes this easy !"
                    },
                    {
                        "username": "Musaddik_Khan009",
                        "content": "class Solution {\\npublic:\\n    void moveZeroes(vector<int>& nums) {\\n    int i = 0;   // initialise first index \\n   for(int j = 0; j<nums.size(); j++){\\n       if(nums[j]  != 0){\\n           swap(nums[i] , nums[j]);\\n           i++;\\n       }\\n   }\\n\\n    }\\n};"
                    },
                    {
                        "username": "user0011s",
                        "content": "Hint 1 was extremely helpful in coming up with this approach. \\n\\nclass Solution {\\npublic void moveZeroes(int[] nums) {\\nint i = 0;\\nfor(int j = 0; j < nums.length; j++) {\\nif(nums[j] != 0) {\\nnums[i++] = nums[j];\\n}\\n}\\nwhile(i < nums.length) {\\nnums[i++] = 0;\\n}\\n}\\n}"
                    },
                    {
                        "username": "xanadoom",
                        "content": "let sol = [];\\n  for(let i = 0; i < nums.length; i++){\\n    if(nums[i] !== 0){\\n      sol.push(nums[i]);\\n    }\\n  }\\n   return sol.concat(nums.filter(x => x === 0));  \\n};\\ndont understand why my code dont work, whit nums = [0,1,0,3,12]; Output [0,1,0,3,12]; Expected [1,3,12,0,0].\\nSomeone have some advice why this code dont work?"
                    },
                    {
                        "username": "avalos010",
                        "content": "[@xanadoom](/xanadoom)  were supposed to modify the nums not return anything."
                    },
                    {
                        "username": "xanadoom",
                        "content": "var moveZeroes = function(nums) {\\n    return nums.filter(x => x !== 0).concat(nums.filter(x => x === 0))\\n};\\neven this code give same problem"
                    },
                    {
                        "username": "AnkushR10",
                        "content": "https://github.com/AnkushRawat10601/Leetcode/blob/main/283_move_zeroes.cpp"
                    },
                    {
                        "username": "devam25",
                        "content": "i am getting error in this code:\nclass Solution {\npublic:\n    void moveZeroes(vector<int>& nums) {\n     int a = nums.size()-1;\n     if(a<2) cout<<a;\n        for(int i=0; i<a; i++){\n            if(nums[i] == 0){\n                if(nums[a] != 0){\n                    swap(nums[a],nums[i]);\n                    a--;\n                }\n            }\n        }\n    }\n};"
                    },
                    {
                        "username": "omar22khaled",
                        "content": "This code runs well and get the right output on may local machine but when I uploaded it here, it got wrong answer. Could anyone explain why does this occur?\\n\\n`class Solution:`\\n`    def moveZeroes(self, nums: List[int]) -> None:`\\n`        nums = [i for i in nums if i !=0] + [i for i in nums if i == 0]`"
                    },
                    {
                        "username": "omar22khaled",
                        "content": "This code runs well and get the right output on may local machine but when I uploaded it here, it got wrong answer. Could anyone explain why does this occur?\\n\\n`class Solution:`\\n`    def moveZeroes(self, nums: List[int]) -> None:`\\n`        nums = [i for i in nums if i !=0] + [i for i in nums if i == 0]`"
                    },
                    {
                        "username": "anamika12b",
                        "content": "They don\\'t want you to change the first array at all. Here you are assigning another list to the initial input list"
                    }
                ]
            },
            {
                "id": 1734277,
                "content": [
                    {
                        "username": "vermillion43015",
                        "content": "I'm a little curious as to why this code runs fine in Pycharm  no matter what array I throw at it but here it returns the wrong answer...\n\nclass Solution:\n    def moveZeroes(self, nums: List[int]) -> None:\n        return [nonZero for nonZero in nums if nonZero != 0] + \\\n            [Zero for Zero in nums if Zero == 0]"
                    },
                    {
                        "username": "Dezmond-sama",
                        "content": "You shouldn\\'t return anything. Just replace \"return [your array]\" with \"nums[:] = [your array]\" if you want to do it this way"
                    },
                    {
                        "username": "dotSlash-Adwitiya",
                        "content": "I don;t understand why the below code isn't working, its working on my machine for the same test cases its failing for in leetcode !\nThe first TC this below code failed for is : [0,1,1,0]\nBut the code runs perfectly for this same TC on my machine ! `\n\nvoid moveZeroes(vector<int> &nums)\n{\n  int left = 0, n = nums.size(), i = left + 1;\n  if (check(nums, n))\n    return;\n\n  while (i < n)\n  {\n    if (nums[i] != 0 && nums[left] != 0)\n    {\n      i++;\n      left++;\n    }\n    else if (nums[left] == 0 && nums[i] == 0)\n    {\n      while (nums[i] == 0 && i < n)\n      {\n        i++;\n      }\n      if (i < n)\n      {\n        swap(nums[i], nums[left]);\n        left++;\n        i++;\n      }\n    }\n\n    else if (nums[left] == 0 && nums[i] != 0)\n    {\n      swap(nums[left], nums[i]);\n      i++;\n      left++;\n    }\n    else\n    {\n      i++;\n      left++;\n    }\n  }\n}"
                    },
                    {
                        "username": "xAdvitya",
                        "content": "Double pointers makes this easy !"
                    },
                    {
                        "username": "Musaddik_Khan009",
                        "content": "class Solution {\\npublic:\\n    void moveZeroes(vector<int>& nums) {\\n    int i = 0;   // initialise first index \\n   for(int j = 0; j<nums.size(); j++){\\n       if(nums[j]  != 0){\\n           swap(nums[i] , nums[j]);\\n           i++;\\n       }\\n   }\\n\\n    }\\n};"
                    },
                    {
                        "username": "user0011s",
                        "content": "Hint 1 was extremely helpful in coming up with this approach. \\n\\nclass Solution {\\npublic void moveZeroes(int[] nums) {\\nint i = 0;\\nfor(int j = 0; j < nums.length; j++) {\\nif(nums[j] != 0) {\\nnums[i++] = nums[j];\\n}\\n}\\nwhile(i < nums.length) {\\nnums[i++] = 0;\\n}\\n}\\n}"
                    },
                    {
                        "username": "xanadoom",
                        "content": "let sol = [];\\n  for(let i = 0; i < nums.length; i++){\\n    if(nums[i] !== 0){\\n      sol.push(nums[i]);\\n    }\\n  }\\n   return sol.concat(nums.filter(x => x === 0));  \\n};\\ndont understand why my code dont work, whit nums = [0,1,0,3,12]; Output [0,1,0,3,12]; Expected [1,3,12,0,0].\\nSomeone have some advice why this code dont work?"
                    },
                    {
                        "username": "avalos010",
                        "content": "[@xanadoom](/xanadoom)  were supposed to modify the nums not return anything."
                    },
                    {
                        "username": "xanadoom",
                        "content": "var moveZeroes = function(nums) {\\n    return nums.filter(x => x !== 0).concat(nums.filter(x => x === 0))\\n};\\neven this code give same problem"
                    },
                    {
                        "username": "AnkushR10",
                        "content": "https://github.com/AnkushRawat10601/Leetcode/blob/main/283_move_zeroes.cpp"
                    },
                    {
                        "username": "devam25",
                        "content": "i am getting error in this code:\nclass Solution {\npublic:\n    void moveZeroes(vector<int>& nums) {\n     int a = nums.size()-1;\n     if(a<2) cout<<a;\n        for(int i=0; i<a; i++){\n            if(nums[i] == 0){\n                if(nums[a] != 0){\n                    swap(nums[a],nums[i]);\n                    a--;\n                }\n            }\n        }\n    }\n};"
                    },
                    {
                        "username": "omar22khaled",
                        "content": "This code runs well and get the right output on may local machine but when I uploaded it here, it got wrong answer. Could anyone explain why does this occur?\\n\\n`class Solution:`\\n`    def moveZeroes(self, nums: List[int]) -> None:`\\n`        nums = [i for i in nums if i !=0] + [i for i in nums if i == 0]`"
                    },
                    {
                        "username": "omar22khaled",
                        "content": "This code runs well and get the right output on may local machine but when I uploaded it here, it got wrong answer. Could anyone explain why does this occur?\\n\\n`class Solution:`\\n`    def moveZeroes(self, nums: List[int]) -> None:`\\n`        nums = [i for i in nums if i !=0] + [i for i in nums if i == 0]`"
                    },
                    {
                        "username": "anamika12b",
                        "content": "They don\\'t want you to change the first array at all. Here you are assigning another list to the initial input list"
                    }
                ]
            },
            {
                "id": 1729226,
                "content": [
                    {
                        "username": "vermillion43015",
                        "content": "I'm a little curious as to why this code runs fine in Pycharm  no matter what array I throw at it but here it returns the wrong answer...\n\nclass Solution:\n    def moveZeroes(self, nums: List[int]) -> None:\n        return [nonZero for nonZero in nums if nonZero != 0] + \\\n            [Zero for Zero in nums if Zero == 0]"
                    },
                    {
                        "username": "Dezmond-sama",
                        "content": "You shouldn\\'t return anything. Just replace \"return [your array]\" with \"nums[:] = [your array]\" if you want to do it this way"
                    },
                    {
                        "username": "dotSlash-Adwitiya",
                        "content": "I don;t understand why the below code isn't working, its working on my machine for the same test cases its failing for in leetcode !\nThe first TC this below code failed for is : [0,1,1,0]\nBut the code runs perfectly for this same TC on my machine ! `\n\nvoid moveZeroes(vector<int> &nums)\n{\n  int left = 0, n = nums.size(), i = left + 1;\n  if (check(nums, n))\n    return;\n\n  while (i < n)\n  {\n    if (nums[i] != 0 && nums[left] != 0)\n    {\n      i++;\n      left++;\n    }\n    else if (nums[left] == 0 && nums[i] == 0)\n    {\n      while (nums[i] == 0 && i < n)\n      {\n        i++;\n      }\n      if (i < n)\n      {\n        swap(nums[i], nums[left]);\n        left++;\n        i++;\n      }\n    }\n\n    else if (nums[left] == 0 && nums[i] != 0)\n    {\n      swap(nums[left], nums[i]);\n      i++;\n      left++;\n    }\n    else\n    {\n      i++;\n      left++;\n    }\n  }\n}"
                    },
                    {
                        "username": "xAdvitya",
                        "content": "Double pointers makes this easy !"
                    },
                    {
                        "username": "Musaddik_Khan009",
                        "content": "class Solution {\\npublic:\\n    void moveZeroes(vector<int>& nums) {\\n    int i = 0;   // initialise first index \\n   for(int j = 0; j<nums.size(); j++){\\n       if(nums[j]  != 0){\\n           swap(nums[i] , nums[j]);\\n           i++;\\n       }\\n   }\\n\\n    }\\n};"
                    },
                    {
                        "username": "user0011s",
                        "content": "Hint 1 was extremely helpful in coming up with this approach. \\n\\nclass Solution {\\npublic void moveZeroes(int[] nums) {\\nint i = 0;\\nfor(int j = 0; j < nums.length; j++) {\\nif(nums[j] != 0) {\\nnums[i++] = nums[j];\\n}\\n}\\nwhile(i < nums.length) {\\nnums[i++] = 0;\\n}\\n}\\n}"
                    },
                    {
                        "username": "xanadoom",
                        "content": "let sol = [];\\n  for(let i = 0; i < nums.length; i++){\\n    if(nums[i] !== 0){\\n      sol.push(nums[i]);\\n    }\\n  }\\n   return sol.concat(nums.filter(x => x === 0));  \\n};\\ndont understand why my code dont work, whit nums = [0,1,0,3,12]; Output [0,1,0,3,12]; Expected [1,3,12,0,0].\\nSomeone have some advice why this code dont work?"
                    },
                    {
                        "username": "avalos010",
                        "content": "[@xanadoom](/xanadoom)  were supposed to modify the nums not return anything."
                    },
                    {
                        "username": "xanadoom",
                        "content": "var moveZeroes = function(nums) {\\n    return nums.filter(x => x !== 0).concat(nums.filter(x => x === 0))\\n};\\neven this code give same problem"
                    },
                    {
                        "username": "AnkushR10",
                        "content": "https://github.com/AnkushRawat10601/Leetcode/blob/main/283_move_zeroes.cpp"
                    },
                    {
                        "username": "devam25",
                        "content": "i am getting error in this code:\nclass Solution {\npublic:\n    void moveZeroes(vector<int>& nums) {\n     int a = nums.size()-1;\n     if(a<2) cout<<a;\n        for(int i=0; i<a; i++){\n            if(nums[i] == 0){\n                if(nums[a] != 0){\n                    swap(nums[a],nums[i]);\n                    a--;\n                }\n            }\n        }\n    }\n};"
                    },
                    {
                        "username": "omar22khaled",
                        "content": "This code runs well and get the right output on may local machine but when I uploaded it here, it got wrong answer. Could anyone explain why does this occur?\\n\\n`class Solution:`\\n`    def moveZeroes(self, nums: List[int]) -> None:`\\n`        nums = [i for i in nums if i !=0] + [i for i in nums if i == 0]`"
                    },
                    {
                        "username": "omar22khaled",
                        "content": "This code runs well and get the right output on may local machine but when I uploaded it here, it got wrong answer. Could anyone explain why does this occur?\\n\\n`class Solution:`\\n`    def moveZeroes(self, nums: List[int]) -> None:`\\n`        nums = [i for i in nums if i !=0] + [i for i in nums if i == 0]`"
                    },
                    {
                        "username": "anamika12b",
                        "content": "They don\\'t want you to change the first array at all. Here you are assigning another list to the initial input list"
                    }
                ]
            },
            {
                "id": 1728561,
                "content": [
                    {
                        "username": "vermillion43015",
                        "content": "I'm a little curious as to why this code runs fine in Pycharm  no matter what array I throw at it but here it returns the wrong answer...\n\nclass Solution:\n    def moveZeroes(self, nums: List[int]) -> None:\n        return [nonZero for nonZero in nums if nonZero != 0] + \\\n            [Zero for Zero in nums if Zero == 0]"
                    },
                    {
                        "username": "Dezmond-sama",
                        "content": "You shouldn\\'t return anything. Just replace \"return [your array]\" with \"nums[:] = [your array]\" if you want to do it this way"
                    },
                    {
                        "username": "dotSlash-Adwitiya",
                        "content": "I don;t understand why the below code isn't working, its working on my machine for the same test cases its failing for in leetcode !\nThe first TC this below code failed for is : [0,1,1,0]\nBut the code runs perfectly for this same TC on my machine ! `\n\nvoid moveZeroes(vector<int> &nums)\n{\n  int left = 0, n = nums.size(), i = left + 1;\n  if (check(nums, n))\n    return;\n\n  while (i < n)\n  {\n    if (nums[i] != 0 && nums[left] != 0)\n    {\n      i++;\n      left++;\n    }\n    else if (nums[left] == 0 && nums[i] == 0)\n    {\n      while (nums[i] == 0 && i < n)\n      {\n        i++;\n      }\n      if (i < n)\n      {\n        swap(nums[i], nums[left]);\n        left++;\n        i++;\n      }\n    }\n\n    else if (nums[left] == 0 && nums[i] != 0)\n    {\n      swap(nums[left], nums[i]);\n      i++;\n      left++;\n    }\n    else\n    {\n      i++;\n      left++;\n    }\n  }\n}"
                    },
                    {
                        "username": "xAdvitya",
                        "content": "Double pointers makes this easy !"
                    },
                    {
                        "username": "Musaddik_Khan009",
                        "content": "class Solution {\\npublic:\\n    void moveZeroes(vector<int>& nums) {\\n    int i = 0;   // initialise first index \\n   for(int j = 0; j<nums.size(); j++){\\n       if(nums[j]  != 0){\\n           swap(nums[i] , nums[j]);\\n           i++;\\n       }\\n   }\\n\\n    }\\n};"
                    },
                    {
                        "username": "user0011s",
                        "content": "Hint 1 was extremely helpful in coming up with this approach. \\n\\nclass Solution {\\npublic void moveZeroes(int[] nums) {\\nint i = 0;\\nfor(int j = 0; j < nums.length; j++) {\\nif(nums[j] != 0) {\\nnums[i++] = nums[j];\\n}\\n}\\nwhile(i < nums.length) {\\nnums[i++] = 0;\\n}\\n}\\n}"
                    },
                    {
                        "username": "xanadoom",
                        "content": "let sol = [];\\n  for(let i = 0; i < nums.length; i++){\\n    if(nums[i] !== 0){\\n      sol.push(nums[i]);\\n    }\\n  }\\n   return sol.concat(nums.filter(x => x === 0));  \\n};\\ndont understand why my code dont work, whit nums = [0,1,0,3,12]; Output [0,1,0,3,12]; Expected [1,3,12,0,0].\\nSomeone have some advice why this code dont work?"
                    },
                    {
                        "username": "avalos010",
                        "content": "[@xanadoom](/xanadoom)  were supposed to modify the nums not return anything."
                    },
                    {
                        "username": "xanadoom",
                        "content": "var moveZeroes = function(nums) {\\n    return nums.filter(x => x !== 0).concat(nums.filter(x => x === 0))\\n};\\neven this code give same problem"
                    },
                    {
                        "username": "AnkushR10",
                        "content": "https://github.com/AnkushRawat10601/Leetcode/blob/main/283_move_zeroes.cpp"
                    },
                    {
                        "username": "devam25",
                        "content": "i am getting error in this code:\nclass Solution {\npublic:\n    void moveZeroes(vector<int>& nums) {\n     int a = nums.size()-1;\n     if(a<2) cout<<a;\n        for(int i=0; i<a; i++){\n            if(nums[i] == 0){\n                if(nums[a] != 0){\n                    swap(nums[a],nums[i]);\n                    a--;\n                }\n            }\n        }\n    }\n};"
                    },
                    {
                        "username": "omar22khaled",
                        "content": "This code runs well and get the right output on may local machine but when I uploaded it here, it got wrong answer. Could anyone explain why does this occur?\\n\\n`class Solution:`\\n`    def moveZeroes(self, nums: List[int]) -> None:`\\n`        nums = [i for i in nums if i !=0] + [i for i in nums if i == 0]`"
                    },
                    {
                        "username": "omar22khaled",
                        "content": "This code runs well and get the right output on may local machine but when I uploaded it here, it got wrong answer. Could anyone explain why does this occur?\\n\\n`class Solution:`\\n`    def moveZeroes(self, nums: List[int]) -> None:`\\n`        nums = [i for i in nums if i !=0] + [i for i in nums if i == 0]`"
                    },
                    {
                        "username": "anamika12b",
                        "content": "They don\\'t want you to change the first array at all. Here you are assigning another list to the initial input list"
                    }
                ]
            },
            {
                "id": 1724337,
                "content": [
                    {
                        "username": "vermillion43015",
                        "content": "I'm a little curious as to why this code runs fine in Pycharm  no matter what array I throw at it but here it returns the wrong answer...\n\nclass Solution:\n    def moveZeroes(self, nums: List[int]) -> None:\n        return [nonZero for nonZero in nums if nonZero != 0] + \\\n            [Zero for Zero in nums if Zero == 0]"
                    },
                    {
                        "username": "Dezmond-sama",
                        "content": "You shouldn\\'t return anything. Just replace \"return [your array]\" with \"nums[:] = [your array]\" if you want to do it this way"
                    },
                    {
                        "username": "dotSlash-Adwitiya",
                        "content": "I don;t understand why the below code isn't working, its working on my machine for the same test cases its failing for in leetcode !\nThe first TC this below code failed for is : [0,1,1,0]\nBut the code runs perfectly for this same TC on my machine ! `\n\nvoid moveZeroes(vector<int> &nums)\n{\n  int left = 0, n = nums.size(), i = left + 1;\n  if (check(nums, n))\n    return;\n\n  while (i < n)\n  {\n    if (nums[i] != 0 && nums[left] != 0)\n    {\n      i++;\n      left++;\n    }\n    else if (nums[left] == 0 && nums[i] == 0)\n    {\n      while (nums[i] == 0 && i < n)\n      {\n        i++;\n      }\n      if (i < n)\n      {\n        swap(nums[i], nums[left]);\n        left++;\n        i++;\n      }\n    }\n\n    else if (nums[left] == 0 && nums[i] != 0)\n    {\n      swap(nums[left], nums[i]);\n      i++;\n      left++;\n    }\n    else\n    {\n      i++;\n      left++;\n    }\n  }\n}"
                    },
                    {
                        "username": "xAdvitya",
                        "content": "Double pointers makes this easy !"
                    },
                    {
                        "username": "Musaddik_Khan009",
                        "content": "class Solution {\\npublic:\\n    void moveZeroes(vector<int>& nums) {\\n    int i = 0;   // initialise first index \\n   for(int j = 0; j<nums.size(); j++){\\n       if(nums[j]  != 0){\\n           swap(nums[i] , nums[j]);\\n           i++;\\n       }\\n   }\\n\\n    }\\n};"
                    },
                    {
                        "username": "user0011s",
                        "content": "Hint 1 was extremely helpful in coming up with this approach. \\n\\nclass Solution {\\npublic void moveZeroes(int[] nums) {\\nint i = 0;\\nfor(int j = 0; j < nums.length; j++) {\\nif(nums[j] != 0) {\\nnums[i++] = nums[j];\\n}\\n}\\nwhile(i < nums.length) {\\nnums[i++] = 0;\\n}\\n}\\n}"
                    },
                    {
                        "username": "xanadoom",
                        "content": "let sol = [];\\n  for(let i = 0; i < nums.length; i++){\\n    if(nums[i] !== 0){\\n      sol.push(nums[i]);\\n    }\\n  }\\n   return sol.concat(nums.filter(x => x === 0));  \\n};\\ndont understand why my code dont work, whit nums = [0,1,0,3,12]; Output [0,1,0,3,12]; Expected [1,3,12,0,0].\\nSomeone have some advice why this code dont work?"
                    },
                    {
                        "username": "avalos010",
                        "content": "[@xanadoom](/xanadoom)  were supposed to modify the nums not return anything."
                    },
                    {
                        "username": "xanadoom",
                        "content": "var moveZeroes = function(nums) {\\n    return nums.filter(x => x !== 0).concat(nums.filter(x => x === 0))\\n};\\neven this code give same problem"
                    },
                    {
                        "username": "AnkushR10",
                        "content": "https://github.com/AnkushRawat10601/Leetcode/blob/main/283_move_zeroes.cpp"
                    },
                    {
                        "username": "devam25",
                        "content": "i am getting error in this code:\nclass Solution {\npublic:\n    void moveZeroes(vector<int>& nums) {\n     int a = nums.size()-1;\n     if(a<2) cout<<a;\n        for(int i=0; i<a; i++){\n            if(nums[i] == 0){\n                if(nums[a] != 0){\n                    swap(nums[a],nums[i]);\n                    a--;\n                }\n            }\n        }\n    }\n};"
                    },
                    {
                        "username": "omar22khaled",
                        "content": "This code runs well and get the right output on may local machine but when I uploaded it here, it got wrong answer. Could anyone explain why does this occur?\\n\\n`class Solution:`\\n`    def moveZeroes(self, nums: List[int]) -> None:`\\n`        nums = [i for i in nums if i !=0] + [i for i in nums if i == 0]`"
                    },
                    {
                        "username": "omar22khaled",
                        "content": "This code runs well and get the right output on may local machine but when I uploaded it here, it got wrong answer. Could anyone explain why does this occur?\\n\\n`class Solution:`\\n`    def moveZeroes(self, nums: List[int]) -> None:`\\n`        nums = [i for i in nums if i !=0] + [i for i in nums if i == 0]`"
                    },
                    {
                        "username": "anamika12b",
                        "content": "They don\\'t want you to change the first array at all. Here you are assigning another list to the initial input list"
                    }
                ]
            },
            {
                "id": 1723763,
                "content": [
                    {
                        "username": "vermillion43015",
                        "content": "I'm a little curious as to why this code runs fine in Pycharm  no matter what array I throw at it but here it returns the wrong answer...\n\nclass Solution:\n    def moveZeroes(self, nums: List[int]) -> None:\n        return [nonZero for nonZero in nums if nonZero != 0] + \\\n            [Zero for Zero in nums if Zero == 0]"
                    },
                    {
                        "username": "Dezmond-sama",
                        "content": "You shouldn\\'t return anything. Just replace \"return [your array]\" with \"nums[:] = [your array]\" if you want to do it this way"
                    },
                    {
                        "username": "dotSlash-Adwitiya",
                        "content": "I don;t understand why the below code isn't working, its working on my machine for the same test cases its failing for in leetcode !\nThe first TC this below code failed for is : [0,1,1,0]\nBut the code runs perfectly for this same TC on my machine ! `\n\nvoid moveZeroes(vector<int> &nums)\n{\n  int left = 0, n = nums.size(), i = left + 1;\n  if (check(nums, n))\n    return;\n\n  while (i < n)\n  {\n    if (nums[i] != 0 && nums[left] != 0)\n    {\n      i++;\n      left++;\n    }\n    else if (nums[left] == 0 && nums[i] == 0)\n    {\n      while (nums[i] == 0 && i < n)\n      {\n        i++;\n      }\n      if (i < n)\n      {\n        swap(nums[i], nums[left]);\n        left++;\n        i++;\n      }\n    }\n\n    else if (nums[left] == 0 && nums[i] != 0)\n    {\n      swap(nums[left], nums[i]);\n      i++;\n      left++;\n    }\n    else\n    {\n      i++;\n      left++;\n    }\n  }\n}"
                    },
                    {
                        "username": "xAdvitya",
                        "content": "Double pointers makes this easy !"
                    },
                    {
                        "username": "Musaddik_Khan009",
                        "content": "class Solution {\\npublic:\\n    void moveZeroes(vector<int>& nums) {\\n    int i = 0;   // initialise first index \\n   for(int j = 0; j<nums.size(); j++){\\n       if(nums[j]  != 0){\\n           swap(nums[i] , nums[j]);\\n           i++;\\n       }\\n   }\\n\\n    }\\n};"
                    },
                    {
                        "username": "user0011s",
                        "content": "Hint 1 was extremely helpful in coming up with this approach. \\n\\nclass Solution {\\npublic void moveZeroes(int[] nums) {\\nint i = 0;\\nfor(int j = 0; j < nums.length; j++) {\\nif(nums[j] != 0) {\\nnums[i++] = nums[j];\\n}\\n}\\nwhile(i < nums.length) {\\nnums[i++] = 0;\\n}\\n}\\n}"
                    },
                    {
                        "username": "xanadoom",
                        "content": "let sol = [];\\n  for(let i = 0; i < nums.length; i++){\\n    if(nums[i] !== 0){\\n      sol.push(nums[i]);\\n    }\\n  }\\n   return sol.concat(nums.filter(x => x === 0));  \\n};\\ndont understand why my code dont work, whit nums = [0,1,0,3,12]; Output [0,1,0,3,12]; Expected [1,3,12,0,0].\\nSomeone have some advice why this code dont work?"
                    },
                    {
                        "username": "avalos010",
                        "content": "[@xanadoom](/xanadoom)  were supposed to modify the nums not return anything."
                    },
                    {
                        "username": "xanadoom",
                        "content": "var moveZeroes = function(nums) {\\n    return nums.filter(x => x !== 0).concat(nums.filter(x => x === 0))\\n};\\neven this code give same problem"
                    },
                    {
                        "username": "AnkushR10",
                        "content": "https://github.com/AnkushRawat10601/Leetcode/blob/main/283_move_zeroes.cpp"
                    },
                    {
                        "username": "devam25",
                        "content": "i am getting error in this code:\nclass Solution {\npublic:\n    void moveZeroes(vector<int>& nums) {\n     int a = nums.size()-1;\n     if(a<2) cout<<a;\n        for(int i=0; i<a; i++){\n            if(nums[i] == 0){\n                if(nums[a] != 0){\n                    swap(nums[a],nums[i]);\n                    a--;\n                }\n            }\n        }\n    }\n};"
                    },
                    {
                        "username": "omar22khaled",
                        "content": "This code runs well and get the right output on may local machine but when I uploaded it here, it got wrong answer. Could anyone explain why does this occur?\\n\\n`class Solution:`\\n`    def moveZeroes(self, nums: List[int]) -> None:`\\n`        nums = [i for i in nums if i !=0] + [i for i in nums if i == 0]`"
                    },
                    {
                        "username": "omar22khaled",
                        "content": "This code runs well and get the right output on may local machine but when I uploaded it here, it got wrong answer. Could anyone explain why does this occur?\\n\\n`class Solution:`\\n`    def moveZeroes(self, nums: List[int]) -> None:`\\n`        nums = [i for i in nums if i !=0] + [i for i in nums if i == 0]`"
                    },
                    {
                        "username": "anamika12b",
                        "content": "They don\\'t want you to change the first array at all. Here you are assigning another list to the initial input list"
                    }
                ]
            },
            {
                "id": 1723287,
                "content": [
                    {
                        "username": "vermillion43015",
                        "content": "I'm a little curious as to why this code runs fine in Pycharm  no matter what array I throw at it but here it returns the wrong answer...\n\nclass Solution:\n    def moveZeroes(self, nums: List[int]) -> None:\n        return [nonZero for nonZero in nums if nonZero != 0] + \\\n            [Zero for Zero in nums if Zero == 0]"
                    },
                    {
                        "username": "Dezmond-sama",
                        "content": "You shouldn\\'t return anything. Just replace \"return [your array]\" with \"nums[:] = [your array]\" if you want to do it this way"
                    },
                    {
                        "username": "dotSlash-Adwitiya",
                        "content": "I don;t understand why the below code isn't working, its working on my machine for the same test cases its failing for in leetcode !\nThe first TC this below code failed for is : [0,1,1,0]\nBut the code runs perfectly for this same TC on my machine ! `\n\nvoid moveZeroes(vector<int> &nums)\n{\n  int left = 0, n = nums.size(), i = left + 1;\n  if (check(nums, n))\n    return;\n\n  while (i < n)\n  {\n    if (nums[i] != 0 && nums[left] != 0)\n    {\n      i++;\n      left++;\n    }\n    else if (nums[left] == 0 && nums[i] == 0)\n    {\n      while (nums[i] == 0 && i < n)\n      {\n        i++;\n      }\n      if (i < n)\n      {\n        swap(nums[i], nums[left]);\n        left++;\n        i++;\n      }\n    }\n\n    else if (nums[left] == 0 && nums[i] != 0)\n    {\n      swap(nums[left], nums[i]);\n      i++;\n      left++;\n    }\n    else\n    {\n      i++;\n      left++;\n    }\n  }\n}"
                    },
                    {
                        "username": "xAdvitya",
                        "content": "Double pointers makes this easy !"
                    },
                    {
                        "username": "Musaddik_Khan009",
                        "content": "class Solution {\\npublic:\\n    void moveZeroes(vector<int>& nums) {\\n    int i = 0;   // initialise first index \\n   for(int j = 0; j<nums.size(); j++){\\n       if(nums[j]  != 0){\\n           swap(nums[i] , nums[j]);\\n           i++;\\n       }\\n   }\\n\\n    }\\n};"
                    },
                    {
                        "username": "user0011s",
                        "content": "Hint 1 was extremely helpful in coming up with this approach. \\n\\nclass Solution {\\npublic void moveZeroes(int[] nums) {\\nint i = 0;\\nfor(int j = 0; j < nums.length; j++) {\\nif(nums[j] != 0) {\\nnums[i++] = nums[j];\\n}\\n}\\nwhile(i < nums.length) {\\nnums[i++] = 0;\\n}\\n}\\n}"
                    },
                    {
                        "username": "xanadoom",
                        "content": "let sol = [];\\n  for(let i = 0; i < nums.length; i++){\\n    if(nums[i] !== 0){\\n      sol.push(nums[i]);\\n    }\\n  }\\n   return sol.concat(nums.filter(x => x === 0));  \\n};\\ndont understand why my code dont work, whit nums = [0,1,0,3,12]; Output [0,1,0,3,12]; Expected [1,3,12,0,0].\\nSomeone have some advice why this code dont work?"
                    },
                    {
                        "username": "avalos010",
                        "content": "[@xanadoom](/xanadoom)  were supposed to modify the nums not return anything."
                    },
                    {
                        "username": "xanadoom",
                        "content": "var moveZeroes = function(nums) {\\n    return nums.filter(x => x !== 0).concat(nums.filter(x => x === 0))\\n};\\neven this code give same problem"
                    },
                    {
                        "username": "AnkushR10",
                        "content": "https://github.com/AnkushRawat10601/Leetcode/blob/main/283_move_zeroes.cpp"
                    },
                    {
                        "username": "devam25",
                        "content": "i am getting error in this code:\nclass Solution {\npublic:\n    void moveZeroes(vector<int>& nums) {\n     int a = nums.size()-1;\n     if(a<2) cout<<a;\n        for(int i=0; i<a; i++){\n            if(nums[i] == 0){\n                if(nums[a] != 0){\n                    swap(nums[a],nums[i]);\n                    a--;\n                }\n            }\n        }\n    }\n};"
                    },
                    {
                        "username": "omar22khaled",
                        "content": "This code runs well and get the right output on may local machine but when I uploaded it here, it got wrong answer. Could anyone explain why does this occur?\\n\\n`class Solution:`\\n`    def moveZeroes(self, nums: List[int]) -> None:`\\n`        nums = [i for i in nums if i !=0] + [i for i in nums if i == 0]`"
                    },
                    {
                        "username": "omar22khaled",
                        "content": "This code runs well and get the right output on may local machine but when I uploaded it here, it got wrong answer. Could anyone explain why does this occur?\\n\\n`class Solution:`\\n`    def moveZeroes(self, nums: List[int]) -> None:`\\n`        nums = [i for i in nums if i !=0] + [i for i in nums if i == 0]`"
                    },
                    {
                        "username": "anamika12b",
                        "content": "They don\\'t want you to change the first array at all. Here you are assigning another list to the initial input list"
                    }
                ]
            },
            {
                "id": 1720688,
                "content": [
                    {
                        "username": "vermillion43015",
                        "content": "I'm a little curious as to why this code runs fine in Pycharm  no matter what array I throw at it but here it returns the wrong answer...\n\nclass Solution:\n    def moveZeroes(self, nums: List[int]) -> None:\n        return [nonZero for nonZero in nums if nonZero != 0] + \\\n            [Zero for Zero in nums if Zero == 0]"
                    },
                    {
                        "username": "Dezmond-sama",
                        "content": "You shouldn\\'t return anything. Just replace \"return [your array]\" with \"nums[:] = [your array]\" if you want to do it this way"
                    },
                    {
                        "username": "dotSlash-Adwitiya",
                        "content": "I don;t understand why the below code isn't working, its working on my machine for the same test cases its failing for in leetcode !\nThe first TC this below code failed for is : [0,1,1,0]\nBut the code runs perfectly for this same TC on my machine ! `\n\nvoid moveZeroes(vector<int> &nums)\n{\n  int left = 0, n = nums.size(), i = left + 1;\n  if (check(nums, n))\n    return;\n\n  while (i < n)\n  {\n    if (nums[i] != 0 && nums[left] != 0)\n    {\n      i++;\n      left++;\n    }\n    else if (nums[left] == 0 && nums[i] == 0)\n    {\n      while (nums[i] == 0 && i < n)\n      {\n        i++;\n      }\n      if (i < n)\n      {\n        swap(nums[i], nums[left]);\n        left++;\n        i++;\n      }\n    }\n\n    else if (nums[left] == 0 && nums[i] != 0)\n    {\n      swap(nums[left], nums[i]);\n      i++;\n      left++;\n    }\n    else\n    {\n      i++;\n      left++;\n    }\n  }\n}"
                    },
                    {
                        "username": "xAdvitya",
                        "content": "Double pointers makes this easy !"
                    },
                    {
                        "username": "Musaddik_Khan009",
                        "content": "class Solution {\\npublic:\\n    void moveZeroes(vector<int>& nums) {\\n    int i = 0;   // initialise first index \\n   for(int j = 0; j<nums.size(); j++){\\n       if(nums[j]  != 0){\\n           swap(nums[i] , nums[j]);\\n           i++;\\n       }\\n   }\\n\\n    }\\n};"
                    },
                    {
                        "username": "user0011s",
                        "content": "Hint 1 was extremely helpful in coming up with this approach. \\n\\nclass Solution {\\npublic void moveZeroes(int[] nums) {\\nint i = 0;\\nfor(int j = 0; j < nums.length; j++) {\\nif(nums[j] != 0) {\\nnums[i++] = nums[j];\\n}\\n}\\nwhile(i < nums.length) {\\nnums[i++] = 0;\\n}\\n}\\n}"
                    },
                    {
                        "username": "xanadoom",
                        "content": "let sol = [];\\n  for(let i = 0; i < nums.length; i++){\\n    if(nums[i] !== 0){\\n      sol.push(nums[i]);\\n    }\\n  }\\n   return sol.concat(nums.filter(x => x === 0));  \\n};\\ndont understand why my code dont work, whit nums = [0,1,0,3,12]; Output [0,1,0,3,12]; Expected [1,3,12,0,0].\\nSomeone have some advice why this code dont work?"
                    },
                    {
                        "username": "avalos010",
                        "content": "[@xanadoom](/xanadoom)  were supposed to modify the nums not return anything."
                    },
                    {
                        "username": "xanadoom",
                        "content": "var moveZeroes = function(nums) {\\n    return nums.filter(x => x !== 0).concat(nums.filter(x => x === 0))\\n};\\neven this code give same problem"
                    },
                    {
                        "username": "AnkushR10",
                        "content": "https://github.com/AnkushRawat10601/Leetcode/blob/main/283_move_zeroes.cpp"
                    },
                    {
                        "username": "devam25",
                        "content": "i am getting error in this code:\nclass Solution {\npublic:\n    void moveZeroes(vector<int>& nums) {\n     int a = nums.size()-1;\n     if(a<2) cout<<a;\n        for(int i=0; i<a; i++){\n            if(nums[i] == 0){\n                if(nums[a] != 0){\n                    swap(nums[a],nums[i]);\n                    a--;\n                }\n            }\n        }\n    }\n};"
                    },
                    {
                        "username": "omar22khaled",
                        "content": "This code runs well and get the right output on may local machine but when I uploaded it here, it got wrong answer. Could anyone explain why does this occur?\\n\\n`class Solution:`\\n`    def moveZeroes(self, nums: List[int]) -> None:`\\n`        nums = [i for i in nums if i !=0] + [i for i in nums if i == 0]`"
                    },
                    {
                        "username": "omar22khaled",
                        "content": "This code runs well and get the right output on may local machine but when I uploaded it here, it got wrong answer. Could anyone explain why does this occur?\\n\\n`class Solution:`\\n`    def moveZeroes(self, nums: List[int]) -> None:`\\n`        nums = [i for i in nums if i !=0] + [i for i in nums if i == 0]`"
                    },
                    {
                        "username": "anamika12b",
                        "content": "They don\\'t want you to change the first array at all. Here you are assigning another list to the initial input list"
                    }
                ]
            },
            {
                "id": 1720686,
                "content": [
                    {
                        "username": "vermillion43015",
                        "content": "I'm a little curious as to why this code runs fine in Pycharm  no matter what array I throw at it but here it returns the wrong answer...\n\nclass Solution:\n    def moveZeroes(self, nums: List[int]) -> None:\n        return [nonZero for nonZero in nums if nonZero != 0] + \\\n            [Zero for Zero in nums if Zero == 0]"
                    },
                    {
                        "username": "Dezmond-sama",
                        "content": "You shouldn\\'t return anything. Just replace \"return [your array]\" with \"nums[:] = [your array]\" if you want to do it this way"
                    },
                    {
                        "username": "dotSlash-Adwitiya",
                        "content": "I don;t understand why the below code isn't working, its working on my machine for the same test cases its failing for in leetcode !\nThe first TC this below code failed for is : [0,1,1,0]\nBut the code runs perfectly for this same TC on my machine ! `\n\nvoid moveZeroes(vector<int> &nums)\n{\n  int left = 0, n = nums.size(), i = left + 1;\n  if (check(nums, n))\n    return;\n\n  while (i < n)\n  {\n    if (nums[i] != 0 && nums[left] != 0)\n    {\n      i++;\n      left++;\n    }\n    else if (nums[left] == 0 && nums[i] == 0)\n    {\n      while (nums[i] == 0 && i < n)\n      {\n        i++;\n      }\n      if (i < n)\n      {\n        swap(nums[i], nums[left]);\n        left++;\n        i++;\n      }\n    }\n\n    else if (nums[left] == 0 && nums[i] != 0)\n    {\n      swap(nums[left], nums[i]);\n      i++;\n      left++;\n    }\n    else\n    {\n      i++;\n      left++;\n    }\n  }\n}"
                    },
                    {
                        "username": "xAdvitya",
                        "content": "Double pointers makes this easy !"
                    },
                    {
                        "username": "Musaddik_Khan009",
                        "content": "class Solution {\\npublic:\\n    void moveZeroes(vector<int>& nums) {\\n    int i = 0;   // initialise first index \\n   for(int j = 0; j<nums.size(); j++){\\n       if(nums[j]  != 0){\\n           swap(nums[i] , nums[j]);\\n           i++;\\n       }\\n   }\\n\\n    }\\n};"
                    },
                    {
                        "username": "user0011s",
                        "content": "Hint 1 was extremely helpful in coming up with this approach. \\n\\nclass Solution {\\npublic void moveZeroes(int[] nums) {\\nint i = 0;\\nfor(int j = 0; j < nums.length; j++) {\\nif(nums[j] != 0) {\\nnums[i++] = nums[j];\\n}\\n}\\nwhile(i < nums.length) {\\nnums[i++] = 0;\\n}\\n}\\n}"
                    },
                    {
                        "username": "xanadoom",
                        "content": "let sol = [];\\n  for(let i = 0; i < nums.length; i++){\\n    if(nums[i] !== 0){\\n      sol.push(nums[i]);\\n    }\\n  }\\n   return sol.concat(nums.filter(x => x === 0));  \\n};\\ndont understand why my code dont work, whit nums = [0,1,0,3,12]; Output [0,1,0,3,12]; Expected [1,3,12,0,0].\\nSomeone have some advice why this code dont work?"
                    },
                    {
                        "username": "avalos010",
                        "content": "[@xanadoom](/xanadoom)  were supposed to modify the nums not return anything."
                    },
                    {
                        "username": "xanadoom",
                        "content": "var moveZeroes = function(nums) {\\n    return nums.filter(x => x !== 0).concat(nums.filter(x => x === 0))\\n};\\neven this code give same problem"
                    },
                    {
                        "username": "AnkushR10",
                        "content": "https://github.com/AnkushRawat10601/Leetcode/blob/main/283_move_zeroes.cpp"
                    },
                    {
                        "username": "devam25",
                        "content": "i am getting error in this code:\nclass Solution {\npublic:\n    void moveZeroes(vector<int>& nums) {\n     int a = nums.size()-1;\n     if(a<2) cout<<a;\n        for(int i=0; i<a; i++){\n            if(nums[i] == 0){\n                if(nums[a] != 0){\n                    swap(nums[a],nums[i]);\n                    a--;\n                }\n            }\n        }\n    }\n};"
                    },
                    {
                        "username": "omar22khaled",
                        "content": "This code runs well and get the right output on may local machine but when I uploaded it here, it got wrong answer. Could anyone explain why does this occur?\\n\\n`class Solution:`\\n`    def moveZeroes(self, nums: List[int]) -> None:`\\n`        nums = [i for i in nums if i !=0] + [i for i in nums if i == 0]`"
                    },
                    {
                        "username": "omar22khaled",
                        "content": "This code runs well and get the right output on may local machine but when I uploaded it here, it got wrong answer. Could anyone explain why does this occur?\\n\\n`class Solution:`\\n`    def moveZeroes(self, nums: List[int]) -> None:`\\n`        nums = [i for i in nums if i !=0] + [i for i in nums if i == 0]`"
                    },
                    {
                        "username": "anamika12b",
                        "content": "They don\\'t want you to change the first array at all. Here you are assigning another list to the initial input list"
                    }
                ]
            },
            {
                "id": 1715673,
                "content": [
                    {
                        "username": "xuxingsheng",
                        "content": "Can anyone tell me why my code does not run correctly here but works in my other Python software?\\nclass Solution:\\n`    def moveZeroes(self, nums: List[int]) -> None:\\n        nums = [x for x in nums if x != 0] + [x for x in nums if x == 0]`"
                    },
                    {
                        "username": "arvindk2025",
                        "content": "\\n        int i=0;\\n        for(int j=0;j<nums.size(); j++){\\n            if(nums[j]!=0){\\n                swap(nums[j],nums[i]);\\n                i++;\\n            }\\n        }\\n    "
                    },
                    {
                        "username": "sivagowda",
                        "content": "Simple code which beats 97% of code with runtime and 85% of code with memory\\n def moveZeroes(nums):\\n        i = 0\\n        count = len(nums) - 1\\n        while i <= count:\\n            if nums[i] == 0:\\n                pe = nums.pop(i)\\n                nums.append(pe)\\n                count -= 1\\n            else:\\n                i+=1      \\n        return nums"
                    },
                    {
                        "username": "Top_C",
                        "content": "   int j=0;\\n        for(int i = 0;i<num.size();i++){\\n            if(num[i]!=0){\\n                num[j]=num[i];\\n                j++;\\n            }\\n        }\\n        while(j<num.size())num[j++]=0;\\n        "
                    },
                    {
                        "username": "akhilachepuri543",
                        "content": "Use the 2 pointer approach\\ninitially they point to starting index\\ncheck if the number!=0 SWAP(i,j);j++"
                    },
                    {
                        "username": "VivekDhiman",
                        "content": "class Solution {\\n    public void moveZeroes(int[] nums) {\\n        int nonzero=  0;\\n        for(int i = 0 ; i < nums.length ; i++){\\n            if(nums[i] != 0){\\n                int temp = nums[i];\\n                nums[i] = nums[nonzero];\\n                nums[nonzero] = temp;\\n                nonzero++;   \\n                }\\n        }\\n    }\\n}"
                    },
                    {
                        "username": "sauravt_5625",
                        "content": "move the non zero values to ith index and then stores that value to x then i++;"
                    },
                    {
                        "username": "HiMaN810",
                        "content": "class Solution {\\npublic:\\n    void moveZeroes(vector<int>& nums) {\\n        int n=nums.size();\\n        int i=0;\\n        int a=0;\\n        while(a<n-1)\\n        {\\n            for(int i=0;i<n-1;i++){\\n            if(nums[i]==0){\\n                int temp=nums[i];\\n                nums[i]=nums[i+1];\\n                nums[i+1]=temp;\\n            }\\n        }\\n        a++;\\n        }\\n        \\n    }\\n};\\n\\nWhy am i getting the TLE help\\n"
                    },
                    {
                        "username": "EatWorkSleep",
                        "content": "I think your solution works, but is too slow. You basically bubble up all the 0s to the right side of the array, but that takes around n*n conditional checks and swaps, which is more than the problem wants. Try to come up with something where you only need to check every position in the array once, while placing all the numbers in the right spots.\\n\\nIf you were given [1, 2, 3, 4, 5, 0, 0], your solution would check the first 6 numbers, except the last number, 6 times to bubble up all the 0s to the right side. That\\'s 36 checks, even though the array already is in the correct state the problem wants."
                    },
                    {
                        "username": "aditya13451",
                        "content": "helppp c++. someone plss tell why this is wrong.\\n\\n\\'\\'\\'\\nclass Solution {\\npublic:\\n    void moveZeroes(vector<int>& nums) {\\n        int left = 0;\\n        for(int right = 1; right < nums.size(); right++){\\n            if(left == 0){\\n                if(right != 0){\\n                    swap(nums[left],nums[right]);\\n                    left++;\\n                }\\n            }\\n            else{\\n                left++;\\n            }\\n        }\\n    }\\n};\\n\\n\\n\\n\\'\\'\\'"
                    },
                    {
                        "username": "emreesrc",
                        "content": "Can anyone tell me why i was getting error ?\n\n\n\n        var moveZeroes = function (nums) {\n         const checkZero = nums.filter((v) => v === 0).length;\n         const makeBool = nums.filter((item) => Boolean(item));\n         Array(checkZero)\n          .fill(0)\n          .forEach((elem, idx) => {\n             makeBool.push(0);\n         });\n           return makeBool;\n         };"
                    }
                ]
            },
            {
                "id": 1713293,
                "content": [
                    {
                        "username": "xuxingsheng",
                        "content": "Can anyone tell me why my code does not run correctly here but works in my other Python software?\\nclass Solution:\\n`    def moveZeroes(self, nums: List[int]) -> None:\\n        nums = [x for x in nums if x != 0] + [x for x in nums if x == 0]`"
                    },
                    {
                        "username": "arvindk2025",
                        "content": "\\n        int i=0;\\n        for(int j=0;j<nums.size(); j++){\\n            if(nums[j]!=0){\\n                swap(nums[j],nums[i]);\\n                i++;\\n            }\\n        }\\n    "
                    },
                    {
                        "username": "sivagowda",
                        "content": "Simple code which beats 97% of code with runtime and 85% of code with memory\\n def moveZeroes(nums):\\n        i = 0\\n        count = len(nums) - 1\\n        while i <= count:\\n            if nums[i] == 0:\\n                pe = nums.pop(i)\\n                nums.append(pe)\\n                count -= 1\\n            else:\\n                i+=1      \\n        return nums"
                    },
                    {
                        "username": "Top_C",
                        "content": "   int j=0;\\n        for(int i = 0;i<num.size();i++){\\n            if(num[i]!=0){\\n                num[j]=num[i];\\n                j++;\\n            }\\n        }\\n        while(j<num.size())num[j++]=0;\\n        "
                    },
                    {
                        "username": "akhilachepuri543",
                        "content": "Use the 2 pointer approach\\ninitially they point to starting index\\ncheck if the number!=0 SWAP(i,j);j++"
                    },
                    {
                        "username": "VivekDhiman",
                        "content": "class Solution {\\n    public void moveZeroes(int[] nums) {\\n        int nonzero=  0;\\n        for(int i = 0 ; i < nums.length ; i++){\\n            if(nums[i] != 0){\\n                int temp = nums[i];\\n                nums[i] = nums[nonzero];\\n                nums[nonzero] = temp;\\n                nonzero++;   \\n                }\\n        }\\n    }\\n}"
                    },
                    {
                        "username": "sauravt_5625",
                        "content": "move the non zero values to ith index and then stores that value to x then i++;"
                    },
                    {
                        "username": "HiMaN810",
                        "content": "class Solution {\\npublic:\\n    void moveZeroes(vector<int>& nums) {\\n        int n=nums.size();\\n        int i=0;\\n        int a=0;\\n        while(a<n-1)\\n        {\\n            for(int i=0;i<n-1;i++){\\n            if(nums[i]==0){\\n                int temp=nums[i];\\n                nums[i]=nums[i+1];\\n                nums[i+1]=temp;\\n            }\\n        }\\n        a++;\\n        }\\n        \\n    }\\n};\\n\\nWhy am i getting the TLE help\\n"
                    },
                    {
                        "username": "EatWorkSleep",
                        "content": "I think your solution works, but is too slow. You basically bubble up all the 0s to the right side of the array, but that takes around n*n conditional checks and swaps, which is more than the problem wants. Try to come up with something where you only need to check every position in the array once, while placing all the numbers in the right spots.\\n\\nIf you were given [1, 2, 3, 4, 5, 0, 0], your solution would check the first 6 numbers, except the last number, 6 times to bubble up all the 0s to the right side. That\\'s 36 checks, even though the array already is in the correct state the problem wants."
                    },
                    {
                        "username": "aditya13451",
                        "content": "helppp c++. someone plss tell why this is wrong.\\n\\n\\'\\'\\'\\nclass Solution {\\npublic:\\n    void moveZeroes(vector<int>& nums) {\\n        int left = 0;\\n        for(int right = 1; right < nums.size(); right++){\\n            if(left == 0){\\n                if(right != 0){\\n                    swap(nums[left],nums[right]);\\n                    left++;\\n                }\\n            }\\n            else{\\n                left++;\\n            }\\n        }\\n    }\\n};\\n\\n\\n\\n\\'\\'\\'"
                    },
                    {
                        "username": "emreesrc",
                        "content": "Can anyone tell me why i was getting error ?\n\n\n\n        var moveZeroes = function (nums) {\n         const checkZero = nums.filter((v) => v === 0).length;\n         const makeBool = nums.filter((item) => Boolean(item));\n         Array(checkZero)\n          .fill(0)\n          .forEach((elem, idx) => {\n             makeBool.push(0);\n         });\n           return makeBool;\n         };"
                    }
                ]
            },
            {
                "id": 1710380,
                "content": [
                    {
                        "username": "xuxingsheng",
                        "content": "Can anyone tell me why my code does not run correctly here but works in my other Python software?\\nclass Solution:\\n`    def moveZeroes(self, nums: List[int]) -> None:\\n        nums = [x for x in nums if x != 0] + [x for x in nums if x == 0]`"
                    },
                    {
                        "username": "arvindk2025",
                        "content": "\\n        int i=0;\\n        for(int j=0;j<nums.size(); j++){\\n            if(nums[j]!=0){\\n                swap(nums[j],nums[i]);\\n                i++;\\n            }\\n        }\\n    "
                    },
                    {
                        "username": "sivagowda",
                        "content": "Simple code which beats 97% of code with runtime and 85% of code with memory\\n def moveZeroes(nums):\\n        i = 0\\n        count = len(nums) - 1\\n        while i <= count:\\n            if nums[i] == 0:\\n                pe = nums.pop(i)\\n                nums.append(pe)\\n                count -= 1\\n            else:\\n                i+=1      \\n        return nums"
                    },
                    {
                        "username": "Top_C",
                        "content": "   int j=0;\\n        for(int i = 0;i<num.size();i++){\\n            if(num[i]!=0){\\n                num[j]=num[i];\\n                j++;\\n            }\\n        }\\n        while(j<num.size())num[j++]=0;\\n        "
                    },
                    {
                        "username": "akhilachepuri543",
                        "content": "Use the 2 pointer approach\\ninitially they point to starting index\\ncheck if the number!=0 SWAP(i,j);j++"
                    },
                    {
                        "username": "VivekDhiman",
                        "content": "class Solution {\\n    public void moveZeroes(int[] nums) {\\n        int nonzero=  0;\\n        for(int i = 0 ; i < nums.length ; i++){\\n            if(nums[i] != 0){\\n                int temp = nums[i];\\n                nums[i] = nums[nonzero];\\n                nums[nonzero] = temp;\\n                nonzero++;   \\n                }\\n        }\\n    }\\n}"
                    },
                    {
                        "username": "sauravt_5625",
                        "content": "move the non zero values to ith index and then stores that value to x then i++;"
                    },
                    {
                        "username": "HiMaN810",
                        "content": "class Solution {\\npublic:\\n    void moveZeroes(vector<int>& nums) {\\n        int n=nums.size();\\n        int i=0;\\n        int a=0;\\n        while(a<n-1)\\n        {\\n            for(int i=0;i<n-1;i++){\\n            if(nums[i]==0){\\n                int temp=nums[i];\\n                nums[i]=nums[i+1];\\n                nums[i+1]=temp;\\n            }\\n        }\\n        a++;\\n        }\\n        \\n    }\\n};\\n\\nWhy am i getting the TLE help\\n"
                    },
                    {
                        "username": "EatWorkSleep",
                        "content": "I think your solution works, but is too slow. You basically bubble up all the 0s to the right side of the array, but that takes around n*n conditional checks and swaps, which is more than the problem wants. Try to come up with something where you only need to check every position in the array once, while placing all the numbers in the right spots.\\n\\nIf you were given [1, 2, 3, 4, 5, 0, 0], your solution would check the first 6 numbers, except the last number, 6 times to bubble up all the 0s to the right side. That\\'s 36 checks, even though the array already is in the correct state the problem wants."
                    },
                    {
                        "username": "aditya13451",
                        "content": "helppp c++. someone plss tell why this is wrong.\\n\\n\\'\\'\\'\\nclass Solution {\\npublic:\\n    void moveZeroes(vector<int>& nums) {\\n        int left = 0;\\n        for(int right = 1; right < nums.size(); right++){\\n            if(left == 0){\\n                if(right != 0){\\n                    swap(nums[left],nums[right]);\\n                    left++;\\n                }\\n            }\\n            else{\\n                left++;\\n            }\\n        }\\n    }\\n};\\n\\n\\n\\n\\'\\'\\'"
                    },
                    {
                        "username": "emreesrc",
                        "content": "Can anyone tell me why i was getting error ?\n\n\n\n        var moveZeroes = function (nums) {\n         const checkZero = nums.filter((v) => v === 0).length;\n         const makeBool = nums.filter((item) => Boolean(item));\n         Array(checkZero)\n          .fill(0)\n          .forEach((elem, idx) => {\n             makeBool.push(0);\n         });\n           return makeBool;\n         };"
                    }
                ]
            },
            {
                "id": 1710204,
                "content": [
                    {
                        "username": "xuxingsheng",
                        "content": "Can anyone tell me why my code does not run correctly here but works in my other Python software?\\nclass Solution:\\n`    def moveZeroes(self, nums: List[int]) -> None:\\n        nums = [x for x in nums if x != 0] + [x for x in nums if x == 0]`"
                    },
                    {
                        "username": "arvindk2025",
                        "content": "\\n        int i=0;\\n        for(int j=0;j<nums.size(); j++){\\n            if(nums[j]!=0){\\n                swap(nums[j],nums[i]);\\n                i++;\\n            }\\n        }\\n    "
                    },
                    {
                        "username": "sivagowda",
                        "content": "Simple code which beats 97% of code with runtime and 85% of code with memory\\n def moveZeroes(nums):\\n        i = 0\\n        count = len(nums) - 1\\n        while i <= count:\\n            if nums[i] == 0:\\n                pe = nums.pop(i)\\n                nums.append(pe)\\n                count -= 1\\n            else:\\n                i+=1      \\n        return nums"
                    },
                    {
                        "username": "Top_C",
                        "content": "   int j=0;\\n        for(int i = 0;i<num.size();i++){\\n            if(num[i]!=0){\\n                num[j]=num[i];\\n                j++;\\n            }\\n        }\\n        while(j<num.size())num[j++]=0;\\n        "
                    },
                    {
                        "username": "akhilachepuri543",
                        "content": "Use the 2 pointer approach\\ninitially they point to starting index\\ncheck if the number!=0 SWAP(i,j);j++"
                    },
                    {
                        "username": "VivekDhiman",
                        "content": "class Solution {\\n    public void moveZeroes(int[] nums) {\\n        int nonzero=  0;\\n        for(int i = 0 ; i < nums.length ; i++){\\n            if(nums[i] != 0){\\n                int temp = nums[i];\\n                nums[i] = nums[nonzero];\\n                nums[nonzero] = temp;\\n                nonzero++;   \\n                }\\n        }\\n    }\\n}"
                    },
                    {
                        "username": "sauravt_5625",
                        "content": "move the non zero values to ith index and then stores that value to x then i++;"
                    },
                    {
                        "username": "HiMaN810",
                        "content": "class Solution {\\npublic:\\n    void moveZeroes(vector<int>& nums) {\\n        int n=nums.size();\\n        int i=0;\\n        int a=0;\\n        while(a<n-1)\\n        {\\n            for(int i=0;i<n-1;i++){\\n            if(nums[i]==0){\\n                int temp=nums[i];\\n                nums[i]=nums[i+1];\\n                nums[i+1]=temp;\\n            }\\n        }\\n        a++;\\n        }\\n        \\n    }\\n};\\n\\nWhy am i getting the TLE help\\n"
                    },
                    {
                        "username": "EatWorkSleep",
                        "content": "I think your solution works, but is too slow. You basically bubble up all the 0s to the right side of the array, but that takes around n*n conditional checks and swaps, which is more than the problem wants. Try to come up with something where you only need to check every position in the array once, while placing all the numbers in the right spots.\\n\\nIf you were given [1, 2, 3, 4, 5, 0, 0], your solution would check the first 6 numbers, except the last number, 6 times to bubble up all the 0s to the right side. That\\'s 36 checks, even though the array already is in the correct state the problem wants."
                    },
                    {
                        "username": "aditya13451",
                        "content": "helppp c++. someone plss tell why this is wrong.\\n\\n\\'\\'\\'\\nclass Solution {\\npublic:\\n    void moveZeroes(vector<int>& nums) {\\n        int left = 0;\\n        for(int right = 1; right < nums.size(); right++){\\n            if(left == 0){\\n                if(right != 0){\\n                    swap(nums[left],nums[right]);\\n                    left++;\\n                }\\n            }\\n            else{\\n                left++;\\n            }\\n        }\\n    }\\n};\\n\\n\\n\\n\\'\\'\\'"
                    },
                    {
                        "username": "emreesrc",
                        "content": "Can anyone tell me why i was getting error ?\n\n\n\n        var moveZeroes = function (nums) {\n         const checkZero = nums.filter((v) => v === 0).length;\n         const makeBool = nums.filter((item) => Boolean(item));\n         Array(checkZero)\n          .fill(0)\n          .forEach((elem, idx) => {\n             makeBool.push(0);\n         });\n           return makeBool;\n         };"
                    }
                ]
            },
            {
                "id": 1701646,
                "content": [
                    {
                        "username": "xuxingsheng",
                        "content": "Can anyone tell me why my code does not run correctly here but works in my other Python software?\\nclass Solution:\\n`    def moveZeroes(self, nums: List[int]) -> None:\\n        nums = [x for x in nums if x != 0] + [x for x in nums if x == 0]`"
                    },
                    {
                        "username": "arvindk2025",
                        "content": "\\n        int i=0;\\n        for(int j=0;j<nums.size(); j++){\\n            if(nums[j]!=0){\\n                swap(nums[j],nums[i]);\\n                i++;\\n            }\\n        }\\n    "
                    },
                    {
                        "username": "sivagowda",
                        "content": "Simple code which beats 97% of code with runtime and 85% of code with memory\\n def moveZeroes(nums):\\n        i = 0\\n        count = len(nums) - 1\\n        while i <= count:\\n            if nums[i] == 0:\\n                pe = nums.pop(i)\\n                nums.append(pe)\\n                count -= 1\\n            else:\\n                i+=1      \\n        return nums"
                    },
                    {
                        "username": "Top_C",
                        "content": "   int j=0;\\n        for(int i = 0;i<num.size();i++){\\n            if(num[i]!=0){\\n                num[j]=num[i];\\n                j++;\\n            }\\n        }\\n        while(j<num.size())num[j++]=0;\\n        "
                    },
                    {
                        "username": "akhilachepuri543",
                        "content": "Use the 2 pointer approach\\ninitially they point to starting index\\ncheck if the number!=0 SWAP(i,j);j++"
                    },
                    {
                        "username": "VivekDhiman",
                        "content": "class Solution {\\n    public void moveZeroes(int[] nums) {\\n        int nonzero=  0;\\n        for(int i = 0 ; i < nums.length ; i++){\\n            if(nums[i] != 0){\\n                int temp = nums[i];\\n                nums[i] = nums[nonzero];\\n                nums[nonzero] = temp;\\n                nonzero++;   \\n                }\\n        }\\n    }\\n}"
                    },
                    {
                        "username": "sauravt_5625",
                        "content": "move the non zero values to ith index and then stores that value to x then i++;"
                    },
                    {
                        "username": "HiMaN810",
                        "content": "class Solution {\\npublic:\\n    void moveZeroes(vector<int>& nums) {\\n        int n=nums.size();\\n        int i=0;\\n        int a=0;\\n        while(a<n-1)\\n        {\\n            for(int i=0;i<n-1;i++){\\n            if(nums[i]==0){\\n                int temp=nums[i];\\n                nums[i]=nums[i+1];\\n                nums[i+1]=temp;\\n            }\\n        }\\n        a++;\\n        }\\n        \\n    }\\n};\\n\\nWhy am i getting the TLE help\\n"
                    },
                    {
                        "username": "EatWorkSleep",
                        "content": "I think your solution works, but is too slow. You basically bubble up all the 0s to the right side of the array, but that takes around n*n conditional checks and swaps, which is more than the problem wants. Try to come up with something where you only need to check every position in the array once, while placing all the numbers in the right spots.\\n\\nIf you were given [1, 2, 3, 4, 5, 0, 0], your solution would check the first 6 numbers, except the last number, 6 times to bubble up all the 0s to the right side. That\\'s 36 checks, even though the array already is in the correct state the problem wants."
                    },
                    {
                        "username": "aditya13451",
                        "content": "helppp c++. someone plss tell why this is wrong.\\n\\n\\'\\'\\'\\nclass Solution {\\npublic:\\n    void moveZeroes(vector<int>& nums) {\\n        int left = 0;\\n        for(int right = 1; right < nums.size(); right++){\\n            if(left == 0){\\n                if(right != 0){\\n                    swap(nums[left],nums[right]);\\n                    left++;\\n                }\\n            }\\n            else{\\n                left++;\\n            }\\n        }\\n    }\\n};\\n\\n\\n\\n\\'\\'\\'"
                    },
                    {
                        "username": "emreesrc",
                        "content": "Can anyone tell me why i was getting error ?\n\n\n\n        var moveZeroes = function (nums) {\n         const checkZero = nums.filter((v) => v === 0).length;\n         const makeBool = nums.filter((item) => Boolean(item));\n         Array(checkZero)\n          .fill(0)\n          .forEach((elem, idx) => {\n             makeBool.push(0);\n         });\n           return makeBool;\n         };"
                    }
                ]
            },
            {
                "id": 1699331,
                "content": [
                    {
                        "username": "xuxingsheng",
                        "content": "Can anyone tell me why my code does not run correctly here but works in my other Python software?\\nclass Solution:\\n`    def moveZeroes(self, nums: List[int]) -> None:\\n        nums = [x for x in nums if x != 0] + [x for x in nums if x == 0]`"
                    },
                    {
                        "username": "arvindk2025",
                        "content": "\\n        int i=0;\\n        for(int j=0;j<nums.size(); j++){\\n            if(nums[j]!=0){\\n                swap(nums[j],nums[i]);\\n                i++;\\n            }\\n        }\\n    "
                    },
                    {
                        "username": "sivagowda",
                        "content": "Simple code which beats 97% of code with runtime and 85% of code with memory\\n def moveZeroes(nums):\\n        i = 0\\n        count = len(nums) - 1\\n        while i <= count:\\n            if nums[i] == 0:\\n                pe = nums.pop(i)\\n                nums.append(pe)\\n                count -= 1\\n            else:\\n                i+=1      \\n        return nums"
                    },
                    {
                        "username": "Top_C",
                        "content": "   int j=0;\\n        for(int i = 0;i<num.size();i++){\\n            if(num[i]!=0){\\n                num[j]=num[i];\\n                j++;\\n            }\\n        }\\n        while(j<num.size())num[j++]=0;\\n        "
                    },
                    {
                        "username": "akhilachepuri543",
                        "content": "Use the 2 pointer approach\\ninitially they point to starting index\\ncheck if the number!=0 SWAP(i,j);j++"
                    },
                    {
                        "username": "VivekDhiman",
                        "content": "class Solution {\\n    public void moveZeroes(int[] nums) {\\n        int nonzero=  0;\\n        for(int i = 0 ; i < nums.length ; i++){\\n            if(nums[i] != 0){\\n                int temp = nums[i];\\n                nums[i] = nums[nonzero];\\n                nums[nonzero] = temp;\\n                nonzero++;   \\n                }\\n        }\\n    }\\n}"
                    },
                    {
                        "username": "sauravt_5625",
                        "content": "move the non zero values to ith index and then stores that value to x then i++;"
                    },
                    {
                        "username": "HiMaN810",
                        "content": "class Solution {\\npublic:\\n    void moveZeroes(vector<int>& nums) {\\n        int n=nums.size();\\n        int i=0;\\n        int a=0;\\n        while(a<n-1)\\n        {\\n            for(int i=0;i<n-1;i++){\\n            if(nums[i]==0){\\n                int temp=nums[i];\\n                nums[i]=nums[i+1];\\n                nums[i+1]=temp;\\n            }\\n        }\\n        a++;\\n        }\\n        \\n    }\\n};\\n\\nWhy am i getting the TLE help\\n"
                    },
                    {
                        "username": "EatWorkSleep",
                        "content": "I think your solution works, but is too slow. You basically bubble up all the 0s to the right side of the array, but that takes around n*n conditional checks and swaps, which is more than the problem wants. Try to come up with something where you only need to check every position in the array once, while placing all the numbers in the right spots.\\n\\nIf you were given [1, 2, 3, 4, 5, 0, 0], your solution would check the first 6 numbers, except the last number, 6 times to bubble up all the 0s to the right side. That\\'s 36 checks, even though the array already is in the correct state the problem wants."
                    },
                    {
                        "username": "aditya13451",
                        "content": "helppp c++. someone plss tell why this is wrong.\\n\\n\\'\\'\\'\\nclass Solution {\\npublic:\\n    void moveZeroes(vector<int>& nums) {\\n        int left = 0;\\n        for(int right = 1; right < nums.size(); right++){\\n            if(left == 0){\\n                if(right != 0){\\n                    swap(nums[left],nums[right]);\\n                    left++;\\n                }\\n            }\\n            else{\\n                left++;\\n            }\\n        }\\n    }\\n};\\n\\n\\n\\n\\'\\'\\'"
                    },
                    {
                        "username": "emreesrc",
                        "content": "Can anyone tell me why i was getting error ?\n\n\n\n        var moveZeroes = function (nums) {\n         const checkZero = nums.filter((v) => v === 0).length;\n         const makeBool = nums.filter((item) => Boolean(item));\n         Array(checkZero)\n          .fill(0)\n          .forEach((elem, idx) => {\n             makeBool.push(0);\n         });\n           return makeBool;\n         };"
                    }
                ]
            },
            {
                "id": 1694986,
                "content": [
                    {
                        "username": "xuxingsheng",
                        "content": "Can anyone tell me why my code does not run correctly here but works in my other Python software?\\nclass Solution:\\n`    def moveZeroes(self, nums: List[int]) -> None:\\n        nums = [x for x in nums if x != 0] + [x for x in nums if x == 0]`"
                    },
                    {
                        "username": "arvindk2025",
                        "content": "\\n        int i=0;\\n        for(int j=0;j<nums.size(); j++){\\n            if(nums[j]!=0){\\n                swap(nums[j],nums[i]);\\n                i++;\\n            }\\n        }\\n    "
                    },
                    {
                        "username": "sivagowda",
                        "content": "Simple code which beats 97% of code with runtime and 85% of code with memory\\n def moveZeroes(nums):\\n        i = 0\\n        count = len(nums) - 1\\n        while i <= count:\\n            if nums[i] == 0:\\n                pe = nums.pop(i)\\n                nums.append(pe)\\n                count -= 1\\n            else:\\n                i+=1      \\n        return nums"
                    },
                    {
                        "username": "Top_C",
                        "content": "   int j=0;\\n        for(int i = 0;i<num.size();i++){\\n            if(num[i]!=0){\\n                num[j]=num[i];\\n                j++;\\n            }\\n        }\\n        while(j<num.size())num[j++]=0;\\n        "
                    },
                    {
                        "username": "akhilachepuri543",
                        "content": "Use the 2 pointer approach\\ninitially they point to starting index\\ncheck if the number!=0 SWAP(i,j);j++"
                    },
                    {
                        "username": "VivekDhiman",
                        "content": "class Solution {\\n    public void moveZeroes(int[] nums) {\\n        int nonzero=  0;\\n        for(int i = 0 ; i < nums.length ; i++){\\n            if(nums[i] != 0){\\n                int temp = nums[i];\\n                nums[i] = nums[nonzero];\\n                nums[nonzero] = temp;\\n                nonzero++;   \\n                }\\n        }\\n    }\\n}"
                    },
                    {
                        "username": "sauravt_5625",
                        "content": "move the non zero values to ith index and then stores that value to x then i++;"
                    },
                    {
                        "username": "HiMaN810",
                        "content": "class Solution {\\npublic:\\n    void moveZeroes(vector<int>& nums) {\\n        int n=nums.size();\\n        int i=0;\\n        int a=0;\\n        while(a<n-1)\\n        {\\n            for(int i=0;i<n-1;i++){\\n            if(nums[i]==0){\\n                int temp=nums[i];\\n                nums[i]=nums[i+1];\\n                nums[i+1]=temp;\\n            }\\n        }\\n        a++;\\n        }\\n        \\n    }\\n};\\n\\nWhy am i getting the TLE help\\n"
                    },
                    {
                        "username": "EatWorkSleep",
                        "content": "I think your solution works, but is too slow. You basically bubble up all the 0s to the right side of the array, but that takes around n*n conditional checks and swaps, which is more than the problem wants. Try to come up with something where you only need to check every position in the array once, while placing all the numbers in the right spots.\\n\\nIf you were given [1, 2, 3, 4, 5, 0, 0], your solution would check the first 6 numbers, except the last number, 6 times to bubble up all the 0s to the right side. That\\'s 36 checks, even though the array already is in the correct state the problem wants."
                    },
                    {
                        "username": "aditya13451",
                        "content": "helppp c++. someone plss tell why this is wrong.\\n\\n\\'\\'\\'\\nclass Solution {\\npublic:\\n    void moveZeroes(vector<int>& nums) {\\n        int left = 0;\\n        for(int right = 1; right < nums.size(); right++){\\n            if(left == 0){\\n                if(right != 0){\\n                    swap(nums[left],nums[right]);\\n                    left++;\\n                }\\n            }\\n            else{\\n                left++;\\n            }\\n        }\\n    }\\n};\\n\\n\\n\\n\\'\\'\\'"
                    },
                    {
                        "username": "emreesrc",
                        "content": "Can anyone tell me why i was getting error ?\n\n\n\n        var moveZeroes = function (nums) {\n         const checkZero = nums.filter((v) => v === 0).length;\n         const makeBool = nums.filter((item) => Boolean(item));\n         Array(checkZero)\n          .fill(0)\n          .forEach((elem, idx) => {\n             makeBool.push(0);\n         });\n           return makeBool;\n         };"
                    }
                ]
            },
            {
                "id": 1691988,
                "content": [
                    {
                        "username": "xuxingsheng",
                        "content": "Can anyone tell me why my code does not run correctly here but works in my other Python software?\\nclass Solution:\\n`    def moveZeroes(self, nums: List[int]) -> None:\\n        nums = [x for x in nums if x != 0] + [x for x in nums if x == 0]`"
                    },
                    {
                        "username": "arvindk2025",
                        "content": "\\n        int i=0;\\n        for(int j=0;j<nums.size(); j++){\\n            if(nums[j]!=0){\\n                swap(nums[j],nums[i]);\\n                i++;\\n            }\\n        }\\n    "
                    },
                    {
                        "username": "sivagowda",
                        "content": "Simple code which beats 97% of code with runtime and 85% of code with memory\\n def moveZeroes(nums):\\n        i = 0\\n        count = len(nums) - 1\\n        while i <= count:\\n            if nums[i] == 0:\\n                pe = nums.pop(i)\\n                nums.append(pe)\\n                count -= 1\\n            else:\\n                i+=1      \\n        return nums"
                    },
                    {
                        "username": "Top_C",
                        "content": "   int j=0;\\n        for(int i = 0;i<num.size();i++){\\n            if(num[i]!=0){\\n                num[j]=num[i];\\n                j++;\\n            }\\n        }\\n        while(j<num.size())num[j++]=0;\\n        "
                    },
                    {
                        "username": "akhilachepuri543",
                        "content": "Use the 2 pointer approach\\ninitially they point to starting index\\ncheck if the number!=0 SWAP(i,j);j++"
                    },
                    {
                        "username": "VivekDhiman",
                        "content": "class Solution {\\n    public void moveZeroes(int[] nums) {\\n        int nonzero=  0;\\n        for(int i = 0 ; i < nums.length ; i++){\\n            if(nums[i] != 0){\\n                int temp = nums[i];\\n                nums[i] = nums[nonzero];\\n                nums[nonzero] = temp;\\n                nonzero++;   \\n                }\\n        }\\n    }\\n}"
                    },
                    {
                        "username": "sauravt_5625",
                        "content": "move the non zero values to ith index and then stores that value to x then i++;"
                    },
                    {
                        "username": "HiMaN810",
                        "content": "class Solution {\\npublic:\\n    void moveZeroes(vector<int>& nums) {\\n        int n=nums.size();\\n        int i=0;\\n        int a=0;\\n        while(a<n-1)\\n        {\\n            for(int i=0;i<n-1;i++){\\n            if(nums[i]==0){\\n                int temp=nums[i];\\n                nums[i]=nums[i+1];\\n                nums[i+1]=temp;\\n            }\\n        }\\n        a++;\\n        }\\n        \\n    }\\n};\\n\\nWhy am i getting the TLE help\\n"
                    },
                    {
                        "username": "EatWorkSleep",
                        "content": "I think your solution works, but is too slow. You basically bubble up all the 0s to the right side of the array, but that takes around n*n conditional checks and swaps, which is more than the problem wants. Try to come up with something where you only need to check every position in the array once, while placing all the numbers in the right spots.\\n\\nIf you were given [1, 2, 3, 4, 5, 0, 0], your solution would check the first 6 numbers, except the last number, 6 times to bubble up all the 0s to the right side. That\\'s 36 checks, even though the array already is in the correct state the problem wants."
                    },
                    {
                        "username": "aditya13451",
                        "content": "helppp c++. someone plss tell why this is wrong.\\n\\n\\'\\'\\'\\nclass Solution {\\npublic:\\n    void moveZeroes(vector<int>& nums) {\\n        int left = 0;\\n        for(int right = 1; right < nums.size(); right++){\\n            if(left == 0){\\n                if(right != 0){\\n                    swap(nums[left],nums[right]);\\n                    left++;\\n                }\\n            }\\n            else{\\n                left++;\\n            }\\n        }\\n    }\\n};\\n\\n\\n\\n\\'\\'\\'"
                    },
                    {
                        "username": "emreesrc",
                        "content": "Can anyone tell me why i was getting error ?\n\n\n\n        var moveZeroes = function (nums) {\n         const checkZero = nums.filter((v) => v === 0).length;\n         const makeBool = nums.filter((item) => Boolean(item));\n         Array(checkZero)\n          .fill(0)\n          .forEach((elem, idx) => {\n             makeBool.push(0);\n         });\n           return makeBool;\n         };"
                    }
                ]
            },
            {
                "id": 1676829,
                "content": [
                    {
                        "username": "xuxingsheng",
                        "content": "Can anyone tell me why my code does not run correctly here but works in my other Python software?\\nclass Solution:\\n`    def moveZeroes(self, nums: List[int]) -> None:\\n        nums = [x for x in nums if x != 0] + [x for x in nums if x == 0]`"
                    },
                    {
                        "username": "arvindk2025",
                        "content": "\\n        int i=0;\\n        for(int j=0;j<nums.size(); j++){\\n            if(nums[j]!=0){\\n                swap(nums[j],nums[i]);\\n                i++;\\n            }\\n        }\\n    "
                    },
                    {
                        "username": "sivagowda",
                        "content": "Simple code which beats 97% of code with runtime and 85% of code with memory\\n def moveZeroes(nums):\\n        i = 0\\n        count = len(nums) - 1\\n        while i <= count:\\n            if nums[i] == 0:\\n                pe = nums.pop(i)\\n                nums.append(pe)\\n                count -= 1\\n            else:\\n                i+=1      \\n        return nums"
                    },
                    {
                        "username": "Top_C",
                        "content": "   int j=0;\\n        for(int i = 0;i<num.size();i++){\\n            if(num[i]!=0){\\n                num[j]=num[i];\\n                j++;\\n            }\\n        }\\n        while(j<num.size())num[j++]=0;\\n        "
                    },
                    {
                        "username": "akhilachepuri543",
                        "content": "Use the 2 pointer approach\\ninitially they point to starting index\\ncheck if the number!=0 SWAP(i,j);j++"
                    },
                    {
                        "username": "VivekDhiman",
                        "content": "class Solution {\\n    public void moveZeroes(int[] nums) {\\n        int nonzero=  0;\\n        for(int i = 0 ; i < nums.length ; i++){\\n            if(nums[i] != 0){\\n                int temp = nums[i];\\n                nums[i] = nums[nonzero];\\n                nums[nonzero] = temp;\\n                nonzero++;   \\n                }\\n        }\\n    }\\n}"
                    },
                    {
                        "username": "sauravt_5625",
                        "content": "move the non zero values to ith index and then stores that value to x then i++;"
                    },
                    {
                        "username": "HiMaN810",
                        "content": "class Solution {\\npublic:\\n    void moveZeroes(vector<int>& nums) {\\n        int n=nums.size();\\n        int i=0;\\n        int a=0;\\n        while(a<n-1)\\n        {\\n            for(int i=0;i<n-1;i++){\\n            if(nums[i]==0){\\n                int temp=nums[i];\\n                nums[i]=nums[i+1];\\n                nums[i+1]=temp;\\n            }\\n        }\\n        a++;\\n        }\\n        \\n    }\\n};\\n\\nWhy am i getting the TLE help\\n"
                    },
                    {
                        "username": "EatWorkSleep",
                        "content": "I think your solution works, but is too slow. You basically bubble up all the 0s to the right side of the array, but that takes around n*n conditional checks and swaps, which is more than the problem wants. Try to come up with something where you only need to check every position in the array once, while placing all the numbers in the right spots.\\n\\nIf you were given [1, 2, 3, 4, 5, 0, 0], your solution would check the first 6 numbers, except the last number, 6 times to bubble up all the 0s to the right side. That\\'s 36 checks, even though the array already is in the correct state the problem wants."
                    },
                    {
                        "username": "aditya13451",
                        "content": "helppp c++. someone plss tell why this is wrong.\\n\\n\\'\\'\\'\\nclass Solution {\\npublic:\\n    void moveZeroes(vector<int>& nums) {\\n        int left = 0;\\n        for(int right = 1; right < nums.size(); right++){\\n            if(left == 0){\\n                if(right != 0){\\n                    swap(nums[left],nums[right]);\\n                    left++;\\n                }\\n            }\\n            else{\\n                left++;\\n            }\\n        }\\n    }\\n};\\n\\n\\n\\n\\'\\'\\'"
                    },
                    {
                        "username": "emreesrc",
                        "content": "Can anyone tell me why i was getting error ?\n\n\n\n        var moveZeroes = function (nums) {\n         const checkZero = nums.filter((v) => v === 0).length;\n         const makeBool = nums.filter((item) => Boolean(item));\n         Array(checkZero)\n          .fill(0)\n          .forEach((elem, idx) => {\n             makeBool.push(0);\n         });\n           return makeBool;\n         };"
                    }
                ]
            },
            {
                "id": 1675422,
                "content": [
                    {
                        "username": "xuxingsheng",
                        "content": "Can anyone tell me why my code does not run correctly here but works in my other Python software?\\nclass Solution:\\n`    def moveZeroes(self, nums: List[int]) -> None:\\n        nums = [x for x in nums if x != 0] + [x for x in nums if x == 0]`"
                    },
                    {
                        "username": "arvindk2025",
                        "content": "\\n        int i=0;\\n        for(int j=0;j<nums.size(); j++){\\n            if(nums[j]!=0){\\n                swap(nums[j],nums[i]);\\n                i++;\\n            }\\n        }\\n    "
                    },
                    {
                        "username": "sivagowda",
                        "content": "Simple code which beats 97% of code with runtime and 85% of code with memory\\n def moveZeroes(nums):\\n        i = 0\\n        count = len(nums) - 1\\n        while i <= count:\\n            if nums[i] == 0:\\n                pe = nums.pop(i)\\n                nums.append(pe)\\n                count -= 1\\n            else:\\n                i+=1      \\n        return nums"
                    },
                    {
                        "username": "Top_C",
                        "content": "   int j=0;\\n        for(int i = 0;i<num.size();i++){\\n            if(num[i]!=0){\\n                num[j]=num[i];\\n                j++;\\n            }\\n        }\\n        while(j<num.size())num[j++]=0;\\n        "
                    },
                    {
                        "username": "akhilachepuri543",
                        "content": "Use the 2 pointer approach\\ninitially they point to starting index\\ncheck if the number!=0 SWAP(i,j);j++"
                    },
                    {
                        "username": "VivekDhiman",
                        "content": "class Solution {\\n    public void moveZeroes(int[] nums) {\\n        int nonzero=  0;\\n        for(int i = 0 ; i < nums.length ; i++){\\n            if(nums[i] != 0){\\n                int temp = nums[i];\\n                nums[i] = nums[nonzero];\\n                nums[nonzero] = temp;\\n                nonzero++;   \\n                }\\n        }\\n    }\\n}"
                    },
                    {
                        "username": "sauravt_5625",
                        "content": "move the non zero values to ith index and then stores that value to x then i++;"
                    },
                    {
                        "username": "HiMaN810",
                        "content": "class Solution {\\npublic:\\n    void moveZeroes(vector<int>& nums) {\\n        int n=nums.size();\\n        int i=0;\\n        int a=0;\\n        while(a<n-1)\\n        {\\n            for(int i=0;i<n-1;i++){\\n            if(nums[i]==0){\\n                int temp=nums[i];\\n                nums[i]=nums[i+1];\\n                nums[i+1]=temp;\\n            }\\n        }\\n        a++;\\n        }\\n        \\n    }\\n};\\n\\nWhy am i getting the TLE help\\n"
                    },
                    {
                        "username": "EatWorkSleep",
                        "content": "I think your solution works, but is too slow. You basically bubble up all the 0s to the right side of the array, but that takes around n*n conditional checks and swaps, which is more than the problem wants. Try to come up with something where you only need to check every position in the array once, while placing all the numbers in the right spots.\\n\\nIf you were given [1, 2, 3, 4, 5, 0, 0], your solution would check the first 6 numbers, except the last number, 6 times to bubble up all the 0s to the right side. That\\'s 36 checks, even though the array already is in the correct state the problem wants."
                    },
                    {
                        "username": "aditya13451",
                        "content": "helppp c++. someone plss tell why this is wrong.\\n\\n\\'\\'\\'\\nclass Solution {\\npublic:\\n    void moveZeroes(vector<int>& nums) {\\n        int left = 0;\\n        for(int right = 1; right < nums.size(); right++){\\n            if(left == 0){\\n                if(right != 0){\\n                    swap(nums[left],nums[right]);\\n                    left++;\\n                }\\n            }\\n            else{\\n                left++;\\n            }\\n        }\\n    }\\n};\\n\\n\\n\\n\\'\\'\\'"
                    },
                    {
                        "username": "emreesrc",
                        "content": "Can anyone tell me why i was getting error ?\n\n\n\n        var moveZeroes = function (nums) {\n         const checkZero = nums.filter((v) => v === 0).length;\n         const makeBool = nums.filter((item) => Boolean(item));\n         Array(checkZero)\n          .fill(0)\n          .forEach((elem, idx) => {\n             makeBool.push(0);\n         });\n           return makeBool;\n         };"
                    }
                ]
            }
        ]
    },
    {
        "title": "Peeking Iterator",
        "question_content": "<p>Design an iterator that supports the <code>peek</code> operation on an existing iterator in addition to the <code>hasNext</code> and the <code>next</code> operations.</p>\n\n<p>Implement the <code>PeekingIterator</code> class:</p>\n\n<ul>\n\t<li><code>PeekingIterator(Iterator&lt;int&gt; nums)</code> Initializes the object with the given integer iterator <code>iterator</code>.</li>\n\t<li><code>int next()</code> Returns the next element in the array and moves the pointer to the next element.</li>\n\t<li><code>boolean hasNext()</code> Returns <code>true</code> if there are still elements in the array.</li>\n\t<li><code>int peek()</code> Returns the next element in the array <strong>without</strong> moving the pointer.</li>\n</ul>\n\n<p><strong>Note:</strong> Each language may have a different implementation of the constructor and <code>Iterator</code>, but they all support the <code>int next()</code> and <code>boolean hasNext()</code> functions.</p>\n\n<p>&nbsp;</p>\n<p><strong class=\"example\">Example 1:</strong></p>\n\n<pre>\n<strong>Input</strong>\n[&quot;PeekingIterator&quot;, &quot;next&quot;, &quot;peek&quot;, &quot;next&quot;, &quot;next&quot;, &quot;hasNext&quot;]\n[[[1, 2, 3]], [], [], [], [], []]\n<strong>Output</strong>\n[null, 1, 2, 2, 3, false]\n\n<strong>Explanation</strong>\nPeekingIterator peekingIterator = new PeekingIterator([1, 2, 3]); // [<u><strong>1</strong></u>,2,3]\npeekingIterator.next();    // return 1, the pointer moves to the next element [1,<u><strong>2</strong></u>,3].\npeekingIterator.peek();    // return 2, the pointer does not move [1,<u><strong>2</strong></u>,3].\npeekingIterator.next();    // return 2, the pointer moves to the next element [1,2,<u><strong>3</strong></u>]\npeekingIterator.next();    // return 3, the pointer moves to the next element [1,2,3]\npeekingIterator.hasNext(); // return False\n</pre>\n\n<p>&nbsp;</p>\n<p><strong>Constraints:</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= nums.length &lt;= 1000</code></li>\n\t<li><code>1 &lt;= nums[i] &lt;= 1000</code></li>\n\t<li>All the calls to <code>next</code> and <code>peek</code> are valid.</li>\n\t<li>At most <code>1000</code> calls will be made to <code>next</code>, <code>hasNext</code>, and <code>peek</code>.</li>\n</ul>\n\n<p>&nbsp;</p>\n<strong>Follow up:</strong> How would you extend your design to be generic and work with all types, not just integer?",
        "solutions": [
            {
                "id": 72558,
                "title": "concise-java-solution",
                "content": "    class PeekingIterator implements Iterator<Integer> {  \\n        private Integer next = null;\\n        private Iterator<Integer> iter;\\n\\n        public PeekingIterator(Iterator<Integer> iterator) {\\n            // initialize any member here.\\n            iter = iterator;\\n            if (iter.hasNext())\\n                next = iter.next();\\n        }\\n        \\n        // Returns the next element in the iteration without advancing the iterator. \\n        public Integer peek() {\\n            return next; \\n        }\\n    \\n        // hasNext() and next() should behave the same as in the Iterator interface.\\n        // Override them if needed.\\n        @Override\\n        public Integer next() {\\n            Integer res = next;\\n            next = iter.hasNext() ? iter.next() : null;\\n            return res; \\n        }\\n\\n        @Override\\n        public boolean hasNext() {\\n            return next != null;\\n        }\\n    }\\n\\ncache the next element. If next is null, there is no more elements in iterator.\\n\\nEdit: check AlexTheGreat's answer. It's better.\\n\\nEdit after 2 years: the old solution didn't consider null values and @AlexTheGreat already posted the correct solution but looks like no one is checking his/her answer. So I took his/her answer as a reference:\\n```\\nimport java.util.NoSuchElementException;\\nclass PeekingIterator implements Iterator<Integer> {\\n    Integer next;\\n    Iterator<Integer> iter;\\n    boolean noSuchElement;\\n\\n    public PeekingIterator(Iterator<Integer> iterator) {\\n\\t// initialize any member here.\\n\\titer = iterator;\\n        advanceIter();\\n    }\\n\\n    // Returns the next element in the iteration without advancing the iterator.\\n    public Integer peek() {\\n        // you should confirm with interviewer what to return/throw\\n        // if there are no more values\\n        return next;\\n    }\\n\\n    // hasNext() and next() should behave the same as in the Iterator interface.\\n    // Override them if needed.\\n    @Override\\n    public Integer next() {\\n        if (noSuchElement)\\n            throw new NoSuchElementException();\\n        Integer res = next;\\n        advanceIter();\\n        return res;\\n    }\\n\\n    @Override \\n    public boolean hasNext() {\\n        return !noSuchElement;\\n    }\\n    \\n    private void advanceIter() {\\n        if (iter.hasNext()) {\\n            next = iter.next();\\n        } else {\\n            noSuchElement = true;\\n        }\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nimport java.util.NoSuchElementException;\\nclass PeekingIterator implements Iterator<Integer> {\\n    Integer next;\\n    Iterator<Integer> iter;\\n    boolean noSuchElement;\\n\\n    public PeekingIterator(Iterator<Integer> iterator) {\\n\\t// initialize any member here.\\n\\titer = iterator;\\n        advanceIter();\\n    }\\n\\n    // Returns the next element in the iteration without advancing the iterator.\\n    public Integer peek() {\\n        // you should confirm with interviewer what to return/throw\\n        // if there are no more values\\n        return next;\\n    }\\n\\n    // hasNext() and next() should behave the same as in the Iterator interface.\\n    // Override them if needed.\\n    @Override\\n    public Integer next() {\\n        if (noSuchElement)\\n            throw new NoSuchElementException();\\n        Integer res = next;\\n        advanceIter();\\n        return res;\\n    }\\n\\n    @Override \\n    public boolean hasNext() {\\n        return !noSuchElement;\\n    }\\n    \\n    private void advanceIter() {\\n        if (iter.hasNext()) {\\n            next = iter.next();\\n        } else {\\n            noSuchElement = true;\\n        }\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 72554,
                "title": "simple-c-solution-1-line-per-method-without-extra-member-variables",
                "content": "Since `Iterator` has a copy constructor, we can just use it:\\n\\n    class PeekingIterator : public Iterator\\n    {\\n    public:\\n        PeekingIterator(const vector<int> &nums) : Iterator(nums)\\n        {\\n        }\\n    \\n        int peek()\\n        {\\n            return Iterator(*this).next();\\n        }\\n    \\n        int next()\\n        {\\n            return Iterator::next();\\n        }\\n    \\n        bool hasNext() const\\n        {\\n            return Iterator::hasNext();\\n        }\\n    };",
                "solutionTags": [],
                "code": "Since `Iterator` has a copy constructor, we can just use it:\\n\\n    class PeekingIterator : public Iterator\\n    {\\n    public:\\n        PeekingIterator(const vector<int> &nums) : Iterator(nums)\\n        {\\n        }\\n    \\n        int peek()\\n        {\\n            return Iterator(*this).next();\\n        }\\n    \\n        int next()\\n        {\\n            return Iterator::next();\\n        }\\n    \\n        bool hasNext() const\\n        {\\n            return Iterator::hasNext();\\n        }\\n    };",
                "codeTag": "Java"
            },
            {
                "id": 72626,
                "title": "simple-python-solution",
                "content": "Store the next value outside the iterator.  When next is called return the stored value and populate with next value from iterator.\\n\\n    class PeekingIterator(object):\\n        def __init__(self, iterator):\\n            self.iter = iterator\\n            self.temp = self.iter.next() if self.iter.hasNext() else None\\n    \\n        def peek(self):\\n            return self.temp\\n    \\n        def next(self):\\n            ret = self.temp\\n            self.temp = self.iter.next() if self.iter.hasNext() else None\\n            return ret\\n    \\n        def hasNext(self):\\n            return self.temp is not None",
                "solutionTags": [
                    "Python"
                ],
                "code": "Store the next value outside the iterator.  When next is called return the stored value and populate with next value from iterator.\\n\\n    class PeekingIterator(object):\\n        def __init__(self, iterator):\\n            self.iter = iterator\\n            self.temp = self.iter.next() if self.iter.hasNext() else None\\n    \\n        def peek(self):\\n            return self.temp\\n    \\n        def next(self):\\n            ret = self.temp\\n            self.temp = self.iter.next() if self.iter.hasNext() else None\\n            return ret\\n    \\n        def hasNext(self):\\n            return self.temp is not None",
                "codeTag": "Java"
            },
            {
                "id": 1055887,
                "title": "c-iterators-caching-0ms-beats-100-explanation",
                "content": "**EXPLANATION**\\n- First define **private variables** as follows:\\n\\t- ```next_val``` : to store the **next value of the Iterator**\\n\\t- ```iter_hasnext``` : to store the **hasNext value of the Iterator**\\n```\\nint next_val; // keep a variable for storing the \"next value\" for use in \"peek\" function\\nbool iter_hasnext; // for storing the \"has next value\"\\n```\\n- In **PeekingIterator** constructor, store the **current Iterator has next value in ```has_next```** and the **current iterator next value in ```next_val```**, which will be used in ```hasNext()``` and ```peek()``` respectively.\\n```\\nPeekingIterator(const vector<int>& nums) : Iterator(nums) {\\n\\titer_hasnext=Iterator::hasNext(); // store current has_next value\\n\\tif (iter_hasnext)\\n\\t\\tnext_val = Iterator::next(); // store the \"next_val\" for \"future\" use in \"peek\" function\\n}\\n```\\n- For **peek()** function, return the **current stored ```next_val```**. *(cached previously in other functions)*\\n```\\nint peek() {\\n\\treturn next_val; // return current next_val\\n}\\n```\\n- For **next()** function, return the **```value of next_val```** and also **cache the next possible value of Iterator** in ```next_val```. Also **update** the ```iter_hasnext``` variable for using in ```hasNext()``` function.\\n```\\nint next() {\\n\\tint curr_next = next_val; // store the current next for returning\\n\\n\\titer_hasnext=Iterator::hasNext(); // change the iter_hasnext variable\\n\\tif (iter_hasnext) \\n\\t\\tnext_val = Iterator::next(); // change the next_val and move the iterator to next position\\n\\n\\treturn curr_next; // return the previously stored current next\\n}\\n```\\n- For **hasNext()** function, return the **current value of ```iter_hasnext```**.\\n```\\nbool hasNext() const {\\n\\treturn iter_hasnext; // return current iter_hashnext value\\n}\\n```\\n \\n \\n**COMPLETE CODE**\\n```\\nclass PeekingIterator : public Iterator {\\n    int next_val; // keep a variable for storing the \"next value\" for use in \"peek\" function\\n    bool iter_hasnext; // for storing the \"has next value\"\\npublic:\\n\\tPeekingIterator(const vector<int>& nums) : Iterator(nums) {\\n        iter_hasnext=Iterator::hasNext(); // store current has_next value\\n\\t    if (iter_hasnext)\\n            next_val = Iterator::next(); // store the \"next_val\" for \"future\" use in \"peek\" function\\n\\t}\\n\\t\\n\\tint peek() {\\n        return next_val; // return current next_val\\n\\t}\\n\\t\\n\\tint next() {\\n\\t    int curr_next = next_val; // store the current next for returning\\n        \\n        iter_hasnext=Iterator::hasNext(); // change the iter_hasnext variable\\n\\t    if (iter_hasnext) \\n            next_val = Iterator::next(); // change the next_val and move the iterator to next position\\n        \\n\\t    return curr_next; // return the previously stored current next\\n\\t}\\n\\t\\n\\tbool hasNext() const {\\n\\t    return iter_hasnext; // return current iter_hashnext value\\n\\t}\\n};\\n```\\n\\n\\n**TIME COMPLEXITY**\\n**peek(): O(1)**\\n**next() : O(1)**\\n**hasNext() : O(1)**\\n\\n**SPACE COMPLEXITY**\\n**O(1)**",
                "solutionTags": [
                    "C",
                    "Iterator"
                ],
                "code": "```next_val```\n```iter_hasnext```\n```\\nint next_val; // keep a variable for storing the \"next value\" for use in \"peek\" function\\nbool iter_hasnext; // for storing the \"has next value\"\\n```\n```has_next```\n```next_val```\n```hasNext()```\n```peek()```\n```\\nPeekingIterator(const vector<int>& nums) : Iterator(nums) {\\n\\titer_hasnext=Iterator::hasNext(); // store current has_next value\\n\\tif (iter_hasnext)\\n\\t\\tnext_val = Iterator::next(); // store the \"next_val\" for \"future\" use in \"peek\" function\\n}\\n```\n```next_val```\n```\\nint peek() {\\n\\treturn next_val; // return current next_val\\n}\\n```\n```value of next_val```\n```next_val```\n```iter_hasnext```\n```hasNext()```\n```\\nint next() {\\n\\tint curr_next = next_val; // store the current next for returning\\n\\n\\titer_hasnext=Iterator::hasNext(); // change the iter_hasnext variable\\n\\tif (iter_hasnext) \\n\\t\\tnext_val = Iterator::next(); // change the next_val and move the iterator to next position\\n\\n\\treturn curr_next; // return the previously stored current next\\n}\\n```\n```iter_hasnext```\n```\\nbool hasNext() const {\\n\\treturn iter_hasnext; // return current iter_hashnext value\\n}\\n```\n```\\nclass PeekingIterator : public Iterator {\\n    int next_val; // keep a variable for storing the \"next value\" for use in \"peek\" function\\n    bool iter_hasnext; // for storing the \"has next value\"\\npublic:\\n\\tPeekingIterator(const vector<int>& nums) : Iterator(nums) {\\n        iter_hasnext=Iterator::hasNext(); // store current has_next value\\n\\t    if (iter_hasnext)\\n            next_val = Iterator::next(); // store the \"next_val\" for \"future\" use in \"peek\" function\\n\\t}\\n\\t\\n\\tint peek() {\\n        return next_val; // return current next_val\\n\\t}\\n\\t\\n\\tint next() {\\n\\t    int curr_next = next_val; // store the current next for returning\\n        \\n        iter_hasnext=Iterator::hasNext(); // change the iter_hasnext variable\\n\\t    if (iter_hasnext) \\n            next_val = Iterator::next(); // change the next_val and move the iterator to next position\\n        \\n\\t    return curr_next; // return the previously stored current next\\n\\t}\\n\\t\\n\\tbool hasNext() const {\\n\\t    return iter_hasnext; // return current iter_hashnext value\\n\\t}\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 72598,
                "title": "another-c-solution-with-one-line-in-peek-and-hasnext-ac",
                "content": "    class PeekingIterator : public Iterator {\\n    private:\\n        int m_next;\\n        bool m_hasnext;\\n    public:\\n    \\tPeekingIterator(const vector<int>& nums) : Iterator(nums) {\\n    \\t    m_hasnext = Iterator::hasNext();\\n    \\t    if (m_hasnext) m_next = Iterator::next();\\n    \\t}\\n    \\n    \\tint peek() {\\n            return m_next;\\n    \\t}\\n    \\n    \\tint next() {\\n    \\t    int t = m_next;\\n    \\t    m_hasnext = Iterator::hasNext();\\n    \\t    if (m_hasnext) m_next = Iterator::next();\\n    \\t    return t;\\n    \\t}\\n    \\n    \\tbool hasNext() const {\\n    \\t    return m_hasnext;\\n    \\t}\\n    };",
                "solutionTags": [
                    "C++"
                ],
                "code": "    class PeekingIterator : public Iterator {\\n    private:\\n        int m_next;\\n        bool m_hasnext;\\n    public:\\n    \\tPeekingIterator(const vector<int>& nums) : Iterator(nums) {\\n    \\t    m_hasnext = Iterator::hasNext();\\n    \\t    if (m_hasnext) m_next = Iterator::next();\\n    \\t}\\n    \\n    \\tint peek() {\\n            return m_next;\\n    \\t}\\n    \\n    \\tint next() {\\n    \\t    int t = m_next;\\n    \\t    m_hasnext = Iterator::hasNext();\\n    \\t    if (m_hasnext) m_next = Iterator::next();\\n    \\t    return t;\\n    \\t}\\n    \\n    \\tbool hasNext() const {\\n    \\t    return m_hasnext;\\n    \\t}\\n    };",
                "codeTag": "Java"
            },
            {
                "id": 1055803,
                "title": "python-simple-solution-explained",
                "content": "This is more design problem, not algorithmic one in my opinion. You already given implemented class `iterator`, which you can understand as list, but it is not list. The goal is to implement so-called peeking iterator and to do this we need to be one step ahead: let us create `self.buffer` variable, which will keep next value from our iterator.\\n\\n1. When we call `peek` function, we just return value from our buffer.\\n2. When we call `next` function, we write buffer variable to `tmp`, then we update our buffer: if we have next element, we go to the next element, if we do not have it we make it equal to `None`.\\n3. Finally, `hasNext` function now is just checking if buffer is empty or not.\\n\\n**Complexity**: it is `O(1)` for all operations, if it was `O(1)` for original `iterator` class.\\n\\n```\\nclass PeekingIterator:\\n    def __init__(self, iterator):\\n        self.iterator = iterator\\n        self.buffer = self.iterator.next() if self.iterator.hasNext() else None\\n        \\n    def peek(self):\\n        return self.buffer\\n        \\n    def next(self):\\n        tmp = self.buffer\\n        self.buffer = self.iterator.next() if self.iterator.hasNext() else None\\n        return tmp\\n        \\n    def hasNext(self):\\n        return self.buffer != None\\n```\\n\\nIf you have any questions, feel free to ask. If you like solution and explanations, please **Upvote!**",
                "solutionTags": [
                    "Design"
                ],
                "code": "```\\nclass PeekingIterator:\\n    def __init__(self, iterator):\\n        self.iterator = iterator\\n        self.buffer = self.iterator.next() if self.iterator.hasNext() else None\\n        \\n    def peek(self):\\n        return self.buffer\\n        \\n    def next(self):\\n        tmp = self.buffer\\n        self.buffer = self.iterator.next() if self.iterator.hasNext() else None\\n        return tmp\\n        \\n    def hasNext(self):\\n        return self.buffer != None\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1980353,
                "title": "two-cpp-solution-with-explanation",
                "content": "![image](https://assets.leetcode.com/users/images/0c357ae9-00b7-4677-9610-1b7383d4637f_1650864187.8238986.jpeg)\\n\\n**CODE BELOW**\\n\\n\\n```\\nclass PeekingIterator : public Iterator {\\npublic:\\n\\n    vector<int>v;\\n    int i=0;\\n\\tPeekingIterator(const vector<int>& nums) : Iterator(nums) {\\n\\t    v=nums;\\n\\t}\\n\\t\\n\\tint peek() {\\n        return v[i];\\n\\t}\\n\\t\\n\\tint next() {\\n\\t    return v[i++];\\n\\t}\\n\\t\\n\\tbool hasNext() const {\\n\\t   if(i<v.size()){\\n           return true;\\n       } \\n        return false;\\n\\t}\\n};\\n```\\n\\n\\n# **APPROACH 2\\n\\n![image](https://assets.leetcode.com/users/images/768cf642-4a21-467a-bf8d-2b3274985321_1650864343.4238212.jpeg)\\n\\n\\n\\n**CODE BELOW**\\n\\n```\\nclass PeekingIterator : public Iterator {\\npublic:\\n\\tPeekingIterator(const vector<int>& nums) : Iterator(nums) {\\n\\t   \\n\\t}\\n\\t\\n\\tint peek() {\\n        Iterator it= *this; //no function defines for peek so we create a function for it.\\n        return it.next();\\n\\t}\\n\\t\\n\\tint next() {\\n\\t    return Iterator ::next(); //calling next function\\n\\t}\\n\\t\\n\\tbool hasNext() const {\\n\\t   return Iterator:: hasNext(); //calling hasnext function\\n\\t}\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass PeekingIterator : public Iterator {\\npublic:\\n\\n    vector<int>v;\\n    int i=0;\\n\\tPeekingIterator(const vector<int>& nums) : Iterator(nums) {\\n\\t    v=nums;\\n\\t}\\n\\t\\n\\tint peek() {\\n        return v[i];\\n\\t}\\n\\t\\n\\tint next() {\\n\\t    return v[i++];\\n\\t}\\n\\t\\n\\tbool hasNext() const {\\n\\t   if(i<v.size()){\\n           return true;\\n       } \\n        return false;\\n\\t}\\n};\\n```\n```\\nclass PeekingIterator : public Iterator {\\npublic:\\n\\tPeekingIterator(const vector<int>& nums) : Iterator(nums) {\\n\\t   \\n\\t}\\n\\t\\n\\tint peek() {\\n        Iterator it= *this; //no function defines for peek so we create a function for it.\\n        return it.next();\\n\\t}\\n\\t\\n\\tint next() {\\n\\t    return Iterator ::next(); //calling next function\\n\\t}\\n\\t\\n\\tbool hasNext() const {\\n\\t   return Iterator:: hasNext(); //calling hasnext function\\n\\t}\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1980013,
                "title": "java-explanation",
                "content": "**Key Point\\'s to remember :-**\\n\\n* **next()** will return the value at current itearator and then increments the iterator (cache the next value)\\n\\n\\n* **hasNext()** tells is there any element after the current iterator\\n* **peek()** will only return the curr element will not increment the iterator\\n\\n```\\nclass PeekingIterator implements Iterator<Integer> {\\n    \\n    Iterator<Integer> iter = null;\\n    Integer next = null;\\n    \\n\\tpublic PeekingIterator(Iterator<Integer> iterator) {\\n\\t    // initialize any member here.\\n\\t    iter = iterator;\\n        if(hasNext()) next = iter.next();\\n\\t}\\n\\t\\n    // Returns the next element in the iteration without advancing the iterator.\\n\\tpublic Integer peek() {\\n        return next;\\n\\t}\\n\\t\\n\\t// hasNext() and next() should behave the same as in the Iterator interface.\\n\\t// Override them if needed.\\n\\t@Override\\n\\tpublic Integer next() {\\n\\t    Integer currVal = next;\\n        if(iter.hasNext()) \\n            next = iter.next();\\n        else \\n            next = null;\\n        return currVal;\\n\\t}\\n\\t\\n\\t@Override\\n\\tpublic boolean hasNext() {\\n\\t    return next != null || iter.hasNext();\\n\\t}\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass PeekingIterator implements Iterator<Integer> {\\n    \\n    Iterator<Integer> iter = null;\\n    Integer next = null;\\n    \\n\\tpublic PeekingIterator(Iterator<Integer> iterator) {\\n\\t    // initialize any member here.\\n\\t    iter = iterator;\\n        if(hasNext()) next = iter.next();\\n\\t}\\n\\t\\n    // Returns the next element in the iteration without advancing the iterator.\\n\\tpublic Integer peek() {\\n        return next;\\n\\t}\\n\\t\\n\\t// hasNext() and next() should behave the same as in the Iterator interface.\\n\\t// Override them if needed.\\n\\t@Override\\n\\tpublic Integer next() {\\n\\t    Integer currVal = next;\\n        if(iter.hasNext()) \\n            next = iter.next();\\n        else \\n            next = null;\\n        return currVal;\\n\\t}\\n\\t\\n\\t@Override\\n\\tpublic boolean hasNext() {\\n\\t    return next != null || iter.hasNext();\\n\\t}\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1055977,
                "title": "python-3-greedy-and-lazy-24ms",
                "content": "# Greedy approach, 24ms\\n- Preload next item as a current value.\\n- ```next()``` returns current value and preloads next item again. Pay attention on the last item (```iterator.hasNext()``` returns False).\\n- ```peek()``` and ```hasNext()``` return preloaded values.\\n```\\nclass PeekingIterator:\\n    def __init__(self, iterator):\\n        self._iterator = iterator\\n        self._current = None\\n        self._hasNext = True\\n        self.next()\\n\\n    def peek(self):\\n        return self._current\\n\\n    def next(self):\\n        current = self._current\\n        if self._iterator.hasNext():\\n            self._current = self._iterator.next()\\n        else:\\n            self._hasNext = False\\n            \\n        return current\\n\\n    def hasNext(self):\\n        return self._hasNext\\n```\\n\\n# Lazy approach\\n- Use a flag to indicate the next value was peeked.\\n- ```peek()``` preloads next item if the flag is unset.\\n- ```next()``` does not load next item if the flag is set.\\n- ```hasNext()``` does not check next item if the flag is set.\\n```\\nclass PeekingIterator:\\n    def __init__(self, iterator):\\n        self._iterator = iterator\\n        self._peeked = False\\n        self._current = None\\n\\n    def peek(self):\\n        if not self._peeked:\\n            self._current = self._iterator.next()\\n            self._peeked = True\\n\\n        return self._current\\n        \\n    def next(self):\\n        if self._peeked:\\n            self._peeked = False\\n        else: \\n            self._current = self._iterator.next()\\n\\n        return self._current \\n        \\n    def hasNext(self):\\n        return self._peeked or self._iterator.hasNext()\\n```",
                "solutionTags": [
                    "Python",
                    "Greedy"
                ],
                "code": "```next()```\n```iterator.hasNext()```\n```peek()```\n```hasNext()```\n```\\nclass PeekingIterator:\\n    def __init__(self, iterator):\\n        self._iterator = iterator\\n        self._current = None\\n        self._hasNext = True\\n        self.next()\\n\\n    def peek(self):\\n        return self._current\\n\\n    def next(self):\\n        current = self._current\\n        if self._iterator.hasNext():\\n            self._current = self._iterator.next()\\n        else:\\n            self._hasNext = False\\n            \\n        return current\\n\\n    def hasNext(self):\\n        return self._hasNext\\n```\n```peek()```\n```next()```\n```hasNext()```\n```\\nclass PeekingIterator:\\n    def __init__(self, iterator):\\n        self._iterator = iterator\\n        self._peeked = False\\n        self._current = None\\n\\n    def peek(self):\\n        if not self._peeked:\\n            self._current = self._iterator.next()\\n            self._peeked = True\\n\\n        return self._current\\n        \\n    def next(self):\\n        if self._peeked:\\n            self._peeked = False\\n        else: \\n            self._current = self._iterator.next()\\n\\n        return self._current \\n        \\n    def hasNext(self):\\n        return self._peeked or self._iterator.hasNext()\\n```",
                "codeTag": "Java"
            },
            {
                "id": 72650,
                "title": "10-line-c-and-14-line-java-implementation",
                "content": "    class PeekingIterator : public Iterator {\\n        bool hasPeeked;\\n        int peekedElem;\\n    public:\\n    \\tPeekingIterator(const vector<int>& num) : Iterator(num) {\\n            hasPeeked = false;\\n    \\t}\\n    \\n    \\tint peek() {\\n            peekedElem = hasPeeked?peekedElem:Iterator::next();\\n            hasPeeked = true;\\n            return peekedElem;\\n    \\t}\\n    \\n    \\tint next() {\\n    \\t    int nextElem = hasPeeked?peekedElem:Iterator::next();\\n    \\t    hasPeeked = false;\\n    \\t    return nextElem;\\n    \\t}\\n    \\n    \\tbool hasNext() const {\\n    \\t    return hasPeeked||Iterator::hasNext();\\n    \\t}\\n    };  \\n\\nJava implementation, inspired by Google's guava library source code.\\n\\n    class PeekingIterator implements Iterator<Integer> {\\n        private final Iterator<Integer> iterator;\\n        private boolean hasPeeked;\\n        private Integer peekedElement;\\n        \\n    \\tpublic PeekingIterator(Iterator<Integer> iterator) {\\n    \\t    if(iterator==null)\\n    \\t        throw new NullPointerException();\\n    \\t    else\\n    \\t        this.iterator = iterator;\\n    \\t}\\n    \\n    \\tpublic Integer peek() {\\n            peekedElement = hasPeeked?peekedElement:iterator.next();\\n            hasPeeked = true;\\n            return peekedElement;\\n    \\t}\\n    \\n    \\t@Override\\n    \\tpublic Integer next() {\\n    \\t    int nextElem = hasPeeked?peekedElement:iterator.next();\\n            hasPeeked = false;\\n            return nextElem;\\n    \\t}\\n    \\n    \\t@Override\\n    \\tpublic boolean hasNext() {\\n    \\t    return hasPeeked || iterator.hasNext();\\n    \\t}\\n    }",
                "solutionTags": [
                    "C++",
                    "Java"
                ],
                "code": "    class PeekingIterator : public Iterator {\\n        bool hasPeeked;\\n        int peekedElem;\\n    public:\\n    \\tPeekingIterator(const vector<int>& num) : Iterator(num) {\\n            hasPeeked = false;\\n    \\t}\\n    \\n    \\tint peek() {\\n            peekedElem = hasPeeked?peekedElem:Iterator::next();\\n            hasPeeked = true;\\n            return peekedElem;\\n    \\t}\\n    \\n    \\tint next() {\\n    \\t    int nextElem = hasPeeked?peekedElem:Iterator::next();\\n    \\t    hasPeeked = false;\\n    \\t    return nextElem;\\n    \\t}\\n    \\n    \\tbool hasNext() const {\\n    \\t    return hasPeeked||Iterator::hasNext();\\n    \\t}\\n    };  \\n\\nJava implementation, inspired by Google's guava library source code.\\n\\n    class PeekingIterator implements Iterator<Integer> {\\n        private final Iterator<Integer> iterator;\\n        private boolean hasPeeked;\\n        private Integer peekedElement;\\n        \\n    \\tpublic PeekingIterator(Iterator<Integer> iterator) {\\n    \\t    if(iterator==null)\\n    \\t        throw new NullPointerException();\\n    \\t    else\\n    \\t        this.iterator = iterator;\\n    \\t}\\n    \\n    \\tpublic Integer peek() {\\n            peekedElement = hasPeeked?peekedElement:iterator.next();\\n            hasPeeked = true;\\n            return peekedElement;\\n    \\t}\\n    \\n    \\t@Override\\n    \\tpublic Integer next() {\\n    \\t    int nextElem = hasPeeked?peekedElement:iterator.next();\\n            hasPeeked = false;\\n            return nextElem;\\n    \\t}\\n    \\n    \\t@Override\\n    \\tpublic boolean hasNext() {\\n    \\t    return hasPeeked || iterator.hasNext();\\n    \\t}\\n    }",
                "codeTag": "Java"
            },
            {
                "id": 1979837,
                "title": "python3-simple-soln",
                "content": "```\\nclass PeekingIterator:\\n    def __init__(self, iterator):\\n        \"\"\"\\n        Initialize your data structure here.\\n        :type iterator: Iterator\\n        \"\"\"\\n        self.iterator = iterator\\n        self.current = self.iterator.next() if self.iterator.hasNext() else None        \\n\\n    def peek(self):\\n        \"\"\"\\n        Returns the next element in the iteration without advancing the iterator.\\n        :rtype: int\\n        \"\"\"\\n        return self.current\\n        \\n\\n    def next(self):\\n        \"\"\"\\n        :rtype: int\\n        \"\"\"\\n        value = self.current\\n        self.current = self.iterator.next() if self.iterator.hasNext() else None       \\n        return value\\n            \\n    def hasNext(self):\\n        \"\"\"\\n        :rtype: bool\\n        \"\"\"\\n        return self.current != None\\n      \\n",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass PeekingIterator:\\n    def __init__(self, iterator):\\n        \"\"\"\\n        Initialize your data structure here.\\n        :type iterator: Iterator\\n        \"\"\"\\n        self.iterator = iterator\\n        self.current = self.iterator.next() if self.iterator.hasNext() else None        \\n\\n    def peek(self):\\n        \"\"\"\\n        Returns the next element in the iteration without advancing the iterator.\\n        :rtype: int\\n        \"\"\"\\n        return self.current\\n        \\n\\n    def next(self):\\n        \"\"\"\\n        :rtype: int\\n        \"\"\"\\n        value = self.current\\n        self.current = self.iterator.next() if self.iterator.hasNext() else None       \\n        return value\\n            \\n    def hasNext(self):\\n        \"\"\"\\n        :rtype: bool\\n        \"\"\"\\n        return self.current != None\\n      \\n",
                "codeTag": "Java"
            },
            {
                "id": 1055835,
                "title": "c-simple-and-easy-solution",
                "content": "```\\nclass PeekingIterator : public Iterator {\\npublic:\\n\\tPeekingIterator(const vector<int>& nums) : Iterator(nums) {\\n        m_has_next = Iterator::hasNext();\\n\\t    if (m_has_next) \\n            m_next = Iterator::next();\\n\\t}\\n\\t\\n\\tint peek() {\\n        return m_next;\\n\\t}\\n\\t\\n\\tint next() {\\n\\t    int temp = m_next;\\n        m_has_next = Iterator::hasNext();\\n        if (m_has_next) m_next = Iterator::next();\\n        return temp;\\n\\t}\\n\\t\\n\\tbool hasNext() const {\\n\\t    return m_has_next;\\n\\t}\\n    \\nprivate:\\n    int m_next;\\n    bool m_has_next;\\n};\\n```\\n**Like it? please upvote...**",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass PeekingIterator : public Iterator {\\npublic:\\n\\tPeekingIterator(const vector<int>& nums) : Iterator(nums) {\\n        m_has_next = Iterator::hasNext();\\n\\t    if (m_has_next) \\n            m_next = Iterator::next();\\n\\t}\\n\\t\\n\\tint peek() {\\n        return m_next;\\n\\t}\\n\\t\\n\\tint next() {\\n\\t    int temp = m_next;\\n        m_has_next = Iterator::hasNext();\\n        if (m_has_next) m_next = Iterator::next();\\n        return temp;\\n\\t}\\n\\t\\n\\tbool hasNext() const {\\n\\t    return m_has_next;\\n\\t}\\n    \\nprivate:\\n    int m_next;\\n    bool m_has_next;\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 72606,
                "title": "simple-java-solution-by-caching-next-element",
                "content": "quite straight forward solution by caching the next element and handling hasNext() and next() by using cached entry.\\n\\n\\n    class PeekingIterator implements Iterator<Integer> {\\n        Integer cache = null;\\n        Iterator<Integer> it;\\n        \\n    \\tpublic PeekingIterator(Iterator<Integer> iterator) {\\n    \\t    // initialize any member here.\\n    \\t    this.it = iterator;\\n    \\t    cache = it.next();\\n    \\t}\\n    \\n        // Returns the next element in the iteration without advancing the iterator.\\n    \\tpublic Integer peek() {\\n            return cache;\\n    \\t}\\n    \\n    \\t// hasNext() and next() should behave the same as in the Iterator interface.\\n    \\t// Override them if needed.\\n    \\t@Override\\n    \\tpublic Integer next() {\\n    \\t    int ret = cache;\\n    \\t    if(it.hasNext()){\\n    \\t        cache = it.next();\\n    \\t    }\\n    \\t    else{\\n    \\t        cache = null;\\n    \\t    }\\n    \\t    return ret;\\n    \\t}\\n    \\n    \\t@Override\\n    \\tpublic boolean hasNext() {\\n    \\t    return (cache != null);\\n    \\t}\\n    }",
                "solutionTags": [],
                "code": "quite straight forward solution by caching the next element and handling hasNext() and next() by using cached entry.\\n\\n\\n    class PeekingIterator implements Iterator<Integer> {\\n        Integer cache = null;\\n        Iterator<Integer> it;\\n        \\n    \\tpublic PeekingIterator(Iterator<Integer> iterator) {\\n    \\t    // initialize any member here.\\n    \\t    this.it = iterator;\\n    \\t    cache = it.next();\\n    \\t}\\n    \\n        // Returns the next element in the iteration without advancing the iterator.\\n    \\tpublic Integer peek() {\\n            return cache;\\n    \\t}\\n    \\n    \\t// hasNext() and next() should behave the same as in the Iterator interface.\\n    \\t// Override them if needed.\\n    \\t@Override\\n    \\tpublic Integer next() {\\n    \\t    int ret = cache;\\n    \\t    if(it.hasNext()){\\n    \\t        cache = it.next();\\n    \\t    }\\n    \\t    else{\\n    \\t        cache = null;\\n    \\t    }\\n    \\t    return ret;\\n    \\t}\\n    \\n    \\t@Override\\n    \\tpublic boolean hasNext() {\\n    \\t    return (cache != null);\\n    \\t}\\n    }",
                "codeTag": "Java"
            },
            {
                "id": 72570,
                "title": "my-4ms-c-supper-easy-solution",
                "content": "    class PeekingIterator : public Iterator {\\n     public:\\n     PeekingIterator(const vector<int>& nums) : Iterator(nums) {\\n        // Initialize any member here.\\n        // **DO NOT** save a copy of nums and manipulate it directly.\\n        // You should only use the Iterator interface methods.\\n\\n    }\\n\\n    // Returns the next element in the iteration without advancing the iterator.\\n    int peek() {\\n        if(hasNext()){\\n            Iterator it(*this);\\n            return it.next();\\n        }\\n    }\\n\\n    // hasNext() and next() should behave the same as in the Iterator interface.\\n    // Override them if needed.\\n    int next() {\\n        Iterator::next();\\n    }\\n\\n    bool hasNext() const {\\n        Iterator::hasNext();\\n    }\\n};",
                "solutionTags": [],
                "code": "    class PeekingIterator : public Iterator {\\n     public:\\n     PeekingIterator(const vector<int>& nums) : Iterator(nums) {\\n        // Initialize any member here.\\n        // **DO NOT** save a copy of nums and manipulate it directly.\\n        // You should only use the Iterator interface methods.\\n\\n    }\\n\\n    // Returns the next element in the iteration without advancing the iterator.\\n    int peek() {\\n        if(hasNext()){\\n            Iterator it(*this);\\n            return it.next();\\n        }\\n    }\\n\\n    // hasNext() and next() should behave the same as in the Iterator interface.\\n    // Override them if needed.\\n    int next() {\\n        Iterator::next();\\n    }\\n\\n    bool hasNext() const {\\n        Iterator::hasNext();\\n    }\\n};",
                "codeTag": "Java"
            },
            {
                "id": 1055989,
                "title": "python-easy-solution-o-1-89-beats",
                "content": "```\\nclass PeekingIterator:\\n    def __init__(self, iterator):\\n        \"\"\"\\n        Initialize your data structure here.\\n        :type iterator: Iterator\\n        \"\"\"\\n        self.iterator = iterator\\n        self.to_peek = self.iterator.next() if self.iterator.hasNext() else None\\n\\n    def peek(self):\\n        \"\"\"\\n        Returns the next element in the iteration without advancing the iterator.\\n        :rtype: int\\n        \"\"\"\\n        return self.to_peek\\n\\n    def next(self):\\n        \"\"\"\\n        :rtype: int\\n        \"\"\"\\n        temp = self.to_peek\\n        self.to_peek = self.iterator.next() if self.iterator.hasNext() else None\\n        return temp\\n\\n        \\n\\n    def hasNext(self):\\n        \"\"\"\\n        :rtype: bool\\n        \"\"\"\\n        return self.to_peek is not None\\n\\n```\\nPlease upvote if you get it.",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nclass PeekingIterator:\\n    def __init__(self, iterator):\\n        \"\"\"\\n        Initialize your data structure here.\\n        :type iterator: Iterator\\n        \"\"\"\\n        self.iterator = iterator\\n        self.to_peek = self.iterator.next() if self.iterator.hasNext() else None\\n\\n    def peek(self):\\n        \"\"\"\\n        Returns the next element in the iteration without advancing the iterator.\\n        :rtype: int\\n        \"\"\"\\n        return self.to_peek\\n\\n    def next(self):\\n        \"\"\"\\n        :rtype: int\\n        \"\"\"\\n        temp = self.to_peek\\n        self.to_peek = self.iterator.next() if self.iterator.hasNext() else None\\n        return temp\\n\\n        \\n\\n    def hasNext(self):\\n        \"\"\"\\n        :rtype: bool\\n        \"\"\"\\n        return self.to_peek is not None\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1055952,
                "title": "js-python-java-c-simple-class-solution-w-explanation-beats-100-100",
                "content": "*(Note: This is part of a series of Leetcode solution explanations ([**index**](https://dev.to/seanpgallivan/leetcode-solutions-index-57fl)). If you like this solution or find it useful,* ***please upvote*** *this post.)*\\n\\n---\\n\\n***Idea:***\\n\\nThe trick here is realizing that you\\'re not building the **class** from scratch. Instead, you\\'re building a class that is constructed from *another* class instance.\\n\\nOur new class will do the same things that the original class does, except that it will store the next value separately, so that we can **peek** at it without it being removed. The only challenging thing at this point is to make sure that the **next** function checks to make sure if there actually *is* a next element before updating the stored value.\\n\\n---\\n\\n***Javascript Code:***\\n\\nThe best result for the code below is **72ms / 39.0MB** (beats 93% / 83%).\\n```javascript\\nclass PeekingIterator {\\n    constructor(iterator) {\\n        this.iterator = iterator\\n        this.nextVal = this.iterator.hasNext() ? this.iterator.next() : null\\n    };\\n    \\n    peek() {\\n        return this.nextVal\\n    };\\n    \\n    next() {\\n        let nextVal = this.nextVal\\n        this.nextVal = this.iterator.hasNext() ? this.iterator.next() : null\\n        return nextVal\\n    };\\n    \\n    hasNext() {\\n        return !!this.nextVal\\n    };\\n};\\n```\\n\\n---\\n\\n***Python Code:***\\n\\nThe best result for the code below is **20ms / 14.2MB** (beats 99% / 100%).\\n```python\\nclass PeekingIterator:\\n    def __init__(self, iterator):\\n        self.iterator = iterator\\n        self.nextVal = self.iterator.next() if self.iterator.hasNext() else None\\n        \\n    def peek(self):\\n        return self.nextVal\\n        \\n    def next(self):\\n        nextVal = self.nextVal\\n        self.nextVal = self.iterator.next() if self.iterator.hasNext() else None\\n        return nextVal\\n\\n    def hasNext(self):\\n        return bool(self.nextVal)\\n```\\n\\n---\\n\\n***Java Code:***\\n\\nThe best result for the code below is **4ms / 38.6MB** (beats 94% / 96%).\\n```java\\nclass PeekingIterator implements Iterator<Integer> {\\n    Iterator<Integer> iter;\\n    Integer nextVal;\\n\\t\\n    public PeekingIterator(Iterator<Integer> iterator) {\\n\\t    iter = iterator;\\n        nextVal = iter.hasNext() ? iter.next() : null;\\n\\t}\\n\\t\\n\\tpublic Integer peek() {\\n        return nextVal;\\n\\t}\\n\\t\\n\\t@Override\\n    public Integer next() {\\n        Integer oldNext = nextVal;\\n        nextVal = iter.hasNext() ? iter.next() : null;\\n        return oldNext; \\n    }\\n\\t\\n\\t@Override\\n\\tpublic boolean hasNext() {\\n\\t    return (nextVal != null);\\n\\t}\\n}\\n```\\n\\n---\\n\\n***C++ Code:***\\n\\nThe best result for the code below is **0ms / 7.3MB** (beats 100% / 94%).\\n```C++\\nclass PeekingIterator : public Iterator {\\npublic:\\n    int nextVal;\\n\\t\\n    PeekingIterator(const vector<int>& nums) : Iterator(nums) {\\n        nextVal = Iterator::hasNext() ? Iterator::next() : NULL;\\n\\t}\\n\\t\\n\\tint peek() {\\n        return nextVal;\\n\\t}\\n\\t\\n\\tint next() {\\n\\t    int oldNext = nextVal;\\n        nextVal = Iterator::hasNext() ? Iterator::next() : NULL;\\n        return oldNext; \\n\\t}\\n\\t\\n\\tbool hasNext() const {\\n\\t    return (nextVal != NULL);\\n\\t}\\n};\\n```",
                "solutionTags": [],
                "code": "```javascript\\nclass PeekingIterator {\\n    constructor(iterator) {\\n        this.iterator = iterator\\n        this.nextVal = this.iterator.hasNext() ? this.iterator.next() : null\\n    };\\n    \\n    peek() {\\n        return this.nextVal\\n    };\\n    \\n    next() {\\n        let nextVal = this.nextVal\\n        this.nextVal = this.iterator.hasNext() ? this.iterator.next() : null\\n        return nextVal\\n    };\\n    \\n    hasNext() {\\n        return !!this.nextVal\\n    };\\n};\\n```\n```python\\nclass PeekingIterator:\\n    def __init__(self, iterator):\\n        self.iterator = iterator\\n        self.nextVal = self.iterator.next() if self.iterator.hasNext() else None\\n        \\n    def peek(self):\\n        return self.nextVal\\n        \\n    def next(self):\\n        nextVal = self.nextVal\\n        self.nextVal = self.iterator.next() if self.iterator.hasNext() else None\\n        return nextVal\\n\\n    def hasNext(self):\\n        return bool(self.nextVal)\\n```\n```java\\nclass PeekingIterator implements Iterator<Integer> {\\n    Iterator<Integer> iter;\\n    Integer nextVal;\\n\\t\\n    public PeekingIterator(Iterator<Integer> iterator) {\\n\\t    iter = iterator;\\n        nextVal = iter.hasNext() ? iter.next() : null;\\n\\t}\\n\\t\\n\\tpublic Integer peek() {\\n        return nextVal;\\n\\t}\\n\\t\\n\\t@Override\\n    public Integer next() {\\n        Integer oldNext = nextVal;\\n        nextVal = iter.hasNext() ? iter.next() : null;\\n        return oldNext; \\n    }\\n\\t\\n\\t@Override\\n\\tpublic boolean hasNext() {\\n\\t    return (nextVal != null);\\n\\t}\\n}\\n```\n```C++\\nclass PeekingIterator : public Iterator {\\npublic:\\n    int nextVal;\\n\\t\\n    PeekingIterator(const vector<int>& nums) : Iterator(nums) {\\n        nextVal = Iterator::hasNext() ? Iterator::next() : NULL;\\n\\t}\\n\\t\\n\\tint peek() {\\n        return nextVal;\\n\\t}\\n\\t\\n\\tint next() {\\n\\t    int oldNext = nextVal;\\n        nextVal = Iterator::hasNext() ? Iterator::next() : NULL;\\n        return oldNext; \\n\\t}\\n\\t\\n\\tbool hasNext() const {\\n\\t    return (nextVal != NULL);\\n\\t}\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 72599,
                "title": "concise-java-solution-beats-99-52-95ms-by-caching-next-element",
                "content": "    class PeekingIterator implements Iterator<Integer> {\\n    \\n        Integer peek;  // use to visit and store the next element\\n        Iterator<Integer> it;\\n        \\n    \\tpublic PeekingIterator(Iterator<Integer> iterator) {\\n    \\t    it = iterator;\\n            peek = it.hasNext()?it.next():null;\\n    \\t}\\n    \\n    \\tpublic Integer peek() {\\n            return peek;        \\n    \\t}\\n    \\n    \\t@Override\\n    \\tpublic Integer next() {\\n            if (peek==null) throw new java.util.NoSuchElementException();\\n    \\t    Integer ret = peek;\\n            peek = it.hasNext()?it.next():null;\\n            return ret;\\n    \\t}\\n    \\n    \\t@Override\\n    \\tpublic boolean hasNext() {\\n    \\t    return peek!=null;\\n    \\t}\\n    \\t\\n    }",
                "solutionTags": [],
                "code": "    class PeekingIterator implements Iterator<Integer> {\\n    \\n        Integer peek;  // use to visit and store the next element\\n        Iterator<Integer> it;\\n        \\n    \\tpublic PeekingIterator(Iterator<Integer> iterator) {\\n    \\t    it = iterator;\\n            peek = it.hasNext()?it.next():null;\\n    \\t}\\n    \\n    \\tpublic Integer peek() {\\n            return peek;        \\n    \\t}\\n    \\n    \\t@Override\\n    \\tpublic Integer next() {\\n            if (peek==null) throw new java.util.NoSuchElementException();\\n    \\t    Integer ret = peek;\\n            peek = it.hasNext()?it.next():null;\\n            return ret;\\n    \\t}\\n    \\n    \\t@Override\\n    \\tpublic boolean hasNext() {\\n    \\t    return peek!=null;\\n    \\t}\\n    \\t\\n    }",
                "codeTag": "Java"
            },
            {
                "id": 1980040,
                "title": "easy-and-clean-code-to-understand-with-without-null",
                "content": "***APPROACH 1 : WITHOUT SETTING PEEK VALUE TO NULL***\\n```\\n// Java Iterator interface reference:\\n// https://docs.oracle.com/javase/8/docs/api/java/util/Iterator.html\\nclass PeekingIterator implements Iterator<Integer> {\\n    \\n    private Iterator<Integer> _iterator;\\n    private Integer peekVal=null;\\n    private boolean empty;\\n    \\n\\tpublic PeekingIterator(Iterator<Integer> iterator) {\\n\\t    // initialize any member here.\\n\\t    this._iterator = iterator;\\n\\t    this.empty = !iterator.hasNext();\\n\\t    this.peekVal = iterator.next();\\n\\t}\\n\\n    // Returns the next element in the iteration without advancing the iterator.\\n\\tpublic Integer peek() {\\n        return peekVal;\\n\\t}\\n\\n\\t// hasNext() and next() should behave the same as in the Iterator interface.\\n\\t// Override them if needed.\\n\\t@Override\\n\\tpublic Integer next() {\\n\\t    int result = peekVal;\\n\\t    if(_iterator.hasNext()) peekVal = _iterator.next();\\n\\t    else {\\n\\t        empty=true;\\n\\t        peekVal=null;\\n\\t    }\\n\\t    return result;\\n\\t}\\n\\n\\t@Override\\n\\tpublic boolean hasNext() {\\n\\t    return !empty;\\n\\t}\\n}\\n```\\n***APPROACH 2 : USING NULL AS AN INTEGER VALUE***\\n```\\n// Java Iterator interface reference:\\n// https://docs.oracle.com/javase/8/docs/api/java/util/Iterator.html\\n\\nclass PeekingIterator implements Iterator<Integer> {\\n\\tIterator<Integer> iterator;\\n\\nInteger mid = null;\\nboolean hasNext = false;\\n\\npublic PeekingIterator(Iterator<Integer> iterator) {\\n    // initialize any member here.\\n    this.iterator = iterator;\\n    if (iterator.hasNext()) {\\n        mid = iterator.next();\\n        hasNext = true;\\n    }\\n}\\n\\n// Returns the next element in the iteration without advancing the iterator.\\npublic Integer peek() {\\n    return mid;\\n}\\n\\n// hasNext() and next() should behave the same as in the Iterator interface.\\n// Override them if needed.\\n@Override\\npublic Integer next() {\\n    Integer re = mid;\\n    if (iterator.hasNext()) {\\n        mid = iterator.next();\\n        hasNext = true;\\n    } else {\\n        mid = null;\\n        hasNext = false;\\n    }\\n    return re;\\n}\\n\\n@Override\\npublic boolean hasNext() {\\n    if (mid == null && hasNext == false) {\\n        return false;\\n    } else {\\n        return true;\\n    }\\n}\\n}\\n\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\n// Java Iterator interface reference:\\n// https://docs.oracle.com/javase/8/docs/api/java/util/Iterator.html\\nclass PeekingIterator implements Iterator<Integer> {\\n    \\n    private Iterator<Integer> _iterator;\\n    private Integer peekVal=null;\\n    private boolean empty;\\n    \\n\\tpublic PeekingIterator(Iterator<Integer> iterator) {\\n\\t    // initialize any member here.\\n\\t    this._iterator = iterator;\\n\\t    this.empty = !iterator.hasNext();\\n\\t    this.peekVal = iterator.next();\\n\\t}\\n\\n    // Returns the next element in the iteration without advancing the iterator.\\n\\tpublic Integer peek() {\\n        return peekVal;\\n\\t}\\n\\n\\t// hasNext() and next() should behave the same as in the Iterator interface.\\n\\t// Override them if needed.\\n\\t@Override\\n\\tpublic Integer next() {\\n\\t    int result = peekVal;\\n\\t    if(_iterator.hasNext()) peekVal = _iterator.next();\\n\\t    else {\\n\\t        empty=true;\\n\\t        peekVal=null;\\n\\t    }\\n\\t    return result;\\n\\t}\\n\\n\\t@Override\\n\\tpublic boolean hasNext() {\\n\\t    return !empty;\\n\\t}\\n}\\n```\n```\\n// Java Iterator interface reference:\\n// https://docs.oracle.com/javase/8/docs/api/java/util/Iterator.html\\n\\nclass PeekingIterator implements Iterator<Integer> {\\n\\tIterator<Integer> iterator;\\n\\nInteger mid = null;\\nboolean hasNext = false;\\n\\npublic PeekingIterator(Iterator<Integer> iterator) {\\n    // initialize any member here.\\n    this.iterator = iterator;\\n    if (iterator.hasNext()) {\\n        mid = iterator.next();\\n        hasNext = true;\\n    }\\n}\\n\\n// Returns the next element in the iteration without advancing the iterator.\\npublic Integer peek() {\\n    return mid;\\n}\\n\\n// hasNext() and next() should behave the same as in the Iterator interface.\\n// Override them if needed.\\n@Override\\npublic Integer next() {\\n    Integer re = mid;\\n    if (iterator.hasNext()) {\\n        mid = iterator.next();\\n        hasNext = true;\\n    } else {\\n        mid = null;\\n        hasNext = false;\\n    }\\n    return re;\\n}\\n\\n@Override\\npublic boolean hasNext() {\\n    if (mid == null && hasNext == false) {\\n        return false;\\n    } else {\\n        return true;\\n    }\\n}\\n}\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1056767,
                "title": "c-2-extra-variables-solution-100-time-99-space",
                "content": "This is a really nice problem to remove some rust from your OOP muscle - maybe it is not explained in the best way, but it is conceptually rather easy to understand once you grasp what you should do and still not too trivial to implement.\\n\\nTo solve it, we will declare 2 extra private class variables:\\n* `_nextVal` will store the expected value that an user would otherwise get with a call to `next()` from the parent class;\\n* `_hasNext` will similarly store the result of the next call to `hasNext()` from the parent class.\\n\\nIn our constructor we will initialse the latter and, if `true`, also the former.\\n\\nOur `peek()` method is consequently easy: we just return `_nextVal` as often as required; similarly, we are going to override `hasNext()` and do exactly the same with `_hasNext`.\\n\\nThe real magic lies in `next()` or, rather, in how we will override it:\\n* first of all we pass the current value of `_nextVal` to a new variable `tmp`;\\n* then we update `_hasNext` calling the dedicated function in its parent;\\n* if the returned value is `true` (ie: we have more element to return after this), then we will update also `_nextVal` in a similar fashion - calling `next()` from the parent;\\n* finally,  we can return `tmp`.\\n\\nNote that in this way we actually keep assigning the result of the successive call to `next()` to `_nextVal` as long as this is possible, thus enabling us to also return the correct values from the other 2 methods that depend on our private variables.\\n\\nThe code:\\n\\n```cpp\\nclass PeekingIterator : public Iterator {\\nprivate:\\n    // support variables\\n    int _nextVal;\\n    bool _hasNext;\\npublic:\\n\\tPeekingIterator(const vector<int>& nums) : Iterator(nums) {\\n        // local copies initialised\\n\\t    this->_hasNext = Iterator::hasNext();\\n\\t    if (this->_hasNext) this->_nextVal = Iterator::next();\\n\\t}\\n\\t\\n    // Returns the next element in the iteration without advancing the iterator.\\n\\tint peek() {\\n        return this->_nextVal;\\n\\t}\\n    \\n\\tint next() {\\n        // storing the current value of nextVal\\n        int tmp = this->_nextVal;\\n        // updating hasNext\\n        this->_hasNext = Iterator::hasNext();\\n        // updating nextVal, but only if we can\\n        if (this->_hasNext) {\\n            this->_nextVal = Iterator::next();\\n        }\\n\\t    return tmp;\\n\\t}\\n\\t\\n\\tbool hasNext() const {\\n\\t    return this->_hasNext;\\n\\t}\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```cpp\\nclass PeekingIterator : public Iterator {\\nprivate:\\n    // support variables\\n    int _nextVal;\\n    bool _hasNext;\\npublic:\\n\\tPeekingIterator(const vector<int>& nums) : Iterator(nums) {\\n        // local copies initialised\\n\\t    this->_hasNext = Iterator::hasNext();\\n\\t    if (this->_hasNext) this->_nextVal = Iterator::next();\\n\\t}\\n\\t\\n    // Returns the next element in the iteration without advancing the iterator.\\n\\tint peek() {\\n        return this->_nextVal;\\n\\t}\\n    \\n\\tint next() {\\n        // storing the current value of nextVal\\n        int tmp = this->_nextVal;\\n        // updating hasNext\\n        this->_hasNext = Iterator::hasNext();\\n        // updating nextVal, but only if we can\\n        if (this->_hasNext) {\\n            this->_nextVal = Iterator::next();\\n        }\\n\\t    return tmp;\\n\\t}\\n\\t\\n\\tbool hasNext() const {\\n\\t    return this->_hasNext;\\n\\t}\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 824113,
                "title": "swift-simple-answer-follow-up-for-generic",
                "content": "**Solution to the question**\\n```\\nclass PeekingIterator {\\n    var array: IndexingIterator<Array<Int>>\\n    var nextElement: Int?\\n    init(_ arr: IndexingIterator<Array<Int>>) {\\n        array = arr\\n        nextElement = array.next()\\n    }\\n    \\n    func next() -> Int {\\n        let curNext = nextElement\\n        nextElement = array.next()\\n        return curNext!\\n    }\\n    \\n    func peek() -> Int {\\n        return nextElement!\\n    }\\n    \\n    func hasNext() -> Bool {\\n        return nextElement != nil\\n    }\\n}\\n```\\n\\n**Solution to for any collection type**\\n```\\nclass PeekingIterator<T: Collection> {\\n    var array: IndexingIterator<T>\\n    var nextElement: T.Element?\\n    init(_ arr: IndexingIterator<T>) {\\n        array = arr\\n        nextElement = array.next()\\n    }\\n    \\n    func next() -> T.Element {\\n        let curNext = nextElement\\n        nextElement = array.next()\\n        return curNext!\\n    }\\n    \\n    func peek() -> T.Element {\\n        return nextElement!\\n    }\\n    \\n    func hasNext() -> Bool {\\n        return nextElement != nil\\n    }\\n}\\n```\\n\\n**Solution to any array type**\\n```\\nclass PeekingIterator<T> {\\n    var array: IndexingIterator<Array<T>>\\n    var nextElement: T?\\n    init(_ arr: IndexingIterator<Array<T>>) {\\n        array = arr\\n        nextElement = array.next()\\n    }\\n    \\n    func next() -> T {\\n        let curNext = nextElement\\n        nextElement = array.next()\\n        return curNext!\\n    }\\n    \\n    func peek() -> T {\\n        return nextElement!\\n    }\\n    \\n    func hasNext() -> Bool {\\n        return nextElement != nil\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass PeekingIterator {\\n    var array: IndexingIterator<Array<Int>>\\n    var nextElement: Int?\\n    init(_ arr: IndexingIterator<Array<Int>>) {\\n        array = arr\\n        nextElement = array.next()\\n    }\\n    \\n    func next() -> Int {\\n        let curNext = nextElement\\n        nextElement = array.next()\\n        return curNext!\\n    }\\n    \\n    func peek() -> Int {\\n        return nextElement!\\n    }\\n    \\n    func hasNext() -> Bool {\\n        return nextElement != nil\\n    }\\n}\\n```\n```\\nclass PeekingIterator<T: Collection> {\\n    var array: IndexingIterator<T>\\n    var nextElement: T.Element?\\n    init(_ arr: IndexingIterator<T>) {\\n        array = arr\\n        nextElement = array.next()\\n    }\\n    \\n    func next() -> T.Element {\\n        let curNext = nextElement\\n        nextElement = array.next()\\n        return curNext!\\n    }\\n    \\n    func peek() -> T.Element {\\n        return nextElement!\\n    }\\n    \\n    func hasNext() -> Bool {\\n        return nextElement != nil\\n    }\\n}\\n```\n```\\nclass PeekingIterator<T> {\\n    var array: IndexingIterator<Array<T>>\\n    var nextElement: T?\\n    init(_ arr: IndexingIterator<Array<T>>) {\\n        array = arr\\n        nextElement = array.next()\\n    }\\n    \\n    func next() -> T {\\n        let curNext = nextElement\\n        nextElement = array.next()\\n        return curNext!\\n    }\\n    \\n    func peek() -> T {\\n        return nextElement!\\n    }\\n    \\n    func hasNext() -> Bool {\\n        return nextElement != nil\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 72632,
                "title": "my-java-solution",
                "content": "    class PeekingIterator implements Iterator<Integer> {\\n        Integer n = null;\\n        private Iterator<Integer> iterator = null;\\n    \\tpublic PeekingIterator(Iterator<Integer> iterator) {\\n    \\t    this.iterator = iterator;\\n    \\t}\\n    \\n        public Integer peek() {\\n            if (n == null && iterator.hasNext()){\\n                n = iterator.next();\\n            }\\n            return n;\\n    \\t}\\n    \\tpublic Integer next() {\\n    \\t    if (n!=null){\\n    \\t        int temp = n;\\n    \\t        n = null;\\n    \\t        return temp;\\n    \\t    }\\n    \\t    return iterator.next();\\n    \\t}\\n    \\tpublic boolean hasNext() {\\n    \\t    if (n!=null){\\n    \\t        return true;\\n    \\t    }\\n    \\t    return iterator.hasNext();\\n    \\t}\\n    }",
                "solutionTags": [],
                "code": "    class PeekingIterator implements Iterator<Integer> {\\n        Integer n = null;\\n        private Iterator<Integer> iterator = null;\\n    \\tpublic PeekingIterator(Iterator<Integer> iterator) {\\n    \\t    this.iterator = iterator;\\n    \\t}\\n    \\n        public Integer peek() {\\n            if (n == null && iterator.hasNext()){\\n                n = iterator.next();\\n            }\\n            return n;\\n    \\t}\\n    \\tpublic Integer next() {\\n    \\t    if (n!=null){\\n    \\t        int temp = n;\\n    \\t        n = null;\\n    \\t        return temp;\\n    \\t    }\\n    \\t    return iterator.next();\\n    \\t}\\n    \\tpublic boolean hasNext() {\\n    \\t    if (n!=null){\\n    \\t        return true;\\n    \\t    }\\n    \\t    return iterator.hasNext();\\n    \\t}\\n    }",
                "codeTag": "Java"
            },
            {
                "id": 1058637,
                "title": "javascript-o-1-space-implementation",
                "content": "```javascript\\nclass PeekingIterator {\\n    \\n    constructor(iterator) {\\n        this.itr = iterator;\\n        this.peeked = null;\\n    }\\n    \\n    peek() {\\n        if(!this.peeked) this.peeked = this.itr.next();\\n        return this.peeked;\\n    }\\n    \\n    next() {\\n        if(!this.peeked) return this.itr.next()\\n        const temp = this.peeked;\\n        this.peeked = null;\\n        return temp;\\n    }\\n    \\n    hasNext() {\\n        if(!this.peeked) return this.itr.hasNext()\\n        return true;\\n    }\\n}\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```javascript\\nclass PeekingIterator {\\n    \\n    constructor(iterator) {\\n        this.itr = iterator;\\n        this.peeked = null;\\n    }\\n    \\n    peek() {\\n        if(!this.peeked) this.peeked = this.itr.next();\\n        return this.peeked;\\n    }\\n    \\n    next() {\\n        if(!this.peeked) return this.itr.next()\\n        const temp = this.peeked;\\n        this.peeked = null;\\n        return temp;\\n    }\\n    \\n    hasNext() {\\n        if(!this.peeked) return this.itr.hasNext()\\n        return true;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1057198,
                "title": "c-solution",
                "content": "```\\n// C# IEnumerator interface reference:\\n// https://docs.microsoft.com/en-us/dotnet/api/system.collections.ienumerator?view=netframework-4.8\\n\\nclass PeekingIterator {\\n    IEnumerator<int> _iterator;\\n    bool hasNext;\\n\\n    // iterators refers to the first element of the array.\\n    public PeekingIterator(IEnumerator<int> iterator) {\\n        // initialize any member here.\\n        _iterator = iterator;\\n        hasNext = true;\\n    }\\n    \\n    // Returns the next element in the iteration without advancing the iterator.\\n    public int Peek() {\\n        return _iterator.Current;     \\n    }\\n    \\n    // Returns the next element in the iteration and advances the iterator.\\n    public int Next() {\\n        var result = _iterator.Current;;\\n        hasNext = _iterator.MoveNext();\\n        \\n        return result;\\n    }\\n    \\n    // Returns false if the iterator is refering to the end of the array of true otherwise.\\n    public bool HasNext() {\\n\\t\\treturn hasNext;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Iterator"
                ],
                "code": "```\\n// C# IEnumerator interface reference:\\n// https://docs.microsoft.com/en-us/dotnet/api/system.collections.ienumerator?view=netframework-4.8\\n\\nclass PeekingIterator {\\n    IEnumerator<int> _iterator;\\n    bool hasNext;\\n\\n    // iterators refers to the first element of the array.\\n    public PeekingIterator(IEnumerator<int> iterator) {\\n        // initialize any member here.\\n        _iterator = iterator;\\n        hasNext = true;\\n    }\\n    \\n    // Returns the next element in the iteration without advancing the iterator.\\n    public int Peek() {\\n        return _iterator.Current;     \\n    }\\n    \\n    // Returns the next element in the iteration and advances the iterator.\\n    public int Next() {\\n        var result = _iterator.Current;;\\n        hasNext = _iterator.MoveNext();\\n        \\n        return result;\\n    }\\n    \\n    // Returns false if the iterator is refering to the end of the array of true otherwise.\\n    public bool HasNext() {\\n\\t\\treturn hasNext;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1056675,
                "title": "java-generic-implementation",
                "content": "Here is the generic implementation inn Regards to PeekingIterator. \\nBasically `<T>` is the generics in the java.\\nRef: Java generics javadoc for more details: https://docs.oracle.com/javase/tutorial/java/generics/types.html\\n```\\nclass PeekingIterator<T> implements Iterator<T> {\\n\\n    private  Iterator<? extends T> iterator;\\n    T forward;\\n\\n    public PeekingIterator(Iterator<? extends T> iterator) {\\n        // initialize any member here.\\n        this.iterator = iterator;\\n        this.forward = iterator.hasNext() ? iterator.next() : null;\\n    }\\n\\n    // Returns the next element in the iteration without advancing the iterator.\\n    public T peek() {\\n        return forward;\\n    }\\n\\n    // hasNext() and next() should behave the same as in the Iterator interface.\\n    // Override them if needed.\\n    @Override\\n    public T next() {\\n        T tmp = forward;\\n        forward = this.iterator.hasNext() ? iterator.next() : null;\\n        return tmp;\\n    }\\n\\n    @Override\\n    public boolean hasNext() {\\n        return forward != null;\\n    }\\n}\\n```\\n\\nPS: Please upvote if you like it.",
                "solutionTags": [],
                "code": "```\\nclass PeekingIterator<T> implements Iterator<T> {\\n\\n    private  Iterator<? extends T> iterator;\\n    T forward;\\n\\n    public PeekingIterator(Iterator<? extends T> iterator) {\\n        // initialize any member here.\\n        this.iterator = iterator;\\n        this.forward = iterator.hasNext() ? iterator.next() : null;\\n    }\\n\\n    // Returns the next element in the iteration without advancing the iterator.\\n    public T peek() {\\n        return forward;\\n    }\\n\\n    // hasNext() and next() should behave the same as in the Iterator interface.\\n    // Override them if needed.\\n    @Override\\n    public T next() {\\n        T tmp = forward;\\n        forward = this.iterator.hasNext() ? iterator.next() : null;\\n        return tmp;\\n    }\\n\\n    @Override\\n    public boolean hasNext() {\\n        return forward != null;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 72618,
                "title": "a-simple-c-solution",
                "content": "    // Below is the interface for Iterator, which is already defined for you.\\n    // **DO NOT** modify the interface for Iterator.\\n    class Iterator {\\n        struct Data;\\n    \\tData* data;\\n    public:\\n    \\tIterator(const vector<int>& nums);\\n    \\tIterator(const Iterator& iter);\\n    \\tvirtual ~Iterator();\\n    \\t// Returns the next element in the iteration.\\n    \\tint next();\\n    \\t// Returns true if the iteration has more elements.\\n    \\tbool hasNext() const;\\n    };\\n    \\n    \\n    class PeekingIterator : public Iterator {\\n    public:\\n        bool peaked;\\n        int peakedElement;\\n    \\tPeekingIterator(const vector<int>& nums) : Iterator(nums) {\\n    \\t    // Initialize any member here.\\n    \\t    // **DO NOT** save a copy of nums and manipulate it directly.\\n    \\t    // You should only use the Iterator interface methods.\\n    \\t    peaked = false;\\n    \\t}\\n    \\n        // Returns the next element in the iteration without advancing the iterator.\\n    \\tint peek() \\n    \\t{\\n            if(!peaked && Iterator::hasNext())\\n            {\\n                peaked = true;\\n                peakedElement = Iterator::next();\\n                return peakedElement;\\n            }\\n            else if(peaked)\\n            {\\n                return peakedElement;\\n            }\\n    \\t}\\n    \\n    \\t// hasNext() and next() should behave the same as in the Iterator interface.\\n    \\t// Override them if needed.\\n    \\tint next() \\n    \\t{\\n    \\t    if(peaked)\\n    \\t    {\\n    \\t        peaked = false;\\n    \\t        return peakedElement;\\n    \\t    }\\n    \\t    if(Iterator::hasNext())\\n    \\t        return Iterator::next();\\n    \\t}\\n    \\n    \\tbool hasNext() const \\n    \\t{\\n    \\t    if(peaked)\\n    \\t        return true;\\n    \\t   return Iterator::hasNext();\\n    \\t}\\n    };",
                "solutionTags": [],
                "code": "    // Below is the interface for Iterator, which is already defined for you.\\n    // **DO NOT** modify the interface for Iterator.\\n    class Iterator {\\n        struct Data;\\n    \\tData* data;\\n    public:\\n    \\tIterator(const vector<int>& nums);\\n    \\tIterator(const Iterator& iter);\\n    \\tvirtual ~Iterator();\\n    \\t// Returns the next element in the iteration.\\n    \\tint next();\\n    \\t// Returns true if the iteration has more elements.\\n    \\tbool hasNext() const;\\n    };\\n    \\n    \\n    class PeekingIterator : public Iterator {\\n    public:\\n        bool peaked;\\n        int peakedElement;\\n    \\tPeekingIterator(const vector<int>& nums) : Iterator(nums) {\\n    \\t    // Initialize any member here.\\n    \\t    // **DO NOT** save a copy of nums and manipulate it directly.\\n    \\t    // You should only use the Iterator interface methods.\\n    \\t    peaked = false;\\n    \\t}\\n    \\n        // Returns the next element in the iteration without advancing the iterator.\\n    \\tint peek() \\n    \\t{\\n            if(!peaked && Iterator::hasNext())\\n            {\\n                peaked = true;\\n                peakedElement = Iterator::next();\\n                return peakedElement;\\n            }\\n            else if(peaked)\\n            {\\n                return peakedElement;\\n            }\\n    \\t}\\n    \\n    \\t// hasNext() and next() should behave the same as in the Iterator interface.\\n    \\t// Override them if needed.\\n    \\tint next() \\n    \\t{\\n    \\t    if(peaked)\\n    \\t    {\\n    \\t        peaked = false;\\n    \\t        return peakedElement;\\n    \\t    }\\n    \\t    if(Iterator::hasNext())\\n    \\t        return Iterator::next();\\n    \\t}\\n    \\n    \\tbool hasNext() const \\n    \\t{\\n    \\t    if(peaked)\\n    \\t        return true;\\n    \\t   return Iterator::hasNext();\\n    \\t}\\n    };",
                "codeTag": "Java"
            },
            {
                "id": 658888,
                "title": "swift-solution-peeking-iterator",
                "content": "```\\nclass PeekingIterator {\\n    private var iterator: IndexingIterator<Array<Int>>\\n    private var lastValue: Int?\\n    \\n\\t\\n    init(_ arr: IndexingIterator<Array<Int>>) {\\n        self.iterator = arr\\n        self.lastValue = iterator.next()\\n    }\\n\\t\\n    \\n    func next() -> Int {\\n        let previous = lastValue\\n        lastValue = iterator.next()\\n        return previous ?? 0\\n    }\\n    \\n    \\n    func peek() -> Int {\\n        return lastValue ?? 0\\n    }\\n    \\n\\t\\n    func hasNext() -> Bool {\\n        return lastValue != nil\\n    }\\n}\\n```\\n",
                "solutionTags": [
                    "Swift"
                ],
                "code": "```\\nclass PeekingIterator {\\n    private var iterator: IndexingIterator<Array<Int>>\\n    private var lastValue: Int?\\n    \\n\\t\\n    init(_ arr: IndexingIterator<Array<Int>>) {\\n        self.iterator = arr\\n        self.lastValue = iterator.next()\\n    }\\n\\t\\n    \\n    func next() -> Int {\\n        let previous = lastValue\\n        lastValue = iterator.next()\\n        return previous ?? 0\\n    }\\n    \\n    \\n    func peek() -> Int {\\n        return lastValue ?? 0\\n    }\\n    \\n\\t\\n    func hasNext() -> Bool {\\n        return lastValue != nil\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 233986,
                "title": "python-simple-solution-beat-100",
                "content": "```python\\nclass PeekingIterator:\\n    def __init__(self, iterator):\\n        self.tep = None\\n        self.it = iterator\\n\\n    def peek(self):\\n        if not self.tep: self.tep = self.it.next()\\n        return self.tep\\n\\n    def next(self):\\n        if self.tep:\\n            res = self.tep\\n            self.tep = None\\n            return res\\n        else:\\n            return self.it.next()\\n        \\n    def hasNext(self):\\n        return self.it.hasNext() or self.tep != None\\n```",
                "solutionTags": [],
                "code": "```python\\nclass PeekingIterator:\\n    def __init__(self, iterator):\\n        self.tep = None\\n        self.it = iterator\\n\\n    def peek(self):\\n        if not self.tep: self.tep = self.it.next()\\n        return self.tep\\n\\n    def next(self):\\n        if self.tep:\\n            res = self.tep\\n            self.tep = None\\n            return res\\n        else:\\n            return self.it.next()\\n        \\n    def hasNext(self):\\n        return self.it.hasNext() or self.tep != None\\n```",
                "codeTag": "Java"
            },
            {
                "id": 72573,
                "title": "simple-java-solution-working-for-generic-types",
                "content": "Most solutions I've seen do not work for generic types as they use null as a special value to indicate the end of the iterator. However, what if we wanted to iterate within possibly null values? If we want to allow null values inside the iterator we need to add an extra flag to indicate whether we are done or not.\\n\\n```\\n// Java Iterator interface reference:\\n// https://docs.oracle.com/javase/8/docs/api/java/util/Iterator.html\\nclass PeekingIterator implements Iterator<Integer> {\\n        Integer next;\\n        boolean done;\\n        Iterator<Integer> it;\\n\\tpublic PeekingIterator(Iterator<Integer> iterator) {\\n\\t    // initialize any member here.\\n\\t    it = iterator;\\n\\t    if(it.hasNext()) { \\n\\t        next = it.next();\\n\\t        done = false;\\n\\t    }else{\\n\\t        done = true;\\n\\t    }\\n\\t}\\n\\n    // Returns the next element in the iteration without advancing the iterator.\\n\\tpublic Integer peek() {\\n        return next;\\n\\t}\\n\\n\\t// hasNext() and next() should behave the same as in the Iterator interface.\\n\\t// Override them if needed.\\n\\t@Override\\n\\tpublic Integer next() {\\n\\t    Integer res = next;\\n\\t    if(it.hasNext()) { \\n\\t        next = it.next();\\n\\t    }else{\\n\\t        done = true;\\n\\t    }\\n\\t    return res;\\n\\t}\\n\\n\\t@Override\\n\\tpublic boolean hasNext() {\\n\\t    return !done;\\n\\t}\\n}\\n```\\nI believe this solution is better on a coding interview as it works for any type (not just integers) and allows for nulls withing the values.",
                "solutionTags": [],
                "code": "```\\n// Java Iterator interface reference:\\n// https://docs.oracle.com/javase/8/docs/api/java/util/Iterator.html\\nclass PeekingIterator implements Iterator<Integer> {\\n        Integer next;\\n        boolean done;\\n        Iterator<Integer> it;\\n\\tpublic PeekingIterator(Iterator<Integer> iterator) {\\n\\t    // initialize any member here.\\n\\t    it = iterator;\\n\\t    if(it.hasNext()) { \\n\\t        next = it.next();\\n\\t        done = false;\\n\\t    }else{\\n\\t        done = true;\\n\\t    }\\n\\t}\\n\\n    // Returns the next element in the iteration without advancing the iterator.\\n\\tpublic Integer peek() {\\n        return next;\\n\\t}\\n\\n\\t// hasNext() and next() should behave the same as in the Iterator interface.\\n\\t// Override them if needed.\\n\\t@Override\\n\\tpublic Integer next() {\\n\\t    Integer res = next;\\n\\t    if(it.hasNext()) { \\n\\t        next = it.next();\\n\\t    }else{\\n\\t        done = true;\\n\\t    }\\n\\t    return res;\\n\\t}\\n\\n\\t@Override\\n\\tpublic boolean hasNext() {\\n\\t    return !done;\\n\\t}\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1979987,
                "title": "java-easy-solution",
                "content": "```\\nclass PeekingIterator implements Iterator<Integer> {\\n\\tprivate List<Integer> list;\\n    public PeekingIterator(Iterator<Integer> iterator) {\\n        list = new ArrayList<>();\\n        // initialize any member here.\\n        while (iterator.hasNext()){\\n            list.add(iterator.next());\\n        }\\n    }\\n\\n    // Returns the next element in the iteration without advancing the iterator.\\n    public Integer peek() {\\n        return list.get(0);\\n    }\\n\\n    // hasNext() and next() should behave the same as in the Iterator interface.\\n    // Override them if needed.\\n    @Override\\n    public Integer next() {\\n        Integer val = list.get(0);\\n        list.remove(0);\\n        return val;\\n    }\\n\\n    @Override\\n    public boolean hasNext() {\\n        return !list.isEmpty();\\n    }\\n}\\n```\\n\\nGiven the constraints suggested that all peek() and next() operations are valid, so no need to do boundary check.",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass PeekingIterator implements Iterator<Integer> {\\n\\tprivate List<Integer> list;\\n    public PeekingIterator(Iterator<Integer> iterator) {\\n        list = new ArrayList<>();\\n        // initialize any member here.\\n        while (iterator.hasNext()){\\n            list.add(iterator.next());\\n        }\\n    }\\n\\n    // Returns the next element in the iteration without advancing the iterator.\\n    public Integer peek() {\\n        return list.get(0);\\n    }\\n\\n    // hasNext() and next() should behave the same as in the Iterator interface.\\n    // Override them if needed.\\n    @Override\\n    public Integer next() {\\n        Integer val = list.get(0);\\n        list.remove(0);\\n        return val;\\n    }\\n\\n    @Override\\n    public boolean hasNext() {\\n        return !list.isEmpty();\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 648878,
                "title": "c-using-movenext-and-current-of-ienumerator",
                "content": "```\\nclass PeekingIterator {\\n    IEnumerator<int> iter;\\n    bool hasNext;\\n    // iterators refers to the first element of the array.\\n    public PeekingIterator(IEnumerator<int> iterator) {\\n        // initialize any member here.\\n        iter=iterator;\\n        hasNext=true;\\n    }\\n    \\n    // Returns the next element in the iteration without advancing the iterator.\\n    public int Peek() {\\n        return iter.Current;\\n    }\\n    \\n    // Returns the next element in the iteration and advances the iterator.\\n    public int Next() {\\n        int res=iter.Current;\\n        hasNext=iter.MoveNext();\\n        return res;\\n    }\\n    \\n    // Returns false if the iterator is refering to the end of the array of true otherwise.\\n    public bool HasNext() {\\n\\t\\treturn hasNext;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass PeekingIterator {\\n    IEnumerator<int> iter;\\n    bool hasNext;\\n    // iterators refers to the first element of the array.\\n    public PeekingIterator(IEnumerator<int> iterator) {\\n        // initialize any member here.\\n        iter=iterator;\\n        hasNext=true;\\n    }\\n    \\n    // Returns the next element in the iteration without advancing the iterator.\\n    public int Peek() {\\n        return iter.Current;\\n    }\\n    \\n    // Returns the next element in the iteration and advances the iterator.\\n    public int Next() {\\n        int res=iter.Current;\\n        hasNext=iter.MoveNext();\\n        return res;\\n    }\\n    \\n    // Returns false if the iterator is refering to the end of the array of true otherwise.\\n    public bool HasNext() {\\n\\t\\treturn hasNext;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1981854,
                "title": "simple-c-solution-without-explanation",
                "content": "The code is pretty self explanatory, however if you have any doubts, please ask them in the comments section.\\n```\\nclass PeekingIterator : public Iterator {\\n    \\n    int peekElement;\\n    bool hasPeeked;\\n    \\npublic:\\n\\tPeekingIterator(const vector<int>& nums) : Iterator(nums) {\\n        hasPeeked = false;\\n\\t}\\n\\t\\n\\tint peek() {\\n        peekElement = hasPeeked ? peekElement : Iterator :: next();\\n        hasPeeked = true;\\n        \\n        return peekElement;\\n\\t}\\n\\t\\n\\tint next() {\\n\\t    int nextElement = hasPeeked ? peekElement : Iterator :: next();\\n\\t    hasPeeked = false;\\n        \\n\\t    return nextElement;\\n\\t}\\n\\t\\n\\tbool hasNext() const {\\n\\t    return hasPeeked || Iterator :: hasNext();\\n\\t}\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nclass PeekingIterator : public Iterator {\\n    \\n    int peekElement;\\n    bool hasPeeked;\\n    \\npublic:\\n\\tPeekingIterator(const vector<int>& nums) : Iterator(nums) {\\n        hasPeeked = false;\\n\\t}\\n\\t\\n\\tint peek() {\\n        peekElement = hasPeeked ? peekElement : Iterator :: next();\\n        hasPeeked = true;\\n        \\n        return peekElement;\\n\\t}\\n\\t\\n\\tint next() {\\n\\t    int nextElement = hasPeeked ? peekElement : Iterator :: next();\\n\\t    hasPeeked = false;\\n        \\n\\t    return nextElement;\\n\\t}\\n\\t\\n\\tbool hasNext() const {\\n\\t    return hasPeeked || Iterator :: hasNext();\\n\\t}\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1980046,
                "title": "c-solution-with-explanation",
                "content": "```\\n/*\\n * Below is the interface for Iterator, which is already defined for you.\\n * **DO NOT** modify the interface for Iterator.\\n *\\n *  class Iterator {\\n *\\t\\tstruct Data;\\n * \\t\\tData* data;\\n *  public:\\n *\\t\\tIterator(const vector<int>& nums);\\n * \\t\\tIterator(const Iterator& iter);\\n *\\n * \\t\\t// Returns the next element in the iteration.\\n *\\t\\tint next();\\n *\\n *\\t\\t// Returns true if the iteration has more elements.\\n *\\t\\tbool hasNext() const;\\n *\\t};\\n */\\n\\nclass PeekingIterator : public Iterator {\\npublic:\\n\\tPeekingIterator(const vector<int>& nums) : Iterator(nums) {\\n\\t    // Initialize any member here.\\n\\t    // **DO NOT** save a copy of nums and manipulate it directly.\\n\\t    // You should only use the Iterator interface methods.\\n\\t    \\n\\t}\\n\\t\\n    // Returns the next element in the iteration without advancing the iterator.\\n\\tint peek() {\\n        Iterator temp = (*this); //taking a new iterator and storing the current value\\n        return temp.next();//return the next of that iterator\\n\\t}\\n\\t\\n\\t// hasNext() and next() should behave the same as in the Iterator interface.\\n\\t// Override them if needed.\\n\\tint next() {\\n\\t    return Iterator::next();// override\\n\\t}\\n\\t\\n\\tbool hasNext() const {\\n\\t    return Iterator::hasNext(); // override\\n\\t}\\n};\\n\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\n/*\\n * Below is the interface for Iterator, which is already defined for you.\\n * **DO NOT** modify the interface for Iterator.\\n *\\n *  class Iterator {\\n *\\t\\tstruct Data;\\n * \\t\\tData* data;\\n *  public:\\n *\\t\\tIterator(const vector<int>& nums);\\n * \\t\\tIterator(const Iterator& iter);\\n *\\n * \\t\\t// Returns the next element in the iteration.\\n *\\t\\tint next();\\n *\\n *\\t\\t// Returns true if the iteration has more elements.\\n *\\t\\tbool hasNext() const;\\n *\\t};\\n */\\n\\nclass PeekingIterator : public Iterator {\\npublic:\\n\\tPeekingIterator(const vector<int>& nums) : Iterator(nums) {\\n\\t    // Initialize any member here.\\n\\t    // **DO NOT** save a copy of nums and manipulate it directly.\\n\\t    // You should only use the Iterator interface methods.\\n\\t    \\n\\t}\\n\\t\\n    // Returns the next element in the iteration without advancing the iterator.\\n\\tint peek() {\\n        Iterator temp = (*this); //taking a new iterator and storing the current value\\n        return temp.next();//return the next of that iterator\\n\\t}\\n\\t\\n\\t// hasNext() and next() should behave the same as in the Iterator interface.\\n\\t// Override them if needed.\\n\\tint next() {\\n\\t    return Iterator::next();// override\\n\\t}\\n\\t\\n\\tbool hasNext() const {\\n\\t    return Iterator::hasNext(); // override\\n\\t}\\n};\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1055896,
                "title": "java-easy-to-understand-using-iterator-only",
                "content": "```\\n// next() will return the value at current itearator and then increments the iterator\\n// hasNext() will tell is there any element after the current iterator\\n// peek() will only return the curr element will not increment the iterator\\nclass PeekingIterator implements Iterator<Integer> {\\n    Iterator<Integer> itr;\\n    Integer currValue;\\n    boolean isEmpty;\\n\\tpublic PeekingIterator(Iterator<Integer> iterator) {\\n\\t    this.itr=iterator;\\n        this.isEmpty=false;\\n\\t    this.currValue=itr.next();\\n\\t}\\n\\t\\n    \\n\\tpublic Integer peek() {\\n        return currValue;\\n\\t}\\n\\t\\n\\t\\n\\t@Override\\n\\tpublic Integer next() {\\n        Integer res=currValue;\\n        \\n\\t    if(itr.hasNext()){\\n            currValue=itr.next();\\n        }\\n        else{\\n            currValue=null;\\n            isEmpty=true;\\n        }\\n        return res;\\n\\t}\\n\\t\\n\\t@Override\\n\\tpublic boolean hasNext() {\\n\\t    return !isEmpty;\\n\\t}\\n}\\n\\n```",
                "solutionTags": [],
                "code": "```\\n// next() will return the value at current itearator and then increments the iterator\\n// hasNext() will tell is there any element after the current iterator\\n// peek() will only return the curr element will not increment the iterator\\nclass PeekingIterator implements Iterator<Integer> {\\n    Iterator<Integer> itr;\\n    Integer currValue;\\n    boolean isEmpty;\\n\\tpublic PeekingIterator(Iterator<Integer> iterator) {\\n\\t    this.itr=iterator;\\n        this.isEmpty=false;\\n\\t    this.currValue=itr.next();\\n\\t}\\n\\t\\n    \\n\\tpublic Integer peek() {\\n        return currValue;\\n\\t}\\n\\t\\n\\t\\n\\t@Override\\n\\tpublic Integer next() {\\n        Integer res=currValue;\\n        \\n\\t    if(itr.hasNext()){\\n            currValue=itr.next();\\n        }\\n        else{\\n            currValue=null;\\n            isEmpty=true;\\n        }\\n        return res;\\n\\t}\\n\\t\\n\\t@Override\\n\\tpublic boolean hasNext() {\\n\\t    return !isEmpty;\\n\\t}\\n}\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 659096,
                "title": "javascript-solution",
                "content": "```\\nPeekingIterator.prototype.peek = function() {\\n    if(this.top){\\n        return this.top;\\n    }\\n    if(this.list.hasNext()){\\n        this.top = this.list.next()\\n        return this.top;\\n    }\\n    return false;\\n};\\n\\n\\nPeekingIterator.prototype.next = function() {\\n    if(this.top){\\n        var v = this.top\\n        this.top = null;\\n        return v;\\n    }\\n    return this.list.next();\\n};\\n\\n\\nPeekingIterator.prototype.hasNext = function() {\\n    if(this.top){\\n        return true;\\n    }\\n    return this.list.hasNext();\\n};\\n\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\nPeekingIterator.prototype.peek = function() {\\n    if(this.top){\\n        return this.top;\\n    }\\n    if(this.list.hasNext()){\\n        this.top = this.list.next()\\n        return this.top;\\n    }\\n    return false;\\n};\\n\\n\\nPeekingIterator.prototype.next = function() {\\n    if(this.top){\\n        var v = this.top\\n        this.top = null;\\n        return v;\\n    }\\n    return this.list.next();\\n};\\n\\n\\nPeekingIterator.prototype.hasNext = function() {\\n    if(this.top){\\n        return true;\\n    }\\n    return this.list.hasNext();\\n};\\n\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 226430,
                "title": "java-solution-for-the-follow-up-question",
                "content": "Solution is based on https://leetcode.com/problems/peeking-iterator/discuss/72558/Concise-Java-Solution\\nI cleaned up the code a bit and added generic support. \\n```\\nimport java.util.List;\\nimport java.util.NoSuchElementException;\\nclass PeekingIterator<E> implements Iterator<E> {\\n    E next;\\n    Iterator<E> iterator;\\n    boolean isEnd;\\n\\n    public PeekingIterator(Iterator<E> iterator) {\\n        this.iterator = iterator;\\n        advance();\\n    }\\n\\n    public E peek() {\\n        if (isEnd)\\n            throw new NoSuchElementException();\\n        return next;\\n    }\\n\\n    // isEnd() and next() should behave the same as in the Iterator interface.\\n    // Override them if needed.\\n    @Override\\n    public E next() {\\n        if (isEnd)\\n            throw new NoSuchElementException();\\n        E res = next;\\n        advance();\\n        return res;\\n    }\\n\\n    @Override\\n    public boolean hasNext() {\\n        return !isEnd;\\n    }\\n\\n    private void advance() {\\n        if (iterator.hasNext()) {\\n            next = iterator.next();\\n        } else {\\n            isEnd = true;\\n        }\\n    }\\n\\t```",
                "solutionTags": [],
                "code": "```\\nimport java.util.List;\\nimport java.util.NoSuchElementException;\\nclass PeekingIterator<E> implements Iterator<E> {\\n    E next;\\n    Iterator<E> iterator;\\n    boolean isEnd;\\n\\n    public PeekingIterator(Iterator<E> iterator) {\\n        this.iterator = iterator;\\n        advance();\\n    }\\n\\n    public E peek() {\\n        if (isEnd)\\n            throw new NoSuchElementException();\\n        return next;\\n    }\\n\\n    // isEnd() and next() should behave the same as in the Iterator interface.\\n    // Override them if needed.\\n    @Override\\n    public E next() {\\n        if (isEnd)\\n            throw new NoSuchElementException();\\n        E res = next;\\n        advance();\\n        return res;\\n    }\\n\\n    @Override\\n    public boolean hasNext() {\\n        return !isEnd;\\n    }\\n\\n    private void advance() {\\n        if (iterator.hasNext()) {\\n            next = iterator.next();\\n        } else {\\n            isEnd = true;\\n        }\\n    }\\n\\t```",
                "codeTag": "Java"
            },
            {
                "id": 1980797,
                "title": "peeking-iterator",
                "content": "Easy C++ solution----->\\nplease upvote if you understand.\\n\\nanything , if you are not getting properly..please let me know in comment section.\\n\\n```\\n \\n  class PeekingIterator : public Iterator {\\npublic:     \\n               \\n      int nextValue;\\n    \\n\\tPeekingIterator(const vector<int>& nums) : Iterator(nums) {\\n\\t     \\n        nextValue = Iterator::next();\\n\\t  \\n\\t}\\n\\t\\n    // Returns the next element in the iteration without advancing the iterator.\\n\\tint peek() {\\n        return nextValue;\\n        \\n\\t}\\n\\t\\n\\t// hasNext() and next() should behave the same as in the Iterator interface.\\n\\t// Override them if needed.\\n\\tint next() {\\n\\t    int temp = nextValue;\\n        \\n        if(Iterator::hasNext())\\n            nextValue = Iterator::next();\\n        \\n        else\\n           nextValue = NULL;\\n        \\n        return temp;\\n\\t}\\n\\t\\n\\tbool hasNext() const {\\n\\t    return (nextValue!=NULL);\\n\\t}\\n};\\n\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Iterator"
                ],
                "code": "```\\n \\n  class PeekingIterator : public Iterator {\\npublic:     \\n               \\n      int nextValue;\\n    \\n\\tPeekingIterator(const vector<int>& nums) : Iterator(nums) {\\n\\t     \\n        nextValue = Iterator::next();\\n\\t  \\n\\t}\\n\\t\\n    // Returns the next element in the iteration without advancing the iterator.\\n\\tint peek() {\\n        return nextValue;\\n        \\n\\t}\\n\\t\\n\\t// hasNext() and next() should behave the same as in the Iterator interface.\\n\\t// Override them if needed.\\n\\tint next() {\\n\\t    int temp = nextValue;\\n        \\n        if(Iterator::hasNext())\\n            nextValue = Iterator::next();\\n        \\n        else\\n           nextValue = NULL;\\n        \\n        return temp;\\n\\t}\\n\\t\\n\\tbool hasNext() const {\\n\\t    return (nextValue!=NULL);\\n\\t}\\n};\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1980525,
                "title": "c-fast-solution-daily-leetcoding-challenge-april-day-25",
                "content": "```\\nclass PeekingIterator : public Iterator {\\n    \\n    int nextVal; \\n    \\n    bool iterHasNext; \\n    \\npublic:\\n\\tPeekingIterator(const vector<int>& nums) : Iterator(nums) {\\n        \\n        iterHasNext=Iterator::hasNext();\\n        \\n\\t    if (iterHasNext) nextVal = Iterator::next(); \\n        \\n\\t}\\n\\t\\n\\tint peek() {\\n        \\n        return nextVal;\\n        \\n    }\\n\\t\\n\\tint next() {\\n        \\n\\t    int currNext = nextVal; \\n        \\n        iterHasNext=Iterator::hasNext(); \\n        \\n\\t    if (iterHasNext) nextVal = Iterator::next(); \\n        \\n\\t    return currNext; \\n    }\\n\\t\\n\\tbool hasNext() const {\\n        \\n\\t    return iterHasNext; \\n        \\n\\t}\\n    \\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass PeekingIterator : public Iterator {\\n    \\n    int nextVal; \\n    \\n    bool iterHasNext; \\n    \\npublic:\\n\\tPeekingIterator(const vector<int>& nums) : Iterator(nums) {\\n        \\n        iterHasNext=Iterator::hasNext();\\n        \\n\\t    if (iterHasNext) nextVal = Iterator::next(); \\n        \\n\\t}\\n\\t\\n\\tint peek() {\\n        \\n        return nextVal;\\n        \\n    }\\n\\t\\n\\tint next() {\\n        \\n\\t    int currNext = nextVal; \\n        \\n        iterHasNext=Iterator::hasNext(); \\n        \\n\\t    if (iterHasNext) nextVal = Iterator::next(); \\n        \\n\\t    return currNext; \\n    }\\n\\t\\n\\tbool hasNext() const {\\n        \\n\\t    return iterHasNext; \\n        \\n\\t}\\n    \\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1980448,
                "title": "easy-solution-beats-100-queue-fast",
                "content": "The Queue (FIFO) could be optimal for this question \\n\\n* Steps : \\n\\t\\tStep 1 : Add all elements in queue (FIFO)\\n\\t\\tStep 2 : Create funtions according to Queue data structure\\n\\t\\t\\n\\n```\\nclass PeekingIterator implements Iterator<Integer>\\n{\\n    private Queue<Integer> queue;\\n\\tpublic PeekingIterator(Iterator<Integer> iterator)\\n    {\\n\\t    queue = new LinkedList<>();\\n\\t\\t\\n\\t\\t// Adding elements to queue\\n        convertToQueue(iterator);\\n\\t}\\n\\t\\n\\tpublic Integer peek()\\n    {\\n        return this.queue.peek();\\n\\t}\\n\\t\\n\\t@Override\\n\\tpublic Integer next()\\n    {\\n\\t    return this.queue.remove();\\n\\t}\\n\\t\\n\\t@Override\\n\\tpublic boolean hasNext()\\n    {\\n\\t    return this.queue.size() > 0;\\n\\t}\\n    \\n\\t// Converting Iterator to Queue\\n    private void convertToQueue(Iterator<Integer> iterator)\\n    {\\n        while(iterator.hasNext())\\n        {\\n            queue.add(iterator.next());\\n        }\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Array",
                    "Queue"
                ],
                "code": "```\\nclass PeekingIterator implements Iterator<Integer>\\n{\\n    private Queue<Integer> queue;\\n\\tpublic PeekingIterator(Iterator<Integer> iterator)\\n    {\\n\\t    queue = new LinkedList<>();\\n\\t\\t\\n\\t\\t// Adding elements to queue\\n        convertToQueue(iterator);\\n\\t}\\n\\t\\n\\tpublic Integer peek()\\n    {\\n        return this.queue.peek();\\n\\t}\\n\\t\\n\\t@Override\\n\\tpublic Integer next()\\n    {\\n\\t    return this.queue.remove();\\n\\t}\\n\\t\\n\\t@Override\\n\\tpublic boolean hasNext()\\n    {\\n\\t    return this.queue.size() > 0;\\n\\t}\\n    \\n\\t// Converting Iterator to Queue\\n    private void convertToQueue(Iterator<Integer> iterator)\\n    {\\n        while(iterator.hasNext())\\n        {\\n            queue.add(iterator.next());\\n        }\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1559916,
                "title": "well-why-not-c",
                "content": "```\\nclass PeekingIterator : public Iterator {\\npublic:\\n\\tPeekingIterator(const vector<int>& nums) : Iterator(nums) {}\\n\\n\\tint peek() {\\n        return PeekingIterator(*this).next();\\n\\t}\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass PeekingIterator : public Iterator {\\npublic:\\n\\tPeekingIterator(const vector<int>& nums) : Iterator(nums) {}\\n\\n\\tint peek() {\\n        return PeekingIterator(*this).next();\\n\\t}\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1377872,
                "title": "4-lines-of-codes-c-4-ms",
                "content": "I really didn\\'t get what point this problem want to make as below implementation just works fine.\\nNote I\\'m not copying any element, just making a copy of iterator (super lightweight).\\n\\nclass PeekingIterator : public Iterator {\\npublic:\\n\\tPeekingIterator(const vector<int>& nums) : Iterator(nums) {\\t    \\n\\t}\\n\\tint peek() {\\n        PeekingIterator iter = *this;\\n        return iter.next();\\n\\t}\\n\\tint next() {\\n\\t    return Iterator::next();\\n\\t}\\n\\tbool hasNext() const {\\n\\t    return Iterator::hasNext();\\t    \\n\\t}\\n};",
                "solutionTags": [],
                "code": "I really didn\\'t get what point this problem want to make as below implementation just works fine.\\nNote I\\'m not copying any element, just making a copy of iterator (super lightweight).\\n\\nclass PeekingIterator : public Iterator {\\npublic:\\n\\tPeekingIterator(const vector<int>& nums) : Iterator(nums) {\\t    \\n\\t}\\n\\tint peek() {\\n        PeekingIterator iter = *this;\\n        return iter.next();\\n\\t}\\n\\tint next() {\\n\\t    return Iterator::next();\\n\\t}\\n\\tbool hasNext() const {\\n\\t    return Iterator::hasNext();\\t    \\n\\t}\\n};",
                "codeTag": "Java"
            },
            {
                "id": 1055965,
                "title": "python-easy-understanding-solution",
                "content": "\\tclass PeekingIterator:\\n\\t\\tdef __init__(self, iterator):\\n\\t\\t\\tself.iter = iterator\\n\\t\\t\\tself.helper = self.iter.next() if self.iter.hasNext() else None\\n\\t\\t\\t\\n\\t\\n\\t\\tdef peek(self):\\n\\t\\t\\treturn self.helper\\n\\t\\t\\t\\n\\t\\n\\t\\tdef next(self):\\n\\t\\t\\ttmp = self.helper\\n\\t\\t\\tself.helper = self.iter.next() if self.iter.hasNext() else None\\n\\t\\t\\treturn tmp\\n\\t\\t\\n\\t\\n\\t\\tdef hasNext(self):\\n\\t\\t\\treturn self.helper != None",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "\\tclass PeekingIterator:\\n\\t\\tdef __init__(self, iterator):\\n\\t\\t\\tself.iter = iterator\\n\\t\\t\\tself.helper = self.iter.next() if self.iter.hasNext() else None\\n\\t\\t\\t\\n\\t\\n\\t\\tdef peek(self):\\n\\t\\t\\treturn self.helper\\n\\t\\t\\t\\n\\t\\n\\t\\tdef next(self):\\n\\t\\t\\ttmp = self.helper\\n\\t\\t\\tself.helper = self.iter.next() if self.iter.hasNext() else None\\n\\t\\t\\treturn tmp\\n\\t\\t\\n\\t\\n\\t\\tdef hasNext(self):\\n\\t\\t\\treturn self.helper != None",
                "codeTag": "Java"
            },
            {
                "id": 1055796,
                "title": "java",
                "content": "```\\n// Java Iterator interface reference:\\n// https://docs.oracle.com/javase/8/docs/api/java/util/Iterator.html\\n\\nclass PeekingIterator implements Iterator<Integer> {\\n    List<Integer> l=new ArrayList<>();\\n    int i=-1;\\n\\tpublic PeekingIterator(Iterator<Integer> iterator) {\\n\\t    // initialize any member here.\\n        while(iterator.hasNext())\\n            l.add(iterator.next());\\n\\t    \\n\\t}\\n\\t\\n    // Returns the next element in the iteration without advancing the iterator.\\n\\tpublic Integer peek() {\\n        return l.get(i+1);\\n\\t}\\n\\t\\n\\t// hasNext() and next() should behave the same as in the Iterator interface.\\n\\t// Override them if needed.\\n\\t@Override\\n\\tpublic Integer next() {\\n\\t    i++;\\n        return l.get(i);\\n\\t}\\n\\t\\n\\t@Override\\n\\tpublic boolean hasNext() {\\n\\t    return i<l.size()-1;\\n\\t}\\n}\\n```",
                "solutionTags": [],
                "code": "```\\n// Java Iterator interface reference:\\n// https://docs.oracle.com/javase/8/docs/api/java/util/Iterator.html\\n\\nclass PeekingIterator implements Iterator<Integer> {\\n    List<Integer> l=new ArrayList<>();\\n    int i=-1;\\n\\tpublic PeekingIterator(Iterator<Integer> iterator) {\\n\\t    // initialize any member here.\\n        while(iterator.hasNext())\\n            l.add(iterator.next());\\n\\t    \\n\\t}\\n\\t\\n    // Returns the next element in the iteration without advancing the iterator.\\n\\tpublic Integer peek() {\\n        return l.get(i+1);\\n\\t}\\n\\t\\n\\t// hasNext() and next() should behave the same as in the Iterator interface.\\n\\t// Override them if needed.\\n\\t@Override\\n\\tpublic Integer next() {\\n\\t    i++;\\n        return l.get(i);\\n\\t}\\n\\t\\n\\t@Override\\n\\tpublic boolean hasNext() {\\n\\t    return i<l.size()-1;\\n\\t}\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 641582,
                "title": "my-c-code",
                "content": "```\\nstruct PeekingIterator {\\n    struct Iterator* iterator;\\n    bool hasPeeked;\\n    int val;\\n};\\n\\nstruct PeekingIterator* Constructor(struct Iterator* iter) {\\n    struct PeekingIterator* piter = malloc(sizeof(struct PeekingIterator));\\n    piter->iterator = iter;\\n    piter->hasPeeked = false;\\n    return piter;\\n}\\n\\nint peek(struct PeekingIterator* obj) {\\n    if(obj->hasPeeked == false)\\n    {\\n        if(obj->iterator->hasNext())\\n        {\\n            obj->val = obj->iterator->next();\\n            obj->hasPeeked = true;\\n        }\\n    }\\n    \\n    return obj->val;\\n}\\n\\nint next(struct PeekingIterator* obj) {\\n    if(obj->hasPeeked == true)\\n    {\\n        obj->hasPeeked = false;\\n        return obj->val;\\n    }\\n    return obj->iterator->next();\\n}\\n\\nbool hasNext(struct PeekingIterator* obj) {\\n    if((obj->hasPeeked == true) || (obj->iterator->hasNext()))\\n        return true;\\n    else\\n        return false;\\n        \\n}\\n```",
                "solutionTags": [],
                "code": "```\\nstruct PeekingIterator {\\n    struct Iterator* iterator;\\n    bool hasPeeked;\\n    int val;\\n};\\n\\nstruct PeekingIterator* Constructor(struct Iterator* iter) {\\n    struct PeekingIterator* piter = malloc(sizeof(struct PeekingIterator));\\n    piter->iterator = iter;\\n    piter->hasPeeked = false;\\n    return piter;\\n}\\n\\nint peek(struct PeekingIterator* obj) {\\n    if(obj->hasPeeked == false)\\n    {\\n        if(obj->iterator->hasNext())\\n        {\\n            obj->val = obj->iterator->next();\\n            obj->hasPeeked = true;\\n        }\\n    }\\n    \\n    return obj->val;\\n}\\n\\nint next(struct PeekingIterator* obj) {\\n    if(obj->hasPeeked == true)\\n    {\\n        obj->hasPeeked = false;\\n        return obj->val;\\n    }\\n    return obj->iterator->next();\\n}\\n\\nbool hasNext(struct PeekingIterator* obj) {\\n    if((obj->hasPeeked == true) || (obj->iterator->hasNext()))\\n        return true;\\n    else\\n        return false;\\n        \\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 72588,
                "title": "simple-c-1-line",
                "content": "Use inherited copy constructor to get next without advancing iterator.\\nLeave everything else alone for inheritance to take care of.\\n\\n```\\nclass PeekingIterator : public Iterator\\n{\\npublic:\\n\\tPeekingIterator(const vector<int>& nums) : Iterator(nums) {}\\n\\n\\tint peek()\\n\\t{\\n\\t    return Iterator{*this}.next();\\n\\t}\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass PeekingIterator : public Iterator\\n{\\npublic:\\n\\tPeekingIterator(const vector<int>& nums) : Iterator(nums) {}\\n\\n\\tint peek()\\n\\t{\\n\\t    return Iterator{*this}.next();\\n\\t}\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 72595,
                "title": "easy-c-solution-using-4ms",
                "content": "    // Below is the interface for Iterator, which is already defined for you.\\n    // **DO NOT** modify the interface for Iterator.\\n    class Iterator {\\n        struct Data;\\n    \\tData* data;\\n    public:\\n    \\tIterator(const vector<int>& nums);\\n    \\tIterator(const Iterator& iter);\\n    \\tvirtual ~Iterator();\\n    \\t// Returns the next element in the iteration.\\n    \\tint next();\\n    \\t// Returns true if the iteration has more elements.\\n    \\tbool hasNext() const;\\n    };\\n    \\n    \\n    class PeekingIterator : public Iterator {\\n    public:\\n        bool isSaved;\\n        int savedValue ; \\n    \\tPeekingIterator(const vector<int>& nums) : Iterator(nums) {\\n    \\t    // Initialize any member here.\\n    \\t    // **DO NOT** save a copy of nums and manipulate it directly.\\n    \\t    // You should only use the Iterator interface methods.\\n    \\t    isSaved = false;\\n    \\t    \\n    \\t}\\n    \\n        // Returns the next element in the iteration without advancing the iterator.\\n    \\tint peek() {\\n            if(isSaved)\\n                return savedValue;\\n            else{\\n                \\n                savedValue = next();\\n                isSaved = true;\\n                return savedValue;\\n            }\\n    \\t}\\n    \\n    \\t// hasNext() and next() should behave the same as in the Iterator interface.\\n    \\t// Override them if needed.\\n    \\tint next() {\\n    \\t    \\n    \\t    if(isSaved){\\n    \\t        isSaved = false; \\n    \\t        return savedValue;\\n    \\t    }\\n    \\t    isSaved = false; \\n    \\t    return Iterator::next();\\n    \\t}\\n    \\n    \\tbool hasNext() const {\\n    \\t    return isSaved || Iterator::hasNext();\\n    \\t}\\n    };",
                "solutionTags": [],
                "code": "    // Below is the interface for Iterator, which is already defined for you.\\n    // **DO NOT** modify the interface for Iterator.\\n    class Iterator {\\n        struct Data;\\n    \\tData* data;\\n    public:\\n    \\tIterator(const vector<int>& nums);\\n    \\tIterator(const Iterator& iter);\\n    \\tvirtual ~Iterator();\\n    \\t// Returns the next element in the iteration.\\n    \\tint next();\\n    \\t// Returns true if the iteration has more elements.\\n    \\tbool hasNext() const;\\n    };\\n    \\n    \\n    class PeekingIterator : public Iterator {\\n    public:\\n        bool isSaved;\\n        int savedValue ; \\n    \\tPeekingIterator(const vector<int>& nums) : Iterator(nums) {\\n    \\t    // Initialize any member here.\\n    \\t    // **DO NOT** save a copy of nums and manipulate it directly.\\n    \\t    // You should only use the Iterator interface methods.\\n    \\t    isSaved = false;\\n    \\t    \\n    \\t}\\n    \\n        // Returns the next element in the iteration without advancing the iterator.\\n    \\tint peek() {\\n            if(isSaved)\\n                return savedValue;\\n            else{\\n                \\n                savedValue = next();\\n                isSaved = true;\\n                return savedValue;\\n            }\\n    \\t}\\n    \\n    \\t// hasNext() and next() should behave the same as in the Iterator interface.\\n    \\t// Override them if needed.\\n    \\tint next() {\\n    \\t    \\n    \\t    if(isSaved){\\n    \\t        isSaved = false; \\n    \\t        return savedValue;\\n    \\t    }\\n    \\t    isSaved = false; \\n    \\t    return Iterator::next();\\n    \\t}\\n    \\n    \\tbool hasNext() const {\\n    \\t    return isSaved || Iterator::hasNext();\\n    \\t}\\n    };",
                "codeTag": "Java"
            },
            {
                "id": 3236474,
                "title": "284-time-89-38-and-space-100-solution-with-step-by-step-explanation",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n- In the constructor, the iterator is initialized and a buffer is set to the next element if it exists, otherwise, the buffer is set to None.\\n- The peek method returns the element currently in the buffer without advancing the iterator.\\n- The next method returns the element currently in the buffer and advances the iterator to the next element by setting the buffer to the next element if it exists, otherwise, the buffer is set to None.\\n- The hasNext method returns a boolean indicating whether there are more elements to be iterated over by checking if the buffer is not None.\\n\\n# Complexity\\n- Time complexity:\\n89.38%\\n\\n- Space complexity:\\n100%\\n\\n# Code\\n```\\nclass PeekingIterator:\\n  def __init__(self, iterator: Iterator):\\n    self.iterator = iterator\\n    self.buffer = self.iterator.next() if self.iterator.hasNext() else None\\n\\n  def peek(self) -> int:\\n    \"\"\"\\n    Returns the next element in the iteration without advancing the iterator.\\n    \"\"\"\\n    return self.buffer\\n\\n  def next(self) -> int:\\n    next = self.buffer\\n    self.buffer = self.iterator.next() if self.iterator.hasNext() else None\\n    return next\\n\\n  def hasNext(self) -> bool:\\n    return self.buffer is not None\\n\\n```",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Array",
                    "Design",
                    "Iterator"
                ],
                "code": "```\\nclass PeekingIterator:\\n  def __init__(self, iterator: Iterator):\\n    self.iterator = iterator\\n    self.buffer = self.iterator.next() if self.iterator.hasNext() else None\\n\\n  def peek(self) -> int:\\n    \"\"\"\\n    Returns the next element in the iteration without advancing the iterator.\\n    \"\"\"\\n    return self.buffer\\n\\n  def next(self) -> int:\\n    next = self.buffer\\n    self.buffer = self.iterator.next() if self.iterator.hasNext() else None\\n    return next\\n\\n  def hasNext(self) -> bool:\\n    return self.buffer is not None\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1981141,
                "title": "python-solution-easy-to-understand",
                "content": "```\\nclass PeekingIterator:\\n    def __init__(self, iterator):\\n        self.iterator = iterator\\n        self.temp = self.iterator.next() if self.iterator.hasNext() else None\\n\\n    def peek(self):\\n        \"\"\"\\n        Returns the next element in the iteration without advancing the iterator.\\n        :rtype: int\\n        \"\"\"\\n        return self.temp\\n\\n    def next(self):\\n        \"\"\"\\n        :rtype: int\\n        \"\"\"\\n        value = self.temp\\n        if self.iterator.hasNext():\\n            self.temp = self.iterator.next()\\n        else:\\n            self.temp = None\\n        return value\\n\\n    def hasNext(self):\\n        \"\"\"\\n        :rtype: bool\\n        \"\"\"\\n        if self.temp is None:\\n            return False\\n        else:\\n            return True\\n```\\nHere instead of simple iterator we need to keep value in temp variable to show in peek function.\\nIf you find this **solution** and **explanation** helpful, please **upvote** it for others people.",
                "solutionTags": [
                    "Python",
                    "Iterator"
                ],
                "code": "```\\nclass PeekingIterator:\\n    def __init__(self, iterator):\\n        self.iterator = iterator\\n        self.temp = self.iterator.next() if self.iterator.hasNext() else None\\n\\n    def peek(self):\\n        \"\"\"\\n        Returns the next element in the iteration without advancing the iterator.\\n        :rtype: int\\n        \"\"\"\\n        return self.temp\\n\\n    def next(self):\\n        \"\"\"\\n        :rtype: int\\n        \"\"\"\\n        value = self.temp\\n        if self.iterator.hasNext():\\n            self.temp = self.iterator.next()\\n        else:\\n            self.temp = None\\n        return value\\n\\n    def hasNext(self):\\n        \"\"\"\\n        :rtype: bool\\n        \"\"\"\\n        if self.temp is None:\\n            return False\\n        else:\\n            return True\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1980055,
                "title": "java-solution",
                "content": "```\\n// Java Iterator interface reference:\\n// https://docs.oracle.com/javase/8/docs/api/java/util/Iterator.html\\n\\nclass PeekingIterator implements Iterator<Integer> {\\n    private List<Integer> res = new ArrayList<>();\\n\\tpublic PeekingIterator(Iterator<Integer> iterator) {\\n\\t    // initialize any member here.\\n\\t    while(iterator.hasNext())\\n            res.add(iterator.next());\\n\\t}\\n\\t\\n    // Returns the next element in the iteration without advancing the iterator.\\n\\tpublic Integer peek() {\\n        return res.get(0);\\n\\t}\\n\\t\\n\\t// hasNext() and next() should behave the same as in the Iterator interface.\\n\\t// Override them if needed.\\n\\t@Override\\n\\tpublic Integer next() {\\n\\t    int data = res.get(0);\\n        res.remove(0);\\n        return data;\\n\\t}\\n\\t\\n\\t@Override\\n\\tpublic boolean hasNext() {\\n\\t    return !res.isEmpty();\\n\\t}\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Array",
                    "Iterator"
                ],
                "code": "```\\n// Java Iterator interface reference:\\n// https://docs.oracle.com/javase/8/docs/api/java/util/Iterator.html\\n\\nclass PeekingIterator implements Iterator<Integer> {\\n    private List<Integer> res = new ArrayList<>();\\n\\tpublic PeekingIterator(Iterator<Integer> iterator) {\\n\\t    // initialize any member here.\\n\\t    while(iterator.hasNext())\\n            res.add(iterator.next());\\n\\t}\\n\\t\\n    // Returns the next element in the iteration without advancing the iterator.\\n\\tpublic Integer peek() {\\n        return res.get(0);\\n\\t}\\n\\t\\n\\t// hasNext() and next() should behave the same as in the Iterator interface.\\n\\t// Override them if needed.\\n\\t@Override\\n\\tpublic Integer next() {\\n\\t    int data = res.get(0);\\n        res.remove(0);\\n        return data;\\n\\t}\\n\\t\\n\\t@Override\\n\\tpublic boolean hasNext() {\\n\\t    return !res.isEmpty();\\n\\t}\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1979855,
                "title": "c-easy-solution",
                "content": "```\\nclass PeekingIterator : public Iterator {\\n    private:\\n    \\n        int *head ;\\n        int pointer = 0 ,size; \\npublic:\\n\\tPeekingIterator(const vector<int>& nums) : Iterator(nums) {\\n\\t    // Initialize any member here.\\n\\t    // **DO NOT** save a copy of nums and manipulate it directly.\\n\\t    // You should only use the Iterator interface methods.\\n        int n = nums.size();\\n\\t    head = new int[n];\\n        for(auto c : nums) head[pointer++] = c ;\\n        pointer = 0 ;\\n        size = nums.size();\\n        \\n\\t}\\n\\t\\n    // Returns the next element in the iteration without advancing the iterator.\\n\\tint peek() {\\n        return head[pointer] ;\\n\\t}\\n\\t\\n\\t// hasNext() and next() should behave the same as in the Iterator interface.\\n\\t// Override them if needed.\\n\\tint next() {\\n\\t    return head[pointer++];\\n\\t}\\n\\t\\n\\tbool hasNext() const {\\n\\t    return pointer<size ;\\n\\t}\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass PeekingIterator : public Iterator {\\n    private:\\n    \\n        int *head ;\\n        int pointer = 0 ,size; \\npublic:\\n\\tPeekingIterator(const vector<int>& nums) : Iterator(nums) {\\n\\t    // Initialize any member here.\\n\\t    // **DO NOT** save a copy of nums and manipulate it directly.\\n\\t    // You should only use the Iterator interface methods.\\n        int n = nums.size();\\n\\t    head = new int[n];\\n        for(auto c : nums) head[pointer++] = c ;\\n        pointer = 0 ;\\n        size = nums.size();\\n        \\n\\t}\\n\\t\\n    // Returns the next element in the iteration without advancing the iterator.\\n\\tint peek() {\\n        return head[pointer] ;\\n\\t}\\n\\t\\n\\t// hasNext() and next() should behave the same as in the Iterator interface.\\n\\t// Override them if needed.\\n\\tint next() {\\n\\t    return head[pointer++];\\n\\t}\\n\\t\\n\\tbool hasNext() const {\\n\\t    return pointer<size ;\\n\\t}\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1979852,
                "title": "c-solution",
                "content": "// C# IEnumerator interface reference:\\n// https://docs.microsoft.com/en-us/dotnet/api/system.collections.ienumerator?view=netframework-4.8\\n\\n\\tclass PeekingIterator {\\n    \\n    IEnumerator<int> _iterator;\\n    bool _hasNext;\\n    \\n    // iterators refers to the first element of the array.\\n    public PeekingIterator(IEnumerator<int> iterator) {\\n        // initialize any member here.\\n        _iterator = iterator;\\n        _hasNext= true;\\n    }\\n    \\n    // Returns the next element in the iteration without advancing the iterator.\\n    public int Peek() {\\n        return _iterator.Current;\\n    }\\n    \\n    // Returns the next element in the iteration and advances the iterator.\\n    public int Next() {\\n        int returnValue = _iterator.Current;\\n        _hasNext = _iterator.MoveNext();\\n        return returnValue;\\n    }\\n    \\n    // Returns false if the iterator is refering to the end of the array of true otherwise.\\n    public bool HasNext() {\\n\\t\\treturn _hasNext;\\n    }\\n}",
                "solutionTags": [],
                "code": "// C# IEnumerator interface reference:\\n// https://docs.microsoft.com/en-us/dotnet/api/system.collections.ienumerator?view=netframework-4.8\\n\\n\\tclass PeekingIterator {\\n    \\n    IEnumerator<int> _iterator;\\n    bool _hasNext;\\n    \\n    // iterators refers to the first element of the array.\\n    public PeekingIterator(IEnumerator<int> iterator) {\\n        // initialize any member here.\\n        _iterator = iterator;\\n        _hasNext= true;\\n    }\\n    \\n    // Returns the next element in the iteration without advancing the iterator.\\n    public int Peek() {\\n        return _iterator.Current;\\n    }\\n    \\n    // Returns the next element in the iteration and advances the iterator.\\n    public int Next() {\\n        int returnValue = _iterator.Current;\\n        _hasNext = _iterator.MoveNext();\\n        return returnValue;\\n    }\\n    \\n    // Returns false if the iterator is refering to the end of the array of true otherwise.\\n    public bool HasNext() {\\n\\t\\treturn _hasNext;\\n    }\\n}",
                "codeTag": "Java"
            },
            {
                "id": 1726163,
                "title": "c-cache-next-val",
                "content": "```\\nclass PeekingIterator : public Iterator {\\npublic:\\n    int next_val=0;\\n\\tPeekingIterator(const vector<int>& nums) : Iterator(nums) {\\n\\t    if(Iterator::hasNext()) next_val=Iterator::next();\\n\\t}\\n\\t\\n\\tint peek() {\\n        return next_val;\\n\\t}\\n    \\n\\tint next() {\\n        int temp=next_val;\\n        if(Iterator::hasNext()) next_val=Iterator::next();\\n        else next_val=0;\\n        return temp;\\n\\t}\\n\\t\\n\\tbool hasNext() const {\\n\\t    return next_val;\\n\\t}\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nclass PeekingIterator : public Iterator {\\npublic:\\n    int next_val=0;\\n\\tPeekingIterator(const vector<int>& nums) : Iterator(nums) {\\n\\t    if(Iterator::hasNext()) next_val=Iterator::next();\\n\\t}\\n\\t\\n\\tint peek() {\\n        return next_val;\\n\\t}\\n    \\n\\tint next() {\\n        int temp=next_val;\\n        if(Iterator::hasNext()) next_val=Iterator::next();\\n        else next_val=0;\\n        return temp;\\n\\t}\\n\\t\\n\\tbool hasNext() const {\\n\\t    return next_val;\\n\\t}\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 987794,
                "title": "c-o-1-extra-space-complexity",
                "content": "```\\nclass PeekingIterator : public Iterator {\\n    bool peeking; \\n    int peek_val; \\npublic:\\n\\tPeekingIterator(const vector<int>& nums) : Iterator(nums), peeking(false), peek_val(0) {\\n\\t    // Initialize any member here.\\n\\t    // **DO NOT** save a copy of nums and manipulate it directly.\\n\\t    // You should only use the Iterator interface methods.\\n\\t}\\n\\t\\n    // Returns the next element in the iteration without advancing the iterator.\\n\\tint peek() {\\n        if (!this->peeking) {\\n            this->peek_val = Iterator::next(); \\n            this->peeking = true; \\n        }\\n        return this->peek_val; \\n\\t}\\n\\t\\n\\t// hasNext() and next() should behave the same as in the Iterator interface.\\n\\t// Override them if needed.\\n\\tint next() {\\n\\t    if (this->peeking) {\\n            this->peeking = false; \\n            return this->peek_val; \\n        } else {\\n            return Iterator::next();\\n        }\\n\\t}\\n\\t\\n\\tbool hasNext() const {\\n\\t    if (this->peeking) {\\n            return true;\\n        } else {\\n            return Iterator::hasNext();\\n        }\\n\\t}\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass PeekingIterator : public Iterator {\\n    bool peeking; \\n    int peek_val; \\npublic:\\n\\tPeekingIterator(const vector<int>& nums) : Iterator(nums), peeking(false), peek_val(0) {\\n\\t    // Initialize any member here.\\n\\t    // **DO NOT** save a copy of nums and manipulate it directly.\\n\\t    // You should only use the Iterator interface methods.\\n\\t}\\n\\t\\n    // Returns the next element in the iteration without advancing the iterator.\\n\\tint peek() {\\n        if (!this->peeking) {\\n            this->peek_val = Iterator::next(); \\n            this->peeking = true; \\n        }\\n        return this->peek_val; \\n\\t}\\n\\t\\n\\t// hasNext() and next() should behave the same as in the Iterator interface.\\n\\t// Override them if needed.\\n\\tint next() {\\n\\t    if (this->peeking) {\\n            this->peeking = false; \\n            return this->peek_val; \\n        } else {\\n            return Iterator::next();\\n        }\\n\\t}\\n\\t\\n\\tbool hasNext() const {\\n\\t    if (this->peeking) {\\n            return true;\\n        } else {\\n            return Iterator::hasNext();\\n        }\\n\\t}\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 72590,
                "title": "concise-and-clean-java-solution",
                "content": "Simple helper function make things easier\\n\\n    class PeekingIterator implements Iterator<Integer> {\\n    \\tprivate Iterator<Integer> iterator;\\n    \\tprivate Integer curr;\\n    \\tprivate boolean next;\\n    \\n    \\tpublic PeekingIterator(Iterator<Integer> iterator) {\\n    \\t\\tthis.iterator = iterator;\\n    \\t\\tprepareNext();\\n    \\t}\\n    \\n    \\tprivate void prepareNext() {\\n    \\t    next = iterator.hasNext();\\n    \\t    curr = next ? iterator.next() : null;\\n    \\t}\\n    \\n    \\tpublic Integer peek() {\\n    \\t\\treturn curr;\\n    \\t}\\n    \\n    \\t@Override\\n    \\tpublic Integer next() {\\n    \\t\\tInteger val = curr;\\n    \\t\\tprepareNext();\\n    \\t\\treturn val;\\n    \\t}\\n    \\n    \\t@Override\\n    \\tpublic boolean hasNext() {\\n    \\t\\treturn next;\\n    \\t}\\n    }",
                "solutionTags": [
                    "Java",
                    "Memoization"
                ],
                "code": "Simple helper function make things easier\\n\\n    class PeekingIterator implements Iterator<Integer> {\\n    \\tprivate Iterator<Integer> iterator;\\n    \\tprivate Integer curr;\\n    \\tprivate boolean next;\\n    \\n    \\tpublic PeekingIterator(Iterator<Integer> iterator) {\\n    \\t\\tthis.iterator = iterator;\\n    \\t\\tprepareNext();\\n    \\t}\\n    \\n    \\tprivate void prepareNext() {\\n    \\t    next = iterator.hasNext();\\n    \\t    curr = next ? iterator.next() : null;\\n    \\t}\\n    \\n    \\tpublic Integer peek() {\\n    \\t\\treturn curr;\\n    \\t}\\n    \\n    \\t@Override\\n    \\tpublic Integer next() {\\n    \\t\\tInteger val = curr;\\n    \\t\\tprepareNext();\\n    \\t\\treturn val;\\n    \\t}\\n    \\n    \\t@Override\\n    \\tpublic boolean hasNext() {\\n    \\t\\treturn next;\\n    \\t}\\n    }",
                "codeTag": "Java"
            },
            {
                "id": 72592,
                "title": "c-4ms-solution",
                "content": "    class PeekingIterator : public Iterator {\\n    public:\\n    \\tPeekingIterator(const vector<int>& nums) : Iterator(nums) {}\\n    \\n    \\tint peek() {\\n            if (peeked_) {\\n                return next_val_;\\n            }\\n            next_val_ = Iterator::next();\\n            peeked_ = true;\\n            return next_val_;\\n    \\t}\\n    \\n    \\tint next() {\\n    \\t    if (peeked_) {\\n    \\t        peeked_ = false;\\n    \\t        return next_val_;\\n    \\t    }\\n    \\t    return Iterator::next();\\n    \\t}\\n    \\n    \\tbool hasNext() const {\\n    \\t    if (peeked_) {\\n    \\t        return true;\\n    \\t    }\\n    \\t    return Iterator::hasNext();\\n    \\t}\\n    \\t\\n    private:\\n        bool peeked_ = false;\\n        int next_val_ = 0;\\n    };",
                "solutionTags": [
                    "C++",
                    "Iterator"
                ],
                "code": "    class PeekingIterator : public Iterator {\\n    public:\\n    \\tPeekingIterator(const vector<int>& nums) : Iterator(nums) {}\\n    \\n    \\tint peek() {\\n            if (peeked_) {\\n                return next_val_;\\n            }\\n            next_val_ = Iterator::next();\\n            peeked_ = true;\\n            return next_val_;\\n    \\t}\\n    \\n    \\tint next() {\\n    \\t    if (peeked_) {\\n    \\t        peeked_ = false;\\n    \\t        return next_val_;\\n    \\t    }\\n    \\t    return Iterator::next();\\n    \\t}\\n    \\n    \\tbool hasNext() const {\\n    \\t    if (peeked_) {\\n    \\t        return true;\\n    \\t    }\\n    \\t    return Iterator::hasNext();\\n    \\t}\\n    \\t\\n    private:\\n        bool peeked_ = false;\\n        int next_val_ = 0;\\n    };",
                "codeTag": "Java"
            },
            {
                "id": 72615,
                "title": "simple-java-solution-using-cached-value-107ms",
                "content": "    class PeekingIterator implements Iterator<Integer> {\\n    \\n        private Integer nextCachedVal = null;\\n        private Iterator<Integer> iterator;\\n    \\n    \\tpublic PeekingIterator(Iterator<Integer> iterator) {\\n    \\t    // initialize any member here.\\n    \\t    this.iterator = iterator;\\n    \\t    next(); // cache the next value if any\\n    \\t}\\n    \\n        // Returns the next element in the iteration without advancing the iterator.\\n    \\tpublic Integer peek() {\\n            return nextCachedVal;\\n    \\t}\\n    \\n    \\t// hasNext() and next() should behave the same as in the Iterator interface.\\n    \\t// Override them if needed.\\n    \\t@Override\\n    \\tpublic Integer next() {\\n    \\t    Integer retVal = nextCachedVal;\\n    \\t    nextCachedVal = iterator.hasNext() ? iterator.next() : null;\\n    \\t    return retVal;\\n    \\t}\\n    \\n    \\t@Override\\n    \\tpublic boolean hasNext() {\\n    \\t    return (nextCachedVal != null);\\n    \\t}\\n    }",
                "solutionTags": [],
                "code": "    class PeekingIterator implements Iterator<Integer> {\\n    \\n        private Integer nextCachedVal = null;\\n        private Iterator<Integer> iterator;\\n    \\n    \\tpublic PeekingIterator(Iterator<Integer> iterator) {\\n    \\t    // initialize any member here.\\n    \\t    this.iterator = iterator;\\n    \\t    next(); // cache the next value if any\\n    \\t}\\n    \\n        // Returns the next element in the iteration without advancing the iterator.\\n    \\tpublic Integer peek() {\\n            return nextCachedVal;\\n    \\t}\\n    \\n    \\t// hasNext() and next() should behave the same as in the Iterator interface.\\n    \\t// Override them if needed.\\n    \\t@Override\\n    \\tpublic Integer next() {\\n    \\t    Integer retVal = nextCachedVal;\\n    \\t    nextCachedVal = iterator.hasNext() ? iterator.next() : null;\\n    \\t    return retVal;\\n    \\t}\\n    \\n    \\t@Override\\n    \\tpublic boolean hasNext() {\\n    \\t    return (nextCachedVal != null);\\n    \\t}\\n    }",
                "codeTag": "Java"
            },
            {
                "id": 72629,
                "title": "accepted-java-solution-peeking-iterator",
                "content": "\\nclass PeekingIterator implements Iterator<Integer> {\\n    \\n    private Iterator<Integer> iter;\\n    private Integer v;\\n\\n\\tpublic PeekingIterator(Iterator<Integer> iterator) {\\n\\t    this.iter = iterator;\\n\\t    v = null;\\n\\t    \\n\\t}\\n\\n    \\n\\tpublic Integer peek() {\\n        if(v == null){\\n            v = iter.next();\\n        }\\n        return v;\\n\\t}\\n\\n\\t\\n\\t@Override\\n\\tpublic Integer next() {\\n\\t    Integer tmp = null;\\n\\t    if(v == null){\\n\\t        v = iter.next();\\n\\t        tmp = v;\\n\\t        v = null;\\n\\t        return tmp;\\n\\t    }\\n\\t    tmp = v;\\n\\t    v = null;\\n\\t    return tmp;\\n\\t    \\n\\t}\\n\\n\\t@Override\\n\\tpublic boolean hasNext() {\\n\\t   if(v != null){\\n\\t       return true;\\n\\t   } \\n\\t   return iter.hasNext();\\n\\t}\\n}",
                "solutionTags": [],
                "code": "\\nclass PeekingIterator implements Iterator<Integer> {\\n    \\n    private Iterator<Integer> iter;\\n    private Integer v;\\n\\n\\tpublic PeekingIterator(Iterator<Integer> iterator) {\\n\\t    this.iter = iterator;\\n\\t    v = null;\\n\\t    \\n\\t}\\n\\n    \\n\\tpublic Integer peek() {\\n        if(v == null){\\n            v = iter.next();\\n        }\\n        return v;\\n\\t}\\n\\n\\t\\n\\t@Override\\n\\tpublic Integer next() {\\n\\t    Integer tmp = null;\\n\\t    if(v == null){\\n\\t        v = iter.next();\\n\\t        tmp = v;\\n\\t        v = null;\\n\\t        return tmp;\\n\\t    }\\n\\t    tmp = v;\\n\\t    v = null;\\n\\t    return tmp;\\n\\t    \\n\\t}\\n\\n\\t@Override\\n\\tpublic boolean hasNext() {\\n\\t   if(v != null){\\n\\t       return true;\\n\\t   } \\n\\t   return iter.hasNext();\\n\\t}\\n}",
                "codeTag": "Java"
            },
            {
                "id": 72557,
                "title": "next-hasnext-use-peek",
                "content": "Just a variation where `next` and `hasNext` use `peek`.\\n\\n    class PeekingIterator implements Iterator<Integer> {\\n    \\n    \\tpublic PeekingIterator(Iterator<Integer> iterator) {\\n    \\t    this.iterator = iterator;\\n    \\t}\\n    \\n    \\tpublic Integer peek() {\\n    \\t    if (cache == null && iterator.hasNext())\\n    \\t        cache = iterator.next();\\n            return cache;\\n    \\t}\\n    \\n    \\tpublic Integer next() {\\n    \\t    Integer tmp = peek();\\n    \\t    cache = null;\\n    \\t    return tmp;\\n    \\t}\\n    \\n    \\tpublic boolean hasNext() {\\n    \\t    return peek() != null;\\n    \\t}\\n    \\t\\n    \\tprivate Iterator<Integer> iterator;\\n    \\tprivate Integer cache;\\n    }",
                "solutionTags": [
                    "Java"
                ],
                "code": "Just a variation where `next` and `hasNext` use `peek`.\\n\\n    class PeekingIterator implements Iterator<Integer> {\\n    \\n    \\tpublic PeekingIterator(Iterator<Integer> iterator) {\\n    \\t    this.iterator = iterator;\\n    \\t}\\n    \\n    \\tpublic Integer peek() {\\n    \\t    if (cache == null && iterator.hasNext())\\n    \\t        cache = iterator.next();\\n            return cache;\\n    \\t}\\n    \\n    \\tpublic Integer next() {\\n    \\t    Integer tmp = peek();\\n    \\t    cache = null;\\n    \\t    return tmp;\\n    \\t}\\n    \\n    \\tpublic boolean hasNext() {\\n    \\t    return peek() != null;\\n    \\t}\\n    \\t\\n    \\tprivate Iterator<Integer> iterator;\\n    \\tprivate Integer cache;\\n    }",
                "codeTag": "Java"
            },
            {
                "id": 72643,
                "title": "c-code-of-this-problem",
                "content": "    class PeekingIterator : public Iterator {\\n        \\n        int peekele;\\n        bool peeked;\\n        \\n    public:\\n    \\tPeekingIterator(const vector<int>& num) : Iterator(num) {\\n    \\t    // Initialize any member here.\\n    \\t    peeked = false;\\n    \\t}\\n    \\n        // Returns the next element in the iteration without advancing the iterator.\\n    \\tint peek() {\\n            if(!peeked) {\\n                peekele = Iterator::next();\\n                peeked = true;\\n            }\\n            return peekele;\\n    \\t}\\n    \\n    \\t// hasNext() and next() should behave the same as in the Iterator interface.\\n    \\t// Override them if needed.\\n    \\tint next() {\\n    \\t    if(!peeked) return Iterator::next();\\n            peeked = false;\\n            return peekele;\\n    \\t}\\n    \\n    \\tbool hasNext() const {\\n    \\t    if(peeked) return true;\\n    \\t    if(Iterator::hasNext()) return true;\\n    \\t    return false;\\n    \\t}\\n    };",
                "solutionTags": [
                    "C++"
                ],
                "code": "    class PeekingIterator : public Iterator {\\n        \\n        int peekele;\\n        bool peeked;\\n        \\n    public:\\n    \\tPeekingIterator(const vector<int>& num) : Iterator(num) {\\n    \\t    // Initialize any member here.\\n    \\t    peeked = false;\\n    \\t}\\n    \\n        // Returns the next element in the iteration without advancing the iterator.\\n    \\tint peek() {\\n            if(!peeked) {\\n                peekele = Iterator::next();\\n                peeked = true;\\n            }\\n            return peekele;\\n    \\t}\\n    \\n    \\t// hasNext() and next() should behave the same as in the Iterator interface.\\n    \\t// Override them if needed.\\n    \\tint next() {\\n    \\t    if(!peeked) return Iterator::next();\\n            peeked = false;\\n            return peekele;\\n    \\t}\\n    \\n    \\tbool hasNext() const {\\n    \\t    if(peeked) return true;\\n    \\t    if(Iterator::hasNext()) return true;\\n    \\t    return false;\\n    \\t}\\n    };",
                "codeTag": "Java"
            },
            {
                "id": 3221615,
                "title": "solution-in-c",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass PeekingIterator : public Iterator {\\npublic:\\n\\tPeekingIterator(const vector<int>& nums) : Iterator(nums) { }\\n\\n\\tint peek() { \\n\\t    return Iterator(*this).next(); \\n\\t}\\n};\\n\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass PeekingIterator : public Iterator {\\npublic:\\n\\tPeekingIterator(const vector<int>& nums) : Iterator(nums) { }\\n\\n\\tint peek() { \\n\\t    return Iterator(*this).next(); \\n\\t}\\n};\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2299519,
                "title": "python-simple-solution-very-easy-to-understand",
                "content": "```\\nclass PeekingIterator:\\n    def __init__(self, iterator):\\n        \"\"\"\\n        Initialize your data structure here.\\n        :type iterator: Iterator\\n        \"\"\"\\n        self.iterator = iterator\\n        self.peeked_elem = None\\n\\n    def peek(self):\\n        \"\"\"\\n        Returns the next element in the iteration without advancing the iterator.\\n        :rtype: int\\n        \"\"\"\\n        if self.peeked_elem is None:\\n            self.peeked_elem = self.iterator.next()\\n        return self.peeked_elem\\n\\n    def next(self):\\n        \"\"\"\\n        :rtype: int\\n        \"\"\"\\n        if self.peeked_elem is not None:\\n            elem = self.peeked_elem\\n            self.peeked_elem = None\\n            return elem\\n        else:\\n            return self.iterator.next()\\n        \\n\\n    def hasNext(self):\\n        \"\"\"\\n        :rtype: bool\\n        \"\"\"\\n        if self.peeked_elem is not None:\\n            return True\\n        return self.iterator.hasNext()\\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nclass PeekingIterator:\\n    def __init__(self, iterator):\\n        \"\"\"\\n        Initialize your data structure here.\\n        :type iterator: Iterator\\n        \"\"\"\\n        self.iterator = iterator\\n        self.peeked_elem = None\\n\\n    def peek(self):\\n        \"\"\"\\n        Returns the next element in the iteration without advancing the iterator.\\n        :rtype: int\\n        \"\"\"\\n        if self.peeked_elem is None:\\n            self.peeked_elem = self.iterator.next()\\n        return self.peeked_elem\\n\\n    def next(self):\\n        \"\"\"\\n        :rtype: int\\n        \"\"\"\\n        if self.peeked_elem is not None:\\n            elem = self.peeked_elem\\n            self.peeked_elem = None\\n            return elem\\n        else:\\n            return self.iterator.next()\\n        \\n\\n    def hasNext(self):\\n        \"\"\"\\n        :rtype: bool\\n        \"\"\"\\n        if self.peeked_elem is not None:\\n            return True\\n        return self.iterator.hasNext()\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1981555,
                "title": "c-easy-implementation-using-vector-daily-leetcoding-challenge-april-day-25",
                "content": "**Please Upvote If It Helps**\\n\\n```\\nclass PeekingIterator : public Iterator \\n{\\npublic:\\n    // it will store the given vector value\\n    // and also declare a integer value that will take care of values\\n    vector<int> temp;\\n    int i=0; \\n    \\n\\tPeekingIterator(const vector<int>& nums) : Iterator(nums) \\n    {\\n\\t    // Initialize any member here.\\n\\t    // **DO NOT** save a copy of nums and manipulate it directly.\\n\\t    // You should only use the Iterator interface methods.\\n        \\n\\t    // assigning the given vector to our temp vector\\n\\t    temp = nums;\\n\\t}\\n\\t\\n    // Returns the next element in the iteration without advancing the iterator.\\n\\tint peek() \\n    {\\n        // print the value withour moving pointer\\n        return temp[i];\\n\\t}\\n\\t\\n\\t// hasNext() and next() should behave the same as in the Iterator interface.\\n\\t// Override them if needed.\\n\\tint next() \\n    {\\n        // print the value and nove the pointer\\n\\t    return temp[i++];\\n\\t}\\n\\t\\n\\tbool hasNext() const \\n    {\\n        // our i crossed the limit\\n\\t    if(i>=temp.size())\\n        {\\n            return false;\\n        }\\n        else\\n        {\\n            return true;\\n        }\\n\\t}\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass PeekingIterator : public Iterator \\n{\\npublic:\\n    // it will store the given vector value\\n    // and also declare a integer value that will take care of values\\n    vector<int> temp;\\n    int i=0; \\n    \\n\\tPeekingIterator(const vector<int>& nums) : Iterator(nums) \\n    {\\n\\t    // Initialize any member here.\\n\\t    // **DO NOT** save a copy of nums and manipulate it directly.\\n\\t    // You should only use the Iterator interface methods.\\n        \\n\\t    // assigning the given vector to our temp vector\\n\\t    temp = nums;\\n\\t}\\n\\t\\n    // Returns the next element in the iteration without advancing the iterator.\\n\\tint peek() \\n    {\\n        // print the value withour moving pointer\\n        return temp[i];\\n\\t}\\n\\t\\n\\t// hasNext() and next() should behave the same as in the Iterator interface.\\n\\t// Override them if needed.\\n\\tint next() \\n    {\\n        // print the value and nove the pointer\\n\\t    return temp[i++];\\n\\t}\\n\\t\\n\\tbool hasNext() const \\n    {\\n        // our i crossed the limit\\n\\t    if(i>=temp.size())\\n        {\\n            return false;\\n        }\\n        else\\n        {\\n            return true;\\n        }\\n\\t}\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1980734,
                "title": "typescript-cache-current-value-and-mark-as-consumed-comments",
                "content": "```typescript\\n/*\\n\\nHere is the idea:\\n\\nLazily(!) cache the current value and keep track of whether we already consumed it.\\nWe will use a consumed current with the value of undefined initially.\\n\\nWhen we peek:\\n- If the current value is already consumed then we retrieve a new unconsumed one.\\n- Otherwise, the current value.\\n\\nWhen we next:\\n- If the current value is already consumed then we retrieve a new unconsumed one.\\n- And we always consume the current value.\\n\\nWhen we check for has next:\\n- If the current value is not yet consumed, then we have a next for sure (namely, the current value).\\n- Otherwise, it depends on the wrapping iterator if we have a next.\\n\\n*/\\n\\nclass PeekingIterator {\\n    iterator: Iterator\\n    current: {value: number, consumed: boolean}\\n    \\n    constructor(iterator: Iterator) {\\n        this.iterator = iterator\\n        \\n        // this.nextOrPreconsumed would also work, but doesn\\'t fit with the laziness of iterators,\\n        // since we will produce a next element before we strictly need it.\\n        this.current = {value: undefined, consumed: true}\\n    }\\n\\n    peek(): number {\\n        if (this.current.consumed) {\\n            this.current = this.nextOrPreconsumed()\\n        }\\n        \\n        // The contract doesn\\'t specify what should happen if \\n        // this.current.consumed == true\\n        // We just return undefined for now.\\n        \\n        return this.current.value\\n    }\\n\\n    next(): number {\\n        if (this.current.consumed) {\\n            this.current = this.nextOrPreconsumed()\\n        }\\n        \\n        // The contract doesn\\'t specify what should happen if \\n        // this.current.consumed == true\\n        // We just ignore it for now.\\n        \\n        this.current.consumed = true\\n        return this.current.value\\n    }\\n\\n    hasNext(): boolean {\\n        if (this.current.consumed) {\\n            return this.iterator.hasNext()\\n        }\\n        return !this.current.consumed\\n    }\\n\\n    private nextOrPreconsumed(): {value: number, consumed: boolean} {\\n        if (this.iterator.hasNext()) {\\n            return {value: this.iterator.next(), consumed: false}\\n        }\\n        \\n        // This will happen when you peek an empty iterator.\\n        // I\\'m not sure what we should do in that case.\\n        // With this implementation we return undefined.\\n        // We can\\'t return consumed = false, because then hasNext will be incorrect.\\n        // But we also can\\'t assert in peek that the current value was not consumed.\\n        // Which is a bit ugly.\\n        return {value: undefined, consumed: true}\\n    }\\n}\\n```",
                "solutionTags": [
                    "TypeScript"
                ],
                "code": "```typescript\\n/*\\n\\nHere is the idea:\\n\\nLazily(!) cache the current value and keep track of whether we already consumed it.\\nWe will use a consumed current with the value of undefined initially.\\n\\nWhen we peek:\\n- If the current value is already consumed then we retrieve a new unconsumed one.\\n- Otherwise, the current value.\\n\\nWhen we next:\\n- If the current value is already consumed then we retrieve a new unconsumed one.\\n- And we always consume the current value.\\n\\nWhen we check for has next:\\n- If the current value is not yet consumed, then we have a next for sure (namely, the current value).\\n- Otherwise, it depends on the wrapping iterator if we have a next.\\n\\n*/\\n\\nclass PeekingIterator {\\n    iterator: Iterator\\n    current: {value: number, consumed: boolean}\\n    \\n    constructor(iterator: Iterator) {\\n        this.iterator = iterator\\n        \\n        // this.nextOrPreconsumed would also work, but doesn\\'t fit with the laziness of iterators,\\n        // since we will produce a next element before we strictly need it.\\n        this.current = {value: undefined, consumed: true}\\n    }\\n\\n    peek(): number {\\n        if (this.current.consumed) {\\n            this.current = this.nextOrPreconsumed()\\n        }\\n        \\n        // The contract doesn\\'t specify what should happen if \\n        // this.current.consumed == true\\n        // We just return undefined for now.\\n        \\n        return this.current.value\\n    }\\n\\n    next(): number {\\n        if (this.current.consumed) {\\n            this.current = this.nextOrPreconsumed()\\n        }\\n        \\n        // The contract doesn\\'t specify what should happen if \\n        // this.current.consumed == true\\n        // We just ignore it for now.\\n        \\n        this.current.consumed = true\\n        return this.current.value\\n    }\\n\\n    hasNext(): boolean {\\n        if (this.current.consumed) {\\n            return this.iterator.hasNext()\\n        }\\n        return !this.current.consumed\\n    }\\n\\n    private nextOrPreconsumed(): {value: number, consumed: boolean} {\\n        if (this.iterator.hasNext()) {\\n            return {value: this.iterator.next(), consumed: false}\\n        }\\n        \\n        // This will happen when you peek an empty iterator.\\n        // I\\'m not sure what we should do in that case.\\n        // With this implementation we return undefined.\\n        // We can\\'t return consumed = false, because then hasNext will be incorrect.\\n        // But we also can\\'t assert in peek that the current value was not consumed.\\n        // Which is a bit ugly.\\n        return {value: undefined, consumed: true}\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1980231,
                "title": "javascript-solution",
                "content": "```\\n/**\\n * // This is the Iterator\\'s API interface.\\n * // You should not implement it, or speculate about its implementation.\\n * function Iterator() {\\n *    @ return {number}\\n *    this.next = function() { // return the next number of the iterator\\n *       ...\\n *    }; \\n *\\n *    @return {boolean}\\n *    this.hasNext = function() { // return true if it still has numbers\\n *       ...\\n *    };\\n * };\\n */\\n\\n/**\\n * @param {Iterator} iterator\\n */\\nvar PeekingIterator = function(iterator) {\\n    //peeked works like a buffer \\n    this.peeked = null;\\n    this.iterator = iterator;\\n};\\n\\n/**\\n * @return {number}\\n */\\nPeekingIterator.prototype.peek = function() {\\n    if(this.peeked!==null){\\n        return this.peeked;\\n    }\\n    if(this.iterator.hasNext()!==false){\\n        this.peeked = this.iterator.next();\\n    }\\n    return this.peeked; \\n};\\n\\n/**\\n * @return {number}\\n */\\nPeekingIterator.prototype.next = function() {\\n    var val = \"\";\\n    if(this.peeked!==null){\\n        val = this.peeked;\\n        this.peeked = null;\\n        return val;\\n    }\\n    return this.iterator.next();\\n};\\n\\n/**\\n * @return {boolean}\\n */\\nPeekingIterator.prototype.hasNext = function() {\\n    if(this.peeked!==null){\\n        return true;\\n    }\\n    return this.iterator.hasNext();\\n};\\n\\n/** \\n * Your PeekingIterator object will be instantiated and called as such:\\n * var obj = new PeekingIterator(arr)\\n * var param_1 = obj.peek()\\n * var param_2 = obj.next()\\n * var param_3 = obj.hasNext()\\n */\\n ```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * // This is the Iterator\\'s API interface.\\n * // You should not implement it, or speculate about its implementation.\\n * function Iterator() {\\n *    @ return {number}\\n *    this.next = function() { // return the next number of the iterator\\n *       ...\\n *    }; \\n *\\n *    @return {boolean}\\n *    this.hasNext = function() { // return true if it still has numbers\\n *       ...\\n *    };\\n * };\\n */\\n\\n/**\\n * @param {Iterator} iterator\\n */\\nvar PeekingIterator = function(iterator) {\\n    //peeked works like a buffer \\n    this.peeked = null;\\n    this.iterator = iterator;\\n};\\n\\n/**\\n * @return {number}\\n */\\nPeekingIterator.prototype.peek = function() {\\n    if(this.peeked!==null){\\n        return this.peeked;\\n    }\\n    if(this.iterator.hasNext()!==false){\\n        this.peeked = this.iterator.next();\\n    }\\n    return this.peeked; \\n};\\n\\n/**\\n * @return {number}\\n */\\nPeekingIterator.prototype.next = function() {\\n    var val = \"\";\\n    if(this.peeked!==null){\\n        val = this.peeked;\\n        this.peeked = null;\\n        return val;\\n    }\\n    return this.iterator.next();\\n};\\n\\n/**\\n * @return {boolean}\\n */\\nPeekingIterator.prototype.hasNext = function() {\\n    if(this.peeked!==null){\\n        return true;\\n    }\\n    return this.iterator.hasNext();\\n};\\n\\n/** \\n * Your PeekingIterator object will be instantiated and called as such:\\n * var obj = new PeekingIterator(arr)\\n * var param_1 = obj.peek()\\n * var param_2 = obj.next()\\n * var param_3 = obj.hasNext()\\n */\\n ```",
                "codeTag": "Unknown"
            },
            {
                "id": 1980082,
                "title": "c-easy-solution-with-explanation",
                "content": "```\\n\\n// peek - if(movedNext) -> return  current \\n// peek - if(!movedNext) - moveNext and return current; set movedNext to true;\\n// hasNext - if(movedNext) - return true;\\n// hasNext - if(!movedNext) - moveNext, return true and set MoveNext to true;\\n// Next - if(movedNext) -set MoveNext to false and return current;\\n// Next - if(!movedNext) - setMoveNext to false,  moveNext and  return current;\\n\\nclass PeekingIterator {\\n    IEnumerator<int> _iterator;\\n    bool movedNext = false;\\n    \\n    // iterators refers to the first element of the array.\\n    public PeekingIterator(IEnumerator<int> iterator) \\n    {\\n       _iterator = iterator;\\n        movedNext = true;\\n    }\\n    \\n    // Returns the next element in the iteration without advancing the iterator.\\n    public int Peek() \\n    {\\n        if(movedNext)\\n            return _iterator.Current;\\n        \\n        movedNext = _iterator.MoveNext();\\n        return _iterator.Current;\\n    }\\n    \\n    // Returns the next element in the iteration and advances the iterator.\\n    public int Next() \\n    {        \\n      if(movedNext)\\n      {\\n          movedNext = false;\\n          return _iterator.Current;         \\n      }\\n        \\n     _iterator.MoveNext();\\n      movedNext = false;\\n      return _iterator.Current;       \\n    }\\n    \\n    // Returns false if the iterator is refering to the end of the array of true otherwise.\\n    public bool HasNext() \\n    {\\n         if(movedNext)\\n            return true;      \\n         movedNext = _iterator.MoveNext();\\n         return movedNext;\\t\\t       \\n    }\\n}",
                "solutionTags": [],
                "code": "```\\n\\n// peek - if(movedNext) -> return  current \\n// peek - if(!movedNext) - moveNext and return current; set movedNext to true;\\n// hasNext - if(movedNext) - return true;\\n// hasNext - if(!movedNext) - moveNext, return true and set MoveNext to true;\\n// Next - if(movedNext) -set MoveNext to false and return current;\\n// Next - if(!movedNext) - setMoveNext to false,  moveNext and  return current;\\n\\nclass PeekingIterator {\\n    IEnumerator<int> _iterator;\\n    bool movedNext = false;\\n    \\n    // iterators refers to the first element of the array.\\n    public PeekingIterator(IEnumerator<int> iterator) \\n    {\\n       _iterator = iterator;\\n        movedNext = true;\\n    }\\n    \\n    // Returns the next element in the iteration without advancing the iterator.\\n    public int Peek() \\n    {\\n        if(movedNext)\\n            return _iterator.Current;\\n        \\n        movedNext = _iterator.MoveNext();\\n        return _iterator.Current;\\n    }\\n    \\n    // Returns the next element in the iteration and advances the iterator.\\n    public int Next() \\n    {        \\n      if(movedNext)\\n      {\\n          movedNext = false;\\n          return _iterator.Current;         \\n      }\\n        \\n     _iterator.MoveNext();\\n      movedNext = false;\\n      return _iterator.Current;       \\n    }\\n    \\n    // Returns false if the iterator is refering to the end of the array of true otherwise.\\n    public bool HasNext() \\n    {\\n         if(movedNext)\\n            return true;      \\n         movedNext = _iterator.MoveNext();\\n         return movedNext;\\t\\t       \\n    }\\n}",
                "codeTag": "Java"
            },
            {
                "id": 1980059,
                "title": "go-clear-solution",
                "content": "```\\ntype PeekingIterator struct {\\n    oneStepAhead    *Iterator\\n    current         int\\n}\\n\\nfunc Constructor(iter *Iterator) *PeekingIterator {\\n    pi := &PeekingIterator{iter, 0} // 0 means no next value since: 1 <= nums[i] <= 1000\\n    if iter.hasNext() { pi.current = iter.next() }\\n    return pi\\n}\\n\\nfunc (this *PeekingIterator) hasNext() bool {\\n    return this.current != 0\\n}\\n\\nfunc (this *PeekingIterator) next() int {\\n    res := this.current\\n    if this.oneStepAhead.hasNext() { this.current = this.oneStepAhead.next() } else { this.current = 0 }\\n    return res\\n}\\n\\nfunc (this *PeekingIterator) peek() int {\\n    return this.current\\n}\\n```",
                "solutionTags": [
                    "Go"
                ],
                "code": "```\\ntype PeekingIterator struct {\\n    oneStepAhead    *Iterator\\n    current         int\\n}\\n\\nfunc Constructor(iter *Iterator) *PeekingIterator {\\n    pi := &PeekingIterator{iter, 0} // 0 means no next value since: 1 <= nums[i] <= 1000\\n    if iter.hasNext() { pi.current = iter.next() }\\n    return pi\\n}\\n\\nfunc (this *PeekingIterator) hasNext() bool {\\n    return this.current != 0\\n}\\n\\nfunc (this *PeekingIterator) next() int {\\n    res := this.current\\n    if this.oneStepAhead.hasNext() { this.current = this.oneStepAhead.next() } else { this.current = 0 }\\n    return res\\n}\\n\\nfunc (this *PeekingIterator) peek() int {\\n    return this.current\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1979916,
                "title": "python-easy-solution-double-beats-100-submit",
                "content": "```\\nclass PeekingIterator:\\n    def __init__(self, iterator):\\n        \"\"\"\\n        Initialize your data structure here.\\n        :type iterator: Iterator\\n        \"\"\"\\n        self.data = iterator.v\\n        self.index = -1\\n        \\n\\n    def peek(self):\\n        \"\"\"\\n        Returns the next element in the iteration without advancing the iterator.\\n        :rtype: int\\n        \"\"\"\\n        return self.data[self.index+1]\\n\\n    def next(self):\\n        \"\"\"\\n        :rtype: int\\n        \"\"\"\\n        self.index += 1\\n        return self.data[self.index]\\n\\n    def hasNext(self):\\n        \"\"\"\\n        :rtype: bool\\n        \"\"\"\\n        return True if self.index + 1 < len(self.data) else False\\n```",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nclass PeekingIterator:\\n    def __init__(self, iterator):\\n        \"\"\"\\n        Initialize your data structure here.\\n        :type iterator: Iterator\\n        \"\"\"\\n        self.data = iterator.v\\n        self.index = -1\\n        \\n\\n    def peek(self):\\n        \"\"\"\\n        Returns the next element in the iteration without advancing the iterator.\\n        :rtype: int\\n        \"\"\"\\n        return self.data[self.index+1]\\n\\n    def next(self):\\n        \"\"\"\\n        :rtype: int\\n        \"\"\"\\n        self.index += 1\\n        return self.data[self.index]\\n\\n    def hasNext(self):\\n        \"\"\"\\n        :rtype: bool\\n        \"\"\"\\n        return True if self.index + 1 < len(self.data) else False\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1979820,
                "title": "c-simple-solution-using-vector",
                "content": "```\\nclass PeekingIterator : public Iterator {\\npublic:\\n    vector<int> temp;\\n    int it = 0;\\n\\tPeekingIterator(const vector<int>& nums) : Iterator(nums) {\\n        for(int i : nums)\\n            temp.push_back(i);\\n\\t}\\n\\tint peek() {\\n            return temp[it];\\n\\t}\\n\\tint next() {\\n        int k = temp[it++];\\n        temp.pop_back();\\n        return k;\\n\\t}\\n\\t\\n\\tbool hasNext() const {\\n        if(temp.size())\\n            return true;\\n            \\n    return false;\\n\\t}\\n};",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass PeekingIterator : public Iterator {\\npublic:\\n    vector<int> temp;\\n    int it = 0;\\n\\tPeekingIterator(const vector<int>& nums) : Iterator(nums) {\\n        for(int i : nums)\\n            temp.push_back(i);\\n\\t}\\n\\tint peek() {\\n            return temp[it];\\n\\t}\\n\\tint next() {\\n        int k = temp[it++];\\n        temp.pop_back();\\n        return k;\\n\\t}\\n\\t\\n\\tbool hasNext() const {\\n        if(temp.size())\\n            return true;\\n            \\n    return false;\\n\\t}\\n};",
                "codeTag": "Java"
            },
            {
                "id": 1651714,
                "title": "java-simple-o-1-solution-100",
                "content": "```java\\n// Java Iterator interface reference:\\n// https://docs.oracle.com/javase/8/docs/api/java/util/Iterator.html\\n\\nclass PeekingIterator implements Iterator<Integer> {\\n    private Iterator<Integer> iterator;\\n    private Integer lastValue = null;\\n    \\n\\tpublic PeekingIterator(Iterator<Integer> iterator) {\\n\\t    // initialize any member here.\\n\\t    this.iterator = iterator;\\n        this.lastValue = iterator.next();\\n\\t}\\n\\t\\n    // Returns the next element in the iteration without advancing the iterator.\\n\\tpublic Integer peek() {\\n        return this.lastValue;\\n\\t}\\n\\t\\n\\t// hasNext() and next() should behave the same as in the Iterator interface.\\n\\t// Override them if needed.\\n\\t@Override\\n\\tpublic Integer next() {\\n\\t    Integer result = this.lastValue;\\n        if(this.iterator.hasNext())\\n            this.lastValue = this.iterator.next();\\n        else\\n            this.lastValue = null;\\n        return result;\\n\\t}\\n\\t\\n\\t@Override\\n\\tpublic boolean hasNext() {\\n\\t    return this.lastValue != null;\\n\\t}\\n}\\n```",
                "solutionTags": [],
                "code": "```java\\n// Java Iterator interface reference:\\n// https://docs.oracle.com/javase/8/docs/api/java/util/Iterator.html\\n\\nclass PeekingIterator implements Iterator<Integer> {\\n    private Iterator<Integer> iterator;\\n    private Integer lastValue = null;\\n    \\n\\tpublic PeekingIterator(Iterator<Integer> iterator) {\\n\\t    // initialize any member here.\\n\\t    this.iterator = iterator;\\n        this.lastValue = iterator.next();\\n\\t}\\n\\t\\n    // Returns the next element in the iteration without advancing the iterator.\\n\\tpublic Integer peek() {\\n        return this.lastValue;\\n\\t}\\n\\t\\n\\t// hasNext() and next() should behave the same as in the Iterator interface.\\n\\t// Override them if needed.\\n\\t@Override\\n\\tpublic Integer next() {\\n\\t    Integer result = this.lastValue;\\n        if(this.iterator.hasNext())\\n            this.lastValue = this.iterator.next();\\n        else\\n            this.lastValue = null;\\n        return result;\\n\\t}\\n\\t\\n\\t@Override\\n\\tpublic boolean hasNext() {\\n\\t    return this.lastValue != null;\\n\\t}\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1569292,
                "title": "c",
                "content": "```\\n/*\\n * Below is the interface for Iterator, which is already defined for you.\\n * **DO NOT** modify the interface for Iterator.\\n *\\n *  class Iterator {\\n *\\t\\tstruct Data;\\n * \\t\\tData* data;\\n *  public:\\n *\\t\\tIterator(const vector<int>& nums);\\n * \\t\\tIterator(const Iterator& iter);\\n *\\n * \\t\\t// Returns the next element in the iteration.\\n *\\t\\tint next();\\n *\\n *\\t\\t// Returns true if the iteration has more elements.\\n *\\t\\tbool hasNext() const;\\n *\\t};\\n */\\n\\nclass PeekingIterator : public Iterator {\\nprivate:\\n    int nextEle;\\npublic:\\n\\tPeekingIterator(const vector<int>& nums) : Iterator(nums) {\\n\\t    // Initialize any member here.\\n\\t    // **DO NOT** save a copy of nums and manipulate it directly.\\n\\t    // You should only use the Iterator interface methods.\\n        nextEle = -1;\\n        if (Iterator::hasNext()) {\\n            nextEle = Iterator::next();\\n        }\\n\\t}\\n\\t\\n    // Returns the next element in the iteration without advancing the iterator.\\n\\tint peek() {\\n        return nextEle;\\n\\t}\\n\\t\\n\\t// hasNext() and next() should behave the same as in the Iterator interface.\\n\\t// Override them if needed.\\n\\tint next() {\\n\\t    int oldNextEle = nextEle;\\n        nextEle = -1;\\n        if (Iterator::hasNext()) {\\n            nextEle = Iterator::next();\\n        }\\n        return oldNextEle;\\n\\t}\\n\\t\\n\\tbool hasNext() const {\\n\\t    return (nextEle != -1);\\n\\t}\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\n/*\\n * Below is the interface for Iterator, which is already defined for you.\\n * **DO NOT** modify the interface for Iterator.\\n *\\n *  class Iterator {\\n *\\t\\tstruct Data;\\n * \\t\\tData* data;\\n *  public:\\n *\\t\\tIterator(const vector<int>& nums);\\n * \\t\\tIterator(const Iterator& iter);\\n *\\n * \\t\\t// Returns the next element in the iteration.\\n *\\t\\tint next();\\n *\\n *\\t\\t// Returns true if the iteration has more elements.\\n *\\t\\tbool hasNext() const;\\n *\\t};\\n */\\n\\nclass PeekingIterator : public Iterator {\\nprivate:\\n    int nextEle;\\npublic:\\n\\tPeekingIterator(const vector<int>& nums) : Iterator(nums) {\\n\\t    // Initialize any member here.\\n\\t    // **DO NOT** save a copy of nums and manipulate it directly.\\n\\t    // You should only use the Iterator interface methods.\\n        nextEle = -1;\\n        if (Iterator::hasNext()) {\\n            nextEle = Iterator::next();\\n        }\\n\\t}\\n\\t\\n    // Returns the next element in the iteration without advancing the iterator.\\n\\tint peek() {\\n        return nextEle;\\n\\t}\\n\\t\\n\\t// hasNext() and next() should behave the same as in the Iterator interface.\\n\\t// Override them if needed.\\n\\tint next() {\\n\\t    int oldNextEle = nextEle;\\n        nextEle = -1;\\n        if (Iterator::hasNext()) {\\n            nextEle = Iterator::next();\\n        }\\n        return oldNextEle;\\n\\t}\\n\\t\\n\\tbool hasNext() const {\\n\\t    return (nextEle != -1);\\n\\t}\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1456665,
                "title": "c-no-cheating-using-the-previous-element",
                "content": "```\\nclass PeekingIterator : public Iterator {\\npublic:\\n    int prev;\\n    bool has;\\n\\tPeekingIterator(const vector<int>& nums) : Iterator(nums) {\\n        has = 1;\\n\\t    next();\\n\\t}\\n\\tint peek() {\\n        return prev;\\n\\t}\\n\\tint next() {\\n        int temp = prev;\\n\\t    if(Iterator::hasNext()==false)\\n            has = false;\\n        else\\n            prev = Iterator::next();\\n        return temp;\\n\\t}\\n\\tbool hasNext() const {\\n\\t    return has;\\n\\t}\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nclass PeekingIterator : public Iterator {\\npublic:\\n    int prev;\\n    bool has;\\n\\tPeekingIterator(const vector<int>& nums) : Iterator(nums) {\\n        has = 1;\\n\\t    next();\\n\\t}\\n\\tint peek() {\\n        return prev;\\n\\t}\\n\\tint next() {\\n        int temp = prev;\\n\\t    if(Iterator::hasNext()==false)\\n            has = false;\\n        else\\n            prev = Iterator::next();\\n        return temp;\\n\\t}\\n\\tbool hasNext() const {\\n\\t    return has;\\n\\t}\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1306891,
                "title": "java-easy-concise",
                "content": "**At first I think of Queue after looking to the question but after implementing and running this using queue i found that , we are only concerned of the next elements so why i\\'m storing each and every element and this can be done using a normal variable also**\\n```\\n// Java Iterator interface reference:\\n// https://docs.oracle.com/javase/8/docs/api/java/util/Iterator.html\\n\\nclass PeekingIterator implements Iterator<Integer> {\\n   Integer n = null;\\n   Iterator<Integer> it = null;\\n\\tpublic PeekingIterator(Iterator<Integer> iterator) {\\n\\t    // initialize any member here.\\n      it = iterator;\\n      if (it.hasNext()){\\n          n = it.next();\\n      }\\n\\t    \\n\\t}\\n\\t\\n    // Returns the next element in the iteration without advancing the iterator.\\n\\tpublic Integer peek() {\\n        return n;\\n\\t}\\n\\t\\n\\t// hasNext() and next() should behave the same as in the Iterator interface.\\n\\t// Override them if needed.\\n\\t@Override\\n\\tpublic Integer next() {\\n      Integer ans = n;\\n      \\n\\t    n = it.hasNext() ? it.next() : null;\\n      return ans;\\n\\t}\\n\\t\\n\\t@Override\\n\\tpublic boolean hasNext() {\\n\\t    return  n != null;\\n\\t}\\n}\\n```",
                "solutionTags": [],
                "code": "```\\n// Java Iterator interface reference:\\n// https://docs.oracle.com/javase/8/docs/api/java/util/Iterator.html\\n\\nclass PeekingIterator implements Iterator<Integer> {\\n   Integer n = null;\\n   Iterator<Integer> it = null;\\n\\tpublic PeekingIterator(Iterator<Integer> iterator) {\\n\\t    // initialize any member here.\\n      it = iterator;\\n      if (it.hasNext()){\\n          n = it.next();\\n      }\\n\\t    \\n\\t}\\n\\t\\n    // Returns the next element in the iteration without advancing the iterator.\\n\\tpublic Integer peek() {\\n        return n;\\n\\t}\\n\\t\\n\\t// hasNext() and next() should behave the same as in the Iterator interface.\\n\\t// Override them if needed.\\n\\t@Override\\n\\tpublic Integer next() {\\n      Integer ans = n;\\n      \\n\\t    n = it.hasNext() ? it.next() : null;\\n      return ans;\\n\\t}\\n\\t\\n\\t@Override\\n\\tpublic boolean hasNext() {\\n\\t    return  n != null;\\n\\t}\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1287859,
                "title": "c-cache-the-first-value-with-optional-int",
                "content": "This iterator copying is really not idiomatic. Just capture the first value in an optional\\\\<int> and then feed it outta there.\\n\\n```\\n#include <optional>\\nclass PeekingIterator : public Iterator {\\nprivate:\\n    optional<int> next_;\\npublic:\\n\\tPeekingIterator(const vector<int>& nums) : Iterator(nums) {\\n\\t    if (Iterator::hasNext()) {\\n            next_ = Iterator::next();\\n        }\\n\\t}\\n\\t\\n\\tint peek() const {\\n        return *next_;\\n\\t}\\n\\n\\tint next() {\\n\\t    auto ret = *next_;\\n        if (Iterator::hasNext()) {\\n            next_ = Iterator::next();\\n        } else {\\n            next_.reset();\\n        }\\n        return ret;\\n\\t}\\n\\t\\n\\tbool hasNext() const {\\n\\t    return next_.has_value();\\n\\t}\\n};\\n```",
                "solutionTags": [],
                "code": "```\\n#include <optional>\\nclass PeekingIterator : public Iterator {\\nprivate:\\n    optional<int> next_;\\npublic:\\n\\tPeekingIterator(const vector<int>& nums) : Iterator(nums) {\\n\\t    if (Iterator::hasNext()) {\\n            next_ = Iterator::next();\\n        }\\n\\t}\\n\\t\\n\\tint peek() const {\\n        return *next_;\\n\\t}\\n\\n\\tint next() {\\n\\t    auto ret = *next_;\\n        if (Iterator::hasNext()) {\\n            next_ = Iterator::next();\\n        } else {\\n            next_.reset();\\n        }\\n        return ret;\\n\\t}\\n\\t\\n\\tbool hasNext() const {\\n\\t    return next_.has_value();\\n\\t}\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 1220145,
                "title": "using-a-global-vector",
                "content": "```\\n/*\\n * Below is the interface for Iterator, which is already defined for you.\\n * **DO NOT** modify the interface for Iterator.\\n *\\n *  class Iterator {\\n *\\t\\tstruct Data;\\n * \\t\\tData* data;\\n *  public:\\n *\\t\\tIterator(const vector<int>& nums);\\n * \\t\\tIterator(const Iterator& iter);\\n *\\n * \\t\\t// Returns the next element in the iteration.\\n *\\t\\tint next();\\n *\\n *\\t\\t// Returns true if the iteration has more elements.\\n *\\t\\tbool hasNext() const;\\n *\\t};\\n */\\n\\nclass PeekingIterator : public Iterator {\\npublic:\\n    int size = 0;\\n    vector<int>result;\\n    int tot = 0;\\n\\tPeekingIterator(const vector<int>& nums) : Iterator(nums) {\\n\\t    // Initialize any member here.\\n\\t    // **DO NOT** save a copy of nums and manipulate it directly.\\n\\t    // You should only use the Iterator interface methods.\\n        result = nums;\\n        size = result.size();\\n\\t    \\n\\t}\\n\\t\\n    // Returns the next element in the iteration without advancing the iterator.\\n\\tint peek() {\\n        if(tot < size)\\n            return result[tot];\\n        return -1;\\n\\t}\\n\\t\\n\\t// hasNext() and next() should behave the same as in the Iterator interface.\\n\\t// Override them if needed.\\n\\tint next() {\\n\\t    return result[tot++];\\n\\t}\\n\\t\\n\\tbool hasNext() const {\\n\\t    if(tot<size)\\n            return true;\\n        return false;\\n\\t}\\n};\\n```",
                "solutionTags": [],
                "code": "```\\n/*\\n * Below is the interface for Iterator, which is already defined for you.\\n * **DO NOT** modify the interface for Iterator.\\n *\\n *  class Iterator {\\n *\\t\\tstruct Data;\\n * \\t\\tData* data;\\n *  public:\\n *\\t\\tIterator(const vector<int>& nums);\\n * \\t\\tIterator(const Iterator& iter);\\n *\\n * \\t\\t// Returns the next element in the iteration.\\n *\\t\\tint next();\\n *\\n *\\t\\t// Returns true if the iteration has more elements.\\n *\\t\\tbool hasNext() const;\\n *\\t};\\n */\\n\\nclass PeekingIterator : public Iterator {\\npublic:\\n    int size = 0;\\n    vector<int>result;\\n    int tot = 0;\\n\\tPeekingIterator(const vector<int>& nums) : Iterator(nums) {\\n\\t    // Initialize any member here.\\n\\t    // **DO NOT** save a copy of nums and manipulate it directly.\\n\\t    // You should only use the Iterator interface methods.\\n        result = nums;\\n        size = result.size();\\n\\t    \\n\\t}\\n\\t\\n    // Returns the next element in the iteration without advancing the iterator.\\n\\tint peek() {\\n        if(tot < size)\\n            return result[tot];\\n        return -1;\\n\\t}\\n\\t\\n\\t// hasNext() and next() should behave the same as in the Iterator interface.\\n\\t// Override them if needed.\\n\\tint next() {\\n\\t    return result[tot++];\\n\\t}\\n\\t\\n\\tbool hasNext() const {\\n\\t    if(tot<size)\\n            return true;\\n        return false;\\n\\t}\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1109615,
                "title": "java-100-100-without-extra-space-using-cache",
                "content": "```\\nclass PeekingIterator implements Iterator<Integer> {\\n    \\n    Iterator<Integer> iterator;\\n    int cached = 0;\\n    \\n\\tpublic PeekingIterator(Iterator<Integer> iterator) {\\n\\t    this.iterator = iterator;\\n\\t}\\n\\t\\n\\tpublic Integer peek() {\\n        if (cached == 0) {\\n            cached = iterator.next();\\n        }\\n        return cached;\\n\\t}\\n\\t\\n\\t@Override\\n\\tpublic Integer next() {\\n\\t    if (cached > 0) {\\n            int temp = cached;\\n            cached = 0;\\n            return temp;\\n        }\\n        return iterator.next();\\n\\t}\\n\\t\\n\\t@Override\\n\\tpublic boolean hasNext() {\\n\\t    if (cached > 0) {\\n            return true;\\n        }\\n        return iterator.hasNext();\\n\\t}\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass PeekingIterator implements Iterator<Integer> {\\n    \\n    Iterator<Integer> iterator;\\n    int cached = 0;\\n    \\n\\tpublic PeekingIterator(Iterator<Integer> iterator) {\\n\\t    this.iterator = iterator;\\n\\t}\\n\\t\\n\\tpublic Integer peek() {\\n        if (cached == 0) {\\n            cached = iterator.next();\\n        }\\n        return cached;\\n\\t}\\n\\t\\n\\t@Override\\n\\tpublic Integer next() {\\n\\t    if (cached > 0) {\\n            int temp = cached;\\n            cached = 0;\\n            return temp;\\n        }\\n        return iterator.next();\\n\\t}\\n\\t\\n\\t@Override\\n\\tpublic boolean hasNext() {\\n\\t    if (cached > 0) {\\n            return true;\\n        }\\n        return iterator.hasNext();\\n\\t}\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1057079,
                "title": "peeking-iterator-java-solution",
                "content": "```\\nclass PeekingIterator implements Iterator<Integer> {\\n    Iterator<Integer> iterator;\\n    int cache;\\n    boolean cached = false;\\n\\tpublic PeekingIterator(Iterator<Integer> iterator) {\\n\\t    this.iterator = iterator;\\n\\t    \\n\\t}\\n\\t\\n\\tpublic Integer peek() {\\n        if (!cached) {\\n            cache = iterator.next();\\n            cached = true;\\n        }\\n        return cache;\\n\\t}\\n\\t\\n\\t@Override\\n\\tpublic Integer next() {\\n\\t    if (cached) {\\n            cached = false;\\n            return cache;\\n        }\\n        return iterator.next();\\n\\t}\\n\\t\\n\\t@Override\\n\\tpublic boolean hasNext() {\\n\\t    return (iterator.hasNext() || cached);\\n\\t}\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass PeekingIterator implements Iterator<Integer> {\\n    Iterator<Integer> iterator;\\n    int cache;\\n    boolean cached = false;\\n\\tpublic PeekingIterator(Iterator<Integer> iterator) {\\n\\t    this.iterator = iterator;\\n\\t    \\n\\t}\\n\\t\\n\\tpublic Integer peek() {\\n        if (!cached) {\\n            cache = iterator.next();\\n            cached = true;\\n        }\\n        return cache;\\n\\t}\\n\\t\\n\\t@Override\\n\\tpublic Integer next() {\\n\\t    if (cached) {\\n            cached = false;\\n            return cache;\\n        }\\n        return iterator.next();\\n\\t}\\n\\t\\n\\t@Override\\n\\tpublic boolean hasNext() {\\n\\t    return (iterator.hasNext() || cached);\\n\\t}\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1056302,
                "title": "easy-to-understand-golang",
                "content": "```\\n// Peeking Iterator Struct\\n// Use peekElement to always store the next element beforehand . Whenever we need to return the next element, return peekElement and update the hasnext and peekElement after returning.\\ntype PeekingIterator struct {\\n    hasnext bool\\n    peekElement int\\n    iterator *Iterator\\n}\\n// Initializing the values \\nfunc Constructor(iter *Iterator) *PeekingIterator {\\n    return &PeekingIterator {\\n        hasnext : iter.hasNext(),\\n        peekElement : iter.next(),\\n        iterator : iter,\\n    }\\n}\\n\\nfunc (this *PeekingIterator) hasNext() bool {\\n    return this.hasnext\\n}\\n// returning the next value.\\nfunc (this *PeekingIterator) next() int {\\n    res := this.peekElement\\n    if this.iterator.hasNext() {\\n        this.peekElement = this.iterator.next()\\n    }else {\\n       this.hasnext = false\\n    }\\n    return res\\n}\\n\\nfunc (this *PeekingIterator) peek() int {\\n    return this.peekElement\\n}\\n```",
                "solutionTags": [
                    "Go"
                ],
                "code": "```\\n// Peeking Iterator Struct\\n// Use peekElement to always store the next element beforehand . Whenever we need to return the next element, return peekElement and update the hasnext and peekElement after returning.\\ntype PeekingIterator struct {\\n    hasnext bool\\n    peekElement int\\n    iterator *Iterator\\n}\\n// Initializing the values \\nfunc Constructor(iter *Iterator) *PeekingIterator {\\n    return &PeekingIterator {\\n        hasnext : iter.hasNext(),\\n        peekElement : iter.next(),\\n        iterator : iter,\\n    }\\n}\\n\\nfunc (this *PeekingIterator) hasNext() bool {\\n    return this.hasnext\\n}\\n// returning the next value.\\nfunc (this *PeekingIterator) next() int {\\n    res := this.peekElement\\n    if this.iterator.hasNext() {\\n        this.peekElement = this.iterator.next()\\n    }else {\\n       this.hasnext = false\\n    }\\n    return res\\n}\\n\\nfunc (this *PeekingIterator) peek() int {\\n    return this.peekElement\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1056209,
                "title": "one-liner-code-c-with-explanation",
                "content": "**Explanation of the given methods**. - \\n1. next( ) - It gives us the next element of the current position of the pointer. Also it increases the pointer position by 1.\\n2. hasNext( ) - A boolean function, which returns whether any element is present in the immediate next position. The pointer position remains unchanged.\\n3. peek( ) - gives us the next element, without changing the current position of the pointer.\\n\\n**Approach**:\\n1. Here *Iterator* is the position pointer, which initially points to beginning of the list. (as mentioned in problem statement).\\n2. To find peek( ) of the current position, we could have used the next( ) method, but it will increment the position of current pointer.\\n3.  in order to avoid that, we create a copy of the current iterator, and call next function upon that. This will give us the next position element value, without changing the position of the original iterator.\\n4.  We don\\'t need to separately define the next( ) and hasNext( ) function, as it is predefined within the class *Iterator*.\\n\\n\\n** **\\n\\n```\\n/*\\n * Below is the interface for Iterator, which is already defined for you.\\n * **DO NOT** modify the interface for Iterator.\\n *\\n *  class Iterator {\\n *\\t\\tstruct Data;\\n * \\t\\tData* data;\\n *\\t\\tIterator(const vector<int>& nums);\\n * \\t\\tIterator(const Iterator& iter);\\n *\\n * \\t\\t// Returns the next element in the iteration.\\n *\\t\\tint next();\\n *\\n *\\t\\t// Returns true if the iteration has more elements.\\n *\\t\\tbool hasNext() const;\\n *\\t};\\n */\\n\\nclass PeekingIterator : public Iterator {\\npublic:\\n\\tPeekingIterator(const vector<int>& nums) : Iterator(nums) {\\n\\t    // Initialize any member here.\\n\\t    // **DO NOT** save a copy of nums and manipulate it directly.\\n\\t    // You should only use the Iterator interface methods.\\n\\t    \\n\\t}\\n\\t\\n    // Returns the next element in the iteration without advancing the iterator.\\n\\tint peek() \\n    {\\n        return Iterator(*this).next();\\n    }\\n\\t\\n\\t\\n};\\n```",
                "solutionTags": [],
                "code": "```\\n/*\\n * Below is the interface for Iterator, which is already defined for you.\\n * **DO NOT** modify the interface for Iterator.\\n *\\n *  class Iterator {\\n *\\t\\tstruct Data;\\n * \\t\\tData* data;\\n *\\t\\tIterator(const vector<int>& nums);\\n * \\t\\tIterator(const Iterator& iter);\\n *\\n * \\t\\t// Returns the next element in the iteration.\\n *\\t\\tint next();\\n *\\n *\\t\\t// Returns true if the iteration has more elements.\\n *\\t\\tbool hasNext() const;\\n *\\t};\\n */\\n\\nclass PeekingIterator : public Iterator {\\npublic:\\n\\tPeekingIterator(const vector<int>& nums) : Iterator(nums) {\\n\\t    // Initialize any member here.\\n\\t    // **DO NOT** save a copy of nums and manipulate it directly.\\n\\t    // You should only use the Iterator interface methods.\\n\\t    \\n\\t}\\n\\t\\n    // Returns the next element in the iteration without advancing the iterator.\\n\\tint peek() \\n    {\\n        return Iterator(*this).next();\\n    }\\n\\t\\n\\t\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1056060,
                "title": "c-solution-very-simple",
                "content": "```\\nclass PeekingIterator : public Iterator {\\npublic:\\n\\tPeekingIterator(const vector<int>& nums) : Iterator(nums) \\n    {\\n\\t    doPeek = false;\\n\\t}\\n\\t\\n\\tint peek() \\n\\t{\\n        if(!doPeek)\\n        {\\n            if(Iterator::hasNext())\\n            {\\n                peekElement = Iterator::next();\\n                doPeek = true;\\n            }\\n        }\\n        return peekElement;\\n\\t}\\n\\t\\n\\tint next() \\n\\t{\\n\\t    if(doPeek)\\n        {\\n            doPeek = false;\\n            return peekElement;\\n        }\\n            \\n        return Iterator::next();\\n\\t}\\n\\t\\n\\tbool hasNext() const \\n    {\\n        if(doPeek)\\n            return true;\\n        \\n\\t    return Iterator::hasNext();\\n\\t}\\n    \\nprivate:\\n    bool doPeek;\\n    int peekElement;\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass PeekingIterator : public Iterator {\\npublic:\\n\\tPeekingIterator(const vector<int>& nums) : Iterator(nums) \\n    {\\n\\t    doPeek = false;\\n\\t}\\n\\t\\n\\tint peek() \\n\\t{\\n        if(!doPeek)\\n        {\\n            if(Iterator::hasNext())\\n            {\\n                peekElement = Iterator::next();\\n                doPeek = true;\\n            }\\n        }\\n        return peekElement;\\n\\t}\\n\\t\\n\\tint next() \\n\\t{\\n\\t    if(doPeek)\\n        {\\n            doPeek = false;\\n            return peekElement;\\n        }\\n            \\n        return Iterator::next();\\n\\t}\\n\\t\\n\\tbool hasNext() const \\n    {\\n        if(doPeek)\\n            return true;\\n        \\n\\t    return Iterator::hasNext();\\n\\t}\\n    \\nprivate:\\n    bool doPeek;\\n    int peekElement;\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1056031,
                "title": "scala-generic-solution",
                "content": "```scala\\nclass GenPeekingIterator[A](iterator: Iterator[A]) {\\n    var peeked: Option[A]  = None\\n    \\n    def peek(): A = peeked.getOrElse {\\n        val res = iterator.next()\\n        peeked = Some(res)\\n        res          \\n    }\\n    \\n    def next(): A = peeked.fold(iterator.next){ x => \\n        peeked = None\\n        x\\n    }\\n    \\n    def hasNext(): Boolean = peeked.nonEmpty || iterator.hasNext\\n}\\n\\nclass PeekingIterator(it: Iterator[Int]) extends GenPeekingIterator[Int](it)\\n```",
                "solutionTags": [],
                "code": "```scala\\nclass GenPeekingIterator[A](iterator: Iterator[A]) {\\n    var peeked: Option[A]  = None\\n    \\n    def peek(): A = peeked.getOrElse {\\n        val res = iterator.next()\\n        peeked = Some(res)\\n        res          \\n    }\\n    \\n    def next(): A = peeked.fold(iterator.next){ x => \\n        peeked = None\\n        x\\n    }\\n    \\n    def hasNext(): Boolean = peeked.nonEmpty || iterator.hasNext\\n}\\n\\nclass PeekingIterator(it: Iterator[Int]) extends GenPeekingIterator[Int](it)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1056007,
                "title": "97-67-faster",
                "content": "![image](https://assets.leetcode.com/users/images/ab373001-05e9-4842-bc6d-01789eb992ae_1612784766.1963801.png)\\n# LeetCode has called MoveNext() before passing the iterator to constructor in C# \\nCorrect implementation is => https://github.com/harsh007kumar/My_PracticeProblemAndProblemSolving/commit/4b925a5f93d7cc5fe1141063287418f1a408d672\\n```\\n// C# IEnumerator interface reference:\\n// https://docs.microsoft.com/en-us/dotnet/api/system.collections.ienumerator?view=netframework-4.8\\n\\nclass PeekingIterator {\\n    bool hasNext = false;\\n    private readonly IEnumerator<int> it;\\n\\n    // iterators refers to the first element of the array.\\n    public PeekingIterator(IEnumerator<int> iterator)\\n    {\\n        it = iterator;\\n        hasNext = true;\\n    }\\n\\n    // Returns the next element in the iteration without advancing the iterator.\\n    public int Peek() => it.Current;\\n\\n    // Returns the next element in the iteration and advances the iterator.\\n    public int Next()\\n    {\\n        int ans = it.Current;\\n        hasNext = it.MoveNext();\\n        return ans;\\n    }\\n\\n    // Returns false if the iterator is refering to the end of the array else return true otherwise.\\n    public bool HasNext() => hasNext;\\n}\\n```",
                "solutionTags": [],
                "code": "```\\n// C# IEnumerator interface reference:\\n// https://docs.microsoft.com/en-us/dotnet/api/system.collections.ienumerator?view=netframework-4.8\\n\\nclass PeekingIterator {\\n    bool hasNext = false;\\n    private readonly IEnumerator<int> it;\\n\\n    // iterators refers to the first element of the array.\\n    public PeekingIterator(IEnumerator<int> iterator)\\n    {\\n        it = iterator;\\n        hasNext = true;\\n    }\\n\\n    // Returns the next element in the iteration without advancing the iterator.\\n    public int Peek() => it.Current;\\n\\n    // Returns the next element in the iteration and advances the iterator.\\n    public int Next()\\n    {\\n        int ans = it.Current;\\n        hasNext = it.MoveNext();\\n        return ans;\\n    }\\n\\n    // Returns false if the iterator is refering to the end of the array else return true otherwise.\\n    public bool HasNext() => hasNext;\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1055955,
                "title": "python-by-looking-ahead-w-hint",
                "content": "\\nHint:\\n\\nPre-store and peek the next one element by **looking-ahead**.\\n\\nRemember that we can use hasNext() and next() offered by class Iterator\\n\\n---\\n\\n**Implementation**:\\n\\n```\\n# Below is the interface for Iterator, which is already defined for you.\\n#\\n# class Iterator:\\n#     def __init__(self, nums):\\n#         \"\"\"\\n#         Initializes an iterator object to the beginning of a list.\\n#         :type nums: List[int]\\n#         \"\"\"\\n#\\n#     def hasNext(self):\\n#         \"\"\"\\n#         Returns true if the iteration has more elements.\\n#         :rtype: bool\\n#         \"\"\"\\n#\\n#     def next(self):\\n#         \"\"\"\\n#         Returns the next element in the iteration.\\n#         :rtype: int\\n#         \"\"\"\\n\\nclass PeekingIterator:\\n    def __init__(self, iterator):\\n        \"\"\"\\n        Initialize your data structure here.\\n        :type iterator: Iterator\\n        \"\"\"\\n        \\n        self.iterator = iterator\\n        \\n        # pre-store next one element by looking ahead\\n        if self.iterator.hasNext():\\n\\t\\t\\t# still have next element\\n            self.next_one = self.iterator.next()\\n        else:\\n\\t\\t\\t# meet the end\\n            self.next_one = None\\n\\n\\n    def peek(self):\\n        \"\"\"\\n        Returns the next element in the iteration without advancing the iterator.\\n        :rtype: int\\n        \"\"\"\\n        \\n        # return the pre-stored element\\n        return self.next_one\\n        \\n\\n    def next(self):\\n        \"\"\"\\n        :rtype: int\\n        \"\"\"\\n        \\n        # backup original pre-stored element\\n        target = self.next_one\\n        \\n        # keep getting next one element\\n        if self.iterator.hasNext():\\n            self.next_one = self.iterator.next()\\n        else:\\n            self.next_one = None\\n        \\n        return target\\n        \\n        \\n\\n    def hasNext(self):\\n        \"\"\"\\n        :rtype: bool\\n        \"\"\"\\n        \\n        # judge by the existence of pre-stored element\\n        if self.next_one:\\n            return True\\n        \\n        else:\\n            return False\\n\\n# Your PeekingIterator object will be instantiated and called as such:\\n# iter = PeekingIterator(Iterator(nums))\\n# while iter.hasNext():\\n#     val = iter.peek()   # Get the next element but not advance the iterator.\\n#     iter.next()         # Should return the same value as [val].\\n```",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\n# Below is the interface for Iterator, which is already defined for you.\\n#\\n# class Iterator:\\n#     def __init__(self, nums):\\n#         \"\"\"\\n#         Initializes an iterator object to the beginning of a list.\\n#         :type nums: List[int]\\n#         \"\"\"\\n#\\n#     def hasNext(self):\\n#         \"\"\"\\n#         Returns true if the iteration has more elements.\\n#         :rtype: bool\\n#         \"\"\"\\n#\\n#     def next(self):\\n#         \"\"\"\\n#         Returns the next element in the iteration.\\n#         :rtype: int\\n#         \"\"\"\\n\\nclass PeekingIterator:\\n    def __init__(self, iterator):\\n        \"\"\"\\n        Initialize your data structure here.\\n        :type iterator: Iterator\\n        \"\"\"\\n        \\n        self.iterator = iterator\\n        \\n        # pre-store next one element by looking ahead\\n        if self.iterator.hasNext():\\n\\t\\t\\t# still have next element\\n            self.next_one = self.iterator.next()\\n        else:\\n\\t\\t\\t# meet the end\\n            self.next_one = None\\n\\n\\n    def peek(self):\\n        \"\"\"\\n        Returns the next element in the iteration without advancing the iterator.\\n        :rtype: int\\n        \"\"\"\\n        \\n        # return the pre-stored element\\n        return self.next_one\\n        \\n\\n    def next(self):\\n        \"\"\"\\n        :rtype: int\\n        \"\"\"\\n        \\n        # backup original pre-stored element\\n        target = self.next_one\\n        \\n        # keep getting next one element\\n        if self.iterator.hasNext():\\n            self.next_one = self.iterator.next()\\n        else:\\n            self.next_one = None\\n        \\n        return target\\n        \\n        \\n\\n    def hasNext(self):\\n        \"\"\"\\n        :rtype: bool\\n        \"\"\"\\n        \\n        # judge by the existence of pre-stored element\\n        if self.next_one:\\n            return True\\n        \\n        else:\\n            return False\\n\\n# Your PeekingIterator object will be instantiated and called as such:\\n# iter = PeekingIterator(Iterator(nums))\\n# while iter.hasNext():\\n#     val = iter.peek()   # Get the next element but not advance the iterator.\\n#     iter.next()         # Should return the same value as [val].\\n```",
                "codeTag": "Java"
            },
            {
                "id": 996966,
                "title": "java-clean-and-efficient-solution",
                "content": "```\\nclass PeekingIterator implements Iterator<Integer> {\\n    \\n    private Integer next;\\n    private Iterator<Integer> iterator;\\n    \\n\\tpublic PeekingIterator(Iterator<Integer> iterator) {\\n\\t    // initialize any member here.\\n\\t    this.iterator = iterator;\\n        \\n        if (iterator.hasNext())\\n            next = iterator.next();\\n\\t}\\n\\t\\n    // Returns the next element in the iteration without advancing the iterator.\\n\\tpublic Integer peek() {\\n        return next;\\n\\t}\\n\\t\\n\\t// hasNext() and next() should behave the same as in the Iterator interface.\\n\\t// Override them if needed.\\n\\t@Override\\n\\tpublic Integer next() {\\n\\t    var elem = next;\\n        \\n        next = iterator.hasNext()? iterator.next(): null;\\n        \\n        return elem;\\n\\t}\\n\\t\\n\\t@Override\\n\\tpublic boolean hasNext() {\\n\\t    return next != null;\\n\\t}\\n```",
                "solutionTags": [],
                "code": "```\\nclass PeekingIterator implements Iterator<Integer> {\\n    \\n    private Integer next;\\n    private Iterator<Integer> iterator;\\n    \\n\\tpublic PeekingIterator(Iterator<Integer> iterator) {\\n\\t    // initialize any member here.\\n\\t    this.iterator = iterator;\\n        \\n        if (iterator.hasNext())\\n            next = iterator.next();\\n\\t}\\n\\t\\n    // Returns the next element in the iteration without advancing the iterator.\\n\\tpublic Integer peek() {\\n        return next;\\n\\t}\\n\\t\\n\\t// hasNext() and next() should behave the same as in the Iterator interface.\\n\\t// Override them if needed.\\n\\t@Override\\n\\tpublic Integer next() {\\n\\t    var elem = next;\\n        \\n        next = iterator.hasNext()? iterator.next(): null;\\n        \\n        return elem;\\n\\t}\\n\\t\\n\\t@Override\\n\\tpublic boolean hasNext() {\\n\\t    return next != null;\\n\\t}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 987819,
                "title": "java-solution-memory-efficient-fast",
                "content": "```\\n// Java Iterator interface reference:\\n// https://docs.oracle.com/javase/8/docs/api/java/util/Iterator.html\\n\\nclass PeekingIterator implements Iterator<Integer> {\\n    Iterator<Integer> iter;\\n    Integer cur;\\n    \\n\\tpublic PeekingIterator(Iterator<Integer> iterator) {\\n\\t    // initialize any member here.\\n        iter = iterator;\\n\\t    cur = iter.hasNext() ? iter.next() : null;\\n\\t}\\n\\t\\n    // Returns the next element in the iteration without advancing the iterator.\\n\\tpublic Integer peek() {\\n        return cur;\\n\\t}\\n\\t\\n\\t// hasNext() and next() should behave the same as in the Iterator interface.\\n\\t// Override them if needed.\\n\\t@Override\\n\\tpublic Integer next() {\\n        int temp = cur;\\n        if (iter.hasNext())\\n            cur = iter.next();\\n        else\\n            cur = null;\\n        return temp;\\n\\t}\\n\\t\\n\\t@Override\\n\\tpublic boolean hasNext() {\\n\\t    return cur == null ? false : true;\\n\\t}\\n}\\n```",
                "solutionTags": [],
                "code": "```\\n// Java Iterator interface reference:\\n// https://docs.oracle.com/javase/8/docs/api/java/util/Iterator.html\\n\\nclass PeekingIterator implements Iterator<Integer> {\\n    Iterator<Integer> iter;\\n    Integer cur;\\n    \\n\\tpublic PeekingIterator(Iterator<Integer> iterator) {\\n\\t    // initialize any member here.\\n        iter = iterator;\\n\\t    cur = iter.hasNext() ? iter.next() : null;\\n\\t}\\n\\t\\n    // Returns the next element in the iteration without advancing the iterator.\\n\\tpublic Integer peek() {\\n        return cur;\\n\\t}\\n\\t\\n\\t// hasNext() and next() should behave the same as in the Iterator interface.\\n\\t// Override them if needed.\\n\\t@Override\\n\\tpublic Integer next() {\\n        int temp = cur;\\n        if (iter.hasNext())\\n            cur = iter.next();\\n        else\\n            cur = null;\\n        return temp;\\n\\t}\\n\\t\\n\\t@Override\\n\\tpublic boolean hasNext() {\\n\\t    return cur == null ? false : true;\\n\\t}\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 848905,
                "title": "python-3-clean-cache-solution-explanations",
                "content": "### Explanation\\n- `peek` will need to get the information of next value, but once `next` is called, iterator can\\'t go back;\\n\\t- thus what we need to do is that even if we call `peek`, the `next` should still be valid and return correct response\\n- How to solve this issue? Simply save value in `cache`, and if `cache` is not empty, return `cache` instead of calling `next` from `iterator`\\n### Implementation\\n```\\nclass PeekingIterator:\\n    def __init__(self, iterator):\\n        self._iterator = iterator\\n        self.cache = None\\n        \\n    def peek(self):\\n        if self.cache is None: self.cache = self._iterator.next()\\n        return self.cache\\n\\n    def next(self):\\n        if self.cache is not None: \\n            val, self.cache = self.cache, None\\n            return val\\n        else: return self._iterator.next()\\n        \\n    def hasNext(self):\\n        return self._iterator.hasNext() or self.cache is not None\\n```",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Design"
                ],
                "code": "```\\nclass PeekingIterator:\\n    def __init__(self, iterator):\\n        self._iterator = iterator\\n        self.cache = None\\n        \\n    def peek(self):\\n        if self.cache is None: self.cache = self._iterator.next()\\n        return self.cache\\n\\n    def next(self):\\n        if self.cache is not None: \\n            val, self.cache = self.cache, None\\n            return val\\n        else: return self._iterator.next()\\n        \\n    def hasNext(self):\\n        return self._iterator.hasNext() or self.cache is not None\\n```",
                "codeTag": "Java"
            },
            {
                "id": 826134,
                "title": "c-one-liner-o-1-accepted-beats-92",
                "content": "Hey, why all the trouble with storing a snapshot of the next value? Iterator is supposed to follow pointer semantic, after all. It shouldn\\'t *hold* values, it should only *point* to values...\\n\\nImagine the pointed value has changed between calls to ```peek()``` and ```next()```. A caching iterator would simply return the wrong (obsolete) value.\\n\\nIterator base class is copyable -- so use it:\\n\\n```\\nclass PeekingIterator : public Iterator\\n{\\npublic:\\n    using Iterator::Iterator;\\n    \\n\\tint peek()\\n\\t{\\n        return Iterator(*this).next();\\n\\t}\\n};\\n```",
                "solutionTags": [],
                "code": "```peek()```\n```next()```\n```\\nclass PeekingIterator : public Iterator\\n{\\npublic:\\n    using Iterator::Iterator;\\n    \\n\\tint peek()\\n\\t{\\n        return Iterator(*this).next();\\n\\t}\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 730879,
                "title": "javascript-64ms",
                "content": "```\\n/**\\n * // This is the Iterator\\'s API interface.\\n * // You should not implement it, or speculate about its implementation.\\n * function Iterator() {\\n *    @ return {number}\\n *    this.next = function() { // return the next number of the iterator\\n *       ...\\n *    }; \\n *\\n *    @return {boolean}\\n *    this.hasNext = function() { // return true if it still has numbers\\n *       ...\\n *    };\\n * };\\n */\\n\\n/**\\n * @param {Iterator} iterator\\n */\\nvar PeekingIterator = function(iterator) {\\n        this.nextVal = null; \\n        this.iterator = iterator;\\n        if (this.iterator.hasNext())\\n            this.nextVal = iterator.next();\\n};\\n\\n/**\\n * @return {number}\\n */\\nPeekingIterator.prototype.peek = function() {\\n// return stored next\\n    return this.nextVal;\\n};\\n\\n/**\\n * @return {number}\\n */\\nPeekingIterator.prototype.next = function() {\\nreturn next\\n    let curr = this.nextVal;\\n\\t// store next\\'s next,\\n    this.nextVal = this.iterator.hasNext() ? this.iterator.next() : null;\\n    return curr;\\n};\\n\\n/**\\n * @return {boolean}\\n */\\nPeekingIterator.prototype.hasNext = function() {\\n    return this.nextVal != null;\\n};\\n\\n/** \\n * Your PeekingIterator object will be instantiated and called as such:\\n * var obj = new PeekingIterator(arr)\\n * var param_1 = obj.peek()\\n * var param_2 = obj.next()\\n * var param_3 = obj.hasNext()\\n */\\n```",
                "solutionTags": [],
                "code": "```\\n/**\\n * // This is the Iterator\\'s API interface.\\n * // You should not implement it, or speculate about its implementation.\\n * function Iterator() {\\n *    @ return {number}\\n *    this.next = function() { // return the next number of the iterator\\n *       ...\\n *    }; \\n *\\n *    @return {boolean}\\n *    this.hasNext = function() { // return true if it still has numbers\\n *       ...\\n *    };\\n * };\\n */\\n\\n/**\\n * @param {Iterator} iterator\\n */\\nvar PeekingIterator = function(iterator) {\\n        this.nextVal = null; \\n        this.iterator = iterator;\\n        if (this.iterator.hasNext())\\n            this.nextVal = iterator.next();\\n};\\n\\n/**\\n * @return {number}\\n */\\nPeekingIterator.prototype.peek = function() {\\n// return stored next\\n    return this.nextVal;\\n};\\n\\n/**\\n * @return {number}\\n */\\nPeekingIterator.prototype.next = function() {\\nreturn next\\n    let curr = this.nextVal;\\n\\t// store next\\'s next,\\n    this.nextVal = this.iterator.hasNext() ? this.iterator.next() : null;\\n    return curr;\\n};\\n\\n/**\\n * @return {boolean}\\n */\\nPeekingIterator.prototype.hasNext = function() {\\n    return this.nextVal != null;\\n};\\n\\n/** \\n * Your PeekingIterator object will be instantiated and called as such:\\n * var obj = new PeekingIterator(arr)\\n * var param_1 = obj.peek()\\n * var param_2 = obj.next()\\n * var param_3 = obj.hasNext()\\n */\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 676129,
                "title": "c-solution",
                "content": "```\\nclass PeekingIterator : public Iterator {\\n    int pk;\\n    bool hn;\\npublic:\\n    PeekingIterator(const vector<int>& nums) : Iterator(nums) {\\n        hn = Iterator::hasNext();    \\n        pk = Iterator::next();    \\n    }\\n\\tint peek() {\\n        return pk;                        \\n\\t}\\n\\tint next() {\\n        int ans = pk;\\n        hn = Iterator::hasNext();    \\n        if(hn) pk = Iterator::next();\\n\\t    return ans;\\n    }\\n\\tbool hasNext() const {\\n\\t    return hn;\\n\\t}\\n};\\n```\\n",
                "solutionTags": [],
                "code": "```\\nclass PeekingIterator : public Iterator {\\n    int pk;\\n    bool hn;\\npublic:\\n    PeekingIterator(const vector<int>& nums) : Iterator(nums) {\\n        hn = Iterator::hasNext();    \\n        pk = Iterator::next();    \\n    }\\n\\tint peek() {\\n        return pk;                        \\n\\t}\\n\\tint next() {\\n        int ans = pk;\\n        hn = Iterator::hasNext();    \\n        if(hn) pk = Iterator::next();\\n\\t    return ans;\\n    }\\n\\tbool hasNext() const {\\n\\t    return hn;\\n\\t}\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 433887,
                "title": "simple-python-solution",
                "content": "```\\nclass PeekingIterator:\\n    def __init__(self, iterator):\\n        self.iter = iterator\\n        self.cur = self.iter.next() if self.iter.hasNext() else None\\n\\n    def peek(self):\\n        return self.cur\\n        \\n    def next(self):\\n        tmp = self.cur\\n        self.cur = self.iter.next() if self.iter.hasNext() else None\\n        return tmp\\n\\n    def hasNext(self):\\n        return self.cur != None\\n```",
                "solutionTags": [],
                "code": "```\\nclass PeekingIterator:\\n    def __init__(self, iterator):\\n        self.iter = iterator\\n        self.cur = self.iter.next() if self.iter.hasNext() else None\\n\\n    def peek(self):\\n        return self.cur\\n        \\n    def next(self):\\n        tmp = self.cur\\n        self.cur = self.iter.next() if self.iter.hasNext() else None\\n        return tmp\\n\\n    def hasNext(self):\\n        return self.cur != None\\n```",
                "codeTag": "Java"
            },
            {
                "id": 340880,
                "title": "different-python-solutions",
                "content": "Solution 1:\\n```\\nclass PeekingIterator:\\n    def __init__(self, iterator):\\n        self.iterator = iterator\\n        self.cache = []\\n\\n    def peek(self):\\n        if not self.cache:\\n            self.cache = [self.iterator.next()]\\n            return self.cache[0]\\n        else:\\n            return self.cache[0]\\n\\n    def next(self):\\n        if not self.cache:\\n            return self.iterator.next()\\n        else:\\n            result = self.cache[0]\\n            self.cache = []\\n            return result\\n\\n    def hasNext(self):\\n        return (self.cache != []) or self.iterator.hasNext()\\n```\\n\\nSolution 2:\\n```\\nclass PeekingIterator:\\n    def __init__(self, iterator):\\n        self.iterator = iterator\\n        self.next_element = None\\n        if self.iterator.hasNext():\\n            self.next_element = self.iterator.next()\\n\\n    def peek(self):\\n        return self.next_element\\n\\n    def next(self):\\n        result = self.next_element\\n        self.next_element = None\\n        if self.iterator.hasNext():\\n            self.next_element = self.iterator.next()\\n        return result  \\n\\n    def hasNext(self):\\n        return self.next_element != None\\n```",
                "solutionTags": [],
                "code": "```\\nclass PeekingIterator:\\n    def __init__(self, iterator):\\n        self.iterator = iterator\\n        self.cache = []\\n\\n    def peek(self):\\n        if not self.cache:\\n            self.cache = [self.iterator.next()]\\n            return self.cache[0]\\n        else:\\n            return self.cache[0]\\n\\n    def next(self):\\n        if not self.cache:\\n            return self.iterator.next()\\n        else:\\n            result = self.cache[0]\\n            self.cache = []\\n            return result\\n\\n    def hasNext(self):\\n        return (self.cache != []) or self.iterator.hasNext()\\n```\n```\\nclass PeekingIterator:\\n    def __init__(self, iterator):\\n        self.iterator = iterator\\n        self.next_element = None\\n        if self.iterator.hasNext():\\n            self.next_element = self.iterator.next()\\n\\n    def peek(self):\\n        return self.next_element\\n\\n    def next(self):\\n        result = self.next_element\\n        self.next_element = None\\n        if self.iterator.hasNext():\\n            self.next_element = self.iterator.next()\\n        return result  \\n\\n    def hasNext(self):\\n        return self.next_element != None\\n```",
                "codeTag": "Java"
            },
            {
                "id": 230892,
                "title": "simple-o-1-java-solution-beats-99",
                "content": "Idea is simple. Just store next element in advance in a variable and return it in peek() and next();\\n\\n```\\nclass PeekingIterator implements Iterator<Integer> {\\n    Integer nextVal = null;\\n    Iterator<Integer> iterator;\\n\\n\\tpublic PeekingIterator(Iterator<Integer> iterator) {\\n        this.iterator = iterator;\\n        if (this.iterator.hasNext())\\n\\t        nextVal = this.iterator.next();\\n\\t}\\n\\n    // Returns the next element in the iteration without advancing the iterator.\\n\\tpublic Integer peek() {\\n        return nextVal;\\n\\t}\\n\\n\\t// hasNext() and next() should behave the same as in the Iterator interface.\\n\\t// Override them if needed.\\n\\t@Override\\n\\tpublic Integer next() {        \\n\\t    int val = nextVal;\\n        nextVal = (iterator.hasNext()) ? iterator.next() : null;\\n        return val;\\n\\t}\\n\\n\\t@Override\\n\\tpublic boolean hasNext() {\\n\\t    return nextVal != null;\\n\\t}\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass PeekingIterator implements Iterator<Integer> {\\n    Integer nextVal = null;\\n    Iterator<Integer> iterator;\\n\\n\\tpublic PeekingIterator(Iterator<Integer> iterator) {\\n        this.iterator = iterator;\\n        if (this.iterator.hasNext())\\n\\t        nextVal = this.iterator.next();\\n\\t}\\n\\n    // Returns the next element in the iteration without advancing the iterator.\\n\\tpublic Integer peek() {\\n        return nextVal;\\n\\t}\\n\\n\\t// hasNext() and next() should behave the same as in the Iterator interface.\\n\\t// Override them if needed.\\n\\t@Override\\n\\tpublic Integer next() {        \\n\\t    int val = nextVal;\\n        nextVal = (iterator.hasNext()) ? iterator.next() : null;\\n        return val;\\n\\t}\\n\\n\\t@Override\\n\\tpublic boolean hasNext() {\\n\\t    return nextVal != null;\\n\\t}\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 185297,
                "title": "simple-python-solution-beats-99-66",
                "content": "class PeekingIterator:\\n\\n    def __init__(self, iterator):\\n        \"\"\"\\n        Initialize your data structure here.\\n        :type iterator: Iterator\\n        \"\"\"\\n        self.q = None\\n        self.it = iterator\\n        \\n\\n    def peek(self):\\n        \"\"\"\\n        Returns the next element in the iteration without advancing the iterator.\\n        :rtype: int\\n        \"\"\"\\n        if self.q == None:\\n             self.q = self.it.next()\\n        return self.q        \\n            \\n        \\n\\n    def next(self):\\n        \"\"\"\\n        :rtype: int\\n        \"\"\"\\n        if self.q:\\n            val = self.q\\n            self.q = None\\n            return val\\n        else:\\n            return self.it.next()\\n        \\n\\n    def hasNext(self):\\n        \"\"\"\\n        :rtype: bool\\n        \"\"\"\\n        if self.q:\\n            return True\\n        return self.it.hasNext()",
                "solutionTags": [],
                "code": "class PeekingIterator:\\n\\n    def __init__(self, iterator):\\n        \"\"\"\\n        Initialize your data structure here.\\n        :type iterator: Iterator\\n        \"\"\"\\n        self.q = None\\n        self.it = iterator\\n        \\n\\n    def peek(self):\\n        \"\"\"\\n        Returns the next element in the iteration without advancing the iterator.\\n        :rtype: int\\n        \"\"\"\\n        if self.q == None:\\n             self.q = self.it.next()\\n        return self.q        \\n            \\n        \\n\\n    def next(self):\\n        \"\"\"\\n        :rtype: int\\n        \"\"\"\\n        if self.q:\\n            val = self.q\\n            self.q = None\\n            return val\\n        else:\\n            return self.it.next()\\n        \\n\\n    def hasNext(self):\\n        \"\"\"\\n        :rtype: bool\\n        \"\"\"\\n        if self.q:\\n            return True\\n        return self.it.hasNext()",
                "codeTag": "Java"
            },
            {
                "id": 159624,
                "title": "short-java-solution",
                "content": "Just store a reference of next()\\'s value. When that reference is null => we have no more values to iterate over.\\n\\n```// Java Iterator interface reference:\\n// https://docs.oracle.com/javase/8/docs/api/java/util/Iterator.html\\nclass PeekingIterator implements Iterator<Integer> {\\n\\n    Integer prev;\\n    Iterator<Integer> it;\\n\\tpublic PeekingIterator(Iterator<Integer> iterator) {\\n        this.it = iterator;\\n        if (it.hasNext()) prev = it.next();\\n\\t}\\n\\n    // Returns the next element in the iteration without advancing the iterator.\\n\\tpublic Integer peek() {\\n        return prev;\\n\\t}\\n\\n\\t// hasNext() and next() should behave the same as in the Iterator interface.\\n\\t// Override them if needed.\\n\\t@Override\\n\\tpublic Integer next() {\\n        Integer ret = prev;\\n\\t    if (it.hasNext()) prev = it.next();\\n        else prev = null;\\n        \\n        return ret;\\n\\t}\\n\\n\\t@Override\\n\\tpublic boolean hasNext() {\\n        return prev != null ;\\n\\t}\\n}\\n```",
                "solutionTags": [],
                "code": "```// Java Iterator interface reference:\\n// https://docs.oracle.com/javase/8/docs/api/java/util/Iterator.html\\nclass PeekingIterator implements Iterator<Integer> {\\n\\n    Integer prev;\\n    Iterator<Integer> it;\\n\\tpublic PeekingIterator(Iterator<Integer> iterator) {\\n        this.it = iterator;\\n        if (it.hasNext()) prev = it.next();\\n\\t}\\n\\n    // Returns the next element in the iteration without advancing the iterator.\\n\\tpublic Integer peek() {\\n        return prev;\\n\\t}\\n\\n\\t// hasNext() and next() should behave the same as in the Iterator interface.\\n\\t// Override them if needed.\\n\\t@Override\\n\\tpublic Integer next() {\\n        Integer ret = prev;\\n\\t    if (it.hasNext()) prev = it.next();\\n        else prev = null;\\n        \\n        return ret;\\n\\t}\\n\\n\\t@Override\\n\\tpublic boolean hasNext() {\\n        return prev != null ;\\n\\t}\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 140094,
                "title": "c-single-line-solution",
                "content": "```\\n// Below is the interface for Iterator, which is already defined for you.\\n// **DO NOT** modify the interface for Iterator.\\nclass Iterator {\\n    struct Data;\\n\\tData* data;\\npublic:\\n\\tIterator(const vector<int>& nums);\\n\\tIterator(const Iterator& iter);\\n\\tvirtual ~Iterator();\\n\\t// Returns the next element in the iteration.\\n\\tint next();\\n\\t// Returns true if the iteration has more elements.\\n\\tbool hasNext() const;\\n};\\n\\n\\nclass PeekingIterator : public Iterator {\\n    \\npublic:\\n\\tPeekingIterator(const vector<int>& nums) : Iterator(nums) {\\n\\t}\\n\\n    // Returns the next element in the iteration without advancing the iterator.\\n\\tint peek() {\\n            return Iterator(*this).next();\\n\\t}\\n};\\n```",
                "solutionTags": [],
                "code": "```\\n// Below is the interface for Iterator, which is already defined for you.\\n// **DO NOT** modify the interface for Iterator.\\nclass Iterator {\\n    struct Data;\\n\\tData* data;\\npublic:\\n\\tIterator(const vector<int>& nums);\\n\\tIterator(const Iterator& iter);\\n\\tvirtual ~Iterator();\\n\\t// Returns the next element in the iteration.\\n\\tint next();\\n\\t// Returns true if the iteration has more elements.\\n\\tbool hasNext() const;\\n};\\n\\n\\nclass PeekingIterator : public Iterator {\\n    \\npublic:\\n\\tPeekingIterator(const vector<int>& nums) : Iterator(nums) {\\n\\t}\\n\\n    // Returns the next element in the iteration without advancing the iterator.\\n\\tint peek() {\\n            return Iterator(*this).next();\\n\\t}\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 137632,
                "title": "thinking-process-with-optimization",
                "content": "> Either first call of `peek`, or calls of `next` without `peek` beforehand will move forward the `current` pointer in the given built-in iterator.\\n> \\n> `next` is maintained to tell the first call of `peek`, or calls of `next` without `peek` beforehand.\\n```\\nclass PeekingIterator implements Iterator<Integer> {\\n\\n    private Iterator<Integer> iterator;\\n    private Integer next;\\n    \\n\\tpublic PeekingIterator(Iterator<Integer> iterator) {\\n        next = null;\\n        this.iterator = iterator;\\n\\t}\\n\\n\\tpublic Integer peek() {\\n        return next == null ? next = iterator.next() : next;\\n\\t}\\n\\n\\t@Override\\n\\tpublic Integer next() {\\n        if (next == null) {\\n            return iterator.next();\\n        } else {\\n            Integer toReturn = next;\\n            next = null;\\n            return toReturn;\\n        }\\n\\t}\\n\\n\\t@Override\\n\\tpublic boolean hasNext() {\\n        return next == null ? iterator.hasNext() : true;\\n\\t}\\n}\\n```\\n****\\n>To optimize, we can bound the movement of  `current` pointer in the given built-in iterator to calls of `next()` only.\\n>\\n>In this case, `next` should point to the first element initially.\\n```\\nclass PeekingIterator implements Iterator<Integer> {\\n\\n    private Iterator<Integer> iterator;\\n    private Integer next;\\n    \\n\\tpublic PeekingIterator(Iterator<Integer> iterator) {\\n        this.iterator = iterator;\\n        next = iterator.next();\\n\\t}\\n\\n\\tpublic Integer peek() {\\n        return next;\\n\\t}\\n\\n\\t@Override\\n\\tpublic Integer next() {\\n        Integer toReturn = next;\\n        next = iterator.hasNext() ? next = iterator.next() : null;\\n        return toReturn;\\n\\t}\\n\\n\\t@Override\\n\\tpublic boolean hasNext() {\\n        return next != null;\\n\\t}\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass PeekingIterator implements Iterator<Integer> {\\n\\n    private Iterator<Integer> iterator;\\n    private Integer next;\\n    \\n\\tpublic PeekingIterator(Iterator<Integer> iterator) {\\n        next = null;\\n        this.iterator = iterator;\\n\\t}\\n\\n\\tpublic Integer peek() {\\n        return next == null ? next = iterator.next() : next;\\n\\t}\\n\\n\\t@Override\\n\\tpublic Integer next() {\\n        if (next == null) {\\n            return iterator.next();\\n        } else {\\n            Integer toReturn = next;\\n            next = null;\\n            return toReturn;\\n        }\\n\\t}\\n\\n\\t@Override\\n\\tpublic boolean hasNext() {\\n        return next == null ? iterator.hasNext() : true;\\n\\t}\\n}\\n```\n```\\nclass PeekingIterator implements Iterator<Integer> {\\n\\n    private Iterator<Integer> iterator;\\n    private Integer next;\\n    \\n\\tpublic PeekingIterator(Iterator<Integer> iterator) {\\n        this.iterator = iterator;\\n        next = iterator.next();\\n\\t}\\n\\n\\tpublic Integer peek() {\\n        return next;\\n\\t}\\n\\n\\t@Override\\n\\tpublic Integer next() {\\n        Integer toReturn = next;\\n        next = iterator.hasNext() ? next = iterator.next() : null;\\n        return toReturn;\\n\\t}\\n\\n\\t@Override\\n\\tpublic boolean hasNext() {\\n        return next != null;\\n\\t}\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 72594,
                "title": "test-cases-should-include-collections-containing-null",
                "content": "Some java collections, such as ArrayList, are allowed to contain null elements. Any implementation of Iterator needs to consider this.\\n\\nThe test cases should check that the iterator handles collections containing null, such as: \\n[1,2,3,null,4,5,6]\\n\\nThe test cases should also check that the peek() and next() method throw java.util.NoSuchElementException when there is no next element.\\n\\nThe current set of test cases allows solutions like this:\\n\\n\\n\\n    //*****************\\n    // INCORRECT\\n    //*****************\\n    class PeekingIterator implements Iterator<Integer> {\\n    \\n        final Iterator<Integer> iterator;\\n        \\n        Integer next = null;\\n        \\n    \\tpublic PeekingIterator(Iterator<Integer> iterator) {\\n    \\t    this.iterator = iterator;\\n    \\t    if(iterator.hasNext()){\\n    \\t        next = iterator.next();\\n    \\t    }\\n    \\t}\\n    \\n    \\tpublic Integer peek() {\\n            return next;\\n    \\t}\\n    \\n    \\t@Override\\n    \\tpublic Integer next() {\\n    \\t    Integer result = this.next;\\n    \\t    if(iterator.hasNext()){\\n    \\t        next = iterator.next();\\n    \\t    }else{\\n    \\t        next = null;\\n    \\t    }\\n    \\t    return result;\\n    \\t}\\n    \\n    \\t@Override\\n    \\tpublic boolean hasNext() {\\n    \\t    return next != null;\\n    \\t}\\n    }\\n\\n\\nThe following is a correct implementation of Iterator:\\n\\n    //*****************\\n    // CORRECT\\n    //*****************\\n    class PeekingIterator implements Iterator<Integer> {\\n    \\n        final Iterator<Integer> iterator;\\n        \\n        Integer next = null;\\n        \\n        boolean hasNext = false;\\n    \\n    \\tpublic PeekingIterator(Iterator<Integer> iterator) {\\n    \\t    this.iterator = iterator;\\n    \\t    if(hasNext = iterator.hasNext()){\\n    \\t        next = iterator.next();\\n    \\t    }\\n    \\t}\\n    \\n        public Integer peek() {\\n            if(!hasNext) throw new java.util.NoSuchElementException();\\n            return next;\\n    \\t}\\n    \\n    \\t@Override\\n    \\tpublic Integer next() {\\n    \\t    if(!hasNext) throw new java.util.NoSuchElementException();\\n    \\t    Integer result = next;\\n    \\t    if(hasNext = iterator.hasNext()){\\n    \\t        next = iterator.next();\\n    \\t    }\\n    \\t    return result;\\n    \\t}\\n    \\n    \\t@Override\\n    \\tpublic boolean hasNext() {\\n    \\t    return hasNext;\\n    \\t}\\n    }",
                "solutionTags": [],
                "code": "Some java collections, such as ArrayList, are allowed to contain null elements. Any implementation of Iterator needs to consider this.\\n\\nThe test cases should check that the iterator handles collections containing null, such as: \\n[1,2,3,null,4,5,6]\\n\\nThe test cases should also check that the peek() and next() method throw java.util.NoSuchElementException when there is no next element.\\n\\nThe current set of test cases allows solutions like this:\\n\\n\\n\\n    //*****************\\n    // INCORRECT\\n    //*****************\\n    class PeekingIterator implements Iterator<Integer> {\\n    \\n        final Iterator<Integer> iterator;\\n        \\n        Integer next = null;\\n        \\n    \\tpublic PeekingIterator(Iterator<Integer> iterator) {\\n    \\t    this.iterator = iterator;\\n    \\t    if(iterator.hasNext()){\\n    \\t        next = iterator.next();\\n    \\t    }\\n    \\t}\\n    \\n    \\tpublic Integer peek() {\\n            return next;\\n    \\t}\\n    \\n    \\t@Override\\n    \\tpublic Integer next() {\\n    \\t    Integer result = this.next;\\n    \\t    if(iterator.hasNext()){\\n    \\t        next = iterator.next();\\n    \\t    }else{\\n    \\t        next = null;\\n    \\t    }\\n    \\t    return result;\\n    \\t}\\n    \\n    \\t@Override\\n    \\tpublic boolean hasNext() {\\n    \\t    return next != null;\\n    \\t}\\n    }\\n\\n\\nThe following is a correct implementation of Iterator:\\n\\n    //*****************\\n    // CORRECT\\n    //*****************\\n    class PeekingIterator implements Iterator<Integer> {\\n    \\n        final Iterator<Integer> iterator;\\n        \\n        Integer next = null;\\n        \\n        boolean hasNext = false;\\n    \\n    \\tpublic PeekingIterator(Iterator<Integer> iterator) {\\n    \\t    this.iterator = iterator;\\n    \\t    if(hasNext = iterator.hasNext()){\\n    \\t        next = iterator.next();\\n    \\t    }\\n    \\t}\\n    \\n        public Integer peek() {\\n            if(!hasNext) throw new java.util.NoSuchElementException();\\n            return next;\\n    \\t}\\n    \\n    \\t@Override\\n    \\tpublic Integer next() {\\n    \\t    if(!hasNext) throw new java.util.NoSuchElementException();\\n    \\t    Integer result = next;\\n    \\t    if(hasNext = iterator.hasNext()){\\n    \\t        next = iterator.next();\\n    \\t    }\\n    \\t    return result;\\n    \\t}\\n    \\n    \\t@Override\\n    \\tpublic boolean hasNext() {\\n    \\t    return hasNext;\\n    \\t}\\n    }",
                "codeTag": "Java"
            },
            {
                "id": 72608,
                "title": "share-useful-concept-in-c-oop",
                "content": "\\n\\n       Just comment out the last two function means that you do not want to override it, so it uses parent class implementation.  \\n\\n\\tint peek() {\\n        if(hasNext()){\\n            Iterator it(*this);\\n            return it.next();\\n        }\\n\\t}\\n\\n\\t// hasNext() and next() should behave the same as in the Iterator interface.\\n\\t// Override them if needed.\\n\\t/*int next() {\\n\\t    \\n\\t}\\n\\n\\tbool hasNext() const {\\n\\t    \\n\\t}*/\\n};",
                "solutionTags": [],
                "code": "\\n\\n       Just comment out the last two function means that you do not want to override it, so it uses parent class implementation.  \\n\\n\\tint peek() {\\n        if(hasNext()){\\n            Iterator it(*this);\\n            return it.next();\\n        }\\n\\t}\\n\\n\\t// hasNext() and next() should behave the same as in the Iterator interface.\\n\\t// Override them if needed.\\n\\t/*int next() {\\n\\t    \\n\\t}\\n\\n\\tbool hasNext() const {\\n\\t    \\n\\t}*/\\n};",
                "codeTag": "Java"
            },
            {
                "id": 72579,
                "title": "using-one-variable-to-cache-the-next",
                "content": "    class PeekingIterator : public Iterator {\\n    private:\\n        int peekElement = -1;\\n\\n    public:\\n\\tPeekingIterator(const vector<int>& nums) : Iterator(nums) {\\n\\t    // Initialize any member here.\\n\\t    // **DO NOT** save a copy of nums and manipulate it directly.\\n\\t    // You should only use the Iterator interface methods.\\n\\t}\\n\\n    // Returns the next element in the iteration without advancing the iterator.\\n\\tint peek() {\\n\\t    if (peekElement == -1 && hasNext()) peekElement = Iterator::next();\\n        return peekElement;\\n\\t}\\n\\n\\t// hasNext() and next() should behave the same as in the Iterator interface.\\n\\t// Override them if needed.\\n\\tint next() {\\n\\t    if (peekElement == -1 && hasNext()) peekElement = Iterator::next();\\n\\t    int old = peekElement;\\n\\t    peekElement = -1;\\n\\t    return old;\\n\\t}\\n\\n\\tbool hasNext() const {\\n\\t    return peekElement != -1 || Iterator::hasNext();\\n\\t}\\n};",
                "solutionTags": [],
                "code": "    class PeekingIterator : public Iterator {\\n    private:\\n        int peekElement = -1;\\n\\n    public:\\n\\tPeekingIterator(const vector<int>& nums) : Iterator(nums) {\\n\\t    // Initialize any member here.\\n\\t    // **DO NOT** save a copy of nums and manipulate it directly.\\n\\t    // You should only use the Iterator interface methods.\\n\\t}\\n\\n    // Returns the next element in the iteration without advancing the iterator.\\n\\tint peek() {\\n\\t    if (peekElement == -1 && hasNext()) peekElement = Iterator::next();\\n        return peekElement;\\n\\t}\\n\\n\\t// hasNext() and next() should behave the same as in the Iterator interface.\\n\\t// Override them if needed.\\n\\tint next() {\\n\\t    if (peekElement == -1 && hasNext()) peekElement = Iterator::next();\\n\\t    int old = peekElement;\\n\\t    peekElement = -1;\\n\\t    return old;\\n\\t}\\n\\n\\tbool hasNext() const {\\n\\t    return peekElement != -1 || Iterator::hasNext();\\n\\t}\\n};",
                "codeTag": "Java"
            },
            {
                "id": 72617,
                "title": "what-is-the-data-member-mean",
                "content": "I don't know what is the \"*data\" used for?\\nCan someone give some detail explanation?\\n\\n\\n    class Iterator {\\n    struct Data;\\n\\tData* data;\\n      public:\\n\\tIterator(const vector<int>& nums);\\n\\tIterator(const Iterator& iter);\\n\\tvirtual ~Iterator();\\n\\t// Returns the next element in the iteration.\\n\\tint next();\\n\\t// Returns true if the iteration has more elements.\\n\\tbool hasNext() const;\\n    };",
                "solutionTags": [],
                "code": "I don't know what is the \"*data\" used for?\\nCan someone give some detail explanation?\\n\\n\\n    class Iterator {\\n    struct Data;\\n\\tData* data;\\n      public:\\n\\tIterator(const vector<int>& nums);\\n\\tIterator(const Iterator& iter);\\n\\tvirtual ~Iterator();\\n\\t// Returns the next element in the iteration.\\n\\tint next();\\n\\t// Returns true if the iteration has more elements.\\n\\tbool hasNext() const;\\n    };",
                "codeTag": "Java"
            },
            {
                "id": 72627,
                "title": "c-solution-using-a-stack",
                "content": "      class PeekingIterator : public Iterator {\\n        public:\\n        \\tPeekingIterator(const vector<int>& nums) : Iterator(nums) {\\n        \\t    it = this;\\n        \\t}\\n        \\n            // Returns the next element in the iteration without advancing the iterator.\\n        \\tint peek() {\\n                if (pk.empty()) {\\n                    pk.push(next());\\n                }\\n                \\n                return pk.top();\\n        \\t}\\n        \\n        \\t// hasNext() and next() should behave the same as in the Iterator interface.\\n        \\t// Override them if needed.\\n        \\tint next() {\\n        \\t    int val;\\n        \\t    if (!pk.empty()) {\\n        \\t        val = pk.top();\\n        \\t        pk.pop();\\n        \\t    } else {\\n        \\t        val = it->next();\\n        \\t    }\\n        \\t    \\n        \\t    return val;\\n        \\t}\\n        \\n        \\tbool hasNext() const {\\n        \\t    return !pk.empty() || it->hasNext();\\n        \\t}\\n        \\t\\n        private:\\n            Iterator *it;\\n            stack<int> pk;\\n        };",
                "solutionTags": [],
                "code": "      class PeekingIterator : public Iterator {\\n        public:\\n        \\tPeekingIterator(const vector<int>& nums) : Iterator(nums) {\\n        \\t    it = this;\\n        \\t}\\n        \\n            // Returns the next element in the iteration without advancing the iterator.\\n        \\tint peek() {\\n                if (pk.empty()) {\\n                    pk.push(next());\\n                }\\n                \\n                return pk.top();\\n        \\t}\\n        \\n        \\t// hasNext() and next() should behave the same as in the Iterator interface.\\n        \\t// Override them if needed.\\n        \\tint next() {\\n        \\t    int val;\\n        \\t    if (!pk.empty()) {\\n        \\t        val = pk.top();\\n        \\t        pk.pop();\\n        \\t    } else {\\n        \\t        val = it->next();\\n        \\t    }\\n        \\t    \\n        \\t    return val;\\n        \\t}\\n        \\n        \\tbool hasNext() const {\\n        \\t    return !pk.empty() || it->hasNext();\\n        \\t}\\n        \\t\\n        private:\\n            Iterator *it;\\n            stack<int> pk;\\n        };",
                "codeTag": "Java"
            },
            {
                "id": 72631,
                "title": "java-solution-which-could-work-with-any-types-and-work-when-there-is-null-element-in-collection",
                "content": "When you need to work with other type, just replace Integer with your type.\\n\\n    class PeekingIterator implements Iterator<Integer> {\\n    \\n        private Integer peekElement = null;\\n        private Iterator<Integer> iter = null;\\n        private boolean hasNext = true;\\n        \\n    \\tpublic PeekingIterator(Iterator<Integer> iterator) {\\n    \\t    iter = iterator;\\n            if(iterator.hasNext()) {    \\t        \\n    \\t        peekElement = iter.next();\\n    \\t    }\\n    \\t    else hasNext = false;\\n    \\t}\\n    \\n    \\tpublic Integer peek() {\\n            return peekElement;\\n    \\t}\\n    \\n    \\tpublic Integer next() {\\n            if(!this.hasNext()) return null; //without this line still got AC, I just think it's a proper way.\\n    \\t    Integer tmp = peekElement;\\n    \\t    if(!iter.hasNext()) {\\n    \\t        peekElement = null;\\n    \\t        hasNext = false;\\n    \\t    }\\n    \\t    else peekElement = iter.next();\\n    \\t    return tmp;\\n    \\t}\\n    \\n    \\tpublic boolean hasNext() {\\n    \\t    return hasNext;\\n    \\t}\\n    }",
                "solutionTags": [],
                "code": "When you need to work with other type, just replace Integer with your type.\\n\\n    class PeekingIterator implements Iterator<Integer> {\\n    \\n        private Integer peekElement = null;\\n        private Iterator<Integer> iter = null;\\n        private boolean hasNext = true;\\n        \\n    \\tpublic PeekingIterator(Iterator<Integer> iterator) {\\n    \\t    iter = iterator;\\n            if(iterator.hasNext()) {    \\t        \\n    \\t        peekElement = iter.next();\\n    \\t    }\\n    \\t    else hasNext = false;\\n    \\t}\\n    \\n    \\tpublic Integer peek() {\\n            return peekElement;\\n    \\t}\\n    \\n    \\tpublic Integer next() {\\n            if(!this.hasNext()) return null; //without this line still got AC, I just think it's a proper way.\\n    \\t    Integer tmp = peekElement;\\n    \\t    if(!iter.hasNext()) {\\n    \\t        peekElement = null;\\n    \\t        hasNext = false;\\n    \\t    }\\n    \\t    else peekElement = iter.next();\\n    \\t    return tmp;\\n    \\t}\\n    \\n    \\tpublic boolean hasNext() {\\n    \\t    return hasNext;\\n    \\t}\\n    }",
                "codeTag": "Java"
            },
            {
                "id": 72649,
                "title": "bug-c-code-has-wrong-ctor-name",
                "content": "Bug report: there's a bug in C++ version of this problem.\\n\\n    class PeekingIterator : public Iterator {\\n    public:\\n    \\tIteratorWithPeek(const vector<int>& nums) : Iterator(nums) {\\n        ^^^^^^^^^^   ctor name mismatches class name",
                "solutionTags": [],
                "code": "Bug report: there's a bug in C++ version of this problem.\\n\\n    class PeekingIterator : public Iterator {\\n    public:\\n    \\tIteratorWithPeek(const vector<int>& nums) : Iterator(nums) {\\n        ^^^^^^^^^^   ctor name mismatches class name",
                "codeTag": "Java"
            },
            {
                "id": 3431773,
                "title": "java-solution-using-passed-iterator",
                "content": "# Code\\n```\\nimport java.util.*;\\n\\nclass PeekingIterator implements Iterator<Integer> {\\n\\n    Iterator<Integer> iterator;\\n    Integer peekedValue;\\n    public PeekingIterator(Iterator<Integer> iterator) {\\n        this.iterator = iterator;\\n        this.peekedValue = null;\\n    }\\n\\n    // Returns the next element in the iteration without advancing the iterator.\\n    public Integer peek() {\\n        if (peekedValue != null) {\\n            return peekedValue;\\n        }\\n        peekedValue = iterator.next();\\n        return peekedValue;\\n    }\\n\\n    // hasNext() and next() should behave the same as in the Iterator interface.\\n    // Override them if needed.\\n    @Override\\n    public Integer next() {\\n        if (peekedValue != null) {\\n            int temp = peekedValue;\\n            peekedValue = null;\\n            return temp;\\n        }\\n        return iterator.next();\\n    }\\n\\n    @Override\\n    public boolean hasNext() {\\n        if (peekedValue != null) {\\n            return true;\\n        }\\n        return iterator.hasNext();\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nimport java.util.*;\\n\\nclass PeekingIterator implements Iterator<Integer> {\\n\\n    Iterator<Integer> iterator;\\n    Integer peekedValue;\\n    public PeekingIterator(Iterator<Integer> iterator) {\\n        this.iterator = iterator;\\n        this.peekedValue = null;\\n    }\\n\\n    // Returns the next element in the iteration without advancing the iterator.\\n    public Integer peek() {\\n        if (peekedValue != null) {\\n            return peekedValue;\\n        }\\n        peekedValue = iterator.next();\\n        return peekedValue;\\n    }\\n\\n    // hasNext() and next() should behave the same as in the Iterator interface.\\n    // Override them if needed.\\n    @Override\\n    public Integer next() {\\n        if (peekedValue != null) {\\n            int temp = peekedValue;\\n            peekedValue = null;\\n            return temp;\\n        }\\n        return iterator.next();\\n    }\\n\\n    @Override\\n    public boolean hasNext() {\\n        if (peekedValue != null) {\\n            return true;\\n        }\\n        return iterator.hasNext();\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3262736,
                "title": "fastest-answer-in-o-1-time-complexity-in-c",
                "content": "\\n\\n# Complexity\\n- Time complexity:\\nO(1)\\n\\n- Space complexity:\\nO(1)\\n\\n# Code\\n```\\n/*\\n * Below is the interface for Iterator, which is already defined for you.\\n * **DO NOT** modify the interface for Iterator.\\n *\\n *  class Iterator {\\n *\\t\\tstruct Data;\\n * \\t\\tData* data;\\n *  public:\\n *\\t\\tIterator(const vector<int>& nums);\\n * \\t\\tIterator(const Iterator& iter);\\n *\\n * \\t\\t// Returns the next element in the iteration.\\n *\\t\\tint next();\\n *\\n *\\t\\t// Returns true if the iteration has more elements.\\n *\\t\\tbool hasNext() const;\\n *\\t};\\n */\\n\\nclass PeekingIterator : public Iterator {\\npublic:\\n\\n    int index = 0;\\n\\n\\tPeekingIterator(const vector<int>& nums) : Iterator(nums) {\\n\\t    // Initialize any member here.\\n\\t    // **DO NOT** save a copy of nums and manipulate it directly.\\n\\t    // You should only use the Iterator interface methods.\\n\\t    \\n\\t}\\n\\t\\n    // Returns the next element in the iteration without advancing the iterator.\\n\\tint peek() {\\n\\n        return Iterator(*this).next();\\n        \\n\\t}\\n\\t\\n\\t// hasNext() and next() should behave the same as in the Iterator interface.\\n\\t// Override them if needed.\\n\\tint next() {\\n\\n        return Iterator::next();\\n\\t    \\n\\t}\\n\\t\\n\\tbool hasNext() const {\\n\\n        return Iterator::hasNext();\\n\\t    \\n\\t}\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Array",
                    "Iterator"
                ],
                "code": "```\\n/*\\n * Below is the interface for Iterator, which is already defined for you.\\n * **DO NOT** modify the interface for Iterator.\\n *\\n *  class Iterator {\\n *\\t\\tstruct Data;\\n * \\t\\tData* data;\\n *  public:\\n *\\t\\tIterator(const vector<int>& nums);\\n * \\t\\tIterator(const Iterator& iter);\\n *\\n * \\t\\t// Returns the next element in the iteration.\\n *\\t\\tint next();\\n *\\n *\\t\\t// Returns true if the iteration has more elements.\\n *\\t\\tbool hasNext() const;\\n *\\t};\\n */\\n\\nclass PeekingIterator : public Iterator {\\npublic:\\n\\n    int index = 0;\\n\\n\\tPeekingIterator(const vector<int>& nums) : Iterator(nums) {\\n\\t    // Initialize any member here.\\n\\t    // **DO NOT** save a copy of nums and manipulate it directly.\\n\\t    // You should only use the Iterator interface methods.\\n\\t    \\n\\t}\\n\\t\\n    // Returns the next element in the iteration without advancing the iterator.\\n\\tint peek() {\\n\\n        return Iterator(*this).next();\\n        \\n\\t}\\n\\t\\n\\t// hasNext() and next() should behave the same as in the Iterator interface.\\n\\t// Override them if needed.\\n\\tint next() {\\n\\n        return Iterator::next();\\n\\t    \\n\\t}\\n\\t\\n\\tbool hasNext() const {\\n\\n        return Iterator::hasNext();\\n\\t    \\n\\t}\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3013588,
                "title": "scala-oneliners-with-memoization-tap-pipe",
                "content": "# Code\\n```\\nclass PeekingIterator(_iterator: Iterator[Int]) {\\n  import scala.util.chaining._\\n  import scala.language.implicitConversions\\n  var last = Option.empty[Int]\\n  def peek(): Int =\\n    (if(last.isEmpty) last=Option(_iterator.next())).pipe{_ => last.get}\\n  def next(): Int =\\n    if(last.isEmpty) _iterator.next else last.get.tap{_ => last = None}\\n  def hasNext(): Boolean =\\n    last.nonEmpty || _iterator.hasNext\\n}\\n```",
                "solutionTags": [
                    "Scala"
                ],
                "code": "```\\nclass PeekingIterator(_iterator: Iterator[Int]) {\\n  import scala.util.chaining._\\n  import scala.language.implicitConversions\\n  var last = Option.empty[Int]\\n  def peek(): Int =\\n    (if(last.isEmpty) last=Option(_iterator.next())).pipe{_ => last.get}\\n  def next(): Int =\\n    if(last.isEmpty) _iterator.next else last.get.tap{_ => last = None}\\n  def hasNext(): Boolean =\\n    last.nonEmpty || _iterator.hasNext\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2534597,
                "title": "faster-than-100-space-less-then-98-easy-solution-10-line-solution",
                "content": "```\\n/*\\n * Below is the interface for Iterator, which is already defined for you.\\n * **DO NOT** modify the interface for Iterator.\\n *\\n *  class Iterator {\\n *\\t\\tstruct Data;\\n * \\t\\tData* data;\\n *  public:\\n *\\t\\tIterator(const vector<int>& nums);\\n * \\t\\tIterator(const Iterator& iter);\\n *\\n * \\t\\t// Returns the next element in the iteration.\\n *\\t\\tint next();\\n *\\n *\\t\\t// Returns true if the iteration has more elements.\\n *\\t\\tbool hasNext() const;\\n *\\t};\\n */\\n\\nclass PeekingIterator : public Iterator {\\nprivate:\\n    int nxt;\\n    void advPointer(){\\n        if(Iterator::hasNext())\\n                nxt=Iterator::next();\\n            else\\n                nxt=INT_MIN;\\n    }\\npublic:\\n\\tPeekingIterator(const vector<int>& nums) : Iterator(nums) {\\n\\t    // Initialize any member here.\\n\\t    // **DO NOT** save a copy of nums and manipulate it directly.\\n\\t    // You should only use the Iterator interface methods.\\n\\t    \\n        advPointer();//1 <= nums[i] <= 1000\\n\\t}\\n\\t\\n    // Returns the next element in the iteration without advancing the iterator.\\n\\tint peek() {\\n        return nxt;\\n\\t}\\n\\t\\n\\t// hasNext() and next() should behave the same as in the Iterator interface.\\n\\t// Override them if needed.\\n\\tint next() {\\n        int tmp=nxt;\\n        advPointer();\\n        return tmp;\\n\\t}\\n\\t\\n\\tbool hasNext() const {\\n\\t    if(nxt!=INT_MIN)\\n            return true;\\n        else\\n            return false;\\n\\t}\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Binary Tree",
                    "Iterator"
                ],
                "code": "```\\n/*\\n * Below is the interface for Iterator, which is already defined for you.\\n * **DO NOT** modify the interface for Iterator.\\n *\\n *  class Iterator {\\n *\\t\\tstruct Data;\\n * \\t\\tData* data;\\n *  public:\\n *\\t\\tIterator(const vector<int>& nums);\\n * \\t\\tIterator(const Iterator& iter);\\n *\\n * \\t\\t// Returns the next element in the iteration.\\n *\\t\\tint next();\\n *\\n *\\t\\t// Returns true if the iteration has more elements.\\n *\\t\\tbool hasNext() const;\\n *\\t};\\n */\\n\\nclass PeekingIterator : public Iterator {\\nprivate:\\n    int nxt;\\n    void advPointer(){\\n        if(Iterator::hasNext())\\n                nxt=Iterator::next();\\n            else\\n                nxt=INT_MIN;\\n    }\\npublic:\\n\\tPeekingIterator(const vector<int>& nums) : Iterator(nums) {\\n\\t    // Initialize any member here.\\n\\t    // **DO NOT** save a copy of nums and manipulate it directly.\\n\\t    // You should only use the Iterator interface methods.\\n\\t    \\n        advPointer();//1 <= nums[i] <= 1000\\n\\t}\\n\\t\\n    // Returns the next element in the iteration without advancing the iterator.\\n\\tint peek() {\\n        return nxt;\\n\\t}\\n\\t\\n\\t// hasNext() and next() should behave the same as in the Iterator interface.\\n\\t// Override them if needed.\\n\\tint next() {\\n        int tmp=nxt;\\n        advPointer();\\n        return tmp;\\n\\t}\\n\\t\\n\\tbool hasNext() const {\\n\\t    if(nxt!=INT_MIN)\\n            return true;\\n        else\\n            return false;\\n\\t}\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2352704,
                "title": "python3-solution",
                "content": "```\\nclass PeekingIterator:\\n    def __init__(self, iterator):\\n        self.iter = iterator\\n        self.peeked_value = None\\n        \\n\\n    def peek(self):\\n        self.peeked_value = self.next()\\n        return self.peeked_value\\n        \\n\\n    def next(self):\\n        if self.peeked_value:\\n            temp = self.peeked_value\\n            self.peeked_value = None\\n            return temp\\n        else:\\n            return self.iter.next()\\n\\n        \\n    def hasNext(self):\\n        if self.peeked_value:\\n            return True\\n        else:\\n            return self.iter.hasNext()\\n```",
                "solutionTags": [
                    "Iterator"
                ],
                "code": "```\\nclass PeekingIterator:\\n    def __init__(self, iterator):\\n        self.iter = iterator\\n        self.peeked_value = None\\n        \\n\\n    def peek(self):\\n        self.peeked_value = self.next()\\n        return self.peeked_value\\n        \\n\\n    def next(self):\\n        if self.peeked_value:\\n            temp = self.peeked_value\\n            self.peeked_value = None\\n            return temp\\n        else:\\n            return self.iter.next()\\n\\n        \\n    def hasNext(self):\\n        if self.peeked_value:\\n            return True\\n        else:\\n            return self.iter.hasNext()\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2229122,
                "title": "a-simple-way",
                "content": "```\\nvar PeekingIterator = function(iterator) {\\n    this.iterator = iterator\\n    this.curr = iterator.next()\\n\\n};\\n\\nPeekingIterator.prototype.peek = function() {\\n    return this.curr\\n};\\n\\nPeekingIterator.prototype.next = function() {\\n    let temp = this.curr\\n    this.curr = this.iterator.next()\\n    return temp\\n};\\n\\nPeekingIterator.prototype.hasNext = function() {\\n    return this.curr > 0   // the input iterator return -100000000 when next() after it run out of members, instead of return undefined.\\n};\\n\\n```\\n",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\nvar PeekingIterator = function(iterator) {\\n    this.iterator = iterator\\n    this.curr = iterator.next()\\n\\n};\\n\\nPeekingIterator.prototype.peek = function() {\\n    return this.curr\\n};\\n\\nPeekingIterator.prototype.next = function() {\\n    let temp = this.curr\\n    this.curr = this.iterator.next()\\n    return temp\\n};\\n\\nPeekingIterator.prototype.hasNext = function() {\\n    return this.curr > 0   // the input iterator return -100000000 when next() after it run out of members, instead of return undefined.\\n};\\n\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2168992,
                "title": "java-simple-solution-with-o-1-space",
                "content": "```\\n// Java Iterator interface reference:\\n// https://docs.oracle.com/javase/8/docs/api/java/util/Iterator.html\\n\\nclass PeekingIterator implements Iterator<Integer> {\\n    private Iterator<Integer> it;\\n    private int num = 0;        //keep the last peek int\\n    \\n\\tpublic PeekingIterator(Iterator<Integer> iterator) {\\n\\t    // initialize any member here.\\n        this.it = iterator;\\n\\t}\\n\\t\\n    // Returns the next element in the iteration without advancing the iterator.\\n\\tpublic Integer peek() {\\n        if(num == 0)\\n            num = it.next();\\n        \\n        return num;\\n\\t}\\n\\t\\n\\t// hasNext() and next() should behave the same as in the Iterator interface.\\n\\t// Override them if needed.\\n\\t@Override\\n\\tpublic Integer next() {\\n        if(num != 0) {\\n            int out = num;\\n            num = 0;\\n            return out;\\n        }\\n        \\n\\t    return it.next();\\n\\t}\\n\\t\\n\\t@Override\\n\\tpublic boolean hasNext() {\\n\\t    return num != 0 ? true : it.hasNext();\\n\\t}\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\n// Java Iterator interface reference:\\n// https://docs.oracle.com/javase/8/docs/api/java/util/Iterator.html\\n\\nclass PeekingIterator implements Iterator<Integer> {\\n    private Iterator<Integer> it;\\n    private int num = 0;        //keep the last peek int\\n    \\n\\tpublic PeekingIterator(Iterator<Integer> iterator) {\\n\\t    // initialize any member here.\\n        this.it = iterator;\\n\\t}\\n\\t\\n    // Returns the next element in the iteration without advancing the iterator.\\n\\tpublic Integer peek() {\\n        if(num == 0)\\n            num = it.next();\\n        \\n        return num;\\n\\t}\\n\\t\\n\\t// hasNext() and next() should behave the same as in the Iterator interface.\\n\\t// Override them if needed.\\n\\t@Override\\n\\tpublic Integer next() {\\n        if(num != 0) {\\n            int out = num;\\n            num = 0;\\n            return out;\\n        }\\n        \\n\\t    return it.next();\\n\\t}\\n\\t\\n\\t@Override\\n\\tpublic boolean hasNext() {\\n\\t    return num != 0 ? true : it.hasNext();\\n\\t}\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2081937,
                "title": "java-easy-solution",
                "content": "So what happens when we call next() , the pointer goes to next pointer and then return its value but we have to implement also peek function so instead of going to next pointer when calling next be there already and whenever peek is called return its value and whenever next is called return its value and go to next position and for hasnext if next value is null then return false;\\n```\\nclass PeekingIterator implements Iterator<Integer> {\\n    Iterator<Integer> iterator;\\n    Integer next;\\n\\tpublic PeekingIterator(Iterator<Integer> iterator) {\\n\\t    // initialize any member here.\\n\\t    this.iterator=iterator;\\n        next=iterator.next();\\n\\t}\\n\\t\\n    // Returns the next element in the iteration without advancing the iterator.\\n\\tpublic Integer peek() {\\n        return next;\\n\\t}\\n\\t\\n\\t// hasNext() and next() should behave the same as in the Iterator interface.\\n\\t// Override them if needed.\\n\\t@Override\\n\\tpublic Integer next() {\\n\\t    Integer ans=next;\\n        next=iterator.hasNext()?iterator.next():null;\\n        return ans;\\n\\t}\\n\\t\\n\\t@Override\\n\\tpublic boolean hasNext() {\\n\\t    return next!=null;\\n\\t}\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass PeekingIterator implements Iterator<Integer> {\\n    Iterator<Integer> iterator;\\n    Integer next;\\n\\tpublic PeekingIterator(Iterator<Integer> iterator) {\\n\\t    // initialize any member here.\\n\\t    this.iterator=iterator;\\n        next=iterator.next();\\n\\t}\\n\\t\\n    // Returns the next element in the iteration without advancing the iterator.\\n\\tpublic Integer peek() {\\n        return next;\\n\\t}\\n\\t\\n\\t// hasNext() and next() should behave the same as in the Iterator interface.\\n\\t// Override them if needed.\\n\\t@Override\\n\\tpublic Integer next() {\\n\\t    Integer ans=next;\\n        next=iterator.hasNext()?iterator.next():null;\\n        return ans;\\n\\t}\\n\\t\\n\\t@Override\\n\\tpublic boolean hasNext() {\\n\\t    return next!=null;\\n\\t}\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2032730,
                "title": "java-simple-solution",
                "content": "```\\nclass PeekingIterator implements Iterator<Integer> {\\n    private Iterator<Integer> iterator;\\n    private boolean picked = false;\\n    private Integer pickedValue;\\n    \\n\\tpublic PeekingIterator(Iterator<Integer> iterator) {\\n\\t    // initialize any member here.\\n        this.iterator = iterator;\\n\\t}\\n\\t\\n    // Returns the next element in the iteration without advancing the iterator.\\n\\tpublic Integer peek() {\\n        if (picked) {\\n            return pickedValue;\\n        }\\n        \\n        Integer value = iterator.next();\\n        picked = true;\\n        pickedValue = value;\\n        \\n        return value;\\n\\t}\\n\\t\\n\\t// hasNext() and next() should behave the same as in the Iterator interface.\\n\\t// Override them if needed.\\n\\t@Override\\n\\tpublic Integer next() {\\n        if (picked) {\\n            picked = false;\\n            return pickedValue;\\n        }\\n        \\n\\t    return iterator.next();\\n\\t}\\n\\t\\n\\t@Override\\n\\tpublic boolean hasNext() {\\n        if (picked) {\\n            return true;\\n        }\\n        \\n\\t    return iterator.hasNext();\\n\\t}\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass PeekingIterator implements Iterator<Integer> {\\n    private Iterator<Integer> iterator;\\n    private boolean picked = false;\\n    private Integer pickedValue;\\n    \\n\\tpublic PeekingIterator(Iterator<Integer> iterator) {\\n\\t    // initialize any member here.\\n        this.iterator = iterator;\\n\\t}\\n\\t\\n    // Returns the next element in the iteration without advancing the iterator.\\n\\tpublic Integer peek() {\\n        if (picked) {\\n            return pickedValue;\\n        }\\n        \\n        Integer value = iterator.next();\\n        picked = true;\\n        pickedValue = value;\\n        \\n        return value;\\n\\t}\\n\\t\\n\\t// hasNext() and next() should behave the same as in the Iterator interface.\\n\\t// Override them if needed.\\n\\t@Override\\n\\tpublic Integer next() {\\n        if (picked) {\\n            picked = false;\\n            return pickedValue;\\n        }\\n        \\n\\t    return iterator.next();\\n\\t}\\n\\t\\n\\t@Override\\n\\tpublic boolean hasNext() {\\n        if (picked) {\\n            return true;\\n        }\\n        \\n\\t    return iterator.hasNext();\\n\\t}\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1982545,
                "title": "python-clean-and-simple-solution",
                "content": "```\\n# Below is the interface for Iterator, which is already defined for you.\\n#\\n# class Iterator:\\n#     def __init__(self, nums):\\n#         \"\"\"\\n#         Initializes an iterator object to the beginning of a list.\\n#         :type nums: List[int]\\n#         \"\"\"\\n#\\n#     def hasNext(self):\\n#         \"\"\"\\n#         Returns true if the iteration has more elements.\\n#         :rtype: bool\\n#         \"\"\"\\n#\\n#     def next(self):\\n#         \"\"\"\\n#         Returns the next element in the iteration.\\n#         :rtype: int\\n#         \"\"\"\\n\\nclass PeekingIterator:\\n    def __init__(self, iterator):\\n        \"\"\"\\n        Initialize your data structure here.\\n        :type iterator: Iterator\\n        \"\"\"\\n        self.iterator = iterator\\n        self.fromNext = self.iterator.next() if self.iterator.hasNext() else None\\n\\n    def peek(self):\\n        \"\"\"\\n        Returns the next element in the iteration without advancing the iterator.\\n        :rtype: int\\n        \"\"\"\\n        return self.fromNext\\n        \\n\\n    def next(self):\\n        \"\"\"\\n        :rtype: int\\n        \"\"\"\\n        curr = self.fromNext\\n        self.fromNext = self.iterator.next() if self.iterator.hasNext() else None\\n        return curr\\n        \\n\\n    def hasNext(self):\\n        \"\"\"\\n        :rtype: bool\\n        \"\"\"\\n        return self.fromNext != None\\n        \\n\\n# Your PeekingIterator object will be instantiated and called as such:\\n# iter = PeekingIterator(Iterator(nums))\\n# while iter.hasNext():\\n#     val = iter.peek()   # Get the next element but not advance the iterator.\\n#     iter.next()         # Should return the same value as [val].\\n```\\n**I hope that you\\'ve found this useful.**\\n**In that case, please upvote. It motivates me to write more such posts\\uD83D\\uDE03**\\nComment below if you have any queries.",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\n# Below is the interface for Iterator, which is already defined for you.\\n#\\n# class Iterator:\\n#     def __init__(self, nums):\\n#         \"\"\"\\n#         Initializes an iterator object to the beginning of a list.\\n#         :type nums: List[int]\\n#         \"\"\"\\n#\\n#     def hasNext(self):\\n#         \"\"\"\\n#         Returns true if the iteration has more elements.\\n#         :rtype: bool\\n#         \"\"\"\\n#\\n#     def next(self):\\n#         \"\"\"\\n#         Returns the next element in the iteration.\\n#         :rtype: int\\n#         \"\"\"\\n\\nclass PeekingIterator:\\n    def __init__(self, iterator):\\n        \"\"\"\\n        Initialize your data structure here.\\n        :type iterator: Iterator\\n        \"\"\"\\n        self.iterator = iterator\\n        self.fromNext = self.iterator.next() if self.iterator.hasNext() else None\\n\\n    def peek(self):\\n        \"\"\"\\n        Returns the next element in the iteration without advancing the iterator.\\n        :rtype: int\\n        \"\"\"\\n        return self.fromNext\\n        \\n\\n    def next(self):\\n        \"\"\"\\n        :rtype: int\\n        \"\"\"\\n        curr = self.fromNext\\n        self.fromNext = self.iterator.next() if self.iterator.hasNext() else None\\n        return curr\\n        \\n\\n    def hasNext(self):\\n        \"\"\"\\n        :rtype: bool\\n        \"\"\"\\n        return self.fromNext != None\\n        \\n\\n# Your PeekingIterator object will be instantiated and called as such:\\n# iter = PeekingIterator(Iterator(nums))\\n# while iter.hasNext():\\n#     val = iter.peek()   # Get the next element but not advance the iterator.\\n#     iter.next()         # Should return the same value as [val].\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1982374,
                "title": "modern-cpp-solution",
                "content": "We can just use std::optional to store if we have a value or not. And then can basically store store the next element whenever we call next().\\n```\\nclass PeekingIterator : public Iterator {\\n    std::optional<int> nextElement;\\npublic:\\n\\tPeekingIterator(const vector<int>& nums) : Iterator(nums) {\\n\\t    // Initialize any member here.\\n\\t    // **DO NOT** save a copy of nums and manipulate it directly.\\n\\t    // You should only use the Iterator interface methods.\\n        bool hasValue = Iterator::hasNext();\\n        if (hasValue)\\n        {\\n            nextElement = Iterator::next();\\n        }\\n\\t    \\n\\t}\\n\\t\\n    // Returns the next element in the iteration without advancing the iterator.\\n\\tint peek() {\\n     return nextElement.value();   \\n\\t}\\n\\t\\n\\t// hasNext() and next() should behave the same as in the Iterator interface.\\n\\t// Override them if needed.\\n\\tint next() {\\n        int retVal = nextElement.value();\\n        bool hasValue = Iterator::hasNext();\\n        if (hasValue)\\n        {\\n            nextElement = Iterator::next();\\n        }\\n        else\\n        {\\n            nextElement.reset();\\n        }\\n\\t    return retVal;\\n\\t}\\n\\t\\n\\tbool hasNext() const {\\n\\t   return (nextElement.has_value());\\n\\t}\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass PeekingIterator : public Iterator {\\n    std::optional<int> nextElement;\\npublic:\\n\\tPeekingIterator(const vector<int>& nums) : Iterator(nums) {\\n\\t    // Initialize any member here.\\n\\t    // **DO NOT** save a copy of nums and manipulate it directly.\\n\\t    // You should only use the Iterator interface methods.\\n        bool hasValue = Iterator::hasNext();\\n        if (hasValue)\\n        {\\n            nextElement = Iterator::next();\\n        }\\n\\t    \\n\\t}\\n\\t\\n    // Returns the next element in the iteration without advancing the iterator.\\n\\tint peek() {\\n     return nextElement.value();   \\n\\t}\\n\\t\\n\\t// hasNext() and next() should behave the same as in the Iterator interface.\\n\\t// Override them if needed.\\n\\tint next() {\\n        int retVal = nextElement.value();\\n        bool hasValue = Iterator::hasNext();\\n        if (hasValue)\\n        {\\n            nextElement = Iterator::next();\\n        }\\n        else\\n        {\\n            nextElement.reset();\\n        }\\n\\t    return retVal;\\n\\t}\\n\\t\\n\\tbool hasNext() const {\\n\\t   return (nextElement.has_value());\\n\\t}\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1982270,
                "title": "swift-very-easy-beats-100",
                "content": "concept: make buf for 1 element then peak and hasNext should use it. next will return it then take new elent from source iterator and put into the buf.\\n\\n```\\n// Swift IndexingIterator refernence:\\n// https://developer.apple.com/documentation/swift/indexingiterator\\n\\nclass PeekingIterator {\\n    var buf: Int?\\n    var arr: IndexingIterator<Array<Int>>\\n    \\n    init(_ ar: IndexingIterator<Array<Int>>) {\\n        arr = ar\\n        buf = n()\\n    }\\n    \\n    func n() -> Int? {\\n        return arr.next()\\n    }\\n    \\n    func next() -> Int {\\n        var ret = buf!\\n        buf = n()\\n        return ret\\n    }\\n    \\n    func peek() -> Int {\\n        return buf!\\n    }\\n    \\n    func hasNext() -> Bool {\\n        return buf != nil\\n    }\\n}\\n\\n/**\\n * Your PeekingIterator object will be instantiated and called as such:\\n * let obj = PeekingIterator(arr)\\n * let ret_1: Int = obj.next()\\n * let ret_2: Int = obj.peek()\\n * let ret_3: Bool = obj.hasNext()\\n */\\n```",
                "solutionTags": [],
                "code": "```\\n// Swift IndexingIterator refernence:\\n// https://developer.apple.com/documentation/swift/indexingiterator\\n\\nclass PeekingIterator {\\n    var buf: Int?\\n    var arr: IndexingIterator<Array<Int>>\\n    \\n    init(_ ar: IndexingIterator<Array<Int>>) {\\n        arr = ar\\n        buf = n()\\n    }\\n    \\n    func n() -> Int? {\\n        return arr.next()\\n    }\\n    \\n    func next() -> Int {\\n        var ret = buf!\\n        buf = n()\\n        return ret\\n    }\\n    \\n    func peek() -> Int {\\n        return buf!\\n    }\\n    \\n    func hasNext() -> Bool {\\n        return buf != nil\\n    }\\n}\\n\\n/**\\n * Your PeekingIterator object will be instantiated and called as such:\\n * let obj = PeekingIterator(arr)\\n * let ret_1: Int = obj.next()\\n * let ret_2: Int = obj.peek()\\n * let ret_3: Bool = obj.hasNext()\\n */\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1982253,
                "title": "java-6ms-smart-explanations",
                "content": "```\\nclass PeekingIterator implements Iterator<Integer> {\\n    /** Algorithm\\n        1. In order to simulate a peek, we will actually do a next() and store the result in a bucket.\\n           This bucket will serve as peek (each time a peek is needed) or next.\\n        2. Peek: if the bucket is empty (eg: -1), do a next() and store/cache the value in the bucket and return it.\\n            If the bucket is NOT empty, just return it.\\n        3. Next: if the bucket is not empty, it means we have a value stored there and we didn\\'t move forward.\\n            Return the bucket and reset it. If the bucket it empty, return it.next().\\n        4. HasNext : check if it.hasNext() OR if there is one element in the bucket.\\n    */\\n    private final Iterator<Integer> it;\\n    private int bucket = -1;\\n    public PeekingIterator(Iterator<Integer> iterator) {\\n        it = iterator;\\n    }\\n\\n    // Returns the next element in the iteration without advancing the iterator.\\n\\t// If there is no element in the bucket, put/cache one and move iterator forward. \\n    public Integer peek() {\\n        if(bucket == -1) {\\n            bucket = it.next();\\n        }\\n        return bucket;\\n    }\\n\\n    @Override\\n\\t//If the bucket is empty, then we have to advance with the iterator.\\n\\t// If the bucket has something, empty and return the bucket\\n    public Integer next() {\\n        int toReturn = bucket;\\n        if (toReturn == -1) {\\n            toReturn = it.next();\\n        }\\n        bucket = -1;\\n        return toReturn;\\n    }\\n    // check if it.hasNext or if there is a cached/bucket value from last next.\\n    @Override\\n    public boolean hasNext() {\\n        return it.hasNext() || bucket != -1;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass PeekingIterator implements Iterator<Integer> {\\n    /** Algorithm\\n        1. In order to simulate a peek, we will actually do a next() and store the result in a bucket.\\n           This bucket will serve as peek (each time a peek is needed) or next.\\n        2. Peek: if the bucket is empty (eg: -1), do a next() and store/cache the value in the bucket and return it.\\n            If the bucket is NOT empty, just return it.\\n        3. Next: if the bucket is not empty, it means we have a value stored there and we didn\\'t move forward.\\n            Return the bucket and reset it. If the bucket it empty, return it.next().\\n        4. HasNext : check if it.hasNext() OR if there is one element in the bucket.\\n    */\\n    private final Iterator<Integer> it;\\n    private int bucket = -1;\\n    public PeekingIterator(Iterator<Integer> iterator) {\\n        it = iterator;\\n    }\\n\\n    // Returns the next element in the iteration without advancing the iterator.\\n\\t// If there is no element in the bucket, put/cache one and move iterator forward. \\n    public Integer peek() {\\n        if(bucket == -1) {\\n            bucket = it.next();\\n        }\\n        return bucket;\\n    }\\n\\n    @Override\\n\\t//If the bucket is empty, then we have to advance with the iterator.\\n\\t// If the bucket has something, empty and return the bucket\\n    public Integer next() {\\n        int toReturn = bucket;\\n        if (toReturn == -1) {\\n            toReturn = it.next();\\n        }\\n        bucket = -1;\\n        return toReturn;\\n    }\\n    // check if it.hasNext or if there is a cached/bucket value from last next.\\n    @Override\\n    public boolean hasNext() {\\n        return it.hasNext() || bucket != -1;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1982240,
                "title": "java-solution",
                "content": "```\\n// Java Iterator interface reference:\\n// https://docs.oracle.com/javase/8/docs/api/java/util/Iterator.html\\n\\nclass PeekingIterator implements Iterator<Integer> {\\n    List<Integer> l;\\n    int a = 0;\\n\\n    public PeekingIterator(Iterator<Integer> iterator) {\\n        // initialize any member here.\\n\\n        l = new ArrayList();\\n        while (iterator.hasNext()) {\\n            l.add(iterator.next());\\n        }\\n    }\\n\\n    // Returns the next element in the iteration without advancing the iterator.\\n    public Integer peek() {\\n        return l.get(a);\\n    }\\n\\n    // hasNext() and next() should behave the same as in the Iterator interface.\\n    // Override them if needed.\\n    @Override\\n    public Integer next() {\\n        int ans = -1;\\n        if (a < l.size()) {\\n            ans = l.get(a);\\n            a++;\\n        }\\n        return ans;\\n    }\\n\\n    @Override\\n    public boolean hasNext() {\\n        if (l.size() > a) return true;\\n\\n        return false;\\n    }\\n}\\n",
                "solutionTags": [
                    "Java",
                    "Array"
                ],
                "code": "```\\n// Java Iterator interface reference:\\n// https://docs.oracle.com/javase/8/docs/api/java/util/Iterator.html\\n\\nclass PeekingIterator implements Iterator<Integer> {\\n    List<Integer> l;\\n    int a = 0;\\n\\n    public PeekingIterator(Iterator<Integer> iterator) {\\n        // initialize any member here.\\n\\n        l = new ArrayList();\\n        while (iterator.hasNext()) {\\n            l.add(iterator.next());\\n        }\\n    }\\n\\n    // Returns the next element in the iteration without advancing the iterator.\\n    public Integer peek() {\\n        return l.get(a);\\n    }\\n\\n    // hasNext() and next() should behave the same as in the Iterator interface.\\n    // Override them if needed.\\n    @Override\\n    public Integer next() {\\n        int ans = -1;\\n        if (a < l.size()) {\\n            ans = l.get(a);\\n            a++;\\n        }\\n        return ans;\\n    }\\n\\n    @Override\\n    public boolean hasNext() {\\n        if (l.size() > a) return true;\\n\\n        return false;\\n    }\\n}\\n",
                "codeTag": "Java"
            },
            {
                "id": 1982005,
                "title": "python-o-1-time-o-0-extra-space-straight-up-che-ting",
                "content": "![image](https://assets.leetcode.com/users/images/9efdf7a0-e15e-413e-a628-4341de2855a4_1650907869.05648.png)\\n\\nSo the problem clearly wants want you to get creative by caching the next value. The idea is that, by requiring you to use the \"Iterator\" class to store your data, you\\'re constrained to using peek() next() and hasNext() as your only ways of interfacing with the collection of elements.\\n\\n*However*, we can look around inside this \"Iterator\" class, to see what it\\'s doing under the hood. Just like the __ init __ constructor, every class in Python has a hidden __ dict __ (without the spaces) variable, that keeps track of all of its self.X variables. So we can look at those by calling the following code:\\n```\\n    print(iterator.__dict__.keys())\\n```\\nThis shows us that the iterator class has two variables: \\'v\\', and \\'index.\\' We can look at what those are by looking at the values of iterator\\'s __ dict __ :\\n```\\n    for i in iterator.__dict__.values(): print(type(i))\\n    print(iterator.__dict__.values())\\n```\\nThis reveals that \\'v\\' is a list, representing our values, and \\'index\\' is, well, our index. With this in mind, our peek() function becomes incredibly simple:\\n```\\n    return self.iterator.v[self.iterator.index]\\n```\\nEvery other method is just calling the exact same method from the iterator class. So our final code is pretty much just one-liners:\\n```\\nclass PeekingIterator:\\n    def __init__(self, iterator):\\n        self.iterator = iterator\\n        return\\n\\n    def peek(self):\\n        return self.iterator.v[self.iterator.index]\\n\\n    def next(self):\\n        return self.iterator.next()\\n\\n    def hasNext(self):\\n        return self.iterator.hasNext()\\n```\\nWe literally don\\'t create or process any information. It\\'s arguably still O(1) memory, because of the minimum space required to declare a new class and link it to the iterator class, but as far as I\\'m concerned that\\'s part of the problem\\'s conceit, just like the List \\'v\\' in iterator being O(n) memory. So I\\'d call this solution O(0) *extra* space, past what we are given.\\n\\nThe problem could force you to go with the intended solution, if the variables inside of the iterator class were private, but to my knowledge there\\'s no easy way to do this in Python. The runtime and memory usage for any solution here varies wildly, because almost every solution uses O(1) time O(1) space, so you could run this and get anything from 0% to 100% for either metric.",
                "solutionTags": [],
                "code": "```\\n    print(iterator.__dict__.keys())\\n```\n```\\n    for i in iterator.__dict__.values(): print(type(i))\\n    print(iterator.__dict__.values())\\n```\n```\\n    return self.iterator.v[self.iterator.index]\\n```\n```\\nclass PeekingIterator:\\n    def __init__(self, iterator):\\n        self.iterator = iterator\\n        return\\n\\n    def peek(self):\\n        return self.iterator.v[self.iterator.index]\\n\\n    def next(self):\\n        return self.iterator.next()\\n\\n    def hasNext(self):\\n        return self.iterator.hasNext()\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1981924,
                "title": "100-faster-and-easy-to-understand-c-code-by-using-vector-and-an-integral-variable",
                "content": "```\\n/*\\n * Below is the interface for Iterator, which is already defined for you.\\n * **DO NOT** modify the interface for Iterator.\\n *\\n *  class Iterator {\\n *\\t\\tstruct Data;\\n * \\t\\tData* data;\\n *  public:\\n *\\t\\tIterator(const vector<int>& nums);\\n * \\t\\tIterator(const Iterator& iter);\\n *\\n * \\t\\t// Returns the next element in the iteration.\\n *\\t\\tint next();\\n *\\n *\\t\\t// Returns true if the iteration has more elements.\\n *\\t\\tbool hasNext() const;\\n *\\t};\\n */\\n\\nclass PeekingIterator : public Iterator {\\npublic:\\n    vector<int>v;\\n    int it{};\\n\\tPeekingIterator(const vector<int>& nums) : Iterator(nums) {\\n\\t    // Initialize any member here.\\n\\t    // **DO NOT** save a copy of nums and manipulate it directly.\\n\\t    // You should only use the Iterator interface methods.\\n        v=nums;\\n        it=0;\\n\\t    \\n\\t}\\n\\t\\n    // Returns the next element in the iteration without advancing the iterator.\\n\\tint peek() \\n    {\\n        \\n        return v[it];\\n        \\n\\t}\\n\\t\\n\\t// hasNext() and next() should behave the same as in the Iterator interface.\\n\\t// Override them if needed.\\n\\tint next() \\n    {\\n        return v[it++];\\n\\t    \\n\\t}\\n\\t\\n\\tbool hasNext() const \\n    {\\n        return (it>=v.size()?false:true);\\n\\t    \\n\\t}\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\n/*\\n * Below is the interface for Iterator, which is already defined for you.\\n * **DO NOT** modify the interface for Iterator.\\n *\\n *  class Iterator {\\n *\\t\\tstruct Data;\\n * \\t\\tData* data;\\n *  public:\\n *\\t\\tIterator(const vector<int>& nums);\\n * \\t\\tIterator(const Iterator& iter);\\n *\\n * \\t\\t// Returns the next element in the iteration.\\n *\\t\\tint next();\\n *\\n *\\t\\t// Returns true if the iteration has more elements.\\n *\\t\\tbool hasNext() const;\\n *\\t};\\n */\\n\\nclass PeekingIterator : public Iterator {\\npublic:\\n    vector<int>v;\\n    int it{};\\n\\tPeekingIterator(const vector<int>& nums) : Iterator(nums) {\\n\\t    // Initialize any member here.\\n\\t    // **DO NOT** save a copy of nums and manipulate it directly.\\n\\t    // You should only use the Iterator interface methods.\\n        v=nums;\\n        it=0;\\n\\t    \\n\\t}\\n\\t\\n    // Returns the next element in the iteration without advancing the iterator.\\n\\tint peek() \\n    {\\n        \\n        return v[it];\\n        \\n\\t}\\n\\t\\n\\t// hasNext() and next() should behave the same as in the Iterator interface.\\n\\t// Override them if needed.\\n\\tint next() \\n    {\\n        return v[it++];\\n\\t    \\n\\t}\\n\\t\\n\\tbool hasNext() const \\n    {\\n        return (it>=v.size()?false:true);\\n\\t    \\n\\t}\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1981886,
                "title": "peeking-iterator-solution",
                "content": "class PeekingIterator : public Iterator\\n{\\npublic:\\n    PeekingIterator(const vector<int> &nums) : Iterator(nums)\\n    {\\n    }\\n\\n    int peek()\\n    {\\n        return Iterator(*this).next();\\n    }\\n\\n    int next()\\n    {\\n        return Iterator::next();\\n    }\\n\\n    bool hasNext() const\\n    {\\n        return Iterator::hasNext();\\n    }\\n};",
                "solutionTags": [
                    "C"
                ],
                "code": "class PeekingIterator : public Iterator\\n{\\npublic:\\n    PeekingIterator(const vector<int> &nums) : Iterator(nums)\\n    {\\n    }\\n\\n    int peek()\\n    {\\n        return Iterator(*this).next();\\n    }\\n\\n    int next()\\n    {\\n        return Iterator::next();\\n    }\\n\\n    bool hasNext() const\\n    {\\n        return Iterator::hasNext();\\n    }\\n};",
                "codeTag": "Java"
            },
            {
                "id": 1981824,
                "title": "kotlin-cache-next-element-to-use-as-a-peek-result",
                "content": "Please, let me know if you have any questions.\\n\\nKey notes:\\n* There is a **maintanState()** procedure which is responsible in checking if there are elements in backing iterator\\n\\t* If there are any, cache them in **next** field\\n\\t* If there are no, set **end** field to **true** which means we reached the end of the iterator\\n* On init phase and every **next()** call there is a **maintainState()** procedure\\n* On **peek()** call return the element cached in **next** field\\n* On **hasNext()** check if **end** is **true**\\n\\nSide note: In general iterator can return null values, that\\'s why it is a part of answer for the follow up question... To make it generic - we need just to substitute **Int** with **\\\\<T\\\\>**\\n\\n```\\nclass Solution {\\n    class PeekingIterator(iterator: Iterator<Int>) : Iterator<Int> {\\n        private val internalIterator: Iterator<Int> = iterator\\n        private var next: Int? = null\\n        private var end = false\\n\\n        init {\\n            maintainState()\\n        }\\n\\n        fun peek(): Int {\\n            return next!!\\n        }\\n\\n        override fun next(): Int {\\n            val result = next\\n            maintainState()\\n            return result!!\\n        }\\n\\n        override fun hasNext(): Boolean {\\n            return !end\\n        }\\n\\n        private fun maintainState() {\\n            if (internalIterator.hasNext()) {\\n                next = internalIterator.next()\\n            } else {\\n                end = true\\n            }\\n        }\\n    }\\n}\\n```",
                "solutionTags": [
                    "Kotlin"
                ],
                "code": "```\\nclass Solution {\\n    class PeekingIterator(iterator: Iterator<Int>) : Iterator<Int> {\\n        private val internalIterator: Iterator<Int> = iterator\\n        private var next: Int? = null\\n        private var end = false\\n\\n        init {\\n            maintainState()\\n        }\\n\\n        fun peek(): Int {\\n            return next!!\\n        }\\n\\n        override fun next(): Int {\\n            val result = next\\n            maintainState()\\n            return result!!\\n        }\\n\\n        override fun hasNext(): Boolean {\\n            return !end\\n        }\\n\\n        private fun maintainState() {\\n            if (internalIterator.hasNext()) {\\n                next = internalIterator.next()\\n            } else {\\n                end = true\\n            }\\n        }\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1981720,
                "title": "c-o-1-space-solution-with-generic-iterator",
                "content": "```c#\\nclass PeekingIterator : GenericPeekingIterator<int>\\n{\\n    public PeekingIterator(IEnumerator<int> iterator) : base(iterator){}\\n}\\n\\nclass GenericPeekingIterator<T>\\n{\\n    private IEnumerator<T> iterator;\\n    private bool hasNext = true;\\n\\n    public GenericPeekingIterator(IEnumerator<T> iterator)\\n    {\\n        this.iterator = iterator;\\n    }\\n\\n    public T Peek() => iterator.Current;\\n\\n    public T Next()\\n    {\\n        var current = iterator.Current;\\n        hasNext = iterator.MoveNext();\\n        return current;\\n    }\\n\\n    public bool HasNext() => hasNext;\\n}\\n```",
                "solutionTags": [],
                "code": "```c#\\nclass PeekingIterator : GenericPeekingIterator<int>\\n{\\n    public PeekingIterator(IEnumerator<int> iterator) : base(iterator){}\\n}\\n\\nclass GenericPeekingIterator<T>\\n{\\n    private IEnumerator<T> iterator;\\n    private bool hasNext = true;\\n\\n    public GenericPeekingIterator(IEnumerator<T> iterator)\\n    {\\n        this.iterator = iterator;\\n    }\\n\\n    public T Peek() => iterator.Current;\\n\\n    public T Next()\\n    {\\n        var current = iterator.Current;\\n        hasNext = iterator.MoveNext();\\n        return current;\\n    }\\n\\n    public bool HasNext() => hasNext;\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1981653,
                "title": "java-solution-no-additional-ds-used",
                "content": "```\\nclass PeekingIterator implements Iterator<Integer> {\\n    Iterator<Integer> iterator;\\n    Integer next;\\n    Boolean nextUsedInPeek = false;\\n\\tpublic PeekingIterator(Iterator<Integer> iterator) {\\n\\t    // initialize any member here.\\n\\t    this.iterator = iterator;\\n\\t}\\n\\t\\n    // Returns the next element in the iteration without advancing the iterator.\\n\\tpublic Integer peek() {\\n         if(nextUsedInPeek){\\n            return next;\\n        }\\n        if(iterator.hasNext()){\\n            next = iterator.next();\\n            nextUsedInPeek = true;\\n            return next;\\n        }\\n        return 0;\\n\\t}\\n\\t\\n\\t// hasNext() and next() should behave the same as in the Iterator interface.\\n\\t// Override them if needed.\\n\\t@Override\\n\\tpublic Integer next() {\\n        if(nextUsedInPeek){\\n            nextUsedInPeek = false;\\n            return next;\\n        }\\n        if(iterator.hasNext()){\\n            next = iterator.next();\\n\\t        return next;\\n        }\\n        return 0;\\n\\t}\\n\\t\\n\\t@Override\\n\\tpublic boolean hasNext() {\\n\\t    return nextUsedInPeek || this.iterator.hasNext();\\n\\t}\\n}```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass PeekingIterator implements Iterator<Integer> {\\n    Iterator<Integer> iterator;\\n    Integer next;\\n    Boolean nextUsedInPeek = false;\\n\\tpublic PeekingIterator(Iterator<Integer> iterator) {\\n\\t    // initialize any member here.\\n\\t    this.iterator = iterator;\\n\\t}\\n\\t\\n    // Returns the next element in the iteration without advancing the iterator.\\n\\tpublic Integer peek() {\\n         if(nextUsedInPeek){\\n            return next;\\n        }\\n        if(iterator.hasNext()){\\n            next = iterator.next();\\n            nextUsedInPeek = true;\\n            return next;\\n        }\\n        return 0;\\n\\t}\\n\\t\\n\\t// hasNext() and next() should behave the same as in the Iterator interface.\\n\\t// Override them if needed.\\n\\t@Override\\n\\tpublic Integer next() {\\n        if(nextUsedInPeek){\\n            nextUsedInPeek = false;\\n            return next;\\n        }\\n        if(iterator.hasNext()){\\n            next = iterator.next();\\n\\t        return next;\\n        }\\n        return 0;\\n\\t}\\n\\t\\n\\t@Override\\n\\tpublic boolean hasNext() {\\n\\t    return nextUsedInPeek || this.iterator.hasNext();\\n\\t}\\n}```",
                "codeTag": "Java"
            },
            {
                "id": 1981510,
                "title": "simple-and-efficient-c-solution-o-1-time-and-space",
                "content": "**<u>Intuition:</u>** In the question, we have already given an Iterator class with next and hasNext methods inside it, we have to create a derived class PeekingIterator which will include extra functionality to check the peek without incrementing the iterator.\\n\\nTo make this happen we will store the result of next in a num variable whenever the peek is called and first check for it in the operation before calling the parent methods.\\n\\n## Methods and their working:\\n\\n**PeekingIterator:**\\nMaking the num value as -1 (Nothing in num)\\n\\n**peek:**\\nIf num is -1, then call the next method and store the value in num and return it.\\nelse, return the value of num as we have stored the value of next in it.\\n\\n**next:**\\nIf num is -1, then call the next method.\\nelse return the value of num and make it -1 as we have stored the value of next in it.\\n\\n**hashNext:**\\nreturn true if num is not -1 or the parent function hasNext returned true\\nelse return false\\n\\n### Time Complexities:\\n\\nAll the function has a time complexity of O(1)\\n\\n### Space Complexity: O(1)\\n\\n```cpp\\nclass PeekingIterator : public Iterator {\\npublic:\\n    int num;\\n    PeekingIterator(const vector<int>& nums) : Iterator(nums) {\\n        num = -1;\\n }\\n\\n    // Returns the next element in the iteration without advancing the iterator.\\n    int peek() {\\n        // If num is not -1, then return the num value\\n        if (num != -1) return num;\\n\\n        // Store the next value in num and return it\\n        num = next();\\n        return num;\\n    }\\n\\n    // hasNext() and next() should behave the same as in the Iterator interface.\\n    // Override them if needed.\\n    int next() {\\n        // If num is not -1, then return value of num and make num as -1\\n        if (num != -1) {\\n            int temp = num;\\n            num = -1;\\n            return temp;\\n        }\\n\\n        // If num is -1, then take the next element from the Iterator\\n        return Iterator::next();\\n    }\\n\\n    // Return true the iterator has next element\\n    bool hasNext() const {\\n        return (num != -1 || Iterator::hasNext());\\n    }\\n};\\n```\\n\\n### **If any doubt, feel free to comment!!**\\n",
                "solutionTags": [
                    "C++",
                    "C",
                    "Design",
                    "Iterator"
                ],
                "code": "```cpp\\nclass PeekingIterator : public Iterator {\\npublic:\\n    int num;\\n    PeekingIterator(const vector<int>& nums) : Iterator(nums) {\\n        num = -1;\\n }\\n\\n    // Returns the next element in the iteration without advancing the iterator.\\n    int peek() {\\n        // If num is not -1, then return the num value\\n        if (num != -1) return num;\\n\\n        // Store the next value in num and return it\\n        num = next();\\n        return num;\\n    }\\n\\n    // hasNext() and next() should behave the same as in the Iterator interface.\\n    // Override them if needed.\\n    int next() {\\n        // If num is not -1, then return value of num and make num as -1\\n        if (num != -1) {\\n            int temp = num;\\n            num = -1;\\n            return temp;\\n        }\\n\\n        // If num is -1, then take the next element from the Iterator\\n        return Iterator::next();\\n    }\\n\\n    // Return true the iterator has next element\\n    bool hasNext() const {\\n        return (num != -1 || Iterator::hasNext());\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1981427,
                "title": "simple-vector-implementation",
                "content": "Have done this question using vector only.\\n\\nIf found helpful, please do **upvote**.\\n\\n```\\n/*\\n * Below is the interface for Iterator, which is already defined for you.\\n * **DO NOT** modify the interface for Iterator.\\n *\\n *  class Iterator {\\n *\\t\\tstruct Data;\\n * \\t\\tData* data;\\n *  public:\\n *\\t\\tIterator(const vector<int>& nums);\\n * \\t\\tIterator(const Iterator& iter);\\n *\\n * \\t\\t// Returns the next element in the iteration.\\n *\\t\\tint next();\\n *\\n *\\t\\t// Returns true if the iteration has more elements.\\n *\\t\\tbool hasNext() const;\\n *\\t};\\n */\\n\\nclass PeekingIterator : public Iterator {\\npublic:\\n    vector<int> v;\\n    int i;\\n\\tPeekingIterator(const vector<int>& nums) : Iterator(nums) {\\n\\t    // Initialize any member here.\\n\\t    // **DO NOT** save a copy of nums and manipulate it directly.\\n\\t    // You should only use the Iterator interface methods.\\n        v = nums;\\n        i = 0;\\n\\t}\\n\\t\\n    // Returns the next element in the iteration without advancing the iterator.\\n\\tint peek() {\\n        return v[i];\\n\\t}\\n\\t\\n\\t// hasNext() and next() should behave the same as in the Iterator interface.\\n\\t// Override them if needed.\\n\\tint next() {\\n\\t    int x = v[i];\\n        i++;\\n        return x;\\n\\t}\\n\\t\\n\\tbool hasNext() const {\\n\\t    return i >= v.size() ? false : true;\\n\\t}\\n};\\n\\n```\\n\\nThanks for reading.\\n\\n",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\n/*\\n * Below is the interface for Iterator, which is already defined for you.\\n * **DO NOT** modify the interface for Iterator.\\n *\\n *  class Iterator {\\n *\\t\\tstruct Data;\\n * \\t\\tData* data;\\n *  public:\\n *\\t\\tIterator(const vector<int>& nums);\\n * \\t\\tIterator(const Iterator& iter);\\n *\\n * \\t\\t// Returns the next element in the iteration.\\n *\\t\\tint next();\\n *\\n *\\t\\t// Returns true if the iteration has more elements.\\n *\\t\\tbool hasNext() const;\\n *\\t};\\n */\\n\\nclass PeekingIterator : public Iterator {\\npublic:\\n    vector<int> v;\\n    int i;\\n\\tPeekingIterator(const vector<int>& nums) : Iterator(nums) {\\n\\t    // Initialize any member here.\\n\\t    // **DO NOT** save a copy of nums and manipulate it directly.\\n\\t    // You should only use the Iterator interface methods.\\n        v = nums;\\n        i = 0;\\n\\t}\\n\\t\\n    // Returns the next element in the iteration without advancing the iterator.\\n\\tint peek() {\\n        return v[i];\\n\\t}\\n\\t\\n\\t// hasNext() and next() should behave the same as in the Iterator interface.\\n\\t// Override them if needed.\\n\\tint next() {\\n\\t    int x = v[i];\\n        i++;\\n        return x;\\n\\t}\\n\\t\\n\\tbool hasNext() const {\\n\\t    return i >= v.size() ? false : true;\\n\\t}\\n};\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1981376,
                "title": "kotlin-solution-easy-simple",
                "content": "```\\n\\tval iter = iterator\\n    var curr = iter.next()\\n\\n    fun peek() = curr\\n\\n    override fun next(): Int {\\n        val prev = curr\\n        curr = if(iter.hasNext()) iter.next() else -1\\n\\n        return prev\\n    }\\n\\n    override fun hasNext() = curr != -1\\n```",
                "solutionTags": [
                    "Kotlin"
                ],
                "code": "```\\n\\tval iter = iterator\\n    var curr = iter.next()\\n\\n    fun peek() = curr\\n\\n    override fun next(): Int {\\n        val prev = curr\\n        curr = if(iter.hasNext()) iter.next() else -1\\n\\n        return prev\\n    }\\n\\n    override fun hasNext() = curr != -1\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1981349,
                "title": "javascript",
                "content": "```\\nvar PeekingIterator = function(iterator) {\\n    this.iterator = iterator;\\n    this.currentValue = undefined;\\n};\\n\\n/**\\n * Returns the next element in the array without moving the pointer.\\n * @return {number}\\n */\\nPeekingIterator.prototype.peek = function() {\\n    // if currentValue === undefined, it means that \\n    // the value doesn\\'t exist yet ---> bring it using \\'next()\\';\\n    // otherwise there were multiple \\'peek()\\' in a row ---> \\n    // they all should return the same value\\n    \\n    if(this.currentValue === undefined){\\n        this.currentValue = this.iterator.next();\\n    }\\n    \\n    return this.currentValue;\\n};\\n\\n/**\\n * @return {number}\\n */\\nPeekingIterator.prototype.next = function() {\\n    if(this.currentValue === undefined){\\n        return this.iterator.next();\\n    }\\n    \\n    // the current value was previously received in \\'peek()\\'\\n    const val = this.currentValue;\\n    this.currentValue = undefined;\\n    return val;\\n};\\n\\n/**\\n * @return {boolean}\\n */\\nPeekingIterator.prototype.hasNext = function() {\\n    // if current value !== undefined --->\\n    // the current value was previously received in \\'peek()\\'\\n    return this.currentValue === undefined ? this.iterator.hasNext() : true;\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\nvar PeekingIterator = function(iterator) {\\n    this.iterator = iterator;\\n    this.currentValue = undefined;\\n};\\n\\n/**\\n * Returns the next element in the array without moving the pointer.\\n * @return {number}\\n */\\nPeekingIterator.prototype.peek = function() {\\n    // if currentValue === undefined, it means that \\n    // the value doesn\\'t exist yet ---> bring it using \\'next()\\';\\n    // otherwise there were multiple \\'peek()\\' in a row ---> \\n    // they all should return the same value\\n    \\n    if(this.currentValue === undefined){\\n        this.currentValue = this.iterator.next();\\n    }\\n    \\n    return this.currentValue;\\n};\\n\\n/**\\n * @return {number}\\n */\\nPeekingIterator.prototype.next = function() {\\n    if(this.currentValue === undefined){\\n        return this.iterator.next();\\n    }\\n    \\n    // the current value was previously received in \\'peek()\\'\\n    const val = this.currentValue;\\n    this.currentValue = undefined;\\n    return val;\\n};\\n\\n/**\\n * @return {boolean}\\n */\\nPeekingIterator.prototype.hasNext = function() {\\n    // if current value !== undefined --->\\n    // the current value was previously received in \\'peek()\\'\\n    return this.currentValue === undefined ? this.iterator.hasNext() : true;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1981327,
                "title": "python-easy-to-understand-solution",
                "content": "\\t# Below is the interface for Iterator, which is already defined for you.\\n\\t#\\n\\t# class Iterator:\\n\\t#     def __init__(self, nums):\\n\\t#         \"\"\"\\n\\t#         Initializes an iterator object to the beginning of a list.\\n\\t#         :type nums: List[int]\\n\\t#         \"\"\"\\n\\t#\\n\\t#     def hasNext(self):\\n\\t#         \"\"\"\\n\\t#         Returns true if the iteration has more elements.\\n\\t#         :rtype: bool\\n\\t#         \"\"\"\\n\\t#\\n\\t#     def next(self):\\n\\t#         \"\"\"\\n\\t#         Returns the next element in the iteration.\\n\\t#         :rtype: int\\n\\t#         \"\"\"\\n\\n\\tclass PeekingIterator:\\n\\t\\tdef __init__(self, iterator):\\n\\t\\t\\t\"\"\"\\n\\t\\t\\tInitialize your data structure here.\\n\\t\\t\\t:type iterator: Iterator\\n\\t\\t\\t\"\"\"\\n\\t\\t\\tself.iterator=iterator\\n\\t\\t\\tself.cache=[]\\n\\n\\n\\t\\tdef peek(self):\\n\\t\\t\\t\"\"\"\\n\\t\\t\\tReturns the next element in the iteration without advancing the iterator.\\n\\t\\t\\t:rtype: int\\n\\t\\t\\t\"\"\"\\n\\t\\t\\tif not self.cache:\\n\\t\\t\\t\\tself.cache.append(self.iterator.next())\\n\\t\\t\\treturn self.cache[0]\\n\\n\\n\\t\\tdef next(self):\\n\\t\\t\\t\"\"\"\\n\\t\\t\\t:rtype: int\\n\\t\\t\\t\"\"\"\\n\\t\\t\\tif self.cache:\\n\\t\\t\\t\\treturn self.cache.pop()\\n\\t\\t\\treturn self.iterator.next()\\n\\n\\n\\t\\tdef hasNext(self):\\n\\t\\t\\t\"\"\"\\n\\t\\t\\t:rtype: bool\\n\\t\\t\\t\"\"\"\\n\\t\\t\\tif self.cache or self.iterator.hasNext():\\n\\t\\t\\t\\treturn True\\n\\t\\t\\treturn False\\n\\n\\n\\t# Your PeekingIterator object will be instantiated and called as such:\\n\\t# iter = PeekingIterator(Iterator(nums))\\n\\t# while iter.hasNext():\\n\\t#     val = iter.peek()   # Get the next element but not advance the iterator.\\n\\t#     iter.next()         # Should return the same value as [val].",
                "solutionTags": [],
                "code": "\\t# Below is the interface for Iterator, which is already defined for you.\\n\\t#\\n\\t# class Iterator:\\n\\t#     def __init__(self, nums):\\n\\t#         \"\"\"\\n\\t#         Initializes an iterator object to the beginning of a list.\\n\\t#         :type nums: List[int]\\n\\t#         \"\"\"\\n\\t#\\n\\t#     def hasNext(self):\\n\\t#         \"\"\"\\n\\t#         Returns true if the iteration has more elements.\\n\\t#         :rtype: bool\\n\\t#         \"\"\"\\n\\t#\\n\\t#     def next(self):\\n\\t#         \"\"\"\\n\\t#         Returns the next element in the iteration.\\n\\t#         :rtype: int\\n\\t#         \"\"\"\\n\\n\\tclass PeekingIterator:\\n\\t\\tdef __init__(self, iterator):\\n\\t\\t\\t\"\"\"\\n\\t\\t\\tInitialize your data structure here.\\n\\t\\t\\t:type iterator: Iterator\\n\\t\\t\\t\"\"\"\\n\\t\\t\\tself.iterator=iterator\\n\\t\\t\\tself.cache=[]\\n\\n\\n\\t\\tdef peek(self):\\n\\t\\t\\t\"\"\"\\n\\t\\t\\tReturns the next element in the iteration without advancing the iterator.\\n\\t\\t\\t:rtype: int\\n\\t\\t\\t\"\"\"\\n\\t\\t\\tif not self.cache:\\n\\t\\t\\t\\tself.cache.append(self.iterator.next())\\n\\t\\t\\treturn self.cache[0]\\n\\n\\n\\t\\tdef next(self):\\n\\t\\t\\t\"\"\"\\n\\t\\t\\t:rtype: int\\n\\t\\t\\t\"\"\"\\n\\t\\t\\tif self.cache:\\n\\t\\t\\t\\treturn self.cache.pop()\\n\\t\\t\\treturn self.iterator.next()\\n\\n\\n\\t\\tdef hasNext(self):\\n\\t\\t\\t\"\"\"\\n\\t\\t\\t:rtype: bool\\n\\t\\t\\t\"\"\"\\n\\t\\t\\tif self.cache or self.iterator.hasNext():\\n\\t\\t\\t\\treturn True\\n\\t\\t\\treturn False\\n\\n\\n\\t# Your PeekingIterator object will be instantiated and called as such:\\n\\t# iter = PeekingIterator(Iterator(nums))\\n\\t# while iter.hasNext():\\n\\t#     val = iter.peek()   # Get the next element but not advance the iterator.\\n\\t#     iter.next()         # Should return the same value as [val].",
                "codeTag": "Java"
            },
            {
                "id": 1981318,
                "title": "c-easy-to-understand-faster-than-80",
                "content": "```class PeekingIterator : public Iterator {\\npublic:\\n    int i=-1,n;\\n      vector<int>num;\\n\\tPeekingIterator(const vector<int>& nums) : Iterator(nums) {\\n\\t       num=nums;\\n           n=nums.size();\\n\\t}\\n\\t\\n    // Returns the next element in the iteration without advancing the iterator.\\n\\tint peek() {\\n        int j=i+1;\\n        return num[j];\\n\\t}\\n\\t\\n\\t// hasNext() and next() should behave the same as in the Iterator interface.\\n\\t// Override them if needed.\\n\\tint next() {\\n        i++;\\n\\t    return num[i];\\n\\t}\\n\\t\\n\\tbool hasNext() const {\\n\\t    if(i==n-1)\\n            return false;\\n        return true;\\n\\t}\\n};",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```class PeekingIterator : public Iterator {\\npublic:\\n    int i=-1,n;\\n      vector<int>num;\\n\\tPeekingIterator(const vector<int>& nums) : Iterator(nums) {\\n\\t       num=nums;\\n           n=nums.size();\\n\\t}\\n\\t\\n    // Returns the next element in the iteration without advancing the iterator.\\n\\tint peek() {\\n        int j=i+1;\\n        return num[j];\\n\\t}\\n\\t\\n\\t// hasNext() and next() should behave the same as in the Iterator interface.\\n\\t// Override them if needed.\\n\\tint next() {\\n        i++;\\n\\t    return num[i];\\n\\t}\\n\\t\\n\\tbool hasNext() const {\\n\\t    if(i==n-1)\\n            return false;\\n        return true;\\n\\t}\\n};",
                "codeTag": "Java"
            },
            {
                "id": 1981192,
                "title": "ruby-with-or-without-cheating-trick",
                "content": "Ruby has `instance_variable_get` which allows you to violate the OOP principles. Here\\'s how you can use it to solve this problem:\\n\\n```ruby\\nclass PeekingIterator\\n  # @param {Iterator} iter\\n  def initialize(iter)\\n    @iterator = iter\\n  end\\n\\n  # Returns true if the iteration has more elements.\\n  # @return {boolean}\\n  def hasNext()\\n    @iterator.hasNext\\n  end\\n\\n  # Returns the next element in the iteration.\\n  # @return {integer}\\n  def next()\\n    @iterator.next\\n  end\\n\\n  # Returns the next element in the iteration without advancing the iterator.\\n  # @return {integer}\\n  def peek()\\n    return @iterator.instance_variable_get(:@v)[@iterator.instance_variable_get(:@index)]\\n  end\\nend\\n```\\n\\nNow, without the trick. The idea is to always keep the next value in the peek and update it when `PeekingIterator#next` is called:\\n\\n```ruby\\nclass PeekingIterator\\n  # @param {Iterator} iter\\n  def initialize(iter)\\n    @iterator = iter\\n    @peek = @iterator.next\\n  end\\n\\n  # Returns true if the iteration has more elements.\\n  # @return {boolean}\\n  def hasNext()\\n    return @peek > 0\\n  end\\n\\n  # Returns the next element in the iteration.\\n  # @return {integer}\\n  def next()\\n    next_num = @peek\\n    @peek = @iterator.next\\n    return next_num\\n  end\\n\\n  # Returns the next element in the iteration without advancing the iterator.\\n  # @return {integer}\\n  def peek()\\n    return @peek\\n  end\\nend\\n```",
                "solutionTags": [
                    "Ruby"
                ],
                "code": "```ruby\\nclass PeekingIterator\\n  # @param {Iterator} iter\\n  def initialize(iter)\\n    @iterator = iter\\n  end\\n\\n  # Returns true if the iteration has more elements.\\n  # @return {boolean}\\n  def hasNext()\\n    @iterator.hasNext\\n  end\\n\\n  # Returns the next element in the iteration.\\n  # @return {integer}\\n  def next()\\n    @iterator.next\\n  end\\n\\n  # Returns the next element in the iteration without advancing the iterator.\\n  # @return {integer}\\n  def peek()\\n    return @iterator.instance_variable_get(:@v)[@iterator.instance_variable_get(:@index)]\\n  end\\nend\\n```\n```ruby\\nclass PeekingIterator\\n  # @param {Iterator} iter\\n  def initialize(iter)\\n    @iterator = iter\\n    @peek = @iterator.next\\n  end\\n\\n  # Returns true if the iteration has more elements.\\n  # @return {boolean}\\n  def hasNext()\\n    return @peek > 0\\n  end\\n\\n  # Returns the next element in the iteration.\\n  # @return {integer}\\n  def next()\\n    next_num = @peek\\n    @peek = @iterator.next\\n    return next_num\\n  end\\n\\n  # Returns the next element in the iteration without advancing the iterator.\\n  # @return {integer}\\n  def peek()\\n    return @peek\\n  end\\nend\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1981163,
                "title": "java-beats-100",
                "content": "```\\nclass PeekingIterator implements Iterator<Integer> {\\n    Iterator<Integer> iterator;\\n    Integer peek;\\n\\tpublic PeekingIterator(Iterator<Integer> iterator) {\\n\\t    this.iterator=iterator;\\n        if(iterator.hasNext()){\\n            peek=iterator.next();\\n        }\\n\\t    \\n\\t}\\n\\t\\n\\tpublic Integer peek() {\\n        return peek;\\n\\t}\\n\\t\\n\\t@Override\\n\\tpublic Integer next() {\\n\\t    Integer next = peek;\\n        if(iterator.hasNext()){\\n            peek=iterator.next();\\n        }else{\\n            peek=null;\\n        }\\n        return next;\\n\\t}\\n\\t\\n\\t@Override\\n\\tpublic boolean hasNext() {\\n\\t    return peek!=null;\\n\\t}\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass PeekingIterator implements Iterator<Integer> {\\n    Iterator<Integer> iterator;\\n    Integer peek;\\n\\tpublic PeekingIterator(Iterator<Integer> iterator) {\\n\\t    this.iterator=iterator;\\n        if(iterator.hasNext()){\\n            peek=iterator.next();\\n        }\\n\\t    \\n\\t}\\n\\t\\n\\tpublic Integer peek() {\\n        return peek;\\n\\t}\\n\\t\\n\\t@Override\\n\\tpublic Integer next() {\\n\\t    Integer next = peek;\\n        if(iterator.hasNext()){\\n            peek=iterator.next();\\n        }else{\\n            peek=null;\\n        }\\n        return next;\\n\\t}\\n\\t\\n\\t@Override\\n\\tpublic boolean hasNext() {\\n\\t    return peek!=null;\\n\\t}\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1981160,
                "title": "easy-java-solution",
                "content": "\\'\\'\\'\\nimport java.util.NoSuchElementException;\\n\\nclass PeekingIterator implements Iterator<Integer> {\\n\\n    private Iterator<Integer> iter;\\n    private Integer peekedValue = null;\\n\\n    public PeekingIterator(Iterator<Integer> iterator) {\\n        iter = iterator;\\n    }\\n\\n    public Integer peek() {\\n        if (peekedValue == null) {\\n            if (!iter.hasNext()) {\\n                throw new NoSuchElementException();\\n            }\\n            \\n            peekedValue = iter.next();\\n        }\\n        return peekedValue;\\n    }\\n\\n    @Override\\n    public Integer next() {\\n       \\n        if (peekedValue != null) {\\n            Integer toReturn = peekedValue;\\n            peekedValue = null;\\n            return toReturn;\\n        }\\n      if (!iter.hasNext()) {\\n            throw new NoSuchElementException();\\n        }\\n        \\n        return iter.next();\\n    }\\n\\n    @Override\\n    public boolean hasNext() {\\n        return peekedValue != null || iter.hasNext();\\n    }\\n}\\n\\'\\'\\'",
                "solutionTags": [],
                "code": "\\'\\'\\'\\nimport java.util.NoSuchElementException;\\n\\nclass PeekingIterator implements Iterator<Integer> {\\n\\n    private Iterator<Integer> iter;\\n    private Integer peekedValue = null;\\n\\n    public PeekingIterator(Iterator<Integer> iterator) {\\n        iter = iterator;\\n    }\\n\\n    public Integer peek() {\\n        if (peekedValue == null) {\\n            if (!iter.hasNext()) {\\n                throw new NoSuchElementException();\\n            }\\n            \\n            peekedValue = iter.next();\\n        }\\n        return peekedValue;\\n    }\\n\\n    @Override\\n    public Integer next() {\\n       \\n        if (peekedValue != null) {\\n            Integer toReturn = peekedValue;\\n            peekedValue = null;\\n            return toReturn;\\n        }\\n      if (!iter.hasNext()) {\\n            throw new NoSuchElementException();\\n        }\\n        \\n        return iter.next();\\n    }\\n\\n    @Override\\n    public boolean hasNext() {\\n        return peekedValue != null || iter.hasNext();\\n    }\\n}\\n\\'\\'\\'",
                "codeTag": "Java"
            },
            {
                "id": 1981114,
                "title": "vector-imlementation-c",
                "content": "```\\nvector <int>temp;\\nint i;\\n\\nPeekingIterator(const vector<int>& nums) : Iterator(nums) \\n{\\n    temp = nums;\\n    i = 0;\\n}\\n\\nint peek() \\n{\\n    return temp[i];\\n}\\n\\nint next() \\n{\\n    return temp[i++];\\n}\\n\\nbool hasNext() const \\n{\\n    return i >= temp.size() ? false : true;\\n}\\n ```",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nvector <int>temp;\\nint i;\\n\\nPeekingIterator(const vector<int>& nums) : Iterator(nums) \\n{\\n    temp = nums;\\n    i = 0;\\n}\\n\\nint peek() \\n{\\n    return temp[i];\\n}\\n\\nint next() \\n{\\n    return temp[i++];\\n}\\n\\nbool hasNext() const \\n{\\n    return i >= temp.size() ? false : true;\\n}\\n ```",
                "codeTag": "Unknown"
            },
            {
                "id": 1981078,
                "title": "for-c-how-would-you-do-it-with-generics",
                "content": "how would you do the follow up? in c# with generics I tried this: but its not right, \\n\\nwhat does this error mean? using the generic type \\'PeekingIterator<T>\\' requires 1 type argument\\n\\n```\\nclass PeekingIterator<T> {\\n    // iterators refers to the first element of the array.\\n    \\n    private IEnumerator<T> _iterator; \\n    private int _count; \\n    private int _current;\\n    \\n    public PeekingIterator(IEnumerator<T> iterator) {\\n        // initialize any member here.\\n        _iterator = iterator;\\n        _count = 0;\\n        _current = 0; \\n        //_iterator.MoveNext(); \\n        do\\n        {\\n            _count++; \\n        }while(_iterator.MoveNext());\\n        \\n        _iterator.Reset(); \\n        _iterator.MoveNext();\\n    }\\n    \\n    // Returns the next element in the iteration without advancing the iterator.\\n    public T Peek() {\\n        \\n        return _iterator.Current;\\n    }\\n    \\n    // Returns the next element in the iteration and advances the iterator.\\n    public T Next() {\\n        \\n        T val = _iterator.Current ;\\n        _iterator.MoveNext();\\n        _current++;\\n        return val; \\n    }\\n    \\n    // Returns false if the iterator is refering to the end of the array of true otherwise.\\n    public bool HasNext() {\\n        //Console.WriteLine(\"count: \" + _count);\\n       // Console.WriteLine(\"current: \" + _current);\\n       // Console.WriteLine();\\n\\t\\treturn _current < _count;\\n    }\\n}",
                "solutionTags": [],
                "code": "how would you do the follow up? in c# with generics I tried this: but its not right, \\n\\nwhat does this error mean? using the generic type \\'PeekingIterator<T>\\' requires 1 type argument\\n\\n```\\nclass PeekingIterator<T> {\\n    // iterators refers to the first element of the array.\\n    \\n    private IEnumerator<T> _iterator; \\n    private int _count; \\n    private int _current;\\n    \\n    public PeekingIterator(IEnumerator<T> iterator) {\\n        // initialize any member here.\\n        _iterator = iterator;\\n        _count = 0;\\n        _current = 0; \\n        //_iterator.MoveNext(); \\n        do\\n        {\\n            _count++; \\n        }while(_iterator.MoveNext());\\n        \\n        _iterator.Reset(); \\n        _iterator.MoveNext();\\n    }\\n    \\n    // Returns the next element in the iteration without advancing the iterator.\\n    public T Peek() {\\n        \\n        return _iterator.Current;\\n    }\\n    \\n    // Returns the next element in the iteration and advances the iterator.\\n    public T Next() {\\n        \\n        T val = _iterator.Current ;\\n        _iterator.MoveNext();\\n        _current++;\\n        return val; \\n    }\\n    \\n    // Returns false if the iterator is refering to the end of the array of true otherwise.\\n    public bool HasNext() {\\n        //Console.WriteLine(\"count: \" + _count);\\n       // Console.WriteLine(\"current: \" + _current);\\n       // Console.WriteLine();\\n\\t\\treturn _current < _count;\\n    }\\n}",
                "codeTag": "Java"
            },
            {
                "id": 1981055,
                "title": "c-easy-solution-using-2-method",
                "content": "**Method 1:**\\n\\n```\\nclass PeekingIterator : public Iterator {\\n    int next_val; // keep a variable for storing the \"next value\" for use in \"peek\" function\\n    bool iter_hasnext; // for storing the \"has next value\"\\npublic:\\n\\tPeekingIterator(const vector<int>& nums) : Iterator(nums) \\n    {\\n        iter_hasnext=Iterator::hasNext(); // store current has_next value\\n\\t    if (iter_hasnext)\\n      next_val = Iterator::next(); //store the \"next_val\" for \"future\" use in \"peek\" function\\n\\t}\\n\\t\\n\\tint peek() \\n    {\\n        return next_val; // return current next_val\\n\\t}\\n\\t\\n\\tint next() \\n    {\\n\\t    int curr_next = next_val; // store the current next for returning\\n        \\n        iter_hasnext=Iterator::hasNext(); // change the iter_hasnext variable\\n\\t    if (iter_hasnext) \\n        next_val = Iterator::next(); //change the next_val and move the iterator to next position\\n        \\n\\t    return curr_next; // return the previously stored current next\\n\\t}\\n\\t\\n\\tbool hasNext() const \\n    {\\n\\t    return iter_hasnext; // return current iter_hashnext value\\n\\t}\\n};\\n```\\n\\nMethod 2:\\nUploading Soon ....",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass PeekingIterator : public Iterator {\\n    int next_val; // keep a variable for storing the \"next value\" for use in \"peek\" function\\n    bool iter_hasnext; // for storing the \"has next value\"\\npublic:\\n\\tPeekingIterator(const vector<int>& nums) : Iterator(nums) \\n    {\\n        iter_hasnext=Iterator::hasNext(); // store current has_next value\\n\\t    if (iter_hasnext)\\n      next_val = Iterator::next(); //store the \"next_val\" for \"future\" use in \"peek\" function\\n\\t}\\n\\t\\n\\tint peek() \\n    {\\n        return next_val; // return current next_val\\n\\t}\\n\\t\\n\\tint next() \\n    {\\n\\t    int curr_next = next_val; // store the current next for returning\\n        \\n        iter_hasnext=Iterator::hasNext(); // change the iter_hasnext variable\\n\\t    if (iter_hasnext) \\n        next_val = Iterator::next(); //change the next_val and move the iterator to next position\\n        \\n\\t    return curr_next; // return the previously stored current next\\n\\t}\\n\\t\\n\\tbool hasNext() const \\n    {\\n\\t    return iter_hasnext; // return current iter_hashnext value\\n\\t}\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1980680,
                "title": "cpp-easy-short",
                "content": "/*\\n * Below is the interface for Iterator, which is already defined for you.\\n * **DO NOT** modify the interface for Iterator.\\n *\\n *  class Iterator {\\n *\\t\\tstruct Data;\\n * \\t\\tData* data;\\n *  public:\\n *\\t\\tIterator(const vector<int>& nums);\\n * \\t\\tIterator(const Iterator& iter);\\n *\\n * \\t\\t// Returns the next element in the iteration.\\n *\\t\\tint next();\\n *\\n *\\t\\t// Returns true if the iteration has more elements.\\n *\\t\\tbool hasNext() const;\\n *\\t};\\n */\\n\\nclass PeekingIterator : public Iterator {\\npublic:\\n\\tPeekingIterator(const vector<int>& nums) : Iterator(nums) {\\n\\t    // Initialize any member here.\\n\\t    // **DO NOT** save a copy of nums and manipulate it directly.\\n\\t    // You should only use the Iterator interface methods.\\n\\t    \\n\\t}\\n\\t\\n    // Returns the next element in the iteration without advancing the iterator.\\n\\tint peek() {\\n        Iterator it=(*this);\\n        return it.next();\\n\\t}\\n\\t\\n\\t// hasNext() and next() should behave the same as in the Iterator interface.\\n\\t// Override them if needed.\\n\\tint next() {\\n\\t    return  Iterator:: next();\\n\\t}\\n\\t\\n\\tbool hasNext() const {\\n\\t    return Iterator::hasNext();\\n\\t}\\n};",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "/*\\n * Below is the interface for Iterator, which is already defined for you.\\n * **DO NOT** modify the interface for Iterator.\\n *\\n *  class Iterator {\\n *\\t\\tstruct Data;\\n * \\t\\tData* data;\\n *  public:\\n *\\t\\tIterator(const vector<int>& nums);\\n * \\t\\tIterator(const Iterator& iter);\\n *\\n * \\t\\t// Returns the next element in the iteration.\\n *\\t\\tint next();\\n *\\n *\\t\\t// Returns true if the iteration has more elements.\\n *\\t\\tbool hasNext() const;\\n *\\t};\\n */\\n\\nclass PeekingIterator : public Iterator {\\npublic:\\n\\tPeekingIterator(const vector<int>& nums) : Iterator(nums) {\\n\\t    // Initialize any member here.\\n\\t    // **DO NOT** save a copy of nums and manipulate it directly.\\n\\t    // You should only use the Iterator interface methods.\\n\\t    \\n\\t}\\n\\t\\n    // Returns the next element in the iteration without advancing the iterator.\\n\\tint peek() {\\n        Iterator it=(*this);\\n        return it.next();\\n\\t}\\n\\t\\n\\t// hasNext() and next() should behave the same as in the Iterator interface.\\n\\t// Override them if needed.\\n\\tint next() {\\n\\t    return  Iterator:: next();\\n\\t}\\n\\t\\n\\tbool hasNext() const {\\n\\t    return Iterator::hasNext();\\n\\t}\\n};",
                "codeTag": "Java"
            },
            {
                "id": 1980596,
                "title": "c-using-optional",
                "content": "I prefer making the implementation as lazy as possible (if Iterator::next() would be time-consuming for example) by caching values on demand only, and I thought this was an excellent use for std::optional, to avoid the pitfalls of null that the reference solution mentions.\\n\\n```\\n#include <optional>\\n\\nclass PeekingIterator : public Iterator {\\npublic:\\n\\tPeekingIterator(const vector<int>& nums) : Iterator(nums) {\\n\\t}\\n\\t\\n\\tint peek() {\\n        if (!cachedNext.has_value()) {\\n            cachedNext = Iterator::next();\\n        }\\n        return cachedNext.value();\\n\\t}\\n\\t\\n\\tint next() {\\n        if (cachedNext.has_value()) {\\n            auto temp = cachedNext.value();\\n            cachedNext.reset();\\n            return temp;\\n        } else {\\n            return Iterator::next();\\n        }\\n\\t}\\n\\t\\n\\tbool hasNext() const {\\n\\t    return cachedNext.has_value() || Iterator::hasNext();\\n\\t}\\nprivate:\\n    \\n    std::optional<int> cachedNext;\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\n#include <optional>\\n\\nclass PeekingIterator : public Iterator {\\npublic:\\n\\tPeekingIterator(const vector<int>& nums) : Iterator(nums) {\\n\\t}\\n\\t\\n\\tint peek() {\\n        if (!cachedNext.has_value()) {\\n            cachedNext = Iterator::next();\\n        }\\n        return cachedNext.value();\\n\\t}\\n\\t\\n\\tint next() {\\n        if (cachedNext.has_value()) {\\n            auto temp = cachedNext.value();\\n            cachedNext.reset();\\n            return temp;\\n        } else {\\n            return Iterator::next();\\n        }\\n\\t}\\n\\t\\n\\tbool hasNext() const {\\n\\t    return cachedNext.has_value() || Iterator::hasNext();\\n\\t}\\nprivate:\\n    \\n    std::optional<int> cachedNext;\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 1980508,
                "title": "simple-swift-solution",
                "content": "```swift\\nclass PeekingIterator {\\n    \\n    private var it: IndexingIterator<Array<Int>>\\n    private var buf: Int?\\n    \\n    init(_ arr: IndexingIterator<Array<Int>>) {\\n        self.it = arr\\n        self.buf = it.next()\\n    }\\n    \\n    private func _next() -> Int {\\n        self.buf ?? 0\\n    }\\n    \\n    func next() -> Int {\\n        defer { self.buf = it.next() }\\n        return self._next() \\n    }\\n    \\n    func peek() -> Int {\\n        return self._next() \\n    }\\n    \\n    func hasNext() -> Bool {\\n        self.buf != nil\\n    }\\n    \\n}\\n```",
                "solutionTags": [
                    "Swift"
                ],
                "code": "```swift\\nclass PeekingIterator {\\n    \\n    private var it: IndexingIterator<Array<Int>>\\n    private var buf: Int?\\n    \\n    init(_ arr: IndexingIterator<Array<Int>>) {\\n        self.it = arr\\n        self.buf = it.next()\\n    }\\n    \\n    private func _next() -> Int {\\n        self.buf ?? 0\\n    }\\n    \\n    func next() -> Int {\\n        defer { self.buf = it.next() }\\n        return self._next() \\n    }\\n    \\n    func peek() -> Int {\\n        return self._next() \\n    }\\n    \\n    func hasNext() -> Bool {\\n        self.buf != nil\\n    }\\n    \\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1980489,
                "title": "easy-pointers-cpp",
                "content": "```\\n\\n\\nclass PeekingIterator : public Iterator {\\npublic:\\n    Iterator *x;\\n\\tPeekingIterator(const vector<int>& nums) : Iterator(nums) {\\n\\t    x=new Iterator(nums);\\n        \\n\\t}\\n\\t\\n    // Returns the next element in the iteration without advancing the iterator.\\n\\tint peek() {\\n        Iterator *t=new Iterator(*x);\\n        return t->next();\\n        \\n\\t}\\n\\t\\n\\t// hasNext() and next() should behave the same as in the Iterator interface.\\n\\t// Override them if needed.\\n\\tint next() {\\n\\t    return x->next();\\n\\t}\\n\\t\\n\\tbool hasNext() const {\\n\\t    return x->hasNext();\\n\\t}\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Iterator"
                ],
                "code": "```\\n\\n\\nclass PeekingIterator : public Iterator {\\npublic:\\n    Iterator *x;\\n\\tPeekingIterator(const vector<int>& nums) : Iterator(nums) {\\n\\t    x=new Iterator(nums);\\n        \\n\\t}\\n\\t\\n    // Returns the next element in the iteration without advancing the iterator.\\n\\tint peek() {\\n        Iterator *t=new Iterator(*x);\\n        return t->next();\\n        \\n\\t}\\n\\t\\n\\t// hasNext() and next() should behave the same as in the Iterator interface.\\n\\t// Override them if needed.\\n\\tint next() {\\n\\t    return x->next();\\n\\t}\\n\\t\\n\\tbool hasNext() const {\\n\\t    return x->hasNext();\\n\\t}\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1980471,
                "title": "doubt-for-run-time-error",
                "content": "can someone please explain that why I\\'m getting runtime error for the following code?\\n\\n```\\nclass PeekingIterator : public Iterator {\\npublic:\\n    vector<int>::const_iterator itr,endItr;\\n\\tPeekingIterator(const vector<int>& nums) : Iterator(nums) {\\n\\t    // Initialize any member here.\\n\\t    // *DO NOT* save a copy of nums and manipulate it directly.\\n\\t    // You should only use the Iterator interface methods.\\n\\t    itr = nums.begin();\\n\\t    endItr = nums.end();\\n\\t}\\n\\t\\n    // Returns the next element in the iteration without advancing the iterator.\\n\\tint peek() {\\n        return *(itr);\\n\\t}\\n\\t\\n\\t// hasNext() and next() should behave the same as in the Iterator interface.\\n\\t// Override them if needed.\\n\\tint next() {\\n\\t    return *(itr++);\\n\\t}\\n\\t\\n\\tbool hasNext() const {\\n\\t    return !(itr==endItr);\\n\\t}\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass PeekingIterator : public Iterator {\\npublic:\\n    vector<int>::const_iterator itr,endItr;\\n\\tPeekingIterator(const vector<int>& nums) : Iterator(nums) {\\n\\t    // Initialize any member here.\\n\\t    // *DO NOT* save a copy of nums and manipulate it directly.\\n\\t    // You should only use the Iterator interface methods.\\n\\t    itr = nums.begin();\\n\\t    endItr = nums.end();\\n\\t}\\n\\t\\n    // Returns the next element in the iteration without advancing the iterator.\\n\\tint peek() {\\n        return *(itr);\\n\\t}\\n\\t\\n\\t// hasNext() and next() should behave the same as in the Iterator interface.\\n\\t// Override them if needed.\\n\\tint next() {\\n\\t    return *(itr++);\\n\\t}\\n\\t\\n\\tbool hasNext() const {\\n\\t    return !(itr==endItr);\\n\\t}\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1980450,
                "title": "java-clean-code-easy-extra-2-variables-used",
                "content": "```\\nclass PeekingIterator implements Iterator<Integer> {\\n\\n    private boolean hasPeeked;\\n    private int peekedValue;\\n    private final Iterator<Integer> iterator;\\n\\n    public PeekingIterator(Iterator<Integer> iterator) {\\n        this.hasPeeked = false;\\n        this.iterator = iterator;\\n    }\\n\\n    public Integer peek() {\\n        if (!hasPeeked) {\\n            hasPeeked = true;\\n            peekedValue = iterator.next();\\n        }\\n        return peekedValue;\\n    }\\n\\n    @Override\\n    public Integer next() {\\n        if (hasPeeked) {\\n            hasPeeked = false;\\n            Integer value = peekedValue;\\n            peekedValue = -1;\\n            return value;\\n        }\\n        return iterator.next();\\n    }\\n\\n    @Override\\n    public boolean hasNext() {\\n        return hasPeeked || iterator.hasNext();\\n    }\\n}\\n\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass PeekingIterator implements Iterator<Integer> {\\n\\n    private boolean hasPeeked;\\n    private int peekedValue;\\n    private final Iterator<Integer> iterator;\\n\\n    public PeekingIterator(Iterator<Integer> iterator) {\\n        this.hasPeeked = false;\\n        this.iterator = iterator;\\n    }\\n\\n    public Integer peek() {\\n        if (!hasPeeked) {\\n            hasPeeked = true;\\n            peekedValue = iterator.next();\\n        }\\n        return peekedValue;\\n    }\\n\\n    @Override\\n    public Integer next() {\\n        if (hasPeeked) {\\n            hasPeeked = false;\\n            Integer value = peekedValue;\\n            peekedValue = -1;\\n            return value;\\n        }\\n        return iterator.next();\\n    }\\n\\n    @Override\\n    public boolean hasNext() {\\n        return hasPeeked || iterator.hasNext();\\n    }\\n}\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1980255,
                "title": "easy-java-solution",
                "content": "```\\nclass PeekingIterator implements Iterator<Integer> {\\n    Iterator<Integer> itr;\\n    Integer res;\\n\\tpublic PeekingIterator(Iterator<Integer> iterator) {\\n\\t    // initialize any member here.\\n        itr=iterator;\\n        if(itr.hasNext())\\n            res=itr.next();\\n\\t    \\n\\t}\\n\\t\\n    // Returns the next element in the iteration without advancing the iterator.\\n\\tpublic Integer peek() {\\n        return res;\\n\\t}\\n\\t\\n\\t// hasNext() and next() should behave the same as in the Iterator interface.\\n\\t// Override them if needed.\\n\\t@Override\\n\\tpublic Integer next() {\\n\\t    int next=res;\\n        res=itr.hasNext()?itr.next():null;\\n        return next;\\n\\t}\\n\\t\\n\\t@Override\\n\\tpublic boolean hasNext() {\\n\\t    return res!=null;\\n\\t}\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Design",
                    "Iterator"
                ],
                "code": "```\\nclass PeekingIterator implements Iterator<Integer> {\\n    Iterator<Integer> itr;\\n    Integer res;\\n\\tpublic PeekingIterator(Iterator<Integer> iterator) {\\n\\t    // initialize any member here.\\n        itr=iterator;\\n        if(itr.hasNext())\\n            res=itr.next();\\n\\t    \\n\\t}\\n\\t\\n    // Returns the next element in the iteration without advancing the iterator.\\n\\tpublic Integer peek() {\\n        return res;\\n\\t}\\n\\t\\n\\t// hasNext() and next() should behave the same as in the Iterator interface.\\n\\t// Override them if needed.\\n\\t@Override\\n\\tpublic Integer next() {\\n\\t    int next=res;\\n        res=itr.hasNext()?itr.next():null;\\n        return next;\\n\\t}\\n\\t\\n\\t@Override\\n\\tpublic boolean hasNext() {\\n\\t    return res!=null;\\n\\t}\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1980230,
                "title": "java-solution-commented",
                "content": "```\\nclass PeekingIterator implements Iterator<Integer> {\\n    private Integer cur; // cache the next value\\n    private Iterator<Integer> itr;\\n    \\n\\tpublic PeekingIterator(Iterator<Integer> iterator) {\\n\\t    // initialize any member here.\\n        itr = iterator;\\n        cur = itr.next(); // move the iterator ponter to find the first val.\\n\\t}\\n\\t\\n    // Returns the next element in the iteration without advancing the iterator.\\n\\tpublic Integer peek() {\\n        return cur;  \\n\\t}\\n\\t\\n\\t// hasNext() and next() should behave the same as in the Iterator interface.\\n\\t// Override them if needed.\\n\\t@Override\\n\\tpublic Integer next() {\\n\\t    Integer res = cur; // val to be returned; this is the next value\\n        if (itr.hasNext()) {\\n            cur = itr.next(); // cache the next peek\\n        }\\n        else {\\n            cur = null;\\n        }\\n        return res;\\n\\t}\\n\\t\\n\\t@Override\\n\\tpublic boolean hasNext() {\\n\\t    return cur != null; // when cache is null when pointer is end of iterator\\n\\t}\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass PeekingIterator implements Iterator<Integer> {\\n    private Integer cur; // cache the next value\\n    private Iterator<Integer> itr;\\n    \\n\\tpublic PeekingIterator(Iterator<Integer> iterator) {\\n\\t    // initialize any member here.\\n        itr = iterator;\\n        cur = itr.next(); // move the iterator ponter to find the first val.\\n\\t}\\n\\t\\n    // Returns the next element in the iteration without advancing the iterator.\\n\\tpublic Integer peek() {\\n        return cur;  \\n\\t}\\n\\t\\n\\t// hasNext() and next() should behave the same as in the Iterator interface.\\n\\t// Override them if needed.\\n\\t@Override\\n\\tpublic Integer next() {\\n\\t    Integer res = cur; // val to be returned; this is the next value\\n        if (itr.hasNext()) {\\n            cur = itr.next(); // cache the next peek\\n        }\\n        else {\\n            cur = null;\\n        }\\n        return res;\\n\\t}\\n\\t\\n\\t@Override\\n\\tpublic boolean hasNext() {\\n\\t    return cur != null; // when cache is null when pointer is end of iterator\\n\\t}\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1980225,
                "title": "c-simplest-solution-using-vector-and-count-variable",
                "content": "class PeekingIterator : public Iterator {\\npublic:\\n\\n    vector<int> v;\\n    int cnt=0;\\n\\tPeekingIterator(const vector<int>& nums) : Iterator(nums) {\\n\\t\\n\\t    for(int i=0;i<nums.size();i++)\\n        {\\n            v.push_back(nums[i]);\\n        }\\n\\t\\t\\n\\t}\\n\\t\\n\\tint peek() {\\n\\t\\n        return v[cnt];\\n\\t\\t\\n\\t}\\n\\t\\n\\tint next() {\\n\\t\\n\\t    return v[cnt++];\\n\\t\\t\\n\\t}\\n\\t\\n\\tbool hasNext() const {\\n\\t\\n\\t    if(cnt>=v.size())\\n        {\\n            return false;\\n        }\\n        else \\n        {\\n            return true;\\n        }\\n\\t\\t\\n\\t}\\n};",
                "solutionTags": [],
                "code": "class PeekingIterator : public Iterator {\\npublic:\\n\\n    vector<int> v;\\n    int cnt=0;\\n\\tPeekingIterator(const vector<int>& nums) : Iterator(nums) {\\n\\t\\n\\t    for(int i=0;i<nums.size();i++)\\n        {\\n            v.push_back(nums[i]);\\n        }\\n\\t\\t\\n\\t}\\n\\t\\n\\tint peek() {\\n\\t\\n        return v[cnt];\\n\\t\\t\\n\\t}\\n\\t\\n\\tint next() {\\n\\t\\n\\t    return v[cnt++];\\n\\t\\t\\n\\t}\\n\\t\\n\\tbool hasNext() const {\\n\\t\\n\\t    if(cnt>=v.size())\\n        {\\n            return false;\\n        }\\n        else \\n        {\\n            return true;\\n        }\\n\\t\\t\\n\\t}\\n};",
                "codeTag": "Java"
            },
            {
                "id": 1980187,
                "title": "understandable-c-solution-using-queue",
                "content": "I used queue instead of stack or any other data structure because we have to take out the first element first and go to the next element, we could have also used 2 stacks here.\\n\\nI hope solution isn\\'t too hard to understand. \\nMake sure you read the problem statement carefully.\\n\\nPlease Upvote it if you are satisfied.\\n\\n```\\nclass PeekingIterator : public Iterator {\\npublic:\\n    queue<int> q;\\n    \\n\\tPeekingIterator(const vector<int>& nums) : Iterator(nums) {\\n\\t    for(int i=0 ; i<nums.size() ; i++)\\n            q.push(nums[i]);\\n\\t}\\n\\t\\n\\tint peek() {\\n        return q.front();    \\n\\t}\\n\\t\\n\\tint next() {\\n\\t    int val = q.front();\\n        q.pop();\\n        return val;\\n\\t}\\n\\t\\n\\tbool hasNext() const {\\n\\t    if(q.size())\\n            return true;\\n        \\n        return false;\\n\\t}\\n};\\n```",
                "solutionTags": [
                    "Queue"
                ],
                "code": "```\\nclass PeekingIterator : public Iterator {\\npublic:\\n    queue<int> q;\\n    \\n\\tPeekingIterator(const vector<int>& nums) : Iterator(nums) {\\n\\t    for(int i=0 ; i<nums.size() ; i++)\\n            q.push(nums[i]);\\n\\t}\\n\\t\\n\\tint peek() {\\n        return q.front();    \\n\\t}\\n\\t\\n\\tint next() {\\n\\t    int val = q.front();\\n        q.pop();\\n        return val;\\n\\t}\\n\\t\\n\\tbool hasNext() const {\\n\\t    if(q.size())\\n            return true;\\n        \\n        return false;\\n\\t}\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1980065,
                "title": "java-deque-solution",
                "content": "```\\n// Java Iterator interface reference:\\n// https://docs.oracle.com/javase/8/docs/api/java/util/Iterator.html\\n\\nclass PeekingIterator implements Iterator<Integer> {\\n    Deque<Integer> save;\\n    public PeekingIterator(Iterator<Integer> iterator) {\\n        // initialize any member here.\\n        this.save = new ArrayDeque<>();\\n        while (iterator.hasNext()){\\n            save.add(iterator.next());\\n        }\\n    }\\n\\n    // Returns the next element in the iteration without advancing the iterator.\\n    public Integer peek() {\\n        return save.peekFirst();\\n    }\\n\\n    // hasNext() and next() should behave the same as in the Iterator interface.\\n    // Override them if needed.\\n    @Override\\n    public Integer next() {\\n        return save.removeFirst();\\n    }\\n\\n    @Override\\n    public boolean hasNext() {\\n        return !save.isEmpty();\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\n// Java Iterator interface reference:\\n// https://docs.oracle.com/javase/8/docs/api/java/util/Iterator.html\\n\\nclass PeekingIterator implements Iterator<Integer> {\\n    Deque<Integer> save;\\n    public PeekingIterator(Iterator<Integer> iterator) {\\n        // initialize any member here.\\n        this.save = new ArrayDeque<>();\\n        while (iterator.hasNext()){\\n            save.add(iterator.next());\\n        }\\n    }\\n\\n    // Returns the next element in the iteration without advancing the iterator.\\n    public Integer peek() {\\n        return save.peekFirst();\\n    }\\n\\n    // hasNext() and next() should behave the same as in the Iterator interface.\\n    // Override them if needed.\\n    @Override\\n    public Integer next() {\\n        return save.removeFirst();\\n    }\\n\\n    @Override\\n    public boolean hasNext() {\\n        return !save.isEmpty();\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1979928,
                "title": "java-easy-solution",
                "content": "```\\nclass PeekingIterator implements Iterator<Integer> {\\n    \\n    List<Integer> list;\\n\\tpublic PeekingIterator(Iterator<Integer> iterator) {\\n\\t    // initialize any member here.\\n\\t    list = new LinkedList<>();\\n        while(iterator.hasNext()){\\n            list.add(iterator.next());\\n        }\\n\\t}\\n\\t\\n    // Returns the next element in the iteration without advancing the iterator.\\n\\tpublic Integer peek() {\\n        if(list.size()>0)\\n            return list.get(0);\\n        return -1;\\n\\t}\\n\\t\\n\\t// hasNext() and next() should behave the same as in the Iterator interface.\\n\\t// Override them if needed.\\n\\t@Override\\n\\tpublic Integer next() {\\n        int num = -1;\\n\\t    if(list.size()>0)\\n            num = list.remove(0);\\n        return num;\\n\\t}\\n\\t\\n\\t@Override\\n\\tpublic boolean hasNext() {\\n\\t    return list.size()>0;\\n\\t}\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass PeekingIterator implements Iterator<Integer> {\\n    \\n    List<Integer> list;\\n\\tpublic PeekingIterator(Iterator<Integer> iterator) {\\n\\t    // initialize any member here.\\n\\t    list = new LinkedList<>();\\n        while(iterator.hasNext()){\\n            list.add(iterator.next());\\n        }\\n\\t}\\n\\t\\n    // Returns the next element in the iteration without advancing the iterator.\\n\\tpublic Integer peek() {\\n        if(list.size()>0)\\n            return list.get(0);\\n        return -1;\\n\\t}\\n\\t\\n\\t// hasNext() and next() should behave the same as in the Iterator interface.\\n\\t// Override them if needed.\\n\\t@Override\\n\\tpublic Integer next() {\\n        int num = -1;\\n\\t    if(list.size()>0)\\n            num = list.remove(0);\\n        return num;\\n\\t}\\n\\t\\n\\t@Override\\n\\tpublic boolean hasNext() {\\n\\t    return list.size()>0;\\n\\t}\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1979927,
                "title": "c-very-easy-solution",
                "content": "```\\nclass PeekingIterator : public Iterator {\\npublic:\\n    vector<int> v;\\n    int i=0;\\n\\tPeekingIterator(const vector<int>& nums) : Iterator(nums) {\\n\\t    v=nums;\\n\\t}\\n\\t\\n    // Returns the next element in the iteration without advancing the iterator.\\n\\tint peek() {\\n        return v[i];\\n\\t}\\n\\t\\n\\t// hasNext() and next() should behave the same as in the Iterator interface.\\n\\t// Override them if needed.\\n\\tint next() {\\n\\t    int k=v[i];\\n        i++;\\n        return k;\\n\\t}\\n\\t\\n\\tbool hasNext() const {\\n\\t    if(i>v.size()-1)\\n            return false;\\n        return true;\\n\\t}\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass PeekingIterator : public Iterator {\\npublic:\\n    vector<int> v;\\n    int i=0;\\n\\tPeekingIterator(const vector<int>& nums) : Iterator(nums) {\\n\\t    v=nums;\\n\\t}\\n\\t\\n    // Returns the next element in the iteration without advancing the iterator.\\n\\tint peek() {\\n        return v[i];\\n\\t}\\n\\t\\n\\t// hasNext() and next() should behave the same as in the Iterator interface.\\n\\t// Override them if needed.\\n\\tint next() {\\n\\t    int k=v[i];\\n        i++;\\n        return k;\\n\\t}\\n\\t\\n\\tbool hasNext() const {\\n\\t    if(i>v.size()-1)\\n            return false;\\n        return true;\\n\\t}\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1979891,
                "title": "easy-understanding-python-solution",
                "content": "All we have to do is to do the \"next\" operation first, and then... here we go ! \\n```\\n# Below is the interface for Iterator, which is already defined for you.\\n#\\n# class Iterator:\\n#     def __init__(self, nums):\\n#         \"\"\"\\n#         Initializes an iterator object to the beginning of a list.\\n#         :type nums: List[int]\\n#         \"\"\"\\n#\\n#     def hasNext(self):\\n#         \"\"\"\\n#         Returns true if the iteration has more elements.\\n#         :rtype: bool\\n#         \"\"\"\\n#\\n#     def next(self):\\n#         \"\"\"\\n#         Returns the next element in the iteration.\\n#         :rtype: int\\n#         \"\"\"\\n\\nclass PeekingIterator:\\n    def __init__(self, iterator):\\n        self.iter = iterator\\n        self.nxt = self.iter.next()\\n        \"\"\"\\n        Initialize your data structure here.\\n        :type iterator: Iterator\\n        \"\"\"\\n        \\n\\n    def peek(self):\\n        return self.nxt\\n        \"\"\"\\n        Returns the next element in the iteration without advancing the iterator.\\n        :rtype: int\\n        \"\"\"\\n        \\n\\n    def next(self):\\n        curr = self.nxt\\n        self.nxt = self.iter.next()\\n        return curr\\n        \"\"\"\\n        :rtype: int\\n        \"\"\"\\n        \\n\\n    def hasNext(self):\\n        # I don\\'t know why it is -10000 when having no next element lol\\n        return self.nxt is not -100000\\n        \"\"\"\\n        :rtype: bool\\n        \"\"\"\\n        \\n\\n# Your PeekingIterator object will be instantiated and called as such:\\n# iter = PeekingIterator(Iterator(nums))\\n# while iter.hasNext():\\n#     val = iter.peek()   # Get the next element but not advance the iterator.\\n#     iter.next()         # Should return the same value as [val].\\n```\\nIf you think it\\'s helpful to you, don\\'t forget to leave an upvote for me \\uD83D\\uDE01",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\n# Below is the interface for Iterator, which is already defined for you.\\n#\\n# class Iterator:\\n#     def __init__(self, nums):\\n#         \"\"\"\\n#         Initializes an iterator object to the beginning of a list.\\n#         :type nums: List[int]\\n#         \"\"\"\\n#\\n#     def hasNext(self):\\n#         \"\"\"\\n#         Returns true if the iteration has more elements.\\n#         :rtype: bool\\n#         \"\"\"\\n#\\n#     def next(self):\\n#         \"\"\"\\n#         Returns the next element in the iteration.\\n#         :rtype: int\\n#         \"\"\"\\n\\nclass PeekingIterator:\\n    def __init__(self, iterator):\\n        self.iter = iterator\\n        self.nxt = self.iter.next()\\n        \"\"\"\\n        Initialize your data structure here.\\n        :type iterator: Iterator\\n        \"\"\"\\n        \\n\\n    def peek(self):\\n        return self.nxt\\n        \"\"\"\\n        Returns the next element in the iteration without advancing the iterator.\\n        :rtype: int\\n        \"\"\"\\n        \\n\\n    def next(self):\\n        curr = self.nxt\\n        self.nxt = self.iter.next()\\n        return curr\\n        \"\"\"\\n        :rtype: int\\n        \"\"\"\\n        \\n\\n    def hasNext(self):\\n        # I don\\'t know why it is -10000 when having no next element lol\\n        return self.nxt is not -100000\\n        \"\"\"\\n        :rtype: bool\\n        \"\"\"\\n        \\n\\n# Your PeekingIterator object will be instantiated and called as such:\\n# iter = PeekingIterator(Iterator(nums))\\n# while iter.hasNext():\\n#     val = iter.peek()   # Get the next element but not advance the iterator.\\n#     iter.next()         # Should return the same value as [val].\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1979847,
                "title": "c-efficient-solution-tc-o-1-and-sc-o-n",
                "content": "```\\n/*\\n * Below is the interface for Iterator, which is already defined for you.\\n * **DO NOT** modify the interface for Iterator.\\n *\\n *  class Iterator {\\n *\\t\\tstruct Data;\\n * \\t\\tData* data;\\n *  public:\\n *\\t\\tIterator(const vector<int>& nums);\\n * \\t\\tIterator(const Iterator& iter);\\n *\\n * \\t\\t// Returns the next element in the iteration.\\n *\\t\\tint next();\\n *\\n *\\t\\t// Returns true if the iteration has more elements.\\n *\\t\\tbool hasNext() const;\\n *\\t};\\n */\\n\\nclass PeekingIterator : public Iterator {\\npublic:\\n    vector<int>vec;\\n    int idx;\\n\\tPeekingIterator(const vector<int>& nums) : Iterator(nums) {\\n\\t    // Initialize any member here.\\n\\t    // **DO NOT** save a copy of nums and manipulate it directly.\\n\\t    // You should only use the Iterator interface methods.\\n\\t     vec=nums;\\n         idx=0;\\n\\t}\\n\\t\\n    // Returns the next element in the iteration without advancing the iterator.\\n\\tint peek() {\\n        return vec[idx];\\n\\t}\\n\\t// hasNext() and next() should behave the same as in the Iterator interface.\\n\\t// Override them if needed.\\n\\tint next() {\\n\\t    return vec[idx++];\\n\\t}\\n\\t\\n\\tbool hasNext() const {\\n\\t    if(idx==vec.size()){\\n            return false;\\n        }\\n        return true;\\n\\t}\\n};\\n```",
                "solutionTags": [
                    "Iterator"
                ],
                "code": "```\\n/*\\n * Below is the interface for Iterator, which is already defined for you.\\n * **DO NOT** modify the interface for Iterator.\\n *\\n *  class Iterator {\\n *\\t\\tstruct Data;\\n * \\t\\tData* data;\\n *  public:\\n *\\t\\tIterator(const vector<int>& nums);\\n * \\t\\tIterator(const Iterator& iter);\\n *\\n * \\t\\t// Returns the next element in the iteration.\\n *\\t\\tint next();\\n *\\n *\\t\\t// Returns true if the iteration has more elements.\\n *\\t\\tbool hasNext() const;\\n *\\t};\\n */\\n\\nclass PeekingIterator : public Iterator {\\npublic:\\n    vector<int>vec;\\n    int idx;\\n\\tPeekingIterator(const vector<int>& nums) : Iterator(nums) {\\n\\t    // Initialize any member here.\\n\\t    // **DO NOT** save a copy of nums and manipulate it directly.\\n\\t    // You should only use the Iterator interface methods.\\n\\t     vec=nums;\\n         idx=0;\\n\\t}\\n\\t\\n    // Returns the next element in the iteration without advancing the iterator.\\n\\tint peek() {\\n        return vec[idx];\\n\\t}\\n\\t// hasNext() and next() should behave the same as in the Iterator interface.\\n\\t// Override them if needed.\\n\\tint next() {\\n\\t    return vec[idx++];\\n\\t}\\n\\t\\n\\tbool hasNext() const {\\n\\t    if(idx==vec.size()){\\n            return false;\\n        }\\n        return true;\\n\\t}\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1979826,
                "title": "java-simple-solution",
                "content": "Please UPVOTE\\'\\'\\'\\nclass PeekingIterator implements Iterator<Integer> {\\n    \\n    List<Integer> list;\\n\\tpublic PeekingIterator(Iterator<Integer> iterator) {\\n\\t    list = new LinkedList<>();\\n        while(iterator.hasNext()){\\n            list.add(iterator.next());\\n        }\\n\\t}\\n\\t\\n\\tpublic Integer peek() {\\n        if(list.size()>0)\\n            return list.get(0);\\n        return -1;\\n\\t}\\n\\t\\n\\t@Override\\n\\tpublic Integer next() {\\n        int num = -1;\\n\\t    if(list.size()>0)\\n            num = list.remove(0);\\n        return num;\\n\\t}\\n\\t\\n\\t@Override\\n\\tpublic boolean hasNext() {\\n\\t    return list.size()>0;\\n\\t}\\n}",
                "solutionTags": [],
                "code": "Please UPVOTE\\'\\'\\'\\nclass PeekingIterator implements Iterator<Integer> {\\n    \\n    List<Integer> list;\\n\\tpublic PeekingIterator(Iterator<Integer> iterator) {\\n\\t    list = new LinkedList<>();\\n        while(iterator.hasNext()){\\n            list.add(iterator.next());\\n        }\\n\\t}\\n\\t\\n\\tpublic Integer peek() {\\n        if(list.size()>0)\\n            return list.get(0);\\n        return -1;\\n\\t}\\n\\t\\n\\t@Override\\n\\tpublic Integer next() {\\n        int num = -1;\\n\\t    if(list.size()>0)\\n            num = list.remove(0);\\n        return num;\\n\\t}\\n\\t\\n\\t@Override\\n\\tpublic boolean hasNext() {\\n\\t    return list.size()>0;\\n\\t}\\n}",
                "codeTag": "Java"
            },
            {
                "id": 1979804,
                "title": "c-easy-solution",
                "content": "```\\nclass PeekingIterator : public Iterator {\\n    int val;\\npublic:\\n\\tPeekingIterator(const vector<int>& nums) : Iterator(nums) {\\n\\t    if(Iterator::hasNext()) val = Iterator::next();\\n        else val = -1; \\n\\t}\\n\\t\\n\\tint peek() {\\n        return val;\\n\\t}\\n\\t\\n\\tint next() {\\n\\t    int res = val;\\n        if(Iterator::hasNext()) val = Iterator::next();\\n        else val = -1;\\n        return res;\\n\\t}\\n\\t\\n\\tbool hasNext() const {\\n\\t    return val != -1;\\n\\t}\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nclass PeekingIterator : public Iterator {\\n    int val;\\npublic:\\n\\tPeekingIterator(const vector<int>& nums) : Iterator(nums) {\\n\\t    if(Iterator::hasNext()) val = Iterator::next();\\n        else val = -1; \\n\\t}\\n\\t\\n\\tint peek() {\\n        return val;\\n\\t}\\n\\t\\n\\tint next() {\\n\\t    int res = val;\\n        if(Iterator::hasNext()) val = Iterator::next();\\n        else val = -1;\\n        return res;\\n\\t}\\n\\t\\n\\tbool hasNext() const {\\n\\t    return val != -1;\\n\\t}\\n};\\n```",
                "codeTag": "Java"
            }
        ],
        "discussions": [
            {
                "id": 1565875,
                "content": [
                    {
                        "username": "renatkaitmazov",
                        "content": "I am getting a runtime error when I click the `Run Code` button with the following message:\\n`\"PeekingIterator\" is not a valid value of type integer`. What does it mean?"
                    },
                    {
                        "username": "d40a",
                        "content": "It seems that medium is too much for this problem."
                    },
                    {
                        "username": "__ron_swanson__",
                        "content": "This question is simple enough that it can be marked as Easy."
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for April, Day 25.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  **📌 Do you want to learn the problem thoroughly?**\n  Read [**⭐  LeetCode Official Solution⭐**](https://leetcode.com/problems/peeking-iterator/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 2 approaches in the official solution</summary>\n\n  \n**Approach 1:** Saving Peeked Value\n\n  \n**Approach 2:** Saving the Next Value\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "chrisTris",
                        "content": "I assume IEnumerator is in-built in C# so not included. But still it should be there. Any reasons?"
                    },
                    {
                        "username": "caplek",
                        "content": "1. During initialization of PeekingIterator IEnumerator<int> instance is already in modified state, that is its **Current** property **already points to the first entry** of iterator, whereas newly initialized instance should point to nothing until MoveNext is called.\\n1. When enumerator reaches the end Next and Peek should throw an exception, whereas according to standard behavior Current property of enumerator returns meaningless value of 0. \\n\\nThat was surprising. With all respect, I think this points should be either clarified in the task description or default behavior should be enforced in runtime."
                    },
                    {
                        "username": "disturbedbrown1",
                        "content": "Problem description could be clearer."
                    },
                    {
                        "username": "WilmerKrisp",
                        "content": "<-- pleasevote\\n\\n\\n![image](https://assets.leetcode.com/users/images/738c16f7-a745-4598-91de-9ff728ef2214_1648497319.9406855.png)\\n\\n![image](https://assets.leetcode.com/users/images/eaedd310-18c4-4c61-aaf4-c5702506fbba_1648497324.0223062.png)\\n"
                    },
                    {
                        "username": "HW311",
                        "content": "I am wondering why `Iterator::next()` and `Iterator::hasNext()` are not declared `virtual` in the provided C++ code template. They need to be virtual functions for overriding to work properly.\\n\\nYes, in simple scenarios like leetcode OJ tests this might work fine if you directly call the methods from an object of the derived class (`PeekingIterator`), however, imagine using the `PeekingIterator` through a pointer (or reference) to the base class `Iterator`, then internal states of the `PeekingIterator` will not be updated accordingly and things can go wrong."
                    },
                    {
                        "username": "linzhu1206",
                        "content": "Particularly the second line:\\n\\n[1,2,3,4]\\n[0,1,1,2,2,1,1,2,0,1,0,2,0]\\n\\nShould they put the explanation into the description?"
                    }
                ]
            },
            {
                "id": 1567941,
                "content": [
                    {
                        "username": "renatkaitmazov",
                        "content": "I am getting a runtime error when I click the `Run Code` button with the following message:\\n`\"PeekingIterator\" is not a valid value of type integer`. What does it mean?"
                    },
                    {
                        "username": "d40a",
                        "content": "It seems that medium is too much for this problem."
                    },
                    {
                        "username": "__ron_swanson__",
                        "content": "This question is simple enough that it can be marked as Easy."
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for April, Day 25.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  **📌 Do you want to learn the problem thoroughly?**\n  Read [**⭐  LeetCode Official Solution⭐**](https://leetcode.com/problems/peeking-iterator/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 2 approaches in the official solution</summary>\n\n  \n**Approach 1:** Saving Peeked Value\n\n  \n**Approach 2:** Saving the Next Value\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "chrisTris",
                        "content": "I assume IEnumerator is in-built in C# so not included. But still it should be there. Any reasons?"
                    },
                    {
                        "username": "caplek",
                        "content": "1. During initialization of PeekingIterator IEnumerator<int> instance is already in modified state, that is its **Current** property **already points to the first entry** of iterator, whereas newly initialized instance should point to nothing until MoveNext is called.\\n1. When enumerator reaches the end Next and Peek should throw an exception, whereas according to standard behavior Current property of enumerator returns meaningless value of 0. \\n\\nThat was surprising. With all respect, I think this points should be either clarified in the task description or default behavior should be enforced in runtime."
                    },
                    {
                        "username": "disturbedbrown1",
                        "content": "Problem description could be clearer."
                    },
                    {
                        "username": "WilmerKrisp",
                        "content": "<-- pleasevote\\n\\n\\n![image](https://assets.leetcode.com/users/images/738c16f7-a745-4598-91de-9ff728ef2214_1648497319.9406855.png)\\n\\n![image](https://assets.leetcode.com/users/images/eaedd310-18c4-4c61-aaf4-c5702506fbba_1648497324.0223062.png)\\n"
                    },
                    {
                        "username": "HW311",
                        "content": "I am wondering why `Iterator::next()` and `Iterator::hasNext()` are not declared `virtual` in the provided C++ code template. They need to be virtual functions for overriding to work properly.\\n\\nYes, in simple scenarios like leetcode OJ tests this might work fine if you directly call the methods from an object of the derived class (`PeekingIterator`), however, imagine using the `PeekingIterator` through a pointer (or reference) to the base class `Iterator`, then internal states of the `PeekingIterator` will not be updated accordingly and things can go wrong."
                    },
                    {
                        "username": "linzhu1206",
                        "content": "Particularly the second line:\\n\\n[1,2,3,4]\\n[0,1,1,2,2,1,1,2,0,1,0,2,0]\\n\\nShould they put the explanation into the description?"
                    }
                ]
            },
            {
                "id": 1570069,
                "content": [
                    {
                        "username": "renatkaitmazov",
                        "content": "I am getting a runtime error when I click the `Run Code` button with the following message:\\n`\"PeekingIterator\" is not a valid value of type integer`. What does it mean?"
                    },
                    {
                        "username": "d40a",
                        "content": "It seems that medium is too much for this problem."
                    },
                    {
                        "username": "__ron_swanson__",
                        "content": "This question is simple enough that it can be marked as Easy."
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for April, Day 25.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  **📌 Do you want to learn the problem thoroughly?**\n  Read [**⭐  LeetCode Official Solution⭐**](https://leetcode.com/problems/peeking-iterator/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 2 approaches in the official solution</summary>\n\n  \n**Approach 1:** Saving Peeked Value\n\n  \n**Approach 2:** Saving the Next Value\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "chrisTris",
                        "content": "I assume IEnumerator is in-built in C# so not included. But still it should be there. Any reasons?"
                    },
                    {
                        "username": "caplek",
                        "content": "1. During initialization of PeekingIterator IEnumerator<int> instance is already in modified state, that is its **Current** property **already points to the first entry** of iterator, whereas newly initialized instance should point to nothing until MoveNext is called.\\n1. When enumerator reaches the end Next and Peek should throw an exception, whereas according to standard behavior Current property of enumerator returns meaningless value of 0. \\n\\nThat was surprising. With all respect, I think this points should be either clarified in the task description or default behavior should be enforced in runtime."
                    },
                    {
                        "username": "disturbedbrown1",
                        "content": "Problem description could be clearer."
                    },
                    {
                        "username": "WilmerKrisp",
                        "content": "<-- pleasevote\\n\\n\\n![image](https://assets.leetcode.com/users/images/738c16f7-a745-4598-91de-9ff728ef2214_1648497319.9406855.png)\\n\\n![image](https://assets.leetcode.com/users/images/eaedd310-18c4-4c61-aaf4-c5702506fbba_1648497324.0223062.png)\\n"
                    },
                    {
                        "username": "HW311",
                        "content": "I am wondering why `Iterator::next()` and `Iterator::hasNext()` are not declared `virtual` in the provided C++ code template. They need to be virtual functions for overriding to work properly.\\n\\nYes, in simple scenarios like leetcode OJ tests this might work fine if you directly call the methods from an object of the derived class (`PeekingIterator`), however, imagine using the `PeekingIterator` through a pointer (or reference) to the base class `Iterator`, then internal states of the `PeekingIterator` will not be updated accordingly and things can go wrong."
                    },
                    {
                        "username": "linzhu1206",
                        "content": "Particularly the second line:\\n\\n[1,2,3,4]\\n[0,1,1,2,2,1,1,2,0,1,0,2,0]\\n\\nShould they put the explanation into the description?"
                    }
                ]
            },
            {
                "id": 1567754,
                "content": [
                    {
                        "username": "renatkaitmazov",
                        "content": "I am getting a runtime error when I click the `Run Code` button with the following message:\\n`\"PeekingIterator\" is not a valid value of type integer`. What does it mean?"
                    },
                    {
                        "username": "d40a",
                        "content": "It seems that medium is too much for this problem."
                    },
                    {
                        "username": "__ron_swanson__",
                        "content": "This question is simple enough that it can be marked as Easy."
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for April, Day 25.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  **📌 Do you want to learn the problem thoroughly?**\n  Read [**⭐  LeetCode Official Solution⭐**](https://leetcode.com/problems/peeking-iterator/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 2 approaches in the official solution</summary>\n\n  \n**Approach 1:** Saving Peeked Value\n\n  \n**Approach 2:** Saving the Next Value\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "chrisTris",
                        "content": "I assume IEnumerator is in-built in C# so not included. But still it should be there. Any reasons?"
                    },
                    {
                        "username": "caplek",
                        "content": "1. During initialization of PeekingIterator IEnumerator<int> instance is already in modified state, that is its **Current** property **already points to the first entry** of iterator, whereas newly initialized instance should point to nothing until MoveNext is called.\\n1. When enumerator reaches the end Next and Peek should throw an exception, whereas according to standard behavior Current property of enumerator returns meaningless value of 0. \\n\\nThat was surprising. With all respect, I think this points should be either clarified in the task description or default behavior should be enforced in runtime."
                    },
                    {
                        "username": "disturbedbrown1",
                        "content": "Problem description could be clearer."
                    },
                    {
                        "username": "WilmerKrisp",
                        "content": "<-- pleasevote\\n\\n\\n![image](https://assets.leetcode.com/users/images/738c16f7-a745-4598-91de-9ff728ef2214_1648497319.9406855.png)\\n\\n![image](https://assets.leetcode.com/users/images/eaedd310-18c4-4c61-aaf4-c5702506fbba_1648497324.0223062.png)\\n"
                    },
                    {
                        "username": "HW311",
                        "content": "I am wondering why `Iterator::next()` and `Iterator::hasNext()` are not declared `virtual` in the provided C++ code template. They need to be virtual functions for overriding to work properly.\\n\\nYes, in simple scenarios like leetcode OJ tests this might work fine if you directly call the methods from an object of the derived class (`PeekingIterator`), however, imagine using the `PeekingIterator` through a pointer (or reference) to the base class `Iterator`, then internal states of the `PeekingIterator` will not be updated accordingly and things can go wrong."
                    },
                    {
                        "username": "linzhu1206",
                        "content": "Particularly the second line:\\n\\n[1,2,3,4]\\n[0,1,1,2,2,1,1,2,0,1,0,2,0]\\n\\nShould they put the explanation into the description?"
                    }
                ]
            },
            {
                "id": 1568118,
                "content": [
                    {
                        "username": "renatkaitmazov",
                        "content": "I am getting a runtime error when I click the `Run Code` button with the following message:\\n`\"PeekingIterator\" is not a valid value of type integer`. What does it mean?"
                    },
                    {
                        "username": "d40a",
                        "content": "It seems that medium is too much for this problem."
                    },
                    {
                        "username": "__ron_swanson__",
                        "content": "This question is simple enough that it can be marked as Easy."
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for April, Day 25.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  **📌 Do you want to learn the problem thoroughly?**\n  Read [**⭐  LeetCode Official Solution⭐**](https://leetcode.com/problems/peeking-iterator/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 2 approaches in the official solution</summary>\n\n  \n**Approach 1:** Saving Peeked Value\n\n  \n**Approach 2:** Saving the Next Value\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "chrisTris",
                        "content": "I assume IEnumerator is in-built in C# so not included. But still it should be there. Any reasons?"
                    },
                    {
                        "username": "caplek",
                        "content": "1. During initialization of PeekingIterator IEnumerator<int> instance is already in modified state, that is its **Current** property **already points to the first entry** of iterator, whereas newly initialized instance should point to nothing until MoveNext is called.\\n1. When enumerator reaches the end Next and Peek should throw an exception, whereas according to standard behavior Current property of enumerator returns meaningless value of 0. \\n\\nThat was surprising. With all respect, I think this points should be either clarified in the task description or default behavior should be enforced in runtime."
                    },
                    {
                        "username": "disturbedbrown1",
                        "content": "Problem description could be clearer."
                    },
                    {
                        "username": "WilmerKrisp",
                        "content": "<-- pleasevote\\n\\n\\n![image](https://assets.leetcode.com/users/images/738c16f7-a745-4598-91de-9ff728ef2214_1648497319.9406855.png)\\n\\n![image](https://assets.leetcode.com/users/images/eaedd310-18c4-4c61-aaf4-c5702506fbba_1648497324.0223062.png)\\n"
                    },
                    {
                        "username": "HW311",
                        "content": "I am wondering why `Iterator::next()` and `Iterator::hasNext()` are not declared `virtual` in the provided C++ code template. They need to be virtual functions for overriding to work properly.\\n\\nYes, in simple scenarios like leetcode OJ tests this might work fine if you directly call the methods from an object of the derived class (`PeekingIterator`), however, imagine using the `PeekingIterator` through a pointer (or reference) to the base class `Iterator`, then internal states of the `PeekingIterator` will not be updated accordingly and things can go wrong."
                    },
                    {
                        "username": "linzhu1206",
                        "content": "Particularly the second line:\\n\\n[1,2,3,4]\\n[0,1,1,2,2,1,1,2,0,1,0,2,0]\\n\\nShould they put the explanation into the description?"
                    }
                ]
            },
            {
                "id": 1568527,
                "content": [
                    {
                        "username": "renatkaitmazov",
                        "content": "I am getting a runtime error when I click the `Run Code` button with the following message:\\n`\"PeekingIterator\" is not a valid value of type integer`. What does it mean?"
                    },
                    {
                        "username": "d40a",
                        "content": "It seems that medium is too much for this problem."
                    },
                    {
                        "username": "__ron_swanson__",
                        "content": "This question is simple enough that it can be marked as Easy."
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for April, Day 25.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  **📌 Do you want to learn the problem thoroughly?**\n  Read [**⭐  LeetCode Official Solution⭐**](https://leetcode.com/problems/peeking-iterator/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 2 approaches in the official solution</summary>\n\n  \n**Approach 1:** Saving Peeked Value\n\n  \n**Approach 2:** Saving the Next Value\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "chrisTris",
                        "content": "I assume IEnumerator is in-built in C# so not included. But still it should be there. Any reasons?"
                    },
                    {
                        "username": "caplek",
                        "content": "1. During initialization of PeekingIterator IEnumerator<int> instance is already in modified state, that is its **Current** property **already points to the first entry** of iterator, whereas newly initialized instance should point to nothing until MoveNext is called.\\n1. When enumerator reaches the end Next and Peek should throw an exception, whereas according to standard behavior Current property of enumerator returns meaningless value of 0. \\n\\nThat was surprising. With all respect, I think this points should be either clarified in the task description or default behavior should be enforced in runtime."
                    },
                    {
                        "username": "disturbedbrown1",
                        "content": "Problem description could be clearer."
                    },
                    {
                        "username": "WilmerKrisp",
                        "content": "<-- pleasevote\\n\\n\\n![image](https://assets.leetcode.com/users/images/738c16f7-a745-4598-91de-9ff728ef2214_1648497319.9406855.png)\\n\\n![image](https://assets.leetcode.com/users/images/eaedd310-18c4-4c61-aaf4-c5702506fbba_1648497324.0223062.png)\\n"
                    },
                    {
                        "username": "HW311",
                        "content": "I am wondering why `Iterator::next()` and `Iterator::hasNext()` are not declared `virtual` in the provided C++ code template. They need to be virtual functions for overriding to work properly.\\n\\nYes, in simple scenarios like leetcode OJ tests this might work fine if you directly call the methods from an object of the derived class (`PeekingIterator`), however, imagine using the `PeekingIterator` through a pointer (or reference) to the base class `Iterator`, then internal states of the `PeekingIterator` will not be updated accordingly and things can go wrong."
                    },
                    {
                        "username": "linzhu1206",
                        "content": "Particularly the second line:\\n\\n[1,2,3,4]\\n[0,1,1,2,2,1,1,2,0,1,0,2,0]\\n\\nShould they put the explanation into the description?"
                    }
                ]
            },
            {
                "id": 1721097,
                "content": [
                    {
                        "username": "renatkaitmazov",
                        "content": "I am getting a runtime error when I click the `Run Code` button with the following message:\\n`\"PeekingIterator\" is not a valid value of type integer`. What does it mean?"
                    },
                    {
                        "username": "d40a",
                        "content": "It seems that medium is too much for this problem."
                    },
                    {
                        "username": "__ron_swanson__",
                        "content": "This question is simple enough that it can be marked as Easy."
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for April, Day 25.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  **📌 Do you want to learn the problem thoroughly?**\n  Read [**⭐  LeetCode Official Solution⭐**](https://leetcode.com/problems/peeking-iterator/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 2 approaches in the official solution</summary>\n\n  \n**Approach 1:** Saving Peeked Value\n\n  \n**Approach 2:** Saving the Next Value\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "chrisTris",
                        "content": "I assume IEnumerator is in-built in C# so not included. But still it should be there. Any reasons?"
                    },
                    {
                        "username": "caplek",
                        "content": "1. During initialization of PeekingIterator IEnumerator<int> instance is already in modified state, that is its **Current** property **already points to the first entry** of iterator, whereas newly initialized instance should point to nothing until MoveNext is called.\\n1. When enumerator reaches the end Next and Peek should throw an exception, whereas according to standard behavior Current property of enumerator returns meaningless value of 0. \\n\\nThat was surprising. With all respect, I think this points should be either clarified in the task description or default behavior should be enforced in runtime."
                    },
                    {
                        "username": "disturbedbrown1",
                        "content": "Problem description could be clearer."
                    },
                    {
                        "username": "WilmerKrisp",
                        "content": "<-- pleasevote\\n\\n\\n![image](https://assets.leetcode.com/users/images/738c16f7-a745-4598-91de-9ff728ef2214_1648497319.9406855.png)\\n\\n![image](https://assets.leetcode.com/users/images/eaedd310-18c4-4c61-aaf4-c5702506fbba_1648497324.0223062.png)\\n"
                    },
                    {
                        "username": "HW311",
                        "content": "I am wondering why `Iterator::next()` and `Iterator::hasNext()` are not declared `virtual` in the provided C++ code template. They need to be virtual functions for overriding to work properly.\\n\\nYes, in simple scenarios like leetcode OJ tests this might work fine if you directly call the methods from an object of the derived class (`PeekingIterator`), however, imagine using the `PeekingIterator` through a pointer (or reference) to the base class `Iterator`, then internal states of the `PeekingIterator` will not be updated accordingly and things can go wrong."
                    },
                    {
                        "username": "linzhu1206",
                        "content": "Particularly the second line:\\n\\n[1,2,3,4]\\n[0,1,1,2,2,1,1,2,0,1,0,2,0]\\n\\nShould they put the explanation into the description?"
                    }
                ]
            },
            {
                "id": 1576556,
                "content": [
                    {
                        "username": "renatkaitmazov",
                        "content": "I am getting a runtime error when I click the `Run Code` button with the following message:\\n`\"PeekingIterator\" is not a valid value of type integer`. What does it mean?"
                    },
                    {
                        "username": "d40a",
                        "content": "It seems that medium is too much for this problem."
                    },
                    {
                        "username": "__ron_swanson__",
                        "content": "This question is simple enough that it can be marked as Easy."
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for April, Day 25.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  **📌 Do you want to learn the problem thoroughly?**\n  Read [**⭐  LeetCode Official Solution⭐**](https://leetcode.com/problems/peeking-iterator/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 2 approaches in the official solution</summary>\n\n  \n**Approach 1:** Saving Peeked Value\n\n  \n**Approach 2:** Saving the Next Value\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "chrisTris",
                        "content": "I assume IEnumerator is in-built in C# so not included. But still it should be there. Any reasons?"
                    },
                    {
                        "username": "caplek",
                        "content": "1. During initialization of PeekingIterator IEnumerator<int> instance is already in modified state, that is its **Current** property **already points to the first entry** of iterator, whereas newly initialized instance should point to nothing until MoveNext is called.\\n1. When enumerator reaches the end Next and Peek should throw an exception, whereas according to standard behavior Current property of enumerator returns meaningless value of 0. \\n\\nThat was surprising. With all respect, I think this points should be either clarified in the task description or default behavior should be enforced in runtime."
                    },
                    {
                        "username": "disturbedbrown1",
                        "content": "Problem description could be clearer."
                    },
                    {
                        "username": "WilmerKrisp",
                        "content": "<-- pleasevote\\n\\n\\n![image](https://assets.leetcode.com/users/images/738c16f7-a745-4598-91de-9ff728ef2214_1648497319.9406855.png)\\n\\n![image](https://assets.leetcode.com/users/images/eaedd310-18c4-4c61-aaf4-c5702506fbba_1648497324.0223062.png)\\n"
                    },
                    {
                        "username": "HW311",
                        "content": "I am wondering why `Iterator::next()` and `Iterator::hasNext()` are not declared `virtual` in the provided C++ code template. They need to be virtual functions for overriding to work properly.\\n\\nYes, in simple scenarios like leetcode OJ tests this might work fine if you directly call the methods from an object of the derived class (`PeekingIterator`), however, imagine using the `PeekingIterator` through a pointer (or reference) to the base class `Iterator`, then internal states of the `PeekingIterator` will not be updated accordingly and things can go wrong."
                    },
                    {
                        "username": "linzhu1206",
                        "content": "Particularly the second line:\\n\\n[1,2,3,4]\\n[0,1,1,2,2,1,1,2,0,1,0,2,0]\\n\\nShould they put the explanation into the description?"
                    }
                ]
            },
            {
                "id": 1573469,
                "content": [
                    {
                        "username": "renatkaitmazov",
                        "content": "I am getting a runtime error when I click the `Run Code` button with the following message:\\n`\"PeekingIterator\" is not a valid value of type integer`. What does it mean?"
                    },
                    {
                        "username": "d40a",
                        "content": "It seems that medium is too much for this problem."
                    },
                    {
                        "username": "__ron_swanson__",
                        "content": "This question is simple enough that it can be marked as Easy."
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for April, Day 25.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  **📌 Do you want to learn the problem thoroughly?**\n  Read [**⭐  LeetCode Official Solution⭐**](https://leetcode.com/problems/peeking-iterator/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 2 approaches in the official solution</summary>\n\n  \n**Approach 1:** Saving Peeked Value\n\n  \n**Approach 2:** Saving the Next Value\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "chrisTris",
                        "content": "I assume IEnumerator is in-built in C# so not included. But still it should be there. Any reasons?"
                    },
                    {
                        "username": "caplek",
                        "content": "1. During initialization of PeekingIterator IEnumerator<int> instance is already in modified state, that is its **Current** property **already points to the first entry** of iterator, whereas newly initialized instance should point to nothing until MoveNext is called.\\n1. When enumerator reaches the end Next and Peek should throw an exception, whereas according to standard behavior Current property of enumerator returns meaningless value of 0. \\n\\nThat was surprising. With all respect, I think this points should be either clarified in the task description or default behavior should be enforced in runtime."
                    },
                    {
                        "username": "disturbedbrown1",
                        "content": "Problem description could be clearer."
                    },
                    {
                        "username": "WilmerKrisp",
                        "content": "<-- pleasevote\\n\\n\\n![image](https://assets.leetcode.com/users/images/738c16f7-a745-4598-91de-9ff728ef2214_1648497319.9406855.png)\\n\\n![image](https://assets.leetcode.com/users/images/eaedd310-18c4-4c61-aaf4-c5702506fbba_1648497324.0223062.png)\\n"
                    },
                    {
                        "username": "HW311",
                        "content": "I am wondering why `Iterator::next()` and `Iterator::hasNext()` are not declared `virtual` in the provided C++ code template. They need to be virtual functions for overriding to work properly.\\n\\nYes, in simple scenarios like leetcode OJ tests this might work fine if you directly call the methods from an object of the derived class (`PeekingIterator`), however, imagine using the `PeekingIterator` through a pointer (or reference) to the base class `Iterator`, then internal states of the `PeekingIterator` will not be updated accordingly and things can go wrong."
                    },
                    {
                        "username": "linzhu1206",
                        "content": "Particularly the second line:\\n\\n[1,2,3,4]\\n[0,1,1,2,2,1,1,2,0,1,0,2,0]\\n\\nShould they put the explanation into the description?"
                    }
                ]
            },
            {
                "id": 1571836,
                "content": [
                    {
                        "username": "renatkaitmazov",
                        "content": "I am getting a runtime error when I click the `Run Code` button with the following message:\\n`\"PeekingIterator\" is not a valid value of type integer`. What does it mean?"
                    },
                    {
                        "username": "d40a",
                        "content": "It seems that medium is too much for this problem."
                    },
                    {
                        "username": "__ron_swanson__",
                        "content": "This question is simple enough that it can be marked as Easy."
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for April, Day 25.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  **📌 Do you want to learn the problem thoroughly?**\n  Read [**⭐  LeetCode Official Solution⭐**](https://leetcode.com/problems/peeking-iterator/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 2 approaches in the official solution</summary>\n\n  \n**Approach 1:** Saving Peeked Value\n\n  \n**Approach 2:** Saving the Next Value\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "chrisTris",
                        "content": "I assume IEnumerator is in-built in C# so not included. But still it should be there. Any reasons?"
                    },
                    {
                        "username": "caplek",
                        "content": "1. During initialization of PeekingIterator IEnumerator<int> instance is already in modified state, that is its **Current** property **already points to the first entry** of iterator, whereas newly initialized instance should point to nothing until MoveNext is called.\\n1. When enumerator reaches the end Next and Peek should throw an exception, whereas according to standard behavior Current property of enumerator returns meaningless value of 0. \\n\\nThat was surprising. With all respect, I think this points should be either clarified in the task description or default behavior should be enforced in runtime."
                    },
                    {
                        "username": "disturbedbrown1",
                        "content": "Problem description could be clearer."
                    },
                    {
                        "username": "WilmerKrisp",
                        "content": "<-- pleasevote\\n\\n\\n![image](https://assets.leetcode.com/users/images/738c16f7-a745-4598-91de-9ff728ef2214_1648497319.9406855.png)\\n\\n![image](https://assets.leetcode.com/users/images/eaedd310-18c4-4c61-aaf4-c5702506fbba_1648497324.0223062.png)\\n"
                    },
                    {
                        "username": "HW311",
                        "content": "I am wondering why `Iterator::next()` and `Iterator::hasNext()` are not declared `virtual` in the provided C++ code template. They need to be virtual functions for overriding to work properly.\\n\\nYes, in simple scenarios like leetcode OJ tests this might work fine if you directly call the methods from an object of the derived class (`PeekingIterator`), however, imagine using the `PeekingIterator` through a pointer (or reference) to the base class `Iterator`, then internal states of the `PeekingIterator` will not be updated accordingly and things can go wrong."
                    },
                    {
                        "username": "linzhu1206",
                        "content": "Particularly the second line:\\n\\n[1,2,3,4]\\n[0,1,1,2,2,1,1,2,0,1,0,2,0]\\n\\nShould they put the explanation into the description?"
                    }
                ]
            },
            {
                "id": 1565875,
                "content": [
                    {
                        "username": "renatkaitmazov",
                        "content": "I am getting a runtime error when I click the `Run Code` button with the following message:\\n`\"PeekingIterator\" is not a valid value of type integer`. What does it mean?"
                    },
                    {
                        "username": "d40a",
                        "content": "It seems that medium is too much for this problem."
                    },
                    {
                        "username": "__ron_swanson__",
                        "content": "This question is simple enough that it can be marked as Easy."
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for April, Day 25.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  **📌 Do you want to learn the problem thoroughly?**\n  Read [**⭐  LeetCode Official Solution⭐**](https://leetcode.com/problems/peeking-iterator/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 2 approaches in the official solution</summary>\n\n  \n**Approach 1:** Saving Peeked Value\n\n  \n**Approach 2:** Saving the Next Value\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "chrisTris",
                        "content": "I assume IEnumerator is in-built in C# so not included. But still it should be there. Any reasons?"
                    },
                    {
                        "username": "caplek",
                        "content": "1. During initialization of PeekingIterator IEnumerator<int> instance is already in modified state, that is its **Current** property **already points to the first entry** of iterator, whereas newly initialized instance should point to nothing until MoveNext is called.\\n1. When enumerator reaches the end Next and Peek should throw an exception, whereas according to standard behavior Current property of enumerator returns meaningless value of 0. \\n\\nThat was surprising. With all respect, I think this points should be either clarified in the task description or default behavior should be enforced in runtime."
                    },
                    {
                        "username": "disturbedbrown1",
                        "content": "Problem description could be clearer."
                    },
                    {
                        "username": "WilmerKrisp",
                        "content": "<-- pleasevote\\n\\n\\n![image](https://assets.leetcode.com/users/images/738c16f7-a745-4598-91de-9ff728ef2214_1648497319.9406855.png)\\n\\n![image](https://assets.leetcode.com/users/images/eaedd310-18c4-4c61-aaf4-c5702506fbba_1648497324.0223062.png)\\n"
                    },
                    {
                        "username": "HW311",
                        "content": "I am wondering why `Iterator::next()` and `Iterator::hasNext()` are not declared `virtual` in the provided C++ code template. They need to be virtual functions for overriding to work properly.\\n\\nYes, in simple scenarios like leetcode OJ tests this might work fine if you directly call the methods from an object of the derived class (`PeekingIterator`), however, imagine using the `PeekingIterator` through a pointer (or reference) to the base class `Iterator`, then internal states of the `PeekingIterator` will not be updated accordingly and things can go wrong."
                    },
                    {
                        "username": "linzhu1206",
                        "content": "Particularly the second line:\\n\\n[1,2,3,4]\\n[0,1,1,2,2,1,1,2,0,1,0,2,0]\\n\\nShould they put the explanation into the description?"
                    }
                ]
            },
            {
                "id": 1567941,
                "content": [
                    {
                        "username": "renatkaitmazov",
                        "content": "I am getting a runtime error when I click the `Run Code` button with the following message:\\n`\"PeekingIterator\" is not a valid value of type integer`. What does it mean?"
                    },
                    {
                        "username": "d40a",
                        "content": "It seems that medium is too much for this problem."
                    },
                    {
                        "username": "__ron_swanson__",
                        "content": "This question is simple enough that it can be marked as Easy."
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for April, Day 25.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  **📌 Do you want to learn the problem thoroughly?**\n  Read [**⭐  LeetCode Official Solution⭐**](https://leetcode.com/problems/peeking-iterator/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 2 approaches in the official solution</summary>\n\n  \n**Approach 1:** Saving Peeked Value\n\n  \n**Approach 2:** Saving the Next Value\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "chrisTris",
                        "content": "I assume IEnumerator is in-built in C# so not included. But still it should be there. Any reasons?"
                    },
                    {
                        "username": "caplek",
                        "content": "1. During initialization of PeekingIterator IEnumerator<int> instance is already in modified state, that is its **Current** property **already points to the first entry** of iterator, whereas newly initialized instance should point to nothing until MoveNext is called.\\n1. When enumerator reaches the end Next and Peek should throw an exception, whereas according to standard behavior Current property of enumerator returns meaningless value of 0. \\n\\nThat was surprising. With all respect, I think this points should be either clarified in the task description or default behavior should be enforced in runtime."
                    },
                    {
                        "username": "disturbedbrown1",
                        "content": "Problem description could be clearer."
                    },
                    {
                        "username": "WilmerKrisp",
                        "content": "<-- pleasevote\\n\\n\\n![image](https://assets.leetcode.com/users/images/738c16f7-a745-4598-91de-9ff728ef2214_1648497319.9406855.png)\\n\\n![image](https://assets.leetcode.com/users/images/eaedd310-18c4-4c61-aaf4-c5702506fbba_1648497324.0223062.png)\\n"
                    },
                    {
                        "username": "HW311",
                        "content": "I am wondering why `Iterator::next()` and `Iterator::hasNext()` are not declared `virtual` in the provided C++ code template. They need to be virtual functions for overriding to work properly.\\n\\nYes, in simple scenarios like leetcode OJ tests this might work fine if you directly call the methods from an object of the derived class (`PeekingIterator`), however, imagine using the `PeekingIterator` through a pointer (or reference) to the base class `Iterator`, then internal states of the `PeekingIterator` will not be updated accordingly and things can go wrong."
                    },
                    {
                        "username": "linzhu1206",
                        "content": "Particularly the second line:\\n\\n[1,2,3,4]\\n[0,1,1,2,2,1,1,2,0,1,0,2,0]\\n\\nShould they put the explanation into the description?"
                    }
                ]
            },
            {
                "id": 1570069,
                "content": [
                    {
                        "username": "renatkaitmazov",
                        "content": "I am getting a runtime error when I click the `Run Code` button with the following message:\\n`\"PeekingIterator\" is not a valid value of type integer`. What does it mean?"
                    },
                    {
                        "username": "d40a",
                        "content": "It seems that medium is too much for this problem."
                    },
                    {
                        "username": "__ron_swanson__",
                        "content": "This question is simple enough that it can be marked as Easy."
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for April, Day 25.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  **📌 Do you want to learn the problem thoroughly?**\n  Read [**⭐  LeetCode Official Solution⭐**](https://leetcode.com/problems/peeking-iterator/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 2 approaches in the official solution</summary>\n\n  \n**Approach 1:** Saving Peeked Value\n\n  \n**Approach 2:** Saving the Next Value\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "chrisTris",
                        "content": "I assume IEnumerator is in-built in C# so not included. But still it should be there. Any reasons?"
                    },
                    {
                        "username": "caplek",
                        "content": "1. During initialization of PeekingIterator IEnumerator<int> instance is already in modified state, that is its **Current** property **already points to the first entry** of iterator, whereas newly initialized instance should point to nothing until MoveNext is called.\\n1. When enumerator reaches the end Next and Peek should throw an exception, whereas according to standard behavior Current property of enumerator returns meaningless value of 0. \\n\\nThat was surprising. With all respect, I think this points should be either clarified in the task description or default behavior should be enforced in runtime."
                    },
                    {
                        "username": "disturbedbrown1",
                        "content": "Problem description could be clearer."
                    },
                    {
                        "username": "WilmerKrisp",
                        "content": "<-- pleasevote\\n\\n\\n![image](https://assets.leetcode.com/users/images/738c16f7-a745-4598-91de-9ff728ef2214_1648497319.9406855.png)\\n\\n![image](https://assets.leetcode.com/users/images/eaedd310-18c4-4c61-aaf4-c5702506fbba_1648497324.0223062.png)\\n"
                    },
                    {
                        "username": "HW311",
                        "content": "I am wondering why `Iterator::next()` and `Iterator::hasNext()` are not declared `virtual` in the provided C++ code template. They need to be virtual functions for overriding to work properly.\\n\\nYes, in simple scenarios like leetcode OJ tests this might work fine if you directly call the methods from an object of the derived class (`PeekingIterator`), however, imagine using the `PeekingIterator` through a pointer (or reference) to the base class `Iterator`, then internal states of the `PeekingIterator` will not be updated accordingly and things can go wrong."
                    },
                    {
                        "username": "linzhu1206",
                        "content": "Particularly the second line:\\n\\n[1,2,3,4]\\n[0,1,1,2,2,1,1,2,0,1,0,2,0]\\n\\nShould they put the explanation into the description?"
                    }
                ]
            },
            {
                "id": 1567754,
                "content": [
                    {
                        "username": "renatkaitmazov",
                        "content": "I am getting a runtime error when I click the `Run Code` button with the following message:\\n`\"PeekingIterator\" is not a valid value of type integer`. What does it mean?"
                    },
                    {
                        "username": "d40a",
                        "content": "It seems that medium is too much for this problem."
                    },
                    {
                        "username": "__ron_swanson__",
                        "content": "This question is simple enough that it can be marked as Easy."
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for April, Day 25.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  **📌 Do you want to learn the problem thoroughly?**\n  Read [**⭐  LeetCode Official Solution⭐**](https://leetcode.com/problems/peeking-iterator/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 2 approaches in the official solution</summary>\n\n  \n**Approach 1:** Saving Peeked Value\n\n  \n**Approach 2:** Saving the Next Value\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "chrisTris",
                        "content": "I assume IEnumerator is in-built in C# so not included. But still it should be there. Any reasons?"
                    },
                    {
                        "username": "caplek",
                        "content": "1. During initialization of PeekingIterator IEnumerator<int> instance is already in modified state, that is its **Current** property **already points to the first entry** of iterator, whereas newly initialized instance should point to nothing until MoveNext is called.\\n1. When enumerator reaches the end Next and Peek should throw an exception, whereas according to standard behavior Current property of enumerator returns meaningless value of 0. \\n\\nThat was surprising. With all respect, I think this points should be either clarified in the task description or default behavior should be enforced in runtime."
                    },
                    {
                        "username": "disturbedbrown1",
                        "content": "Problem description could be clearer."
                    },
                    {
                        "username": "WilmerKrisp",
                        "content": "<-- pleasevote\\n\\n\\n![image](https://assets.leetcode.com/users/images/738c16f7-a745-4598-91de-9ff728ef2214_1648497319.9406855.png)\\n\\n![image](https://assets.leetcode.com/users/images/eaedd310-18c4-4c61-aaf4-c5702506fbba_1648497324.0223062.png)\\n"
                    },
                    {
                        "username": "HW311",
                        "content": "I am wondering why `Iterator::next()` and `Iterator::hasNext()` are not declared `virtual` in the provided C++ code template. They need to be virtual functions for overriding to work properly.\\n\\nYes, in simple scenarios like leetcode OJ tests this might work fine if you directly call the methods from an object of the derived class (`PeekingIterator`), however, imagine using the `PeekingIterator` through a pointer (or reference) to the base class `Iterator`, then internal states of the `PeekingIterator` will not be updated accordingly and things can go wrong."
                    },
                    {
                        "username": "linzhu1206",
                        "content": "Particularly the second line:\\n\\n[1,2,3,4]\\n[0,1,1,2,2,1,1,2,0,1,0,2,0]\\n\\nShould they put the explanation into the description?"
                    }
                ]
            },
            {
                "id": 1568118,
                "content": [
                    {
                        "username": "renatkaitmazov",
                        "content": "I am getting a runtime error when I click the `Run Code` button with the following message:\\n`\"PeekingIterator\" is not a valid value of type integer`. What does it mean?"
                    },
                    {
                        "username": "d40a",
                        "content": "It seems that medium is too much for this problem."
                    },
                    {
                        "username": "__ron_swanson__",
                        "content": "This question is simple enough that it can be marked as Easy."
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for April, Day 25.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  **📌 Do you want to learn the problem thoroughly?**\n  Read [**⭐  LeetCode Official Solution⭐**](https://leetcode.com/problems/peeking-iterator/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 2 approaches in the official solution</summary>\n\n  \n**Approach 1:** Saving Peeked Value\n\n  \n**Approach 2:** Saving the Next Value\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "chrisTris",
                        "content": "I assume IEnumerator is in-built in C# so not included. But still it should be there. Any reasons?"
                    },
                    {
                        "username": "caplek",
                        "content": "1. During initialization of PeekingIterator IEnumerator<int> instance is already in modified state, that is its **Current** property **already points to the first entry** of iterator, whereas newly initialized instance should point to nothing until MoveNext is called.\\n1. When enumerator reaches the end Next and Peek should throw an exception, whereas according to standard behavior Current property of enumerator returns meaningless value of 0. \\n\\nThat was surprising. With all respect, I think this points should be either clarified in the task description or default behavior should be enforced in runtime."
                    },
                    {
                        "username": "disturbedbrown1",
                        "content": "Problem description could be clearer."
                    },
                    {
                        "username": "WilmerKrisp",
                        "content": "<-- pleasevote\\n\\n\\n![image](https://assets.leetcode.com/users/images/738c16f7-a745-4598-91de-9ff728ef2214_1648497319.9406855.png)\\n\\n![image](https://assets.leetcode.com/users/images/eaedd310-18c4-4c61-aaf4-c5702506fbba_1648497324.0223062.png)\\n"
                    },
                    {
                        "username": "HW311",
                        "content": "I am wondering why `Iterator::next()` and `Iterator::hasNext()` are not declared `virtual` in the provided C++ code template. They need to be virtual functions for overriding to work properly.\\n\\nYes, in simple scenarios like leetcode OJ tests this might work fine if you directly call the methods from an object of the derived class (`PeekingIterator`), however, imagine using the `PeekingIterator` through a pointer (or reference) to the base class `Iterator`, then internal states of the `PeekingIterator` will not be updated accordingly and things can go wrong."
                    },
                    {
                        "username": "linzhu1206",
                        "content": "Particularly the second line:\\n\\n[1,2,3,4]\\n[0,1,1,2,2,1,1,2,0,1,0,2,0]\\n\\nShould they put the explanation into the description?"
                    }
                ]
            },
            {
                "id": 1568527,
                "content": [
                    {
                        "username": "renatkaitmazov",
                        "content": "I am getting a runtime error when I click the `Run Code` button with the following message:\\n`\"PeekingIterator\" is not a valid value of type integer`. What does it mean?"
                    },
                    {
                        "username": "d40a",
                        "content": "It seems that medium is too much for this problem."
                    },
                    {
                        "username": "__ron_swanson__",
                        "content": "This question is simple enough that it can be marked as Easy."
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for April, Day 25.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  **📌 Do you want to learn the problem thoroughly?**\n  Read [**⭐  LeetCode Official Solution⭐**](https://leetcode.com/problems/peeking-iterator/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 2 approaches in the official solution</summary>\n\n  \n**Approach 1:** Saving Peeked Value\n\n  \n**Approach 2:** Saving the Next Value\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "chrisTris",
                        "content": "I assume IEnumerator is in-built in C# so not included. But still it should be there. Any reasons?"
                    },
                    {
                        "username": "caplek",
                        "content": "1. During initialization of PeekingIterator IEnumerator<int> instance is already in modified state, that is its **Current** property **already points to the first entry** of iterator, whereas newly initialized instance should point to nothing until MoveNext is called.\\n1. When enumerator reaches the end Next and Peek should throw an exception, whereas according to standard behavior Current property of enumerator returns meaningless value of 0. \\n\\nThat was surprising. With all respect, I think this points should be either clarified in the task description or default behavior should be enforced in runtime."
                    },
                    {
                        "username": "disturbedbrown1",
                        "content": "Problem description could be clearer."
                    },
                    {
                        "username": "WilmerKrisp",
                        "content": "<-- pleasevote\\n\\n\\n![image](https://assets.leetcode.com/users/images/738c16f7-a745-4598-91de-9ff728ef2214_1648497319.9406855.png)\\n\\n![image](https://assets.leetcode.com/users/images/eaedd310-18c4-4c61-aaf4-c5702506fbba_1648497324.0223062.png)\\n"
                    },
                    {
                        "username": "HW311",
                        "content": "I am wondering why `Iterator::next()` and `Iterator::hasNext()` are not declared `virtual` in the provided C++ code template. They need to be virtual functions for overriding to work properly.\\n\\nYes, in simple scenarios like leetcode OJ tests this might work fine if you directly call the methods from an object of the derived class (`PeekingIterator`), however, imagine using the `PeekingIterator` through a pointer (or reference) to the base class `Iterator`, then internal states of the `PeekingIterator` will not be updated accordingly and things can go wrong."
                    },
                    {
                        "username": "linzhu1206",
                        "content": "Particularly the second line:\\n\\n[1,2,3,4]\\n[0,1,1,2,2,1,1,2,0,1,0,2,0]\\n\\nShould they put the explanation into the description?"
                    }
                ]
            },
            {
                "id": 1721097,
                "content": [
                    {
                        "username": "renatkaitmazov",
                        "content": "I am getting a runtime error when I click the `Run Code` button with the following message:\\n`\"PeekingIterator\" is not a valid value of type integer`. What does it mean?"
                    },
                    {
                        "username": "d40a",
                        "content": "It seems that medium is too much for this problem."
                    },
                    {
                        "username": "__ron_swanson__",
                        "content": "This question is simple enough that it can be marked as Easy."
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for April, Day 25.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  **📌 Do you want to learn the problem thoroughly?**\n  Read [**⭐  LeetCode Official Solution⭐**](https://leetcode.com/problems/peeking-iterator/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 2 approaches in the official solution</summary>\n\n  \n**Approach 1:** Saving Peeked Value\n\n  \n**Approach 2:** Saving the Next Value\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "chrisTris",
                        "content": "I assume IEnumerator is in-built in C# so not included. But still it should be there. Any reasons?"
                    },
                    {
                        "username": "caplek",
                        "content": "1. During initialization of PeekingIterator IEnumerator<int> instance is already in modified state, that is its **Current** property **already points to the first entry** of iterator, whereas newly initialized instance should point to nothing until MoveNext is called.\\n1. When enumerator reaches the end Next and Peek should throw an exception, whereas according to standard behavior Current property of enumerator returns meaningless value of 0. \\n\\nThat was surprising. With all respect, I think this points should be either clarified in the task description or default behavior should be enforced in runtime."
                    },
                    {
                        "username": "disturbedbrown1",
                        "content": "Problem description could be clearer."
                    },
                    {
                        "username": "WilmerKrisp",
                        "content": "<-- pleasevote\\n\\n\\n![image](https://assets.leetcode.com/users/images/738c16f7-a745-4598-91de-9ff728ef2214_1648497319.9406855.png)\\n\\n![image](https://assets.leetcode.com/users/images/eaedd310-18c4-4c61-aaf4-c5702506fbba_1648497324.0223062.png)\\n"
                    },
                    {
                        "username": "HW311",
                        "content": "I am wondering why `Iterator::next()` and `Iterator::hasNext()` are not declared `virtual` in the provided C++ code template. They need to be virtual functions for overriding to work properly.\\n\\nYes, in simple scenarios like leetcode OJ tests this might work fine if you directly call the methods from an object of the derived class (`PeekingIterator`), however, imagine using the `PeekingIterator` through a pointer (or reference) to the base class `Iterator`, then internal states of the `PeekingIterator` will not be updated accordingly and things can go wrong."
                    },
                    {
                        "username": "linzhu1206",
                        "content": "Particularly the second line:\\n\\n[1,2,3,4]\\n[0,1,1,2,2,1,1,2,0,1,0,2,0]\\n\\nShould they put the explanation into the description?"
                    }
                ]
            },
            {
                "id": 1576556,
                "content": [
                    {
                        "username": "renatkaitmazov",
                        "content": "I am getting a runtime error when I click the `Run Code` button with the following message:\\n`\"PeekingIterator\" is not a valid value of type integer`. What does it mean?"
                    },
                    {
                        "username": "d40a",
                        "content": "It seems that medium is too much for this problem."
                    },
                    {
                        "username": "__ron_swanson__",
                        "content": "This question is simple enough that it can be marked as Easy."
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for April, Day 25.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  **📌 Do you want to learn the problem thoroughly?**\n  Read [**⭐  LeetCode Official Solution⭐**](https://leetcode.com/problems/peeking-iterator/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 2 approaches in the official solution</summary>\n\n  \n**Approach 1:** Saving Peeked Value\n\n  \n**Approach 2:** Saving the Next Value\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "chrisTris",
                        "content": "I assume IEnumerator is in-built in C# so not included. But still it should be there. Any reasons?"
                    },
                    {
                        "username": "caplek",
                        "content": "1. During initialization of PeekingIterator IEnumerator<int> instance is already in modified state, that is its **Current** property **already points to the first entry** of iterator, whereas newly initialized instance should point to nothing until MoveNext is called.\\n1. When enumerator reaches the end Next and Peek should throw an exception, whereas according to standard behavior Current property of enumerator returns meaningless value of 0. \\n\\nThat was surprising. With all respect, I think this points should be either clarified in the task description or default behavior should be enforced in runtime."
                    },
                    {
                        "username": "disturbedbrown1",
                        "content": "Problem description could be clearer."
                    },
                    {
                        "username": "WilmerKrisp",
                        "content": "<-- pleasevote\\n\\n\\n![image](https://assets.leetcode.com/users/images/738c16f7-a745-4598-91de-9ff728ef2214_1648497319.9406855.png)\\n\\n![image](https://assets.leetcode.com/users/images/eaedd310-18c4-4c61-aaf4-c5702506fbba_1648497324.0223062.png)\\n"
                    },
                    {
                        "username": "HW311",
                        "content": "I am wondering why `Iterator::next()` and `Iterator::hasNext()` are not declared `virtual` in the provided C++ code template. They need to be virtual functions for overriding to work properly.\\n\\nYes, in simple scenarios like leetcode OJ tests this might work fine if you directly call the methods from an object of the derived class (`PeekingIterator`), however, imagine using the `PeekingIterator` through a pointer (or reference) to the base class `Iterator`, then internal states of the `PeekingIterator` will not be updated accordingly and things can go wrong."
                    },
                    {
                        "username": "linzhu1206",
                        "content": "Particularly the second line:\\n\\n[1,2,3,4]\\n[0,1,1,2,2,1,1,2,0,1,0,2,0]\\n\\nShould they put the explanation into the description?"
                    }
                ]
            },
            {
                "id": 1573469,
                "content": [
                    {
                        "username": "renatkaitmazov",
                        "content": "I am getting a runtime error when I click the `Run Code` button with the following message:\\n`\"PeekingIterator\" is not a valid value of type integer`. What does it mean?"
                    },
                    {
                        "username": "d40a",
                        "content": "It seems that medium is too much for this problem."
                    },
                    {
                        "username": "__ron_swanson__",
                        "content": "This question is simple enough that it can be marked as Easy."
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for April, Day 25.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  **📌 Do you want to learn the problem thoroughly?**\n  Read [**⭐  LeetCode Official Solution⭐**](https://leetcode.com/problems/peeking-iterator/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 2 approaches in the official solution</summary>\n\n  \n**Approach 1:** Saving Peeked Value\n\n  \n**Approach 2:** Saving the Next Value\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "chrisTris",
                        "content": "I assume IEnumerator is in-built in C# so not included. But still it should be there. Any reasons?"
                    },
                    {
                        "username": "caplek",
                        "content": "1. During initialization of PeekingIterator IEnumerator<int> instance is already in modified state, that is its **Current** property **already points to the first entry** of iterator, whereas newly initialized instance should point to nothing until MoveNext is called.\\n1. When enumerator reaches the end Next and Peek should throw an exception, whereas according to standard behavior Current property of enumerator returns meaningless value of 0. \\n\\nThat was surprising. With all respect, I think this points should be either clarified in the task description or default behavior should be enforced in runtime."
                    },
                    {
                        "username": "disturbedbrown1",
                        "content": "Problem description could be clearer."
                    },
                    {
                        "username": "WilmerKrisp",
                        "content": "<-- pleasevote\\n\\n\\n![image](https://assets.leetcode.com/users/images/738c16f7-a745-4598-91de-9ff728ef2214_1648497319.9406855.png)\\n\\n![image](https://assets.leetcode.com/users/images/eaedd310-18c4-4c61-aaf4-c5702506fbba_1648497324.0223062.png)\\n"
                    },
                    {
                        "username": "HW311",
                        "content": "I am wondering why `Iterator::next()` and `Iterator::hasNext()` are not declared `virtual` in the provided C++ code template. They need to be virtual functions for overriding to work properly.\\n\\nYes, in simple scenarios like leetcode OJ tests this might work fine if you directly call the methods from an object of the derived class (`PeekingIterator`), however, imagine using the `PeekingIterator` through a pointer (or reference) to the base class `Iterator`, then internal states of the `PeekingIterator` will not be updated accordingly and things can go wrong."
                    },
                    {
                        "username": "linzhu1206",
                        "content": "Particularly the second line:\\n\\n[1,2,3,4]\\n[0,1,1,2,2,1,1,2,0,1,0,2,0]\\n\\nShould they put the explanation into the description?"
                    }
                ]
            },
            {
                "id": 1571836,
                "content": [
                    {
                        "username": "renatkaitmazov",
                        "content": "I am getting a runtime error when I click the `Run Code` button with the following message:\\n`\"PeekingIterator\" is not a valid value of type integer`. What does it mean?"
                    },
                    {
                        "username": "d40a",
                        "content": "It seems that medium is too much for this problem."
                    },
                    {
                        "username": "__ron_swanson__",
                        "content": "This question is simple enough that it can be marked as Easy."
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for April, Day 25.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  **📌 Do you want to learn the problem thoroughly?**\n  Read [**⭐  LeetCode Official Solution⭐**](https://leetcode.com/problems/peeking-iterator/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 2 approaches in the official solution</summary>\n\n  \n**Approach 1:** Saving Peeked Value\n\n  \n**Approach 2:** Saving the Next Value\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "chrisTris",
                        "content": "I assume IEnumerator is in-built in C# so not included. But still it should be there. Any reasons?"
                    },
                    {
                        "username": "caplek",
                        "content": "1. During initialization of PeekingIterator IEnumerator<int> instance is already in modified state, that is its **Current** property **already points to the first entry** of iterator, whereas newly initialized instance should point to nothing until MoveNext is called.\\n1. When enumerator reaches the end Next and Peek should throw an exception, whereas according to standard behavior Current property of enumerator returns meaningless value of 0. \\n\\nThat was surprising. With all respect, I think this points should be either clarified in the task description or default behavior should be enforced in runtime."
                    },
                    {
                        "username": "disturbedbrown1",
                        "content": "Problem description could be clearer."
                    },
                    {
                        "username": "WilmerKrisp",
                        "content": "<-- pleasevote\\n\\n\\n![image](https://assets.leetcode.com/users/images/738c16f7-a745-4598-91de-9ff728ef2214_1648497319.9406855.png)\\n\\n![image](https://assets.leetcode.com/users/images/eaedd310-18c4-4c61-aaf4-c5702506fbba_1648497324.0223062.png)\\n"
                    },
                    {
                        "username": "HW311",
                        "content": "I am wondering why `Iterator::next()` and `Iterator::hasNext()` are not declared `virtual` in the provided C++ code template. They need to be virtual functions for overriding to work properly.\\n\\nYes, in simple scenarios like leetcode OJ tests this might work fine if you directly call the methods from an object of the derived class (`PeekingIterator`), however, imagine using the `PeekingIterator` through a pointer (or reference) to the base class `Iterator`, then internal states of the `PeekingIterator` will not be updated accordingly and things can go wrong."
                    },
                    {
                        "username": "linzhu1206",
                        "content": "Particularly the second line:\\n\\n[1,2,3,4]\\n[0,1,1,2,2,1,1,2,0,1,0,2,0]\\n\\nShould they put the explanation into the description?"
                    }
                ]
            }
        ]
    }
]