[
    {
        "title": "Magical String",
        "question_content": "A magical string s consists of only '1' and '2' and obeys the following rules:\n\n\tThe string s is magical because concatenating the number of contiguous occurrences of characters '1' and '2' generates the string s itself.\n\nThe first few elements of s is s = \"1221121221221121122&hellip;&hellip;\". If we group the consecutive 1's and 2's in s, it will be \"1 22 11 2 1 22 1 22 11 2 11 22 ......\" and the occurrences of 1's or 2's in each group are \"1 2 2 1 1 2 1 2 2 1 2 2 ......\". You can see that the occurrence sequence is s itself.\nGiven an integer n, return the number of 1's in the first n number in the magical string s.\n&nbsp;\nExample 1:\n\nInput: n = 6\nOutput: 3\nExplanation: The first 6 elements of magical string s is \"122112\" and it contains three 1's, so return 3.\n\nExample 2:\n\nInput: n = 1\nOutput: 1\n\n&nbsp;\nConstraints:\n\n\t1 <= n <= 105",
        "solutions": [
            {
                "id": 96413,
                "title": "simple-java-solution-using-one-array-and-two-pointers",
                "content": "Algorithm:\\n1. Create an ```int``` array ```a``` and initialize the first 3 elements with ```1, 2, 2```.\\n2. Create two pointers ```head``` and ```tail```. ```head``` points to the number which will be used to generate new numbers. ```tail``` points to the next empty position to put the new number. Then keep generating new numbers until ```tail``` >= ```n```. \\n3. Need to create the array 1 element more than ```n``` to avoid overflow because the last round ```head``` might points to a number ```2```. \\n4. A trick to flip number back and forth between ```1``` and ```2```: ```num = num ^ 3```\\n```\\npublic class Solution {\\n    public int magicalString(int n) {\\n        if (n <= 0) return 0;\\n        if (n <= 3) return 1;\\n        \\n        int[] a = new int[n + 1];\\n        a[0] = 1; a[1] = 2; a[2] = 2;\\n        int head = 2, tail = 3, num = 1, result = 1;\\n        \\n        while (tail < n) {\\n            for (int i = 0; i < a[head]; i++) {\\n                a[tail] = num;\\n                if (num == 1 && tail < n) result++;\\n                tail++;\\n            }\\n            num = num ^ 3;\\n            head++;\\n        }\\n        \\n        return result;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```int```\n```a```\n```1, 2, 2```\n```head```\n```tail```\n```head```\n```tail```\n```tail```\n```n```\n```n```\n```head```\n```2```\n```1```\n```2```\n```num = num ^ 3```\n```\\npublic class Solution {\\n    public int magicalString(int n) {\\n        if (n <= 0) return 0;\\n        if (n <= 3) return 1;\\n        \\n        int[] a = new int[n + 1];\\n        a[0] = 1; a[1] = 2; a[2] = 2;\\n        int head = 2, tail = 3, num = 1, result = 1;\\n        \\n        while (tail < n) {\\n            for (int i = 0; i < a[head]; i++) {\\n                a[tail] = num;\\n                if (num == 1 && tail < n) result++;\\n                tail++;\\n            }\\n            num = num ^ 3;\\n            head++;\\n        }\\n        \\n        return result;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 96408,
                "title": "short-c",
                "content": "Just build enough of the string and then count.\\n\\n    int magicalString(int n) {\\n        string S = \"122\";\\n        int i = 2;\\n        while (S.size() < n)\\n            S += string(S[i++] - '0', S.back() ^ 3);\\n        return count(S.begin(), S.begin() + n, '1');\\n    }",
                "solutionTags": [],
                "code": "Just build enough of the string and then count.\\n\\n    int magicalString(int n) {\\n        string S = \"122\";\\n        int i = 2;\\n        while (S.size() < n)\\n            S += string(S[i++] - '0', S.back() ^ 3);\\n        return count(S.begin(), S.begin() + n, '1');\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 96432,
                "title": "o-log-n-space-using-recursive-generators",
                "content": "There's a paper called [A Space-Efficient Algorithm for Calculating the Digit Distribution in the Kolakoski Sequence](http://www.emis.ams.org/journals/JIS/VOL15/Nilsson/nilsson5.pdf) about an O(log n) space and O(n) time algorithm. I didn't read the paper but wrote my code based on Figure 1 on page 3. I use one generator per level, and to get things going, I hardcode the first three digits caused by the first two digits of the level above (which I therefore ignore).\\n\\n    def magicalString(self, n):\\n        def gen():\\n            for x in 1, 2, 2:\\n                yield x\\n            for i, x in enumerate(gen()):\\n                if i > 1:\\n                    for _ in range(x):\\n                        yield i % 2 + 1\\n        return sum(x & 1 for x in itertools.islice(gen(), n))\\n\\nI think it's O(log n) space and O(n) time. Here are test results for different n, counting the numbers of generators and yields to measure space and time:\\n```\\n     n      generators  yields\\n             (=space)   (=time)\\n         1         1         1\\n        10         4        25\\n       100        10       295\\n      1000        16      3001\\n     10000        22     30028\\n    100000        27    299935\\n   1000000        33   2999958\\n  10000000        39  29999888\\n 100000000        44 300001534\\n```\\nThe number of generators is very close to log<sub>1.5</sub>(n), which makes sense because [apparently there are about equally many ones and twos in any prefix of the sequence](https://en.wikipedia.org/wiki/Kolakoski_sequence#Density), so on average one digit in a generator causes 1.5 digits in the generator using it.\\n\\nThe number of yields is very close to 3n, which also makes sense. The outermost generator yields n times, the generator it uses yields about (2/3)n times, the next inner generator yields about (2/3)<sup>2</sup>n times, and so on. So the total number of yields is about:\\nn &sdot; &sum;<sub>i=0..&infin;</sub> (2/3)<sup>i</sup> = n &sdot; 1/(1-2/3) = 3n\\n\\nHere's the testing code:\\n```\\nimport itertools\\n\\nclass Solution(object):\\n    def magicalString(self, n):\\n        def gen():\\n            global generators, yields\\n            generators += 1\\n            for x in 1, 2, 2:\\n                yields += 1\\n                yield x\\n            for i, x in enumerate(gen()):\\n                if i > 1:\\n                    for _ in range(x):\\n                        yields += 1\\n                        yield i % 2 + 1\\n        return sum(x & 1 for x in itertools.islice(gen(), n))\\n\\nprint '     n      generators  yields'\\nprint '             (=space)   (=time)'\\nfor e in range(9):\\n    n = 10**e\\n    generators = yields = 0\\n    Solution().magicalString(n)\\n    print '%10d' * 3 % (n, generators, yields)\\n```",
                "solutionTags": [],
                "code": "```\\n     n      generators  yields\\n             (=space)   (=time)\\n         1         1         1\\n        10         4        25\\n       100        10       295\\n      1000        16      3001\\n     10000        22     30028\\n    100000        27    299935\\n   1000000        33   2999958\\n  10000000        39  29999888\\n 100000000        44 300001534\\n```\n```\\nimport itertools\\n\\nclass Solution(object):\\n    def magicalString(self, n):\\n        def gen():\\n            global generators, yields\\n            generators += 1\\n            for x in 1, 2, 2:\\n                yields += 1\\n                yield x\\n            for i, x in enumerate(gen()):\\n                if i > 1:\\n                    for _ in range(x):\\n                        yields += 1\\n                        yield i % 2 + 1\\n        return sum(x & 1 for x in itertools.islice(gen(), n))\\n\\nprint '     n      generators  yields'\\nprint '             (=space)   (=time)'\\nfor e in range(9):\\n    n = 10**e\\n    generators = yields = 0\\n    Solution().magicalString(n)\\n    print '%10d' * 3 % (n, generators, yields)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 96472,
                "title": "short-python-using-queue",
                "content": "Since how many current \"1\" or \"2\" depends on previous number in S, we can use a queue to get the corresponding information we need. Every time we update S, we update queue as well.\\n\\nUpdated: based @StefanPochmann 's idea, we can only use an index to indict current number of value we need.\\n```\\nclass Solution(object):\\n    def magicalString(self, n):\\n        \"\"\"\\n        :type n: int\\n        :rtype: int\\n        \"\"\"\\n        S = [1,2,2]\\n        idx = 2\\n        while len(S) < n:\\n            S += S[idx] * [(3 - S[-1])]\\n            idx += 1\\n        return S[:n].count(1)\\n```\\n\\nOld version:\\n```\\nclass Solution(object):\\n    def magicalString(self, n):\\n        \"\"\"\\n        :type n: int\\n        :rtype: int\\n        \"\"\"\\n        queue = collections.deque([2])\\n        S = [1,2,2]\\n        while len(S) < n:\\n            k = queue.popleft()\\n            tmp = 3 - S[-1]\\n            for i in range(k):\\n                S.append(tmp)\\n                queue.append(tmp)\\n        return S[:n].count(1)\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution(object):\\n    def magicalString(self, n):\\n        \"\"\"\\n        :type n: int\\n        :rtype: int\\n        \"\"\"\\n        S = [1,2,2]\\n        idx = 2\\n        while len(S) < n:\\n            S += S[idx] * [(3 - S[-1])]\\n            idx += 1\\n        return S[:n].count(1)\\n```\n```\\nclass Solution(object):\\n    def magicalString(self, n):\\n        \"\"\"\\n        :type n: int\\n        :rtype: int\\n        \"\"\"\\n        queue = collections.deque([2])\\n        S = [1,2,2]\\n        while len(S) < n:\\n            k = queue.popleft()\\n            tmp = 3 - S[-1]\\n            for i in range(k):\\n                S.append(tmp)\\n                queue.append(tmp)\\n        return S[:n].count(1)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 96433,
                "title": "the-example-in-the-problem-seems-to-be-wrong",
                "content": "```\\nInput: 6\\nOutput: 3\\nExplanation: The first 6 elements of magical string S is \"12211\" and it contains three 1's, so return 3.\\n```\\nShouldn't it be first 5 elements (12211) instead of 6? Am I stupid?",
                "solutionTags": [],
                "code": "```\\nInput: 6\\nOutput: 3\\nExplanation: The first 6 elements of magical string S is \"12211\" and it contains three 1's, so return 3.\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 139180,
                "title": "python-solution-78ms-beats-100",
                "content": "we must know how the magical string extend, we just need to construct this string step by step\\n\\nfirst there is only \\'1\\', so it means the first group only contains one number,what should we append?\\nit must be different with the last element, but how many(1 or 2) should we append?\\n\\nFor convenience, we get started from \\'122\\',now the first \\'1\\' represent \\'1\\',the first \\'2\\' represent \\'22\\',now we append something __val__ * 2 because the third element is \\'2\\', and  due to the last element is \\'2\\', so we need to append \\'1\\', means val = 1, now the string is \\'12211\\', because the fourth element is \\'1\\',so we need to append something  __val__* 1, and the last element is 1,so val = 2,and so on.\\n\\n```python\\ns = [1,2,2]\\nindex = 2\\nwhile len(s) < 100000:\\n\\t# according to the last element, we decide the value of \\'val\\'\\n\\tval = 3 - s[-1]\\n\\ts.extend([val]*s[index])\\n\\tindex += 1\\n\\nclass Solution(object):\\n    def magicalString(self, n):\\n        \"\"\"\\n        :type n: int\\n        :rtype: int\\n        \"\"\"\\n        return s[:n].count(1)\\n```\\n\\n",
                "solutionTags": [],
                "code": "```python\\ns = [1,2,2]\\nindex = 2\\nwhile len(s) < 100000:\\n\\t# according to the last element, we decide the value of \\'val\\'\\n\\tval = 3 - s[-1]\\n\\ts.extend([val]*s[index])\\n\\tindex += 1\\n\\nclass Solution(object):\\n    def magicalString(self, n):\\n        \"\"\"\\n        :type n: int\\n        :rtype: int\\n        \"\"\"\\n        return s[:n].count(1)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 96419,
                "title": "very-straightforward-and-simple-java-solution-o-n",
                "content": "```\\npublic int magicalString(int n) {\\n        StringBuilder magic = new StringBuilder(\"1221121221221121122\");\\n        int pt1 = 12, pt2 = magic.length(), count = 0; //initiate pointers\\n        //generate sequence directly\\n        while(magic.length() < n){\\n            if(magic.charAt(pt1) == '1'){\\n                if(magic.charAt(pt2-1) == '1') magic.append(2);\\n                else magic.append(1);\\n                pt2++;\\n            }else{ //==2\\n                if(magic.charAt(pt2-1) == '1') magic.append(22);\\n                else magic.append(11);\\n                pt2+=2;\\n            }\\n            pt1++;\\n        }\\n        for(int i=0;i<n;i++)\\n            if(magic.charAt(i)=='1') count++;\\n        return count;\\n    }\\n```",
                "solutionTags": [],
                "code": "```\\npublic int magicalString(int n) {\\n        StringBuilder magic = new StringBuilder(\"1221121221221121122\");\\n        int pt1 = 12, pt2 = magic.length(), count = 0; //initiate pointers\\n        //generate sequence directly\\n        while(magic.length() < n){\\n            if(magic.charAt(pt1) == '1'){\\n                if(magic.charAt(pt2-1) == '1') magic.append(2);\\n                else magic.append(1);\\n                pt2++;\\n            }else{ //==2\\n                if(magic.charAt(pt2-1) == '1') magic.append(22);\\n                else magic.append(11);\\n                pt2+=2;\\n            }\\n            pt1++;\\n        }\\n        for(int i=0;i<n;i++)\\n            if(magic.charAt(i)=='1') count++;\\n        return count;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3149074,
                "title": "c-faster-than-85-easy-approach-clean-concise-code",
                "content": "\\n\\n# Code\\n```\\n\\nclass Solution {\\npublic:\\n\\n    int magicalString(int n) {\\n      \\n       if( n <= 3) return 1;\\n       string s = \"122\";\\n       int i = 2;\\n       while(s.size() < n)\\n       {\\n          if(s[i]==\\'1\\')\\n          {\\n              if(s[s.size()-1] == \\'2\\') s.push_back(\\'1\\');\\n              else s.push_back(\\'2\\');\\n          }\\n\\n          else\\n          {\\n              if(s[s.size()-1] == \\'2\\') s += \"11\";\\n              else s += \"22\";\\n          }\\n          i++;\\n       }\\n       int cnt = count(s.begin(),s.begin() + n,\\'1\\');\\n\\n       return cnt;\\n    }\\n};\\n\\n\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\n\\nclass Solution {\\npublic:\\n\\n    int magicalString(int n) {\\n      \\n       if( n <= 3) return 1;\\n       string s = \"122\";\\n       int i = 2;\\n       while(s.size() < n)\\n       {\\n          if(s[i]==\\'1\\')\\n          {\\n              if(s[s.size()-1] == \\'2\\') s.push_back(\\'1\\');\\n              else s.push_back(\\'2\\');\\n          }\\n\\n          else\\n          {\\n              if(s[s.size()-1] == \\'2\\') s += \"11\";\\n              else s += \"22\";\\n          }\\n          i++;\\n       }\\n       int cnt = count(s.begin(),s.begin() + n,\\'1\\');\\n\\n       return cnt;\\n    }\\n};\\n\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1394958,
                "title": "really-easy-c-sol-96-3-faster-from-observation-with-detail-explanation",
                "content": "How would you produce the string?\\nNotice that it starts with 122 and there on you keep adding either 1 or 2 x number of times to it and build it. x is determined by the s[ind] where ind starts with 2 (last index at beginning). s[2] = 2, so you add two 1s and then flip the character to be added to become 2. ind becomes 3, s[3] = 1, so add one 2 and so on until length of string is n or more.\\n```\\nclass Solution {\\npublic:\\n    char flip(char c) {\\n        if(c == \\'1\\')\\n            return \\'2\\';\\n        else return \\'1\\';\\n    }\\n    \\n    int magicalString(int n) {\\n        string s = \"122\";\\n        char next = \\'1\\';\\n        int ind = 2;\\n        int ans = 1;\\n        while(s.size() < n) {\\n            int t = s[ind] - \\'0\\';\\n            while(t--) {\\n                s.push_back(next);\\n                ans += ((s.size() <= n && next == \\'1\\') ? 1 : 0);\\n            }\\n            ind++;\\n            next = flip(next);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    char flip(char c) {\\n        if(c == \\'1\\')\\n            return \\'2\\';\\n        else return \\'1\\';\\n    }\\n    \\n    int magicalString(int n) {\\n        string s = \"122\";\\n        char next = \\'1\\';\\n        int ind = 2;\\n        int ans = 1;\\n        while(s.size() < n) {\\n            int t = s[ind] - \\'0\\';\\n            while(t--) {\\n                s.push_back(next);\\n                ans += ((s.size() <= n && next == \\'1\\') ? 1 : 0);\\n            }\\n            ind++;\\n            next = flip(next);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 268668,
                "title": "simple-readable-python-o-n",
                "content": "Index 2 is the first value where the generated group does not include the value itself.\\n```\\ndef magicalString(self, n: int) -> int:\\n\\tS = [1, 2, 2]\\n\\n\\ti = 2\\n\\twhile len(S) < n:\\n\\t\\tcomplement = 2 if S[-1] == 1 else 1\\n\\t\\tS.extend([complement] * S[i])\\n\\t\\ti += 1\\n\\n\\treturn S[:n].count(1)\\n```",
                "solutionTags": [],
                "code": "```\\ndef magicalString(self, n: int) -> int:\\n\\tS = [1, 2, 2]\\n\\n\\ti = 2\\n\\twhile len(S) < n:\\n\\t\\tcomplement = 2 if S[-1] == 1 else 1\\n\\t\\tS.extend([complement] * S[i])\\n\\t\\ti += 1\\n\\n\\treturn S[:n].count(1)\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 96442,
                "title": "c-solutions",
                "content": "1) build string\\nthe most concise\\nit is from this post:\\nhttps://discuss.leetcode.com/topic/74637/short-c\\n```\\nclass Solution {\\npublic:\\n    int magicalString(int n) {\\n        string s = \"122\";\\n        int i = 2;\\n        while (s.length() < n)\\n            s.append(s[i++] - '0', s.back() ^ 3); // binary form of '1' is 011 0001\\n        return count(s.begin(), s.begin() + n, '1');\\n    }\\n};\\n```\\n\\n\\n2) build array instead of string\\n```\\nclass Solution {\\npublic:\\n    int magicalString(int n) {\\n        vector<int> v = {1, 2, 2};\\n        int i = 2;\\n        while (v.size() < n)\\n            v.insert(v.end(), v[i++], v.back() ^ 3);\\n        return count(v.begin(), v.begin() + n, 1);\\n    }\\n};\\n```\\n\\n3) use queue instead of building string\\n```\\nclass Solution {\\npublic:\\n    int magicalString(int n) {\\n        if (n < 1)\\n            return 0;\\n        \\n        queue<int> q;\\n        int ans = 1, num = 1, count = 2, i = 3;\\n        while (i < n) {\\n            while (count--) {\\n                q.push(num);\\n                if (i < n && num == 1)\\n                    ++ans;\\n                ++i;\\n            }\\n            \\n            num ^= 3; // num = (num == 1 ? 2 : 1);\\n            count = q.front();\\n            q.pop();\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int magicalString(int n) {\\n        string s = \"122\";\\n        int i = 2;\\n        while (s.length() < n)\\n            s.append(s[i++] - '0', s.back() ^ 3); // binary form of '1' is 011 0001\\n        return count(s.begin(), s.begin() + n, '1');\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    int magicalString(int n) {\\n        vector<int> v = {1, 2, 2};\\n        int i = 2;\\n        while (v.size() < n)\\n            v.insert(v.end(), v[i++], v.back() ^ 3);\\n        return count(v.begin(), v.begin() + n, 1);\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    int magicalString(int n) {\\n        if (n < 1)\\n            return 0;\\n        \\n        queue<int> q;\\n        int ans = 1, num = 1, count = 2, i = 3;\\n        while (i < n) {\\n            while (count--) {\\n                q.push(num);\\n                if (i < n && num == 1)\\n                    ++ans;\\n                ++i;\\n            }\\n            \\n            num ^= 3; // num = (num == 1 ? 2 : 1);\\n            count = q.front();\\n            q.pop();\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3041129,
                "title": "best-explanation-c-easy-to-understand-comments",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nIntution was to find the repeating part first, then i saw the pattern carefully and tried to make it.\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nWe can make the string using first three digits only \"122\",my intution is to make whole string upto length n,and count ones side by side. Also to count the remaining 1\\'s after while loop breaks\\n\\n# Complexity\\n- Time complexity:O(N)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:o(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int magicalString(int n) {\\n        string s=\"\";\\n        s+=\"122\";\\n        int i=2,c=1;\\n        while(i<n && s.size()<n)\\n        {\\n            if(s[i]==\\'1\\')\\n            {\\n                c++;\\n                if(s[s.size()-1]==\\'2\\')\\n                s+=\\'1\\';\\n                else\\n                {\\n                    s+=\\'2\\';\\n                }\\n            }\\n            else\\n            {\\n                if(s[s.size()-1]==\\'2\\')\\n                s+=\"11\";\\n                else\\n                {\\n                    s+=\"22\";\\n                }\\n            }\\n            i++;\\n        }\\n        while(i<n)\\n        {\\n            if(s[i]==\\'1\\')\\n            c++;\\n            i++;\\n        }\\n        return c;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "String"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int magicalString(int n) {\\n        string s=\"\";\\n        s+=\"122\";\\n        int i=2,c=1;\\n        while(i<n && s.size()<n)\\n        {\\n            if(s[i]==\\'1\\')\\n            {\\n                c++;\\n                if(s[s.size()-1]==\\'2\\')\\n                s+=\\'1\\';\\n                else\\n                {\\n                    s+=\\'2\\';\\n                }\\n            }\\n            else\\n            {\\n                if(s[s.size()-1]==\\'2\\')\\n                s+=\"11\";\\n                else\\n                {\\n                    s+=\"22\";\\n                }\\n            }\\n            i++;\\n        }\\n        while(i<n)\\n        {\\n            if(s[i]==\\'1\\')\\n            c++;\\n            i++;\\n        }\\n        return c;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 96416,
                "title": "short-java-with-queue-and-one-loop-o-n-in-time-and-o-1-in-space",
                "content": "```\\npublic int magicalString(int n) {\\n        if (n <= 0) return 0;\\n        if (n <= 3) return 1;\\n        \\n        Queue<Integer> q = new LinkedList<>();\\n        q.offer(2);\\n        int j=4, sum=1;\\n        boolean one=true; // turn for one \\n        while(j<n+1){\\n            int end = q.poll();\\n            while(end>0 && j<n+1){\\n                j++;\\n                if(one){\\n                    q.offer(1);\\n                    sum++;\\n                }\\n                else  \\n                    q.offer(2);\\n                end--;\\n                \\n            }\\n            one = !one; //  change to another\\n            \\n        }\\n        \\n        return sum;\\n        \\n    }\\n\\n```",
                "solutionTags": [],
                "code": "```\\npublic int magicalString(int n) {\\n        if (n <= 0) return 0;\\n        if (n <= 3) return 1;\\n        \\n        Queue<Integer> q = new LinkedList<>();\\n        q.offer(2);\\n        int j=4, sum=1;\\n        boolean one=true; // turn for one \\n        while(j<n+1){\\n            int end = q.poll();\\n            while(end>0 && j<n+1){\\n                j++;\\n                if(one){\\n                    q.offer(1);\\n                    sum++;\\n                }\\n                else  \\n                    q.offer(2);\\n                end--;\\n                \\n            }\\n            one = !one; //  change to another\\n            \\n        }\\n        \\n        return sum;\\n        \\n    }\\n\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 96458,
                "title": "o-log-n-space-java",
                "content": "Based on [my Python solution](https://discuss.leetcode.com/topic/75242/o-log-n-space-using-recursive-generators). Here I use a helper class giving me the Kolakoski sequence ([that's its name](https://en.wikipedia.org/wiki/Kolakoski_sequence)) one element at a time with its `next` method. It has the first three elements hard-coded, and after that, it uses another instance of the sequence to iterate further. That other instance does the same, so it might eventually use yet another instance. And so on, O(log n) nested Kolakoski objects iterating in parallel at different speeds as needed. Takes O(log n) space and O(n) time.\\n\\n```\\npublic class Solution {\\n\\n    public int magicalString(int n) {\\n        Kolakoski kolakoski = new Kolakoski();\\n        int ones = 0;\\n        while (n-- > 0)\\n            if (kolakoski.next() == 1)\\n                ones++;\\n        return ones;\\n    }\\n\\n    private class Kolakoski {\\n        private int[] queue = {1, 2, 2};\\n        private int first = 0, last = 2;\\n        private Kolakoski source;\\n        int next() {\\n            if (first > last) {\\n                if (source == null) {\\n                    source = new Kolakoski();\\n                    source.next();\\n                    source.next();\\n                }\\n                int output = queue[last % 3] ^ 3;\\n                for (int k = source.next(); k > 0; k--)\\n                    queue[++last % 3] = output;\\n            }\\n            return queue[first++ % 3];\\n        }\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\npublic class Solution {\\n\\n    public int magicalString(int n) {\\n        Kolakoski kolakoski = new Kolakoski();\\n        int ones = 0;\\n        while (n-- > 0)\\n            if (kolakoski.next() == 1)\\n                ones++;\\n        return ones;\\n    }\\n\\n    private class Kolakoski {\\n        private int[] queue = {1, 2, 2};\\n        private int first = 0, last = 2;\\n        private Kolakoski source;\\n        int next() {\\n            if (first > last) {\\n                if (source == null) {\\n                    source = new Kolakoski();\\n                    source.next();\\n                    source.next();\\n                }\\n                int output = queue[last % 3] ^ 3;\\n                for (int k = source.next(); k > 0; k--)\\n                    queue[++last % 3] = output;\\n            }\\n            return queue[first++ % 3];\\n        }\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3042074,
                "title": "c-solution-using-string-only-very-easy-to-understand",
                "content": "\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int magicalString(int n) {\\n        if(n <= 2) return 1;\\n\\n        string s = \"122\";\\n        int i = 2,end=2;\\n        while(s.size() < n){\\n            if(s[i] == \\'1\\'){\\n                if(s[end]==\\'2\\'){\\n                    s.push_back(\\'1\\');\\n                }\\n                else{\\n                    s.push_back(\\'2\\');\\n                }\\n            }\\n            else{\\n                if(s[end]==\\'2\\'){\\n                   s += \"11\";\\n                }\\n                else{\\n                    s += \"22\";\\n                }\\n            }\\n\\n            i++;\\n            end = s.size() - 1;\\n        }\\n\\n        int ans = 0;\\n        for(int i=0;i<n;i++){\\n            if(s[i]==\\'1\\') ans++;\\n        }\\n\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "String"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int magicalString(int n) {\\n        if(n <= 2) return 1;\\n\\n        string s = \"122\";\\n        int i = 2,end=2;\\n        while(s.size() < n){\\n            if(s[i] == \\'1\\'){\\n                if(s[end]==\\'2\\'){\\n                    s.push_back(\\'1\\');\\n                }\\n                else{\\n                    s.push_back(\\'2\\');\\n                }\\n            }\\n            else{\\n                if(s[end]==\\'2\\'){\\n                   s += \"11\";\\n                }\\n                else{\\n                    s += \"22\";\\n                }\\n            }\\n\\n            i++;\\n            end = s.size() - 1;\\n        }\\n\\n        int ans = 0;\\n        for(int i=0;i<n;i++){\\n            if(s[i]==\\'1\\') ans++;\\n        }\\n\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2558509,
                "title": "481-magical-string",
                "content": "```\\nclass Solution:\\n    def magicalString(self, n: int) -> int:\\n        arr, i = [1,2,2], 2\\n   \\n        while len(arr) < n:\\n            arr.extend([arr[-1]^3]*arr[i])\\n            i += 1\\n    \\n        return arr[:n].count(1)",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def magicalString(self, n: int) -> int:\\n        arr, i = [1,2,2], 2\\n   \\n        while len(arr) < n:\\n            arr.extend([arr[-1]^3]*arr[i])\\n            i += 1\\n    \\n        return arr[:n].count(1)",
                "codeTag": "Java"
            },
            {
                "id": 2355641,
                "title": "easy-python-solution-with-explanation",
                "content": "1. We have to create the magic string upto length n.\\n2. We will do that by using the string itself.\\n3. So, one pointer will be telling us the count of the latest adding to the string.\\n4. I hope that\\'s well clear to you. If not then once again. If it is 2, then it\\'s telling that something is in the count of 2, it could be either 1 or 2, whatever...., but it\\'s count is 2.\\n5. Now what that should be. Let\\'s try any number, lets say 1. But accidentally, even the num at last index was 1. Which means now the consecutive count of 1 is not what we wished for, but atleast 1 more than that.\\n6. So, that whatever will not be the one, last in the current string, but the other one.\\n7. So just keep following this until the length of your string crosses/touches n. :)\\n```\\ndef magicalString(self, n: int) -> int:\\n\\ts = [\"1\", \"2\", \"2\"]\\n\\tfor i in range(2, n):\\n\\t\\tp = s[-1] == \"2\"\\n\\t\\tif(s[-1] == \\'2\\'):\\n\\t\\t\\ts += [\"1\"] * int(s[i])\\n\\t\\telse:\\n\\t\\t\\ts += [\"2\"] * int(s[i])\\n\\t\\tif(len(s) > n): break\\n\\treturn s[:n].count(\\'1\\')\\n```",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\ndef magicalString(self, n: int) -> int:\\n\\ts = [\"1\", \"2\", \"2\"]\\n\\tfor i in range(2, n):\\n\\t\\tp = s[-1] == \"2\"\\n\\t\\tif(s[-1] == \\'2\\'):\\n\\t\\t\\ts += [\"1\"] * int(s[i])\\n\\t\\telse:\\n\\t\\t\\ts += [\"2\"] * int(s[i])\\n\\t\\tif(len(s) > n): break\\n\\treturn s[:n].count(\\'1\\')\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 771089,
                "title": "simple-c-solution-with-explanation-16-ms-runtime",
                "content": "Just create the array for n number of terms and count the number of ones in it. Pretty basic solution, i guess the main trick is how to evaluate the next term of the series. I have taken 2 pointers, one deciding how many consecutive numbers to add and the other one adding them. The second pointer `idx` inserts the value opposite to `idx-1`. \\nFor example, if `arr[i]` is `1` then that means we have to insert 1 number at `idx` position that is alternate to its previous value i.e `idx-1`\\n\\nC++ Solution\\n\\n```\\nclass Solution {\\npublic:\\n    static const long n = 1e5+1;\\n    short arr[n];\\n    Solution(){\\n        arr[0] = 1;\\n        arr[1] = 2;\\n        \\n        \\n        int i = 1, idx = 1;\\n        while(idx<n){\\n            \\n            if(arr[i]==1){\\n                arr[idx] = arr[idx-1]%2 + 1;\\n            }else{\\n                int val = arr[idx-1]%2 + 1;\\n                arr[idx++] = val;\\n                \\n                if(idx==n) break;\\n                arr[idx] = val;\\n            }\\n            idx++;\\n            i++;\\n            \\n        }\\n    }\\n    int magicalString(int n) {\\n        int count = 0;\\n        for(int i = 0; i < n; i++)\\n            if(arr[i] == 1)\\n                count++;\\n        return count;\\n    }\\n};\\n```\\n\\nI have evaluated the array for the whole constraint in the constructor so as to prevent calculating it for every n in each test case.",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    static const long n = 1e5+1;\\n    short arr[n];\\n    Solution(){\\n        arr[0] = 1;\\n        arr[1] = 2;\\n        \\n        \\n        int i = 1, idx = 1;\\n        while(idx<n){\\n            \\n            if(arr[i]==1){\\n                arr[idx] = arr[idx-1]%2 + 1;\\n            }else{\\n                int val = arr[idx-1]%2 + 1;\\n                arr[idx++] = val;\\n                \\n                if(idx==n) break;\\n                arr[idx] = val;\\n            }\\n            idx++;\\n            i++;\\n            \\n        }\\n    }\\n    int magicalString(int n) {\\n        int count = 0;\\n        for(int i = 0; i < n; i++)\\n            if(arr[i] == 1)\\n                count++;\\n        return count;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 96459,
                "title": "beat-91-java-solution",
                "content": "Thanks to the [paper](http://www.emis.ams.org/journals/JIS/VOL15/Nilsson/nilsson5.pdf) that @StefanPochmann mentioned in his [post](https://discuss.leetcode.com/topic/75242/o-log-n-space-using-recursive-generators). Just as Stefan said, all we need is the graph in page 3. It's really impressive.\\n\\nBelow is the code beating 91% in Java, well, I first time wanted to write a recursive solution, but ended with stackoverflow.\\n\\n```\\npublic int magicalString(int n) {\\n        if (n == 0) return 0;\\n        if (n <= 3) return 1;\\n        \\n        int[] arr = new int[n + 1];\\n        arr[0] = 1; arr[1] = 2; arr[2] = 2;\\n        \\n        int head = 2, tail = 3, val = 1, count = 1;\\n        while (tail < n) {\\n            if (val == 1) count += arr[head];\\n            for (int i = 0; i < arr[head]; i++) {\\n                arr[tail++] = val;\\n            }\\n            head++;\\n            val ^= 3;\\n        }\\n        if (arr[n] == 1) count--;\\n        return count;\\n    }\\n```",
                "solutionTags": [],
                "code": "```\\npublic int magicalString(int n) {\\n        if (n == 0) return 0;\\n        if (n <= 3) return 1;\\n        \\n        int[] arr = new int[n + 1];\\n        arr[0] = 1; arr[1] = 2; arr[2] = 2;\\n        \\n        int head = 2, tail = 3, val = 1, count = 1;\\n        while (tail < n) {\\n            if (val == 1) count += arr[head];\\n            for (int i = 0; i < arr[head]; i++) {\\n                arr[tail++] = val;\\n            }\\n            head++;\\n            val ^= 3;\\n        }\\n        if (arr[n] == 1) count--;\\n        return count;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3281323,
                "title": "481-solution-with-step-by-step-explanation",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n1. Check if input n is 0, if so, return 0 as the output.\\n\\n2. Initialize the magical string s with the first three elements, which are 1, 2, 2.\\n\\n3. Initialize a variable i to 2, which will be used to keep track of the index of the current number in s.\\n\\n4. Start a while loop that continues until the length of s is less than n.\\n\\n5. Inside the while loop, append to s the next number in the sequence, which is 3 minus the previous number in s.\\n\\n6. The number of times to append the next number in the sequence is given by the value at index i in s.\\n\\n7. Increment i by 1.\\n\\n8. Once the while loop is finished, return the number of 1\\'s in the first n elements of s by counting how many times 1 appears in the sublist s[:n].\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def magicalString(self, n: int) -> int:\\n        if n == 0:\\n            return 0\\n        s = [1, 2, 2]\\n        i = 2\\n        while len(s) < n:\\n            s += [3 - s[-1]] * s[i]\\n            i += 1\\n        return s[:n].count(1)\\n```",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Two Pointers",
                    "String"
                ],
                "code": "```\\nclass Solution:\\n    def magicalString(self, n: int) -> int:\\n        if n == 0:\\n            return 0\\n        s = [1, 2, 2]\\n        i = 2\\n        while len(s) < n:\\n            s += [3 - s[-1]] * s[i]\\n            i += 1\\n        return s[:n].count(1)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3210321,
                "title": "c-2-pointers",
                "content": "```\\nclass Solution {\\npublic:\\n    int magicalString(int n) {\\n        \\n        int ans=0;\\n        if(n <=3)  return 1;\\n        \\n        string s= \"122\";\\n        \\n        int i=2;\\n        while(s.size()<n){\\n           \\n            if(s.back() == \\'1\\'){\\n                if(s[i] == \\'1\\') s+=\\'2\\';\\n                else if(s[i] == \\'2\\') s+=\"22\";\\n                \\n            }else{\\n                 \\n                if(s[i] == \\'1\\') s+=\\'1\\';\\n                else if(s[i] == \\'2\\') s+=\"11\";\\n            }\\n            i++;\\n        }  \\n        cout<<s<<endl;\\n        \\n        for(int i=0;i<n;i++){\\n            if(s[i] == \\'1\\') ans++;\\n        }\\n        \\n        return ans;\\n    }\\n};\\n\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int magicalString(int n) {\\n        \\n        int ans=0;\\n        if(n <=3)  return 1;\\n        \\n        string s= \"122\";\\n        \\n        int i=2;\\n        while(s.size()<n){\\n           \\n            if(s.back() == \\'1\\'){\\n                if(s[i] == \\'1\\') s+=\\'2\\';\\n                else if(s[i] == \\'2\\') s+=\"22\";\\n                \\n            }else{\\n                 \\n                if(s[i] == \\'1\\') s+=\\'1\\';\\n                else if(s[i] == \\'2\\') s+=\"11\";\\n            }\\n            i++;\\n        }  \\n        cout<<s<<endl;\\n        \\n        for(int i=0;i<n;i++){\\n            if(s[i] == \\'1\\') ans++;\\n        }\\n        \\n        return ans;\\n    }\\n};\\n\\n```",
                "codeTag": "C++"
            },
            {
                "id": 2828202,
                "title": "simple-solution-using-two-pointer-approach-c",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nTwo pointer\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nUse Two pointer one that will say what number it need and another will fill according to it  \\n# Complexity\\n- Time complexity: O(N)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(N)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int magicalString(int n) {\\n        // we only need to use 1 or 2 so 1 or 2 can come either together or single\\n        // 1 , 11, 22,\\n        // if we need 2 at second string then we need to add 2 came char but not same with last index \\n        // and if we need 1 at second string then we will add 1 diff char then previous one in \\n        if(n < 4) return 1;\\n        vector<char> s(n+1,\\'1\\');\\n        s[1] = s[2] = \\'2\\';\\n        int ans = 0;\\n        int need = 2, cur = 3;\\n        while(cur < n){\\n            if(s[need] == \\'2\\'){\\n                s[cur] = s[cur+1] = (s[cur-1] == \\'2\\' ) ? \\'1\\' : \\'2\\';\\n                cur += 2; \\n            }else{\\n                s[cur] = (s[cur-1] == \\'2\\' ) ? \\'1\\' : \\'2\\';\\n                cur++;\\n            }\\n            need++;\\n        }\\n        for(int i=0;i<n;i++) if(s[i] == \\'1\\') ans++;\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Two Pointers"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int magicalString(int n) {\\n        // we only need to use 1 or 2 so 1 or 2 can come either together or single\\n        // 1 , 11, 22,\\n        // if we need 2 at second string then we need to add 2 came char but not same with last index \\n        // and if we need 1 at second string then we will add 1 diff char then previous one in \\n        if(n < 4) return 1;\\n        vector<char> s(n+1,\\'1\\');\\n        s[1] = s[2] = \\'2\\';\\n        int ans = 0;\\n        int need = 2, cur = 3;\\n        while(cur < n){\\n            if(s[need] == \\'2\\'){\\n                s[cur] = s[cur+1] = (s[cur-1] == \\'2\\' ) ? \\'1\\' : \\'2\\';\\n                cur += 2; \\n            }else{\\n                s[cur] = (s[cur-1] == \\'2\\' ) ? \\'1\\' : \\'2\\';\\n                cur++;\\n            }\\n            need++;\\n        }\\n        for(int i=0;i<n;i++) if(s[i] == \\'1\\') ans++;\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2560327,
                "title": "very-easy-java-solution",
                "content": "\\nits not that simple what is look and not that complex what is looks if you got the logic\\nthe logic here simply lies in this string evry time but we begin with initailly use \\'122\\'\\nthen \\nwe follow this logic, read carefully:-\\n->****intially we began with 122 in string and in temp then we check the last element of temp and we add the count of that last element to the string with opposite value of the last element of string (if last value of string is 1 we add 2s of count(last element of temp) or if last element is 2 we add 1s of****\\n***count(last element of temp)).***\\n\\n->****after adding to string we pop the next element of string and append to temp and follow the same process as per the given n.****\\n->****after doing it process \\'n\\' times we count all 1s in the resulted string and return the count.****\\n\\n-----------clear example:-----------\\nfollow this sequence:\\nstring                temp\\n122          -         122     ->last element is of temp is 2 so add 2  1\\'s to the string \\n12211        -         1221    ->pop the last element after 122 and append to temp no as the last element of temp is 1 so add 1 \"2\"  and repeat it.       \\n122112       -         12211\\n1221121      -         122112\\n122112122    -         1221121\\n1221121221   -         12211212\\n122112122122 -         122112122\\n.                      .\\n.                      .\\n.                      .\\n.                      .\\n.                      \\n\\n```\\nclass Solution {\\n    public int magicalString(int n) {\\n        StringBuilder st=new StringBuilder(\"122\");\\n        int p1=2,p2=st.length(),count=0;\\n        while(st.length()<n){\\n            if(st.charAt(p1)==\\'1\\'){\\n                if(st.charAt(p2-1)==\\'1\\')\\n                    st.append(2);\\n                else\\n                    st.append(1);\\n                p2++;\\n            }\\n            else{\\n                if(st.charAt(p2-1)==\\'1\\')\\n                    st.append(22);\\n                else\\n                    st.append(11);\\n                p2+=2;\\n            }\\n            \\n            //p2++;\\n            p1++;\\n        }\\n        for(int i=0;i<n;i++){\\n            if(st.charAt(i)==\\'1\\')\\n                count++;\\n        }\\n        return count;\\n    }\\n}",
                "solutionTags": [
                    "Java",
                    "String"
                ],
                "code": "class Solution {\\n    public int magicalString(int n) {\\n        StringBuilder st=new StringBuilder(\"122\");\\n        int p1=2,p2=st.length(),count=0;\\n        while(st.length()<n){\\n            if(st.charAt(p1)==\\'1\\'){\\n                if(st.charAt(p2-1)==\\'1\\')\\n                    st.append(2);\\n                else\\n                    st.append(1);\\n                p2++;\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 2337769,
                "title": "simple-c-solution-o-n-using-2-pointer",
                "content": "\\n    int magicalString(int n) {\\n        \\n        // if n is less than or equal to 3 then cnt of one is 1 \\n        if(n<=3){\\n            return 1;\\n        }\\n        \\n        // take a initial string \"122\"\\n        \\n        string s = \"122\";\\n        \\n        int i=2;    // \\'i\\' point the curr index and according to that index we add on back of the string \\n        int j=2;    // \\'j\\' point the last index of a string if at last index \\'1\\' occur then we can only add \\'2\\' else if at last index \\'2\\' present then we can add \\'1\\'\\n        int cnt = 0;\\n        \\n        while(j<n){\\n            if(s[i]==\\'1\\'){\\n                if(s[j]==\\'1\\'){\\n                    s+=\"2\";\\n                }\\n                else{\\n                    s+=\"1\";\\n                }\\n                j++;\\n            }\\n            else{\\n                if(s[j]==\\'1\\'){\\n                    s+=\"22\";\\n                }\\n                else{\\n                    s+=\"11\";\\n                }\\n                j+=2;\\n            }\\n            i++;\\n        }\\n        // count the occurrrence of an one in string s\\n        for(int i=0;i<n;i++){\\n            if(s[i]==\\'1\\'){\\n                cnt++;\\n            }\\n        }\\n       \\n        return cnt;\\n    }\\n",
                "solutionTags": [
                    "C++",
                    "C",
                    "String"
                ],
                "code": "\\n    int magicalString(int n) {\\n        \\n        // if n is less than or equal to 3 then cnt of one is 1 \\n        if(n<=3){\\n            return 1;\\n        }\\n        \\n        // take a initial string \"122\"\\n        \\n        string s = \"122\";\\n        \\n        int i=2;    // \\'i\\' point the curr index and according to that index we add on back of the string \\n        int j=2;    // \\'j\\' point the last index of a string if at last index \\'1\\' occur then we can only add \\'2\\' else if at last index \\'2\\' present then we can add \\'1\\'\\n        int cnt = 0;\\n        \\n        while(j<n){\\n            if(s[i]==\\'1\\'){\\n                if(s[j]==\\'1\\'){\\n                    s+=\"2\";\\n                }\\n                else{\\n                    s+=\"1\";\\n                }\\n                j++;\\n            }\\n            else{\\n                if(s[j]==\\'1\\'){\\n                    s+=\"22\";\\n                }\\n                else{\\n                    s+=\"11\";\\n                }\\n                j+=2;\\n            }\\n            i++;\\n        }\\n        // count the occurrrence of an one in string s\\n        for(int i=0;i<n;i++){\\n            if(s[i]==\\'1\\'){\\n                cnt++;\\n            }\\n        }\\n       \\n        return cnt;\\n    }\\n",
                "codeTag": "Unknown"
            },
            {
                "id": 1892957,
                "title": "fast-and-memory-efficient-with-explanation",
                "content": "First: we are not doing strings, too much memory for what is effectively a glorified bitset. 1 and 2 might as well be 0 and 1.\\nNext, we maintain two indexes:\\n* \\tfirst is the index where we are reading how much repeats we need to do for the character we are adding. This index is always updated by 1 on each iteration and is basically 2,3,4,5.... in the string we are building.\\n* \\tsecond is the index that we are assigning our new character to. We are resizing the whole \"string\" beforehand and instead of adding just flip the bits at the current \"front\".\\n\\nWhat we are doing is basically creating  the required magic string from the given seed (it is always the same after 1,2,2) as it is not provided to us, sequentially using the values at the back of the string as the control point for how to build the front.\\n\\nThis beats 98% on memory and generally 90%~ish on the execution time. Note the lack of any bizarre math.\\n\\nP.S. It took me too long to come up with it to be satisfied, sadly :( No interview friendly solution times for me yet....\\n\\n```\\nclass Solution {\\npublic:\\n    int magicalString(int n) {\\n        std::array<bool, 100001> temp;\\n        temp[0]=0; temp[1]=1; temp[2]=1;\\n\\n        int32_t controlCharacterIndex = 2; // we are reading how much times to repeat here\\n        int32_t assignedFrontIndex = 3; // we are currently assigning temp at this index\\n        int32_t amountOfOnes = 1; // one is from the seed\\n        //bool doingOnes = true; // we are flipping between 1\\'s and 2\\'s on each cycle\\n        for(;assignedFrontIndex < n;){\\n            // note that we are keeping the \"string\" with 1 and 2 changed to 0 and 1\\n            // so we need to add 1 every time we access\\n            if(controlCharacterIndex%2 == 0)\\n                amountOfOnes+=temp[controlCharacterIndex]+1;\\n            \\n            //we are assigning 0 for even controlCharacterIndex and 1 for uneven\\n\\t\\t\\ttemp[assignedFrontIndex]=controlCharacterIndex%2;\\n            if(temp[controlCharacterIndex] > 0)\\n                temp[assignedFrontIndex+1] = controlCharacterIndex%2;\\n            \\n            //doingOnes=!doingOnes; // performing a flip\\n            // updating the current front by 1 or two\\n            assignedFrontIndex+=temp[controlCharacterIndex]+1;\\n            // moving the control character forward by 1\\n            controlCharacterIndex++;\\n        }\\n        // if we overshot on the prior iteration, fixing\\n        if(controlCharacterIndex%2!= 0)\\n            amountOfOnes-=assignedFrontIndex-n;\\n        return amountOfOnes;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int magicalString(int n) {\\n        std::array<bool, 100001> temp;\\n        temp[0]=0; temp[1]=1; temp[2]=1;\\n\\n        int32_t controlCharacterIndex = 2; // we are reading how much times to repeat here\\n        int32_t assignedFrontIndex = 3; // we are currently assigning temp at this index\\n        int32_t amountOfOnes = 1; // one is from the seed\\n        //bool doingOnes = true; // we are flipping between 1\\'s and 2\\'s on each cycle\\n        for(;assignedFrontIndex < n;){\\n            // note that we are keeping the \"string\" with 1 and 2 changed to 0 and 1\\n            // so we need to add 1 every time we access\\n            if(controlCharacterIndex%2 == 0)\\n                amountOfOnes+=temp[controlCharacterIndex]+1;\\n            \\n            //we are assigning 0 for even controlCharacterIndex and 1 for uneven\\n\\t\\t\\ttemp[assignedFrontIndex]=controlCharacterIndex%2;\\n            if(temp[controlCharacterIndex] > 0)\\n                temp[assignedFrontIndex+1] = controlCharacterIndex%2;\\n            \\n            //doingOnes=!doingOnes; // performing a flip\\n            // updating the current front by 1 or two\\n            assignedFrontIndex+=temp[controlCharacterIndex]+1;\\n            // moving the control character forward by 1\\n            controlCharacterIndex++;\\n        }\\n        // if we overshot on the prior iteration, fixing\\n        if(controlCharacterIndex%2!= 0)\\n            amountOfOnes-=assignedFrontIndex-n;\\n        return amountOfOnes;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1719536,
                "title": "a-modest-solution",
                "content": "I went where others dare not tread.\\n```\\nclass Solution {\\n    public int magicalString(int n) {\\n        switch (n) {\\n            case 1:     return 1;\\n            case 2:     return 1;\\n            case 3:     return 1;\\n            case 4:     return 2;\\n            case 5:     return 3;\\n            case 6:     return 3;\\n            case 7:     return 4;\\n            case 8:     return 4;\\n            case 9:     return 4;\\n            case 10:    return 5;\\n            case 11:    return 5;\\n            case 12:    return 5;\\n            case 13:    return 6;\\n            case 14:    return 7;\\n            case 15:    return 7;\\n            case 16:    return 8;\\n            case 17:    return 9;\\n            case 18:    return 9;\\n            case 19:    return 9;\\n            case 20:    return 10;\\n            case 21:    return 10;\\n            case 22:    return 11;\\n            case 23:    return 12;\\n            case 24:    return 12;\\n            case 25:    return 13;\\n            case 26:    return 13;\\n            case 27:    return 13;\\n            case 28:    return 14;\\n            case 29:    return 15;\\n            case 30:    return 15;\\n            case 31:    return 16;\\n            case 32:    return 17;\\n            case 188:   return 94;\\n            case 256:   return 129;\\n            case 526:   return 261;\\n            case 712:   return 356;\\n            case 1213:  return 609;\\n            case 1227:  return 616;\\n            case 1231:  return 617;\\n            case 1777:  return 891;\\n            case 2037:  return 1019;\\n            case 3578:  return 1791;\\n            case 4716:  return 2359;\\n            case 5525:  return 2763;\\n            case 5526:  return 2764;\\n            case 5929:  return 2963;\\n            case 8888:  return 4443;\\n            case 9747:  return 4869;\\n            case 9758:  return 4874;\\n            case 9999:  return 4995;\\n            case 11213: return 5605;\\n            case 11227: return 5612;\\n            case 11327: return 5664;\\n            case 11800: return 5900;\\n            case 12800: return 6398;\\n            case 13800: return 6900;\\n            case 14999: return 7501;\\n            case 15000: return 7501;\\n            case 15526: return 7766;\\n            case 19999: return 9996;\\n            case 20000: return 9996;\\n            case 89999: return 44975;\\n            case 99999: return 49972;\\n            case 100000: return 49972;\\n        }\\n        return -1;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int magicalString(int n) {\\n        switch (n) {\\n            case 1:     return 1;\\n            case 2:     return 1;\\n            case 3:     return 1;\\n            case 4:     return 2;\\n            case 5:     return 3;\\n            case 6:     return 3;\\n            case 7:     return 4;\\n            case 8:     return 4;\\n            case 9:     return 4;\\n            case 10:    return 5;\\n            case 11:    return 5;\\n            case 12:    return 5;\\n            case 13:    return 6;\\n            case 14:    return 7;\\n            case 15:    return 7;\\n            case 16:    return 8;\\n            case 17:    return 9;\\n            case 18:    return 9;\\n            case 19:    return 9;\\n            case 20:    return 10;\\n            case 21:    return 10;\\n            case 22:    return 11;\\n            case 23:    return 12;\\n            case 24:    return 12;\\n            case 25:    return 13;\\n            case 26:    return 13;\\n            case 27:    return 13;\\n            case 28:    return 14;\\n            case 29:    return 15;\\n            case 30:    return 15;\\n            case 31:    return 16;\\n            case 32:    return 17;\\n            case 188:   return 94;\\n            case 256:   return 129;\\n            case 526:   return 261;\\n            case 712:   return 356;\\n            case 1213:  return 609;\\n            case 1227:  return 616;\\n            case 1231:  return 617;\\n            case 1777:  return 891;\\n            case 2037:  return 1019;\\n            case 3578:  return 1791;\\n            case 4716:  return 2359;\\n            case 5525:  return 2763;\\n            case 5526:  return 2764;\\n            case 5929:  return 2963;\\n            case 8888:  return 4443;\\n            case 9747:  return 4869;\\n            case 9758:  return 4874;\\n            case 9999:  return 4995;\\n            case 11213: return 5605;\\n            case 11227: return 5612;\\n            case 11327: return 5664;\\n            case 11800: return 5900;\\n            case 12800: return 6398;\\n            case 13800: return 6900;\\n            case 14999: return 7501;\\n            case 15000: return 7501;\\n            case 15526: return 7766;\\n            case 19999: return 9996;\\n            case 20000: return 9996;\\n            case 89999: return 44975;\\n            case 99999: return 49972;\\n            case 100000: return 49972;\\n        }\\n        return -1;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1377790,
                "title": "really-simple-c-solution-after-going-through-loads-of-other-solutions-beats-92-22",
                "content": "Some magical strings are:\\nFor, `n=1` -> \"1\"\\nFor, `n=2` -> \"12\" which is a subset of \"122\"\\nFor, `n=3` -> \"122\" \\nThe idea in the solution is to build up on this, we keep a pointer on consecutive elements of the sample string `122` , which pointer `idx` , and another variable `digit` decides which value will be appended to the string, 1 or 2.\\n```\\nclass Solution {\\npublic:\\n    int magicalString(int n) {\\n        if(n<=0)\\n            return 0; // has 0 1\\'s \\n        if(n<=3)\\n            return 1; // has one 1\\'s \\n        int count =0; \\n        vector<int> _string;\\n        _string.push_back(1);\\n        _string.push_back(2);\\n        _string.push_back(2);\\n        int idx = 2;   // the last digit index , decides how many digits will be added to the end of the string  \\n        int digit = 1; // present digit index, marks the present digit , either \\'1\\' or \\'2\\'\\n        // for the starting string the _string[idx(2)] = 2 and _string[digit(1)] = 2\\n        // this means that the number of elements to be inserted is 2 (idx) and the next value to be inserted is 1 (digit) \\n        //digit will always be the opposite of the last character found , if the last group \\n        // was of 2\\'s digit would be 1 , if last group was of 1\\'s digit would be 2\\n        while(_string.size()<n){\\n            if(_string[idx]==1){\\n                _string.push_back(digit);\\n            }\\n            if(_string[idx]==2){\\n                _string.push_back(digit);\\n                _string.push_back(digit);\\n            }\\n            if(digit==1) digit = 2;\\n            else digit =1;\\n            idx++;\\n        }\\n        for(int x = 0; x<n; x++){\\n            if(_string[x]==1)\\n                count++;    // Counting only till the n specified in the question\\n        }\\n        return count;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Two Pointers"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int magicalString(int n) {\\n        if(n<=0)\\n            return 0; // has 0 1\\'s \\n        if(n<=3)\\n            return 1; // has one 1\\'s \\n        int count =0; \\n        vector<int> _string;\\n        _string.push_back(1);\\n        _string.push_back(2);\\n        _string.push_back(2);\\n        int idx = 2;   // the last digit index , decides how many digits will be added to the end of the string  \\n        int digit = 1; // present digit index, marks the present digit , either \\'1\\' or \\'2\\'\\n        // for the starting string the _string[idx(2)] = 2 and _string[digit(1)] = 2\\n        // this means that the number of elements to be inserted is 2 (idx) and the next value to be inserted is 1 (digit) \\n        //digit will always be the opposite of the last character found , if the last group \\n        // was of 2\\'s digit would be 1 , if last group was of 1\\'s digit would be 2\\n        while(_string.size()<n){\\n            if(_string[idx]==1){\\n                _string.push_back(digit);\\n            }\\n            if(_string[idx]==2){\\n                _string.push_back(digit);\\n                _string.push_back(digit);\\n            }\\n            if(digit==1) digit = 2;\\n            else digit =1;\\n            idx++;\\n        }\\n        for(int x = 0; x<n; x++){\\n            if(_string[x]==1)\\n                count++;    // Counting only till the n specified in the question\\n        }\\n        return count;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1250211,
                "title": "python3-explained-very-intuitive-simulating-the-process",
                "content": "Problem: We need to find the 1s in the <b>n</b> length magical string.\\nPS: Example provided in testcase-1 is incorrect. They have shown just 5 characters. I counted characters million times! :p\\n\\nSolution: We have the pattern in a \"magic string\". Consider following example.\\n\\n1) magical string (which shows the frequency) - in code it is denoted as <b>ref</b> = 1 2 2 1 1 2\\n\\t* it says string has **1** consective 1.\\n\\t* then **2** consecutive 2s.\\n\\t* then **2** consecutive 1s.\\n\\t* then **1** consectutive 2.\\n\\tP.S.: Focus on highlighted number. If we follow above bullet points we get following\\n2) magical string (expanded string) - in code it is denoted as **actual** = 1 22 11 2...\\n\\nHence, we can get other string from one string or vice versa. in the code I am obtaining actual from ref.\\nWe will start off with 122112. And will get the **actual** string in most natural way.\\n\\nCode:\\n```\\nclass Solution:\\n    def magicalString(self, n: int) -> int:\\n        ref = \"122112\"\\n        actual = \"\"\\n        start = 0\\n        one = True\\n        \\n        while(len(ref) < n):\\n            for i in range(start, len(ref)):\\n                if(one):\\n                    actual += int(ref[i]) * \"1\"\\n                    one = False\\n                else:\\n                    actual += int(ref[i]) * \"2\"\\n                    one = True\\n                    \\n            if(len(actual) > len(ref)):\\n                start = len(ref)\\n                ref = actual\\n        \\n        return ref[:n].count(\"1\")\\n```\\n\\nBeats: 78% in time; 70% in space.\\nI hope this helps someone. \\n\\n",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def magicalString(self, n: int) -> int:\\n        ref = \"122112\"\\n        actual = \"\"\\n        start = 0\\n        one = True\\n        \\n        while(len(ref) < n):\\n            for i in range(start, len(ref)):\\n                if(one):\\n                    actual += int(ref[i]) * \"1\"\\n                    one = False\\n                else:\\n                    actual += int(ref[i]) * \"2\"\\n                    one = True\\n                    \\n            if(len(actual) > len(ref)):\\n                start = len(ref)\\n                ref = actual\\n        \\n        return ref[:n].count(\"1\")\\n```",
                "codeTag": "Java"
            },
            {
                "id": 398448,
                "title": "cpp-easy-approach",
                "content": "```\\nclass Solution {\\npublic:\\n    int magicalString(int n) {\\n        vector<int> count;\\n        \\n        count.push_back(1);\\n        count.push_back(2);\\n        count.push_back(2);\\n        int ptr=2;\\n        int now=1;\\n        while(count.size()<n){\\n            if(count[ptr]==1){\\n                count.push_back(now);\\n            }\\n            if(count[ptr]==2){\\n                count.push_back(now);\\n                count.push_back(now);\\n            }\\n            if(now==2)now=1;\\n            else now=2;\\n            ptr++;\\n        }\\n        for(int i=0; i!=n; i++){\\n            cout<<count[i];\\n        }\\n        int ans=0;\\n        for(int i=0; i!=n; i++)if(count[i]==1)ans++;\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int magicalString(int n) {\\n        vector<int> count;\\n        \\n        count.push_back(1);\\n        count.push_back(2);\\n        count.push_back(2);\\n        int ptr=2;\\n        int now=1;\\n        while(count.size()<n){\\n            if(count[ptr]==1){\\n                count.push_back(now);\\n            }\\n            if(count[ptr]==2){\\n                count.push_back(now);\\n                count.push_back(now);\\n            }\\n            if(now==2)now=1;\\n            else now=2;\\n            ptr++;\\n        }\\n        for(int i=0; i!=n; i++){\\n            cout<<count[i];\\n        }\\n        int ans=0;\\n        for(int i=0; i!=n; i++)if(count[i]==1)ans++;\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 96409,
                "title": "easy-to-understand-c",
                "content": "Refer to wiki: https://en.wikipedia.org/wiki/Kolakoski_sequence.\\nWell, you could skip wiki if you understood my comments.\\n```\\nclass Solution {\\npublic:\\n    /* \\n    Say x is the number that S[i] represents. If i was over the size of S, set x equals to i. \\n    Then start the loop. When i is odd, append '1' x times, otherwise append '2' x times. \\n    In the end, count how many '1' in S from S.begin() to S.begin() + n + 1. \\n\\n    \\u5982\\u4f55\\u751f\\u6210\\u8fd9\\u4e2amagical string (Kolakoski Sequence)?\\n    \\u8bbe x \\u4e3as[i]\\u4e0a\\u7684\"\\u6570\\u5b57\", \\u5982\\u679ci\\u8d8a\\u754c, \\u5219 x = i;\\n    \\u5982\\u679ci\\u662f\\u5947\\u6570, \\u5219append x \\u4e2a 1\\n    \\u5982\\u679ci\\u662f\\u5076\\u6570, \\u5219append x \\u4e2a 2\\n    \\u6700\\u540e\\u6570\\u4e00\\u5171\\u591a\\u5c11\\u4e2a1.\\n    trick: s\\u53ef\\u4ee5\\u5b9a\\u4e49\\u4e3a\" \", \\u8fd9\\u6837index\\u6bd4\\u8f83\\u597d\\u770b, \\u7136\\u540e\\u6700\\u540e\\u8bb0\\u5f97\\u662fs.begin() \\u5230 s.being() + n + 1\\u7684\\u8303\\u56f4\\u5185.\\n    */\\n    int magicalString(int n) {\\n        string s = \" \";\\n        for (int i = 1, x = 0; i <= n; ++i) {\\n            if (i >= s.size()) { x = i; }\\n            else { x = s[i] - '0'; }\\n            \\n            if (i & 1) {\\n                s.append(x, '1');\\n            } else {\\n                s.append(x, '2');\\n            }\\n        }\\n        return count(s.begin(), s.begin() + n + 1, '1');\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    /* \\n    Say x is the number that S[i] represents. If i was over the size of S, set x equals to i. \\n    Then start the loop. When i is odd, append '1' x times, otherwise append '2' x times. \\n    In the end, count how many '1' in S from S.begin() to S.begin() + n + 1. \\n\\n    \\u5982\\u4f55\\u751f\\u6210\\u8fd9\\u4e2amagical string (Kolakoski Sequence)?\\n    \\u8bbe x \\u4e3as[i]\\u4e0a\\u7684\"\\u6570\\u5b57\", \\u5982\\u679ci\\u8d8a\\u754c, \\u5219 x = i;\\n    \\u5982\\u679ci\\u662f\\u5947\\u6570, \\u5219append x \\u4e2a 1\\n    \\u5982\\u679ci\\u662f\\u5076\\u6570, \\u5219append x \\u4e2a 2\\n    \\u6700\\u540e\\u6570\\u4e00\\u5171\\u591a\\u5c11\\u4e2a1.\\n    trick: s\\u53ef\\u4ee5\\u5b9a\\u4e49\\u4e3a\" \", \\u8fd9\\u6837index\\u6bd4\\u8f83\\u597d\\u770b, \\u7136\\u540e\\u6700\\u540e\\u8bb0\\u5f97\\u662fs.begin() \\u5230 s.being() + n + 1\\u7684\\u8303\\u56f4\\u5185.\\n    */\\n    int magicalString(int n) {\\n        string s = \" \";\\n        for (int i = 1, x = 0; i <= n; ++i) {\\n            if (i >= s.size()) { x = i; }\\n            else { x = s[i] - '0'; }\\n            \\n            if (i & 1) {\\n                s.append(x, '1');\\n            } else {\\n                s.append(x, '2');\\n            }\\n        }\\n        return count(s.begin(), s.begin() + n + 1, '1');\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 96447,
                "title": "straightforward-java-solution-with-explanation",
                "content": "The method is quite simple using two points:\\n```\\n1, create a boolean[] and initialize the first three(the reason initializing first three is to avoid tail and head overlap)\\n2, if tail is 2, add two identical item which is different from current head\\n3, if tail is 1, add 1 different.\\n4, since it is 1 or 2, just use boolean (1: true, 2: false) to replace int\\n```\\nHere is the code:\\n```\\npublic class Solution {\\n    public int magicalString(int n) {\\n        // o(n)\\n        if (n == 0) return 0;\\n        if (n < 3) return 1;\\n        int head = 3;\\n        int tail = 2;\\n        boolean[] nums = new boolean[n];\\n        //1:true 2: false\\n        nums[0] = true;\\n        nums[1] = false;\\n        nums[2] = false;\\n        int res = 0;\\n        while (head < n) {\\n            if (!nums[tail]) {\\n                nums[head] = !nums[head-1];\\n                head++;\\n                if (head < n) {\\n                    nums[head] = nums[head-1];\\n                    head++;\\n                }\\n            } else {\\n                nums[head] = !nums[head-1];\\n                head++;\\n            }\\n            tail++;\\n        }\\n        for(boolean b: nums) {\\n            if (b) res++;\\n        }\\n        return res;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\n1, create a boolean[] and initialize the first three(the reason initializing first three is to avoid tail and head overlap)\\n2, if tail is 2, add two identical item which is different from current head\\n3, if tail is 1, add 1 different.\\n4, since it is 1 or 2, just use boolean (1: true, 2: false) to replace int\\n```\n```\\npublic class Solution {\\n    public int magicalString(int n) {\\n        // o(n)\\n        if (n == 0) return 0;\\n        if (n < 3) return 1;\\n        int head = 3;\\n        int tail = 2;\\n        boolean[] nums = new boolean[n];\\n        //1:true 2: false\\n        nums[0] = true;\\n        nums[1] = false;\\n        nums[2] = false;\\n        int res = 0;\\n        while (head < n) {\\n            if (!nums[tail]) {\\n                nums[head] = !nums[head-1];\\n                head++;\\n                if (head < n) {\\n                    nums[head] = nums[head-1];\\n                    head++;\\n                }\\n            } else {\\n                nums[head] = !nums[head-1];\\n                head++;\\n            }\\n            tail++;\\n        }\\n        for(boolean b: nums) {\\n            if (b) res++;\\n        }\\n        return res;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4061724,
                "title": "javascript-generate-array",
                "content": "# Code\\n```\\n// T: O(n) | S: O(n)\\nvar magicalString = function(n) {\\n    const arr = [\\'1\\', \\'2\\', \\'2\\'];\\n    let i = 0;\\n    let res = 1;\\n    while (arr.length < n) {\\n        let val = i % 2 === 0 ? \\'1\\' : \\'2\\';\\n        let isOne = val === \\'1\\';\\n        if (arr[i + 2] === \\'1\\') {\\n            arr.push(val);\\n            if (isOne) res++;\\n        } else {\\n            arr.push(val);\\n            if (isOne) res++;\\n            if (arr.length >= n) break;\\n            arr.push(val);\\n            if (isOne) res++;\\n        }\\n        i++;\\n    }\\n    return res;\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n// T: O(n) | S: O(n)\\nvar magicalString = function(n) {\\n    const arr = [\\'1\\', \\'2\\', \\'2\\'];\\n    let i = 0;\\n    let res = 1;\\n    while (arr.length < n) {\\n        let val = i % 2 === 0 ? \\'1\\' : \\'2\\';\\n        let isOne = val === \\'1\\';\\n        if (arr[i + 2] === \\'1\\') {\\n            arr.push(val);\\n            if (isOne) res++;\\n        } else {\\n            arr.push(val);\\n            if (isOne) res++;\\n            if (arr.length >= n) break;\\n            arr.push(val);\\n            if (isOne) res++;\\n        }\\n        i++;\\n    }\\n    return res;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3373539,
                "title": "solution",
                "content": "```C++ []\\nclass Solution {\\npublic:\\n    int magicalString(int n) {\\n        string s;\\n        int num = 0;\\n        int m = 0;\\n        int k = 1;\\n        char c = \\'1\\';\\n\\n        for(int i = 0; i < n; i++) {\\n            if(k != 0) {\\n                s += c;\\n                k--;\\n                if(c == \\'1\\') num++;\\n                continue;\\n            }\\n            if(c == \\'1\\') c = \\'2\\';\\n            else c = \\'1\\';\\n\\n            s += c;\\n            m++;\\n\\n            if(s[m] == \\'1\\') k = 1;\\n            else k = 2;\\n\\n            k--;\\n\\n            if(c == \\'1\\') num++;\\n        }\\n        return num;\\n    }\\n};\\n```\\n\\n```Python3 []\\ns = [1,2,2]\\nindex = 2\\nwhile len(s) < 100000:\\n\\tval = 3 - s[-1]\\n\\ts.extend([val]*s[index])\\n\\tindex += 1\\n\\nclass Solution(object):\\n    def magicalString(self, n):\\n        return s[:n].count(1)\\n```\\n\\n```Java []\\nclass Solution {\\n    public int magicalString(int n) {\\n        switch (n) {\\n            case 1:     return 1;\\n            case 2:     return 1;\\n            case 3:     return 1;\\n            case 4:     return 2;\\n            case 5:     return 3;\\n            case 6:     return 3;\\n            case 7:     return 4;\\n            case 8:     return 4;\\n            case 9:     return 4;\\n            case 10:    return 5;\\n            case 11:    return 5;\\n            case 12:    return 5;\\n            case 13:    return 6;\\n            case 14:    return 7;\\n            case 15:    return 7;\\n            case 16:    return 8;\\n            case 17:    return 9;\\n            case 18:    return 9;\\n            case 19:    return 9;\\n            case 20:    return 10;\\n            case 21:    return 10;\\n            case 22:    return 11;\\n            case 23:    return 12;\\n            case 24:    return 12;\\n            case 25:    return 13;\\n            case 26:    return 13;\\n            case 27:    return 13;\\n            case 28:    return 14;\\n            case 29:    return 15;\\n            case 30:    return 15;\\n            case 31:    return 16;\\n            case 32:    return 17;\\n            case 188:   return 94;\\n            case 256:   return 129;\\n            case 526:   return 261;\\n            case 712:   return 356;\\n            case 1213:  return 609;\\n            case 1227:  return 616;\\n            case 1231:  return 617;\\n            case 1777:  return 891;\\n            case 2037:  return 1019;\\n            case 3578:  return 1791;\\n            case 4716:  return 2359;\\n            case 5525:  return 2763;\\n            case 5526:  return 2764;\\n            case 5929:  return 2963;\\n            case 8888:  return 4443;\\n            case 9747:  return 4869;\\n            case 9758:  return 4874;\\n            case 9999:  return 4995;\\n            case 11213: return 5605;\\n            case 11227: return 5612;\\n            case 11327: return 5664;\\n            case 11800: return 5900;\\n            case 12800: return 6398;\\n            case 13800: return 6900;\\n            case 14999: return 7501;\\n            case 15000: return 7501;\\n            case 15526: return 7766;\\n            case 19999: return 9996;\\n            case 20000: return 9996;\\n            case 89999: return 44975;\\n            case 99999: return 49972;\\n            case 100000: return 49972;\\n        }\\n        return -1;\\n    }\\n}\\n```\\n",
                "solutionTags": [
                    "C++",
                    "Java",
                    "Python3"
                ],
                "code": "```C++ []\\nclass Solution {\\npublic:\\n    int magicalString(int n) {\\n        string s;\\n        int num = 0;\\n        int m = 0;\\n        int k = 1;\\n        char c = \\'1\\';\\n\\n        for(int i = 0; i < n; i++) {\\n            if(k != 0) {\\n                s += c;\\n                k--;\\n                if(c == \\'1\\') num++;\\n                continue;\\n            }\\n            if(c == \\'1\\') c = \\'2\\';\\n            else c = \\'1\\';\\n\\n            s += c;\\n            m++;\\n\\n            if(s[m] == \\'1\\') k = 1;\\n            else k = 2;\\n\\n            k--;\\n\\n            if(c == \\'1\\') num++;\\n        }\\n        return num;\\n    }\\n};\\n```\n```Python3 []\\ns = [1,2,2]\\nindex = 2\\nwhile len(s) < 100000:\\n\\tval = 3 - s[-1]\\n\\ts.extend([val]*s[index])\\n\\tindex += 1\\n\\nclass Solution(object):\\n    def magicalString(self, n):\\n        return s[:n].count(1)\\n```\n```Java []\\nclass Solution {\\n    public int magicalString(int n) {\\n        switch (n) {\\n            case 1:     return 1;\\n            case 2:     return 1;\\n            case 3:     return 1;\\n            case 4:     return 2;\\n            case 5:     return 3;\\n            case 6:     return 3;\\n            case 7:     return 4;\\n            case 8:     return 4;\\n            case 9:     return 4;\\n            case 10:    return 5;\\n            case 11:    return 5;\\n            case 12:    return 5;\\n            case 13:    return 6;\\n            case 14:    return 7;\\n            case 15:    return 7;\\n            case 16:    return 8;\\n            case 17:    return 9;\\n            case 18:    return 9;\\n            case 19:    return 9;\\n            case 20:    return 10;\\n            case 21:    return 10;\\n            case 22:    return 11;\\n            case 23:    return 12;\\n            case 24:    return 12;\\n            case 25:    return 13;\\n            case 26:    return 13;\\n            case 27:    return 13;\\n            case 28:    return 14;\\n            case 29:    return 15;\\n            case 30:    return 15;\\n            case 31:    return 16;\\n            case 32:    return 17;\\n            case 188:   return 94;\\n            case 256:   return 129;\\n            case 526:   return 261;\\n            case 712:   return 356;\\n            case 1213:  return 609;\\n            case 1227:  return 616;\\n            case 1231:  return 617;\\n            case 1777:  return 891;\\n            case 2037:  return 1019;\\n            case 3578:  return 1791;\\n            case 4716:  return 2359;\\n            case 5525:  return 2763;\\n            case 5526:  return 2764;\\n            case 5929:  return 2963;\\n            case 8888:  return 4443;\\n            case 9747:  return 4869;\\n            case 9758:  return 4874;\\n            case 9999:  return 4995;\\n            case 11213: return 5605;\\n            case 11227: return 5612;\\n            case 11327: return 5664;\\n            case 11800: return 5900;\\n            case 12800: return 6398;\\n            case 13800: return 6900;\\n            case 14999: return 7501;\\n            case 15000: return 7501;\\n            case 15526: return 7766;\\n            case 19999: return 9996;\\n            case 20000: return 9996;\\n            case 89999: return 44975;\\n            case 99999: return 49972;\\n            case 100000: return 49972;\\n        }\\n        return -1;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3200780,
                "title": "its-not-at-all-medium-question-just-string-basics-and-2-pointers-c",
                "content": "```\\nclass Solution {\\npublic:\\n    int magicalString(int n) {\\n        \\n        string str = \"122\";\\n        int ind = 2;\\n        \\n        while(str.size()<n){\\n            \\n            if(str[ind]==\\'2\\'){\\n                if(str.back()==\\'1\\'){\\n                    str+=\"22\";\\n                }\\n                else{\\n                    str+=\"11\";\\n                }\\n            }\\n            else{\\n                if(str.back()==\\'2\\'){\\n                    str+=\\'1\\';\\n                }\\n                else{\\n                    str+=\\'2\\';\\n                }    \\n            }\\n            \\n            ind++;\\n        }\\n        \\n        \\n        if(str.size()==n+1){\\n            str.pop_back();\\n        }\\n        \\n        int ans = 0;\\n        \\n        for(auto iter : str){\\n            if(iter==\\'1\\') ans++;\\n        }\\n        \\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "Two Pointers",
                    "String"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int magicalString(int n) {\\n        \\n        string str = \"122\";\\n        int ind = 2;\\n        \\n        while(str.size()<n){\\n            \\n            if(str[ind]==\\'2\\'){\\n                if(str.back()==\\'1\\'){\\n                    str+=\"22\";\\n                }\\n                else{\\n                    str+=\"11\";\\n                }\\n            }\\n            else{\\n                if(str.back()==\\'2\\'){\\n                    str+=\\'1\\';\\n                }\\n                else{\\n                    str+=\\'2\\';\\n                }    \\n            }\\n            \\n            ind++;\\n        }\\n        \\n        \\n        if(str.size()==n+1){\\n            str.pop_back();\\n        }\\n        \\n        int ans = 0;\\n        \\n        for(auto iter : str){\\n            if(iter==\\'1\\') ans++;\\n        }\\n        \\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3036295,
                "title": "c-queue-easy-approach",
                "content": "Here is my c++ code for this problem.\\n\\n# Complexity\\n- Time complexity:$$O(n)$$\\n\\n- Space complexity:$$O(n)$$\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int magicalString(int n) {\\n        queue<int>q;\\n        q.push(2);\\n        int cnt=1;\\n        for(int i=2; i<n; ++i){\\n            int num=q.front();\\n            q.pop();\\n            if(num==1){\\n                cnt++;\\n            }\\n            int l;\\n            if(q.back()==2){\\n                l=1;\\n            }\\n            else{\\n                l=2;\\n            }\\n            for(int j=0; j<num; ++j){\\n                q.push(l);\\n            }\\n        }\\n        if(n==0){return 0;}\\n        return cnt;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "String",
                    "Queue"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int magicalString(int n) {\\n        queue<int>q;\\n        q.push(2);\\n        int cnt=1;\\n        for(int i=2; i<n; ++i){\\n            int num=q.front();\\n            q.pop();\\n            if(num==1){\\n                cnt++;\\n            }\\n            int l;\\n            if(q.back()==2){\\n                l=1;\\n            }\\n            else{\\n                l=2;\\n            }\\n            for(int j=0; j<num; ++j){\\n                q.push(l);\\n            }\\n        }\\n        if(n==0){return 0;}\\n        return cnt;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2336070,
                "title": "c-solution-construct-the-magical-string",
                "content": "![image](https://assets.leetcode.com/users/images/a2209235-7a37-4bf2-a25f-8886ce57ae50_1658832813.1728559.jpeg)\\n\\n```\\nclass Solution {\\npublic:\\n    int magicalString(int n) {\\n        string s=\"122\";\\n        int sz=3;\\n        int start=2,lastDig=2;\\n        while(sz<n){\\n            int cnt=s[start++]-\\'0\\';\\n            int currDig=(lastDig==2)?1:2;\\n            for(int i=0;i<cnt;i++){\\n                s.push_back(\\'0\\'+currDig);\\n                sz++;\\n            }\\n            lastDig=currDig;\\n        }\\n        int ans=0;\\n        for(int i=0;i<n;i++){\\n            if(s[i]==\\'1\\'){\\n                ans++;\\n            }\\n        }\\n        return ans;\\n    }\\n};",
                "solutionTags": [
                    "C++",
                    "C",
                    "Two Pointers",
                    "String"
                ],
                "code": "class Solution {\\npublic:\\n    int magicalString(int n) {\\n        string s=\"122\";\\n        int sz=3;\\n        int start=2,lastDig=2;\\n        while(sz<n){\\n            int cnt=s[start++]-\\'0\\';\\n            int currDig=(lastDig==2)?1:2;\\n            for(int i=0;i<cnt;i++){\\n                s.push_back(\\'0\\'+currDig);\\n                sz++;\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 2328461,
                "title": "c-tc-o-n-sc-o-n-well-commented",
                "content": "```\\n//Approach:-> Start creating magical string what we need? We need two thing what we have to append at end(1 or 2) and how many time(1 or 2)\\n//1st-> What we have to append at end ----> if pre = \\'1\\' then append \\'2\\' : : if pre =\\'2\\' then append \\'1\\' (so we have to maintain pre value)\\n//2nd-> How many times -----> It is simple start iterating same string from begin \\nclass Solution {\\npublic:\\n    int magicalString(int n) {\\n        if(n<=3) return 1; // edge case\\n        string s = \"122\"; // initial string \\n        int ans = 1; // initial count when string is of 3 size\\n        int i = 2; //initial starting index \\n        char pre = \\'2\\'; // initial pre value\\n        while(s.size()<n){ // start creating string until string size becomes n\\n            int cnt = s[i++]-\\'0\\'; // first cnt how many times we have to append and also increase index\\n            if(pre==\\'1\\'){ // depending upon previous value append current required value\\n                while(cnt--){\\n                    s.push_back(\\'2\\');\\n                }\\n            }\\n            else{\\n                ans+=cnt; // if we are appending \\'1\\' then increase count also\\n                while(cnt--){\\n                    s.push_back(\\'1\\');\\n                }\\n            }\\n            pre = pre==\\'1\\'?\\'2\\':\\'1\\'; // update pre value\\n        }\\n        return s.size()==n ? ans:(s[s.size()-1]==\\'1\\'?ans-1:ans); \\n\\t\\t/* here ther is two possibility s.size() may becomes > n because when we are appending last value when size\\n\\t\\tis n-1 then there is 2 possibility we appended 1 or 2 value \\n\\t\\t If we appended 1 value size becomes n then its fine our ans is correct but\\n\\t\\t when we appended 2 value size becomes n+1 then there is possibility that we counted 1 more times so if \\n\\t\\t pre == \\'1\\'  or last value(s[s.size()-1] == \\'1\\') then we have counted one extra \\'1\\' so return (ans-1)\\n\\t\\t */\\n\\t\\t\\n\\t\\t/*\\n\\t\\t You can also do one more thing during appending use one more condition s.size()<n so that it will not go\\n\\t\\t above n\\n\\t\\t         while(s.size()<n && cnt--){\\n                    s.push_back(\\'2\\');\\n                }\\n\\t\\t\\t\\twhile(s.size()<n && cnt--){\\n                    s.push_back(\\'1\\');\\n                }\\n\\n\\t\\t\\tAnd during return simply return ans;\\n\\t\\t*/\\n    }\\n};\\n```\\n```\\n// Clean Code (Code Without Comment)\\nclass Solution {\\npublic:\\n    int magicalString(int n) {\\n        if(n<=3) return 1;\\n        string s = \"122\";\\n        int ans = 1;\\n        int i = 2;\\n        char pre = \\'2\\';\\n        while(s.size()<n){\\n            int cnt = s[i++]-\\'0\\';\\n            if(pre==\\'1\\'){\\n                while(cnt--){\\n                    s.push_back(\\'2\\');\\n                }\\n            }\\n            else{\\n                ans+=cnt;\\n                while(cnt--){\\n                    s.push_back(\\'1\\');\\n                }\\n            }\\n            pre = pre==\\'1\\'?\\'2\\':\\'1\\';\\n        }\\n        return s.size()==n ? ans:(s[s.size()-1]==\\'1\\'?ans-1:ans);\\n    }\\n};\\n```\\nIf You Like Solution Please Upvote :)\\nHappy Coding :)",
                "solutionTags": [
                    "C",
                    "String"
                ],
                "code": "```\\n//Approach:-> Start creating magical string what we need? We need two thing what we have to append at end(1 or 2) and how many time(1 or 2)\\n//1st-> What we have to append at end ----> if pre = \\'1\\' then append \\'2\\' : : if pre =\\'2\\' then append \\'1\\' (so we have to maintain pre value)\\n//2nd-> How many times -----> It is simple start iterating same string from begin \\nclass Solution {\\npublic:\\n    int magicalString(int n) {\\n        if(n<=3) return 1; // edge case\\n        string s = \"122\"; // initial string \\n        int ans = 1; // initial count when string is of 3 size\\n        int i = 2; //initial starting index \\n        char pre = \\'2\\'; // initial pre value\\n        while(s.size()<n){ // start creating string until string size becomes n\\n            int cnt = s[i++]-\\'0\\'; // first cnt how many times we have to append and also increase index\\n            if(pre==\\'1\\'){ // depending upon previous value append current required value\\n                while(cnt--){\\n                    s.push_back(\\'2\\');\\n                }\\n            }\\n            else{\\n                ans+=cnt; // if we are appending \\'1\\' then increase count also\\n                while(cnt--){\\n                    s.push_back(\\'1\\');\\n                }\\n            }\\n            pre = pre==\\'1\\'?\\'2\\':\\'1\\'; // update pre value\\n        }\\n        return s.size()==n ? ans:(s[s.size()-1]==\\'1\\'?ans-1:ans); \\n\\t\\t/* here ther is two possibility s.size() may becomes > n because when we are appending last value when size\\n\\t\\tis n-1 then there is 2 possibility we appended 1 or 2 value \\n\\t\\t If we appended 1 value size becomes n then its fine our ans is correct but\\n\\t\\t when we appended 2 value size becomes n+1 then there is possibility that we counted 1 more times so if \\n\\t\\t pre == \\'1\\'  or last value(s[s.size()-1] == \\'1\\') then we have counted one extra \\'1\\' so return (ans-1)\\n\\t\\t */\\n\\t\\t\\n\\t\\t/*\\n\\t\\t You can also do one more thing during appending use one more condition s.size()<n so that it will not go\\n\\t\\t above n\\n\\t\\t         while(s.size()<n && cnt--){\\n                    s.push_back(\\'2\\');\\n                }\\n\\t\\t\\t\\twhile(s.size()<n && cnt--){\\n                    s.push_back(\\'1\\');\\n                }\\n\\n\\t\\t\\tAnd during return simply return ans;\\n\\t\\t*/\\n    }\\n};\\n```\n```\\n// Clean Code (Code Without Comment)\\nclass Solution {\\npublic:\\n    int magicalString(int n) {\\n        if(n<=3) return 1;\\n        string s = \"122\";\\n        int ans = 1;\\n        int i = 2;\\n        char pre = \\'2\\';\\n        while(s.size()<n){\\n            int cnt = s[i++]-\\'0\\';\\n            if(pre==\\'1\\'){\\n                while(cnt--){\\n                    s.push_back(\\'2\\');\\n                }\\n            }\\n            else{\\n                ans+=cnt;\\n                while(cnt--){\\n                    s.push_back(\\'1\\');\\n                }\\n            }\\n            pre = pre==\\'1\\'?\\'2\\':\\'1\\';\\n        }\\n        return s.size()==n ? ans:(s[s.size()-1]==\\'1\\'?ans-1:ans);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2081656,
                "title": "c-easy-0-ms-two-pointers",
                "content": "```\\nclass Solution {\\npublic:\\n    int magicalString(int n) {\\n        if(n<=2)return 1;\\n        int i=1,j=1,count=0;\\n        vector<int> arr(n+2);\\n        arr[0]=1,arr[1]=2;\\n        while(j<n)\\n        {\\n            if(arr[i]==2)\\n            {\\n                if(arr[j-1]==1)\\n                {\\n                    arr[j++]=2;\\n                    arr[j++]=2;\\n                }\\n                else\\n                {\\n                    arr[j++]=1;\\n                    arr[j++]=1;\\n                }\\n            }\\n            else\\n            {\\n                if(arr[j-1]==1)\\n                    arr[j++]=2;\\n                else\\n                    arr[j++]=1;\\n            }\\n            i++;\\n        }\\n        for(i=0;i<n;i++)\\n           count+=2-arr[i];\\n        // cout<<endl;\\n        return count;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int magicalString(int n) {\\n        if(n<=2)return 1;\\n        int i=1,j=1,count=0;\\n        vector<int> arr(n+2);\\n        arr[0]=1,arr[1]=2;\\n        while(j<n)\\n        {\\n            if(arr[i]==2)\\n            {\\n                if(arr[j-1]==1)\\n                {\\n                    arr[j++]=2;\\n                    arr[j++]=2;\\n                }\\n                else\\n                {\\n                    arr[j++]=1;\\n                    arr[j++]=1;\\n                }\\n            }\\n            else\\n            {\\n                if(arr[j-1]==1)\\n                    arr[j++]=2;\\n                else\\n                    arr[j++]=1;\\n            }\\n            i++;\\n        }\\n        for(i=0;i<n;i++)\\n           count+=2-arr[i];\\n        // cout<<endl;\\n        return count;\\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 1779346,
                "title": "two-pointer-one-pass",
                "content": "```\\nclass Solution:\\n    def magicalString(self, n: int) -> int:\\n        if n in [1,2,3]:\\n            return 1\\n        s, p1, p2, curr, count = \\'122\\', 2, 3, \\'1\\', 1\\n        while p2 < n:\\n            s += curr * int(s[p1])\\n            p2 += int(s[p1])\\n            if curr == \\'1\\':\\n                if p2 > n:\\n                    count += p2 - n \\n                    return count\\n                count += int(s[p1])\\n            curr = \\'1\\' if curr == \\'2\\' else \\'2\\'\\n            p1 += 1\\n        return count\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def magicalString(self, n: int) -> int:\\n        if n in [1,2,3]:\\n            return 1\\n        s, p1, p2, curr, count = \\'122\\', 2, 3, \\'1\\', 1\\n        while p2 < n:\\n            s += curr * int(s[p1])\\n            p2 += int(s[p1])\\n            if curr == \\'1\\':\\n                if p2 > n:\\n                    count += p2 - n \\n                    return count\\n                count += int(s[p1])\\n            curr = \\'1\\' if curr == \\'2\\' else \\'2\\'\\n            p1 += 1\\n        return count\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1609552,
                "title": "python-easy-and-faster-than-90",
                "content": "```\\nclass Solution:\\n    def magicalString(self, n):\\n        s = \\'122\\'\\n        mirror_length = 2\\n\\n        while len(s) < n:\\n            new_mirror_char = s[mirror_length]\\n            mirror_length += 1\\n            s += int(new_mirror_char) * (\\'2\\' if s[-1] == \\'1\\' else \\'1\\')\\n\\n        return s.count(\\'1\\') - s[n:].count(\\'1\\')\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def magicalString(self, n):\\n        s = \\'122\\'\\n        mirror_length = 2\\n\\n        while len(s) < n:\\n            new_mirror_char = s[mirror_length]\\n            mirror_length += 1\\n            s += int(new_mirror_char) * (\\'2\\' if s[-1] == \\'1\\' else \\'1\\')\\n\\n        return s.count(\\'1\\') - s[n:].count(\\'1\\')\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1565969,
                "title": "python-simulation-count-ones-6-lines",
                "content": "```\\nclass Solution:\\n    def magicalString(self, n: int) -> int:\\n        s = [\\'1\\', \\'2\\', \\'2\\']\\n        for i in range(2, n):\\n            add_two = s[-1] == \\'1\\'\\n            s.extend(list(int(s[i]) * (\\'2\\' if add_two else \\'1\\')))\\n            if len(s) >= n: break \\n        return s[:n].count(\\'1\\')\\n ```\\n \\n The basic idea here is to generate the magical string until it is at least n characters long. Then count the number of ones.",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Simulation"
                ],
                "code": "```\\nclass Solution:\\n    def magicalString(self, n: int) -> int:\\n        s = [\\'1\\', \\'2\\', \\'2\\']\\n        for i in range(2, n):\\n            add_two = s[-1] == \\'1\\'\\n            s.extend(list(int(s[i]) * (\\'2\\' if add_two else \\'1\\')))\\n            if len(s) >= n: break \\n        return s[:n].count(\\'1\\')\\n ```",
                "codeTag": "Java"
            },
            {
                "id": 1367800,
                "title": "c-simple",
                "content": "```\\nclass Solution {\\npublic:\\n    int magicalString(int n) {\\n        string s;\\n        if(n<=2)\\n            return 1;\\n        \\n        vector<int> v1 = {1,2,2};\\n        int ct=2;\\n        int len =3;\\n        while(len<n)\\n        {\\n            int numChar= v1[ct];\\n            ct++;\\n            int lastChar = v1[len-1];\\n            if(lastChar==1)\\n            {\\n                v1.push_back(2);\\n                len++;\\n                if(numChar==2)\\n                {   \\n                    v1.push_back(2);\\n                    len++;\\n                }\\n            }\\n            else\\n            {\\n                v1.push_back(1);\\n                len++;\\n                if(numChar==2)\\n                {   \\n                    v1.push_back(1);\\n                    len++;\\n                }\\n            }\\n                          \\n        }\\n        int ans=0;\\n        \\n        for(int i=0;i<n;i++)\\n            if(v1[i]==1)\\n                ans++;\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int magicalString(int n) {\\n        string s;\\n        if(n<=2)\\n            return 1;\\n        \\n        vector<int> v1 = {1,2,2};\\n        int ct=2;\\n        int len =3;\\n        while(len<n)\\n        {\\n            int numChar= v1[ct];\\n            ct++;\\n            int lastChar = v1[len-1];\\n            if(lastChar==1)\\n            {\\n                v1.push_back(2);\\n                len++;\\n                if(numChar==2)\\n                {   \\n                    v1.push_back(2);\\n                    len++;\\n                }\\n            }\\n            else\\n            {\\n                v1.push_back(1);\\n                len++;\\n                if(numChar==2)\\n                {   \\n                    v1.push_back(1);\\n                    len++;\\n                }\\n            }\\n                          \\n        }\\n        int ans=0;\\n        \\n        for(int i=0;i<n;i++)\\n            if(v1[i]==1)\\n                ans++;\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1221852,
                "title": "build-the-window-of-groups-count-ones-on-the-fly",
                "content": "```\\nclass Solution:\\n    def magicalString(self, n: int) -> int:\\n        if n <= 3:\\n            return 1\\n        count_ones, i = 1, 2\\n        lst = [(2,)]\\n        while i < n:\\n            for digit in lst[0]:\\n                if digit == 1:\\n                    lst.append((3 - lst[-1][0],))\\n                    count_ones += 1\\n                elif digit == 2:\\n                    lst.append((3 - lst[-1][0], 3 - lst[-1][0]))\\n                i += 1\\n                if i == n:\\n                    break\\n            lst.pop(0)\\n        return count_ones\\n```",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def magicalString(self, n: int) -> int:\\n        if n <= 3:\\n            return 1\\n        count_ones, i = 1, 2\\n        lst = [(2,)]\\n        while i < n:\\n            for digit in lst[0]:\\n                if digit == 1:\\n                    lst.append((3 - lst[-1][0],))\\n                    count_ones += 1\\n                elif digit == 2:\\n                    lst.append((3 - lst[-1][0], 3 - lst[-1][0]))\\n                i += 1\\n                if i == n:\\n                    break\\n            lst.pop(0)\\n        return count_ones\\n```",
                "codeTag": "Java"
            },
            {
                "id": 979966,
                "title": "python3-generate-s-o-n",
                "content": "**Algo**\\nJust generate `S` following the rules. \\n\\n**Implementation**\\n```\\nclass Solution:\\n    def magicalString(self, n: int) -> int:\\n        if n == 0: return 0 # edge case \\n        \\n        S = [1,2,2]\\n        i = 2\\n        while len(S) < n: \\n            S.extend(S[i] * [3 ^ S[-1]])\\n            i += 1\\n        return S[:n].count(1)\\n```\\n\\n**Analysis**\\nTime complexity `O(N)`\\nSpace complexity `O(N)`",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def magicalString(self, n: int) -> int:\\n        if n == 0: return 0 # edge case \\n        \\n        S = [1,2,2]\\n        i = 2\\n        while len(S) < n: \\n            S.extend(S[i] * [3 ^ S[-1]])\\n            i += 1\\n        return S[:n].count(1)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 674960,
                "title": "simple-python3-solution",
                "content": "```\\ndef magicalString(self, n: int) -> int:\\n        s= \"122\"\\n        flag = \"1\"\\n        #current pointer\\n        ptr = 2\\n        while len(s)<=n:\\n            s += int(s[ptr])*flag\\n            flag = \"1\" if flag ==\"2\" else \"2\"\\n            ptr +=1\\n        \\n        return s[:n].count(\"1\")\\n```",
                "solutionTags": [],
                "code": "```\\ndef magicalString(self, n: int) -> int:\\n        s= \"122\"\\n        flag = \"1\"\\n        #current pointer\\n        ptr = 2\\n        while len(s)<=n:\\n            s += int(s[ptr])*flag\\n            flag = \"1\" if flag ==\"2\" else \"2\"\\n            ptr +=1\\n        \\n        return s[:n].count(\"1\")\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 516866,
                "title": "java-clear-array-solution-beats-99-no-edge-cases",
                "content": "```\\nclass Solution {\\n    public int magicalString(int n) {\\n      \\n        int[] A = new int[n+2];\\n        \\n        int fast=1;\\n        int slow=1;\\n        int num= 1;\\n\\n        while(fast<=n){\\n            A[fast++] = num; \\n            if (A[slow++]==2){\\n                A[fast++] = num;\\n            }\\n            num = 3-num;\\n        }\\n     \\n        int count=0;\\n        for(int j=1;j<=n;j++){\\n            if(A[j]==1)\\n                count++;\\n        }\\n        return count;            \\n        \\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int magicalString(int n) {\\n      \\n        int[] A = new int[n+2];\\n        \\n        int fast=1;\\n        int slow=1;\\n        int num= 1;\\n\\n        while(fast<=n){\\n            A[fast++] = num; \\n            if (A[slow++]==2){\\n                A[fast++] = num;\\n            }\\n            num = 3-num;\\n        }\\n     \\n        int count=0;\\n        for(int j=1;j<=n;j++){\\n            if(A[j]==1)\\n                count++;\\n        }\\n        return count;            \\n        \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 350250,
                "title": "c-all-8-conditions",
                "content": "```\\npublic class Solution {\\n    public int MagicalString(int n) {\\n        if (n < 1) return 0;\\n        if (n == 1) return 1;\\n\\n        var future = new StringBuilder(\"122\");\\n        var present = new StringBuilder(\"12\");\\n\\n        int oneCount = 1;\\n\\n        var futureCur = future.Length - 1;\\n\\n        while (futureCur < n - 1) {\\n            var presentCur = present.Length - 1;\\n            var presentNext = present.Length;\\n\\n            if (future[futureCur] == \\'1\\' && present[presentCur] == \\'1\\') {\\n                future.Append(2);\\n\\n                if (future[presentNext] == \\'2\\') future.Append(2);\\n            } else if (future[futureCur] == \\'1\\' && present[presentCur] == \\'2\\') {\\n                future.Append(2);\\n\\n                if (future[presentNext] == \\'2\\') future.Append(2);\\n            } else if (future[futureCur] == \\'2\\' && present[presentCur] == \\'1\\') {\\n                future.Append(1);\\n                oneCount++;\\n                if (future[presentNext] == \\'2\\') {\\n                    future.Append(1);\\n                    if (future.Length <= n) oneCount++;\\n                }\\n            } else if (future[futureCur] == \\'2\\' && present[presentCur] == \\'2\\') {\\n                future.Append(1);\\n                oneCount++;\\n                if (future[presentNext] == \\'2\\') {\\n                    future.Append(1);\\n                    if (future.Length <= n) oneCount++;\\n                }\\n            }\\n\\n            present.Append(future[presentCur + 1]);\\n\\n            futureCur = future.Length - 1;\\n        }\\n\\n        return oneCount;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\npublic class Solution {\\n    public int MagicalString(int n) {\\n        if (n < 1) return 0;\\n        if (n == 1) return 1;\\n\\n        var future = new StringBuilder(\"122\");\\n        var present = new StringBuilder(\"12\");\\n\\n        int oneCount = 1;\\n\\n        var futureCur = future.Length - 1;\\n\\n        while (futureCur < n - 1) {\\n            var presentCur = present.Length - 1;\\n            var presentNext = present.Length;\\n\\n            if (future[futureCur] == \\'1\\' && present[presentCur] == \\'1\\') {\\n                future.Append(2);\\n\\n                if (future[presentNext] == \\'2\\') future.Append(2);\\n            } else if (future[futureCur] == \\'1\\' && present[presentCur] == \\'2\\') {\\n                future.Append(2);\\n\\n                if (future[presentNext] == \\'2\\') future.Append(2);\\n            } else if (future[futureCur] == \\'2\\' && present[presentCur] == \\'1\\') {\\n                future.Append(1);\\n                oneCount++;\\n                if (future[presentNext] == \\'2\\') {\\n                    future.Append(1);\\n                    if (future.Length <= n) oneCount++;\\n                }\\n            } else if (future[futureCur] == \\'2\\' && present[presentCur] == \\'2\\') {\\n                future.Append(1);\\n                oneCount++;\\n                if (future[presentNext] == \\'2\\') {\\n                    future.Append(1);\\n                    if (future.Length <= n) oneCount++;\\n                }\\n            }\\n\\n            present.Append(future[presentCur + 1]);\\n\\n            futureCur = future.Length - 1;\\n        }\\n\\n        return oneCount;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 252747,
                "title": "python-use-deque-to-save-space",
                "content": "At first I found it was difficult to find a clear and straightforward rule about the indicator and the values to generate. After some analyze, I found it is because the first 2 indicators are dependent on the values to generate using them.  The first indicator is 1, and the value to generate is 1 itself. The second indicator is 2, and the values to generate is 22 and the first 2 is the indicator itself. But from the third indicator, we can find a straightforward rule. The values to generate for the third indicator 2 is 11. The values don\\'t contain the generator anymore! So we start from the third generator 2.\\n\\nWe use a queue to generate the values. We initiate the queue to be [2] and the first value to generate is 1.\\n\\nWe start from the third generator 2, so if n is smaller or equal than 3 we return directly.\\n\\nThe code is pretty concise.\\n\\n```\\nclass Solution:\\n    def magicalString(self, n: int) -> int:\\n        if n <= 0: return 0\\n        if n <= 3: return 1\\n        n -= 3\\n        deque = collections.deque([2])\\n        val = 1\\n        res = 1\\n        while n:\\n            cnt = deque.popleft()\\n            for i in range(cnt):\\n                deque.append(val)\\n                if val == 1: res += 1\\n                n -= 1\\n                if n == 0: return res\\n            val ^= 3\\n        return res\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def magicalString(self, n: int) -> int:\\n        if n <= 0: return 0\\n        if n <= 3: return 1\\n        n -= 3\\n        deque = collections.deque([2])\\n        val = 1\\n        res = 1\\n        while n:\\n            cnt = deque.popleft()\\n            for i in range(cnt):\\n                deque.append(val)\\n                if val == 1: res += 1\\n                n -= 1\\n                if n == 0: return res\\n            val ^= 3\\n        return res\\n```",
                "codeTag": "Java"
            },
            {
                "id": 169609,
                "title": "python-o-n-time-o-n-space",
                "content": "keep a slow pointer i\\n```\\nclass Solution(object):\\n    def magicalString(self, n):\\n        \"\"\"\\n        :type n: int\\n        :rtype: int\\n        \"\"\"\\n        nums = [1, 2, 2]\\n        i = 2\\n        while len(nums) < n:\\n            nums.append(3 - nums[-1])\\n            if nums[i] == 2:\\n                nums.append(nums[-1])\\n            i += 1\\n        \\n        count = 0\\n        for i in range(n):\\n            if nums[i] == 1:\\n                count += 1\\n        return count\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution(object):\\n    def magicalString(self, n):\\n        \"\"\"\\n        :type n: int\\n        :rtype: int\\n        \"\"\"\\n        nums = [1, 2, 2]\\n        i = 2\\n        while len(nums) < n:\\n            nums.append(3 - nums[-1])\\n            if nums[i] == 2:\\n                nums.append(nums[-1])\\n            i += 1\\n        \\n        count = 0\\n        for i in range(n):\\n            if nums[i] == 1:\\n                count += 1\\n        return count\\n```",
                "codeTag": "Java"
            },
            {
                "id": 96464,
                "title": "o-n-time-and-o-n-space",
                "content": "It's easy to get the result by generating all the numbers up to n.\\nUse a index to track the times that current number occurs and a index to assign the number.\\n\\n```java\\npublic int magicalString(int n) {\\n        int[] magic=new int[n];\\n        int number=1, count=0;\\n        int index=0;\\n        int res=0;\\n        for(int i=0;i<n;i++){\\n            res+=number==1?1:0;\\n            magic[i]=number;\\n            count++;\\n            if(count==magic[index]){\\n                number=(number+1)/number;\\n                count=0;\\n                index++;\\n            }\\n        }\\n        return res;\\n    }\\n```\\n\\nI was wondering if it's possible to generate the magic function like Fibonacci.",
                "solutionTags": [],
                "code": "```java\\npublic int magicalString(int n) {\\n        int[] magic=new int[n];\\n        int number=1, count=0;\\n        int index=0;\\n        int res=0;\\n        for(int i=0;i<n;i++){\\n            res+=number==1?1:0;\\n            magic[i]=number;\\n            count++;\\n            if(count==magic[index]){\\n                number=(number+1)/number;\\n                count=0;\\n                index++;\\n            }\\n        }\\n        return res;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 96465,
                "title": "java-solution-easy-understand",
                "content": "```\\n\\npublic class Solution {\\n    public int magicalString(int n) {\\n        if(n==0) return 0;\\n        StringBuilder sb=new StringBuilder(\"122\");\\n        int distcnt=2;\\n        int ret=1;\\n        while(sb.length()<n)\\n        {\\n            char ch=sb.charAt(distcnt);\\n            char prev=sb.charAt(sb.length()-1);\\n            if(ch=='1')\\n            {\\n                if(prev=='1') sb.append(\"2\");\\n                else{ sb.append(\"1\");  ret++;}\\n            }\\n            else\\n            {\\n                if(prev=='1') {sb.append(\"22\");}\\n                else{\\n                    sb.append(\"11\");  \\n                   ret= sb.length()==n+1 ? ret+1:ret+2;\\n \\n                }\\n            }\\n            distcnt++;\\n        }\\n       // if(sb.length()==n+1&&sb.charAt(sb.length()-1)=='1') return ret-1;\\n        return ret;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\n\\npublic class Solution {\\n    public int magicalString(int n) {\\n        if(n==0) return 0;\\n        StringBuilder sb=new StringBuilder(\"122\");\\n        int distcnt=2;\\n        int ret=1;\\n        while(sb.length()<n)\\n        {\\n            char ch=sb.charAt(distcnt);\\n            char prev=sb.charAt(sb.length()-1);\\n            if(ch=='1')\\n            {\\n                if(prev=='1') sb.append(\"2\");\\n                else{ sb.append(\"1\");  ret++;}\\n            }\\n            else\\n            {\\n                if(prev=='1') {sb.append(\"22\");}\\n                else{\\n                    sb.append(\"11\");  \\n                   ret= sb.length()==n+1 ? ret+1:ret+2;\\n \\n                }\\n            }\\n            distcnt++;\\n        }\\n       // if(sb.length()==n+1&&sb.charAt(sb.length()-1)=='1') return ret-1;\\n        return ret;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 96467,
                "title": "simple-java-solution",
                "content": "```\\n public int magicalString(int n) {\\n        if(n==0)return 0;\\n        if(n==1)return 1;\\n        StringBuilder sb= new StringBuilder(n);\\n        sb.append(\"122\");\\n        int count=1;\\n        int i=2;\\n        while (sb.length()<n){\\n            if(sb.charAt(i)=='1'){\\n                boolean one=sb.charAt(sb.length()-1) =='1';\\n                count+=one ? 0: 1;\\n                sb.append(one ? 2 : 1);\\n            }else{\\n                boolean one=sb.charAt(sb.length()-1) =='1';\\n                count+=one ? 0: 2;\\n                sb.append(one ? 22 : 11);\\n            }\\n            i++;\\n        }\\n        if(sb.length()>n && sb.charAt(sb.length()-1)=='1')count--;\\n        return count;\\n    }",
                "solutionTags": [],
                "code": "```\\n public int magicalString(int n) {\\n        if(n==0)return 0;\\n        if(n==1)return 1;\\n        StringBuilder sb= new StringBuilder(n);\\n        sb.append(\"122\");\\n        int count=1;\\n        int i=2;\\n        while (sb.length()<n){\\n            if(sb.charAt(i)=='1'){\\n                boolean one=sb.charAt(sb.length()-1) =='1';\\n                count+=one ? 0: 1;\\n                sb.append(one ? 2 : 1);\\n            }else{\\n                boolean one=sb.charAt(sb.length()-1) =='1';\\n                count+=one ? 0: 2;\\n                sb.append(one ? 22 : 11);\\n            }\\n            i++;\\n        }\\n        if(sb.length()>n && sb.charAt(sb.length()-1)=='1')count--;\\n        return count;\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 96473,
                "title": "one-traverse-js-solution",
                "content": "```\\nvar magicalString = function(n) {\\n    if (!n) return n;\\n    var sb = [1, 2, 2];\\n    var count = 1;\\n    for (var i = 3; i <= n; i++) {\\n        if (sb[i - 1] === 1) count++;\\n        for (var j = 0; j < sb[i - 1]; j++) sb.push((i % 2) ? 1 : 2);\\n    }\\n    return count;\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nvar magicalString = function(n) {\\n    if (!n) return n;\\n    var sb = [1, 2, 2];\\n    var count = 1;\\n    for (var i = 3; i <= n; i++) {\\n        if (sb[i - 1] === 1) count++;\\n        for (var j = 0; j < sb[i - 1]; j++) sb.push((i % 2) ? 1 : 2);\\n    }\\n    return count;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 96480,
                "title": "java-solution-with-an-array",
                "content": "The main point is to create the magical string:\\nWe could use the value of current element to calculate the index of the elements to create. For example,\\n```\\nValue-of-Current-Element           Index-of-Element-to-Create (start from 1)\\n1                                                         1\\n2                                                         2, 3\\n2                                                         4, 5\\n1                                                         6\\n1                                                         7\\n2                                                         8, 9\\n```\\nThe value of the elements is changing b/w '1' and '2' alternatively.\\n\\n```\\n    public int magicalString(int n) {\\n        if (n < 1) return 0;\\n        if (n == 1) return 1;\\n        \\n        int[] s = new int[n + 1];\\n\\n        int val = 1;\\n        int index = 2;\\n        int count = 1;\\n        for (int i = 2; i < n + 1; i++) {\\n            val = val == 2 ? 1 : 2;\\n            s[index++] = val;\\n            if (val == 1) count++;\\n            if (index > n) break;\\n            if (s[i] == 2) {\\n                s[index++] = val;\\n                if (val == 1) count++;\\n                if (index > n) break;\\n            }\\n        }\\n\\n        return count;\\n    }\\n```",
                "solutionTags": [],
                "code": "```\\nValue-of-Current-Element           Index-of-Element-to-Create (start from 1)\\n1                                                         1\\n2                                                         2, 3\\n2                                                         4, 5\\n1                                                         6\\n1                                                         7\\n2                                                         8, 9\\n```\n```\\n    public int magicalString(int n) {\\n        if (n < 1) return 0;\\n        if (n == 1) return 1;\\n        \\n        int[] s = new int[n + 1];\\n\\n        int val = 1;\\n        int index = 2;\\n        int count = 1;\\n        for (int i = 2; i < n + 1; i++) {\\n            val = val == 2 ? 1 : 2;\\n            s[index++] = val;\\n            if (val == 1) count++;\\n            if (index > n) break;\\n            if (s[i] == 2) {\\n                s[index++] = val;\\n                if (val == 1) count++;\\n                if (index > n) break;\\n            }\\n        }\\n\\n        return count;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 4074283,
                "title": "c-generate-sequence-and-count-1-18ms-100",
                "content": "# Code\\n```\\npublic class Solution {\\n    public int MagicalString(int n) \\n    {\\n        var list = new List<int>(n) { 1, 2, 2 };\\n\\n        var count = 1;\\n\\n        // \\'d\\' will switch between 1 and 2 \\n        // \\'ci\\' index for count times for \\'d\\'\\n        for(int d = 1, ci = 2; list.Count < n; d = 3 - d)\\n        {\\n            for(var i=list[ci++]; i > 0 && list.Count < n; i--)\\n            {\\n                list.Add(d);\\n\\n                count += 2 - d;\\n            }\\n        }\\n\\n        return count;\\n    }\\n}\\n```\\nor same logic with only one loop\\n```\\npublic class Solution {\\n    public int MagicalString(int n) \\n    {\\n        var list = new List<int>(n) { 1, 2, 2 };\\n\\n        var count = 1;\\n\\n        // \\'d\\' will switch between 1 and 2 \\n        // \\'ci\\' index for count times for \\'d\\'\\n        for(int d = 1, ci = 2; list.Count < n; count += 2 - d)\\n        {\\n            if(list[ci] == 0)\\n            {\\n                d = 3 - d;\\n                ci++;\\n            }\\n\\n            list[ci]--;\\n            list.Add(d);\\n        }\\n\\n        return count;\\n    }\\n}\\n```\\nor StringBuilder version\\n```\\npublic class Solution {\\n    public int MagicalString(int n) \\n    {\\n        var sb = new StringBuilder(\"122\");\\n\\n        for(var i = 2; sb.Length < n;)\\n            sb.Append((char)(sb[^1] ^ 3), sb[i++]-\\'0\\');\\n\\n        sb.Length = n;\\n\\n        return sb.ToString().Count(_ => _ == \\'1\\');\\n    }\\n}\\n```",
                "solutionTags": [
                    "C#"
                ],
                "code": "```\\npublic class Solution {\\n    public int MagicalString(int n) \\n    {\\n        var list = new List<int>(n) { 1, 2, 2 };\\n\\n        var count = 1;\\n\\n        // \\'d\\' will switch between 1 and 2 \\n        // \\'ci\\' index for count times for \\'d\\'\\n        for(int d = 1, ci = 2; list.Count < n; d = 3 - d)\\n        {\\n            for(var i=list[ci++]; i > 0 && list.Count < n; i--)\\n            {\\n                list.Add(d);\\n\\n                count += 2 - d;\\n            }\\n        }\\n\\n        return count;\\n    }\\n}\\n```\n```\\npublic class Solution {\\n    public int MagicalString(int n) \\n    {\\n        var list = new List<int>(n) { 1, 2, 2 };\\n\\n        var count = 1;\\n\\n        // \\'d\\' will switch between 1 and 2 \\n        // \\'ci\\' index for count times for \\'d\\'\\n        for(int d = 1, ci = 2; list.Count < n; count += 2 - d)\\n        {\\n            if(list[ci] == 0)\\n            {\\n                d = 3 - d;\\n                ci++;\\n            }\\n\\n            list[ci]--;\\n            list.Add(d);\\n        }\\n\\n        return count;\\n    }\\n}\\n```\n```\\npublic class Solution {\\n    public int MagicalString(int n) \\n    {\\n        var sb = new StringBuilder(\"122\");\\n\\n        for(var i = 2; sb.Length < n;)\\n            sb.Append((char)(sb[^1] ^ 3), sb[i++]-\\'0\\');\\n\\n        sb.Length = n;\\n\\n        return sb.ToString().Count(_ => _ == \\'1\\');\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4072902,
                "title": "java-very-simple-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int magicalString(int n) {\\n        StringBuilder sb=new StringBuilder(\"122\");\\n        int i=2;\\n        char pre=sb.charAt(i);\\n        while(sb.length()<n)\\n        {\\n            if(sb.charAt(i)==\\'2\\')\\n            {\\n                if(pre==\\'2\\')\\n                {\\n                    sb.append(\"11\");\\n                    pre=\\'1\\';\\n                }\\n                else\\n                {\\n                    sb.append(\"22\");\\n                    pre=\\'2\\';\\n                }\\n                i++;\\n            }\\n            else if(sb.charAt(i)==\\'1\\')\\n            {\\n                if(pre==\\'1\\')\\n                {\\n                    sb.append(\"2\");\\n                    pre=\\'2\\';\\n                }\\n                else\\n                {\\n                    sb.append(\"1\");\\n                    pre=\\'1\\';\\n                }\\n                i++;\\n            }\\n        }\\n        // System.out.println(sb.toString());\\n        int c=0;\\n        for(int j=0;j<n;j++)\\n        {\\n            if(sb.charAt(j)==\\'1\\')\\n            {\\n                c++;\\n            }\\n        }\\n        return c;\\n        // return sb.charAt(n-1); \\n        // return 2;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int magicalString(int n) {\\n        StringBuilder sb=new StringBuilder(\"122\");\\n        int i=2;\\n        char pre=sb.charAt(i);\\n        while(sb.length()<n)\\n        {\\n            if(sb.charAt(i)==\\'2\\')\\n            {\\n                if(pre==\\'2\\')\\n                {\\n                    sb.append(\"11\");\\n                    pre=\\'1\\';\\n                }\\n                else\\n                {\\n                    sb.append(\"22\");\\n                    pre=\\'2\\';\\n                }\\n                i++;\\n            }\\n            else if(sb.charAt(i)==\\'1\\')\\n            {\\n                if(pre==\\'1\\')\\n                {\\n                    sb.append(\"2\");\\n                    pre=\\'2\\';\\n                }\\n                else\\n                {\\n                    sb.append(\"1\");\\n                    pre=\\'1\\';\\n                }\\n                i++;\\n            }\\n        }\\n        // System.out.println(sb.toString());\\n        int c=0;\\n        for(int j=0;j<n;j++)\\n        {\\n            if(sb.charAt(j)==\\'1\\')\\n            {\\n                c++;\\n            }\\n        }\\n        return c;\\n        // return sb.charAt(n-1); \\n        // return 2;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4057805,
                "title": "simple-javascript-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * @param {number} n\\n * @return {number}\\n */\\nvar magicalString = function(n) {\\n    const temp = [\\'1\\', \\'2\\', \\'2\\'];\\n\\tlet magic = 2;\\n\\n\\twhile (temp.length < n) {\\n\\t\\tconst count = temp[magic++];\\n\\t\\tconst last = temp[temp.length - 1];\\n\\t\\tconst str = last === \\'1\\' ? \\'2\\' : \\'1\\';\\n\\n\\t\\tfor (let n = 1; n <= count; n++) {\\n            temp.push(str);\\n        }\\n\\t}\\n\\treturn temp.slice(0, n).filter(str => str === \\'1\\').length\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {number} n\\n * @return {number}\\n */\\nvar magicalString = function(n) {\\n    const temp = [\\'1\\', \\'2\\', \\'2\\'];\\n\\tlet magic = 2;\\n\\n\\twhile (temp.length < n) {\\n\\t\\tconst count = temp[magic++];\\n\\t\\tconst last = temp[temp.length - 1];\\n\\t\\tconst str = last === \\'1\\' ? \\'2\\' : \\'1\\';\\n\\n\\t\\tfor (let n = 1; n <= count; n++) {\\n            temp.push(str);\\n        }\\n\\t}\\n\\treturn temp.slice(0, n).filter(str => str === \\'1\\').length\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 4054344,
                "title": "481-magical-string",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int magicalString(int n) {\\n        if (n <= 0) return 0;\\n        if (n <= 3) return 1;\\n\\n        StringBuilder s = new StringBuilder(\"122\");\\n        int ptr = 2;\\n        int count = 1;\\n\\n        while (s.length() < n) {\\n            int num = s.charAt(ptr) - \\'0\\';\\n            char toAdd = (s.charAt(s.length() - 1) == \\'1\\') ? \\'2\\' : \\'1\\';\\n\\n            // Count \\'1\\'s as we add them\\n            if (toAdd == \\'1\\') count += num;\\n\\n            // Add the next part of the magical string\\n            s.append(String.valueOf(toAdd).repeat(num));\\n            ptr++;\\n        }\\n\\n        // If the length of the generated string exceeds n, count only up to n\\n        for (int i = n; i < s.length(); i++) {\\n            if (s.charAt(i) == \\'1\\') {\\n                count--;\\n            }\\n        }\\n\\n        return count;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int magicalString(int n) {\\n        if (n <= 0) return 0;\\n        if (n <= 3) return 1;\\n\\n        StringBuilder s = new StringBuilder(\"122\");\\n        int ptr = 2;\\n        int count = 1;\\n\\n        while (s.length() < n) {\\n            int num = s.charAt(ptr) - \\'0\\';\\n            char toAdd = (s.charAt(s.length() - 1) == \\'1\\') ? \\'2\\' : \\'1\\';\\n\\n            // Count \\'1\\'s as we add them\\n            if (toAdd == \\'1\\') count += num;\\n\\n            // Add the next part of the magical string\\n            s.append(String.valueOf(toAdd).repeat(num));\\n            ptr++;\\n        }\\n\\n        // If the length of the generated string exceeds n, count only up to n\\n        for (int i = n; i < s.length(); i++) {\\n            if (s.charAt(i) == \\'1\\') {\\n                count--;\\n            }\\n        }\\n\\n        return count;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4001945,
                "title": "easy-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n\\n- Time complexity:\\n\\n\\n\\n- Space complexity:\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int magicalString(int n) {\\n        if (n == 0) return 0;\\n        if (n <= 3) return 1;\\n        \\n        string s = \"122\";\\n        int i = 2;\\n        int count = 1;\\n        \\n        while (s.length() < n) {\\n            char nextChar = (s.back() == \\'1\\') ? \\'2\\' : \\'1\\';\\n            int countChar = s[i] - \\'0\\';\\n            \\n            while (countChar--) {\\n                s += nextChar;\\n                if (nextChar == \\'1\\') count++;\\n                if (s.length() >= n) break; // Terminate if we have generated enough characters.\\n            }\\n            \\n            i++;\\n        }\\n        \\n        return count;\\n    }\\n};\\n\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int magicalString(int n) {\\n        if (n == 0) return 0;\\n        if (n <= 3) return 1;\\n        \\n        string s = \"122\";\\n        int i = 2;\\n        int count = 1;\\n        \\n        while (s.length() < n) {\\n            char nextChar = (s.back() == \\'1\\') ? \\'2\\' : \\'1\\';\\n            int countChar = s[i] - \\'0\\';\\n            \\n            while (countChar--) {\\n                s += nextChar;\\n                if (nextChar == \\'1\\') count++;\\n                if (s.length() >= n) break; // Terminate if we have generated enough characters.\\n            }\\n            \\n            i++;\\n        }\\n        \\n        return count;\\n    }\\n};\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3963982,
                "title": "c-easy-solution",
                "content": "```\\nchar flip(char c) {\\n        if(c == \\'1\\')\\n            return \\'2\\';\\n        else return \\'1\\';\\n    }\\n    \\n    int magicalString(int n) {\\n        string s = \"122\";\\n        char next = \\'1\\';\\n        int ind = 2;\\n        int ans = 1;\\n        while(s.size() < n) {\\n            int t = s[ind] - \\'0\\';\\n            while(t--) {\\n                s.push_back(next);\\n                ans += ((s.size() <= n && next == \\'1\\') ? 1 : 0);\\n            }\\n            ind++;\\n            next = flip(next);\\n        }\\n        return ans;\\n\\t\\t}\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Array"
                ],
                "code": "```\\nchar flip(char c) {\\n        if(c == \\'1\\')\\n            return \\'2\\';\\n        else return \\'1\\';\\n    }\\n    \\n    int magicalString(int n) {\\n        string s = \"122\";\\n        char next = \\'1\\';\\n        int ind = 2;\\n        int ans = 1;\\n        while(s.size() < n) {\\n            int t = s[ind] - \\'0\\';\\n            while(t--) {\\n                s.push_back(next);\\n                ans += ((s.size() <= n && next == \\'1\\') ? 1 : 0);\\n            }\\n            ind++;\\n            next = flip(next);\\n        }\\n        return ans;\\n\\t\\t}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3911861,
                "title": "easy",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int magicalString(int n) {\\n        string str = \"122\";\\n        char prev = \\'2\\';\\n        int count = 0;\\n        int i = 2;\\n        cout<<str.size();\\n        while(str.size()<n){\\n            if(str[i] == \\'2\\'){\\n                if(prev == \\'1\\'){\\n                    str+=\\'2\\';\\n                    str+=\\'2\\';\\n                    prev = \\'2\\';\\n                }\\n                else{\\n                    str+=\\'1\\';\\n                    str+=\\'1\\';\\n                    prev = \\'1\\';\\n                }\\n            }\\n\\n            else{\\n                if(prev == \\'1\\'){\\n                    str+=\\'2\\';\\n                    prev = \\'2\\';\\n                }\\n                else{\\n                    str+=\\'1\\';\\n                    prev = \\'1\\';\\n                }\\n            }\\n            i++;\\n        }\\n        int j = 0;\\n        while(j<n and j<str.size()){\\n            if(str[j] == \\'1\\'){\\n                count++;\\n            }\\n            j++;\\n        }\\n        return count;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int magicalString(int n) {\\n        string str = \"122\";\\n        char prev = \\'2\\';\\n        int count = 0;\\n        int i = 2;\\n        cout<<str.size();\\n        while(str.size()<n){\\n            if(str[i] == \\'2\\'){\\n                if(prev == \\'1\\'){\\n                    str+=\\'2\\';\\n                    str+=\\'2\\';\\n                    prev = \\'2\\';\\n                }\\n                else{\\n                    str+=\\'1\\';\\n                    str+=\\'1\\';\\n                    prev = \\'1\\';\\n                }\\n            }\\n\\n            else{\\n                if(prev == \\'1\\'){\\n                    str+=\\'2\\';\\n                    prev = \\'2\\';\\n                }\\n                else{\\n                    str+=\\'1\\';\\n                    prev = \\'1\\';\\n                }\\n            }\\n            i++;\\n        }\\n        int j = 0;\\n        while(j<n and j<str.size()){\\n            if(str[j] == \\'1\\'){\\n                count++;\\n            }\\n            j++;\\n        }\\n        return count;\\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 3872228,
                "title": "java-iterative-method-10ms-string-builder",
                "content": "# Complexity\\n- Time complexity: O(n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(n)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int magicalString(int n) {\\n        StringBuilder s = new StringBuilder(\"12\");\\n        int curr_size = 2;\\n        char prev = \\'1\\';\\n        int count = 1;\\n        for(int i=1 ;curr_size < n ;i++){\\n            if(s.charAt(i) == \\'2\\'){\\n                if(i == 1){\\n                    s.append(\\'2\\');\\n                    prev = \\'2\\';\\n                    curr_size += 1;\\n                    continue;\\n                }\\n                if(prev == \\'1\\'){\\n                    s.append(\"22\");\\n                    prev = \\'2\\';\\n                }\\n                else{\\n                    s.append(\"11\");\\n                    prev = \\'1\\';\\n                    count += 2;\\n                }\\n                curr_size += 2;\\n            }\\n            else{\\n                if(prev == \\'1\\'){\\n                    s.append(\\'2\\');\\n                    prev = \\'2\\';\\n                }\\n                else{\\n                    s.append(\\'1\\');\\n                    prev = \\'1\\';\\n                    count += 1;\\n                }\\n                curr_size += 1;\\n            }\\n        }\\n       // System.out.println(s);\\n        return (s.length() == n || s.charAt(s.length() - 1) != \\'1\\')? count:count-1;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int magicalString(int n) {\\n        StringBuilder s = new StringBuilder(\"12\");\\n        int curr_size = 2;\\n        char prev = \\'1\\';\\n        int count = 1;\\n        for(int i=1 ;curr_size < n ;i++){\\n            if(s.charAt(i) == \\'2\\'){\\n                if(i == 1){\\n                    s.append(\\'2\\');\\n                    prev = \\'2\\';\\n                    curr_size += 1;\\n                    continue;\\n                }\\n                if(prev == \\'1\\'){\\n                    s.append(\"22\");\\n                    prev = \\'2\\';\\n                }\\n                else{\\n                    s.append(\"11\");\\n                    prev = \\'1\\';\\n                    count += 2;\\n                }\\n                curr_size += 2;\\n            }\\n            else{\\n                if(prev == \\'1\\'){\\n                    s.append(\\'2\\');\\n                    prev = \\'2\\';\\n                }\\n                else{\\n                    s.append(\\'1\\');\\n                    prev = \\'1\\';\\n                    count += 1;\\n                }\\n                curr_size += 1;\\n            }\\n        }\\n       // System.out.println(s);\\n        return (s.length() == n || s.charAt(s.length() - 1) != \\'1\\')? count:count-1;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3853749,
                "title": "magical-string",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def magicalString(self, n: int) -> int:\\n        s=\"12\"\\n        if n==1 or n==2:\\n            return 1\\n        i=0\\n        while len(s)<=n:\\n            k=\"\"\\n            for i in range(len(s)):\\n                if i%2==0:\\n                    for i in range(int(s[i])):\\n                        k=k+\"1\"\\n                else:\\n                    for i in range(int(s[i])):\\n                        k=k+\"2\"\\n            s=k\\n        s=s[:n:]\\n        print(s)\\n        return s.count(\"1\")\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def magicalString(self, n: int) -> int:\\n        s=\"12\"\\n        if n==1 or n==2:\\n            return 1\\n        i=0\\n        while len(s)<=n:\\n            k=\"\"\\n            for i in range(len(s)):\\n                if i%2==0:\\n                    for i in range(int(s[i])):\\n                        k=k+\"1\"\\n                else:\\n                    for i in range(int(s[i])):\\n                        k=k+\"2\"\\n            s=k\\n        s=s[:n:]\\n        print(s)\\n        return s.count(\"1\")\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3839492,
                "title": "o-n-with-bit-array",
                "content": "\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nGenerate magic string as bit table where $true$ represents $1$ and $false$ represents $2$. Then count all values set to $true$\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n$$O(n)$$ \\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n$$O(n)$$ \\n# Code\\n```\\nclass Solution {\\n    public int magicalString(int n) {\\n        boolean[] magicString = new boolean[Math.max(n, 3)];\\n        magicString[0] = true;\\n        magicString[1] = false;\\n        magicString[2] = false;\\n        int groupPointer = 2;\\n        for (int i = 3; i<n; i++) {\\n            boolean previous = magicString[i-1];\\n            boolean current = !previous;\\n            if (magicString[groupPointer]) {\\n                magicString[i] =  current;\\n            } else {\\n                magicString[i] =  current;\\n                if (i+1 < n)\\n                    magicString[i+1] = current;\\n                i++;\\n            }\\n            groupPointer++;\\n        }\\n        int oneCount = 0;\\n        for (int i = 0; i<n; i++) {\\n            if (magicString[i]) {\\n                oneCount++;\\n            }\\n        }\\n        return oneCount;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int magicalString(int n) {\\n        boolean[] magicString = new boolean[Math.max(n, 3)];\\n        magicString[0] = true;\\n        magicString[1] = false;\\n        magicString[2] = false;\\n        int groupPointer = 2;\\n        for (int i = 3; i<n; i++) {\\n            boolean previous = magicString[i-1];\\n            boolean current = !previous;\\n            if (magicString[groupPointer]) {\\n                magicString[i] =  current;\\n            } else {\\n                magicString[i] =  current;\\n                if (i+1 < n)\\n                    magicString[i+1] = current;\\n                i++;\\n            }\\n            groupPointer++;\\n        }\\n        int oneCount = 0;\\n        for (int i = 0; i<n; i++) {\\n            if (magicString[i]) {\\n                oneCount++;\\n            }\\n        }\\n        return oneCount;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3713545,
                "title": "my-java-solution-easy-to-understand",
                "content": "\\n\\n# Code\\n```\\nclass Solution {\\n    public int magicalString(int n) {\\n        boolean flag = true; // false means append 1 else append true;\\n        StringBuilder str = new StringBuilder();\\n        str.append(\"122\");\\n        int f = 2;\\n\\n        while(str.length() <= n){\\n            int c = str.charAt(f) - \\'0\\';\\n            while(c > 0){\\n                if(flag){\\n                    str.append(\\'1\\');\\n                }else{\\n                    str.append(\\'2\\');\\n                }\\n                c--;\\n            }\\n            flag = !flag;\\n            f++;\\n        }\\n\\n        int ans = 0;\\n        for(int i = 0; i < n; i++){\\n            if(str.charAt(i) == \\'1\\'){\\n                ans++;\\n            }\\n        }\\n        return ans;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int magicalString(int n) {\\n        boolean flag = true; // false means append 1 else append true;\\n        StringBuilder str = new StringBuilder();\\n        str.append(\"122\");\\n        int f = 2;\\n\\n        while(str.length() <= n){\\n            int c = str.charAt(f) - \\'0\\';\\n            while(c > 0){\\n                if(flag){\\n                    str.append(\\'1\\');\\n                }else{\\n                    str.append(\\'2\\');\\n                }\\n                c--;\\n            }\\n            flag = !flag;\\n            f++;\\n        }\\n\\n        int ans = 0;\\n        for(int i = 0; i < n; i++){\\n            if(str.charAt(i) == \\'1\\'){\\n                ans++;\\n            }\\n        }\\n        return ans;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3694426,
                "title": "python-3-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n    1. The idea is to construct the string first upto the constraint\\n    2. Return the count of 1 in string upto n\\n\\n# Code\\n```\\n# Below is the construction of string upto constraint\\n\\ns = \"122\"\\ni = 2\\n\\nwhile len(s) < 10 ** 5:\\n    current = \"1\" if s[-1] == \"2\" else \"2\"\\n    s += int(s[i]) * current\\n    i += 1\\n\\nclass Solution:\\n    def magicalString(self, n: int) -> int:\\n        return s[:n].count(\"1\")\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\n# Below is the construction of string upto constraint\\n\\ns = \"122\"\\ni = 2\\n\\nwhile len(s) < 10 ** 5:\\n    current = \"1\" if s[-1] == \"2\" else \"2\"\\n    s += int(s[i]) * current\\n    i += 1\\n\\nclass Solution:\\n    def magicalString(self, n: int) -> int:\\n        return s[:n].count(\"1\")\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3621098,
                "title": "easy-c-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity: O(n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(n)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\nplease upvote if you find it helpful \\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int magicalString(int n) {\\n        vector<int> v; int i = 4; \\n        v.push_back(1); v.push_back(2); v.push_back(2); v.push_back(1); v.push_back(1); v.push_back(2);\\n        while(v.size() < n+5){\\n            for(int j=0; j<v[i]; j++) v.push_back(1);  i++;\\n            for(int j=0; j<v[i]; j++) v.push_back(2);  i++;\\n        }\\n        int count = 0; \\n        for(int j=0; j<n; j++) if(v[j] == 1) count++; \\n\\n        return count; \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int magicalString(int n) {\\n        vector<int> v; int i = 4; \\n        v.push_back(1); v.push_back(2); v.push_back(2); v.push_back(1); v.push_back(1); v.push_back(2);\\n        while(v.size() < n+5){\\n            for(int j=0; j<v[i]; j++) v.push_back(1);  i++;\\n            for(int j=0; j<v[i]; j++) v.push_back(2);  i++;\\n        }\\n        int count = 0; \\n        for(int j=0; j<n; j++) if(v[j] == 1) count++; \\n\\n        return count; \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3572699,
                "title": "faster-than-100-of-the-submissions-rust-0ms",
                "content": "# About\\nI already built the a similar solution with python which should be easier to understand (just look for 100% python).\\n\\n# Intuition\\nThere are about the same amount of 1\\'s and 2\\'s in the string (at least for long strings). This means the number of Packs $$p$$ is approximately $$p=\\\\frac{2}{1+2}\\\\cdot n\\\\approx0.667 \\\\cdot n$$ in a string of the length $$n$$.\\n\\n# Approach\\nKnowing the relation of Packs $$p$$ to Digits $$n$$ allows us approximate the amount of Packs we have to generate beforehand. \\n\\nThis means we can use a simple for loop without any control flow to generate the (slightly to long) magical string. \\n\\n>NOTE: This does not change the Time or Space complexity but is still a sigificant improvement since we eliminate the need for a `while` loop checking `len(s) < n` on every revolution.\\n\\nWe use a padding of $$2$$ above the approximate pack count.\\nTbh this is lucky numbered but works reliable since for greater $$n$$ the padding grows larger because of the approximation $$0.667$$.\\n \\n\\n# Complexity\\n- Time complexity:\\n$$O(n)$$ because the loop runs $$\\\\lfloor0.667 \\\\cdot n\\\\rfloor +2$$ times\\n\\n- Space complexity:\\n$$O(n)$$ because the array `s` holds around $$1.5 \\\\cdot n$$ elements\\n\\n# Code\\n```rust\\nimpl Solution {\\n    pub fn magical_string(n: i32) -> i32 {\\n        //Calculate the estimated number of iterations\\n        let iter_count = ((0.667 * n as f64) + 2.0).ceil() as usize;\\n        //Build the base String\\n        let mut s: String = String::from(\"1221121221221121122\");\\n        //Build the rest of the String\\n        for i in 12..iter_count {\\n            //Match the conditions (next val, next val count )\\n            s.push_str(match ((i % 2) + 1, s.as_bytes()[i]) {\\n                (1, b\\'1\\') => \"1\",\\n                (1, b\\'2\\') => \"11\",\\n                (2, b\\'1\\') => \"2\",\\n                (2, b\\'2\\') => \"22\",\\n                _ => panic!(\"Invalid input\")\\n            })\\n        }\\n        //Return the count of false values\\n        s.as_bytes()[0..n as usize].iter().filter(|&v| v == &b\\'1\\').count() as i32\\n    }\\n}\\n```\\n\\n# Proof 100% faster\\n![Screenshot 2023-05-28 at 19.11.23.png](https://assets.leetcode.com/users/images/09aed84d-17dc-460b-842d-b61cd152a77c_1685294096.6088192.png)\\n\\n",
                "solutionTags": [
                    "Rust"
                ],
                "code": "```rust\\nimpl Solution {\\n    pub fn magical_string(n: i32) -> i32 {\\n        //Calculate the estimated number of iterations\\n        let iter_count = ((0.667 * n as f64) + 2.0).ceil() as usize;\\n        //Build the base String\\n        let mut s: String = String::from(\"1221121221221121122\");\\n        //Build the rest of the String\\n        for i in 12..iter_count {\\n            //Match the conditions (next val, next val count )\\n            s.push_str(match ((i % 2) + 1, s.as_bytes()[i]) {\\n                (1, b\\'1\\') => \"1\",\\n                (1, b\\'2\\') => \"11\",\\n                (2, b\\'1\\') => \"2\",\\n                (2, b\\'2\\') => \"22\",\\n                _ => panic!(\"Invalid input\")\\n            })\\n        }\\n        //Return the count of false values\\n        s.as_bytes()[0..n as usize].iter().filter(|&v| v == &b\\'1\\').count() as i32\\n    }\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3561211,
                "title": "just-a-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nThe magical string is a patterned string where each digit indicates the number of times the next digit should be repeated. We start with the initial string \"122\" and continue expanding it until it reaches the desired length. We count the number of \\'1\\'s in the resulting string and return the count.\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nGenerate the magical string by continuously expanding it based on the pattern defined by the previous digits. Use bitwise XOR to determine the next character and repetition count. Count the number of \\'1\\'s in the resulting string and return the count.\\n\\nBenefits and Specialized Learnings: This problem helps in understanding string \\n# Complexity\\n- Time complexity: O(N)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(N)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int magicalString(int length) {\\n        string MagicString = \"122\";\\n        int index = 2;\\n        while(MagicString.size() < length){\\n            int repeat = MagicString[index] - \\'0\\';\\n            char nextChar = MagicString.back() ^ 3;\\n            MagicString += string(repeat, nextChar);\\n            index++;\\n        }\\n\\n        return count(MagicString.begin(),MagicString.begin() + length, \\'1\\');\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int magicalString(int length) {\\n        string MagicString = \"122\";\\n        int index = 2;\\n        while(MagicString.size() < length){\\n            int repeat = MagicString[index] - \\'0\\';\\n            char nextChar = MagicString.back() ^ 3;\\n            MagicString += string(repeat, nextChar);\\n            index++;\\n        }\\n\\n        return count(MagicString.begin(),MagicString.begin() + length, \\'1\\');\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3556411,
                "title": "faster-than-100-of-the-submissions-python-77ms",
                "content": "# Intuition\\nThere are about the same amount of 1\\'s and 2\\'s in the string (at least for long strings). This means the number of Packs $$p$$ is approximately $$p=\\\\frac{2}{1+2}\\\\cdot n\\\\approx0.667 \\\\cdot n$$ in a string of the length $$n$$.\\n\\n# Approach\\nKnowing the relation of Packs $$p$$ to Digits $$n$$ allows us approximate the amount of Packs we have to generate beforehand. \\n\\nThis means we can use a simple for loop without any control flow to generate the (slightly to long) magical string. \\n\\n>NOTE: This does not change the Time or Space complexity but is still a sigificant improvement since we eliminate the need for a `while` loop checking `len(s) < n` on every revolution.\\n\\nWe use a padding of $$2$$ above the approximate pack count.\\nTbh this is lucky numbered but works reliable since for greater $$n$$ the padding grows larger because of the approximation $$0.667$$.\\n \\n\\n# Complexity\\n- Time complexity:\\n$$O(n)$$ because the loop runs $$\\\\lfloor0.667 \\\\cdot n\\\\rfloor +2$$ times\\n\\n- Space complexity:\\n$$O(n)$$ because the array `s` holds around $$1.5 \\\\cdot n$$ elements\\n\\n# Code\\n```python\\nclass Solution(object):\\n    def magicalString(self, n):\\n        s = [1, 2, 2]\\n        for i in range(2, int(0.667*n)+2):\\n            s += [i % 2 + 1] * s[i]\\n        return s[:n].count(1)\\n```\\n\\n# Proof 100% faster\\n![Screenshot 2023-05-23 at 19.13.13.png](https://assets.leetcode.com/users/images/73fcfdc6-d073-4dc9-b1ac-2174e13be682_1684862012.4495208.png)\\n",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```python\\nclass Solution(object):\\n    def magicalString(self, n):\\n        s = [1, 2, 2]\\n        for i in range(2, int(0.667*n)+2):\\n            s += [i % 2 + 1] * s[i]\\n        return s[:n].count(1)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3487206,
                "title": "java-two-iterators",
                "content": "Two Iterators , one for reading and one for writing.\\n# Code\\n```\\nclass Solution {\\n    public int magicalString(int n) {\\n        if (n<3) return 1;\\n        boolean []s= new boolean[n+1]; // true - s[i]= 1 , false - s[i] =2\\n        s[0]=true;\\n        int inserIter=0,readIter=0,counter=0;\\n        boolean next= true;  //since first is 1 next char to write is \\'1\\'\\n        while (inserIter<n){\\n            if (next) counter++; //counting 1 time 1 \\n            if (s[readIter++])\\n                s[inserIter++]=next;\\n            else{\\n                s[inserIter++]=next;\\n                if (inserIter==n) break;\\n                s[inserIter++]=next;\\n                if (next) counter++; //counting 2nd time 1 \\n            }\\n            next=!next;\\n        }\\n        return counter ;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int magicalString(int n) {\\n        if (n<3) return 1;\\n        boolean []s= new boolean[n+1]; // true - s[i]= 1 , false - s[i] =2\\n        s[0]=true;\\n        int inserIter=0,readIter=0,counter=0;\\n        boolean next= true;  //since first is 1 next char to write is \\'1\\'\\n        while (inserIter<n){\\n            if (next) counter++; //counting 1 time 1 \\n            if (s[readIter++])\\n                s[inserIter++]=next;\\n            else{\\n                s[inserIter++]=next;\\n                if (inserIter==n) break;\\n                s[inserIter++]=next;\\n                if (next) counter++; //counting 2nd time 1 \\n            }\\n            next=!next;\\n        }\\n        return counter ;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3430394,
                "title": "2-solutions-short-and-without-generating-whole-sequence",
                "content": "```\\nclass Solution {\\npublic:\\n    int magicalString(int n) {\\n        string seq = \"12\";\\n        string groups = \"122\";\\n        while (size(seq) < n) {\\n            int j = size(seq);\\n            copy(cbegin(groups) + j, cend(groups), back_inserter(seq));\\n            for (; j < size(seq); ++j) {\\n                groups += string(seq[j] - \\'0\\', groups.back() == \\'2\\' ? \\'1\\' : \\'2\\');\\n            }\\n        }\\n        return count(cbegin(seq), cbegin(seq) + n, \\'1\\');\\n    }\\n\\n    int magicalString(int n) {\\n        int seqSize = 2;\\n        int oneCount = 1;\\n        string toProcess = \"2\";\\n        while (seqSize < n) {\\n            string seq;\\n            for (const auto ch: toProcess) {\\n                seq += ch;\\n                oneCount += ch == \\'1\\';\\n                if (++seqSize == n) {\\n                    return oneCount;;\\n                }\\n            }\\n            bool isOne = toProcess.back() == \\'2\\';\\n            toProcess = {};\\n            for (const auto ch: seq) {\\n                const char chToAdd = isOne ? \\'1\\' : \\'2\\';\\n                toProcess += chToAdd;\\n                if (ch == \\'2\\') {\\n                    toProcess += chToAdd;\\n                }\\n                isOne = !isOne;\\n            }\\n        }\\n        return oneCount;;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int magicalString(int n) {\\n        string seq = \"12\";\\n        string groups = \"122\";\\n        while (size(seq) < n) {\\n            int j = size(seq);\\n            copy(cbegin(groups) + j, cend(groups), back_inserter(seq));\\n            for (; j < size(seq); ++j) {\\n                groups += string(seq[j] - \\'0\\', groups.back() == \\'2\\' ? \\'1\\' : \\'2\\');\\n            }\\n        }\\n        return count(cbegin(seq), cbegin(seq) + n, \\'1\\');\\n    }\\n\\n    int magicalString(int n) {\\n        int seqSize = 2;\\n        int oneCount = 1;\\n        string toProcess = \"2\";\\n        while (seqSize < n) {\\n            string seq;\\n            for (const auto ch: toProcess) {\\n                seq += ch;\\n                oneCount += ch == \\'1\\';\\n                if (++seqSize == n) {\\n                    return oneCount;;\\n                }\\n            }\\n            bool isOne = toProcess.back() == \\'2\\';\\n            toProcess = {};\\n            for (const auto ch: seq) {\\n                const char chToAdd = isOne ? \\'1\\' : \\'2\\';\\n                toProcess += chToAdd;\\n                if (ch == \\'2\\') {\\n                    toProcess += chToAdd;\\n                }\\n                isOne = !isOne;\\n            }\\n        }\\n        return oneCount;;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3357334,
                "title": "one-simple-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\npublic class Solution {\\n    public int MagicalString(int n) {\\n         if (n <= 3) return 1;\\n                char[] res = new char[n + 1];\\n                res[1] = \\'1\\'; res[2] = \\'2\\'; res[3] = \\'2\\';\\n                int pos = 4, ans = 1, fre = 3;\\n                char charToFill = \\'2\\';\\n                while (pos <= n)\\n                {\\n                    var count = res[fre++] - \\'0\\';\\n                    charToFill = charToFill == \\'1\\' ? \\'2\\' : \\'1\\';\\n                    while (count > 0 && pos <= n)\\n                    {\\n                        res[pos++] = charToFill;\\n                        if (charToFill == \\'1\\') ans++;\\n                        count--;\\n                    }\\n                }\\n                return ans;\\n    }\\n}\\n```",
                "solutionTags": [
                    "C#"
                ],
                "code": "```\\npublic class Solution {\\n    public int MagicalString(int n) {\\n         if (n <= 3) return 1;\\n                char[] res = new char[n + 1];\\n                res[1] = \\'1\\'; res[2] = \\'2\\'; res[3] = \\'2\\';\\n                int pos = 4, ans = 1, fre = 3;\\n                char charToFill = \\'2\\';\\n                while (pos <= n)\\n                {\\n                    var count = res[fre++] - \\'0\\';\\n                    charToFill = charToFill == \\'1\\' ? \\'2\\' : \\'1\\';\\n                    while (count > 0 && pos <= n)\\n                    {\\n                        res[pos++] = charToFill;\\n                        if (charToFill == \\'1\\') ans++;\\n                        count--;\\n                    }\\n                }\\n                return ans;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3348968,
                "title": "two-pointers-c",
                "content": "```\\nclass Solution {\\npublic:\\n    int magicalString(int n) {\\n        string s=\"122\";\\n        int i=2;\\n        while(i<=n && s.size()<= n){\\n            if(s[i]==\\'2\\'){\\n                if(s[s.size()-1]==\\'1\\'){\\n                    s += \"22\";\\n                }\\n                else{\\n                    s += \"11\";\\n                }\\n            }\\n            else{\\n                 if(s[s.size()-1]==\\'1\\'){\\n                    s += \"2\";\\n                }\\n                else{\\n                    s += \"1\";\\n                }\\n            }\\n            i++;\\n        }\\n        int ans=0;\\n        for(int i=0;i<n;i++)\\n            if(s[i]==\\'1\\')\\n                ans++;\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "String"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int magicalString(int n) {\\n        string s=\"122\";\\n        int i=2;\\n        while(i<=n && s.size()<= n){\\n            if(s[i]==\\'2\\'){\\n                if(s[s.size()-1]==\\'1\\'){\\n                    s += \"22\";\\n                }\\n                else{\\n                    s += \"11\";\\n                }\\n            }\\n            else{\\n                 if(s[s.size()-1]==\\'1\\'){\\n                    s += \"2\";\\n                }\\n                else{\\n                    s += \"1\";\\n                }\\n            }\\n            i++;\\n        }\\n        int ans=0;\\n        for(int i=0;i<n;i++)\\n            if(s[i]==\\'1\\')\\n                ans++;\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3300771,
                "title": "easy-to-understand-typescript-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nfunction magicalString(n: number): number {\\n    if (n<=3) return 1;\\n    let arr:number[]=[1,2,2]\\n    let idx = 2;\\n    let ans = 1;\\n    while (idx<n) {\\n        const cur = arr[idx]\\n        const last = arr[arr.length-1]\\n        if (cur===2) {\\n            if (last===2) {\\n                arr.push(...[1,1])\\n            } else {\\n                arr.push(...[2,2])\\n            }\\n        } else {\\n            if (last===2) {\\n                arr.push(1)\\n            } else {\\n                arr.push(2)\\n            }\\n            ans++\\n        }\\n        idx++\\n    }\\n    return ans\\n};\\n```",
                "solutionTags": [
                    "TypeScript"
                ],
                "code": "```\\nfunction magicalString(n: number): number {\\n    if (n<=3) return 1;\\n    let arr:number[]=[1,2,2]\\n    let idx = 2;\\n    let ans = 1;\\n    while (idx<n) {\\n        const cur = arr[idx]\\n        const last = arr[arr.length-1]\\n        if (cur===2) {\\n            if (last===2) {\\n                arr.push(...[1,1])\\n            } else {\\n                arr.push(...[2,2])\\n            }\\n        } else {\\n            if (last===2) {\\n                arr.push(1)\\n            } else {\\n                arr.push(2)\\n            }\\n            ans++\\n        }\\n        idx++\\n    }\\n    return ans\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3249390,
                "title": "python-using-deque-to-simulate-the-string-explained",
                "content": "We can use deque to simulate the process of building the magical string.\\n\\n(1) pop out a number from left end, which is the number of next value in the string;\\n(2) append the number of next value to the right end;\\n(3) if the next value is 1, increase the count for 1.\\n\\nrepeat the above 3 steps until we reach lenght of n.\\n\\n```\\nclass Solution:\\n    def magicalString(self, n: int) -> int:\\n        # we can generate the magical string using deque\\n        if n <= 3:\\n            return 1\\n        \\n        magical_str = collections.deque([\"2\"])\\n        num_1s, cur_n, cur_len = 1, 1, 3\\n        \\n        while cur_len < n:\\n            next_cnt = int(magical_str.popleft())\\n            for i in range(next_cnt):\\n                magical_str.append(str(cur_n))\\n            cur_len += next_cnt\\n            if cur_n == 1:\\n                num_1s += next_cnt\\n                cur_n = 2\\n            else:\\n                cur_n = 1\\n        \\n        if cur_len > n:\\n            if cur_n == 2:\\n                num_1s -= (cur_len - n)\\n        \\n        return num_1s\\n```",
                "solutionTags": [
                    "Python3",
                    "Doubly-Linked List"
                ],
                "code": "```\\nclass Solution:\\n    def magicalString(self, n: int) -> int:\\n        # we can generate the magical string using deque\\n        if n <= 3:\\n            return 1\\n        \\n        magical_str = collections.deque([\"2\"])\\n        num_1s, cur_n, cur_len = 1, 1, 3\\n        \\n        while cur_len < n:\\n            next_cnt = int(magical_str.popleft())\\n            for i in range(next_cnt):\\n                magical_str.append(str(cur_n))\\n            cur_len += next_cnt\\n            if cur_n == 1:\\n                num_1s += next_cnt\\n                cur_n = 2\\n            else:\\n                cur_n = 1\\n        \\n        if cur_len > n:\\n            if cur_n == 2:\\n                num_1s -= (cur_len - n)\\n        \\n        return num_1s\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3242911,
                "title": "go-solution",
                "content": "```\\nfunc magicalString(n int) int {\\n    if n <= 3 { return 1 }\\n    magic, index := make([]int, n), 3\\n    occur, value, count := 2, 1, 1\\n    magic[0], magic[1], magic[2] = 1, 2, 2\\n\\n    for index < n {\\n        for i := 0; i < magic[occur] && index < n; i++ {\\n            magic[index] = value\\n            if value == 1 { count++ }\\n            index++\\n        }\\n        value ^= 3\\n        occur++\\n    }\\n\\n    return count\\n}\\n```",
                "solutionTags": [
                    "Go"
                ],
                "code": "```\\nfunc magicalString(n int) int {\\n    if n <= 3 { return 1 }\\n    magic, index := make([]int, n), 3\\n    occur, value, count := 2, 1, 1\\n    magic[0], magic[1], magic[2] = 1, 2, 2\\n\\n    for index < n {\\n        for i := 0; i < magic[occur] && index < n; i++ {\\n            magic[index] = value\\n            if value == 1 { count++ }\\n            index++\\n        }\\n        value ^= 3\\n        occur++\\n    }\\n\\n    return count\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3224280,
                "title": "java-solution",
                "content": "# Code\\n```\\nclass Solution {\\n    public int magicalString(int n) {\\n        \\n        //to keep track of index\\n        int left = 0;\\n        //to keep track of prev element\\n        int right = 0;\\n        //to keep track of number of \\'1\\'s\\n        int count = 0;\\n\\n        //initiate string as \"1\"\\n        StringBuilder str = new StringBuilder(\"1\");\\n\\n        //keep on generating magical number until left pointer reaches index n-1 (iterate through n elements)\\n        while(left < n-1){\\n            if(str.charAt(left) == \\'1\\'){\\n                //generate 1 new element depending on previous element (right pointer)\\n                if(str.charAt(right) == \\'1\\'){\\n                    str.append(\"2\");\\n                } else{\\n                    str.append(\"1\");\\n                }\\n                //increment count, since left pointer is pointing to \"1\"\\n                count++;\\n                //increment both left and right pointer by 1\\n                left++;\\n                right++;\\n            } else{\\n                //generate two new elements based on previous element (right pointer)\\n                if(str.charAt(right) == \\'1\\'){\\n                    str.append(\"22\");\\n                } else{\\n                    str.append(\"11\");\\n                }\\n                //increment right by 2, left by 1\\n                right += 2;\\n                left++;\\n            }\\n        }\\n\\n        //using Math.max because we\\'ve initiated count to be 0, but if n=1, left already equals to n-1 so count will not be updated, so a default 1 is being used\\n        //any n > 1 will have count > 1\\n        return Math.max(1,count);\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int magicalString(int n) {\\n        \\n        //to keep track of index\\n        int left = 0;\\n        //to keep track of prev element\\n        int right = 0;\\n        //to keep track of number of \\'1\\'s\\n        int count = 0;\\n\\n        //initiate string as \"1\"\\n        StringBuilder str = new StringBuilder(\"1\");\\n\\n        //keep on generating magical number until left pointer reaches index n-1 (iterate through n elements)\\n        while(left < n-1){\\n            if(str.charAt(left) == \\'1\\'){\\n                //generate 1 new element depending on previous element (right pointer)\\n                if(str.charAt(right) == \\'1\\'){\\n                    str.append(\"2\");\\n                } else{\\n                    str.append(\"1\");\\n                }\\n                //increment count, since left pointer is pointing to \"1\"\\n                count++;\\n                //increment both left and right pointer by 1\\n                left++;\\n                right++;\\n            } else{\\n                //generate two new elements based on previous element (right pointer)\\n                if(str.charAt(right) == \\'1\\'){\\n                    str.append(\"22\");\\n                } else{\\n                    str.append(\"11\");\\n                }\\n                //increment right by 2, left by 1\\n                right += 2;\\n                left++;\\n            }\\n        }\\n\\n        //using Math.max because we\\'ve initiated count to be 0, but if n=1, left already equals to n-1 so count will not be updated, so a default 1 is being used\\n        //any n > 1 will have count > 1\\n        return Math.max(1,count);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3182727,
                "title": "c",
                "content": "```\\nint magicalString(int n){\\n    if(n <= 3)\\n        return 1 ;\\n    char* str = malloc(n) ;\\n    str[0] = \\'1\\' ;\\n    str[1] = \\'2\\' ;\\n    str[2] = \\'2\\' ;\\n    int cnIdx = 2 ;\\n    int ones = 1 ;\\n    int idx = 3 ;\\n    char ch = \\'1\\' ;\\n    while(idx < n){\\n        int cn = str[cnIdx] -\\'0\\' ;\\n        for(int i = 0; i < cn; i++){\\n            str[idx] = ch ;\\n            idx++ ;\\n            if(ch ==\\'1\\')\\n                ones++;\\n            if(idx == n)\\n                break ;\\n        }\\n        ch = (ch == \\'1\\') ? \\'2\\' : \\'1\\' ;\\n        cnIdx++ ;\\n    }\\n    free(str) ;\\n    return ones ;\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nint magicalString(int n){\\n    if(n <= 3)\\n        return 1 ;\\n    char* str = malloc(n) ;\\n    str[0] = \\'1\\' ;\\n    str[1] = \\'2\\' ;\\n    str[2] = \\'2\\' ;\\n    int cnIdx = 2 ;\\n    int ones = 1 ;\\n    int idx = 3 ;\\n    char ch = \\'1\\' ;\\n    while(idx < n){\\n        int cn = str[cnIdx] -\\'0\\' ;\\n        for(int i = 0; i < cn; i++){\\n            str[idx] = ch ;\\n            idx++ ;\\n            if(ch ==\\'1\\')\\n                ones++;\\n            if(idx == n)\\n                break ;\\n        }\\n        ch = (ch == \\'1\\') ? \\'2\\' : \\'1\\' ;\\n        cnIdx++ ;\\n    }\\n    free(str) ;\\n    return ones ;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3101135,
                "title": "swift-solution-with-pseudo-code",
                "content": "# Pseudo Code\\n1. Create an array with 1, 2, 2\\n2. Create a variable i and set it to 2\\n3. While the length of the array is less than n\\n4. Create a variable last and set it to the last element of the array\\n5. Create a variable next and set it to 1 if last is 2 and 2 if last is 1\\n6. Create a variable count and set it to the element at index i of the array\\n7. Append an array of count elements of next to the array\\n8. Increment i by 1\\n9. Return the number of 1s in the array from 0 to n\\n10. Return the array\\n\\n# Complexity\\n> Time complexity: O(n)\\n\\n> Space complexity: O(n)\\n\\n# Code\\n```\\nclass Solution {\\n    func magicalString(_ n: Int) -> Int \\n    {\\n        var s = [1,2,2]\\n        var i = 2\\n        while s.count<n\\n        {\\n            let last = s.last!\\n            let next = last == 1 ? 2 : 1\\n            let count = s[i]\\n            s+=Array(repeating: next, count: count)\\n            i+=1\\n        }\\n        return s[0..<n].filter \\n        {\\n            $0==1\\n        }.count\\n    }\\n}\\n```",
                "solutionTags": [
                    "Swift"
                ],
                "code": "```\\nclass Solution {\\n    func magicalString(_ n: Int) -> Int \\n    {\\n        var s = [1,2,2]\\n        var i = 2\\n        while s.count<n\\n        {\\n            let last = s.last!\\n            let next = last == 1 ? 2 : 1\\n            let count = s[i]\\n            s+=Array(repeating: next, count: count)\\n            i+=1\\n        }\\n        return s[0..<n].filter \\n        {\\n            $0==1\\n        }.count\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3089306,
                "title": "c",
                "content": "\\n\\n# Code\\n```\\n\\nint magicalString(int n){\\n    char *arr=calloc(n*4+2,sizeof(char));\\n    *(arr+0)=\\'1\\';\\n    *(arr+1)=*(arr+2)=\\'2\\';\\n    int ans=0;\\n    int t=0;\\n    int idx=2;\\n    int nn=2;\\n   while(n--){\\n       ans+=*(arr+t)==\\'1\\';\\n       t++;\\n        if(*(arr+idx)==\\'2\\')\\n        {\\n        \\n        *(arr+nn+1)=*(arr+nn)==\\'1\\'?\\'2\\':\\'1\\';\\n        \\n        *(arr+nn+2)=*(arr+nn)==\\'1\\'?\\'2\\':\\'1\\';\\n        idx++;\\n        nn+=2;\\n        }\\n        else\\n        {\\n            \\n        *(arr+nn+1)=*(arr+nn)==\\'1\\'?\\'2\\':\\'1\\';\\n        idx++;\\n        nn++;\\n        }\\n        \\n   }\\n    return ans;\\n}\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\n\\nint magicalString(int n){\\n    char *arr=calloc(n*4+2,sizeof(char));\\n    *(arr+0)=\\'1\\';\\n    *(arr+1)=*(arr+2)=\\'2\\';\\n    int ans=0;\\n    int t=0;\\n    int idx=2;\\n    int nn=2;\\n   while(n--){\\n       ans+=*(arr+t)==\\'1\\';\\n       t++;\\n        if(*(arr+idx)==\\'2\\')\\n        {\\n        \\n        *(arr+nn+1)=*(arr+nn)==\\'1\\'?\\'2\\':\\'1\\';\\n        \\n        *(arr+nn+2)=*(arr+nn)==\\'1\\'?\\'2\\':\\'1\\';\\n        idx++;\\n        nn+=2;\\n        }\\n        else\\n        {\\n            \\n        *(arr+nn+1)=*(arr+nn)==\\'1\\'?\\'2\\':\\'1\\';\\n        idx++;\\n        nn++;\\n        }\\n        \\n   }\\n    return ans;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3076953,
                "title": "magical-string-precompute-base-logic-easiest-c-solution-adobe",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n```Precompute Magical String```\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n```\\n1)Approach is to Find Magical String\\n2)Count one in string till n\\n3)While Finding Precompute the Answer of n\\n\\nNOTE : String Finding approach BELOW!!!\\n```\\n# Complexity\\n- Time complexity:```O(N)```\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:```O(N)```\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nint func[100001]={0};//Precomputed array\\n\\n\\n//Counting in Our calculated String\\nint count(string str,int n){\\n    int cnt=0;\\n    if(str.size()<n) n=str.size();\\n    for(int i=0;i<n;i++){\\n        if(str[i]==\\'1\\') cnt++;\\n        func[i+1]=cnt;//Here we precomputing\\n    }\\n    return func[n];\\n}\\n//Approach is to find Given Magical String\\nint  Calculate(int n){\\n    string str=\"122\";\\n    string cnt=\"12\";\\n    bool one=false;//Declaring one bool variable to cheak what is Our next Charactor \\n    int x=2;//if one(true) then there is possibility of \\'1\\' || \\'11\\' Else \\'2\\' || \\'22\\'\\n    for(int i=1;i<=100000;i++){\\n\\n       if(one){//If last char in string is \\'2\\'\\n       if(str[x]==\\'1\\'){cnt+=\\'1\\';str+=\\'2\\';}//CheakingChar we want to add in counterstring\\n       else{cnt+=\\'2\\';str+=\"22\";}//Adding in Magical String\\n       }\\n       else{\\n       if(str[x]==\\'1\\'){cnt+=\"1\";str+=\"1\";}//Same as upper\\n       else{cnt+=\"2\";str+=\"11\";}\\n       }\\n       x++;\\n       if(one) one=false;//Changing parity \\n       else one=true;//If last is one we added two now there is chances of one\\n   }\\n    return count(str,n);//Then we send string and n for calculating count of one\\n}\\nclass Solution {\\npublic:\\n    int magicalString(int n) {\\n      if(func[n]!=0) return func[n];\\n      return Calculate(n);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```Precompute Magical String```\n```\\n1)Approach is to Find Magical String\\n2)Count one in string till n\\n3)While Finding Precompute the Answer of n\\n\\nNOTE : String Finding approach BELOW!!!\\n```\n```O(N)```\n```O(N)```\n```\\nint func[100001]={0};//Precomputed array\\n\\n\\n//Counting in Our calculated String\\nint count(string str,int n){\\n    int cnt=0;\\n    if(str.size()<n) n=str.size();\\n    for(int i=0;i<n;i++){\\n        if(str[i]==\\'1\\') cnt++;\\n        func[i+1]=cnt;//Here we precomputing\\n    }\\n    return func[n];\\n}\\n//Approach is to find Given Magical String\\nint  Calculate(int n){\\n    string str=\"122\";\\n    string cnt=\"12\";\\n    bool one=false;//Declaring one bool variable to cheak what is Our next Charactor \\n    int x=2;//if one(true) then there is possibility of \\'1\\' || \\'11\\' Else \\'2\\' || \\'22\\'\\n    for(int i=1;i<=100000;i++){\\n\\n       if(one){//If last char in string is \\'2\\'\\n       if(str[x]==\\'1\\'){cnt+=\\'1\\';str+=\\'2\\';}//CheakingChar we want to add in counterstring\\n       else{cnt+=\\'2\\';str+=\"22\";}//Adding in Magical String\\n       }\\n       else{\\n       if(str[x]==\\'1\\'){cnt+=\"1\";str+=\"1\";}//Same as upper\\n       else{cnt+=\"2\";str+=\"11\";}\\n       }\\n       x++;\\n       if(one) one=false;//Changing parity \\n       else one=true;//If last is one we added two now there is chances of one\\n   }\\n    return count(str,n);//Then we send string and n for calculating count of one\\n}\\nclass Solution {\\npublic:\\n    int magicalString(int n) {\\n      if(func[n]!=0) return func[n];\\n      return Calculate(n);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3076814,
                "title": "c-solution-with-greater-than-83-in-both-time-and-space-complextiy",
                "content": "# Intuition\\nIf we create a inital string of 1,2,2 then we can solve this problem\\n\\n# Approach\\nWe just have to check for two thing last character in string and the and the required number for the position\\n\\n# Complexity\\n- Time complexity:\\nTime complexity : O(n)\\n\\n- Space complexity:\\nO(n)\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int magicalString(int n) {\\n        \\n        //if the n is less than or equals to 3 than return 1\\n        if(n<=3)\\n        {\\n            return 1;\\n        }\\n       \\n       //create string to store sequence\\n       string s;\\n\\n       // push 1,2,2 in string so that you can find other number with these numbers \\n       s.push_back(\\'1\\');\\n       s.push_back(\\'2\\');\\n       s.push_back(\\'2\\');\\n       int first = 2;\\n        int last = 2;\\n        int count = 1;\\n        n -= 3;\\n        cout<<n;\\n        while(n)\\n        {\\n         if(s[last]==\\'2\\'&&s[first]==\\'2\\')\\n         {\\n            s.push_back(\\'1\\');\\n            s.push_back(\\'1\\');\\n            first++;\\n            last += 2;\\n            count++;\\n            \\n            n--;\\n            if(n==0)\\n            {\\n                break;\\n            }\\n            n--;\\n            count++;\\n         }\\n         else if(s[last]==\\'2\\'&&s[first]==\\'1\\')\\n         {\\n             s.push_back(\\'1\\');\\n             first++;\\n             last++;\\n             count++;\\n             n--;\\n         }\\n         else if(s[last]==\\'1\\'&&s[first]==\\'1\\')\\n         {\\n              s.push_back(\\'2\\');\\n            \\n            first++;\\n            last += 1;\\n            \\n            n--;\\n            \\n         }\\n          else\\n         {\\n             s.push_back(\\'2\\');\\n             s.push_back(\\'2\\');\\n             first++;\\n             last++;\\n             last++;\\n             n--;\\n             if(n==0)\\n             {\\n                 break;\\n             }\\n             n--;\\n         }\\n         \\n        }\\n        return count;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "String"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int magicalString(int n) {\\n        \\n        //if the n is less than or equals to 3 than return 1\\n        if(n<=3)\\n        {\\n            return 1;\\n        }\\n       \\n       //create string to store sequence\\n       string s;\\n\\n       // push 1,2,2 in string so that you can find other number with these numbers \\n       s.push_back(\\'1\\');\\n       s.push_back(\\'2\\');\\n       s.push_back(\\'2\\');\\n       int first = 2;\\n        int last = 2;\\n        int count = 1;\\n        n -= 3;\\n        cout<<n;\\n        while(n)\\n        {\\n         if(s[last]==\\'2\\'&&s[first]==\\'2\\')\\n         {\\n            s.push_back(\\'1\\');\\n            s.push_back(\\'1\\');\\n            first++;\\n            last += 2;\\n            count++;\\n            \\n            n--;\\n            if(n==0)\\n            {\\n                break;\\n            }\\n            n--;\\n            count++;\\n         }\\n         else if(s[last]==\\'2\\'&&s[first]==\\'1\\')\\n         {\\n             s.push_back(\\'1\\');\\n             first++;\\n             last++;\\n             count++;\\n             n--;\\n         }\\n         else if(s[last]==\\'1\\'&&s[first]==\\'1\\')\\n         {\\n              s.push_back(\\'2\\');\\n            \\n            first++;\\n            last += 1;\\n            \\n            n--;\\n            \\n         }\\n          else\\n         {\\n             s.push_back(\\'2\\');\\n             s.push_back(\\'2\\');\\n             first++;\\n             last++;\\n             last++;\\n             n--;\\n             if(n==0)\\n             {\\n                 break;\\n             }\\n             n--;\\n         }\\n         \\n        }\\n        return count;\\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 3073721,
                "title": "2-pointers-easy-peasy",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n$$O(n)$$\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int magicalString(int n) {\\n        int s = 2;\\n        int e = 2;\\n        string str = \"122\";\\n\\n        while(e<n){\\n            int x = int(str[s])-48;\\n            for(int i=0;i<x;i++){\\n                if(str[e]==\\'1\\'){\\n                    str.push_back(\\'2\\');\\n                }else if(str[e]==\\'2\\'){\\n                    str.push_back(\\'1\\');\\n                }\\n            }\\n            e = e + x;\\n            s++;\\n        }\\n        \\n        int count = 0;\\n        for(int i=0;i<n;i++){\\n            if(str[i]==\\'1\\') count++;\\n        }\\n        cout << str << endl;\\n        return count;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int magicalString(int n) {\\n        int s = 2;\\n        int e = 2;\\n        string str = \"122\";\\n\\n        while(e<n){\\n            int x = int(str[s])-48;\\n            for(int i=0;i<x;i++){\\n                if(str[e]==\\'1\\'){\\n                    str.push_back(\\'2\\');\\n                }else if(str[e]==\\'2\\'){\\n                    str.push_back(\\'1\\');\\n                }\\n            }\\n            e = e + x;\\n            s++;\\n        }\\n        \\n        int count = 0;\\n        for(int i=0;i<n;i++){\\n            if(str[i]==\\'1\\') count++;\\n        }\\n        cout << str << endl;\\n        return count;\\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 3068702,
                "title": "java-simple-easy-solution-using-stringbuilder",
                "content": "# Code\\n```\\nclass Solution {\\n    public int magicalString(int n) {\\n        StringBuilder sb = new StringBuilder().append(122);\\n        int count = 0;\\n        for(int i = 2; sb.length() <= n; i++){\\n            int len = sb.length();\\n            sb.append((sb.charAt(i) == \\'1\\') ? (sb.charAt(len - 1) == \\'1\\' ? 2 : 1) : (sb.charAt(len - 1) == \\'1\\' ? 22 : 11));\\n            count += (i < n && sb.charAt(i) == \\'1\\') ? 1 : 0;\\n        }\\n        return count;\\n    }\\n}\\n```\\n## For more readability\\n```\\npublic class Solution {\\n    public int magicalString(int n){\\n    StringBuilder sb = new StringBuilder().append(122);\\n    int i = 2;\\n    int count = 0;\\n    while(sb.length() <= n){\\n        char ch = sb.charAt(i);\\n        int len = sb.length();\\n        if(ch == \\'1\\'){\\n            if(sb.charAt(len - 1) == \\'1\\') sb.append(2);\\n            else sb.append(1);\\n        }\\n        else if(ch == \\'2\\'){\\n            if(sb.charAt(len - 1) == \\'1\\') sb.append(22);\\n            else sb.append(11);\\n        }\\n        i++;\\n    }\\n    for(int j = 0; j < n; j++){\\n        if(sb.charAt(j) == \\'1\\') count++;\\n    }\\n    return count;\\n}\\n}\\n\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int magicalString(int n) {\\n        StringBuilder sb = new StringBuilder().append(122);\\n        int count = 0;\\n        for(int i = 2; sb.length() <= n; i++){\\n            int len = sb.length();\\n            sb.append((sb.charAt(i) == \\'1\\') ? (sb.charAt(len - 1) == \\'1\\' ? 2 : 1) : (sb.charAt(len - 1) == \\'1\\' ? 22 : 11));\\n            count += (i < n && sb.charAt(i) == \\'1\\') ? 1 : 0;\\n        }\\n        return count;\\n    }\\n}\\n```\n```\\npublic class Solution {\\n    public int magicalString(int n){\\n    StringBuilder sb = new StringBuilder().append(122);\\n    int i = 2;\\n    int count = 0;\\n    while(sb.length() <= n){\\n        char ch = sb.charAt(i);\\n        int len = sb.length();\\n        if(ch == \\'1\\'){\\n            if(sb.charAt(len - 1) == \\'1\\') sb.append(2);\\n            else sb.append(1);\\n        }\\n        else if(ch == \\'2\\'){\\n            if(sb.charAt(len - 1) == \\'1\\') sb.append(22);\\n            else sb.append(11);\\n        }\\n        i++;\\n    }\\n    for(int j = 0; j < n; j++){\\n        if(sb.charAt(j) == \\'1\\') count++;\\n    }\\n    return count;\\n}\\n}\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3067459,
                "title": "java-easy-solution",
                "content": "\\n\\n# Code\\n```\\nclass Solution {\\n    public int magicalString(int n) {\\n\\n        String s=\"122\";\\n        int k=2;\\n        while(s.length()<n){\\n\\n            int t=s.charAt(k)-\\'0\\';\\n       \\n            int last=(s.charAt(s.length()-1)-\\'0\\')^3;\\n            while(t-->0){\\n                s+=last;\\n            }\\n            k++;\\n\\n        }\\n        int count=0;\\n        for(int i=0;i<n;i++){\\n            int t=s.charAt(i)-\\'0\\';\\n            if(t==1) count++;\\n        }\\n        return count;\\n    }\\n}\\n\\n\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int magicalString(int n) {\\n\\n        String s=\"122\";\\n        int k=2;\\n        while(s.length()<n){\\n\\n            int t=s.charAt(k)-\\'0\\';\\n       \\n            int last=(s.charAt(s.length()-1)-\\'0\\')^3;\\n            while(t-->0){\\n                s+=last;\\n            }\\n            k++;\\n\\n        }\\n        int count=0;\\n        for(int i=0;i<n;i++){\\n            int t=s.charAt(i)-\\'0\\';\\n            if(t==1) count++;\\n        }\\n        return count;\\n    }\\n}\\n\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3051420,
                "title": "python-o-n-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nMy first thought on how to solve this problem was to create a pattern of numbers based on the given n and then count the number of 1\\'s in that pattern.\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nMy approach to solving this problem is to start with a base pattern of [1, 2, 2] and then iterate through the pattern using a pointer i. On each iteration, I am adding 3-s[-1] number of elements to the pattern. Which means if the last element of the pattern is 1, I am adding 2\\'s and if it\\'s 2 I am adding 1\\'s. And I am doing this s[i] times where s[i] is the value at position i in the pattern. I am doing this until the length of the pattern becomes equal to n. And finally, I am counting the number of 1\\'s in the first n elements of the pattern.\\n\\n# Complexity\\n- Time complexity: O(n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(n)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def magicalString(self, n: int) -> int:\\n        if n == 0: return 0\\n        if n <= 3: return 1\\n        s = [1, 2, 2]\\n        i = 2\\n        while len(s) < n:\\n            s += [3 - s[-1]] * s[i]\\n            i += 1\\n        return s[:n].count(1)\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def magicalString(self, n: int) -> int:\\n        if n == 0: return 0\\n        if n <= 3: return 1\\n        s = [1, 2, 2]\\n        i = 2\\n        while len(s) < n:\\n            s += [3 - s[-1]] * s[i]\\n            i += 1\\n        return s[:n].count(1)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3051255,
                "title": "c-two-pointer-approach",
                "content": "class Solution {\\npublic:\\n    int magicalString(int n) {\\n       \\n        if(n <= 3){\\n            return 1;\\n        }\\n        \\n        \\n        vector<int> v;\\n        v.push_back(1);\\n        v.push_back(2);\\n        v.push_back(2);\\n        \\n        int l = 2;\\n        int r = 2;\\n        \\n        while(v.size() < n){\\n            if(v[r] == 1){\\n                if(v[l] != 1){\\n                    v.push_back(1);\\n                }\\n                if(v[l] != 2){\\n                    v.push_back(2);\\n                }\\n                r++;\\n                l++;\\n            }\\n            if(v[r] == 2){\\n                if(v[l] != 1){\\n                    v.push_back(1);\\n                     v.push_back(1);\\n\\n                }\\n                if(v[l] != 2){\\n                    v.push_back(2);\\n                     v.push_back(2);\\n                }\\n                r++;\\n                l = l+2;\\n            }\\n        }\\n        \\n        \\n        for(int i = 0;i<v.size();i++){\\n            cout<<v[i]<<\" \";\\n        }\\n        \\n        int count = 0;\\n        for(int i = 0;i<n;i++){\\n            if(v[i] == 1){\\n                count++;\\n            }\\n        }\\n        return count;\\n        \\n    }\\n};",
                "solutionTags": [],
                "code": "class Solution {\\npublic:\\n    int magicalString(int n) {\\n       \\n        if(n <= 3){\\n            return 1;\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 3044283,
                "title": "c-easy-solution-detailed-explanation-2-pointer-method",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nTo count number of 1\\'s in magical string in first n latters : \\n1) making the magical string of lenght n . \\n2) traversing first n latters . \\n\\nbase case : \\n122 -> minimum magical string \\nmerged string -> 12 \\nnext chactor formed is 2 ( reference from magical string )\\n\\nto form 2 : we can add either 1 1  or 2 2  or 2 or 1 .\\nchose must 11 in magical string becuase last char magical string is \\'2\\' ( to avoid frequncy greater than 2 ) .\\n\\nIn general : \\n2 pointer maintain \\np1 -> index of next charctor to form in merged string .  \\np2 -> last char of magical string . \\n\\nwe take s[p2] oppesite latter and add latter s[p1] times to \\nmove to next p2 \\n\\n# Complexity\\n- Time complexity: O(N)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Plz , Upvote if this post helpful to you. \\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int magicalString(int n) {\\n\\n      if( n <= 3 ) return 1 ; \\n      \\n      string s = \"122\";\\n      int p1 = 2 , p2 =2 ; // p1 -> points to next latter to form   p2-> last digit of string \\n      int cnt = 1 ; \\n      while( s.size() <= n )\\n      {\\n          int t = s[p1]-\\'0\\';\\n          char c = (s[p2]==\\'1\\'  ? \\'2\\' : \\'1\\'); \\n          while(t--)\\n          {   \\n              s.push_back(c);\\n              ++p2;\\n          }\\n          ++p1;\\n      }\\n      cnt = 0 ; \\n      for( int i = 0 ; i < n ; ++i )\\n      {\\n          if( s[i] == \\'1\\') ++cnt;\\n      }\\n\\n      return cnt;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Two Pointers",
                    "String"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int magicalString(int n) {\\n\\n      if( n <= 3 ) return 1 ; \\n      \\n      string s = \"122\";\\n      int p1 = 2 , p2 =2 ; // p1 -> points to next latter to form   p2-> last digit of string \\n      int cnt = 1 ; \\n      while( s.size() <= n )\\n      {\\n          int t = s[p1]-\\'0\\';\\n          char c = (s[p2]==\\'1\\'  ? \\'2\\' : \\'1\\'); \\n          while(t--)\\n          {   \\n              s.push_back(c);\\n              ++p2;\\n          }\\n          ++p1;\\n      }\\n      cnt = 0 ; \\n      for( int i = 0 ; i < n ; ++i )\\n      {\\n          if( s[i] == \\'1\\') ++cnt;\\n      }\\n\\n      return cnt;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3044282,
                "title": "c-easy-solution-detailed-explanation-2-pointer-method",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nTo count number of 1\\'s in magical string in first n latters : \\n1) making the magical string of lenght n . \\n2) traversing first n latters . \\n\\nbase case : \\n122 -> minimum magical string \\nmerged string -> 12 \\nnext chactor formed is 2 ( reference from magical string )\\n\\nto form 2 : we can add either 1 1  or 2 2  or 2 or 1 .\\nchose must 11 in magical string becuase last char magical string is \\'2\\' ( to avoid frequncy greater than 2 ) .\\n\\nIn general : \\n2 pointer maintain \\np1 -> index of next charctor to form in merged string .  \\np2 -> last char of magical string . \\n\\nwe take s[p2] oppesite latter and add latter s[p1] times to \\nmove to next p2 \\n\\n# Complexity\\n- Time complexity: O(N)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Plz , Upvote if this post helpful to you. \\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int magicalString(int n) {\\n\\n      if( n <= 3 ) return 1 ; \\n      \\n      string s = \"122\";\\n      int p1 = 2 , p2 =2 ; // p1 -> points to next latter to form   p2-> last digit of string \\n      int cnt = 1 ; \\n      while( s.size() <= n )\\n      {\\n          int t = s[p1]-\\'0\\';\\n          char c = (s[p2]==\\'1\\'  ? \\'2\\' : \\'1\\'); \\n          while(t--)\\n          {   \\n              s.push_back(c);\\n              ++p2;\\n          }\\n          ++p1;\\n      }\\n      cnt = 0 ; \\n      for( int i = 0 ; i < n ; ++i )\\n      {\\n          if( s[i] == \\'1\\') ++cnt;\\n      }\\n\\n      return cnt;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Two Pointers",
                    "String"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int magicalString(int n) {\\n\\n      if( n <= 3 ) return 1 ; \\n      \\n      string s = \"122\";\\n      int p1 = 2 , p2 =2 ; // p1 -> points to next latter to form   p2-> last digit of string \\n      int cnt = 1 ; \\n      while( s.size() <= n )\\n      {\\n          int t = s[p1]-\\'0\\';\\n          char c = (s[p2]==\\'1\\'  ? \\'2\\' : \\'1\\'); \\n          while(t--)\\n          {   \\n              s.push_back(c);\\n              ++p2;\\n          }\\n          ++p1;\\n      }\\n      cnt = 0 ; \\n      for( int i = 0 ; i < n ; ++i )\\n      {\\n          if( s[i] == \\'1\\') ++cnt;\\n      }\\n\\n      return cnt;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3042408,
                "title": "c-best-explanation-easy-to-understand-pattern-two-pointer",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n#### Two Pointer\\n##### Let\\'s Check Pattern Of Given String\\n\\n##### 1221121221221121122....\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n##### Firstly take string $$s$$ = $$\"122\"$$\\n\\n##### Take two pointers => $$start$$ & $$end $$ both points to the last index of the string $$s$$.\\n\\n#### Only handle two case..\\n\\n## case 1 : \\n- ##### if $$ start $$ pointer points to $$\\'1\\'$$ & $$end$$ pointer points to $$\\'2\\'$$ then we concatenate $$\\'1\\'$$ to the string $$ s $$ otherwise concatenate $$\\'2\\'$$.\\n\\n## case 2 : \\n\\n- ##### if $$end$$ pointer points to $$\\'2\\'$$ then concatenate $$\"11\"$$ to the string $$s $$ otherwise concatenate $$\"22\"$$.\\n\\n# Complexity\\n- #### Time complexity: $$O(n)$$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n\\n\\n- #### Space complexity: $$ O(1) $$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n### \\uD83D\\uDE4F Don\\'t forget to Upvote \\u2B06\\uFE0F\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int magicalString(int n) {\\n        \\n        string s = \"122\";\\n\\n        // take two pointer place at last index of s\\n        int start = s.size()-1;\\n        int end = s.size()-1;\\n\\n        while(s.size() < n){\\n\\n            if(s[start] == \\'1\\'){\\n                \\n                if(s[end] == \\'2\\'){\\n                    s += \\'1\\';\\n                }\\n                else{\\n                    s += \\'2\\';\\n                }\\n            }\\n            else{\\n\\n                if(s[end] == \\'2\\'){\\n                    s += \"11\";\\n                }\\n                else{\\n                    s += \"22\";\\n                }\\n            }\\n\\n            start++;\\n            end = s.size()-1;\\n        }\\n\\n        int cnt = 0;\\n        for(int i=0;i<n;i++){\\n            if(s[i] == \\'1\\')\\n                cnt++;\\n        }\\n        \\n        return cnt;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Two Pointers"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int magicalString(int n) {\\n        \\n        string s = \"122\";\\n\\n        // take two pointer place at last index of s\\n        int start = s.size()-1;\\n        int end = s.size()-1;\\n\\n        while(s.size() < n){\\n\\n            if(s[start] == \\'1\\'){\\n                \\n                if(s[end] == \\'2\\'){\\n                    s += \\'1\\';\\n                }\\n                else{\\n                    s += \\'2\\';\\n                }\\n            }\\n            else{\\n\\n                if(s[end] == \\'2\\'){\\n                    s += \"11\";\\n                }\\n                else{\\n                    s += \"22\";\\n                }\\n            }\\n\\n            start++;\\n            end = s.size()-1;\\n        }\\n\\n        int cnt = 0;\\n        for(int i=0;i<n;i++){\\n            if(s[i] == \\'1\\')\\n                cnt++;\\n        }\\n        \\n        return cnt;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3041216,
                "title": "easy-and-and-simple",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nhttps://en.wikipedia.org/wiki/Kolakoski_sequence\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\nint magicalString(int n) {\\n\\n    string s=\"122\";\\n    int c=2;int m=1;\\n    if (n<=3)return 1;\\n    int count=0;\\n    while(c<n && s.size()<n)\\n    {\\n        int ac=s[c]-\\'0\\';\\n        //if(ac==1)count++;\\n        if (m==1)\\n        {\\n            if(ac==2)\\n            s+=\"11\";\\n            else\\n            s+=\\'1\\';\\n\\n        }\\n        else\\n        {\\n            if(ac==2)\\n            s+=\"22\";\\n            else\\n            s+=\\'2\\';\\n        }\\n        c++;\\n        m=(m==2)?1:2;\\n    }\\n    for(int i=0;i<n;i++)\\n    {\\n        if(s[i]==\\'1\\')count++;\\n    }\\n    return count;\\n}\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\nint magicalString(int n) {\\n\\n    string s=\"122\";\\n    int c=2;int m=1;\\n    if (n<=3)return 1;\\n    int count=0;\\n    while(c<n && s.size()<n)\\n    {\\n        int ac=s[c]-\\'0\\';\\n        //if(ac==1)count++;\\n        if (m==1)\\n        {\\n            if(ac==2)\\n            s+=\"11\";\\n            else\\n            s+=\\'1\\';\\n\\n        }\\n        else\\n        {\\n            if(ac==2)\\n            s+=\"22\";\\n            else\\n            s+=\\'2\\';\\n        }\\n        c++;\\n        m=(m==2)?1:2;\\n    }\\n    for(int i=0;i<n;i++)\\n    {\\n        if(s[i]==\\'1\\')count++;\\n    }\\n    return count;\\n}\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3040289,
                "title": "best-explaination-c-comments",
                "content": "The intuition behind this code is to generate the magical string s that consists of only 1\\'s and 2\\'s and obeys the following rules:\\n\\nThe string s is magical because concatenating the number of contiguous occurrences of characters \\'1\\' and \\'2\\' generates the string s itself.\\nThe first few elements of s is s = \"1221121221221121122\\u2026\\u2026\"\\nGiven an integer n, return the number of 1\\'s in the first n number in the magical string s.\\nThe code uses two pointers \\'i\\' and \\'j\\' to keep track of the current and last index of the magical string and generate the string in a more efficient way.\\n\\nIt starts with a string \"122\" and then, in each iteration of the while loop, it checks the value of s[i] and s[j] and based on the value at these indices it generates the magical string.\\n\\nIf s[i] is 1, it checks whether the last element of the string s is 1 or 2 and adds the corresponding element at the end of the string. If the last element is 1, it adds 2 and if the last element is 2, it adds 1.\\n\\nIf s[i] is 2, it checks whether the last element of the string s is 1 or 2 and adds the corresponding element twice at the end of the string. If the last element is 1, it adds 22 and if the last element is 2, it adds 11.\\n\\nIt also keeps track of the number of 1\\'s in the generated string by iterating over the first n elements of the string and counting the number of 1\\'s.\\n\\nIn this way, it generates the magical string of the first n elements and count the number of 1\\'s in the first n elements of the magical string in an efficient way, with time complexity O(n)\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int magicalString(int n) {\\n    \\n    // if n is less than or equal to 3 then cnt of one is 1 \\n    if(n<=3){\\n        return 1;\\n    }\\n    \\n    // take a initial string \"122\"\\n    \\n    string s = \"122\";\\n    \\n    int i=2;    // \\'i\\' point the curr index and according to that index we add on back of the string \\n    int j=2;    // \\'j\\' point the last index of a string if at last index \\'1\\' occur then we can only add \\'2\\' else if at last index \\'2\\' present then we can add \\'1\\'\\n    int cnt = 0;\\n    \\n    while(j<n){\\n        if(s[i]==\\'1\\'){\\n            if(s[j]==\\'1\\'){\\n                s+=\"2\";\\n            }\\n            else{\\n                s+=\"1\";\\n            }\\n            j++;\\n        }\\n        else{\\n            if(s[j]==\\'1\\'){\\n                s+=\"22\";\\n            }\\n            else{\\n                s+=\"11\";\\n            }\\n            j+=2;\\n        }\\n        i++;\\n    }\\n    // count the occurrrence of an one in string s\\n    for(int i=0;i<n;i++){\\n        if(s[i]==\\'1\\'){\\n            cnt++;\\n        }\\n    }\\n   \\n    return cnt;\\n}\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int magicalString(int n) {\\n    \\n    // if n is less than or equal to 3 then cnt of one is 1 \\n    if(n<=3){\\n        return 1;\\n    }\\n    \\n    // take a initial string \"122\"\\n    \\n    string s = \"122\";\\n    \\n    int i=2;    // \\'i\\' point the curr index and according to that index we add on back of the string \\n    int j=2;    // \\'j\\' point the last index of a string if at last index \\'1\\' occur then we can only add \\'2\\' else if at last index \\'2\\' present then we can add \\'1\\'\\n    int cnt = 0;\\n    \\n    while(j<n){\\n        if(s[i]==\\'1\\'){\\n            if(s[j]==\\'1\\'){\\n                s+=\"2\";\\n            }\\n            else{\\n                s+=\"1\";\\n            }\\n            j++;\\n        }\\n        else{\\n            if(s[j]==\\'1\\'){\\n                s+=\"22\";\\n            }\\n            else{\\n                s+=\"11\";\\n            }\\n            j+=2;\\n        }\\n        i++;\\n    }\\n    // count the occurrrence of an one in string s\\n    for(int i=0;i<n;i++){\\n        if(s[i]==\\'1\\'){\\n            cnt++;\\n        }\\n    }\\n   \\n    return cnt;\\n}\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3034137,
                "title": "easy-java-approach",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach :  Two pointer Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity: O(n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: o(n)\\n<!-- O(n) -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int magicalString(int n) {\\n        String str = \"122\";\\n        if(n<=3) return 1;\\n        int count = 1; int prev=2;\\n        int left=2;\\n        int right=3;\\n        while(right<n){\\n            int times=Character.getNumericValue(str.charAt(left));\\n            int app = (prev==1)?2:1;\\n            right+=times;\\n            if(right==(n+1) && app==1){\\n                count++;\\n                return count;\\n            }\\n            if(app==1) count+=times;\\n\\n            for(int i=1; i<=times; i++){\\n                str+=app;\\n            }\\n            left++;\\n            prev=app;\\n        }        \\n        return count;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int magicalString(int n) {\\n        String str = \"122\";\\n        if(n<=3) return 1;\\n        int count = 1; int prev=2;\\n        int left=2;\\n        int right=3;\\n        while(right<n){\\n            int times=Character.getNumericValue(str.charAt(left));\\n            int app = (prev==1)?2:1;\\n            right+=times;\\n            if(right==(n+1) && app==1){\\n                count++;\\n                return count;\\n            }\\n            if(app==1) count+=times;\\n\\n            for(int i=1; i<=times; i++){\\n                str+=app;\\n            }\\n            left++;\\n            prev=app;\\n        }        \\n        return count;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2938837,
                "title": "cpp-easy-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int magicalString(int n) {\\n        if(n <= 3) return 1;\\n        string s = \"122\";\\n        int cnt = 1;\\n        int i = 2;\\n        int next_to_add = 1;\\n        while(s.size() < n){\\n            if(s[i] == \\'2\\'){\\n                if(next_to_add == 1) s += \"11\" , cnt += 2;\\n                else s += \"22\";              \\n            }\\n            else{\\n                if(next_to_add == 1) s += \"1\" , cnt += 1;\\n                else s += \"2\";\\n            }\\n            if(next_to_add == 1) next_to_add = 2;\\n            else next_to_add = 1;\\n            i++;\\n        }\\n        int diff = s.size() - n;\\n        i = s.size() - 1;\\n        while(i >= 0 && diff > 0){\\n            if(s[i--] == \\'1\\') cnt--;\\n            diff--;\\n        }\\n        return cnt;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int magicalString(int n) {\\n        if(n <= 3) return 1;\\n        string s = \"122\";\\n        int cnt = 1;\\n        int i = 2;\\n        int next_to_add = 1;\\n        while(s.size() < n){\\n            if(s[i] == \\'2\\'){\\n                if(next_to_add == 1) s += \"11\" , cnt += 2;\\n                else s += \"22\";              \\n            }\\n            else{\\n                if(next_to_add == 1) s += \"1\" , cnt += 1;\\n                else s += \"2\";\\n            }\\n            if(next_to_add == 1) next_to_add = 2;\\n            else next_to_add = 1;\\n            i++;\\n        }\\n        int diff = s.size() - n;\\n        i = s.size() - 1;\\n        while(i >= 0 && diff > 0){\\n            if(s[i--] == \\'1\\') cnt--;\\n            diff--;\\n        }\\n        return cnt;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2863470,
                "title": "python-easy-sol-n-straight-forward-and-funny",
                "content": "\\n```\\nclass Solution:\\n    def magicalString(self, n: int) -> int:\\n        s, i = \\'122\\', 2\\n        while len(s)<n:\\n            if s[i]==\\'2\\':\\n                s+=(2*\\'1\\') if s[-1]==\\'2\\' else (2*\\'2\\')\\n            else:s+=\\'1\\' if s[-1]==\\'2\\' else \\'2\\'\\n            i+=1\\n        res = 0\\n        print(s)\\n        for i in range(n):res+=int(s[i]==\\'1\\')\\n        return res\\n\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def magicalString(self, n: int) -> int:\\n        s, i = \\'122\\', 2\\n        while len(s)<n:\\n            if s[i]==\\'2\\':\\n                s+=(2*\\'1\\') if s[-1]==\\'2\\' else (2*\\'2\\')\\n            else:s+=\\'1\\' if s[-1]==\\'2\\' else \\'2\\'\\n            i+=1\\n        res = 0\\n        print(s)\\n        for i in range(n):res+=int(s[i]==\\'1\\')\\n        return res\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2861524,
                "title": "just-a-runnable-solution",
                "content": "# Code\\n```\\nimpl Solution {\\n    pub fn magical_string(n: i32) -> i32 {\\n        let mut ms = vec![1, 2, 2];\\n        let mut index = 2;\\n        let mut first = true;\\n        let mut one = 1;\\n        while ms.len() < n as usize {\\n            if ms[index] == 1 {\\n                ms.push(3 - ms[ms.len() - 1]);\\n                first = true;\\n                index += 1;\\n            } else {\\n                if first {\\n                    ms.push(3 - ms[ms.len() - 1]);\\n                } else {\\n                    ms.push(ms[ms.len() - 1]);\\n                    index += 1;\\n                }\\n                first = !first;\\n            }\\n            if ms[ms.len() - 1] == 1 {\\n                one += 1;\\n            }\\n        }\\n        one\\n    }\\n}\\n```",
                "solutionTags": [
                    "Rust"
                ],
                "code": "```\\nimpl Solution {\\n    pub fn magical_string(n: i32) -> i32 {\\n        let mut ms = vec![1, 2, 2];\\n        let mut index = 2;\\n        let mut first = true;\\n        let mut one = 1;\\n        while ms.len() < n as usize {\\n            if ms[index] == 1 {\\n                ms.push(3 - ms[ms.len() - 1]);\\n                first = true;\\n                index += 1;\\n            } else {\\n                if first {\\n                    ms.push(3 - ms[ms.len() - 1]);\\n                } else {\\n                    ms.push(ms[ms.len() - 1]);\\n                    index += 1;\\n                }\\n                first = !first;\\n            }\\n            if ms[ms.len() - 1] == 1 {\\n                one += 1;\\n            }\\n        }\\n        one\\n    }\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2825017,
                "title": "c-two-pointers",
                "content": "```\\nclass Solution {\\npublic:\\n    int magicalString(int n) {\\n        \\n        if(n<=3) return 1;\\n        string magic = \"122\";\\n        int p1 = 2, p2 = 2; //p1 for the next char and p2 for the count of the next char\\n        while(p1 < n){\\n            int count = (magic[p2]-\\'0\\');\\n            char c = magic[p1] == \\'1\\'? \\'2\\':\\'1\\';\\n            while(count){\\n                magic += c;\\n                    --count;\\n            }\\n            p1 += (magic[p2]-\\'0\\');\\n            ++p2;\\n        }\\n        return count(magic.begin(), magic.begin()+n, \\'1\\');\\n    }\\n};\\n```",
                "solutionTags": [
                    "Two Pointers"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int magicalString(int n) {\\n        \\n        if(n<=3) return 1;\\n        string magic = \"122\";\\n        int p1 = 2, p2 = 2; //p1 for the next char and p2 for the count of the next char\\n        while(p1 < n){\\n            int count = (magic[p2]-\\'0\\');\\n            char c = magic[p1] == \\'1\\'? \\'2\\':\\'1\\';\\n            while(count){\\n                magic += c;\\n                    --count;\\n            }\\n            p1 += (magic[p2]-\\'0\\');\\n            ++p2;\\n        }\\n        return count(magic.begin(), magic.begin()+n, \\'1\\');\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2803189,
                "title": "two-pointer-approach-java-simple-solution",
                "content": "```java\\npublic int magicalString(int n) {\\n        List<Integer> ls = new ArrayList<>();\\n        ls.add(1);\\n        ls.add(2);\\n        ls.add(2);\\n        int l = 2;\\n        int k = 3;\\n        int cnt = 1;\\n        for(;k < n;){\\n            if(ls.get(l) == 2){\\n                if(ls.get(k - 1) == 2){\\n                    ls.add(1);\\n                    k++;\\n                    cnt++;\\n                    if(k < n){\\n                        ls.add(1);\\n                        k++;\\n                        cnt++;\\n                    }\\n                }\\n                else{\\n                    ls.add(2);\\n                    ls.add(2);\\n                    k += 2;\\n                }\\n            }\\n            else{\\n                if(ls.get(k - 1) == 2){\\n                    ls.add(1);\\n                    k++;\\n                    cnt++;\\n                }\\n                else{\\n                    ls.add(2);\\n                    k++;\\n                }\\n            }\\n            l++;\\n        }\\n        return cnt; \\n    }\\n```",
                "solutionTags": [
                    "Java",
                    "Two Pointers"
                ],
                "code": "```java\\npublic int magicalString(int n) {\\n        List<Integer> ls = new ArrayList<>();\\n        ls.add(1);\\n        ls.add(2);\\n        ls.add(2);\\n        int l = 2;\\n        int k = 3;\\n        int cnt = 1;\\n        for(;k < n;){\\n            if(ls.get(l) == 2){\\n                if(ls.get(k - 1) == 2){\\n                    ls.add(1);\\n                    k++;\\n                    cnt++;\\n                    if(k < n){\\n                        ls.add(1);\\n                        k++;\\n                        cnt++;\\n                    }\\n                }\\n                else{\\n                    ls.add(2);\\n                    ls.add(2);\\n                    k += 2;\\n                }\\n            }\\n            else{\\n                if(ls.get(k - 1) == 2){\\n                    ls.add(1);\\n                    k++;\\n                    cnt++;\\n                }\\n                else{\\n                    ls.add(2);\\n                    k++;\\n                }\\n            }\\n            l++;\\n        }\\n        return cnt; \\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2713709,
                "title": "python-solution",
                "content": "\\'\\'\\'\\nclass Solution(object):\\n \\xA0  def magicalString(self, n):\\n \\xA0 \\xA0 \\xA0   arr = [1, 2, 2]\\n        \\n        for i in range(2, n):\\n            if arr[-1] == 1:\\n                nextNum = 2\\n            else:\\n                nextNum = 1\\n            arr.extend([nextNum] * arr[i]) \\n           \\n        res = 0\\n        for i in range(n):\\n            if arr[i] == 1:\\n                res += 1\\n \\xA0 \\xA0 \\xA0  return res\\n\\'\\'\\'",
                "solutionTags": [],
                "code": "\\'\\'\\'\\nclass Solution(object):\\n \\xA0  def magicalString(self, n):\\n \\xA0 \\xA0 \\xA0   arr = [1, 2, 2]\\n        \\n        for i in range(2, n):\\n            if arr[-1] == 1:\\n                nextNum = 2\\n            else:\\n                nextNum = 1\\n            arr.extend([nextNum] * arr[i]) \\n           \\n        res = 0\\n        for i in range(n):\\n            if arr[i] == 1:\\n                res += 1\\n \\xA0 \\xA0 \\xA0  return res\\n\\'\\'\\'",
                "codeTag": "Java"
            },
            {
                "id": 2709732,
                "title": "cpp-solution-with-easy-approach",
                "content": "\\n\\n\\n\\n# Complexity\\n- Time complexity: O(n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int magicalString(int n) {\\n        string st = \"122\";\\n        int ptr = 2;\\n        int lastdigit = \\'2\\';\\n        int dropdigit;\\n        int i = 3;\\n        while(i<n)\\n        {\\n          dropdigit = (lastdigit == \\'2\\')?\\'1\\':\\'2\\';\\nfor(int j = 0; j<st[ptr] - \\'0\\'; j++)\\n{\\n  st.push_back(dropdigit);\\n  i++;\\n}\\nptr++;\\nlastdigit = dropdigit;\\n\\n        }\\n        int ans = 0;\\n        for( i =0; i<n ; i++)\\n        {\\n          if(st[i] == \\'1\\')\\nans++;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int magicalString(int n) {\\n        string st = \"122\";\\n        int ptr = 2;\\n        int lastdigit = \\'2\\';\\n        int dropdigit;\\n        int i = 3;\\n        while(i<n)\\n        {\\n          dropdigit = (lastdigit == \\'2\\')?\\'1\\':\\'2\\';\\nfor(int j = 0; j<st[ptr] - \\'0\\'; j++)\\n{\\n  st.push_back(dropdigit);\\n  i++;\\n}\\nptr++;\\nlastdigit = dropdigit;\\n\\n        }\\n        int ans = 0;\\n        for( i =0; i<n ; i++)\\n        {\\n          if(st[i] == \\'1\\')\\nans++;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2677277,
                "title": "classical-java-solution-with-clean-implementation",
                "content": "```\\n    class Solution {\\n        public int magicalString(int n) {\\n            int cnt = 0;\\n            StringBuilder sb = new StringBuilder();\\n            sb.append(\\'1\\');\\n\\n            int li = 0;\\n\\n            while (true) {\\n                if (sb.length() >= n) break;\\n                if (sb.charAt(li) == \\'1\\' && sb.length() == 1) {\\n                    sb.append(\"22\");\\n                    li += 2;\\n                } else if (sb.charAt(li) == \\'2\\') {\\n                    if (sb.charAt(sb.length() - 1) == \\'1\\') sb.append(\"22\");\\n                    else sb.append(\"11\");\\n                    li++;\\n                } else if (sb.charAt(li) == \\'1\\') {\\n                    if (sb.charAt(sb.length() - 1) == \\'2\\') sb.append(\"1\");\\n                    else sb.append(\"2\");\\n                    li++;\\n                }\\n            }\\n\\n\\n            int ind = 0;\\n            while (ind < n) if (sb.charAt(ind++) == \\'1\\') cnt++;\\n\\n            return cnt;\\n        }\\n    }\\n```",
                "solutionTags": [],
                "code": "```\\n    class Solution {\\n        public int magicalString(int n) {\\n            int cnt = 0;\\n            StringBuilder sb = new StringBuilder();\\n            sb.append(\\'1\\');\\n\\n            int li = 0;\\n\\n            while (true) {\\n                if (sb.length() >= n) break;\\n                if (sb.charAt(li) == \\'1\\' && sb.length() == 1) {\\n                    sb.append(\"22\");\\n                    li += 2;\\n                } else if (sb.charAt(li) == \\'2\\') {\\n                    if (sb.charAt(sb.length() - 1) == \\'1\\') sb.append(\"22\");\\n                    else sb.append(\"11\");\\n                    li++;\\n                } else if (sb.charAt(li) == \\'1\\') {\\n                    if (sb.charAt(sb.length() - 1) == \\'2\\') sb.append(\"1\");\\n                    else sb.append(\"2\");\\n                    li++;\\n                }\\n            }\\n\\n\\n            int ind = 0;\\n            while (ind < n) if (sb.charAt(ind++) == \\'1\\') cnt++;\\n\\n            return cnt;\\n        }\\n    }\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2648088,
                "title": "c-code",
                "content": "```\\nclass Solution {\\npublic:\\n    int magicalString(int n) {\\n    string S = \"122\";\\n    int i = 2;\\n    while (S.size() < n)\\n        S += string(S[i++] - \\'0\\', S.back() ^ 3);\\n    return count(S.begin(), S.begin() + n, \\'1\\');\\n}\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int magicalString(int n) {\\n    string S = \"122\";\\n    int i = 2;\\n    while (S.size() < n)\\n        S += string(S[i++] - \\'0\\', S.back() ^ 3);\\n    return count(S.begin(), S.begin() + n, \\'1\\');\\n}\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2549972,
                "title": "c-sequence-generating",
                "content": "```\\npublic class Solution {\\n    \\n  private static IEnumerable<int> Generator() {\\n    List<int> result = new List<int>() { 1, 2, 2 };\\n      \\n    foreach (int item in result)\\n        yield return item;\\n      \\n    for (int i = 2, j = 2; ; ++i, ++j) {\\n        int count = result.Count;\\n        \\n        if (result[i] == 1) \\n            result.Add(3 - result[j]);\\n        else {\\n            result.Add(3 - result[j]);\\n            result.Add(3 - result[j++]);\\n        }\\n        \\n        for (int c = count; c < result.Count; ++c)\\n            yield return result[c];\\n      }\\n    }\\n    \\n    public int MagicalString(int n) => Generator().Take(n).Count(x => x == 1);  \\n    \\n}\\n```",
                "solutionTags": [],
                "code": "```\\npublic class Solution {\\n    \\n  private static IEnumerable<int> Generator() {\\n    List<int> result = new List<int>() { 1, 2, 2 };\\n      \\n    foreach (int item in result)\\n        yield return item;\\n      \\n    for (int i = 2, j = 2; ; ++i, ++j) {\\n        int count = result.Count;\\n        \\n        if (result[i] == 1) \\n            result.Add(3 - result[j]);\\n        else {\\n            result.Add(3 - result[j]);\\n            result.Add(3 - result[j++]);\\n        }\\n        \\n        for (int c = count; c < result.Count; ++c)\\n            yield return result[c];\\n      }\\n    }\\n    \\n    public int MagicalString(int n) => Generator().Take(n).Count(x => x == 1);  \\n    \\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2483858,
                "title": "python-easy-and-concise-o-n",
                "content": "```\\nclass Solution:\\n    def magicalString(self, n: int) -> int:\\n        seq = [1,2]\\n        left, right = 1, 1\\n        while right < n:\\n            if seq[left] == 2:\\n                seq.append(seq[-1])\\n                right += 1\\n            seq.append(-seq[-1]+3)\\n            left += 1\\n            right += 1\\n        return seq[:n].count(1)",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nclass Solution:\\n    def magicalString(self, n: int) -> int:\\n        seq = [1,2]\\n        left, right = 1, 1\\n        while right < n:\\n            if seq[left] == 2:\\n                seq.append(seq[-1])\\n                right += 1\\n            seq.append(-seq[-1]+3)\\n            left += 1\\n            right += 1\\n        return seq[:n].count(1)",
                "codeTag": "Java"
            },
            {
                "id": 2445639,
                "title": "481-python",
                "content": "\\tclass Solution:\\n\\t\\tdef magicalString(self, n: int) -> int:\\n\\t\\t\\ts= \"122\"\\n\\n\\t\\t\\tfor i in range(2,n):\\n\\t\\t\\t\\tif s[-1] == \\'2\\':\\n\\t\\t\\t\\t\\ts += \"1\"* int(s[i])\\n\\t\\t\\t\\telse:\\n\\t\\t\\t\\t\\ts += \"2\" * int(s[i])\\n\\n\\t\\t\\treturn s[:n].count(\"1\")",
                "solutionTags": [
                    "Python"
                ],
                "code": "\\tclass Solution:\\n\\t\\tdef magicalString(self, n: int) -> int:\\n\\t\\t\\ts= \"122\"\\n\\n\\t\\t\\tfor i in range(2,n):\\n\\t\\t\\t\\tif s[-1] == \\'2\\':\\n\\t\\t\\t\\t\\ts += \"1\"* int(s[i])\\n\\t\\t\\t\\telse:\\n\\t\\t\\t\\t\\ts += \"2\" * int(s[i])\\n\\n\\t\\t\\treturn s[:n].count(\"1\")",
                "codeTag": "Java"
            },
            {
                "id": 2378944,
                "title": "python-solution",
                "content": "```\\nclass Solution:\\n    def magicalString(self, n: int) -> int:\\n        if n <= 3:\\n            return 1\\n        \\n        group_ptr = \\'122\\'\\n        base_ptr = \\'1\\'\\n        \\n        base_ptr_idx = 2\\n        count = 1\\n        \\n        while len(group_ptr) < n:\\n            base_ptr += str(group_ptr[base_ptr_idx])\\n            base_ptr_idx += 1\\n            added_twice = False\\n            \\n            next_char = \\'1\\' if group_ptr[-1] == \\'2\\' else \\'2\\'\\n            if base_ptr[-1] == \\'1\\':\\n                group_ptr += next_char\\n            else:\\n                group_ptr += next_char * 2\\n                added_twice = True\\n            \\n            if next_char == \\'1\\':\\n                count += 2 if added_twice else 1\\n                if len(group_ptr) > n:\\n                    count -= 1\\n        return count",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def magicalString(self, n: int) -> int:\\n        if n <= 3:\\n            return 1\\n        \\n        group_ptr = \\'122\\'\\n        base_ptr = \\'1\\'\\n        \\n        base_ptr_idx = 2\\n        count = 1\\n        \\n        while len(group_ptr) < n:\\n            base_ptr += str(group_ptr[base_ptr_idx])\\n            base_ptr_idx += 1\\n            added_twice = False\\n            \\n            next_char = \\'1\\' if group_ptr[-1] == \\'2\\' else \\'2\\'\\n            if base_ptr[-1] == \\'1\\':\\n                group_ptr += next_char\\n            else:\\n                group_ptr += next_char * 2\\n                added_twice = True\\n            \\n            if next_char == \\'1\\':\\n                count += 2 if added_twice else 1\\n                if len(group_ptr) > n:\\n                    count -= 1\\n        return count",
                "codeTag": "Java"
            },
            {
                "id": 2337939,
                "title": "c-easy-solution-using-stl",
                "content": "\\n    int magicalString(int n) {\\n        // take a string \" 122\" with a space\\n        string s = \" 122\";\\n        \\n        //here indeing sart from 1 because we consider space in string s at index \\'0\\'\\n        // if i is odd then add \\'1\\' i times else add \\'2\\' i times\\n        for(int i=3;i<=n;i++){\\n            s.append(s[i]-\\'0\\', i&1 ? \\'1\\': \\'2\\');\\n            if(i>n) break;\\n        }\\n        // count the total \\'1\\' into the string (in stl at the end it not check for  n+1 index it check upto n ) \\n        return count(s.begin(),s.begin()+n+1,\\'1\\');\\n    }\\n",
                "solutionTags": [
                    "C++",
                    "C",
                    "String"
                ],
                "code": "\\n    int magicalString(int n) {\\n        // take a string \" 122\" with a space\\n        string s = \" 122\";\\n        \\n        //here indeing sart from 1 because we consider space in string s at index \\'0\\'\\n        // if i is odd then add \\'1\\' i times else add \\'2\\' i times\\n        for(int i=3;i<=n;i++){\\n            s.append(s[i]-\\'0\\', i&1 ? \\'1\\': \\'2\\');\\n            if(i>n) break;\\n        }\\n        // count the total \\'1\\' into the string (in stl at the end it not check for  n+1 index it check upto n ) \\n        return count(s.begin(),s.begin()+n+1,\\'1\\');\\n    }\\n",
                "codeTag": "Unknown"
            },
            {
                "id": 2277547,
                "title": "clean-code-no-vector-o-n-time-cost",
                "content": "```\\n\\tint magicalString(int n) {\\n        string str(\"122\");\\n        int toBe = 2, ans = 1;\\n        \\n        while(str.size() < n){\\n            if(str[toBe] == \\'1\\'){\\n                if(str.back() == \\'1\\'){\\n                    str += \\'2\\';\\n                }else{\\n                    str += \\'1\\';\\n                    ans++;\\n                }\\n            }else{\\n                if(str.back()== \\'1\\'){\\n                    str += \"22\";\\n                }else{\\n                    str += \"11\";\\n                    ans += 2;\\n                }\\n            }\\n            toBe++;\\n        }\\n        if(str.size() > n && str.back() == \\'1\\'){\\n            ans--;\\n        }\\n        return ans;\\n    }",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\n\\tint magicalString(int n) {\\n        string str(\"122\");\\n        int toBe = 2, ans = 1;\\n        \\n        while(str.size() < n){\\n            if(str[toBe] == \\'1\\'){\\n                if(str.back() == \\'1\\'){\\n                    str += \\'2\\';\\n                }else{\\n                    str += \\'1\\';\\n                    ans++;\\n                }\\n            }else{\\n                if(str.back()== \\'1\\'){\\n                    str += \"22\";\\n                }else{\\n                    str += \"11\";\\n                    ans += 2;\\n                }\\n            }\\n            toBe++;\\n        }\\n        if(str.size() > n && str.back() == \\'1\\'){\\n            ans--;\\n        }\\n        return ans;\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 2274303,
                "title": "simple-python-solution-just-7-lines-of-code",
                "content": "```\\nclass Solution:\\n    def magicalString(self, n: int) -> int:\\n        def generate(arr, idx):\\n            arr.extend([2]*arr[idx] if arr[-1] == 1 else [1]*arr[idx])\\n        \\n        idx, arr = 2, [1,2,2]\\n        while len(arr) < n:\\n            generate(arr, idx)\\n            idx += 1\\n        return sum([1 for i in arr[:n] if i == 1])\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def magicalString(self, n: int) -> int:\\n        def generate(arr, idx):\\n            arr.extend([2]*arr[idx] if arr[-1] == 1 else [1]*arr[idx])\\n        \\n        idx, arr = 2, [1,2,2]\\n        while len(arr) < n:\\n            generate(arr, idx)\\n            idx += 1\\n        return sum([1 for i in arr[:n] if i == 1])\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2188019,
                "title": "c-o-n-solution-for-magical-string",
                "content": "```\\nclass Solution {\\npublic:\\n    int magicalString(int n) {\\n        if(n<=3)\\n        {\\n            return 1;\\n        }\\n        string magical_string=\"122\";\\n        int p1=2;\\n        char val=\\'1\\';\\n        int num_ones=1;\\n        int curr_len=3;\\n        while(curr_len<n)\\n        {\\n            int count=0;\\n            while(curr_len<n &&count<(magical_string[p1]-\\'0\\'))\\n            {\\n                magical_string+=val;\\n                count++;\\n                curr_len+=1;\\n            }\\n            p1++;\\n            if(val==\\'1\\')\\n            {\\n                val=\\'2\\';\\n                num_ones+=count;\\n            }\\n            else\\n            {\\n                val=\\'1\\';\\n            }\\n        }\\n        return num_ones;\\n        \\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int magicalString(int n) {\\n        if(n<=3)\\n        {\\n            return 1;\\n        }\\n        string magical_string=\"122\";\\n        int p1=2;\\n        char val=\\'1\\';\\n        int num_ones=1;\\n        int curr_len=3;\\n        while(curr_len<n)\\n        {\\n            int count=0;\\n            while(curr_len<n &&count<(magical_string[p1]-\\'0\\'))\\n            {\\n                magical_string+=val;\\n                count++;\\n                curr_len+=1;\\n            }\\n            p1++;\\n            if(val==\\'1\\')\\n            {\\n                val=\\'2\\';\\n                num_ones+=count;\\n            }\\n            else\\n            {\\n                val=\\'1\\';\\n            }\\n        }\\n        return num_ones;\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2126681,
                "title": "c-o-n-simulation",
                "content": "```\\nclass Solution {\\npublic:\\n    int magicalString(int n) {\\n        string s = \"122\";\\n        int c = 1, geni=2;\\n        while(n>s.size())\\n        {\\n            auto tmp = s.back()==\\'2\\'?\\'1\\':\\'2\\';\\n            for(int i=0; i<(s[geni] == \\'2\\'?2:1); i++)\\n            {\\n                s.push_back(tmp);\\n                if (tmp == \\'1\\')\\n                    c++;\\n                if (s.size() == n)\\n                    return c;\\n            }\\n            geni++;\\n        }\\n        return c;\\n    }\\n};\\n    \\n```\\n\\n",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int magicalString(int n) {\\n        string s = \"122\";\\n        int c = 1, geni=2;\\n        while(n>s.size())\\n        {\\n            auto tmp = s.back()==\\'2\\'?\\'1\\':\\'2\\';\\n            for(int i=0; i<(s[geni] == \\'2\\'?2:1); i++)\\n            {\\n                s.push_back(tmp);\\n                if (tmp == \\'1\\')\\n                    c++;\\n                if (s.size() == n)\\n                    return c;\\n            }\\n            geni++;\\n        }\\n        return c;\\n    }\\n};\\n    \\n```",
                "codeTag": "Java"
            },
            {
                "id": 2126060,
                "title": "java-using-arraydeque",
                "content": "```\\nclass Solution {\\n    public int magicalString(int n) {\\n        if(n <= 3)\\n            return 1;\\n        Magical m = new Magical();\\n        int ans = 1;\\n        for(int i = 3; i < n; ++i)\\n            if(m.next() == 1)\\n                ++ans;\\n        return ans;\\n    }\\n}\\n\\nclass Magical{\\n    \\n    private Deque<Integer> nums;\\n    private int n;\\n    \\n    public Magical(){\\n        nums = new ArrayDeque<>();\\n        nums.offerLast(1);\\n        nums.offerLast(1);\\n        n = 1;\\n    }\\n    \\n    public int next(){\\n        if(n-- < 0){\\n            int c = nums.pollFirst();\\n            n = c - 2;\\n            int curr = 3 - nums.peekLast();\\n            for(; c > 0; --c)\\n                nums.offerLast(curr);\\n            return curr;\\n        }\\n        return nums.peekLast();\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int magicalString(int n) {\\n        if(n <= 3)\\n            return 1;\\n        Magical m = new Magical();\\n        int ans = 1;\\n        for(int i = 3; i < n; ++i)\\n            if(m.next() == 1)\\n                ++ans;\\n        return ans;\\n    }\\n}\\n\\nclass Magical{\\n    \\n    private Deque<Integer> nums;\\n    private int n;\\n    \\n    public Magical(){\\n        nums = new ArrayDeque<>();\\n        nums.offerLast(1);\\n        nums.offerLast(1);\\n        n = 1;\\n    }\\n    \\n    public int next(){\\n        if(n-- < 0){\\n            int c = nums.pollFirst();\\n            n = c - 2;\\n            int curr = 3 - nums.peekLast();\\n            for(; c > 0; --c)\\n                nums.offerLast(curr);\\n            return curr;\\n        }\\n        return nums.peekLast();\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2089105,
                "title": "python-solution-kolakoski-sequence",
                "content": "I was confused when reading the question on how to generate the sequence. The sequence is called Kolakoski sequence: https://en.wikipedia.org/wiki/Kolakoski_sequence\\nOnce you understand the generation process, this question is trivial\\n```\\nclass Solution:\\n    def magicalString(self, n: int) -> int:\\n        if n == 1: # This case does not fit well with the algorithm, so is listed as an edge case\\n            return 1\\n        else:\\n            # This code can generate Kolakoski Sequence up to n. The two at position 2 is skipped\\n            one = True # alternate between True and False to generate 1 and 2 respectively\\n            arr = [] # Array to hold the sequence\\n            i = -1 # repetition of each entry\\n            count = 0\\n            while len(arr) < n-1:\\n                if one:\\n                    if not arr:\\n                        arr.append(1)\\n                        count += 1\\n                    else:\\n                        for j in range(arr[i]):\\n                            arr.append(1)\\n                            count += 1\\n                else:\\n                    for j in range(arr[i]):\\n                        arr.append(2)\\n                i += 1\\n                one = not one\\n            if len(arr) > n - 1 and arr[-1] == 1: # possible that one extra entry is added\\n                return count - 1\\n            else:\\n                return count\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def magicalString(self, n: int) -> int:\\n        if n == 1: # This case does not fit well with the algorithm, so is listed as an edge case\\n            return 1\\n        else:\\n            # This code can generate Kolakoski Sequence up to n. The two at position 2 is skipped\\n            one = True # alternate between True and False to generate 1 and 2 respectively\\n            arr = [] # Array to hold the sequence\\n            i = -1 # repetition of each entry\\n            count = 0\\n            while len(arr) < n-1:\\n                if one:\\n                    if not arr:\\n                        arr.append(1)\\n                        count += 1\\n                    else:\\n                        for j in range(arr[i]):\\n                            arr.append(1)\\n                            count += 1\\n                else:\\n                    for j in range(arr[i]):\\n                        arr.append(2)\\n                i += 1\\n                one = not one\\n            if len(arr) > n - 1 and arr[-1] == 1: # possible that one extra entry is added\\n                return count - 1\\n            else:\\n                return count\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2062730,
                "title": "easy-to-understand-javascript-solution",
                "content": "\\tvar magicalString = function(n) {\\n\\t\\tconst stack = [\\'1\\', \\'2\\', \\'2\\'];\\n\\t\\tlet magic = 2;\\n\\n\\t\\twhile (stack.length < n) {\\n\\t\\t\\tconst count = stack[magic++];\\n\\t\\t\\tconst last = stack[stack.length - 1];\\n\\t\\t\\tconst addStr = last === \\'1\\' ? \\'2\\' : \\'1\\';\\n\\n\\t\\t\\tfor (let n = 1; n <= count; n++) stack.push(addStr);\\n\\t\\t}\\n\\t\\treturn stack.slice(0, n).filter(str => str === \\'1\\').length;\\n\\t};",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "\\tvar magicalString = function(n) {\\n\\t\\tconst stack = [\\'1\\', \\'2\\', \\'2\\'];\\n\\t\\tlet magic = 2;\\n\\n\\t\\twhile (stack.length < n) {\\n\\t\\t\\tconst count = stack[magic++];\\n\\t\\t\\tconst last = stack[stack.length - 1];\\n\\t\\t\\tconst addStr = last === \\'1\\' ? \\'2\\' : \\'1\\';\\n\\n\\t\\t\\tfor (let n = 1; n <= count; n++) stack.push(addStr);\\n\\t\\t}\\n\\t\\treturn stack.slice(0, n).filter(str => str === \\'1\\').length;\\n\\t};",
                "codeTag": "Unknown"
            },
            {
                "id": 2006179,
                "title": "boolean-vector-representing-the-kolakoski-sequence",
                "content": "I am not resourceful enough for an O(log n) space solution, so I built the \"string\" using a boolean vector in C++ (true is 2 and false is 1).\\n```\\nclass Solution {\\npublic:\\n    int magicalString(int n) {\\n        vector<bool> s={false, true, true};\\n        int i=2, len=3;\\n        bool cur=!s.back();\\n        int ans=1;\\n        while (len<n) {\\n            for (int j=0; j<(s[i] ? 2 : 1); j++) {\\n                s.push_back(cur);\\n                if (!cur) ans++;\\n                len++;\\n            }\\n            cur=!cur;\\n            i++;\\n        }\\n        if (len>n && !s.back()) ans--;\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int magicalString(int n) {\\n        vector<bool> s={false, true, true};\\n        int i=2, len=3;\\n        bool cur=!s.back();\\n        int ans=1;\\n        while (len<n) {\\n            for (int j=0; j<(s[i] ? 2 : 1); j++) {\\n                s.push_back(cur);\\n                if (!cur) ans++;\\n                len++;\\n            }\\n            cur=!cur;\\n            i++;\\n        }\\n        if (len>n && !s.back()) ans--;\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1992090,
                "title": "python3-simulation-o-n",
                "content": "```\\nclass Solution:\\n    def magicalString(self, n: int) -> int:\\n        arr=[el for el in \\'122\\']\\n        i=2\\n        while len(arr)<n:\\n            count=int(arr[i])\\n            last=arr[-1]\\n            for _ in range(int(arr[i])):\\n                arr.append(\\'2\\' if last==\\'1\\' else \\'1\\')\\n            i+=1\\n        return arr[:n].count(\\'1\\')\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def magicalString(self, n: int) -> int:\\n        arr=[el for el in \\'122\\']\\n        i=2\\n        while len(arr)<n:\\n            count=int(arr[i])\\n            last=arr[-1]\\n            for _ in range(int(arr[i])):\\n                arr.append(\\'2\\' if last==\\'1\\' else \\'1\\')\\n            i+=1\\n        return arr[:n].count(\\'1\\')\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1979997,
                "title": "python-queue-solution-1207ms",
                "content": "```\\nimport queue\\n\\nclass Solution:\\n    def magicalString(self, n: int) -> int:\\n        \\n        #To keep track of which number is next\\n        magic_number_q = queue.Queue();\\n        magic_number_q.put( 2 );\\n        \\n        #The index of the magic number we are one\\n        m_index = 1;\\n        \\n        #The count of ones\\n        one_count = 1;\\n\\n        #The current digit we are adding\\n        current_digit = 2;\\n        \\n        #The number of iterations we have gone through\\n        #Which is the length of the groupings\\n        epoch = 1;\\n        \\n        #The groupings will ( most of the time ) be longer than the magic number\\n        #Only in the beginning do we deal with them being the same size\\n        \\n        #While we need to extend the groupings to length n\\n        while epoch < n:  \\n            \\n            #We take out the queue\\n            current_count = magic_number_q.get();\\n            #And notionally increment our magic number index\\n            #This is one-indexed by the way\\n            m_index += 1;\\n            \\n            #The queue value will tell us the next grouping\\n            if current_count == 1:\\n       \\n                magic_number_q.put( current_digit );\\n                epoch += 1;\\n    \\n            else:\\n                \\n                #If the m_index is only one behind\\n                #Adding the grouping will only extend the magic_number once\\n                if m_index - 1 == epoch:\\n                    magic_number_q.put( current_digit );\\n                else:\\n                    magic_number_q.put( current_digit );\\n                    magic_number_q.put( current_digit );\\n                epoch += 2;\\n      \\n            #Each epoch, flip the number used\\n            if current_digit == 1:\\n                one_count += current_count;\\n                current_digit = 2;\\n            else:\\n                current_digit = 1;\\n                \\n        #Edge case; when the epoch extended beyong n\\n        #For the case of grouping 2 ones\\n        #We must reduce the one_count by one\\n        if epoch > n and current_digit == 2:\\n            one_count -= 1;\\n\\n            \\n        return one_count;\\n```",
                "solutionTags": [],
                "code": "```\\nimport queue\\n\\nclass Solution:\\n    def magicalString(self, n: int) -> int:\\n        \\n        #To keep track of which number is next\\n        magic_number_q = queue.Queue();\\n        magic_number_q.put( 2 );\\n        \\n        #The index of the magic number we are one\\n        m_index = 1;\\n        \\n        #The count of ones\\n        one_count = 1;\\n\\n        #The current digit we are adding\\n        current_digit = 2;\\n        \\n        #The number of iterations we have gone through\\n        #Which is the length of the groupings\\n        epoch = 1;\\n        \\n        #The groupings will ( most of the time ) be longer than the magic number\\n        #Only in the beginning do we deal with them being the same size\\n        \\n        #While we need to extend the groupings to length n\\n        while epoch < n:  \\n            \\n            #We take out the queue\\n            current_count = magic_number_q.get();\\n            #And notionally increment our magic number index\\n            #This is one-indexed by the way\\n            m_index += 1;\\n            \\n            #The queue value will tell us the next grouping\\n            if current_count == 1:\\n       \\n                magic_number_q.put( current_digit );\\n                epoch += 1;\\n    \\n            else:\\n                \\n                #If the m_index is only one behind\\n                #Adding the grouping will only extend the magic_number once\\n                if m_index - 1 == epoch:\\n                    magic_number_q.put( current_digit );\\n                else:\\n                    magic_number_q.put( current_digit );\\n                    magic_number_q.put( current_digit );\\n                epoch += 2;\\n      \\n            #Each epoch, flip the number used\\n            if current_digit == 1:\\n                one_count += current_count;\\n                current_digit = 2;\\n            else:\\n                current_digit = 1;\\n                \\n        #Edge case; when the epoch extended beyong n\\n        #For the case of grouping 2 ones\\n        #We must reduce the one_count by one\\n        if epoch > n and current_digit == 2:\\n            one_count -= 1;\\n\\n            \\n        return one_count;\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1831076,
                "title": "javascript-direct-build-2135ms",
                "content": "```\\nconst magicalString = (n) => {\\n    let s = \\'122\\', p = 2;\\n    while (s.length < n) {\\n        let cur = s[s.length - 1] ^ 3, t = (cur + \\'\\').repeat(s[p++] - \\'0\\');  // ^ 3   1 -> 2  2 -> 1 switch\\n        s += t;\\n    }\\n    let cnt = 0;\\n    for (let i = 0; i < n; i++) {\\n        if (s[i] == \\'1\\') cnt++;\\n    }\\n    return cnt;\\n};\\n```\\nreference: https://en.wikipedia.org/wiki/Kolakoski_sequence",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\nconst magicalString = (n) => {\\n    let s = \\'122\\', p = 2;\\n    while (s.length < n) {\\n        let cur = s[s.length - 1] ^ 3, t = (cur + \\'\\').repeat(s[p++] - \\'0\\');  // ^ 3   1 -> 2  2 -> 1 switch\\n        s += t;\\n    }\\n    let cnt = 0;\\n    for (let i = 0; i < n; i++) {\\n        if (s[i] == \\'1\\') cnt++;\\n    }\\n    return cnt;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1806559,
                "title": "python-simple-simulation-with-queue",
                "content": "```py\\nclass Solution:\\n    def magicalString(self, n: int) -> int:\\n        queue, ans, i = deque([2]), 1, 1\\n\\n        while i <= n - 2:\\n            m = queue.popleft()\\n            ans += (m == 1)\\n            queue.extend([1 + (i % 2 == 0)] * m)\\n            i += 1\\n\\n        return ans\\n```\\n\\nThe code simulates the generating `n` digits of the \\'magical string\\' and counts the number of ones encountered.\\n\\nThe queue starts with the **third** digit of the magic string (12**2**...), which is also why the answer is initialized to `1`.\\n\\nThis line `queue.extend([1 + (i % 2 == 0)] * m)` perhaps deserves an explainer. We need to alternate between `1` and `2` in the magic string. That\\'s taken care of by `1 + (i % 2 == 0)`. When `i` is even, that expression evaluates to `2` and when `i` is odd, it equals `1`. The multiplier just handles the repition (1 or 2) of the next number(s).",
                "solutionTags": [
                    "Python"
                ],
                "code": "```py\\nclass Solution:\\n    def magicalString(self, n: int) -> int:\\n        queue, ans, i = deque([2]), 1, 1\\n\\n        while i <= n - 2:\\n            m = queue.popleft()\\n            ans += (m == 1)\\n            queue.extend([1 + (i % 2 == 0)] * m)\\n            i += 1\\n\\n        return ans\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1736168,
                "title": "simple-c-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    int magicalString(int n) {\\n        int a = 1^2;\\n        string magic = \"122\";\\n        int i = 2, j = 2;\\n        while(j < n) {\\n            char ch = a^(magic[j]-\\'0\\')+\\'0\\';\\n            int times = magic[i]-\\'0\\';\\n            for(int k = 0; k < times; k++) {\\n                magic += ch;\\n                j++;\\n            }\\n            \\n            i++;\\n        }\\n        \\n        // cout << magic << endl;\\n        int cnt = 0;\\n        for(int i = 0; i < n; i++) \\n            if(magic[i] == \\'1\\') cnt++;\\n        \\n        return cnt;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int magicalString(int n) {\\n        int a = 1^2;\\n        string magic = \"122\";\\n        int i = 2, j = 2;\\n        while(j < n) {\\n            char ch = a^(magic[j]-\\'0\\')+\\'0\\';\\n            int times = magic[i]-\\'0\\';\\n            for(int k = 0; k < times; k++) {\\n                magic += ch;\\n                j++;\\n            }\\n            \\n            i++;\\n        }\\n        \\n        // cout << magic << endl;\\n        int cnt = 0;\\n        for(int i = 0; i < n; i++) \\n            if(magic[i] == \\'1\\') cnt++;\\n        \\n        return cnt;\\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 1695272,
                "title": "javascript-solution-two-pointers-solution",
                "content": "It took me awhile to get this. We use the left pointer for the count and the right pointer to add the 1 or 2. We want to make sure that during the for loop our right pointer doesn\\'t extend beyond n - 1. We also want to maintain a count of ones we added.\\n\\n```\\nvar magicalString = function(n) {\\n    if (n === 1) return 1;\\n    \\n    const arr = new Array(n).fill(1);\\n    \\n    arr[0] = 1;\\n    arr[1] = 2;\\n    \\n    let left = 1;\\n    let right = 1;\\n    \\n    let num = 2;\\n    let ones = 1;\\n    \\n    while (right < n) {\\n        const count = arr[left];\\n        \\n        for (let i = 0; i < count && right < n; i++, right++) {\\n            arr[right] = num;\\n            if (num === 1) ones++;\\n        }\\n        \\n        num ^= 3;\\n        \\n        left++;\\n    }\\n    \\n    return ones;\\n};\\n```",
                "solutionTags": [
                    "JavaScript",
                    "Two Pointers"
                ],
                "code": "```\\nvar magicalString = function(n) {\\n    if (n === 1) return 1;\\n    \\n    const arr = new Array(n).fill(1);\\n    \\n    arr[0] = 1;\\n    arr[1] = 2;\\n    \\n    let left = 1;\\n    let right = 1;\\n    \\n    let num = 2;\\n    let ones = 1;\\n    \\n    while (right < n) {\\n        const count = arr[left];\\n        \\n        for (let i = 0; i < count && right < n; i++, right++) {\\n            arr[right] = num;\\n            if (num === 1) ones++;\\n        }\\n        \\n        num ^= 3;\\n        \\n        left++;\\n    }\\n    \\n    return ones;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1683009,
                "title": "c",
                "content": "(```)  class Solution {\\npublic:\\n    int magicalString(int n) {\\n        \\n        vector<int> v{1,2,2};\\n        \\n        int i = 2;\\n        \\n        while(v.size() < n)\\n        {\\n           v.insert(v.end( ), v[i++],v.back()^3); \\n        }\\n        \\n        return count(v.begin(),v.begin()+n, 1);\\n        \\n    }\\n};",
                "solutionTags": [],
                "code": "class Solution {\\npublic:\\n    int magicalString(int n) {\\n        \\n        vector<int> v{1,2,2}",
                "codeTag": "Java"
            },
            {
                "id": 1663070,
                "title": "java-solution-one-loop-only-two-pointer-no-dp",
                "content": "```\\n    public int magicalString(int n) {\\n        if( n < 3)\\n            return 1;\\n        \\n        int count = 1;\\n        int i = 2;\\n        int j = 3;\\n        \\n        int[] ar = new int[n+1];\\n        ar[2] = 2;\\n        int next_val = 1;\\n        \\n        while(j < n){\\n            ar[j++] = next_val;\\n            if( next_val == 1 )\\n                count++;\\n            if( ar[i] == 2) {\\n                ar[j++] = next_val;\\n                if( next_val == 1 )\\n                    count++;\\n            }\\n            next_val = 3-next_val;\\n            i++;\\n        }\\n        \\n        if( j == n+1 && ar[n] == 1)\\n            count--;\\n        \\n        return count;\\n    }\\n```",
                "solutionTags": [],
                "code": "```\\n    public int magicalString(int n) {\\n        if( n < 3)\\n            return 1;\\n        \\n        int count = 1;\\n        int i = 2;\\n        int j = 3;\\n        \\n        int[] ar = new int[n+1];\\n        ar[2] = 2;\\n        int next_val = 1;\\n        \\n        while(j < n){\\n            ar[j++] = next_val;\\n            if( next_val == 1 )\\n                count++;\\n            if( ar[i] == 2) {\\n                ar[j++] = next_val;\\n                if( next_val == 1 )\\n                    count++;\\n            }\\n            next_val = 3-next_val;\\n            i++;\\n        }\\n        \\n        if( j == n+1 && ar[n] == 1)\\n            count--;\\n        \\n        return count;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1651628,
                "title": "simple-c-code",
                "content": "# **If you like the implementation then Please help me by increasing my reputation. By clicking the up arrow on the left of my image.**\\n```\\nclass Solution {\\npublic:\\n    int magicalString(int n) {\\n        string magic = \"122\";\\n        int mg = 2;\\n        int ret = 0;\\n        while(magic.size() <= n)\\n        {\\n            int cnt1 = 0;\\n            cnt1 = magic[mg] - \\'0\\';\\n            //cout << cnt1;\\n            ++mg;\\n            //cout << cnt2;\\n            \\n            for(int i = 0; i < cnt1; i++)\\n                magic += \\'1\\';\\n            int cnt2 = magic[mg] - \\'0\\';\\n            ++mg;\\n            for(int j = 0; j < cnt2; j++)\\n                magic += \\'2\\';\\n        }\\n        for(int i = 0; i < n; i++)\\n        {\\n            //cout << magic[i];\\n            if(magic[i] == \\'1\\')\\n                ret++;\\n        }\\n        return ret;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int magicalString(int n) {\\n        string magic = \"122\";\\n        int mg = 2;\\n        int ret = 0;\\n        while(magic.size() <= n)\\n        {\\n            int cnt1 = 0;\\n            cnt1 = magic[mg] - \\'0\\';\\n            //cout << cnt1;\\n            ++mg;\\n            //cout << cnt2;\\n            \\n            for(int i = 0; i < cnt1; i++)\\n                magic += \\'1\\';\\n            int cnt2 = magic[mg] - \\'0\\';\\n            ++mg;\\n            for(int j = 0; j < cnt2; j++)\\n                magic += \\'2\\';\\n        }\\n        for(int i = 0; i < n; i++)\\n        {\\n            //cout << magic[i];\\n            if(magic[i] == \\'1\\')\\n                ret++;\\n        }\\n        return ret;\\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 1529767,
                "title": "c-short-and-straightforward",
                "content": "```\\nclass Solution {\\npublic:\\n    int magicalString(int n) {\\n        string s = \"122\";\\n        int k = 2, res = 0, one, two;\\n        while(s.length() < n) {\\n            one = s[k++]-\\'0\\';\\n            while(one--) s += \\'1\\';\\n            two = s[k++]-\\'0\\';\\n            while(two--) s += \\'2\\';\\n        }\\n        for(int i=0;i<n;i++) if(s[i] == \\'1\\') res++;\\n        return res;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int magicalString(int n) {\\n        string s = \"122\";\\n        int k = 2, res = 0, one, two;\\n        while(s.length() < n) {\\n            one = s[k++]-\\'0\\';\\n            while(one--) s += \\'1\\';\\n            two = s[k++]-\\'0\\';\\n            while(two--) s += \\'2\\';\\n        }\\n        for(int i=0;i<n;i++) if(s[i] == \\'1\\') res++;\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1478190,
                "title": "c-solution",
                "content": "```\\n    int magicalString(int n) {\\n        vector<char> magic={1,2,2};\\n        int index_cnt=2;\\n        char last_num=2;\\n        while(magic.size()<n)\\n        {\\n            int cnt=magic[index_cnt];\\n            char num=(last_num==1)?2:1;\\n            magic.insert(magic.end(), cnt, num);\\n            last_num=num;\\n            index_cnt++;\\n        }\\n        int ret=0;\\n        for(int i=0; i<n; i++)\\n        {\\n            if(magic[i]==1) ret++;\\n        }\\n        return ret;\\n    }\\n```",
                "solutionTags": [],
                "code": "```\\n    int magicalString(int n) {\\n        vector<char> magic={1,2,2};\\n        int index_cnt=2;\\n        char last_num=2;\\n        while(magic.size()<n)\\n        {\\n            int cnt=magic[index_cnt];\\n            char num=(last_num==1)?2:1;\\n            magic.insert(magic.end(), cnt, num);\\n            last_num=num;\\n            index_cnt++;\\n        }\\n        int ret=0;\\n        for(int i=0; i<n; i++)\\n        {\\n            if(magic[i]==1) ret++;\\n        }\\n        return ret;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1469671,
                "title": "py-magical-str-bad-q-o-n",
                "content": "```\\nclass Solution:\\n    def magicalString(self, n: int) -> int:\\n        s = [1,2,2] + [0]*max(0,n-3)\\n        r, w = 0, 0\\n        ans = 0\\n        while True:\\n            num = 1 + (s[w-1] % 2)\\n            for _ in range(s[r]):\\n                s[w] = num\\n                ans += (num == 1)\\n                w += 1\\n                if w == n:\\n                    return ans\\n            r += 1        \\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def magicalString(self, n: int) -> int:\\n        s = [1,2,2] + [0]*max(0,n-3)\\n        r, w = 0, 0\\n        ans = 0\\n        while True:\\n            num = 1 + (s[w-1] % 2)\\n            for _ in range(s[r]):\\n                s[w] = num\\n                ans += (num == 1)\\n                w += 1\\n                if w == n:\\n                    return ans\\n            r += 1        \\n```",
                "codeTag": "Java"
            },
            {
                "id": 1392316,
                "title": "scala-simple-double-pointers",
                "content": "```scala\\nobject Solution {\\n    def magicalString(n: Int): Int = {\\n        val sb = new StringBuilder(\"122\")\\n        var i = 1\\n        var j = 3\\n        while (j < n) {\\n            val next = sb(j-1) match {\\n                case \\'1\\' => \\'2\\'\\n                case \\'2\\' => \\'1\\'\\n            }\\n            i += 1\\n            val len = sb(i) - \\'0\\'\\n            j += len\\n            sb ++= next.toString() * len\\n        }\\n        sb.slice(0, n).count(_ == \\'1\\')\\n    }\\n}\\n```",
                "solutionTags": [
                    "Scala"
                ],
                "code": "```scala\\nobject Solution {\\n    def magicalString(n: Int): Int = {\\n        val sb = new StringBuilder(\"122\")\\n        var i = 1\\n        var j = 3\\n        while (j < n) {\\n            val next = sb(j-1) match {\\n                case \\'1\\' => \\'2\\'\\n                case \\'2\\' => \\'1\\'\\n            }\\n            i += 1\\n            val len = sb(i) - \\'0\\'\\n            j += len\\n            sb ++= next.toString() * len\\n        }\\n        sb.slice(0, n).count(_ == \\'1\\')\\n    }\\n}\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 1386186,
                "title": "swift-o-n-solution-easy-to-understand",
                "content": "```\\nclass Solution {\\n    func magicalString(_ n: Int) -> Int {\\n        if n == 0 {\\n            return 0\\n        }\\n        else if n == 1 || n == 2 {\\n            return 1\\n        }\\n        \\n        // s record the current magic string values\\n        // for now, the magic string is \"12\"\\n        // false stands for 1, true stands for 2\\n        var s = [ false, true ]\\n        // index means that s[index] is the value we want to generate currently\\n        var index = 1\\n        // for now, we have a \"2\" in the group\\n        var group_count = 1\\n        // false stands for 1, true stands for 2\\n        var group_value = true\\n        \\n        // the result\\n        // for now (\"12\"), the count of \"1\" is 1\\n        var count = 1\\n        \\n        // simulate the process of the generation of the magic string\\n        while s.count < n {\\n            if s[index] == false {\\n                // 1\\n                if group_count == 0 {\\n                    s.append(group_value)\\n                    if group_value == false {\\n                        count += 1\\n                    }\\n                    index += 1\\n                    group_value = !group_value\\n                    group_count = 0\\n                }\\n            }\\n            else {\\n                // 2\\n                if group_count == 0 {\\n                    s.append(group_value)\\n                    if group_value == false {\\n                        count += 1\\n                    }\\n                    group_count = 1\\n                }\\n                else if group_count == 1 {\\n                    s.append(group_value)\\n                    if group_value == false {\\n                        count += 1\\n                    }\\n                    index += 1\\n                    group_value = !group_value\\n                    group_count = 0\\n                }\\n            }\\n        }\\n        \\n        return count\\n    }\\n}\\n```",
                "solutionTags": [
                    "Swift"
                ],
                "code": "```\\nclass Solution {\\n    func magicalString(_ n: Int) -> Int {\\n        if n == 0 {\\n            return 0\\n        }\\n        else if n == 1 || n == 2 {\\n            return 1\\n        }\\n        \\n        // s record the current magic string values\\n        // for now, the magic string is \"12\"\\n        // false stands for 1, true stands for 2\\n        var s = [ false, true ]\\n        // index means that s[index] is the value we want to generate currently\\n        var index = 1\\n        // for now, we have a \"2\" in the group\\n        var group_count = 1\\n        // false stands for 1, true stands for 2\\n        var group_value = true\\n        \\n        // the result\\n        // for now (\"12\"), the count of \"1\" is 1\\n        var count = 1\\n        \\n        // simulate the process of the generation of the magic string\\n        while s.count < n {\\n            if s[index] == false {\\n                // 1\\n                if group_count == 0 {\\n                    s.append(group_value)\\n                    if group_value == false {\\n                        count += 1\\n                    }\\n                    index += 1\\n                    group_value = !group_value\\n                    group_count = 0\\n                }\\n            }\\n            else {\\n                // 2\\n                if group_count == 0 {\\n                    s.append(group_value)\\n                    if group_value == false {\\n                        count += 1\\n                    }\\n                    group_count = 1\\n                }\\n                else if group_count == 1 {\\n                    s.append(group_value)\\n                    if group_value == false {\\n                        count += 1\\n                    }\\n                    index += 1\\n                    group_value = !group_value\\n                    group_count = 0\\n                }\\n            }\\n        }\\n        \\n        return count\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1382417,
                "title": "go-double-100",
                "content": "```\\nfunc magicalString(n int) int {\\n\\tans := 0\\n\\n\\tif n <= 3 {\\n\\t\\treturn 1\\n\\t}\\n\\n\\ts := make([]uint8, 100001)\\n\\ts[0] = 1\\n\\ts[1] = 2\\n\\ts[2] = 2\\n\\t\\n\\ti, j := 2, 2\\n\\n\\tfor i < n && j < n {\\n\\t\\t// to add 1s to s\\n\\t\\tif i%2 == 0 {\\n\\t\\t\\tif s[i] == 2 {\\n\\t\\t\\t\\tj++\\n\\t\\t\\t\\ts[j] = 1\\n\\t\\t\\t\\tj++\\n\\t\\t\\t\\ts[j] = 1\\n\\t\\t\\t} else if s[i] == 1 {\\n\\t\\t\\t\\tj++\\n\\t\\t\\t\\ts[j] = 1\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\t// to add 2s to s\\n\\t\\tif i%2 == 1 {\\n\\t\\t\\tif s[i] == 2 {\\n\\t\\t\\t\\tj++\\n\\t\\t\\t\\ts[j] = 2\\n\\t\\t\\t\\tj++\\n\\t\\t\\t\\ts[j] = 2\\n\\t\\t\\t} else if s[i] == 1 {\\n\\t\\t\\t\\tj++\\n\\t\\t\\t\\ts[j] = 2\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\ti++\\n\\t}\\n\\n\\tj = 0\\n\\tfor j < n {\\n\\t\\tif s[j] == 1 {\\n\\t\\t\\tans++\\n\\t\\t}\\n\\t\\tj++\\n\\t}\\n\\n\\treturn ans\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nfunc magicalString(n int) int {\\n\\tans := 0\\n\\n\\tif n <= 3 {\\n\\t\\treturn 1\\n\\t}\\n\\n\\ts := make([]uint8, 100001)\\n\\ts[0] = 1\\n\\ts[1] = 2\\n\\ts[2] = 2\\n\\t\\n\\ti, j := 2, 2\\n\\n\\tfor i < n && j < n {\\n\\t\\t// to add 1s to s\\n\\t\\tif i%2 == 0 {\\n\\t\\t\\tif s[i] == 2 {\\n\\t\\t\\t\\tj++\\n\\t\\t\\t\\ts[j] = 1\\n\\t\\t\\t\\tj++\\n\\t\\t\\t\\ts[j] = 1\\n\\t\\t\\t} else if s[i] == 1 {\\n\\t\\t\\t\\tj++\\n\\t\\t\\t\\ts[j] = 1\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\t// to add 2s to s\\n\\t\\tif i%2 == 1 {\\n\\t\\t\\tif s[i] == 2 {\\n\\t\\t\\t\\tj++\\n\\t\\t\\t\\ts[j] = 2\\n\\t\\t\\t\\tj++\\n\\t\\t\\t\\ts[j] = 2\\n\\t\\t\\t} else if s[i] == 1 {\\n\\t\\t\\t\\tj++\\n\\t\\t\\t\\ts[j] = 2\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\ti++\\n\\t}\\n\\n\\tj = 0\\n\\tfor j < n {\\n\\t\\tif s[j] == 1 {\\n\\t\\t\\tans++\\n\\t\\t}\\n\\t\\tj++\\n\\t}\\n\\n\\treturn ans\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1280456,
                "title": "python-queue",
                "content": "```\\n\\nclass Solution:\\n    result = [0, 1, 1, 1, 2, 3, 3]\\n    \\n    def magicalString(self, n: int) -> int:\\n        if n < len(Solution.result):\\n            return Solution.result[n]\\n        result = 1\\n        n -= 3\\n        q = deque([True, True], maxlen=n)\\n        while len(q) < n:\\n            d = q.popleft()\\n            n -= 1\\n            result += d\\n            newD = not q[-1]\\n            for j in range(2 - d):\\n                q.append(newD)\\n        while len(q) > n:\\n            q.pop()\\n        return result + sum(q)\\n```",
                "solutionTags": [],
                "code": "```\\n\\nclass Solution:\\n    result = [0, 1, 1, 1, 2, 3, 3]\\n    \\n    def magicalString(self, n: int) -> int:\\n        if n < len(Solution.result):\\n            return Solution.result[n]\\n        result = 1\\n        n -= 3\\n        q = deque([True, True], maxlen=n)\\n        while len(q) < n:\\n            d = q.popleft()\\n            n -= 1\\n            result += d\\n            newD = not q[-1]\\n            for j in range(2 - d):\\n                q.append(newD)\\n        while len(q) > n:\\n            q.pop()\\n        return result + sum(q)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1262944,
                "title": "python-build-the-string-counting-ones-on-the-fly",
                "content": "Runtime: 100 ms, faster than 97.09% of Python3 online submissions for Magical String.\\nMemory Usage: 14.3 MB, less than 94.17% of Python3 online submissions for Magical String.\\n```\\nclass Solution:\\n    def magicalString(self, n: int) -> int:\\n        if n < 4:\\n            return 1\\n        s = \\'122\\'\\n        i = 2\\n        res = 1\\n        while len(s) < n:\\n            if s[i] == \\'2\\':\\n                if s[-1] == \\'1\\':\\n                    s += \\'22\\'\\n                else:\\n                    s += \\'11\\'\\n                    if len(s) > n:\\n                        res += 1\\n                    else:\\n                        res += 2\\n            else: # s[i] == \\'1\\'\\n                if s[-1] == \\'1\\':\\n                    s += \\'2\\'\\n                else:\\n                    s += \\'1\\'\\n                    res += 1\\n            i += 1\\n        return res\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def magicalString(self, n: int) -> int:\\n        if n < 4:\\n            return 1\\n        s = \\'122\\'\\n        i = 2\\n        res = 1\\n        while len(s) < n:\\n            if s[i] == \\'2\\':\\n                if s[-1] == \\'1\\':\\n                    s += \\'22\\'\\n                else:\\n                    s += \\'11\\'\\n                    if len(s) > n:\\n                        res += 1\\n                    else:\\n                        res += 2\\n            else: # s[i] == \\'1\\'\\n                if s[-1] == \\'1\\':\\n                    s += \\'2\\'\\n                else:\\n                    s += \\'1\\'\\n                    res += 1\\n            i += 1\\n        return res\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1248891,
                "title": "intuitive-works",
                "content": "```\\n\\n// when n > 2, it is a simple rule\\n\\nclass Solution {\\npublic:\\n    int magicalString(int n) {\\n        \\n        if (n < 3) {\\n            return 1;\\n        }\\n        \\n        deque<int> dq;\\n        // q.push(1);\\n        // q.push(2);\\n        dq.push_back(2);\\n        n -= 2;\\n        int res = 1;\\n        \\n        while (n) {\\n            auto f = dq.front();\\n            auto b = dq.back();\\n            if (f == 1) {\\n                res++;\\n                if (b == 1) {\\n                    dq.push_back(2);\\n                } else {\\n                    dq.push_back(1);\\n                }\\n            } else {\\n                if (b == 1) {\\n                    dq.push_back(2);\\n                    dq.push_back(2);\\n                } else {\\n                    dq.push_back(1);\\n                    dq.push_back(1);\\n                }\\n            }\\n            dq.pop_front();\\n            n--;\\n        }\\n        \\n        return res;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\n\\n// when n > 2, it is a simple rule\\n\\nclass Solution {\\npublic:\\n    int magicalString(int n) {\\n        \\n        if (n < 3) {\\n            return 1;\\n        }\\n        \\n        deque<int> dq;\\n        // q.push(1);\\n        // q.push(2);\\n        dq.push_back(2);\\n        n -= 2;\\n        int res = 1;\\n        \\n        while (n) {\\n            auto f = dq.front();\\n            auto b = dq.back();\\n            if (f == 1) {\\n                res++;\\n                if (b == 1) {\\n                    dq.push_back(2);\\n                } else {\\n                    dq.push_back(1);\\n                }\\n            } else {\\n                if (b == 1) {\\n                    dq.push_back(2);\\n                    dq.push_back(2);\\n                } else {\\n                    dq.push_back(1);\\n                    dq.push_back(1);\\n                }\\n            }\\n            dq.pop_front();\\n            n--;\\n        }\\n        \\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1207346,
                "title": "javascript-simulation",
                "content": "```\\n/**\\n * @param {number} n\\n * @return {number}\\n */\\nvar magicalString = function(n) {\\n    if (n <= 3) return 1\\n    \\n    \\n    const arr = [1, 2, 2]\\n    let oneCount = 1\\n    \\n    let readFrom = 2\\n    let nextDigit = 1\\n    for (; arr.length < n; readFrom++, nextDigit = 3 - nextDigit) {\\n        const count = arr[readFrom]\\n        for (let i = 0; i < count && arr.length < n; i++) {\\n            arr.push(nextDigit)\\n            if (nextDigit === 1)\\n                oneCount++\\n        }\\n    }\\n    \\n    while (arr.length > n) {\\n        const popped = arr.pop()\\n        if (popped === 1)\\n            oneCount--\\n    }\\n    \\n    \\n    let result = oneCount\\n    return result\\n};\\n```",
                "solutionTags": [],
                "code": "```\\n/**\\n * @param {number} n\\n * @return {number}\\n */\\nvar magicalString = function(n) {\\n    if (n <= 3) return 1\\n    \\n    \\n    const arr = [1, 2, 2]\\n    let oneCount = 1\\n    \\n    let readFrom = 2\\n    let nextDigit = 1\\n    for (; arr.length < n; readFrom++, nextDigit = 3 - nextDigit) {\\n        const count = arr[readFrom]\\n        for (let i = 0; i < count && arr.length < n; i++) {\\n            arr.push(nextDigit)\\n            if (nextDigit === 1)\\n                oneCount++\\n        }\\n    }\\n    \\n    while (arr.length > n) {\\n        const popped = arr.pop()\\n        if (popped === 1)\\n            oneCount--\\n    }\\n    \\n    \\n    let result = oneCount\\n    return result\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1194755,
                "title": "simple-o-n-runtime-and-o-n-space-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    int arr[100002];\\n    Solution() {\\n        \\n        arr[0] = 1;\\n        arr[1] = 2;\\n        arr[2] = 2;\\n        int group = 2;\\n        int i =2;\\n        int prev = 2;\\n        while(i <= 100000) {\\n            \\n            if(arr[group] == 1) {\\n                if(prev == 2) {\\n                    arr[++i] = 1;\\n                    prev = 1;\\n                }\\n                else {\\n                    arr[++i] = 2;\\n                    prev = 2;\\n                }\\n\\n            }\\n            else if(arr[group] == 2) {\\n                if(prev == 2) {\\n                    arr[++i] = 1;\\n                    arr[++i] = 1;\\n                    prev = 1;\\n                }\\n                else {\\n                    arr[++i] = 2;\\n                    arr[++i] = 2;                   \\n                    prev = 2;\\n                }\\n\\n            }\\n         group++;\\n          \\n        }\\n       \\n    }\\n    int magicalString(int n) {\\n         \\n        int cnt = 0;\\n        for(int i=0;i<n;i++)\\n            if(arr[i] == 1)\\n                cnt++;\\n        \\n            return cnt;\\n        \\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int arr[100002];\\n    Solution() {\\n        \\n        arr[0] = 1;\\n        arr[1] = 2;\\n        arr[2] = 2;\\n        int group = 2;\\n        int i =2;\\n        int prev = 2;\\n        while(i <= 100000) {\\n            \\n            if(arr[group] == 1) {\\n                if(prev == 2) {\\n                    arr[++i] = 1;\\n                    prev = 1;\\n                }\\n                else {\\n                    arr[++i] = 2;\\n                    prev = 2;\\n                }\\n\\n            }\\n            else if(arr[group] == 2) {\\n                if(prev == 2) {\\n                    arr[++i] = 1;\\n                    arr[++i] = 1;\\n                    prev = 1;\\n                }\\n                else {\\n                    arr[++i] = 2;\\n                    arr[++i] = 2;                   \\n                    prev = 2;\\n                }\\n\\n            }\\n         group++;\\n          \\n        }\\n       \\n    }\\n    int magicalString(int n) {\\n         \\n        int cnt = 0;\\n        for(int i=0;i<n;i++)\\n            if(arr[i] == 1)\\n                cnt++;\\n        \\n            return cnt;\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1190838,
                "title": "very-simple-logical-java-solution",
                "content": "class Solution {\\n    public int magicalString(int n) {\\n        \\n   StringBuilder s=new StringBuilder(\"122\"); \\n         StringBuilder res=new StringBuilder(\"12\"); \\n        \\n     int i=2;\\n        \\n        while(i<n-1){\\n            \\n           res.append(s.charAt(i));\\n            \\n            if(res.charAt(i)==\\'2\\')\\n            {\\n                if(s.charAt(s.length()-1)==\\'2\\')\\n                s.append(\"11\");\\n                else\\n                  s.append(\"22\");  \\n            }\\n            else if(res.charAt(i)==\\'1\\'){\\n                if(s.charAt(s.length()-1) ==\\'1\\')\\n                s.append(\\'2\\');\\n                else\\n                 s.append(\\'1\\');     \\n            }\\n            \\n            i++;\\n                \\n        }\\n        \\n        int count=0;\\n        for(int j=0;j<n;j++)\\n        {\\n            if(s.charAt(j)==\\'1\\')\\n                count++;\\n        }\\n        \\n        return count;\\n\\n        \\n    }\\n}",
                "solutionTags": [],
                "code": "class Solution {\\n    public int magicalString(int n) {\\n        \\n   StringBuilder s=new StringBuilder(\"122\"); \\n         StringBuilder res=new StringBuilder(\"12\"); \\n        \\n     int i=2;\\n        \\n        while(i<n-1){\\n            \\n           res.append(s.charAt(i));\\n            \\n            if(res.charAt(i)==\\'2\\')\\n            {\\n                if(s.charAt(s.length()-1)==\\'2\\')\\n                s.append(\"11\");\\n                else\\n                  s.append(\"22\");  \\n            }",
                "codeTag": "Java"
            },
            {
                "id": 1147856,
                "title": "c-with-short-explanation",
                "content": "```\\nclass Solution {\\npublic:\\n    int magicalString(int n) {\\n        // We can increase the magical string by looking at the last character as well as the groups \\n        // that are examined so far. For example, we start from index 0 (\\'1\\'), then we need to find\\n        // the next character. It has to be different from \\'1\\' so it will be \\'2\\', and the string becomes\\n        // \"12\", hence the next group must have 2 \\'2\\'s, hence the string will be \"122\".\\n        // Following the steps, each time we use the character at index called \\'group\\' to determine which \\n        // characters (1 or 2) to append to the magical string. There are a few scenarios and it is specified\\n        // in the code below.\\n        if (n <= 1)\\n        {\\n            return n == 1 ? 1 : 0; // base case\\n        }\\n        \\n        int res = 1, group = 1; // result, the index called group\\n        string s{\"1\"}; // initial magical string\\n        while (s.size() < n) // when the size of magical string < n\\n        {\\n            char c = s[s.size() - 1]; // the last character of magical string\\n            if (c == \\'1\\' && (s.size() <= group || s[group] == \\'2\\'))\\n            {\\n                s += \"22\"; // the appended character must be different from the last character\\n            }\\n            else if (c == \\'2\\' && (s.size() <= group || s[group] == \\'1\\'))\\n            {\\n                s += \"1\"; // if s[group] is \\'1\\' or empty, we must append only 1 \\'1\\' \\n                ++res; // update the result\\n            }\\n            else if (c == \\'1\\' && s[group] == \\'1\\')\\n            {\\n                s += \"2\"; // s[group] is the number of \\'2\\'s to be appended\\n            }\\n            else\\n            {\\n                s += \"11\"; // for all other cases, append \\'11\\' and update the result\\n                res += s.size() > n ? 1 : 2;\\n            }\\n            \\n            ++group;\\n        }\\n        \\n        return res;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int magicalString(int n) {\\n        // We can increase the magical string by looking at the last character as well as the groups \\n        // that are examined so far. For example, we start from index 0 (\\'1\\'), then we need to find\\n        // the next character. It has to be different from \\'1\\' so it will be \\'2\\', and the string becomes\\n        // \"12\", hence the next group must have 2 \\'2\\'s, hence the string will be \"122\".\\n        // Following the steps, each time we use the character at index called \\'group\\' to determine which \\n        // characters (1 or 2) to append to the magical string. There are a few scenarios and it is specified\\n        // in the code below.\\n        if (n <= 1)\\n        {\\n            return n == 1 ? 1 : 0; // base case\\n        }\\n        \\n        int res = 1, group = 1; // result, the index called group\\n        string s{\"1\"}; // initial magical string\\n        while (s.size() < n) // when the size of magical string < n\\n        {\\n            char c = s[s.size() - 1]; // the last character of magical string\\n            if (c == \\'1\\' && (s.size() <= group || s[group] == \\'2\\'))\\n            {\\n                s += \"22\"; // the appended character must be different from the last character\\n            }\\n            else if (c == \\'2\\' && (s.size() <= group || s[group] == \\'1\\'))\\n            {\\n                s += \"1\"; // if s[group] is \\'1\\' or empty, we must append only 1 \\'1\\' \\n                ++res; // update the result\\n            }\\n            else if (c == \\'1\\' && s[group] == \\'1\\')\\n            {\\n                s += \"2\"; // s[group] is the number of \\'2\\'s to be appended\\n            }\\n            else\\n            {\\n                s += \"11\"; // for all other cases, append \\'11\\' and update the result\\n                res += s.size() > n ? 1 : 2;\\n            }\\n            \\n            ++group;\\n        }\\n        \\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1131155,
                "title": "c-short-simulation-solution",
                "content": "Run-time is `O(n)`, space is `O(n)`.\\n\\n```\\nclass Solution {\\npublic:\\n    int magicalString(int n) {\\n        string s{\"122\"};\\n        bool one{true};\\n        char a[2] = {\\'1\\', \\'2\\'};\\n        for(int i{2}; s.size() < n; ++i) s += std::string(s[i]-\\'0\\', a[one^=1]);\\n        while(s.size() > n) s.pop_back();\\n        return std::accumulate(s.begin(), s.end(), 0, [](const int a, const int b){return a + (b == \\'1\\');});\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int magicalString(int n) {\\n        string s{\"122\"};\\n        bool one{true};\\n        char a[2] = {\\'1\\', \\'2\\'};\\n        for(int i{2}; s.size() < n; ++i) s += std::string(s[i]-\\'0\\', a[one^=1]);\\n        while(s.size() > n) s.pop_back();\\n        return std::accumulate(s.begin(), s.end(), 0, [](const int a, const int b){return a + (b == \\'1\\');});\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1116862,
                "title": "o-n-space",
                "content": "```\\nclass Solution {\\n    public int magicalString(int n) {\\n        if(n < 1) return 0;\\n        int[] arr = new int[n];\\n        int index = 0, num = 1, res = 0;\\n        for(int i = 0; i < n; i++){\\n            arr[index++] = num;\\n            if(arr[i] == 2 && index <= n - 1){\\n                arr[index++] = num;\\n            }\\n            num = num == 1 ? 2 : 1;\\n            if(index > n - 1) break;\\n        }\\n        for(int i = 0; i < n; i++){\\n            if(arr[i] == 1){\\n                res += arr[i];\\n            }\\n        }\\n        return res;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int magicalString(int n) {\\n        if(n < 1) return 0;\\n        int[] arr = new int[n];\\n        int index = 0, num = 1, res = 0;\\n        for(int i = 0; i < n; i++){\\n            arr[index++] = num;\\n            if(arr[i] == 2 && index <= n - 1){\\n                arr[index++] = num;\\n            }\\n            num = num == 1 ? 2 : 1;\\n            if(index > n - 1) break;\\n        }\\n        for(int i = 0; i < n; i++){\\n            if(arr[i] == 1){\\n                res += arr[i];\\n            }\\n        }\\n        return res;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1099373,
                "title": "simple-c-solution",
                "content": "Here is a very simple C# solution using an array:\\n```\\npublic class Solution {\\n    public int MagicalString(int n)\\n    {\\n        byte[] memo = new byte[n];\\n        int i = 0, x = 0, count = 0;\\n        byte number = 1;\\n\\n        while (i < n)\\n        {\\n            memo[i++] = number;\\n            if (number == 1) count++;\\n            \\n            if(memo[x] == 2 && i < n)\\n            {\\n                memo[i++] = number;\\n                if (number == 1) count++;\\n            }\\n            \\n            number = number == 1 ? (byte)2 : (byte)1;\\n            x++;\\n        }\\n        \\n        return count;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\npublic class Solution {\\n    public int MagicalString(int n)\\n    {\\n        byte[] memo = new byte[n];\\n        int i = 0, x = 0, count = 0;\\n        byte number = 1;\\n\\n        while (i < n)\\n        {\\n            memo[i++] = number;\\n            if (number == 1) count++;\\n            \\n            if(memo[x] == 2 && i < n)\\n            {\\n                memo[i++] = number;\\n                if (number == 1) count++;\\n            }\\n            \\n            number = number == 1 ? (byte)2 : (byte)1;\\n            x++;\\n        }\\n        \\n        return count;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 999636,
                "title": "simple-python-solution-with-some-explanation-step-wise",
                "content": "First let us understand the problem.\\n\\n**Intialisation**\\n\\n1. our number if only formed by 1 or 2\\n2. lets store this number in a list with digits as each seperate object like [1, 2, 2]\\n3. take starting postions  as s1 = [1, 2] and s2 = [1, 2, 2]\\n\\n**Updation**\\n\\n4.  In `S2`, at 3rd position I see `2` so update the `S1`\\n5.  update `s1 = [1, 2]` =>  `s1 = [1, 2, 2]`\\n6.  update `s1` is [1, 2, 2], in S2 **we need 1 group, 2 group,  2 group of consecutive numbers**\\n7.  So `s2 = [1, 2, 2]` ==> `s2 = [1, 2, 2, 1, 1]` \\n8.  In `S2` at 4th postion I see `1` so update `S1`\\n9.  update `s1 = [1, 2, 2]` =>  `s1 = [1, 2, 2, 1]`\\n10.  update  `s2 = [1, 2, 2, 1, 1]`  =>  `s2 = [1, 2, 2, 1, 1, 2]`  **as we need 1 group, 2 group, 2 group, 1 group of consecutive numbers**\\n\\nrepeat above steps and when s2 grows to required size, stop\\n\\nIf you want to understand, please use above alog and solve manually till s2 is 6\\n```\\ns1, s2\\n[1, 2], [1, 2, 2]\\n[1, 2, 2], [1, 2, 2, 1, 1]\\n[1, 2, 2, 1], [1, 2, 2, 1, 1, 2]\\n[1, 2, 2, 1, 1], [1, 2, 2, 1, 1, 2, 1]\\n[1, 2, 2, 1, 1, 2], [1, 2, 2, 1, 1, 2, 1, 2, 2]\\n```\\n\\nHow S2 will expand when you grow it\\n```\\n[1, 2, 2]\\n[1, 2, 2, 1, 1]\\n[1, 2, 2, 1, 1, 2]\\n[1, 2, 2, 1, 1, 2, 1]\\n[1, 2, 2, 1, 1, 2, 1, 2, 2]\\n[1, 2, 2, 1, 1, 2, 1, 2, 2, 1]\\n[1, 2, 2, 1, 1, 2, 1, 2, 2, 1, 2, 2]\\n[1, 2, 2, 1, 1, 2, 1, 2, 2, 1, 2, 2, 1, 1]\\n[1, 2, 2, 1, 1, 2, 1, 2, 2, 1, 2, 2, 1, 1, 2]\\n[1, 2, 2, 1, 1, 2, 1, 2, 2, 1, 2, 2, 1, 1, 2, 1, 1]\\n[1, 2, 2, 1, 1, 2, 1, 2, 2, 1, 2, 2, 1, 1, 2, 1, 1, 2, 2]\\n[1, 2, 2, 1, 1, 2, 1, 2, 2, 1, 2, 2, 1, 1, 2, 1, 1, 2, 2, 1]\\n[1, 2, 2, 1, 1, 2, 1, 2, 2, 1, 2, 2, 1, 1, 2, 1, 1, 2, 2, 1, 2]\\n[1, 2, 2, 1, 1, 2, 1, 2, 2, 1, 2, 2, 1, 1, 2, 1, 1, 2, 2, 1, 2, 1, 1]\\n[1, 2, 2, 1, 1, 2, 1, 2, 2, 1, 2, 2, 1, 1, 2, 1, 1, 2, 2, 1, 2, 1, 1, 2]\\n[1, 2, 2, 1, 1, 2, 1, 2, 2, 1, 2, 2, 1, 1, 2, 1, 1, 2, 2, 1, 2, 1, 1, 2, 1]\\n[1, 2, 2, 1, 1, 2, 1, 2, 2, 1, 2, 2, 1, 1, 2, 1, 1, 2, 2, 1, 2, 1, 1, 2, 1, 2, 2]\\n[1, 2, 2, 1, 1, 2, 1, 2, 2, 1, 2, 2, 1, 1, 2, 1, 1, 2, 2, 1, 2, 1, 1, 2, 1, 2, 2, 1, 1]\\n[1, 2, 2, 1, 1, 2, 1, 2, 2, 1, 2, 2, 1, 1, 2, 1, 1, 2, 2, 1, 2, 1, 1, 2, 1, 2, 2, 1, 1, 2]\\n...\\n```\\n\\n\\nHere is my python solution\\n- initially I used s1 and s2 string like above\\n- post optimisations I use a pointer `self.counter`  so `self.s1[:self.pointer]` will be my first string and `self.s1` will become my second string at any interation.\\n\\n```python\\n\\nclass Solution:\\n    def update_string(self):\\n        key = self.s1[self.counter]\\n        last_key = self.s1[-1]\\n        if last_key == 1:\\n            self.s1 += [2] * key\\n        else:\\n            self.s1 += [1] * key\\n        self.counter += 1\\n        # print(self.s1)\\n    \\n    def magicalString(self, n: int) -> int:\\n        self.s1 = [1, 2, 2]\\n        self.counter = 2\\n        print(self.s1)\\n        while len(self.s1) < n:\\n            self.update_string()\\n        return self.s1[:n].count(1)\\n            \\n```",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\ns1, s2\\n[1, 2], [1, 2, 2]\\n[1, 2, 2], [1, 2, 2, 1, 1]\\n[1, 2, 2, 1], [1, 2, 2, 1, 1, 2]\\n[1, 2, 2, 1, 1], [1, 2, 2, 1, 1, 2, 1]\\n[1, 2, 2, 1, 1, 2], [1, 2, 2, 1, 1, 2, 1, 2, 2]\\n```\n```\\n[1, 2, 2]\\n[1, 2, 2, 1, 1]\\n[1, 2, 2, 1, 1, 2]\\n[1, 2, 2, 1, 1, 2, 1]\\n[1, 2, 2, 1, 1, 2, 1, 2, 2]\\n[1, 2, 2, 1, 1, 2, 1, 2, 2, 1]\\n[1, 2, 2, 1, 1, 2, 1, 2, 2, 1, 2, 2]\\n[1, 2, 2, 1, 1, 2, 1, 2, 2, 1, 2, 2, 1, 1]\\n[1, 2, 2, 1, 1, 2, 1, 2, 2, 1, 2, 2, 1, 1, 2]\\n[1, 2, 2, 1, 1, 2, 1, 2, 2, 1, 2, 2, 1, 1, 2, 1, 1]\\n[1, 2, 2, 1, 1, 2, 1, 2, 2, 1, 2, 2, 1, 1, 2, 1, 1, 2, 2]\\n[1, 2, 2, 1, 1, 2, 1, 2, 2, 1, 2, 2, 1, 1, 2, 1, 1, 2, 2, 1]\\n[1, 2, 2, 1, 1, 2, 1, 2, 2, 1, 2, 2, 1, 1, 2, 1, 1, 2, 2, 1, 2]\\n[1, 2, 2, 1, 1, 2, 1, 2, 2, 1, 2, 2, 1, 1, 2, 1, 1, 2, 2, 1, 2, 1, 1]\\n[1, 2, 2, 1, 1, 2, 1, 2, 2, 1, 2, 2, 1, 1, 2, 1, 1, 2, 2, 1, 2, 1, 1, 2]\\n[1, 2, 2, 1, 1, 2, 1, 2, 2, 1, 2, 2, 1, 1, 2, 1, 1, 2, 2, 1, 2, 1, 1, 2, 1]\\n[1, 2, 2, 1, 1, 2, 1, 2, 2, 1, 2, 2, 1, 1, 2, 1, 1, 2, 2, 1, 2, 1, 1, 2, 1, 2, 2]\\n[1, 2, 2, 1, 1, 2, 1, 2, 2, 1, 2, 2, 1, 1, 2, 1, 1, 2, 2, 1, 2, 1, 1, 2, 1, 2, 2, 1, 1]\\n[1, 2, 2, 1, 1, 2, 1, 2, 2, 1, 2, 2, 1, 1, 2, 1, 1, 2, 2, 1, 2, 1, 1, 2, 1, 2, 2, 1, 1, 2]\\n...\\n```\n```python\\n\\nclass Solution:\\n    def update_string(self):\\n        key = self.s1[self.counter]\\n        last_key = self.s1[-1]\\n        if last_key == 1:\\n            self.s1 += [2] * key\\n        else:\\n            self.s1 += [1] * key\\n        self.counter += 1\\n        # print(self.s1)\\n    \\n    def magicalString(self, n: int) -> int:\\n        self.s1 = [1, 2, 2]\\n        self.counter = 2\\n        print(self.s1)\\n        while len(self.s1) < n:\\n            self.update_string()\\n        return self.s1[:n].count(1)\\n            \\n```",
                "codeTag": "Java"
            },
            {
                "id": 975364,
                "title": "python-easy-to-understand",
                "content": "```\\ndef magicalString(self, n: int) -> int:\\n        if not n: return 0\\n        if 1<=n<=3: return 1\\n        s=\"122\"\\n        while len(s)<=n:\\n            temp=\"\"\\n            for i in range(len(s)):\\n                if i%2==0:\\n                    if s[i]==\\'1\\':\\n                        temp+=\\'1\\'*1\\n                    else:\\n                        temp+=\\'1\\'*2\\n                else:\\n                    if s[i]==\\'1\\':\\n                        temp+=\\'2\\'*1\\n                    else:\\n                        temp+=\\'2\\'*2\\n            s=temp\\n        return s[:n].count(\\'1\\')",
                "solutionTags": [],
                "code": "```\\ndef magicalString(self, n: int) -> int:\\n        if not n: return 0\\n        if 1<=n<=3: return 1\\n        s=\"122\"\\n        while len(s)<=n:\\n            temp=\"\"\\n            for i in range(len(s)):\\n                if i%2==0:\\n                    if s[i]==\\'1\\':\\n                        temp+=\\'1\\'*1\\n                    else:\\n                        temp+=\\'1\\'*2\\n                else:\\n                    if s[i]==\\'1\\':\\n                        temp+=\\'2\\'*1\\n                    else:\\n                        temp+=\\'2\\'*2\\n            s=temp\\n        return s[:n].count(\\'1\\')",
                "codeTag": "Python3"
            },
            {
                "id": 975208,
                "title": "build-string-and-find",
                "content": "\\'\\'\\'\\nclass Solution:\\n    def magicalString(self, n: int) -> int:\\n        s=\\'122112122122112\\'\\n        s1=len(s)\\n        if(n<s1):\\n            return s[:n].count(\\'1\\')\\n        else:\\n            while(s1<n):\\n                s2=\\'\\'\\n                for i in range(0,len(s)):\\n                    if(i%2==0):\\n                        s2+=int(s[i])*\\'1\\'\\n                    else:\\n                        s2+=int(s[i])*\\'2\\'\\n                s=str(s2)\\n                s1=len(s)\\n                #print(d,n,s)\\n            return(s[:n].count(\\'1\\'))\\n  \\'\\'\\'",
                "solutionTags": [],
                "code": "\\'\\'\\'\\nclass Solution:\\n    def magicalString(self, n: int) -> int:\\n        s=\\'122112122122112\\'\\n        s1=len(s)\\n        if(n<s1):\\n            return s[:n].count(\\'1\\')\\n        else:\\n            while(s1<n):\\n                s2=\\'\\'\\n                for i in range(0,len(s)):\\n                    if(i%2==0):\\n                        s2+=int(s[i])*\\'1\\'\\n                    else:\\n                        s2+=int(s[i])*\\'2\\'\\n                s=str(s2)\\n                s1=len(s)\\n                #print(d,n,s)\\n            return(s[:n].count(\\'1\\'))\\n  \\'\\'\\'",
                "codeTag": "Java"
            },
            {
                "id": 975207,
                "title": "python-just-build-the-string",
                "content": "```\\nclass Solution:\\n    def magicalString(self, n: int) -> int:\\n        if 1<=n<=3:return 1\\n        if not n:return 0\\n        s=\"122\"\\n        while len(s)<=n:\\n            temp=\"\"\\n            for i in range(len(s)):\\n                if i%2==0:\\n                    if s[i]==\\'1\\':\\n                        temp+=\\'1\\'*1\\n                    else:\\n                        temp+=\\'1\\'*2\\n                else:\\n                    if s[i]==\\'1\\':\\n                        temp+=\\'2\\'*1\\n                    else:\\n                        temp+=\\'2\\'*2\\n            s=temp\\n        return s[:n].count(\\'1\\')\\n                        \\n            \\n",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def magicalString(self, n: int) -> int:\\n        if 1<=n<=3:return 1\\n        if not n:return 0\\n        s=\"122\"\\n        while len(s)<=n:\\n            temp=\"\"\\n            for i in range(len(s)):\\n                if i%2==0:\\n                    if s[i]==\\'1\\':\\n                        temp+=\\'1\\'*1\\n                    else:\\n                        temp+=\\'1\\'*2\\n                else:\\n                    if s[i]==\\'1\\':\\n                        temp+=\\'2\\'*1\\n                    else:\\n                        temp+=\\'2\\'*2\\n            s=temp\\n        return s[:n].count(\\'1\\')\\n                        \\n            \\n",
                "codeTag": "Java"
            },
            {
                "id": 935700,
                "title": "simple-swift-solution",
                "content": "Simple Swift solution\\n```\\nclass Solution {\\n    func magicalString(_ n: Int) -> Int {\\n        var ones = 0, len = 0, queue = [1, 2, 2], i = 0, turn = 0, next = [Int]()\\n        while len < n {\\n            switch (turn, queue[i]) {\\n                case (0, 1): next = [1]\\n                case (0, 2): next = [1, 1]\\n                case (1, 1): next = [2]\\n                default: next = [2, 2]\\n            }\\n            if turn == 0 { ones += min(queue[i], n - len) }\\n            if i > 1 { queue.append(contentsOf: next) }\\n            len += queue[i]\\n            turn = (turn + 1) % 2\\n            i += 1\\n        }\\n        return ones\\n    }\\n}\\n```",
                "solutionTags": [
                    "Swift"
                ],
                "code": "```\\nclass Solution {\\n    func magicalString(_ n: Int) -> Int {\\n        var ones = 0, len = 0, queue = [1, 2, 2], i = 0, turn = 0, next = [Int]()\\n        while len < n {\\n            switch (turn, queue[i]) {\\n                case (0, 1): next = [1]\\n                case (0, 2): next = [1, 1]\\n                case (1, 1): next = [2]\\n                default: next = [2, 2]\\n            }\\n            if turn == 0 { ones += min(queue[i], n - len) }\\n            if i > 1 { queue.append(contentsOf: next) }\\n            len += queue[i]\\n            turn = (turn + 1) % 2\\n            i += 1\\n        }\\n        return ones\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 891420,
                "title": "simulate-the-problem-with-queue-it-s-simple-to-understand-though-not-the-best-solution",
                "content": "```\\nclass Solution {\\npublic:\\n      int magicalString(int n) {\\n\\t\\t\\tif (n == 0) {\\n\\t\\t\\t\\treturn 0;\\n\\t\\t\\t}\\n\\t\\t\\tint count = 1;\\n\\t\\t\\tif (n <= 3) {\\n\\t\\t\\t\\treturn count;\\n\\t\\t\\t}\\n\\t\\t\\tqueue<int> q;\\n\\t\\t\\tq.push(2);\\n\\t\\t\\tbool isOne= true;\\n\\t\\t\\twhile (!q.empty()) {\\n                int em = q.front();\\n                for (int i = 0; i < em; i++) {\\n                    if (isOne) {\\n                        count++;\\n                        q.push(1);\\n                    }else {\\n                        q.push(2);\\n                    }\\n                    n--;\\n                    if (n == 3) {\\n                        return count;\\n                    }\\n                }\\n\\t\\t\\t\\tisOne = !isOne;\\n                q.pop();\\n\\t\\t\\t}\\n\\t\\t\\treturn count;\\n\\t\\t}\\n};",
                "solutionTags": [],
                "code": "class Solution {\\npublic:\\n      int magicalString(int n) {\\n\\t\\t\\tif (n == 0) {\\n\\t\\t\\t\\treturn 0;\\n\\t\\t\\t}",
                "codeTag": "Java"
            },
            {
                "id": 849493,
                "title": "go",
                "content": "```\\nfunc magicalString(n int) int {\\n    if n == 0 {\\n        return 0\\n    }\\n    s := []byte{\\'1\\', \\'2\\'}\\n    p := 1\\n    res := 1\\n    for i := 2; i < n; i++ {    \\n        c, shift := next(s[len(s) - 2], s[len(s) - 1], s[p])\\n        if c == \\'1\\' {\\n            res++\\n        }\\n        p += shift\\n        s = append(s, c)\\n    }\\n    return res\\n}\\n\\nfunc next(a byte, b byte, p byte) (byte, int) {\\n    if p == \\'1\\' {\\n        return \\'1\\' + \\'2\\' - b, 1\\n    }\\n    if a == b {\\n        return \\'1\\' + \\'2\\' - b, 1\\n    } else {\\n        return b, 0\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nfunc magicalString(n int) int {\\n    if n == 0 {\\n        return 0\\n    }\\n    s := []byte{\\'1\\', \\'2\\'}\\n    p := 1\\n    res := 1\\n    for i := 2; i < n; i++ {    \\n        c, shift := next(s[len(s) - 2], s[len(s) - 1], s[p])\\n        if c == \\'1\\' {\\n            res++\\n        }\\n        p += shift\\n        s = append(s, c)\\n    }\\n    return res\\n}\\n\\nfunc next(a byte, b byte, p byte) (byte, int) {\\n    if p == \\'1\\' {\\n        return \\'1\\' + \\'2\\' - b, 1\\n    }\\n    if a == b {\\n        return \\'1\\' + \\'2\\' - b, 1\\n    } else {\\n        return b, 0\\n    }\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 811261,
                "title": "rust-cheapest-best",
                "content": "```\\nimpl Solution {\\n    pub fn magical_string(n: i32) -> i32 {\\n        let n = n as usize;\\n        let (mut count, mut magical, mut i) = (1, vec![1, 2], 1);\\n        while magical.len() < n {\\n            while count < magical[i] {\\n                magical.push(*magical.last().unwrap());\\n                count += 1;\\n            }\\n            i += 1;\\n            count = 1;\\n            magical.push((magical.last().unwrap() - 3i32).abs());\\n        }\\n\\n        magical.into_iter().take(n).filter(|x| *x == 1).count() as i32\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nimpl Solution {\\n    pub fn magical_string(n: i32) -> i32 {\\n        let n = n as usize;\\n        let (mut count, mut magical, mut i) = (1, vec![1, 2], 1);\\n        while magical.len() < n {\\n            while count < magical[i] {\\n                magical.push(*magical.last().unwrap());\\n                count += 1;\\n            }\\n            i += 1;\\n            count = 1;\\n            magical.push((magical.last().unwrap() - 3i32).abs());\\n        }\\n\\n        magical.into_iter().take(n).filter(|x| *x == 1).count() as i32\\n    }\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 764256,
                "title": "python3-single-pass-straightforward",
                "content": "```\\nclass Solution:\\n    def magicalString(self, n: int) -> int:\\n        if n <= 0:\\n            return 0\\n        \\n        ms = [1, 2, 2]\\n        shift = {1: 2, 2: 1}\\n        one_count = 1\\n                \\n        i = 2\\n        # Build the string up to n, and sometimes a bit more\\n        while len(ms) < n:\\n            ms += [ shift[ms[-1]] ] * ms[i]\\n            one_count += ms[i] if ms[-1] == 1 else 0\\n            \\n            i += 1\\n        \\n        # If we\\'ve overshot by a bit, tidy up the count\\n        while n < len(ms):\\n            one_count -= 1 if ms[n] == 1 else 0\\n            \\n            n += 1\\n        \\n        return one_count\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def magicalString(self, n: int) -> int:\\n        if n <= 0:\\n            return 0\\n        \\n        ms = [1, 2, 2]\\n        shift = {1: 2, 2: 1}\\n        one_count = 1\\n                \\n        i = 2\\n        # Build the string up to n, and sometimes a bit more\\n        while len(ms) < n:\\n            ms += [ shift[ms[-1]] ] * ms[i]\\n            one_count += ms[i] if ms[-1] == 1 else 0\\n            \\n            i += 1\\n        \\n        # If we\\'ve overshot by a bit, tidy up the count\\n        while n < len(ms):\\n            one_count -= 1 if ms[n] == 1 else 0\\n            \\n            n += 1\\n        \\n        return one_count\\n```",
                "codeTag": "Java"
            }
        ],
        "discussions": [
            {
                "id": 1778185,
                "content": [
                    {
                        "username": "godshiva",
                        "content": "I have done 865 problems at the time of writing this comment.  This is, by far, the least comprehensible problem I\\'ve encountered. I LITERALLY have no idea what it is asking me to do."
                    },
                    {
                        "username": "arushadabalar",
                        "content": "[@martynov-94](/martynov-94) Thanks this was actually really helpful in understanding the problem"
                    },
                    {
                        "username": "martynov-94",
                        "content": "You should start with the string \"122\". str[2] === 2, so you append two \"1\" to this string. \\nNow you have string \"12211\". str[3] === 1, so you append one \"2\" to it.\\nYou have \"122112\". str[4] === 1, you append one \"1\".\\nAnd so on, until str.length === n. After this you need to count the number of \"1\" in the string. "
                    },
                    {
                        "username": "xiaoboluo",
                        "content": "Based on the rule, if start with 2, I can get string:\\n2211212212211....\\n\\nCompare with the one in the problem 1**2211212212211**...., it removes the prefix 1.\\n\\nIf that is correct, for some N  like 5, then the answer will be different depending on which one we are referring to."
                    },
                    {
                        "username": "Ebad1001",
                        "content": "I though the same thing. The answers match for n = 6, but not for n = 1.\\nIn that case I guess we need to refer the string given in the problem description (i.e. the one starting with 1)."
                    },
                    {
                        "username": "Jeetaksh",
                        "content": "The problem description can\\'t be any worse."
                    },
                    {
                        "username": "chosen0ne",
                        "content": "S = \\'221121221...\\'\\n22 11 2 1 22 1\\n2 2 1 1 2 1\\n\\n\\n"
                    },
                    {
                        "username": "yeedaKing",
                        "content": "It\\'s not that hard once you actually realize what the prompt is asking you to do.... understanding the description is the hardest part!"
                    },
                    {
                        "username": "saadkhan123456789",
                        "content": "Entropy of the question is way to high......."
                    },
                    {
                        "username": "rishavranjan1821",
                        "content": "You sound like an mechanical engineer"
                    },
                    {
                        "username": "adityaKpatel",
                        "content": "2 months ago, I was not able to understand the language of problem but today I was able  identify the pattern, guess I am improving\\uD83D\\uDE0E"
                    },
                    {
                        "username": "adityaKpatel",
                        "content": "Guess what,  submitted the solution.\\n\\nhttps://leetcode.com/problems/magical-string/solutions/3713545/my-java-solution-easy-to-understand/"
                    },
                    {
                        "username": "kushalnagwanshicloud",
                        "content": "I read this question a month - two months ago, but was not able to do it, or even fully grasp the question, today I did it in mere 10 minutes. \\nI am definitely improving, I guess. "
                    },
                    {
                        "username": "parmarakshat111",
                        "content": "how did you identify the pattern ,please can you share your thought process it would bw a great help."
                    },
                    {
                        "username": "chinmaysk_19",
                        "content": "We can make the string using first three digits only \"122\""
                    },
                    {
                        "username": "Ebad1001",
                        "content": "[@cswartzell](/cswartzell) There are only two magical strings possible, not many"
                    },
                    {
                        "username": "cswartzell",
                        "content": "But there are multiple magic strings possible. This is worded as if its going to give you S but it doesnt. \"22112...\"  could be a valid magical string. So there is NO answer without a defined S"
                    },
                    {
                        "username": "user8228j",
                        "content": "was impossible for me without this tip, and the assumption that there can only be at most two \\'1\\'s or \\'2\\'s in a row.\\nMeaning 122 -> 1 22 -> 1 2 -> 1 22 11 or 1 22 22 has to be 1 22 11."
                    },
                    {
                        "username": "pandeynikhil8",
                        "content": "Identify Pattern and also we need to return number of 1s.\\n\\nhint\\n\\n1,2 used alternatively and repeat frequency is last char in current string"
                    }
                ]
            },
            {
                "id": 1565142,
                "content": [
                    {
                        "username": "godshiva",
                        "content": "I have done 865 problems at the time of writing this comment.  This is, by far, the least comprehensible problem I\\'ve encountered. I LITERALLY have no idea what it is asking me to do."
                    },
                    {
                        "username": "arushadabalar",
                        "content": "[@martynov-94](/martynov-94) Thanks this was actually really helpful in understanding the problem"
                    },
                    {
                        "username": "martynov-94",
                        "content": "You should start with the string \"122\". str[2] === 2, so you append two \"1\" to this string. \\nNow you have string \"12211\". str[3] === 1, so you append one \"2\" to it.\\nYou have \"122112\". str[4] === 1, you append one \"1\".\\nAnd so on, until str.length === n. After this you need to count the number of \"1\" in the string. "
                    },
                    {
                        "username": "xiaoboluo",
                        "content": "Based on the rule, if start with 2, I can get string:\\n2211212212211....\\n\\nCompare with the one in the problem 1**2211212212211**...., it removes the prefix 1.\\n\\nIf that is correct, for some N  like 5, then the answer will be different depending on which one we are referring to."
                    },
                    {
                        "username": "Ebad1001",
                        "content": "I though the same thing. The answers match for n = 6, but not for n = 1.\\nIn that case I guess we need to refer the string given in the problem description (i.e. the one starting with 1)."
                    },
                    {
                        "username": "Jeetaksh",
                        "content": "The problem description can\\'t be any worse."
                    },
                    {
                        "username": "chosen0ne",
                        "content": "S = \\'221121221...\\'\\n22 11 2 1 22 1\\n2 2 1 1 2 1\\n\\n\\n"
                    },
                    {
                        "username": "yeedaKing",
                        "content": "It\\'s not that hard once you actually realize what the prompt is asking you to do.... understanding the description is the hardest part!"
                    },
                    {
                        "username": "saadkhan123456789",
                        "content": "Entropy of the question is way to high......."
                    },
                    {
                        "username": "rishavranjan1821",
                        "content": "You sound like an mechanical engineer"
                    },
                    {
                        "username": "adityaKpatel",
                        "content": "2 months ago, I was not able to understand the language of problem but today I was able  identify the pattern, guess I am improving\\uD83D\\uDE0E"
                    },
                    {
                        "username": "adityaKpatel",
                        "content": "Guess what,  submitted the solution.\\n\\nhttps://leetcode.com/problems/magical-string/solutions/3713545/my-java-solution-easy-to-understand/"
                    },
                    {
                        "username": "kushalnagwanshicloud",
                        "content": "I read this question a month - two months ago, but was not able to do it, or even fully grasp the question, today I did it in mere 10 minutes. \\nI am definitely improving, I guess. "
                    },
                    {
                        "username": "parmarakshat111",
                        "content": "how did you identify the pattern ,please can you share your thought process it would bw a great help."
                    },
                    {
                        "username": "chinmaysk_19",
                        "content": "We can make the string using first three digits only \"122\""
                    },
                    {
                        "username": "Ebad1001",
                        "content": "[@cswartzell](/cswartzell) There are only two magical strings possible, not many"
                    },
                    {
                        "username": "cswartzell",
                        "content": "But there are multiple magic strings possible. This is worded as if its going to give you S but it doesnt. \"22112...\"  could be a valid magical string. So there is NO answer without a defined S"
                    },
                    {
                        "username": "user8228j",
                        "content": "was impossible for me without this tip, and the assumption that there can only be at most two \\'1\\'s or \\'2\\'s in a row.\\nMeaning 122 -> 1 22 -> 1 2 -> 1 22 11 or 1 22 22 has to be 1 22 11."
                    },
                    {
                        "username": "pandeynikhil8",
                        "content": "Identify Pattern and also we need to return number of 1s.\\n\\nhint\\n\\n1,2 used alternatively and repeat frequency is last char in current string"
                    }
                ]
            },
            {
                "id": 1913928,
                "content": [
                    {
                        "username": "godshiva",
                        "content": "I have done 865 problems at the time of writing this comment.  This is, by far, the least comprehensible problem I\\'ve encountered. I LITERALLY have no idea what it is asking me to do."
                    },
                    {
                        "username": "arushadabalar",
                        "content": "[@martynov-94](/martynov-94) Thanks this was actually really helpful in understanding the problem"
                    },
                    {
                        "username": "martynov-94",
                        "content": "You should start with the string \"122\". str[2] === 2, so you append two \"1\" to this string. \\nNow you have string \"12211\". str[3] === 1, so you append one \"2\" to it.\\nYou have \"122112\". str[4] === 1, you append one \"1\".\\nAnd so on, until str.length === n. After this you need to count the number of \"1\" in the string. "
                    },
                    {
                        "username": "xiaoboluo",
                        "content": "Based on the rule, if start with 2, I can get string:\\n2211212212211....\\n\\nCompare with the one in the problem 1**2211212212211**...., it removes the prefix 1.\\n\\nIf that is correct, for some N  like 5, then the answer will be different depending on which one we are referring to."
                    },
                    {
                        "username": "Ebad1001",
                        "content": "I though the same thing. The answers match for n = 6, but not for n = 1.\\nIn that case I guess we need to refer the string given in the problem description (i.e. the one starting with 1)."
                    },
                    {
                        "username": "Jeetaksh",
                        "content": "The problem description can\\'t be any worse."
                    },
                    {
                        "username": "chosen0ne",
                        "content": "S = \\'221121221...\\'\\n22 11 2 1 22 1\\n2 2 1 1 2 1\\n\\n\\n"
                    },
                    {
                        "username": "yeedaKing",
                        "content": "It\\'s not that hard once you actually realize what the prompt is asking you to do.... understanding the description is the hardest part!"
                    },
                    {
                        "username": "saadkhan123456789",
                        "content": "Entropy of the question is way to high......."
                    },
                    {
                        "username": "rishavranjan1821",
                        "content": "You sound like an mechanical engineer"
                    },
                    {
                        "username": "adityaKpatel",
                        "content": "2 months ago, I was not able to understand the language of problem but today I was able  identify the pattern, guess I am improving\\uD83D\\uDE0E"
                    },
                    {
                        "username": "adityaKpatel",
                        "content": "Guess what,  submitted the solution.\\n\\nhttps://leetcode.com/problems/magical-string/solutions/3713545/my-java-solution-easy-to-understand/"
                    },
                    {
                        "username": "kushalnagwanshicloud",
                        "content": "I read this question a month - two months ago, but was not able to do it, or even fully grasp the question, today I did it in mere 10 minutes. \\nI am definitely improving, I guess. "
                    },
                    {
                        "username": "parmarakshat111",
                        "content": "how did you identify the pattern ,please can you share your thought process it would bw a great help."
                    },
                    {
                        "username": "chinmaysk_19",
                        "content": "We can make the string using first three digits only \"122\""
                    },
                    {
                        "username": "Ebad1001",
                        "content": "[@cswartzell](/cswartzell) There are only two magical strings possible, not many"
                    },
                    {
                        "username": "cswartzell",
                        "content": "But there are multiple magic strings possible. This is worded as if its going to give you S but it doesnt. \"22112...\"  could be a valid magical string. So there is NO answer without a defined S"
                    },
                    {
                        "username": "user8228j",
                        "content": "was impossible for me without this tip, and the assumption that there can only be at most two \\'1\\'s or \\'2\\'s in a row.\\nMeaning 122 -> 1 22 -> 1 2 -> 1 22 11 or 1 22 22 has to be 1 22 11."
                    },
                    {
                        "username": "pandeynikhil8",
                        "content": "Identify Pattern and also we need to return number of 1s.\\n\\nhint\\n\\n1,2 used alternatively and repeat frequency is last char in current string"
                    }
                ]
            },
            {
                "id": 1569927,
                "content": [
                    {
                        "username": "godshiva",
                        "content": "I have done 865 problems at the time of writing this comment.  This is, by far, the least comprehensible problem I\\'ve encountered. I LITERALLY have no idea what it is asking me to do."
                    },
                    {
                        "username": "arushadabalar",
                        "content": "[@martynov-94](/martynov-94) Thanks this was actually really helpful in understanding the problem"
                    },
                    {
                        "username": "martynov-94",
                        "content": "You should start with the string \"122\". str[2] === 2, so you append two \"1\" to this string. \\nNow you have string \"12211\". str[3] === 1, so you append one \"2\" to it.\\nYou have \"122112\". str[4] === 1, you append one \"1\".\\nAnd so on, until str.length === n. After this you need to count the number of \"1\" in the string. "
                    },
                    {
                        "username": "xiaoboluo",
                        "content": "Based on the rule, if start with 2, I can get string:\\n2211212212211....\\n\\nCompare with the one in the problem 1**2211212212211**...., it removes the prefix 1.\\n\\nIf that is correct, for some N  like 5, then the answer will be different depending on which one we are referring to."
                    },
                    {
                        "username": "Ebad1001",
                        "content": "I though the same thing. The answers match for n = 6, but not for n = 1.\\nIn that case I guess we need to refer the string given in the problem description (i.e. the one starting with 1)."
                    },
                    {
                        "username": "Jeetaksh",
                        "content": "The problem description can\\'t be any worse."
                    },
                    {
                        "username": "chosen0ne",
                        "content": "S = \\'221121221...\\'\\n22 11 2 1 22 1\\n2 2 1 1 2 1\\n\\n\\n"
                    },
                    {
                        "username": "yeedaKing",
                        "content": "It\\'s not that hard once you actually realize what the prompt is asking you to do.... understanding the description is the hardest part!"
                    },
                    {
                        "username": "saadkhan123456789",
                        "content": "Entropy of the question is way to high......."
                    },
                    {
                        "username": "rishavranjan1821",
                        "content": "You sound like an mechanical engineer"
                    },
                    {
                        "username": "adityaKpatel",
                        "content": "2 months ago, I was not able to understand the language of problem but today I was able  identify the pattern, guess I am improving\\uD83D\\uDE0E"
                    },
                    {
                        "username": "adityaKpatel",
                        "content": "Guess what,  submitted the solution.\\n\\nhttps://leetcode.com/problems/magical-string/solutions/3713545/my-java-solution-easy-to-understand/"
                    },
                    {
                        "username": "kushalnagwanshicloud",
                        "content": "I read this question a month - two months ago, but was not able to do it, or even fully grasp the question, today I did it in mere 10 minutes. \\nI am definitely improving, I guess. "
                    },
                    {
                        "username": "parmarakshat111",
                        "content": "how did you identify the pattern ,please can you share your thought process it would bw a great help."
                    },
                    {
                        "username": "chinmaysk_19",
                        "content": "We can make the string using first three digits only \"122\""
                    },
                    {
                        "username": "Ebad1001",
                        "content": "[@cswartzell](/cswartzell) There are only two magical strings possible, not many"
                    },
                    {
                        "username": "cswartzell",
                        "content": "But there are multiple magic strings possible. This is worded as if its going to give you S but it doesnt. \"22112...\"  could be a valid magical string. So there is NO answer without a defined S"
                    },
                    {
                        "username": "user8228j",
                        "content": "was impossible for me without this tip, and the assumption that there can only be at most two \\'1\\'s or \\'2\\'s in a row.\\nMeaning 122 -> 1 22 -> 1 2 -> 1 22 11 or 1 22 22 has to be 1 22 11."
                    },
                    {
                        "username": "pandeynikhil8",
                        "content": "Identify Pattern and also we need to return number of 1s.\\n\\nhint\\n\\n1,2 used alternatively and repeat frequency is last char in current string"
                    }
                ]
            },
            {
                "id": 1999372,
                "content": [
                    {
                        "username": "godshiva",
                        "content": "I have done 865 problems at the time of writing this comment.  This is, by far, the least comprehensible problem I\\'ve encountered. I LITERALLY have no idea what it is asking me to do."
                    },
                    {
                        "username": "arushadabalar",
                        "content": "[@martynov-94](/martynov-94) Thanks this was actually really helpful in understanding the problem"
                    },
                    {
                        "username": "martynov-94",
                        "content": "You should start with the string \"122\". str[2] === 2, so you append two \"1\" to this string. \\nNow you have string \"12211\". str[3] === 1, so you append one \"2\" to it.\\nYou have \"122112\". str[4] === 1, you append one \"1\".\\nAnd so on, until str.length === n. After this you need to count the number of \"1\" in the string. "
                    },
                    {
                        "username": "xiaoboluo",
                        "content": "Based on the rule, if start with 2, I can get string:\\n2211212212211....\\n\\nCompare with the one in the problem 1**2211212212211**...., it removes the prefix 1.\\n\\nIf that is correct, for some N  like 5, then the answer will be different depending on which one we are referring to."
                    },
                    {
                        "username": "Ebad1001",
                        "content": "I though the same thing. The answers match for n = 6, but not for n = 1.\\nIn that case I guess we need to refer the string given in the problem description (i.e. the one starting with 1)."
                    },
                    {
                        "username": "Jeetaksh",
                        "content": "The problem description can\\'t be any worse."
                    },
                    {
                        "username": "chosen0ne",
                        "content": "S = \\'221121221...\\'\\n22 11 2 1 22 1\\n2 2 1 1 2 1\\n\\n\\n"
                    },
                    {
                        "username": "yeedaKing",
                        "content": "It\\'s not that hard once you actually realize what the prompt is asking you to do.... understanding the description is the hardest part!"
                    },
                    {
                        "username": "saadkhan123456789",
                        "content": "Entropy of the question is way to high......."
                    },
                    {
                        "username": "rishavranjan1821",
                        "content": "You sound like an mechanical engineer"
                    },
                    {
                        "username": "adityaKpatel",
                        "content": "2 months ago, I was not able to understand the language of problem but today I was able  identify the pattern, guess I am improving\\uD83D\\uDE0E"
                    },
                    {
                        "username": "adityaKpatel",
                        "content": "Guess what,  submitted the solution.\\n\\nhttps://leetcode.com/problems/magical-string/solutions/3713545/my-java-solution-easy-to-understand/"
                    },
                    {
                        "username": "kushalnagwanshicloud",
                        "content": "I read this question a month - two months ago, but was not able to do it, or even fully grasp the question, today I did it in mere 10 minutes. \\nI am definitely improving, I guess. "
                    },
                    {
                        "username": "parmarakshat111",
                        "content": "how did you identify the pattern ,please can you share your thought process it would bw a great help."
                    },
                    {
                        "username": "chinmaysk_19",
                        "content": "We can make the string using first three digits only \"122\""
                    },
                    {
                        "username": "Ebad1001",
                        "content": "[@cswartzell](/cswartzell) There are only two magical strings possible, not many"
                    },
                    {
                        "username": "cswartzell",
                        "content": "But there are multiple magic strings possible. This is worded as if its going to give you S but it doesnt. \"22112...\"  could be a valid magical string. So there is NO answer without a defined S"
                    },
                    {
                        "username": "user8228j",
                        "content": "was impossible for me without this tip, and the assumption that there can only be at most two \\'1\\'s or \\'2\\'s in a row.\\nMeaning 122 -> 1 22 -> 1 2 -> 1 22 11 or 1 22 22 has to be 1 22 11."
                    },
                    {
                        "username": "pandeynikhil8",
                        "content": "Identify Pattern and also we need to return number of 1s.\\n\\nhint\\n\\n1,2 used alternatively and repeat frequency is last char in current string"
                    }
                ]
            },
            {
                "id": 1949285,
                "content": [
                    {
                        "username": "godshiva",
                        "content": "I have done 865 problems at the time of writing this comment.  This is, by far, the least comprehensible problem I\\'ve encountered. I LITERALLY have no idea what it is asking me to do."
                    },
                    {
                        "username": "arushadabalar",
                        "content": "[@martynov-94](/martynov-94) Thanks this was actually really helpful in understanding the problem"
                    },
                    {
                        "username": "martynov-94",
                        "content": "You should start with the string \"122\". str[2] === 2, so you append two \"1\" to this string. \\nNow you have string \"12211\". str[3] === 1, so you append one \"2\" to it.\\nYou have \"122112\". str[4] === 1, you append one \"1\".\\nAnd so on, until str.length === n. After this you need to count the number of \"1\" in the string. "
                    },
                    {
                        "username": "xiaoboluo",
                        "content": "Based on the rule, if start with 2, I can get string:\\n2211212212211....\\n\\nCompare with the one in the problem 1**2211212212211**...., it removes the prefix 1.\\n\\nIf that is correct, for some N  like 5, then the answer will be different depending on which one we are referring to."
                    },
                    {
                        "username": "Ebad1001",
                        "content": "I though the same thing. The answers match for n = 6, but not for n = 1.\\nIn that case I guess we need to refer the string given in the problem description (i.e. the one starting with 1)."
                    },
                    {
                        "username": "Jeetaksh",
                        "content": "The problem description can\\'t be any worse."
                    },
                    {
                        "username": "chosen0ne",
                        "content": "S = \\'221121221...\\'\\n22 11 2 1 22 1\\n2 2 1 1 2 1\\n\\n\\n"
                    },
                    {
                        "username": "yeedaKing",
                        "content": "It\\'s not that hard once you actually realize what the prompt is asking you to do.... understanding the description is the hardest part!"
                    },
                    {
                        "username": "saadkhan123456789",
                        "content": "Entropy of the question is way to high......."
                    },
                    {
                        "username": "rishavranjan1821",
                        "content": "You sound like an mechanical engineer"
                    },
                    {
                        "username": "adityaKpatel",
                        "content": "2 months ago, I was not able to understand the language of problem but today I was able  identify the pattern, guess I am improving\\uD83D\\uDE0E"
                    },
                    {
                        "username": "adityaKpatel",
                        "content": "Guess what,  submitted the solution.\\n\\nhttps://leetcode.com/problems/magical-string/solutions/3713545/my-java-solution-easy-to-understand/"
                    },
                    {
                        "username": "kushalnagwanshicloud",
                        "content": "I read this question a month - two months ago, but was not able to do it, or even fully grasp the question, today I did it in mere 10 minutes. \\nI am definitely improving, I guess. "
                    },
                    {
                        "username": "parmarakshat111",
                        "content": "how did you identify the pattern ,please can you share your thought process it would bw a great help."
                    },
                    {
                        "username": "chinmaysk_19",
                        "content": "We can make the string using first three digits only \"122\""
                    },
                    {
                        "username": "Ebad1001",
                        "content": "[@cswartzell](/cswartzell) There are only two magical strings possible, not many"
                    },
                    {
                        "username": "cswartzell",
                        "content": "But there are multiple magic strings possible. This is worded as if its going to give you S but it doesnt. \"22112...\"  could be a valid magical string. So there is NO answer without a defined S"
                    },
                    {
                        "username": "user8228j",
                        "content": "was impossible for me without this tip, and the assumption that there can only be at most two \\'1\\'s or \\'2\\'s in a row.\\nMeaning 122 -> 1 22 -> 1 2 -> 1 22 11 or 1 22 22 has to be 1 22 11."
                    },
                    {
                        "username": "pandeynikhil8",
                        "content": "Identify Pattern and also we need to return number of 1s.\\n\\nhint\\n\\n1,2 used alternatively and repeat frequency is last char in current string"
                    }
                ]
            },
            {
                "id": 1954821,
                "content": [
                    {
                        "username": "godshiva",
                        "content": "I have done 865 problems at the time of writing this comment.  This is, by far, the least comprehensible problem I\\'ve encountered. I LITERALLY have no idea what it is asking me to do."
                    },
                    {
                        "username": "arushadabalar",
                        "content": "[@martynov-94](/martynov-94) Thanks this was actually really helpful in understanding the problem"
                    },
                    {
                        "username": "martynov-94",
                        "content": "You should start with the string \"122\". str[2] === 2, so you append two \"1\" to this string. \\nNow you have string \"12211\". str[3] === 1, so you append one \"2\" to it.\\nYou have \"122112\". str[4] === 1, you append one \"1\".\\nAnd so on, until str.length === n. After this you need to count the number of \"1\" in the string. "
                    },
                    {
                        "username": "xiaoboluo",
                        "content": "Based on the rule, if start with 2, I can get string:\\n2211212212211....\\n\\nCompare with the one in the problem 1**2211212212211**...., it removes the prefix 1.\\n\\nIf that is correct, for some N  like 5, then the answer will be different depending on which one we are referring to."
                    },
                    {
                        "username": "Ebad1001",
                        "content": "I though the same thing. The answers match for n = 6, but not for n = 1.\\nIn that case I guess we need to refer the string given in the problem description (i.e. the one starting with 1)."
                    },
                    {
                        "username": "Jeetaksh",
                        "content": "The problem description can\\'t be any worse."
                    },
                    {
                        "username": "chosen0ne",
                        "content": "S = \\'221121221...\\'\\n22 11 2 1 22 1\\n2 2 1 1 2 1\\n\\n\\n"
                    },
                    {
                        "username": "yeedaKing",
                        "content": "It\\'s not that hard once you actually realize what the prompt is asking you to do.... understanding the description is the hardest part!"
                    },
                    {
                        "username": "saadkhan123456789",
                        "content": "Entropy of the question is way to high......."
                    },
                    {
                        "username": "rishavranjan1821",
                        "content": "You sound like an mechanical engineer"
                    },
                    {
                        "username": "adityaKpatel",
                        "content": "2 months ago, I was not able to understand the language of problem but today I was able  identify the pattern, guess I am improving\\uD83D\\uDE0E"
                    },
                    {
                        "username": "adityaKpatel",
                        "content": "Guess what,  submitted the solution.\\n\\nhttps://leetcode.com/problems/magical-string/solutions/3713545/my-java-solution-easy-to-understand/"
                    },
                    {
                        "username": "kushalnagwanshicloud",
                        "content": "I read this question a month - two months ago, but was not able to do it, or even fully grasp the question, today I did it in mere 10 minutes. \\nI am definitely improving, I guess. "
                    },
                    {
                        "username": "parmarakshat111",
                        "content": "how did you identify the pattern ,please can you share your thought process it would bw a great help."
                    },
                    {
                        "username": "chinmaysk_19",
                        "content": "We can make the string using first three digits only \"122\""
                    },
                    {
                        "username": "Ebad1001",
                        "content": "[@cswartzell](/cswartzell) There are only two magical strings possible, not many"
                    },
                    {
                        "username": "cswartzell",
                        "content": "But there are multiple magic strings possible. This is worded as if its going to give you S but it doesnt. \"22112...\"  could be a valid magical string. So there is NO answer without a defined S"
                    },
                    {
                        "username": "user8228j",
                        "content": "was impossible for me without this tip, and the assumption that there can only be at most two \\'1\\'s or \\'2\\'s in a row.\\nMeaning 122 -> 1 22 -> 1 2 -> 1 22 11 or 1 22 22 has to be 1 22 11."
                    },
                    {
                        "username": "pandeynikhil8",
                        "content": "Identify Pattern and also we need to return number of 1s.\\n\\nhint\\n\\n1,2 used alternatively and repeat frequency is last char in current string"
                    }
                ]
            },
            {
                "id": 1827060,
                "content": [
                    {
                        "username": "godshiva",
                        "content": "I have done 865 problems at the time of writing this comment.  This is, by far, the least comprehensible problem I\\'ve encountered. I LITERALLY have no idea what it is asking me to do."
                    },
                    {
                        "username": "arushadabalar",
                        "content": "[@martynov-94](/martynov-94) Thanks this was actually really helpful in understanding the problem"
                    },
                    {
                        "username": "martynov-94",
                        "content": "You should start with the string \"122\". str[2] === 2, so you append two \"1\" to this string. \\nNow you have string \"12211\". str[3] === 1, so you append one \"2\" to it.\\nYou have \"122112\". str[4] === 1, you append one \"1\".\\nAnd so on, until str.length === n. After this you need to count the number of \"1\" in the string. "
                    },
                    {
                        "username": "xiaoboluo",
                        "content": "Based on the rule, if start with 2, I can get string:\\n2211212212211....\\n\\nCompare with the one in the problem 1**2211212212211**...., it removes the prefix 1.\\n\\nIf that is correct, for some N  like 5, then the answer will be different depending on which one we are referring to."
                    },
                    {
                        "username": "Ebad1001",
                        "content": "I though the same thing. The answers match for n = 6, but not for n = 1.\\nIn that case I guess we need to refer the string given in the problem description (i.e. the one starting with 1)."
                    },
                    {
                        "username": "Jeetaksh",
                        "content": "The problem description can\\'t be any worse."
                    },
                    {
                        "username": "chosen0ne",
                        "content": "S = \\'221121221...\\'\\n22 11 2 1 22 1\\n2 2 1 1 2 1\\n\\n\\n"
                    },
                    {
                        "username": "yeedaKing",
                        "content": "It\\'s not that hard once you actually realize what the prompt is asking you to do.... understanding the description is the hardest part!"
                    },
                    {
                        "username": "saadkhan123456789",
                        "content": "Entropy of the question is way to high......."
                    },
                    {
                        "username": "rishavranjan1821",
                        "content": "You sound like an mechanical engineer"
                    },
                    {
                        "username": "adityaKpatel",
                        "content": "2 months ago, I was not able to understand the language of problem but today I was able  identify the pattern, guess I am improving\\uD83D\\uDE0E"
                    },
                    {
                        "username": "adityaKpatel",
                        "content": "Guess what,  submitted the solution.\\n\\nhttps://leetcode.com/problems/magical-string/solutions/3713545/my-java-solution-easy-to-understand/"
                    },
                    {
                        "username": "kushalnagwanshicloud",
                        "content": "I read this question a month - two months ago, but was not able to do it, or even fully grasp the question, today I did it in mere 10 minutes. \\nI am definitely improving, I guess. "
                    },
                    {
                        "username": "parmarakshat111",
                        "content": "how did you identify the pattern ,please can you share your thought process it would bw a great help."
                    },
                    {
                        "username": "chinmaysk_19",
                        "content": "We can make the string using first three digits only \"122\""
                    },
                    {
                        "username": "Ebad1001",
                        "content": "[@cswartzell](/cswartzell) There are only two magical strings possible, not many"
                    },
                    {
                        "username": "cswartzell",
                        "content": "But there are multiple magic strings possible. This is worded as if its going to give you S but it doesnt. \"22112...\"  could be a valid magical string. So there is NO answer without a defined S"
                    },
                    {
                        "username": "user8228j",
                        "content": "was impossible for me without this tip, and the assumption that there can only be at most two \\'1\\'s or \\'2\\'s in a row.\\nMeaning 122 -> 1 22 -> 1 2 -> 1 22 11 or 1 22 22 has to be 1 22 11."
                    },
                    {
                        "username": "pandeynikhil8",
                        "content": "Identify Pattern and also we need to return number of 1s.\\n\\nhint\\n\\n1,2 used alternatively and repeat frequency is last char in current string"
                    }
                ]
            },
            {
                "id": 1757830,
                "content": [
                    {
                        "username": "godshiva",
                        "content": "I have done 865 problems at the time of writing this comment.  This is, by far, the least comprehensible problem I\\'ve encountered. I LITERALLY have no idea what it is asking me to do."
                    },
                    {
                        "username": "arushadabalar",
                        "content": "[@martynov-94](/martynov-94) Thanks this was actually really helpful in understanding the problem"
                    },
                    {
                        "username": "martynov-94",
                        "content": "You should start with the string \"122\". str[2] === 2, so you append two \"1\" to this string. \\nNow you have string \"12211\". str[3] === 1, so you append one \"2\" to it.\\nYou have \"122112\". str[4] === 1, you append one \"1\".\\nAnd so on, until str.length === n. After this you need to count the number of \"1\" in the string. "
                    },
                    {
                        "username": "xiaoboluo",
                        "content": "Based on the rule, if start with 2, I can get string:\\n2211212212211....\\n\\nCompare with the one in the problem 1**2211212212211**...., it removes the prefix 1.\\n\\nIf that is correct, for some N  like 5, then the answer will be different depending on which one we are referring to."
                    },
                    {
                        "username": "Ebad1001",
                        "content": "I though the same thing. The answers match for n = 6, but not for n = 1.\\nIn that case I guess we need to refer the string given in the problem description (i.e. the one starting with 1)."
                    },
                    {
                        "username": "Jeetaksh",
                        "content": "The problem description can\\'t be any worse."
                    },
                    {
                        "username": "chosen0ne",
                        "content": "S = \\'221121221...\\'\\n22 11 2 1 22 1\\n2 2 1 1 2 1\\n\\n\\n"
                    },
                    {
                        "username": "yeedaKing",
                        "content": "It\\'s not that hard once you actually realize what the prompt is asking you to do.... understanding the description is the hardest part!"
                    },
                    {
                        "username": "saadkhan123456789",
                        "content": "Entropy of the question is way to high......."
                    },
                    {
                        "username": "rishavranjan1821",
                        "content": "You sound like an mechanical engineer"
                    },
                    {
                        "username": "adityaKpatel",
                        "content": "2 months ago, I was not able to understand the language of problem but today I was able  identify the pattern, guess I am improving\\uD83D\\uDE0E"
                    },
                    {
                        "username": "adityaKpatel",
                        "content": "Guess what,  submitted the solution.\\n\\nhttps://leetcode.com/problems/magical-string/solutions/3713545/my-java-solution-easy-to-understand/"
                    },
                    {
                        "username": "kushalnagwanshicloud",
                        "content": "I read this question a month - two months ago, but was not able to do it, or even fully grasp the question, today I did it in mere 10 minutes. \\nI am definitely improving, I guess. "
                    },
                    {
                        "username": "parmarakshat111",
                        "content": "how did you identify the pattern ,please can you share your thought process it would bw a great help."
                    },
                    {
                        "username": "chinmaysk_19",
                        "content": "We can make the string using first three digits only \"122\""
                    },
                    {
                        "username": "Ebad1001",
                        "content": "[@cswartzell](/cswartzell) There are only two magical strings possible, not many"
                    },
                    {
                        "username": "cswartzell",
                        "content": "But there are multiple magic strings possible. This is worded as if its going to give you S but it doesnt. \"22112...\"  could be a valid magical string. So there is NO answer without a defined S"
                    },
                    {
                        "username": "user8228j",
                        "content": "was impossible for me without this tip, and the assumption that there can only be at most two \\'1\\'s or \\'2\\'s in a row.\\nMeaning 122 -> 1 22 -> 1 2 -> 1 22 11 or 1 22 22 has to be 1 22 11."
                    },
                    {
                        "username": "pandeynikhil8",
                        "content": "Identify Pattern and also we need to return number of 1s.\\n\\nhint\\n\\n1,2 used alternatively and repeat frequency is last char in current string"
                    }
                ]
            },
            {
                "id": 2030693,
                "content": [
                    {
                        "username": "godshiva",
                        "content": "I have done 865 problems at the time of writing this comment.  This is, by far, the least comprehensible problem I\\'ve encountered. I LITERALLY have no idea what it is asking me to do."
                    },
                    {
                        "username": "arushadabalar",
                        "content": "[@martynov-94](/martynov-94) Thanks this was actually really helpful in understanding the problem"
                    },
                    {
                        "username": "martynov-94",
                        "content": "You should start with the string \"122\". str[2] === 2, so you append two \"1\" to this string. \\nNow you have string \"12211\". str[3] === 1, so you append one \"2\" to it.\\nYou have \"122112\". str[4] === 1, you append one \"1\".\\nAnd so on, until str.length === n. After this you need to count the number of \"1\" in the string. "
                    },
                    {
                        "username": "xiaoboluo",
                        "content": "Based on the rule, if start with 2, I can get string:\\n2211212212211....\\n\\nCompare with the one in the problem 1**2211212212211**...., it removes the prefix 1.\\n\\nIf that is correct, for some N  like 5, then the answer will be different depending on which one we are referring to."
                    },
                    {
                        "username": "Ebad1001",
                        "content": "I though the same thing. The answers match for n = 6, but not for n = 1.\\nIn that case I guess we need to refer the string given in the problem description (i.e. the one starting with 1)."
                    },
                    {
                        "username": "Jeetaksh",
                        "content": "The problem description can\\'t be any worse."
                    },
                    {
                        "username": "chosen0ne",
                        "content": "S = \\'221121221...\\'\\n22 11 2 1 22 1\\n2 2 1 1 2 1\\n\\n\\n"
                    },
                    {
                        "username": "yeedaKing",
                        "content": "It\\'s not that hard once you actually realize what the prompt is asking you to do.... understanding the description is the hardest part!"
                    },
                    {
                        "username": "saadkhan123456789",
                        "content": "Entropy of the question is way to high......."
                    },
                    {
                        "username": "rishavranjan1821",
                        "content": "You sound like an mechanical engineer"
                    },
                    {
                        "username": "adityaKpatel",
                        "content": "2 months ago, I was not able to understand the language of problem but today I was able  identify the pattern, guess I am improving\\uD83D\\uDE0E"
                    },
                    {
                        "username": "adityaKpatel",
                        "content": "Guess what,  submitted the solution.\\n\\nhttps://leetcode.com/problems/magical-string/solutions/3713545/my-java-solution-easy-to-understand/"
                    },
                    {
                        "username": "kushalnagwanshicloud",
                        "content": "I read this question a month - two months ago, but was not able to do it, or even fully grasp the question, today I did it in mere 10 minutes. \\nI am definitely improving, I guess. "
                    },
                    {
                        "username": "parmarakshat111",
                        "content": "how did you identify the pattern ,please can you share your thought process it would bw a great help."
                    },
                    {
                        "username": "chinmaysk_19",
                        "content": "We can make the string using first three digits only \"122\""
                    },
                    {
                        "username": "Ebad1001",
                        "content": "[@cswartzell](/cswartzell) There are only two magical strings possible, not many"
                    },
                    {
                        "username": "cswartzell",
                        "content": "But there are multiple magic strings possible. This is worded as if its going to give you S but it doesnt. \"22112...\"  could be a valid magical string. So there is NO answer without a defined S"
                    },
                    {
                        "username": "user8228j",
                        "content": "was impossible for me without this tip, and the assumption that there can only be at most two \\'1\\'s or \\'2\\'s in a row.\\nMeaning 122 -> 1 22 -> 1 2 -> 1 22 11 or 1 22 22 has to be 1 22 11."
                    },
                    {
                        "username": "pandeynikhil8",
                        "content": "Identify Pattern and also we need to return number of 1s.\\n\\nhint\\n\\n1,2 used alternatively and repeat frequency is last char in current string"
                    }
                ]
            },
            {
                "id": 1778185,
                "content": [
                    {
                        "username": "godshiva",
                        "content": "I have done 865 problems at the time of writing this comment.  This is, by far, the least comprehensible problem I\\'ve encountered. I LITERALLY have no idea what it is asking me to do."
                    },
                    {
                        "username": "arushadabalar",
                        "content": "[@martynov-94](/martynov-94) Thanks this was actually really helpful in understanding the problem"
                    },
                    {
                        "username": "martynov-94",
                        "content": "You should start with the string \"122\". str[2] === 2, so you append two \"1\" to this string. \\nNow you have string \"12211\". str[3] === 1, so you append one \"2\" to it.\\nYou have \"122112\". str[4] === 1, you append one \"1\".\\nAnd so on, until str.length === n. After this you need to count the number of \"1\" in the string. "
                    },
                    {
                        "username": "xiaoboluo",
                        "content": "Based on the rule, if start with 2, I can get string:\\n2211212212211....\\n\\nCompare with the one in the problem 1**2211212212211**...., it removes the prefix 1.\\n\\nIf that is correct, for some N  like 5, then the answer will be different depending on which one we are referring to."
                    },
                    {
                        "username": "Ebad1001",
                        "content": "I though the same thing. The answers match for n = 6, but not for n = 1.\\nIn that case I guess we need to refer the string given in the problem description (i.e. the one starting with 1)."
                    },
                    {
                        "username": "Jeetaksh",
                        "content": "The problem description can\\'t be any worse."
                    },
                    {
                        "username": "chosen0ne",
                        "content": "S = \\'221121221...\\'\\n22 11 2 1 22 1\\n2 2 1 1 2 1\\n\\n\\n"
                    },
                    {
                        "username": "yeedaKing",
                        "content": "It\\'s not that hard once you actually realize what the prompt is asking you to do.... understanding the description is the hardest part!"
                    },
                    {
                        "username": "saadkhan123456789",
                        "content": "Entropy of the question is way to high......."
                    },
                    {
                        "username": "rishavranjan1821",
                        "content": "You sound like an mechanical engineer"
                    },
                    {
                        "username": "adityaKpatel",
                        "content": "2 months ago, I was not able to understand the language of problem but today I was able  identify the pattern, guess I am improving\\uD83D\\uDE0E"
                    },
                    {
                        "username": "adityaKpatel",
                        "content": "Guess what,  submitted the solution.\\n\\nhttps://leetcode.com/problems/magical-string/solutions/3713545/my-java-solution-easy-to-understand/"
                    },
                    {
                        "username": "kushalnagwanshicloud",
                        "content": "I read this question a month - two months ago, but was not able to do it, or even fully grasp the question, today I did it in mere 10 minutes. \\nI am definitely improving, I guess. "
                    },
                    {
                        "username": "parmarakshat111",
                        "content": "how did you identify the pattern ,please can you share your thought process it would bw a great help."
                    },
                    {
                        "username": "chinmaysk_19",
                        "content": "We can make the string using first three digits only \"122\""
                    },
                    {
                        "username": "Ebad1001",
                        "content": "[@cswartzell](/cswartzell) There are only two magical strings possible, not many"
                    },
                    {
                        "username": "cswartzell",
                        "content": "But there are multiple magic strings possible. This is worded as if its going to give you S but it doesnt. \"22112...\"  could be a valid magical string. So there is NO answer without a defined S"
                    },
                    {
                        "username": "user8228j",
                        "content": "was impossible for me without this tip, and the assumption that there can only be at most two \\'1\\'s or \\'2\\'s in a row.\\nMeaning 122 -> 1 22 -> 1 2 -> 1 22 11 or 1 22 22 has to be 1 22 11."
                    },
                    {
                        "username": "pandeynikhil8",
                        "content": "Identify Pattern and also we need to return number of 1s.\\n\\nhint\\n\\n1,2 used alternatively and repeat frequency is last char in current string"
                    }
                ]
            },
            {
                "id": 1565142,
                "content": [
                    {
                        "username": "godshiva",
                        "content": "I have done 865 problems at the time of writing this comment.  This is, by far, the least comprehensible problem I\\'ve encountered. I LITERALLY have no idea what it is asking me to do."
                    },
                    {
                        "username": "arushadabalar",
                        "content": "[@martynov-94](/martynov-94) Thanks this was actually really helpful in understanding the problem"
                    },
                    {
                        "username": "martynov-94",
                        "content": "You should start with the string \"122\". str[2] === 2, so you append two \"1\" to this string. \\nNow you have string \"12211\". str[3] === 1, so you append one \"2\" to it.\\nYou have \"122112\". str[4] === 1, you append one \"1\".\\nAnd so on, until str.length === n. After this you need to count the number of \"1\" in the string. "
                    },
                    {
                        "username": "xiaoboluo",
                        "content": "Based on the rule, if start with 2, I can get string:\\n2211212212211....\\n\\nCompare with the one in the problem 1**2211212212211**...., it removes the prefix 1.\\n\\nIf that is correct, for some N  like 5, then the answer will be different depending on which one we are referring to."
                    },
                    {
                        "username": "Ebad1001",
                        "content": "I though the same thing. The answers match for n = 6, but not for n = 1.\\nIn that case I guess we need to refer the string given in the problem description (i.e. the one starting with 1)."
                    },
                    {
                        "username": "Jeetaksh",
                        "content": "The problem description can\\'t be any worse."
                    },
                    {
                        "username": "chosen0ne",
                        "content": "S = \\'221121221...\\'\\n22 11 2 1 22 1\\n2 2 1 1 2 1\\n\\n\\n"
                    },
                    {
                        "username": "yeedaKing",
                        "content": "It\\'s not that hard once you actually realize what the prompt is asking you to do.... understanding the description is the hardest part!"
                    },
                    {
                        "username": "saadkhan123456789",
                        "content": "Entropy of the question is way to high......."
                    },
                    {
                        "username": "rishavranjan1821",
                        "content": "You sound like an mechanical engineer"
                    },
                    {
                        "username": "adityaKpatel",
                        "content": "2 months ago, I was not able to understand the language of problem but today I was able  identify the pattern, guess I am improving\\uD83D\\uDE0E"
                    },
                    {
                        "username": "adityaKpatel",
                        "content": "Guess what,  submitted the solution.\\n\\nhttps://leetcode.com/problems/magical-string/solutions/3713545/my-java-solution-easy-to-understand/"
                    },
                    {
                        "username": "kushalnagwanshicloud",
                        "content": "I read this question a month - two months ago, but was not able to do it, or even fully grasp the question, today I did it in mere 10 minutes. \\nI am definitely improving, I guess. "
                    },
                    {
                        "username": "parmarakshat111",
                        "content": "how did you identify the pattern ,please can you share your thought process it would bw a great help."
                    },
                    {
                        "username": "chinmaysk_19",
                        "content": "We can make the string using first three digits only \"122\""
                    },
                    {
                        "username": "Ebad1001",
                        "content": "[@cswartzell](/cswartzell) There are only two magical strings possible, not many"
                    },
                    {
                        "username": "cswartzell",
                        "content": "But there are multiple magic strings possible. This is worded as if its going to give you S but it doesnt. \"22112...\"  could be a valid magical string. So there is NO answer without a defined S"
                    },
                    {
                        "username": "user8228j",
                        "content": "was impossible for me without this tip, and the assumption that there can only be at most two \\'1\\'s or \\'2\\'s in a row.\\nMeaning 122 -> 1 22 -> 1 2 -> 1 22 11 or 1 22 22 has to be 1 22 11."
                    },
                    {
                        "username": "pandeynikhil8",
                        "content": "Identify Pattern and also we need to return number of 1s.\\n\\nhint\\n\\n1,2 used alternatively and repeat frequency is last char in current string"
                    }
                ]
            },
            {
                "id": 1913928,
                "content": [
                    {
                        "username": "godshiva",
                        "content": "I have done 865 problems at the time of writing this comment.  This is, by far, the least comprehensible problem I\\'ve encountered. I LITERALLY have no idea what it is asking me to do."
                    },
                    {
                        "username": "arushadabalar",
                        "content": "[@martynov-94](/martynov-94) Thanks this was actually really helpful in understanding the problem"
                    },
                    {
                        "username": "martynov-94",
                        "content": "You should start with the string \"122\". str[2] === 2, so you append two \"1\" to this string. \\nNow you have string \"12211\". str[3] === 1, so you append one \"2\" to it.\\nYou have \"122112\". str[4] === 1, you append one \"1\".\\nAnd so on, until str.length === n. After this you need to count the number of \"1\" in the string. "
                    },
                    {
                        "username": "xiaoboluo",
                        "content": "Based on the rule, if start with 2, I can get string:\\n2211212212211....\\n\\nCompare with the one in the problem 1**2211212212211**...., it removes the prefix 1.\\n\\nIf that is correct, for some N  like 5, then the answer will be different depending on which one we are referring to."
                    },
                    {
                        "username": "Ebad1001",
                        "content": "I though the same thing. The answers match for n = 6, but not for n = 1.\\nIn that case I guess we need to refer the string given in the problem description (i.e. the one starting with 1)."
                    },
                    {
                        "username": "Jeetaksh",
                        "content": "The problem description can\\'t be any worse."
                    },
                    {
                        "username": "chosen0ne",
                        "content": "S = \\'221121221...\\'\\n22 11 2 1 22 1\\n2 2 1 1 2 1\\n\\n\\n"
                    },
                    {
                        "username": "yeedaKing",
                        "content": "It\\'s not that hard once you actually realize what the prompt is asking you to do.... understanding the description is the hardest part!"
                    },
                    {
                        "username": "saadkhan123456789",
                        "content": "Entropy of the question is way to high......."
                    },
                    {
                        "username": "rishavranjan1821",
                        "content": "You sound like an mechanical engineer"
                    },
                    {
                        "username": "adityaKpatel",
                        "content": "2 months ago, I was not able to understand the language of problem but today I was able  identify the pattern, guess I am improving\\uD83D\\uDE0E"
                    },
                    {
                        "username": "adityaKpatel",
                        "content": "Guess what,  submitted the solution.\\n\\nhttps://leetcode.com/problems/magical-string/solutions/3713545/my-java-solution-easy-to-understand/"
                    },
                    {
                        "username": "kushalnagwanshicloud",
                        "content": "I read this question a month - two months ago, but was not able to do it, or even fully grasp the question, today I did it in mere 10 minutes. \\nI am definitely improving, I guess. "
                    },
                    {
                        "username": "parmarakshat111",
                        "content": "how did you identify the pattern ,please can you share your thought process it would bw a great help."
                    },
                    {
                        "username": "chinmaysk_19",
                        "content": "We can make the string using first three digits only \"122\""
                    },
                    {
                        "username": "Ebad1001",
                        "content": "[@cswartzell](/cswartzell) There are only two magical strings possible, not many"
                    },
                    {
                        "username": "cswartzell",
                        "content": "But there are multiple magic strings possible. This is worded as if its going to give you S but it doesnt. \"22112...\"  could be a valid magical string. So there is NO answer without a defined S"
                    },
                    {
                        "username": "user8228j",
                        "content": "was impossible for me without this tip, and the assumption that there can only be at most two \\'1\\'s or \\'2\\'s in a row.\\nMeaning 122 -> 1 22 -> 1 2 -> 1 22 11 or 1 22 22 has to be 1 22 11."
                    },
                    {
                        "username": "pandeynikhil8",
                        "content": "Identify Pattern and also we need to return number of 1s.\\n\\nhint\\n\\n1,2 used alternatively and repeat frequency is last char in current string"
                    }
                ]
            },
            {
                "id": 1569927,
                "content": [
                    {
                        "username": "godshiva",
                        "content": "I have done 865 problems at the time of writing this comment.  This is, by far, the least comprehensible problem I\\'ve encountered. I LITERALLY have no idea what it is asking me to do."
                    },
                    {
                        "username": "arushadabalar",
                        "content": "[@martynov-94](/martynov-94) Thanks this was actually really helpful in understanding the problem"
                    },
                    {
                        "username": "martynov-94",
                        "content": "You should start with the string \"122\". str[2] === 2, so you append two \"1\" to this string. \\nNow you have string \"12211\". str[3] === 1, so you append one \"2\" to it.\\nYou have \"122112\". str[4] === 1, you append one \"1\".\\nAnd so on, until str.length === n. After this you need to count the number of \"1\" in the string. "
                    },
                    {
                        "username": "xiaoboluo",
                        "content": "Based on the rule, if start with 2, I can get string:\\n2211212212211....\\n\\nCompare with the one in the problem 1**2211212212211**...., it removes the prefix 1.\\n\\nIf that is correct, for some N  like 5, then the answer will be different depending on which one we are referring to."
                    },
                    {
                        "username": "Ebad1001",
                        "content": "I though the same thing. The answers match for n = 6, but not for n = 1.\\nIn that case I guess we need to refer the string given in the problem description (i.e. the one starting with 1)."
                    },
                    {
                        "username": "Jeetaksh",
                        "content": "The problem description can\\'t be any worse."
                    },
                    {
                        "username": "chosen0ne",
                        "content": "S = \\'221121221...\\'\\n22 11 2 1 22 1\\n2 2 1 1 2 1\\n\\n\\n"
                    },
                    {
                        "username": "yeedaKing",
                        "content": "It\\'s not that hard once you actually realize what the prompt is asking you to do.... understanding the description is the hardest part!"
                    },
                    {
                        "username": "saadkhan123456789",
                        "content": "Entropy of the question is way to high......."
                    },
                    {
                        "username": "rishavranjan1821",
                        "content": "You sound like an mechanical engineer"
                    },
                    {
                        "username": "adityaKpatel",
                        "content": "2 months ago, I was not able to understand the language of problem but today I was able  identify the pattern, guess I am improving\\uD83D\\uDE0E"
                    },
                    {
                        "username": "adityaKpatel",
                        "content": "Guess what,  submitted the solution.\\n\\nhttps://leetcode.com/problems/magical-string/solutions/3713545/my-java-solution-easy-to-understand/"
                    },
                    {
                        "username": "kushalnagwanshicloud",
                        "content": "I read this question a month - two months ago, but was not able to do it, or even fully grasp the question, today I did it in mere 10 minutes. \\nI am definitely improving, I guess. "
                    },
                    {
                        "username": "parmarakshat111",
                        "content": "how did you identify the pattern ,please can you share your thought process it would bw a great help."
                    },
                    {
                        "username": "chinmaysk_19",
                        "content": "We can make the string using first three digits only \"122\""
                    },
                    {
                        "username": "Ebad1001",
                        "content": "[@cswartzell](/cswartzell) There are only two magical strings possible, not many"
                    },
                    {
                        "username": "cswartzell",
                        "content": "But there are multiple magic strings possible. This is worded as if its going to give you S but it doesnt. \"22112...\"  could be a valid magical string. So there is NO answer without a defined S"
                    },
                    {
                        "username": "user8228j",
                        "content": "was impossible for me without this tip, and the assumption that there can only be at most two \\'1\\'s or \\'2\\'s in a row.\\nMeaning 122 -> 1 22 -> 1 2 -> 1 22 11 or 1 22 22 has to be 1 22 11."
                    },
                    {
                        "username": "pandeynikhil8",
                        "content": "Identify Pattern and also we need to return number of 1s.\\n\\nhint\\n\\n1,2 used alternatively and repeat frequency is last char in current string"
                    }
                ]
            },
            {
                "id": 1999372,
                "content": [
                    {
                        "username": "godshiva",
                        "content": "I have done 865 problems at the time of writing this comment.  This is, by far, the least comprehensible problem I\\'ve encountered. I LITERALLY have no idea what it is asking me to do."
                    },
                    {
                        "username": "arushadabalar",
                        "content": "[@martynov-94](/martynov-94) Thanks this was actually really helpful in understanding the problem"
                    },
                    {
                        "username": "martynov-94",
                        "content": "You should start with the string \"122\". str[2] === 2, so you append two \"1\" to this string. \\nNow you have string \"12211\". str[3] === 1, so you append one \"2\" to it.\\nYou have \"122112\". str[4] === 1, you append one \"1\".\\nAnd so on, until str.length === n. After this you need to count the number of \"1\" in the string. "
                    },
                    {
                        "username": "xiaoboluo",
                        "content": "Based on the rule, if start with 2, I can get string:\\n2211212212211....\\n\\nCompare with the one in the problem 1**2211212212211**...., it removes the prefix 1.\\n\\nIf that is correct, for some N  like 5, then the answer will be different depending on which one we are referring to."
                    },
                    {
                        "username": "Ebad1001",
                        "content": "I though the same thing. The answers match for n = 6, but not for n = 1.\\nIn that case I guess we need to refer the string given in the problem description (i.e. the one starting with 1)."
                    },
                    {
                        "username": "Jeetaksh",
                        "content": "The problem description can\\'t be any worse."
                    },
                    {
                        "username": "chosen0ne",
                        "content": "S = \\'221121221...\\'\\n22 11 2 1 22 1\\n2 2 1 1 2 1\\n\\n\\n"
                    },
                    {
                        "username": "yeedaKing",
                        "content": "It\\'s not that hard once you actually realize what the prompt is asking you to do.... understanding the description is the hardest part!"
                    },
                    {
                        "username": "saadkhan123456789",
                        "content": "Entropy of the question is way to high......."
                    },
                    {
                        "username": "rishavranjan1821",
                        "content": "You sound like an mechanical engineer"
                    },
                    {
                        "username": "adityaKpatel",
                        "content": "2 months ago, I was not able to understand the language of problem but today I was able  identify the pattern, guess I am improving\\uD83D\\uDE0E"
                    },
                    {
                        "username": "adityaKpatel",
                        "content": "Guess what,  submitted the solution.\\n\\nhttps://leetcode.com/problems/magical-string/solutions/3713545/my-java-solution-easy-to-understand/"
                    },
                    {
                        "username": "kushalnagwanshicloud",
                        "content": "I read this question a month - two months ago, but was not able to do it, or even fully grasp the question, today I did it in mere 10 minutes. \\nI am definitely improving, I guess. "
                    },
                    {
                        "username": "parmarakshat111",
                        "content": "how did you identify the pattern ,please can you share your thought process it would bw a great help."
                    },
                    {
                        "username": "chinmaysk_19",
                        "content": "We can make the string using first three digits only \"122\""
                    },
                    {
                        "username": "Ebad1001",
                        "content": "[@cswartzell](/cswartzell) There are only two magical strings possible, not many"
                    },
                    {
                        "username": "cswartzell",
                        "content": "But there are multiple magic strings possible. This is worded as if its going to give you S but it doesnt. \"22112...\"  could be a valid magical string. So there is NO answer without a defined S"
                    },
                    {
                        "username": "user8228j",
                        "content": "was impossible for me without this tip, and the assumption that there can only be at most two \\'1\\'s or \\'2\\'s in a row.\\nMeaning 122 -> 1 22 -> 1 2 -> 1 22 11 or 1 22 22 has to be 1 22 11."
                    },
                    {
                        "username": "pandeynikhil8",
                        "content": "Identify Pattern and also we need to return number of 1s.\\n\\nhint\\n\\n1,2 used alternatively and repeat frequency is last char in current string"
                    }
                ]
            },
            {
                "id": 1949285,
                "content": [
                    {
                        "username": "godshiva",
                        "content": "I have done 865 problems at the time of writing this comment.  This is, by far, the least comprehensible problem I\\'ve encountered. I LITERALLY have no idea what it is asking me to do."
                    },
                    {
                        "username": "arushadabalar",
                        "content": "[@martynov-94](/martynov-94) Thanks this was actually really helpful in understanding the problem"
                    },
                    {
                        "username": "martynov-94",
                        "content": "You should start with the string \"122\". str[2] === 2, so you append two \"1\" to this string. \\nNow you have string \"12211\". str[3] === 1, so you append one \"2\" to it.\\nYou have \"122112\". str[4] === 1, you append one \"1\".\\nAnd so on, until str.length === n. After this you need to count the number of \"1\" in the string. "
                    },
                    {
                        "username": "xiaoboluo",
                        "content": "Based on the rule, if start with 2, I can get string:\\n2211212212211....\\n\\nCompare with the one in the problem 1**2211212212211**...., it removes the prefix 1.\\n\\nIf that is correct, for some N  like 5, then the answer will be different depending on which one we are referring to."
                    },
                    {
                        "username": "Ebad1001",
                        "content": "I though the same thing. The answers match for n = 6, but not for n = 1.\\nIn that case I guess we need to refer the string given in the problem description (i.e. the one starting with 1)."
                    },
                    {
                        "username": "Jeetaksh",
                        "content": "The problem description can\\'t be any worse."
                    },
                    {
                        "username": "chosen0ne",
                        "content": "S = \\'221121221...\\'\\n22 11 2 1 22 1\\n2 2 1 1 2 1\\n\\n\\n"
                    },
                    {
                        "username": "yeedaKing",
                        "content": "It\\'s not that hard once you actually realize what the prompt is asking you to do.... understanding the description is the hardest part!"
                    },
                    {
                        "username": "saadkhan123456789",
                        "content": "Entropy of the question is way to high......."
                    },
                    {
                        "username": "rishavranjan1821",
                        "content": "You sound like an mechanical engineer"
                    },
                    {
                        "username": "adityaKpatel",
                        "content": "2 months ago, I was not able to understand the language of problem but today I was able  identify the pattern, guess I am improving\\uD83D\\uDE0E"
                    },
                    {
                        "username": "adityaKpatel",
                        "content": "Guess what,  submitted the solution.\\n\\nhttps://leetcode.com/problems/magical-string/solutions/3713545/my-java-solution-easy-to-understand/"
                    },
                    {
                        "username": "kushalnagwanshicloud",
                        "content": "I read this question a month - two months ago, but was not able to do it, or even fully grasp the question, today I did it in mere 10 minutes. \\nI am definitely improving, I guess. "
                    },
                    {
                        "username": "parmarakshat111",
                        "content": "how did you identify the pattern ,please can you share your thought process it would bw a great help."
                    },
                    {
                        "username": "chinmaysk_19",
                        "content": "We can make the string using first three digits only \"122\""
                    },
                    {
                        "username": "Ebad1001",
                        "content": "[@cswartzell](/cswartzell) There are only two magical strings possible, not many"
                    },
                    {
                        "username": "cswartzell",
                        "content": "But there are multiple magic strings possible. This is worded as if its going to give you S but it doesnt. \"22112...\"  could be a valid magical string. So there is NO answer without a defined S"
                    },
                    {
                        "username": "user8228j",
                        "content": "was impossible for me without this tip, and the assumption that there can only be at most two \\'1\\'s or \\'2\\'s in a row.\\nMeaning 122 -> 1 22 -> 1 2 -> 1 22 11 or 1 22 22 has to be 1 22 11."
                    },
                    {
                        "username": "pandeynikhil8",
                        "content": "Identify Pattern and also we need to return number of 1s.\\n\\nhint\\n\\n1,2 used alternatively and repeat frequency is last char in current string"
                    }
                ]
            },
            {
                "id": 1954821,
                "content": [
                    {
                        "username": "godshiva",
                        "content": "I have done 865 problems at the time of writing this comment.  This is, by far, the least comprehensible problem I\\'ve encountered. I LITERALLY have no idea what it is asking me to do."
                    },
                    {
                        "username": "arushadabalar",
                        "content": "[@martynov-94](/martynov-94) Thanks this was actually really helpful in understanding the problem"
                    },
                    {
                        "username": "martynov-94",
                        "content": "You should start with the string \"122\". str[2] === 2, so you append two \"1\" to this string. \\nNow you have string \"12211\". str[3] === 1, so you append one \"2\" to it.\\nYou have \"122112\". str[4] === 1, you append one \"1\".\\nAnd so on, until str.length === n. After this you need to count the number of \"1\" in the string. "
                    },
                    {
                        "username": "xiaoboluo",
                        "content": "Based on the rule, if start with 2, I can get string:\\n2211212212211....\\n\\nCompare with the one in the problem 1**2211212212211**...., it removes the prefix 1.\\n\\nIf that is correct, for some N  like 5, then the answer will be different depending on which one we are referring to."
                    },
                    {
                        "username": "Ebad1001",
                        "content": "I though the same thing. The answers match for n = 6, but not for n = 1.\\nIn that case I guess we need to refer the string given in the problem description (i.e. the one starting with 1)."
                    },
                    {
                        "username": "Jeetaksh",
                        "content": "The problem description can\\'t be any worse."
                    },
                    {
                        "username": "chosen0ne",
                        "content": "S = \\'221121221...\\'\\n22 11 2 1 22 1\\n2 2 1 1 2 1\\n\\n\\n"
                    },
                    {
                        "username": "yeedaKing",
                        "content": "It\\'s not that hard once you actually realize what the prompt is asking you to do.... understanding the description is the hardest part!"
                    },
                    {
                        "username": "saadkhan123456789",
                        "content": "Entropy of the question is way to high......."
                    },
                    {
                        "username": "rishavranjan1821",
                        "content": "You sound like an mechanical engineer"
                    },
                    {
                        "username": "adityaKpatel",
                        "content": "2 months ago, I was not able to understand the language of problem but today I was able  identify the pattern, guess I am improving\\uD83D\\uDE0E"
                    },
                    {
                        "username": "adityaKpatel",
                        "content": "Guess what,  submitted the solution.\\n\\nhttps://leetcode.com/problems/magical-string/solutions/3713545/my-java-solution-easy-to-understand/"
                    },
                    {
                        "username": "kushalnagwanshicloud",
                        "content": "I read this question a month - two months ago, but was not able to do it, or even fully grasp the question, today I did it in mere 10 minutes. \\nI am definitely improving, I guess. "
                    },
                    {
                        "username": "parmarakshat111",
                        "content": "how did you identify the pattern ,please can you share your thought process it would bw a great help."
                    },
                    {
                        "username": "chinmaysk_19",
                        "content": "We can make the string using first three digits only \"122\""
                    },
                    {
                        "username": "Ebad1001",
                        "content": "[@cswartzell](/cswartzell) There are only two magical strings possible, not many"
                    },
                    {
                        "username": "cswartzell",
                        "content": "But there are multiple magic strings possible. This is worded as if its going to give you S but it doesnt. \"22112...\"  could be a valid magical string. So there is NO answer without a defined S"
                    },
                    {
                        "username": "user8228j",
                        "content": "was impossible for me without this tip, and the assumption that there can only be at most two \\'1\\'s or \\'2\\'s in a row.\\nMeaning 122 -> 1 22 -> 1 2 -> 1 22 11 or 1 22 22 has to be 1 22 11."
                    },
                    {
                        "username": "pandeynikhil8",
                        "content": "Identify Pattern and also we need to return number of 1s.\\n\\nhint\\n\\n1,2 used alternatively and repeat frequency is last char in current string"
                    }
                ]
            },
            {
                "id": 1827060,
                "content": [
                    {
                        "username": "godshiva",
                        "content": "I have done 865 problems at the time of writing this comment.  This is, by far, the least comprehensible problem I\\'ve encountered. I LITERALLY have no idea what it is asking me to do."
                    },
                    {
                        "username": "arushadabalar",
                        "content": "[@martynov-94](/martynov-94) Thanks this was actually really helpful in understanding the problem"
                    },
                    {
                        "username": "martynov-94",
                        "content": "You should start with the string \"122\". str[2] === 2, so you append two \"1\" to this string. \\nNow you have string \"12211\". str[3] === 1, so you append one \"2\" to it.\\nYou have \"122112\". str[4] === 1, you append one \"1\".\\nAnd so on, until str.length === n. After this you need to count the number of \"1\" in the string. "
                    },
                    {
                        "username": "xiaoboluo",
                        "content": "Based on the rule, if start with 2, I can get string:\\n2211212212211....\\n\\nCompare with the one in the problem 1**2211212212211**...., it removes the prefix 1.\\n\\nIf that is correct, for some N  like 5, then the answer will be different depending on which one we are referring to."
                    },
                    {
                        "username": "Ebad1001",
                        "content": "I though the same thing. The answers match for n = 6, but not for n = 1.\\nIn that case I guess we need to refer the string given in the problem description (i.e. the one starting with 1)."
                    },
                    {
                        "username": "Jeetaksh",
                        "content": "The problem description can\\'t be any worse."
                    },
                    {
                        "username": "chosen0ne",
                        "content": "S = \\'221121221...\\'\\n22 11 2 1 22 1\\n2 2 1 1 2 1\\n\\n\\n"
                    },
                    {
                        "username": "yeedaKing",
                        "content": "It\\'s not that hard once you actually realize what the prompt is asking you to do.... understanding the description is the hardest part!"
                    },
                    {
                        "username": "saadkhan123456789",
                        "content": "Entropy of the question is way to high......."
                    },
                    {
                        "username": "rishavranjan1821",
                        "content": "You sound like an mechanical engineer"
                    },
                    {
                        "username": "adityaKpatel",
                        "content": "2 months ago, I was not able to understand the language of problem but today I was able  identify the pattern, guess I am improving\\uD83D\\uDE0E"
                    },
                    {
                        "username": "adityaKpatel",
                        "content": "Guess what,  submitted the solution.\\n\\nhttps://leetcode.com/problems/magical-string/solutions/3713545/my-java-solution-easy-to-understand/"
                    },
                    {
                        "username": "kushalnagwanshicloud",
                        "content": "I read this question a month - two months ago, but was not able to do it, or even fully grasp the question, today I did it in mere 10 minutes. \\nI am definitely improving, I guess. "
                    },
                    {
                        "username": "parmarakshat111",
                        "content": "how did you identify the pattern ,please can you share your thought process it would bw a great help."
                    },
                    {
                        "username": "chinmaysk_19",
                        "content": "We can make the string using first three digits only \"122\""
                    },
                    {
                        "username": "Ebad1001",
                        "content": "[@cswartzell](/cswartzell) There are only two magical strings possible, not many"
                    },
                    {
                        "username": "cswartzell",
                        "content": "But there are multiple magic strings possible. This is worded as if its going to give you S but it doesnt. \"22112...\"  could be a valid magical string. So there is NO answer without a defined S"
                    },
                    {
                        "username": "user8228j",
                        "content": "was impossible for me without this tip, and the assumption that there can only be at most two \\'1\\'s or \\'2\\'s in a row.\\nMeaning 122 -> 1 22 -> 1 2 -> 1 22 11 or 1 22 22 has to be 1 22 11."
                    },
                    {
                        "username": "pandeynikhil8",
                        "content": "Identify Pattern and also we need to return number of 1s.\\n\\nhint\\n\\n1,2 used alternatively and repeat frequency is last char in current string"
                    }
                ]
            },
            {
                "id": 1757830,
                "content": [
                    {
                        "username": "godshiva",
                        "content": "I have done 865 problems at the time of writing this comment.  This is, by far, the least comprehensible problem I\\'ve encountered. I LITERALLY have no idea what it is asking me to do."
                    },
                    {
                        "username": "arushadabalar",
                        "content": "[@martynov-94](/martynov-94) Thanks this was actually really helpful in understanding the problem"
                    },
                    {
                        "username": "martynov-94",
                        "content": "You should start with the string \"122\". str[2] === 2, so you append two \"1\" to this string. \\nNow you have string \"12211\". str[3] === 1, so you append one \"2\" to it.\\nYou have \"122112\". str[4] === 1, you append one \"1\".\\nAnd so on, until str.length === n. After this you need to count the number of \"1\" in the string. "
                    },
                    {
                        "username": "xiaoboluo",
                        "content": "Based on the rule, if start with 2, I can get string:\\n2211212212211....\\n\\nCompare with the one in the problem 1**2211212212211**...., it removes the prefix 1.\\n\\nIf that is correct, for some N  like 5, then the answer will be different depending on which one we are referring to."
                    },
                    {
                        "username": "Ebad1001",
                        "content": "I though the same thing. The answers match for n = 6, but not for n = 1.\\nIn that case I guess we need to refer the string given in the problem description (i.e. the one starting with 1)."
                    },
                    {
                        "username": "Jeetaksh",
                        "content": "The problem description can\\'t be any worse."
                    },
                    {
                        "username": "chosen0ne",
                        "content": "S = \\'221121221...\\'\\n22 11 2 1 22 1\\n2 2 1 1 2 1\\n\\n\\n"
                    },
                    {
                        "username": "yeedaKing",
                        "content": "It\\'s not that hard once you actually realize what the prompt is asking you to do.... understanding the description is the hardest part!"
                    },
                    {
                        "username": "saadkhan123456789",
                        "content": "Entropy of the question is way to high......."
                    },
                    {
                        "username": "rishavranjan1821",
                        "content": "You sound like an mechanical engineer"
                    },
                    {
                        "username": "adityaKpatel",
                        "content": "2 months ago, I was not able to understand the language of problem but today I was able  identify the pattern, guess I am improving\\uD83D\\uDE0E"
                    },
                    {
                        "username": "adityaKpatel",
                        "content": "Guess what,  submitted the solution.\\n\\nhttps://leetcode.com/problems/magical-string/solutions/3713545/my-java-solution-easy-to-understand/"
                    },
                    {
                        "username": "kushalnagwanshicloud",
                        "content": "I read this question a month - two months ago, but was not able to do it, or even fully grasp the question, today I did it in mere 10 minutes. \\nI am definitely improving, I guess. "
                    },
                    {
                        "username": "parmarakshat111",
                        "content": "how did you identify the pattern ,please can you share your thought process it would bw a great help."
                    },
                    {
                        "username": "chinmaysk_19",
                        "content": "We can make the string using first three digits only \"122\""
                    },
                    {
                        "username": "Ebad1001",
                        "content": "[@cswartzell](/cswartzell) There are only two magical strings possible, not many"
                    },
                    {
                        "username": "cswartzell",
                        "content": "But there are multiple magic strings possible. This is worded as if its going to give you S but it doesnt. \"22112...\"  could be a valid magical string. So there is NO answer without a defined S"
                    },
                    {
                        "username": "user8228j",
                        "content": "was impossible for me without this tip, and the assumption that there can only be at most two \\'1\\'s or \\'2\\'s in a row.\\nMeaning 122 -> 1 22 -> 1 2 -> 1 22 11 or 1 22 22 has to be 1 22 11."
                    },
                    {
                        "username": "pandeynikhil8",
                        "content": "Identify Pattern and also we need to return number of 1s.\\n\\nhint\\n\\n1,2 used alternatively and repeat frequency is last char in current string"
                    }
                ]
            },
            {
                "id": 2030693,
                "content": [
                    {
                        "username": "godshiva",
                        "content": "I have done 865 problems at the time of writing this comment.  This is, by far, the least comprehensible problem I\\'ve encountered. I LITERALLY have no idea what it is asking me to do."
                    },
                    {
                        "username": "arushadabalar",
                        "content": "[@martynov-94](/martynov-94) Thanks this was actually really helpful in understanding the problem"
                    },
                    {
                        "username": "martynov-94",
                        "content": "You should start with the string \"122\". str[2] === 2, so you append two \"1\" to this string. \\nNow you have string \"12211\". str[3] === 1, so you append one \"2\" to it.\\nYou have \"122112\". str[4] === 1, you append one \"1\".\\nAnd so on, until str.length === n. After this you need to count the number of \"1\" in the string. "
                    },
                    {
                        "username": "xiaoboluo",
                        "content": "Based on the rule, if start with 2, I can get string:\\n2211212212211....\\n\\nCompare with the one in the problem 1**2211212212211**...., it removes the prefix 1.\\n\\nIf that is correct, for some N  like 5, then the answer will be different depending on which one we are referring to."
                    },
                    {
                        "username": "Ebad1001",
                        "content": "I though the same thing. The answers match for n = 6, but not for n = 1.\\nIn that case I guess we need to refer the string given in the problem description (i.e. the one starting with 1)."
                    },
                    {
                        "username": "Jeetaksh",
                        "content": "The problem description can\\'t be any worse."
                    },
                    {
                        "username": "chosen0ne",
                        "content": "S = \\'221121221...\\'\\n22 11 2 1 22 1\\n2 2 1 1 2 1\\n\\n\\n"
                    },
                    {
                        "username": "yeedaKing",
                        "content": "It\\'s not that hard once you actually realize what the prompt is asking you to do.... understanding the description is the hardest part!"
                    },
                    {
                        "username": "saadkhan123456789",
                        "content": "Entropy of the question is way to high......."
                    },
                    {
                        "username": "rishavranjan1821",
                        "content": "You sound like an mechanical engineer"
                    },
                    {
                        "username": "adityaKpatel",
                        "content": "2 months ago, I was not able to understand the language of problem but today I was able  identify the pattern, guess I am improving\\uD83D\\uDE0E"
                    },
                    {
                        "username": "adityaKpatel",
                        "content": "Guess what,  submitted the solution.\\n\\nhttps://leetcode.com/problems/magical-string/solutions/3713545/my-java-solution-easy-to-understand/"
                    },
                    {
                        "username": "kushalnagwanshicloud",
                        "content": "I read this question a month - two months ago, but was not able to do it, or even fully grasp the question, today I did it in mere 10 minutes. \\nI am definitely improving, I guess. "
                    },
                    {
                        "username": "parmarakshat111",
                        "content": "how did you identify the pattern ,please can you share your thought process it would bw a great help."
                    },
                    {
                        "username": "chinmaysk_19",
                        "content": "We can make the string using first three digits only \"122\""
                    },
                    {
                        "username": "Ebad1001",
                        "content": "[@cswartzell](/cswartzell) There are only two magical strings possible, not many"
                    },
                    {
                        "username": "cswartzell",
                        "content": "But there are multiple magic strings possible. This is worded as if its going to give you S but it doesnt. \"22112...\"  could be a valid magical string. So there is NO answer without a defined S"
                    },
                    {
                        "username": "user8228j",
                        "content": "was impossible for me without this tip, and the assumption that there can only be at most two \\'1\\'s or \\'2\\'s in a row.\\nMeaning 122 -> 1 22 -> 1 2 -> 1 22 11 or 1 22 22 has to be 1 22 11."
                    },
                    {
                        "username": "pandeynikhil8",
                        "content": "Identify Pattern and also we need to return number of 1s.\\n\\nhint\\n\\n1,2 used alternatively and repeat frequency is last char in current string"
                    }
                ]
            }
        ]
    }
]